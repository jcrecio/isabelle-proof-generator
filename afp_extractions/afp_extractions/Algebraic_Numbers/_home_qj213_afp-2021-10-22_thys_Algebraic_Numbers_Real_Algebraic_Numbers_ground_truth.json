{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers/Real_Algebraic_Numbers.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers", "problem_names": ["lemma ex1_imp_Collect_singleton: \"(\\<exists>!x. P x) \\<and> P x \\<longleftrightarrow> Collect P = {x}\"", "lemma ex1_Collect_singleton[consumes 2]:\n  assumes \"\\<exists>!x. P x\" and \"P x\" and \"Collect P = {x} \\<Longrightarrow> thesis\" shows thesis", "lemma ex1_iff_Collect_singleton: \"P x \\<Longrightarrow> (\\<exists>!x. P x) \\<longleftrightarrow> Collect P = {x}\"", "lemma bij_imp_ex1_iff: \"(\\<exists>!x. P (f x)) \\<longleftrightarrow> (\\<exists>!y. P y)\" (is \"?l = ?r\")", "lemma bij_ex1_imp_the_shift:\n  assumes ex1: \"\\<exists>!y. P y\" shows \"(THE x. P (f x)) = Hilbert_Choice.inv f (THE y. P y)\" (is \"?l = ?r\")", "lemma bij_imp_Collect_image: \"{x. P (f x)} = Hilbert_Choice.inv f ` {y. P y}\" (is \"?l = ?g ` _\")", "lemma bij_imp_card_image: \"card (f ` X) = card X\"", "lemma bij_imp_card: assumes bij: \"bij f\" shows \"card {x. P (f x)} = card {x. P x}\"", "lemma bij_add: \"bij (\\<lambda>x. x + y :: 'a :: group_add)\" (is ?g1)\n  and bij_minus: \"bij (\\<lambda>x. x - y :: 'a)\" (is ?g2)\n  and inv_add[simp]: \"Hilbert_Choice.inv (\\<lambda>x. x + y) = (\\<lambda>x. x - y)\" (is ?g3)\n  and inv_minus[simp]: \"Hilbert_Choice.inv (\\<lambda>x. x - y) = (\\<lambda>x. x + y)\" (is ?g4)", "lemmas ex1_shift[simp] = bij_imp_ex1_iff[OF bij_add] bij_imp_ex1_iff[OF bij_minus]", "lemma ex1_the_shift:\n  assumes ex1: \"\\<exists>!y :: 'a :: group_add. P y\"\n  shows \"(THE x. P (x + d)) = (THE y. P y) - d\"\n    and \"(THE x. P (x - d)) = (THE y. P y) + d\"", "lemma card_shift_image[simp]:\n  shows \"card ((\\<lambda>x :: 'a :: group_add. x + d) ` X) = card X\"\n    and \"card ((\\<lambda>x. x - d) ` X) = card X\"", "lemma irreducible_root_free:\n  fixes p :: \"'a :: {idom,comm_ring_1} poly\"\n  assumes irr: \"irreducible p\" shows \"root_free p\"", "lemma root_condI[intro]:\n  assumes \"of_rat (rai_lb plr) \\<le> x\" and \"x \\<le> of_rat (rai_ub plr)\" and \"ipoly (poly_real_alg_1 plr) x = 0\"\n  shows \"root_cond plr x\"", "lemma root_condE[elim]:\n  assumes \"root_cond plr x\"\n      and \"of_rat (rai_lb plr) \\<le> x \\<Longrightarrow> x \\<le> of_rat (rai_ub plr) \\<Longrightarrow> ipoly (poly_real_alg_1 plr) x = 0 \\<Longrightarrow> thesis\"\n  shows thesis", "lemma\n  assumes ur: \"unique_root plr\"\n  defines \"x \\<equiv> the_unique_root plr\" and \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  shows unique_rootD: \"of_rat l \\<le> x\" \"x \\<le> of_rat r\" \"ipoly p x = 0\" \"root_cond plr x\"\n        \"x = y \\<longleftrightarrow> root_cond plr y\" \"y = x \\<longleftrightarrow> root_cond plr y\"\n    and the_unique_root_eqI: \"root_cond plr y \\<Longrightarrow> y = x\" \"root_cond plr y \\<Longrightarrow> x = y\"", "lemma unique_rootE:\n  assumes ur: \"unique_root plr\"\n  defines \"x \\<equiv> the_unique_root plr\" and \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  assumes main: \"of_rat l \\<le> x \\<Longrightarrow> x \\<le> of_rat r \\<Longrightarrow> ipoly p x = 0 \\<Longrightarrow> root_cond plr x \\<Longrightarrow>\n        (\\<And>y. x = y \\<longleftrightarrow> root_cond plr y) \\<Longrightarrow> (\\<And>y. y = x \\<longleftrightarrow> root_cond plr y) \\<Longrightarrow> thesis\"\n  shows thesis", "lemma unique_rootI:\n  assumes \"\\<And> y. root_cond plr y \\<Longrightarrow> x = y\" \"root_cond plr x\"\n  shows \"unique_root plr\"", "lemma poly_condI[intro]:\n  assumes \"lead_coeff p > 0\" and \"irreducible p\" shows \"poly_cond p\"", "lemma poly_condD:\n  assumes \"poly_cond p\"\n  shows \"irreducible p\" and \"lead_coeff p > 0\" and \"root_free p\" and \"square_free p\" and \"p \\<noteq> 0\"", "lemma poly_condE[elim]:\n  assumes \"poly_cond p\"\n      and \"irreducible p \\<Longrightarrow> lead_coeff p > 0 \\<Longrightarrow> root_free p \\<Longrightarrow> square_free p \\<Longrightarrow> p \\<noteq> 0 \\<Longrightarrow> thesis\"\n  shows thesis", "lemma invariant_1I:\n  assumes \"unique_root plr\" and \"sgn (rai_lb plr) = sgn (rai_ub plr)\" and \"poly_cond (poly_real_alg_1 plr)\"\n  shows \"invariant_1 plr\"", "lemma\n  assumes \"invariant_1 plr\"\n  defines \"x \\<equiv> the_unique_root plr\" and \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  shows invariant_1D: \"root_cond plr x\"\n    \"sgn l = sgn r\" \"sgn x = of_rat (sgn r)\" \"unique_root plr\" \"poly_cond p\" \"degree p > 0\" \"primitive p\"\n    and invariant_1_root_cond: \"\\<And> y. root_cond plr y \\<longleftrightarrow> y = x\"", "lemma invariant_1E[elim]:\n  assumes \"invariant_1 plr\"\n  defines \"x \\<equiv> the_unique_root plr\" and \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  assumes main: \"root_cond plr x \\<Longrightarrow>\n      sgn l = sgn r \\<Longrightarrow> sgn x = of_rat (sgn r) \\<Longrightarrow> unique_root plr \\<Longrightarrow> poly_cond p \\<Longrightarrow> degree p > 0 \\<Longrightarrow>\n      primitive p \\<Longrightarrow> thesis\"\n  shows thesis", "lemma invariant_1_realI:\n  fixes plr :: real_alg_1\n  defines \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  assumes x: \"root_cond plr x\" and \"sgn l = sgn r\"\n      and ur: \"unique_root plr\"\n      and \"poly_cond p\"\n  shows \"invariant_1 plr \\<and> real_of_1 plr = x\"", "lemma real_of_1_0:\n  assumes \"invariant_1 (p,l,r)\"\n  shows [simp]: \"the_unique_root (p,l,r) = 0 \\<longleftrightarrow> r = 0\"\n    and [dest]: \"l = 0 \\<Longrightarrow> r = 0\"\n    and [intro]: \"r = 0 \\<Longrightarrow> l = 0\"", "lemma invariant_1_pos: assumes rc: \"invariant_1 (p,l,r)\"\n  shows [simp]:\"the_unique_root (p,l,r) > 0 \\<longleftrightarrow> r > 0\" (is \"?x > 0 \\<longleftrightarrow> _\")\n    and [simp]:\"the_unique_root (p,l,r) < 0 \\<longleftrightarrow> r < 0\"\n    and [simp]:\"the_unique_root (p,l,r) \\<le> 0 \\<longleftrightarrow> r \\<le> 0\"\n    and [simp]:\"the_unique_root (p,l,r) \\<ge> 0 \\<longleftrightarrow> r \\<ge> 0\"\n    and [intro]: \"r > 0 \\<Longrightarrow> l > 0\"\n    and [dest]: \"l > 0 \\<Longrightarrow> r > 0\"\n    and [intro]: \"r < 0 \\<Longrightarrow> l < 0\"\n    and [dest]: \"l < 0 \\<Longrightarrow> r < 0\"", "lemma poly_cond2I[intro!]: \"poly_cond p \\<Longrightarrow> degree p > 1 \\<Longrightarrow> poly_cond2 p\"", "lemma poly_cond2D:\n  assumes \"poly_cond2 p\"\n  shows \"poly_cond p\" and \"degree p > 1\"", "lemma poly_cond2E[elim!]:\n  assumes \"poly_cond2 p\" and \"poly_cond p \\<Longrightarrow> degree p > 1 \\<Longrightarrow> thesis\" shows thesis", "lemma invariant_1_2_poly_cond2: \"invariant_1_2 rai \\<Longrightarrow> poly_cond2 (poly_real_alg_1 rai)\"", "lemma invariant_1_2I[intro!]:\n  assumes \"invariant_1 rai\" and \"degree (poly_real_alg_1 rai) > 1\" shows \"invariant_1_2 rai\"", "lemma invariant_1_2E[elim!]:\n  assumes \"invariant_1_2 rai\"\n      and \"invariant_1 rai \\<Longrightarrow> degree (poly_real_alg_1 rai) > 1 \\<Longrightarrow> thesis\"\n  shows thesis", "lemma invariant_1_2_realI:\n  fixes plr :: real_alg_1\n  defines \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  assumes x: \"root_cond plr x\" and sgn: \"sgn l = sgn r\" and ur: \"unique_root plr\" and p: \"poly_cond2 p\"\n  shows \"invariant_1_2 plr \\<and> real_of_1 plr = x\"", "lemma of_rat_2: \"real_of_2 (of_rat_2 x) = of_rat x\" \"invariant_2 (of_rat_2 x)\"", "lemma real_of_inj: \"(real_of x = real_of y) = (x = y)\"", "lemma sgn_1: \"invariant_1 x \\<Longrightarrow> real_of_rat (sgn_1 x) = sgn (real_of_1 x)\"", "lemma sgn_1_inj: \"invariant_1 x \\<Longrightarrow> invariant_1 y \\<Longrightarrow> real_of_1 x = real_of_1 y \\<Longrightarrow> sgn_1 x = sgn_1 y\"", "lemma unique_root_lr: assumes ur: \"unique_root plr\" shows \"rai_lb plr \\<le> rai_ub plr\" (is \"?l \\<le> ?r\")", "lemma ipoly_roots_finite: \"p \\<noteq> 0 \\<Longrightarrow> finite {x :: 'a :: {idom, ring_char_0}. ipoly p x = 0}\"", "lemma roots_below_the_unique_root:\n  assumes ur: \"unique_root (p,l,r)\"\n  shows \"roots_below p (the_unique_root (p,l,r)) = roots_below p (of_rat r)\" (is \"roots_below p ?x = _\")", "lemma unique_root_sub_interval:\n  assumes ur: \"unique_root (p,l,r)\"\n      and rc: \"root_cond (p,l',r') (the_unique_root (p,l,r))\"\n      and between: \"l \\<le> l'\" \"r' \\<le> r\"\n  shows \"unique_root (p,l',r')\"\n    and \"the_unique_root (p,l',r') = the_unique_root (p,l,r)\"", "lemma invariant_1_sub_interval:\n  assumes rc: \"invariant_1 (p,l,r)\"\n      and sub: \"root_cond (p,l',r') (the_unique_root (p,l,r))\"\n      and between: \"l \\<le> l'\" \"r' \\<le> r\"\n  shows \"invariant_1 (p,l',r')\" and \"real_of_1 (p,l',r') = real_of_1 (p,l,r)\"", "lemma root_sign_change: assumes\n    p0: \"poly (p::real poly) x = 0\" and\n    pd_ne0: \"poly (pderiv p) x \\<noteq> 0\"\n  obtains d where\n    \"0 < d\"\n    \"sgn (poly p (x - d)) \\<noteq> sgn (poly p (x + d))\"\n    \"sgn (poly p (x - d)) \\<noteq> 0\"\n    \"0 \\<noteq> sgn (poly p (x + d))\"\n    \"\\<forall> d' > 0. d' \\<le> d \\<longrightarrow> sgn (poly p (x + d')) = sgn (poly p (x + d)) \\<and> sgn (poly p (x - d')) = sgn (poly p (x - d))\"", "lemma rational_root_free_degree_iff: assumes rf: \"root_free (map_poly rat_of_int p)\" and rt: \"ipoly p x = 0\"\n  shows \"(x \\<in> \\<rat>) = (degree p = 1)\"", "lemma rational_poly_cond_iff: assumes \"poly_cond p\" and \"ipoly p x = 0\" and \"degree p > 1\"\n  shows \"(x \\<in> \\<rat>) = (degree p = 1)\"", "lemma poly_cond_degree_gt_1: assumes \"poly_cond p\" \"degree p > 1\" \"ipoly p x = 0\"\n  shows \"x \\<notin> \\<rat>\"", "lemma poly_cond2_no_rat_root: assumes \"poly_cond2 p\" \n  shows \"ipoly p (real_of_rat x) \\<noteq> 0\"", "lemma gt_rat_sign_change:\n  assumes ur: \"unique_root plr\"\n  defines \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  assumes p: \"poly_cond2 p\" and in_interval: \"l \\<le> y\" \"y \\<le> r\"\nshows \"(sgn (ipoly p y) = sgn (ipoly p r)) = (of_rat y > the_unique_root plr)\" (is \"?gt = _\")", "lemma tighten_poly_bounds: assumes res: \"tighten_poly_bounds l r sr = (l',r',sr')\"\n  and ur: \"unique_root (p,l,r)\"\n  and p:  \"poly_cond2 p\"   \n  and sr: \"sr = sgn (ipoly p r)\" \n  shows \"root_cond (p,l',r') (the_unique_root (p,l,r))\" \"l \\<le> l'\" \"l' \\<le> r'\" \"r' \\<le> r\" \n    \"(r' - l') = (r - l) / 2\" \"sr' = sgn (ipoly p r')\"", "lemma tighten_poly_bounds_epsilon:\n  assumes ur: \"unique_root (p,l,r)\"\n  defines u: \"u \\<equiv> the_unique_root (p,l,r)\"\n  assumes p: \"poly_cond2 p\"\n      and res: \"tighten_poly_bounds_epsilon l r sr = (l',r',sr')\"\n      and sr: \"sr = sgn (ipoly p r)\" \n      and x: \"x > 0\"\n  shows \"l \\<le> l'\" \"r' \\<le> r\" \"root_cond (p,l',r') u\" \"r' - l' \\<le> x\" \"sr' = sgn (ipoly p r')\"", "lemma tighten_poly_bounds_for_x:\n  assumes ur: \"unique_root (p,l,r)\"\n  defines u: \"u \\<equiv> the_unique_root (p,l,r)\"\n  assumes p: \"poly_cond2 p\" \n      and res: \"tighten_poly_bounds_for_x l r sr = (l',r',sr')\"\n      and sr: \"sr = sgn (ipoly p r)\" \n  shows \"l \\<le> l'\" \"l' \\<le> r'\" \"r' \\<le> r\" \"root_cond (p,l',r') u\" \"\\<not> (l' \\<le> x \\<and> x \\<le> r')\" \"sr' = sgn (ipoly p r')\" \"unique_root (p,l',r')\"", "lemma real_alg_precision: \"real_alg_precision > 0\"", "lemma root_cond_cong: \"root_cond (p,l,r) = root_cond (q,l,r)\"", "lemma the_unique_root_cong: \n  \"the_unique_root (p,l,r) = the_unique_root (q,l,r)\"", "lemma unique_root_cong: \n  \"unique_root (p,l,r) = unique_root (q,l,r)\"", "lemma normalize_bounds_1_main: assumes eps: \"eps > 0\" and rc: \"invariant_1_2 x\"\n  defines y: \"y \\<equiv> normalize_bounds_1_main eps x\"\n  shows \"invariant_1_2 y \\<and> (real_of_1 y = real_of_1 x)\"", "lemma normalize_bounds_1: assumes x: \"invariant_1_2 x\"\n  shows \"invariant_1_2 (normalize_bounds_1 x) \\<and> (real_of_1 (normalize_bounds_1 x) = real_of_1 x)\"", "lemma normalize_bound_1_poly: \"poly_real_alg_1 (normalize_bounds_1 rai) = poly_real_alg_1 rai\"", "lemma degree_1_ipoly: assumes \"degree p = Suc 0\"\n  shows \"ipoly p x = 0 \\<longleftrightarrow> (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))\"", "lemma invariant_1_degree_0:\n  assumes inv: \"invariant_1 rai\"\n  shows \"degree (poly_real_alg_1 rai) \\<noteq> 0\" (is \"degree ?p \\<noteq> 0\")", "lemma real_alg_2_main:\n  assumes inv: \"invariant_1 rai\"\n  defines [simp]: \"p \\<equiv> poly_real_alg_1 rai\"\n  assumes ric: \"irreducible (poly_real_alg_1 rai) \\<Longrightarrow> root_info_cond ri (poly_real_alg_1 rai)\" \n  shows \"invariant_2 (real_alg_2_main ri rai)\" \"real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\"", "lemma real_alg_2: assumes \"invariant_1 rai\" \n  shows \"invariant_2 (real_alg_2 rai)\" \"real_of_2 (real_alg_2 rai) = real_of_1 rai\"", "lemma invariant_2_realI:\n  fixes plr :: real_alg_1\n  defines \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  assumes x: \"root_cond plr x\" and sgn: \"sgn l = sgn r\"\n      and ur: \"unique_root plr\"\n      and p: \"poly_cond p\"\n  shows \"invariant_2 (real_alg_2 plr) \\<and> real_of_2 (real_alg_2 plr) = x\"", "lemma compare_rat_1: assumes rai: \"invariant_1_2 y\" \n  shows \"compare_rat_1 x y = compare (of_rat x) (real_of_1 y)\"", "lemma cf_pos_0[simp]: \"\\<not> cf_pos 0\"", "lemma uminus_1: assumes x: \"invariant_1 x\"\n  defines y: \"y \\<equiv> uminus_1 x\"\n  shows \"invariant_1 y \\<and> (real_of_1 y = - real_of_1 x)\"", "lemma uminus_1_2:\n  assumes x: \"invariant_1_2 x\"\n  defines y: \"y \\<equiv> uminus_1 x\"\n  shows \"invariant_1_2 y \\<and> (real_of_1 y = - real_of_1 x)\"", "lemma uminus_2: assumes \"invariant_2 x\" \n  shows \"real_of_2 (uminus_2 x) = uminus (real_of_2 x)\"\n  \"invariant_2 (uminus_2 x)\"", "lemma uminus_3: \"real_of_3 (uminus_3 x) = - real_of_3 x\"", "lemma uminus_real_alg: \"- (real_of x) = real_of (- x)\"", "lemma invariant_1_2_of_rat: assumes rc: \"invariant_1_2 rai\" \n  shows \"real_of_1 rai \\<noteq> of_rat x\"", "lemma inverse_1:\n  assumes rcx: \"invariant_1_2 x\"\n  defines y: \"y \\<equiv> inverse_1 x\"\n  shows \"invariant_2 y \\<and> (real_of_2 y = inverse (real_of_1 x))\"", "lemma inverse_2: assumes \"invariant_2 x\"\n  shows \"real_of_2 (inverse_2 x) = inverse (real_of_2 x)\"\n  \"invariant_2 (inverse_2 x)\"", "lemma inverse_3: \"real_of_3 (inverse_3 x) = inverse (real_of_3 x)\"", "lemma floor_1: assumes \"invariant_1_2 x\"\n  shows \"floor (real_of_1 x) = floor_1 x\"", "lemma card_1_Collect_ex1: assumes \"card (Collect P) = 1\"\n  shows \"\\<exists>! x. P x\"", "lemma select_correct_factor_main: assumes conv: \"converges_to f x\"\n  and at: \"at_step f i a\"\n  and res: \"select_correct_factor_main a todo old l r n = ((q,ri_fin),(l_fin,r_fin))\"\n  and bnd: \"bnd_get a = (l,r)\"\n  and ri: \"\\<And> q ri. (q,ri) \\<in> set todo \\<union> set old \\<Longrightarrow> root_info_cond ri q\"\n  and q0: \"\\<And> q ri. (q,ri) \\<in> set todo \\<union> set old \\<Longrightarrow> q \\<noteq> 0\"\n  and ex: \"\\<exists>q. q \\<in> fst ` set todo \\<union> fst ` set old \\<and> ipoly q x = 0\"\n  and dist: \"distinct (map fst (todo @ old))\"\n  and old: \"\\<And> q ri. (q,ri) \\<in> set old \\<Longrightarrow> root_info.l_r ri l r \\<noteq> 0\"\n  and un: \"\\<And> x :: real. (\\<exists>q. q \\<in> fst ` set todo \\<union> fst ` set old \\<and> ipoly q x = 0) \\<Longrightarrow> \n    \\<exists>!q. q \\<in> fst ` set todo \\<union> fst ` set old \\<and> ipoly q x = 0\"\n  and n: \"n = sum_list (map (\\<lambda> (q,ri). root_info.l_r ri l r) old)\"\n  shows \"unique_root (q,l_fin,r_fin) \\<and> (q,ri_fin) \\<in> set todo \\<union> set old \\<and> x = the_unique_root (q,l_fin,r_fin)\"", "lemma select_correct_factor: assumes \n      conv: \"converges_to (\\<lambda> i. bnd_get ((bnd_update ^^ i) init)) x\"\n  and res: \"select_correct_factor init polys = ((q,ri),(l,r))\"\n  and ri: \"\\<And> q ri. (q,ri) \\<in> set polys \\<Longrightarrow> root_info_cond ri q\"\n  and q0: \"\\<And> q ri. (q,ri) \\<in> set polys \\<Longrightarrow> q \\<noteq> 0\"\n  and ex: \"\\<exists>q. q \\<in> fst ` set polys \\<and> ipoly q x = 0\"\n  and dist: \"distinct (map fst polys)\"\n  and un: \"\\<And> x :: real. (\\<exists>q. q \\<in> fst ` set polys \\<and> ipoly q x = 0) \\<Longrightarrow> \n    \\<exists>!q. q \\<in> fst ` set polys \\<and> ipoly q x = 0\"\n  shows \"unique_root (q,l,r) \\<and> (q,ri) \\<in> set polys \\<and> x = the_unique_root (q,l,r)\"", "lemma real_alg_2'_code[code]: \"real_alg_2' ri p l r =\n (if degree p = 1 then Rational (Rat.Fract (- coeff p 0) (coeff p 1))\n     else case normalize_bounds_1\n        (case tighten_poly_bounds_for_x p 0 l r (sgn (ipoly p r)) of (l', r', sr') \\<Rightarrow> (p, l', r')) \n     of (p', l, r) \\<Rightarrow> Irrational (root_info.number_root ri r) (p', l, r))\"", "lemma real_alg_2'': \"degree p \\<noteq> 1 \\<Longrightarrow> real_alg_2'' ri p l r = real_alg_2' ri p l r\"", "lemma poly_cond_degree_0_imp_no_root:\n  fixes x :: \"'b :: {comm_ring_1,ring_char_0}\"\n  assumes pc: \"poly_cond p\" and deg: \"degree p = 0\" shows \"ipoly p x \\<noteq> 0\"", "lemma real_alg_2':\n  assumes ur: \"unique_root (q,l,r)\" and pc: \"poly_cond q\" and ri: \"root_info_cond ri q\"\n  shows \"invariant_2 (real_alg_2' ri q l r) \\<and> real_of_2 (real_alg_2' ri q l r) = the_unique_root (q,l,r)\" (is \"_ \\<and> _ = ?x\")", "lemma select_correct_factor_int_poly: assumes \n      conv: \"converges_to (\\<lambda> i. bnd_get ((bnd_update ^^ i) init)) x\"\n  and rai: \"select_correct_factor_int_poly init p = rai\"\n  and x: \"ipoly p x = 0\"\n  and p: \"p \\<noteq> 0\"\n  shows \"invariant_2 rai \\<and> real_of_2 rai = x\"", "lemma ipoly_0_0[simp]: \"ipoly f (0::'a::{comm_ring_1,ring_char_0}) = 0 \\<longleftrightarrow> poly f 0 = 0\"", "lemma add_rat_roots_below[simp]: \"roots_below (poly_add_rat r p) x = (\\<lambda>y. y + of_rat r) ` roots_below p (x - of_rat r)\"", "lemma add_rat_root_cond:\n  shows \"root_cond (cf_pos_poly (poly_add_rat m p),l,r) x = root_cond (p, l - m, r - m) (x - of_rat m)\"", "lemma add_rat_unique_root: \"unique_root (cf_pos_poly (poly_add_rat m p), l, r) = unique_root (p, l-m, r-m)\"", "lemma poly_real_alg_1_add_rat[simp]:\n  \"poly_real_alg_1 (add_rat_1 r y) = cf_pos_poly (poly_add_rat r (poly_real_alg_1 y))\"", "lemma sgn_cf_pos:\n  assumes \"lead_coeff p > 0\" shows \"sgn (ipoly (cf_pos_poly p) (x::'a::linordered_field)) = sgn (ipoly p x)\"", "lemma add_rat_1: fixes r1 :: rat assumes inv_y: \"invariant_1_2 y\"\n  defines \"z \\<equiv> add_rat_1 r1 y\"\n  shows \"invariant_1_2 z \\<and> (real_of_1 z = of_rat r1 + real_of_1 y)\"", "lemma tighten_poly_bounds_binary:\n  assumes ur: \"unique_root (p1,l1,r1)\" \"unique_root (p2,l2,r2)\" and pt: \"poly_cond2 p1\" \"poly_cond2 p2\" \n  defines \"x \\<equiv> the_unique_root (p1,l1,r1)\" and \"y \\<equiv> the_unique_root (p2,l2,r2)\"\n  assumes bnd: \"\\<And> l1 r1 l2 r2 l r sr1 sr2. I l1 \\<Longrightarrow> I l2 \\<Longrightarrow> root_cond (p1,l1,r1) x \\<Longrightarrow> root_cond (p2,l2,r2) y \\<Longrightarrow>\n      bnd ((l1,r1,sr1),(l2,r2,sr2)) = (l,r) \\<Longrightarrow> of_rat l \\<le> f x y \\<and> f x y \\<le> of_rat r\"\n  and approx: \"\\<And> l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'. \n    I l1 \\<Longrightarrow> I l2 \\<Longrightarrow>\n    l1 \\<le> r1 \\<Longrightarrow> l2 \\<le> r2 \\<Longrightarrow> \n    (l,r) = bnd ((l1,r1,sr1), (l2,r2,sr2)) \\<Longrightarrow>\n    (l',r') = bnd ((l1',r1',sr1'), (l2',r2',sr2')) \\<Longrightarrow>\n    (l1',r1') \\<in> {(l1,(l1+r1)/2),((l1+r1)/2,r1)} \\<Longrightarrow>\n    (l2',r2') \\<in> {(l2,(l2+r2)/2),((l2+r2)/2,r2)} \\<Longrightarrow>\n    (r' - l') \\<le> 3/4 * (r - l) \\<and> l \\<le> l' \\<and> r' \\<le> r\"\n  and I_mono: \"\\<And> l l'. I l \\<Longrightarrow> l \\<le> l' \\<Longrightarrow> I l'\"\n  and I: \"I l1\" \"I l2\" \n  and sr: \"sr1 = sgn (ipoly p1 r1)\" \"sr2 = sgn (ipoly p2 r2)\"\n  shows \"converges_to (\\<lambda> i. bnd ((tighten_poly_bounds_binary p1 p2 ^^ i) ((l1,r1,sr1),(l2,r2,sr2))))\n     (f x y)\"", "lemma add_1:\n  assumes x: \"invariant_1_2 x\" and y: \"invariant_1_2 y\"\n  defines z: \"z \\<equiv> add_1 x y\"\n  shows \"invariant_2 z \\<and> (real_of_2 z = real_of_1 x + real_of_1 y)\"", "lemma mult_rat_1_pos: fixes r1 :: rat assumes r1: \"r1 > 0\" and y: \"invariant_1 y\"\n  defines z: \"z \\<equiv> mult_rat_1_pos r1 y\"\n  shows \"invariant_2 z \\<and> (real_of_2 z = of_rat r1 * real_of_1 y)\"", "lemma mult_1_pos: assumes x: \"invariant_1_2 x\" and y: \"invariant_1_2 y\"\n  defines z: \"z \\<equiv> mult_1_pos x y\"\n  assumes pos: \"real_of_1 x > 0\" \"real_of_1 y > 0\"\n  shows \"invariant_2 z \\<and> (real_of_2 z = real_of_1 x * real_of_1 y)\"", "lemma mult_1: assumes x: \"invariant_1_2 x\" and y: \"invariant_1_2 y\"\n  defines z[simp]: \"z \\<equiv> mult_1 x y\"\n  shows \"invariant_2 z \\<and> (real_of_2 z = real_of_1 x * real_of_1 y)\"", "lemma mult_rat_1: fixes x assumes y: \"invariant_1 y\"  \n  defines z: \"z \\<equiv> mult_rat_1 x y\"\n  shows \"invariant_2 z \\<and> (real_of_2 z = of_rat x * real_of_1 y)\"", "lemma ipoly_root_delta: assumes \"p \\<noteq> 0\"\n  shows \"ipoly_root_delta p > 0\"\n    \"2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow> ipoly_root_delta p \\<le> real_of_rat (r - l) / 4\"", "lemma sgn_less_eq_1_rat: fixes a b :: rat\n  shows \"sgn a = 1 \\<Longrightarrow> a \\<le> b \\<Longrightarrow> sgn b = 1\"", "lemma sgn_less_eq_1_real: fixes a b :: real\n  shows \"sgn a = 1 \\<Longrightarrow> a \\<le> b \\<Longrightarrow> sgn b = 1\"", "lemma compare_real_of_rat: \"compare (real_of_rat x) (of_rat y) = compare x y\"", "lemma compare_1_rat: assumes rc: \"invariant_1 y\"\n  shows \"compare_1_rat y x = compare (of_rat x) (real_of_1 y)\"", "lemma tighten_bound_root: assumes sgn: \"sgn il = 1\" \"real_of_1 x \\<ge> 0\" and\n  il: \"real_of_rat il \\<le> root n (real_of_1 x)\" and \n  ir: \"root n (real_of_1 x) \\<le> real_of_rat ir\" and\n  rai: \"invariant_1 x\" and\n  cmpx: \"cmpx = compare_1_rat x\" and\n  n: \"n \\<noteq> 0\" \nshows \"converges_to (\\<lambda> i. (tighten_bound_root ^^ i) (il, ir))\n     (root n (real_of_1 x))\" (is \"converges_to ?f ?x\")", "lemma initial_upper_bound: assumes x: \"x > 0\" and xr: \"x \\<le> of_rat r\"\n  shows \"sgn (initial_upper_bound r) = 1\" \"root n x \\<le> of_rat (initial_upper_bound r)\"", "lemma initial_lower_bound: assumes l: \"l > 0\" and lx: \"of_rat l \\<le> x\"\n  shows \"sgn (initial_lower_bound l) = 1\" \"of_rat (initial_lower_bound l) \\<le> root n x\"", "lemma root_pos_1:\n  assumes x: \"invariant_1 x\" and pos: \"rai_ub x > 0\"\n  defines y: \"y \\<equiv> root_pos_1 x\"\n  shows \"invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\"", "lemma root_1: assumes x: \"invariant_1 x\"\n  defines y: \"y \\<equiv> root_1 x\"\n  shows \"invariant_2 y \\<and> (real_of_2 y = root n (real_of_1 x))\"", "lemma of_rat_1:\n  shows \"invariant_1 (of_rat_1 x)\" and \"real_of_1 (of_rat_1 x) = of_rat x\"", "lemma info_2_card: assumes rc: \"invariant_2 x\"\n  shows \"info_2 x = Inr (p,n) \\<Longrightarrow> poly_cond p \\<and> ipoly p (real_of_2 x) = 0 \\<and> degree p \\<ge> 2 \n    \\<and> card (roots_below p (real_of_2 x)) = n\"\n    \"info_2 x = Inl y \\<Longrightarrow> real_of_2 x = of_rat y\"", "lemma real_of_2_Irrational: \"invariant_2 (Irrational n rai) \\<Longrightarrow> real_of_2 (Irrational n rai) \\<noteq> of_rat x\"", "lemma info_2: assumes \n    ix: \"invariant_2 x\" and iy: \"invariant_2 y\"\n  shows \"info_2 x = info_2 y \\<longleftrightarrow> real_of_2 x = real_of_2 y\"", "lemma info_2_unique: \"invariant_2 x \\<Longrightarrow> invariant_2 y \\<Longrightarrow> \n  real_of_2 x = real_of_2 y \\<Longrightarrow> info_2 x = info_2 y\"", "lemma info_2_inj: \"invariant_2 x \\<Longrightarrow> invariant_2 y \\<Longrightarrow> info_2 x = info_2 y \\<Longrightarrow>\n  real_of_2 x = real_of_2 y\"", "lemma compare_1:\n  assumes ur1: \"unique_root (p1,l1,r1)\"\n  and ur2: \"unique_root (p2,l2,r2)\"\n  and pc: \"poly_cond2 p1\" \"poly_cond2 p2\"\n  and diff: \"the_unique_root (p1,l1,r1) \\<noteq> the_unique_root (p2,l2,r2)\"\n  and sr: \"sr1 = sgn (ipoly p1 r1)\" \"sr2 = sgn (ipoly p2 r2)\" \n shows \"compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare (the_unique_root (p1,l1,r1)) (the_unique_root (p2,l2,r2))\"", "lemma real_alg_1: \"real_of_1 (real_alg_1 x) = real_of_2 x\"", "lemma root_2: assumes \"invariant_2 x\"\n  shows \"real_of_2 (root_2 n x) = root n (real_of_2 x)\"\n  \"invariant_2 (root_2 n x)\"", "lemma add_2: assumes x: \"invariant_2 x\" and y: \"invariant_2 y\" \n  shows \"invariant_2 (add_2 x y)\" (is ?g1)\n    and \"real_of_2 (add_2 x y) = real_of_2 x + real_of_2 y\" (is ?g2)", "lemma mult_2: assumes \"invariant_2 x\" \"invariant_2 y\"\n  shows \"real_of_2 (mult_2 x y) = real_of_2 x * real_of_2 y\"\n  \"invariant_2 (mult_2 x y)\"", "lemma to_rat_2: assumes rc: \"invariant_2 x\" \n  shows \"to_rat_2 x = (if real_of_2 x \\<in> \\<rat> then Some (THE q. real_of_2 x = of_rat q) else None)\"", "lemma equal_2[simp]: assumes rc: \"invariant_2 x\" \"invariant_2 y\" \n  shows \"equal_2 x y = (real_of_2 x = real_of_2 y)\"", "lemma compare_2: assumes rc: \"invariant_2 x\" \"invariant_2 y\"\n  shows \"compare_2 x y = compare (real_of_2 x) (real_of_2 y)\"", "lemma sgn_2: \"invariant_2 x \\<Longrightarrow> real_of_rat (sgn_2 x) = sgn (real_of_2 x)\"", "lemma floor_2: \"invariant_2 x \\<Longrightarrow> floor_2 x = floor (real_of_2 x)\"", "lemma of_rat_3: \"real_of_3 (of_rat_3 x) = of_rat x\"", "lemma root_3: \"real_of_3 (root_3 n x) = root n (real_of_3 x)\"", "lemma equal_3: \"equal_3 x y = (real_of_3 x = real_of_3 y)\"", "lemma compare_3: \"compare_3 x y = (compare (real_of_3 x) (real_of_3 y))\"", "lemma add_3: \"real_of_3 (add_3 x y) = real_of_3 x + real_of_3 y\"", "lemma mult_3: \"real_of_3 (mult_3 x y) = real_of_3 x * real_of_3 y\"", "lemma sgn_3: \"real_of_rat (sgn_3 x) = sgn (real_of_3 x)\"", "lemma to_rat_3: \"to_rat_3 x = \n  (if real_of_3 x \\<in> \\<rat> then Some (THE q. real_of_3 x = of_rat q) else None)\"", "lemma floor_3: \"floor_3 x = floor (real_of_3 x)\"", "lemma info_3_fun: \"real_of_3 x = real_of_3 y \\<Longrightarrow> info_3 x = info_3 y\"", "lemma info_real_alg: \n  \"info_real_alg x = Inr (p,n) \\<Longrightarrow> p represents (real_of x) \\<and> card {y. y \\<le> real_of x \\<and> ipoly p y = 0} = n \\<and> irreducible p\" \n  \"info_real_alg x = Inl q \\<Longrightarrow> real_of x = of_rat q\"", "lemma plus_real_alg: \"(real_of x) + (real_of y) = real_of (x + y)\"", "lemma minus_real_alg: \"(real_of x) - (real_of y) = real_of (x - y)\"", "lemma of_rat_real_alg: \"real_of_rat x = real_of (of_rat_real_alg x)\"", "lemma zero_real_alg: \"0 = real_of 0\"", "lemma one_real_alg: \"1 = real_of 1\"", "lemma times_real_alg: \"(real_of x) * (real_of y) = real_of (x * y)\"", "lemma inverse_real_alg: \"inverse (real_of x) = real_of (inverse x)\"", "lemma divide_real_alg: \"(real_of x) / (real_of y) = real_of (x / y)\"", "lemma root_real_alg: \"root n (real_of x) = real_of (root_real_alg n x)\"", "lemma sgn_real_alg_rat: \"real_of_rat (sgn_real_alg_rat x) = sgn (real_of x)\"", "lemma sgn_real_alg: \"sgn (real_of x) = real_of (sgn x)\"", "lemma equal_real_alg: \"HOL.equal (real_of x) (real_of y) = (x = y)\"", "lemma less_real_alg: \"less (real_of x) (real_of y) = (x < y)\"", "lemma less_eq_real_alg: \"less_eq (real_of x) (real_of y) = (x \\<le> y)\"", "lemma compare_real_alg: \"compare (real_of x) (real_of y) = (compare x y)\"", "lemma less_eq_real_alg_code[code]: \n  \"(less_eq :: real_alg \\<Rightarrow> real_alg \\<Rightarrow> bool) = le_of_comp compare\"\n  \"(less :: real_alg \\<Rightarrow> real_alg \\<Rightarrow> bool) = lt_of_comp compare\"", "lemma abs_real_alg: \"abs (real_of x) = real_of (abs x)\"", "lemma sgn_real_alg_sound: \"sgn x = (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)\"\n  (is \"_ = ?r\")", "lemma real_of_of_int: \"real_of_rat (rat_of_int z) = real_of (of_int z)\"", "lemma floor_real_alg: \"floor (real_of x) = floor x\"", "lemma real_alg_of_real_code[code]: \"real_alg_of_real (real_of x) = x\"", "lemma to_rat_real_alg_main: \"to_rat_real_alg_main x = (if real_of x \\<in> \\<rat> then \n  Some (THE q. real_of x = of_rat q) else None)\"", "lemma is_rat_real_alg: \"is_rat (real_of x) = (is_rat_real_alg x)\"", "lemma to_rat_real_alg: \"to_rat (real_of x) = (to_rat_real_alg x)\"", "lemmas real_alg_code_eqns =  \n  one_real_alg\n  zero_real_alg\n  uminus_real_alg\n  root_real_alg\n  minus_real_alg\n  plus_real_alg\n  times_real_alg\n  inverse_real_alg\n  divide_real_alg\n  equal_real_alg\n  less_real_alg\n  less_eq_real_alg\n  compare_real_alg\n  sgn_real_alg\n  abs_real_alg\n  floor_real_alg\n  is_rat_real_alg\n  to_rat_real_alg", "lemma Ratreal_code[code]:\n  \"Ratreal = real_of \\<circ> of_rat_real_alg\"", "lemma real_of_post[code_post]: \"real_of (Real_Alg_Quotient (Real_Alg_Invariant (Rational x))) = of_rat x\""], "translations": [["", "lemma ex1_imp_Collect_singleton: \"(\\<exists>!x. P x) \\<and> P x \\<longleftrightarrow> Collect P = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>!x. P x) \\<and> P x) = (Collect P = {x})", "proof(intro iffI conjI, unfold conj_imp_eq_imp_imp)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>Ex1 P; P x\\<rbrakk> \\<Longrightarrow> Collect P = {x}\n 2. Collect P = {x} \\<Longrightarrow> \\<exists>!x. P x\n 3. Collect P = {x} \\<Longrightarrow> P x", "assume \"Ex1 P\" \"P x\""], ["proof (state)\nthis:\n  Ex1 P\n  P x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Ex1 P; P x\\<rbrakk> \\<Longrightarrow> Collect P = {x}\n 2. Collect P = {x} \\<Longrightarrow> \\<exists>!x. P x\n 3. Collect P = {x} \\<Longrightarrow> P x", "then"], ["proof (chain)\npicking this:\n  Ex1 P\n  P x", "show \"Collect P = {x}\""], ["proof (prove)\nusing this:\n  Ex1 P\n  P x\n\ngoal (1 subgoal):\n 1. Collect P = {x}", "by blast"], ["proof (state)\nthis:\n  Collect P = {x}\n\ngoal (2 subgoals):\n 1. Collect P = {x} \\<Longrightarrow> \\<exists>!x. P x\n 2. Collect P = {x} \\<Longrightarrow> P x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. Collect P = {x} \\<Longrightarrow> \\<exists>!x. P x\n 2. Collect P = {x} \\<Longrightarrow> P x", "assume Px: \"Collect P = {x}\""], ["proof (state)\nthis:\n  Collect P = {x}\n\ngoal (2 subgoals):\n 1. Collect P = {x} \\<Longrightarrow> \\<exists>!x. P x\n 2. Collect P = {x} \\<Longrightarrow> P x", "then"], ["proof (chain)\npicking this:\n  Collect P = {x}", "have \"P y \\<longleftrightarrow> x = y\" for y"], ["proof (prove)\nusing this:\n  Collect P = {x}\n\ngoal (1 subgoal):\n 1. P y = (x = y)", "by auto"], ["proof (state)\nthis:\n  P ?y = (x = ?y)\n\ngoal (2 subgoals):\n 1. Collect P = {x} \\<Longrightarrow> \\<exists>!x. P x\n 2. Collect P = {x} \\<Longrightarrow> P x", "then"], ["proof (chain)\npicking this:\n  P ?y = (x = ?y)", "show \"Ex1 P\""], ["proof (prove)\nusing this:\n  P ?y = (x = ?y)\n\ngoal (1 subgoal):\n 1. Ex1 P", "by auto"], ["proof (state)\nthis:\n  Ex1 P\n\ngoal (1 subgoal):\n 1. Collect P = {x} \\<Longrightarrow> P x", "from Px"], ["proof (chain)\npicking this:\n  Collect P = {x}", "show \"P x\""], ["proof (prove)\nusing this:\n  Collect P = {x}\n\ngoal (1 subgoal):\n 1. P x", "by auto"], ["proof (state)\nthis:\n  P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex1_Collect_singleton[consumes 2]:\n  assumes \"\\<exists>!x. P x\" and \"P x\" and \"Collect P = {x} \\<Longrightarrow> thesis\" shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by (rule assms(3), subst ex1_imp_Collect_singleton[symmetric], insert assms(1,2), auto)"], ["", "lemma ex1_iff_Collect_singleton: \"P x \\<Longrightarrow> (\\<exists>!x. P x) \\<longleftrightarrow> Collect P = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x \\<Longrightarrow> (\\<exists>!x. P x) = (Collect P = {x})", "by (subst ex1_imp_Collect_singleton[symmetric], auto)"], ["", "context\n  fixes f\n  assumes bij: \"bij f\"\nbegin"], ["", "lemma bij_imp_ex1_iff: \"(\\<exists>!x. P (f x)) \\<longleftrightarrow> (\\<exists>!y. P y)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!x. P (f x)) = (\\<exists>!y. P y)", "proof (intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y\n 2. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "assume l: ?l"], ["proof (state)\nthis:\n  \\<exists>!x. P (f x)\n\ngoal (2 subgoals):\n 1. \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y\n 2. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>!x. P (f x)", "obtain x where \"P (f x)\""], ["proof (prove)\nusing this:\n  \\<exists>!x. P (f x)\n\ngoal (1 subgoal):\n 1. (\\<And>x. P (f x) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  P (f x)\n\ngoal (2 subgoals):\n 1. \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y\n 2. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "with l"], ["proof (chain)\npicking this:\n  \\<exists>!x. P (f x)\n  P (f x)", "have *: \"{x} = Collect (P o f)\""], ["proof (prove)\nusing this:\n  \\<exists>!x. P (f x)\n  P (f x)\n\ngoal (1 subgoal):\n 1. {x} = Collect (P \\<circ> f)", "by auto"], ["proof (state)\nthis:\n  {x} = Collect (P \\<circ> f)\n\ngoal (2 subgoals):\n 1. \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y\n 2. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "also"], ["proof (state)\nthis:\n  {x} = Collect (P \\<circ> f)\n\ngoal (2 subgoals):\n 1. \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y\n 2. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "have \"f ` \\<dots> = {y. P (f (Hilbert_Choice.inv f y))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` Collect (P \\<circ> f) = {y. P (f (inv f y))}", "using bij_image_Collect_eq[OF bij]"], ["proof (prove)\nusing this:\n  f ` Collect ?P = {y. ?P (inv f y)}\n\ngoal (1 subgoal):\n 1. f ` Collect (P \\<circ> f) = {y. P (f (inv f y))}", "by auto"], ["proof (state)\nthis:\n  f ` Collect (P \\<circ> f) = {y. P (f (inv f y))}\n\ngoal (2 subgoals):\n 1. \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y\n 2. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "also"], ["proof (state)\nthis:\n  f ` Collect (P \\<circ> f) = {y. P (f (inv f y))}\n\ngoal (2 subgoals):\n 1. \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y\n 2. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "have \"\\<dots> = {y. P y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. P (f (inv f y))} = {y. P y}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. {y. P (f (inv f y))} = {y. P y}", "have \"f (Hilbert_Choice.inv f y) = y\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (inv f y) = y", "by (meson bij bij_inv_eq_iff)"], ["proof (state)\nthis:\n  f (inv f ?y) = ?y\n\ngoal (1 subgoal):\n 1. {y. P (f (inv f y))} = {y. P y}", "then"], ["proof (chain)\npicking this:\n  f (inv f ?y) = ?y", "show ?thesis"], ["proof (prove)\nusing this:\n  f (inv f ?y) = ?y\n\ngoal (1 subgoal):\n 1. {y. P (f (inv f y))} = {y. P y}", "by simp"], ["proof (state)\nthis:\n  {y. P (f (inv f y))} = {y. P y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {y. P (f (inv f y))} = {y. P y}\n\ngoal (2 subgoals):\n 1. \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y\n 2. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "finally"], ["proof (chain)\npicking this:\n  f ` {x} = {y. P y}", "have \"Collect P = {f x}\""], ["proof (prove)\nusing this:\n  f ` {x} = {y. P y}\n\ngoal (1 subgoal):\n 1. Collect P = {f x}", "by auto"], ["proof (state)\nthis:\n  Collect P = {f x}\n\ngoal (2 subgoals):\n 1. \\<exists>!x. P (f x) \\<Longrightarrow> \\<exists>!y. P y\n 2. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "then"], ["proof (chain)\npicking this:\n  Collect P = {f x}", "show ?r"], ["proof (prove)\nusing this:\n  Collect P = {f x}\n\ngoal (1 subgoal):\n 1. \\<exists>!y. P y", "by (fold ex1_imp_Collect_singleton, auto)"], ["proof (state)\nthis:\n  \\<exists>!y. P y\n\ngoal (1 subgoal):\n 1. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "assume r: ?r"], ["proof (state)\nthis:\n  \\<exists>!y. P y\n\ngoal (1 subgoal):\n 1. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>!y. P y", "obtain y where \"P y\""], ["proof (prove)\nusing this:\n  \\<exists>!y. P y\n\ngoal (1 subgoal):\n 1. (\\<And>y. P y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  P y\n\ngoal (1 subgoal):\n 1. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "with r"], ["proof (chain)\npicking this:\n  \\<exists>!y. P y\n  P y", "have \"{y} = Collect P\""], ["proof (prove)\nusing this:\n  \\<exists>!y. P y\n  P y\n\ngoal (1 subgoal):\n 1. {y} = Collect P", "by auto"], ["proof (state)\nthis:\n  {y} = Collect P\n\ngoal (1 subgoal):\n 1. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "also"], ["proof (state)\nthis:\n  {y} = Collect P\n\ngoal (1 subgoal):\n 1. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "have \"Hilbert_Choice.inv f ` \\<dots> = Collect (P \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv f ` Collect P = Collect (P \\<circ> f)", "using bij_image_Collect_eq[OF bij_imp_bij_inv[OF bij]] bij"], ["proof (prove)\nusing this:\n  inv f ` Collect ?P = {y. ?P (inv (inv f) y)}\n  bij f\n\ngoal (1 subgoal):\n 1. inv f ` Collect P = Collect (P \\<circ> f)", "by (auto simp: inv_inv_eq)"], ["proof (state)\nthis:\n  inv f ` Collect P = Collect (P \\<circ> f)\n\ngoal (1 subgoal):\n 1. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "finally"], ["proof (chain)\npicking this:\n  inv f ` {y} = {a. (P \\<circ> f) a}", "have \"Collect (P o f) = {Hilbert_Choice.inv f y}\""], ["proof (prove)\nusing this:\n  inv f ` {y} = {a. (P \\<circ> f) a}\n\ngoal (1 subgoal):\n 1. Collect (P \\<circ> f) = {inv f y}", "by (simp add: o_def)"], ["proof (state)\nthis:\n  Collect (P \\<circ> f) = {inv f y}\n\ngoal (1 subgoal):\n 1. \\<exists>!y. P y \\<Longrightarrow> \\<exists>!x. P (f x)", "then"], ["proof (chain)\npicking this:\n  Collect (P \\<circ> f) = {inv f y}", "show ?l"], ["proof (prove)\nusing this:\n  Collect (P \\<circ> f) = {inv f y}\n\ngoal (1 subgoal):\n 1. \\<exists>!x. P (f x)", "by (fold ex1_imp_Collect_singleton, auto)"], ["proof (state)\nthis:\n  \\<exists>!x. P (f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_ex1_imp_the_shift:\n  assumes ex1: \"\\<exists>!y. P y\" shows \"(THE x. P (f x)) = Hilbert_Choice.inv f (THE y. P y)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE x. P (f x)) = inv f (THE y. P y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (THE x. P (f x)) = inv f (THE y. P y)", "from ex1"], ["proof (chain)\npicking this:\n  \\<exists>!y. P y", "have \"P (THE y. P y)\""], ["proof (prove)\nusing this:\n  \\<exists>!y. P y\n\ngoal (1 subgoal):\n 1. P (THE y. P y)", "by (rule the1I2)"], ["proof (state)\nthis:\n  P (THE y. P y)\n\ngoal (1 subgoal):\n 1. (THE x. P (f x)) = inv f (THE y. P y)", "moreover"], ["proof (state)\nthis:\n  P (THE y. P y)\n\ngoal (1 subgoal):\n 1. (THE x. P (f x)) = inv f (THE y. P y)", "from ex1[folded bij_imp_ex1_iff]"], ["proof (chain)\npicking this:\n  \\<exists>!x. P (f x)", "have \"P (f (THE x. P (f x)))\""], ["proof (prove)\nusing this:\n  \\<exists>!x. P (f x)\n\ngoal (1 subgoal):\n 1. P (f (THE x. P (f x)))", "by (rule the1I2)"], ["proof (state)\nthis:\n  P (f (THE x. P (f x)))\n\ngoal (1 subgoal):\n 1. (THE x. P (f x)) = inv f (THE y. P y)", "ultimately"], ["proof (chain)\npicking this:\n  P (THE y. P y)\n  P (f (THE x. P (f x)))", "have \"(THE y. P y) = f (THE x. P (f x))\""], ["proof (prove)\nusing this:\n  P (THE y. P y)\n  P (f (THE x. P (f x)))\n\ngoal (1 subgoal):\n 1. (THE y. P y) = f (THE x. P (f x))", "using ex1"], ["proof (prove)\nusing this:\n  P (THE y. P y)\n  P (f (THE x. P (f x)))\n  \\<exists>!y. P y\n\ngoal (1 subgoal):\n 1. (THE y. P y) = f (THE x. P (f x))", "by auto"], ["proof (state)\nthis:\n  (THE y. P y) = f (THE x. P (f x))\n\ngoal (1 subgoal):\n 1. (THE x. P (f x)) = inv f (THE y. P y)", "also"], ["proof (state)\nthis:\n  (THE y. P y) = f (THE x. P (f x))\n\ngoal (1 subgoal):\n 1. (THE x. P (f x)) = inv f (THE y. P y)", "have \"Hilbert_Choice.inv f \\<dots> = (THE x. P (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv f (f (THE x. P (f x))) = (THE x. P (f x))", "using bij"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. inv f (f (THE x. P (f x))) = (THE x. P (f x))", "by (simp add: bij_is_inj)"], ["proof (state)\nthis:\n  inv f (f (THE x. P (f x))) = (THE x. P (f x))\n\ngoal (1 subgoal):\n 1. (THE x. P (f x)) = inv f (THE y. P y)", "finally"], ["proof (chain)\npicking this:\n  inv f (THE y. P y) = (THE x. P (f x))", "show \"?l = ?r\""], ["proof (prove)\nusing this:\n  inv f (THE y. P y) = (THE x. P (f x))\n\ngoal (1 subgoal):\n 1. (THE x. P (f x)) = inv f (THE y. P y)", "by auto"], ["proof (state)\nthis:\n  (THE x. P (f x)) = inv f (THE y. P y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_imp_Collect_image: \"{x. P (f x)} = Hilbert_Choice.inv f ` {y. P y}\" (is \"?l = ?g ` _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. P (f x)} = inv f ` {y. P y}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. P (f x)} = inv f ` {y. P y}", "have \"?l = ?g ` f ` ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. P (f x)} = inv f ` f ` {x. P (f x)}", "by (simp add: image_comp inv_o_cancel[OF bij_is_inj[OF bij]])"], ["proof (state)\nthis:\n  {x. P (f x)} = inv f ` f ` {x. P (f x)}\n\ngoal (1 subgoal):\n 1. {x. P (f x)} = inv f ` {y. P y}", "also"], ["proof (state)\nthis:\n  {x. P (f x)} = inv f ` f ` {x. P (f x)}\n\ngoal (1 subgoal):\n 1. {x. P (f x)} = inv f ` {y. P y}", "have \"f ` ?l = {f x | x. P (f x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` {x. P (f x)} = {f x |x. P (f x)}", "by auto"], ["proof (state)\nthis:\n  f ` {x. P (f x)} = {f x |x. P (f x)}\n\ngoal (1 subgoal):\n 1. {x. P (f x)} = inv f ` {y. P y}", "also"], ["proof (state)\nthis:\n  f ` {x. P (f x)} = {f x |x. P (f x)}\n\ngoal (1 subgoal):\n 1. {x. P (f x)} = inv f ` {y. P y}", "have \"\\<dots> = {y. P y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f x |x. P (f x)} = {y. P y}", "by (metis bij bij_iff)"], ["proof (state)\nthis:\n  {f x |x. P (f x)} = {y. P y}\n\ngoal (1 subgoal):\n 1. {x. P (f x)} = inv f ` {y. P y}", "finally"], ["proof (chain)\npicking this:\n  {x. P (f x)} = inv f ` {y. P y}", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. P (f x)} = inv f ` {y. P y}\n\ngoal (1 subgoal):\n 1. {x. P (f x)} = inv f ` {y. P y}", "."], ["proof (state)\nthis:\n  {x. P (f x)} = inv f ` {y. P y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_imp_card_image: \"card (f ` X) = card X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (f ` X) = card X", "by (metis bij bij_iff card.infinite finite_imageD inj_onI inj_on_iff_eq_card)"], ["", "end"], ["", "lemma bij_imp_card: assumes bij: \"bij f\" shows \"card {x. P (f x)} = card {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. P (f x)} = card {x. P x}", "unfolding bij_imp_Collect_image[OF bij] bij_imp_card_image[OF bij_imp_bij_inv[OF bij]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Collect P) = card {x. P x}", ".."], ["", "lemma bij_add: \"bij (\\<lambda>x. x + y :: 'a :: group_add)\" (is ?g1)\n  and bij_minus: \"bij (\\<lambda>x. x - y :: 'a)\" (is ?g2)\n  and inv_add[simp]: \"Hilbert_Choice.inv (\\<lambda>x. x + y) = (\\<lambda>x. x - y)\" (is ?g3)\n  and inv_minus[simp]: \"Hilbert_Choice.inv (\\<lambda>x. x - y) = (\\<lambda>x. x + y)\" (is ?g4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (bij (\\<lambda>x. x + y) &&& bij (\\<lambda>x. x - y)) &&&\n    inv (\\<lambda>x. x + y) = (\\<lambda>x. x - y) &&&\n    inv (\\<lambda>x. x - y) = (\\<lambda>x. x + y)", "proof-"], ["proof (state)\ngoal (4 subgoals):\n 1. bij (\\<lambda>x. x + y)\n 2. bij (\\<lambda>x. x - y)\n 3. inv (\\<lambda>x. x + y) = (\\<lambda>x. x - y)\n 4. inv (\\<lambda>x. x - y) = (\\<lambda>x. x + y)", "have 1: \"(\\<lambda>x. x - y) \\<circ> (\\<lambda>x. x + y) = id\" and 2: \"(\\<lambda>x. x + y) \\<circ> (\\<lambda>x. x - y) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x - y) \\<circ> (\\<lambda>x. x + y) = id &&&\n    (\\<lambda>x. x + y) \\<circ> (\\<lambda>x. x - y) = id", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. x - y) \\<circ> (\\<lambda>x. x + y) = id\n  (\\<lambda>x. x + y) \\<circ> (\\<lambda>x. x - y) = id\n\ngoal (4 subgoals):\n 1. bij (\\<lambda>x. x + y)\n 2. bij (\\<lambda>x. x - y)\n 3. inv (\\<lambda>x. x + y) = (\\<lambda>x. x - y)\n 4. inv (\\<lambda>x. x - y) = (\\<lambda>x. x + y)", "from o_bij[OF 1 2]"], ["proof (chain)\npicking this:\n  bij (\\<lambda>x. x + y)", "show ?g1"], ["proof (prove)\nusing this:\n  bij (\\<lambda>x. x + y)\n\ngoal (1 subgoal):\n 1. bij (\\<lambda>x. x + y)", "."], ["proof (state)\nthis:\n  bij (\\<lambda>x. x + y)\n\ngoal (3 subgoals):\n 1. bij (\\<lambda>x. x - y)\n 2. inv (\\<lambda>x. x + y) = (\\<lambda>x. x - y)\n 3. inv (\\<lambda>x. x - y) = (\\<lambda>x. x + y)", "from o_bij[OF 2 1]"], ["proof (chain)\npicking this:\n  bij (\\<lambda>x. x - y)", "show ?g2"], ["proof (prove)\nusing this:\n  bij (\\<lambda>x. x - y)\n\ngoal (1 subgoal):\n 1. bij (\\<lambda>x. x - y)", "."], ["proof (state)\nthis:\n  bij (\\<lambda>x. x - y)\n\ngoal (2 subgoals):\n 1. inv (\\<lambda>x. x + y) = (\\<lambda>x. x - y)\n 2. inv (\\<lambda>x. x - y) = (\\<lambda>x. x + y)", "from inv_unique_comp[OF 2 1]"], ["proof (chain)\npicking this:\n  inv (\\<lambda>x. x + y) = (\\<lambda>x. x - y)", "show ?g3"], ["proof (prove)\nusing this:\n  inv (\\<lambda>x. x + y) = (\\<lambda>x. x - y)\n\ngoal (1 subgoal):\n 1. inv (\\<lambda>x. x + y) = (\\<lambda>x. x - y)", "."], ["proof (state)\nthis:\n  inv (\\<lambda>x. x + y) = (\\<lambda>x. x - y)\n\ngoal (1 subgoal):\n 1. inv (\\<lambda>x. x - y) = (\\<lambda>x. x + y)", "from inv_unique_comp[OF 1 2]"], ["proof (chain)\npicking this:\n  inv (\\<lambda>x. x - y) = (\\<lambda>x. x + y)", "show ?g4"], ["proof (prove)\nusing this:\n  inv (\\<lambda>x. x - y) = (\\<lambda>x. x + y)\n\ngoal (1 subgoal):\n 1. inv (\\<lambda>x. x - y) = (\\<lambda>x. x + y)", "."], ["proof (state)\nthis:\n  inv (\\<lambda>x. x - y) = (\\<lambda>x. x + y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas ex1_shift[simp] = bij_imp_ex1_iff[OF bij_add] bij_imp_ex1_iff[OF bij_minus]"], ["", "lemma ex1_the_shift:\n  assumes ex1: \"\\<exists>!y :: 'a :: group_add. P y\"\n  shows \"(THE x. P (x + d)) = (THE y. P y) - d\"\n    and \"(THE x. P (x - d)) = (THE y. P y) + d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE x. P (x + d)) = (THE y. P y) - d &&&\n    (THE x. P (x - d)) = (THE y. P y) + d", "unfolding bij_ex1_imp_the_shift[OF bij_add ex1] bij_ex1_imp_the_shift[OF bij_minus ex1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (\\<lambda>x. x + d) (The P) = (THE y. P y) - d &&&\n    inv (\\<lambda>x. x - d) (The P) = (THE y. P y) + d", "by auto"], ["", "lemma card_shift_image[simp]:\n  shows \"card ((\\<lambda>x :: 'a :: group_add. x + d) ` X) = card X\"\n    and \"card ((\\<lambda>x. x - d) ` X) = card X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((\\<lambda>x. x + d) ` X) = card X &&&\n    card ((\\<lambda>x. x - d) ` X) = card X", "by (auto simp: bij_imp_card_image[OF bij_add] bij_imp_card_image[OF bij_minus])"], ["", "lemma irreducible_root_free:\n  fixes p :: \"'a :: {idom,comm_ring_1} poly\"\n  assumes irr: \"irreducible p\" shows \"root_free p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_free p", "proof (cases \"degree p\" \"1::nat\" rule: linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p\n 3. 1 < degree p \\<Longrightarrow> root_free p", "case greater"], ["proof (state)\nthis:\n  1 < degree p\n\ngoal (3 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p\n 3. 1 < degree p \\<Longrightarrow> root_free p", "{"], ["proof (state)\nthis:\n  1 < degree p\n\ngoal (3 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p\n 3. 1 < degree p \\<Longrightarrow> root_free p", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p\n 3. 1 < degree p \\<Longrightarrow> root_free p", "assume \"poly p x = 0\""], ["proof (state)\nthis:\n  poly p x = (0::'a)\n\ngoal (3 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p\n 3. 1 < degree p \\<Longrightarrow> root_free p", "hence \"[:-x,1:] dvd p\""], ["proof (prove)\nusing this:\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] dvd p", "using poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  poly p x = (0::'a)\n  (poly ?p ?c = (0::?'a)) = ([:- ?c, 1::?'a:] dvd ?p)\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] dvd p", "by blast"], ["proof (state)\nthis:\n  [:- x, 1::'a:] dvd p\n\ngoal (3 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p\n 3. 1 < degree p \\<Longrightarrow> root_free p", "then"], ["proof (chain)\npicking this:\n  [:- x, 1::'a:] dvd p", "obtain r where p: \"p = r * [:-x,1:]\""], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        p = r * [:- x, 1::'a:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE, auto)"], ["proof (state)\nthis:\n  p = r * [:- x, 1::'a:]\n\ngoal (3 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p\n 3. 1 < degree p \\<Longrightarrow> root_free p", "have deg: \"degree [:-x,1:] = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree [:- x, 1::'a:] = 1", "by simp"], ["proof (state)\nthis:\n  degree [:- x, 1::'a:] = 1\n\ngoal (3 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p\n 3. 1 < degree p \\<Longrightarrow> root_free p", "have dvd: \"\\<not> [:-x,1:] dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> [:- x, 1::'a:] dvd 1", "by (auto simp: poly_dvd_1)"], ["proof (state)\nthis:\n  \\<not> [:- x, 1::'a:] dvd 1\n\ngoal (3 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p\n 3. 1 < degree p \\<Longrightarrow> root_free p", "from greater"], ["proof (chain)\npicking this:\n  1 < degree p", "have \"degree r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  1 < degree p\n\ngoal (1 subgoal):\n 1. degree r \\<noteq> 0", "using degree_mult_le[of r \"[:-x,1:]\", unfolded deg, folded p]"], ["proof (prove)\nusing this:\n  1 < degree p\n  degree p \\<le> degree r + 1\n\ngoal (1 subgoal):\n 1. degree r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree r \\<noteq> 0\n\ngoal (3 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p\n 3. 1 < degree p \\<Longrightarrow> root_free p", "then"], ["proof (chain)\npicking this:\n  degree r \\<noteq> 0", "have \"\\<not> r dvd 1\""], ["proof (prove)\nusing this:\n  degree r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> r dvd 1", "by (auto simp: poly_dvd_1)"], ["proof (state)\nthis:\n  \\<not> r dvd 1\n\ngoal (3 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p\n 3. 1 < degree p \\<Longrightarrow> root_free p", "with p irr irreducibleD[OF irr p] dvd"], ["proof (chain)\npicking this:\n  p = r * [:- x, 1::'a:]\n  irreducible p\n  r dvd 1 \\<or> [:- x, 1::'a:] dvd 1\n  \\<not> [:- x, 1::'a:] dvd 1\n  \\<not> r dvd 1", "have False"], ["proof (prove)\nusing this:\n  p = r * [:- x, 1::'a:]\n  irreducible p\n  r dvd 1 \\<or> [:- x, 1::'a:] dvd 1\n  \\<not> [:- x, 1::'a:] dvd 1\n  \\<not> r dvd 1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p\n 3. 1 < degree p \\<Longrightarrow> root_free p", "}"], ["proof (state)\nthis:\n  poly p ?x2 = (0::'a) \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p\n 3. 1 < degree p \\<Longrightarrow> root_free p", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly p ?x2 = (0::'a) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. root_free p", "unfolding root_free_def"], ["proof (prove)\nusing this:\n  poly p ?x2 = (0::'a) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. degree p = 1 \\<or> (\\<forall>x. poly p x \\<noteq> (0::'a))", "by auto"], ["proof (state)\nthis:\n  root_free p\n\ngoal (2 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p", "case less"], ["proof (state)\nthis:\n  degree p < 1\n\ngoal (2 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p", "then"], ["proof (chain)\npicking this:\n  degree p < 1", "have deg: \"degree p = 0\""], ["proof (prove)\nusing this:\n  degree p < 1\n\ngoal (1 subgoal):\n 1. degree p = 0", "by auto"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (2 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p", "from deg"], ["proof (chain)\npicking this:\n  degree p = 0", "obtain p0 where p: \"p = [:p0:]\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. (\\<And>p0. p = [:p0:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using degree0_coeffs"], ["proof (prove)\nusing this:\n  degree p = 0\n  degree ?p = 0 \\<Longrightarrow> \\<exists>a. ?p = [:a:]\n\ngoal (1 subgoal):\n 1. (\\<And>p0. p = [:p0:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p = [:p0:]\n\ngoal (2 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p", "with irr"], ["proof (chain)\npicking this:\n  irreducible p\n  p = [:p0:]", "have \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  irreducible p\n  p = [:p0:]\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p", "with p"], ["proof (chain)\npicking this:\n  p = [:p0:]\n  p \\<noteq> 0", "have \"poly p x \\<noteq> 0\" for x"], ["proof (prove)\nusing this:\n  p = [:p0:]\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  poly p ?x \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. degree p < 1 \\<Longrightarrow> root_free p\n 2. degree p = 1 \\<Longrightarrow> root_free p", "thus ?thesis"], ["proof (prove)\nusing this:\n  poly p ?x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. root_free p", "by (auto simp: root_free_def)"], ["proof (state)\nthis:\n  root_free p\n\ngoal (1 subgoal):\n 1. degree p = 1 \\<Longrightarrow> root_free p", "qed (auto simp: root_free_def)"], ["", "(* **************************************************************** *)"], ["", "subsection \\<open>Real Algebraic Numbers -- Innermost Layer\\<close>"], ["", "text \\<open>We represent a real algebraic number \\<open>\\<alpha>\\<close> by a tuple (p,l,r):\n    \\<open>\\<alpha>\\<close> is the unique root in the interval [l,r]\n    and l and r have the same sign. We always assume that p is normalized, i.e.,\n    p is the unique irreducible and positive content-free polynomial \n    which represents the algebraic number.\n\n  This representation clearly admits duplicate representations for the same number, e.g.\n  (...,x-3, 3,3) is equivalent to (...,x-3,2,10).\\<close>"], ["", "subsubsection \\<open>Basic Definitions\\<close>"], ["", "type_synonym real_alg_1 = \"int poly \\<times> rat \\<times> rat\""], ["", "fun poly_real_alg_1 :: \"real_alg_1 \\<Rightarrow> int poly\" where \"poly_real_alg_1 (p,_,_) = p\""], ["", "fun rai_ub :: \"real_alg_1 \\<Rightarrow> rat\" where \"rai_ub (_,_,r) = r\""], ["", "fun rai_lb :: \"real_alg_1 \\<Rightarrow> rat\" where \"rai_lb (_,l,_) = l\""], ["", "abbreviation \"roots_below p x \\<equiv> {y :: real. y \\<le> x \\<and> ipoly p y = 0}\""], ["", "abbreviation(input) unique_root :: \"real_alg_1 \\<Rightarrow> bool\" where\n  \"unique_root plr \\<equiv> (\\<exists>! x. root_cond plr x)\""], ["", "abbreviation the_unique_root :: \"real_alg_1 \\<Rightarrow> real\" where\n  \"the_unique_root plr \\<equiv> (THE x. root_cond plr x)\""], ["", "abbreviation real_of_1 where \"real_of_1 \\<equiv> the_unique_root\""], ["", "lemma root_condI[intro]:\n  assumes \"of_rat (rai_lb plr) \\<le> x\" and \"x \\<le> of_rat (rai_ub plr)\" and \"ipoly (poly_real_alg_1 plr) x = 0\"\n  shows \"root_cond plr x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_cond plr x", "using assms"], ["proof (prove)\nusing this:\n  real_of_rat (rai_lb plr) \\<le> x\n  x \\<le> real_of_rat (rai_ub plr)\n  poly (real_of_int_poly (poly_real_alg_1 plr)) x = 0\n\ngoal (1 subgoal):\n 1. root_cond plr x", "by (auto simp: root_cond_def)"], ["", "lemma root_condE[elim]:\n  assumes \"root_cond plr x\"\n      and \"of_rat (rai_lb plr) \\<le> x \\<Longrightarrow> x \\<le> of_rat (rai_ub plr) \\<Longrightarrow> ipoly (poly_real_alg_1 plr) x = 0 \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  root_cond plr x\n  \\<lbrakk>real_of_rat (rai_lb plr) \\<le> x;\n   x \\<le> real_of_rat (rai_ub plr);\n   poly (real_of_int_poly (poly_real_alg_1 plr)) x = 0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: root_cond_def)"], ["", "lemma\n  assumes ur: \"unique_root plr\"\n  defines \"x \\<equiv> the_unique_root plr\" and \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  shows unique_rootD: \"of_rat l \\<le> x\" \"x \\<le> of_rat r\" \"ipoly p x = 0\" \"root_cond plr x\"\n        \"x = y \\<longleftrightarrow> root_cond plr y\" \"y = x \\<longleftrightarrow> root_cond plr y\"\n    and the_unique_root_eqI: \"root_cond plr y \\<Longrightarrow> y = x\" \"root_cond plr y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((real_of_rat l \\<le> x &&&\n      x \\<le> real_of_rat r &&& poly (real_of_int_poly p) x = 0) &&&\n     root_cond plr x &&&\n     (x = y) = root_cond plr y &&& (y = x) = root_cond plr y) &&&\n    (root_cond plr y \\<Longrightarrow> y = x) &&&\n    (root_cond plr y \\<Longrightarrow> x = y)", "proof -"], ["proof (state)\ngoal (8 subgoals):\n 1. real_of_rat l \\<le> x\n 2. x \\<le> real_of_rat r\n 3. poly (real_of_int_poly p) x = 0\n 4. root_cond plr x\n 5. (x = y) = root_cond plr y\n 6. (y = x) = root_cond plr y\n 7. root_cond plr y \\<Longrightarrow> y = x\n 8. root_cond plr y \\<Longrightarrow> x = y", "from ur"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond plr x", "show x: \"root_cond plr x\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond plr x\n\ngoal (1 subgoal):\n 1. root_cond plr x", "unfolding x_def"], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond plr x\n\ngoal (1 subgoal):\n 1. root_cond plr (real_of_1 plr)", "by (rule theI')"], ["proof (state)\nthis:\n  root_cond plr x\n\ngoal (7 subgoals):\n 1. real_of_rat l \\<le> x\n 2. x \\<le> real_of_rat r\n 3. poly (real_of_int_poly p) x = 0\n 4. (x = y) = root_cond plr y\n 5. (y = x) = root_cond plr y\n 6. root_cond plr y \\<Longrightarrow> y = x\n 7. root_cond plr y \\<Longrightarrow> x = y", "have \"plr = (p,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plr = (p, l, r)", "by (cases plr, auto simp: p_def l_def r_def)"], ["proof (state)\nthis:\n  plr = (p, l, r)\n\ngoal (7 subgoals):\n 1. real_of_rat l \\<le> x\n 2. x \\<le> real_of_rat r\n 3. poly (real_of_int_poly p) x = 0\n 4. (x = y) = root_cond plr y\n 5. (y = x) = root_cond plr y\n 6. root_cond plr y \\<Longrightarrow> y = x\n 7. root_cond plr y \\<Longrightarrow> x = y", "from x[unfolded this]"], ["proof (chain)\npicking this:\n  root_cond (p, l, r) x", "show \"of_rat l \\<le> x\" \"x \\<le> of_rat r\" \"ipoly p x = 0\""], ["proof (prove)\nusing this:\n  root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> x &&&\n    x \\<le> real_of_rat r &&& poly (real_of_int_poly p) x = 0", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  poly (real_of_int_poly p) x = 0\n\ngoal (4 subgoals):\n 1. (x = y) = root_cond plr y\n 2. (y = x) = root_cond plr y\n 3. root_cond plr y \\<Longrightarrow> y = x\n 4. root_cond plr y \\<Longrightarrow> x = y", "from x ur"], ["proof (chain)\npicking this:\n  root_cond plr x\n  \\<exists>!x. root_cond plr x", "show \"root_cond plr y \\<Longrightarrow> y = x\" and \"root_cond plr y \\<Longrightarrow> x = y\"\n   and \"x = y \\<longleftrightarrow> root_cond plr y\" and \"y = x \\<longleftrightarrow> root_cond plr y\""], ["proof (prove)\nusing this:\n  root_cond plr x\n  \\<exists>!x. root_cond plr x\n\ngoal (1 subgoal):\n 1. ((root_cond plr y \\<Longrightarrow> y = x) &&&\n     (root_cond plr y \\<Longrightarrow> x = y)) &&&\n    (x = y) = root_cond plr y &&& (y = x) = root_cond plr y", "by auto"], ["proof (state)\nthis:\n  root_cond plr y \\<Longrightarrow> y = x\n  root_cond plr y \\<Longrightarrow> x = y\n  (x = y) = root_cond plr y\n  (y = x) = root_cond plr y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_rootE:\n  assumes ur: \"unique_root plr\"\n  defines \"x \\<equiv> the_unique_root plr\" and \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  assumes main: \"of_rat l \\<le> x \\<Longrightarrow> x \\<le> of_rat r \\<Longrightarrow> ipoly p x = 0 \\<Longrightarrow> root_cond plr x \\<Longrightarrow>\n        (\\<And>y. x = y \\<longleftrightarrow> root_cond plr y) \\<Longrightarrow> (\\<And>y. y = x \\<longleftrightarrow> root_cond plr y) \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by (rule main, unfold x_def p_def l_def r_def; rule unique_rootD[OF ur])"], ["", "lemma unique_rootI:\n  assumes \"\\<And> y. root_cond plr y \\<Longrightarrow> x = y\" \"root_cond plr x\"\n  shows \"unique_root plr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond plr x", "using assms"], ["proof (prove)\nusing this:\n  root_cond plr ?y \\<Longrightarrow> x = ?y\n  root_cond plr x\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond plr x", "by blast"], ["", "definition poly_cond :: \"int poly \\<Rightarrow> bool\" where\n  \"poly_cond p = (lead_coeff p > 0 \\<and> irreducible p)\""], ["", "lemma poly_condI[intro]:\n  assumes \"lead_coeff p > 0\" and \"irreducible p\" shows \"poly_cond p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_cond p", "using assms"], ["proof (prove)\nusing this:\n  0 < lead_coeff p\n  irreducible p\n\ngoal (1 subgoal):\n 1. poly_cond p", "by (auto simp: poly_cond_def)"], ["", "lemma poly_condD:\n  assumes \"poly_cond p\"\n  shows \"irreducible p\" and \"lead_coeff p > 0\" and \"root_free p\" and \"square_free p\" and \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (irreducible p &&& 0 < lead_coeff p) &&&\n    root_free p &&& square_free p &&& p \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  poly_cond p\n\ngoal (1 subgoal):\n 1. (irreducible p &&& 0 < lead_coeff p) &&&\n    root_free p &&& square_free p &&& p \\<noteq> 0", "unfolding poly_cond_def"], ["proof (prove)\nusing this:\n  0 < lead_coeff p \\<and> irreducible p\n\ngoal (1 subgoal):\n 1. (irreducible p &&& 0 < lead_coeff p) &&&\n    root_free p &&& square_free p &&& p \\<noteq> 0", "using irreducible_root_free irreducible_imp_square_free cf_pos_def"], ["proof (prove)\nusing this:\n  0 < lead_coeff p \\<and> irreducible p\n  irreducible ?p \\<Longrightarrow> root_free ?p\n  irreducible ?p \\<Longrightarrow> square_free ?p\n  cf_pos ?p = (content ?p = 1 \\<and> 0 < lead_coeff ?p)\n\ngoal (1 subgoal):\n 1. (irreducible p &&& 0 < lead_coeff p) &&&\n    root_free p &&& square_free p &&& p \\<noteq> 0", "by auto"], ["", "lemma poly_condE[elim]:\n  assumes \"poly_cond p\"\n      and \"irreducible p \\<Longrightarrow> lead_coeff p > 0 \\<Longrightarrow> root_free p \\<Longrightarrow> square_free p \\<Longrightarrow> p \\<noteq> 0 \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  poly_cond p\n  \\<lbrakk>irreducible p; 0 < lead_coeff p; root_free p; square_free p;\n   p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (auto dest:poly_condD)"], ["", "definition invariant_1 :: \"real_alg_1 \\<Rightarrow> bool\" where\n  \"invariant_1 tup \\<equiv> case tup of (p,l,r) \\<Rightarrow>\n    unique_root (p,l,r) \\<and> sgn l = sgn r \\<and> poly_cond p\""], ["", "lemma invariant_1I:\n  assumes \"unique_root plr\" and \"sgn (rai_lb plr) = sgn (rai_ub plr)\" and \"poly_cond (poly_real_alg_1 plr)\"\n  shows \"invariant_1 plr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1 plr", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond plr x\n  sgn (rai_lb plr) = sgn (rai_ub plr)\n  poly_cond (poly_real_alg_1 plr)\n\ngoal (1 subgoal):\n 1. invariant_1 plr", "by (auto simp: invariant_1_def)"], ["", "lemma\n  assumes \"invariant_1 plr\"\n  defines \"x \\<equiv> the_unique_root plr\" and \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  shows invariant_1D: \"root_cond plr x\"\n    \"sgn l = sgn r\" \"sgn x = of_rat (sgn r)\" \"unique_root plr\" \"poly_cond p\" \"degree p > 0\" \"primitive p\"\n    and invariant_1_root_cond: \"\\<And> y. root_cond plr y \\<longleftrightarrow> y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((root_cond plr x &&& sgn l = sgn r &&& sgn x = real_of_rat (sgn r)) &&&\n     (\\<exists>!x. root_cond plr x &&& poly_cond p) &&&\n     0 < degree p &&& primitive p) &&&\n    (\\<And>y. root_cond plr y = (y = x))", "proof -"], ["proof (state)\ngoal (8 subgoals):\n 1. root_cond plr x\n 2. sgn l = sgn r\n 3. sgn x = real_of_rat (sgn r)\n 4. \\<exists>!x. root_cond plr x\n 5. poly_cond p\n 6. 0 < degree p\n 7. primitive p\n 8. \\<And>y. root_cond plr y = (y = x)", "let ?l = \"of_rat l :: real\""], ["proof (state)\ngoal (8 subgoals):\n 1. root_cond plr x\n 2. sgn l = sgn r\n 3. sgn x = real_of_rat (sgn r)\n 4. \\<exists>!x. root_cond plr x\n 5. poly_cond p\n 6. 0 < degree p\n 7. primitive p\n 8. \\<And>y. root_cond plr y = (y = x)", "let ?r = \"of_rat r :: real\""], ["proof (state)\ngoal (8 subgoals):\n 1. root_cond plr x\n 2. sgn l = sgn r\n 3. sgn x = real_of_rat (sgn r)\n 4. \\<exists>!x. root_cond plr x\n 5. poly_cond p\n 6. 0 < degree p\n 7. primitive p\n 8. \\<And>y. root_cond plr y = (y = x)", "have plr: \"plr = (p,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plr = (p, l, r)", "by (cases plr, auto simp: p_def l_def r_def)"], ["proof (state)\nthis:\n  plr = (p, l, r)\n\ngoal (8 subgoals):\n 1. root_cond plr x\n 2. sgn l = sgn r\n 3. sgn x = real_of_rat (sgn r)\n 4. \\<exists>!x. root_cond plr x\n 5. poly_cond p\n 6. 0 < degree p\n 7. primitive p\n 8. \\<And>y. root_cond plr y = (y = x)", "from assms"], ["proof (chain)\npicking this:\n  invariant_1 plr\n  x \\<equiv> real_of_1 plr\n  p \\<equiv> poly_real_alg_1 plr\n  l \\<equiv> rai_lb plr\n  r \\<equiv> rai_ub plr", "show ur: \"unique_root plr\" and sgn: \"sgn l = sgn r\" and pc: \"poly_cond p\""], ["proof (prove)\nusing this:\n  invariant_1 plr\n  x \\<equiv> real_of_1 plr\n  p \\<equiv> poly_real_alg_1 plr\n  l \\<equiv> rai_lb plr\n  r \\<equiv> rai_ub plr\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond plr x &&& sgn l = sgn r &&& poly_cond p", "by (auto simp: invariant_1_def)"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond plr x\n  sgn l = sgn r\n  poly_cond p\n\ngoal (5 subgoals):\n 1. root_cond plr x\n 2. sgn x = real_of_rat (sgn r)\n 3. 0 < degree p\n 4. primitive p\n 5. \\<And>y. root_cond plr y = (y = x)", "from ur"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond plr x", "show rc: \"root_cond plr x\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond plr x\n\ngoal (1 subgoal):\n 1. root_cond plr x", "by (auto simp add: x_def plr intro: theI')"], ["proof (state)\nthis:\n  root_cond plr x\n\ngoal (4 subgoals):\n 1. sgn x = real_of_rat (sgn r)\n 2. 0 < degree p\n 3. primitive p\n 4. \\<And>y. root_cond plr y = (y = x)", "from this[unfolded plr]"], ["proof (chain)\npicking this:\n  root_cond (p, l, r) x", "have x: \"ipoly p x = 0\" and bnd: \"?l \\<le> x\" \"x \\<le> ?r\""], ["proof (prove)\nusing this:\n  root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 &&&\n    real_of_rat l \\<le> x &&& x \\<le> real_of_rat r", "by auto"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) x = 0\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n\ngoal (4 subgoals):\n 1. sgn x = real_of_rat (sgn r)\n 2. 0 < degree p\n 3. primitive p\n 4. \\<And>y. root_cond plr y = (y = x)", "show \"sgn x = of_rat (sgn r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn x = real_of_rat (sgn r)", "proof (cases \"0::real\" \"x\" rule:linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < x \\<Longrightarrow> sgn x = real_of_rat (sgn r)\n 2. 0 = x \\<Longrightarrow> sgn x = real_of_rat (sgn r)\n 3. x < 0 \\<Longrightarrow> sgn x = real_of_rat (sgn r)", "case less"], ["proof (state)\nthis:\n  0 < x\n\ngoal (3 subgoals):\n 1. 0 < x \\<Longrightarrow> sgn x = real_of_rat (sgn r)\n 2. 0 = x \\<Longrightarrow> sgn x = real_of_rat (sgn r)\n 3. x < 0 \\<Longrightarrow> sgn x = real_of_rat (sgn r)", "with bnd(2)"], ["proof (chain)\npicking this:\n  x \\<le> real_of_rat r\n  0 < x", "have \"0 < ?r\""], ["proof (prove)\nusing this:\n  x \\<le> real_of_rat r\n  0 < x\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat r", "by arith"], ["proof (state)\nthis:\n  0 < real_of_rat r\n\ngoal (3 subgoals):\n 1. 0 < x \\<Longrightarrow> sgn x = real_of_rat (sgn r)\n 2. 0 = x \\<Longrightarrow> sgn x = real_of_rat (sgn r)\n 3. x < 0 \\<Longrightarrow> sgn x = real_of_rat (sgn r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < real_of_rat r\n\ngoal (1 subgoal):\n 1. sgn x = real_of_rat (sgn r)", "using less"], ["proof (prove)\nusing this:\n  0 < real_of_rat r\n  0 < x\n\ngoal (1 subgoal):\n 1. sgn x = real_of_rat (sgn r)", "by simp"], ["proof (state)\nthis:\n  sgn x = real_of_rat (sgn r)\n\ngoal (2 subgoals):\n 1. 0 = x \\<Longrightarrow> sgn x = real_of_rat (sgn r)\n 2. x < 0 \\<Longrightarrow> sgn x = real_of_rat (sgn r)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 = x \\<Longrightarrow> sgn x = real_of_rat (sgn r)\n 2. x < 0 \\<Longrightarrow> sgn x = real_of_rat (sgn r)", "case equal"], ["proof (state)\nthis:\n  0 = x\n\ngoal (2 subgoals):\n 1. 0 = x \\<Longrightarrow> sgn x = real_of_rat (sgn r)\n 2. x < 0 \\<Longrightarrow> sgn x = real_of_rat (sgn r)", "with bnd"], ["proof (chain)\npicking this:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  0 = x", "have \"?l \\<le> 0\" \"?r \\<ge> 0\""], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  0 = x\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> 0 &&& 0 \\<le> real_of_rat r", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> 0\n  0 \\<le> real_of_rat r\n\ngoal (2 subgoals):\n 1. 0 = x \\<Longrightarrow> sgn x = real_of_rat (sgn r)\n 2. x < 0 \\<Longrightarrow> sgn x = real_of_rat (sgn r)", "hence \"l \\<le> 0\" \"r \\<ge> 0\""], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> 0\n  0 \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. l \\<le> 0 &&& 0 \\<le> r", "by auto"], ["proof (state)\nthis:\n  l \\<le> 0\n  0 \\<le> r\n\ngoal (2 subgoals):\n 1. 0 = x \\<Longrightarrow> sgn x = real_of_rat (sgn r)\n 2. x < 0 \\<Longrightarrow> sgn x = real_of_rat (sgn r)", "with \\<open>sgn l = sgn r\\<close>"], ["proof (chain)\npicking this:\n  sgn l = sgn r\n  l \\<le> 0\n  0 \\<le> r", "have \"l = 0\" \"r = 0\""], ["proof (prove)\nusing this:\n  sgn l = sgn r\n  l \\<le> 0\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. l = 0 &&& r = 0", "unfolding sgn_rat_def"], ["proof (prove)\nusing this:\n  (if l = 0 then 0 else if 0 < l then 1 else - 1) =\n  (if r = 0 then 0 else if 0 < r then 1 else - 1)\n  l \\<le> 0\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. l = 0 &&& r = 0", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  l = 0\n  r = 0\n\ngoal (2 subgoals):\n 1. 0 = x \\<Longrightarrow> sgn x = real_of_rat (sgn r)\n 2. x < 0 \\<Longrightarrow> sgn x = real_of_rat (sgn r)", "with rc[unfolded plr]"], ["proof (chain)\npicking this:\n  root_cond (p, l, r) x\n  l = 0\n  r = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  root_cond (p, l, r) x\n  l = 0\n  r = 0\n\ngoal (1 subgoal):\n 1. sgn x = real_of_rat (sgn r)", "by auto"], ["proof (state)\nthis:\n  sgn x = real_of_rat (sgn r)\n\ngoal (1 subgoal):\n 1. x < 0 \\<Longrightarrow> sgn x = real_of_rat (sgn r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x < 0 \\<Longrightarrow> sgn x = real_of_rat (sgn r)", "case greater"], ["proof (state)\nthis:\n  x < 0\n\ngoal (1 subgoal):\n 1. x < 0 \\<Longrightarrow> sgn x = real_of_rat (sgn r)", "with bnd(1)"], ["proof (chain)\npicking this:\n  real_of_rat l \\<le> x\n  x < 0", "have \"?l < 0\""], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x\n  x < 0\n\ngoal (1 subgoal):\n 1. real_of_rat l < 0", "by arith"], ["proof (state)\nthis:\n  real_of_rat l < 0\n\ngoal (1 subgoal):\n 1. x < 0 \\<Longrightarrow> sgn x = real_of_rat (sgn r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  real_of_rat l < 0\n\ngoal (1 subgoal):\n 1. sgn x = real_of_rat (sgn r)", "unfolding \\<open>sgn l = sgn r\\<close>[symmetric]"], ["proof (prove)\nusing this:\n  real_of_rat l < 0\n\ngoal (1 subgoal):\n 1. sgn x = real_of_rat (sgn l)", "using greater"], ["proof (prove)\nusing this:\n  real_of_rat l < 0\n  x < 0\n\ngoal (1 subgoal):\n 1. sgn x = real_of_rat (sgn l)", "by simp"], ["proof (state)\nthis:\n  sgn x = real_of_rat (sgn r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgn x = real_of_rat (sgn r)\n\ngoal (3 subgoals):\n 1. 0 < degree p\n 2. primitive p\n 3. \\<And>y. root_cond plr y = (y = x)", "from the_unique_root_eqI[OF ur] rc"], ["proof (chain)\npicking this:\n  root_cond plr ?y \\<Longrightarrow> ?y = real_of_1 plr\n  root_cond plr ?y \\<Longrightarrow> real_of_1 plr = ?y\n  root_cond plr x", "show \"\\<And> y. root_cond plr y \\<longleftrightarrow> y = x\""], ["proof (prove)\nusing this:\n  root_cond plr ?y \\<Longrightarrow> ?y = real_of_1 plr\n  root_cond plr ?y \\<Longrightarrow> real_of_1 plr = ?y\n  root_cond plr x\n\ngoal (1 subgoal):\n 1. \\<And>y. root_cond plr y = (y = x)", "by metis"], ["proof (state)\nthis:\n  root_cond plr ?y = (?y = x)\n\ngoal (2 subgoals):\n 1. 0 < degree p\n 2. primitive p", "{"], ["proof (state)\nthis:\n  root_cond plr ?y = (?y = x)\n\ngoal (2 subgoals):\n 1. 0 < degree p\n 2. primitive p", "assume \"degree p = 0\""], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (2 subgoals):\n 1. 0 < degree p\n 2. primitive p", "with poly_zero[OF x, simplified] sgn bnd"], ["proof (chain)\npicking this:\n  (p = 0) = (degree p = 0)\n  sgn l = sgn r\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  degree p = 0", "have \"p = 0\""], ["proof (prove)\nusing this:\n  (p = 0) = (degree p = 0)\n  sgn l = sgn r\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  degree p = 0\n\ngoal (1 subgoal):\n 1. p = 0", "by auto"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. 0 < degree p\n 2. primitive p", "with pc"], ["proof (chain)\npicking this:\n  poly_cond p\n  p = 0", "have \"False\""], ["proof (prove)\nusing this:\n  poly_cond p\n  p = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. 0 < degree p\n 2. primitive p", "}"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. 0 < degree p\n 2. primitive p", "then"], ["proof (chain)\npicking this:\n  degree p = 0 \\<Longrightarrow> False", "show \"degree p > 0\""], ["proof (prove)\nusing this:\n  degree p = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. 0 < degree p", "by auto"], ["proof (state)\nthis:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. primitive p", "with pc"], ["proof (chain)\npicking this:\n  poly_cond p\n  0 < degree p", "show \"primitive p\""], ["proof (prove)\nusing this:\n  poly_cond p\n  0 < degree p\n\ngoal (1 subgoal):\n 1. primitive p", "by (intro irreducible_imp_primitive, auto)"], ["proof (state)\nthis:\n  primitive p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invariant_1E[elim]:\n  assumes \"invariant_1 plr\"\n  defines \"x \\<equiv> the_unique_root plr\" and \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  assumes main: \"root_cond plr x \\<Longrightarrow>\n      sgn l = sgn r \\<Longrightarrow> sgn x = of_rat (sgn r) \\<Longrightarrow> unique_root plr \\<Longrightarrow> poly_cond p \\<Longrightarrow> degree p > 0 \\<Longrightarrow>\n      primitive p \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule main)"], ["proof (prove)\ngoal (7 subgoals):\n 1. root_cond plr x\n 2. sgn l = sgn r\n 3. sgn x = real_of_rat (sgn r)\n 4. \\<exists>!x. root_cond plr x\n 5. poly_cond p\n 6. 0 < degree p\n 7. primitive p", "using assms(1)"], ["proof (prove)\nusing this:\n  invariant_1 plr\n\ngoal (7 subgoals):\n 1. root_cond plr x\n 2. sgn l = sgn r\n 3. sgn x = real_of_rat (sgn r)\n 4. \\<exists>!x. root_cond plr x\n 5. poly_cond p\n 6. 0 < degree p\n 7. primitive p", "unfolding x_def p_def l_def r_def"], ["proof (prove)\nusing this:\n  invariant_1 plr\n\ngoal (7 subgoals):\n 1. root_cond plr (real_of_1 plr)\n 2. sgn (rai_lb plr) = sgn (rai_ub plr)\n 3. sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr))\n 4. \\<exists>!x. root_cond plr x\n 5. poly_cond (poly_real_alg_1 plr)\n 6. 0 < degree (poly_real_alg_1 plr)\n 7. primitive (poly_real_alg_1 plr)", "by (auto dest: invariant_1D)"], ["", "lemma invariant_1_realI:\n  fixes plr :: real_alg_1\n  defines \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  assumes x: \"root_cond plr x\" and \"sgn l = sgn r\"\n      and ur: \"unique_root plr\"\n      and \"poly_cond p\"\n  shows \"invariant_1 plr \\<and> real_of_1 plr = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1 plr \\<and> real_of_1 plr = x", "using the_unique_root_eqI[OF ur x] assms"], ["proof (prove)\nusing this:\n  x = real_of_1 plr\n  real_of_1 plr = x\n  p \\<equiv> poly_real_alg_1 plr\n  l \\<equiv> rai_lb plr\n  r \\<equiv> rai_ub plr\n  root_cond plr x\n  sgn l = sgn r\n  \\<exists>!x. root_cond plr x\n  poly_cond p\n\ngoal (1 subgoal):\n 1. invariant_1 plr \\<and> real_of_1 plr = x", "by (cases plr, auto intro: invariant_1I)"], ["", "lemma real_of_1_0:\n  assumes \"invariant_1 (p,l,r)\"\n  shows [simp]: \"the_unique_root (p,l,r) = 0 \\<longleftrightarrow> r = 0\"\n    and [dest]: \"l = 0 \\<Longrightarrow> r = 0\"\n    and [intro]: \"r = 0 \\<Longrightarrow> l = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real_of_1 (p, l, r) = 0) = (r = 0) &&&\n    (l = 0 \\<Longrightarrow> r = 0) &&& (r = 0 \\<Longrightarrow> l = 0)", "using assms"], ["proof (prove)\nusing this:\n  invariant_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. (real_of_1 (p, l, r) = 0) = (r = 0) &&&\n    (l = 0 \\<Longrightarrow> r = 0) &&& (r = 0 \\<Longrightarrow> l = 0)", "by (auto simp: sgn_0_0)"], ["", "lemma invariant_1_pos: assumes rc: \"invariant_1 (p,l,r)\"\n  shows [simp]:\"the_unique_root (p,l,r) > 0 \\<longleftrightarrow> r > 0\" (is \"?x > 0 \\<longleftrightarrow> _\")\n    and [simp]:\"the_unique_root (p,l,r) < 0 \\<longleftrightarrow> r < 0\"\n    and [simp]:\"the_unique_root (p,l,r) \\<le> 0 \\<longleftrightarrow> r \\<le> 0\"\n    and [simp]:\"the_unique_root (p,l,r) \\<ge> 0 \\<longleftrightarrow> r \\<ge> 0\"\n    and [intro]: \"r > 0 \\<Longrightarrow> l > 0\"\n    and [dest]: \"l > 0 \\<Longrightarrow> r > 0\"\n    and [intro]: \"r < 0 \\<Longrightarrow> l < 0\"\n    and [dest]: \"l < 0 \\<Longrightarrow> r < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((0 < real_of_1 (p, l, r)) = (0 < r) &&&\n      (real_of_1 (p, l, r) < 0) = (r < 0)) &&&\n     (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) &&&\n     (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) &&&\n    ((0 < r \\<Longrightarrow> 0 < l) &&&\n     (0 < l \\<Longrightarrow> 0 < r)) &&&\n    (r < 0 \\<Longrightarrow> l < 0) &&& (l < 0 \\<Longrightarrow> r < 0)", "proof(atomize(full),goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n      (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n     (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n     (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n    ((0 < r \\<longrightarrow> 0 < l) \\<and>\n     (0 < l \\<longrightarrow> 0 < r)) \\<and>\n    (r < 0 \\<longrightarrow> l < 0) \\<and> (l < 0 \\<longrightarrow> r < 0)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n      (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n     (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n     (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n    ((0 < r \\<longrightarrow> 0 < l) \\<and>\n     (0 < l \\<longrightarrow> 0 < r)) \\<and>\n    (r < 0 \\<longrightarrow> l < 0) \\<and> (l < 0 \\<longrightarrow> r < 0)", "let ?r = \"real_of_rat\""], ["proof (state)\ngoal (1 subgoal):\n 1. (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n      (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n     (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n     (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n    ((0 < r \\<longrightarrow> 0 < l) \\<and>\n     (0 < l \\<longrightarrow> 0 < r)) \\<and>\n    (r < 0 \\<longrightarrow> l < 0) \\<and> (l < 0 \\<longrightarrow> r < 0)", "from assms[unfolded invariant_1_def]"], ["proof (chain)\npicking this:\n  case (p, l, r) of\n  (p, l, r) \\<Rightarrow>\n    (\\<exists>!x. root_cond (p, l, r) x) \\<and>\n    sgn l = sgn r \\<and> poly_cond p", "have ur: \"unique_root (p,l,r)\" and sgn: \"sgn l = sgn r\""], ["proof (prove)\nusing this:\n  case (p, l, r) of\n  (p, l, r) \\<Rightarrow>\n    (\\<exists>!x. root_cond (p, l, r) x) \\<and>\n    sgn l = sgn r \\<and> poly_cond p\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, l, r) x &&& sgn l = sgn r", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, l, r) x\n  sgn l = sgn r\n\ngoal (1 subgoal):\n 1. (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n      (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n     (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n     (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n    ((0 < r \\<longrightarrow> 0 < l) \\<and>\n     (0 < l \\<longrightarrow> 0 < r)) \\<and>\n    (r < 0 \\<longrightarrow> l < 0) \\<and> (l < 0 \\<longrightarrow> r < 0)", "from unique_rootD(1-2)[OF ur]"], ["proof (chain)\npicking this:\n  real_of_rat (rai_lb (p, l, r)) \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat (rai_ub (p, l, r))", "have le: \"?r l \\<le> ?x\" \"?x \\<le> ?r r\""], ["proof (prove)\nusing this:\n  real_of_rat (rai_lb (p, l, r)) \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat (rai_ub (p, l, r))\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> real_of_1 (p, l, r) &&&\n    real_of_1 (p, l, r) \\<le> real_of_rat r", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n      (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n     (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n     (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n    ((0 < r \\<longrightarrow> 0 < l) \\<and>\n     (0 < l \\<longrightarrow> 0 < r)) \\<and>\n    (r < 0 \\<longrightarrow> l < 0) \\<and> (l < 0 \\<longrightarrow> r < 0)", "from rc"], ["proof (chain)\npicking this:\n  invariant_1 (p, l, r)", "show ?case"], ["proof (prove)\nusing this:\n  invariant_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n      (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n     (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n     (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n    ((0 < r \\<longrightarrow> 0 < l) \\<and>\n     (0 < l \\<longrightarrow> 0 < r)) \\<and>\n    (r < 0 \\<longrightarrow> l < 0) \\<and> (l < 0 \\<longrightarrow> r < 0)", "proof (cases r \"0::rat\" rule:linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 2. \\<lbrakk>invariant_1 (p, l, r); r = 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 3. \\<lbrakk>invariant_1 (p, l, r); 0 < r\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "case greater"], ["proof (state)\nthis:\n  0 < r\n\ngoal (3 subgoals):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 2. \\<lbrakk>invariant_1 (p, l, r); r = 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 3. \\<lbrakk>invariant_1 (p, l, r); 0 < r\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "with sgn"], ["proof (chain)\npicking this:\n  sgn l = sgn r\n  0 < r", "have \"sgn l = 1\""], ["proof (prove)\nusing this:\n  sgn l = sgn r\n  0 < r\n\ngoal (1 subgoal):\n 1. sgn l = 1", "by simp"], ["proof (state)\nthis:\n  sgn l = 1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 2. \\<lbrakk>invariant_1 (p, l, r); r = 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 3. \\<lbrakk>invariant_1 (p, l, r); 0 < r\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "hence l0: \"l > 0\""], ["proof (prove)\nusing this:\n  sgn l = 1\n\ngoal (1 subgoal):\n 1. 0 < l", "by (auto simp: sgn_1_pos)"], ["proof (state)\nthis:\n  0 < l\n\ngoal (3 subgoals):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 2. \\<lbrakk>invariant_1 (p, l, r); r = 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 3. \\<lbrakk>invariant_1 (p, l, r); 0 < r\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "hence \"?r l > 0\""], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat l", "by auto"], ["proof (state)\nthis:\n  0 < real_of_rat l\n\ngoal (3 subgoals):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 2. \\<lbrakk>invariant_1 (p, l, r); r = 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 3. \\<lbrakk>invariant_1 (p, l, r); 0 < r\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "hence \"?x > 0\""], ["proof (prove)\nusing this:\n  0 < real_of_rat l\n\ngoal (1 subgoal):\n 1. 0 < real_of_1 (p, l, r)", "using le(1)"], ["proof (prove)\nusing this:\n  0 < real_of_rat l\n  real_of_rat l \\<le> real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. 0 < real_of_1 (p, l, r)", "by arith"], ["proof (state)\nthis:\n  0 < real_of_1 (p, l, r)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 2. \\<lbrakk>invariant_1 (p, l, r); r = 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 3. \\<lbrakk>invariant_1 (p, l, r); 0 < r\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "with greater l0"], ["proof (chain)\npicking this:\n  0 < r\n  0 < l\n  0 < real_of_1 (p, l, r)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < r\n  0 < l\n  0 < real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n      (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n     (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n     (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n    ((0 < r \\<longrightarrow> 0 < l) \\<and>\n     (0 < l \\<longrightarrow> 0 < r)) \\<and>\n    (r < 0 \\<longrightarrow> l < 0) \\<and> (l < 0 \\<longrightarrow> r < 0)", "by auto"], ["proof (state)\nthis:\n  (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n    (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n   (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n   (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n  ((0 < r \\<longrightarrow> 0 < l) \\<and>\n   (0 < l \\<longrightarrow> 0 < r)) \\<and>\n  (r < 0 \\<longrightarrow> l < 0) \\<and> (l < 0 \\<longrightarrow> r < 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 2. \\<lbrakk>invariant_1 (p, l, r); r = 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 2. \\<lbrakk>invariant_1 (p, l, r); r = 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "case equal"], ["proof (state)\nthis:\n  r = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)\n 2. \\<lbrakk>invariant_1 (p, l, r); r = 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "with real_of_1_0[OF rc]"], ["proof (chain)\npicking this:\n  (real_of_1 (p, l, r) = 0) = (r = 0)\n  l = 0 \\<Longrightarrow> r = 0\n  r = 0 \\<Longrightarrow> l = 0\n  r = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (real_of_1 (p, l, r) = 0) = (r = 0)\n  l = 0 \\<Longrightarrow> r = 0\n  r = 0 \\<Longrightarrow> l = 0\n  r = 0\n\ngoal (1 subgoal):\n 1. (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n      (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n     (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n     (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n    ((0 < r \\<longrightarrow> 0 < l) \\<and>\n     (0 < l \\<longrightarrow> 0 < r)) \\<and>\n    (r < 0 \\<longrightarrow> l < 0) \\<and> (l < 0 \\<longrightarrow> r < 0)", "by auto"], ["proof (state)\nthis:\n  (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n    (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n   (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n   (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n  ((0 < r \\<longrightarrow> 0 < l) \\<and>\n   (0 < l \\<longrightarrow> 0 < r)) \\<and>\n  (r < 0 \\<longrightarrow> l < 0) \\<and> (l < 0 \\<longrightarrow> r < 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "case less"], ["proof (state)\nthis:\n  r < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "hence \"?r r < 0\""], ["proof (prove)\nusing this:\n  r < 0\n\ngoal (1 subgoal):\n 1. real_of_rat r < 0", "by auto"], ["proof (state)\nthis:\n  real_of_rat r < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "with le(2)"], ["proof (chain)\npicking this:\n  real_of_1 (p, l, r) \\<le> real_of_rat r\n  real_of_rat r < 0", "have \"?x < 0\""], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) \\<le> real_of_rat r\n  real_of_rat r < 0\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) < 0", "by arith"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_1 (p, l, r); r < 0\\<rbrakk>\n    \\<Longrightarrow> (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n                        (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n                       (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n                       (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n                      ((0 < r \\<longrightarrow> 0 < l) \\<and>\n                       (0 < l \\<longrightarrow> 0 < r)) \\<and>\n                      (r < 0 \\<longrightarrow> l < 0) \\<and>\n                      (l < 0 \\<longrightarrow> r < 0)", "with less sgn"], ["proof (chain)\npicking this:\n  r < 0\n  sgn l = sgn r\n  real_of_1 (p, l, r) < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  r < 0\n  sgn l = sgn r\n  real_of_1 (p, l, r) < 0\n\ngoal (1 subgoal):\n 1. (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n      (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n     (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n     (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n    ((0 < r \\<longrightarrow> 0 < l) \\<and>\n     (0 < l \\<longrightarrow> 0 < r)) \\<and>\n    (r < 0 \\<longrightarrow> l < 0) \\<and> (l < 0 \\<longrightarrow> r < 0)", "by (auto simp: sgn_1_neg)"], ["proof (state)\nthis:\n  (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n    (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n   (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n   (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n  ((0 < r \\<longrightarrow> 0 < l) \\<and>\n   (0 < l \\<longrightarrow> 0 < r)) \\<and>\n  (r < 0 \\<longrightarrow> l < 0) \\<and> (l < 0 \\<longrightarrow> r < 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (((0 < real_of_1 (p, l, r)) = (0 < r) \\<and>\n    (real_of_1 (p, l, r) < 0) = (r < 0)) \\<and>\n   (real_of_1 (p, l, r) \\<le> 0) = (r \\<le> 0) \\<and>\n   (0 \\<le> real_of_1 (p, l, r)) = (0 \\<le> r)) \\<and>\n  ((0 < r \\<longrightarrow> 0 < l) \\<and>\n   (0 < l \\<longrightarrow> 0 < r)) \\<and>\n  (r < 0 \\<longrightarrow> l < 0) \\<and> (l < 0 \\<longrightarrow> r < 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition invariant_1_2 where\n  \"invariant_1_2 rai \\<equiv> invariant_1 rai \\<and> degree (poly_real_alg_1 rai) > 1\""], ["", "definition poly_cond2 where \"poly_cond2 p \\<equiv> poly_cond p \\<and> degree p > 1\""], ["", "lemma poly_cond2I[intro!]: \"poly_cond p \\<Longrightarrow> degree p > 1 \\<Longrightarrow> poly_cond2 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>poly_cond p; 1 < degree p\\<rbrakk>\n    \\<Longrightarrow> poly_cond2 p", "by (simp add: poly_cond2_def)"], ["", "lemma poly_cond2D:\n  assumes \"poly_cond2 p\"\n  shows \"poly_cond p\" and \"degree p > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_cond p &&& 1 < degree p", "using assms"], ["proof (prove)\nusing this:\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. poly_cond p &&& 1 < degree p", "by (auto simp: poly_cond2_def)"], ["", "lemma poly_cond2E[elim!]:\n  assumes \"poly_cond2 p\" and \"poly_cond p \\<Longrightarrow> degree p > 1 \\<Longrightarrow> thesis\" shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  poly_cond2 p\n  \\<lbrakk>poly_cond p; 1 < degree p\\<rbrakk> \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp: poly_cond2_def)"], ["", "lemma invariant_1_2_poly_cond2: \"invariant_1_2 rai \\<Longrightarrow> poly_cond2 (poly_real_alg_1 rai)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1_2 rai \\<Longrightarrow> poly_cond2 (poly_real_alg_1 rai)", "unfolding invariant_1_def invariant_1_2_def poly_cond2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case rai of\n     (p, l, r) \\<Rightarrow>\n       (\\<exists>!x. root_cond (p, l, r) x) \\<and>\n       sgn l = sgn r \\<and> poly_cond p) \\<and>\n    1 < degree (poly_real_alg_1 rai) \\<Longrightarrow>\n    poly_cond (poly_real_alg_1 rai) \\<and> 1 < degree (poly_real_alg_1 rai)", "by auto"], ["", "lemma invariant_1_2I[intro!]:\n  assumes \"invariant_1 rai\" and \"degree (poly_real_alg_1 rai) > 1\" shows \"invariant_1_2 rai\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1_2 rai", "using assms"], ["proof (prove)\nusing this:\n  invariant_1 rai\n  1 < degree (poly_real_alg_1 rai)\n\ngoal (1 subgoal):\n 1. invariant_1_2 rai", "by (auto simp: invariant_1_2_def)"], ["", "lemma invariant_1_2E[elim!]:\n  assumes \"invariant_1_2 rai\"\n      and \"invariant_1 rai \\<Longrightarrow> degree (poly_real_alg_1 rai) > 1 \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms[unfolded invariant_1_2_def]"], ["proof (prove)\nusing this:\n  invariant_1 rai \\<and> 1 < degree (poly_real_alg_1 rai)\n  \\<lbrakk>invariant_1 rai; 1 < degree (poly_real_alg_1 rai)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["", "lemma invariant_1_2_realI:\n  fixes plr :: real_alg_1\n  defines \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  assumes x: \"root_cond plr x\" and sgn: \"sgn l = sgn r\" and ur: \"unique_root plr\" and p: \"poly_cond2 p\"\n  shows \"invariant_1_2 plr \\<and> real_of_1 plr = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1_2 plr \\<and> real_of_1 plr = x", "using invariant_1_realI[OF x] p sgn ur"], ["proof (prove)\nusing this:\n  \\<lbrakk>sgn (rai_lb plr) = sgn (rai_ub plr);\n   \\<exists>!x. root_cond plr x; poly_cond (poly_real_alg_1 plr)\\<rbrakk>\n  \\<Longrightarrow> invariant_1 plr \\<and> real_of_1 plr = x\n  poly_cond2 p\n  sgn l = sgn r\n  \\<exists>!x. root_cond plr x\n\ngoal (1 subgoal):\n 1. invariant_1_2 plr \\<and> real_of_1 plr = x", "unfolding p_def l_def r_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>sgn (rai_lb plr) = sgn (rai_ub plr);\n   \\<exists>!x. root_cond plr x; poly_cond (poly_real_alg_1 plr)\\<rbrakk>\n  \\<Longrightarrow> invariant_1 plr \\<and> real_of_1 plr = x\n  poly_cond2 (poly_real_alg_1 plr)\n  sgn (rai_lb plr) = sgn (rai_ub plr)\n  \\<exists>!x. root_cond plr x\n\ngoal (1 subgoal):\n 1. invariant_1_2 plr \\<and> real_of_1 plr = x", "by auto"], ["", "subsection \\<open>Real Algebraic Numbers = Rational + Irrational Real Algebraic Numbers\\<close>"], ["", "text \\<open>In the next representation of real algebraic numbers, we distinguish between\n  rational and irrational numbers. The advantage is that whenever we only work on\n  rational numbers, there is not much overhead involved in comparison to the \n  existing implementation of real numbers which just supports the rational numbers.\n  For irrational numbers we additionally store the number of the root, counting from\n  left to right. For instance $-\\sqrt{2}$ and $\\sqrt{2}$ would be root number 1 and 2\n  of $x^2 - 2$.\\<close>"], ["", "subsubsection \\<open>Definitions and Algorithms on Raw Type\\<close>"], ["", "datatype real_alg_2 = Rational rat | Irrational nat real_alg_1"], ["", "fun invariant_2 :: \"real_alg_2 \\<Rightarrow> bool\" where \n  \"invariant_2 (Irrational n rai) = (invariant_1_2 rai\n    \\<and> n = card(roots_below (poly_real_alg_1 rai) (real_of_1 rai)))\"\n| \"invariant_2 (Rational r) = True\""], ["", "fun real_of_2 :: \"real_alg_2 \\<Rightarrow> real\" where\n  \"real_of_2 (Rational r) = of_rat r\"\n| \"real_of_2 (Irrational n rai) = real_of_1 rai\""], ["", "definition of_rat_2 :: \"rat \\<Rightarrow> real_alg_2\" where\n  [code_unfold]: \"of_rat_2 = Rational\""], ["", "lemma of_rat_2: \"real_of_2 (of_rat_2 x) = of_rat x\" \"invariant_2 (of_rat_2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 (of_rat_2 x) = real_of_rat x &&& invariant_2 (of_rat_2 x)", "by (auto simp: of_rat_2_def)"], ["", "(* Invariant type *)"], ["", "typedef real_alg_3 = \"Collect invariant_2\" \n  morphisms rep_real_alg_3 Real_Alg_Invariant"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Collect invariant_2", "by (rule exI[of _ \"Rational 0\"], auto)"], ["", "setup_lifting type_definition_real_alg_3"], ["", "lift_definition real_of_3 :: \"real_alg_3 \\<Rightarrow> real\" is real_of_2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(* *************** *)"], ["", "subsubsection \\<open>Definitions and Algorithms on Quotient Type\\<close>"], ["", "quotient_type real_alg = real_alg_3 / \"\\<lambda> x y. real_of_3 x = real_of_3 y\"\n  morphisms rep_real_alg Real_Alg_Quotient"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivp (\\<lambda>x y. real_of_3 x = real_of_3 y)", "by (auto simp: equivp_def) metis"], ["", "(* real_of *)"], ["", "lift_definition real_of :: \"real_alg \\<Rightarrow> real\" is real_of_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_31 real_alg_32.\n       real_of_3 real_alg_31 = real_of_3 real_alg_32 \\<Longrightarrow>\n       real_of_3 real_alg_31 = real_of_3 real_alg_32", "."], ["", "lemma real_of_inj: \"(real_of x = real_of y) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real_of x = real_of y) = (x = y)", "by (transfer, simp)"], ["", "(* ********************** *)"], ["", "subsubsection \\<open>Sign\\<close>"], ["", "definition sgn_1 :: \"real_alg_1 \\<Rightarrow> rat\" where\n  \"sgn_1 x = sgn (rai_ub x)\""], ["", "lemma sgn_1: \"invariant_1 x \\<Longrightarrow> real_of_rat (sgn_1 x) = sgn (real_of_1 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1 x \\<Longrightarrow>\n    real_of_rat (sgn_1 x) = sgn (real_of_1 x)", "unfolding sgn_1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1 x \\<Longrightarrow>\n    real_of_rat (sgn (rai_ub x)) = sgn (real_of_1 x)", "by auto"], ["", "lemma sgn_1_inj: \"invariant_1 x \\<Longrightarrow> invariant_1 y \\<Longrightarrow> real_of_1 x = real_of_1 y \\<Longrightarrow> sgn_1 x = sgn_1 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_1 x; invariant_1 y;\n     real_of_1 x = real_of_1 y\\<rbrakk>\n    \\<Longrightarrow> sgn_1 x = sgn_1 y", "by (auto simp: sgn_1_def elim!: invariant_1E)"], ["", "(* ********************** *)"], ["", "subsubsection \\<open>Normalization: Bounds Close Together\\<close>"], ["", "lemma unique_root_lr: assumes ur: \"unique_root plr\" shows \"rai_lb plr \\<le> rai_ub plr\" (is \"?l \\<le> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rai_lb plr \\<le> rai_ub plr", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rai_lb plr \\<le> rai_ub plr", "let ?p = \"poly_real_alg_1 plr\""], ["proof (state)\ngoal (1 subgoal):\n 1. rai_lb plr \\<le> rai_ub plr", "from ur[unfolded root_cond_def]"], ["proof (chain)\npicking this:\n  \\<exists>!x.\n     case plr of\n     (p, l, r) \\<Rightarrow>\n       real_of_rat l \\<le> x \\<and>\n       x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0", "have ex1: \"\\<exists>! x :: real. of_rat ?l \\<le> x \\<and> x \\<le> of_rat ?r \\<and> ipoly ?p x = 0\""], ["proof (prove)\nusing this:\n  \\<exists>!x.\n     case plr of\n     (p, l, r) \\<Rightarrow>\n       real_of_rat l \\<le> x \\<and>\n       x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       real_of_rat (rai_lb plr) \\<le> x \\<and>\n       x \\<le> real_of_rat (rai_ub plr) \\<and>\n       poly (real_of_int_poly (poly_real_alg_1 plr)) x = 0", "by (cases plr, simp)"], ["proof (state)\nthis:\n  \\<exists>!x.\n     real_of_rat (rai_lb plr) \\<le> x \\<and>\n     x \\<le> real_of_rat (rai_ub plr) \\<and>\n     poly (real_of_int_poly (poly_real_alg_1 plr)) x = 0\n\ngoal (1 subgoal):\n 1. rai_lb plr \\<le> rai_ub plr", "then"], ["proof (chain)\npicking this:\n  \\<exists>!x.\n     real_of_rat (rai_lb plr) \\<le> x \\<and>\n     x \\<le> real_of_rat (rai_ub plr) \\<and>\n     poly (real_of_int_poly (poly_real_alg_1 plr)) x = 0", "obtain x :: real where bnd: \"of_rat ?l \\<le> x\" \"x \\<le> of_rat ?r\" and rt: \"ipoly ?p x = 0\""], ["proof (prove)\nusing this:\n  \\<exists>!x.\n     real_of_rat (rai_lb plr) \\<le> x \\<and>\n     x \\<le> real_of_rat (rai_ub plr) \\<and>\n     poly (real_of_int_poly (poly_real_alg_1 plr)) x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>real_of_rat (rai_lb plr) \\<le> x;\n         x \\<le> real_of_rat (rai_ub plr);\n         poly (real_of_int_poly (poly_real_alg_1 plr)) x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  real_of_rat (rai_lb plr) \\<le> x\n  x \\<le> real_of_rat (rai_ub plr)\n  poly (real_of_int_poly (poly_real_alg_1 plr)) x = 0\n\ngoal (1 subgoal):\n 1. rai_lb plr \\<le> rai_ub plr", "from bnd"], ["proof (chain)\npicking this:\n  real_of_rat (rai_lb plr) \\<le> x\n  x \\<le> real_of_rat (rai_ub plr)", "have \"real_of_rat ?l \\<le> of_rat ?r\""], ["proof (prove)\nusing this:\n  real_of_rat (rai_lb plr) \\<le> x\n  x \\<le> real_of_rat (rai_ub plr)\n\ngoal (1 subgoal):\n 1. real_of_rat (rai_lb plr) \\<le> real_of_rat (rai_ub plr)", "by linarith"], ["proof (state)\nthis:\n  real_of_rat (rai_lb plr) \\<le> real_of_rat (rai_ub plr)\n\ngoal (1 subgoal):\n 1. rai_lb plr \\<le> rai_ub plr", "thus \"?l \\<le> ?r\""], ["proof (prove)\nusing this:\n  real_of_rat (rai_lb plr) \\<le> real_of_rat (rai_ub plr)\n\ngoal (1 subgoal):\n 1. rai_lb plr \\<le> rai_ub plr", "by (simp add: of_rat_less_eq)"], ["proof (state)\nthis:\n  rai_lb plr \\<le> rai_ub plr\n\ngoal:\nNo subgoals!", "qed"], ["", "locale map_poly_zero_hom_0 = base: zero_hom_0\nbegin"], ["", "sublocale zero_hom_0 \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_hom_0 (map_poly hom)", "by (unfold_locales,auto)"], ["", "end"], ["", "interpretation of_int_poly_hom:\n  map_poly_zero_hom_0 \"of_int :: int \\<Rightarrow> 'a :: {ring_1, ring_char_0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_zero_hom_0 of_int", ".."], ["", "lemma ipoly_roots_finite: \"p \\<noteq> 0 \\<Longrightarrow> finite {x :: 'a :: {idom, ring_char_0}. ipoly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> finite {x. ipoly p x = (0::'a)}", "by (rule poly_roots_finite, simp)"], ["", "lemma roots_below_the_unique_root:\n  assumes ur: \"unique_root (p,l,r)\"\n  shows \"roots_below p (the_unique_root (p,l,r)) = roots_below p (of_rat r)\" (is \"roots_below p ?x = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p, l, r) \\<and>\n        poly (real_of_int_poly p) y = 0} =\n    {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p, l, r) \\<and>\n        poly (real_of_int_poly p) y = 0} =\n    {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "from ur"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond (p, l, r) x", "have rc: \"root_cond (p,l,r) ?x\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. root_cond (p, l, r) (real_of_1 (p, l, r))", "by (auto dest!: unique_rootD)"], ["proof (state)\nthis:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p, l, r) \\<and>\n        poly (real_of_int_poly p) y = 0} =\n    {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "with ur"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond (p, l, r) x\n  root_cond (p, l, r) (real_of_1 (p, l, r))", "have x: \"{x. root_cond (p,l,r) x} = {?x}\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond (p, l, r) x\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. {x. root_cond (p, l, r) x} = {real_of_1 (p, l, r)}", "by (auto intro: the_unique_root_eqI)"], ["proof (state)\nthis:\n  {x. root_cond (p, l, r) x} = {real_of_1 (p, l, r)}\n\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p, l, r) \\<and>\n        poly (real_of_int_poly p) y = 0} =\n    {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "from rc"], ["proof (chain)\npicking this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))", "have \"?x \\<in> {y. ?x \\<le> y \\<and> y \\<le> of_rat r \\<and> ipoly p y = 0}\""], ["proof (prove)\nusing this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r)\n    \\<in> {y. real_of_1 (p, l, r) \\<le> y \\<and>\n              y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "by auto"], ["proof (state)\nthis:\n  real_of_1 (p, l, r)\n  \\<in> {y. real_of_1 (p, l, r) \\<le> y \\<and>\n            y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}\n\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p, l, r) \\<and>\n        poly (real_of_int_poly p) y = 0} =\n    {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "with rc"], ["proof (chain)\npicking this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  real_of_1 (p, l, r)\n  \\<in> {y. real_of_1 (p, l, r) \\<le> y \\<and>\n            y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "have l1x: \"... = {?x}\""], ["proof (prove)\nusing this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  real_of_1 (p, l, r)\n  \\<in> {y. real_of_1 (p, l, r) \\<le> y \\<and>\n            y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}\n\ngoal (1 subgoal):\n 1. {y. real_of_1 (p, l, r) \\<le> y \\<and>\n        y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0} =\n    {real_of_1 (p, l, r)}", "by (intro equalityI, fold x(1), force, simp add: x)"], ["proof (state)\nthis:\n  {y. real_of_1 (p, l, r) \\<le> y \\<and>\n      y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0} =\n  {real_of_1 (p, l, r)}\n\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p, l, r) \\<and>\n        poly (real_of_int_poly p) y = 0} =\n    {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "have rb:\"roots_below p (of_rat r) = roots_below p ?x \\<union> {y. ?x < y \\<and> y \\<le> of_rat r \\<and> ipoly p y = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0} =\n    {y. y \\<le> real_of_1 (p, l, r) \\<and>\n        poly (real_of_int_poly p) y = 0} \\<union>\n    {y. real_of_1 (p, l, r) < y \\<and>\n        y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "using rc"], ["proof (prove)\nusing this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0} =\n    {y. y \\<le> real_of_1 (p, l, r) \\<and>\n        poly (real_of_int_poly p) y = 0} \\<union>\n    {y. real_of_1 (p, l, r) < y \\<and>\n        y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "by auto"], ["proof (state)\nthis:\n  {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0} =\n  {y. y \\<le> real_of_1 (p, l, r) \\<and>\n      poly (real_of_int_poly p) y = 0} \\<union>\n  {y. real_of_1 (p, l, r) < y \\<and>\n      y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}\n\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p, l, r) \\<and>\n        poly (real_of_int_poly p) y = 0} =\n    {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "have emp: \"\\<And>x. the_unique_root (p, l, r) < x \\<Longrightarrow>\n                  x \\<notin> {ra. ?x \\<le> ra \\<and> ra \\<le> real_of_rat r \\<and> ipoly p ra = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       real_of_1 (p, l, r) < x \\<Longrightarrow>\n       x \\<notin> {ra.\n                   real_of_1 (p, l, r) \\<le> ra \\<and>\n                   ra \\<le> real_of_rat r \\<and>\n                   poly (real_of_int_poly p) ra = 0}", "using l1x"], ["proof (prove)\nusing this:\n  {y. real_of_1 (p, l, r) \\<le> y \\<and>\n      y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0} =\n  {real_of_1 (p, l, r)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       real_of_1 (p, l, r) < x \\<Longrightarrow>\n       x \\<notin> {ra.\n                   real_of_1 (p, l, r) \\<le> ra \\<and>\n                   ra \\<le> real_of_rat r \\<and>\n                   poly (real_of_int_poly p) ra = 0}", "by auto"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) < ?x \\<Longrightarrow>\n  ?x \\<notin> {ra.\n               real_of_1 (p, l, r) \\<le> ra \\<and>\n               ra \\<le> real_of_rat r \\<and>\n               poly (real_of_int_poly p) ra = 0}\n\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p, l, r) \\<and>\n        poly (real_of_int_poly p) y = 0} =\n    {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "with rb"], ["proof (chain)\npicking this:\n  {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0} =\n  {y. y \\<le> real_of_1 (p, l, r) \\<and>\n      poly (real_of_int_poly p) y = 0} \\<union>\n  {y. real_of_1 (p, l, r) < y \\<and>\n      y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}\n  real_of_1 (p, l, r) < ?x \\<Longrightarrow>\n  ?x \\<notin> {ra.\n               real_of_1 (p, l, r) \\<le> ra \\<and>\n               ra \\<le> real_of_rat r \\<and>\n               poly (real_of_int_poly p) ra = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0} =\n  {y. y \\<le> real_of_1 (p, l, r) \\<and>\n      poly (real_of_int_poly p) y = 0} \\<union>\n  {y. real_of_1 (p, l, r) < y \\<and>\n      y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}\n  real_of_1 (p, l, r) < ?x \\<Longrightarrow>\n  ?x \\<notin> {ra.\n               real_of_1 (p, l, r) \\<le> ra \\<and>\n               ra \\<le> real_of_rat r \\<and>\n               poly (real_of_int_poly p) ra = 0}\n\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p, l, r) \\<and>\n        poly (real_of_int_poly p) y = 0} =\n    {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "by auto"], ["proof (state)\nthis:\n  {y. y \\<le> real_of_1 (p, l, r) \\<and> poly (real_of_int_poly p) y = 0} =\n  {y. y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_root_sub_interval:\n  assumes ur: \"unique_root (p,l,r)\"\n      and rc: \"root_cond (p,l',r') (the_unique_root (p,l,r))\"\n      and between: \"l \\<le> l'\" \"r' \\<le> r\"\n  shows \"unique_root (p,l',r')\"\n    and \"the_unique_root (p,l',r') = the_unique_root (p,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, l', r') x &&&\n    real_of_1 (p, l', r') = real_of_1 (p, l, r)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>!x. root_cond (p, l', r') x\n 2. real_of_1 (p, l', r') = real_of_1 (p, l, r)", "from between"], ["proof (chain)\npicking this:\n  l \\<le> l'\n  r' \\<le> r", "have ord: \"real_of_rat l \\<le> of_rat l'\" \"real_of_rat r' \\<le> of_rat r\""], ["proof (prove)\nusing this:\n  l \\<le> l'\n  r' \\<le> r\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> real_of_rat l' &&&\n    real_of_rat r' \\<le> real_of_rat r", "by (auto simp: of_rat_less_eq)"], ["proof (state)\nthis:\n  real_of_rat l \\<le> real_of_rat l'\n  real_of_rat r' \\<le> real_of_rat r\n\ngoal (2 subgoals):\n 1. \\<exists>!x. root_cond (p, l', r') x\n 2. real_of_1 (p, l', r') = real_of_1 (p, l, r)", "from rc"], ["proof (chain)\npicking this:\n  root_cond (p, l', r') (real_of_1 (p, l, r))", "have lr': \"real_of_rat l' \\<le> of_rat r'\""], ["proof (prove)\nusing this:\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. real_of_rat l' \\<le> real_of_rat r'", "by auto"], ["proof (state)\nthis:\n  real_of_rat l' \\<le> real_of_rat r'\n\ngoal (2 subgoals):\n 1. \\<exists>!x. root_cond (p, l', r') x\n 2. real_of_1 (p, l', r') = real_of_1 (p, l, r)", "with ord"], ["proof (chain)\npicking this:\n  real_of_rat l \\<le> real_of_rat l'\n  real_of_rat r' \\<le> real_of_rat r\n  real_of_rat l' \\<le> real_of_rat r'", "have lr: \"real_of_rat l \\<le> real_of_rat r\""], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> real_of_rat l'\n  real_of_rat r' \\<le> real_of_rat r\n  real_of_rat l' \\<le> real_of_rat r'\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> real_of_rat r", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> real_of_rat r\n\ngoal (2 subgoals):\n 1. \\<exists>!x. root_cond (p, l', r') x\n 2. real_of_1 (p, l', r') = real_of_1 (p, l, r)", "show \"\\<exists>!x. root_cond (p, l', r') x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, l', r') x", "proof (rule, rule rc)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (p, l', r') x \\<Longrightarrow> x = real_of_1 (p, l, r)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (p, l', r') x \\<Longrightarrow> x = real_of_1 (p, l, r)", "assume \"root_cond (p,l',r') y\""], ["proof (state)\nthis:\n  root_cond (p, l', r') y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (p, l', r') x \\<Longrightarrow> x = real_of_1 (p, l, r)", "with ord"], ["proof (chain)\npicking this:\n  real_of_rat l \\<le> real_of_rat l'\n  real_of_rat r' \\<le> real_of_rat r\n  root_cond (p, l', r') y", "have \"root_cond (p,l,r) y\""], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> real_of_rat l'\n  real_of_rat r' \\<le> real_of_rat r\n  root_cond (p, l', r') y\n\ngoal (1 subgoal):\n 1. root_cond (p, l, r) y", "by (auto intro!:root_condI)"], ["proof (state)\nthis:\n  root_cond (p, l, r) y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (p, l', r') x \\<Longrightarrow> x = real_of_1 (p, l, r)", "from the_unique_root_eqI[OF ur this]"], ["proof (chain)\npicking this:\n  y = real_of_1 (p, l, r)\n  real_of_1 (p, l, r) = y", "show \"y = the_unique_root (p,l,r)\""], ["proof (prove)\nusing this:\n  y = real_of_1 (p, l, r)\n  real_of_1 (p, l, r) = y\n\ngoal (1 subgoal):\n 1. y = real_of_1 (p, l, r)", "by simp"], ["proof (state)\nthis:\n  y = real_of_1 (p, l, r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, l', r') x\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l', r') = real_of_1 (p, l, r)", "from the_unique_root_eqI[OF this rc]"], ["proof (chain)\npicking this:\n  real_of_1 (p, l, r) = real_of_1 (p, l', r')\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)", "show \"the_unique_root (p,l',r') = the_unique_root (p,l,r)\""], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) = real_of_1 (p, l', r')\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l', r') = real_of_1 (p, l, r)", "by simp"], ["proof (state)\nthis:\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invariant_1_sub_interval:\n  assumes rc: \"invariant_1 (p,l,r)\"\n      and sub: \"root_cond (p,l',r') (the_unique_root (p,l,r))\"\n      and between: \"l \\<le> l'\" \"r' \\<le> r\"\n  shows \"invariant_1 (p,l',r')\" and \"real_of_1 (p,l',r') = real_of_1 (p,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1 (p, l', r') &&& real_of_1 (p, l', r') = real_of_1 (p, l, r)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. invariant_1 (p, l', r')\n 2. real_of_1 (p, l', r') = real_of_1 (p, l, r)", "let ?r = real_of_rat"], ["proof (state)\ngoal (2 subgoals):\n 1. invariant_1 (p, l', r')\n 2. real_of_1 (p, l', r') = real_of_1 (p, l, r)", "note rcD = invariant_1D[OF rc]"], ["proof (state)\nthis:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (2 subgoals):\n 1. invariant_1 (p, l', r')\n 2. real_of_1 (p, l', r') = real_of_1 (p, l, r)", "from rc"], ["proof (chain)\npicking this:\n  invariant_1 (p, l, r)", "have ur: \"unique_root (p, l', r')\"\n    and id: \"the_unique_root (p, l', r') = the_unique_root (p, l, r)\""], ["proof (prove)\nusing this:\n  invariant_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, l', r') x &&&\n    real_of_1 (p, l', r') = real_of_1 (p, l, r)", "by (atomize(full), intro conjI unique_root_sub_interval[OF _ sub between], auto)"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, l', r') x\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n\ngoal (2 subgoals):\n 1. invariant_1 (p, l', r')\n 2. real_of_1 (p, l', r') = real_of_1 (p, l, r)", "show \"real_of_1 (p,l',r') = real_of_1 (p,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 (p, l', r') = real_of_1 (p, l, r)", "using id"], ["proof (prove)\nusing this:\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l', r') = real_of_1 (p, l, r)", "by simp"], ["proof (state)\nthis:\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l', r')", "from rcD(1)[unfolded split]"], ["proof (chain)\npicking this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))", "have \"?r l \\<le> ?r r\""], ["proof (prove)\nusing this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> real_of_rat r", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l', r')", "hence lr: \"l \\<le> r\""], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. l \\<le> r", "by (auto simp: of_rat_less_eq)"], ["proof (state)\nthis:\n  l \\<le> r\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l', r')", "from unique_rootD[OF ur]"], ["proof (chain)\npicking this:\n  real_of_rat (rai_lb (p, l', r')) \\<le> real_of_1 (p, l', r')\n  real_of_1 (p, l', r') \\<le> real_of_rat (rai_ub (p, l', r'))\n  poly (real_of_int_poly (poly_real_alg_1 (p, l', r')))\n   (real_of_1 (p, l', r')) =\n  0\n  root_cond (p, l', r') (real_of_1 (p, l', r'))\n  (real_of_1 (p, l', r') = ?y) = root_cond (p, l', r') ?y\n  (?y = real_of_1 (p, l', r')) = root_cond (p, l', r') ?y", "have \"?r l' \\<le> ?r r'\""], ["proof (prove)\nusing this:\n  real_of_rat (rai_lb (p, l', r')) \\<le> real_of_1 (p, l', r')\n  real_of_1 (p, l', r') \\<le> real_of_rat (rai_ub (p, l', r'))\n  poly (real_of_int_poly (poly_real_alg_1 (p, l', r')))\n   (real_of_1 (p, l', r')) =\n  0\n  root_cond (p, l', r') (real_of_1 (p, l', r'))\n  (real_of_1 (p, l', r') = ?y) = root_cond (p, l', r') ?y\n  (?y = real_of_1 (p, l', r')) = root_cond (p, l', r') ?y\n\ngoal (1 subgoal):\n 1. real_of_rat l' \\<le> real_of_rat r'", "by auto"], ["proof (state)\nthis:\n  real_of_rat l' \\<le> real_of_rat r'\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l', r')", "hence lr': \"l' \\<le> r'\""], ["proof (prove)\nusing this:\n  real_of_rat l' \\<le> real_of_rat r'\n\ngoal (1 subgoal):\n 1. l' \\<le> r'", "by (auto simp: of_rat_less_eq)"], ["proof (state)\nthis:\n  l' \\<le> r'\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l', r')", "have \"sgn l' = sgn r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn l' = sgn r'", "proof (cases \"r\" \"0::rat\" rule: linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. r < 0 \\<Longrightarrow> sgn l' = sgn r'\n 2. r = 0 \\<Longrightarrow> sgn l' = sgn r'\n 3. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "case less"], ["proof (state)\nthis:\n  r < 0\n\ngoal (3 subgoals):\n 1. r < 0 \\<Longrightarrow> sgn l' = sgn r'\n 2. r = 0 \\<Longrightarrow> sgn l' = sgn r'\n 3. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "with lr lr' between"], ["proof (chain)\npicking this:\n  l \\<le> r\n  l' \\<le> r'\n  l \\<le> l'\n  r' \\<le> r\n  r < 0", "have \"l < 0\" \"l' < 0\" \"r' < 0\" \"r < 0\""], ["proof (prove)\nusing this:\n  l \\<le> r\n  l' \\<le> r'\n  l \\<le> l'\n  r' \\<le> r\n  r < 0\n\ngoal (1 subgoal):\n 1. (l < 0 &&& l' < 0) &&& r' < 0 &&& r < 0", "by auto"], ["proof (state)\nthis:\n  l < 0\n  l' < 0\n  r' < 0\n  r < 0\n\ngoal (3 subgoals):\n 1. r < 0 \\<Longrightarrow> sgn l' = sgn r'\n 2. r = 0 \\<Longrightarrow> sgn l' = sgn r'\n 3. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "thus ?thesis"], ["proof (prove)\nusing this:\n  l < 0\n  l' < 0\n  r' < 0\n  r < 0\n\ngoal (1 subgoal):\n 1. sgn l' = sgn r'", "unfolding sgn_rat_def"], ["proof (prove)\nusing this:\n  l < 0\n  l' < 0\n  r' < 0\n  r < 0\n\ngoal (1 subgoal):\n 1. (if l' = 0 then 0 else if 0 < l' then 1 else - 1) =\n    (if r' = 0 then 0 else if 0 < r' then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  sgn l' = sgn r'\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> sgn l' = sgn r'\n 2. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> sgn l' = sgn r'\n 2. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "case equal"], ["proof (state)\nthis:\n  r = 0\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> sgn l' = sgn r'\n 2. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "with rcD(2)"], ["proof (chain)\npicking this:\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  r = 0", "have \"l = 0\""], ["proof (prove)\nusing this:\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  r = 0\n\ngoal (1 subgoal):\n 1. l = 0", "using sgn_0_0"], ["proof (prove)\nusing this:\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  r = 0\n  (sgn ?a = (0::?'a)) = (?a = (0::?'a))\n\ngoal (1 subgoal):\n 1. l = 0", "by auto"], ["proof (state)\nthis:\n  l = 0\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> sgn l' = sgn r'\n 2. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "with equal between lr'"], ["proof (chain)\npicking this:\n  r = 0\n  l \\<le> l'\n  r' \\<le> r\n  l' \\<le> r'\n  l = 0", "have \"l' = 0\" \"r' = 0\""], ["proof (prove)\nusing this:\n  r = 0\n  l \\<le> l'\n  r' \\<le> r\n  l' \\<le> r'\n  l = 0\n\ngoal (1 subgoal):\n 1. l' = 0 &&& r' = 0", "by auto"], ["proof (state)\nthis:\n  l' = 0\n  r' = 0\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow> sgn l' = sgn r'\n 2. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "then"], ["proof (chain)\npicking this:\n  l' = 0\n  r' = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  l' = 0\n  r' = 0\n\ngoal (1 subgoal):\n 1. sgn l' = sgn r'", "by auto"], ["proof (state)\nthis:\n  sgn l' = sgn r'\n\ngoal (1 subgoal):\n 1. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "case greater"], ["proof (state)\nthis:\n  0 < r\n\ngoal (1 subgoal):\n 1. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "with rcD(4)"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond (p, l, r) x\n  0 < r", "have \"sgn r = 1\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond (p, l, r) x\n  0 < r\n\ngoal (1 subgoal):\n 1. sgn r = 1", "unfolding sgn_rat_def"], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond (p, l, r) x\n  0 < r\n\ngoal (1 subgoal):\n 1. (if r = 0 then 0 else if 0 < r then 1 else - 1) = 1", "by (cases \"r = 0\", auto)"], ["proof (state)\nthis:\n  sgn r = 1\n\ngoal (1 subgoal):\n 1. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "with rcD(2)"], ["proof (chain)\npicking this:\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn r = 1", "have \"sgn l = 1\""], ["proof (prove)\nusing this:\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn r = 1\n\ngoal (1 subgoal):\n 1. sgn l = 1", "by simp"], ["proof (state)\nthis:\n  sgn l = 1\n\ngoal (1 subgoal):\n 1. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "hence l: \"l > 0\""], ["proof (prove)\nusing this:\n  sgn l = 1\n\ngoal (1 subgoal):\n 1. 0 < l", "unfolding sgn_rat_def"], ["proof (prove)\nusing this:\n  (if l = 0 then 0 else if 0 < l then 1 else - 1) = 1\n\ngoal (1 subgoal):\n 1. 0 < l", "by (cases \"l = 0\"; cases \"l < 0\"; auto)"], ["proof (state)\nthis:\n  0 < l\n\ngoal (1 subgoal):\n 1. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "with lr lr' between"], ["proof (chain)\npicking this:\n  l \\<le> r\n  l' \\<le> r'\n  l \\<le> l'\n  r' \\<le> r\n  0 < l", "have \"l > 0\" \"l' > 0\" \"r' > 0\" \"r > 0\""], ["proof (prove)\nusing this:\n  l \\<le> r\n  l' \\<le> r'\n  l \\<le> l'\n  r' \\<le> r\n  0 < l\n\ngoal (1 subgoal):\n 1. (0 < l &&& 0 < l') &&& 0 < r' &&& 0 < r", "by auto"], ["proof (state)\nthis:\n  0 < l\n  0 < l'\n  0 < r'\n  0 < r\n\ngoal (1 subgoal):\n 1. 0 < r \\<Longrightarrow> sgn l' = sgn r'", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < l\n  0 < l'\n  0 < r'\n  0 < r\n\ngoal (1 subgoal):\n 1. sgn l' = sgn r'", "unfolding sgn_rat_def"], ["proof (prove)\nusing this:\n  0 < l\n  0 < l'\n  0 < r'\n  0 < r\n\ngoal (1 subgoal):\n 1. (if l' = 0 then 0 else if 0 < l' then 1 else - 1) =\n    (if r' = 0 then 0 else if 0 < r' then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  sgn l' = sgn r'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgn l' = sgn r'\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l', r')", "with between ur rc"], ["proof (chain)\npicking this:\n  l \\<le> l'\n  r' \\<le> r\n  \\<exists>!x. root_cond (p, l', r') x\n  invariant_1 (p, l, r)\n  sgn l' = sgn r'", "show \"invariant_1 (p,l',r')\""], ["proof (prove)\nusing this:\n  l \\<le> l'\n  r' \\<le> r\n  \\<exists>!x. root_cond (p, l', r') x\n  invariant_1 (p, l, r)\n  sgn l' = sgn r'\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l', r')", "by (auto simp add: invariant_1_def id)"], ["proof (state)\nthis:\n  invariant_1 (p, l', r')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_sign_change: assumes\n    p0: \"poly (p::real poly) x = 0\" and\n    pd_ne0: \"poly (pderiv p) x \\<noteq> 0\"\n  obtains d where\n    \"0 < d\"\n    \"sgn (poly p (x - d)) \\<noteq> sgn (poly p (x + d))\"\n    \"sgn (poly p (x - d)) \\<noteq> 0\"\n    \"0 \\<noteq> sgn (poly p (x + d))\"\n    \"\\<forall> d' > 0. d' \\<le> d \\<longrightarrow> sgn (poly p (x + d')) = sgn (poly p (x + d)) \\<and> sgn (poly p (x - d')) = sgn (poly p (x - d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>0 < d; sgn (poly p (x - d)) \\<noteq> sgn (poly p (x + d));\n         sgn (poly p (x - d)) \\<noteq> 0; 0 \\<noteq> sgn (poly p (x + d));\n         \\<forall>d'>0.\n            d' \\<le> d \\<longrightarrow>\n            sgn (poly p (x + d')) = sgn (poly p (x + d)) \\<and>\n            sgn (poly p (x - d')) = sgn (poly p (x - d))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>0 < d; sgn (poly p (x - d)) \\<noteq> sgn (poly p (x + d));\n         sgn (poly p (x - d)) \\<noteq> 0; 0 \\<noteq> sgn (poly p (x + d));\n         \\<forall>d'>0.\n            d' \\<le> d \\<longrightarrow>\n            sgn (poly p (x + d')) = sgn (poly p (x + d)) \\<and>\n            sgn (poly p (x - d')) = sgn (poly p (x - d))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume a:\"(\\<And>d. 0 < d \\<Longrightarrow>\n          sgn (poly p (x - d)) \\<noteq> sgn (poly p (x + d)) \\<Longrightarrow>\n          sgn (poly p (x - d)) \\<noteq> 0 \\<Longrightarrow>\n          0 \\<noteq> sgn (poly p (x + d)) \\<Longrightarrow>\n          \\<forall>d'>0. d' \\<le> d \\<longrightarrow>\n                 sgn (poly p (x + d')) = sgn (poly p (x + d)) \\<and> sgn (poly p (x - d')) = sgn (poly p (x - d)) \\<Longrightarrow>\n          thesis)\""], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?d; sgn (poly p (x - ?d)) \\<noteq> sgn (poly p (x + ?d));\n   sgn (poly p (x - ?d)) \\<noteq> 0; 0 \\<noteq> sgn (poly p (x + ?d));\n   \\<forall>d'>0.\n      d' \\<le> ?d \\<longrightarrow>\n      sgn (poly p (x + d')) = sgn (poly p (x + ?d)) \\<and>\n      sgn (poly p (x - d')) = sgn (poly p (x - ?d))\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>0 < d; sgn (poly p (x - d)) \\<noteq> sgn (poly p (x + d));\n         sgn (poly p (x - d)) \\<noteq> 0; 0 \\<noteq> sgn (poly p (x + d));\n         \\<forall>d'>0.\n            d' \\<le> d \\<longrightarrow>\n            sgn (poly p (x + d')) = sgn (poly p (x + d)) \\<and>\n            sgn (poly p (x - d')) = sgn (poly p (x - d))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from pd_ne0"], ["proof (chain)\npicking this:\n  poly (pderiv p) x \\<noteq> 0", "consider \"poly (pderiv p) x > 0\" | \"poly (pderiv p) x < 0\""], ["proof (prove)\nusing this:\n  poly (pderiv p) x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < poly (pderiv p) x \\<Longrightarrow> thesis;\n     poly (pderiv p) x < 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>0 < poly (pderiv p) x \\<Longrightarrow> ?thesis;\n   poly (pderiv p) x < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>0 < d; sgn (poly p (x - d)) \\<noteq> sgn (poly p (x + d));\n         sgn (poly p (x - d)) \\<noteq> 0; 0 \\<noteq> sgn (poly p (x + d));\n         \\<forall>d'>0.\n            d' \\<le> d \\<longrightarrow>\n            sgn (poly p (x + d')) = sgn (poly p (x + d)) \\<and>\n            sgn (poly p (x - d')) = sgn (poly p (x - d))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < poly (pderiv p) x \\<Longrightarrow> ?thesis;\n   poly (pderiv p) x < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < poly (pderiv p) x \\<Longrightarrow> thesis\n 2. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "case 1"], ["proof (state)\nthis:\n  0 < poly (pderiv p) x\n\ngoal (2 subgoals):\n 1. 0 < poly (pderiv p) x \\<Longrightarrow> thesis\n 2. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "obtain d1 where d1:\"\\<And>h. 0<h \\<Longrightarrow> h < d1 \\<Longrightarrow> poly p (x - h) < 0\" \"d1 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d1.\n        \\<lbrakk>\\<And>h.\n                    \\<lbrakk>0 < h; h < d1\\<rbrakk>\n                    \\<Longrightarrow> poly p (x - h) < 0;\n         0 < d1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using DERIV_pos_inc_left[OF poly_DERIV 1] p0"], ["proof (prove)\nusing this:\n  \\<exists>d>0.\n     \\<forall>h>0. h < d \\<longrightarrow> poly p (x - h) < poly p x\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>d1.\n        \\<lbrakk>\\<And>h.\n                    \\<lbrakk>0 < h; h < d1\\<rbrakk>\n                    \\<Longrightarrow> poly p (x - h) < 0;\n         0 < d1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?h; ?h < d1\\<rbrakk> \\<Longrightarrow> poly p (x - ?h) < 0\n  0 < d1\n\ngoal (2 subgoals):\n 1. 0 < poly (pderiv p) x \\<Longrightarrow> thesis\n 2. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "obtain d2 where d2:\"\\<And>h. 0<h \\<Longrightarrow> h < d2 \\<Longrightarrow> poly p (x + h) > 0\" \"d2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d2.\n        \\<lbrakk>\\<And>h.\n                    \\<lbrakk>0 < h; h < d2\\<rbrakk>\n                    \\<Longrightarrow> 0 < poly p (x + h);\n         0 < d2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using DERIV_pos_inc_right[OF poly_DERIV 1] p0"], ["proof (prove)\nusing this:\n  \\<exists>d>0.\n     \\<forall>h>0. h < d \\<longrightarrow> poly p x < poly p (x + h)\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>d2.\n        \\<lbrakk>\\<And>h.\n                    \\<lbrakk>0 < h; h < d2\\<rbrakk>\n                    \\<Longrightarrow> 0 < poly p (x + h);\n         0 < d2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?h; ?h < d2\\<rbrakk> \\<Longrightarrow> 0 < poly p (x + ?h)\n  0 < d2\n\ngoal (2 subgoals):\n 1. 0 < poly (pderiv p) x \\<Longrightarrow> thesis\n 2. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "have g0:\"0 < (min d1 d2) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < min d1 d2 / 2", "using d1 d2"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?h; ?h < d1\\<rbrakk> \\<Longrightarrow> poly p (x - ?h) < 0\n  0 < d1\n  \\<lbrakk>0 < ?h; ?h < d2\\<rbrakk> \\<Longrightarrow> 0 < poly p (x + ?h)\n  0 < d2\n\ngoal (1 subgoal):\n 1. 0 < min d1 d2 / 2", "by auto"], ["proof (state)\nthis:\n  0 < min d1 d2 / 2\n\ngoal (2 subgoals):\n 1. 0 < poly (pderiv p) x \\<Longrightarrow> thesis\n 2. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "hence m1:\"min d1 d2 / 2 < d1\" and m2:\"min d1 d2 / 2 < d2\""], ["proof (prove)\nusing this:\n  0 < min d1 d2 / 2\n\ngoal (1 subgoal):\n 1. min d1 d2 / 2 < d1 &&& min d1 d2 / 2 < d2", "by auto"], ["proof (state)\nthis:\n  min d1 d2 / 2 < d1\n  min d1 d2 / 2 < d2\n\ngoal (2 subgoals):\n 1. 0 < poly (pderiv p) x \\<Longrightarrow> thesis\n 2. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "{"], ["proof (state)\nthis:\n  min d1 d2 / 2 < d1\n  min d1 d2 / 2 < d2\n\ngoal (2 subgoals):\n 1. 0 < poly (pderiv p) x \\<Longrightarrow> thesis\n 2. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "fix d"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < poly (pderiv p) x \\<Longrightarrow> thesis\n 2. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "assume a1:\"0 < d\" and a2:\"d < min d1 d2\""], ["proof (state)\nthis:\n  0 < d\n  d < min d1 d2\n\ngoal (2 subgoals):\n 1. 0 < poly (pderiv p) x \\<Longrightarrow> thesis\n 2. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "have \"sgn (poly p (x - d)) = -1\" \"sgn (poly p (x + d)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly p (x - d)) = - 1 &&& sgn (poly p (x + d)) = 1", "using d1(1)[OF a1] d2(1)[OF a1] a2"], ["proof (prove)\nusing this:\n  d < d1 \\<Longrightarrow> poly p (x - d) < 0\n  d < d2 \\<Longrightarrow> 0 < poly p (x + d)\n  d < min d1 d2\n\ngoal (1 subgoal):\n 1. sgn (poly p (x - d)) = - 1 &&& sgn (poly p (x + d)) = 1", "by auto"], ["proof (state)\nthis:\n  sgn (poly p (x - d)) = - 1\n  sgn (poly p (x + d)) = 1\n\ngoal (2 subgoals):\n 1. 0 < poly (pderiv p) x \\<Longrightarrow> thesis\n 2. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?d2; ?d2 < min d1 d2\\<rbrakk>\n  \\<Longrightarrow> sgn (poly p (x - ?d2)) = - 1\n  \\<lbrakk>0 < ?d2; ?d2 < min d1 d2\\<rbrakk>\n  \\<Longrightarrow> sgn (poly p (x + ?d2)) = 1\n\ngoal (2 subgoals):\n 1. 0 < poly (pderiv p) x \\<Longrightarrow> thesis\n 2. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "note d=this"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?d2; ?d2 < min d1 d2\\<rbrakk>\n  \\<Longrightarrow> sgn (poly p (x - ?d2)) = - 1\n  \\<lbrakk>0 < ?d2; ?d2 < min d1 d2\\<rbrakk>\n  \\<Longrightarrow> sgn (poly p (x + ?d2)) = 1\n\ngoal (2 subgoals):\n 1. 0 < poly (pderiv p) x \\<Longrightarrow> thesis\n 2. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by(rule a[OF g0];insert d g0 m1 m2, simp)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "case 2"], ["proof (state)\nthis:\n  poly (pderiv p) x < 0\n\ngoal (1 subgoal):\n 1. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "obtain d1 where d1:\"\\<And>h. 0<h \\<Longrightarrow> h < d1 \\<Longrightarrow> poly p (x - h) > 0\" \"d1 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d1.\n        \\<lbrakk>\\<And>h.\n                    \\<lbrakk>0 < h; h < d1\\<rbrakk>\n                    \\<Longrightarrow> 0 < poly p (x - h);\n         0 < d1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using DERIV_neg_dec_left[OF poly_DERIV 2] p0"], ["proof (prove)\nusing this:\n  \\<exists>d>0.\n     \\<forall>h>0. h < d \\<longrightarrow> poly p x < poly p (x - h)\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>d1.\n        \\<lbrakk>\\<And>h.\n                    \\<lbrakk>0 < h; h < d1\\<rbrakk>\n                    \\<Longrightarrow> 0 < poly p (x - h);\n         0 < d1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?h; ?h < d1\\<rbrakk> \\<Longrightarrow> 0 < poly p (x - ?h)\n  0 < d1\n\ngoal (1 subgoal):\n 1. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "obtain d2 where d2:\"\\<And>h. 0<h \\<Longrightarrow> h < d2 \\<Longrightarrow> poly p (x + h) < 0\" \"d2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d2.\n        \\<lbrakk>\\<And>h.\n                    \\<lbrakk>0 < h; h < d2\\<rbrakk>\n                    \\<Longrightarrow> poly p (x + h) < 0;\n         0 < d2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using DERIV_neg_dec_right[OF poly_DERIV 2] p0"], ["proof (prove)\nusing this:\n  \\<exists>d>0.\n     \\<forall>h>0. h < d \\<longrightarrow> poly p (x + h) < poly p x\n  poly p x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>d2.\n        \\<lbrakk>\\<And>h.\n                    \\<lbrakk>0 < h; h < d2\\<rbrakk>\n                    \\<Longrightarrow> poly p (x + h) < 0;\n         0 < d2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?h; ?h < d2\\<rbrakk> \\<Longrightarrow> poly p (x + ?h) < 0\n  0 < d2\n\ngoal (1 subgoal):\n 1. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "have g0:\"0 < (min d1 d2) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < min d1 d2 / 2", "using d1 d2"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?h; ?h < d1\\<rbrakk> \\<Longrightarrow> 0 < poly p (x - ?h)\n  0 < d1\n  \\<lbrakk>0 < ?h; ?h < d2\\<rbrakk> \\<Longrightarrow> poly p (x + ?h) < 0\n  0 < d2\n\ngoal (1 subgoal):\n 1. 0 < min d1 d2 / 2", "by auto"], ["proof (state)\nthis:\n  0 < min d1 d2 / 2\n\ngoal (1 subgoal):\n 1. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "hence m1:\"min d1 d2 / 2 < d1\" and m2:\"min d1 d2 / 2 < d2\""], ["proof (prove)\nusing this:\n  0 < min d1 d2 / 2\n\ngoal (1 subgoal):\n 1. min d1 d2 / 2 < d1 &&& min d1 d2 / 2 < d2", "by auto"], ["proof (state)\nthis:\n  min d1 d2 / 2 < d1\n  min d1 d2 / 2 < d2\n\ngoal (1 subgoal):\n 1. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "{"], ["proof (state)\nthis:\n  min d1 d2 / 2 < d1\n  min d1 d2 / 2 < d2\n\ngoal (1 subgoal):\n 1. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "assume a1:\"0 < d\" and a2:\"d < min d1 d2\""], ["proof (state)\nthis:\n  0 < d\n  d < min d1 d2\n\ngoal (1 subgoal):\n 1. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "have \"sgn (poly p (x - d)) = 1\" \"sgn (poly p (x + d)) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly p (x - d)) = 1 &&& sgn (poly p (x + d)) = - 1", "using d1(1)[OF a1] d2(1)[OF a1] a2"], ["proof (prove)\nusing this:\n  d < d1 \\<Longrightarrow> 0 < poly p (x - d)\n  d < d2 \\<Longrightarrow> poly p (x + d) < 0\n  d < min d1 d2\n\ngoal (1 subgoal):\n 1. sgn (poly p (x - d)) = 1 &&& sgn (poly p (x + d)) = - 1", "by auto"], ["proof (state)\nthis:\n  sgn (poly p (x - d)) = 1\n  sgn (poly p (x + d)) = - 1\n\ngoal (1 subgoal):\n 1. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?d2; ?d2 < min d1 d2\\<rbrakk>\n  \\<Longrightarrow> sgn (poly p (x - ?d2)) = 1\n  \\<lbrakk>0 < ?d2; ?d2 < min d1 d2\\<rbrakk>\n  \\<Longrightarrow> sgn (poly p (x + ?d2)) = - 1\n\ngoal (1 subgoal):\n 1. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "note d=this"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?d2; ?d2 < min d1 d2\\<rbrakk>\n  \\<Longrightarrow> sgn (poly p (x - ?d2)) = 1\n  \\<lbrakk>0 < ?d2; ?d2 < min d1 d2\\<rbrakk>\n  \\<Longrightarrow> sgn (poly p (x + ?d2)) = - 1\n\ngoal (1 subgoal):\n 1. poly (pderiv p) x < 0 \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by(rule a[OF g0];insert d g0 m1 m2, simp)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rational_root_free_degree_iff: assumes rf: \"root_free (map_poly rat_of_int p)\" and rt: \"ipoly p x = 0\"\n  shows \"(x \\<in> \\<rat>) = (degree p = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> \\<rat>) = (degree p = 1)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> \\<rat> \\<Longrightarrow> degree p = 1\n 2. degree p = 1 \\<Longrightarrow> x \\<in> \\<rat>", "assume \"x \\<in> \\<rat>\""], ["proof (state)\nthis:\n  x \\<in> \\<rat>\n\ngoal (2 subgoals):\n 1. x \\<in> \\<rat> \\<Longrightarrow> degree p = 1\n 2. degree p = 1 \\<Longrightarrow> x \\<in> \\<rat>", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<rat>", "obtain y where x: \"x = of_rat y\" (is \"_ = ?x\")"], ["proof (prove)\nusing this:\n  x \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. (\\<And>y. x = of_rat y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Rats_def"], ["proof (prove)\nusing this:\n  x \\<in> range of_rat\n\ngoal (1 subgoal):\n 1. (\\<And>y. x = of_rat y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = of_rat y\n\ngoal (2 subgoals):\n 1. x \\<in> \\<rat> \\<Longrightarrow> degree p = 1\n 2. degree p = 1 \\<Longrightarrow> x \\<in> \\<rat>", "from rt[unfolded x]"], ["proof (chain)\npicking this:\n  ipoly p (of_rat y) = (0::'a)", "have \"poly (map_poly rat_of_int p) y = 0\""], ["proof (prove)\nusing this:\n  ipoly p (of_rat y) = (0::'a)\n\ngoal (1 subgoal):\n 1. ipoly p y = 0", "by simp"], ["proof (state)\nthis:\n  ipoly p y = 0\n\ngoal (2 subgoals):\n 1. x \\<in> \\<rat> \\<Longrightarrow> degree p = 1\n 2. degree p = 1 \\<Longrightarrow> x \\<in> \\<rat>", "with rf"], ["proof (chain)\npicking this:\n  root_free (of_int_poly p)\n  ipoly p y = 0", "show \"degree p = 1\""], ["proof (prove)\nusing this:\n  root_free (of_int_poly p)\n  ipoly p y = 0\n\ngoal (1 subgoal):\n 1. degree p = 1", "unfolding root_free_def"], ["proof (prove)\nusing this:\n  degree (of_int_poly p) = 1 \\<or> (\\<forall>x. ipoly p x \\<noteq> 0)\n  ipoly p y = 0\n\ngoal (1 subgoal):\n 1. degree p = 1", "by auto"], ["proof (state)\nthis:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. degree p = 1 \\<Longrightarrow> x \\<in> \\<rat>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p = 1 \\<Longrightarrow> x \\<in> \\<rat>", "assume \"degree p = 1\""], ["proof (state)\nthis:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. degree p = 1 \\<Longrightarrow> x \\<in> \\<rat>", "from degree1_coeffs[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>a b. p = [:b, a:] \\<and> a \\<noteq> 0", "obtain a b where p: \"p = [:a,b:]\" and b: \"b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>a b. p = [:b, a:] \\<and> a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>p = [:a, b:]; b \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = [:a, b:]\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p = 1 \\<Longrightarrow> x \\<in> \\<rat>", "from rt[unfolded p hom_distribs]"], ["proof (chain)\npicking this:\n  poly (pCons (of_int a) (pCons (of_int b) (of_int_poly 0))) x = (0::'a)", "have \"of_int a + x * of_int b = 0\""], ["proof (prove)\nusing this:\n  poly (pCons (of_int a) (pCons (of_int b) (of_int_poly 0))) x = (0::'a)\n\ngoal (1 subgoal):\n 1. of_int a + x * of_int b = (0::'a)", "by auto"], ["proof (state)\nthis:\n  of_int a + x * of_int b = (0::'a)\n\ngoal (1 subgoal):\n 1. degree p = 1 \\<Longrightarrow> x \\<in> \\<rat>", "from arg_cong[OF this, of \"\\<lambda> x. (x - of_int a) / of_int b\"]"], ["proof (chain)\npicking this:\n  (of_int a + x * of_int b - of_int a) / of_int b =\n  ((0::'a) - of_int a) / of_int b", "have \"x = - of_rat (of_int a) / of_rat (of_int b)\""], ["proof (prove)\nusing this:\n  (of_int a + x * of_int b - of_int a) / of_int b =\n  ((0::'a) - of_int a) / of_int b\n\ngoal (1 subgoal):\n 1. x = - of_rat (rat_of_int a) / of_rat (rat_of_int b)", "using b"], ["proof (prove)\nusing this:\n  (of_int a + x * of_int b - of_int a) / of_int b =\n  ((0::'a) - of_int a) / of_int b\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x = - of_rat (rat_of_int a) / of_rat (rat_of_int b)", "by auto"], ["proof (state)\nthis:\n  x = - of_rat (rat_of_int a) / of_rat (rat_of_int b)\n\ngoal (1 subgoal):\n 1. degree p = 1 \\<Longrightarrow> x \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  x = - of_rat (rat_of_int a) / of_rat (rat_of_int b)\n\ngoal (1 subgoal):\n 1. degree p = 1 \\<Longrightarrow> x \\<in> \\<rat>", "have \"\\<dots> = of_rat (- of_int a / of_int b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - of_rat (rat_of_int a) / of_rat (rat_of_int b) =\n    of_rat (- rat_of_int a / rat_of_int b)", "unfolding of_rat_minus of_rat_divide"], ["proof (prove)\ngoal (1 subgoal):\n 1. - of_rat (rat_of_int a) / of_rat (rat_of_int b) =\n    - of_rat (rat_of_int a) / of_rat (rat_of_int b)", ".."], ["proof (state)\nthis:\n  - of_rat (rat_of_int a) / of_rat (rat_of_int b) =\n  of_rat (- rat_of_int a / rat_of_int b)\n\ngoal (1 subgoal):\n 1. degree p = 1 \\<Longrightarrow> x \\<in> \\<rat>", "finally"], ["proof (chain)\npicking this:\n  x = of_rat (- rat_of_int a / rat_of_int b)", "show \"x \\<in> \\<rat>\""], ["proof (prove)\nusing this:\n  x = of_rat (- rat_of_int a / rat_of_int b)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<rat>", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<rat>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rational_poly_cond_iff: assumes \"poly_cond p\" and \"ipoly p x = 0\" and \"degree p > 1\"\n  shows \"(x \\<in> \\<rat>) = (degree p = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> \\<rat>) = (degree p = 1)", "proof (rule rational_root_free_degree_iff[OF _ assms(2)])"], ["proof (state)\ngoal (1 subgoal):\n 1. root_free (of_int_poly p)", "from poly_condD[OF assms(1)] irreducible_connect_rev[of p] assms(3)"], ["proof (chain)\npicking this:\n  irreducible p\n  0 < lead_coeff p\n  root_free p\n  square_free p\n  p \\<noteq> 0\n  \\<lbrakk>irreducible p; 0 < degree p\\<rbrakk>\n  \\<Longrightarrow> irreducible\\<^sub>d p\n  1 < degree p", "have p: \"irreducible\\<^sub>d p\""], ["proof (prove)\nusing this:\n  irreducible p\n  0 < lead_coeff p\n  root_free p\n  square_free p\n  p \\<noteq> 0\n  \\<lbrakk>irreducible p; 0 < degree p\\<rbrakk>\n  \\<Longrightarrow> irreducible\\<^sub>d p\n  1 < degree p\n\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "by auto"], ["proof (state)\nthis:\n  irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. root_free (of_int_poly p)", "from irreducible\\<^sub>d_int_rat[OF this]"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d (of_int_poly p)", "have \"irreducible (map_poly rat_of_int p)\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (of_int_poly p)\n\ngoal (1 subgoal):\n 1. irreducible (of_int_poly p)", "by simp"], ["proof (state)\nthis:\n  irreducible (of_int_poly p)\n\ngoal (1 subgoal):\n 1. root_free (of_int_poly p)", "thus \"root_free (map_poly rat_of_int p)\""], ["proof (prove)\nusing this:\n  irreducible (of_int_poly p)\n\ngoal (1 subgoal):\n 1. root_free (of_int_poly p)", "by (rule irreducible_root_free)"], ["proof (state)\nthis:\n  root_free (of_int_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_cond_degree_gt_1: assumes \"poly_cond p\" \"degree p > 1\" \"ipoly p x = 0\"\n  shows \"x \\<notin> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> \\<rat>", "using rational_poly_cond_iff[OF assms(1,3)] assms(2)"], ["proof (prove)\nusing this:\n  1 < degree p \\<Longrightarrow> (x \\<in> \\<rat>) = (degree p = 1)\n  1 < degree p\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<rat>", "by simp"], ["", "lemma poly_cond2_no_rat_root: assumes \"poly_cond2 p\" \n  shows \"ipoly p (real_of_rat x) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) (real_of_rat x) \\<noteq> 0", "using poly_cond_degree_gt_1[of p \"real_of_rat x\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>poly_cond p; 1 < degree p;\n   poly (real_of_int_poly p) (real_of_rat x) = 0\\<rbrakk>\n  \\<Longrightarrow> real_of_rat x \\<notin> \\<rat>\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) (real_of_rat x) \\<noteq> 0", "by auto"], ["", "context \n  fixes p :: \"int poly\"\n  and x :: \"rat\"\nbegin"], ["", "lemma gt_rat_sign_change:\n  assumes ur: \"unique_root plr\"\n  defines \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  assumes p: \"poly_cond2 p\" and in_interval: \"l \\<le> y\" \"y \\<le> r\"\nshows \"(sgn (ipoly p y) = sgn (ipoly p r)) = (of_rat y > the_unique_root plr)\" (is \"?gt = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) = (real_of_1 plr < real_of_rat y)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "have plr[simp]: \"plr = (p,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plr = (p, l, r)", "by (cases plr, auto simp: p_def l_def r_def)"], ["proof (state)\nthis:\n  plr = (p, l, r)\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "assume \"?gt \\<noteq> (real_of_rat y > the_unique_root plr)\""], ["proof (state)\nthis:\n  (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n  (real_of_1 plr < real_of_rat y)\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "note a = this[unfolded plr]"], ["proof (state)\nthis:\n  (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n  (real_of_1 (p, l, r) < real_of_rat y)\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "from p"], ["proof (chain)\npicking this:\n  poly_cond2 p", "have \"irreducible p\""], ["proof (prove)\nusing this:\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. irreducible p", "by auto"], ["proof (state)\nthis:\n  irreducible p\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "note nz = poly_cond2_no_rat_root[OF p]"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) (real_of_rat ?x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "hence \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (real_of_rat ?x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "unfolding irreducible_def"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (real_of_rat ?x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "hence p0_real: \"real_of_int_poly p \\<noteq> (0::real poly)\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_int_poly p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  real_of_int_poly p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "let ?p = \"real_of_int_poly p\""], ["proof (state)\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "note urD = unique_rootD[OF ur, simplified]"], ["proof (state)\nthis:\n  real_of_rat l \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat r\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "let ?ur = \"the_unique_root (p, l, r)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "let ?r = real_of_rat"], ["proof (state)\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "from poly_cond2_no_rat_root p"], ["proof (chain)\npicking this:\n  poly_cond2 ?p \\<Longrightarrow>\n  poly (real_of_int_poly ?p) (real_of_rat ?x) \\<noteq> 0\n  poly_cond2 p", "have ru:\"ipoly p y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly_cond2 ?p \\<Longrightarrow>\n  poly (real_of_int_poly ?p) (real_of_rat ?x) \\<noteq> 0\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. ipoly p y \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  ipoly p y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "from in_interval"], ["proof (chain)\npicking this:\n  l \\<le> y\n  y \\<le> r", "have in':\"?r l \\<le> ?r y\" \"?r y \\<le> ?r r\""], ["proof (prove)\nusing this:\n  l \\<le> y\n  y \\<le> r\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> real_of_rat y &&& real_of_rat y \\<le> real_of_rat r", "unfolding of_rat_less_eq"], ["proof (prove)\nusing this:\n  l \\<le> y\n  y \\<le> r\n\ngoal (1 subgoal):\n 1. l \\<le> y &&& y \\<le> r", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> real_of_rat y\n  real_of_rat y \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "from p square_free_of_int_poly[of p] square_free_rsquarefree"], ["proof (chain)\npicking this:\n  poly_cond2 p\n  square_free p \\<Longrightarrow> square_free (of_int_poly p)\n  square_free ?f \\<Longrightarrow> rsquarefree ?f", "have rsf:\"rsquarefree ?p\""], ["proof (prove)\nusing this:\n  poly_cond2 p\n  square_free p \\<Longrightarrow> square_free (of_int_poly p)\n  square_free ?f \\<Longrightarrow> rsquarefree ?f\n\ngoal (1 subgoal):\n 1. rsquarefree (real_of_int_poly p)", "by auto"], ["proof (state)\nthis:\n  rsquarefree (real_of_int_poly p)\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "have ur3:\"poly ?p ?ur = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0", "using urD(3)"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0", "by simp"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "from ur"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond plr x", "have \"?ur \\<le> of_rat r\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond plr x\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) \\<le> real_of_rat r", "by (auto elim!: unique_rootE)"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "from nz"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly p) (real_of_rat ?x) \\<noteq> 0", "have \"ipoly p (real_of_rat r) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (real_of_rat ?x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) (real_of_rat r) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) (real_of_rat r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "with ur3"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0\n  poly (real_of_int_poly p) (real_of_rat r) \\<noteq> 0", "have \"real_of_rat r \\<noteq> real_of_1 (p,l,r)\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0\n  poly (real_of_int_poly p) (real_of_rat r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_rat r \\<noteq> real_of_1 (p, l, r)", "by force"], ["proof (state)\nthis:\n  real_of_rat r \\<noteq> real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  real_of_1 (p, l, r) \\<le> real_of_rat r\n  real_of_rat r \\<noteq> real_of_1 (p, l, r)", "have \"?ur < ?r r\""], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) \\<le> real_of_rat r\n  real_of_rat r \\<noteq> real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) < real_of_rat r", "by auto"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) < real_of_rat r\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "hence ur2: \"0 < ?r r - ?ur\""], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) < real_of_rat r\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat r - real_of_1 (p, l, r)", "by linarith"], ["proof (state)\nthis:\n  0 < real_of_rat r - real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "from rsquarefree_roots rsf ur3"], ["proof (chain)\npicking this:\n  rsquarefree ?p =\n  (\\<forall>a.\n      \\<not> (poly ?p a = (0::?'a) \\<and> poly (pderiv ?p) a = (0::?'a)))\n  rsquarefree (real_of_int_poly p)\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0", "have pd_nonz:\"poly (pderiv ?p) ?ur \\<noteq> 0\""], ["proof (prove)\nusing this:\n  rsquarefree ?p =\n  (\\<forall>a.\n      \\<not> (poly ?p a = (0::?'a) \\<and> poly (pderiv ?p) a = (0::?'a)))\n  rsquarefree (real_of_int_poly p)\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0\n\ngoal (1 subgoal):\n 1. poly (pderiv (real_of_int_poly p)) (real_of_1 (p, l, r)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly (pderiv (real_of_int_poly p)) (real_of_1 (p, l, r)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "obtain d where d':\"\\<And>d'. d'>0 \\<Longrightarrow> d' \\<le> d \\<Longrightarrow>\n             sgn (poly ?p (?ur + d')) = sgn (poly ?p (?ur + d)) \\<and>\n             sgn (poly ?p (?ur - d')) = sgn (poly ?p (?ur - d))\"\n      \"sgn (poly ?p (?ur - d)) \\<noteq> sgn (poly ?p (?ur + d))\"\n      \"sgn (poly ?p (?ur + d)) \\<noteq> 0\"\n      and d_ge_0:\"d > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>\\<And>d'.\n                    \\<lbrakk>0 < d'; d' \\<le> d\\<rbrakk>\n                    \\<Longrightarrow> sgn\n (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d')) =\nsgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) \\<and>\nsgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d')) =\nsgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d));\n         sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) \\<noteq>\n         sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d));\n         sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) \\<noteq>\n         0;\n         0 < d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis root_sign_change[OF ur3 pd_nonz])"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?d'; ?d' \\<le> d\\<rbrakk>\n  \\<Longrightarrow> sgn (poly (real_of_int_poly p)\n                          (real_of_1 (p, l, r) + ?d')) =\n                    sgn (poly (real_of_int_poly p)\n                          (real_of_1 (p, l, r) + d)) \\<and>\n                    sgn (poly (real_of_int_poly p)\n                          (real_of_1 (p, l, r) - ?d')) =\n                    sgn (poly (real_of_int_poly p)\n                          (real_of_1 (p, l, r) - d))\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) \\<noteq>\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d))\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) \\<noteq> 0\n  0 < d\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "have sr:\"sgn (poly ?p (?ur + d)) = sgn (poly ?p (?r r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat r))", "proof (cases \"?r r - ?ur \\<le> d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. real_of_rat r - real_of_1 (p, l, r) \\<le> d \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat r))\n 2. \\<not> real_of_rat r - real_of_1 (p, l, r) \\<le> d \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat r))", "case True"], ["proof (state)\nthis:\n  real_of_rat r - real_of_1 (p, l, r) \\<le> d\n\ngoal (2 subgoals):\n 1. real_of_rat r - real_of_1 (p, l, r) \\<le> d \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat r))\n 2. \\<not> real_of_rat r - real_of_1 (p, l, r) \\<le> d \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat r))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat r))", "using d'(1)[OF ur2 True]"], ["proof (prove)\nusing this:\n  sgn (poly (real_of_int_poly p)\n        (real_of_1 (p, l, r) + (real_of_rat r - real_of_1 (p, l, r)))) =\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) \\<and>\n  sgn (poly (real_of_int_poly p)\n        (real_of_1 (p, l, r) - (real_of_rat r - real_of_1 (p, l, r)))) =\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d))\n\ngoal (1 subgoal):\n 1. sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat r))", "by auto"], ["proof (state)\nthis:\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n  sgn (poly (real_of_int_poly p) (real_of_rat r))\n\ngoal (1 subgoal):\n 1. \\<not> real_of_rat r - real_of_1 (p, l, r) \\<le> d \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat r))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> real_of_rat r - real_of_1 (p, l, r) \\<le> d \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat r))", "case False"], ["proof (state)\nthis:\n  \\<not> real_of_rat r - real_of_1 (p, l, r) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<not> real_of_rat r - real_of_1 (p, l, r) \\<le> d \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat r))", "hence less:\"?ur + d < ?r r\""], ["proof (prove)\nusing this:\n  \\<not> real_of_rat r - real_of_1 (p, l, r) \\<le> d\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) + d < real_of_rat r", "by auto"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) + d < real_of_rat r\n\ngoal (1 subgoal):\n 1. \\<not> real_of_rat r - real_of_1 (p, l, r) \\<le> d \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat r))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat r))", "proof(rule no_roots_inbetween_imp_same_sign[OF less,rule_format],goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       real_of_1 (p, l, r) + d \\<le> x \\<and>\n       x \\<le> real_of_rat r \\<Longrightarrow>\n       poly (real_of_int_poly p) x \\<noteq> 0", "case (1 x)"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) + d \\<le> x \\<and> x \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       real_of_1 (p, l, r) + d \\<le> x \\<and>\n       x \\<le> real_of_rat r \\<Longrightarrow>\n       poly (real_of_int_poly p) x \\<noteq> 0", "from ur 1 d_ge_0"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond plr x\n  real_of_1 (p, l, r) + d \\<le> x \\<and> x \\<le> real_of_rat r\n  0 < d", "have ran: \"real_of_rat l \\<le> x\" \"x \\<le> real_of_rat r\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond plr x\n  real_of_1 (p, l, r) + d \\<le> x \\<and> x \\<le> real_of_rat r\n  0 < d\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> x &&& x \\<le> real_of_rat r", "by (auto elim!: unique_rootE)"], ["proof (state)\nthis:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       real_of_1 (p, l, r) + d \\<le> x \\<and>\n       x \\<le> real_of_rat r \\<Longrightarrow>\n       poly (real_of_int_poly p) x \\<noteq> 0", "from 1 d_ge_0"], ["proof (chain)\npicking this:\n  real_of_1 (p, l, r) + d \\<le> x \\<and> x \\<le> real_of_rat r\n  0 < d", "have \"the_unique_root (p, l, r) \\<noteq> x\""], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) + d \\<le> x \\<and> x \\<le> real_of_rat r\n  0 < d\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) \\<noteq> x", "by auto"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       real_of_1 (p, l, r) + d \\<le> x \\<and>\n       x \\<le> real_of_rat r \\<Longrightarrow>\n       poly (real_of_int_poly p) x \\<noteq> 0", "with ur"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond plr x\n  real_of_1 (p, l, r) \\<noteq> x", "have \"\\<not> root_cond (p,l,r) x\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond plr x\n  real_of_1 (p, l, r) \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<not> root_cond (p, l, r) x", "by auto"], ["proof (state)\nthis:\n  \\<not> root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       real_of_1 (p, l, r) + d \\<le> x \\<and>\n       x \\<le> real_of_rat r \\<Longrightarrow>\n       poly (real_of_int_poly p) x \\<noteq> 0", "with ran"], ["proof (chain)\npicking this:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  \\<not> root_cond (p, l, r) x", "show ?case"], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  \\<not> root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) x \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n  sgn (poly (real_of_int_poly p) (real_of_rat r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n  sgn (poly (real_of_int_poly p) (real_of_rat r))\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "consider \"?r l < ?ur - d\" \"?r l < ?ur\" | \"0 < ?ur - ?r l\" \"?ur - ?r l \\<le> d\" | \"?ur = ?r l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>real_of_rat l < real_of_1 (p, l, r) - d;\n              real_of_rat l < real_of_1 (p, l, r)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>0 < real_of_1 (p, l, r) - real_of_rat l;\n      real_of_1 (p, l, r) - real_of_rat l \\<le> d\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     real_of_1 (p, l, r) = real_of_rat l \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using urD"], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat r\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>real_of_rat l < real_of_1 (p, l, r) - d;\n              real_of_rat l < real_of_1 (p, l, r)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>0 < real_of_1 (p, l, r) - real_of_rat l;\n      real_of_1 (p, l, r) - real_of_rat l \\<le> d\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     real_of_1 (p, l, r) = real_of_rat l \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by argo"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>real_of_rat l < real_of_1 (p, l, r) - d;\n            real_of_rat l < real_of_1 (p, l, r)\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>0 < real_of_1 (p, l, r) - real_of_rat l;\n    real_of_1 (p, l, r) - real_of_rat l \\<le> d\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   real_of_1 (p, l, r) = real_of_rat l \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "hence sl:\"sgn (poly ?p (?ur - d)) = sgn (poly ?p (?r l)) \\<or> 0 = sgn (poly ?p (?r l))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>real_of_rat l < real_of_1 (p, l, r) - d;\n            real_of_rat l < real_of_1 (p, l, r)\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>0 < real_of_1 (p, l, r) - real_of_rat l;\n    real_of_1 (p, l, r) - real_of_rat l \\<le> d\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   real_of_1 (p, l, r) = real_of_rat l \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n    0 = sgn (poly (real_of_int_poly p) (real_of_rat l))", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>real_of_rat l < real_of_1 (p, l, r) - d;\n     real_of_rat l < real_of_1 (p, l, r)\\<rbrakk>\n    \\<Longrightarrow> sgn (poly (real_of_int_poly p)\n                            (real_of_1 (p, l, r) - d)) =\n                      sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n                      0 = sgn (poly (real_of_int_poly p) (real_of_rat l))\n 2. \\<lbrakk>0 < real_of_1 (p, l, r) - real_of_rat l;\n     real_of_1 (p, l, r) - real_of_rat l \\<le> d\\<rbrakk>\n    \\<Longrightarrow> sgn (poly (real_of_int_poly p)\n                            (real_of_1 (p, l, r) - d)) =\n                      sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n                      0 = sgn (poly (real_of_int_poly p) (real_of_rat l))\n 3. real_of_1 (p, l, r) = real_of_rat l \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n    0 = sgn (poly (real_of_int_poly p) (real_of_rat l))", "case 1"], ["proof (state)\nthis:\n  real_of_rat l < real_of_1 (p, l, r) - d\n  real_of_rat l < real_of_1 (p, l, r)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>real_of_rat l < real_of_1 (p, l, r) - d;\n     real_of_rat l < real_of_1 (p, l, r)\\<rbrakk>\n    \\<Longrightarrow> sgn (poly (real_of_int_poly p)\n                            (real_of_1 (p, l, r) - d)) =\n                      sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n                      0 = sgn (poly (real_of_int_poly p) (real_of_rat l))\n 2. \\<lbrakk>0 < real_of_1 (p, l, r) - real_of_rat l;\n     real_of_1 (p, l, r) - real_of_rat l \\<le> d\\<rbrakk>\n    \\<Longrightarrow> sgn (poly (real_of_int_poly p)\n                            (real_of_1 (p, l, r) - d)) =\n                      sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n                      0 = sgn (poly (real_of_int_poly p) (real_of_rat l))\n 3. real_of_1 (p, l, r) = real_of_rat l \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n    0 = sgn (poly (real_of_int_poly p) (real_of_rat l))", "have \"sgn (poly ?p (?r l)) = sgn (poly ?p (?ur - d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly (real_of_int_poly p) (real_of_rat l)) =\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d))", "proof(rule no_roots_inbetween_imp_same_sign[OF 1(1),rule_format],goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       real_of_rat l \\<le> x \\<and>\n       x \\<le> real_of_1 (p, l, r) - d \\<Longrightarrow>\n       poly (real_of_int_poly p) x \\<noteq> 0", "case (1 x)"], ["proof (state)\nthis:\n  real_of_rat l \\<le> x \\<and> x \\<le> real_of_1 (p, l, r) - d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       real_of_rat l \\<le> x \\<and>\n       x \\<le> real_of_1 (p, l, r) - d \\<Longrightarrow>\n       poly (real_of_int_poly p) x \\<noteq> 0", "from ur 1 d_ge_0"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond plr x\n  real_of_rat l \\<le> x \\<and> x \\<le> real_of_1 (p, l, r) - d\n  0 < d", "have ran: \"real_of_rat l \\<le> x\" \"x \\<le> real_of_rat r\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond plr x\n  real_of_rat l \\<le> x \\<and> x \\<le> real_of_1 (p, l, r) - d\n  0 < d\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> x &&& x \\<le> real_of_rat r", "by (auto elim!: unique_rootE)"], ["proof (state)\nthis:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       real_of_rat l \\<le> x \\<and>\n       x \\<le> real_of_1 (p, l, r) - d \\<Longrightarrow>\n       poly (real_of_int_poly p) x \\<noteq> 0", "from 1 d_ge_0"], ["proof (chain)\npicking this:\n  real_of_rat l \\<le> x \\<and> x \\<le> real_of_1 (p, l, r) - d\n  0 < d", "have \"the_unique_root (p, l, r) \\<noteq> x\""], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x \\<and> x \\<le> real_of_1 (p, l, r) - d\n  0 < d\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) \\<noteq> x", "by auto"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       real_of_rat l \\<le> x \\<and>\n       x \\<le> real_of_1 (p, l, r) - d \\<Longrightarrow>\n       poly (real_of_int_poly p) x \\<noteq> 0", "with ur"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond plr x\n  real_of_1 (p, l, r) \\<noteq> x", "have \"\\<not> root_cond (p,l,r) x\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond plr x\n  real_of_1 (p, l, r) \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<not> root_cond (p, l, r) x", "by auto"], ["proof (state)\nthis:\n  \\<not> root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       real_of_rat l \\<le> x \\<and>\n       x \\<le> real_of_1 (p, l, r) - d \\<Longrightarrow>\n       poly (real_of_int_poly p) x \\<noteq> 0", "with ran"], ["proof (chain)\npicking this:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  \\<not> root_cond (p, l, r) x", "show ?case"], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  \\<not> root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) x \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgn (poly (real_of_int_poly p) (real_of_rat l)) =\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>real_of_rat l < real_of_1 (p, l, r) - d;\n     real_of_rat l < real_of_1 (p, l, r)\\<rbrakk>\n    \\<Longrightarrow> sgn (poly (real_of_int_poly p)\n                            (real_of_1 (p, l, r) - d)) =\n                      sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n                      0 = sgn (poly (real_of_int_poly p) (real_of_rat l))\n 2. \\<lbrakk>0 < real_of_1 (p, l, r) - real_of_rat l;\n     real_of_1 (p, l, r) - real_of_rat l \\<le> d\\<rbrakk>\n    \\<Longrightarrow> sgn (poly (real_of_int_poly p)\n                            (real_of_1 (p, l, r) - d)) =\n                      sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n                      0 = sgn (poly (real_of_int_poly p) (real_of_rat l))\n 3. real_of_1 (p, l, r) = real_of_rat l \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n    0 = sgn (poly (real_of_int_poly p) (real_of_rat l))", "thus ?thesis"], ["proof (prove)\nusing this:\n  sgn (poly (real_of_int_poly p) (real_of_rat l)) =\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d))\n\ngoal (1 subgoal):\n 1. sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n    0 = sgn (poly (real_of_int_poly p) (real_of_rat l))", "by auto"], ["proof (state)\nthis:\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n  sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n  0 = sgn (poly (real_of_int_poly p) (real_of_rat l))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < real_of_1 (p, l, r) - real_of_rat l;\n     real_of_1 (p, l, r) - real_of_rat l \\<le> d\\<rbrakk>\n    \\<Longrightarrow> sgn (poly (real_of_int_poly p)\n                            (real_of_1 (p, l, r) - d)) =\n                      sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n                      0 = sgn (poly (real_of_int_poly p) (real_of_rat l))\n 2. real_of_1 (p, l, r) = real_of_rat l \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n    0 = sgn (poly (real_of_int_poly p) (real_of_rat l))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < real_of_1 (p, l, r) - real_of_rat l;\n     real_of_1 (p, l, r) - real_of_rat l \\<le> d\\<rbrakk>\n    \\<Longrightarrow> sgn (poly (real_of_int_poly p)\n                            (real_of_1 (p, l, r) - d)) =\n                      sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n                      0 = sgn (poly (real_of_int_poly p) (real_of_rat l))\n 2. real_of_1 (p, l, r) = real_of_rat l \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n    0 = sgn (poly (real_of_int_poly p) (real_of_rat l))", "case 2"], ["proof (state)\nthis:\n  0 < real_of_1 (p, l, r) - real_of_rat l\n  real_of_1 (p, l, r) - real_of_rat l \\<le> d\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < real_of_1 (p, l, r) - real_of_rat l;\n     real_of_1 (p, l, r) - real_of_rat l \\<le> d\\<rbrakk>\n    \\<Longrightarrow> sgn (poly (real_of_int_poly p)\n                            (real_of_1 (p, l, r) - d)) =\n                      sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n                      0 = sgn (poly (real_of_int_poly p) (real_of_rat l))\n 2. real_of_1 (p, l, r) = real_of_rat l \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n    0 = sgn (poly (real_of_int_poly p) (real_of_rat l))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n    0 = sgn (poly (real_of_int_poly p) (real_of_rat l))", "using d'(1)[OF 2]"], ["proof (prove)\nusing this:\n  sgn (poly (real_of_int_poly p)\n        (real_of_1 (p, l, r) + (real_of_1 (p, l, r) - real_of_rat l))) =\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) \\<and>\n  sgn (poly (real_of_int_poly p)\n        (real_of_1 (p, l, r) - (real_of_1 (p, l, r) - real_of_rat l))) =\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d))\n\ngoal (1 subgoal):\n 1. sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n    0 = sgn (poly (real_of_int_poly p) (real_of_rat l))", "by simp"], ["proof (state)\nthis:\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n  sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n  0 = sgn (poly (real_of_int_poly p) (real_of_rat l))\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) = real_of_rat l \\<Longrightarrow>\n    sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n    sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n    0 = sgn (poly (real_of_int_poly p) (real_of_rat l))", "qed (insert ur3,simp)"], ["proof (state)\nthis:\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n  sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n  0 = sgn (poly (real_of_int_poly p) (real_of_rat l))\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "have diff_sign: \"sgn (ipoly p l) \\<noteq> sgn (ipoly p r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (ipoly p l) \\<noteq> sgn (ipoly p r)", "using d'(2-) sr sl real_of_rat_sgn"], ["proof (prove)\nusing this:\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) \\<noteq>\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d))\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) \\<noteq> 0\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) + d)) =\n  sgn (poly (real_of_int_poly p) (real_of_rat r))\n  sgn (poly (real_of_int_poly p) (real_of_1 (p, l, r) - d)) =\n  sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<or>\n  0 = sgn (poly (real_of_int_poly p) (real_of_rat l))\n  sgn (real_of_rat ?x) = real_of_rat (sgn ?x)\n\ngoal (1 subgoal):\n 1. sgn (ipoly p l) \\<noteq> sgn (ipoly p r)", "by auto"], ["proof (state)\nthis:\n  sgn (ipoly p l) \\<noteq> sgn (ipoly p r)\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "have ur':\"\\<And>x. real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y \\<Longrightarrow> ipoly p x = 0 \\<Longrightarrow> \\<not> (?r y \\<le> the_unique_root (p,l,r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y;\n        poly (real_of_int_poly p) x = 0\\<rbrakk>\n       \\<Longrightarrow> \\<not> real_of_rat y \\<le> real_of_1 (p, l, r)", "proof(standard+,goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y;\n        poly (real_of_int_poly p) x = 0;\n        real_of_rat y \\<le> real_of_1 (p, l, r)\\<rbrakk>\n       \\<Longrightarrow> False", "case (1 x)"], ["proof (state)\nthis:\n  real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y\n  poly (real_of_int_poly p) x = 0\n  real_of_rat y \\<le> real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y;\n        poly (real_of_int_poly p) x = 0;\n        real_of_rat y \\<le> real_of_1 (p, l, r)\\<rbrakk>\n       \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y\n  poly (real_of_int_poly p) x = 0\n  real_of_rat y \\<le> real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y;\n        poly (real_of_int_poly p) x = 0;\n        real_of_rat y \\<le> real_of_1 (p, l, r)\\<rbrakk>\n       \\<Longrightarrow> False", "assume id: \"the_unique_root (p,l,r) = ?r y\""], ["proof (state)\nthis:\n  real_of_1 (p, l, r) = real_of_rat y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y;\n        poly (real_of_int_poly p) x = 0;\n        real_of_rat y \\<le> real_of_1 (p, l, r)\\<rbrakk>\n       \\<Longrightarrow> False", "from nz[of y] id ur"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly p) (real_of_rat y) \\<noteq> 0\n  real_of_1 (p, l, r) = real_of_rat y\n  \\<exists>!x. root_cond plr x", "have False"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (real_of_rat y) \\<noteq> 0\n  real_of_1 (p, l, r) = real_of_rat y\n  \\<exists>!x. root_cond plr x\n\ngoal (1 subgoal):\n 1. False", "by (auto elim!: unique_rootE)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y;\n        poly (real_of_int_poly p) x = 0;\n        real_of_rat y \\<le> real_of_1 (p, l, r)\\<rbrakk>\n       \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) = real_of_rat y \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y;\n        poly (real_of_int_poly p) x = 0;\n        real_of_rat y \\<le> real_of_1 (p, l, r)\\<rbrakk>\n       \\<Longrightarrow> False", "note neq = this"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) = real_of_rat y \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y;\n        poly (real_of_int_poly p) x = 0;\n        real_of_rat y \\<le> real_of_1 (p, l, r)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"root_cond (p, l, r) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_cond (p, l, r) x", "unfolding root_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (p, l, r) of\n    (p, l, r) \\<Rightarrow>\n      real_of_rat l \\<le> x \\<and>\n      x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0", "using 1 a ur"], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y\n  poly (real_of_int_poly p) x = 0\n  real_of_rat y \\<le> real_of_1 (p, l, r)\n  (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n  (real_of_1 (p, l, r) < real_of_rat y)\n  \\<exists>!x. root_cond plr x\n\ngoal (1 subgoal):\n 1. case (p, l, r) of\n    (p, l, r) \\<Rightarrow>\n      real_of_rat l \\<le> x \\<and>\n      x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0", "by (auto elim!: unique_rootE)"], ["proof (state)\nthis:\n  root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y;\n        poly (real_of_int_poly p) x = 0;\n        real_of_rat y \\<le> real_of_1 (p, l, r)\\<rbrakk>\n       \\<Longrightarrow> False", "with conjunct2[OF 1(1)] 1(2-) the_unique_root_eqI[OF ur]"], ["proof (chain)\npicking this:\n  x \\<le> real_of_rat y\n  poly (real_of_int_poly p) x = 0\n  real_of_rat y \\<le> real_of_1 (p, l, r)\n  root_cond plr ?y \\<Longrightarrow> ?y = real_of_1 plr\n  root_cond plr ?y \\<Longrightarrow> real_of_1 plr = ?y\n  root_cond (p, l, r) x", "show ?case"], ["proof (prove)\nusing this:\n  x \\<le> real_of_rat y\n  poly (real_of_int_poly p) x = 0\n  real_of_rat y \\<le> real_of_1 (p, l, r)\n  root_cond plr ?y \\<Longrightarrow> ?y = real_of_1 plr\n  root_cond plr ?y \\<Longrightarrow> real_of_1 plr = ?y\n  root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. False", "by (auto intro!: neq)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>real_of_rat l \\<le> ?x \\<and> ?x \\<le> real_of_rat y;\n   poly (real_of_int_poly p) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> real_of_rat y \\<le> real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "hence ur'':\"\\<forall>x. real_of_rat y \\<le> x \\<and> x \\<le> real_of_rat r \\<longrightarrow> poly (real_of_int_poly p) x \\<noteq> 0 \\<Longrightarrow> \\<not> (?r y \\<le> the_unique_root (p,l,r))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>real_of_rat l \\<le> ?x \\<and> ?x \\<le> real_of_rat y;\n   poly (real_of_int_poly p) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> real_of_rat y \\<le> real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       real_of_rat y \\<le> x \\<and> x \\<le> real_of_rat r \\<longrightarrow>\n       poly (real_of_int_poly p) x \\<noteq> 0 \\<Longrightarrow>\n    \\<not> real_of_rat y \\<le> real_of_1 (p, l, r)", "using urD(2,3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>real_of_rat l \\<le> ?x \\<and> ?x \\<le> real_of_rat y;\n   poly (real_of_int_poly p) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> real_of_rat y \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat r\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       real_of_rat y \\<le> x \\<and> x \\<le> real_of_rat r \\<longrightarrow>\n       poly (real_of_int_poly p) x \\<noteq> 0 \\<Longrightarrow>\n    \\<not> real_of_rat y \\<le> real_of_1 (p, l, r)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     real_of_rat y \\<le> x \\<and> x \\<le> real_of_rat r \\<longrightarrow>\n     poly (real_of_int_poly p) x \\<noteq> 0 \\<Longrightarrow>\n  \\<not> real_of_rat y \\<le> real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "have \"(sgn (ipoly p y) = sgn (ipoly p r)) = (?r y > the_unique_root (p,l,r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "proof(cases \"sgn (ipoly p r) = sgn (ipoly p y)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sgn (ipoly p r) = sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)\n 2. sgn (ipoly p r) \\<noteq> sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "case True"], ["proof (state)\nthis:\n  sgn (ipoly p r) = sgn (ipoly p y)\n\ngoal (2 subgoals):\n 1. sgn (ipoly p r) = sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)\n 2. sgn (ipoly p r) \\<noteq> sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "have sgn:\"sgn (poly ?p (real_of_rat l)) \\<noteq> sgn (poly ?p (real_of_rat y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<noteq>\n    sgn (poly (real_of_int_poly p) (real_of_rat y))", "using True diff_sign"], ["proof (prove)\nusing this:\n  sgn (ipoly p r) = sgn (ipoly p y)\n  sgn (ipoly p l) \\<noteq> sgn (ipoly p r)\n\ngoal (1 subgoal):\n 1. sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<noteq>\n    sgn (poly (real_of_int_poly p) (real_of_rat y))", "by (simp add: real_of_rat_sgn)"], ["proof (state)\nthis:\n  sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<noteq>\n  sgn (poly (real_of_int_poly p) (real_of_rat y))\n\ngoal (2 subgoals):\n 1. sgn (ipoly p r) = sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)\n 2. sgn (ipoly p r) \\<noteq> sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "have ly:\"of_rat l < (of_rat y::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat l < real_of_rat y", "using in_interval True diff_sign less_eq_rat_def of_rat_less"], ["proof (prove)\nusing this:\n  l \\<le> y\n  y \\<le> r\n  sgn (ipoly p r) = sgn (ipoly p y)\n  sgn (ipoly p l) \\<noteq> sgn (ipoly p r)\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n  (of_rat ?r < of_rat ?s) = (?r < ?s)\n\ngoal (1 subgoal):\n 1. real_of_rat l < real_of_rat y", "by auto"], ["proof (state)\nthis:\n  real_of_rat l < real_of_rat y\n\ngoal (2 subgoals):\n 1. sgn (ipoly p r) = sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)\n 2. sgn (ipoly p r) \\<noteq> sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "with no_roots_inbetween_imp_same_sign[OF ly,of ?p] sgn ur' True"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y \\<longrightarrow>\n     poly (real_of_int_poly p) x \\<noteq> 0 \\<Longrightarrow>\n  sgn (poly (real_of_int_poly p) (real_of_rat l)) =\n  sgn (poly (real_of_int_poly p) (real_of_rat y))\n  sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<noteq>\n  sgn (poly (real_of_int_poly p) (real_of_rat y))\n  \\<lbrakk>real_of_rat l \\<le> ?x \\<and> ?x \\<le> real_of_rat y;\n   poly (real_of_int_poly p) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> real_of_rat y \\<le> real_of_1 (p, l, r)\n  sgn (ipoly p r) = sgn (ipoly p y)\n  real_of_rat l < real_of_rat y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     real_of_rat l \\<le> x \\<and> x \\<le> real_of_rat y \\<longrightarrow>\n     poly (real_of_int_poly p) x \\<noteq> 0 \\<Longrightarrow>\n  sgn (poly (real_of_int_poly p) (real_of_rat l)) =\n  sgn (poly (real_of_int_poly p) (real_of_rat y))\n  sgn (poly (real_of_int_poly p) (real_of_rat l)) \\<noteq>\n  sgn (poly (real_of_int_poly p) (real_of_rat y))\n  \\<lbrakk>real_of_rat l \\<le> ?x \\<and> ?x \\<le> real_of_rat y;\n   poly (real_of_int_poly p) ?x = 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> real_of_rat y \\<le> real_of_1 (p, l, r)\n  sgn (ipoly p r) = sgn (ipoly p y)\n  real_of_rat l < real_of_rat y\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "by force"], ["proof (state)\nthis:\n  (sgn (ipoly p y) = sgn (ipoly p r)) =\n  (real_of_1 (p, l, r) < real_of_rat y)\n\ngoal (1 subgoal):\n 1. sgn (ipoly p r) \\<noteq> sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sgn (ipoly p r) \\<noteq> sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "case False"], ["proof (state)\nthis:\n  sgn (ipoly p r) \\<noteq> sgn (ipoly p y)\n\ngoal (1 subgoal):\n 1. sgn (ipoly p r) \\<noteq> sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "hence ne:\"sgn (ipoly p (real_of_rat y)) \\<noteq> sgn (ipoly p (real_of_rat r))\""], ["proof (prove)\nusing this:\n  sgn (ipoly p r) \\<noteq> sgn (ipoly p y)\n\ngoal (1 subgoal):\n 1. sgn (poly (real_of_int_poly p) (real_of_rat y)) \\<noteq>\n    sgn (poly (real_of_int_poly p) (real_of_rat r))", "by (simp add: real_of_rat_sgn)"], ["proof (state)\nthis:\n  sgn (poly (real_of_int_poly p) (real_of_rat y)) \\<noteq>\n  sgn (poly (real_of_int_poly p) (real_of_rat r))\n\ngoal (1 subgoal):\n 1. sgn (ipoly p r) \\<noteq> sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "have ry:\"of_rat y < (of_rat r::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat y < real_of_rat r", "using in_interval False diff_sign less_eq_rat_def of_rat_less"], ["proof (prove)\nusing this:\n  l \\<le> y\n  y \\<le> r\n  sgn (ipoly p r) \\<noteq> sgn (ipoly p y)\n  sgn (ipoly p l) \\<noteq> sgn (ipoly p r)\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n  (of_rat ?r < of_rat ?s) = (?r < ?s)\n\ngoal (1 subgoal):\n 1. real_of_rat y < real_of_rat r", "by auto"], ["proof (state)\nthis:\n  real_of_rat y < real_of_rat r\n\ngoal (1 subgoal):\n 1. sgn (ipoly p r) \\<noteq> sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "obtain x where x:\"real_of_rat y \\<le> x\" \"x \\<le> real_of_rat r\" \"ipoly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>real_of_rat y \\<le> x; x \\<le> real_of_rat r;\n         poly (real_of_int_poly p) x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using no_roots_inbetween_imp_same_sign[OF ry,of ?p] ne"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     real_of_rat y \\<le> x \\<and> x \\<le> real_of_rat r \\<longrightarrow>\n     poly (real_of_int_poly p) x \\<noteq> 0 \\<Longrightarrow>\n  sgn (poly (real_of_int_poly p) (real_of_rat y)) =\n  sgn (poly (real_of_int_poly p) (real_of_rat r))\n  sgn (poly (real_of_int_poly p) (real_of_rat y)) \\<noteq>\n  sgn (poly (real_of_int_poly p) (real_of_rat r))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>real_of_rat y \\<le> x; x \\<le> real_of_rat r;\n         poly (real_of_int_poly p) x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  real_of_rat y \\<le> x\n  x \\<le> real_of_rat r\n  poly (real_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. sgn (ipoly p r) \\<noteq> sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "hence lx:\"real_of_rat l \\<le> x\""], ["proof (prove)\nusing this:\n  real_of_rat y \\<le> x\n  x \\<le> real_of_rat r\n  poly (real_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> x", "using in_interval"], ["proof (prove)\nusing this:\n  real_of_rat y \\<le> x\n  x \\<le> real_of_rat r\n  poly (real_of_int_poly p) x = 0\n  l \\<le> y\n  y \\<le> r\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> x", "using False a urD"], ["proof (prove)\nusing this:\n  real_of_rat y \\<le> x\n  x \\<le> real_of_rat r\n  poly (real_of_int_poly p) x = 0\n  l \\<le> y\n  y \\<le> r\n  sgn (ipoly p r) \\<noteq> sgn (ipoly p y)\n  (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n  (real_of_1 (p, l, r) < real_of_rat y)\n  real_of_rat l \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat r\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> x", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> x\n\ngoal (1 subgoal):\n 1. sgn (ipoly p r) \\<noteq> sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "have \"?ur = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) = x", "using x lx ur"], ["proof (prove)\nusing this:\n  real_of_rat y \\<le> x\n  x \\<le> real_of_rat r\n  poly (real_of_int_poly p) x = 0\n  real_of_rat l \\<le> x\n  \\<exists>!x. root_cond plr x\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) = x", "by (intro the_unique_root_eqI, auto)"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) = x\n\ngoal (1 subgoal):\n 1. sgn (ipoly p r) \\<noteq> sgn (ipoly p y) \\<Longrightarrow>\n    (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "then"], ["proof (chain)\npicking this:\n  real_of_1 (p, l, r) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) = x\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "using False x"], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) = x\n  sgn (ipoly p r) \\<noteq> sgn (ipoly p y)\n  real_of_rat y \\<le> x\n  x \\<le> real_of_rat r\n  poly (real_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) =\n    (real_of_1 (p, l, r) < real_of_rat y)", "by auto"], ["proof (state)\nthis:\n  (sgn (ipoly p y) = sgn (ipoly p r)) =\n  (real_of_1 (p, l, r) < real_of_rat y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (sgn (ipoly p y) = sgn (ipoly p r)) =\n  (real_of_1 (p, l, r) < real_of_rat y)\n\ngoal (1 subgoal):\n 1. (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n    (real_of_1 plr < real_of_rat y) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  (sgn (ipoly p y) = sgn (ipoly p r)) =\n  (real_of_1 (p, l, r) < real_of_rat y)\n\ngoal (1 subgoal):\n 1. False", "using diff_sign(1) a ru"], ["proof (prove)\nusing this:\n  (sgn (ipoly p y) = sgn (ipoly p r)) =\n  (real_of_1 (p, l, r) < real_of_rat y)\n  sgn (ipoly p l) \\<noteq> sgn (ipoly p r)\n  (sgn (ipoly p y) = sgn (ipoly p r)) \\<noteq>\n  (real_of_1 (p, l, r) < real_of_rat y)\n  ipoly p y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by(cases \"ipoly p r = 0\";auto simp:sgn_0_0)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "definition tighten_poly_bounds :: \"rat \\<Rightarrow> rat \\<Rightarrow> rat \\<Rightarrow> rat \\<times> rat \\<times> rat\" where\n  \"tighten_poly_bounds l r sr = (let m = (l + r) / 2; sm = sgn (ipoly p m) in \n    if sm = sr\n     then (l,m,sm) else (m,r,sr))\""], ["", "lemma tighten_poly_bounds: assumes res: \"tighten_poly_bounds l r sr = (l',r',sr')\"\n  and ur: \"unique_root (p,l,r)\"\n  and p:  \"poly_cond2 p\"   \n  and sr: \"sr = sgn (ipoly p r)\" \n  shows \"root_cond (p,l',r') (the_unique_root (p,l,r))\" \"l \\<le> l'\" \"l' \\<le> r'\" \"r' \\<le> r\" \n    \"(r' - l') = (r - l) / 2\" \"sr' = sgn (ipoly p r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (root_cond (p, l', r') (real_of_1 (p, l, r)) &&&\n     l \\<le> l' &&& l' \\<le> r') &&&\n    r' \\<le> r &&& r' - l' = (r - l) / 2 &&& sr' = sgn (ipoly p r')", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. root_cond (p, l', r') (real_of_1 (p, l, r))\n 2. l \\<le> l'\n 3. l' \\<le> r'\n 4. r' \\<le> r\n 5. r' - l' = (r - l) / 2\n 6. sr' = sgn (ipoly p r')", "let ?x = \"the_unique_root (p,l,r)\""], ["proof (state)\ngoal (6 subgoals):\n 1. root_cond (p, l', r') (real_of_1 (p, l, r))\n 2. l \\<le> l'\n 3. l' \\<le> r'\n 4. r' \\<le> r\n 5. r' - l' = (r - l) / 2\n 6. sr' = sgn (ipoly p r')", "let ?x' = \"the_unique_root (p,l',r')\""], ["proof (state)\ngoal (6 subgoals):\n 1. root_cond (p, l', r') (real_of_1 (p, l, r))\n 2. l \\<le> l'\n 3. l' \\<le> r'\n 4. r' \\<le> r\n 5. r' - l' = (r - l) / 2\n 6. sr' = sgn (ipoly p r')", "let ?m = \"(l + r) / 2\""], ["proof (state)\ngoal (6 subgoals):\n 1. root_cond (p, l', r') (real_of_1 (p, l, r))\n 2. l \\<le> l'\n 3. l' \\<le> r'\n 4. r' \\<le> r\n 5. r' - l' = (r - l) / 2\n 6. sr' = sgn (ipoly p r')", "note d = tighten_poly_bounds_def Let_def"], ["proof (state)\nthis:\n  local.tighten_poly_bounds ?l ?r ?sr =\n  (let m = (?l + ?r) / 2; sm = sgn (ipoly p m)\n   in if sm = ?sr then (?l, m, sm) else (m, ?r, ?sr))\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (6 subgoals):\n 1. root_cond (p, l', r') (real_of_1 (p, l, r))\n 2. l \\<le> l'\n 3. l' \\<le> r'\n 4. r' \\<le> r\n 5. r' - l' = (r - l) / 2\n 6. sr' = sgn (ipoly p r')", "from unique_root_lr[OF ur]"], ["proof (chain)\npicking this:\n  rai_lb (p, l, r) \\<le> rai_ub (p, l, r)", "have lr: \"l \\<le> r\""], ["proof (prove)\nusing this:\n  rai_lb (p, l, r) \\<le> rai_ub (p, l, r)\n\ngoal (1 subgoal):\n 1. l \\<le> r", "by auto"], ["proof (state)\nthis:\n  l \\<le> r\n\ngoal (6 subgoals):\n 1. root_cond (p, l', r') (real_of_1 (p, l, r))\n 2. l \\<le> l'\n 3. l' \\<le> r'\n 4. r' \\<le> r\n 5. r' - l' = (r - l) / 2\n 6. sr' = sgn (ipoly p r')", "thus \"l \\<le> l'\" \"l' \\<le> r'\" \"r' \\<le> r\" \"(r' - l') = (r - l) / 2\" \"sr' = sgn (ipoly p r')\""], ["proof (prove)\nusing this:\n  l \\<le> r\n\ngoal (1 subgoal):\n 1. (l \\<le> l' &&& l' \\<le> r') &&&\n    r' \\<le> r &&& r' - l' = (r - l) / 2 &&& sr' = sgn (ipoly p r')", "using res sr"], ["proof (prove)\nusing this:\n  l \\<le> r\n  local.tighten_poly_bounds l r sr = (l', r', sr')\n  sr = sgn (ipoly p r)\n\ngoal (1 subgoal):\n 1. (l \\<le> l' &&& l' \\<le> r') &&&\n    r' \\<le> r &&& r' - l' = (r - l) / 2 &&& sr' = sgn (ipoly p r')", "unfolding d"], ["proof (prove)\nusing this:\n  l \\<le> r\n  (if sgn (ipoly p ((l + r) / 2)) = sr\n   then (l, (l + r) / 2, sgn (ipoly p ((l + r) / 2)))\n   else ((l + r) / 2, r, sr)) =\n  (l', r', sr')\n  sr = sgn (ipoly p r)\n\ngoal (1 subgoal):\n 1. (l \\<le> l' &&& l' \\<le> r') &&&\n    r' \\<le> r &&& r' - l' = (r - l) / 2 &&& sr' = sgn (ipoly p r')", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  r' - l' = (r - l) / 2\n  sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. root_cond (p, l', r') (real_of_1 (p, l, r))", "hence \"l \\<le> ?m\" \"?m \\<le> r\""], ["proof (prove)\nusing this:\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  r' - l' = (r - l) / 2\n  sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. l \\<le> (l + r) / 2 &&& (l + r) / 2 \\<le> r", "by auto"], ["proof (state)\nthis:\n  l \\<le> (l + r) / 2\n  (l + r) / 2 \\<le> r\n\ngoal (1 subgoal):\n 1. root_cond (p, l', r') (real_of_1 (p, l, r))", "note le = gt_rat_sign_change[OF ur,simplified,OF p this]"], ["proof (state)\nthis:\n  (sgn (ipoly p ((l + r) / 2)) = sgn (ipoly p r)) =\n  (real_of_1 (p, l, r) < real_of_rat ((l + r) / 2))\n\ngoal (1 subgoal):\n 1. root_cond (p, l', r') (real_of_1 (p, l, r))", "note urD = unique_rootD[OF ur]"], ["proof (state)\nthis:\n  real_of_rat (rai_lb (p, l, r)) \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat (rai_ub (p, l, r))\n  poly (real_of_int_poly (poly_real_alg_1 (p, l, r)))\n   (real_of_1 (p, l, r)) =\n  0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y\n\ngoal (1 subgoal):\n 1. root_cond (p, l', r') (real_of_1 (p, l, r))", "show \"root_cond (p,l',r') ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_cond (p, l', r') (real_of_1 (p, l, r))", "proof (cases \"sgn (ipoly p ?m) = sgn (ipoly p r)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sgn (ipoly p ((l + r) / 2)) = sgn (ipoly p r) \\<Longrightarrow>\n    root_cond (p, l', r') (real_of_1 (p, l, r))\n 2. sgn (ipoly p ((l + r) / 2)) \\<noteq> sgn (ipoly p r) \\<Longrightarrow>\n    root_cond (p, l', r') (real_of_1 (p, l, r))", "case *: False"], ["proof (state)\nthis:\n  sgn (ipoly p ((l + r) / 2)) \\<noteq> sgn (ipoly p r)\n\ngoal (2 subgoals):\n 1. sgn (ipoly p ((l + r) / 2)) = sgn (ipoly p r) \\<Longrightarrow>\n    root_cond (p, l', r') (real_of_1 (p, l, r))\n 2. sgn (ipoly p ((l + r) / 2)) \\<noteq> sgn (ipoly p r) \\<Longrightarrow>\n    root_cond (p, l', r') (real_of_1 (p, l, r))", "with res sr"], ["proof (chain)\npicking this:\n  local.tighten_poly_bounds l r sr = (l', r', sr')\n  sr = sgn (ipoly p r)\n  sgn (ipoly p ((l + r) / 2)) \\<noteq> sgn (ipoly p r)", "have id: \"l' = ?m\" \"r' = r\""], ["proof (prove)\nusing this:\n  local.tighten_poly_bounds l r sr = (l', r', sr')\n  sr = sgn (ipoly p r)\n  sgn (ipoly p ((l + r) / 2)) \\<noteq> sgn (ipoly p r)\n\ngoal (1 subgoal):\n 1. l' = (l + r) / 2 &&& r' = r", "unfolding d"], ["proof (prove)\nusing this:\n  (if sgn (ipoly p ((l + r) / 2)) = sr\n   then (l, (l + r) / 2, sgn (ipoly p ((l + r) / 2)))\n   else ((l + r) / 2, r, sr)) =\n  (l', r', sr')\n  sr = sgn (ipoly p r)\n  sgn (ipoly p ((l + r) / 2)) \\<noteq> sgn (ipoly p r)\n\ngoal (1 subgoal):\n 1. l' = (l + r) / 2 &&& r' = r", "by auto"], ["proof (state)\nthis:\n  l' = (l + r) / 2\n  r' = r\n\ngoal (2 subgoals):\n 1. sgn (ipoly p ((l + r) / 2)) = sgn (ipoly p r) \\<Longrightarrow>\n    root_cond (p, l', r') (real_of_1 (p, l, r))\n 2. sgn (ipoly p ((l + r) / 2)) \\<noteq> sgn (ipoly p r) \\<Longrightarrow>\n    root_cond (p, l', r') (real_of_1 (p, l, r))", "from *[unfolded le] urD"], ["proof (chain)\npicking this:\n  \\<not> real_of_1 (p, l, r) < real_of_rat ((l + r) / 2)\n  real_of_rat (rai_lb (p, l, r)) \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat (rai_ub (p, l, r))\n  poly (real_of_int_poly (poly_real_alg_1 (p, l, r)))\n   (real_of_1 (p, l, r)) =\n  0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> real_of_1 (p, l, r) < real_of_rat ((l + r) / 2)\n  real_of_rat (rai_lb (p, l, r)) \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat (rai_ub (p, l, r))\n  poly (real_of_int_poly (poly_real_alg_1 (p, l, r)))\n   (real_of_1 (p, l, r)) =\n  0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y\n\ngoal (1 subgoal):\n 1. root_cond (p, l', r') (real_of_1 (p, l, r))", "unfolding id"], ["proof (prove)\nusing this:\n  \\<not> real_of_1 (p, l, r) < real_of_rat ((l + r) / 2)\n  real_of_rat (rai_lb (p, l, r)) \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat (rai_ub (p, l, r))\n  poly (real_of_int_poly (poly_real_alg_1 (p, l, r)))\n   (real_of_1 (p, l, r)) =\n  0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y\n\ngoal (1 subgoal):\n 1. root_cond (p, (l + r) / 2, r) (real_of_1 (p, l, r))", "by auto"], ["proof (state)\nthis:\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. sgn (ipoly p ((l + r) / 2)) = sgn (ipoly p r) \\<Longrightarrow>\n    root_cond (p, l', r') (real_of_1 (p, l, r))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sgn (ipoly p ((l + r) / 2)) = sgn (ipoly p r) \\<Longrightarrow>\n    root_cond (p, l', r') (real_of_1 (p, l, r))", "case *: True"], ["proof (state)\nthis:\n  sgn (ipoly p ((l + r) / 2)) = sgn (ipoly p r)\n\ngoal (1 subgoal):\n 1. sgn (ipoly p ((l + r) / 2)) = sgn (ipoly p r) \\<Longrightarrow>\n    root_cond (p, l', r') (real_of_1 (p, l, r))", "with res sr"], ["proof (chain)\npicking this:\n  local.tighten_poly_bounds l r sr = (l', r', sr')\n  sr = sgn (ipoly p r)\n  sgn (ipoly p ((l + r) / 2)) = sgn (ipoly p r)", "have id: \"l' = l\" \"r' = ?m\""], ["proof (prove)\nusing this:\n  local.tighten_poly_bounds l r sr = (l', r', sr')\n  sr = sgn (ipoly p r)\n  sgn (ipoly p ((l + r) / 2)) = sgn (ipoly p r)\n\ngoal (1 subgoal):\n 1. l' = l &&& r' = (l + r) / 2", "unfolding d"], ["proof (prove)\nusing this:\n  (if sgn (ipoly p ((l + r) / 2)) = sr\n   then (l, (l + r) / 2, sgn (ipoly p ((l + r) / 2)))\n   else ((l + r) / 2, r, sr)) =\n  (l', r', sr')\n  sr = sgn (ipoly p r)\n  sgn (ipoly p ((l + r) / 2)) = sgn (ipoly p r)\n\ngoal (1 subgoal):\n 1. l' = l &&& r' = (l + r) / 2", "by auto"], ["proof (state)\nthis:\n  l' = l\n  r' = (l + r) / 2\n\ngoal (1 subgoal):\n 1. sgn (ipoly p ((l + r) / 2)) = sgn (ipoly p r) \\<Longrightarrow>\n    root_cond (p, l', r') (real_of_1 (p, l, r))", "from *[unfolded le] urD"], ["proof (chain)\npicking this:\n  real_of_1 (p, l, r) < real_of_rat ((l + r) / 2)\n  real_of_rat (rai_lb (p, l, r)) \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat (rai_ub (p, l, r))\n  poly (real_of_int_poly (poly_real_alg_1 (p, l, r)))\n   (real_of_1 (p, l, r)) =\n  0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) < real_of_rat ((l + r) / 2)\n  real_of_rat (rai_lb (p, l, r)) \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat (rai_ub (p, l, r))\n  poly (real_of_int_poly (poly_real_alg_1 (p, l, r)))\n   (real_of_1 (p, l, r)) =\n  0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y\n\ngoal (1 subgoal):\n 1. root_cond (p, l', r') (real_of_1 (p, l, r))", "unfolding id"], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) < real_of_rat ((l + r) / 2)\n  real_of_rat (rai_lb (p, l, r)) \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat (rai_ub (p, l, r))\n  poly (real_of_int_poly (poly_real_alg_1 (p, l, r)))\n   (real_of_1 (p, l, r)) =\n  0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y\n\ngoal (1 subgoal):\n 1. root_cond (p, l, (l + r) / 2) (real_of_1 (p, l, r))", "by auto"], ["proof (state)\nthis:\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n\ngoal:\nNo subgoals!", "qed"], ["", "partial_function (tailrec) tighten_poly_bounds_epsilon :: \"rat \\<Rightarrow> rat \\<Rightarrow> rat \\<Rightarrow> rat \\<times> rat \\<times> rat\" where\n  [code]: \"tighten_poly_bounds_epsilon l r sr = (if r - l \\<le> x then (l,r,sr) else\n    (case tighten_poly_bounds l r sr of (l',r',sr') \\<Rightarrow> tighten_poly_bounds_epsilon l' r' sr'))\""], ["", "partial_function (tailrec) tighten_poly_bounds_for_x :: \"rat \\<Rightarrow> rat \\<Rightarrow> rat \\<Rightarrow>\n  rat \\<times> rat \\<times> rat\" where \n  [code]: \"tighten_poly_bounds_for_x l r sr = (if x < l \\<or> r < x then (l, r, sr) else\n     (case tighten_poly_bounds l r sr of (l',r',sr') \\<Rightarrow> tighten_poly_bounds_for_x l' r' sr'))\""], ["", "lemma tighten_poly_bounds_epsilon:\n  assumes ur: \"unique_root (p,l,r)\"\n  defines u: \"u \\<equiv> the_unique_root (p,l,r)\"\n  assumes p: \"poly_cond2 p\"\n      and res: \"tighten_poly_bounds_epsilon l r sr = (l',r',sr')\"\n      and sr: \"sr = sgn (ipoly p r)\" \n      and x: \"x > 0\"\n  shows \"l \\<le> l'\" \"r' \\<le> r\" \"root_cond (p,l',r') u\" \"r' - l' \\<le> x\" \"sr' = sgn (ipoly p r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l \\<le> l' &&& r' \\<le> r) &&&\n    root_cond (p, l', r') u &&& r' - l' \\<le> x &&& sr' = sgn (ipoly p r')", "proof -"], ["proof (state)\ngoal (5 subgoals):\n 1. l \\<le> l'\n 2. r' \\<le> r\n 3. root_cond (p, l', r') u\n 4. r' - l' \\<le> x\n 5. sr' = sgn (ipoly p r')", "let ?u = \"the_unique_root (p,l,r)\""], ["proof (state)\ngoal (5 subgoals):\n 1. l \\<le> l'\n 2. r' \\<le> r\n 3. root_cond (p, l', r') u\n 4. r' - l' \\<le> x\n 5. sr' = sgn (ipoly p r')", "define delta where \"delta = x / 2\""], ["proof (state)\nthis:\n  delta = x / 2\n\ngoal (5 subgoals):\n 1. l \\<le> l'\n 2. r' \\<le> r\n 3. root_cond (p, l', r') u\n 4. r' - l' \\<le> x\n 5. sr' = sgn (ipoly p r')", "have delta: \"delta > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < delta", "unfolding delta_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x / 2", "using x"], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. 0 < x / 2", "by auto"], ["proof (state)\nthis:\n  0 < delta\n\ngoal (5 subgoals):\n 1. l \\<le> l'\n 2. r' \\<le> r\n 3. root_cond (p, l', r') u\n 4. r' - l' \\<le> x\n 5. sr' = sgn (ipoly p r')", "let ?dist = \"\\<lambda> (l,r,sr). r - l\""], ["proof (state)\ngoal (5 subgoals):\n 1. l \\<le> l'\n 2. r' \\<le> r\n 3. root_cond (p, l', r') u\n 4. r' - l' \\<le> x\n 5. sr' = sgn (ipoly p r')", "let ?rel = \"inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y} ?dist\""], ["proof (state)\ngoal (5 subgoals):\n 1. l \\<le> l'\n 2. r' \\<le> r\n 3. root_cond (p, l', r') u\n 4. r' - l' \\<le> x\n 5. sr' = sgn (ipoly p r')", "note SN = SN_inv_image[OF delta_gt_SN[OF delta], of ?dist]"], ["proof (state)\nthis:\n  SN (inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n       (\\<lambda>(l, r, sr). r - l))\n\ngoal (5 subgoals):\n 1. l \\<le> l'\n 2. r' \\<le> r\n 3. root_cond (p, l', r') u\n 4. r' - l' \\<le> x\n 5. sr' = sgn (ipoly p r')", "note simps = res[unfolded tighten_poly_bounds_for_x.simps[of l r]]"], ["proof (state)\nthis:\n  local.tighten_poly_bounds_epsilon l r sr = (l', r', sr')\n\ngoal (5 subgoals):\n 1. l \\<le> l'\n 2. r' \\<le> r\n 3. root_cond (p, l', r') u\n 4. r' - l' \\<le> x\n 5. sr' = sgn (ipoly p r')", "let ?P = \"\\<lambda> (l,r,sr). unique_root (p,l,r) \\<longrightarrow> u = the_unique_root (p,l,r) \n    \\<longrightarrow> tighten_poly_bounds_epsilon l r sr = (l',r',sr') \n    \\<longrightarrow> sr = sgn (ipoly p r)\n    \\<longrightarrow> l \\<le> l' \\<and> r' \\<le> r \\<and> r' - l' \\<le> x \\<and> root_cond (p,l',r') u \\<and> sr' = sgn (ipoly p r')\""], ["proof (state)\ngoal (5 subgoals):\n 1. l \\<le> l'\n 2. r' \\<le> r\n 3. root_cond (p, l', r') u\n 4. r' - l' \\<le> x\n 5. sr' = sgn (ipoly p r')", "have \"?P (l,r,sr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case (l, r, sr) of\n    (l, r, sr) \\<Rightarrow>\n      (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n      u = real_of_1 (p, l, r) \\<longrightarrow>\n      local.tighten_poly_bounds_epsilon l r sr =\n      (l', r', sr') \\<longrightarrow>\n      sr = sgn (ipoly p r) \\<longrightarrow>\n      l \\<le> l' \\<and>\n      r' \\<le> r \\<and>\n      r' - l' \\<le> x \\<and>\n      root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "proof (induct rule: SN_induct[OF SN])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n                  (\\<lambda>(l, r, sr). r - l) \\<Longrightarrow>\n           case b of\n           (l, r, sr) \\<Rightarrow>\n             (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n             u = real_of_1 (p, l, r) \\<longrightarrow>\n             local.tighten_poly_bounds_epsilon l r sr =\n             (l', r', sr') \\<longrightarrow>\n             sr = sgn (ipoly p r) \\<longrightarrow>\n             l \\<le> l' \\<and>\n             r' \\<le> r \\<and>\n             r' - l' \\<le> x \\<and>\n             root_cond (p, l', r') u \\<and>\n             sr' = sgn (ipoly p r')) \\<Longrightarrow>\n       case a of\n       (l, r, sr) \\<Rightarrow>\n         (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n         u = real_of_1 (p, l, r) \\<longrightarrow>\n         local.tighten_poly_bounds_epsilon l r sr =\n         (l', r', sr') \\<longrightarrow>\n         sr = sgn (ipoly p r) \\<longrightarrow>\n         l \\<le> l' \\<and>\n         r' \\<le> r \\<and>\n         r' - l' \\<le> x \\<and>\n         root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "case (1 lr)"], ["proof (state)\nthis:\n  (lr, ?b2)\n  \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n         (\\<lambda>(l, r, sr). r - l) \\<Longrightarrow>\n  case ?b2 of\n  (l, r, sr) \\<Rightarrow>\n    (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n    u = real_of_1 (p, l, r) \\<longrightarrow>\n    local.tighten_poly_bounds_epsilon l r sr =\n    (l', r', sr') \\<longrightarrow>\n    sr = sgn (ipoly p r) \\<longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n                  (\\<lambda>(l, r, sr). r - l) \\<Longrightarrow>\n           case b of\n           (l, r, sr) \\<Rightarrow>\n             (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n             u = real_of_1 (p, l, r) \\<longrightarrow>\n             local.tighten_poly_bounds_epsilon l r sr =\n             (l', r', sr') \\<longrightarrow>\n             sr = sgn (ipoly p r) \\<longrightarrow>\n             l \\<le> l' \\<and>\n             r' \\<le> r \\<and>\n             r' - l' \\<le> x \\<and>\n             root_cond (p, l', r') u \\<and>\n             sr' = sgn (ipoly p r')) \\<Longrightarrow>\n       case a of\n       (l, r, sr) \\<Rightarrow>\n         (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n         u = real_of_1 (p, l, r) \\<longrightarrow>\n         local.tighten_poly_bounds_epsilon l r sr =\n         (l', r', sr') \\<longrightarrow>\n         sr = sgn (ipoly p r) \\<longrightarrow>\n         l \\<le> l' \\<and>\n         r' \\<le> r \\<and>\n         r' - l' \\<le> x \\<and>\n         root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "obtain l r sr where lr: \"lr = (l,r,sr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l r sr.\n        lr = (l, r, sr) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases lr, auto)"], ["proof (state)\nthis:\n  lr = (l, r, sr)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n                  (\\<lambda>(l, r, sr). r - l) \\<Longrightarrow>\n           case b of\n           (l, r, sr) \\<Rightarrow>\n             (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n             u = real_of_1 (p, l, r) \\<longrightarrow>\n             local.tighten_poly_bounds_epsilon l r sr =\n             (l', r', sr') \\<longrightarrow>\n             sr = sgn (ipoly p r) \\<longrightarrow>\n             l \\<le> l' \\<and>\n             r' \\<le> r \\<and>\n             r' - l' \\<le> x \\<and>\n             root_cond (p, l', r') u \\<and>\n             sr' = sgn (ipoly p r')) \\<Longrightarrow>\n       case a of\n       (l, r, sr) \\<Rightarrow>\n         (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n         u = real_of_1 (p, l, r) \\<longrightarrow>\n         local.tighten_poly_bounds_epsilon l r sr =\n         (l', r', sr') \\<longrightarrow>\n         sr = sgn (ipoly p r) \\<longrightarrow>\n         l \\<le> l' \\<and>\n         r' \\<le> r \\<and>\n         r' - l' \\<le> x \\<and>\n         root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. case lr of\n    (l, r, sr) \\<Rightarrow>\n      (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n      u = real_of_1 (p, l, r) \\<longrightarrow>\n      local.tighten_poly_bounds_epsilon l r sr =\n      (l', r', sr') \\<longrightarrow>\n      sr = sgn (ipoly p r) \\<longrightarrow>\n      l \\<le> l' \\<and>\n      r' \\<le> r \\<and>\n      r' - l' \\<le> x \\<and>\n      root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "unfolding lr split"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex1 (root_cond (p, l, r)) \\<longrightarrow>\n    u = real_of_1 (p, l, r) \\<longrightarrow>\n    local.tighten_poly_bounds_epsilon l r sr =\n    (l', r', sr') \\<longrightarrow>\n    sr = sgn (ipoly p r) \\<longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "proof (intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ex1 (root_cond (p, l, r)); u = real_of_1 (p, l, r);\n     local.tighten_poly_bounds_epsilon l r sr = (l', r', sr');\n     sr = sgn (ipoly p r)\\<rbrakk>\n    \\<Longrightarrow> l \\<le> l' \\<and>\n                      r' \\<le> r \\<and>\n                      r' - l' \\<le> x \\<and>\n                      root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "assume ur: \"unique_root (p, l, r)\"\n        and u: \"u = the_unique_root (p, l, r)\"\n        and res: \"tighten_poly_bounds_epsilon l r sr = (l', r', sr')\"\n        and sr: \"sr = sgn (ipoly p r)\""], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, l, r) x\n  u = real_of_1 (p, l, r)\n  local.tighten_poly_bounds_epsilon l r sr = (l', r', sr')\n  sr = sgn (ipoly p r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ex1 (root_cond (p, l, r)); u = real_of_1 (p, l, r);\n     local.tighten_poly_bounds_epsilon l r sr = (l', r', sr');\n     sr = sgn (ipoly p r)\\<rbrakk>\n    \\<Longrightarrow> l \\<le> l' \\<and>\n                      r' \\<le> r \\<and>\n                      r' - l' \\<le> x \\<and>\n                      root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "note tur = unique_rootD[OF ur]"], ["proof (state)\nthis:\n  real_of_rat (rai_lb (p, l, r)) \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat (rai_ub (p, l, r))\n  poly (real_of_int_poly (poly_real_alg_1 (p, l, r)))\n   (real_of_1 (p, l, r)) =\n  0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ex1 (root_cond (p, l, r)); u = real_of_1 (p, l, r);\n     local.tighten_poly_bounds_epsilon l r sr = (l', r', sr');\n     sr = sgn (ipoly p r)\\<rbrakk>\n    \\<Longrightarrow> l \\<le> l' \\<and>\n                      r' \\<le> r \\<and>\n                      r' - l' \\<le> x \\<and>\n                      root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "note simps = tighten_poly_bounds_epsilon.simps[of l r sr]"], ["proof (state)\nthis:\n  local.tighten_poly_bounds_epsilon l r sr =\n  (if r - l \\<le> x then (l, r, sr)\n   else case local.tighten_poly_bounds l r sr of\n        (l', r', sr') \\<Rightarrow>\n          local.tighten_poly_bounds_epsilon l' r' sr')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ex1 (root_cond (p, l, r)); u = real_of_1 (p, l, r);\n     local.tighten_poly_bounds_epsilon l r sr = (l', r', sr');\n     sr = sgn (ipoly p r)\\<rbrakk>\n    \\<Longrightarrow> l \\<le> l' \\<and>\n                      r' \\<le> r \\<and>\n                      r' - l' \\<le> x \\<and>\n                      root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "show \"l \\<le> l' \\<and> r' \\<le> r \\<and> r' - l' \\<le> x \\<and> root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "proof (cases \"r - l \\<le> x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n 2. \\<not> r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "case True"], ["proof (state)\nthis:\n  r - l \\<le> x\n\ngoal (2 subgoals):\n 1. r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n 2. \\<not> r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "with res[unfolded simps] ur tur(4) u sr"], ["proof (chain)\npicking this:\n  (if r - l \\<le> x then (l, r, sr)\n   else case local.tighten_poly_bounds l r sr of\n        (l', xa, xb) \\<Rightarrow>\n          local.tighten_poly_bounds_epsilon l' xa xb) =\n  (l', r', sr')\n  \\<exists>!x. root_cond (p, l, r) x\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  u = real_of_1 (p, l, r)\n  sr = sgn (ipoly p r)\n  r - l \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  (if r - l \\<le> x then (l, r, sr)\n   else case local.tighten_poly_bounds l r sr of\n        (l', xa, xb) \\<Rightarrow>\n          local.tighten_poly_bounds_epsilon l' xa xb) =\n  (l', r', sr')\n  \\<exists>!x. root_cond (p, l, r) x\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  u = real_of_1 (p, l, r)\n  sr = sgn (ipoly p r)\n  r - l \\<le> x\n\ngoal (1 subgoal):\n 1. l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "by auto"], ["proof (state)\nthis:\n  l \\<le> l' \\<and>\n  r' \\<le> r \\<and>\n  r' - l' \\<le> x \\<and>\n  root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. \\<not> r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "case False"], ["proof (state)\nthis:\n  \\<not> r - l \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "hence x: \"r - l > x\""], ["proof (prove)\nusing this:\n  \\<not> r - l \\<le> x\n\ngoal (1 subgoal):\n 1. x < r - l", "by auto"], ["proof (state)\nthis:\n  x < r - l\n\ngoal (1 subgoal):\n 1. \\<not> r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "let ?tight = \"tighten_poly_bounds l r sr\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "obtain L R SR where tight: \"?tight = (L,R,SR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>L R SR.\n        local.tighten_poly_bounds l r sr = (L, R, SR) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?tight, auto)"], ["proof (state)\nthis:\n  local.tighten_poly_bounds l r sr = (L, R, SR)\n\ngoal (1 subgoal):\n 1. \\<not> r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "note tighten = tighten_poly_bounds[OF tight[unfolded sr] ur p]"], ["proof (state)\nthis:\n  sgn (ipoly p r) = sgn (ipoly p r) \\<Longrightarrow>\n  root_cond (p, L, R) (real_of_1 (p, l, r))\n  sgn (ipoly p r) = sgn (ipoly p r) \\<Longrightarrow> l \\<le> L\n  sgn (ipoly p r) = sgn (ipoly p r) \\<Longrightarrow> L \\<le> R\n  sgn (ipoly p r) = sgn (ipoly p r) \\<Longrightarrow> R \\<le> r\n  sgn (ipoly p r) = sgn (ipoly p r) \\<Longrightarrow> R - L = (r - l) / 2\n  sgn (ipoly p r) = sgn (ipoly p r) \\<Longrightarrow> SR = sgn (ipoly p R)\n\ngoal (1 subgoal):\n 1. \\<not> r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "from unique_root_sub_interval[OF ur tighten(1-2,4)] p"], ["proof (chain)\npicking this:\n  \\<lbrakk>sgn (ipoly p r) = sgn (ipoly p r);\n   sgn (ipoly p r) = sgn (ipoly p r);\n   sgn (ipoly p r) = sgn (ipoly p r)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!x. root_cond (p, L, R) x\n  \\<lbrakk>sgn (ipoly p r) = sgn (ipoly p r);\n   sgn (ipoly p r) = sgn (ipoly p r);\n   sgn (ipoly p r) = sgn (ipoly p r)\\<rbrakk>\n  \\<Longrightarrow> real_of_1 (p, L, R) = real_of_1 (p, l, r)\n  poly_cond2 p", "have ur': \"unique_root (p,L,R)\" \"u = the_unique_root (p,L,R)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sgn (ipoly p r) = sgn (ipoly p r);\n   sgn (ipoly p r) = sgn (ipoly p r);\n   sgn (ipoly p r) = sgn (ipoly p r)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!x. root_cond (p, L, R) x\n  \\<lbrakk>sgn (ipoly p r) = sgn (ipoly p r);\n   sgn (ipoly p r) = sgn (ipoly p r);\n   sgn (ipoly p r) = sgn (ipoly p r)\\<rbrakk>\n  \\<Longrightarrow> real_of_1 (p, L, R) = real_of_1 (p, l, r)\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, L, R) x &&& u = real_of_1 (p, L, R)", "unfolding u"], ["proof (prove)\nusing this:\n  \\<lbrakk>sgn (ipoly p r) = sgn (ipoly p r);\n   sgn (ipoly p r) = sgn (ipoly p r);\n   sgn (ipoly p r) = sgn (ipoly p r)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!x. root_cond (p, L, R) x\n  \\<lbrakk>sgn (ipoly p r) = sgn (ipoly p r);\n   sgn (ipoly p r) = sgn (ipoly p r);\n   sgn (ipoly p r) = sgn (ipoly p r)\\<rbrakk>\n  \\<Longrightarrow> real_of_1 (p, L, R) = real_of_1 (p, l, r)\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, L, R) x &&&\n    real_of_1 (p, l, r) = real_of_1 (p, L, R)", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, L, R) x\n  u = real_of_1 (p, L, R)\n\ngoal (1 subgoal):\n 1. \\<not> r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "from res[unfolded simps tight] False sr"], ["proof (chain)\npicking this:\n  (if r - l \\<le> x then (l, r, sr)\n   else case (L, R, SR) of\n        (l', xa, xb) \\<Rightarrow>\n          local.tighten_poly_bounds_epsilon l' xa xb) =\n  (l', r', sr')\n  \\<not> r - l \\<le> x\n  sr = sgn (ipoly p r)", "have \"tighten_poly_bounds_epsilon L R SR = (l',r',sr')\""], ["proof (prove)\nusing this:\n  (if r - l \\<le> x then (l, r, sr)\n   else case (L, R, SR) of\n        (l', xa, xb) \\<Rightarrow>\n          local.tighten_poly_bounds_epsilon l' xa xb) =\n  (l', r', sr')\n  \\<not> r - l \\<le> x\n  sr = sgn (ipoly p r)\n\ngoal (1 subgoal):\n 1. local.tighten_poly_bounds_epsilon L R SR = (l', r', sr')", "by auto"], ["proof (state)\nthis:\n  local.tighten_poly_bounds_epsilon L R SR = (l', r', sr')\n\ngoal (1 subgoal):\n 1. \\<not> r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "note IH = 1[of \"(L,R,SR)\", unfolded tight split lr, rule_format, OF _ ur' this]"], ["proof (state)\nthis:\n  \\<lbrakk>((l, r, sr), L, R, SR)\n           \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n                  (\\<lambda>(l, r, sr). r - l);\n   SR = sgn (ipoly p R)\\<rbrakk>\n  \\<Longrightarrow> L \\<le> l' \\<and>\n                    r' \\<le> R \\<and>\n                    r' - l' \\<le> x \\<and>\n                    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. \\<not> r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "have \"L \\<le> l' \\<and> r' \\<le> R \\<and> r' - l' \\<le> x \\<and> root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<le> l' \\<and>\n    r' \\<le> R \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "by (rule IH, insert tighten False, auto simp: delta_gt_def delta_def)"], ["proof (state)\nthis:\n  L \\<le> l' \\<and>\n  r' \\<le> R \\<and>\n  r' - l' \\<le> x \\<and>\n  root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. \\<not> r - l \\<le> x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "thus ?thesis"], ["proof (prove)\nusing this:\n  L \\<le> l' \\<and>\n  r' \\<le> R \\<and>\n  r' - l' \\<le> x \\<and>\n  root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "using tighten"], ["proof (prove)\nusing this:\n  L \\<le> l' \\<and>\n  r' \\<le> R \\<and>\n  r' - l' \\<le> x \\<and>\n  root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n  sgn (ipoly p r) = sgn (ipoly p r) \\<Longrightarrow>\n  root_cond (p, L, R) (real_of_1 (p, l, r))\n  sgn (ipoly p r) = sgn (ipoly p r) \\<Longrightarrow> l \\<le> L\n  sgn (ipoly p r) = sgn (ipoly p r) \\<Longrightarrow> L \\<le> R\n  sgn (ipoly p r) = sgn (ipoly p r) \\<Longrightarrow> R \\<le> r\n  sgn (ipoly p r) = sgn (ipoly p r) \\<Longrightarrow> R - L = (r - l) / 2\n  sgn (ipoly p r) = sgn (ipoly p r) \\<Longrightarrow> SR = sgn (ipoly p R)\n\ngoal (1 subgoal):\n 1. l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "by auto"], ["proof (state)\nthis:\n  l \\<le> l' \\<and>\n  r' \\<le> r \\<and>\n  r' - l' \\<le> x \\<and>\n  root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l \\<le> l' \\<and>\n  r' \\<le> r \\<and>\n  r' - l' \\<le> x \\<and>\n  root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case lr of\n  (l, r, sr) \\<Rightarrow>\n    (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n    u = real_of_1 (p, l, r) \\<longrightarrow>\n    local.tighten_poly_bounds_epsilon l r sr =\n    (l', r', sr') \\<longrightarrow>\n    sr = sgn (ipoly p r) \\<longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case (l, r, sr) of\n  (l, r, sr) \\<Rightarrow>\n    (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n    u = real_of_1 (p, l, r) \\<longrightarrow>\n    local.tighten_poly_bounds_epsilon l r sr =\n    (l', r', sr') \\<longrightarrow>\n    sr = sgn (ipoly p r) \\<longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    r' - l' \\<le> x \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal (5 subgoals):\n 1. l \\<le> l'\n 2. r' \\<le> r\n 3. root_cond (p, l', r') u\n 4. r' - l' \\<le> x\n 5. sr' = sgn (ipoly p r')", "from this[unfolded split u, rule_format, OF ur refl res sr]"], ["proof (chain)\npicking this:\n  l \\<le> l' \\<and>\n  r' \\<le> r \\<and>\n  r' - l' \\<le> x \\<and>\n  root_cond (p, l', r') (real_of_1 (p, l, r)) \\<and> sr' = sgn (ipoly p r')", "show \"l \\<le> l'\" \"r' \\<le> r\" \"root_cond (p,l',r') u\" \"r' - l' \\<le> x\" \"sr' = sgn (ipoly p r')\""], ["proof (prove)\nusing this:\n  l \\<le> l' \\<and>\n  r' \\<le> r \\<and>\n  r' - l' \\<le> x \\<and>\n  root_cond (p, l', r') (real_of_1 (p, l, r)) \\<and> sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. (l \\<le> l' &&& r' \\<le> r) &&&\n    root_cond (p, l', r') u &&& r' - l' \\<le> x &&& sr' = sgn (ipoly p r')", "using u"], ["proof (prove)\nusing this:\n  l \\<le> l' \\<and>\n  r' \\<le> r \\<and>\n  r' - l' \\<le> x \\<and>\n  root_cond (p, l', r') (real_of_1 (p, l, r)) \\<and> sr' = sgn (ipoly p r')\n  u \\<equiv> real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. (l \\<le> l' &&& r' \\<le> r) &&&\n    root_cond (p, l', r') u &&& r' - l' \\<le> x &&& sr' = sgn (ipoly p r')", "by auto"], ["proof (state)\nthis:\n  l \\<le> l'\n  r' \\<le> r\n  root_cond (p, l', r') u\n  r' - l' \\<le> x\n  sr' = sgn (ipoly p r')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tighten_poly_bounds_for_x:\n  assumes ur: \"unique_root (p,l,r)\"\n  defines u: \"u \\<equiv> the_unique_root (p,l,r)\"\n  assumes p: \"poly_cond2 p\" \n      and res: \"tighten_poly_bounds_for_x l r sr = (l',r',sr')\"\n      and sr: \"sr = sgn (ipoly p r)\" \n  shows \"l \\<le> l'\" \"l' \\<le> r'\" \"r' \\<le> r\" \"root_cond (p,l',r') u\" \"\\<not> (l' \\<le> x \\<and> x \\<le> r')\" \"sr' = sgn (ipoly p r')\" \"unique_root (p,l',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l \\<le> l' &&& l' \\<le> r' &&& r' \\<le> r) &&&\n    (root_cond (p, l', r') u &&& \\<not> (l' \\<le> x \\<and> x \\<le> r')) &&&\n    sr' = sgn (ipoly p r') &&& \\<exists>!x. root_cond (p, l', r') x", "proof -"], ["proof (state)\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "let ?u = \"the_unique_root (p,l,r)\""], ["proof (state)\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "let ?x = \"real_of_rat x\""], ["proof (state)\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "define delta where \"delta = abs ((u - ?x) / 2)\""], ["proof (state)\nthis:\n  delta = \\<bar>(u - real_of_rat x) / 2\\<bar>\n\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "let ?p = \"real_of_int_poly p\""], ["proof (state)\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "note ru = unique_rootD[OF ur]"], ["proof (state)\nthis:\n  real_of_rat (rai_lb (p, l, r)) \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat (rai_ub (p, l, r))\n  poly (real_of_int_poly (poly_real_alg_1 (p, l, r)))\n   (real_of_1 (p, l, r)) =\n  0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y\n\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "{"], ["proof (state)\nthis:\n  real_of_rat (rai_lb (p, l, r)) \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat (rai_ub (p, l, r))\n  poly (real_of_int_poly (poly_real_alg_1 (p, l, r)))\n   (real_of_1 (p, l, r)) =\n  0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y\n\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "assume \"u = ?x\""], ["proof (state)\nthis:\n  u = real_of_rat x\n\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "note u = this[unfolded u]"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) = real_of_rat x\n\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "from poly_cond2_no_rat_root[OF p] ur"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly p) (real_of_rat ?x) \\<noteq> 0\n  \\<exists>!x. root_cond (p, l, r) x", "have False"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (real_of_rat ?x) \\<noteq> 0\n  \\<exists>!x. root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. False", "by (elim unique_rootE, auto simp: u)"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "}"], ["proof (state)\nthis:\n  u = real_of_rat x \\<Longrightarrow> False\n\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "hence delta: \"delta > 0\""], ["proof (prove)\nusing this:\n  u = real_of_rat x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. 0 < delta", "unfolding delta_def"], ["proof (prove)\nusing this:\n  u = real_of_rat x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. 0 < \\<bar>(u - real_of_rat x) / 2\\<bar>", "by auto"], ["proof (state)\nthis:\n  0 < delta\n\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "let ?dist = \"\\<lambda> (l,r,sr). real_of_rat (r - l)\""], ["proof (state)\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "let ?rel = \"inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y} ?dist\""], ["proof (state)\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "note SN = SN_inv_image[OF delta_gt_SN[OF delta], of ?dist]"], ["proof (state)\nthis:\n  SN (inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n       (\\<lambda>(l, r, sr). real_of_rat (r - l)))\n\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "note simps = res[unfolded tighten_poly_bounds_for_x.simps[of l r]]"], ["proof (state)\nthis:\n  (if x < l \\<or> r < x then (l, r, sr)\n   else case local.tighten_poly_bounds l r sr of\n        (l', xa, xb) \\<Rightarrow>\n          local.tighten_poly_bounds_for_x l' xa xb) =\n  (l', r', sr')\n\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "let ?P = \"\\<lambda> (l,r,sr). unique_root (p,l,r) \\<longrightarrow> u = the_unique_root (p,l,r) \n    \\<longrightarrow> tighten_poly_bounds_for_x l r sr = (l',r',sr') \n    \\<longrightarrow> sr = sgn (ipoly p r)\n    \\<longrightarrow> l \\<le> l' \\<and> r' \\<le> r \\<and> \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and> root_cond (p,l',r') u \\<and> sr' = sgn (ipoly p r')\""], ["proof (state)\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "have \"?P (l,r,sr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case (l, r, sr) of\n    (l, r, sr) \\<Rightarrow>\n      (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n      u = real_of_1 (p, l, r) \\<longrightarrow>\n      local.tighten_poly_bounds_for_x l r sr =\n      (l', r', sr') \\<longrightarrow>\n      sr = sgn (ipoly p r) \\<longrightarrow>\n      l \\<le> l' \\<and>\n      r' \\<le> r \\<and>\n      \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n      root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "proof (induct rule: SN_induct[OF SN])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n                  (\\<lambda>(l, r, sr).\n                      real_of_rat (r - l)) \\<Longrightarrow>\n           case b of\n           (l, r, sr) \\<Rightarrow>\n             (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n             u = real_of_1 (p, l, r) \\<longrightarrow>\n             local.tighten_poly_bounds_for_x l r sr =\n             (l', r', sr') \\<longrightarrow>\n             sr = sgn (ipoly p r) \\<longrightarrow>\n             l \\<le> l' \\<and>\n             r' \\<le> r \\<and>\n             \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n             root_cond (p, l', r') u \\<and>\n             sr' = sgn (ipoly p r')) \\<Longrightarrow>\n       case a of\n       (l, r, sr) \\<Rightarrow>\n         (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n         u = real_of_1 (p, l, r) \\<longrightarrow>\n         local.tighten_poly_bounds_for_x l r sr =\n         (l', r', sr') \\<longrightarrow>\n         sr = sgn (ipoly p r) \\<longrightarrow>\n         l \\<le> l' \\<and>\n         r' \\<le> r \\<and>\n         \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n         root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "case (1 lr)"], ["proof (state)\nthis:\n  (lr, ?b2)\n  \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n         (\\<lambda>(l, r, sr). real_of_rat (r - l)) \\<Longrightarrow>\n  case ?b2 of\n  (l, r, sr) \\<Rightarrow>\n    (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n    u = real_of_1 (p, l, r) \\<longrightarrow>\n    local.tighten_poly_bounds_for_x l r sr = (l', r', sr') \\<longrightarrow>\n    sr = sgn (ipoly p r) \\<longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n                  (\\<lambda>(l, r, sr).\n                      real_of_rat (r - l)) \\<Longrightarrow>\n           case b of\n           (l, r, sr) \\<Rightarrow>\n             (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n             u = real_of_1 (p, l, r) \\<longrightarrow>\n             local.tighten_poly_bounds_for_x l r sr =\n             (l', r', sr') \\<longrightarrow>\n             sr = sgn (ipoly p r) \\<longrightarrow>\n             l \\<le> l' \\<and>\n             r' \\<le> r \\<and>\n             \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n             root_cond (p, l', r') u \\<and>\n             sr' = sgn (ipoly p r')) \\<Longrightarrow>\n       case a of\n       (l, r, sr) \\<Rightarrow>\n         (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n         u = real_of_1 (p, l, r) \\<longrightarrow>\n         local.tighten_poly_bounds_for_x l r sr =\n         (l', r', sr') \\<longrightarrow>\n         sr = sgn (ipoly p r) \\<longrightarrow>\n         l \\<le> l' \\<and>\n         r' \\<le> r \\<and>\n         \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n         root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "obtain l r sr where lr: \"lr = (l,r,sr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l r sr.\n        lr = (l, r, sr) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases lr, auto)"], ["proof (state)\nthis:\n  lr = (l, r, sr)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n                  (\\<lambda>(l, r, sr).\n                      real_of_rat (r - l)) \\<Longrightarrow>\n           case b of\n           (l, r, sr) \\<Rightarrow>\n             (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n             u = real_of_1 (p, l, r) \\<longrightarrow>\n             local.tighten_poly_bounds_for_x l r sr =\n             (l', r', sr') \\<longrightarrow>\n             sr = sgn (ipoly p r) \\<longrightarrow>\n             l \\<le> l' \\<and>\n             r' \\<le> r \\<and>\n             \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n             root_cond (p, l', r') u \\<and>\n             sr' = sgn (ipoly p r')) \\<Longrightarrow>\n       case a of\n       (l, r, sr) \\<Rightarrow>\n         (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n         u = real_of_1 (p, l, r) \\<longrightarrow>\n         local.tighten_poly_bounds_for_x l r sr =\n         (l', r', sr') \\<longrightarrow>\n         sr = sgn (ipoly p r) \\<longrightarrow>\n         l \\<le> l' \\<and>\n         r' \\<le> r \\<and>\n         \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n         root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "let ?l = \"real_of_rat l\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n                  (\\<lambda>(l, r, sr).\n                      real_of_rat (r - l)) \\<Longrightarrow>\n           case b of\n           (l, r, sr) \\<Rightarrow>\n             (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n             u = real_of_1 (p, l, r) \\<longrightarrow>\n             local.tighten_poly_bounds_for_x l r sr =\n             (l', r', sr') \\<longrightarrow>\n             sr = sgn (ipoly p r) \\<longrightarrow>\n             l \\<le> l' \\<and>\n             r' \\<le> r \\<and>\n             \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n             root_cond (p, l', r') u \\<and>\n             sr' = sgn (ipoly p r')) \\<Longrightarrow>\n       case a of\n       (l, r, sr) \\<Rightarrow>\n         (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n         u = real_of_1 (p, l, r) \\<longrightarrow>\n         local.tighten_poly_bounds_for_x l r sr =\n         (l', r', sr') \\<longrightarrow>\n         sr = sgn (ipoly p r) \\<longrightarrow>\n         l \\<le> l' \\<and>\n         r' \\<le> r \\<and>\n         \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n         root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "let ?r = \"real_of_rat r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>b.\n           (a, b)\n           \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n                  (\\<lambda>(l, r, sr).\n                      real_of_rat (r - l)) \\<Longrightarrow>\n           case b of\n           (l, r, sr) \\<Rightarrow>\n             (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n             u = real_of_1 (p, l, r) \\<longrightarrow>\n             local.tighten_poly_bounds_for_x l r sr =\n             (l', r', sr') \\<longrightarrow>\n             sr = sgn (ipoly p r) \\<longrightarrow>\n             l \\<le> l' \\<and>\n             r' \\<le> r \\<and>\n             \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n             root_cond (p, l', r') u \\<and>\n             sr' = sgn (ipoly p r')) \\<Longrightarrow>\n       case a of\n       (l, r, sr) \\<Rightarrow>\n         (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n         u = real_of_1 (p, l, r) \\<longrightarrow>\n         local.tighten_poly_bounds_for_x l r sr =\n         (l', r', sr') \\<longrightarrow>\n         sr = sgn (ipoly p r) \\<longrightarrow>\n         l \\<le> l' \\<and>\n         r' \\<le> r \\<and>\n         \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n         root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. case lr of\n    (l, r, sr) \\<Rightarrow>\n      (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n      u = real_of_1 (p, l, r) \\<longrightarrow>\n      local.tighten_poly_bounds_for_x l r sr =\n      (l', r', sr') \\<longrightarrow>\n      sr = sgn (ipoly p r) \\<longrightarrow>\n      l \\<le> l' \\<and>\n      r' \\<le> r \\<and>\n      \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n      root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "unfolding lr split"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex1 (root_cond (p, l, r)) \\<longrightarrow>\n    u = real_of_1 (p, l, r) \\<longrightarrow>\n    local.tighten_poly_bounds_for_x l r sr = (l', r', sr') \\<longrightarrow>\n    sr = sgn (ipoly p r) \\<longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "proof (intro impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ex1 (root_cond (p, l, r)); u = real_of_1 (p, l, r);\n     local.tighten_poly_bounds_for_x l r sr = (l', r', sr');\n     sr = sgn (ipoly p r)\\<rbrakk>\n    \\<Longrightarrow> l \\<le> l' \\<and>\n                      r' \\<le> r \\<and>\n                      \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n                      root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "assume ur: \"unique_root (p, l, r)\"\n        and u: \"u = the_unique_root (p, l, r)\"\n        and res: \"tighten_poly_bounds_for_x l r sr = (l', r', sr')\"\n        and sr: \"sr = sgn (ipoly p r)\""], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, l, r) x\n  u = real_of_1 (p, l, r)\n  local.tighten_poly_bounds_for_x l r sr = (l', r', sr')\n  sr = sgn (ipoly p r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ex1 (root_cond (p, l, r)); u = real_of_1 (p, l, r);\n     local.tighten_poly_bounds_for_x l r sr = (l', r', sr');\n     sr = sgn (ipoly p r)\\<rbrakk>\n    \\<Longrightarrow> l \\<le> l' \\<and>\n                      r' \\<le> r \\<and>\n                      \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n                      root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "note tur = unique_rootD[OF ur]"], ["proof (state)\nthis:\n  real_of_rat (rai_lb (p, l, r)) \\<le> real_of_1 (p, l, r)\n  real_of_1 (p, l, r) \\<le> real_of_rat (rai_ub (p, l, r))\n  poly (real_of_int_poly (poly_real_alg_1 (p, l, r)))\n   (real_of_1 (p, l, r)) =\n  0\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  (real_of_1 (p, l, r) = ?y) = root_cond (p, l, r) ?y\n  (?y = real_of_1 (p, l, r)) = root_cond (p, l, r) ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ex1 (root_cond (p, l, r)); u = real_of_1 (p, l, r);\n     local.tighten_poly_bounds_for_x l r sr = (l', r', sr');\n     sr = sgn (ipoly p r)\\<rbrakk>\n    \\<Longrightarrow> l \\<le> l' \\<and>\n                      r' \\<le> r \\<and>\n                      \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n                      root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "note simps = tighten_poly_bounds_for_x.simps[of l r]"], ["proof (state)\nthis:\n  local.tighten_poly_bounds_for_x l r ?sr =\n  (if x < l \\<or> r < x then (l, r, ?sr)\n   else case local.tighten_poly_bounds l r ?sr of\n        (l', r', sr') \\<Rightarrow>\n          local.tighten_poly_bounds_for_x l' r' sr')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ex1 (root_cond (p, l, r)); u = real_of_1 (p, l, r);\n     local.tighten_poly_bounds_for_x l r sr = (l', r', sr');\n     sr = sgn (ipoly p r)\\<rbrakk>\n    \\<Longrightarrow> l \\<le> l' \\<and>\n                      r' \\<le> r \\<and>\n                      \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n                      root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "show \"l \\<le> l' \\<and> r' \\<le> r \\<and> \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and> root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "proof (cases \"x < l \\<or> r < x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "case True"], ["proof (state)\nthis:\n  x < l \\<or> r < x\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "with res[unfolded simps] ur tur(4) u sr"], ["proof (chain)\npicking this:\n  (if x < l \\<or> r < x then (l, r, sr)\n   else case local.tighten_poly_bounds l r sr of\n        (l', xa, xb) \\<Rightarrow>\n          local.tighten_poly_bounds_for_x l' xa xb) =\n  (l', r', sr')\n  \\<exists>!x. root_cond (p, l, r) x\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  u = real_of_1 (p, l, r)\n  sr = sgn (ipoly p r)\n  x < l \\<or> r < x", "show ?thesis"], ["proof (prove)\nusing this:\n  (if x < l \\<or> r < x then (l, r, sr)\n   else case local.tighten_poly_bounds l r sr of\n        (l', xa, xb) \\<Rightarrow>\n          local.tighten_poly_bounds_for_x l' xa xb) =\n  (l', r', sr')\n  \\<exists>!x. root_cond (p, l, r) x\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  u = real_of_1 (p, l, r)\n  sr = sgn (ipoly p r)\n  x < l \\<or> r < x\n\ngoal (1 subgoal):\n 1. l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "by auto"], ["proof (state)\nthis:\n  l \\<le> l' \\<and>\n  r' \\<le> r \\<and>\n  \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n  root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "case False"], ["proof (state)\nthis:\n  \\<not> (x < l \\<or> r < x)\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "hence x: \"?l \\<le> ?x\" \"?x \\<le> ?r\""], ["proof (prove)\nusing this:\n  \\<not> (x < l \\<or> r < x)\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> real_of_rat x &&& real_of_rat x \\<le> real_of_rat r", "by (auto simp: of_rat_less_eq)"], ["proof (state)\nthis:\n  real_of_rat l \\<le> real_of_rat x\n  real_of_rat x \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "let ?tight = \"tighten_poly_bounds l r sr\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "obtain L R SR where tight: \"?tight = (L,R,SR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>L R SR.\n        local.tighten_poly_bounds l r sr = (L, R, SR) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?tight, auto)"], ["proof (state)\nthis:\n  local.tighten_poly_bounds l r sr = (L, R, SR)\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "note tighten = tighten_poly_bounds[OF tight ur p sr]"], ["proof (state)\nthis:\n  root_cond (p, L, R) (real_of_1 (p, l, r))\n  l \\<le> L\n  L \\<le> R\n  R \\<le> r\n  R - L = (r - l) / 2\n  SR = sgn (ipoly p R)\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "from unique_root_sub_interval[OF ur tighten(1-2,4)] p"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond (p, L, R) x\n  real_of_1 (p, L, R) = real_of_1 (p, l, r)\n  poly_cond2 p", "have ur': \"unique_root (p,L,R)\" \"u = the_unique_root (p,L,R)\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond (p, L, R) x\n  real_of_1 (p, L, R) = real_of_1 (p, l, r)\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, L, R) x &&& u = real_of_1 (p, L, R)", "unfolding u"], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond (p, L, R) x\n  real_of_1 (p, L, R) = real_of_1 (p, l, r)\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, L, R) x &&&\n    real_of_1 (p, l, r) = real_of_1 (p, L, R)", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, L, R) x\n  u = real_of_1 (p, L, R)\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "from res[unfolded simps tight] False"], ["proof (chain)\npicking this:\n  (if x < l \\<or> r < x then (l, r, sr)\n   else case (L, R, SR) of\n        (l', xa, xb) \\<Rightarrow>\n          local.tighten_poly_bounds_for_x l' xa xb) =\n  (l', r', sr')\n  \\<not> (x < l \\<or> r < x)", "have \"tighten_poly_bounds_for_x L R SR = (l',r',sr')\""], ["proof (prove)\nusing this:\n  (if x < l \\<or> r < x then (l, r, sr)\n   else case (L, R, SR) of\n        (l', xa, xb) \\<Rightarrow>\n          local.tighten_poly_bounds_for_x l' xa xb) =\n  (l', r', sr')\n  \\<not> (x < l \\<or> r < x)\n\ngoal (1 subgoal):\n 1. local.tighten_poly_bounds_for_x L R SR = (l', r', sr')", "by auto"], ["proof (state)\nthis:\n  local.tighten_poly_bounds_for_x L R SR = (l', r', sr')\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "note IH = 1[of ?tight, unfolded tight split lr, rule_format, OF _ ur' this]"], ["proof (state)\nthis:\n  \\<lbrakk>((l, r, sr), L, R, SR)\n           \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n                  (\\<lambda>(l, r, sr). real_of_rat (r - l));\n   SR = sgn (ipoly p R)\\<rbrakk>\n  \\<Longrightarrow> L \\<le> l' \\<and>\n                    r' \\<le> R \\<and>\n                    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n                    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "let ?DIFF = \"real_of_rat (R - L)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "let ?diff = \"real_of_rat (r - l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "have diff0: \"0 \\<le> ?DIFF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_rat (R - L)", "using tighten(3)"], ["proof (prove)\nusing this:\n  L \\<le> R\n\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_rat (R - L)", "by (metis cancel_comm_monoid_add_class.diff_cancel diff_right_mono of_rat_less_eq of_rat_hom.hom_zero)"], ["proof (state)\nthis:\n  0 \\<le> real_of_rat (R - L)\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "have *: \"r - l - (r - l) / 2 = (r - l) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r - l - (r - l) / 2 = (r - l) / 2", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  r - l - (r - l) / 2 = (r - l) / 2\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "have \"delta_gt delta ?diff ?DIFF = (abs (u - of_rat x) \\<le> real_of_rat (r - l) * 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_gt delta (real_of_rat (r - l)) (real_of_rat (R - L)) =\n    (\\<bar>u - real_of_rat x\\<bar> \\<le> real_of_rat (r - l) * 1)", "unfolding delta_gt_def tighten(5) delta_def of_rat_diff[symmetric] *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bar>(u - real_of_rat x) / 2\\<bar> \\<le> real_of_rat ((r - l) / 2)) =\n    (\\<bar>u - real_of_rat x\\<bar> \\<le> real_of_rat (r - l) * 1)", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  delta_gt delta (real_of_rat (r - l)) (real_of_rat (R - L)) =\n  (\\<bar>u - real_of_rat x\\<bar> \\<le> real_of_rat (r - l) * 1)\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "also"], ["proof (state)\nthis:\n  delta_gt delta (real_of_rat (r - l)) (real_of_rat (R - L)) =\n  (\\<bar>u - real_of_rat x\\<bar> \\<le> real_of_rat (r - l) * 1)\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "have \"real_of_rat (r - l) * 1 = ?r - ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (r - l) * 1 = real_of_rat r - real_of_rat l", "unfolding of_rat_divide of_rat_mult of_rat_diff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (real_of_rat r - real_of_rat l) * 1 = real_of_rat r - real_of_rat l", "by auto"], ["proof (state)\nthis:\n  real_of_rat (r - l) * 1 = real_of_rat r - real_of_rat l\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "also"], ["proof (state)\nthis:\n  real_of_rat (r - l) * 1 = real_of_rat r - real_of_rat l\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "have \"abs (u - of_rat x) \\<le> ?r - ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>u - real_of_rat x\\<bar> \\<le> real_of_rat r - real_of_rat l", "using x ur"], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> real_of_rat x\n  real_of_rat x \\<le> real_of_rat r\n  \\<exists>!x. root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. \\<bar>u - real_of_rat x\\<bar> \\<le> real_of_rat r - real_of_rat l", "by (elim unique_rootE, auto simp: u)"], ["proof (state)\nthis:\n  \\<bar>u - real_of_rat x\\<bar> \\<le> real_of_rat r - real_of_rat l\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "finally"], ["proof (chain)\npicking this:\n  delta_gt delta (real_of_rat (r - l)) (real_of_rat (R - L))", "have delta: \"delta_gt delta ?diff ?DIFF\""], ["proof (prove)\nusing this:\n  delta_gt delta (real_of_rat (r - l)) (real_of_rat (R - L))\n\ngoal (1 subgoal):\n 1. delta_gt delta (real_of_rat (r - l)) (real_of_rat (R - L))", "."], ["proof (state)\nthis:\n  delta_gt delta (real_of_rat (r - l)) (real_of_rat (R - L))\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "have \"L \\<le> l' \\<and> r' \\<le> R \\<and> \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and> root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<le> l' \\<and>\n    r' \\<le> R \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "by (rule IH, insert delta diff0 tighten(6), auto)"], ["proof (state)\nthis:\n  L \\<le> l' \\<and>\n  r' \\<le> R \\<and>\n  \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n  root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "with \\<open>l \\<le> L\\<close> \\<open>R \\<le> r\\<close>"], ["proof (chain)\npicking this:\n  l \\<le> L\n  R \\<le> r\n  L \\<le> l' \\<and>\n  r' \\<le> R \\<and>\n  \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n  root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<le> L\n  R \\<le> r\n  L \\<le> l' \\<and>\n  r' \\<le> R \\<and>\n  \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n  root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')", "by auto"], ["proof (state)\nthis:\n  l \\<le> l' \\<and>\n  r' \\<le> r \\<and>\n  \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n  root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l \\<le> l' \\<and>\n  r' \\<le> r \\<and>\n  \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n  root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case lr of\n  (l, r, sr) \\<Rightarrow>\n    (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n    u = real_of_1 (p, l, r) \\<longrightarrow>\n    local.tighten_poly_bounds_for_x l r sr = (l', r', sr') \\<longrightarrow>\n    sr = sgn (ipoly p r) \\<longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case (l, r, sr) of\n  (l, r, sr) \\<Rightarrow>\n    (\\<exists>!x. root_cond (p, l, r) x) \\<longrightarrow>\n    u = real_of_1 (p, l, r) \\<longrightarrow>\n    local.tighten_poly_bounds_for_x l r sr = (l', r', sr') \\<longrightarrow>\n    sr = sgn (ipoly p r) \\<longrightarrow>\n    l \\<le> l' \\<and>\n    r' \\<le> r \\<and>\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n    root_cond (p, l', r') u \\<and> sr' = sgn (ipoly p r')\n\ngoal (7 subgoals):\n 1. l \\<le> l'\n 2. l' \\<le> r'\n 3. r' \\<le> r\n 4. root_cond (p, l', r') u\n 5. \\<not> (l' \\<le> x \\<and> x \\<le> r')\n 6. sr' = sgn (ipoly p r')\n 7. \\<exists>!x. root_cond (p, l', r') x", "from this[unfolded split u, rule_format, OF ur refl res sr]"], ["proof (chain)\npicking this:\n  l \\<le> l' \\<and>\n  r' \\<le> r \\<and>\n  \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n  root_cond (p, l', r') (real_of_1 (p, l, r)) \\<and> sr' = sgn (ipoly p r')", "show *: \"l \\<le> l'\" \"r' \\<le> r\" \"root_cond (p,l',r') u\" \"\\<not> (l' \\<le> x \\<and> x \\<le> r')\" \"sr' = sgn (ipoly p r')\""], ["proof (prove)\nusing this:\n  l \\<le> l' \\<and>\n  r' \\<le> r \\<and>\n  \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n  root_cond (p, l', r') (real_of_1 (p, l, r)) \\<and> sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. (l \\<le> l' &&& r' \\<le> r) &&&\n    root_cond (p, l', r') u &&&\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') &&& sr' = sgn (ipoly p r')", "unfolding u"], ["proof (prove)\nusing this:\n  l \\<le> l' \\<and>\n  r' \\<le> r \\<and>\n  \\<not> (l' \\<le> x \\<and> x \\<le> r') \\<and>\n  root_cond (p, l', r') (real_of_1 (p, l, r)) \\<and> sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. (l \\<le> l' &&& r' \\<le> r) &&&\n    root_cond (p, l', r') (real_of_1 (p, l, r)) &&&\n    \\<not> (l' \\<le> x \\<and> x \\<le> r') &&& sr' = sgn (ipoly p r')", "by auto"], ["proof (state)\nthis:\n  l \\<le> l'\n  r' \\<le> r\n  root_cond (p, l', r') u\n  \\<not> (l' \\<le> x \\<and> x \\<le> r')\n  sr' = sgn (ipoly p r')\n\ngoal (2 subgoals):\n 1. l' \\<le> r'\n 2. \\<exists>!x. root_cond (p, l', r') x", "from *(3)[unfolded split]"], ["proof (chain)\npicking this:\n  root_cond (p, l', r') u", "have \"real_of_rat l' \\<le> of_rat r'\""], ["proof (prove)\nusing this:\n  root_cond (p, l', r') u\n\ngoal (1 subgoal):\n 1. real_of_rat l' \\<le> real_of_rat r'", "by auto"], ["proof (state)\nthis:\n  real_of_rat l' \\<le> real_of_rat r'\n\ngoal (2 subgoals):\n 1. l' \\<le> r'\n 2. \\<exists>!x. root_cond (p, l', r') x", "thus \"l' \\<le> r'\""], ["proof (prove)\nusing this:\n  real_of_rat l' \\<le> real_of_rat r'\n\ngoal (1 subgoal):\n 1. l' \\<le> r'", "unfolding of_rat_less_eq"], ["proof (prove)\nusing this:\n  l' \\<le> r'\n\ngoal (1 subgoal):\n 1. l' \\<le> r'", "."], ["proof (state)\nthis:\n  l' \\<le> r'\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, l', r') x", "show \"unique_root (p,l',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, l', r') x", "using ur *(1-3) p poly_condD(5) u unique_root_sub_interval(1)"], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond (p, l, r) x\n  l \\<le> l'\n  r' \\<le> r\n  root_cond (p, l', r') u\n  poly_cond2 p\n  poly_cond ?p \\<Longrightarrow> ?p \\<noteq> 0\n  u \\<equiv> real_of_1 (p, l, r)\n  \\<lbrakk>\\<exists>!x. root_cond (?p, ?l, ?r) x;\n   root_cond (?p, ?l', ?r') (real_of_1 (?p, ?l, ?r)); ?l \\<le> ?l';\n   ?r' \\<le> ?r\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!x. root_cond (?p, ?l', ?r') x\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, l', r') x", "by blast"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, l', r') x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition real_alg_precision :: rat where\n  \"real_alg_precision \\<equiv> Rat.Fract 1 2\""], ["", "lemma real_alg_precision: \"real_alg_precision > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < real_alg_precision", "by eval"], ["", "definition normalize_bounds_1_main :: \"rat \\<Rightarrow> real_alg_1 \\<Rightarrow> real_alg_1\" where\n  \"normalize_bounds_1_main eps rai = (case rai of (p,l,r) \\<Rightarrow>\n    let (l',r',sr') = tighten_poly_bounds_epsilon p eps l r (sgn (ipoly p r));\n        fr = rat_of_int (floor r');\n        (l'',r'',_) = tighten_poly_bounds_for_x p fr l' r' sr'\n    in (p,l'',r''))\""], ["", "definition normalize_bounds_1 :: \"real_alg_1 \\<Rightarrow> real_alg_1\" where \n  \"normalize_bounds_1 = (normalize_bounds_1_main real_alg_precision)\""], ["", "context\n  fixes p q and l r :: rat\n  assumes cong: \"\\<And> x. real_of_rat l \\<le> x \\<Longrightarrow> x \\<le> of_rat r \\<Longrightarrow> (ipoly p x = (0 :: real)) = (ipoly q x = 0)\"\nbegin"], ["", "lemma root_cond_cong: \"root_cond (p,l,r) = root_cond (q,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_cond (p, l, r) = root_cond (q, l, r)", "by (intro ext, insert cong, auto simp: root_cond_def)"], ["", "lemma the_unique_root_cong: \n  \"the_unique_root (p,l,r) = the_unique_root (q,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) = real_of_1 (q, l, r)", "unfolding root_cond_cong"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 (q, l, r) = real_of_1 (q, l, r)", ".."], ["", "lemma unique_root_cong: \n  \"unique_root (p,l,r) = unique_root (q,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (p, l, r) x) =\n    (\\<exists>!x. root_cond (q, l, r) x)", "unfolding root_cond_cong"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l, r) x) =\n    (\\<exists>!x. root_cond (q, l, r) x)", ".."], ["", "end"], ["", "lemma normalize_bounds_1_main: assumes eps: \"eps > 0\" and rc: \"invariant_1_2 x\"\n  defines y: \"y \\<equiv> normalize_bounds_1_main eps x\"\n  shows \"invariant_1_2 y \\<and> (real_of_1 y = real_of_1 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = real_of_1 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = real_of_1 x", "obtain p l r where x: \"x = (p,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p l r. x = (p, l, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x) auto"], ["proof (state)\nthis:\n  x = (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = real_of_1 x", "note rc = rc[unfolded x]"], ["proof (state)\nthis:\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = real_of_1 x", "obtain l' r' sr' where tb: \"tighten_poly_bounds_epsilon p eps l r (sgn (ipoly p r)) = (l',r',sr')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l' r' sr'.\n        tighten_poly_bounds_epsilon p eps l r (sgn (ipoly p r)) =\n        (l', r', sr') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases rule: prod_cases3, auto)"], ["proof (state)\nthis:\n  tighten_poly_bounds_epsilon p eps l r (sgn (ipoly p r)) = (l', r', sr')\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = real_of_1 x", "let ?fr = \"rat_of_int (floor r')\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = real_of_1 x", "obtain l'' r'' sr'' where tbx: \"tighten_poly_bounds_for_x p ?fr l' r' sr' = (l'',r'',sr'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l'' r'' sr''.\n        tighten_poly_bounds_for_x p (rat_of_int \\<lfloor>r'\\<rfloor>) l' r'\n         sr' =\n        (l'', r'', sr'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases rule: prod_cases3, auto)"], ["proof (state)\nthis:\n  tighten_poly_bounds_for_x p (rat_of_int \\<lfloor>r'\\<rfloor>) l' r' sr' =\n  (l'', r'', sr'')\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = real_of_1 x", "from y[unfolded normalize_bounds_1_main_def x] tb tbx"], ["proof (chain)\npicking this:\n  y \\<equiv>\n  case (p, l, r) of\n  (p, l, r) \\<Rightarrow>\n    let (l', r', sr') =\n          tighten_poly_bounds_epsilon p eps l r (sgn (ipoly p r));\n        fr = rat_of_int \\<lfloor>r'\\<rfloor>;\n        (l'', r'', uu_) = tighten_poly_bounds_for_x p fr l' r' sr'\n    in (p, l'', r'')\n  tighten_poly_bounds_epsilon p eps l r (sgn (ipoly p r)) = (l', r', sr')\n  tighten_poly_bounds_for_x p (rat_of_int \\<lfloor>r'\\<rfloor>) l' r' sr' =\n  (l'', r'', sr'')", "have y: \"y = (p, l'', r'')\""], ["proof (prove)\nusing this:\n  y \\<equiv>\n  case (p, l, r) of\n  (p, l, r) \\<Rightarrow>\n    let (l', r', sr') =\n          tighten_poly_bounds_epsilon p eps l r (sgn (ipoly p r));\n        fr = rat_of_int \\<lfloor>r'\\<rfloor>;\n        (l'', r'', uu_) = tighten_poly_bounds_for_x p fr l' r' sr'\n    in (p, l'', r'')\n  tighten_poly_bounds_epsilon p eps l r (sgn (ipoly p r)) = (l', r', sr')\n  tighten_poly_bounds_for_x p (rat_of_int \\<lfloor>r'\\<rfloor>) l' r' sr' =\n  (l'', r'', sr'')\n\ngoal (1 subgoal):\n 1. y = (p, l'', r'')", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  y = (p, l'', r'')\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = real_of_1 x", "from rc"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l, r)", "have \"unique_root (p, l, r)\" and p2: \"poly_cond2 p\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, l, r) x &&& poly_cond2 p", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = real_of_1 x", "from tighten_poly_bounds_epsilon[OF this tb refl eps]"], ["proof (chain)\npicking this:\n  l \\<le> l'\n  r' \\<le> r\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n  r' - l' \\<le> eps\n  sr' = sgn (ipoly p r')", "have bnd: \"l \\<le> l'\" \"r' \\<le> r\" and rc': \"root_cond (p, l', r') (the_unique_root (p, l, r))\" \n    and eps: \"r' - l' \\<le> eps\" (* currently not relevant for lemma *)\n    and sr': \"sr' = sgn (ipoly p r')\""], ["proof (prove)\nusing this:\n  l \\<le> l'\n  r' \\<le> r\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n  r' - l' \\<le> eps\n  sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. ((l \\<le> l' &&& r' \\<le> r) &&&\n     root_cond (p, l', r') (real_of_1 (p, l, r))) &&&\n    r' - l' \\<le> eps &&& sr' = sgn (ipoly p r')", "by auto"], ["proof (state)\nthis:\n  l \\<le> l'\n  r' \\<le> r\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n  r' - l' \\<le> eps\n  sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = real_of_1 x", "from invariant_1_sub_interval[OF _ rc' bnd] rc"], ["proof (chain)\npicking this:\n  invariant_1 (p, l, r) \\<Longrightarrow> invariant_1 (p, l', r')\n  invariant_1 (p, l, r) \\<Longrightarrow>\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n  invariant_1_2 (p, l, r)", "have inv': \"invariant_1 (p, l', r')\" and eq: \"real_of_1 (p, l', r') = real_of_1 (p, l, r)\""], ["proof (prove)\nusing this:\n  invariant_1 (p, l, r) \\<Longrightarrow> invariant_1 (p, l', r')\n  invariant_1 (p, l, r) \\<Longrightarrow>\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l', r') &&& real_of_1 (p, l', r') = real_of_1 (p, l, r)", "by auto"], ["proof (state)\nthis:\n  invariant_1 (p, l', r')\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = real_of_1 x", "have bnd: \"l' \\<le> l''\" \"r'' \\<le> r'\" and rc': \"root_cond (p, l'', r'') (the_unique_root (p, l', r'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l' \\<le> l'' &&& r'' \\<le> r') &&&\n    root_cond (p, l'', r'') (real_of_1 (p, l', r'))", "by (rule tighten_poly_bounds_for_x[OF _ p2 tbx sr'], fact invariant_1D[OF inv'])+"], ["proof (state)\nthis:\n  l' \\<le> l''\n  r'' \\<le> r'\n  root_cond (p, l'', r'') (real_of_1 (p, l', r'))\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = real_of_1 x", "from invariant_1_sub_interval[OF inv' rc' bnd] p2 eq"], ["proof (chain)\npicking this:\n  invariant_1 (p, l'', r'')\n  real_of_1 (p, l'', r'') = real_of_1 (p, l', r')\n  poly_cond2 p\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant_1 (p, l'', r'')\n  real_of_1 (p, l'', r'') = real_of_1 (p, l', r')\n  poly_cond2 p\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = real_of_1 x", "unfolding y x"], ["proof (prove)\nusing this:\n  invariant_1 (p, l'', r'')\n  real_of_1 (p, l'', r'') = real_of_1 (p, l', r')\n  poly_cond2 p\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1_2 (p, l'', r'') \\<and>\n    real_of_1 (p, l'', r'') = real_of_1 (p, l, r)", "by auto"], ["proof (state)\nthis:\n  invariant_1_2 y \\<and> real_of_1 y = real_of_1 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_bounds_1: assumes x: \"invariant_1_2 x\"\n  shows \"invariant_1_2 (normalize_bounds_1 x) \\<and> (real_of_1 (normalize_bounds_1 x) = real_of_1 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1_2 (normalize_bounds_1 x) \\<and>\n    real_of_1 (normalize_bounds_1 x) = real_of_1 x", "proof(cases x)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 (normalize_bounds_1 x) \\<and>\n       real_of_1 (normalize_bounds_1 x) = real_of_1 x", "case xx:(fields p l r)"], ["proof (state)\nthis:\n  x = (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 (normalize_bounds_1 x) \\<and>\n       real_of_1 (normalize_bounds_1 x) = real_of_1 x", "let ?res = \"(p,l,r)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 (normalize_bounds_1 x) \\<and>\n       real_of_1 (normalize_bounds_1 x) = real_of_1 x", "have norm: \"normalize_bounds_1 x = (normalize_bounds_1_main real_alg_precision ?res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize_bounds_1 x =\n    normalize_bounds_1_main real_alg_precision (p, l, r)", "unfolding normalize_bounds_1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize_bounds_1_main real_alg_precision x =\n    normalize_bounds_1_main real_alg_precision (p, l, r)", "by (simp add: xx)"], ["proof (state)\nthis:\n  normalize_bounds_1 x =\n  normalize_bounds_1_main real_alg_precision (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 (normalize_bounds_1 x) \\<and>\n       real_of_1 (normalize_bounds_1 x) = real_of_1 x", "from x"], ["proof (chain)\npicking this:\n  invariant_1_2 x", "have x: \"invariant_1_2 ?res\" \"real_of_1 ?res = real_of_1 x\""], ["proof (prove)\nusing this:\n  invariant_1_2 x\n\ngoal (1 subgoal):\n 1. invariant_1_2 (p, l, r) &&& real_of_1 (p, l, r) = real_of_1 x", "unfolding xx"], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1_2 (p, l, r) &&& real_of_1 (p, l, r) = real_of_1 (p, l, r)", "by auto"], ["proof (state)\nthis:\n  invariant_1_2 (p, l, r)\n  real_of_1 (p, l, r) = real_of_1 x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 (normalize_bounds_1 x) \\<and>\n       real_of_1 (normalize_bounds_1 x) = real_of_1 x", "from normalize_bounds_1_main[OF real_alg_precision x(1)] x(2-)"], ["proof (chain)\npicking this:\n  invariant_1_2\n   (normalize_bounds_1_main real_alg_precision (p, l, r)) \\<and>\n  real_of_1 (normalize_bounds_1_main real_alg_precision (p, l, r)) =\n  real_of_1 (p, l, r)\n  real_of_1 (p, l, r) = real_of_1 x", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant_1_2\n   (normalize_bounds_1_main real_alg_precision (p, l, r)) \\<and>\n  real_of_1 (normalize_bounds_1_main real_alg_precision (p, l, r)) =\n  real_of_1 (p, l, r)\n  real_of_1 (p, l, r) = real_of_1 x\n\ngoal (1 subgoal):\n 1. invariant_1_2 (normalize_bounds_1 x) \\<and>\n    real_of_1 (normalize_bounds_1 x) = real_of_1 x", "unfolding normalize_bounds_1_def xx"], ["proof (prove)\nusing this:\n  invariant_1_2\n   (normalize_bounds_1_main real_alg_precision (p, l, r)) \\<and>\n  real_of_1 (normalize_bounds_1_main real_alg_precision (p, l, r)) =\n  real_of_1 (p, l, r)\n  real_of_1 (p, l, r) = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1_2\n     (normalize_bounds_1_main real_alg_precision (p, l, r)) \\<and>\n    real_of_1 (normalize_bounds_1_main real_alg_precision (p, l, r)) =\n    real_of_1 (p, l, r)", "by auto"], ["proof (state)\nthis:\n  invariant_1_2 (normalize_bounds_1 x) \\<and>\n  real_of_1 (normalize_bounds_1 x) = real_of_1 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_bound_1_poly: \"poly_real_alg_1 (normalize_bounds_1 rai) = poly_real_alg_1 rai\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_real_alg_1 (normalize_bounds_1 rai) = poly_real_alg_1 rai", "unfolding normalize_bounds_1_def normalize_bounds_1_main_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_real_alg_1\n     (case rai of\n      (p, l, r) \\<Rightarrow>\n        case tighten_poly_bounds_epsilon p real_alg_precision l r\n              (sgn (ipoly p r)) of\n        (l', r', sr') \\<Rightarrow>\n          case tighten_poly_bounds_for_x p (rat_of_int \\<lfloor>r'\\<rfloor>)\n                l' r' sr' of\n          (l'', r'', uu_) \\<Rightarrow> (p, l'', r'')) =\n    poly_real_alg_1 rai", "by (auto split: prod.splits)"], ["", "definition real_alg_2_main :: \"root_info \\<Rightarrow> real_alg_1 \\<Rightarrow> real_alg_2\" where \n  \"real_alg_2_main ri rai \\<equiv> let p = poly_real_alg_1 rai\n     in (if degree p = 1 then Rational (Rat.Fract (- coeff p 0) (coeff p 1))\n       else (case normalize_bounds_1 rai of (p',l,r) \\<Rightarrow>\n       Irrational (root_info.number_root ri r) (p',l,r)))\""], ["", "definition real_alg_2 :: \"real_alg_1 \\<Rightarrow> real_alg_2\" where \n  \"real_alg_2 rai \\<equiv> let p = poly_real_alg_1 rai\n     in (if degree p = 1 then Rational (Rat.Fract (- coeff p 0) (coeff p 1))\n       else (case normalize_bounds_1 rai of (p',l,r) \\<Rightarrow>\n       Irrational (root_info.number_root (root_info p) r) (p',l,r)))\""], ["", "lemma degree_1_ipoly: assumes \"degree p = Suc 0\"\n  shows \"ipoly p x = 0 \\<longleftrightarrow> (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (real_of_int_poly p) x = 0) =\n    (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly (real_of_int_poly p) x = 0) =\n    (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))", "from roots1[of \"map_poly real_of_int p\"] assms"], ["proof (chain)\npicking this:\n  degree (real_of_int_poly p) = 1 \\<Longrightarrow>\n  {x. poly (real_of_int_poly p) x = 0} = {roots1 (real_of_int_poly p)}\n  degree p = Suc 0", "have \"ipoly p x = 0 \\<longleftrightarrow> x \\<in> {roots1 (real_of_int_poly p)}\""], ["proof (prove)\nusing this:\n  degree (real_of_int_poly p) = 1 \\<Longrightarrow>\n  {x. poly (real_of_int_poly p) x = 0} = {roots1 (real_of_int_poly p)}\n  degree p = Suc 0\n\ngoal (1 subgoal):\n 1. (poly (real_of_int_poly p) x = 0) =\n    (x \\<in> {roots1 (real_of_int_poly p)})", "by auto"], ["proof (state)\nthis:\n  (poly (real_of_int_poly p) x = 0) =\n  (x \\<in> {roots1 (real_of_int_poly p)})\n\ngoal (1 subgoal):\n 1. (poly (real_of_int_poly p) x = 0) =\n    (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))", "also"], ["proof (state)\nthis:\n  (poly (real_of_int_poly p) x = 0) =\n  (x \\<in> {roots1 (real_of_int_poly p)})\n\ngoal (1 subgoal):\n 1. (poly (real_of_int_poly p) x = 0) =\n    (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))", "have \"\\<dots> = (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> {roots1 (real_of_int_poly p)}) =\n    (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))", "unfolding Fract_of_int_quotient roots1_def hom_distribs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> {- coeff (real_of_int_poly p) 0 /\n              coeff (real_of_int_poly p) 1}) =\n    (x =\n     - real_of_rat (rat_of_int (coeff p 0)) /\n     real_of_rat (rat_of_int (coeff p 1)))", "by auto"], ["proof (state)\nthis:\n  (x \\<in> {roots1 (real_of_int_poly p)}) =\n  (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))\n\ngoal (1 subgoal):\n 1. (poly (real_of_int_poly p) x = 0) =\n    (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))", "finally"], ["proof (chain)\npicking this:\n  (poly (real_of_int_poly p) x = 0) =\n  (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (poly (real_of_int_poly p) x = 0) =\n  (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))\n\ngoal (1 subgoal):\n 1. (poly (real_of_int_poly p) x = 0) =\n    (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))", "."], ["proof (state)\nthis:\n  (poly (real_of_int_poly p) x = 0) =\n  (x = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invariant_1_degree_0:\n  assumes inv: \"invariant_1 rai\"\n  shows \"degree (poly_real_alg_1 rai) \\<noteq> 0\" (is \"degree ?p \\<noteq> 0\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_real_alg_1 rai) \\<noteq> 0", "proof (rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (poly_real_alg_1 rai) = 0 \\<Longrightarrow> False", "assume deg: \"degree ?p = 0\""], ["proof (state)\nthis:\n  degree (poly_real_alg_1 rai) = 0\n\ngoal (1 subgoal):\n 1. degree (poly_real_alg_1 rai) = 0 \\<Longrightarrow> False", "from inv"], ["proof (chain)\npicking this:\n  invariant_1 rai", "have \"ipoly ?p (real_of_1 rai) = 0\""], ["proof (prove)\nusing this:\n  invariant_1 rai\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly (poly_real_alg_1 rai)) (real_of_1 rai) = 0", "by auto"], ["proof (state)\nthis:\n  poly (real_of_int_poly (poly_real_alg_1 rai)) (real_of_1 rai) = 0\n\ngoal (1 subgoal):\n 1. degree (poly_real_alg_1 rai) = 0 \\<Longrightarrow> False", "with deg"], ["proof (chain)\npicking this:\n  degree (poly_real_alg_1 rai) = 0\n  poly (real_of_int_poly (poly_real_alg_1 rai)) (real_of_1 rai) = 0", "have \"?p = 0\""], ["proof (prove)\nusing this:\n  degree (poly_real_alg_1 rai) = 0\n  poly (real_of_int_poly (poly_real_alg_1 rai)) (real_of_1 rai) = 0\n\ngoal (1 subgoal):\n 1. poly_real_alg_1 rai = 0", "by (meson less_Suc0 representsI represents_degree)"], ["proof (state)\nthis:\n  poly_real_alg_1 rai = 0\n\ngoal (1 subgoal):\n 1. degree (poly_real_alg_1 rai) = 0 \\<Longrightarrow> False", "with inv"], ["proof (chain)\npicking this:\n  invariant_1 rai\n  poly_real_alg_1 rai = 0", "show False"], ["proof (prove)\nusing this:\n  invariant_1 rai\n  poly_real_alg_1 rai = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma real_alg_2_main:\n  assumes inv: \"invariant_1 rai\"\n  defines [simp]: \"p \\<equiv> poly_real_alg_1 rai\"\n  assumes ric: \"irreducible (poly_real_alg_1 rai) \\<Longrightarrow> root_info_cond ri (poly_real_alg_1 rai)\" \n  shows \"invariant_2 (real_alg_2_main ri rai)\" \"real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2_main ri rai) &&&\n    real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "proof (atomize(full))"], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2_main ri rai) \\<and>\n    real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "define l r where [simp]: \"l \\<equiv> rai_lb rai\" and [simp]: \"r \\<equiv> rai_ub rai\""], ["proof (state)\nthis:\n  l \\<equiv> rai_lb rai\n  r \\<equiv> rai_ub rai\n\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2_main ri rai) \\<and>\n    real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "show \"invariant_2 (real_alg_2_main ri rai) \\<and> real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2_main ri rai) \\<and>\n    real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2_main ri rai) \\<and>\n    real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "using invariant_1D"], ["proof (prove)\nusing this:\n  invariant_1 ?plr \\<Longrightarrow> root_cond ?plr (real_of_1 ?plr)\n  invariant_1 ?plr \\<Longrightarrow> sgn (rai_lb ?plr) = sgn (rai_ub ?plr)\n  invariant_1 ?plr \\<Longrightarrow>\n  sgn (real_of_1 ?plr) = real_of_rat (sgn (rai_ub ?plr))\n  invariant_1 ?plr \\<Longrightarrow> \\<exists>!x. root_cond ?plr x\n  invariant_1 ?plr \\<Longrightarrow> poly_cond (poly_real_alg_1 ?plr)\n  invariant_1 ?plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 ?plr)\n  invariant_1 ?plr \\<Longrightarrow> primitive (poly_real_alg_1 ?plr)\n\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2_main ri rai) \\<and>\n    real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "proof (cases \"degree p\" \"Suc 0\" rule: linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p = Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 3. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "case deg: equal"], ["proof (state)\nthis:\n  degree p = Suc 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p = Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 3. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "hence id: \"real_alg_2_main ri rai = Rational (Rat.Fract (- coeff p 0) (coeff p 1))\""], ["proof (prove)\nusing this:\n  degree p = Suc 0\n\ngoal (1 subgoal):\n 1. real_alg_2_main ri rai = Rational (Rat.Fract (- coeff p 0) (coeff p 1))", "unfolding real_alg_2_main_def Let_def"], ["proof (prove)\nusing this:\n  degree p = Suc 0\n\ngoal (1 subgoal):\n 1. (if degree (poly_real_alg_1 rai) = 1\n     then Rational\n           (Rat.Fract (- coeff (poly_real_alg_1 rai) 0)\n             (coeff (poly_real_alg_1 rai) 1))\n     else case normalize_bounds_1 rai of\n          (p', l, r) \\<Rightarrow>\n            Irrational (root_info.number_root ri r) (p', l, r)) =\n    Rational (Rat.Fract (- coeff p 0) (coeff p 1))", "by auto"], ["proof (state)\nthis:\n  real_alg_2_main ri rai = Rational (Rat.Fract (- coeff p 0) (coeff p 1))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p = Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 3. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "note rc = invariant_1D[OF inv]"], ["proof (state)\nthis:\n  root_cond rai (real_of_1 rai)\n  sgn (rai_lb rai) = sgn (rai_ub rai)\n  sgn (real_of_1 rai) = real_of_rat (sgn (rai_ub rai))\n  \\<exists>!x. root_cond rai x\n  poly_cond (poly_real_alg_1 rai)\n  0 < degree (poly_real_alg_1 rai)\n  primitive (poly_real_alg_1 rai)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p = Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 3. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "from degree_1_ipoly[OF deg, of \"the_unique_root rai\"] rc(1)"], ["proof (chain)\npicking this:\n  (poly (real_of_int_poly p) (real_of_1 rai) = 0) =\n  (real_of_1 rai = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))\n  root_cond rai (real_of_1 rai)", "show ?thesis"], ["proof (prove)\nusing this:\n  (poly (real_of_int_poly p) (real_of_1 rai) = 0) =\n  (real_of_1 rai = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))\n  root_cond rai (real_of_1 rai)\n\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2_main ri rai) \\<and>\n    real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "unfolding id"], ["proof (prove)\nusing this:\n  (poly (real_of_int_poly p) (real_of_1 rai) = 0) =\n  (real_of_1 rai = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))\n  root_cond rai (real_of_1 rai)\n\ngoal (1 subgoal):\n 1. invariant_2 (Rational (Rat.Fract (- coeff p 0) (coeff p 1))) \\<and>\n    real_of_2 (Rational (Rat.Fract (- coeff p 0) (coeff p 1))) =\n    real_of_1 rai", "by auto"], ["proof (state)\nthis:\n  invariant_2 (real_alg_2_main ri rai) \\<and>\n  real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "case deg: greater"], ["proof (state)\nthis:\n  Suc 0 < degree p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "with inv"], ["proof (chain)\npicking this:\n  invariant_1 rai\n  Suc 0 < degree p", "have inv: \"invariant_1_2 rai\""], ["proof (prove)\nusing this:\n  invariant_1 rai\n  Suc 0 < degree p\n\ngoal (1 subgoal):\n 1. invariant_1_2 rai", "unfolding p_def"], ["proof (prove)\nusing this:\n  invariant_1 rai\n  Suc 0 < degree (poly_real_alg_1 rai)\n\ngoal (1 subgoal):\n 1. invariant_1_2 rai", "by auto"], ["proof (state)\nthis:\n  invariant_1_2 rai\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "define rai' where \"rai' = normalize_bounds_1 rai\""], ["proof (state)\nthis:\n  rai' = normalize_bounds_1 rai\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "have rai': \"real_of_1 rai = real_of_1 rai'\" and inv': \"invariant_1_2 rai'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 rai = real_of_1 rai' &&& invariant_1_2 rai'", "unfolding rai'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 rai = real_of_1 (normalize_bounds_1 rai) &&&\n    invariant_1_2 (normalize_bounds_1 rai)", "using normalize_bounds_1[OF inv]"], ["proof (prove)\nusing this:\n  invariant_1_2 (normalize_bounds_1 rai) \\<and>\n  real_of_1 (normalize_bounds_1 rai) = real_of_1 rai\n\ngoal (1 subgoal):\n 1. real_of_1 rai = real_of_1 (normalize_bounds_1 rai) &&&\n    invariant_1_2 (normalize_bounds_1 rai)", "by auto"], ["proof (state)\nthis:\n  real_of_1 rai = real_of_1 rai'\n  invariant_1_2 rai'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "obtain p' l' r' where \"rai' = (p',l',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p' l' r'.\n        rai' = (p', l', r') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases rai')"], ["proof (state)\nthis:\n  rai' = (p', l', r')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "with arg_cong[OF rai'_def, of poly_real_alg_1, unfolded normalize_bound_1_poly] split"], ["proof (chain)\npicking this:\n  poly_real_alg_1 rai' = poly_real_alg_1 rai\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n  rai' = (p', l', r')", "have split: \"rai' = (p,l',r')\""], ["proof (prove)\nusing this:\n  poly_real_alg_1 rai' = poly_real_alg_1 rai\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n  rai' = (p', l', r')\n\ngoal (1 subgoal):\n 1. rai' = (p, l', r')", "by auto"], ["proof (state)\nthis:\n  rai' = (p, l', r')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "from inv'[unfolded split]"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l', r')", "have \"poly_cond p\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l', r')\n\ngoal (1 subgoal):\n 1. poly_cond p", "by auto"], ["proof (state)\nthis:\n  poly_cond p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "from poly_condD[OF this]"], ["proof (chain)\npicking this:\n  irreducible p\n  0 < lead_coeff p\n  root_free p\n  square_free p\n  p \\<noteq> 0", "have irr: \"irreducible p\""], ["proof (prove)\nusing this:\n  irreducible p\n  0 < lead_coeff p\n  root_free p\n  square_free p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irreducible p", "by simp"], ["proof (state)\nthis:\n  irreducible p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "from ric irr"], ["proof (chain)\npicking this:\n  irreducible (poly_real_alg_1 rai) \\<Longrightarrow>\n  root_info_cond ri (poly_real_alg_1 rai)\n  irreducible p", "have ric: \"root_info_cond ri p\""], ["proof (prove)\nusing this:\n  irreducible (poly_real_alg_1 rai) \\<Longrightarrow>\n  root_info_cond ri (poly_real_alg_1 rai)\n  irreducible p\n\ngoal (1 subgoal):\n 1. root_info_cond ri p", "by auto"], ["proof (state)\nthis:\n  root_info_cond ri p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "have id: \"real_alg_2_main ri rai = (Irrational (root_info.number_root ri r') rai')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_alg_2_main ri rai = Irrational (root_info.number_root ri r') rai'", "unfolding real_alg_2_main_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if degree (poly_real_alg_1 rai) = 1\n     then Rational\n           (Rat.Fract (- coeff (poly_real_alg_1 rai) 0)\n             (coeff (poly_real_alg_1 rai) 1))\n     else case normalize_bounds_1 rai of\n          (p', l, r) \\<Rightarrow>\n            Irrational (root_info.number_root ri r) (p', l, r)) =\n    Irrational (root_info.number_root ri r') rai'", "using deg split rai'_def"], ["proof (prove)\nusing this:\n  Suc 0 < degree p\n  rai' = (p, l', r')\n  rai' = normalize_bounds_1 rai\n\ngoal (1 subgoal):\n 1. (if degree (poly_real_alg_1 rai) = 1\n     then Rational\n           (Rat.Fract (- coeff (poly_real_alg_1 rai) 0)\n             (coeff (poly_real_alg_1 rai) 1))\n     else case normalize_bounds_1 rai of\n          (p', l, r) \\<Rightarrow>\n            Irrational (root_info.number_root ri r) (p', l, r)) =\n    Irrational (root_info.number_root ri r') rai'", "by (auto simp: rai'_def rai')"], ["proof (state)\nthis:\n  real_alg_2_main ri rai = Irrational (root_info.number_root ri r') rai'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n 2. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     Suc 0 < degree p\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2_main ri rai) \\<and>\n    real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (Irrational (root_info.number_root ri r') rai') \\<and>\n    real_of_2 (Irrational (root_info.number_root ri r') rai') =\n    real_of_1 rai", "using rai' root_info_condD(2)[OF ric] \n         inv'[unfolded split]"], ["proof (prove)\nusing this:\n  real_of_1 rai = real_of_1 rai'\n  root_info.number_root ri ?a =\n  card {x. x \\<le> real_of_rat ?a \\<and> poly (real_of_int_poly p) x = 0}\n  invariant_1_2 (p, l', r')\n\ngoal (1 subgoal):\n 1. invariant_2 (Irrational (root_info.number_root ri r') rai') \\<and>\n    real_of_2 (Irrational (root_info.number_root ri r') rai') =\n    real_of_1 rai", "apply (elim invariant_1_2E invariant_1E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>real_of_1 rai = real_of_1 rai';\n     \\<And>a.\n        root_info.number_root ri a =\n        card\n         {x. x \\<le> real_of_rat a \\<and> poly (real_of_int_poly p) x = 0};\n     1 < degree (poly_real_alg_1 (p, l', r'));\n     root_cond (p, l', r') (real_of_1 (p, l', r'));\n     sgn (rai_lb (p, l', r')) = sgn (rai_ub (p, l', r'));\n     sgn (real_of_1 (p, l', r')) = real_of_rat (sgn (rai_ub (p, l', r')));\n     \\<exists>!x. root_cond (p, l', r') x;\n     poly_cond (poly_real_alg_1 (p, l', r'));\n     0 < degree (poly_real_alg_1 (p, l', r'));\n     primitive (poly_real_alg_1 (p, l', r'))\\<rbrakk>\n    \\<Longrightarrow> invariant_2\n                       (Irrational (root_info.number_root ri r')\n                         rai') \\<and>\n                      real_of_2\n                       (Irrational (root_info.number_root ri r') rai') =\n                      real_of_1 rai", "using inv'"], ["proof (prove)\nusing this:\n  invariant_1_2 rai'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>real_of_1 rai = real_of_1 rai';\n     \\<And>a.\n        root_info.number_root ri a =\n        card\n         {x. x \\<le> real_of_rat a \\<and> poly (real_of_int_poly p) x = 0};\n     1 < degree (poly_real_alg_1 (p, l', r'));\n     root_cond (p, l', r') (real_of_1 (p, l', r'));\n     sgn (rai_lb (p, l', r')) = sgn (rai_ub (p, l', r'));\n     sgn (real_of_1 (p, l', r')) = real_of_rat (sgn (rai_ub (p, l', r')));\n     \\<exists>!x. root_cond (p, l', r') x;\n     poly_cond (poly_real_alg_1 (p, l', r'));\n     0 < degree (poly_real_alg_1 (p, l', r'));\n     primitive (poly_real_alg_1 (p, l', r'))\\<rbrakk>\n    \\<Longrightarrow> invariant_2\n                       (Irrational (root_info.number_root ri r')\n                         rai') \\<and>\n                      real_of_2\n                       (Irrational (root_info.number_root ri r') rai') =\n                      real_of_1 rai", "by(auto simp: split roots_below_the_unique_root)"], ["proof (state)\nthis:\n  invariant_2 (real_alg_2_main ri rai) \\<and>\n  real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "case deg: less"], ["proof (state)\nthis:\n  degree p < Suc 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "then"], ["proof (chain)\npicking this:\n  degree p < Suc 0", "have \"degree p = 0\""], ["proof (prove)\nusing this:\n  degree p < Suc 0\n\ngoal (1 subgoal):\n 1. degree p = 0", "by auto"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "from this invariant_1_degree_0[OF inv]"], ["proof (chain)\npicking this:\n  degree p = 0\n  degree (poly_real_alg_1 rai) \\<noteq> 0", "have \"p = 0\""], ["proof (prove)\nusing this:\n  degree p = 0\n  degree (poly_real_alg_1 rai) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p = 0", "by simp"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>plr.\n                invariant_1 plr \\<Longrightarrow>\n                root_cond plr (real_of_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (rai_lb plr) = sgn (rai_ub plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow>\n        sgn (real_of_1 plr) = real_of_rat (sgn (rai_ub plr));\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> \\<exists>!x. root_cond plr x;\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> poly_cond (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> 0 < degree (poly_real_alg_1 plr);\n     \\<And>plr.\n        invariant_1 plr \\<Longrightarrow> primitive (poly_real_alg_1 plr);\n     degree p < Suc 0\\<rbrakk>\n    \\<Longrightarrow> invariant_2 (real_alg_2_main ri rai) \\<and>\n                      real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "with inv"], ["proof (chain)\npicking this:\n  invariant_1 rai\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant_1 rai\n  p = 0\n\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2_main ri rai) \\<and>\n    real_of_2 (real_alg_2_main ri rai) = real_of_1 rai", "by auto"], ["proof (state)\nthis:\n  invariant_2 (real_alg_2_main ri rai) \\<and>\n  real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invariant_2 (real_alg_2_main ri rai) \\<and>\n  real_of_2 (real_alg_2_main ri rai) = real_of_1 rai\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma real_alg_2: assumes \"invariant_1 rai\" \n  shows \"invariant_2 (real_alg_2 rai)\" \"real_of_2 (real_alg_2 rai) = real_of_1 rai\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2 rai) &&&\n    real_of_2 (real_alg_2 rai) = real_of_1 rai", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. invariant_2 (real_alg_2 rai)\n 2. real_of_2 (real_alg_2 rai) = real_of_1 rai", "have deg: \"0 < degree (poly_real_alg_1 rai)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree (poly_real_alg_1 rai)", "using assms"], ["proof (prove)\nusing this:\n  invariant_1 rai\n\ngoal (1 subgoal):\n 1. 0 < degree (poly_real_alg_1 rai)", "by auto"], ["proof (state)\nthis:\n  0 < degree (poly_real_alg_1 rai)\n\ngoal (2 subgoals):\n 1. invariant_2 (real_alg_2 rai)\n 2. real_of_2 (real_alg_2 rai) = real_of_1 rai", "have \"real_alg_2 rai = real_alg_2_main (root_info (poly_real_alg_1 rai)) rai\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_alg_2 rai = real_alg_2_main (root_info (poly_real_alg_1 rai)) rai", "unfolding real_alg_2_def real_alg_2_main_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if degree (poly_real_alg_1 rai) = 1\n     then Rational\n           (Rat.Fract (- coeff (poly_real_alg_1 rai) 0)\n             (coeff (poly_real_alg_1 rai) 1))\n     else case normalize_bounds_1 rai of\n          (p', l, r) \\<Rightarrow>\n            Irrational\n             (root_info.number_root (root_info (poly_real_alg_1 rai)) r)\n             (p', l, r)) =\n    (if degree (poly_real_alg_1 rai) = 1\n     then Rational\n           (Rat.Fract (- coeff (poly_real_alg_1 rai) 0)\n             (coeff (poly_real_alg_1 rai) 1))\n     else case normalize_bounds_1 rai of\n          (p', l, r) \\<Rightarrow>\n            Irrational\n             (root_info.number_root (root_info (poly_real_alg_1 rai)) r)\n             (p', l, r))", "by auto"], ["proof (state)\nthis:\n  real_alg_2 rai = real_alg_2_main (root_info (poly_real_alg_1 rai)) rai\n\ngoal (2 subgoals):\n 1. invariant_2 (real_alg_2 rai)\n 2. real_of_2 (real_alg_2 rai) = real_of_1 rai", "from real_alg_2_main[OF assms root_info, folded this, simplified] deg"], ["proof (chain)\npicking this:\n  (irreducible (poly_real_alg_1 rai) \\<Longrightarrow>\n   0 < degree (poly_real_alg_1 rai)) \\<Longrightarrow>\n  invariant_2 (real_alg_2 rai)\n  (irreducible (poly_real_alg_1 rai) \\<Longrightarrow>\n   0 < degree (poly_real_alg_1 rai)) \\<Longrightarrow>\n  real_of_2 (real_alg_2 rai) = real_of_1 rai\n  0 < degree (poly_real_alg_1 rai)", "show \"invariant_2 (real_alg_2 rai)\" \"real_of_2 (real_alg_2 rai) = real_of_1 rai\""], ["proof (prove)\nusing this:\n  (irreducible (poly_real_alg_1 rai) \\<Longrightarrow>\n   0 < degree (poly_real_alg_1 rai)) \\<Longrightarrow>\n  invariant_2 (real_alg_2 rai)\n  (irreducible (poly_real_alg_1 rai) \\<Longrightarrow>\n   0 < degree (poly_real_alg_1 rai)) \\<Longrightarrow>\n  real_of_2 (real_alg_2 rai) = real_of_1 rai\n  0 < degree (poly_real_alg_1 rai)\n\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2 rai) &&&\n    real_of_2 (real_alg_2 rai) = real_of_1 rai", "by auto"], ["proof (state)\nthis:\n  invariant_2 (real_alg_2 rai)\n  real_of_2 (real_alg_2 rai) = real_of_1 rai\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invariant_2_realI:\n  fixes plr :: real_alg_1\n  defines \"p \\<equiv> poly_real_alg_1 plr\" and \"l \\<equiv> rai_lb plr\" and \"r \\<equiv> rai_ub plr\"\n  assumes x: \"root_cond plr x\" and sgn: \"sgn l = sgn r\"\n      and ur: \"unique_root plr\"\n      and p: \"poly_cond p\"\n  shows \"invariant_2 (real_alg_2 plr) \\<and> real_of_2 (real_alg_2 plr) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2 plr) \\<and> real_of_2 (real_alg_2 plr) = x", "using invariant_1_realI[OF x,folded p_def l_def r_def] sgn ur p\n    real_alg_2[of plr]"], ["proof (prove)\nusing this:\n  \\<lbrakk>sgn l = sgn r; \\<exists>!x. root_cond plr x; poly_cond p\\<rbrakk>\n  \\<Longrightarrow> invariant_1 plr \\<and> real_of_1 plr = x\n  sgn l = sgn r\n  \\<exists>!x. root_cond plr x\n  poly_cond p\n  invariant_1 plr \\<Longrightarrow> invariant_2 (real_alg_2 plr)\n  invariant_1 plr \\<Longrightarrow>\n  real_of_2 (real_alg_2 plr) = real_of_1 plr\n\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2 plr) \\<and> real_of_2 (real_alg_2 plr) = x", "by auto"], ["", "(* ********************* *)"], ["", "subsubsection \\<open>Comparisons\\<close>"], ["", "fun compare_rat_1 :: \"rat \\<Rightarrow> real_alg_1 \\<Rightarrow> order\" where\n  \"compare_rat_1 x (p,l,r) = (if x < l then Lt else if x > r then Gt else\n      if sgn (ipoly p x) = sgn(ipoly p r) then Gt else Lt)\""], ["", "lemma compare_rat_1: assumes rai: \"invariant_1_2 y\" \n  shows \"compare_rat_1 x y = compare (of_rat x) (real_of_1 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "define p l r where \"p \\<equiv> poly_real_alg_1 y\" \"l \\<equiv> rai_lb y\" \"r \\<equiv> rai_ub y\""], ["proof (state)\nthis:\n  p \\<equiv> poly_real_alg_1 y\n  l \\<equiv> rai_lb y\n  r \\<equiv> rai_ub y\n\ngoal (1 subgoal):\n 1. compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "then"], ["proof (chain)\npicking this:\n  p \\<equiv> poly_real_alg_1 y\n  l \\<equiv> rai_lb y\n  r \\<equiv> rai_ub y", "have y [simp]: \"y = (p,l,r)\""], ["proof (prove)\nusing this:\n  p \\<equiv> poly_real_alg_1 y\n  l \\<equiv> rai_lb y\n  r \\<equiv> rai_ub y\n\ngoal (1 subgoal):\n 1. y = (p, l, r)", "by (cases y, auto)"], ["proof (state)\nthis:\n  y = (p, l, r)\n\ngoal (1 subgoal):\n 1. compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "from rai"], ["proof (chain)\npicking this:\n  invariant_1_2 y", "have ur: \"unique_root y\""], ["proof (prove)\nusing this:\n  invariant_1_2 y\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond y x", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond y x\n\ngoal (1 subgoal):\n 1. compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "proof (cases \"x < l \\<or> x > r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "case True"], ["proof (state)\nthis:\n  x < l \\<or> r < x\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "{"], ["proof (state)\nthis:\n  x < l \\<or> r < x\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "assume xl: \"x < l\""], ["proof (state)\nthis:\n  x < l\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "hence \"real_of_rat x < of_rat l\""], ["proof (prove)\nusing this:\n  x < l\n\ngoal (1 subgoal):\n 1. real_of_rat x < real_of_rat l", "unfolding of_rat_less"], ["proof (prove)\nusing this:\n  x < l\n\ngoal (1 subgoal):\n 1. x < l", "by auto"], ["proof (state)\nthis:\n  real_of_rat x < real_of_rat l\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "with rai"], ["proof (chain)\npicking this:\n  invariant_1_2 y\n  real_of_rat x < real_of_rat l", "have \"of_rat x < the_unique_root y\""], ["proof (prove)\nusing this:\n  invariant_1_2 y\n  real_of_rat x < real_of_rat l\n\ngoal (1 subgoal):\n 1. real_of_rat x < real_of_1 y", "by (auto elim!: invariant_1E)"], ["proof (state)\nthis:\n  real_of_rat x < real_of_1 y\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "with xl rai"], ["proof (chain)\npicking this:\n  x < l\n  invariant_1_2 y\n  real_of_rat x < real_of_1 y", "have ?thesis"], ["proof (prove)\nusing this:\n  x < l\n  invariant_1_2 y\n  real_of_rat x < real_of_1 y\n\ngoal (1 subgoal):\n 1. compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "by (cases y, auto simp: compare_real_def comparator_of_def)"], ["proof (state)\nthis:\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "}"], ["proof (state)\nthis:\n  x < l \\<Longrightarrow>\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "moreover"], ["proof (state)\nthis:\n  x < l \\<Longrightarrow>\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "{"], ["proof (state)\nthis:\n  x < l \\<Longrightarrow>\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "assume xr: \"\\<not> x < l\" \"x > r\""], ["proof (state)\nthis:\n  \\<not> x < l\n  r < x\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "hence \"real_of_rat x > of_rat r\""], ["proof (prove)\nusing this:\n  \\<not> x < l\n  r < x\n\ngoal (1 subgoal):\n 1. real_of_rat r < real_of_rat x", "unfolding of_rat_less"], ["proof (prove)\nusing this:\n  \\<not> x < l\n  r < x\n\ngoal (1 subgoal):\n 1. r < x", "by auto"], ["proof (state)\nthis:\n  real_of_rat r < real_of_rat x\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "with rai"], ["proof (chain)\npicking this:\n  invariant_1_2 y\n  real_of_rat r < real_of_rat x", "have \"of_rat x > the_unique_root y\""], ["proof (prove)\nusing this:\n  invariant_1_2 y\n  real_of_rat r < real_of_rat x\n\ngoal (1 subgoal):\n 1. real_of_1 y < real_of_rat x", "by (auto elim!: invariant_1E)"], ["proof (state)\nthis:\n  real_of_1 y < real_of_rat x\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "with xr rai"], ["proof (chain)\npicking this:\n  \\<not> x < l\n  r < x\n  invariant_1_2 y\n  real_of_1 y < real_of_rat x", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<not> x < l\n  r < x\n  invariant_1_2 y\n  real_of_1 y < real_of_rat x\n\ngoal (1 subgoal):\n 1. compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "by (cases y, auto simp: compare_real_def comparator_of_def)"], ["proof (state)\nthis:\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> x < l; r < x\\<rbrakk>\n  \\<Longrightarrow> compare_rat_1 x y =\n                    compare (real_of_rat x) (real_of_1 y)\n\ngoal (2 subgoals):\n 1. x < l \\<or> r < x \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n 2. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "ultimately"], ["proof (chain)\npicking this:\n  x < l \\<Longrightarrow>\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n  \\<lbrakk>\\<not> x < l; r < x\\<rbrakk>\n  \\<Longrightarrow> compare_rat_1 x y =\n                    compare (real_of_rat x) (real_of_1 y)", "show ?thesis"], ["proof (prove)\nusing this:\n  x < l \\<Longrightarrow>\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n  \\<lbrakk>\\<not> x < l; r < x\\<rbrakk>\n  \\<Longrightarrow> compare_rat_1 x y =\n                    compare (real_of_rat x) (real_of_1 y)\n\ngoal (1 subgoal):\n 1. compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "using True"], ["proof (prove)\nusing this:\n  x < l \\<Longrightarrow>\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n  \\<lbrakk>\\<not> x < l; r < x\\<rbrakk>\n  \\<Longrightarrow> compare_rat_1 x y =\n                    compare (real_of_rat x) (real_of_1 y)\n  x < l \\<or> r < x\n\ngoal (1 subgoal):\n 1. compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "by auto"], ["proof (state)\nthis:\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "case False"], ["proof (state)\nthis:\n  \\<not> (x < l \\<or> r < x)\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "have 0: \"ipoly p (real_of_rat x) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) (real_of_rat x) \\<noteq> 0", "by (rule poly_cond2_no_rat_root, insert rai, auto)"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) (real_of_rat x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "with rai"], ["proof (chain)\npicking this:\n  invariant_1_2 y\n  poly (real_of_int_poly p) (real_of_rat x) \\<noteq> 0", "have diff: \"real_of_1 y \\<noteq> of_rat x\""], ["proof (prove)\nusing this:\n  invariant_1_2 y\n  poly (real_of_int_poly p) (real_of_rat x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_1 y \\<noteq> real_of_rat x", "by (auto elim!: invariant_1E)"], ["proof (state)\nthis:\n  real_of_1 y \\<noteq> real_of_rat x\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "have \"\\<And> P. (1 < degree (poly_real_alg_1 y) \\<Longrightarrow> \\<exists>!x. root_cond y x \\<Longrightarrow> poly_cond p \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       (\\<lbrakk>1 < degree (poly_real_alg_1 y); \\<exists>!x. root_cond y x;\n         poly_cond p\\<rbrakk>\n        \\<Longrightarrow> P) \\<Longrightarrow>\n       P", "using poly_real_alg_1.simps y rai invariant_1_2E invariant_1E"], ["proof (prove)\nusing this:\n  poly_real_alg_1 (?p, ?uu, ?uv) = ?p\n  y = (p, l, r)\n  invariant_1_2 y\n  \\<lbrakk>invariant_1_2 ?rai;\n   \\<lbrakk>invariant_1 ?rai; 1 < degree (poly_real_alg_1 ?rai)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>invariant_1 ?plr;\n   \\<lbrakk>root_cond ?plr (real_of_1 ?plr);\n    sgn (rai_lb ?plr) = sgn (rai_ub ?plr);\n    sgn (real_of_1 ?plr) = real_of_rat (sgn (rai_ub ?plr));\n    \\<exists>!x. root_cond ?plr x; poly_cond (poly_real_alg_1 ?plr);\n    0 < degree (poly_real_alg_1 ?plr);\n    primitive (poly_real_alg_1 ?plr)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       (\\<lbrakk>1 < degree (poly_real_alg_1 y); \\<exists>!x. root_cond y x;\n         poly_cond p\\<rbrakk>\n        \\<Longrightarrow> P) \\<Longrightarrow>\n       P", "by metis"], ["proof (state)\nthis:\n  (\\<lbrakk>1 < degree (poly_real_alg_1 y); \\<exists>!x. root_cond y x;\n    poly_cond p\\<rbrakk>\n   \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "from this[OF gt_rat_sign_change] False"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>1 < degree (poly_real_alg_1 y);\n            \\<exists>!x. root_cond y x; poly_cond p\\<rbrakk>\n           \\<Longrightarrow> \\<exists>!x. root_cond ?plr1 x;\n   \\<lbrakk>1 < degree (poly_real_alg_1 y); \\<exists>!x. root_cond y x;\n    poly_cond p\\<rbrakk>\n   \\<Longrightarrow> poly_cond2 (poly_real_alg_1 ?plr1);\n   \\<lbrakk>1 < degree (poly_real_alg_1 y); \\<exists>!x. root_cond y x;\n    poly_cond p\\<rbrakk>\n   \\<Longrightarrow> rai_lb ?plr1 \\<le> ?y1;\n   \\<lbrakk>1 < degree (poly_real_alg_1 y); \\<exists>!x. root_cond y x;\n    poly_cond p\\<rbrakk>\n   \\<Longrightarrow> ?y1 \\<le> rai_ub ?plr1\\<rbrakk>\n  \\<Longrightarrow> (sgn (ipoly (poly_real_alg_1 ?plr1) ?y1) =\n                     sgn (ipoly (poly_real_alg_1 ?plr1) (rai_ub ?plr1))) =\n                    (real_of_1 ?plr1 < real_of_rat ?y1)\n  \\<not> (x < l \\<or> r < x)", "have left: \"compare_rat_1 x y = (if real_of_rat x \\<le> the_unique_root y then Lt else Gt)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>1 < degree (poly_real_alg_1 y);\n            \\<exists>!x. root_cond y x; poly_cond p\\<rbrakk>\n           \\<Longrightarrow> \\<exists>!x. root_cond ?plr1 x;\n   \\<lbrakk>1 < degree (poly_real_alg_1 y); \\<exists>!x. root_cond y x;\n    poly_cond p\\<rbrakk>\n   \\<Longrightarrow> poly_cond2 (poly_real_alg_1 ?plr1);\n   \\<lbrakk>1 < degree (poly_real_alg_1 y); \\<exists>!x. root_cond y x;\n    poly_cond p\\<rbrakk>\n   \\<Longrightarrow> rai_lb ?plr1 \\<le> ?y1;\n   \\<lbrakk>1 < degree (poly_real_alg_1 y); \\<exists>!x. root_cond y x;\n    poly_cond p\\<rbrakk>\n   \\<Longrightarrow> ?y1 \\<le> rai_ub ?plr1\\<rbrakk>\n  \\<Longrightarrow> (sgn (ipoly (poly_real_alg_1 ?plr1) ?y1) =\n                     sgn (ipoly (poly_real_alg_1 ?plr1) (rai_ub ?plr1))) =\n                    (real_of_1 ?plr1 < real_of_rat ?y1)\n  \\<not> (x < l \\<or> r < x)\n\ngoal (1 subgoal):\n 1. compare_rat_1 x y = (if real_of_rat x \\<le> real_of_1 y then Lt else Gt)", "by (auto simp:poly_cond2_def)"], ["proof (state)\nthis:\n  compare_rat_1 x y = (if real_of_rat x \\<le> real_of_1 y then Lt else Gt)\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "also"], ["proof (state)\nthis:\n  compare_rat_1 x y = (if real_of_rat x \\<le> real_of_1 y then Lt else Gt)\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "have \"\\<dots> = compare (real_of_rat x) (real_of_1 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if real_of_rat x \\<le> real_of_1 y then Lt else Gt) =\n    compare (real_of_rat x) (real_of_1 y)", "using diff"], ["proof (prove)\nusing this:\n  real_of_1 y \\<noteq> real_of_rat x\n\ngoal (1 subgoal):\n 1. (if real_of_rat x \\<le> real_of_1 y then Lt else Gt) =\n    compare (real_of_rat x) (real_of_1 y)", "by (auto simp: compare_real_def comparator_of_def)"], ["proof (state)\nthis:\n  (if real_of_rat x \\<le> real_of_1 y then Lt else Gt) =\n  compare (real_of_rat x) (real_of_1 y)\n\ngoal (1 subgoal):\n 1. \\<not> (x < l \\<or> r < x) \\<Longrightarrow>\n    compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "finally"], ["proof (chain)\npicking this:\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "show ?thesis"], ["proof (prove)\nusing this:\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n\ngoal (1 subgoal):\n 1. compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "."], ["proof (state)\nthis:\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cf_pos_0[simp]: \"\\<not> cf_pos 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> cf_pos 0", "unfolding cf_pos_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (content 0 = 1 \\<and> 0 < lead_coeff 0)", "by auto"], ["", "(* ********************* *)"], ["", "subsubsection\\<open>Negation\\<close>"], ["", "fun uminus_1 :: \"real_alg_1 \\<Rightarrow> real_alg_1\" where\n  \"uminus_1 (p,l,r) = (abs_int_poly (poly_uminus p), -r, -l)\""], ["", "lemma uminus_1: assumes x: \"invariant_1 x\"\n  defines y: \"y \\<equiv> uminus_1 x\"\n  shows \"invariant_1 y \\<and> (real_of_1 y = - real_of_1 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "proof (cases x)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "case plr: (fields p l r)"], ["proof (state)\nthis:\n  x = (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "from x plr"], ["proof (chain)\npicking this:\n  invariant_1 x\n  x = (p, l, r)", "have inv: \"invariant_1 (p,l,r)\""], ["proof (prove)\nusing this:\n  invariant_1 x\n  x = (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l, r)", "by auto"], ["proof (state)\nthis:\n  invariant_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "note * = invariant_1D[OF this]"], ["proof (state)\nthis:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "from plr"], ["proof (chain)\npicking this:\n  x = (p, l, r)", "have x: \"x = (p,l,r)\""], ["proof (prove)\nusing this:\n  x = (p, l, r)\n\ngoal (1 subgoal):\n 1. x = (p, l, r)", "by simp"], ["proof (state)\nthis:\n  x = (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "let ?p = \"poly_uminus p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "let ?mp = \"abs_int_poly ?p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "have y: \"y = (?mp, -r , -l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = (abs_int_poly (poly_uminus p), - r, - l)", "unfolding y plr"], ["proof (prove)\ngoal (1 subgoal):\n 1. uminus_1 (p, l, r) = (abs_int_poly (poly_uminus p), - r, - l)", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  y = (abs_int_poly (poly_uminus p), - r, - l)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "{"], ["proof (state)\nthis:\n  y = (abs_int_poly (poly_uminus p), - r, - l)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "assume \"root_cond (?mp, - r, - l) y\""], ["proof (state)\nthis:\n  root_cond (abs_int_poly (poly_uminus p), - r, - l) y\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "hence mpy: \"ipoly ?mp y = 0\" and bnd: \"- of_rat r \\<le> y\" \"y \\<le> - of_rat l\""], ["proof (prove)\nusing this:\n  root_cond (abs_int_poly (poly_uminus p), - r, - l) y\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly (abs_int_poly (poly_uminus p))) y = 0 &&&\n    - real_of_rat r \\<le> y &&& y \\<le> - real_of_rat l", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  case (abs_int_poly (poly_uminus p), - r, - l) of\n  (p, l, r) \\<Rightarrow>\n    real_of_rat l \\<le> y \\<and>\n    y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly (abs_int_poly (poly_uminus p))) y = 0 &&&\n    - real_of_rat r \\<le> y &&& y \\<le> - real_of_rat l", "by (auto simp: of_rat_minus)"], ["proof (state)\nthis:\n  poly (real_of_int_poly (abs_int_poly (poly_uminus p))) y = 0\n  - real_of_rat r \\<le> y\n  y \\<le> - real_of_rat l\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "from mpy"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly (abs_int_poly (poly_uminus p))) y = 0", "have id: \"ipoly p (- y) = 0\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly (abs_int_poly (poly_uminus p))) y = 0\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) (- y) = 0", "by auto"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) (- y) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "from bnd"], ["proof (chain)\npicking this:\n  - real_of_rat r \\<le> y\n  y \\<le> - real_of_rat l", "have bnd: \"of_rat l \\<le> - y\" \"-y \\<le> of_rat r\""], ["proof (prove)\nusing this:\n  - real_of_rat r \\<le> y\n  y \\<le> - real_of_rat l\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> - y &&& - y \\<le> real_of_rat r", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> - y\n  - y \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "from id bnd"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly p) (- y) = 0\n  real_of_rat l \\<le> - y\n  - y \\<le> real_of_rat r", "have \"root_cond (p, l, r) (-y)\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (- y) = 0\n  real_of_rat l \\<le> - y\n  - y \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. root_cond (p, l, r) (- y)", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (- y) = 0\n  real_of_rat l \\<le> - y\n  - y \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. case (p, l, r) of\n    (p, l, r) \\<Rightarrow>\n      real_of_rat l \\<le> - y \\<and>\n      - y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) (- y) = 0", "by auto"], ["proof (state)\nthis:\n  root_cond (p, l, r) (- y)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "with inv x"], ["proof (chain)\npicking this:\n  invariant_1 (p, l, r)\n  x = (p, l, r)\n  root_cond (p, l, r) (- y)", "have \"real_of_1 x = -y\""], ["proof (prove)\nusing this:\n  invariant_1 (p, l, r)\n  x = (p, l, r)\n  root_cond (p, l, r) (- y)\n\ngoal (1 subgoal):\n 1. real_of_1 x = - y", "by (auto intro!: the_unique_root_eqI)"], ["proof (state)\nthis:\n  real_of_1 x = - y\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "then"], ["proof (chain)\npicking this:\n  real_of_1 x = - y", "have \"-real_of_1 x = y\""], ["proof (prove)\nusing this:\n  real_of_1 x = - y\n\ngoal (1 subgoal):\n 1. - real_of_1 x = y", "by auto"], ["proof (state)\nthis:\n  - real_of_1 x = y\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "}"], ["proof (state)\nthis:\n  root_cond (abs_int_poly (poly_uminus p), - r, - l) ?ya2 \\<Longrightarrow>\n  - real_of_1 x = ?ya2\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "note inj = this"], ["proof (state)\nthis:\n  root_cond (abs_int_poly (poly_uminus p), - r, - l) ?ya2 \\<Longrightarrow>\n  - real_of_1 x = ?ya2\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "have rc: \"root_cond (?mp, - r, - l) (- real_of_1 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_cond (abs_int_poly (poly_uminus p), - r, - l) (- real_of_1 x)", "using *"], ["proof (prove)\nusing this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. root_cond (abs_int_poly (poly_uminus p), - r, - l) (- real_of_1 x)", "unfolding root_cond_def y x"], ["proof (prove)\nusing this:\n  case (p, l, r) of\n  (pa, la, ra) \\<Rightarrow>\n    real_of_rat la\n    \\<le> (THE x.\n              case (p, l, r) of\n              (p, l, r) \\<Rightarrow>\n                real_of_rat l \\<le> x \\<and>\n                x \\<le> real_of_rat r \\<and>\n                poly (real_of_int_poly p) x = 0) \\<and>\n    (THE x.\n        case (p, l, r) of\n        (p, l, r) \\<Rightarrow>\n          real_of_rat l \\<le> x \\<and>\n          x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0)\n    \\<le> real_of_rat ra \\<and>\n    poly (real_of_int_poly pa)\n     (THE x.\n         case (p, l, r) of\n         (p, l, r) \\<Rightarrow>\n           real_of_rat l \\<le> x \\<and>\n           x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0) =\n    0\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (THE x.\n          case (p, l, r) of\n          (p, l, r) \\<Rightarrow>\n            real_of_rat l \\<le> x \\<and>\n            x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0) =\n  real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x.\n     case (p, l, r) of\n     (p, l, r) \\<Rightarrow>\n       real_of_rat l \\<le> x \\<and>\n       x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. case (abs_int_poly (poly_uminus p), - r, - l) of\n    (pa, la, ra) \\<Rightarrow>\n      real_of_rat la\n      \\<le> - (THE x.\n                  case (p, l, r) of\n                  (p, l, r) \\<Rightarrow>\n                    real_of_rat l \\<le> x \\<and>\n                    x \\<le> real_of_rat r \\<and>\n                    poly (real_of_int_poly p) x = 0) \\<and>\n      - (THE x.\n            case (p, l, r) of\n            (p, l, r) \\<Rightarrow>\n              real_of_rat l \\<le> x \\<and>\n              x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0)\n      \\<le> real_of_rat ra \\<and>\n      poly (real_of_int_poly pa)\n       (- (THE x.\n              case (p, l, r) of\n              (p, l, r) \\<Rightarrow>\n                real_of_rat l \\<le> x \\<and>\n                x \\<le> real_of_rat r \\<and>\n                poly (real_of_int_poly p) x = 0)) =\n      0", "by (auto simp: of_rat_minus sgn_minus_rat)"], ["proof (state)\nthis:\n  root_cond (abs_int_poly (poly_uminus p), - r, - l) (- real_of_1 x)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "from inj rc"], ["proof (chain)\npicking this:\n  root_cond (abs_int_poly (poly_uminus p), - r, - l) ?ya2 \\<Longrightarrow>\n  - real_of_1 x = ?ya2\n  root_cond (abs_int_poly (poly_uminus p), - r, - l) (- real_of_1 x)", "have ur': \"unique_root (?mp, -r, -l)\""], ["proof (prove)\nusing this:\n  root_cond (abs_int_poly (poly_uminus p), - r, - l) ?ya2 \\<Longrightarrow>\n  - real_of_1 x = ?ya2\n  root_cond (abs_int_poly (poly_uminus p), - r, - l) (- real_of_1 x)\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (abs_int_poly (poly_uminus p), - r, - l) x", "by (auto intro: unique_rootI)"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (abs_int_poly (poly_uminus p), - r, - l) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "with rc"], ["proof (chain)\npicking this:\n  root_cond (abs_int_poly (poly_uminus p), - r, - l) (- real_of_1 x)\n  \\<exists>!x. root_cond (abs_int_poly (poly_uminus p), - r, - l) x", "have the: \"- real_of_1 x = the_unique_root (?mp, -r, -l)\""], ["proof (prove)\nusing this:\n  root_cond (abs_int_poly (poly_uminus p), - r, - l) (- real_of_1 x)\n  \\<exists>!x. root_cond (abs_int_poly (poly_uminus p), - r, - l) x\n\ngoal (1 subgoal):\n 1. - real_of_1 x = real_of_1 (abs_int_poly (poly_uminus p), - r, - l)", "by (auto intro: the_unique_root_eqI)"], ["proof (state)\nthis:\n  - real_of_1 x = real_of_1 (abs_int_poly (poly_uminus p), - r, - l)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "have xp: \"p represents (real_of_1 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p represents real_of_1 x", "using *"], ["proof (prove)\nusing this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. p represents real_of_1 x", "unfolding root_cond_def split represents_def x"], ["proof (prove)\nusing this:\n  real_of_rat l\n  \\<le> (THE x.\n            real_of_rat l \\<le> x \\<and>\n            x \\<le> real_of_rat r \\<and>\n            poly (real_of_int_poly p) x = 0) \\<and>\n  (THE x.\n      real_of_rat l \\<le> x \\<and>\n      x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0)\n  \\<le> real_of_rat r \\<and>\n  poly (real_of_int_poly p)\n   (THE x.\n       real_of_rat l \\<le> x \\<and>\n       x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0) =\n  0\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (THE x.\n          real_of_rat l \\<le> x \\<and>\n          x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0) =\n  real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x.\n     real_of_rat l \\<le> x \\<and>\n     x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p)\n     (THE x.\n         real_of_rat l \\<le> x \\<and>\n         x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0) =\n    0 \\<and>\n    p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p represents real_of_1 x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "from *"], ["proof (chain)\npicking this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))", "have mon: \"lead_coeff ?mp > 0\""], ["proof (prove)\nusing this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff (abs_int_poly (poly_uminus p))", "by (unfold pos_poly_abs_poly, auto)"], ["proof (state)\nthis:\n  0 < lead_coeff (abs_int_poly (poly_uminus p))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "from poly_uminus_irreducible *"], ["proof (chain)\npicking this:\n  \\<lbrakk>irreducible ?p; degree ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> irreducible (poly_uminus ?p)\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))", "have mi: \"irreducible ?mp\""], ["proof (prove)\nusing this:\n  \\<lbrakk>irreducible ?p; degree ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> irreducible (poly_uminus ?p)\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. irreducible (abs_int_poly (poly_uminus p))", "by auto"], ["proof (state)\nthis:\n  irreducible (abs_int_poly (poly_uminus p))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "from mi mon"], ["proof (chain)\npicking this:\n  irreducible (abs_int_poly (poly_uminus p))\n  0 < lead_coeff (abs_int_poly (poly_uminus p))", "have pc': \"poly_cond ?mp\""], ["proof (prove)\nusing this:\n  irreducible (abs_int_poly (poly_uminus p))\n  0 < lead_coeff (abs_int_poly (poly_uminus p))\n\ngoal (1 subgoal):\n 1. poly_cond (abs_int_poly (poly_uminus p))", "by (auto simp: cf_pos_def)"], ["proof (state)\nthis:\n  poly_cond (abs_int_poly (poly_uminus p))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "from poly_condD[OF pc']"], ["proof (chain)\npicking this:\n  irreducible (abs_int_poly (poly_uminus p))\n  0 < lead_coeff (abs_int_poly (poly_uminus p))\n  root_free (abs_int_poly (poly_uminus p))\n  square_free (abs_int_poly (poly_uminus p))\n  abs_int_poly (poly_uminus p) \\<noteq> 0", "have irr: \"irreducible ?mp\""], ["proof (prove)\nusing this:\n  irreducible (abs_int_poly (poly_uminus p))\n  0 < lead_coeff (abs_int_poly (poly_uminus p))\n  root_free (abs_int_poly (poly_uminus p))\n  square_free (abs_int_poly (poly_uminus p))\n  abs_int_poly (poly_uminus p) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. irreducible (abs_int_poly (poly_uminus p))", "by auto"], ["proof (state)\nthis:\n  irreducible (abs_int_poly (poly_uminus p))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1 y \\<and> real_of_1 y = - real_of_1 x", "unfolding y"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1 (abs_int_poly (poly_uminus p), - r, - l) \\<and>\n    real_of_1 (abs_int_poly (poly_uminus p), - r, - l) = - real_of_1 x", "apply (intro invariant_1_realI ur' rc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sgn (rai_lb (abs_int_poly (poly_uminus p), - r, - l)) =\n    sgn (rai_ub (abs_int_poly (poly_uminus p), - r, - l))\n 2. poly_cond (poly_real_alg_1 (abs_int_poly (poly_uminus p), - r, - l))", "using pc' inv"], ["proof (prove)\nusing this:\n  poly_cond (abs_int_poly (poly_uminus p))\n  invariant_1 (p, l, r)\n\ngoal (2 subgoals):\n 1. sgn (rai_lb (abs_int_poly (poly_uminus p), - r, - l)) =\n    sgn (rai_ub (abs_int_poly (poly_uminus p), - r, - l))\n 2. poly_cond (poly_real_alg_1 (abs_int_poly (poly_uminus p), - r, - l))", "by auto"], ["proof (state)\nthis:\n  invariant_1 y \\<and> real_of_1 y = - real_of_1 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uminus_1_2:\n  assumes x: \"invariant_1_2 x\"\n  defines y: \"y \\<equiv> uminus_1 x\"\n  shows \"invariant_1_2 y \\<and> (real_of_1 y = - real_of_1 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = - real_of_1 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = - real_of_1 x", "from x"], ["proof (chain)\npicking this:\n  invariant_1_2 x", "have \"invariant_1 x\""], ["proof (prove)\nusing this:\n  invariant_1_2 x\n\ngoal (1 subgoal):\n 1. invariant_1 x", "by auto"], ["proof (state)\nthis:\n  invariant_1 x\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = - real_of_1 x", "from uminus_1[OF this]"], ["proof (chain)\npicking this:\n  invariant_1 (uminus_1 x) \\<and> real_of_1 (uminus_1 x) = - real_of_1 x", "have *: \"real_of_1 y = - real_of_1 x\" \n    \"invariant_1 y\""], ["proof (prove)\nusing this:\n  invariant_1 (uminus_1 x) \\<and> real_of_1 (uminus_1 x) = - real_of_1 x\n\ngoal (1 subgoal):\n 1. real_of_1 y = - real_of_1 x &&& invariant_1 y", "unfolding y"], ["proof (prove)\nusing this:\n  invariant_1 (uminus_1 x) \\<and> real_of_1 (uminus_1 x) = - real_of_1 x\n\ngoal (1 subgoal):\n 1. real_of_1 (uminus_1 x) = - real_of_1 x &&& invariant_1 (uminus_1 x)", "by auto"], ["proof (state)\nthis:\n  real_of_1 y = - real_of_1 x\n  invariant_1 y\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = - real_of_1 x", "obtain p l r where id: \"x = (p,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p l r. x = (p, l, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x)"], ["proof (state)\nthis:\n  x = (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = - real_of_1 x", "from x[unfolded id]"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l, r)", "have \"degree p > 1\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. 1 < degree p", "by auto"], ["proof (state)\nthis:\n  1 < degree p\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = - real_of_1 x", "moreover"], ["proof (state)\nthis:\n  1 < degree p\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = - real_of_1 x", "have \"poly_real_alg_1 y = abs_int_poly (poly_uminus p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_real_alg_1 y = abs_int_poly (poly_uminus p)", "unfolding y id uminus_1.simps split Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_real_alg_1 (abs_int_poly (poly_uminus p), - r, - l) =\n    abs_int_poly (poly_uminus p)", "by auto"], ["proof (state)\nthis:\n  poly_real_alg_1 y = abs_int_poly (poly_uminus p)\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = - real_of_1 x", "ultimately"], ["proof (chain)\npicking this:\n  1 < degree p\n  poly_real_alg_1 y = abs_int_poly (poly_uminus p)", "have \"degree (poly_real_alg_1 y) > 1\""], ["proof (prove)\nusing this:\n  1 < degree p\n  poly_real_alg_1 y = abs_int_poly (poly_uminus p)\n\ngoal (1 subgoal):\n 1. 1 < degree (poly_real_alg_1 y)", "by simp"], ["proof (state)\nthis:\n  1 < degree (poly_real_alg_1 y)\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = - real_of_1 x", "with *"], ["proof (chain)\npicking this:\n  real_of_1 y = - real_of_1 x\n  invariant_1 y\n  1 < degree (poly_real_alg_1 y)", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_1 y = - real_of_1 x\n  invariant_1 y\n  1 < degree (poly_real_alg_1 y)\n\ngoal (1 subgoal):\n 1. invariant_1_2 y \\<and> real_of_1 y = - real_of_1 x", "by auto"], ["proof (state)\nthis:\n  invariant_1_2 y \\<and> real_of_1 y = - real_of_1 x\n\ngoal:\nNo subgoals!", "qed"], ["", "fun uminus_2 :: \"real_alg_2 \\<Rightarrow> real_alg_2\" where\n  \"uminus_2 (Rational r) = Rational (-r)\"\n| \"uminus_2 (Irrational n x) = real_alg_2 (uminus_1 x)\""], ["", "lemma uminus_2: assumes \"invariant_2 x\" \n  shows \"real_of_2 (uminus_2 x) = uminus (real_of_2 x)\"\n  \"invariant_2 (uminus_2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 (uminus_2 x) = - real_of_2 x &&& invariant_2 (uminus_2 x)", "using assms real_alg_2 uminus_1"], ["proof (prove)\nusing this:\n  invariant_2 x\n  invariant_1 ?rai \\<Longrightarrow> invariant_2 (real_alg_2 ?rai)\n  invariant_1 ?rai \\<Longrightarrow>\n  real_of_2 (real_alg_2 ?rai) = real_of_1 ?rai\n  invariant_1 ?x \\<Longrightarrow>\n  invariant_1 (uminus_1 ?x) \\<and> real_of_1 (uminus_1 ?x) = - real_of_1 ?x\n\ngoal (1 subgoal):\n 1. real_of_2 (uminus_2 x) = - real_of_2 x &&& invariant_2 (uminus_2 x)", "by (atomize(full), cases x, auto simp: hom_distribs)"], ["", "declare uminus_1.simps[simp del]"], ["", "lift_definition uminus_3 :: \"real_alg_3 \\<Rightarrow> real_alg_3\" is uminus_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_2.\n       real_alg_2 \\<in> Collect invariant_2 \\<Longrightarrow>\n       uminus_2 real_alg_2 \\<in> Collect invariant_2", "by (auto simp: uminus_2)"], ["", "lemma uminus_3: \"real_of_3 (uminus_3 x) = - real_of_3 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 (uminus_3 x) = - real_of_3 x", "by (transfer, auto simp: uminus_2)"], ["", "instantiation real_alg :: uminus\nbegin"], ["", "lift_definition uminus_real_alg :: \"real_alg \\<Rightarrow> real_alg\" is uminus_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_31 real_alg_32.\n       real_of_3 real_alg_31 = real_of_3 real_alg_32 \\<Longrightarrow>\n       real_of_3 (uminus_3 real_alg_31) = real_of_3 (uminus_3 real_alg_32)", "by (simp add: uminus_3)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, uminus_class)", ".."], ["", "end"], ["", "lemma uminus_real_alg: \"- (real_of x) = real_of (- x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - real_of x = real_of (- x)", "by (transfer, rule uminus_3[symmetric])"], ["", "(* ********************* *)"], ["", "subsubsection\\<open>Inverse\\<close>"], ["", "fun inverse_1 :: \"real_alg_1 \\<Rightarrow> real_alg_2\" where\n  \"inverse_1 (p,l,r) = real_alg_2 (abs_int_poly (reflect_poly p), inverse r, inverse l)\""], ["", "lemma invariant_1_2_of_rat: assumes rc: \"invariant_1_2 rai\" \n  shows \"real_of_1 rai \\<noteq> of_rat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 rai \\<noteq> real_of_rat x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_1 rai \\<noteq> real_of_rat x", "obtain p l r where rai: \"rai = (p, l, r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p l r.\n        rai = (p, l, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases rai, auto)"], ["proof (state)\nthis:\n  rai = (p, l, r)\n\ngoal (1 subgoal):\n 1. real_of_1 rai \\<noteq> real_of_rat x", "from rc[unfolded rai]"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l, r)", "have \"poly_cond2 p\" \"ipoly p (the_unique_root (p, l, r)) = 0\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. poly_cond2 p &&& poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0", "by (auto elim!: invariant_1E)"], ["proof (state)\nthis:\n  poly_cond2 p\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0\n\ngoal (1 subgoal):\n 1. real_of_1 rai \\<noteq> real_of_rat x", "from poly_cond2_no_rat_root[OF this(1), of x] this(2)"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly p) (real_of_rat x) \\<noteq> 0\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (real_of_rat x) \\<noteq> 0\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0\n\ngoal (1 subgoal):\n 1. real_of_1 rai \\<noteq> real_of_rat x", "unfolding rai"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (real_of_rat x) \\<noteq> 0\n  poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) \\<noteq> real_of_rat x", "by auto"], ["proof (state)\nthis:\n  real_of_1 rai \\<noteq> real_of_rat x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_1:\n  assumes rcx: \"invariant_1_2 x\"\n  defines y: \"y \\<equiv> inverse_1 x\"\n  shows \"invariant_2 y \\<and> (real_of_2 y = inverse (real_of_1 x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "proof (cases x)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "case x: (fields p l r)"], ["proof (state)\nthis:\n  x = (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "from x rcx"], ["proof (chain)\npicking this:\n  x = (p, l, r)\n  invariant_1_2 x", "have rcx: \"invariant_1_2 (p,l,r)\""], ["proof (prove)\nusing this:\n  x = (p, l, r)\n  invariant_1_2 x\n\ngoal (1 subgoal):\n 1. invariant_1_2 (p, l, r)", "by auto"], ["proof (state)\nthis:\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "from invariant_1_2_poly_cond2[OF rcx]"], ["proof (chain)\npicking this:\n  poly_cond2 (poly_real_alg_1 (p, l, r))", "have pc2: \"poly_cond2 p\""], ["proof (prove)\nusing this:\n  poly_cond2 (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. poly_cond2 p", "by simp"], ["proof (state)\nthis:\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "have x0: \"real_of_1 (p,l,r) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) \\<noteq> 0", "using invariant_1_2_of_rat[OF rcx, of 0] x"], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) \\<noteq> real_of_rat 0\n  x = (p, l, r)\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "let ?x = \"real_of_1 (p,l,r)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "let ?mp = \"abs_int_poly (reflect_poly p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "from x0 rcx"], ["proof (chain)\npicking this:\n  real_of_1 (p, l, r) \\<noteq> 0\n  invariant_1_2 (p, l, r)", "have lr0: \"l \\<noteq> 0\" and \"r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) \\<noteq> 0\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 &&& r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  l \\<noteq> 0\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "from x0 rcx"], ["proof (chain)\npicking this:\n  real_of_1 (p, l, r) \\<noteq> 0\n  invariant_1_2 (p, l, r)", "have y: \"y = real_alg_2 (?mp, inverse r, inverse l)\""], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) \\<noteq> 0\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. y = real_alg_2 (abs_int_poly (reflect_poly p), inverse r, inverse l)", "unfolding y x Let_def inverse_1.simps"], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) \\<noteq> 0\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. real_alg_2 (abs_int_poly (reflect_poly p), inverse r, inverse l) =\n    real_alg_2 (abs_int_poly (reflect_poly p), inverse r, inverse l)", "by auto"], ["proof (state)\nthis:\n  y = real_alg_2 (abs_int_poly (reflect_poly p), inverse r, inverse l)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "from rcx"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l, r)", "have mon: \"lead_coeff ?mp > 0\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff (abs_int_poly (reflect_poly p))", "by (unfold lead_coeff_abs_int_poly, auto)"], ["proof (state)\nthis:\n  0 < lead_coeff (abs_int_poly (reflect_poly p))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "{"], ["proof (state)\nthis:\n  0 < lead_coeff (abs_int_poly (reflect_poly p))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "assume \"root_cond (?mp, inverse r, inverse l) y\""], ["proof (state)\nthis:\n  root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l) y\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "hence mpy: \"ipoly ?mp y = 0\" and bnd: \"inverse (of_rat r) \\<le> y\" \"y \\<le> inverse (of_rat l)\""], ["proof (prove)\nusing this:\n  root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l) y\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly (abs_int_poly (reflect_poly p))) y = 0 &&&\n    inverse (real_of_rat r) \\<le> y &&& y \\<le> inverse (real_of_rat l)", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  case (abs_int_poly (reflect_poly p), inverse r, inverse l) of\n  (p, l, r) \\<Rightarrow>\n    real_of_rat l \\<le> y \\<and>\n    y \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y = 0\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly (abs_int_poly (reflect_poly p))) y = 0 &&&\n    inverse (real_of_rat r) \\<le> y &&& y \\<le> inverse (real_of_rat l)", "by (auto simp: of_rat_inverse)"], ["proof (state)\nthis:\n  poly (real_of_int_poly (abs_int_poly (reflect_poly p))) y = 0\n  inverse (real_of_rat r) \\<le> y\n  y \\<le> inverse (real_of_rat l)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "from sgn_real_mono[OF bnd(1)] sgn_real_mono[OF bnd(2)]"], ["proof (chain)\npicking this:\n  sgn (inverse (real_of_rat r)) \\<le> sgn y\n  sgn y \\<le> sgn (inverse (real_of_rat l))", "have \"sgn (of_rat r) \\<le> sgn y\" \"sgn y \\<le> sgn (of_rat l)\""], ["proof (prove)\nusing this:\n  sgn (inverse (real_of_rat r)) \\<le> sgn y\n  sgn y \\<le> sgn (inverse (real_of_rat l))\n\ngoal (1 subgoal):\n 1. sgn (real_of_rat r) \\<le> sgn y &&& sgn y \\<le> sgn (real_of_rat l)", "by (simp_all add: algebra_simps)"], ["proof (state)\nthis:\n  sgn (real_of_rat r) \\<le> sgn y\n  sgn y \\<le> sgn (real_of_rat l)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "with rcx"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l, r)\n  sgn (real_of_rat r) \\<le> sgn y\n  sgn y \\<le> sgn (real_of_rat l)", "have sgn: \"sgn (inverse (of_rat r)) = sgn y\" \"sgn y = sgn (inverse (of_rat l))\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n  sgn (real_of_rat r) \\<le> sgn y\n  sgn y \\<le> sgn (real_of_rat l)\n\ngoal (1 subgoal):\n 1. sgn (inverse (real_of_rat r)) = sgn y &&&\n    sgn y = sgn (inverse (real_of_rat l))", "unfolding sgn_inverse inverse_sgn"], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n  sgn (real_of_rat r) \\<le> sgn y\n  sgn y \\<le> sgn (real_of_rat l)\n\ngoal (1 subgoal):\n 1. sgn (real_of_rat r) = sgn y &&& sgn y = sgn (real_of_rat l)", "by (auto simp add: real_of_rat_sgn intro: order_antisym)"], ["proof (state)\nthis:\n  sgn (inverse (real_of_rat r)) = sgn y\n  sgn y = sgn (inverse (real_of_rat l))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "from sgn[simplified, unfolded real_of_rat_sgn] lr0"], ["proof (chain)\npicking this:\n  real_of_rat (sgn r) = sgn y\n  sgn y = real_of_rat (sgn l)\n  l \\<noteq> 0", "have \"y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  real_of_rat (sgn r) = sgn y\n  sgn y = real_of_rat (sgn l)\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "by (auto simp:sgn_0_0)"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "with mpy"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly (abs_int_poly (reflect_poly p))) y = 0\n  y \\<noteq> 0", "have id: \"ipoly p (inverse y) = 0\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly (abs_int_poly (reflect_poly p))) y = 0\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) (inverse y) = 0", "by (auto simp: ipoly_reflect_poly)"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) (inverse y) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "from inverse_le_sgn[OF sgn(1) bnd(1)] inverse_le_sgn[OF sgn(2) bnd(2)]"], ["proof (chain)\npicking this:\n  inverse y \\<le> inverse (inverse (real_of_rat r))\n  inverse (inverse (real_of_rat l)) \\<le> inverse y", "have bnd: \"of_rat l \\<le> inverse y\" \"inverse y \\<le> of_rat r\""], ["proof (prove)\nusing this:\n  inverse y \\<le> inverse (inverse (real_of_rat r))\n  inverse (inverse (real_of_rat l)) \\<le> inverse y\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> inverse y &&& inverse y \\<le> real_of_rat r", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> inverse y\n  inverse y \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "from id bnd"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly p) (inverse y) = 0\n  real_of_rat l \\<le> inverse y\n  inverse y \\<le> real_of_rat r", "have \"root_cond (p,l,r) (inverse y)\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (inverse y) = 0\n  real_of_rat l \\<le> inverse y\n  inverse y \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. root_cond (p, l, r) (inverse y)", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (inverse y) = 0\n  real_of_rat l \\<le> inverse y\n  inverse y \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. case (p, l, r) of\n    (p, l, r) \\<Rightarrow>\n      real_of_rat l \\<le> inverse y \\<and>\n      inverse y \\<le> real_of_rat r \\<and>\n      poly (real_of_int_poly p) (inverse y) = 0", "by auto"], ["proof (state)\nthis:\n  root_cond (p, l, r) (inverse y)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "from rcx this x0"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l, r)\n  root_cond (p, l, r) (inverse y)\n  real_of_1 (p, l, r) \\<noteq> 0", "have \"?x = inverse y\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n  root_cond (p, l, r) (inverse y)\n  real_of_1 (p, l, r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) = inverse y", "by auto"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) = inverse y\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "then"], ["proof (chain)\npicking this:\n  real_of_1 (p, l, r) = inverse y", "have \"inverse ?x = y\""], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) = inverse y\n\ngoal (1 subgoal):\n 1. inverse (real_of_1 (p, l, r)) = y", "by auto"], ["proof (state)\nthis:\n  inverse (real_of_1 (p, l, r)) = y\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "}"], ["proof (state)\nthis:\n  root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l)\n   ?ya2 \\<Longrightarrow>\n  inverse (real_of_1 (p, l, r)) = ?ya2\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "note inj = this"], ["proof (state)\nthis:\n  root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l)\n   ?ya2 \\<Longrightarrow>\n  inverse (real_of_1 (p, l, r)) = ?ya2\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "have rc: \"root_cond (?mp, inverse r, inverse l) (inverse ?x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l)\n     (inverse (real_of_1 (p, l, r)))", "using rcx x0"], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n  real_of_1 (p, l, r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l)\n     (inverse (real_of_1 (p, l, r)))", "apply (elim invariant_1_2E invariant_1E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>real_of_1 (p, l, r) \\<noteq> 0;\n     1 < degree (poly_real_alg_1 (p, l, r));\n     root_cond (p, l, r) (real_of_1 (p, l, r));\n     sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r));\n     sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)));\n     \\<exists>!x. root_cond (p, l, r) x;\n     poly_cond (poly_real_alg_1 (p, l, r));\n     0 < degree (poly_real_alg_1 (p, l, r));\n     primitive (poly_real_alg_1 (p, l, r))\\<rbrakk>\n    \\<Longrightarrow> root_cond\n                       (abs_int_poly (reflect_poly p), inverse r, inverse l)\n                       (inverse (real_of_1 (p, l, r)))", "by (simp add: root_cond_def of_rat_inverse real_of_rat_sgn inverse_le_iff_sgn ipoly_reflect_poly)"], ["proof (state)\nthis:\n  root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l)\n   (inverse (real_of_1 (p, l, r)))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "from inj rc"], ["proof (chain)\npicking this:\n  root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l)\n   ?ya2 \\<Longrightarrow>\n  inverse (real_of_1 (p, l, r)) = ?ya2\n  root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l)\n   (inverse (real_of_1 (p, l, r)))", "have ur: \"unique_root (?mp, inverse r, inverse l)\""], ["proof (prove)\nusing this:\n  root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l)\n   ?ya2 \\<Longrightarrow>\n  inverse (real_of_1 (p, l, r)) = ?ya2\n  root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l)\n   (inverse (real_of_1 (p, l, r)))\n\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l) x", "by (auto intro: unique_rootI)"], ["proof (state)\nthis:\n  \\<exists>!x.\n     root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "with rc"], ["proof (chain)\npicking this:\n  root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l)\n   (inverse (real_of_1 (p, l, r)))\n  \\<exists>!x.\n     root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l) x", "have the: \"the_unique_root (?mp, inverse r, inverse l) = inverse ?x\""], ["proof (prove)\nusing this:\n  root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l)\n   (inverse (real_of_1 (p, l, r)))\n  \\<exists>!x.\n     root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l) x\n\ngoal (1 subgoal):\n 1. real_of_1 (abs_int_poly (reflect_poly p), inverse r, inverse l) =\n    inverse (real_of_1 (p, l, r))", "by (auto intro: the_unique_root_eqI)"], ["proof (state)\nthis:\n  real_of_1 (abs_int_poly (reflect_poly p), inverse r, inverse l) =\n  inverse (real_of_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "have xp: \"p represents ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p represents real_of_1 (p, l, r)", "unfolding split represents_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0 \\<and> p \\<noteq> 0", "using rcx"], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0 \\<and> p \\<noteq> 0", "by (auto elim!: invariant_1E)"], ["proof (state)\nthis:\n  p represents real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "from reflect_poly_irreducible[OF _ xp x0] poly_condD rcx"], ["proof (chain)\npicking this:\n  irreducible p \\<Longrightarrow> irreducible (reflect_poly p)\n  poly_cond ?p \\<Longrightarrow> irreducible ?p\n  poly_cond ?p \\<Longrightarrow> 0 < lead_coeff ?p\n  poly_cond ?p \\<Longrightarrow> root_free ?p\n  poly_cond ?p \\<Longrightarrow> square_free ?p\n  poly_cond ?p \\<Longrightarrow> ?p \\<noteq> 0\n  invariant_1_2 (p, l, r)", "have mi: \"irreducible ?mp\""], ["proof (prove)\nusing this:\n  irreducible p \\<Longrightarrow> irreducible (reflect_poly p)\n  poly_cond ?p \\<Longrightarrow> irreducible ?p\n  poly_cond ?p \\<Longrightarrow> 0 < lead_coeff ?p\n  poly_cond ?p \\<Longrightarrow> root_free ?p\n  poly_cond ?p \\<Longrightarrow> square_free ?p\n  poly_cond ?p \\<Longrightarrow> ?p \\<noteq> 0\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. irreducible (abs_int_poly (reflect_poly p))", "by auto"], ["proof (state)\nthis:\n  irreducible (abs_int_poly (reflect_poly p))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "from mi mon"], ["proof (chain)\npicking this:\n  irreducible (abs_int_poly (reflect_poly p))\n  0 < lead_coeff (abs_int_poly (reflect_poly p))", "have un: \"poly_cond ?mp\""], ["proof (prove)\nusing this:\n  irreducible (abs_int_poly (reflect_poly p))\n  0 < lead_coeff (abs_int_poly (reflect_poly p))\n\ngoal (1 subgoal):\n 1. poly_cond (abs_int_poly (reflect_poly p))", "by (auto simp: poly_cond_def)"], ["proof (state)\nthis:\n  poly_cond (abs_int_poly (reflect_poly p))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "using rcx rc ur"], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n  root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l)\n   (inverse (real_of_1 (p, l, r)))\n  \\<exists>!x.\n     root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l) x\n\ngoal (1 subgoal):\n 1. invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)", "unfolding y"], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n  root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l)\n   (inverse (real_of_1 (p, l, r)))\n  \\<exists>!x.\n     root_cond (abs_int_poly (reflect_poly p), inverse r, inverse l) x\n\ngoal (1 subgoal):\n 1. invariant_2\n     (real_alg_2\n       (abs_int_poly (reflect_poly p), inverse r, inverse l)) \\<and>\n    real_of_2\n     (real_alg_2 (abs_int_poly (reflect_poly p), inverse r, inverse l)) =\n    inverse (real_of_1 x)", "by (intro invariant_2_realI, auto simp: x y un)"], ["proof (state)\nthis:\n  invariant_2 y \\<and> real_of_2 y = inverse (real_of_1 x)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun inverse_2 :: \"real_alg_2 \\<Rightarrow> real_alg_2\" where\n  \"inverse_2 (Rational r) = Rational (inverse r)\"\n| \"inverse_2 (Irrational n x) = inverse_1 x\""], ["", "lemma inverse_2: assumes \"invariant_2 x\"\n  shows \"real_of_2 (inverse_2 x) = inverse (real_of_2 x)\"\n  \"invariant_2 (inverse_2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 (inverse_2 x) = inverse (real_of_2 x) &&&\n    invariant_2 (inverse_2 x)", "using assms"], ["proof (prove)\nusing this:\n  invariant_2 x\n\ngoal (1 subgoal):\n 1. real_of_2 (inverse_2 x) = inverse (real_of_2 x) &&&\n    invariant_2 (inverse_2 x)", "by (atomize(full), cases x, auto simp: real_alg_2 inverse_1 hom_distribs)"], ["", "lift_definition inverse_3 :: \"real_alg_3 \\<Rightarrow> real_alg_3\" is inverse_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_2.\n       real_alg_2 \\<in> Collect invariant_2 \\<Longrightarrow>\n       inverse_2 real_alg_2 \\<in> Collect invariant_2", "by (auto simp: inverse_2)"], ["", "lemma inverse_3: \"real_of_3 (inverse_3 x) = inverse (real_of_3 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 (inverse_3 x) = inverse (real_of_3 x)", "by (transfer, auto simp: inverse_2)"], ["", "(* ********************* *)"], ["", "subsubsection\\<open>Floor\\<close>"], ["", "fun floor_1 :: \"real_alg_1 \\<Rightarrow> int\" where\n  \"floor_1 (p,l,r) = (let\n    (l',r',sr') = tighten_poly_bounds_epsilon p (1/2) l r (sgn (ipoly p r));\n    fr = floor r';\n    fl = floor l';\n    fr' = rat_of_int fr\n    in (if fr = fl then fr else\n    let (l'',r'',sr'') = tighten_poly_bounds_for_x p fr' l' r' sr'\n    in if fr' < l'' then fr else fl))\""], ["", "lemma floor_1: assumes \"invariant_1_2 x\"\n  shows \"floor (real_of_1 x) = floor_1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "proof (cases x)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "case (fields p l r)"], ["proof (state)\nthis:\n  x = (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "obtain l' r' sr' where tbe: \"tighten_poly_bounds_epsilon p (1 / 2) l r (sgn (ipoly p r)) = (l',r',sr')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l' r' sr'.\n        tighten_poly_bounds_epsilon p (1 / 2) l r (sgn (ipoly p r)) =\n        (l', r', sr') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases rule: prod_cases3, auto)"], ["proof (state)\nthis:\n  tighten_poly_bounds_epsilon p (1 / 2) l r (sgn (ipoly p r)) =\n  (l', r', sr')\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "let ?fr = \"floor r'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "let ?fl = \"floor l'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "let ?fr' = \"rat_of_int ?fr\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "obtain l'' r'' sr'' where tbx: \"tighten_poly_bounds_for_x p ?fr' l' r' sr' = (l'',r'',sr'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l'' r'' sr''.\n        tighten_poly_bounds_for_x p (rat_of_int \\<lfloor>r'\\<rfloor>) l' r'\n         sr' =\n        (l'', r'', sr'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases rule: prod_cases3, auto)"], ["proof (state)\nthis:\n  tighten_poly_bounds_for_x p (rat_of_int \\<lfloor>r'\\<rfloor>) l' r' sr' =\n  (l'', r'', sr'')\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "note rc = assms[unfolded fields]"], ["proof (state)\nthis:\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "hence rc1: \"invariant_1 (p,l,r)\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l, r)", "by auto"], ["proof (state)\nthis:\n  invariant_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "have id: \"floor_1 x = ((if ?fr = ?fl then ?fr \n    else if ?fr' < l'' then ?fr else ?fl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. floor_1 x =\n    (if \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor>\n     then \\<lfloor>r'\\<rfloor>\n     else if rat_of_int \\<lfloor>r'\\<rfloor> < l'' then \\<lfloor>r'\\<rfloor>\n          else \\<lfloor>l'\\<rfloor>)", "unfolding fields floor_1.simps tbe Let_def split tbx"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor>\n     then \\<lfloor>r'\\<rfloor>\n     else if rat_of_int \\<lfloor>r'\\<rfloor> < l'' then \\<lfloor>r'\\<rfloor>\n          else \\<lfloor>l'\\<rfloor>) =\n    (if \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor>\n     then \\<lfloor>r'\\<rfloor>\n     else if rat_of_int \\<lfloor>r'\\<rfloor> < l'' then \\<lfloor>r'\\<rfloor>\n          else \\<lfloor>l'\\<rfloor>)", "by simp"], ["proof (state)\nthis:\n  floor_1 x =\n  (if \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor> then \\<lfloor>r'\\<rfloor>\n   else if rat_of_int \\<lfloor>r'\\<rfloor> < l'' then \\<lfloor>r'\\<rfloor>\n        else \\<lfloor>l'\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "let ?x = \"real_of_1 x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "have x: \"?x = the_unique_root (p,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 x = real_of_1 (p, l, r)", "unfolding fields"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) = real_of_1 (p, l, r)", "by simp"], ["proof (state)\nthis:\n  real_of_1 x = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "have bnd: \"l \\<le> l'\" \"r' \\<le> r\" \"r' - l' \\<le> 1 / 2\"\n    and rc': \"root_cond (p, l', r') (the_unique_root (p, l, r))\" \n    and sr': \"sr' = sgn (ipoly p r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l \\<le> l' &&& r' \\<le> r &&& r' - l' \\<le> 1 / 2) &&&\n    root_cond (p, l', r') (real_of_1 (p, l, r)) &&& sr' = sgn (ipoly p r')", "by (atomize(full), intro conjI tighten_poly_bounds_epsilon[OF _ _ tbe refl],insert rc,auto elim!: invariant_1E)"], ["proof (state)\nthis:\n  l \\<le> l'\n  r' \\<le> r\n  r' - l' \\<le> 1 / 2\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n  sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "let ?r = real_of_rat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "from rc'[folded x, unfolded split]"], ["proof (chain)\npicking this:\n  root_cond (p, l', r') (real_of_1 x)", "have ineq: \"?r l' \\<le> ?x\" \"?x \\<le> ?r r'\" \"?r l' \\<le> ?r r'\""], ["proof (prove)\nusing this:\n  root_cond (p, l', r') (real_of_1 x)\n\ngoal (1 subgoal):\n 1. real_of_rat l' \\<le> real_of_1 x &&&\n    real_of_1 x \\<le> real_of_rat r' &&& real_of_rat l' \\<le> real_of_rat r'", "by auto"], ["proof (state)\nthis:\n  real_of_rat l' \\<le> real_of_1 x\n  real_of_1 x \\<le> real_of_rat r'\n  real_of_rat l' \\<le> real_of_rat r'\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "hence lr': \"l' \\<le> r'\""], ["proof (prove)\nusing this:\n  real_of_rat l' \\<le> real_of_1 x\n  real_of_1 x \\<le> real_of_rat r'\n  real_of_rat l' \\<le> real_of_rat r'\n\ngoal (1 subgoal):\n 1. l' \\<le> r'", "unfolding of_rat_less_eq"], ["proof (prove)\nusing this:\n  real_of_rat l' \\<le> real_of_1 x\n  real_of_1 x \\<le> real_of_rat r'\n  l' \\<le> r'\n\ngoal (1 subgoal):\n 1. l' \\<le> r'", "by simp"], ["proof (state)\nthis:\n  l' \\<le> r'\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "have flr: \"?fl \\<le> ?fr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>l'\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor>", "by (rule floor_mono[OF lr'])"], ["proof (state)\nthis:\n  \\<lfloor>l'\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "from invariant_1_sub_interval[OF rc1 rc' bnd(1,2)]"], ["proof (chain)\npicking this:\n  invariant_1 (p, l', r')\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)", "have rc': \"invariant_1 (p, l', r')\"\n    and id': \"the_unique_root (p, l', r') = the_unique_root (p, l, r)\""], ["proof (prove)\nusing this:\n  invariant_1 (p, l', r')\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l', r') &&& real_of_1 (p, l', r') = real_of_1 (p, l, r)", "by auto"], ["proof (state)\nthis:\n  invariant_1 (p, l', r')\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "with rc"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l, r)\n  invariant_1 (p, l', r')\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)", "have rc2': \"invariant_1_2 (p, l', r')\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n  invariant_1 (p, l', r')\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1_2 (p, l', r')", "by auto"], ["proof (state)\nthis:\n  invariant_1_2 (p, l', r')\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "have x: \"?x = the_unique_root (p,l',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 x = real_of_1 (p, l', r')", "unfolding fields"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) = real_of_1 (p, l', r')", "using id'"], ["proof (prove)\nusing this:\n  real_of_1 (p, l', r') = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) = real_of_1 (p, l', r')", "by simp"], ["proof (state)\nthis:\n  real_of_1 x = real_of_1 (p, l', r')\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "{"], ["proof (state)\nthis:\n  real_of_1 x = real_of_1 (p, l', r')\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "assume \"?fr \\<noteq> ?fl\""], ["proof (state)\nthis:\n  \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "with flr"], ["proof (chain)\npicking this:\n  \\<lfloor>l'\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor>\n  \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor>", "have flr: \"?fl \\<le> ?fr - 1\""], ["proof (prove)\nusing this:\n  \\<lfloor>l'\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor>\n  \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>l'\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor> - 1", "by simp"], ["proof (state)\nthis:\n  \\<lfloor>l'\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor> - 1\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "have \"?fr' \\<le> r'\"  \"l' \\<le> ?fr'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r' &&&\n    l' \\<le> rat_of_int \\<lfloor>r'\\<rfloor>", "using flr bnd"], ["proof (prove)\nusing this:\n  \\<lfloor>l'\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor> - 1\n  l \\<le> l'\n  r' \\<le> r\n  r' - l' \\<le> 1 / 2\n\ngoal (1 subgoal):\n 1. rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r' &&&\n    l' \\<le> rat_of_int \\<lfloor>r'\\<rfloor>", "by linarith+"], ["proof (state)\nthis:\n  rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r'\n  l' \\<le> rat_of_int \\<lfloor>r'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "}"], ["proof (state)\nthis:\n  \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n  rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r'\n  \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n  l' \\<le> rat_of_int \\<lfloor>r'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "note fl_diff = this"], ["proof (state)\nthis:\n  \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n  rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r'\n  \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n  l' \\<le> rat_of_int \\<lfloor>r'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "proof (cases \"?fr = ?fl\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "case True"], ["proof (state)\nthis:\n  \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "hence id1: \"floor_1 x = ?fr\""], ["proof (prove)\nusing this:\n  \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. floor_1 x = \\<lfloor>r'\\<rfloor>", "unfolding id"], ["proof (prove)\nusing this:\n  \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. (if \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor>\n     then \\<lfloor>r'\\<rfloor>\n     else if rat_of_int \\<lfloor>r'\\<rfloor> < l'' then \\<lfloor>r'\\<rfloor>\n          else \\<lfloor>l'\\<rfloor>) =\n    \\<lfloor>r'\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  floor_1 x = \\<lfloor>r'\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "from True"], ["proof (chain)\npicking this:\n  \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor>", "have id: \"floor (?r l') = floor (?r r')\""], ["proof (prove)\nusing this:\n  \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_rat l'\\<rfloor> = \\<lfloor>real_of_rat r'\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<lfloor>real_of_rat l'\\<rfloor> = \\<lfloor>real_of_rat r'\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "have \"floor ?x \\<le> floor (?r r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>real_of_rat r'\\<rfloor>", "by (rule floor_mono[OF ineq(2)])"], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>real_of_rat r'\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "moreover"], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>real_of_rat r'\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "have \"floor (?r l') \\<le> floor ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_rat l'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>", "by (rule floor_mono[OF ineq(1)])"], ["proof (state)\nthis:\n  \\<lfloor>real_of_rat l'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "ultimately"], ["proof (chain)\npicking this:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>real_of_rat r'\\<rfloor>\n  \\<lfloor>real_of_rat l'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>", "have \"floor ?x = floor (?r r')\""], ["proof (prove)\nusing this:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>real_of_rat r'\\<rfloor>\n  \\<lfloor>real_of_rat l'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> = \\<lfloor>real_of_rat r'\\<rfloor>", "unfolding id"], ["proof (prove)\nusing this:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>real_of_rat r'\\<rfloor>\n  \\<lfloor>real_of_rat r'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> = \\<lfloor>real_of_rat r'\\<rfloor>", "by (simp add: id)"], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> = \\<lfloor>real_of_rat r'\\<rfloor>\n\ngoal (2 subgoals):\n 1. \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "then"], ["proof (chain)\npicking this:\n  \\<lfloor>real_of_1 x\\<rfloor> = \\<lfloor>real_of_rat r'\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lfloor>real_of_1 x\\<rfloor> = \\<lfloor>real_of_rat r'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "by (simp add: id1)"], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n\ngoal (1 subgoal):\n 1. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "case False"], ["proof (state)\nthis:\n  \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "with id"], ["proof (chain)\npicking this:\n  floor_1 x =\n  (if \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor> then \\<lfloor>r'\\<rfloor>\n   else if rat_of_int \\<lfloor>r'\\<rfloor> < l'' then \\<lfloor>r'\\<rfloor>\n        else \\<lfloor>l'\\<rfloor>)\n  \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor>", "have id: \"floor_1 x = (if ?fr' < l'' then ?fr else ?fl)\""], ["proof (prove)\nusing this:\n  floor_1 x =\n  (if \\<lfloor>r'\\<rfloor> = \\<lfloor>l'\\<rfloor> then \\<lfloor>r'\\<rfloor>\n   else if rat_of_int \\<lfloor>r'\\<rfloor> < l'' then \\<lfloor>r'\\<rfloor>\n        else \\<lfloor>l'\\<rfloor>)\n  \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. floor_1 x =\n    (if rat_of_int \\<lfloor>r'\\<rfloor> < l'' then \\<lfloor>r'\\<rfloor>\n     else \\<lfloor>l'\\<rfloor>)", "by simp"], ["proof (state)\nthis:\n  floor_1 x =\n  (if rat_of_int \\<lfloor>r'\\<rfloor> < l'' then \\<lfloor>r'\\<rfloor>\n   else \\<lfloor>l'\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "from rc2'"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l', r')", "have \"unique_root (p,l',r')\" \"poly_cond2 p\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l', r')\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, l', r') x &&& poly_cond2 p", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, l', r') x\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "from tighten_poly_bounds_for_x[OF this tbx sr']"], ["proof (chain)\npicking this:\n  l' \\<le> l''\n  l'' \\<le> r''\n  r'' \\<le> r'\n  root_cond (p, l'', r'') (real_of_1 (p, l', r'))\n  \\<not> (l'' \\<le> rat_of_int \\<lfloor>r'\\<rfloor> \\<and>\n          rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r'')\n  sr'' = sgn (ipoly p r'')\n  \\<exists>!x. root_cond (p, l'', r'') x", "have ineq': \"l' \\<le> l''\" \"r'' \\<le> r'\" and lr'': \"l'' \\<le> r''\" and rc'': \"root_cond (p,l'',r'') ?x\"\n      and fr': \"\\<not> (l'' \\<le> ?fr' \\<and> ?fr' \\<le> r'')\""], ["proof (prove)\nusing this:\n  l' \\<le> l''\n  l'' \\<le> r''\n  r'' \\<le> r'\n  root_cond (p, l'', r'') (real_of_1 (p, l', r'))\n  \\<not> (l'' \\<le> rat_of_int \\<lfloor>r'\\<rfloor> \\<and>\n          rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r'')\n  sr'' = sgn (ipoly p r'')\n  \\<exists>!x. root_cond (p, l'', r'') x\n\ngoal (1 subgoal):\n 1. ((l' \\<le> l'' &&& r'' \\<le> r') &&& l'' \\<le> r'') &&&\n    root_cond (p, l'', r'') (real_of_1 x) &&&\n    \\<not> (l'' \\<le> rat_of_int \\<lfloor>r'\\<rfloor> \\<and>\n            rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r'')", "unfolding x"], ["proof (prove)\nusing this:\n  l' \\<le> l''\n  l'' \\<le> r''\n  r'' \\<le> r'\n  root_cond (p, l'', r'') (real_of_1 (p, l', r'))\n  \\<not> (l'' \\<le> rat_of_int \\<lfloor>r'\\<rfloor> \\<and>\n          rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r'')\n  sr'' = sgn (ipoly p r'')\n  \\<exists>!x. root_cond (p, l'', r'') x\n\ngoal (1 subgoal):\n 1. ((l' \\<le> l'' &&& r'' \\<le> r') &&& l'' \\<le> r'') &&&\n    root_cond (p, l'', r'') (real_of_1 (p, l', r')) &&&\n    \\<not> (l'' \\<le> rat_of_int \\<lfloor>r'\\<rfloor> \\<and>\n            rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r'')", "by auto"], ["proof (state)\nthis:\n  l' \\<le> l''\n  r'' \\<le> r'\n  l'' \\<le> r''\n  root_cond (p, l'', r'') (real_of_1 x)\n  \\<not> (l'' \\<le> rat_of_int \\<lfloor>r'\\<rfloor> \\<and>\n          rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r'')\n\ngoal (1 subgoal):\n 1. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "from rc''[unfolded split]"], ["proof (chain)\npicking this:\n  root_cond (p, l'', r'') (real_of_1 x)", "have ineq'': \"?r l'' \\<le> ?x\" \"?x \\<le> ?r r''\""], ["proof (prove)\nusing this:\n  root_cond (p, l'', r'') (real_of_1 x)\n\ngoal (1 subgoal):\n 1. real_of_rat l'' \\<le> real_of_1 x &&& real_of_1 x \\<le> real_of_rat r''", "by auto"], ["proof (state)\nthis:\n  real_of_rat l'' \\<le> real_of_1 x\n  real_of_1 x \\<le> real_of_rat r''\n\ngoal (1 subgoal):\n 1. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "from False"], ["proof (chain)\npicking this:\n  \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor>", "have \"?fr \\<noteq> ?fl\""], ["proof (prove)\nusing this:\n  \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "note fr = fl_diff[OF this]"], ["proof (state)\nthis:\n  rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r'\n  l' \\<le> rat_of_int \\<lfloor>r'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>r'\\<rfloor> \\<noteq> \\<lfloor>l'\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "proof (cases \"?fr' < l''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "case True"], ["proof (state)\nthis:\n  rat_of_int \\<lfloor>r'\\<rfloor> < l''\n\ngoal (2 subgoals):\n 1. rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "with id"], ["proof (chain)\npicking this:\n  floor_1 x =\n  (if rat_of_int \\<lfloor>r'\\<rfloor> < l'' then \\<lfloor>r'\\<rfloor>\n   else \\<lfloor>l'\\<rfloor>)\n  rat_of_int \\<lfloor>r'\\<rfloor> < l''", "have id: \"floor_1 x = ?fr\""], ["proof (prove)\nusing this:\n  floor_1 x =\n  (if rat_of_int \\<lfloor>r'\\<rfloor> < l'' then \\<lfloor>r'\\<rfloor>\n   else \\<lfloor>l'\\<rfloor>)\n  rat_of_int \\<lfloor>r'\\<rfloor> < l''\n\ngoal (1 subgoal):\n 1. floor_1 x = \\<lfloor>r'\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  floor_1 x = \\<lfloor>r'\\<rfloor>\n\ngoal (2 subgoals):\n 1. rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "have \"floor ?x \\<le> ?fr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor>", "using floor_mono[OF ineq(2)]"], ["proof (prove)\nusing this:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>real_of_rat r'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor>\n\ngoal (2 subgoals):\n 1. rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "moreover"], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor>\n\ngoal (2 subgoals):\n 1. rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "from True"], ["proof (chain)\npicking this:\n  rat_of_int \\<lfloor>r'\\<rfloor> < l''", "have \"?r ?fr' < ?r l''\""], ["proof (prove)\nusing this:\n  rat_of_int \\<lfloor>r'\\<rfloor> < l''\n\ngoal (1 subgoal):\n 1. real_of_rat (rat_of_int \\<lfloor>r'\\<rfloor>) < real_of_rat l''", "unfolding of_rat_less"], ["proof (prove)\nusing this:\n  rat_of_int \\<lfloor>r'\\<rfloor> < l''\n\ngoal (1 subgoal):\n 1. rat_of_int \\<lfloor>r'\\<rfloor> < l''", "."], ["proof (state)\nthis:\n  real_of_rat (rat_of_int \\<lfloor>r'\\<rfloor>) < real_of_rat l''\n\ngoal (2 subgoals):\n 1. rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "with ineq''(1)"], ["proof (chain)\npicking this:\n  real_of_rat l'' \\<le> real_of_1 x\n  real_of_rat (rat_of_int \\<lfloor>r'\\<rfloor>) < real_of_rat l''", "have \"?r ?fr' \\<le> ?x\""], ["proof (prove)\nusing this:\n  real_of_rat l'' \\<le> real_of_1 x\n  real_of_rat (rat_of_int \\<lfloor>r'\\<rfloor>) < real_of_rat l''\n\ngoal (1 subgoal):\n 1. real_of_rat (rat_of_int \\<lfloor>r'\\<rfloor>) \\<le> real_of_1 x", "by simp"], ["proof (state)\nthis:\n  real_of_rat (rat_of_int \\<lfloor>r'\\<rfloor>) \\<le> real_of_1 x\n\ngoal (2 subgoals):\n 1. rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "from floor_mono[OF this]"], ["proof (chain)\npicking this:\n  \\<lfloor>real_of_rat (rat_of_int \\<lfloor>r'\\<rfloor>)\\<rfloor>\n  \\<le> \\<lfloor>real_of_1 x\\<rfloor>", "have \"?fr \\<le> floor ?x\""], ["proof (prove)\nusing this:\n  \\<lfloor>real_of_rat (rat_of_int \\<lfloor>r'\\<rfloor>)\\<rfloor>\n  \\<le> \\<lfloor>real_of_1 x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>r'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<lfloor>r'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>\n\ngoal (2 subgoals):\n 1. rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n 2. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "ultimately"], ["proof (chain)\npicking this:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor>\n  \\<lfloor>r'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor>\n  \\<lfloor>r'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "unfolding id"], ["proof (prove)\nusing this:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor>\n  \\<lfloor>r'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> = \\<lfloor>r'\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n\ngoal (1 subgoal):\n 1. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "case False"], ["proof (state)\nthis:\n  \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l''\n\ngoal (1 subgoal):\n 1. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "with id"], ["proof (chain)\npicking this:\n  floor_1 x =\n  (if rat_of_int \\<lfloor>r'\\<rfloor> < l'' then \\<lfloor>r'\\<rfloor>\n   else \\<lfloor>l'\\<rfloor>)\n  \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l''", "have id: \"floor_1 x = ?fl\""], ["proof (prove)\nusing this:\n  floor_1 x =\n  (if rat_of_int \\<lfloor>r'\\<rfloor> < l'' then \\<lfloor>r'\\<rfloor>\n   else \\<lfloor>l'\\<rfloor>)\n  \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l''\n\ngoal (1 subgoal):\n 1. floor_1 x = \\<lfloor>l'\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  floor_1 x = \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "from False"], ["proof (chain)\npicking this:\n  \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l''", "have \"l'' \\<le> ?fr'\""], ["proof (prove)\nusing this:\n  \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l''\n\ngoal (1 subgoal):\n 1. l'' \\<le> rat_of_int \\<lfloor>r'\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  l'' \\<le> rat_of_int \\<lfloor>r'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "from floor_mono[OF ineq(1)]"], ["proof (chain)\npicking this:\n  \\<lfloor>real_of_rat l'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>", "have \"?fl \\<le> floor ?x\""], ["proof (prove)\nusing this:\n  \\<lfloor>real_of_rat l'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>l'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<lfloor>l'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "moreover"], ["proof (state)\nthis:\n  \\<lfloor>l'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "have \"floor ?x \\<le> ?fl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>", "from False fr'"], ["proof (chain)\npicking this:\n  \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l''\n  \\<not> (l'' \\<le> rat_of_int \\<lfloor>r'\\<rfloor> \\<and>\n          rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r'')", "have fr': \"r'' < ?fr'\""], ["proof (prove)\nusing this:\n  \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l''\n  \\<not> (l'' \\<le> rat_of_int \\<lfloor>r'\\<rfloor> \\<and>\n          rat_of_int \\<lfloor>r'\\<rfloor> \\<le> r'')\n\ngoal (1 subgoal):\n 1. r'' < rat_of_int \\<lfloor>r'\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  r'' < rat_of_int \\<lfloor>r'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>", "hence \"floor r'' < ?fr\""], ["proof (prove)\nusing this:\n  r'' < rat_of_int \\<lfloor>r'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>r''\\<rfloor> < \\<lfloor>r'\\<rfloor>", "by linarith"], ["proof (state)\nthis:\n  \\<lfloor>r''\\<rfloor> < \\<lfloor>r'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>", "with floor_mono[OF ineq''(2)]"], ["proof (chain)\npicking this:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>real_of_rat r''\\<rfloor>\n  \\<lfloor>r''\\<rfloor> < \\<lfloor>r'\\<rfloor>", "have \"floor ?x \\<le> ?fr - 1\""], ["proof (prove)\nusing this:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>real_of_rat r''\\<rfloor>\n  \\<lfloor>r''\\<rfloor> < \\<lfloor>r'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor> - 1", "by auto"], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor> - 1\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>", "also"], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>r'\\<rfloor> - 1\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>", "have \"?fr - 1 = floor (r' - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>r'\\<rfloor> - 1 = \\<lfloor>r' - 1\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  \\<lfloor>r'\\<rfloor> - 1 = \\<lfloor>r' - 1\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>", "also"], ["proof (state)\nthis:\n  \\<lfloor>r'\\<rfloor> - 1 = \\<lfloor>r' - 1\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>", "have \"\\<dots> \\<le> ?fl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>r' - 1\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>", "by (rule floor_mono, insert bnd, auto)"], ["proof (state)\nthis:\n  \\<lfloor>r' - 1\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>", "finally"], ["proof (chain)\npicking this:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>", "."], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> rat_of_int \\<lfloor>r'\\<rfloor> < l'' \\<Longrightarrow>\n    \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "ultimately"], ["proof (chain)\npicking this:\n  \\<lfloor>l'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lfloor>l'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x", "unfolding id"], ["proof (prove)\nusing this:\n  \\<lfloor>l'\\<rfloor> \\<le> \\<lfloor>real_of_1 x\\<rfloor>\n  \\<lfloor>real_of_1 x\\<rfloor> \\<le> \\<lfloor>l'\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>real_of_1 x\\<rfloor> = \\<lfloor>l'\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lfloor>real_of_1 x\\<rfloor> = floor_1 x\n\ngoal:\nNo subgoals!", "qed"], ["", "(* ********************* *)"], ["", "subsubsection\\<open>Generic Factorization and Bisection Framework\\<close>"], ["", "lemma card_1_Collect_ex1: assumes \"card (Collect P) = 1\"\n  shows \"\\<exists>! x. P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. P x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!x. P x", "from assms[unfolded card_eq_1_iff]"], ["proof (chain)\npicking this:\n  \\<exists>x. Collect P = {x}", "obtain x where \"Collect P = {x}\""], ["proof (prove)\nusing this:\n  \\<exists>x. Collect P = {x}\n\ngoal (1 subgoal):\n 1. (\\<And>x. Collect P = {x} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Collect P = {x}\n\ngoal (1 subgoal):\n 1. \\<exists>!x. P x", "thus ?thesis"], ["proof (prove)\nusing this:\n  Collect P = {x}\n\ngoal (1 subgoal):\n 1. \\<exists>!x. P x", "by (intro ex1I[of _ x], auto)"], ["proof (state)\nthis:\n  \\<exists>!x. P x\n\ngoal:\nNo subgoals!", "qed"], ["", "fun sub_interval :: \"rat \\<times> rat \\<Rightarrow> rat \\<times> rat \\<Rightarrow> bool\" where\n  \"sub_interval (l,r) (l',r') = (l' \\<le> l \\<and> r \\<le> r')\""], ["", "fun in_interval :: \"rat \\<times> rat \\<Rightarrow> real \\<Rightarrow> bool\" where \n  \"in_interval (l,r) x = (of_rat l \\<le> x \\<and> x \\<le> of_rat r)\""], ["", "definition converges_to :: \"(nat \\<Rightarrow> rat \\<times> rat) \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"converges_to f x \\<equiv> (\\<forall> n. in_interval (f n) x \\<and> sub_interval (f (Suc n)) (f n))\n   \\<and> (\\<forall> (eps :: real) > 0. \\<exists> n l r. f n = (l,r) \\<and> of_rat r - of_rat l \\<le> eps)\""], ["", "context\n  fixes bnd_update :: \"'a \\<Rightarrow> 'a\" \n  and bnd_get :: \"'a \\<Rightarrow> rat \\<times> rat\"\nbegin"], ["", "definition at_step :: \"(nat \\<Rightarrow> rat \\<times> rat) \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"at_step f n a \\<equiv> \\<forall> i. bnd_get ((bnd_update ^^ i) a) = f (n + i)\""], ["", "partial_function (tailrec) select_correct_factor_main\n  :: \"'a \\<Rightarrow> (int poly \\<times> root_info)list \\<Rightarrow> (int poly \\<times> root_info)list\n    \\<Rightarrow> rat \\<Rightarrow> rat \\<Rightarrow> nat \\<Rightarrow> (int poly \\<times> root_info) \\<times> rat \\<times> rat\" where\n  [code]: \"select_correct_factor_main bnd todo old l r n = (case todo of Nil\n    \\<Rightarrow> if n = 1 then (hd old, l, r) else let bnd' = bnd_update bnd in (case bnd_get bnd' of (l,r) \\<Rightarrow> \n      select_correct_factor_main bnd' old [] l r 0)\n   | Cons (p,ri) todo \\<Rightarrow> let m = root_info.l_r ri l r in \n      if m = 0 then select_correct_factor_main bnd todo old l r n\n      else select_correct_factor_main bnd todo ((p,ri) # old) l r (n + m))\""], ["", "definition select_correct_factor :: \"'a \\<Rightarrow> (int poly \\<times> root_info)list \\<Rightarrow>\n    (int poly \\<times> root_info) \\<times> rat \\<times> rat\" where\n  \"select_correct_factor init polys = (case bnd_get init of (l,r) \\<Rightarrow>\n    select_correct_factor_main init polys [] l r 0)\""], ["", "lemma select_correct_factor_main: assumes conv: \"converges_to f x\"\n  and at: \"at_step f i a\"\n  and res: \"select_correct_factor_main a todo old l r n = ((q,ri_fin),(l_fin,r_fin))\"\n  and bnd: \"bnd_get a = (l,r)\"\n  and ri: \"\\<And> q ri. (q,ri) \\<in> set todo \\<union> set old \\<Longrightarrow> root_info_cond ri q\"\n  and q0: \"\\<And> q ri. (q,ri) \\<in> set todo \\<union> set old \\<Longrightarrow> q \\<noteq> 0\"\n  and ex: \"\\<exists>q. q \\<in> fst ` set todo \\<union> fst ` set old \\<and> ipoly q x = 0\"\n  and dist: \"distinct (map fst (todo @ old))\"\n  and old: \"\\<And> q ri. (q,ri) \\<in> set old \\<Longrightarrow> root_info.l_r ri l r \\<noteq> 0\"\n  and un: \"\\<And> x :: real. (\\<exists>q. q \\<in> fst ` set todo \\<union> fst ` set old \\<and> ipoly q x = 0) \\<Longrightarrow> \n    \\<exists>!q. q \\<in> fst ` set todo \\<union> fst ` set old \\<and> ipoly q x = 0\"\n  and n: \"n = sum_list (map (\\<lambda> (q,ri). root_info.l_r ri l r) old)\"\n  shows \"unique_root (q,l_fin,r_fin) \\<and> (q,ri_fin) \\<in> set todo \\<union> set old \\<and> x = the_unique_root (q,l_fin,r_fin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "define orig where \"orig = set todo \\<union> set old\""], ["proof (state)\nthis:\n  orig = set todo \\<union> set old\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "have orig: \"set todo \\<union> set old \\<subseteq> orig\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set todo \\<union> set old \\<subseteq> orig", "unfolding orig_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set todo \\<union> set old \\<subseteq> set todo \\<union> set old", "by auto"], ["proof (state)\nthis:\n  set todo \\<union> set old \\<subseteq> orig\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "let ?rts = \"{x :: real. \\<exists> q ri. (q,ri) \\<in> orig \\<and> ipoly q x = 0}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "define rts where \"rts = ?rts\""], ["proof (state)\nthis:\n  rts =\n  {x. \\<exists>q ri.\n         (q, ri) \\<in> orig \\<and> poly (real_of_int_poly q) x = 0}\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "let ?h = \"\\<lambda> (x,y). abs (x - y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "let ?r = real_of_rat"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "have rts: \"?rts = (\\<Union> ((\\<lambda> (q,ri). {x. ipoly q x = 0}) ` set (todo @ old)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>q ri.\n           (q, ri) \\<in> orig \\<and> poly (real_of_int_poly q) x = 0} =\n    (\\<Union>(q, ri)\\<in>set (todo @ old).\n        {x. poly (real_of_int_poly q) x = 0})", "unfolding orig_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<and>\n           poly (real_of_int_poly q) x = 0} =\n    (\\<Union>(q, ri)\\<in>set (todo @ old).\n        {x. poly (real_of_int_poly q) x = 0})", "by auto"], ["proof (state)\nthis:\n  {x. \\<exists>q ri.\n         (q, ri) \\<in> orig \\<and> poly (real_of_int_poly q) x = 0} =\n  (\\<Union>(q, ri)\\<in>set (todo @ old).\n      {x. poly (real_of_int_poly q) x = 0})\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "have \"finite rts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite rts", "unfolding rts rts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>(q, ri)\\<in>set (todo @ old).\n         {x. poly (real_of_int_poly q) x = 0})", "using finite_ipoly_roots[OF q0] finite_set[of \"todo @ old\"]"], ["proof (prove)\nusing this:\n  (?p, ?ri1) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  finite {x. poly (real_of_int_poly ?p) x = 0}\n  finite (set (todo @ old))\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>(q, ri)\\<in>set (todo @ old).\n         {x. poly (real_of_int_poly q) x = 0})", "by auto"], ["proof (state)\nthis:\n  finite rts\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "hence fin: \"finite (rts \\<times> rts - Id)\""], ["proof (prove)\nusing this:\n  finite rts\n\ngoal (1 subgoal):\n 1. finite (rts \\<times> rts - Id)", "by auto"], ["proof (state)\nthis:\n  finite (rts \\<times> rts - Id)\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "define diffs where \"diffs = insert 1 {abs (x - y) | x y. x \\<in> rts \\<and> y \\<in> rts \\<and> x \\<noteq> y}\""], ["proof (state)\nthis:\n  diffs =\n  insert 1\n   {\\<bar>x - y\\<bar> |x y.\n    x \\<in> rts \\<and> y \\<in> rts \\<and> x \\<noteq> y}\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "have \"finite {abs (x - y) | x y. x \\<in> rts \\<and> y \\<in> rts \\<and> x \\<noteq> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {\\<bar>x - y\\<bar> |x y.\n      x \\<in> rts \\<and> y \\<in> rts \\<and> x \\<noteq> y}", "by (rule subst[of _ _ finite, OF _ finite_imageI[OF fin, of ?h]], auto)"], ["proof (state)\nthis:\n  finite\n   {\\<bar>x - y\\<bar> |x y.\n    x \\<in> rts \\<and> y \\<in> rts \\<and> x \\<noteq> y}\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "hence diffs: \"finite diffs\" \"diffs \\<noteq> {}\""], ["proof (prove)\nusing this:\n  finite\n   {\\<bar>x - y\\<bar> |x y.\n    x \\<in> rts \\<and> y \\<in> rts \\<and> x \\<noteq> y}\n\ngoal (1 subgoal):\n 1. finite diffs &&& diffs \\<noteq> {}", "unfolding diffs_def"], ["proof (prove)\nusing this:\n  finite\n   {\\<bar>x - y\\<bar> |x y.\n    x \\<in> rts \\<and> y \\<in> rts \\<and> x \\<noteq> y}\n\ngoal (1 subgoal):\n 1. finite\n     (insert 1\n       {\\<bar>x - y\\<bar> |x y.\n        x \\<in> rts \\<and> y \\<in> rts \\<and> x \\<noteq> y}) &&&\n    insert 1\n     {\\<bar>x - y\\<bar> |x y.\n      x \\<in> rts \\<and> y \\<in> rts \\<and> x \\<noteq> y} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  finite diffs\n  diffs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "define eps where \"eps = Min diffs / 2\""], ["proof (state)\nthis:\n  eps = Min diffs / 2\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "have \"\\<And> x. x \\<in> diffs \\<Longrightarrow> x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> diffs \\<Longrightarrow> 0 < x", "unfolding diffs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> insert 1\n                {\\<bar>x - y\\<bar> |x y.\n                 x \\<in> rts \\<and>\n                 y \\<in> rts \\<and> x \\<noteq> y} \\<Longrightarrow>\n       0 < x", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> diffs \\<Longrightarrow> 0 < ?x1\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "with Min_gr_iff[OF diffs]"], ["proof (chain)\npicking this:\n  (?x < Min diffs) = (\\<forall>a\\<in>diffs. ?x < a)\n  ?x1 \\<in> diffs \\<Longrightarrow> 0 < ?x1", "have eps: \"eps > 0\""], ["proof (prove)\nusing this:\n  (?x < Min diffs) = (\\<forall>a\\<in>diffs. ?x < a)\n  ?x1 \\<in> diffs \\<Longrightarrow> 0 < ?x1\n\ngoal (1 subgoal):\n 1. 0 < eps", "unfolding eps_def"], ["proof (prove)\nusing this:\n  (?x < Min diffs) = (\\<forall>a\\<in>diffs. ?x < a)\n  ?x1 \\<in> diffs \\<Longrightarrow> 0 < ?x1\n\ngoal (1 subgoal):\n 1. 0 < Min diffs / 2", "by auto"], ["proof (state)\nthis:\n  0 < eps\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "note conv = conv[unfolded converges_to_def]"], ["proof (state)\nthis:\n  (\\<forall>n.\n      in_interval (f n) x \\<and> sub_interval (f (Suc n)) (f n)) \\<and>\n  (\\<forall>eps>0.\n      \\<exists>n l r.\n         f n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps)\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from conv eps"], ["proof (chain)\npicking this:\n  (\\<forall>n.\n      in_interval (f n) x \\<and> sub_interval (f (Suc n)) (f n)) \\<and>\n  (\\<forall>eps>0.\n      \\<exists>n l r.\n         f n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps)\n  0 < eps", "obtain N L R where \n    N: \"f N = (L,R)\" \"?r R - ?r L \\<le> eps\""], ["proof (prove)\nusing this:\n  (\\<forall>n.\n      in_interval (f n) x \\<and> sub_interval (f (Suc n)) (f n)) \\<and>\n  (\\<forall>eps>0.\n      \\<exists>n l r.\n         f n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps)\n  0 < eps\n\ngoal (1 subgoal):\n 1. (\\<And>N L R.\n        \\<lbrakk>f N = (L, R);\n         real_of_rat R - real_of_rat L \\<le> eps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f N = (L, R)\n  real_of_rat R - real_of_rat L \\<le> eps\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "obtain pair where pair: \"pair = (todo,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pair.\n        pair = (todo, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pair = (todo, i)\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "define rel where \"rel = measures [ \\<lambda> (t,i). N - i, \\<lambda> (t :: (int poly \\<times> root_info) list,i). length t]\""], ["proof (state)\nthis:\n  rel = measures [\\<lambda>(t, i). N - i, \\<lambda>(t, i). length t]\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "have wf: \"wf rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf rel", "unfolding rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measures [\\<lambda>(t, y). N - y, \\<lambda>(t, i). length t])", "by simp"], ["proof (state)\nthis:\n  wf rel\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "using at res bnd ri q0 ex dist old un n pair orig"], ["proof (prove)\nusing this:\n  local.at_step f i a\n  local.select_correct_factor_main a todo old l r n =\n  ((q, ri_fin), l_fin, r_fin)\n  bnd_get a = (l, r)\n  (?q, ?ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  root_info_cond ?ri ?q\n  (?q, ?ri) \\<in> set todo \\<union> set old \\<Longrightarrow> ?q \\<noteq> 0\n  \\<exists>q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) x = 0\n  distinct (map fst (todo @ old))\n  (?q, ?ri) \\<in> set old \\<Longrightarrow> root_info.l_r ?ri l r \\<noteq> 0\n  \\<exists>q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) ?x = 0 \\<Longrightarrow>\n  \\<exists>!q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) ?x = 0\n  n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r)\n  pair = (todo, i)\n  set todo \\<union> set old \\<subseteq> orig\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "proof (induct pair arbitrary: todo i old a l r n rule: wf_induct[OF wf])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "case (1 pair todo i old a l r n)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, pair) \\<in> rel \\<longrightarrow>\n     (\\<forall>xa xaa xaaa xaaaa.\n         local.at_step f xaa xaaaa \\<longrightarrow>\n         (\\<forall>xaaaaa xaaaaaa xaaaaaaa.\n             local.select_correct_factor_main xaaaa xa xaaa xaaaaa xaaaaaa\n              xaaaaaaa =\n             ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n             bnd_get xaaaa = (xaaaaa, xaaaaaa) \\<longrightarrow>\n             (\\<forall>x xaa.\n                 (x, xaa) \\<in> set xa \\<union> set xaaa \\<longrightarrow>\n                 root_info_cond xaa x) \\<longrightarrow>\n             (\\<forall>x xaa.\n                 (x, xaa) \\<in> set xa \\<union> set xaaa \\<longrightarrow>\n                 x \\<noteq> 0) \\<longrightarrow>\n             (\\<exists>q.\n                 q \\<in> fst ` set xa \\<union> fst ` set xaaa \\<and>\n                 poly (real_of_int_poly q) x = 0) \\<longrightarrow>\n             distinct (map fst (xa @ xaaa)) \\<longrightarrow>\n             (\\<forall>x xa.\n                 (x, xa) \\<in> set xaaa \\<longrightarrow>\n                 root_info.l_r xa xaaaaa xaaaaaa \\<noteq>\n                 0) \\<longrightarrow>\n             (\\<forall>x.\n                 (\\<exists>q.\n                     q \\<in> fst ` set xa \\<union> fst ` set xaaa \\<and>\n                     poly (real_of_int_poly q) x = 0) \\<longrightarrow>\n                 (\\<exists>!q.\n                     q \\<in> fst ` set xa \\<union> fst ` set xaaa \\<and>\n                     poly (real_of_int_poly q) x = 0)) \\<longrightarrow>\n             xaaaaaaa =\n             (\\<Sum>a\\<leftarrow>xaaa. case a of\n (q, ri) \\<Rightarrow> root_info.l_r ri xaaaaa xaaaaaa) \\<longrightarrow>\n             y = (xa, xaa) \\<longrightarrow>\n             set xa \\<union> set xaaa \\<subseteq> orig \\<longrightarrow>\n             (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n             (q, ri_fin) \\<in> set xa \\<union> set xaaa \\<and>\n             x = real_of_1 (q, l_fin, r_fin)))\n  local.at_step f i a\n  local.select_correct_factor_main a todo old l r n =\n  ((q, ri_fin), l_fin, r_fin)\n  bnd_get a = (l, r)\n  (?q1, ?ri1) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  root_info_cond ?ri1 ?q1\n  (?q1, ?ri1) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  ?q1 \\<noteq> 0\n  \\<exists>q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) x = 0\n  distinct (map fst (todo @ old))\n  (?q1, ?ri1) \\<in> set old \\<Longrightarrow>\n  root_info.l_r ?ri1 l r \\<noteq> 0\n  \\<exists>q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) ?x1 = 0 \\<Longrightarrow>\n  \\<exists>!q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) ?x1 = 0\n  n =\n  (\\<Sum>a\\<leftarrow>old. case a of\n                           (q, ri) \\<Rightarrow> root_info.l_r ri l r)\n  pair = (todo, i)\n  set todo \\<union> set old \\<subseteq> orig\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "note IH = 1(1)[rule_format]"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, pair) \\<in> rel; local.at_step f ?xa ?xc;\n   local.select_correct_factor_main ?xc ?x ?xb ?xd ?xe ?xf =\n   ((q, ri_fin), l_fin, r_fin);\n   bnd_get ?xc = (?xd, ?xe);\n   \\<And>x xa.\n      (x, xa) \\<in> set ?x \\<union> set ?xb \\<Longrightarrow>\n      root_info_cond xa x;\n   \\<And>x xa.\n      (x, xa) \\<in> set ?x \\<union> set ?xb \\<Longrightarrow> x \\<noteq> 0;\n   \\<exists>q.\n      q \\<in> fst ` set ?x \\<union> fst ` set ?xb \\<and>\n      poly (real_of_int_poly q) x = 0;\n   distinct (map fst (?x @ ?xb));\n   \\<And>x xa.\n      (x, xa) \\<in> set ?xb \\<Longrightarrow>\n      root_info.l_r xa ?xd ?xe \\<noteq> 0;\n   \\<And>x.\n      \\<exists>q.\n         q \\<in> fst ` set ?x \\<union> fst ` set ?xb \\<and>\n         poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n      \\<exists>!q.\n         q \\<in> fst ` set ?x \\<union> fst ` set ?xb \\<and>\n         poly (real_of_int_poly q) x = 0;\n   ?xf = (\\<Sum>(q, ri)\\<leftarrow>?xb. root_info.l_r ri ?xd ?xe);\n   ?y = (?x, ?xa); set ?x \\<union> set ?xb \\<subseteq> orig\\<rbrakk>\n  \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                    (q, ri_fin) \\<in> set ?x \\<union> set ?xb \\<and>\n                    x = real_of_1 (q, l_fin, r_fin)\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "note at = 1(2)"], ["proof (state)\nthis:\n  local.at_step f i a\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "note res = 1(3)[unfolded select_correct_factor_main.simps[of _ todo]]"], ["proof (state)\nthis:\n  (case todo of\n   [] \\<Rightarrow>\n     if n = 1 then (hd old, l, r)\n     else let bnd' = bnd_update a\n          in case bnd_get bnd' of\n             (l, r) \\<Rightarrow>\n               local.select_correct_factor_main bnd' old [] l r 0\n   | (p, ri) # todo \\<Rightarrow>\n       let m = root_info.l_r ri l r\n       in if m = 0 then local.select_correct_factor_main a todo old l r n\n          else local.select_correct_factor_main a todo ((p, ri) # old) l r\n                (n + m)) =\n  ((q, ri_fin), l_fin, r_fin)\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "note bnd = 1(4)"], ["proof (state)\nthis:\n  bnd_get a = (l, r)\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "note ri = 1(5)"], ["proof (state)\nthis:\n  (?q1, ?ri1) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  root_info_cond ?ri1 ?q1\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "note q0 = 1(6)"], ["proof (state)\nthis:\n  (?q1, ?ri1) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  ?q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "note ex = 1(7)"], ["proof (state)\nthis:\n  \\<exists>q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "note dist = 1(8)"], ["proof (state)\nthis:\n  distinct (map fst (todo @ old))\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "note old = 1(9)"], ["proof (state)\nthis:\n  (?q1, ?ri1) \\<in> set old \\<Longrightarrow>\n  root_info.l_r ?ri1 l r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "note un = 1(10)"], ["proof (state)\nthis:\n  \\<exists>q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) ?x1 = 0 \\<Longrightarrow>\n  \\<exists>!q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) ?x1 = 0\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "note n = 1(11)"], ["proof (state)\nthis:\n  n =\n  (\\<Sum>a\\<leftarrow>old. case a of\n                           (q, ri) \\<Rightarrow> root_info.l_r ri l r)\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "note pair = 1(12)"], ["proof (state)\nthis:\n  pair = (todo, i)\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "note orig = 1(13)"], ["proof (state)\nthis:\n  set todo \\<union> set old \\<subseteq> orig\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "from at[unfolded at_step_def, rule_format, of 0] bnd"], ["proof (chain)\npicking this:\n  bnd_get ((bnd_update ^^ 0) a) = f (i + 0)\n  bnd_get a = (l, r)", "have fi: \"f i = (l,r)\""], ["proof (prove)\nusing this:\n  bnd_get ((bnd_update ^^ 0) a) = f (i + 0)\n  bnd_get a = (l, r)\n\ngoal (1 subgoal):\n 1. f i = (l, r)", "by auto"], ["proof (state)\nthis:\n  f i = (l, r)\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "with conv"], ["proof (chain)\npicking this:\n  (\\<forall>n.\n      in_interval (f n) x \\<and> sub_interval (f (Suc n)) (f n)) \\<and>\n  (\\<forall>eps>0.\n      \\<exists>n l r.\n         f n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps)\n  f i = (l, r)", "have inx: \"in_interval (f i) x\""], ["proof (prove)\nusing this:\n  (\\<forall>n.\n      in_interval (f n) x \\<and> sub_interval (f (Suc n)) (f n)) \\<and>\n  (\\<forall>eps>0.\n      \\<exists>n l r.\n         f n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps)\n  f i = (l, r)\n\ngoal (1 subgoal):\n 1. in_interval (f i) x", "by blast"], ["proof (state)\nthis:\n  in_interval (f i) x\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "hence lxr: \"?r l \\<le> x\" \"x \\<le> ?r r\""], ["proof (prove)\nusing this:\n  in_interval (f i) x\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> x &&& x \\<le> real_of_rat r", "unfolding fi"], ["proof (prove)\nusing this:\n  in_interval (l, r) x\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> x &&& x \\<le> real_of_rat r", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "from order.trans[OF this]"], ["proof (chain)\npicking this:\n  real_of_rat l \\<le> real_of_rat r", "have lr: \"l \\<le> r\""], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. l \\<le> r", "unfolding of_rat_less_eq"], ["proof (prove)\nusing this:\n  l \\<le> r\n\ngoal (1 subgoal):\n 1. l \\<le> r", "."], ["proof (state)\nthis:\n  l \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>xa todo i old a l r n.\n       \\<lbrakk>\\<forall>y.\n                   (y, xa) \\<in> rel \\<longrightarrow>\n                   (\\<forall>xa xb xc xd.\n                       local.at_step f xb xd \\<longrightarrow>\n                       (\\<forall>xe xf xg.\n                           local.select_correct_factor_main xd xa xc xe xf\n                            xg =\n                           ((q, ri_fin), l_fin, r_fin) \\<longrightarrow>\n                           bnd_get xd = (xe, xf) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               root_info_cond xb x) \\<longrightarrow>\n                           (\\<forall>x xb.\n                               (x, xb)\n                               \\<in> set xa \\<union>\n                                     set xc \\<longrightarrow>\n                               x \\<noteq> 0) \\<longrightarrow>\n                           (\\<exists>q.\n                               q \\<in> fst ` set xa \\<union>\n fst ` set xc \\<and>\n                               poly (real_of_int_poly q) x =\n                               0) \\<longrightarrow>\n                           distinct (map fst (xa @ xc)) \\<longrightarrow>\n                           (\\<forall>x xa.\n                               (x, xa) \\<in> set xc \\<longrightarrow>\n                               root_info.l_r xa xe xf \\<noteq>\n                               0) \\<longrightarrow>\n                           (\\<forall>x.\n                               (\\<exists>q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0) \\<longrightarrow>\n                               (\\<exists>!q.\n                                   q \\<in> fst ` set xa \\<union>\n     fst ` set xc \\<and>\n                                   poly (real_of_int_poly q) x =\n                                   0)) \\<longrightarrow>\n                           xg =\n                           (\\<Sum>(q,\n                               ri)\\<leftarrow>xc. root_info.l_r ri xe\n             xf) \\<longrightarrow>\n                           y = (xa, xb) \\<longrightarrow>\n                           set xa \\<union> set xc\n                           \\<subseteq> orig \\<longrightarrow>\n                           Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                           (q, ri_fin) \\<in> set xa \\<union> set xc \\<and>\n                           x = real_of_1 (q, l_fin, r_fin)));\n        local.at_step f i a;\n        local.select_correct_factor_main a todo old l r n =\n        ((q, ri_fin), l_fin, r_fin);\n        bnd_get a = (l, r);\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           root_info_cond ri q;\n        \\<And>q ri.\n           (q, ri) \\<in> set todo \\<union> set old \\<Longrightarrow>\n           q \\<noteq> 0;\n        \\<exists>q.\n           q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n           poly (real_of_int_poly q) x = 0;\n        distinct (map fst (todo @ old));\n        \\<And>q ri.\n           (q, ri) \\<in> set old \\<Longrightarrow>\n           root_info.l_r ri l r \\<noteq> 0;\n        \\<And>x.\n           \\<exists>q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n           \\<exists>!q.\n              q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n              poly (real_of_int_poly q) x = 0;\n        n = (\\<Sum>(q, ri)\\<leftarrow>old. root_info.l_r ri l r);\n        xa = (todo, i); set todo \\<union> set old \\<subseteq> orig\\<rbrakk>\n       \\<Longrightarrow> Ex1 (root_cond (q, l_fin, r_fin)) \\<and>\n                         (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n                         x = real_of_1 (q, l_fin, r_fin)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "proof (cases todo)"], ["proof (state)\ngoal (2 subgoals):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. \\<And>a list.\n       todo = a # list \\<Longrightarrow>\n       (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n       (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n       x = real_of_1 (q, l_fin, r_fin)", "case (Cons rri tod)"], ["proof (state)\nthis:\n  todo = rri # tod\n\ngoal (2 subgoals):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. \\<And>a list.\n       todo = a # list \\<Longrightarrow>\n       (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n       (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n       x = real_of_1 (q, l_fin, r_fin)", "obtain s ri where rri: \"rri = (s,ri)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s ri. rri = (s, ri) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rri = (s, ri)\n\ngoal (2 subgoals):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. \\<And>a list.\n       todo = a # list \\<Longrightarrow>\n       (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n       (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n       x = real_of_1 (q, l_fin, r_fin)", "with Cons"], ["proof (chain)\npicking this:\n  todo = rri # tod\n  rri = (s, ri)", "have todo: \"todo = (s,ri) # tod\""], ["proof (prove)\nusing this:\n  todo = rri # tod\n  rri = (s, ri)\n\ngoal (1 subgoal):\n 1. todo = (s, ri) # tod", "by simp"], ["proof (state)\nthis:\n  todo = (s, ri) # tod\n\ngoal (2 subgoals):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. \\<And>a list.\n       todo = a # list \\<Longrightarrow>\n       (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n       (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n       x = real_of_1 (q, l_fin, r_fin)", "note res = res[unfolded todo list.simps split Let_def]"], ["proof (state)\nthis:\n  (if root_info.l_r ri l r = 0\n   then local.select_correct_factor_main a tod old l r n\n   else local.select_correct_factor_main a tod ((s, ri) # old) l r\n         (n + root_info.l_r ri l r)) =\n  ((q, ri_fin), l_fin, r_fin)\n\ngoal (2 subgoals):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. \\<And>a list.\n       todo = a # list \\<Longrightarrow>\n       (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n       (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n       x = real_of_1 (q, l_fin, r_fin)", "from root_info_condD(1)[OF ri[of s ri, unfolded todo] lr]"], ["proof (chain)\npicking this:\n  (s, ri) \\<in> set ((s, ri) # tod) \\<union> set old \\<Longrightarrow>\n  root_info.l_r ri l r = card {x. root_cond (s, l, r) x}", "have ri': \"root_info.l_r ri l r = card {x. root_cond (s, l, r) x}\""], ["proof (prove)\nusing this:\n  (s, ri) \\<in> set ((s, ri) # tod) \\<union> set old \\<Longrightarrow>\n  root_info.l_r ri l r = card {x. root_cond (s, l, r) x}\n\ngoal (1 subgoal):\n 1. root_info.l_r ri l r = card {x. root_cond (s, l, r) x}", "by auto"], ["proof (state)\nthis:\n  root_info.l_r ri l r = card {x. root_cond (s, l, r) x}\n\ngoal (2 subgoals):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. \\<And>a list.\n       todo = a # list \\<Longrightarrow>\n       (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n       (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n       x = real_of_1 (q, l_fin, r_fin)", "from q0"], ["proof (chain)\npicking this:\n  (?q1, ?ri1) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  ?q1 \\<noteq> 0", "have s0: \"s \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (?q1, ?ri1) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  ?q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0", "unfolding todo"], ["proof (prove)\nusing this:\n  (?q1, ?ri1) \\<in> set ((s, ri) # tod) \\<union> set old \\<Longrightarrow>\n  ?q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  s \\<noteq> 0\n\ngoal (2 subgoals):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. \\<And>a list.\n       todo = a # list \\<Longrightarrow>\n       (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n       (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n       x = real_of_1 (q, l_fin, r_fin)", "from finite_ipoly_roots[OF s0]"], ["proof (chain)\npicking this:\n  finite {x. poly (real_of_int_poly s) x = 0}", "have fins: \"finite {x. root_cond (s, l, r) x}\""], ["proof (prove)\nusing this:\n  finite {x. poly (real_of_int_poly s) x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. root_cond (s, l, r) x}", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  finite {x. poly (real_of_int_poly s) x = 0}\n\ngoal (1 subgoal):\n 1. finite\n     {x. case (s, l, r) of\n         (p, l, r) \\<Rightarrow>\n           real_of_rat l \\<le> x \\<and>\n           x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0}", "by auto"], ["proof (state)\nthis:\n  finite {x. root_cond (s, l, r) x}\n\ngoal (2 subgoals):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. \\<And>a list.\n       todo = a # list \\<Longrightarrow>\n       (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n       (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n       x = real_of_1 (q, l_fin, r_fin)", "have rel: \"((tod,i), pair) \\<in> rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((tod, i), pair) \\<in> rel", "unfolding rel_def pair todo"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((tod, i), (s, ri) # tod, i)\n    \\<in> measures [\\<lambda>(t, y). N - y, \\<lambda>(t, i). length t]", "by simp"], ["proof (state)\nthis:\n  ((tod, i), pair) \\<in> rel\n\ngoal (2 subgoals):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. \\<And>a list.\n       todo = a # list \\<Longrightarrow>\n       (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n       (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n       x = real_of_1 (q, l_fin, r_fin)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "proof (cases \"root_info.l_r ri l r = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. root_info.l_r ri l r = 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. root_info.l_r ri l r \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "case True"], ["proof (state)\nthis:\n  root_info.l_r ri l r = 0\n\ngoal (2 subgoals):\n 1. root_info.l_r ri l r = 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. root_info.l_r ri l r \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "with res"], ["proof (chain)\npicking this:\n  (if root_info.l_r ri l r = 0\n   then local.select_correct_factor_main a tod old l r n\n   else local.select_correct_factor_main a tod ((s, ri) # old) l r\n         (n + root_info.l_r ri l r)) =\n  ((q, ri_fin), l_fin, r_fin)\n  root_info.l_r ri l r = 0", "have res: \"select_correct_factor_main a tod old l r n = ((q, ri_fin), l_fin, r_fin)\""], ["proof (prove)\nusing this:\n  (if root_info.l_r ri l r = 0\n   then local.select_correct_factor_main a tod old l r n\n   else local.select_correct_factor_main a tod ((s, ri) # old) l r\n         (n + root_info.l_r ri l r)) =\n  ((q, ri_fin), l_fin, r_fin)\n  root_info.l_r ri l r = 0\n\ngoal (1 subgoal):\n 1. local.select_correct_factor_main a tod old l r n =\n    ((q, ri_fin), l_fin, r_fin)", "by auto"], ["proof (state)\nthis:\n  local.select_correct_factor_main a tod old l r n =\n  ((q, ri_fin), l_fin, r_fin)\n\ngoal (2 subgoals):\n 1. root_info.l_r ri l r = 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. root_info.l_r ri l r \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from ri'[symmetric, unfolded True] fins"], ["proof (chain)\npicking this:\n  card {x. root_cond (s, l, r) x} = 0\n  finite {x. root_cond (s, l, r) x}", "have empty: \"{x. root_cond (s, l, r) x} = {}\""], ["proof (prove)\nusing this:\n  card {x. root_cond (s, l, r) x} = 0\n  finite {x. root_cond (s, l, r) x}\n\ngoal (1 subgoal):\n 1. {x. root_cond (s, l, r) x} = {}", "by simp"], ["proof (state)\nthis:\n  {x. root_cond (s, l, r) x} = {}\n\ngoal (2 subgoals):\n 1. root_info.l_r ri l r = 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. root_info.l_r ri l r \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from ex lxr empty"], ["proof (chain)\npicking this:\n  \\<exists>q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) x = 0\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  {x. root_cond (s, l, r) x} = {}", "have ex': \"(\\<exists>q. q \\<in> fst ` set tod \\<union> fst ` set old \\<and> ipoly q x = 0)\""], ["proof (prove)\nusing this:\n  \\<exists>q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) x = 0\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  {x. root_cond (s, l, r) x} = {}\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n       poly (real_of_int_poly q) x = 0", "unfolding todo root_cond_def split"], ["proof (prove)\nusing this:\n  \\<exists>q.\n     q \\<in> fst ` set ((s, ri) # tod) \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) x = 0\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  {x. real_of_rat l \\<le> x \\<and>\n      x \\<le> real_of_rat r \\<and> poly (real_of_int_poly s) x = 0} =\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n       poly (real_of_int_poly q) x = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>q.\n     q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) x = 0\n\ngoal (2 subgoals):\n 1. root_info.l_r ri l r = 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. root_info.l_r ri l r \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "have \"unique_root (q, l_fin, r_fin) \\<and> (q, ri_fin) \\<in> set tod \\<union> set old \\<and> \n          x = the_unique_root (q, l_fin, r_fin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n    (q, ri_fin) \\<in> set tod \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "proof (rule IH[OF rel at res bnd ri _ ex' _ _ _ n refl], goal_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set old \\<Longrightarrow>\n       (x, xa) \\<in> set todo \\<union> set old\n 2. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set old \\<Longrightarrow> x \\<noteq> 0\n 3. distinct (map fst (tod @ old))\n 4. \\<And>x xa.\n       (x, xa) \\<in> set old \\<Longrightarrow>\n       root_info.l_r xa l r \\<noteq> 0\n 5. \\<And>x.\n       \\<exists>q.\n          q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n          poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n       \\<exists>!q.\n          q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n          poly (real_of_int_poly q) x = 0\n 6. set tod \\<union> set old \\<subseteq> orig", "case (5 y)"], ["proof (state)\nthis:\n  \\<exists>q.\n     q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) y = 0\n\ngoal (6 subgoals):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set old \\<Longrightarrow>\n       (x, xa) \\<in> set todo \\<union> set old\n 2. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set old \\<Longrightarrow> x \\<noteq> 0\n 3. distinct (map fst (tod @ old))\n 4. \\<And>x xa.\n       (x, xa) \\<in> set old \\<Longrightarrow>\n       root_info.l_r xa l r \\<noteq> 0\n 5. \\<And>x.\n       \\<exists>q.\n          q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n          poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n       \\<exists>!q.\n          q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n          poly (real_of_int_poly q) x = 0\n 6. set tod \\<union> set old \\<subseteq> orig", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>q.\n     q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) y = 0\n\ngoal (1 subgoal):\n 1. \\<exists>!q.\n       q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n       poly (real_of_int_poly q) y = 0", "using un[of y]"], ["proof (prove)\nusing this:\n  \\<exists>q.\n     q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) y = 0\n  \\<exists>q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) y = 0 \\<Longrightarrow>\n  \\<exists>!q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) y = 0\n\ngoal (1 subgoal):\n 1. \\<exists>!q.\n       q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n       poly (real_of_int_poly q) y = 0", "unfolding todo"], ["proof (prove)\nusing this:\n  \\<exists>q.\n     q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) y = 0\n  \\<exists>q.\n     q \\<in> fst ` set ((s, ri) # tod) \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) y = 0 \\<Longrightarrow>\n  \\<exists>!q.\n     q \\<in> fst ` set ((s, ri) # tod) \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) y = 0\n\ngoal (1 subgoal):\n 1. \\<exists>!q.\n       q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n       poly (real_of_int_poly q) y = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>!q.\n     q \\<in> fst ` set tod \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) y = 0\n\ngoal (5 subgoals):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set old \\<Longrightarrow>\n       (x, xa) \\<in> set todo \\<union> set old\n 2. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set old \\<Longrightarrow> x \\<noteq> 0\n 3. distinct (map fst (tod @ old))\n 4. \\<And>x xa.\n       (x, xa) \\<in> set old \\<Longrightarrow>\n       root_info.l_r xa l r \\<noteq> 0\n 5. set tod \\<union> set old \\<subseteq> orig", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set old \\<Longrightarrow>\n       (x, xa) \\<in> set todo \\<union> set old\n 2. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set old \\<Longrightarrow> x \\<noteq> 0\n 3. distinct (map fst (tod @ old))\n 4. \\<And>x xa.\n       (x, xa) \\<in> set old \\<Longrightarrow>\n       root_info.l_r xa l r \\<noteq> 0\n 5. set tod \\<union> set old \\<subseteq> orig", "case 2"], ["proof (state)\nthis:\n  (x_, xa_) \\<in> set tod \\<union> set old\n\ngoal (5 subgoals):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set old \\<Longrightarrow>\n       (x, xa) \\<in> set todo \\<union> set old\n 2. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set old \\<Longrightarrow> x \\<noteq> 0\n 3. distinct (map fst (tod @ old))\n 4. \\<And>x xa.\n       (x, xa) \\<in> set old \\<Longrightarrow>\n       root_info.l_r xa l r \\<noteq> 0\n 5. set tod \\<union> set old \\<subseteq> orig", "thus ?case"], ["proof (prove)\nusing this:\n  (x_, xa_) \\<in> set tod \\<union> set old\n\ngoal (1 subgoal):\n 1. x_ \\<noteq> 0", "using q0"], ["proof (prove)\nusing this:\n  (x_, xa_) \\<in> set tod \\<union> set old\n  (?q1, ?ri1) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  ?q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x_ \\<noteq> 0", "unfolding todo"], ["proof (prove)\nusing this:\n  (x_, xa_) \\<in> set tod \\<union> set old\n  (?q1, ?ri1) \\<in> set ((s, ri) # tod) \\<union> set old \\<Longrightarrow>\n  ?q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x_ \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  x_ \\<noteq> 0\n\ngoal (4 subgoals):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set old \\<Longrightarrow>\n       (x, xa) \\<in> set todo \\<union> set old\n 2. distinct (map fst (tod @ old))\n 3. \\<And>x xa.\n       (x, xa) \\<in> set old \\<Longrightarrow>\n       root_info.l_r xa l r \\<noteq> 0\n 4. set tod \\<union> set old \\<subseteq> orig", "qed (insert dist old orig, auto simp: todo)"], ["proof (state)\nthis:\n  (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n  (q, ri_fin) \\<in> set tod \\<union> set old \\<and>\n  x = real_of_1 (q, l_fin, r_fin)\n\ngoal (2 subgoals):\n 1. root_info.l_r ri l r = 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. root_info.l_r ri l r \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n  (q, ri_fin) \\<in> set tod \\<union> set old \\<and>\n  x = real_of_1 (q, l_fin, r_fin)\n\ngoal (1 subgoal):\n 1. (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "unfolding todo"], ["proof (prove)\nusing this:\n  (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n  (q, ri_fin) \\<in> set tod \\<union> set old \\<and>\n  x = real_of_1 (q, l_fin, r_fin)\n\ngoal (1 subgoal):\n 1. (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set ((s, ri) # tod) \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n  (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n  x = real_of_1 (q, l_fin, r_fin)\n\ngoal (1 subgoal):\n 1. root_info.l_r ri l r \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. root_info.l_r ri l r \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "case False"], ["proof (state)\nthis:\n  root_info.l_r ri l r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root_info.l_r ri l r \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "with res"], ["proof (chain)\npicking this:\n  (if root_info.l_r ri l r = 0\n   then local.select_correct_factor_main a tod old l r n\n   else local.select_correct_factor_main a tod ((s, ri) # old) l r\n         (n + root_info.l_r ri l r)) =\n  ((q, ri_fin), l_fin, r_fin)\n  root_info.l_r ri l r \\<noteq> 0", "have res: \"select_correct_factor_main a tod ((s, ri) # old) l r \n          (n + root_info.l_r ri l r) = ((q, ri_fin), l_fin, r_fin)\""], ["proof (prove)\nusing this:\n  (if root_info.l_r ri l r = 0\n   then local.select_correct_factor_main a tod old l r n\n   else local.select_correct_factor_main a tod ((s, ri) # old) l r\n         (n + root_info.l_r ri l r)) =\n  ((q, ri_fin), l_fin, r_fin)\n  root_info.l_r ri l r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. local.select_correct_factor_main a tod ((s, ri) # old) l r\n     (n + root_info.l_r ri l r) =\n    ((q, ri_fin), l_fin, r_fin)", "by auto"], ["proof (state)\nthis:\n  local.select_correct_factor_main a tod ((s, ri) # old) l r\n   (n + root_info.l_r ri l r) =\n  ((q, ri_fin), l_fin, r_fin)\n\ngoal (1 subgoal):\n 1. root_info.l_r ri l r \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from ex"], ["proof (chain)\npicking this:\n  \\<exists>q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) x = 0", "have ex': \"\\<exists>q. q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and> ipoly q x = 0\""], ["proof (prove)\nusing this:\n  \\<exists>q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n       poly (real_of_int_poly q) x = 0", "unfolding todo"], ["proof (prove)\nusing this:\n  \\<exists>q.\n     q \\<in> fst ` set ((s, ri) # tod) \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n       poly (real_of_int_poly q) x = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>q.\n     q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n     poly (real_of_int_poly q) x = 0\n\ngoal (1 subgoal):\n 1. root_info.l_r ri l r \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from dist"], ["proof (chain)\npicking this:\n  distinct (map fst (todo @ old))", "have dist: \"distinct (map fst (tod @ (s, ri) # old))\""], ["proof (prove)\nusing this:\n  distinct (map fst (todo @ old))\n\ngoal (1 subgoal):\n 1. distinct (map fst (tod @ (s, ri) # old))", "unfolding todo"], ["proof (prove)\nusing this:\n  distinct (map fst (((s, ri) # tod) @ old))\n\ngoal (1 subgoal):\n 1. distinct (map fst (tod @ (s, ri) # old))", "by auto"], ["proof (state)\nthis:\n  distinct (map fst (tod @ (s, ri) # old))\n\ngoal (1 subgoal):\n 1. root_info.l_r ri l r \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "have id: \"set todo \\<union> set old = set tod \\<union> set ((s, ri) # old)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set todo \\<union> set old = set tod \\<union> set ((s, ri) # old)", "unfolding todo"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ((s, ri) # tod) \\<union> set old =\n    set tod \\<union> set ((s, ri) # old)", "by simp"], ["proof (state)\nthis:\n  set todo \\<union> set old = set tod \\<union> set ((s, ri) # old)\n\ngoal (1 subgoal):\n 1. root_info.l_r ri l r \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set tod \\<union> set ((s, ri) # old) \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "proof (rule IH[OF rel at res bnd ri _ ex' dist], goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set ((s, ri) # old) \\<Longrightarrow>\n       (x, xa) \\<in> set todo \\<union> set old\n 2. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set ((s, ri) # old) \\<Longrightarrow>\n       x \\<noteq> 0\n 3. \\<And>x xa.\n       (x, xa) \\<in> set ((s, ri) # old) \\<Longrightarrow>\n       root_info.l_r xa l r \\<noteq> 0\n 4. \\<And>x.\n       \\<exists>q.\n          q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n          poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n       \\<exists>!q.\n          q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n          poly (real_of_int_poly q) x = 0\n 5. n + root_info.l_r ri l r =\n    (\\<Sum>(q, ri)\\<leftarrow>(s, ri) # old. root_info.l_r ri l r)\n 6. (tod, i) = (tod, i)\n 7. set tod \\<union> set ((s, ri) # old) \\<subseteq> orig", "case 4"], ["proof (state)\nthis:\n  \\<exists>q.\n     q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n     poly (real_of_int_poly q) x_ = 0\n\ngoal (7 subgoals):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set ((s, ri) # old) \\<Longrightarrow>\n       (x, xa) \\<in> set todo \\<union> set old\n 2. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set ((s, ri) # old) \\<Longrightarrow>\n       x \\<noteq> 0\n 3. \\<And>x xa.\n       (x, xa) \\<in> set ((s, ri) # old) \\<Longrightarrow>\n       root_info.l_r xa l r \\<noteq> 0\n 4. \\<And>x.\n       \\<exists>q.\n          q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n          poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n       \\<exists>!q.\n          q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n          poly (real_of_int_poly q) x = 0\n 5. n + root_info.l_r ri l r =\n    (\\<Sum>(q, ri)\\<leftarrow>(s, ri) # old. root_info.l_r ri l r)\n 6. (tod, i) = (tod, i)\n 7. set tod \\<union> set ((s, ri) # old) \\<subseteq> orig", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>q.\n     q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n     poly (real_of_int_poly q) x_ = 0\n\ngoal (1 subgoal):\n 1. \\<exists>!q.\n       q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n       poly (real_of_int_poly q) x_ = 0", "using un"], ["proof (prove)\nusing this:\n  \\<exists>q.\n     q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n     poly (real_of_int_poly q) x_ = 0\n  \\<exists>q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) ?x1 = 0 \\<Longrightarrow>\n  \\<exists>!q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) ?x1 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>!q.\n       q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n       poly (real_of_int_poly q) x_ = 0", "unfolding todo"], ["proof (prove)\nusing this:\n  \\<exists>q.\n     q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n     poly (real_of_int_poly q) x_ = 0\n  \\<exists>q.\n     q \\<in> fst ` set ((s, ri) # tod) \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) ?x1 = 0 \\<Longrightarrow>\n  \\<exists>!q.\n     q \\<in> fst ` set ((s, ri) # tod) \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) ?x1 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>!q.\n       q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n       poly (real_of_int_poly q) x_ = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>!q.\n     q \\<in> fst ` set tod \\<union> fst ` set ((s, ri) # old) \\<and>\n     poly (real_of_int_poly q) x_ = 0\n\ngoal (6 subgoals):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set ((s, ri) # old) \\<Longrightarrow>\n       (x, xa) \\<in> set todo \\<union> set old\n 2. \\<And>x xa.\n       (x, xa) \\<in> set tod \\<union> set ((s, ri) # old) \\<Longrightarrow>\n       x \\<noteq> 0\n 3. \\<And>x xa.\n       (x, xa) \\<in> set ((s, ri) # old) \\<Longrightarrow>\n       root_info.l_r xa l r \\<noteq> 0\n 4. n + root_info.l_r ri l r =\n    (\\<Sum>(q, ri)\\<leftarrow>(s, ri) # old. root_info.l_r ri l r)\n 5. (tod, i) = (tod, i)\n 6. set tod \\<union> set ((s, ri) # old) \\<subseteq> orig", "qed (insert old False orig, auto simp: q0 todo n)"], ["proof (state)\nthis:\n  (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n  (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n  x = real_of_1 (q, l_fin, r_fin)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n  (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n  x = real_of_1 (q, l_fin, r_fin)\n\ngoal (1 subgoal):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "case Nil"], ["proof (state)\nthis:\n  todo = []\n\ngoal (1 subgoal):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "note res = res[unfolded Nil list.simps Let_def]"], ["proof (state)\nthis:\n  (if n = 1 then (hd old, l, r)\n   else case bnd_get (bnd_update a) of\n        (l, r) \\<Rightarrow>\n          local.select_correct_factor_main (bnd_update a) old [] l r 0) =\n  ((q, ri_fin), l_fin, r_fin)\n\ngoal (1 subgoal):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from ex[unfolded Nil] lxr"], ["proof (chain)\npicking this:\n  \\<exists>q.\n     q \\<in> fst ` set [] \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) x = 0\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r", "obtain s where \"s \\<in> fst ` set old \\<and> root_cond (s,l,r) x\""], ["proof (prove)\nusing this:\n  \\<exists>q.\n     q \\<in> fst ` set [] \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) x = 0\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> fst ` set old \\<and> root_cond (s, l, r) x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  \\<exists>q.\n     q \\<in> fst ` set [] \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) x = 0\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        s \\<in> fst ` set old \\<and>\n        (case (s, l, r) of\n         (p, l, r) \\<Rightarrow>\n           real_of_rat l \\<le> x \\<and>\n           x \\<le> real_of_rat r \\<and>\n           poly (real_of_int_poly p) x = 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<in> fst ` set old \\<and> root_cond (s, l, r) x\n\ngoal (1 subgoal):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "then"], ["proof (chain)\npicking this:\n  s \\<in> fst ` set old \\<and> root_cond (s, l, r) x", "obtain q1 ri1 old' where old': \"old = (q1,ri1) # old'\""], ["proof (prove)\nusing this:\n  s \\<in> fst ` set old \\<and> root_cond (s, l, r) x\n\ngoal (1 subgoal):\n 1. (\\<And>q1 ri1 old'.\n        old = (q1, ri1) # old' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using id"], ["proof (prove)\nusing this:\n  s \\<in> fst ` set old \\<and> root_cond (s, l, r) x\n  swapidseq 0 id\n\ngoal (1 subgoal):\n 1. (\\<And>q1 ri1 old'.\n        old = (q1, ri1) # old' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases old, auto)"], ["proof (state)\nthis:\n  old = (q1, ri1) # old'\n\ngoal (1 subgoal):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "let ?ri = \"root_info.l_r ri1 l r\""], ["proof (state)\ngoal (1 subgoal):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from old[unfolded old']"], ["proof (chain)\npicking this:\n  (?q1, ?ri1) \\<in> set ((q1, ri1) # old') \\<Longrightarrow>\n  root_info.l_r ?ri1 l r \\<noteq> 0", "have 0: \"?ri \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (?q1, ?ri1) \\<in> set ((q1, ri1) # old') \\<Longrightarrow>\n  root_info.l_r ?ri1 l r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root_info.l_r ri1 l r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  root_info.l_r ri1 l r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from n[unfolded old'] 0"], ["proof (chain)\npicking this:\n  n =\n  (\\<Sum>a\\<leftarrow>(q1, ri1) #\n                      old'. case a of\n                            (q, ri) \\<Rightarrow> root_info.l_r ri l r)\n  root_info.l_r ri1 l r \\<noteq> 0", "have n0: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  n =\n  (\\<Sum>a\\<leftarrow>(q1, ri1) #\n                      old'. case a of\n                            (q, ri) \\<Rightarrow> root_info.l_r ri l r)\n  root_info.l_r ri1 l r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from ri[unfolded old']"], ["proof (chain)\npicking this:\n  (?q1, ?ri1)\n  \\<in> set todo \\<union> set ((q1, ri1) # old') \\<Longrightarrow>\n  root_info_cond ?ri1 ?q1", "have ri': \"root_info_cond ri1 q1\""], ["proof (prove)\nusing this:\n  (?q1, ?ri1)\n  \\<in> set todo \\<union> set ((q1, ri1) # old') \\<Longrightarrow>\n  root_info_cond ?ri1 ?q1\n\ngoal (1 subgoal):\n 1. root_info_cond ri1 q1", "by auto"], ["proof (state)\nthis:\n  root_info_cond ri1 q1\n\ngoal (1 subgoal):\n 1. todo = [] \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "proof (cases \"n = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 1\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "with n0"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  n \\<noteq> 1", "have n1: \"n > 1\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < n", "by auto"], ["proof (state)\nthis:\n  1 < n\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "obtain l' r' where bnd': \"bnd_get (bnd_update a) = (l',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l' r'.\n        bnd_get (bnd_update a) = (l', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  bnd_get (bnd_update a) = (l', r')\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "with res False"], ["proof (chain)\npicking this:\n  (if n = 1 then (hd old, l, r)\n   else case bnd_get (bnd_update a) of\n        (l, r) \\<Rightarrow>\n          local.select_correct_factor_main (bnd_update a) old [] l r 0) =\n  ((q, ri_fin), l_fin, r_fin)\n  n \\<noteq> 1\n  bnd_get (bnd_update a) = (l', r')", "have res: \"select_correct_factor_main (bnd_update a) old [] l' r' 0 =\n          ((q, ri_fin), l_fin, r_fin)\""], ["proof (prove)\nusing this:\n  (if n = 1 then (hd old, l, r)\n   else case bnd_get (bnd_update a) of\n        (l, r) \\<Rightarrow>\n          local.select_correct_factor_main (bnd_update a) old [] l r 0) =\n  ((q, ri_fin), l_fin, r_fin)\n  n \\<noteq> 1\n  bnd_get (bnd_update a) = (l', r')\n\ngoal (1 subgoal):\n 1. local.select_correct_factor_main (bnd_update a) old [] l' r' 0 =\n    ((q, ri_fin), l_fin, r_fin)", "by auto"], ["proof (state)\nthis:\n  local.select_correct_factor_main (bnd_update a) old [] l' r' 0 =\n  ((q, ri_fin), l_fin, r_fin)\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "have at': \"at_step f (Suc i) (bnd_update a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.at_step f (Suc i) (bnd_update a)", "unfolding at_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. bnd_get ((bnd_update ^^ i) (bnd_update a)) = f (Suc i + i)", "proof (intro allI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. bnd_get ((bnd_update ^^ i) (bnd_update a)) = f (Suc i + i)", "case (1 n)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>i. bnd_get ((bnd_update ^^ i) (bnd_update a)) = f (Suc i + i)", "have id: \"(bnd_update ^^ Suc n) a = (bnd_update ^^ n) (bnd_update a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bnd_update ^^ Suc n) a = (bnd_update ^^ n) (bnd_update a)", "by (induct n, auto)"], ["proof (state)\nthis:\n  (bnd_update ^^ Suc n) a = (bnd_update ^^ n) (bnd_update a)\n\ngoal (1 subgoal):\n 1. \\<And>i. bnd_get ((bnd_update ^^ i) (bnd_update a)) = f (Suc i + i)", "from at[unfolded at_step_def, rule_format, of \"Suc n\"]"], ["proof (chain)\npicking this:\n  bnd_get ((bnd_update ^^ Suc n) a) = f (i + Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  bnd_get ((bnd_update ^^ Suc n) a) = f (i + Suc n)\n\ngoal (1 subgoal):\n 1. bnd_get ((bnd_update ^^ n) (bnd_update a)) = f (Suc i + n)", "unfolding id"], ["proof (prove)\nusing this:\n  bnd_get ((bnd_update ^^ n) (bnd_update a)) = f (i + Suc n)\n\ngoal (1 subgoal):\n 1. bnd_get ((bnd_update ^^ n) (bnd_update a)) = f (Suc i + n)", "by simp"], ["proof (state)\nthis:\n  bnd_get ((bnd_update ^^ n) (bnd_update a)) = f (Suc i + n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.at_step f (Suc i) (bnd_update a)\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from 0[unfolded root_info_condD(1)[OF ri' lr]]"], ["proof (chain)\npicking this:\n  card (Collect (root_cond (q1, l, r))) \\<noteq> 0", "obtain y1 where y1: \"root_cond (q1,l,r) y1\""], ["proof (prove)\nusing this:\n  card (Collect (root_cond (q1, l, r))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>y1.\n        root_cond (q1, l, r) y1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"Collect (root_cond (q1, l, r)) = {}\", auto)"], ["proof (state)\nthis:\n  root_cond (q1, l, r) y1\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from n1[unfolded n old']"], ["proof (chain)\npicking this:\n  1 < (\\<Sum>(q, ri)\\<leftarrow>(q1, ri1) # old'. root_info.l_r ri l r)", "have \"?ri > 1 \\<or> sum_list (map (\\<lambda> (q,ri). root_info.l_r ri l r) old') \\<noteq> 0\""], ["proof (prove)\nusing this:\n  1 < (\\<Sum>(q, ri)\\<leftarrow>(q1, ri1) # old'. root_info.l_r ri l r)\n\ngoal (1 subgoal):\n 1. 1 < root_info.l_r ri1 l r \\<or>\n    (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq> 0", "by (cases \"sum_list (map (\\<lambda> (q,ri). root_info.l_r ri l r) old')\", auto)"], ["proof (state)\nthis:\n  1 < root_info.l_r ri1 l r \\<or>\n  (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "hence \"\\<exists> q2 ri2 y2. (q2,ri2) \\<in> set old \\<and> root_cond (q2,l,r) y2 \\<and> y1 \\<noteq> y2\""], ["proof (prove)\nusing this:\n  1 < root_info.l_r ri1 l r \\<or>\n  (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < root_info.l_r ri1 l r \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2\n 2. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "assume \"?ri > 1\""], ["proof (state)\nthis:\n  1 < root_info.l_r ri1 l r\n\ngoal (2 subgoals):\n 1. 1 < root_info.l_r ri1 l r \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2\n 2. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "with root_info_condD(1)[OF ri' lr]"], ["proof (chain)\npicking this:\n  root_info.l_r ri1 l r = card {x. root_cond (q1, l, r) x}\n  1 < root_info.l_r ri1 l r", "have \"card {x. root_cond (q1, l, r) x} > 1\""], ["proof (prove)\nusing this:\n  root_info.l_r ri1 l r = card {x. root_cond (q1, l, r) x}\n  1 < root_info.l_r ri1 l r\n\ngoal (1 subgoal):\n 1. 1 < card {x. root_cond (q1, l, r) x}", "by simp"], ["proof (state)\nthis:\n  1 < card {x. root_cond (q1, l, r) x}\n\ngoal (2 subgoals):\n 1. 1 < root_info.l_r ri1 l r \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2\n 2. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "from card_gt_1D[OF this] y1"], ["proof (chain)\npicking this:\n  \\<exists>x y.\n     x \\<in> {x. root_cond (q1, l, r) x} \\<and>\n     y \\<in> {x. root_cond (q1, l, r) x} \\<and> x \\<noteq> y\n  root_cond (q1, l, r) y1", "obtain y2 where \"root_cond (q1,l,r) y2\" and \"y1 \\<noteq> y2\""], ["proof (prove)\nusing this:\n  \\<exists>x y.\n     x \\<in> {x. root_cond (q1, l, r) x} \\<and>\n     y \\<in> {x. root_cond (q1, l, r) x} \\<and> x \\<noteq> y\n  root_cond (q1, l, r) y1\n\ngoal (1 subgoal):\n 1. (\\<And>y2.\n        \\<lbrakk>root_cond (q1, l, r) y2; y1 \\<noteq> y2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  root_cond (q1, l, r) y2\n  y1 \\<noteq> y2\n\ngoal (2 subgoals):\n 1. 1 < root_info.l_r ri1 l r \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2\n 2. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "thus ?thesis"], ["proof (prove)\nusing this:\n  root_cond (q1, l, r) y2\n  y1 \\<noteq> y2\n\ngoal (1 subgoal):\n 1. \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "unfolding old'"], ["proof (prove)\nusing this:\n  root_cond (q1, l, r) y2\n  y1 \\<noteq> y2\n\ngoal (1 subgoal):\n 1. \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set ((q1, ri1) # old') \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "by auto"], ["proof (state)\nthis:\n  \\<exists>q2 ri2 y2.\n     (q2, ri2) \\<in> set old \\<and>\n     root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2\n\ngoal (1 subgoal):\n 1. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "assume \"sum_list (map (\\<lambda> (q,ri). root_info.l_r ri l r) old') \\<noteq> 0\""], ["proof (state)\nthis:\n  (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq> 0", "obtain q2 ri2 where mem: \"(q2,ri2) \\<in> set old'\" and ri2: \"root_info.l_r ri2 l r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>q2 ri2.\n        \\<lbrakk>(q2, ri2) \\<in> set old';\n         root_info.l_r ri2 l r \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (q2, ri2) \\<in> set old'\n  root_info.l_r ri2 l r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "with q0 ri"], ["proof (chain)\npicking this:\n  (?q1, ?ri1) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  ?q1 \\<noteq> 0\n  (?q1, ?ri1) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  root_info_cond ?ri1 ?q1\n  (q2, ri2) \\<in> set old'\n  root_info.l_r ri2 l r \\<noteq> 0", "have \"root_info_cond ri2 q2\""], ["proof (prove)\nusing this:\n  (?q1, ?ri1) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  ?q1 \\<noteq> 0\n  (?q1, ?ri1) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  root_info_cond ?ri1 ?q1\n  (q2, ri2) \\<in> set old'\n  root_info.l_r ri2 l r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root_info_cond ri2 q2", "unfolding old'"], ["proof (prove)\nusing this:\n  (?q1, ?ri1)\n  \\<in> set todo \\<union> set ((q1, ri1) # old') \\<Longrightarrow>\n  ?q1 \\<noteq> 0\n  (?q1, ?ri1)\n  \\<in> set todo \\<union> set ((q1, ri1) # old') \\<Longrightarrow>\n  root_info_cond ?ri1 ?q1\n  (q2, ri2) \\<in> set old'\n  root_info.l_r ri2 l r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root_info_cond ri2 q2", "by auto"], ["proof (state)\nthis:\n  root_info_cond ri2 q2\n\ngoal (1 subgoal):\n 1. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "from ri2[unfolded root_info_condD(1)[OF this lr]]"], ["proof (chain)\npicking this:\n  card (Collect (root_cond (q2, l, r))) \\<noteq> 0", "obtain y2 where y2: \"root_cond (q2,l,r) y2\""], ["proof (prove)\nusing this:\n  card (Collect (root_cond (q2, l, r))) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>y2.\n        root_cond (q2, l, r) y2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"Collect (root_cond (q2, l, r)) = {}\", auto)"], ["proof (state)\nthis:\n  root_cond (q2, l, r) y2\n\ngoal (1 subgoal):\n 1. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "from dist[unfolded old'] split_list[OF mem]"], ["proof (chain)\npicking this:\n  distinct (map fst (todo @ (q1, ri1) # old'))\n  \\<exists>ys zs. old' = ys @ (q2, ri2) # zs", "have diff: \"q1 \\<noteq> q2\""], ["proof (prove)\nusing this:\n  distinct (map fst (todo @ (q1, ri1) # old'))\n  \\<exists>ys zs. old' = ys @ (q2, ri2) # zs\n\ngoal (1 subgoal):\n 1. q1 \\<noteq> q2", "by auto"], ["proof (state)\nthis:\n  q1 \\<noteq> q2\n\ngoal (1 subgoal):\n 1. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "from y1"], ["proof (chain)\npicking this:\n  root_cond (q1, l, r) y1", "have q1: \"q1 \\<in> fst ` set todo \\<union> fst ` set old \\<and> ipoly q1 y1 = 0\""], ["proof (prove)\nusing this:\n  root_cond (q1, l, r) y1\n\ngoal (1 subgoal):\n 1. q1 \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n    poly (real_of_int_poly q1) y1 = 0", "unfolding old' root_cond_def"], ["proof (prove)\nusing this:\n  case (q1, l, r) of\n  (p, l, r) \\<Rightarrow>\n    real_of_rat l \\<le> y1 \\<and>\n    y1 \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y1 = 0\n\ngoal (1 subgoal):\n 1. q1 \\<in> fst ` set todo \\<union> fst ` set ((q1, ri1) # old') \\<and>\n    poly (real_of_int_poly q1) y1 = 0", "by auto"], ["proof (state)\nthis:\n  q1 \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n  poly (real_of_int_poly q1) y1 = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "from y2"], ["proof (chain)\npicking this:\n  root_cond (q2, l, r) y2", "have q2: \"q2 \\<in> fst ` set todo \\<union> fst ` set old \\<and> ipoly q2 y2 = 0\""], ["proof (prove)\nusing this:\n  root_cond (q2, l, r) y2\n\ngoal (1 subgoal):\n 1. q2 \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n    poly (real_of_int_poly q2) y2 = 0", "unfolding old' root_cond_def"], ["proof (prove)\nusing this:\n  case (q2, l, r) of\n  (p, l, r) \\<Rightarrow>\n    real_of_rat l \\<le> y2 \\<and>\n    y2 \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y2 = 0\n\ngoal (1 subgoal):\n 1. q2 \\<in> fst ` set todo \\<union> fst ` set ((q1, ri1) # old') \\<and>\n    poly (real_of_int_poly q2) y2 = 0", "using mem"], ["proof (prove)\nusing this:\n  case (q2, l, r) of\n  (p, l, r) \\<Rightarrow>\n    real_of_rat l \\<le> y2 \\<and>\n    y2 \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y2 = 0\n  (q2, ri2) \\<in> set old'\n\ngoal (1 subgoal):\n 1. q2 \\<in> fst ` set todo \\<union> fst ` set ((q1, ri1) # old') \\<and>\n    poly (real_of_int_poly q2) y2 = 0", "by force"], ["proof (state)\nthis:\n  q2 \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n  poly (real_of_int_poly q2) y2 = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "have \"y1 \\<noteq> y2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y1 \\<noteq> y2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. y1 = y2 \\<Longrightarrow> False", "assume id: \"y1 = y2\""], ["proof (state)\nthis:\n  y1 = y2\n\ngoal (1 subgoal):\n 1. y1 = y2 \\<Longrightarrow> False", "from q1"], ["proof (chain)\npicking this:\n  q1 \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n  poly (real_of_int_poly q1) y1 = 0", "have \"\\<exists> q1. q1 \\<in> fst ` set todo \\<union> fst ` set old \\<and> ipoly q1 y1 = 0\""], ["proof (prove)\nusing this:\n  q1 \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n  poly (real_of_int_poly q1) y1 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>q1.\n       q1 \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n       poly (real_of_int_poly q1) y1 = 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>q1.\n     q1 \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q1) y1 = 0\n\ngoal (1 subgoal):\n 1. y1 = y2 \\<Longrightarrow> False", "from un[OF this] q1 q2[folded id]"], ["proof (chain)\npicking this:\n  \\<exists>!q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) y1 = 0\n  q1 \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n  poly (real_of_int_poly q1) y1 = 0\n  q2 \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n  poly (real_of_int_poly q2) y1 = 0", "have \"q1 = q2\""], ["proof (prove)\nusing this:\n  \\<exists>!q.\n     q \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n     poly (real_of_int_poly q) y1 = 0\n  q1 \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n  poly (real_of_int_poly q1) y1 = 0\n  q2 \\<in> fst ` set todo \\<union> fst ` set old \\<and>\n  poly (real_of_int_poly q2) y1 = 0\n\ngoal (1 subgoal):\n 1. q1 = q2", "by auto"], ["proof (state)\nthis:\n  q1 = q2\n\ngoal (1 subgoal):\n 1. y1 = y2 \\<Longrightarrow> False", "with diff"], ["proof (chain)\npicking this:\n  q1 \\<noteq> q2\n  q1 = q2", "show False"], ["proof (prove)\nusing this:\n  q1 \\<noteq> q2\n  q1 = q2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y1 \\<noteq> y2\n\ngoal (1 subgoal):\n 1. (\\<Sum>(q, ri)\\<leftarrow>old'. root_info.l_r ri l r) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "with mem y2"], ["proof (chain)\npicking this:\n  (q2, ri2) \\<in> set old'\n  root_cond (q2, l, r) y2\n  y1 \\<noteq> y2", "show ?thesis"], ["proof (prove)\nusing this:\n  (q2, ri2) \\<in> set old'\n  root_cond (q2, l, r) y2\n  y1 \\<noteq> y2\n\ngoal (1 subgoal):\n 1. \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set old \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "unfolding old'"], ["proof (prove)\nusing this:\n  (q2, ri2) \\<in> set old'\n  root_cond (q2, l, r) y2\n  y1 \\<noteq> y2\n\ngoal (1 subgoal):\n 1. \\<exists>q2 ri2 y2.\n       (q2, ri2) \\<in> set ((q1, ri1) # old') \\<and>\n       root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "by auto"], ["proof (state)\nthis:\n  \\<exists>q2 ri2 y2.\n     (q2, ri2) \\<in> set old \\<and>\n     root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q2 ri2 y2.\n     (q2, ri2) \\<in> set old \\<and>\n     root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "then"], ["proof (chain)\npicking this:\n  \\<exists>q2 ri2 y2.\n     (q2, ri2) \\<in> set old \\<and>\n     root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2", "obtain q2 ri2 y2 where \n          mem2: \"(q2,ri2) \\<in> set old\" and y2: \"root_cond (q2,l,r) y2\" and diff: \"y1 \\<noteq> y2\""], ["proof (prove)\nusing this:\n  \\<exists>q2 ri2 y2.\n     (q2, ri2) \\<in> set old \\<and>\n     root_cond (q2, l, r) y2 \\<and> y1 \\<noteq> y2\n\ngoal (1 subgoal):\n 1. (\\<And>q2 ri2 y2.\n        \\<lbrakk>(q2, ri2) \\<in> set old; root_cond (q2, l, r) y2;\n         y1 \\<noteq> y2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (q2, ri2) \\<in> set old\n  root_cond (q2, l, r) y2\n  y1 \\<noteq> y2\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from mem2 orig"], ["proof (chain)\npicking this:\n  (q2, ri2) \\<in> set old\n  set todo \\<union> set old \\<subseteq> orig", "have \"(q1,ri1) \\<in> orig\" \"(q2,ri2) \\<in> orig\""], ["proof (prove)\nusing this:\n  (q2, ri2) \\<in> set old\n  set todo \\<union> set old \\<subseteq> orig\n\ngoal (1 subgoal):\n 1. (q1, ri1) \\<in> orig &&& (q2, ri2) \\<in> orig", "unfolding old'"], ["proof (prove)\nusing this:\n  (q2, ri2) \\<in> set ((q1, ri1) # old')\n  set todo \\<union> set ((q1, ri1) # old') \\<subseteq> orig\n\ngoal (1 subgoal):\n 1. (q1, ri1) \\<in> orig &&& (q2, ri2) \\<in> orig", "by auto"], ["proof (state)\nthis:\n  (q1, ri1) \\<in> orig\n  (q2, ri2) \\<in> orig\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "with y1 y2 diff"], ["proof (chain)\npicking this:\n  root_cond (q1, l, r) y1\n  root_cond (q2, l, r) y2\n  y1 \\<noteq> y2\n  (q1, ri1) \\<in> orig\n  (q2, ri2) \\<in> orig", "have \"abs (y1 - y2) \\<in> diffs\""], ["proof (prove)\nusing this:\n  root_cond (q1, l, r) y1\n  root_cond (q2, l, r) y2\n  y1 \\<noteq> y2\n  (q1, ri1) \\<in> orig\n  (q2, ri2) \\<in> orig\n\ngoal (1 subgoal):\n 1. \\<bar>y1 - y2\\<bar> \\<in> diffs", "unfolding diffs_def rts_def root_cond_def"], ["proof (prove)\nusing this:\n  case (q1, l, r) of\n  (p, l, r) \\<Rightarrow>\n    real_of_rat l \\<le> y1 \\<and>\n    y1 \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y1 = 0\n  case (q2, l, r) of\n  (p, l, r) \\<Rightarrow>\n    real_of_rat l \\<le> y2 \\<and>\n    y2 \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y2 = 0\n  y1 \\<noteq> y2\n  (q1, ri1) \\<in> orig\n  (q2, ri2) \\<in> orig\n\ngoal (1 subgoal):\n 1. \\<bar>y1 - y2\\<bar>\n    \\<in> insert 1\n           {\\<bar>x - y\\<bar> |x y.\n            x \\<in> {x. \\<exists>q ri.\n                           (q, ri) \\<in> orig \\<and>\n                           poly (real_of_int_poly q) x = 0} \\<and>\n            y \\<in> {x. \\<exists>q ri.\n                           (q, ri) \\<in> orig \\<and>\n                           poly (real_of_int_poly q) x = 0} \\<and>\n            x \\<noteq> y}", "by auto"], ["proof (state)\nthis:\n  \\<bar>y1 - y2\\<bar> \\<in> diffs\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from Min_le[OF diffs(1) this]"], ["proof (chain)\npicking this:\n  Min diffs \\<le> \\<bar>y1 - y2\\<bar>", "have \"abs (y1 - y2) \\<ge> 2 * eps\""], ["proof (prove)\nusing this:\n  Min diffs \\<le> \\<bar>y1 - y2\\<bar>\n\ngoal (1 subgoal):\n 1. 2 * eps \\<le> \\<bar>y1 - y2\\<bar>", "unfolding eps_def"], ["proof (prove)\nusing this:\n  Min diffs \\<le> \\<bar>y1 - y2\\<bar>\n\ngoal (1 subgoal):\n 1. 2 * (Min diffs / 2) \\<le> \\<bar>y1 - y2\\<bar>", "by auto"], ["proof (state)\nthis:\n  2 * eps \\<le> \\<bar>y1 - y2\\<bar>\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "with eps"], ["proof (chain)\npicking this:\n  0 < eps\n  2 * eps \\<le> \\<bar>y1 - y2\\<bar>", "have eps: \"abs (y1 - y2) > eps\""], ["proof (prove)\nusing this:\n  0 < eps\n  2 * eps \\<le> \\<bar>y1 - y2\\<bar>\n\ngoal (1 subgoal):\n 1. eps < \\<bar>y1 - y2\\<bar>", "by auto"], ["proof (state)\nthis:\n  eps < \\<bar>y1 - y2\\<bar>\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from y1 y2"], ["proof (chain)\npicking this:\n  root_cond (q1, l, r) y1\n  root_cond (q2, l, r) y2", "have l: \"of_rat l \\<le> min y1 y2\""], ["proof (prove)\nusing this:\n  root_cond (q1, l, r) y1\n  root_cond (q2, l, r) y2\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> min y1 y2", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  case (q1, l, r) of\n  (p, l, r) \\<Rightarrow>\n    real_of_rat l \\<le> y1 \\<and>\n    y1 \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y1 = 0\n  case (q2, l, r) of\n  (p, l, r) \\<Rightarrow>\n    real_of_rat l \\<le> y2 \\<and>\n    y2 \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y2 = 0\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> min y1 y2", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> min y1 y2\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from y1 y2"], ["proof (chain)\npicking this:\n  root_cond (q1, l, r) y1\n  root_cond (q2, l, r) y2", "have r: \"of_rat r \\<ge> max y1 y2\""], ["proof (prove)\nusing this:\n  root_cond (q1, l, r) y1\n  root_cond (q2, l, r) y2\n\ngoal (1 subgoal):\n 1. max y1 y2 \\<le> real_of_rat r", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  case (q1, l, r) of\n  (p, l, r) \\<Rightarrow>\n    real_of_rat l \\<le> y1 \\<and>\n    y1 \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y1 = 0\n  case (q2, l, r) of\n  (p, l, r) \\<Rightarrow>\n    real_of_rat l \\<le> y2 \\<and>\n    y2 \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) y2 = 0\n\ngoal (1 subgoal):\n 1. max y1 y2 \\<le> real_of_rat r", "by auto"], ["proof (state)\nthis:\n  max y1 y2 \\<le> real_of_rat r\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from l r eps"], ["proof (chain)\npicking this:\n  real_of_rat l \\<le> min y1 y2\n  max y1 y2 \\<le> real_of_rat r\n  eps < \\<bar>y1 - y2\\<bar>", "have eps: \"of_rat r - of_rat l > eps\""], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> min y1 y2\n  max y1 y2 \\<le> real_of_rat r\n  eps < \\<bar>y1 - y2\\<bar>\n\ngoal (1 subgoal):\n 1. eps < real_of_rat r - real_of_rat l", "by auto"], ["proof (state)\nthis:\n  eps < real_of_rat r - real_of_rat l\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "have \"i < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < N", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < N \\<Longrightarrow> False", "assume \"\\<not> i < N\""], ["proof (state)\nthis:\n  \\<not> i < N\n\ngoal (1 subgoal):\n 1. \\<not> i < N \\<Longrightarrow> False", "hence \"\\<exists> k. i = N + k\""], ["proof (prove)\nusing this:\n  \\<not> i < N\n\ngoal (1 subgoal):\n 1. \\<exists>k. i = N + k", "by presburger"], ["proof (state)\nthis:\n  \\<exists>k. i = N + k\n\ngoal (1 subgoal):\n 1. \\<not> i < N \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>k. i = N + k", "obtain k where i: \"i = N + k\""], ["proof (prove)\nusing this:\n  \\<exists>k. i = N + k\n\ngoal (1 subgoal):\n 1. (\\<And>k. i = N + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  i = N + k\n\ngoal (1 subgoal):\n 1. \\<not> i < N \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  i = N + k\n\ngoal (1 subgoal):\n 1. \\<not> i < N \\<Longrightarrow> False", "fix k l r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < N \\<Longrightarrow> False", "assume \"f (N + k) = (l,r)\""], ["proof (state)\nthis:\n  f (N + k) = (l, r)\n\ngoal (1 subgoal):\n 1. \\<not> i < N \\<Longrightarrow> False", "hence \"of_rat r - of_rat l \\<le> eps\""], ["proof (prove)\nusing this:\n  f (N + k) = (l, r)\n\ngoal (1 subgoal):\n 1. real_of_rat r - real_of_rat l \\<le> eps", "proof (induct k arbitrary: l r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l r.\n       f (N + 0) = (l, r) \\<Longrightarrow>\n       real_of_rat r - real_of_rat l \\<le> eps\n 2. \\<And>k l r.\n       \\<lbrakk>\\<And>l r.\n                   f (N + k) = (l, r) \\<Longrightarrow>\n                   real_of_rat r - real_of_rat l \\<le> eps;\n        f (N + Suc k) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat r - real_of_rat l \\<le> eps", "case 0"], ["proof (state)\nthis:\n  f (N + 0) = (l, r)\n\ngoal (2 subgoals):\n 1. \\<And>l r.\n       f (N + 0) = (l, r) \\<Longrightarrow>\n       real_of_rat r - real_of_rat l \\<le> eps\n 2. \\<And>k l r.\n       \\<lbrakk>\\<And>l r.\n                   f (N + k) = (l, r) \\<Longrightarrow>\n                   real_of_rat r - real_of_rat l \\<le> eps;\n        f (N + Suc k) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat r - real_of_rat l \\<le> eps", "with N"], ["proof (chain)\npicking this:\n  f N = (L, R)\n  real_of_rat R - real_of_rat L \\<le> eps\n  f (N + 0) = (l, r)", "show ?case"], ["proof (prove)\nusing this:\n  f N = (L, R)\n  real_of_rat R - real_of_rat L \\<le> eps\n  f (N + 0) = (l, r)\n\ngoal (1 subgoal):\n 1. real_of_rat r - real_of_rat l \\<le> eps", "by auto"], ["proof (state)\nthis:\n  real_of_rat r - real_of_rat l \\<le> eps\n\ngoal (1 subgoal):\n 1. \\<And>k l r.\n       \\<lbrakk>\\<And>l r.\n                   f (N + k) = (l, r) \\<Longrightarrow>\n                   real_of_rat r - real_of_rat l \\<le> eps;\n        f (N + Suc k) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat r - real_of_rat l \\<le> eps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k l r.\n       \\<lbrakk>\\<And>l r.\n                   f (N + k) = (l, r) \\<Longrightarrow>\n                   real_of_rat r - real_of_rat l \\<le> eps;\n        f (N + Suc k) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat r - real_of_rat l \\<le> eps", "case (Suc k l r)"], ["proof (state)\nthis:\n  f (N + k) = (?l1, ?r1) \\<Longrightarrow>\n  real_of_rat ?r1 - real_of_rat ?l1 \\<le> eps\n  f (N + Suc k) = (l, r)\n\ngoal (1 subgoal):\n 1. \\<And>k l r.\n       \\<lbrakk>\\<And>l r.\n                   f (N + k) = (l, r) \\<Longrightarrow>\n                   real_of_rat r - real_of_rat l \\<le> eps;\n        f (N + Suc k) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat r - real_of_rat l \\<le> eps", "obtain l' r' where f: \"f (N + k) = (l',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l' r'.\n        f (N + k) = (l', r') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  f (N + k) = (l', r')\n\ngoal (1 subgoal):\n 1. \\<And>k l r.\n       \\<lbrakk>\\<And>l r.\n                   f (N + k) = (l, r) \\<Longrightarrow>\n                   real_of_rat r - real_of_rat l \\<le> eps;\n        f (N + Suc k) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat r - real_of_rat l \\<le> eps", "from Suc(1)[OF this]"], ["proof (chain)\npicking this:\n  real_of_rat r' - real_of_rat l' \\<le> eps", "have IH: \"?r r' - ?r l' \\<le> eps\""], ["proof (prove)\nusing this:\n  real_of_rat r' - real_of_rat l' \\<le> eps\n\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' \\<le> eps", "by auto"], ["proof (state)\nthis:\n  real_of_rat r' - real_of_rat l' \\<le> eps\n\ngoal (1 subgoal):\n 1. \\<And>k l r.\n       \\<lbrakk>\\<And>l r.\n                   f (N + k) = (l, r) \\<Longrightarrow>\n                   real_of_rat r - real_of_rat l \\<le> eps;\n        f (N + Suc k) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat r - real_of_rat l \\<le> eps", "from f Suc(2) conv[THEN conjunct1, rule_format, of \"N + k\"]"], ["proof (chain)\npicking this:\n  f (N + k) = (l', r')\n  f (N + Suc k) = (l, r)\n  in_interval (f (N + k)) x \\<and>\n  sub_interval (f (Suc (N + k))) (f (N + k))", "have \"?r l \\<ge> ?r l'\" \"?r r \\<le> ?r r'\""], ["proof (prove)\nusing this:\n  f (N + k) = (l', r')\n  f (N + Suc k) = (l, r)\n  in_interval (f (N + k)) x \\<and>\n  sub_interval (f (Suc (N + k))) (f (N + k))\n\ngoal (1 subgoal):\n 1. real_of_rat l' \\<le> real_of_rat l &&&\n    real_of_rat r \\<le> real_of_rat r'", "by (auto simp: of_rat_less_eq)"], ["proof (state)\nthis:\n  real_of_rat l' \\<le> real_of_rat l\n  real_of_rat r \\<le> real_of_rat r'\n\ngoal (1 subgoal):\n 1. \\<And>k l r.\n       \\<lbrakk>\\<And>l r.\n                   f (N + k) = (l, r) \\<Longrightarrow>\n                   real_of_rat r - real_of_rat l \\<le> eps;\n        f (N + Suc k) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat r - real_of_rat l \\<le> eps", "thus ?case"], ["proof (prove)\nusing this:\n  real_of_rat l' \\<le> real_of_rat l\n  real_of_rat r \\<le> real_of_rat r'\n\ngoal (1 subgoal):\n 1. real_of_rat r - real_of_rat l \\<le> eps", "using IH"], ["proof (prove)\nusing this:\n  real_of_rat l' \\<le> real_of_rat l\n  real_of_rat r \\<le> real_of_rat r'\n  real_of_rat r' - real_of_rat l' \\<le> eps\n\ngoal (1 subgoal):\n 1. real_of_rat r - real_of_rat l \\<le> eps", "by auto"], ["proof (state)\nthis:\n  real_of_rat r - real_of_rat l \\<le> eps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_rat r - real_of_rat l \\<le> eps\n\ngoal (1 subgoal):\n 1. \\<not> i < N \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  f (N + ?ka3) = (?lb3, ?rb3) \\<Longrightarrow>\n  real_of_rat ?rb3 - real_of_rat ?lb3 \\<le> eps\n\ngoal (1 subgoal):\n 1. \\<not> i < N \\<Longrightarrow> False", "note * = this"], ["proof (state)\nthis:\n  f (N + ?ka3) = (?lb3, ?rb3) \\<Longrightarrow>\n  real_of_rat ?rb3 - real_of_rat ?lb3 \\<le> eps\n\ngoal (1 subgoal):\n 1. \\<not> i < N \\<Longrightarrow> False", "from at[unfolded at_step_def i, rule_format, of 0] bnd"], ["proof (chain)\npicking this:\n  bnd_get ((bnd_update ^^ 0) a) = f (N + k + 0)\n  bnd_get a = (l, r)", "have \"f (N + k) = (l,r)\""], ["proof (prove)\nusing this:\n  bnd_get ((bnd_update ^^ 0) a) = f (N + k + 0)\n  bnd_get a = (l, r)\n\ngoal (1 subgoal):\n 1. f (N + k) = (l, r)", "by auto"], ["proof (state)\nthis:\n  f (N + k) = (l, r)\n\ngoal (1 subgoal):\n 1. \\<not> i < N \\<Longrightarrow> False", "from *[OF this] eps"], ["proof (chain)\npicking this:\n  real_of_rat r - real_of_rat l \\<le> eps\n  eps < real_of_rat r - real_of_rat l", "show False"], ["proof (prove)\nusing this:\n  real_of_rat r - real_of_rat l \\<le> eps\n  eps < real_of_rat r - real_of_rat l\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < N\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "hence rel: \"((old, Suc i), pair) \\<in> rel\""], ["proof (prove)\nusing this:\n  i < N\n\ngoal (1 subgoal):\n 1. ((old, Suc i), pair) \\<in> rel", "unfolding pair rel_def"], ["proof (prove)\nusing this:\n  i < N\n\ngoal (1 subgoal):\n 1. ((old, Suc i), todo, i)\n    \\<in> measures [\\<lambda>(t, y). N - y, \\<lambda>(t, i). length t]", "by auto"], ["proof (state)\nthis:\n  ((old, Suc i), pair) \\<in> rel\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from dist"], ["proof (chain)\npicking this:\n  distinct (map fst (todo @ old))", "have dist: \"distinct (map fst (old @ []))\""], ["proof (prove)\nusing this:\n  distinct (map fst (todo @ old))\n\ngoal (1 subgoal):\n 1. distinct (map fst (old @ []))", "unfolding Nil"], ["proof (prove)\nusing this:\n  distinct (map fst ([] @ old))\n\ngoal (1 subgoal):\n 1. distinct (map fst (old @ []))", "by auto"], ["proof (state)\nthis:\n  distinct (map fst (old @ []))\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "have id: \"set todo \\<union> set old = set old \\<union> set []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set todo \\<union> set old = set old \\<union> set []", "unfolding Nil"], ["proof (prove)\ngoal (1 subgoal):\n 1. set [] \\<union> set old = set old \\<union> set []", "by auto"], ["proof (state)\nthis:\n  set todo \\<union> set old = set old \\<union> set []\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set old \\<union> set [] \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "proof (rule IH[OF rel at' res bnd' ri _ _ dist _ _ _ refl], goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set old \\<union> set [] \\<Longrightarrow>\n       (x, xa) \\<in> set todo \\<union> set old\n 2. \\<And>x xa.\n       (x, xa) \\<in> set old \\<union> set [] \\<Longrightarrow> x \\<noteq> 0\n 3. \\<exists>q.\n       q \\<in> fst ` set old \\<union> fst ` set [] \\<and>\n       poly (real_of_int_poly q) x = 0\n 4. \\<And>x xa.\n       (x, xa) \\<in> set [] \\<Longrightarrow>\n       root_info.l_r xa l' r' \\<noteq> 0\n 5. \\<And>x.\n       \\<exists>q.\n          q \\<in> fst ` set old \\<union> fst ` set [] \\<and>\n          poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n       \\<exists>!q.\n          q \\<in> fst ` set old \\<union> fst ` set [] \\<and>\n          poly (real_of_int_poly q) x = 0\n 6. 0 = (\\<Sum>(q, ri)\\<leftarrow>[]. root_info.l_r ri l' r')\n 7. set old \\<union> set [] \\<subseteq> orig", "case 2"], ["proof (state)\nthis:\n  (x_, xa_) \\<in> set old \\<union> set []\n\ngoal (7 subgoals):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set old \\<union> set [] \\<Longrightarrow>\n       (x, xa) \\<in> set todo \\<union> set old\n 2. \\<And>x xa.\n       (x, xa) \\<in> set old \\<union> set [] \\<Longrightarrow> x \\<noteq> 0\n 3. \\<exists>q.\n       q \\<in> fst ` set old \\<union> fst ` set [] \\<and>\n       poly (real_of_int_poly q) x = 0\n 4. \\<And>x xa.\n       (x, xa) \\<in> set [] \\<Longrightarrow>\n       root_info.l_r xa l' r' \\<noteq> 0\n 5. \\<And>x.\n       \\<exists>q.\n          q \\<in> fst ` set old \\<union> fst ` set [] \\<and>\n          poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n       \\<exists>!q.\n          q \\<in> fst ` set old \\<union> fst ` set [] \\<and>\n          poly (real_of_int_poly q) x = 0\n 6. 0 = (\\<Sum>(q, ri)\\<leftarrow>[]. root_info.l_r ri l' r')\n 7. set old \\<union> set [] \\<subseteq> orig", "thus ?case"], ["proof (prove)\nusing this:\n  (x_, xa_) \\<in> set old \\<union> set []\n\ngoal (1 subgoal):\n 1. x_ \\<noteq> 0", "using q0"], ["proof (prove)\nusing this:\n  (x_, xa_) \\<in> set old \\<union> set []\n  (?q1, ?ri1) \\<in> set todo \\<union> set old \\<Longrightarrow>\n  ?q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x_ \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  x_ \\<noteq> 0\n\ngoal (6 subgoals):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set old \\<union> set [] \\<Longrightarrow>\n       (x, xa) \\<in> set todo \\<union> set old\n 2. \\<exists>q.\n       q \\<in> fst ` set old \\<union> fst ` set [] \\<and>\n       poly (real_of_int_poly q) x = 0\n 3. \\<And>x xa.\n       (x, xa) \\<in> set [] \\<Longrightarrow>\n       root_info.l_r xa l' r' \\<noteq> 0\n 4. \\<And>x.\n       \\<exists>q.\n          q \\<in> fst ` set old \\<union> fst ` set [] \\<and>\n          poly (real_of_int_poly q) x = 0 \\<Longrightarrow>\n       \\<exists>!q.\n          q \\<in> fst ` set old \\<union> fst ` set [] \\<and>\n          poly (real_of_int_poly q) x = 0\n 5. 0 = (\\<Sum>(q, ri)\\<leftarrow>[]. root_info.l_r ri l' r')\n 6. set old \\<union> set [] \\<subseteq> orig", "qed (insert ex un orig Nil, auto)"], ["proof (state)\nthis:\n  (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n  (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n  x = real_of_1 (q, l_fin, r_fin)\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "case True"], ["proof (state)\nthis:\n  n = 1\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "with res old'"], ["proof (chain)\npicking this:\n  (if n = 1 then (hd old, l, r)\n   else case bnd_get (bnd_update a) of\n        (l, r) \\<Rightarrow>\n          local.select_correct_factor_main (bnd_update a) old [] l r 0) =\n  ((q, ri_fin), l_fin, r_fin)\n  old = (q1, ri1) # old'\n  n = 1", "have id: \"q = q1\" \"ri_fin = ri1\" \"l_fin = l\" \"r_fin = r\""], ["proof (prove)\nusing this:\n  (if n = 1 then (hd old, l, r)\n   else case bnd_get (bnd_update a) of\n        (l, r) \\<Rightarrow>\n          local.select_correct_factor_main (bnd_update a) old [] l r 0) =\n  ((q, ri_fin), l_fin, r_fin)\n  old = (q1, ri1) # old'\n  n = 1\n\ngoal (1 subgoal):\n 1. (q = q1 &&& ri_fin = ri1) &&& l_fin = l &&& r_fin = r", "by auto"], ["proof (state)\nthis:\n  q = q1\n  ri_fin = ri1\n  l_fin = l\n  r_fin = r\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from n[unfolded True old'] 0"], ["proof (chain)\npicking this:\n  1 =\n  (\\<Sum>a\\<leftarrow>(q1, ri1) #\n                      old'. case a of\n                            (q, ri) \\<Rightarrow> root_info.l_r ri l r)\n  root_info.l_r ri1 l r \\<noteq> 0", "have 1: \"?ri = 1\""], ["proof (prove)\nusing this:\n  1 =\n  (\\<Sum>a\\<leftarrow>(q1, ri1) #\n                      old'. case a of\n                            (q, ri) \\<Rightarrow> root_info.l_r ri l r)\n  root_info.l_r ri1 l r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root_info.l_r ri1 l r = 1", "by (cases ?ri; cases \"?ri - 1\", auto)"], ["proof (state)\nthis:\n  root_info.l_r ri1 l r = 1\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from root_info_condD(1)[OF ri' lr] 1"], ["proof (chain)\npicking this:\n  root_info.l_r ri1 l r = card {x. root_cond (q1, l, r) x}\n  root_info.l_r ri1 l r = 1", "have \"card {x. root_cond (q1,l,r) x} = 1\""], ["proof (prove)\nusing this:\n  root_info.l_r ri1 l r = card {x. root_cond (q1, l, r) x}\n  root_info.l_r ri1 l r = 1\n\ngoal (1 subgoal):\n 1. card {x. root_cond (q1, l, r) x} = 1", "by auto"], ["proof (state)\nthis:\n  card {x. root_cond (q1, l, r) x} = 1\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from card_1_Collect_ex1[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond (q1, l, r) x", "have unique: \"unique_root (q1,l,r)\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond (q1, l, r) x\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (q1, l, r) x", "."], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (q1, l, r) x\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "from ex[unfolded Nil old']"], ["proof (chain)\npicking this:\n  \\<exists>q.\n     q \\<in> fst ` set [] \\<union> fst ` set ((q1, ri1) # old') \\<and>\n     poly (real_of_int_poly q) x = 0", "consider (A) \"ipoly q1 x = 0\" \n          | (B) q where \"q \\<in> fst ` set old'\" \"ipoly q x = 0\""], ["proof (prove)\nusing this:\n  \\<exists>q.\n     q \\<in> fst ` set [] \\<union> fst ` set ((q1, ri1) # old') \\<and>\n     poly (real_of_int_poly q) x = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>poly (real_of_int_poly q1) x = 0 \\<Longrightarrow> thesis;\n     \\<And>q.\n        \\<lbrakk>q \\<in> fst ` set old';\n         poly (real_of_int_poly q) x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>poly (real_of_int_poly q1) x = 0 \\<Longrightarrow> ?thesis1;\n   \\<And>q.\n      \\<lbrakk>q \\<in> fst ` set old';\n       poly (real_of_int_poly q) x = 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "hence \"x = the_unique_root (q1,l,r)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>poly (real_of_int_poly q1) x = 0 \\<Longrightarrow> ?thesis1;\n   \\<And>q.\n      \\<lbrakk>q \\<in> fst ` set old';\n       poly (real_of_int_poly q) x = 0\\<rbrakk>\n      \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. x = real_of_1 (q1, l, r)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly (real_of_int_poly q1) x = 0 \\<Longrightarrow>\n    x = real_of_1 (q1, l, r)\n 2. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "case A"], ["proof (state)\nthis:\n  poly (real_of_int_poly q1) x = 0\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly q1) x = 0 \\<Longrightarrow>\n    x = real_of_1 (q1, l, r)\n 2. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "with lxr"], ["proof (chain)\npicking this:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  poly (real_of_int_poly q1) x = 0", "have \"root_cond (q1,l,r) x\""], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  poly (real_of_int_poly q1) x = 0\n\ngoal (1 subgoal):\n 1. root_cond (q1, l, r) x", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  poly (real_of_int_poly q1) x = 0\n\ngoal (1 subgoal):\n 1. case (q1, l, r) of\n    (p, l, r) \\<Rightarrow>\n      real_of_rat l \\<le> x \\<and>\n      x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0", "by auto"], ["proof (state)\nthis:\n  root_cond (q1, l, r) x\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly q1) x = 0 \\<Longrightarrow>\n    x = real_of_1 (q1, l, r)\n 2. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "from the_unique_root_eqI[OF unique this]"], ["proof (chain)\npicking this:\n  x = real_of_1 (q1, l, r)\n  real_of_1 (q1, l, r) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  x = real_of_1 (q1, l, r)\n  real_of_1 (q1, l, r) = x\n\ngoal (1 subgoal):\n 1. x = real_of_1 (q1, l, r)", "by simp"], ["proof (state)\nthis:\n  x = real_of_1 (q1, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "case (B q)"], ["proof (state)\nthis:\n  q \\<in> fst ` set old'\n  poly (real_of_int_poly q) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "with lxr"], ["proof (chain)\npicking this:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  q \\<in> fst ` set old'\n  poly (real_of_int_poly q) x = 0", "have \"root_cond (q,l,r) x\""], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  q \\<in> fst ` set old'\n  poly (real_of_int_poly q) x = 0\n\ngoal (1 subgoal):\n 1. root_cond (q, l, r) x", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x\n  x \\<le> real_of_rat r\n  q \\<in> fst ` set old'\n  poly (real_of_int_poly q) x = 0\n\ngoal (1 subgoal):\n 1. case (q, l, r) of\n    (p, l, r) \\<Rightarrow>\n      real_of_rat l \\<le> x \\<and>\n      x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0", "by auto"], ["proof (state)\nthis:\n  root_cond (q, l, r) x\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "hence empty: \"{x. root_cond (q,l,r) x} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  root_cond (q, l, r) x\n\ngoal (1 subgoal):\n 1. {x. root_cond (q, l, r) x} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {x. root_cond (q, l, r) x} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "from B(1)"], ["proof (chain)\npicking this:\n  q \\<in> fst ` set old'", "obtain ri' where mem: \"(q,ri') \\<in> set old'\""], ["proof (prove)\nusing this:\n  q \\<in> fst ` set old'\n\ngoal (1 subgoal):\n 1. (\\<And>ri'.\n        (q, ri') \\<in> set old' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (q, ri') \\<in> set old'\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "from q0[unfolded old'] mem"], ["proof (chain)\npicking this:\n  (?q1, ?ri1)\n  \\<in> set todo \\<union> set ((q1, ri1) # old') \\<Longrightarrow>\n  ?q1 \\<noteq> 0\n  (q, ri') \\<in> set old'", "have q0: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (?q1, ?ri1)\n  \\<in> set todo \\<union> set ((q1, ri1) # old') \\<Longrightarrow>\n  ?q1 \\<noteq> 0\n  (q, ri') \\<in> set old'\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "from finite_ipoly_roots[OF this]"], ["proof (chain)\npicking this:\n  finite {x. poly (real_of_int_poly q) x = 0}", "have \"finite {x. root_cond (q,l,r) x}\""], ["proof (prove)\nusing this:\n  finite {x. poly (real_of_int_poly q) x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. root_cond (q, l, r) x}", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  finite {x. poly (real_of_int_poly q) x = 0}\n\ngoal (1 subgoal):\n 1. finite\n     {x. case (q, l, r) of\n         (p, l, r) \\<Rightarrow>\n           real_of_rat l \\<le> x \\<and>\n           x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0}", "by auto"], ["proof (state)\nthis:\n  finite {x. root_cond (q, l, r) x}\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "with empty"], ["proof (chain)\npicking this:\n  {x. root_cond (q, l, r) x} \\<noteq> {}\n  finite {x. root_cond (q, l, r) x}", "have card: \"card {x. root_cond (q,l,r) x} \\<noteq> 0\""], ["proof (prove)\nusing this:\n  {x. root_cond (q, l, r) x} \\<noteq> {}\n  finite {x. root_cond (q, l, r) x}\n\ngoal (1 subgoal):\n 1. card {x. root_cond (q, l, r) x} \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  card {x. root_cond (q, l, r) x} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "from ri[unfolded old'] mem"], ["proof (chain)\npicking this:\n  (?q1, ?ri1)\n  \\<in> set todo \\<union> set ((q1, ri1) # old') \\<Longrightarrow>\n  root_info_cond ?ri1 ?q1\n  (q, ri') \\<in> set old'", "have \"root_info_cond ri' q\""], ["proof (prove)\nusing this:\n  (?q1, ?ri1)\n  \\<in> set todo \\<union> set ((q1, ri1) # old') \\<Longrightarrow>\n  root_info_cond ?ri1 ?q1\n  (q, ri') \\<in> set old'\n\ngoal (1 subgoal):\n 1. root_info_cond ri' q", "by auto"], ["proof (state)\nthis:\n  root_info_cond ri' q\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "from root_info_condD(1)[OF this lr] card"], ["proof (chain)\npicking this:\n  root_info.l_r ri' l r = card {x. root_cond (q, l, r) x}\n  card {x. root_cond (q, l, r) x} \\<noteq> 0", "have \"root_info.l_r ri' l r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  root_info.l_r ri' l r = card {x. root_cond (q, l, r) x}\n  card {x. root_cond (q, l, r) x} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root_info.l_r ri' l r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  root_info.l_r ri' l r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "with n[unfolded True old'] 1 split_list[OF mem]"], ["proof (chain)\npicking this:\n  1 =\n  (\\<Sum>a\\<leftarrow>(q1, ri1) #\n                      old'. case a of\n                            (q, ri) \\<Rightarrow> root_info.l_r ri l r)\n  root_info.l_r ri1 l r = 1\n  \\<exists>ys zs. old' = ys @ (q, ri') # zs\n  root_info.l_r ri' l r \\<noteq> 0", "have False"], ["proof (prove)\nusing this:\n  1 =\n  (\\<Sum>a\\<leftarrow>(q1, ri1) #\n                      old'. case a of\n                            (q, ri) \\<Rightarrow> root_info.l_r ri l r)\n  root_info.l_r ri1 l r = 1\n  \\<exists>ys zs. old' = ys @ (q, ri') # zs\n  root_info.l_r ri' l r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>q \\<in> fst ` set old';\n        poly (real_of_int_poly q) x = 0\\<rbrakk>\n       \\<Longrightarrow> x = real_of_1 (q1, l, r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x = real_of_1 (q1, l, r)", "by simp"], ["proof (state)\nthis:\n  x = real_of_1 (q1, l, r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = real_of_1 (q1, l, r)\n\ngoal (1 subgoal):\n 1. n = 1 \\<Longrightarrow>\n    (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = real_of_1 (q1, l, r)\n\ngoal (1 subgoal):\n 1. (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n    (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q, l_fin, r_fin)", "unfolding id"], ["proof (prove)\nusing this:\n  x = real_of_1 (q1, l, r)\n\ngoal (1 subgoal):\n 1. (\\<exists>!a. root_cond (q1, l, r) a) \\<and>\n    (q1, ri1) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q1, l, r)", "using unique ri'"], ["proof (prove)\nusing this:\n  x = real_of_1 (q1, l, r)\n  \\<exists>!x. root_cond (q1, l, r) x\n  root_info_cond ri1 q1\n\ngoal (1 subgoal):\n 1. (\\<exists>!a. root_cond (q1, l, r) a) \\<and>\n    (q1, ri1) \\<in> set todo \\<union> set old \\<and>\n    x = real_of_1 (q1, l, r)", "unfolding old'"], ["proof (prove)\nusing this:\n  x = real_of_1 (q1, l, r)\n  \\<exists>!x. root_cond (q1, l, r) x\n  root_info_cond ri1 q1\n\ngoal (1 subgoal):\n 1. (\\<exists>!a. root_cond (q1, l, r) a) \\<and>\n    (q1, ri1) \\<in> set todo \\<union> set ((q1, ri1) # old') \\<and>\n    x = real_of_1 (q1, l, r)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n  (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n  x = real_of_1 (q, l_fin, r_fin)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n  (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n  x = real_of_1 (q, l_fin, r_fin)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>!a. root_cond (q, l_fin, r_fin) a) \\<and>\n  (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n  x = real_of_1 (q, l_fin, r_fin)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>!x. root_cond (q, l_fin, r_fin) x) \\<and>\n  (q, ri_fin) \\<in> set todo \\<union> set old \\<and>\n  x = real_of_1 (q, l_fin, r_fin)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma select_correct_factor: assumes \n      conv: \"converges_to (\\<lambda> i. bnd_get ((bnd_update ^^ i) init)) x\"\n  and res: \"select_correct_factor init polys = ((q,ri),(l,r))\"\n  and ri: \"\\<And> q ri. (q,ri) \\<in> set polys \\<Longrightarrow> root_info_cond ri q\"\n  and q0: \"\\<And> q ri. (q,ri) \\<in> set polys \\<Longrightarrow> q \\<noteq> 0\"\n  and ex: \"\\<exists>q. q \\<in> fst ` set polys \\<and> ipoly q x = 0\"\n  and dist: \"distinct (map fst polys)\"\n  and un: \"\\<And> x :: real. (\\<exists>q. q \\<in> fst ` set polys \\<and> ipoly q x = 0) \\<Longrightarrow> \n    \\<exists>!q. q \\<in> fst ` set polys \\<and> ipoly q x = 0\"\n  shows \"unique_root (q,l,r) \\<and> (q,ri) \\<in> set polys \\<and> x = the_unique_root (q,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n    (q, ri) \\<in> set polys \\<and> x = real_of_1 (q, l, r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n    (q, ri) \\<in> set polys \\<and> x = real_of_1 (q, l, r)", "obtain l' r' where init: \"bnd_get init = (l',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l' r'.\n        bnd_get init = (l', r') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  bnd_get init = (l', r')\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n    (q, ri) \\<in> set polys \\<and> x = real_of_1 (q, l, r)", "from res[unfolded select_correct_factor_def init split]"], ["proof (chain)\npicking this:\n  local.select_correct_factor_main init polys [] l' r' 0 = ((q, ri), l, r)", "have res: \"select_correct_factor_main init polys [] l' r' 0 = ((q, ri), l, r)\""], ["proof (prove)\nusing this:\n  local.select_correct_factor_main init polys [] l' r' 0 = ((q, ri), l, r)\n\ngoal (1 subgoal):\n 1. local.select_correct_factor_main init polys [] l' r' 0 = ((q, ri), l, r)", "by auto"], ["proof (state)\nthis:\n  local.select_correct_factor_main init polys [] l' r' 0 = ((q, ri), l, r)\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n    (q, ri) \\<in> set polys \\<and> x = real_of_1 (q, l, r)", "have at: \"at_step (\\<lambda> i. bnd_get ((bnd_update ^^ i) init)) 0 init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.at_step (\\<lambda>i. bnd_get ((bnd_update ^^ i) init)) 0 init", "unfolding at_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       bnd_get ((bnd_update ^^ i) init) =\n       bnd_get ((bnd_update ^^ (0 + i)) init)", "by auto"], ["proof (state)\nthis:\n  local.at_step (\\<lambda>i. bnd_get ((bnd_update ^^ i) init)) 0 init\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n    (q, ri) \\<in> set polys \\<and> x = real_of_1 (q, l, r)", "have \"unique_root (q,l,r) \\<and> (q,ri) \\<in> set polys \\<union> set [] \\<and> x = the_unique_root (q,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n    (q, ri) \\<in> set polys \\<union> set [] \\<and> x = real_of_1 (q, l, r)", "by (rule select_correct_factor_main[OF conv at res init ri], insert dist un ex q0, auto)"], ["proof (state)\nthis:\n  (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n  (q, ri) \\<in> set polys \\<union> set [] \\<and> x = real_of_1 (q, l, r)\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n    (q, ri) \\<in> set polys \\<and> x = real_of_1 (q, l, r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n  (q, ri) \\<in> set polys \\<union> set [] \\<and> x = real_of_1 (q, l, r)\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n    (q, ri) \\<in> set polys \\<and> x = real_of_1 (q, l, r)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n  (q, ri) \\<in> set polys \\<and> x = real_of_1 (q, l, r)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition real_alg_2' :: \"root_info \\<Rightarrow> int poly \\<Rightarrow> rat \\<Rightarrow> rat \\<Rightarrow> real_alg_2\" where\n  [code del]: \"real_alg_2' ri p l r = (\n    if degree p = 1 then Rational (Rat.Fract (- coeff p 0) (coeff p 1)) else\n    real_alg_2_main ri (case tighten_poly_bounds_for_x p 0 l r (sgn (ipoly p r)) of\n              (l',r',sr') \\<Rightarrow> (p, l', r')))\""], ["", "lemma real_alg_2'_code[code]: \"real_alg_2' ri p l r =\n (if degree p = 1 then Rational (Rat.Fract (- coeff p 0) (coeff p 1))\n     else case normalize_bounds_1\n        (case tighten_poly_bounds_for_x p 0 l r (sgn (ipoly p r)) of (l', r', sr') \\<Rightarrow> (p, l', r')) \n     of (p', l, r) \\<Rightarrow> Irrational (root_info.number_root ri r) (p', l, r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_alg_2' ri p l r =\n    (if degree p = 1 then Rational (Rat.Fract (- coeff p 0) (coeff p 1))\n     else case normalize_bounds_1\n                (case tighten_poly_bounds_for_x p 0 l r (sgn (ipoly p r)) of\n                 (l', r', sr') \\<Rightarrow> (p, l', r')) of\n          (p', l, r) \\<Rightarrow>\n            Irrational (root_info.number_root ri r) (p', l, r))", "unfolding real_alg_2'_def real_alg_2_main_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if degree p = 1 then Rational (Rat.Fract (- coeff p 0) (coeff p 1))\n     else let pa = poly_real_alg_1\n                    (case tighten_poly_bounds_for_x p 0 l r\n                           (sgn (ipoly p r)) of\n                     (l', r', sr') \\<Rightarrow> (p, l', r'))\n          in if degree pa = 1\n             then Rational (Rat.Fract (- coeff pa 0) (coeff pa 1))\n             else case normalize_bounds_1\n                        (case tighten_poly_bounds_for_x p 0 l r\n                               (sgn (ipoly p r)) of\n                         (l', r', sr') \\<Rightarrow> (p, l', r')) of\n                  (p', l, r) \\<Rightarrow>\n                    Irrational (root_info.number_root ri r) (p', l, r)) =\n    (if degree p = 1 then Rational (Rat.Fract (- coeff p 0) (coeff p 1))\n     else case normalize_bounds_1\n                (case tighten_poly_bounds_for_x p 0 l r (sgn (ipoly p r)) of\n                 (l', r', sr') \\<Rightarrow> (p, l', r')) of\n          (p', l, r) \\<Rightarrow>\n            Irrational (root_info.number_root ri r) (p', l, r))", "by (cases \"tighten_poly_bounds_for_x p 0 l r (sgn (ipoly p r))\", simp add: Let_def)"], ["", "definition real_alg_2'' :: \"root_info \\<Rightarrow> int poly \\<Rightarrow> rat \\<Rightarrow> rat \\<Rightarrow> real_alg_2\" where\n  \"real_alg_2'' ri p l r = (case normalize_bounds_1\n        (case tighten_poly_bounds_for_x p 0 l r (sgn (ipoly p r)) of (l', r', sr') \\<Rightarrow> (p, l', r')) \n     of (p', l, r) \\<Rightarrow> Irrational (root_info.number_root ri r) (p', l, r))\""], ["", "lemma real_alg_2'': \"degree p \\<noteq> 1 \\<Longrightarrow> real_alg_2'' ri p l r = real_alg_2' ri p l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_alg_2'' ri p l r = real_alg_2' ri p l r", "unfolding real_alg_2'_code real_alg_2''_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    (case normalize_bounds_1\n           (case tighten_poly_bounds_for_x p 0 l r (sgn (ipoly p r)) of\n            (l', r', sr') \\<Rightarrow> (p, l', r')) of\n     (p', l, r) \\<Rightarrow>\n       Irrational (root_info.number_root ri r) (p', l, r)) =\n    (if degree p = 1 then Rational (Rat.Fract (- coeff p 0) (coeff p 1))\n     else case normalize_bounds_1\n                (case tighten_poly_bounds_for_x p 0 l r (sgn (ipoly p r)) of\n                 (l', r', sr') \\<Rightarrow> (p, l', r')) of\n          (p', l, r) \\<Rightarrow>\n            Irrational (root_info.number_root ri r) (p', l, r))", "by auto"], ["", "lemma poly_cond_degree_0_imp_no_root:\n  fixes x :: \"'b :: {comm_ring_1,ring_char_0}\"\n  assumes pc: \"poly_cond p\" and deg: \"degree p = 0\" shows \"ipoly p x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly p x \\<noteq> (0::'b)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ipoly p x = (0::'b) \\<Longrightarrow> False", "from pc"], ["proof (chain)\npicking this:\n  poly_cond p", "have \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly_cond p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ipoly p x = (0::'b) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ipoly p x = (0::'b) \\<Longrightarrow> False", "assume \"ipoly p x = 0\""], ["proof (state)\nthis:\n  ipoly p x = (0::'b)\n\ngoal (1 subgoal):\n 1. ipoly p x = (0::'b) \\<Longrightarrow> False", "note poly_zero[OF this]"], ["proof (state)\nthis:\n  (of_int_poly p = 0) = (degree (of_int_poly p) = 0)\n\ngoal (1 subgoal):\n 1. ipoly p x = (0::'b) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  (of_int_poly p = 0) = (degree (of_int_poly p) = 0)", "show False"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  (of_int_poly p = 0) = (degree (of_int_poly p) = 0)\n\ngoal (1 subgoal):\n 1. False", "using deg"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  (of_int_poly p = 0) = (degree (of_int_poly p) = 0)\n  degree p = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma real_alg_2':\n  assumes ur: \"unique_root (q,l,r)\" and pc: \"poly_cond q\" and ri: \"root_info_cond ri q\"\n  shows \"invariant_2 (real_alg_2' ri q l r) \\<and> real_of_2 (real_alg_2' ri q l r) = the_unique_root (q,l,r)\" (is \"_ \\<and> _ = ?x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "proof (cases \"degree q\" \"Suc 0\" rule: linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. degree q < Suc 0 \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n 2. degree q = Suc 0 \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n 3. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "case deg: less"], ["proof (state)\nthis:\n  degree q < Suc 0\n\ngoal (3 subgoals):\n 1. degree q < Suc 0 \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n 2. degree q = Suc 0 \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n 3. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "then"], ["proof (chain)\npicking this:\n  degree q < Suc 0", "have \"degree q = 0\""], ["proof (prove)\nusing this:\n  degree q < Suc 0\n\ngoal (1 subgoal):\n 1. degree q = 0", "by auto"], ["proof (state)\nthis:\n  degree q = 0\n\ngoal (3 subgoals):\n 1. degree q < Suc 0 \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n 2. degree q = Suc 0 \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n 3. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "from poly_cond_degree_0_imp_no_root[OF pc this] ur"], ["proof (chain)\npicking this:\n  ipoly q ?x \\<noteq> (0::?'b)\n  \\<exists>!x. root_cond (q, l, r) x", "have False"], ["proof (prove)\nusing this:\n  ipoly q ?x \\<noteq> (0::?'b)\n  \\<exists>!x. root_cond (q, l, r) x\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. degree q < Suc 0 \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n 2. degree q = Suc 0 \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n 3. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "by auto"], ["proof (state)\nthis:\n  invariant_2 (real_alg_2' ri q l r) \\<and>\n  real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n\ngoal (2 subgoals):\n 1. degree q = Suc 0 \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n 2. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. degree q = Suc 0 \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n 2. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "case deg: equal"], ["proof (state)\nthis:\n  degree q = Suc 0\n\ngoal (2 subgoals):\n 1. degree q = Suc 0 \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n 2. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "hence id: \"real_alg_2' ri q l r = Rational (Rat.Fract (- coeff q 0) (coeff q 1))\""], ["proof (prove)\nusing this:\n  degree q = Suc 0\n\ngoal (1 subgoal):\n 1. real_alg_2' ri q l r = Rational (Rat.Fract (- coeff q 0) (coeff q 1))", "unfolding real_alg_2'_def"], ["proof (prove)\nusing this:\n  degree q = Suc 0\n\ngoal (1 subgoal):\n 1. (if degree q = 1 then Rational (Rat.Fract (- coeff q 0) (coeff q 1))\n     else real_alg_2_main ri\n           (case tighten_poly_bounds_for_x q 0 l r (sgn (ipoly q r)) of\n            (l', r', sr') \\<Rightarrow> (q, l', r'))) =\n    Rational (Rat.Fract (- coeff q 0) (coeff q 1))", "by auto"], ["proof (state)\nthis:\n  real_alg_2' ri q l r = Rational (Rat.Fract (- coeff q 0) (coeff q 1))\n\ngoal (2 subgoals):\n 1. degree q = Suc 0 \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n 2. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (Rational (Rat.Fract (- coeff q 0) (coeff q 1))) \\<and>\n    real_of_2 (Rational (Rat.Fract (- coeff q 0) (coeff q 1))) =\n    real_of_1 (q, l, r)", "using degree_1_ipoly[OF deg]"], ["proof (prove)\nusing this:\n  (poly (real_of_int_poly q) ?x = 0) =\n  (?x = real_of_rat (Rat.Fract (- coeff q 0) (coeff q 1)))\n\ngoal (1 subgoal):\n 1. invariant_2 (Rational (Rat.Fract (- coeff q 0) (coeff q 1))) \\<and>\n    real_of_2 (Rational (Rat.Fract (- coeff q 0) (coeff q 1))) =\n    real_of_1 (q, l, r)", "using unique_rootD(4)[OF ur]"], ["proof (prove)\nusing this:\n  (poly (real_of_int_poly q) ?x = 0) =\n  (?x = real_of_rat (Rat.Fract (- coeff q 0) (coeff q 1)))\n  root_cond (q, l, r) (real_of_1 (q, l, r))\n\ngoal (1 subgoal):\n 1. invariant_2 (Rational (Rat.Fract (- coeff q 0) (coeff q 1))) \\<and>\n    real_of_2 (Rational (Rat.Fract (- coeff q 0) (coeff q 1))) =\n    real_of_1 (q, l, r)", "by auto"], ["proof (state)\nthis:\n  invariant_2 (real_alg_2' ri q l r) \\<and>\n  real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "case deg: greater"], ["proof (state)\nthis:\n  Suc 0 < degree q\n\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "with pc"], ["proof (chain)\npicking this:\n  poly_cond q\n  Suc 0 < degree q", "have pc2: \"poly_cond2 q\""], ["proof (prove)\nusing this:\n  poly_cond q\n  Suc 0 < degree q\n\ngoal (1 subgoal):\n 1. poly_cond2 q", "by auto"], ["proof (state)\nthis:\n  poly_cond2 q\n\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "let ?rai = \"real_alg_2' ri q l r\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "let ?r = real_of_rat"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "obtain l' r' sr' where tight: \"tighten_poly_bounds_for_x q 0 l r (sgn (ipoly q r)) = (l',r',sr')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l' r' sr'.\n        tighten_poly_bounds_for_x q 0 l r (sgn (ipoly q r)) =\n        (l', r', sr') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases rule: prod_cases3, auto)"], ["proof (state)\nthis:\n  tighten_poly_bounds_for_x q 0 l r (sgn (ipoly q r)) = (l', r', sr')\n\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "let ?rai' = \"(q, l', r')\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "have rai': \"?rai = real_alg_2_main ri ?rai'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_alg_2' ri q l r = real_alg_2_main ri (q, l', r')", "unfolding real_alg_2'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if degree q = 1 then Rational (Rat.Fract (- coeff q 0) (coeff q 1))\n     else real_alg_2_main ri\n           (case tighten_poly_bounds_for_x q 0 l r (sgn (ipoly q r)) of\n            (l', r', sr') \\<Rightarrow> (q, l', r'))) =\n    real_alg_2_main ri (q, l', r')", "using deg tight"], ["proof (prove)\nusing this:\n  Suc 0 < degree q\n  tighten_poly_bounds_for_x q 0 l r (sgn (ipoly q r)) = (l', r', sr')\n\ngoal (1 subgoal):\n 1. (if degree q = 1 then Rational (Rat.Fract (- coeff q 0) (coeff q 1))\n     else real_alg_2_main ri\n           (case tighten_poly_bounds_for_x q 0 l r (sgn (ipoly q r)) of\n            (l', r', sr') \\<Rightarrow> (q, l', r'))) =\n    real_alg_2_main ri (q, l', r')", "by auto"], ["proof (state)\nthis:\n  real_alg_2' ri q l r = real_alg_2_main ri (q, l', r')\n\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "hence rai: \"real_of_1 ?rai' = the_unique_root (q,l',r')\""], ["proof (prove)\nusing this:\n  real_alg_2' ri q l r = real_alg_2_main ri (q, l', r')\n\ngoal (1 subgoal):\n 1. real_of_1 (q, l', r') = real_of_1 (q, l', r')", "by auto"], ["proof (state)\nthis:\n  real_of_1 (q, l', r') = real_of_1 (q, l', r')\n\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "note tight = tighten_poly_bounds_for_x[OF ur pc2 tight refl]"], ["proof (state)\nthis:\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  root_cond (q, l', r') (real_of_1 (q, l, r))\n  \\<not> (l' \\<le> 0 \\<and> 0 \\<le> r')\n  sr' = sgn (ipoly q r')\n  \\<exists>!x. root_cond (q, l', r') x\n\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "let ?x = \"the_unique_root (q, l, r)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "from tight"], ["proof (chain)\npicking this:\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  root_cond (q, l', r') (real_of_1 (q, l, r))\n  \\<not> (l' \\<le> 0 \\<and> 0 \\<le> r')\n  sr' = sgn (ipoly q r')\n  \\<exists>!x. root_cond (q, l', r') x", "have tight: \"root_cond (q,l',r') ?x\" \"l \\<le> l'\" \"l' \\<le> r'\" \"r' \\<le> r\" \"l' > 0 \\<or> r' < 0\""], ["proof (prove)\nusing this:\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  root_cond (q, l', r') (real_of_1 (q, l, r))\n  \\<not> (l' \\<le> 0 \\<and> 0 \\<le> r')\n  sr' = sgn (ipoly q r')\n  \\<exists>!x. root_cond (q, l', r') x\n\ngoal (1 subgoal):\n 1. (root_cond (q, l', r') (real_of_1 (q, l, r)) &&& l \\<le> l') &&&\n    l' \\<le> r' &&& r' \\<le> r &&& 0 < l' \\<or> r' < 0", "by auto"], ["proof (state)\nthis:\n  root_cond (q, l', r') (real_of_1 (q, l, r))\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  0 < l' \\<or> r' < 0\n\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "from unique_root_sub_interval[OF ur tight(1) tight(2,4)] poly_condD[OF pc]"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond (q, l', r') x\n  real_of_1 (q, l', r') = real_of_1 (q, l, r)\n  irreducible q\n  0 < lead_coeff q\n  root_free q\n  square_free q\n  q \\<noteq> 0", "have ur': \"unique_root (q, l', r')\" and x: \"?x = the_unique_root (q,l',r')\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond (q, l', r') x\n  real_of_1 (q, l', r') = real_of_1 (q, l, r)\n  irreducible q\n  0 < lead_coeff q\n  root_free q\n  square_free q\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (q, l', r') x &&&\n    real_of_1 (q, l, r) = real_of_1 (q, l', r')", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (q, l', r') x\n  real_of_1 (q, l, r) = real_of_1 (q, l', r')\n\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "from tight(2-)"], ["proof (chain)\npicking this:\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  0 < l' \\<or> r' < 0", "have sgn: \"sgn l' = sgn r'\""], ["proof (prove)\nusing this:\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  0 < l' \\<or> r' < 0\n\ngoal (1 subgoal):\n 1. sgn l' = sgn r'", "by auto"], ["proof (state)\nthis:\n  sgn l' = sgn r'\n\ngoal (1 subgoal):\n 1. Suc 0 < degree q \\<Longrightarrow>\n    invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "unfolding rai'"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2_main ri (q, l', r')) \\<and>\n    real_of_2 (real_alg_2_main ri (q, l', r')) = real_of_1 (q, l, r)", "using real_alg_2_main[of ?rai' ri] invariant_1_realI[of ?rai' ?x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>invariant_1 (q, l', r');\n   irreducible (poly_real_alg_1 (q, l', r')) \\<Longrightarrow>\n   root_info_cond ri (poly_real_alg_1 (q, l', r'))\\<rbrakk>\n  \\<Longrightarrow> invariant_2 (real_alg_2_main ri (q, l', r'))\n  \\<lbrakk>invariant_1 (q, l', r');\n   irreducible (poly_real_alg_1 (q, l', r')) \\<Longrightarrow>\n   root_info_cond ri (poly_real_alg_1 (q, l', r'))\\<rbrakk>\n  \\<Longrightarrow> real_of_2 (real_alg_2_main ri (q, l', r')) =\n                    real_of_1 (q, l', r')\n  \\<lbrakk>root_cond (q, l', r') (real_of_1 (q, l, r));\n   sgn (rai_lb (q, l', r')) = sgn (rai_ub (q, l', r'));\n   \\<exists>!x. root_cond (q, l', r') x;\n   poly_cond (poly_real_alg_1 (q, l', r'))\\<rbrakk>\n  \\<Longrightarrow> invariant_1 (q, l', r') \\<and>\n                    real_of_1 (q, l', r') = real_of_1 (q, l, r)\n\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2_main ri (q, l', r')) \\<and>\n    real_of_2 (real_alg_2_main ri (q, l', r')) = real_of_1 (q, l, r)", "by (auto simp: tight(1) sgn pc ri ur')"], ["proof (state)\nthis:\n  invariant_2 (real_alg_2' ri q l r) \\<and>\n  real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition select_correct_factor_int_poly :: \"'a \\<Rightarrow> int poly \\<Rightarrow> real_alg_2\" where\n  \"select_correct_factor_int_poly init p \\<equiv> \n     let qs = factors_of_int_poly p;\n         polys = map (\\<lambda> q. (q, root_info q)) qs;\n         ((q,ri),(l,r)) = select_correct_factor init polys\n      in real_alg_2' ri q l r\""], ["", "lemma select_correct_factor_int_poly: assumes \n      conv: \"converges_to (\\<lambda> i. bnd_get ((bnd_update ^^ i) init)) x\"\n  and rai: \"select_correct_factor_int_poly init p = rai\"\n  and x: \"ipoly p x = 0\"\n  and p: \"p \\<noteq> 0\"\n  shows \"invariant_2 rai \\<and> real_of_2 rai = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "obtain qs where fact: \"factors_of_int_poly p = qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qs.\n        factors_of_int_poly p = qs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  factors_of_int_poly p = qs\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "define polys where \"polys = map (\\<lambda> q. (q, root_info q)) qs\""], ["proof (state)\nthis:\n  polys = map (\\<lambda>q. (q, root_info q)) qs\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "obtain q ri l r where res: \"select_correct_factor init polys = ((q,ri),(l,r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q ri l r.\n        local.select_correct_factor init polys =\n        ((q, ri), l, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"select_correct_factor init polys\", auto)"], ["proof (state)\nthis:\n  local.select_correct_factor init polys = ((q, ri), l, r)\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "have fst: \"map fst polys = qs\" \"fst ` set polys = set qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst polys = qs &&& fst ` set polys = set qs", "unfolding polys_def map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. fst (x, root_info x)) qs = qs &&&\n    fst ` set (map (\\<lambda>q. (q, root_info q)) qs) = set qs", "by force+"], ["proof (state)\nthis:\n  map fst polys = qs\n  fst ` set polys = set qs\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "note fact' = factors_of_int_poly[OF fact]"], ["proof (state)\nthis:\n  ?q \\<in> set qs \\<Longrightarrow>\n  irreducible ?q \\<and>\n  0 < lead_coeff ?q \\<and>\n  degree ?q \\<le> degree p \\<and> degree ?q \\<noteq> 0\n  p \\<noteq> 0 \\<Longrightarrow>\n  (ipoly p ?x = (0::?'a)) = (\\<exists>q\\<in>set qs. ipoly q ?x = (0::?'a))\n  \\<lbrakk>p \\<noteq> 0; ipoly p ?x = (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!q. q \\<in> set qs \\<and> ipoly q ?x = (0::?'a)\n  distinct qs\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "note rai = rai[unfolded select_correct_factor_int_poly_def Let_def fact, \n    folded polys_def, unfolded res split]"], ["proof (state)\nthis:\n  real_alg_2' ri q l r = rai\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "from fact' fst"], ["proof (chain)\npicking this:\n  ?q \\<in> set qs \\<Longrightarrow>\n  irreducible ?q \\<and>\n  0 < lead_coeff ?q \\<and>\n  degree ?q \\<le> degree p \\<and> degree ?q \\<noteq> 0\n  p \\<noteq> 0 \\<Longrightarrow>\n  (ipoly p ?x = (0::?'a)) = (\\<exists>q\\<in>set qs. ipoly q ?x = (0::?'a))\n  \\<lbrakk>p \\<noteq> 0; ipoly p ?x = (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!q. q \\<in> set qs \\<and> ipoly q ?x = (0::?'a)\n  distinct qs\n  map fst polys = qs\n  fst ` set polys = set qs", "have dist: \"distinct (map fst polys)\""], ["proof (prove)\nusing this:\n  ?q \\<in> set qs \\<Longrightarrow>\n  irreducible ?q \\<and>\n  0 < lead_coeff ?q \\<and>\n  degree ?q \\<le> degree p \\<and> degree ?q \\<noteq> 0\n  p \\<noteq> 0 \\<Longrightarrow>\n  (ipoly p ?x = (0::?'a)) = (\\<exists>q\\<in>set qs. ipoly q ?x = (0::?'a))\n  \\<lbrakk>p \\<noteq> 0; ipoly p ?x = (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!q. q \\<in> set qs \\<and> ipoly q ?x = (0::?'a)\n  distinct qs\n  map fst polys = qs\n  fst ` set polys = set qs\n\ngoal (1 subgoal):\n 1. distinct (map fst polys)", "by auto"], ["proof (state)\nthis:\n  distinct (map fst polys)\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "from fact'(2)[OF p, of x] x fst"], ["proof (chain)\npicking this:\n  (poly (real_of_int_poly p) x = 0) =\n  (\\<exists>q\\<in>set qs. poly (real_of_int_poly q) x = 0)\n  poly (real_of_int_poly p) x = 0\n  map fst polys = qs\n  fst ` set polys = set qs", "have ex: \"\\<exists>q. q \\<in> fst ` set polys \\<and> ipoly q x = 0\""], ["proof (prove)\nusing this:\n  (poly (real_of_int_poly p) x = 0) =\n  (\\<exists>q\\<in>set qs. poly (real_of_int_poly q) x = 0)\n  poly (real_of_int_poly p) x = 0\n  map fst polys = qs\n  fst ` set polys = set qs\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       q \\<in> fst ` set polys \\<and> poly (real_of_int_poly q) x = 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>q. q \\<in> fst ` set polys \\<and> poly (real_of_int_poly q) x = 0\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "{"], ["proof (state)\nthis:\n  \\<exists>q. q \\<in> fst ` set polys \\<and> poly (real_of_int_poly q) x = 0\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "fix q ri"], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "assume \"(q,ri) \\<in> set polys\""], ["proof (state)\nthis:\n  (q, ri) \\<in> set polys\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "hence ri: \"ri = root_info q\" and q: \"q \\<in> set qs\""], ["proof (prove)\nusing this:\n  (q, ri) \\<in> set polys\n\ngoal (1 subgoal):\n 1. ri = root_info q &&& q \\<in> set qs", "unfolding polys_def"], ["proof (prove)\nusing this:\n  (q, ri) \\<in> set (map (\\<lambda>q. (q, root_info q)) qs)\n\ngoal (1 subgoal):\n 1. ri = root_info q &&& q \\<in> set qs", "by auto"], ["proof (state)\nthis:\n  ri = root_info q\n  q \\<in> set qs\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "from fact'(1)[OF q]"], ["proof (chain)\npicking this:\n  irreducible q \\<and>\n  0 < lead_coeff q \\<and> degree q \\<le> degree p \\<and> degree q \\<noteq> 0", "have *: \"lead_coeff q > 0\" \"irreducible q\" \"degree q > 0\""], ["proof (prove)\nusing this:\n  irreducible q \\<and>\n  0 < lead_coeff q \\<and> degree q \\<le> degree p \\<and> degree q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff q &&& irreducible q &&& 0 < degree q", "by auto"], ["proof (state)\nthis:\n  0 < lead_coeff q\n  irreducible q\n  0 < degree q\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "from *"], ["proof (chain)\npicking this:\n  0 < lead_coeff q\n  irreducible q\n  0 < degree q", "have q0: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < lead_coeff q\n  irreducible q\n  0 < degree q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "from root_info[OF *(2-3)] ri"], ["proof (chain)\npicking this:\n  root_info_cond (root_info q) q\n  ri = root_info q", "have ri: \"root_info_cond ri q\""], ["proof (prove)\nusing this:\n  root_info_cond (root_info q) q\n  ri = root_info q\n\ngoal (1 subgoal):\n 1. root_info_cond ri q", "by auto"], ["proof (state)\nthis:\n  root_info_cond ri q\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "note ri q0 *"], ["proof (state)\nthis:\n  root_info_cond ri q\n  q \\<noteq> 0\n  0 < lead_coeff q\n  irreducible q\n  0 < degree q\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "}"], ["proof (state)\nthis:\n  (?qa2, ?ria2) \\<in> set polys \\<Longrightarrow> root_info_cond ?ria2 ?qa2\n  (?qa2, ?ria2) \\<in> set polys \\<Longrightarrow> ?qa2 \\<noteq> 0\n  (?qa2, ?ria2) \\<in> set polys \\<Longrightarrow> 0 < lead_coeff ?qa2\n  (?qa2, ?ria2) \\<in> set polys \\<Longrightarrow> irreducible ?qa2\n  (?qa2, ?ria2) \\<in> set polys \\<Longrightarrow> 0 < degree ?qa2\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "note polys = this"], ["proof (state)\nthis:\n  (?qa2, ?ria2) \\<in> set polys \\<Longrightarrow> root_info_cond ?ria2 ?qa2\n  (?qa2, ?ria2) \\<in> set polys \\<Longrightarrow> ?qa2 \\<noteq> 0\n  (?qa2, ?ria2) \\<in> set polys \\<Longrightarrow> 0 < lead_coeff ?qa2\n  (?qa2, ?ria2) \\<in> set polys \\<Longrightarrow> irreducible ?qa2\n  (?qa2, ?ria2) \\<in> set polys \\<Longrightarrow> 0 < degree ?qa2\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "have \"unique_root (q, l, r) \\<and> (q, ri) \\<in> set polys \\<and> x = the_unique_root (q, l, r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n    (q, ri) \\<in> set polys \\<and> x = real_of_1 (q, l, r)", "by (rule select_correct_factor[OF conv res polys(1) _ ex dist, unfolded fst, OF _ _ fact'(3)[OF p]],\n    insert fact'(2)[OF p] polys(2), auto)"], ["proof (state)\nthis:\n  (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n  (q, ri) \\<in> set polys \\<and> x = real_of_1 (q, l, r)\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "hence ur: \"unique_root (q,l,r)\" and mem: \"(q,ri) \\<in> set polys\" and x: \"x = the_unique_root (q,l,r)\""], ["proof (prove)\nusing this:\n  (\\<exists>!x. root_cond (q, l, r) x) \\<and>\n  (q, ri) \\<in> set polys \\<and> x = real_of_1 (q, l, r)\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (q, l, r) x &&&\n    (q, ri) \\<in> set polys &&& x = real_of_1 (q, l, r)", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (q, l, r) x\n  (q, ri) \\<in> set polys\n  x = real_of_1 (q, l, r)\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "note polys = polys[OF mem]"], ["proof (state)\nthis:\n  root_info_cond ri q\n  q \\<noteq> 0\n  0 < lead_coeff q\n  irreducible q\n  0 < degree q\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "from polys(3-4)"], ["proof (chain)\npicking this:\n  0 < lead_coeff q\n  irreducible q", "have ty: \"poly_cond q\""], ["proof (prove)\nusing this:\n  0 < lead_coeff q\n  irreducible q\n\ngoal (1 subgoal):\n 1. poly_cond q", "by (simp add: poly_cond_def)"], ["proof (state)\nthis:\n  poly_cond q\n\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 rai \\<and> real_of_2 rai = x", "unfolding x rai[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2' ri q l r) \\<and>\n    real_of_2 (real_alg_2' ri q l r) = real_of_1 (q, l, r)", "by (intro real_alg_2' ur ty polys(1))"], ["proof (state)\nthis:\n  invariant_2 rai \\<and> real_of_2 rai = x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* ********************* *)"], ["", "subsubsection\\<open>Addition\\<close>"], ["", "lemma ipoly_0_0[simp]: \"ipoly f (0::'a::{comm_ring_1,ring_char_0}) = 0 \\<longleftrightarrow> poly f 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipoly f (0::'a) = (0::'a)) = (poly f 0 = 0)", "unfolding poly_0_coeff_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (coeff (of_int_poly f) 0 = (0::'a)) = (coeff f 0 = 0)", "by simp"], ["", "lemma add_rat_roots_below[simp]: \"roots_below (poly_add_rat r p) x = (\\<lambda>y. y + of_rat r) ` roots_below p (x - of_rat r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y \\<le> x \\<and> poly (real_of_int_poly (poly_add_rat r p)) y = 0} =\n    (\\<lambda>y. y + real_of_rat r) `\n    {y. y \\<le> x - real_of_rat r \\<and> poly (real_of_int_poly p) y = 0}", "proof (unfold add_rat_roots image_def, intro Collect_eqI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<le> x \\<and>\n        poly (real_of_int_poly p) (xa - real_of_rat r) = 0) =\n       (\\<exists>x\\<in>{y. y \\<le> x - real_of_rat r \\<and>\n                           poly (real_of_int_poly p) y = 0}.\n           xa = x + real_of_rat r)", "case (1 y)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<le> x \\<and>\n        poly (real_of_int_poly p) (xa - real_of_rat r) = 0) =\n       (\\<exists>x\\<in>{y. y \\<le> x - real_of_rat r \\<and>\n                           poly (real_of_int_poly p) y = 0}.\n           xa = x + real_of_rat r)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<le> x \\<and> poly (real_of_int_poly p) (y - real_of_rat r) = 0) =\n    (\\<exists>x\\<in>{y. y \\<le> x - real_of_rat r \\<and>\n                        poly (real_of_int_poly p) y = 0}.\n        y = x + real_of_rat r)", "by (auto intro: exI[of _ \"y - real_of_rat r\"])"], ["proof (state)\nthis:\n  (y \\<le> x \\<and> poly (real_of_int_poly p) (y - real_of_rat r) = 0) =\n  (\\<exists>x\\<in>{y. y \\<le> x - real_of_rat r \\<and>\n                      poly (real_of_int_poly p) y = 0}.\n      y = x + real_of_rat r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_rat_root_cond:\n  shows \"root_cond (cf_pos_poly (poly_add_rat m p),l,r) x = root_cond (p, l - m, r - m) (x - of_rat m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_cond (cf_pos_poly (poly_add_rat m p), l, r) x =\n    root_cond (p, l - m, r - m) (x - real_of_rat m)", "by (unfold root_cond_def, auto simp add: add_rat_roots hom_distribs)"], ["", "lemma add_rat_unique_root: \"unique_root (cf_pos_poly (poly_add_rat m p), l, r) = unique_root (p, l-m, r-m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (cf_pos_poly (poly_add_rat m p), l, r) x) =\n    (\\<exists>!x. root_cond (p, l - m, r - m) x)", "by (auto simp: add_rat_root_cond)"], ["", "fun add_rat_1 :: \"rat \\<Rightarrow> real_alg_1 \\<Rightarrow> real_alg_1\" where\n  \"add_rat_1 r1 (p2,l2,r2) = (\n    let p = cf_pos_poly (poly_add_rat r1 p2);\n      (l,r,sr) = tighten_poly_bounds_for_x p 0 (l2+r1) (r2+r1) (sgn (ipoly p (r2+r1)))\n    in\n    (p,l,r))\""], ["", "lemma poly_real_alg_1_add_rat[simp]:\n  \"poly_real_alg_1 (add_rat_1 r y) = cf_pos_poly (poly_add_rat r (poly_real_alg_1 y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_real_alg_1 (add_rat_1 r y) =\n    cf_pos_poly (poly_add_rat r (poly_real_alg_1 y))", "by (cases y, auto simp: Let_def split: prod.split)"], ["", "lemma sgn_cf_pos:\n  assumes \"lead_coeff p > 0\" shows \"sgn (ipoly (cf_pos_poly p) (x::'a::linordered_field)) = sgn (ipoly p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)", "with assms"], ["proof (chain)\npicking this:\n  0 < lead_coeff p\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < lead_coeff p\n  p = 0\n\ngoal (1 subgoal):\n 1. sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)", "by auto"], ["proof (state)\nthis:\n  sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)", "from cf_pos_poly_main False"], ["proof (chain)\npicking this:\n  Polynomial.smult (sgn (lead_coeff ?f) * content ?f) (cf_pos_poly ?f) = ?f\n  p \\<noteq> 0", "obtain d where p': \"Polynomial.smult d (cf_pos_poly p) = p\""], ["proof (prove)\nusing this:\n  Polynomial.smult (sgn (lead_coeff ?f) * content ?f) (cf_pos_poly ?f) = ?f\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        Polynomial.smult d (cf_pos_poly p) = p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult d (cf_pos_poly p) = p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)", "have \"d > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d", "proof (rule zero_less_mult_pos2)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < d * ?a\n 2. 0 < ?a", "from False assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  0 < lead_coeff p", "have \"0 < lead_coeff p\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff p", "by (auto simp: cf_pos_def)"], ["proof (state)\nthis:\n  0 < lead_coeff p\n\ngoal (2 subgoals):\n 1. 0 < d * ?a\n 2. 0 < ?a", "also"], ["proof (state)\nthis:\n  0 < lead_coeff p\n\ngoal (2 subgoals):\n 1. 0 < d * ?a\n 2. 0 < ?a", "from p'"], ["proof (chain)\npicking this:\n  Polynomial.smult d (cf_pos_poly p) = p", "have \"\\<dots> = d * lead_coeff (cf_pos_poly p)\""], ["proof (prove)\nusing this:\n  Polynomial.smult d (cf_pos_poly p) = p\n\ngoal (1 subgoal):\n 1. lead_coeff p = d * lead_coeff (cf_pos_poly p)", "by (metis lead_coeff_smult)"], ["proof (state)\nthis:\n  lead_coeff p = d * lead_coeff (cf_pos_poly p)\n\ngoal (2 subgoals):\n 1. 0 < d * ?a\n 2. 0 < ?a", "finally"], ["proof (chain)\npicking this:\n  0 < d * lead_coeff (cf_pos_poly p)", "show \"0 < \\<dots>\""], ["proof (prove)\nusing this:\n  0 < d * lead_coeff (cf_pos_poly p)\n\ngoal (1 subgoal):\n 1. 0 < d * lead_coeff (cf_pos_poly p)", "."], ["proof (state)\nthis:\n  0 < d * lead_coeff (cf_pos_poly p)\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff (cf_pos_poly p)", "show \"lead_coeff (cf_pos_poly p) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lead_coeff (cf_pos_poly p)", "using False"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff (cf_pos_poly p)", "by (unfold lead_coeff_cf_pos_poly)"], ["proof (state)\nthis:\n  0 < lead_coeff (cf_pos_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < d\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)", "moreover"], ["proof (state)\nthis:\n  0 < d\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)", "from p'"], ["proof (chain)\npicking this:\n  Polynomial.smult d (cf_pos_poly p) = p", "have \"ipoly p x = of_int d * ipoly (cf_pos_poly p) x\""], ["proof (prove)\nusing this:\n  Polynomial.smult d (cf_pos_poly p) = p\n\ngoal (1 subgoal):\n 1. ipoly p x = of_int d * ipoly (cf_pos_poly p) x", "by (fold poly_smult of_int_hom.map_poly_hom_smult, auto)"], ["proof (state)\nthis:\n  ipoly p x = of_int d * ipoly (cf_pos_poly p) x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)", "ultimately"], ["proof (chain)\npicking this:\n  0 < d\n  ipoly p x = of_int d * ipoly (cf_pos_poly p) x", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < d\n  ipoly p x = of_int d * ipoly (cf_pos_poly p) x\n\ngoal (1 subgoal):\n 1. sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)", "by (auto simp: sgn_mult[where 'a='a])"], ["proof (state)\nthis:\n  sgn (ipoly (cf_pos_poly p) x) = sgn (ipoly p x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_rat_1: fixes r1 :: rat assumes inv_y: \"invariant_1_2 y\"\n  defines \"z \\<equiv> add_rat_1 r1 y\"\n  shows \"invariant_1_2 z \\<and> (real_of_1 z = of_rat r1 + real_of_1 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1_2 z \\<and> real_of_1 z = real_of_rat r1 + real_of_1 y", "proof (cases y)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 z \\<and> real_of_1 z = real_of_rat r1 + real_of_1 y", "case y_def: (fields p2 l2 r2)"], ["proof (state)\nthis:\n  y = (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 z \\<and> real_of_1 z = real_of_rat r1 + real_of_1 y", "define p where \"p \\<equiv> cf_pos_poly (poly_add_rat r1 p2)\""], ["proof (state)\nthis:\n  p \\<equiv> cf_pos_poly (poly_add_rat r1 p2)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 z \\<and> real_of_1 z = real_of_rat r1 + real_of_1 y", "obtain l r sr where lr: \"tighten_poly_bounds_for_x p 0 (l2+r1) (r2+r1) (sgn (ipoly p (r2+r1))) = (l,r,sr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l r sr.\n        tighten_poly_bounds_for_x p 0 (l2 + r1) (r2 + r1)\n         (sgn (ipoly p (r2 + r1))) =\n        (l, r, sr) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  tighten_poly_bounds_for_x p 0 (l2 + r1) (r2 + r1)\n   (sgn (ipoly p (r2 + r1))) =\n  (l, r, sr)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 z \\<and> real_of_1 z = real_of_rat r1 + real_of_1 y", "from lr"], ["proof (chain)\npicking this:\n  tighten_poly_bounds_for_x p 0 (l2 + r1) (r2 + r1)\n   (sgn (ipoly p (r2 + r1))) =\n  (l, r, sr)", "have z: \"z = (p,l,r)\""], ["proof (prove)\nusing this:\n  tighten_poly_bounds_for_x p 0 (l2 + r1) (r2 + r1)\n   (sgn (ipoly p (r2 + r1))) =\n  (l, r, sr)\n\ngoal (1 subgoal):\n 1. z = (p, l, r)", "by (auto simp: y_def z_def p_def Let_def)"], ["proof (state)\nthis:\n  z = (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 z \\<and> real_of_1 z = real_of_rat r1 + real_of_1 y", "from inv_y"], ["proof (chain)\npicking this:\n  invariant_1_2 y", "have ur: \"unique_root (p, l2 + r1, r2 + r1)\""], ["proof (prove)\nusing this:\n  invariant_1_2 y\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, l2 + r1, r2 + r1) x", "by (auto simp: p_def add_rat_root_cond y_def add_rat_unique_root)"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, l2 + r1, r2 + r1) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 z \\<and> real_of_1 z = real_of_rat r1 + real_of_1 y", "from inv_y[unfolded y_def invariant_1_2_def,simplified]"], ["proof (chain)\npicking this:\n  invariant_1 (p2, l2, r2) \\<and> Suc 0 < degree p2", "have pc2: \"poly_cond2 p\""], ["proof (prove)\nusing this:\n  invariant_1 (p2, l2, r2) \\<and> Suc 0 < degree p2\n\ngoal (1 subgoal):\n 1. poly_cond2 p", "unfolding p_def"], ["proof (prove)\nusing this:\n  invariant_1 (p2, l2, r2) \\<and> Suc 0 < degree p2\n\ngoal (1 subgoal):\n 1. poly_cond2 (cf_pos_poly (poly_add_rat r1 p2))", "apply (intro poly_cond2I poly_add_rat_irreducible poly_condI, unfold lead_coeff_cf_pos_poly)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>invariant_1 (p2, l2, r2) \\<and> Suc 0 < degree p2;\n     invariant_1 (p2, l2, r2) \\<and> Suc 0 < degree p2\\<rbrakk>\n    \\<Longrightarrow> poly_add_rat r1 p2 \\<noteq> 0\n 2. \\<lbrakk>invariant_1 (p2, l2, r2) \\<and> Suc 0 < degree p2;\n     invariant_1 (p2, l2, r2) \\<and> Suc 0 < degree p2\\<rbrakk>\n    \\<Longrightarrow> irreducible p2\n 3. \\<lbrakk>invariant_1 (p2, l2, r2) \\<and> Suc 0 < degree p2;\n     invariant_1 (p2, l2, r2) \\<and> Suc 0 < degree p2\\<rbrakk>\n    \\<Longrightarrow> degree p2 \\<noteq> 0\n 4. \\<lbrakk>invariant_1 (p2, l2, r2) \\<and> Suc 0 < degree p2;\n     invariant_1 (p2, l2, r2) \\<and> Suc 0 < degree p2\\<rbrakk>\n    \\<Longrightarrow> 1 < degree (cf_pos_poly (poly_add_rat r1 p2))", "apply (auto elim!: invariant_1E)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 z \\<and> real_of_1 z = real_of_rat r1 + real_of_1 y", "note main = tighten_poly_bounds_for_x[OF ur pc2 lr refl, simplified]"], ["proof (state)\nthis:\n  l2 + r1 \\<le> l\n  l \\<le> r\n  r \\<le> r2 + r1\n  root_cond (p, l, r) (real_of_1 (p, l2 + r1, r2 + r1))\n  l \\<le> 0 \\<longrightarrow> \\<not> 0 \\<le> r\n  sr = sgn (ipoly p r)\n  \\<exists>!x. root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 z \\<and> real_of_1 z = real_of_rat r1 + real_of_1 y", "then"], ["proof (chain)\npicking this:\n  l2 + r1 \\<le> l\n  l \\<le> r\n  r \\<le> r2 + r1\n  root_cond (p, l, r) (real_of_1 (p, l2 + r1, r2 + r1))\n  l \\<le> 0 \\<longrightarrow> \\<not> 0 \\<le> r\n  sr = sgn (ipoly p r)\n  \\<exists>!x. root_cond (p, l, r) x", "have \"sgn l = sgn r\""], ["proof (prove)\nusing this:\n  l2 + r1 \\<le> l\n  l \\<le> r\n  r \\<le> r2 + r1\n  root_cond (p, l, r) (real_of_1 (p, l2 + r1, r2 + r1))\n  l \\<le> 0 \\<longrightarrow> \\<not> 0 \\<le> r\n  sr = sgn (ipoly p r)\n  \\<exists>!x. root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. sgn l = sgn r", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  l2 + r1 \\<le> l\n  l \\<le> r\n  r \\<le> r2 + r1\n  root_cond (p, l, r) (real_of_1 (p, l2 + r1, r2 + r1))\n  l \\<le> 0 \\<longrightarrow> \\<not> 0 \\<le> r\n  sr = (if ipoly p r = 0 then 0 else if 0 < ipoly p r then 1 else - 1)\n  \\<exists>!x. root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. (if l = 0 then 0 else if 0 < l then 1 else - 1) =\n    (if r = 0 then 0 else if 0 < r then 1 else - 1)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l2 + r1 \\<le> l; l \\<le> r; r \\<le> r2 + r1;\n     root_cond (p, l, r) (real_of_1 (p, l2 + r1, r2 + r1));\n     l \\<le> 0 \\<longrightarrow> \\<not> 0 \\<le> r;\n     sr = (if ipoly p r = 0 then 0 else if 0 < ipoly p r then 1 else - 1);\n     \\<exists>!x. root_cond (p, l, r) x\\<rbrakk>\n    \\<Longrightarrow> \\<not> 0 < l \\<longrightarrow>\n                      (l = 0 \\<longrightarrow> \\<not> 0 < r) \\<and>\n                      (l \\<noteq> 0 \\<longrightarrow>\n                       \\<not> 0 < r \\<and>\n                       (\\<not> 0 < r \\<longrightarrow> r \\<noteq> 0))", "apply linarith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sgn l = sgn r\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_1_2 z \\<and> real_of_1 z = real_of_rat r1 + real_of_1 y", "from invariant_1_2_realI[OF main(4) _ main(7), simplified, OF this pc2] main(1-3) ur"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l, r) \\<and>\n  real_of_1 (p, l, r) = real_of_1 (p, l2 + r1, r2 + r1)\n  l2 + r1 \\<le> l\n  l \\<le> r\n  r \\<le> r2 + r1\n  \\<exists>!x. root_cond (p, l2 + r1, r2 + r1) x", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r) \\<and>\n  real_of_1 (p, l, r) = real_of_1 (p, l2 + r1, r2 + r1)\n  l2 + r1 \\<le> l\n  l \\<le> r\n  r \\<le> r2 + r1\n  \\<exists>!x. root_cond (p, l2 + r1, r2 + r1) x\n\ngoal (1 subgoal):\n 1. invariant_1_2 z \\<and> real_of_1 z = real_of_rat r1 + real_of_1 y", "by (auto simp: z p_def y_def add_rat_root_cond ex1_the_shift)"], ["proof (state)\nthis:\n  invariant_1_2 z \\<and> real_of_1 z = real_of_rat r1 + real_of_1 y\n\ngoal:\nNo subgoals!", "qed"], ["", "fun tighten_poly_bounds_binary :: \"int poly \\<Rightarrow> int poly \\<Rightarrow> (rat \\<times> rat \\<times> rat) \\<times> rat \\<times> rat \\<times> rat \\<Rightarrow> (rat \\<times> rat \\<times> rat) \\<times> rat \\<times> rat \\<times> rat\"  where\n  \"tighten_poly_bounds_binary cr1 cr2 ((l1,r1,sr1),(l2,r2,sr2)) = \n     (tighten_poly_bounds cr1 l1 r1 sr1, tighten_poly_bounds cr2 l2 r2 sr2)\""], ["", "lemma tighten_poly_bounds_binary:\n  assumes ur: \"unique_root (p1,l1,r1)\" \"unique_root (p2,l2,r2)\" and pt: \"poly_cond2 p1\" \"poly_cond2 p2\" \n  defines \"x \\<equiv> the_unique_root (p1,l1,r1)\" and \"y \\<equiv> the_unique_root (p2,l2,r2)\"\n  assumes bnd: \"\\<And> l1 r1 l2 r2 l r sr1 sr2. I l1 \\<Longrightarrow> I l2 \\<Longrightarrow> root_cond (p1,l1,r1) x \\<Longrightarrow> root_cond (p2,l2,r2) y \\<Longrightarrow>\n      bnd ((l1,r1,sr1),(l2,r2,sr2)) = (l,r) \\<Longrightarrow> of_rat l \\<le> f x y \\<and> f x y \\<le> of_rat r\"\n  and approx: \"\\<And> l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'. \n    I l1 \\<Longrightarrow> I l2 \\<Longrightarrow>\n    l1 \\<le> r1 \\<Longrightarrow> l2 \\<le> r2 \\<Longrightarrow> \n    (l,r) = bnd ((l1,r1,sr1), (l2,r2,sr2)) \\<Longrightarrow>\n    (l',r') = bnd ((l1',r1',sr1'), (l2',r2',sr2')) \\<Longrightarrow>\n    (l1',r1') \\<in> {(l1,(l1+r1)/2),((l1+r1)/2,r1)} \\<Longrightarrow>\n    (l2',r2') \\<in> {(l2,(l2+r2)/2),((l2+r2)/2,r2)} \\<Longrightarrow>\n    (r' - l') \\<le> 3/4 * (r - l) \\<and> l \\<le> l' \\<and> r' \\<le> r\"\n  and I_mono: \"\\<And> l l'. I l \\<Longrightarrow> l \\<le> l' \\<Longrightarrow> I l'\"\n  and I: \"I l1\" \"I l2\" \n  and sr: \"sr1 = sgn (ipoly p1 r1)\" \"sr2 = sgn (ipoly p2 r2)\"\n  shows \"converges_to (\\<lambda> i. bnd ((tighten_poly_bounds_binary p1 p2 ^^ i) ((l1,r1,sr1),(l2,r2,sr2))))\n     (f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "let ?upd = \"tighten_poly_bounds_binary p1 p2\""], ["proof (state)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "define upd where \"upd = ?upd\""], ["proof (state)\nthis:\n  upd = tighten_poly_bounds_binary p1 p2\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "define init where \"init = ((l1, r1, sr1), l2, r2, sr2)\""], ["proof (state)\nthis:\n  init = ((l1, r1, sr1), l2, r2, sr2)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "let ?g = \"(\\<lambda>i. bnd ((upd ^^ i) init))\""], ["proof (state)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "obtain l r where bnd_init: \"bnd init = (l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l r.\n        bnd init = (l, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  bnd init = (l, r)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "note ur1 = unique_rootD[OF ur(1)]"], ["proof (state)\nthis:\n  real_of_rat (rai_lb (p1, l1, r1)) \\<le> real_of_1 (p1, l1, r1)\n  real_of_1 (p1, l1, r1) \\<le> real_of_rat (rai_ub (p1, l1, r1))\n  poly (real_of_int_poly (poly_real_alg_1 (p1, l1, r1)))\n   (real_of_1 (p1, l1, r1)) =\n  0\n  root_cond (p1, l1, r1) (real_of_1 (p1, l1, r1))\n  (real_of_1 (p1, l1, r1) = ?y) = root_cond (p1, l1, r1) ?y\n  (?y = real_of_1 (p1, l1, r1)) = root_cond (p1, l1, r1) ?y\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "note ur2 = unique_rootD[OF ur(2)]"], ["proof (state)\nthis:\n  real_of_rat (rai_lb (p2, l2, r2)) \\<le> real_of_1 (p2, l2, r2)\n  real_of_1 (p2, l2, r2) \\<le> real_of_rat (rai_ub (p2, l2, r2))\n  poly (real_of_int_poly (poly_real_alg_1 (p2, l2, r2)))\n   (real_of_1 (p2, l2, r2)) =\n  0\n  root_cond (p2, l2, r2) (real_of_1 (p2, l2, r2))\n  (real_of_1 (p2, l2, r2) = ?y) = root_cond (p2, l2, r2) ?y\n  (?y = real_of_1 (p2, l2, r2)) = root_cond (p2, l2, r2) ?y\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "from ur1(4) ur2(4) x_def y_def"], ["proof (chain)\npicking this:\n  root_cond (p1, l1, r1) (real_of_1 (p1, l1, r1))\n  root_cond (p2, l2, r2) (real_of_1 (p2, l2, r2))\n  x \\<equiv> real_of_1 (p1, l1, r1)\n  y \\<equiv> real_of_1 (p2, l2, r2)", "have rc1: \"root_cond (p1,l1,r1) x\" and rc2: \"root_cond (p2,l2,r2) y\""], ["proof (prove)\nusing this:\n  root_cond (p1, l1, r1) (real_of_1 (p1, l1, r1))\n  root_cond (p2, l2, r2) (real_of_1 (p2, l2, r2))\n  x \\<equiv> real_of_1 (p1, l1, r1)\n  y \\<equiv> real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. root_cond (p1, l1, r1) x &&& root_cond (p2, l2, r2) y", "by auto"], ["proof (state)\nthis:\n  root_cond (p1, l1, r1) x\n  root_cond (p2, l2, r2) y\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "define g where \"g = ?g\""], ["proof (state)\nthis:\n  g = (\\<lambda>i. bnd ((upd ^^ i) init))\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "{"], ["proof (state)\nthis:\n  g = (\\<lambda>i. bnd ((upd ^^ i) init))\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "fix i L1 R1 L2 R2 L R j SR1 SR2"], ["proof (state)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "assume \"((upd ^^ i)) init = ((L1,R1,SR1),(L2,R2,SR2))\" \"g i = (L,R)\""], ["proof (state)\nthis:\n  (upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2)\n  g i = (L, R)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "hence \"I L1 \\<and> I L2 \\<and> root_cond (p1,L1,R1) x \\<and> root_cond (p2,L2,R2) y \\<and>\n      unique_root (p1, L1, R1) \\<and> unique_root (p2, L2, R2) \\<and> in_interval (L,R) (f x y) \\<and> \n      (i = Suc j \\<longrightarrow> sub_interval (g i) (g j) \\<and> (R - L \\<le> 3/4 * (snd (g j) - fst (g j))))\n      \\<and> SR1 = sgn (ipoly p1 R1) \\<and> SR2 = sgn (ipoly p2 R2)\""], ["proof (prove)\nusing this:\n  (upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2)\n  g i = (L, R)\n\ngoal (1 subgoal):\n 1. I L1 \\<and>\n    I L2 \\<and>\n    root_cond (p1, L1, R1) x \\<and>\n    root_cond (p2, L2, R2) y \\<and>\n    (\\<exists>!x. root_cond (p1, L1, R1) x) \\<and>\n    (\\<exists>!x. root_cond (p2, L2, R2) x) \\<and>\n    in_interval (L, R) (f x y) \\<and>\n    (i = Suc j \\<longrightarrow>\n     sub_interval (g i) (g j) \\<and>\n     R - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n    SR1 = sgn (ipoly p1 R1) \\<and> SR2 = sgn (ipoly p2 R2)", "proof (induct i arbitrary: L1 R1 L2 R2 L R j SR1 SR2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>(upd ^^ 0) init = ((L1, R1, SR1), L2, R2, SR2);\n        g 0 = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (0 = Suc j \\<longrightarrow>\n                          sub_interval (g 0) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)\n 2. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "case 0"], ["proof (state)\nthis:\n  (upd ^^ 0) init = ((L1, R1, SR1), L2, R2, SR2)\n  g 0 = (L, R)\n\ngoal (2 subgoals):\n 1. \\<And>L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>(upd ^^ 0) init = ((L1, R1, SR1), L2, R2, SR2);\n        g 0 = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (0 = Suc j \\<longrightarrow>\n                          sub_interval (g 0) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)\n 2. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "thus ?case"], ["proof (prove)\nusing this:\n  (upd ^^ 0) init = ((L1, R1, SR1), L2, R2, SR2)\n  g 0 = (L, R)\n\ngoal (1 subgoal):\n 1. I L1 \\<and>\n    I L2 \\<and>\n    root_cond (p1, L1, R1) x \\<and>\n    root_cond (p2, L2, R2) y \\<and>\n    (\\<exists>!a. root_cond (p1, L1, R1) a) \\<and>\n    (\\<exists>!a. root_cond (p2, L2, R2) a) \\<and>\n    in_interval (L, R) (f x y) \\<and>\n    (0 = Suc j \\<longrightarrow>\n     sub_interval (g 0) (g j) \\<and>\n     R - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n    SR1 = sgn (ipoly p1 R1) \\<and> SR2 = sgn (ipoly p2 R2)", "using I rc1 rc2 ur bnd[of l1 l2 r1 r2 sr1 sr2 L R] g_def sr"], ["proof (prove)\nusing this:\n  (upd ^^ 0) init = ((L1, R1, SR1), L2, R2, SR2)\n  g 0 = (L, R)\n  I l1\n  I l2\n  root_cond (p1, l1, r1) x\n  root_cond (p2, l2, r2) y\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  \\<lbrakk>I l1; I l2; root_cond (p1, l1, r1) x; root_cond (p2, l2, r2) y;\n   bnd ((l1, r1, sr1), l2, r2, sr2) = (L, R)\\<rbrakk>\n  \\<Longrightarrow> real_of_rat L \\<le> f x y \\<and>\n                    f x y \\<le> real_of_rat R\n  g = (\\<lambda>i. bnd ((upd ^^ i) init))\n  sr1 = sgn (ipoly p1 r1)\n  sr2 = sgn (ipoly p2 r2)\n\ngoal (1 subgoal):\n 1. I L1 \\<and>\n    I L2 \\<and>\n    root_cond (p1, L1, R1) x \\<and>\n    root_cond (p2, L2, R2) y \\<and>\n    (\\<exists>!a. root_cond (p1, L1, R1) a) \\<and>\n    (\\<exists>!a. root_cond (p2, L2, R2) a) \\<and>\n    in_interval (L, R) (f x y) \\<and>\n    (0 = Suc j \\<longrightarrow>\n     sub_interval (g 0) (g j) \\<and>\n     R - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n    SR1 = sgn (ipoly p1 R1) \\<and> SR2 = sgn (ipoly p2 R2)", "unfolding init_def"], ["proof (prove)\nusing this:\n  (upd ^^ 0) ((l1, r1, sr1), l2, r2, sr2) = ((L1, R1, SR1), L2, R2, SR2)\n  g 0 = (L, R)\n  I l1\n  I l2\n  root_cond (p1, l1, r1) x\n  root_cond (p2, l2, r2) y\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  \\<lbrakk>I l1; I l2; root_cond (p1, l1, r1) x; root_cond (p2, l2, r2) y;\n   bnd ((l1, r1, sr1), l2, r2, sr2) = (L, R)\\<rbrakk>\n  \\<Longrightarrow> real_of_rat L \\<le> f x y \\<and>\n                    f x y \\<le> real_of_rat R\n  g = (\\<lambda>i. bnd ((upd ^^ i) ((l1, r1, sr1), l2, r2, sr2)))\n  sr1 = sgn (ipoly p1 r1)\n  sr2 = sgn (ipoly p2 r2)\n\ngoal (1 subgoal):\n 1. I L1 \\<and>\n    I L2 \\<and>\n    root_cond (p1, L1, R1) x \\<and>\n    root_cond (p2, L2, R2) y \\<and>\n    (\\<exists>!a. root_cond (p1, L1, R1) a) \\<and>\n    (\\<exists>!a. root_cond (p2, L2, R2) a) \\<and>\n    in_interval (L, R) (f x y) \\<and>\n    (0 = Suc j \\<longrightarrow>\n     sub_interval (g 0) (g j) \\<and>\n     R - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n    SR1 = sgn (ipoly p1 R1) \\<and> SR2 = sgn (ipoly p2 R2)", "by auto"], ["proof (state)\nthis:\n  I L1 \\<and>\n  I L2 \\<and>\n  root_cond (p1, L1, R1) x \\<and>\n  root_cond (p2, L2, R2) y \\<and>\n  (\\<exists>!a. root_cond (p1, L1, R1) a) \\<and>\n  (\\<exists>!a. root_cond (p2, L2, R2) a) \\<and>\n  in_interval (L, R) (f x y) \\<and>\n  (0 = Suc j \\<longrightarrow>\n   sub_interval (g 0) (g j) \\<and>\n   R - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n  SR1 = sgn (ipoly p1 R1) \\<and> SR2 = sgn (ipoly p2 R2)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "case (Suc i)"], ["proof (state)\nthis:\n  \\<lbrakk>(upd ^^ i) init = ((?L1.0, ?R1.0, ?SR1.0), ?L2.0, ?R2.0, ?SR2.0);\n   g i = (?L, ?R)\\<rbrakk>\n  \\<Longrightarrow> I ?L1.0 \\<and>\n                    I ?L2.0 \\<and>\n                    root_cond (p1, ?L1.0, ?R1.0) x \\<and>\n                    root_cond (p2, ?L2.0, ?R2.0) y \\<and>\n                    (\\<exists>!a. root_cond (p1, ?L1.0, ?R1.0) a) \\<and>\n                    (\\<exists>!a. root_cond (p2, ?L2.0, ?R2.0) a) \\<and>\n                    in_interval (?L, ?R) (f x y) \\<and>\n                    (i = Suc ?j \\<longrightarrow>\n                     sub_interval (g i) (g ?j) \\<and>\n                     ?R - ?L \\<le> 3 / 4 * (snd (g ?j) - fst (g ?j))) \\<and>\n                    ?SR1.0 = sgn (ipoly p1 ?R1.0) \\<and>\n                    ?SR2.0 = sgn (ipoly p2 ?R2.0)\n  (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2)\n  g (Suc i) = (L, R)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "obtain l1 r1 l2 r2 sr1 sr2 where updi: \"(upd ^^ i) init = ((l1, r1, sr1), l2, r2, sr2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l1 r1 sr1 l2 r2 sr2.\n        (upd ^^ i) init = ((l1, r1, sr1), l2, r2, sr2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"(upd ^^ i) init\", auto)"], ["proof (state)\nthis:\n  (upd ^^ i) init = ((l1, r1, sr1), l2, r2, sr2)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "obtain l r where bndi: \"bnd ((l1, r1, sr1), l2, r2, sr2) = (l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l r.\n        bnd ((l1, r1, sr1), l2, r2, sr2) = (l, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  bnd ((l1, r1, sr1), l2, r2, sr2) = (l, r)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "hence gi: \"g i = (l,r)\""], ["proof (prove)\nusing this:\n  bnd ((l1, r1, sr1), l2, r2, sr2) = (l, r)\n\ngoal (1 subgoal):\n 1. g i = (l, r)", "using updi"], ["proof (prove)\nusing this:\n  bnd ((l1, r1, sr1), l2, r2, sr2) = (l, r)\n  (upd ^^ i) init = ((l1, r1, sr1), l2, r2, sr2)\n\ngoal (1 subgoal):\n 1. g i = (l, r)", "unfolding g_def"], ["proof (prove)\nusing this:\n  bnd ((l1, r1, sr1), l2, r2, sr2) = (l, r)\n  (upd ^^ i) init = ((l1, r1, sr1), l2, r2, sr2)\n\ngoal (1 subgoal):\n 1. bnd ((upd ^^ i) init) = (l, r)", "by auto"], ["proof (state)\nthis:\n  g i = (l, r)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "have \"(upd ^^ Suc i) init = upd ((l1, r1, sr1), l2, r2, sr2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (upd ^^ Suc i) init = upd ((l1, r1, sr1), l2, r2, sr2)", "using updi"], ["proof (prove)\nusing this:\n  (upd ^^ i) init = ((l1, r1, sr1), l2, r2, sr2)\n\ngoal (1 subgoal):\n 1. (upd ^^ Suc i) init = upd ((l1, r1, sr1), l2, r2, sr2)", "by simp"], ["proof (state)\nthis:\n  (upd ^^ Suc i) init = upd ((l1, r1, sr1), l2, r2, sr2)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from Suc(2)[unfolded this]"], ["proof (chain)\npicking this:\n  upd ((l1, r1, sr1), l2, r2, sr2) = ((L1, R1, SR1), L2, R2, SR2)", "have upd: \"upd ((l1, r1, sr1), l2, r2, sr2) = ((L1, R1, SR1), L2, R2, SR2)\""], ["proof (prove)\nusing this:\n  upd ((l1, r1, sr1), l2, r2, sr2) = ((L1, R1, SR1), L2, R2, SR2)\n\ngoal (1 subgoal):\n 1. upd ((l1, r1, sr1), l2, r2, sr2) = ((L1, R1, SR1), L2, R2, SR2)", "."], ["proof (state)\nthis:\n  upd ((l1, r1, sr1), l2, r2, sr2) = ((L1, R1, SR1), L2, R2, SR2)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from upd updi Suc(3)"], ["proof (chain)\npicking this:\n  upd ((l1, r1, sr1), l2, r2, sr2) = ((L1, R1, SR1), L2, R2, SR2)\n  (upd ^^ i) init = ((l1, r1, sr1), l2, r2, sr2)\n  g (Suc i) = (L, R)", "have bndsi: \"bnd ((L1, R1, SR1), L2, R2, SR2) = (L,R)\""], ["proof (prove)\nusing this:\n  upd ((l1, r1, sr1), l2, r2, sr2) = ((L1, R1, SR1), L2, R2, SR2)\n  (upd ^^ i) init = ((l1, r1, sr1), l2, r2, sr2)\n  g (Suc i) = (L, R)\n\ngoal (1 subgoal):\n 1. bnd ((L1, R1, SR1), L2, R2, SR2) = (L, R)", "by (auto simp: g_def)"], ["proof (state)\nthis:\n  bnd ((L1, R1, SR1), L2, R2, SR2) = (L, R)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from Suc(1)[OF updi gi]"], ["proof (chain)\npicking this:\n  I l1 \\<and>\n  I l2 \\<and>\n  root_cond (p1, l1, r1) x \\<and>\n  root_cond (p2, l2, r2) y \\<and>\n  (\\<exists>!a. root_cond (p1, l1, r1) a) \\<and>\n  (\\<exists>!a. root_cond (p2, l2, r2) a) \\<and>\n  in_interval (l, r) (f x y) \\<and>\n  (i = Suc ?j \\<longrightarrow>\n   sub_interval (g i) (g ?j) \\<and>\n   r - l \\<le> 3 / 4 * (snd (g ?j) - fst (g ?j))) \\<and>\n  sr1 = sgn (ipoly p1 r1) \\<and> sr2 = sgn (ipoly p2 r2)", "have I: \"I l1\" \"I l2\" \n        and rc: \"root_cond (p1,l1,r1) x\" \"root_cond (p2,l2,r2) y\"\n        and ur: \"unique_root (p1, l1, r1)\" \"unique_root (p2, l2, r2)\"\n        and sr: \"sr1 = sgn (ipoly p1 r1)\" \"sr2 = sgn (ipoly p2 r2)\""], ["proof (prove)\nusing this:\n  I l1 \\<and>\n  I l2 \\<and>\n  root_cond (p1, l1, r1) x \\<and>\n  root_cond (p2, l2, r2) y \\<and>\n  (\\<exists>!a. root_cond (p1, l1, r1) a) \\<and>\n  (\\<exists>!a. root_cond (p2, l2, r2) a) \\<and>\n  in_interval (l, r) (f x y) \\<and>\n  (i = Suc ?j \\<longrightarrow>\n   sub_interval (g i) (g ?j) \\<and>\n   r - l \\<le> 3 / 4 * (snd (g ?j) - fst (g ?j))) \\<and>\n  sr1 = sgn (ipoly p1 r1) \\<and> sr2 = sgn (ipoly p2 r2)\n\ngoal (1 subgoal):\n 1. ((I l1 &&& I l2) &&&\n     root_cond (p1, l1, r1) x &&& root_cond (p2, l2, r2) y) &&&\n    (\\<exists>!x. root_cond (p1, l1, r1) x &&&\n     \\<exists>!x. root_cond (p2, l2, r2) x) &&&\n    sr1 = sgn (ipoly p1 r1) &&& sr2 = sgn (ipoly p2 r2)", "by auto"], ["proof (state)\nthis:\n  I l1\n  I l2\n  root_cond (p1, l1, r1) x\n  root_cond (p2, l2, r2) y\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  sr1 = sgn (ipoly p1 r1)\n  sr2 = sgn (ipoly p2 r2)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from upd[unfolded upd_def]"], ["proof (chain)\npicking this:\n  tighten_poly_bounds_binary p1 p2 ((l1, r1, sr1), l2, r2, sr2) =\n  ((L1, R1, SR1), L2, R2, SR2)", "have tight: \"tighten_poly_bounds p1 l1 r1 sr1 = (L1, R1, SR1)\" \"tighten_poly_bounds p2 l2 r2 sr2 = (L2, R2, SR2)\""], ["proof (prove)\nusing this:\n  tighten_poly_bounds_binary p1 p2 ((l1, r1, sr1), l2, r2, sr2) =\n  ((L1, R1, SR1), L2, R2, SR2)\n\ngoal (1 subgoal):\n 1. tighten_poly_bounds p1 l1 r1 sr1 = (L1, R1, SR1) &&&\n    tighten_poly_bounds p2 l2 r2 sr2 = (L2, R2, SR2)", "by auto"], ["proof (state)\nthis:\n  tighten_poly_bounds p1 l1 r1 sr1 = (L1, R1, SR1)\n  tighten_poly_bounds p2 l2 r2 sr2 = (L2, R2, SR2)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "note tight1 = tighten_poly_bounds[OF tight(1) ur(1) pt(1) sr(1)]"], ["proof (state)\nthis:\n  root_cond (p1, L1, R1) (real_of_1 (p1, l1, r1))\n  l1 \\<le> L1\n  L1 \\<le> R1\n  R1 \\<le> r1\n  R1 - L1 = (r1 - l1) / 2\n  SR1 = sgn (ipoly p1 R1)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "note tight2 = tighten_poly_bounds[OF tight(2) ur(2) pt(2) sr(2)]"], ["proof (state)\nthis:\n  root_cond (p2, L2, R2) (real_of_1 (p2, l2, r2))\n  l2 \\<le> L2\n  L2 \\<le> R2\n  R2 \\<le> r2\n  R2 - L2 = (r2 - l2) / 2\n  SR2 = sgn (ipoly p2 R2)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from tight1"], ["proof (chain)\npicking this:\n  root_cond (p1, L1, R1) (real_of_1 (p1, l1, r1))\n  l1 \\<le> L1\n  L1 \\<le> R1\n  R1 \\<le> r1\n  R1 - L1 = (r1 - l1) / 2\n  SR1 = sgn (ipoly p1 R1)", "have lr1: \"l1 \\<le> r1\""], ["proof (prove)\nusing this:\n  root_cond (p1, L1, R1) (real_of_1 (p1, l1, r1))\n  l1 \\<le> L1\n  L1 \\<le> R1\n  R1 \\<le> r1\n  R1 - L1 = (r1 - l1) / 2\n  SR1 = sgn (ipoly p1 R1)\n\ngoal (1 subgoal):\n 1. l1 \\<le> r1", "by auto"], ["proof (state)\nthis:\n  l1 \\<le> r1\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from tight2"], ["proof (chain)\npicking this:\n  root_cond (p2, L2, R2) (real_of_1 (p2, l2, r2))\n  l2 \\<le> L2\n  L2 \\<le> R2\n  R2 \\<le> r2\n  R2 - L2 = (r2 - l2) / 2\n  SR2 = sgn (ipoly p2 R2)", "have lr2: \"l2 \\<le> r2\""], ["proof (prove)\nusing this:\n  root_cond (p2, L2, R2) (real_of_1 (p2, l2, r2))\n  l2 \\<le> L2\n  L2 \\<le> R2\n  R2 \\<le> r2\n  R2 - L2 = (r2 - l2) / 2\n  SR2 = sgn (ipoly p2 R2)\n\ngoal (1 subgoal):\n 1. l2 \\<le> r2", "by auto"], ["proof (state)\nthis:\n  l2 \\<le> r2\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "note ur1 = unique_rootD[OF ur(1)]"], ["proof (state)\nthis:\n  real_of_rat (rai_lb (p1, l1, r1)) \\<le> real_of_1 (p1, l1, r1)\n  real_of_1 (p1, l1, r1) \\<le> real_of_rat (rai_ub (p1, l1, r1))\n  poly (real_of_int_poly (poly_real_alg_1 (p1, l1, r1)))\n   (real_of_1 (p1, l1, r1)) =\n  0\n  root_cond (p1, l1, r1) (real_of_1 (p1, l1, r1))\n  (real_of_1 (p1, l1, r1) = ?y) = root_cond (p1, l1, r1) ?y\n  (?y = real_of_1 (p1, l1, r1)) = root_cond (p1, l1, r1) ?y\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "note ur2 = unique_rootD[OF ur(2)]"], ["proof (state)\nthis:\n  real_of_rat (rai_lb (p2, l2, r2)) \\<le> real_of_1 (p2, l2, r2)\n  real_of_1 (p2, l2, r2) \\<le> real_of_rat (rai_ub (p2, l2, r2))\n  poly (real_of_int_poly (poly_real_alg_1 (p2, l2, r2)))\n   (real_of_1 (p2, l2, r2)) =\n  0\n  root_cond (p2, l2, r2) (real_of_1 (p2, l2, r2))\n  (real_of_1 (p2, l2, r2) = ?y) = root_cond (p2, l2, r2) ?y\n  (?y = real_of_1 (p2, l2, r2)) = root_cond (p2, l2, r2) ?y\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from tight1 I_mono[OF I(1)]"], ["proof (chain)\npicking this:\n  root_cond (p1, L1, R1) (real_of_1 (p1, l1, r1))\n  l1 \\<le> L1\n  L1 \\<le> R1\n  R1 \\<le> r1\n  R1 - L1 = (r1 - l1) / 2\n  SR1 = sgn (ipoly p1 R1)\n  l1 \\<le> ?l' \\<Longrightarrow> I ?l'", "have I1: \"I L1\""], ["proof (prove)\nusing this:\n  root_cond (p1, L1, R1) (real_of_1 (p1, l1, r1))\n  l1 \\<le> L1\n  L1 \\<le> R1\n  R1 \\<le> r1\n  R1 - L1 = (r1 - l1) / 2\n  SR1 = sgn (ipoly p1 R1)\n  l1 \\<le> ?l' \\<Longrightarrow> I ?l'\n\ngoal (1 subgoal):\n 1. I L1", "by auto"], ["proof (state)\nthis:\n  I L1\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from tight2 I_mono[OF I(2)]"], ["proof (chain)\npicking this:\n  root_cond (p2, L2, R2) (real_of_1 (p2, l2, r2))\n  l2 \\<le> L2\n  L2 \\<le> R2\n  R2 \\<le> r2\n  R2 - L2 = (r2 - l2) / 2\n  SR2 = sgn (ipoly p2 R2)\n  l2 \\<le> ?l' \\<Longrightarrow> I ?l'", "have I2: \"I L2\""], ["proof (prove)\nusing this:\n  root_cond (p2, L2, R2) (real_of_1 (p2, l2, r2))\n  l2 \\<le> L2\n  L2 \\<le> R2\n  R2 \\<le> r2\n  R2 - L2 = (r2 - l2) / 2\n  SR2 = sgn (ipoly p2 R2)\n  l2 \\<le> ?l' \\<Longrightarrow> I ?l'\n\ngoal (1 subgoal):\n 1. I L2", "by auto"], ["proof (state)\nthis:\n  I L2\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "note ur1 = unique_root_sub_interval[OF ur(1) tight1(1,2,4)]"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p1, L1, R1) x\n  real_of_1 (p1, L1, R1) = real_of_1 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "note ur2 = unique_root_sub_interval[OF ur(2) tight2(1,2,4)]"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p2, L2, R2) x\n  real_of_1 (p2, L2, R2) = real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from rc(1) ur ur1"], ["proof (chain)\npicking this:\n  root_cond (p1, l1, r1) x\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  \\<exists>!x. root_cond (p1, L1, R1) x\n  real_of_1 (p1, L1, R1) = real_of_1 (p1, l1, r1)", "have x: \"x = the_unique_root (p1,L1,R1)\""], ["proof (prove)\nusing this:\n  root_cond (p1, l1, r1) x\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  \\<exists>!x. root_cond (p1, L1, R1) x\n  real_of_1 (p1, L1, R1) = real_of_1 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. x = real_of_1 (p1, L1, R1)", "by (auto intro!:the_unique_root_eqI)"], ["proof (state)\nthis:\n  x = real_of_1 (p1, L1, R1)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from rc(2) ur ur2"], ["proof (chain)\npicking this:\n  root_cond (p2, l2, r2) y\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  \\<exists>!x. root_cond (p2, L2, R2) x\n  real_of_1 (p2, L2, R2) = real_of_1 (p2, l2, r2)", "have y: \"y = the_unique_root (p2,L2,R2)\""], ["proof (prove)\nusing this:\n  root_cond (p2, l2, r2) y\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  \\<exists>!x. root_cond (p2, L2, R2) x\n  real_of_1 (p2, L2, R2) = real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. y = real_of_1 (p2, L2, R2)", "by (auto intro!:the_unique_root_eqI)"], ["proof (state)\nthis:\n  y = real_of_1 (p2, L2, R2)\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from unique_rootD[OF ur1(1)] x"], ["proof (chain)\npicking this:\n  real_of_rat (rai_lb (p1, L1, R1)) \\<le> real_of_1 (p1, L1, R1)\n  real_of_1 (p1, L1, R1) \\<le> real_of_rat (rai_ub (p1, L1, R1))\n  poly (real_of_int_poly (poly_real_alg_1 (p1, L1, R1)))\n   (real_of_1 (p1, L1, R1)) =\n  0\n  root_cond (p1, L1, R1) (real_of_1 (p1, L1, R1))\n  (real_of_1 (p1, L1, R1) = ?y) = root_cond (p1, L1, R1) ?y\n  (?y = real_of_1 (p1, L1, R1)) = root_cond (p1, L1, R1) ?y\n  x = real_of_1 (p1, L1, R1)", "have x: \"root_cond (p1,L1,R1) x\""], ["proof (prove)\nusing this:\n  real_of_rat (rai_lb (p1, L1, R1)) \\<le> real_of_1 (p1, L1, R1)\n  real_of_1 (p1, L1, R1) \\<le> real_of_rat (rai_ub (p1, L1, R1))\n  poly (real_of_int_poly (poly_real_alg_1 (p1, L1, R1)))\n   (real_of_1 (p1, L1, R1)) =\n  0\n  root_cond (p1, L1, R1) (real_of_1 (p1, L1, R1))\n  (real_of_1 (p1, L1, R1) = ?y) = root_cond (p1, L1, R1) ?y\n  (?y = real_of_1 (p1, L1, R1)) = root_cond (p1, L1, R1) ?y\n  x = real_of_1 (p1, L1, R1)\n\ngoal (1 subgoal):\n 1. root_cond (p1, L1, R1) x", "by auto"], ["proof (state)\nthis:\n  root_cond (p1, L1, R1) x\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from unique_rootD[OF ur2(1)] y"], ["proof (chain)\npicking this:\n  real_of_rat (rai_lb (p2, L2, R2)) \\<le> real_of_1 (p2, L2, R2)\n  real_of_1 (p2, L2, R2) \\<le> real_of_rat (rai_ub (p2, L2, R2))\n  poly (real_of_int_poly (poly_real_alg_1 (p2, L2, R2)))\n   (real_of_1 (p2, L2, R2)) =\n  0\n  root_cond (p2, L2, R2) (real_of_1 (p2, L2, R2))\n  (real_of_1 (p2, L2, R2) = ?y) = root_cond (p2, L2, R2) ?y\n  (?y = real_of_1 (p2, L2, R2)) = root_cond (p2, L2, R2) ?y\n  y = real_of_1 (p2, L2, R2)", "have y: \"root_cond (p2,L2,R2) y\""], ["proof (prove)\nusing this:\n  real_of_rat (rai_lb (p2, L2, R2)) \\<le> real_of_1 (p2, L2, R2)\n  real_of_1 (p2, L2, R2) \\<le> real_of_rat (rai_ub (p2, L2, R2))\n  poly (real_of_int_poly (poly_real_alg_1 (p2, L2, R2)))\n   (real_of_1 (p2, L2, R2)) =\n  0\n  root_cond (p2, L2, R2) (real_of_1 (p2, L2, R2))\n  (real_of_1 (p2, L2, R2) = ?y) = root_cond (p2, L2, R2) ?y\n  (?y = real_of_1 (p2, L2, R2)) = root_cond (p2, L2, R2) ?y\n  y = real_of_1 (p2, L2, R2)\n\ngoal (1 subgoal):\n 1. root_cond (p2, L2, R2) y", "by auto"], ["proof (state)\nthis:\n  root_cond (p2, L2, R2) y\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from tight(1)"], ["proof (chain)\npicking this:\n  tighten_poly_bounds p1 l1 r1 sr1 = (L1, R1, SR1)", "have half1: \"(L1, R1) \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)}\""], ["proof (prove)\nusing this:\n  tighten_poly_bounds p1 l1 r1 sr1 = (L1, R1, SR1)\n\ngoal (1 subgoal):\n 1. (L1, R1) \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)}", "unfolding tighten_poly_bounds_def Let_def"], ["proof (prove)\nusing this:\n  (if sgn (ipoly p1 ((l1 + r1) / 2)) = sr1\n   then (l1, (l1 + r1) / 2, sgn (ipoly p1 ((l1 + r1) / 2)))\n   else ((l1 + r1) / 2, r1, sr1)) =\n  (L1, R1, SR1)\n\ngoal (1 subgoal):\n 1. (L1, R1) \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)}", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  (L1, R1) \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)}\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from tight(2)"], ["proof (chain)\npicking this:\n  tighten_poly_bounds p2 l2 r2 sr2 = (L2, R2, SR2)", "have half2: \"(L2, R2) \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\""], ["proof (prove)\nusing this:\n  tighten_poly_bounds p2 l2 r2 sr2 = (L2, R2, SR2)\n\ngoal (1 subgoal):\n 1. (L2, R2) \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}", "unfolding tighten_poly_bounds_def Let_def"], ["proof (prove)\nusing this:\n  (if sgn (ipoly p2 ((l2 + r2) / 2)) = sr2\n   then (l2, (l2 + r2) / 2, sgn (ipoly p2 ((l2 + r2) / 2)))\n   else ((l2 + r2) / 2, r2, sr2)) =\n  (L2, R2, SR2)\n\ngoal (1 subgoal):\n 1. (L2, R2) \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  (L2, R2) \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "from approx[OF I lr1 lr2 bndi[symmetric] bndsi[symmetric] half1 half2]"], ["proof (chain)\npicking this:\n  R - L \\<le> 3 / 4 * (r - l) \\<and> l \\<le> L \\<and> R \\<le> r", "have \"R - L \\<le> 3 / 4 * (r - l) \\<and> l \\<le> L \\<and> R \\<le> r\""], ["proof (prove)\nusing this:\n  R - L \\<le> 3 / 4 * (r - l) \\<and> l \\<le> L \\<and> R \\<le> r\n\ngoal (1 subgoal):\n 1. R - L \\<le> 3 / 4 * (r - l) \\<and> l \\<le> L \\<and> R \\<le> r", "."], ["proof (state)\nthis:\n  R - L \\<le> 3 / 4 * (r - l) \\<and> l \\<le> L \\<and> R \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "hence \"sub_interval (g (Suc i)) (g i)\" \"R - L \\<le> 3/4 * (snd (g i) - fst (g i))\""], ["proof (prove)\nusing this:\n  R - L \\<le> 3 / 4 * (r - l) \\<and> l \\<le> L \\<and> R \\<le> r\n\ngoal (1 subgoal):\n 1. sub_interval (g (Suc i)) (g i) &&&\n    R - L \\<le> 3 / 4 * (snd (g i) - fst (g i))", "unfolding gi Suc(3)"], ["proof (prove)\nusing this:\n  R - L \\<le> 3 / 4 * (r - l) \\<and> l \\<le> L \\<and> R \\<le> r\n\ngoal (1 subgoal):\n 1. sub_interval (L, R) (l, r) &&&\n    R - L \\<le> 3 / 4 * (snd (l, r) - fst (l, r))", "by auto"], ["proof (state)\nthis:\n  sub_interval (g (Suc i)) (g i)\n  R - L \\<le> 3 / 4 * (snd (g i) - fst (g i))\n\ngoal (1 subgoal):\n 1. \\<And>i L1 R1 L2 R2 L R j SR1 SR2.\n       \\<lbrakk>\\<And>L1 R1 L2 R2 L R j SR1 SR2.\n                   \\<lbrakk>(upd ^^ i) init = ((L1, R1, SR1), L2, R2, SR2);\n                    g i = (L, R)\\<rbrakk>\n                   \\<Longrightarrow> I L1 \\<and>\n                                     I L2 \\<and>\n                                     root_cond (p1, L1, R1) x \\<and>\n                                     root_cond (p2, L2, R2) y \\<and>\n                                     Ex1 (root_cond (p1, L1, R1)) \\<and>\n                                     Ex1 (root_cond (p2, L2, R2)) \\<and>\n                                     in_interval (L, R) (f x y) \\<and>\n                                     (i = Suc j \\<longrightarrow>\nsub_interval (g i) (g j) \\<and>\nR - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                                     SR1 = sgn (ipoly p1 R1) \\<and>\n                                     SR2 = sgn (ipoly p2 R2);\n        (upd ^^ Suc i) init = ((L1, R1, SR1), L2, R2, SR2);\n        g (Suc i) = (L, R)\\<rbrakk>\n       \\<Longrightarrow> I L1 \\<and>\n                         I L2 \\<and>\n                         root_cond (p1, L1, R1) x \\<and>\n                         root_cond (p2, L2, R2) y \\<and>\n                         Ex1 (root_cond (p1, L1, R1)) \\<and>\n                         Ex1 (root_cond (p2, L2, R2)) \\<and>\n                         in_interval (L, R) (f x y) \\<and>\n                         (Suc i = Suc j \\<longrightarrow>\n                          sub_interval (g (Suc i)) (g j) \\<and>\n                          R - L\n                          \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n                         SR1 = sgn (ipoly p1 R1) \\<and>\n                         SR2 = sgn (ipoly p2 R2)", "with bnd[OF I1 I2 x y bndsi]"], ["proof (chain)\npicking this:\n  real_of_rat L \\<le> f x y \\<and> f x y \\<le> real_of_rat R\n  sub_interval (g (Suc i)) (g i)\n  R - L \\<le> 3 / 4 * (snd (g i) - fst (g i))", "show ?case"], ["proof (prove)\nusing this:\n  real_of_rat L \\<le> f x y \\<and> f x y \\<le> real_of_rat R\n  sub_interval (g (Suc i)) (g i)\n  R - L \\<le> 3 / 4 * (snd (g i) - fst (g i))\n\ngoal (1 subgoal):\n 1. I L1 \\<and>\n    I L2 \\<and>\n    root_cond (p1, L1, R1) x \\<and>\n    root_cond (p2, L2, R2) y \\<and>\n    (\\<exists>!a. root_cond (p1, L1, R1) a) \\<and>\n    (\\<exists>!a. root_cond (p2, L2, R2) a) \\<and>\n    in_interval (L, R) (f x y) \\<and>\n    (Suc i = Suc j \\<longrightarrow>\n     sub_interval (g (Suc i)) (g j) \\<and>\n     R - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n    SR1 = sgn (ipoly p1 R1) \\<and> SR2 = sgn (ipoly p2 R2)", "using I1 I2 x y ur1 ur2 tight1(6) tight2(6)"], ["proof (prove)\nusing this:\n  real_of_rat L \\<le> f x y \\<and> f x y \\<le> real_of_rat R\n  sub_interval (g (Suc i)) (g i)\n  R - L \\<le> 3 / 4 * (snd (g i) - fst (g i))\n  I L1\n  I L2\n  root_cond (p1, L1, R1) x\n  root_cond (p2, L2, R2) y\n  \\<exists>!x. root_cond (p1, L1, R1) x\n  real_of_1 (p1, L1, R1) = real_of_1 (p1, l1, r1)\n  \\<exists>!x. root_cond (p2, L2, R2) x\n  real_of_1 (p2, L2, R2) = real_of_1 (p2, l2, r2)\n  SR1 = sgn (ipoly p1 R1)\n  SR2 = sgn (ipoly p2 R2)\n\ngoal (1 subgoal):\n 1. I L1 \\<and>\n    I L2 \\<and>\n    root_cond (p1, L1, R1) x \\<and>\n    root_cond (p2, L2, R2) y \\<and>\n    (\\<exists>!a. root_cond (p1, L1, R1) a) \\<and>\n    (\\<exists>!a. root_cond (p2, L2, R2) a) \\<and>\n    in_interval (L, R) (f x y) \\<and>\n    (Suc i = Suc j \\<longrightarrow>\n     sub_interval (g (Suc i)) (g j) \\<and>\n     R - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n    SR1 = sgn (ipoly p1 R1) \\<and> SR2 = sgn (ipoly p2 R2)", "by auto"], ["proof (state)\nthis:\n  I L1 \\<and>\n  I L2 \\<and>\n  root_cond (p1, L1, R1) x \\<and>\n  root_cond (p2, L2, R2) y \\<and>\n  (\\<exists>!a. root_cond (p1, L1, R1) a) \\<and>\n  (\\<exists>!a. root_cond (p2, L2, R2) a) \\<and>\n  in_interval (L, R) (f x y) \\<and>\n  (Suc i = Suc j \\<longrightarrow>\n   sub_interval (g (Suc i)) (g j) \\<and>\n   R - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n  SR1 = sgn (ipoly p1 R1) \\<and> SR2 = sgn (ipoly p2 R2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  I L1 \\<and>\n  I L2 \\<and>\n  root_cond (p1, L1, R1) x \\<and>\n  root_cond (p2, L2, R2) y \\<and>\n  (\\<exists>!x. root_cond (p1, L1, R1) x) \\<and>\n  (\\<exists>!x. root_cond (p2, L2, R2) x) \\<and>\n  in_interval (L, R) (f x y) \\<and>\n  (i = Suc j \\<longrightarrow>\n   sub_interval (g i) (g j) \\<and>\n   R - L \\<le> 3 / 4 * (snd (g j) - fst (g j))) \\<and>\n  SR1 = sgn (ipoly p1 R1) \\<and> SR2 = sgn (ipoly p2 R2)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(upd ^^ ?i2) init =\n           ((?L1.2, ?R1.2, ?SR1.2), ?L2.2, ?R2.2, ?SR2.2);\n   g ?i2 = (?L2, ?R2)\\<rbrakk>\n  \\<Longrightarrow> I ?L1.2 \\<and>\n                    I ?L2.2 \\<and>\n                    root_cond (p1, ?L1.2, ?R1.2) x \\<and>\n                    root_cond (p2, ?L2.2, ?R2.2) y \\<and>\n                    (\\<exists>!x. root_cond (p1, ?L1.2, ?R1.2) x) \\<and>\n                    (\\<exists>!x. root_cond (p2, ?L2.2, ?R2.2) x) \\<and>\n                    in_interval (?L2, ?R2) (f x y) \\<and>\n                    (?i2 = Suc ?j2 \\<longrightarrow>\n                     sub_interval (g ?i2) (g ?j2) \\<and>\n                     ?R2 - ?L2\n                     \\<le> 3 / 4 * (snd (g ?j2) - fst (g ?j2))) \\<and>\n                    ?SR1.2 = sgn (ipoly p1 ?R1.2) \\<and>\n                    ?SR2.2 = sgn (ipoly p2 ?R2.2)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "note invariants = this"], ["proof (state)\nthis:\n  \\<lbrakk>(upd ^^ ?i2) init =\n           ((?L1.2, ?R1.2, ?SR1.2), ?L2.2, ?R2.2, ?SR2.2);\n   g ?i2 = (?L2, ?R2)\\<rbrakk>\n  \\<Longrightarrow> I ?L1.2 \\<and>\n                    I ?L2.2 \\<and>\n                    root_cond (p1, ?L1.2, ?R1.2) x \\<and>\n                    root_cond (p2, ?L2.2, ?R2.2) y \\<and>\n                    (\\<exists>!x. root_cond (p1, ?L1.2, ?R1.2) x) \\<and>\n                    (\\<exists>!x. root_cond (p2, ?L2.2, ?R2.2) x) \\<and>\n                    in_interval (?L2, ?R2) (f x y) \\<and>\n                    (?i2 = Suc ?j2 \\<longrightarrow>\n                     sub_interval (g ?i2) (g ?j2) \\<and>\n                     ?R2 - ?L2\n                     \\<le> 3 / 4 * (snd (g ?j2) - fst (g ?j2))) \\<and>\n                    ?SR1.2 = sgn (ipoly p1 ?R1.2) \\<and>\n                    ?SR2.2 = sgn (ipoly p2 ?R2.2)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "define L where \"L = (\\<lambda> i. fst (g i))\""], ["proof (state)\nthis:\n  L = (\\<lambda>i. fst (g i))\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "define R where \"R = (\\<lambda> i. snd (g i))\""], ["proof (state)\nthis:\n  R = (\\<lambda>i. snd (g i))\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "{"], ["proof (state)\nthis:\n  R = (\\<lambda>i. snd (g i))\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "obtain l1 r1 l2 r2 sr1 sr2 where updi: \"(upd ^^ i) init = ((l1, r1, sr1), l2, r2, sr2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l1 r1 sr1 l2 r2 sr2.\n        (upd ^^ i) init = ((l1, r1, sr1), l2, r2, sr2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"(upd ^^ i) init\", auto)"], ["proof (state)\nthis:\n  (upd ^^ i) init = ((l1, r1, sr1), l2, r2, sr2)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "obtain l r where bnd': \"bnd ((l1, r1, sr1), l2, r2, sr2) = (l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l r.\n        bnd ((l1, r1, sr1), l2, r2, sr2) = (l, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  bnd ((l1, r1, sr1), l2, r2, sr2) = (l, r)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "have gi: \"g i = (l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g i = (l, r)", "unfolding g_def updi bnd'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l, r) = (l, r)", "by auto"], ["proof (state)\nthis:\n  g i = (l, r)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "hence id: \"l = L i\" \"r = R i\""], ["proof (prove)\nusing this:\n  g i = (l, r)\n\ngoal (1 subgoal):\n 1. l = L i &&& r = R i", "unfolding L_def R_def"], ["proof (prove)\nusing this:\n  g i = (l, r)\n\ngoal (1 subgoal):\n 1. l = fst (g i) &&& r = snd (g i)", "by auto"], ["proof (state)\nthis:\n  l = L i\n  r = R i\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "from invariants[OF updi gi[unfolded id]]"], ["proof (chain)\npicking this:\n  I l1 \\<and>\n  I l2 \\<and>\n  root_cond (p1, l1, r1) x \\<and>\n  root_cond (p2, l2, r2) y \\<and>\n  (\\<exists>!x. root_cond (p1, l1, r1) x) \\<and>\n  (\\<exists>!x. root_cond (p2, l2, r2) x) \\<and>\n  in_interval (L i, R i) (f x y) \\<and>\n  (i = Suc ?j2 \\<longrightarrow>\n   sub_interval (g i) (g ?j2) \\<and>\n   R i - L i \\<le> 3 / 4 * (snd (g ?j2) - fst (g ?j2))) \\<and>\n  sr1 = sgn (ipoly p1 r1) \\<and> sr2 = sgn (ipoly p2 r2)", "have \"in_interval (L i, R i) (f x y)\" \n      \"\\<And> j. i = Suc j \\<Longrightarrow> sub_interval (g i) (g j) \\<and> R i - L i \\<le> 3 / 4 * (R j - L j)\""], ["proof (prove)\nusing this:\n  I l1 \\<and>\n  I l2 \\<and>\n  root_cond (p1, l1, r1) x \\<and>\n  root_cond (p2, l2, r2) y \\<and>\n  (\\<exists>!x. root_cond (p1, l1, r1) x) \\<and>\n  (\\<exists>!x. root_cond (p2, l2, r2) x) \\<and>\n  in_interval (L i, R i) (f x y) \\<and>\n  (i = Suc ?j2 \\<longrightarrow>\n   sub_interval (g i) (g ?j2) \\<and>\n   R i - L i \\<le> 3 / 4 * (snd (g ?j2) - fst (g ?j2))) \\<and>\n  sr1 = sgn (ipoly p1 r1) \\<and> sr2 = sgn (ipoly p2 r2)\n\ngoal (1 subgoal):\n 1. in_interval (L i, R i) (f x y) &&&\n    (\\<And>j.\n        i = Suc j \\<Longrightarrow>\n        sub_interval (g i) (g j) \\<and> R i - L i \\<le> 3 / 4 * (R j - L j))", "unfolding L_def R_def"], ["proof (prove)\nusing this:\n  I l1 \\<and>\n  I l2 \\<and>\n  root_cond (p1, l1, r1) x \\<and>\n  root_cond (p2, l2, r2) y \\<and>\n  (\\<exists>!x. root_cond (p1, l1, r1) x) \\<and>\n  (\\<exists>!x. root_cond (p2, l2, r2) x) \\<and>\n  in_interval (fst (g i), snd (g i)) (f x y) \\<and>\n  (i = Suc ?j2 \\<longrightarrow>\n   sub_interval (g i) (g ?j2) \\<and>\n   snd (g i) - fst (g i) \\<le> 3 / 4 * (snd (g ?j2) - fst (g ?j2))) \\<and>\n  sr1 = sgn (ipoly p1 r1) \\<and> sr2 = sgn (ipoly p2 r2)\n\ngoal (1 subgoal):\n 1. in_interval (fst (g i), snd (g i)) (f x y) &&&\n    (\\<And>j.\n        i = Suc j \\<Longrightarrow>\n        sub_interval (g i) (g j) \\<and>\n        snd (g i) - fst (g i) \\<le> 3 / 4 * (snd (g j) - fst (g j)))", "by auto"], ["proof (state)\nthis:\n  in_interval (L i, R i) (f x y)\n  i = Suc ?j \\<Longrightarrow>\n  sub_interval (g i) (g ?j) \\<and> R i - L i \\<le> 3 / 4 * (R ?j - L ?j)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "}"], ["proof (state)\nthis:\n  in_interval (L ?i8, R ?i8) (f x y)\n  ?i8 = Suc ?j5 \\<Longrightarrow>\n  sub_interval (g ?i8) (g ?j5) \\<and>\n  R ?i8 - L ?i8 \\<le> 3 / 4 * (R ?j5 - L ?j5)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "note * = this"], ["proof (state)\nthis:\n  in_interval (L ?i8, R ?i8) (f x y)\n  ?i8 = Suc ?j5 \\<Longrightarrow>\n  sub_interval (g ?i8) (g ?j5) \\<and>\n  R ?i8 - L ?i8 \\<le> 3 / 4 * (R ?j5 - L ?j5)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "{"], ["proof (state)\nthis:\n  in_interval (L ?i8, R ?i8) (f x y)\n  ?i8 = Suc ?j5 \\<Longrightarrow>\n  sub_interval (g ?i8) (g ?j5) \\<and>\n  R ?i8 - L ?i8 \\<le> 3 / 4 * (R ?j5 - L ?j5)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "from *(1)[of i] *(2)[of \"Suc i\", OF refl]"], ["proof (chain)\npicking this:\n  in_interval (L i, R i) (f x y)\n  sub_interval (g (Suc i)) (g i) \\<and>\n  R (Suc i) - L (Suc i) \\<le> 3 / 4 * (R i - L i)", "have \"in_interval (g i) (f x y)\" \"sub_interval (g (Suc i)) (g i)\" \n      \"R (Suc i) - L (Suc i) \\<le> 3 / 4 * (R i - L i)\""], ["proof (prove)\nusing this:\n  in_interval (L i, R i) (f x y)\n  sub_interval (g (Suc i)) (g i) \\<and>\n  R (Suc i) - L (Suc i) \\<le> 3 / 4 * (R i - L i)\n\ngoal (1 subgoal):\n 1. in_interval (g i) (f x y) &&&\n    sub_interval (g (Suc i)) (g i) &&&\n    R (Suc i) - L (Suc i) \\<le> 3 / 4 * (R i - L i)", "unfolding L_def R_def"], ["proof (prove)\nusing this:\n  in_interval (fst (g i), snd (g i)) (f x y)\n  sub_interval (g (Suc i)) (g i) \\<and>\n  snd (g (Suc i)) - fst (g (Suc i)) \\<le> 3 / 4 * (snd (g i) - fst (g i))\n\ngoal (1 subgoal):\n 1. in_interval (g i) (f x y) &&&\n    sub_interval (g (Suc i)) (g i) &&&\n    snd (g (Suc i)) - fst (g (Suc i)) \\<le> 3 / 4 * (snd (g i) - fst (g i))", "by auto"], ["proof (state)\nthis:\n  in_interval (g i) (f x y)\n  sub_interval (g (Suc i)) (g i)\n  R (Suc i) - L (Suc i) \\<le> 3 / 4 * (R i - L i)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "}"], ["proof (state)\nthis:\n  in_interval (g ?i2) (f x y)\n  sub_interval (g (Suc ?i2)) (g ?i2)\n  R (Suc ?i2) - L (Suc ?i2) \\<le> 3 / 4 * (R ?i2 - L ?i2)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "note * = this"], ["proof (state)\nthis:\n  in_interval (g ?i2) (f x y)\n  sub_interval (g (Suc ?i2)) (g ?i2)\n  R (Suc ?i2) - L (Suc ?i2) \\<le> 3 / 4 * (R ?i2 - L ?i2)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sr1), l2, r2, sr2)))\n     (f x y)", "unfolding upd_def[symmetric] init_def[symmetric] g_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. converges_to g (f x y)", "unfolding converges_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n.\n        in_interval (g n) (f x y) \\<and>\n        sub_interval (g (Suc n)) (g n)) \\<and>\n    (\\<forall>eps>0.\n        \\<exists>n l r.\n           g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps)", "proof (intro conjI allI impI, rule *(1), rule *(2))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "fix eps :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "assume eps: \"0 < eps\""], ["proof (state)\nthis:\n  0 < eps\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "let ?r = real_of_rat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "define r where \"r = (\\<lambda> n. ?r (R n))\""], ["proof (state)\nthis:\n  r = (\\<lambda>n. real_of_rat (R n))\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "define l where \"l = (\\<lambda> n. ?r (L n))\""], ["proof (state)\nthis:\n  l = (\\<lambda>n. real_of_rat (L n))\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "define diff where \"diff = (\\<lambda> n. r n - l n)\""], ["proof (state)\nthis:\n  diff = (\\<lambda>n. r n - l n)\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "{"], ["proof (state)\nthis:\n  diff = (\\<lambda>n. r n - l n)\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "from *(3)[of n]"], ["proof (chain)\npicking this:\n  R (Suc n) - L (Suc n) \\<le> 3 / 4 * (R n - L n)", "have \"?r (R (Suc n) - L (Suc n)) \\<le> ?r (3 / 4 * (R n - L n))\""], ["proof (prove)\nusing this:\n  R (Suc n) - L (Suc n) \\<le> 3 / 4 * (R n - L n)\n\ngoal (1 subgoal):\n 1. real_of_rat (R (Suc n) - L (Suc n))\n    \\<le> real_of_rat (3 / 4 * (R n - L n))", "unfolding of_rat_less_eq"], ["proof (prove)\nusing this:\n  R (Suc n) - L (Suc n) \\<le> 3 / 4 * (R n - L n)\n\ngoal (1 subgoal):\n 1. R (Suc n) - L (Suc n) \\<le> 3 / 4 * (R n - L n)", "by simp"], ["proof (state)\nthis:\n  real_of_rat (R (Suc n) - L (Suc n))\n  \\<le> real_of_rat (3 / 4 * (R n - L n))\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "also"], ["proof (state)\nthis:\n  real_of_rat (R (Suc n) - L (Suc n))\n  \\<le> real_of_rat (3 / 4 * (R n - L n))\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "have \"?r (R (Suc n) - L (Suc n)) = (r (Suc n) - l (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (R (Suc n) - L (Suc n)) = r (Suc n) - l (Suc n)", "unfolding of_rat_diff r_def l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (R (Suc n)) - real_of_rat (L (Suc n)) =\n    real_of_rat (R (Suc n)) - real_of_rat (L (Suc n))", "by simp"], ["proof (state)\nthis:\n  real_of_rat (R (Suc n) - L (Suc n)) = r (Suc n) - l (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "also"], ["proof (state)\nthis:\n  real_of_rat (R (Suc n) - L (Suc n)) = r (Suc n) - l (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "have \"?r (3 / 4 * (R n - L n)) = 3 / 4 * (r n - l n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (3 / 4 * (R n - L n)) = 3 / 4 * (r n - l n)", "unfolding r_def l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (3 / 4 * (R n - L n)) =\n    3 / 4 * (real_of_rat (R n) - real_of_rat (L n))", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  real_of_rat (3 / 4 * (R n - L n)) = 3 / 4 * (r n - l n)\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "finally"], ["proof (chain)\npicking this:\n  r (Suc n) - l (Suc n) \\<le> 3 / 4 * (r n - l n)", "have \"diff (Suc n) \\<le> 3 / 4 * diff n\""], ["proof (prove)\nusing this:\n  r (Suc n) - l (Suc n) \\<le> 3 / 4 * (r n - l n)\n\ngoal (1 subgoal):\n 1. diff (Suc n) \\<le> 3 / 4 * diff n", "unfolding diff_def"], ["proof (prove)\nusing this:\n  r (Suc n) - l (Suc n) \\<le> 3 / 4 * (r n - l n)\n\ngoal (1 subgoal):\n 1. r (Suc n) - l (Suc n) \\<le> 3 / 4 * (r n - l n)", "."], ["proof (state)\nthis:\n  diff (Suc n) \\<le> 3 / 4 * diff n\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "}"], ["proof (state)\nthis:\n  diff (Suc ?n2) \\<le> 3 / 4 * diff ?n2\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "note * = this"], ["proof (state)\nthis:\n  diff (Suc ?n2) \\<le> 3 / 4 * diff ?n2\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "{"], ["proof (state)\nthis:\n  diff (Suc ?n2) \\<le> 3 / 4 * diff ?n2\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "have \"diff i \\<le> (3/4)^i * diff 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff i \\<le> (3 / 4) ^ i * diff 0", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. diff 0 \\<le> (3 / 4) ^ 0 * diff 0\n 2. \\<And>i.\n       diff i \\<le> (3 / 4) ^ i * diff 0 \\<Longrightarrow>\n       diff (Suc i) \\<le> (3 / 4) ^ Suc i * diff 0", "case (Suc i)"], ["proof (state)\nthis:\n  diff i \\<le> (3 / 4) ^ i * diff 0\n\ngoal (2 subgoals):\n 1. diff 0 \\<le> (3 / 4) ^ 0 * diff 0\n 2. \\<And>i.\n       diff i \\<le> (3 / 4) ^ i * diff 0 \\<Longrightarrow>\n       diff (Suc i) \\<le> (3 / 4) ^ Suc i * diff 0", "from Suc *[of i]"], ["proof (chain)\npicking this:\n  diff i \\<le> (3 / 4) ^ i * diff 0\n  diff (Suc i) \\<le> 3 / 4 * diff i", "show ?case"], ["proof (prove)\nusing this:\n  diff i \\<le> (3 / 4) ^ i * diff 0\n  diff (Suc i) \\<le> 3 / 4 * diff i\n\ngoal (1 subgoal):\n 1. diff (Suc i) \\<le> (3 / 4) ^ Suc i * diff 0", "by auto"], ["proof (state)\nthis:\n  diff (Suc i) \\<le> (3 / 4) ^ Suc i * diff 0\n\ngoal (1 subgoal):\n 1. diff 0 \\<le> (3 / 4) ^ 0 * diff 0", "qed auto"], ["proof (state)\nthis:\n  diff i \\<le> (3 / 4) ^ i * diff 0\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "}"], ["proof (state)\nthis:\n  diff ?i2 \\<le> (3 / 4) ^ ?i2 * diff 0\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "then"], ["proof (chain)\npicking this:\n  diff ?i2 \\<le> (3 / 4) ^ ?i2 * diff 0", "obtain c where *: \"\\<And> i. diff i \\<le> (3/4)^i * c\""], ["proof (prove)\nusing this:\n  diff ?i2 \\<le> (3 / 4) ^ ?i2 * diff 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        (\\<And>i. diff i \\<le> (3 / 4) ^ i * c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  diff ?i \\<le> (3 / 4) ^ ?i * c\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "have \"\\<exists> n. diff n \\<le> eps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. diff n \\<le> eps", "proof (cases \"c \\<le> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<le> 0 \\<Longrightarrow> \\<exists>n. diff n \\<le> eps\n 2. \\<not> c \\<le> 0 \\<Longrightarrow> \\<exists>n. diff n \\<le> eps", "case True"], ["proof (state)\nthis:\n  c \\<le> 0\n\ngoal (2 subgoals):\n 1. c \\<le> 0 \\<Longrightarrow> \\<exists>n. diff n \\<le> eps\n 2. \\<not> c \\<le> 0 \\<Longrightarrow> \\<exists>n. diff n \\<le> eps", "with *[of 0] eps"], ["proof (chain)\npicking this:\n  diff 0 \\<le> (3 / 4) ^ 0 * c\n  0 < eps\n  c \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  diff 0 \\<le> (3 / 4) ^ 0 * c\n  0 < eps\n  c \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<exists>n. diff n \\<le> eps", "by (intro exI[of _ 0], auto)"], ["proof (state)\nthis:\n  \\<exists>n. diff n \\<le> eps\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> 0 \\<Longrightarrow> \\<exists>n. diff n \\<le> eps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> c \\<le> 0 \\<Longrightarrow> \\<exists>n. diff n \\<le> eps", "case False"], ["proof (state)\nthis:\n  \\<not> c \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> 0 \\<Longrightarrow> \\<exists>n. diff n \\<le> eps", "hence c: \"c > 0\""], ["proof (prove)\nusing this:\n  \\<not> c \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 < c", "by auto"], ["proof (state)\nthis:\n  0 < c\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> 0 \\<Longrightarrow> \\<exists>n. diff n \\<le> eps", "with eps"], ["proof (chain)\npicking this:\n  0 < eps\n  0 < c", "have \"inverse c * eps > 0\""], ["proof (prove)\nusing this:\n  0 < eps\n  0 < c\n\ngoal (1 subgoal):\n 1. 0 < inverse c * eps", "by auto"], ["proof (state)\nthis:\n  0 < inverse c * eps\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> 0 \\<Longrightarrow> \\<exists>n. diff n \\<le> eps", "from exp_tends_to_zero[of \"3/4 :: real\", OF _ _ this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < 3 / 4; 3 / 4 < 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. (3 / 4) ^ x \\<le> inverse c * eps", "obtain n where \n        \"(3/4) ^ n \\<le> inverse c * eps\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 3 / 4; 3 / 4 < 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. (3 / 4) ^ x \\<le> inverse c * eps\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (3 / 4) ^ n \\<le> inverse c * eps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (3 / 4) ^ n \\<le> inverse c * eps\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> 0 \\<Longrightarrow> \\<exists>n. diff n \\<le> eps", "from mult_right_mono[OF this, of c] c"], ["proof (chain)\npicking this:\n  0 \\<le> c \\<Longrightarrow> (3 / 4) ^ n * c \\<le> inverse c * eps * c\n  0 < c", "have \"(3/4) ^ n * c \\<le> eps\""], ["proof (prove)\nusing this:\n  0 \\<le> c \\<Longrightarrow> (3 / 4) ^ n * c \\<le> inverse c * eps * c\n  0 < c\n\ngoal (1 subgoal):\n 1. (3 / 4) ^ n * c \\<le> eps", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (3 / 4) ^ n * c \\<le> eps\n\ngoal (1 subgoal):\n 1. \\<not> c \\<le> 0 \\<Longrightarrow> \\<exists>n. diff n \\<le> eps", "with *[of n]"], ["proof (chain)\npicking this:\n  diff n \\<le> (3 / 4) ^ n * c\n  (3 / 4) ^ n * c \\<le> eps", "show ?thesis"], ["proof (prove)\nusing this:\n  diff n \\<le> (3 / 4) ^ n * c\n  (3 / 4) ^ n * c \\<le> eps\n\ngoal (1 subgoal):\n 1. \\<exists>n. diff n \\<le> eps", "by (intro exI[of _ n], auto)"], ["proof (state)\nthis:\n  \\<exists>n. diff n \\<le> eps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n. diff n \\<le> eps\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. diff n \\<le> eps", "obtain n where \"?r (R n) - ?r (L n) \\<le> eps\""], ["proof (prove)\nusing this:\n  \\<exists>n. diff n \\<le> eps\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        real_of_rat (R n) - real_of_rat (L n) \\<le> eps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding l_def r_def diff_def"], ["proof (prove)\nusing this:\n  \\<exists>n. real_of_rat (R n) - real_of_rat (L n) \\<le> eps\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        real_of_rat (R n) - real_of_rat (L n) \\<le> eps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  real_of_rat (R n) - real_of_rat (L n) \\<le> eps\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "thus \"\\<exists>n l r. g n = (l, r) \\<and> ?r r - ?r l \\<le> eps\""], ["proof (prove)\nusing this:\n  real_of_rat (R n) - real_of_rat (L n) \\<le> eps\n\ngoal (1 subgoal):\n 1. \\<exists>n l r.\n       g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "unfolding L_def R_def"], ["proof (prove)\nusing this:\n  real_of_rat (snd (g n)) - real_of_rat (fst (g n)) \\<le> eps\n\ngoal (1 subgoal):\n 1. \\<exists>n l r.\n       g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps", "by (intro exI[of _ n], force)"], ["proof (state)\nthis:\n  \\<exists>n l r.\n     g n = (l, r) \\<and> real_of_rat r - real_of_rat l \\<le> eps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  converges_to\n   (\\<lambda>i.\n       bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n             ((l1, r1, sr1), l2, r2, sr2)))\n   (f x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun add_1 :: \"real_alg_1 \\<Rightarrow> real_alg_1 \\<Rightarrow> real_alg_2\" where\n  \"add_1 (p1,l1,r1) (p2,l2,r2) = (\n     select_correct_factor_int_poly\n       (tighten_poly_bounds_binary p1 p2)\n       (\\<lambda> ((l1,r1,sr1),(l2,r2,sr2)). (l1 + l2, r1 + r2))\n       ((l1,r1,sgn (ipoly p1 r1)),(l2,r2, sgn (ipoly p2 r2))) \n       (poly_add p1 p2))\""], ["", "lemma add_1:\n  assumes x: \"invariant_1_2 x\" and y: \"invariant_1_2 y\"\n  defines z: \"z \\<equiv> add_1 x y\"\n  shows \"invariant_2 z \\<and> (real_of_2 z = real_of_1 x + real_of_1 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "proof (cases x)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "case xt: (fields p1 l1 r1)"], ["proof (state)\nthis:\n  x = (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "proof (cases y)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "case yt: (fields p2 l2 r2)"], ["proof (state)\nthis:\n  y = (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "let ?x = \"real_of_1 (p1, l1, r1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "let ?y = \"real_of_1 (p2, l2, r2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "let ?p = \"poly_add p1 p2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "note x = x[unfolded xt]"], ["proof (state)\nthis:\n  invariant_1_2 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "note y = y[unfolded yt]"], ["proof (state)\nthis:\n  invariant_1_2 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "from x"], ["proof (chain)\npicking this:\n  invariant_1_2 (p1, l1, r1)", "have ax: \"p1 represents ?x\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. p1 represents real_of_1 (p1, l1, r1)", "unfolding represents_def"], ["proof (prove)\nusing this:\n  invariant_1_2 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p1) (real_of_1 (p1, l1, r1)) = 0 \\<and>\n    p1 \\<noteq> 0", "by (auto elim!: invariant_1E)"], ["proof (state)\nthis:\n  p1 represents real_of_1 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "from y"], ["proof (chain)\npicking this:\n  invariant_1_2 (p2, l2, r2)", "have ay: \"p2 represents ?y\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. p2 represents real_of_1 (p2, l2, r2)", "unfolding represents_def"], ["proof (prove)\nusing this:\n  invariant_1_2 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p2) (real_of_1 (p2, l2, r2)) = 0 \\<and>\n    p2 \\<noteq> 0", "by (auto elim!: invariant_1E)"], ["proof (state)\nthis:\n  p2 represents real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "let ?bnd = \"(\\<lambda>((l1, r1, sr1 :: rat), l2 :: rat, r2 :: rat, sr2 :: rat). (l1 + l2, r1 + r2))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "define bnd where \"bnd = ?bnd\""], ["proof (state)\nthis:\n  bnd = (\\<lambda>((l1, r1, sr1), l2, r2, sr2). (l1 + l2, r1 + r2))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "have \"invariant_2 z \\<and> real_of_2 z = ?x + ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and>\n    real_of_2 z = real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2)", "proof (intro select_correct_factor_int_poly)"], ["proof (state)\ngoal (4 subgoals):\n 1. converges_to (\\<lambda>i. ?bnd_get ((?bnd_update ^^ i) ?init))\n     (real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2))\n 2. select_correct_factor_int_poly ?bnd_update ?bnd_get ?init ?p = z\n 3. poly (real_of_int_poly ?p)\n     (real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2)) =\n    0\n 4. ?p \\<noteq> 0", "from represents_add[OF ax ay]"], ["proof (chain)\npicking this:\n  poly_add p1 p2 represents real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2)", "show \"?p \\<noteq> 0\" \"ipoly ?p (?x + ?y) = 0\""], ["proof (prove)\nusing this:\n  poly_add p1 p2 represents real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. poly_add p1 p2 \\<noteq> 0 &&&\n    poly (real_of_int_poly (poly_add p1 p2))\n     (real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2)) =\n    0", "by auto"], ["proof (state)\nthis:\n  poly_add p1 p2 \\<noteq> 0\n  poly (real_of_int_poly (poly_add p1 p2))\n   (real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2)) =\n  0\n\ngoal (2 subgoals):\n 1. converges_to (\\<lambda>i. ?bnd_get ((?bnd_update ^^ i) ?init))\n     (real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2))\n 2. select_correct_factor_int_poly ?bnd_update ?bnd_get ?init\n     (poly_add p1 p2) =\n    z", "from z[unfolded xt yt]"], ["proof (chain)\npicking this:\n  z \\<equiv> add_1 (p1, l1, r1) (p2, l2, r2)", "show sel: \"select_correct_factor_int_poly\n          (tighten_poly_bounds_binary p1 p2)\n          bnd \n          ((l1,r1,sgn (ipoly p1 r1)),(l2,r2, sgn (ipoly p2 r2))) \n          (poly_add p1 p2) = z\""], ["proof (prove)\nusing this:\n  z \\<equiv> add_1 (p1, l1, r1) (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. select_correct_factor_int_poly (tighten_poly_bounds_binary p1 p2) bnd\n     ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))\n     (poly_add p1 p2) =\n    z", "by (auto simp: bnd_def)"], ["proof (state)\nthis:\n  select_correct_factor_int_poly (tighten_poly_bounds_binary p1 p2) bnd\n   ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))\n   (poly_add p1 p2) =\n  z\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))))\n     (real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2))", "have ur1: \"unique_root (p1,l1,r1)\" \"poly_cond2 p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p1, l1, r1) x &&& poly_cond2 p1", "using x"], ["proof (prove)\nusing this:\n  invariant_1_2 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p1, l1, r1) x &&& poly_cond2 p1", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  poly_cond2 p1\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))))\n     (real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2))", "have ur2: \"unique_root (p2,l2,r2)\" \"poly_cond2 p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p2, l2, r2) x &&& poly_cond2 p2", "using y"], ["proof (prove)\nusing this:\n  invariant_1_2 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p2, l2, r2) x &&& poly_cond2 p2", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  poly_cond2 p2\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))))\n     (real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2))", "show \"converges_to\n        (\\<lambda>i. bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n        ((l1,r1,sgn (ipoly p1 r1)),(l2,r2, sgn (ipoly p2 r2))))) (?x + ?y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))))\n     (real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2))", "by (intro tighten_poly_bounds_binary ur1 ur2; force simp: bnd_def hom_distribs)"], ["proof (state)\nthis:\n  converges_to\n   (\\<lambda>i.\n       bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n             ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))))\n   (real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invariant_2 z \\<and>\n  real_of_2 z = real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "thus ?thesis"], ["proof (prove)\nusing this:\n  invariant_2 z \\<and>\n  real_of_2 z = real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y", "unfolding xt yt"], ["proof (prove)\nusing this:\n  invariant_2 z \\<and>\n  real_of_2 z = real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and>\n    real_of_2 z = real_of_1 (p1, l1, r1) + real_of_1 (p2, l2, r2)", "."], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_1 x + real_of_1 y\n\ngoal:\nNo subgoals!", "qed"], ["", "declare add_rat_1.simps[simp del]"], ["", "declare add_1.simps[simp del]"], ["", "(* ********************* *)"], ["", "subsubsection\\<open>Multiplication\\<close>"], ["", "context\nbegin"], ["", "private"], ["", "fun mult_rat_1_pos :: \"rat \\<Rightarrow> real_alg_1 \\<Rightarrow> real_alg_2\" where\n  \"mult_rat_1_pos r1 (p2,l2,r2) = real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l2*r1, r2*r1)\""], ["", "private"], ["", "fun mult_1_pos :: \"real_alg_1 \\<Rightarrow> real_alg_1 \\<Rightarrow> real_alg_2\" where\n  \"mult_1_pos (p1,l1,r1) (p2,l2,r2) =\n      select_correct_factor_int_poly \n        (tighten_poly_bounds_binary p1 p2)\n        (\\<lambda> ((l1,r1,sr1),(l2,r2,sr2)). (l1 * l2, r1 * r2))\n        ((l1,r1,sgn (ipoly p1 r1)),(l2,r2, sgn (ipoly p2 r2))) \n        (poly_mult p1 p2)\""], ["", "fun mult_rat_1 :: \"rat \\<Rightarrow> real_alg_1 \\<Rightarrow> real_alg_2\" where\n  \"mult_rat_1 x y = \n    (if x < 0 then uminus_2 (mult_rat_1_pos (-x) y)\n      else if x = 0 then Rational 0 else (mult_rat_1_pos x y))\""], ["", "fun mult_1 :: \"real_alg_1 \\<Rightarrow> real_alg_1 \\<Rightarrow> real_alg_2\" where\n  \"mult_1 x y = (case (x,y) of ((p1,l1,r1),(p2,l2,r2)) \\<Rightarrow>\n   if r1 > 0 then\n     if r2 > 0 then mult_1_pos x y\n     else uminus_2 (mult_1_pos x (uminus_1 y))\n   else if r2 > 0 then uminus_2 (mult_1_pos (uminus_1 x) y)\n     else mult_1_pos (uminus_1 x) (uminus_1 y))\""], ["", "lemma mult_rat_1_pos: fixes r1 :: rat assumes r1: \"r1 > 0\" and y: \"invariant_1 y\"\n  defines z: \"z \\<equiv> mult_rat_1_pos r1 y\"\n  shows \"invariant_2 z \\<and> (real_of_2 z = of_rat r1 * real_of_1 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "obtain p2 l2 r2 where yt: \"y = (p2,l2,r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2 l2 r2.\n        y = (p2, l2, r2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases y, auto)"], ["proof (state)\nthis:\n  y = (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "let ?x = \"real_of_rat r1\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "let ?y = \"real_of_1 (p2, l2, r2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "let ?p = \"poly_mult_rat r1 p2\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "let ?mp = \"cf_pos_poly ?p\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "note y = y[unfolded yt]"], ["proof (state)\nthis:\n  invariant_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "note yD = invariant_1D[OF y]"], ["proof (state)\nthis:\n  root_cond (p2, l2, r2) (real_of_1 (p2, l2, r2))\n  sgn (rai_lb (p2, l2, r2)) = sgn (rai_ub (p2, l2, r2))\n  sgn (real_of_1 (p2, l2, r2)) = real_of_rat (sgn (rai_ub (p2, l2, r2)))\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  poly_cond (poly_real_alg_1 (p2, l2, r2))\n  0 < degree (poly_real_alg_1 (p2, l2, r2))\n  primitive (poly_real_alg_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "from yD r1"], ["proof (chain)\npicking this:\n  root_cond (p2, l2, r2) (real_of_1 (p2, l2, r2))\n  sgn (rai_lb (p2, l2, r2)) = sgn (rai_ub (p2, l2, r2))\n  sgn (real_of_1 (p2, l2, r2)) = real_of_rat (sgn (rai_ub (p2, l2, r2)))\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  poly_cond (poly_real_alg_1 (p2, l2, r2))\n  0 < degree (poly_real_alg_1 (p2, l2, r2))\n  primitive (poly_real_alg_1 (p2, l2, r2))\n  0 < r1", "have p: \"?p \\<noteq> 0\" and r10: \"r1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  root_cond (p2, l2, r2) (real_of_1 (p2, l2, r2))\n  sgn (rai_lb (p2, l2, r2)) = sgn (rai_ub (p2, l2, r2))\n  sgn (real_of_1 (p2, l2, r2)) = real_of_rat (sgn (rai_ub (p2, l2, r2)))\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  poly_cond (poly_real_alg_1 (p2, l2, r2))\n  0 < degree (poly_real_alg_1 (p2, l2, r2))\n  primitive (poly_real_alg_1 (p2, l2, r2))\n  0 < r1\n\ngoal (1 subgoal):\n 1. poly_mult_rat r1 p2 \\<noteq> 0 &&& r1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly_mult_rat r1 p2 \\<noteq> 0\n  r1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "hence mp: \"?mp \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly_mult_rat r1 p2 \\<noteq> 0\n  r1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cf_pos_poly (poly_mult_rat r1 p2) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  cf_pos_poly (poly_mult_rat r1 p2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "from yD(1)"], ["proof (chain)\npicking this:\n  root_cond (p2, l2, r2) (real_of_1 (p2, l2, r2))", "have rt: \"ipoly p2 ?y = 0\" and bnd: \"of_rat l2 \\<le> ?y\" \"?y \\<le> of_rat r2\""], ["proof (prove)\nusing this:\n  root_cond (p2, l2, r2) (real_of_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p2) (real_of_1 (p2, l2, r2)) = 0 &&&\n    real_of_rat l2 \\<le> real_of_1 (p2, l2, r2) &&&\n    real_of_1 (p2, l2, r2) \\<le> real_of_rat r2", "by auto"], ["proof (state)\nthis:\n  poly (real_of_int_poly p2) (real_of_1 (p2, l2, r2)) = 0\n  real_of_rat l2 \\<le> real_of_1 (p2, l2, r2)\n  real_of_1 (p2, l2, r2) \\<le> real_of_rat r2\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "from rt r1"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly p2) (real_of_1 (p2, l2, r2)) = 0\n  0 < r1", "have rt: \"ipoly ?mp (?x * ?y) = 0\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p2) (real_of_1 (p2, l2, r2)) = 0\n  0 < r1\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly (cf_pos_poly (poly_mult_rat r1 p2)))\n     (real_of_rat r1 * real_of_1 (p2, l2, r2)) =\n    0", "by (auto simp add: field_simps ipoly_mult_rat[OF r10])"], ["proof (state)\nthis:\n  poly (real_of_int_poly (cf_pos_poly (poly_mult_rat r1 p2)))\n   (real_of_rat r1 * real_of_1 (p2, l2, r2)) =\n  0\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "from yD(5)"], ["proof (chain)\npicking this:\n  poly_cond (poly_real_alg_1 (p2, l2, r2))", "have irr: \"irreducible p2\""], ["proof (prove)\nusing this:\n  poly_cond (poly_real_alg_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. irreducible p2", "unfolding represents_def"], ["proof (prove)\nusing this:\n  poly_cond (poly_real_alg_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. irreducible p2", "using y"], ["proof (prove)\nusing this:\n  poly_cond (poly_real_alg_1 (p2, l2, r2))\n  invariant_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. irreducible p2", "unfolding root_cond_def split"], ["proof (prove)\nusing this:\n  poly_cond (poly_real_alg_1 (p2, l2, r2))\n  invariant_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. irreducible p2", "by auto"], ["proof (state)\nthis:\n  irreducible p2\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "from poly_mult_rat_irreducible[OF this _ r10] yD"], ["proof (chain)\npicking this:\n  degree p2 \\<noteq> 0 \\<Longrightarrow>\n  irreducible (cf_pos_poly (poly_mult_rat r1 p2))\n  root_cond (p2, l2, r2) (real_of_1 (p2, l2, r2))\n  sgn (rai_lb (p2, l2, r2)) = sgn (rai_ub (p2, l2, r2))\n  sgn (real_of_1 (p2, l2, r2)) = real_of_rat (sgn (rai_ub (p2, l2, r2)))\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  poly_cond (poly_real_alg_1 (p2, l2, r2))\n  0 < degree (poly_real_alg_1 (p2, l2, r2))\n  primitive (poly_real_alg_1 (p2, l2, r2))", "have irr: \"irreducible ?mp\""], ["proof (prove)\nusing this:\n  degree p2 \\<noteq> 0 \\<Longrightarrow>\n  irreducible (cf_pos_poly (poly_mult_rat r1 p2))\n  root_cond (p2, l2, r2) (real_of_1 (p2, l2, r2))\n  sgn (rai_lb (p2, l2, r2)) = sgn (rai_ub (p2, l2, r2))\n  sgn (real_of_1 (p2, l2, r2)) = real_of_rat (sgn (rai_ub (p2, l2, r2)))\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  poly_cond (poly_real_alg_1 (p2, l2, r2))\n  0 < degree (poly_real_alg_1 (p2, l2, r2))\n  primitive (poly_real_alg_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. irreducible (cf_pos_poly (poly_mult_rat r1 p2))", "by simp"], ["proof (state)\nthis:\n  irreducible (cf_pos_poly (poly_mult_rat r1 p2))\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "from p"], ["proof (chain)\npicking this:\n  poly_mult_rat r1 p2 \\<noteq> 0", "have mon: \"cf_pos ?mp\""], ["proof (prove)\nusing this:\n  poly_mult_rat r1 p2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cf_pos (cf_pos_poly (poly_mult_rat r1 p2))", "by auto"], ["proof (state)\nthis:\n  cf_pos (cf_pos_poly (poly_mult_rat r1 p2))\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "obtain l r where lr: \"l = l2 * r1\" \"r = r2 * r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l r.\n        \\<lbrakk>l = l2 * r1; r = r2 * r1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  l = l2 * r1\n  r = r2 * r1\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "from bnd r1"], ["proof (chain)\npicking this:\n  real_of_rat l2 \\<le> real_of_1 (p2, l2, r2)\n  real_of_1 (p2, l2, r2) \\<le> real_of_rat r2\n  0 < r1", "have bnd: \"of_rat l \\<le> ?x * ?y\" \"?x * ?y \\<le> of_rat r\""], ["proof (prove)\nusing this:\n  real_of_rat l2 \\<le> real_of_1 (p2, l2, r2)\n  real_of_1 (p2, l2, r2) \\<le> real_of_rat r2\n  0 < r1\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> real_of_rat r1 * real_of_1 (p2, l2, r2) &&&\n    real_of_rat r1 * real_of_1 (p2, l2, r2) \\<le> real_of_rat r", "unfolding lr of_rat_mult"], ["proof (prove)\nusing this:\n  real_of_rat l2 \\<le> real_of_1 (p2, l2, r2)\n  real_of_1 (p2, l2, r2) \\<le> real_of_rat r2\n  0 < r1\n\ngoal (1 subgoal):\n 1. real_of_rat l2 * real_of_rat r1\n    \\<le> real_of_rat r1 * real_of_1 (p2, l2, r2) &&&\n    real_of_rat r1 * real_of_1 (p2, l2, r2)\n    \\<le> real_of_rat r2 * real_of_rat r1", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> real_of_rat r1 * real_of_1 (p2, l2, r2)\n  real_of_rat r1 * real_of_1 (p2, l2, r2) \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "with rt"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly (cf_pos_poly (poly_mult_rat r1 p2)))\n   (real_of_rat r1 * real_of_1 (p2, l2, r2)) =\n  0\n  real_of_rat l \\<le> real_of_rat r1 * real_of_1 (p2, l2, r2)\n  real_of_rat r1 * real_of_1 (p2, l2, r2) \\<le> real_of_rat r", "have rc: \"root_cond (?mp,l,r) (?x * ?y)\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly (cf_pos_poly (poly_mult_rat r1 p2)))\n   (real_of_rat r1 * real_of_1 (p2, l2, r2)) =\n  0\n  real_of_rat l \\<le> real_of_rat r1 * real_of_1 (p2, l2, r2)\n  real_of_rat r1 * real_of_1 (p2, l2, r2) \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n     (real_of_rat r1 * real_of_1 (p2, l2, r2))", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly (cf_pos_poly (poly_mult_rat r1 p2)))\n   (real_of_rat r1 *\n    (THE x.\n        case (p2, l2, r2) of\n        (p, l, r) \\<Rightarrow>\n          real_of_rat l \\<le> x \\<and>\n          x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0)) =\n  0\n  real_of_rat l\n  \\<le> real_of_rat r1 *\n        (THE x.\n            case (p2, l2, r2) of\n            (p, l, r) \\<Rightarrow>\n              real_of_rat l \\<le> x \\<and>\n              x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0)\n  real_of_rat r1 *\n  (THE x.\n      case (p2, l2, r2) of\n      (p, l, r) \\<Rightarrow>\n        real_of_rat l \\<le> x \\<and>\n        x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0)\n  \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. case (cf_pos_poly (poly_mult_rat r1 p2), l, r) of\n    (p, l, r) \\<Rightarrow>\n      real_of_rat l\n      \\<le> real_of_rat r1 *\n            (THE x.\n                case (p2, l2, r2) of\n                (p, l, r) \\<Rightarrow>\n                  real_of_rat l \\<le> x \\<and>\n                  x \\<le> real_of_rat r \\<and>\n                  poly (real_of_int_poly p) x = 0) \\<and>\n      real_of_rat r1 *\n      (THE x.\n          case (p2, l2, r2) of\n          (p, l, r) \\<Rightarrow>\n            real_of_rat l \\<le> x \\<and>\n            x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0)\n      \\<le> real_of_rat r \\<and>\n      poly (real_of_int_poly p)\n       (real_of_rat r1 *\n        (THE x.\n            case (p2, l2, r2) of\n            (p, l, r) \\<Rightarrow>\n              real_of_rat l \\<le> x \\<and>\n              x \\<le> real_of_rat r \\<and>\n              poly (real_of_int_poly p) x = 0)) =\n      0", "by auto"], ["proof (state)\nthis:\n  root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n   (real_of_rat r1 * real_of_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "have ur: \"unique_root (?mp,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r) x", "proof (rule ex1I, rule rc)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n        x \\<Longrightarrow>\n       x = real_of_rat r1 * real_of_1 (p2, l2, r2)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n        x \\<Longrightarrow>\n       x = real_of_rat r1 * real_of_1 (p2, l2, r2)", "assume \"root_cond (?mp,l,r) z\""], ["proof (state)\nthis:\n  root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r) z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n        x \\<Longrightarrow>\n       x = real_of_rat r1 * real_of_1 (p2, l2, r2)", "from this[unfolded root_cond_def split]"], ["proof (chain)\npicking this:\n  real_of_rat l \\<le> z \\<and>\n  z \\<le> real_of_rat r \\<and>\n  poly (real_of_int_poly (cf_pos_poly (poly_mult_rat r1 p2))) z = 0", "have bndz: \"of_rat l \\<le> z\" \"z \\<le> of_rat r\" \n      and rt: \"ipoly ?mp z = 0\""], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> z \\<and>\n  z \\<le> real_of_rat r \\<and>\n  poly (real_of_int_poly (cf_pos_poly (poly_mult_rat r1 p2))) z = 0\n\ngoal (1 subgoal):\n 1. (real_of_rat l \\<le> z &&& z \\<le> real_of_rat r) &&&\n    poly (real_of_int_poly (cf_pos_poly (poly_mult_rat r1 p2))) z = 0", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> z\n  z \\<le> real_of_rat r\n  poly (real_of_int_poly (cf_pos_poly (poly_mult_rat r1 p2))) z = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n        x \\<Longrightarrow>\n       x = real_of_rat r1 * real_of_1 (p2, l2, r2)", "have \"fst (quotient_of r1) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (quotient_of r1) \\<noteq> 0", "using quotient_of_div[of r1] r10"], ["proof (prove)\nusing this:\n  quotient_of r1 = (?n, ?d) \\<Longrightarrow>\n  r1 = rat_of_int ?n / rat_of_int ?d\n  r1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fst (quotient_of r1) \\<noteq> 0", "by (cases \"quotient_of r1\", auto)"], ["proof (state)\nthis:\n  fst (quotient_of r1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n        x \\<Longrightarrow>\n       x = real_of_rat r1 * real_of_1 (p2, l2, r2)", "with rt"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly (cf_pos_poly (poly_mult_rat r1 p2))) z = 0\n  fst (quotient_of r1) \\<noteq> 0", "have rt: \"ipoly p2 (z * inverse ?x) = 0\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly (cf_pos_poly (poly_mult_rat r1 p2))) z = 0\n  fst (quotient_of r1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p2) (z * inverse (real_of_rat r1)) = 0", "by (auto simp: ipoly_mult_rat[OF r10])"], ["proof (state)\nthis:\n  poly (real_of_int_poly p2) (z * inverse (real_of_rat r1)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n        x \\<Longrightarrow>\n       x = real_of_rat r1 * real_of_1 (p2, l2, r2)", "from bndz r1"], ["proof (chain)\npicking this:\n  real_of_rat l \\<le> z\n  z \\<le> real_of_rat r\n  0 < r1", "have \"of_rat l2 \\<le> z * inverse ?x\" \"z * inverse ?x \\<le> of_rat r2\""], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> z\n  z \\<le> real_of_rat r\n  0 < r1\n\ngoal (1 subgoal):\n 1. real_of_rat l2 \\<le> z * inverse (real_of_rat r1) &&&\n    z * inverse (real_of_rat r1) \\<le> real_of_rat r2", "unfolding lr of_rat_mult"], ["proof (prove)\nusing this:\n  real_of_rat l2 * real_of_rat r1 \\<le> z\n  z \\<le> real_of_rat r2 * real_of_rat r1\n  0 < r1\n\ngoal (1 subgoal):\n 1. real_of_rat l2 \\<le> z * inverse (real_of_rat r1) &&&\n    z * inverse (real_of_rat r1) \\<le> real_of_rat r2", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  real_of_rat l2 \\<le> z * inverse (real_of_rat r1)\n  z * inverse (real_of_rat r1) \\<le> real_of_rat r2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n        x \\<Longrightarrow>\n       x = real_of_rat r1 * real_of_1 (p2, l2, r2)", "with rt"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly p2) (z * inverse (real_of_rat r1)) = 0\n  real_of_rat l2 \\<le> z * inverse (real_of_rat r1)\n  z * inverse (real_of_rat r1) \\<le> real_of_rat r2", "have \"root_cond (p2,l2,r2) (z * inverse ?x)\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p2) (z * inverse (real_of_rat r1)) = 0\n  real_of_rat l2 \\<le> z * inverse (real_of_rat r1)\n  z * inverse (real_of_rat r1) \\<le> real_of_rat r2\n\ngoal (1 subgoal):\n 1. root_cond (p2, l2, r2) (z * inverse (real_of_rat r1))", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p2) (z * inverse (real_of_rat r1)) = 0\n  real_of_rat l2 \\<le> z * inverse (real_of_rat r1)\n  z * inverse (real_of_rat r1) \\<le> real_of_rat r2\n\ngoal (1 subgoal):\n 1. case (p2, l2, r2) of\n    (p, l, r) \\<Rightarrow>\n      real_of_rat l \\<le> z * inverse (real_of_rat r1) \\<and>\n      z * inverse (real_of_rat r1) \\<le> real_of_rat r \\<and>\n      poly (real_of_int_poly p) (z * inverse (real_of_rat r1)) = 0", "by auto"], ["proof (state)\nthis:\n  root_cond (p2, l2, r2) (z * inverse (real_of_rat r1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n        x \\<Longrightarrow>\n       x = real_of_rat r1 * real_of_1 (p2, l2, r2)", "also"], ["proof (state)\nthis:\n  root_cond (p2, l2, r2) (z * inverse (real_of_rat r1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n        x \\<Longrightarrow>\n       x = real_of_rat r1 * real_of_1 (p2, l2, r2)", "note invariant_1_root_cond[OF y]"], ["proof (state)\nthis:\n  root_cond (p2, l2, r2) ?y = (?y = real_of_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n        x \\<Longrightarrow>\n       x = real_of_rat r1 * real_of_1 (p2, l2, r2)", "finally"], ["proof (chain)\npicking this:\n  z * inverse (real_of_rat r1) = real_of_1 (p2, l2, r2)", "have \"?y = z * inverse ?x\""], ["proof (prove)\nusing this:\n  z * inverse (real_of_rat r1) = real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. real_of_1 (p2, l2, r2) = z * inverse (real_of_rat r1)", "by auto"], ["proof (state)\nthis:\n  real_of_1 (p2, l2, r2) = z * inverse (real_of_rat r1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n        x \\<Longrightarrow>\n       x = real_of_rat r1 * real_of_1 (p2, l2, r2)", "thus \"z = ?x * ?y\""], ["proof (prove)\nusing this:\n  real_of_1 (p2, l2, r2) = z * inverse (real_of_rat r1)\n\ngoal (1 subgoal):\n 1. z = real_of_rat r1 * real_of_1 (p2, l2, r2)", "using r1"], ["proof (prove)\nusing this:\n  real_of_1 (p2, l2, r2) = z * inverse (real_of_rat r1)\n  0 < r1\n\ngoal (1 subgoal):\n 1. z = real_of_rat r1 * real_of_1 (p2, l2, r2)", "by auto"], ["proof (state)\nthis:\n  z = real_of_rat r1 * real_of_1 (p2, l2, r2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r) x\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "from r1"], ["proof (chain)\npicking this:\n  0 < r1", "have sgnr: \"sgn r = sgn r2\""], ["proof (prove)\nusing this:\n  0 < r1\n\ngoal (1 subgoal):\n 1. sgn r = sgn r2", "unfolding lr"], ["proof (prove)\nusing this:\n  0 < r1\n\ngoal (1 subgoal):\n 1. sgn (r2 * r1) = sgn r2", "by (cases \"r2 = 0\"; cases \"r2 < 0\"; auto simp: mult_neg_pos mult_less_0_iff)"], ["proof (state)\nthis:\n  sgn r = sgn r2\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "from r1"], ["proof (chain)\npicking this:\n  0 < r1", "have sgnl: \"sgn l = sgn l2\""], ["proof (prove)\nusing this:\n  0 < r1\n\ngoal (1 subgoal):\n 1. sgn l = sgn l2", "unfolding lr"], ["proof (prove)\nusing this:\n  0 < r1\n\ngoal (1 subgoal):\n 1. sgn (l2 * r1) = sgn l2", "by (cases \"l2 = 0\"; cases \"l2 < 0\"; auto simp: mult_neg_pos mult_less_0_iff)"], ["proof (state)\nthis:\n  sgn l = sgn l2\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "from the_unique_root_eqI[OF ur rc]"], ["proof (chain)\npicking this:\n  real_of_rat r1 * real_of_1 (p2, l2, r2) =\n  real_of_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n  real_of_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r) =\n  real_of_rat r1 * real_of_1 (p2, l2, r2)", "have xy: \"?x * ?y = the_unique_root (?mp,l,r)\""], ["proof (prove)\nusing this:\n  real_of_rat r1 * real_of_1 (p2, l2, r2) =\n  real_of_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n  real_of_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r) =\n  real_of_rat r1 * real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. real_of_rat r1 * real_of_1 (p2, l2, r2) =\n    real_of_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r)", "by auto"], ["proof (state)\nthis:\n  real_of_rat r1 * real_of_1 (p2, l2, r2) =\n  real_of_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "from z[unfolded yt, simplified, unfolded Let_def lr[symmetric] split]"], ["proof (chain)\npicking this:\n  z \\<equiv> real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)", "have z: \"z = real_alg_2 (?mp, l, r)\""], ["proof (prove)\nusing this:\n  z \\<equiv> real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n\ngoal (1 subgoal):\n 1. z = real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)", "by simp"], ["proof (state)\nthis:\n  z = real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "have yp2: \"p2 represents ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p2 represents real_of_1 (p2, l2, r2)", "using yD"], ["proof (prove)\nusing this:\n  root_cond (p2, l2, r2) (real_of_1 (p2, l2, r2))\n  sgn (rai_lb (p2, l2, r2)) = sgn (rai_ub (p2, l2, r2))\n  sgn (real_of_1 (p2, l2, r2)) = real_of_rat (sgn (rai_ub (p2, l2, r2)))\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  poly_cond (poly_real_alg_1 (p2, l2, r2))\n  0 < degree (poly_real_alg_1 (p2, l2, r2))\n  primitive (poly_real_alg_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. p2 represents real_of_1 (p2, l2, r2)", "unfolding root_cond_def split represents_def"], ["proof (prove)\nusing this:\n  real_of_rat l2\n  \\<le> (THE x.\n            real_of_rat l2 \\<le> x \\<and>\n            x \\<le> real_of_rat r2 \\<and>\n            poly (real_of_int_poly p2) x = 0) \\<and>\n  (THE x.\n      real_of_rat l2 \\<le> x \\<and>\n      x \\<le> real_of_rat r2 \\<and> poly (real_of_int_poly p2) x = 0)\n  \\<le> real_of_rat r2 \\<and>\n  poly (real_of_int_poly p2)\n   (THE x.\n       real_of_rat l2 \\<le> x \\<and>\n       x \\<le> real_of_rat r2 \\<and> poly (real_of_int_poly p2) x = 0) =\n  0\n  sgn (rai_lb (p2, l2, r2)) = sgn (rai_ub (p2, l2, r2))\n  sgn (THE x.\n          real_of_rat l2 \\<le> x \\<and>\n          x \\<le> real_of_rat r2 \\<and> poly (real_of_int_poly p2) x = 0) =\n  real_of_rat (sgn (rai_ub (p2, l2, r2)))\n  \\<exists>!x.\n     real_of_rat l2 \\<le> x \\<and>\n     x \\<le> real_of_rat r2 \\<and> poly (real_of_int_poly p2) x = 0\n  poly_cond (poly_real_alg_1 (p2, l2, r2))\n  0 < degree (poly_real_alg_1 (p2, l2, r2))\n  primitive (poly_real_alg_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p2)\n     (THE x.\n         real_of_rat l2 \\<le> x \\<and>\n         x \\<le> real_of_rat r2 \\<and> poly (real_of_int_poly p2) x = 0) =\n    0 \\<and>\n    p2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p2 represents real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "with irr mon"], ["proof (chain)\npicking this:\n  irreducible (cf_pos_poly (poly_mult_rat r1 p2))\n  cf_pos (cf_pos_poly (poly_mult_rat r1 p2))\n  p2 represents real_of_1 (p2, l2, r2)", "have pc: \"poly_cond ?mp\""], ["proof (prove)\nusing this:\n  irreducible (cf_pos_poly (poly_mult_rat r1 p2))\n  cf_pos (cf_pos_poly (poly_mult_rat r1 p2))\n  p2 represents real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. poly_cond (cf_pos_poly (poly_mult_rat r1 p2))", "by (auto simp: poly_cond_def cf_pos_def)"], ["proof (state)\nthis:\n  poly_cond (cf_pos_poly (poly_mult_rat r1 p2))\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "have rc: \"invariant_1 (?mp, l, r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r)", "unfolding z"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r)", "using yD(2) pc ur"], ["proof (prove)\nusing this:\n  sgn (rai_lb (p2, l2, r2)) = sgn (rai_ub (p2, l2, r2))\n  poly_cond (cf_pos_poly (poly_mult_rat r1 p2))\n  \\<exists>!x. root_cond (cf_pos_poly (poly_mult_rat r1 p2), l, r) x\n\ngoal (1 subgoal):\n 1. invariant_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r)", "by (auto simp add: invariant_1_def ur mp sgnr sgnl)"], ["proof (state)\nthis:\n  invariant_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y", "unfolding z"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2\n     (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)) \\<and>\n    real_of_2 (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)) =\n    real_of_rat r1 * real_of_1 y", "using real_alg_2[OF rc]"], ["proof (prove)\nusing this:\n  invariant_2 (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r))\n  real_of_2 (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)) =\n  real_of_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n\ngoal (1 subgoal):\n 1. invariant_2\n     (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)) \\<and>\n    real_of_2 (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)) =\n    real_of_rat r1 * real_of_1 y", "unfolding yt xy"], ["proof (prove)\nusing this:\n  invariant_2 (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r))\n  real_of_2 (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)) =\n  real_of_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n\ngoal (1 subgoal):\n 1. invariant_2\n     (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)) \\<and>\n    real_of_2 (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)) =\n    real_of_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r)", "unfolding z"], ["proof (prove)\nusing this:\n  invariant_2 (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r))\n  real_of_2 (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)) =\n  real_of_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r)\n\ngoal (1 subgoal):\n 1. invariant_2\n     (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)) \\<and>\n    real_of_2 (real_alg_2 (cf_pos_poly (poly_mult_rat r1 p2), l, r)) =\n    real_of_1 (cf_pos_poly (poly_mult_rat r1 p2), l, r)", "by simp"], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_rat r1 * real_of_1 y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_1_pos: assumes x: \"invariant_1_2 x\" and y: \"invariant_1_2 y\"\n  defines z: \"z \\<equiv> mult_1_pos x y\"\n  assumes pos: \"real_of_1 x > 0\" \"real_of_1 y > 0\"\n  shows \"invariant_2 z \\<and> (real_of_2 z = real_of_1 x * real_of_1 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "obtain p1 l1 r1 where xt: \"x = (p1,l1,r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 l1 r1.\n        x = (p1, l1, r1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x, auto)"], ["proof (state)\nthis:\n  x = (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "obtain p2 l2 r2 where yt: \"y = (p2,l2,r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2 l2 r2.\n        y = (p2, l2, r2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases y, auto)"], ["proof (state)\nthis:\n  y = (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?x = \"real_of_1 (p1, l1, r1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?y = \"real_of_1 (p2, l2, r2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?r = \"real_of_rat\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?p = \"poly_mult p1 p2\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "note x = x[unfolded xt]"], ["proof (state)\nthis:\n  invariant_1_2 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "note y = y[unfolded yt]"], ["proof (state)\nthis:\n  invariant_1_2 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from x y"], ["proof (chain)\npicking this:\n  invariant_1_2 (p1, l1, r1)\n  invariant_1_2 (p2, l2, r2)", "have basic: \"unique_root (p1, l1, r1)\" \"poly_cond2 p1\" \"unique_root (p2, l2, r2)\" \"poly_cond2 p2\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p1, l1, r1)\n  invariant_1_2 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (p1, l1, r1) x &&& poly_cond2 p1) &&&\n    \\<exists>!x. root_cond (p2, l2, r2) x &&& poly_cond2 p2", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  poly_cond2 p1\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  poly_cond2 p2\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from basic"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  poly_cond2 p1\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  poly_cond2 p2", "have irr1: \"irreducible p1\" and irr2: \"irreducible p2\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  poly_cond2 p1\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  poly_cond2 p2\n\ngoal (1 subgoal):\n 1. irreducible p1 &&& irreducible p2", "by auto"], ["proof (state)\nthis:\n  irreducible p1\n  irreducible p2\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from x"], ["proof (chain)\npicking this:\n  invariant_1_2 (p1, l1, r1)", "have ax: \"p1 represents ?x\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. p1 represents real_of_1 (p1, l1, r1)", "unfolding represents_def"], ["proof (prove)\nusing this:\n  invariant_1_2 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p1) (real_of_1 (p1, l1, r1)) = 0 \\<and>\n    p1 \\<noteq> 0", "by (auto elim!:invariant_1E)"], ["proof (state)\nthis:\n  p1 represents real_of_1 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from y"], ["proof (chain)\npicking this:\n  invariant_1_2 (p2, l2, r2)", "have ay: \"p2 represents ?y\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. p2 represents real_of_1 (p2, l2, r2)", "unfolding represents_def"], ["proof (prove)\nusing this:\n  invariant_1_2 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p2) (real_of_1 (p2, l2, r2)) = 0 \\<and>\n    p2 \\<noteq> 0", "by (auto elim!:invariant_1E)"], ["proof (state)\nthis:\n  p2 represents real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from ax ay pos[unfolded xt yt]"], ["proof (chain)\npicking this:\n  p1 represents real_of_1 (p1, l1, r1)\n  p2 represents real_of_1 (p2, l2, r2)\n  0 < real_of_1 (p1, l1, r1)\n  0 < real_of_1 (p2, l2, r2)", "have axy: \"?p represents (?x * ?y)\""], ["proof (prove)\nusing this:\n  p1 represents real_of_1 (p1, l1, r1)\n  p2 represents real_of_1 (p2, l2, r2)\n  0 < real_of_1 (p1, l1, r1)\n  0 < real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. poly_mult p1 p2 represents\n    real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)", "by (intro represents_mult represents_irr_non_0[OF irr2], auto)"], ["proof (state)\nthis:\n  poly_mult p1 p2 represents real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from representsD[OF this]"], ["proof (chain)\npicking this:\n  poly_mult p1 p2 \\<noteq> 0\n  poly (real_of_int_poly (poly_mult p1 p2))\n   (real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)) =\n  0", "have p: \"?p \\<noteq> 0\" and rt: \"ipoly ?p (?x * ?y) = 0\""], ["proof (prove)\nusing this:\n  poly_mult p1 p2 \\<noteq> 0\n  poly (real_of_int_poly (poly_mult p1 p2))\n   (real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)) =\n  0\n\ngoal (1 subgoal):\n 1. poly_mult p1 p2 \\<noteq> 0 &&&\n    poly (real_of_int_poly (poly_mult p1 p2))\n     (real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)) =\n    0", "."], ["proof (state)\nthis:\n  poly_mult p1 p2 \\<noteq> 0\n  poly (real_of_int_poly (poly_mult p1 p2))\n   (real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)) =\n  0\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from x pos(1)[unfolded xt]"], ["proof (chain)\npicking this:\n  invariant_1_2 (p1, l1, r1)\n  0 < real_of_1 (p1, l1, r1)", "have \"?r r1 > 0\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p1, l1, r1)\n  0 < real_of_1 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat r1", "unfolding split"], ["proof (prove)\nusing this:\n  invariant_1_2 (p1, l1, r1)\n  0 < real_of_1 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat r1", "by auto"], ["proof (state)\nthis:\n  0 < real_of_rat r1\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "hence \"sgn r1 = 1\""], ["proof (prove)\nusing this:\n  0 < real_of_rat r1\n\ngoal (1 subgoal):\n 1. sgn r1 = 1", "unfolding sgn_rat_def"], ["proof (prove)\nusing this:\n  0 < real_of_rat r1\n\ngoal (1 subgoal):\n 1. (if r1 = 0 then 0 else if 0 < r1 then 1 else - 1) = 1", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  sgn r1 = 1\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "with x"], ["proof (chain)\npicking this:\n  invariant_1_2 (p1, l1, r1)\n  sgn r1 = 1", "have \"sgn l1 = 1\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p1, l1, r1)\n  sgn r1 = 1\n\ngoal (1 subgoal):\n 1. sgn l1 = 1", "by auto"], ["proof (state)\nthis:\n  sgn l1 = 1\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "hence l1_pos: \"l1 > 0\""], ["proof (prove)\nusing this:\n  sgn l1 = 1\n\ngoal (1 subgoal):\n 1. 0 < l1", "unfolding sgn_rat_def"], ["proof (prove)\nusing this:\n  (if l1 = 0 then 0 else if 0 < l1 then 1 else - 1) = 1\n\ngoal (1 subgoal):\n 1. 0 < l1", "by (cases \"l1 = 0\"; cases \"l1 < 0\"; auto)"], ["proof (state)\nthis:\n  0 < l1\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from y pos(2)[unfolded yt]"], ["proof (chain)\npicking this:\n  invariant_1_2 (p2, l2, r2)\n  0 < real_of_1 (p2, l2, r2)", "have \"?r r2 > 0\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p2, l2, r2)\n  0 < real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat r2", "unfolding split"], ["proof (prove)\nusing this:\n  invariant_1_2 (p2, l2, r2)\n  0 < real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat r2", "by auto"], ["proof (state)\nthis:\n  0 < real_of_rat r2\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "hence \"sgn r2 = 1\""], ["proof (prove)\nusing this:\n  0 < real_of_rat r2\n\ngoal (1 subgoal):\n 1. sgn r2 = 1", "unfolding sgn_rat_def"], ["proof (prove)\nusing this:\n  0 < real_of_rat r2\n\ngoal (1 subgoal):\n 1. (if r2 = 0 then 0 else if 0 < r2 then 1 else - 1) = 1", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  sgn r2 = 1\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "with y"], ["proof (chain)\npicking this:\n  invariant_1_2 (p2, l2, r2)\n  sgn r2 = 1", "have \"sgn l2 = 1\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p2, l2, r2)\n  sgn r2 = 1\n\ngoal (1 subgoal):\n 1. sgn l2 = 1", "by auto"], ["proof (state)\nthis:\n  sgn l2 = 1\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "hence l2_pos: \"l2 > 0\""], ["proof (prove)\nusing this:\n  sgn l2 = 1\n\ngoal (1 subgoal):\n 1. 0 < l2", "unfolding sgn_rat_def"], ["proof (prove)\nusing this:\n  (if l2 = 0 then 0 else if 0 < l2 then 1 else - 1) = 1\n\ngoal (1 subgoal):\n 1. 0 < l2", "by (cases \"l2 = 0\"; cases \"l2 < 0\"; auto)"], ["proof (state)\nthis:\n  0 < l2\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?bnd = \"(\\<lambda>((l1, r1, sr1 :: rat), l2 :: rat, r2 :: rat, sr2 :: rat). (l1 * l2, r1 * r2))\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "define bnd where \"bnd = ?bnd\""], ["proof (state)\nthis:\n  bnd = (\\<lambda>((l1, r1, sr1), l2, r2, sr2). (l1 * l2, r1 * r2))\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "obtain z' where sel: \"select_correct_factor_int_poly\n        (tighten_poly_bounds_binary p1 p2)\n        bnd \n        ((l1,r1,sgn (ipoly p1 r1)),(l2,r2, sgn (ipoly p2 r2))) \n        ?p = z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        select_correct_factor_int_poly (tighten_poly_bounds_binary p1 p2)\n         bnd ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))\n         (poly_mult p1 p2) =\n        z' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  select_correct_factor_int_poly (tighten_poly_bounds_binary p1 p2) bnd\n   ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))\n   (poly_mult p1 p2) =\n  z'\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "have main: \"invariant_2 z' \\<and> real_of_2 z' = ?x * ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 z' \\<and>\n    real_of_2 z' = real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)", "proof (rule select_correct_factor_int_poly[OF _ sel rt p])"], ["proof (state)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))))\n     (real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))))\n     (real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2))", "fix l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' :: rat"], ["proof (state)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1__, r1__, sgn (ipoly p1 r1__)), l2__, r2__,\n                sgn (ipoly p2 r2__))))\n     (real_of_1 (p1, l1__, r1__) * real_of_1 (p2, l2__, r2__))", "let ?m1 = \"(l1+r1)/2\""], ["proof (state)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1__, r1__, sgn (ipoly p1 r1__)), l2__, r2__,\n                sgn (ipoly p2 r2__))))\n     (real_of_1 (p1, l1__, r1__) * real_of_1 (p2, l2__, r2__))", "let ?m2 = \"(l2+r2)/2\""], ["proof (state)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1__, r1__, sgn (ipoly p1 r1__)), l2__, r2__,\n                sgn (ipoly p2 r2__))))\n     (real_of_1 (p1, l1__, r1__) * real_of_1 (p2, l2__, r2__))", "define d1 where \"d1 = r1 - l1\""], ["proof (state)\nthis:\n  d1 = r1 - l1\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1__, r1__, sgn (ipoly p1 r1__)), l2__, r2__,\n                sgn (ipoly p2 r2__))))\n     (real_of_1 (p1, l1__, r1__) * real_of_1 (p2, l2__, r2__))", "define d2 where \"d2 = r2 - l2\""], ["proof (state)\nthis:\n  d2 = r2 - l2\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1__, r1__, sgn (ipoly p1 r1__)), l2__, r2__,\n                sgn (ipoly p2 r2__))))\n     (real_of_1 (p1, l1__, r1__) * real_of_1 (p2, l2__, r2__))", "let ?M1 = \"l1 + d1/2\""], ["proof (state)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1__, r1__, sgn (ipoly p1 r1__)), l2__, r2__,\n                sgn (ipoly p2 r2__))))\n     (real_of_1 (p1, l1__, r1__) * real_of_1 (p2, l2__, r2__))", "let ?M2 = \"l2 + d2/2\""], ["proof (state)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1__, r1__, sgn (ipoly p1 r1__)), l2__, r2__,\n                sgn (ipoly p2 r2__))))\n     (real_of_1 (p1, l1__, r1__) * real_of_1 (p2, l2__, r2__))", "assume le: \"l1 > 0\" \"l2 > 0\" \"l1 \\<le> r1\" \"l2 \\<le> r2\" and id: \"(l, r) = (l1 * l2, r1 * r2)\"\n        \"(l', r') = (l1' * l2', r1' * r2')\" \n        and mem: \"(l1', r1') \\<in> {(l1, ?m1), (?m1, r1)}\"\n          \"(l2', r2') \\<in> {(l2, ?m2), (?m2, r2)}\""], ["proof (state)\nthis:\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2\n  (l, r) = (l1 * l2, r1 * r2)\n  (l', r') = (l1' * l2', r1' * r2')\n  (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)}\n  (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1__, r1__, sgn (ipoly p1 r1__)), l2__, r2__,\n                sgn (ipoly p2 r2__))))\n     (real_of_1 (p1, l1__, r1__) * real_of_1 (p2, l2__, r2__))", "hence id: \"l = l1 * l2\" \"r = (l1 + d1) * (l2 + d2)\" \"l' = l1' * l2'\" \"r' = r1' * r2'\" \n        \"r1 = l1 + d1\" \"r2 = l2 + d2\" and id': \"?m1 = ?M1\" \"?m2 = ?M2\""], ["proof (prove)\nusing this:\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2\n  (l, r) = (l1 * l2, r1 * r2)\n  (l', r') = (l1' * l2', r1' * r2')\n  (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)}\n  (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\n\ngoal (1 subgoal):\n 1. ((l = l1 * l2 &&& r = (l1 + d1) * (l2 + d2) &&& l' = l1' * l2') &&&\n     r' = r1' * r2' &&& r1 = l1 + d1 &&& r2 = l2 + d2) &&&\n    (l1 + r1) / 2 = l1 + d1 / 2 &&& (l2 + r2) / 2 = l2 + d2 / 2", "unfolding d1_def d2_def"], ["proof (prove)\nusing this:\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2\n  (l, r) = (l1 * l2, r1 * r2)\n  (l', r') = (l1' * l2', r1' * r2')\n  (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)}\n  (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\n\ngoal (1 subgoal):\n 1. ((l = l1 * l2 &&&\n      r = (l1 + (r1 - l1)) * (l2 + (r2 - l2)) &&& l' = l1' * l2') &&&\n     r' = r1' * r2' &&& r1 = l1 + (r1 - l1) &&& r2 = l2 + (r2 - l2)) &&&\n    (l1 + r1) / 2 = l1 + (r1 - l1) / 2 &&&\n    (l2 + r2) / 2 = l2 + (r2 - l2) / 2", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  l = l1 * l2\n  r = (l1 + d1) * (l2 + d2)\n  l' = l1' * l2'\n  r' = r1' * r2'\n  r1 = l1 + d1\n  r2 = l2 + d2\n  (l1 + r1) / 2 = l1 + d1 / 2\n  (l2 + r2) / 2 = l2 + d2 / 2\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1__, r1__, sgn (ipoly p1 r1__)), l2__, r2__,\n                sgn (ipoly p2 r2__))))\n     (real_of_1 (p1, l1__, r1__) * real_of_1 (p2, l2__, r2__))", "define l1d1 where \"l1d1 = l1 + d1\""], ["proof (state)\nthis:\n  l1d1 = l1 + d1\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1__, r1__, sgn (ipoly p1 r1__)), l2__, r2__,\n                sgn (ipoly p2 r2__))))\n     (real_of_1 (p1, l1__, r1__) * real_of_1 (p2, l2__, r2__))", "from le"], ["proof (chain)\npicking this:\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2", "have ge0: \"d1 \\<ge> 0\" \"d2 \\<ge> 0\" \"l1 \\<ge> 0\" \"l2 \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2\n\ngoal (1 subgoal):\n 1. (0 \\<le> d1 &&& 0 \\<le> d2) &&& 0 \\<le> l1 &&& 0 \\<le> l2", "unfolding d1_def d2_def"], ["proof (prove)\nusing this:\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2\n\ngoal (1 subgoal):\n 1. (0 \\<le> r1 - l1 &&& 0 \\<le> r2 - l2) &&& 0 \\<le> l1 &&& 0 \\<le> l2", "by auto"], ["proof (state)\nthis:\n  0 \\<le> d1\n  0 \\<le> d2\n  0 \\<le> l1\n  0 \\<le> l2\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1__, r1__, sgn (ipoly p1 r1__)), l2__, r2__,\n                sgn (ipoly p2 r2__))))\n     (real_of_1 (p1, l1__, r1__) * real_of_1 (p2, l2__, r2__))", "have \"4 * (r' - l') \\<le> 3 * (r - l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (r' - l') \\<le> 3 * (r - l)", "proof (cases \"l1' = l1 \\<and> r1' = ?M1 \\<and> l2' = l2 \\<and> r2' = ?M2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l1' = l1 \\<and>\n    r1' = l1 + d1 / 2 \\<and>\n    l2' = l2 \\<and> r2' = l2 + d2 / 2 \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)\n 2. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "case True"], ["proof (state)\nthis:\n  l1' = l1 \\<and> r1' = l1 + d1 / 2 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2\n\ngoal (2 subgoals):\n 1. l1' = l1 \\<and>\n    r1' = l1 + d1 / 2 \\<and>\n    l2' = l2 \\<and> r2' = l2 + d2 / 2 \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)\n 2. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "hence id2: \"l1' = l1\" \"r1' = ?M1\" \"l2' = l2\" \"r2' = ?M2\""], ["proof (prove)\nusing this:\n  l1' = l1 \\<and> r1' = l1 + d1 / 2 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2\n\ngoal (1 subgoal):\n 1. (l1' = l1 &&& r1' = l1 + d1 / 2) &&& l2' = l2 &&& r2' = l2 + d2 / 2", "by auto"], ["proof (state)\nthis:\n  l1' = l1\n  r1' = l1 + d1 / 2\n  l2' = l2\n  r2' = l2 + d2 / 2\n\ngoal (2 subgoals):\n 1. l1' = l1 \\<and>\n    r1' = l1 + d1 / 2 \\<and>\n    l2' = l2 \\<and> r2' = l2 + d2 / 2 \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)\n 2. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (r' - l') \\<le> 3 * (r - l)", "unfolding id id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * ((l1 + d1 / 2) * (l2 + d2 / 2) - l1 * l2)\n    \\<le> 3 * ((l1 + d1) * (l2 + d2) - l1 * l2)", "unfolding ring_distribs"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (l1 * l2) + 4 * (d1 / 2 * l2) +\n    (4 * (l1 * (d2 / 2)) + 4 * (d1 / 2 * (d2 / 2))) -\n    4 * (l1 * l2)\n    \\<le> 3 * (l1 * l2) + 3 * (d1 * l2) + (3 * (l1 * d2) + 3 * (d1 * d2)) -\n          3 * (l1 * l2)", "using ge0"], ["proof (prove)\nusing this:\n  0 \\<le> d1\n  0 \\<le> d2\n  0 \\<le> l1\n  0 \\<le> l2\n\ngoal (1 subgoal):\n 1. 4 * (l1 * l2) + 4 * (d1 / 2 * l2) +\n    (4 * (l1 * (d2 / 2)) + 4 * (d1 / 2 * (d2 / 2))) -\n    4 * (l1 * l2)\n    \\<le> 3 * (l1 * l2) + 3 * (d1 * l2) + (3 * (l1 * d2) + 3 * (d1 * d2)) -\n          3 * (l1 * l2)", "by simp"], ["proof (state)\nthis:\n  4 * (r' - l') \\<le> 3 * (r - l)\n\ngoal (1 subgoal):\n 1. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "case False"], ["proof (state)\nthis:\n  \\<not> (l1' = l1 \\<and>\n          r1' = l1 + d1 / 2 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2)\n\ngoal (1 subgoal):\n 1. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "note 1 = this"], ["proof (state)\nthis:\n  \\<not> (l1' = l1 \\<and>\n          r1' = l1 + d1 / 2 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2)\n\ngoal (1 subgoal):\n 1. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (r' - l') \\<le> 3 * (r - l)", "proof (cases \"l1' = l1 \\<and> r1' = ?M1 \\<and> l2' = ?M2 \\<and> r2' = r2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l1' = l1 \\<and>\n    r1' = l1 + d1 / 2 \\<and>\n    l2' = l2 + d2 / 2 \\<and> r2' = r2 \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)\n 2. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 + d2 / 2 \\<and> r2' = r2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "case True"], ["proof (state)\nthis:\n  l1' = l1 \\<and> r1' = l1 + d1 / 2 \\<and> l2' = l2 + d2 / 2 \\<and> r2' = r2\n\ngoal (2 subgoals):\n 1. l1' = l1 \\<and>\n    r1' = l1 + d1 / 2 \\<and>\n    l2' = l2 + d2 / 2 \\<and> r2' = r2 \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)\n 2. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 + d2 / 2 \\<and> r2' = r2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "hence id2: \"l1' = l1\" \"r1' = ?M1\" \"l2' = ?M2\" \"r2' = r2\""], ["proof (prove)\nusing this:\n  l1' = l1 \\<and> r1' = l1 + d1 / 2 \\<and> l2' = l2 + d2 / 2 \\<and> r2' = r2\n\ngoal (1 subgoal):\n 1. (l1' = l1 &&& r1' = l1 + d1 / 2) &&& l2' = l2 + d2 / 2 &&& r2' = r2", "by auto"], ["proof (state)\nthis:\n  l1' = l1\n  r1' = l1 + d1 / 2\n  l2' = l2 + d2 / 2\n  r2' = r2\n\ngoal (2 subgoals):\n 1. l1' = l1 \\<and>\n    r1' = l1 + d1 / 2 \\<and>\n    l2' = l2 + d2 / 2 \\<and> r2' = r2 \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)\n 2. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 + d2 / 2 \\<and> r2' = r2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (r' - l') \\<le> 3 * (r - l)", "unfolding id id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * ((l1 + d1 / 2) * (l2 + d2) - l1 * (l2 + d2 / 2))\n    \\<le> 3 * ((l1 + d1) * (l2 + d2) - l1 * l2)", "unfolding ring_distribs"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (l1 * l2) + 4 * (d1 / 2 * l2) +\n    (4 * (l1 * d2) + 4 * (d1 / 2 * d2)) -\n    (4 * (l1 * l2) + 4 * (l1 * (d2 / 2)))\n    \\<le> 3 * (l1 * l2) + 3 * (d1 * l2) + (3 * (l1 * d2) + 3 * (d1 * d2)) -\n          3 * (l1 * l2)", "using ge0"], ["proof (prove)\nusing this:\n  0 \\<le> d1\n  0 \\<le> d2\n  0 \\<le> l1\n  0 \\<le> l2\n\ngoal (1 subgoal):\n 1. 4 * (l1 * l2) + 4 * (d1 / 2 * l2) +\n    (4 * (l1 * d2) + 4 * (d1 / 2 * d2)) -\n    (4 * (l1 * l2) + 4 * (l1 * (d2 / 2)))\n    \\<le> 3 * (l1 * l2) + 3 * (d1 * l2) + (3 * (l1 * d2) + 3 * (d1 * d2)) -\n          3 * (l1 * l2)", "by simp"], ["proof (state)\nthis:\n  4 * (r' - l') \\<le> 3 * (r - l)\n\ngoal (1 subgoal):\n 1. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 + d2 / 2 \\<and> r2' = r2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 + d2 / 2 \\<and> r2' = r2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "case False"], ["proof (state)\nthis:\n  \\<not> (l1' = l1 \\<and>\n          r1' = l1 + d1 / 2 \\<and> l2' = l2 + d2 / 2 \\<and> r2' = r2)\n\ngoal (1 subgoal):\n 1. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 + d2 / 2 \\<and> r2' = r2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "note 2 = this"], ["proof (state)\nthis:\n  \\<not> (l1' = l1 \\<and>\n          r1' = l1 + d1 / 2 \\<and> l2' = l2 + d2 / 2 \\<and> r2' = r2)\n\ngoal (1 subgoal):\n 1. \\<not> (l1' = l1 \\<and>\n            r1' = l1 + d1 / 2 \\<and>\n            l2' = l2 + d2 / 2 \\<and> r2' = r2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (r' - l') \\<le> 3 * (r - l)", "proof (cases \"l1' = ?M1 \\<and> r1' = r1 \\<and> l2' = l2 \\<and> r2' = ?M2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l1' = l1 + d1 / 2 \\<and>\n    r1' = r1 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2 \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)\n 2. \\<not> (l1' = l1 + d1 / 2 \\<and>\n            r1' = r1 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "case True"], ["proof (state)\nthis:\n  l1' = l1 + d1 / 2 \\<and> r1' = r1 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2\n\ngoal (2 subgoals):\n 1. l1' = l1 + d1 / 2 \\<and>\n    r1' = r1 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2 \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)\n 2. \\<not> (l1' = l1 + d1 / 2 \\<and>\n            r1' = r1 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "hence id2: \"l1' = ?M1\" \"r1' = r1\" \"l2' = l2\" \"r2' = ?M2\""], ["proof (prove)\nusing this:\n  l1' = l1 + d1 / 2 \\<and> r1' = r1 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2\n\ngoal (1 subgoal):\n 1. (l1' = l1 + d1 / 2 &&& r1' = r1) &&& l2' = l2 &&& r2' = l2 + d2 / 2", "by auto"], ["proof (state)\nthis:\n  l1' = l1 + d1 / 2\n  r1' = r1\n  l2' = l2\n  r2' = l2 + d2 / 2\n\ngoal (2 subgoals):\n 1. l1' = l1 + d1 / 2 \\<and>\n    r1' = r1 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2 \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)\n 2. \\<not> (l1' = l1 + d1 / 2 \\<and>\n            r1' = r1 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (r' - l') \\<le> 3 * (r - l)", "unfolding id id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * ((l1 + d1) * (l2 + d2 / 2) - (l1 + d1 / 2) * l2)\n    \\<le> 3 * ((l1 + d1) * (l2 + d2) - l1 * l2)", "unfolding ring_distribs"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (l1 * l2) + 4 * (d1 * l2) +\n    (4 * (l1 * (d2 / 2)) + 4 * (d1 * (d2 / 2))) -\n    (4 * (l1 * l2) + 4 * (d1 / 2 * l2))\n    \\<le> 3 * (l1 * l2) + 3 * (d1 * l2) + (3 * (l1 * d2) + 3 * (d1 * d2)) -\n          3 * (l1 * l2)", "using ge0"], ["proof (prove)\nusing this:\n  0 \\<le> d1\n  0 \\<le> d2\n  0 \\<le> l1\n  0 \\<le> l2\n\ngoal (1 subgoal):\n 1. 4 * (l1 * l2) + 4 * (d1 * l2) +\n    (4 * (l1 * (d2 / 2)) + 4 * (d1 * (d2 / 2))) -\n    (4 * (l1 * l2) + 4 * (d1 / 2 * l2))\n    \\<le> 3 * (l1 * l2) + 3 * (d1 * l2) + (3 * (l1 * d2) + 3 * (d1 * d2)) -\n          3 * (l1 * l2)", "by simp"], ["proof (state)\nthis:\n  4 * (r' - l') \\<le> 3 * (r - l)\n\ngoal (1 subgoal):\n 1. \\<not> (l1' = l1 + d1 / 2 \\<and>\n            r1' = r1 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (l1' = l1 + d1 / 2 \\<and>\n            r1' = r1 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "case False"], ["proof (state)\nthis:\n  \\<not> (l1' = l1 + d1 / 2 \\<and>\n          r1' = r1 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2)\n\ngoal (1 subgoal):\n 1. \\<not> (l1' = l1 + d1 / 2 \\<and>\n            r1' = r1 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "note 3 = this"], ["proof (state)\nthis:\n  \\<not> (l1' = l1 + d1 / 2 \\<and>\n          r1' = r1 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2)\n\ngoal (1 subgoal):\n 1. \\<not> (l1' = l1 + d1 / 2 \\<and>\n            r1' = r1 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "from 1 2 3 mem"], ["proof (chain)\npicking this:\n  \\<not> (l1' = l1 \\<and>\n          r1' = l1 + d1 / 2 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2)\n  \\<not> (l1' = l1 \\<and>\n          r1' = l1 + d1 / 2 \\<and> l2' = l2 + d2 / 2 \\<and> r2' = r2)\n  \\<not> (l1' = l1 + d1 / 2 \\<and>\n          r1' = r1 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2)\n  (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)}\n  (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}", "have id2: \"l1' = ?M1\" \"r1' = r1\" \"l2' = ?M2\" \"r2' = r2\""], ["proof (prove)\nusing this:\n  \\<not> (l1' = l1 \\<and>\n          r1' = l1 + d1 / 2 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2)\n  \\<not> (l1' = l1 \\<and>\n          r1' = l1 + d1 / 2 \\<and> l2' = l2 + d2 / 2 \\<and> r2' = r2)\n  \\<not> (l1' = l1 + d1 / 2 \\<and>\n          r1' = r1 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2)\n  (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)}\n  (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\n\ngoal (1 subgoal):\n 1. (l1' = l1 + d1 / 2 &&& r1' = r1) &&& l2' = l2 + d2 / 2 &&& r2' = r2", "unfolding id'"], ["proof (prove)\nusing this:\n  \\<not> (l1' = l1 \\<and>\n          r1' = l1 + d1 / 2 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2)\n  \\<not> (l1' = l1 \\<and>\n          r1' = l1 + d1 / 2 \\<and> l2' = l2 + d2 / 2 \\<and> r2' = r2)\n  \\<not> (l1' = l1 + d1 / 2 \\<and>\n          r1' = r1 \\<and> l2' = l2 \\<and> r2' = l2 + d2 / 2)\n  (l1', r1') \\<in> {(l1, l1 + d1 / 2), (l1 + d1 / 2, r1)}\n  (l2', r2') \\<in> {(l2, l2 + d2 / 2), (l2 + d2 / 2, r2)}\n\ngoal (1 subgoal):\n 1. (l1' = l1 + d1 / 2 &&& r1' = r1) &&& l2' = l2 + d2 / 2 &&& r2' = r2", "by auto"], ["proof (state)\nthis:\n  l1' = l1 + d1 / 2\n  r1' = r1\n  l2' = l2 + d2 / 2\n  r2' = r2\n\ngoal (1 subgoal):\n 1. \\<not> (l1' = l1 + d1 / 2 \\<and>\n            r1' = r1 \\<and>\n            l2' = l2 \\<and> r2' = l2 + d2 / 2) \\<Longrightarrow>\n    4 * (r' - l') \\<le> 3 * (r - l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (r' - l') \\<le> 3 * (r - l)", "unfolding id id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * ((l1 + d1) * (l2 + d2) - (l1 + d1 / 2) * (l2 + d2 / 2))\n    \\<le> 3 * ((l1 + d1) * (l2 + d2) - l1 * l2)", "unfolding ring_distribs"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (l1 * l2) + 4 * (d1 * l2) + (4 * (l1 * d2) + 4 * (d1 * d2)) -\n    (4 * (l1 * l2) + 4 * (d1 / 2 * l2) +\n     (4 * (l1 * (d2 / 2)) + 4 * (d1 / 2 * (d2 / 2))))\n    \\<le> 3 * (l1 * l2) + 3 * (d1 * l2) + (3 * (l1 * d2) + 3 * (d1 * d2)) -\n          3 * (l1 * l2)", "using ge0"], ["proof (prove)\nusing this:\n  0 \\<le> d1\n  0 \\<le> d2\n  0 \\<le> l1\n  0 \\<le> l2\n\ngoal (1 subgoal):\n 1. 4 * (l1 * l2) + 4 * (d1 * l2) + (4 * (l1 * d2) + 4 * (d1 * d2)) -\n    (4 * (l1 * l2) + 4 * (d1 / 2 * l2) +\n     (4 * (l1 * (d2 / 2)) + 4 * (d1 / 2 * (d2 / 2))))\n    \\<le> 3 * (l1 * l2) + 3 * (d1 * l2) + (3 * (l1 * d2) + 3 * (d1 * d2)) -\n          3 * (l1 * l2)", "by simp"], ["proof (state)\nthis:\n  4 * (r' - l') \\<le> 3 * (r - l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  4 * (r' - l') \\<le> 3 * (r - l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  4 * (r' - l') \\<le> 3 * (r - l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  4 * (r' - l') \\<le> 3 * (r - l)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1__, r1__, sgn (ipoly p1 r1__)), l2__, r2__,\n                sgn (ipoly p2 r2__))))\n     (real_of_1 (p1, l1__, r1__) * real_of_1 (p2, l2__, r2__))", "hence \"r' - l' \\<le> 3 / 4 * (r - l)\""], ["proof (prove)\nusing this:\n  4 * (r' - l') \\<le> 3 * (r - l)\n\ngoal (1 subgoal):\n 1. r' - l' \\<le> 3 / 4 * (r - l)", "by simp"], ["proof (state)\nthis:\n  r' - l' \\<le> 3 / 4 * (r - l)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1__, r1__, sgn (ipoly p1 r1__)), l2__, r2__,\n                sgn (ipoly p2 r2__))))\n     (real_of_1 (p1, l1__, r1__) * real_of_1 (p2, l2__, r2__))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?l1a2; 0 < ?l2a2; ?l1a2 \\<le> ?r1a2; ?l2a2 \\<le> ?r2a2;\n   (?l2, ?r2) = (?l1a2 * ?l2a2, ?r1a2 * ?r2a2);\n   (?l'2, ?r'2) = (?l1'2 * ?l2'2, ?r1'2 * ?r2'2);\n   (?l1'2, ?r1'2)\n   \\<in> {(?l1a2, (?l1a2 + ?r1a2) / 2), ((?l1a2 + ?r1a2) / 2, ?r1a2)};\n   (?l2'2, ?r2'2)\n   \\<in> {(?l2a2, (?l2a2 + ?r2a2) / 2),\n          ((?l2a2 + ?r2a2) / 2, ?r2a2)}\\<rbrakk>\n  \\<Longrightarrow> ?r'2 - ?l'2 \\<le> 3 / 4 * (?r2 - ?l2)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))))\n     (real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2))", "note decr = this"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?l1a2; 0 < ?l2a2; ?l1a2 \\<le> ?r1a2; ?l2a2 \\<le> ?r2a2;\n   (?l2, ?r2) = (?l1a2 * ?l2a2, ?r1a2 * ?r2a2);\n   (?l'2, ?r'2) = (?l1'2 * ?l2'2, ?r1'2 * ?r2'2);\n   (?l1'2, ?r1'2)\n   \\<in> {(?l1a2, (?l1a2 + ?r1a2) / 2), ((?l1a2 + ?r1a2) / 2, ?r1a2)};\n   (?l2'2, ?r2'2)\n   \\<in> {(?l2a2, (?l2a2 + ?r2a2) / 2),\n          ((?l2a2 + ?r2a2) / 2, ?r2a2)}\\<rbrakk>\n  \\<Longrightarrow> ?r'2 - ?l'2 \\<le> 3 / 4 * (?r2 - ?l2)\n\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))))\n     (real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2))", "show \"converges_to\n        (\\<lambda>i. bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n        ((l1,r1,sgn (ipoly p1 r1)),(l2,r2, sgn (ipoly p2 r2))))) (?x * ?y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. converges_to\n     (\\<lambda>i.\n         bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n               ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))))\n     (real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2))", "proof (intro tighten_poly_bounds_binary[where f = \"(*)\" and I = \"\\<lambda> l. l > 0\"]\n      basic l1_pos l2_pos, goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>l1a r1a l2a r2a l r sr1 sr2.\n       \\<lbrakk>0 < l1a; 0 < l2a;\n        root_cond (p1, l1a, r1a) (real_of_1 (p1, l1, r1));\n        root_cond (p2, l2a, r2a) (real_of_1 (p2, l2, r2));\n        bnd ((l1a, r1a, sr1), l2a, r2a, sr2) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat l\n                         \\<le> real_of_1 (p1, l1, r1) *\n                               real_of_1 (p2, l2, r2) \\<and>\n                         real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n                         \\<le> real_of_rat r\n 2. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 3. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 4. sgn (ipoly p1 r1) = sgn (ipoly p1 r1)\n 5. sgn (ipoly p2 r2) = sgn (ipoly p2 r2)", "case (1 L1 R1 L2 R2 L R)"], ["proof (state)\nthis:\n  0 < L1\n  0 < L2\n  root_cond (p1, L1, R1) (real_of_1 (p1, l1, r1))\n  root_cond (p2, L2, R2) (real_of_1 (p2, l2, r2))\n  bnd ((L1, R1, sr1_), L2, R2, sr2_) = (L, R)\n\ngoal (5 subgoals):\n 1. \\<And>l1a r1a l2a r2a l r sr1 sr2.\n       \\<lbrakk>0 < l1a; 0 < l2a;\n        root_cond (p1, l1a, r1a) (real_of_1 (p1, l1, r1));\n        root_cond (p2, l2a, r2a) (real_of_1 (p2, l2, r2));\n        bnd ((l1a, r1a, sr1), l2a, r2a, sr2) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat l\n                         \\<le> real_of_1 (p1, l1, r1) *\n                               real_of_1 (p2, l2, r2) \\<and>\n                         real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n                         \\<le> real_of_rat r\n 2. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 3. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 4. sgn (ipoly p1 r1) = sgn (ipoly p1 r1)\n 5. sgn (ipoly p2 r2) = sgn (ipoly p2 r2)", "hence \"L = L1 * L2\" \"R = R1 * R2\""], ["proof (prove)\nusing this:\n  0 < L1\n  0 < L2\n  root_cond (p1, L1, R1) (real_of_1 (p1, l1, r1))\n  root_cond (p2, L2, R2) (real_of_1 (p2, l2, r2))\n  bnd ((L1, R1, sr1_), L2, R2, sr2_) = (L, R)\n\ngoal (1 subgoal):\n 1. L = L1 * L2 &&& R = R1 * R2", "unfolding bnd_def"], ["proof (prove)\nusing this:\n  0 < L1\n  0 < L2\n  root_cond (p1, L1, R1) (real_of_1 (p1, l1, r1))\n  root_cond (p2, L2, R2) (real_of_1 (p2, l2, r2))\n  (case ((L1, R1, sr1_), L2, R2, sr2_) of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (l1, r1, sr1) \\<Rightarrow>\n        \\<lambda>(l2, r2, sr2). (l1 * l2, r1 * r2))\n      xa) =\n  (L, R)\n\ngoal (1 subgoal):\n 1. L = L1 * L2 &&& R = R1 * R2", "by auto"], ["proof (state)\nthis:\n  L = L1 * L2\n  R = R1 * R2\n\ngoal (5 subgoals):\n 1. \\<And>l1a r1a l2a r2a l r sr1 sr2.\n       \\<lbrakk>0 < l1a; 0 < l2a;\n        root_cond (p1, l1a, r1a) (real_of_1 (p1, l1, r1));\n        root_cond (p2, l2a, r2a) (real_of_1 (p2, l2, r2));\n        bnd ((l1a, r1a, sr1), l2a, r2a, sr2) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat l\n                         \\<le> real_of_1 (p1, l1, r1) *\n                               real_of_1 (p2, l2, r2) \\<and>\n                         real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n                         \\<le> real_of_rat r\n 2. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 3. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 4. sgn (ipoly p1 r1) = sgn (ipoly p1 r1)\n 5. sgn (ipoly p2 r2) = sgn (ipoly p2 r2)", "hence id: \"?r L = ?r L1 * ?r L2\" \"?r R = ?r R1 * ?r R2\""], ["proof (prove)\nusing this:\n  L = L1 * L2\n  R = R1 * R2\n\ngoal (1 subgoal):\n 1. real_of_rat L = real_of_rat L1 * real_of_rat L2 &&&\n    real_of_rat R = real_of_rat R1 * real_of_rat R2", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  real_of_rat L = real_of_rat L1 * real_of_rat L2\n  real_of_rat R = real_of_rat R1 * real_of_rat R2\n\ngoal (5 subgoals):\n 1. \\<And>l1a r1a l2a r2a l r sr1 sr2.\n       \\<lbrakk>0 < l1a; 0 < l2a;\n        root_cond (p1, l1a, r1a) (real_of_1 (p1, l1, r1));\n        root_cond (p2, l2a, r2a) (real_of_1 (p2, l2, r2));\n        bnd ((l1a, r1a, sr1), l2a, r2a, sr2) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat l\n                         \\<le> real_of_1 (p1, l1, r1) *\n                               real_of_1 (p2, l2, r2) \\<and>\n                         real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n                         \\<le> real_of_rat r\n 2. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 3. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 4. sgn (ipoly p1 r1) = sgn (ipoly p1 r1)\n 5. sgn (ipoly p2 r2) = sgn (ipoly p2 r2)", "from 1(3-4)"], ["proof (chain)\npicking this:\n  root_cond (p1, L1, R1) (real_of_1 (p1, l1, r1))\n  root_cond (p2, L2, R2) (real_of_1 (p2, l2, r2))", "have le: \"?r L1 \\<le> ?x\" \"?x \\<le> ?r R1\" \"?r L2 \\<le> ?y\" \"?y \\<le> ?r R2\""], ["proof (prove)\nusing this:\n  root_cond (p1, L1, R1) (real_of_1 (p1, l1, r1))\n  root_cond (p2, L2, R2) (real_of_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. (real_of_rat L1 \\<le> real_of_1 (p1, l1, r1) &&&\n     real_of_1 (p1, l1, r1) \\<le> real_of_rat R1) &&&\n    real_of_rat L2 \\<le> real_of_1 (p2, l2, r2) &&&\n    real_of_1 (p2, l2, r2) \\<le> real_of_rat R2", "unfolding root_cond_def"], ["proof (prove)\nusing this:\n  case (p1, L1, R1) of\n  (p, l, r) \\<Rightarrow>\n    real_of_rat l\n    \\<le> (THE x.\n              case (p1, l1, r1) of\n              (p, l, r) \\<Rightarrow>\n                real_of_rat l \\<le> x \\<and>\n                x \\<le> real_of_rat r \\<and>\n                poly (real_of_int_poly p) x = 0) \\<and>\n    (THE x.\n        case (p1, l1, r1) of\n        (p, l, r) \\<Rightarrow>\n          real_of_rat l \\<le> x \\<and>\n          x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0)\n    \\<le> real_of_rat r \\<and>\n    poly (real_of_int_poly p)\n     (THE x.\n         case (p1, l1, r1) of\n         (p, l, r) \\<Rightarrow>\n           real_of_rat l \\<le> x \\<and>\n           x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0) =\n    0\n  case (p2, L2, R2) of\n  (p, l, r) \\<Rightarrow>\n    real_of_rat l\n    \\<le> (THE x.\n              case (p2, l2, r2) of\n              (p, l, r) \\<Rightarrow>\n                real_of_rat l \\<le> x \\<and>\n                x \\<le> real_of_rat r \\<and>\n                poly (real_of_int_poly p) x = 0) \\<and>\n    (THE x.\n        case (p2, l2, r2) of\n        (p, l, r) \\<Rightarrow>\n          real_of_rat l \\<le> x \\<and>\n          x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0)\n    \\<le> real_of_rat r \\<and>\n    poly (real_of_int_poly p)\n     (THE x.\n         case (p2, l2, r2) of\n         (p, l, r) \\<Rightarrow>\n           real_of_rat l \\<le> x \\<and>\n           x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0) =\n    0\n\ngoal (1 subgoal):\n 1. (real_of_rat L1\n     \\<le> (THE x.\n               case (p1, l1, r1) of\n               (p, l, r) \\<Rightarrow>\n                 real_of_rat l \\<le> x \\<and>\n                 x \\<le> real_of_rat r \\<and>\n                 poly (real_of_int_poly p) x = 0) &&&\n     (THE x.\n         case (p1, l1, r1) of\n         (p, l, r) \\<Rightarrow>\n           real_of_rat l \\<le> x \\<and>\n           x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0)\n     \\<le> real_of_rat R1) &&&\n    real_of_rat L2\n    \\<le> (THE x.\n              case (p2, l2, r2) of\n              (p, l, r) \\<Rightarrow>\n                real_of_rat l \\<le> x \\<and>\n                x \\<le> real_of_rat r \\<and>\n                poly (real_of_int_poly p) x = 0) &&&\n    (THE x.\n        case (p2, l2, r2) of\n        (p, l, r) \\<Rightarrow>\n          real_of_rat l \\<le> x \\<and>\n          x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0)\n    \\<le> real_of_rat R2", "by auto"], ["proof (state)\nthis:\n  real_of_rat L1 \\<le> real_of_1 (p1, l1, r1)\n  real_of_1 (p1, l1, r1) \\<le> real_of_rat R1\n  real_of_rat L2 \\<le> real_of_1 (p2, l2, r2)\n  real_of_1 (p2, l2, r2) \\<le> real_of_rat R2\n\ngoal (5 subgoals):\n 1. \\<And>l1a r1a l2a r2a l r sr1 sr2.\n       \\<lbrakk>0 < l1a; 0 < l2a;\n        root_cond (p1, l1a, r1a) (real_of_1 (p1, l1, r1));\n        root_cond (p2, l2a, r2a) (real_of_1 (p2, l2, r2));\n        bnd ((l1a, r1a, sr1), l2a, r2a, sr2) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat l\n                         \\<le> real_of_1 (p1, l1, r1) *\n                               real_of_1 (p2, l2, r2) \\<and>\n                         real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n                         \\<le> real_of_rat r\n 2. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 3. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 4. sgn (ipoly p1 r1) = sgn (ipoly p1 r1)\n 5. sgn (ipoly p2 r2) = sgn (ipoly p2 r2)", "from 1(1-2)"], ["proof (chain)\npicking this:\n  0 < L1\n  0 < L2", "have lt: \"0 < ?r L1\" \"0 < ?r L2\""], ["proof (prove)\nusing this:\n  0 < L1\n  0 < L2\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat L1 &&& 0 < real_of_rat L2", "by auto"], ["proof (state)\nthis:\n  0 < real_of_rat L1\n  0 < real_of_rat L2\n\ngoal (5 subgoals):\n 1. \\<And>l1a r1a l2a r2a l r sr1 sr2.\n       \\<lbrakk>0 < l1a; 0 < l2a;\n        root_cond (p1, l1a, r1a) (real_of_1 (p1, l1, r1));\n        root_cond (p2, l2a, r2a) (real_of_1 (p2, l2, r2));\n        bnd ((l1a, r1a, sr1), l2a, r2a, sr2) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat l\n                         \\<le> real_of_1 (p1, l1, r1) *\n                               real_of_1 (p2, l2, r2) \\<and>\n                         real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n                         \\<le> real_of_rat r\n 2. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 3. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 4. sgn (ipoly p1 r1) = sgn (ipoly p1 r1)\n 5. sgn (ipoly p2 r2) = sgn (ipoly p2 r2)", "from mult_mono[OF le(1,3), folded id] lt le"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> real_of_1 (p1, l1, r1); 0 \\<le> real_of_rat L2\\<rbrakk>\n  \\<Longrightarrow> real_of_rat L\n                    \\<le> real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n  0 < real_of_rat L1\n  0 < real_of_rat L2\n  real_of_rat L1 \\<le> real_of_1 (p1, l1, r1)\n  real_of_1 (p1, l1, r1) \\<le> real_of_rat R1\n  real_of_rat L2 \\<le> real_of_1 (p2, l2, r2)\n  real_of_1 (p2, l2, r2) \\<le> real_of_rat R2", "have L: \"?r L \\<le> ?x * ?y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> real_of_1 (p1, l1, r1); 0 \\<le> real_of_rat L2\\<rbrakk>\n  \\<Longrightarrow> real_of_rat L\n                    \\<le> real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n  0 < real_of_rat L1\n  0 < real_of_rat L2\n  real_of_rat L1 \\<le> real_of_1 (p1, l1, r1)\n  real_of_1 (p1, l1, r1) \\<le> real_of_rat R1\n  real_of_rat L2 \\<le> real_of_1 (p2, l2, r2)\n  real_of_1 (p2, l2, r2) \\<le> real_of_rat R2\n\ngoal (1 subgoal):\n 1. real_of_rat L \\<le> real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)", "by linarith"], ["proof (state)\nthis:\n  real_of_rat L \\<le> real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n\ngoal (5 subgoals):\n 1. \\<And>l1a r1a l2a r2a l r sr1 sr2.\n       \\<lbrakk>0 < l1a; 0 < l2a;\n        root_cond (p1, l1a, r1a) (real_of_1 (p1, l1, r1));\n        root_cond (p2, l2a, r2a) (real_of_1 (p2, l2, r2));\n        bnd ((l1a, r1a, sr1), l2a, r2a, sr2) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat l\n                         \\<le> real_of_1 (p1, l1, r1) *\n                               real_of_1 (p2, l2, r2) \\<and>\n                         real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n                         \\<le> real_of_rat r\n 2. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 3. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 4. sgn (ipoly p1 r1) = sgn (ipoly p1 r1)\n 5. sgn (ipoly p2 r2) = sgn (ipoly p2 r2)", "have R: \"?x * ?y \\<le> ?r R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2) \\<le> real_of_rat R", "by (rule mult_mono[OF le(2,4), folded id], insert lt le, linarith+)"], ["proof (state)\nthis:\n  real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2) \\<le> real_of_rat R\n\ngoal (5 subgoals):\n 1. \\<And>l1a r1a l2a r2a l r sr1 sr2.\n       \\<lbrakk>0 < l1a; 0 < l2a;\n        root_cond (p1, l1a, r1a) (real_of_1 (p1, l1, r1));\n        root_cond (p2, l2a, r2a) (real_of_1 (p2, l2, r2));\n        bnd ((l1a, r1a, sr1), l2a, r2a, sr2) = (l, r)\\<rbrakk>\n       \\<Longrightarrow> real_of_rat l\n                         \\<le> real_of_1 (p1, l1, r1) *\n                               real_of_1 (p2, l2, r2) \\<and>\n                         real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n                         \\<le> real_of_rat r\n 2. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 3. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 4. sgn (ipoly p1 r1) = sgn (ipoly p1 r1)\n 5. sgn (ipoly p2 r2) = sgn (ipoly p2 r2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat L\n    \\<le> real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2) \\<and>\n    real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2) \\<le> real_of_rat R", "using L R"], ["proof (prove)\nusing this:\n  real_of_rat L \\<le> real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n  real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2) \\<le> real_of_rat R\n\ngoal (1 subgoal):\n 1. real_of_rat L\n    \\<le> real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2) \\<and>\n    real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2) \\<le> real_of_rat R", "by blast"], ["proof (state)\nthis:\n  real_of_rat L \\<le> real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2) \\<and>\n  real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2) \\<le> real_of_rat R\n\ngoal (4 subgoals):\n 1. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 2. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 3. sgn (ipoly p1 r1) = sgn (ipoly p1 r1)\n 4. sgn (ipoly p2 r2) = sgn (ipoly p2 r2)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 2. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 3. sgn (ipoly p1 r1) = sgn (ipoly p1 r1)\n 4. sgn (ipoly p2 r2) = sgn (ipoly p2 r2)", "case (2 l1 r1 l2 r2 l1' r1' l2' r2' l l' r r')"], ["proof (state)\nthis:\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2\n  (l, r) = bnd ((l1, r1, sr1_), l2, r2, sr2_)\n  (l', r') = bnd ((l1', r1', sr1'_), l2', r2', sr2'_)\n  (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)}\n  (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\n\ngoal (4 subgoals):\n 1. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 2. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 3. sgn (ipoly p1 r1__) = sgn (ipoly p1 r1__)\n 4. sgn (ipoly p2 r2__) = sgn (ipoly p2 r2__)", "from 2(5-6)"], ["proof (chain)\npicking this:\n  (l, r) = bnd ((l1, r1, sr1_), l2, r2, sr2_)\n  (l', r') = bnd ((l1', r1', sr1'_), l2', r2', sr2'_)", "have lr: \"l = l1 * l2\" \"r = r1 * r2\" \"l' = l1' * l2'\" \"r' = r1' * r2'\""], ["proof (prove)\nusing this:\n  (l, r) = bnd ((l1, r1, sr1_), l2, r2, sr2_)\n  (l', r') = bnd ((l1', r1', sr1'_), l2', r2', sr2'_)\n\ngoal (1 subgoal):\n 1. (l = l1 * l2 &&& r = r1 * r2) &&& l' = l1' * l2' &&& r' = r1' * r2'", "unfolding bnd_def"], ["proof (prove)\nusing this:\n  (l, r) =\n  (case ((l1, r1, sr1_), l2, r2, sr2_) of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (l1, r1, sr1) \\<Rightarrow>\n        \\<lambda>(l2, r2, sr2). (l1 * l2, r1 * r2))\n      xa)\n  (l', r') =\n  (case ((l1', r1', sr1'_), l2', r2', sr2'_) of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (l1, r1, sr1) \\<Rightarrow>\n        \\<lambda>(l2, r2, sr2). (l1 * l2, r1 * r2))\n      xa)\n\ngoal (1 subgoal):\n 1. (l = l1 * l2 &&& r = r1 * r2) &&& l' = l1' * l2' &&& r' = r1' * r2'", "by auto"], ["proof (state)\nthis:\n  l = l1 * l2\n  r = r1 * r2\n  l' = l1' * l2'\n  r' = r1' * r2'\n\ngoal (4 subgoals):\n 1. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 2. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 3. sgn (ipoly p1 r1__) = sgn (ipoly p1 r1__)\n 4. sgn (ipoly p2 r2__) = sgn (ipoly p2 r2__)", "from 2(1-4)"], ["proof (chain)\npicking this:\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2", "have le: \"0 < l1\" \"0 < l2\" \"l1 \\<le> r1\" \"l2 \\<le> r2\""], ["proof (prove)\nusing this:\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2\n\ngoal (1 subgoal):\n 1. (0 < l1 &&& 0 < l2) &&& l1 \\<le> r1 &&& l2 \\<le> r2", "by auto"], ["proof (state)\nthis:\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2\n\ngoal (4 subgoals):\n 1. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 2. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 3. sgn (ipoly p1 r1__) = sgn (ipoly p1 r1__)\n 4. sgn (ipoly p2 r2__) = sgn (ipoly p2 r2__)", "from 2(7-8) le"], ["proof (chain)\npicking this:\n  (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)}\n  (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2", "have le': \"l1 \\<le> l1'\" \"r1' \\<le> r1\" \"l2 \\<le> l2'\" \"r2' \\<le> r2\" \"0 < r2'\" \"0 < r2\""], ["proof (prove)\nusing this:\n  (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)}\n  (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2\n\ngoal (1 subgoal):\n 1. (l1 \\<le> l1' &&& r1' \\<le> r1 &&& l2 \\<le> l2') &&&\n    r2' \\<le> r2 &&& 0 < r2' &&& 0 < r2", "by auto"], ["proof (state)\nthis:\n  l1 \\<le> l1'\n  r1' \\<le> r1\n  l2 \\<le> l2'\n  r2' \\<le> r2\n  0 < r2'\n  0 < r2\n\ngoal (4 subgoals):\n 1. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 2. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 3. sgn (ipoly p1 r1__) = sgn (ipoly p1 r1__)\n 4. sgn (ipoly p2 r2__) = sgn (ipoly p2 r2__)", "from mult_mono[OF le'(1,3), folded lr] le le'"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> l1'; 0 \\<le> l2\\<rbrakk> \\<Longrightarrow> l \\<le> l'\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2\n  l1 \\<le> l1'\n  r1' \\<le> r1\n  l2 \\<le> l2'\n  r2' \\<le> r2\n  0 < r2'\n  0 < r2", "have l: \"l \\<le> l'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> l1'; 0 \\<le> l2\\<rbrakk> \\<Longrightarrow> l \\<le> l'\n  0 < l1\n  0 < l2\n  l1 \\<le> r1\n  l2 \\<le> r2\n  l1 \\<le> l1'\n  r1' \\<le> r1\n  l2 \\<le> l2'\n  r2' \\<le> r2\n  0 < r2'\n  0 < r2\n\ngoal (1 subgoal):\n 1. l \\<le> l'", "by auto"], ["proof (state)\nthis:\n  l \\<le> l'\n\ngoal (4 subgoals):\n 1. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 2. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 3. sgn (ipoly p1 r1__) = sgn (ipoly p1 r1__)\n 4. sgn (ipoly p2 r2__) = sgn (ipoly p2 r2__)", "have r: \"r' \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r' \\<le> r", "by (rule mult_mono[OF le'(2,4), folded lr], insert le le', linarith+)"], ["proof (state)\nthis:\n  r' \\<le> r\n\ngoal (4 subgoals):\n 1. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 2. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 3. sgn (ipoly p1 r1__) = sgn (ipoly p1 r1__)\n 4. sgn (ipoly p2 r2__) = sgn (ipoly p2 r2__)", "have \"r' - l' \\<le> 3 / 4 * (r - l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r' - l' \\<le> 3 / 4 * (r - l)", "by (rule decr[OF _ _ _ _ _ _ 2(7-8)], insert le le' lr, auto)"], ["proof (state)\nthis:\n  r' - l' \\<le> 3 / 4 * (r - l)\n\ngoal (4 subgoals):\n 1. \\<And>l1 r1 l2 r2 l1' r1' l2' r2' l l' r r' sr1 sr2 sr1' sr2'.\n       \\<lbrakk>0 < l1; 0 < l2; l1 \\<le> r1; l2 \\<le> r2;\n        (l, r) = bnd ((l1, r1, sr1), l2, r2, sr2);\n        (l', r') = bnd ((l1', r1', sr1'), l2', r2', sr2');\n        (l1', r1') \\<in> {(l1, (l1 + r1) / 2), ((l1 + r1) / 2, r1)};\n        (l2', r2') \\<in> {(l2, (l2 + r2) / 2), ((l2 + r2) / 2, r2)}\\<rbrakk>\n       \\<Longrightarrow> r' - l' \\<le> 3 / 4 * (r - l) \\<and>\n                         l \\<le> l' \\<and> r' \\<le> r\n 2. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 3. sgn (ipoly p1 r1__) = sgn (ipoly p1 r1__)\n 4. sgn (ipoly p2 r2__) = sgn (ipoly p2 r2__)", "thus ?case"], ["proof (prove)\nusing this:\n  r' - l' \\<le> 3 / 4 * (r - l)\n\ngoal (1 subgoal):\n 1. r' - l' \\<le> 3 / 4 * (r - l) \\<and> l \\<le> l' \\<and> r' \\<le> r", "using l r"], ["proof (prove)\nusing this:\n  r' - l' \\<le> 3 / 4 * (r - l)\n  l \\<le> l'\n  r' \\<le> r\n\ngoal (1 subgoal):\n 1. r' - l' \\<le> 3 / 4 * (r - l) \\<and> l \\<le> l' \\<and> r' \\<le> r", "by blast"], ["proof (state)\nthis:\n  r' - l' \\<le> 3 / 4 * (r - l) \\<and> l \\<le> l' \\<and> r' \\<le> r\n\ngoal (3 subgoals):\n 1. \\<And>l l'. \\<lbrakk>0 < l; l \\<le> l'\\<rbrakk> \\<Longrightarrow> 0 < l'\n 2. sgn (ipoly p1 r1__) = sgn (ipoly p1 r1__)\n 3. sgn (ipoly p2 r2__) = sgn (ipoly p2 r2__)", "qed auto"], ["proof (state)\nthis:\n  converges_to\n   (\\<lambda>i.\n       bnd ((tighten_poly_bounds_binary p1 p2 ^^ i)\n             ((l1, r1, sgn (ipoly p1 r1)), l2, r2, sgn (ipoly p2 r2))))\n   (real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invariant_2 z' \\<and>\n  real_of_2 z' = real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "have z': \"z' = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z' = z", "unfolding z[unfolded xt yt, simplified, unfolded bnd_def[symmetric] sel]"], ["proof (prove)\ngoal (1 subgoal):\n 1. z' = z'", "by auto"], ["proof (state)\nthis:\n  z' = z\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from main[unfolded this]"], ["proof (chain)\npicking this:\n  invariant_2 z \\<and>\n  real_of_2 z = real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant_2 z \\<and>\n  real_of_2 z = real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "unfolding xt yt"], ["proof (prove)\nusing this:\n  invariant_2 z \\<and>\n  real_of_2 z = real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and>\n    real_of_2 z = real_of_1 (p1, l1, r1) * real_of_1 (p2, l2, r2)", "by simp"], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_1: assumes x: \"invariant_1_2 x\" and y: \"invariant_1_2 y\"\n  defines z[simp]: \"z \\<equiv> mult_1 x y\"\n  shows \"invariant_2 z \\<and> (real_of_2 z = real_of_1 x * real_of_1 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "obtain p1 l1 r1 where xt[simp]: \"x = (p1,l1,r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 l1 r1.\n        x = (p1, l1, r1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x)"], ["proof (state)\nthis:\n  x = (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "obtain p2 l2 r2 where yt[simp]: \"y = (p2,l2,r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2 l2 r2.\n        y = (p2, l2, r2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases y)"], ["proof (state)\nthis:\n  y = (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?xt = \"(p1, l1, r1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?yt = \"(p2, l2, r2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?x = \"real_of_1 ?xt\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?y = \"real_of_1 ?yt\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?mxt = \"uminus_1 ?xt\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?myt = \"uminus_1 ?yt\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?mx = \"real_of_1 ?mxt\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?my = \"real_of_1 ?myt\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "let ?r = \"real_of_rat\""], ["proof (state)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from invariant_1_2_of_rat[OF x, of 0]"], ["proof (chain)\npicking this:\n  real_of_1 x \\<noteq> real_of_rat 0", "have x0: \"?x < 0 \\<or> ?x > 0\""], ["proof (prove)\nusing this:\n  real_of_1 x \\<noteq> real_of_rat 0\n\ngoal (1 subgoal):\n 1. real_of_1 (p1, l1, r1) < 0 \\<or> 0 < real_of_1 (p1, l1, r1)", "by auto"], ["proof (state)\nthis:\n  real_of_1 (p1, l1, r1) < 0 \\<or> 0 < real_of_1 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from invariant_1_2_of_rat[OF y, of 0]"], ["proof (chain)\npicking this:\n  real_of_1 y \\<noteq> real_of_rat 0", "have y0: \"?y < 0 \\<or> ?y > 0\""], ["proof (prove)\nusing this:\n  real_of_1 y \\<noteq> real_of_rat 0\n\ngoal (1 subgoal):\n 1. real_of_1 (p2, l2, r2) < 0 \\<or> 0 < real_of_1 (p2, l2, r2)", "by auto"], ["proof (state)\nthis:\n  real_of_1 (p2, l2, r2) < 0 \\<or> 0 < real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from uminus_1_2[OF x]"], ["proof (chain)\npicking this:\n  invariant_1_2 (uminus_1 x) \\<and> real_of_1 (uminus_1 x) = - real_of_1 x", "have mx: \"invariant_1_2 ?mxt\" and [simp]: \"?mx = - ?x\""], ["proof (prove)\nusing this:\n  invariant_1_2 (uminus_1 x) \\<and> real_of_1 (uminus_1 x) = - real_of_1 x\n\ngoal (1 subgoal):\n 1. invariant_1_2 (uminus_1 (p1, l1, r1)) &&&\n    real_of_1 (uminus_1 (p1, l1, r1)) = - real_of_1 (p1, l1, r1)", "by auto"], ["proof (state)\nthis:\n  invariant_1_2 (uminus_1 (p1, l1, r1))\n  real_of_1 (uminus_1 (p1, l1, r1)) = - real_of_1 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from uminus_1_2[OF y]"], ["proof (chain)\npicking this:\n  invariant_1_2 (uminus_1 y) \\<and> real_of_1 (uminus_1 y) = - real_of_1 y", "have my: \"invariant_1_2 ?myt\" and [simp]: \"?my = - ?y\""], ["proof (prove)\nusing this:\n  invariant_1_2 (uminus_1 y) \\<and> real_of_1 (uminus_1 y) = - real_of_1 y\n\ngoal (1 subgoal):\n 1. invariant_1_2 (uminus_1 (p2, l2, r2)) &&&\n    real_of_1 (uminus_1 (p2, l2, r2)) = - real_of_1 (p2, l2, r2)", "by auto"], ["proof (state)\nthis:\n  invariant_1_2 (uminus_1 (p2, l2, r2))\n  real_of_1 (uminus_1 (p2, l2, r2)) = - real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "have id: \"r1 > 0 \\<longleftrightarrow> ?x > 0\" \"r1 < 0 \\<longleftrightarrow> ?x < 0\" \"r2 > 0 \\<longleftrightarrow> ?y > 0\" \"r2 < 0 \\<longleftrightarrow> ?y < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0 < r1) = (0 < real_of_1 (p1, l1, r1)) &&&\n     (r1 < 0) = (real_of_1 (p1, l1, r1) < 0)) &&&\n    (0 < r2) = (0 < real_of_1 (p2, l2, r2)) &&&\n    (r2 < 0) = (real_of_1 (p2, l2, r2) < 0)", "using x y"], ["proof (prove)\nusing this:\n  invariant_1_2 x\n  invariant_1_2 y\n\ngoal (1 subgoal):\n 1. ((0 < r1) = (0 < real_of_1 (p1, l1, r1)) &&&\n     (r1 < 0) = (real_of_1 (p1, l1, r1) < 0)) &&&\n    (0 < r2) = (0 < real_of_1 (p2, l2, r2)) &&&\n    (r2 < 0) = (real_of_1 (p2, l2, r2) < 0)", "by auto"], ["proof (state)\nthis:\n  (0 < r1) = (0 < real_of_1 (p1, l1, r1))\n  (r1 < 0) = (real_of_1 (p1, l1, r1) < 0)\n  (0 < r2) = (0 < real_of_1 (p2, l2, r2))\n  (r2 < 0) = (real_of_1 (p2, l2, r2) < 0)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "proof (cases \"?x > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n 2. \\<not> 0 < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "case x0: True"], ["proof (state)\nthis:\n  0 < real_of_1 (p1, l1, r1)\n\ngoal (2 subgoals):\n 1. 0 < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n 2. \\<not> 0 < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "proof (cases \"?y > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n 2. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "case y0: True"], ["proof (state)\nthis:\n  0 < real_of_1 (p2, l2, r2)\n\ngoal (2 subgoals):\n 1. 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n 2. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "with x y x0 mult_1_pos[OF x y]"], ["proof (chain)\npicking this:\n  invariant_1_2 x\n  invariant_1_2 y\n  0 < real_of_1 (p1, l1, r1)\n  \\<lbrakk>0 < real_of_1 x; 0 < real_of_1 y\\<rbrakk>\n  \\<Longrightarrow> invariant_2 (mult_1_pos x y) \\<and>\n                    real_of_2 (mult_1_pos x y) = real_of_1 x * real_of_1 y\n  0 < real_of_1 (p2, l2, r2)", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant_1_2 x\n  invariant_1_2 y\n  0 < real_of_1 (p1, l1, r1)\n  \\<lbrakk>0 < real_of_1 x; 0 < real_of_1 y\\<rbrakk>\n  \\<Longrightarrow> invariant_2 (mult_1_pos x y) \\<and>\n                    real_of_2 (mult_1_pos x y) = real_of_1 x * real_of_1 y\n  0 < real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "by auto"], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "with y0"], ["proof (chain)\npicking this:\n  real_of_1 (p2, l2, r2) < 0 \\<or> 0 < real_of_1 (p2, l2, r2)\n  \\<not> 0 < real_of_1 (p2, l2, r2)", "have y0: \"?y < 0\""], ["proof (prove)\nusing this:\n  real_of_1 (p2, l2, r2) < 0 \\<or> 0 < real_of_1 (p2, l2, r2)\n  \\<not> 0 < real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. real_of_1 (p2, l2, r2) < 0", "by auto"], ["proof (state)\nthis:\n  real_of_1 (p2, l2, r2) < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "with x0"], ["proof (chain)\npicking this:\n  0 < real_of_1 (p1, l1, r1)\n  real_of_1 (p2, l2, r2) < 0", "have z: \"z = uminus_2 (mult_1_pos ?xt ?myt)\""], ["proof (prove)\nusing this:\n  0 < real_of_1 (p1, l1, r1)\n  real_of_1 (p2, l2, r2) < 0\n\ngoal (1 subgoal):\n 1. z = uminus_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2)))", "unfolding z xt yt mult_1.simps split id"], ["proof (prove)\nusing this:\n  0 < real_of_1 (p1, l1, r1)\n  real_of_1 (p2, l2, r2) < 0\n\ngoal (1 subgoal):\n 1. (if 0 < real_of_1 (p1, l1, r1)\n     then if 0 < real_of_1 (p2, l2, r2)\n          then mult_1_pos (p1, l1, r1) (p2, l2, r2)\n          else uminus_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2)))\n     else if 0 < real_of_1 (p2, l2, r2)\n          then uminus_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2))\n          else mult_1_pos (uminus_1 (p1, l1, r1)) (uminus_1 (p2, l2, r2))) =\n    uminus_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2)))", "by simp"], ["proof (state)\nthis:\n  z = uminus_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2)))\n\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from x0 y0 mult_1_pos[OF x my] uminus_2[of \"mult_1_pos ?xt ?myt\"]"], ["proof (chain)\npicking this:\n  0 < real_of_1 (p1, l1, r1)\n  real_of_1 (p2, l2, r2) < 0\n  \\<lbrakk>0 < real_of_1 x; 0 < real_of_1 (uminus_1 (p2, l2, r2))\\<rbrakk>\n  \\<Longrightarrow> invariant_2\n                     (mult_1_pos x (uminus_1 (p2, l2, r2))) \\<and>\n                    real_of_2 (mult_1_pos x (uminus_1 (p2, l2, r2))) =\n                    real_of_1 x * real_of_1 (uminus_1 (p2, l2, r2))\n  invariant_2\n   (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2))) \\<Longrightarrow>\n  real_of_2 (uminus_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2)))) =\n  - real_of_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2)))\n  invariant_2\n   (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2))) \\<Longrightarrow>\n  invariant_2 (uminus_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2))))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < real_of_1 (p1, l1, r1)\n  real_of_1 (p2, l2, r2) < 0\n  \\<lbrakk>0 < real_of_1 x; 0 < real_of_1 (uminus_1 (p2, l2, r2))\\<rbrakk>\n  \\<Longrightarrow> invariant_2\n                     (mult_1_pos x (uminus_1 (p2, l2, r2))) \\<and>\n                    real_of_2 (mult_1_pos x (uminus_1 (p2, l2, r2))) =\n                    real_of_1 x * real_of_1 (uminus_1 (p2, l2, r2))\n  invariant_2\n   (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2))) \\<Longrightarrow>\n  real_of_2 (uminus_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2)))) =\n  - real_of_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2)))\n  invariant_2\n   (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2))) \\<Longrightarrow>\n  invariant_2 (uminus_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2))))\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "unfolding z"], ["proof (prove)\nusing this:\n  0 < real_of_1 (p1, l1, r1)\n  real_of_1 (p2, l2, r2) < 0\n  \\<lbrakk>0 < real_of_1 x; 0 < real_of_1 (uminus_1 (p2, l2, r2))\\<rbrakk>\n  \\<Longrightarrow> invariant_2\n                     (mult_1_pos x (uminus_1 (p2, l2, r2))) \\<and>\n                    real_of_2 (mult_1_pos x (uminus_1 (p2, l2, r2))) =\n                    real_of_1 x * real_of_1 (uminus_1 (p2, l2, r2))\n  invariant_2\n   (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2))) \\<Longrightarrow>\n  real_of_2 (uminus_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2)))) =\n  - real_of_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2)))\n  invariant_2\n   (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2))) \\<Longrightarrow>\n  invariant_2 (uminus_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2))))\n\ngoal (1 subgoal):\n 1. invariant_2\n     (uminus_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2)))) \\<and>\n    real_of_2 (uminus_2 (mult_1_pos (p1, l1, r1) (uminus_1 (p2, l2, r2)))) =\n    real_of_1 x * real_of_1 y", "by simp"], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < real_of_1 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "with x0"], ["proof (chain)\npicking this:\n  real_of_1 (p1, l1, r1) < 0 \\<or> 0 < real_of_1 (p1, l1, r1)\n  \\<not> 0 < real_of_1 (p1, l1, r1)", "have x0: \"?x0 < 0\""], ["proof (prove)\nusing this:\n  real_of_1 (p1, l1, r1) < 0 \\<or> 0 < real_of_1 (p1, l1, r1)\n  \\<not> 0 < real_of_1 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. real_of_1 (p1, l1, r1) < 0", "by simp"], ["proof (state)\nthis:\n  real_of_1 (p1, l1, r1) < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "proof (cases \"?y > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n 2. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "case y0: True"], ["proof (state)\nthis:\n  0 < real_of_1 (p2, l2, r2)\n\ngoal (2 subgoals):\n 1. 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n 2. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "with x0 x y id"], ["proof (chain)\npicking this:\n  real_of_1 (p1, l1, r1) < 0\n  invariant_1_2 x\n  invariant_1_2 y\n  (0 < r1) = (0 < real_of_1 (p1, l1, r1))\n  (r1 < 0) = (real_of_1 (p1, l1, r1) < 0)\n  (0 < r2) = (0 < real_of_1 (p2, l2, r2))\n  (r2 < 0) = (real_of_1 (p2, l2, r2) < 0)\n  0 < real_of_1 (p2, l2, r2)", "have z: \"z = uminus_2 (mult_1_pos ?mxt ?yt)\""], ["proof (prove)\nusing this:\n  real_of_1 (p1, l1, r1) < 0\n  invariant_1_2 x\n  invariant_1_2 y\n  (0 < r1) = (0 < real_of_1 (p1, l1, r1))\n  (r1 < 0) = (real_of_1 (p1, l1, r1) < 0)\n  (0 < r2) = (0 < real_of_1 (p2, l2, r2))\n  (r2 < 0) = (real_of_1 (p2, l2, r2) < 0)\n  0 < real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. z = uminus_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2))", "by simp"], ["proof (state)\nthis:\n  z = uminus_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2))\n\ngoal (2 subgoals):\n 1. 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n 2. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "from x0 y0 mult_1_pos[OF mx y] uminus_2[of \"mult_1_pos ?mxt ?yt\"]"], ["proof (chain)\npicking this:\n  real_of_1 (p1, l1, r1) < 0\n  0 < real_of_1 (p2, l2, r2)\n  \\<lbrakk>0 < real_of_1 (uminus_1 (p1, l1, r1)); 0 < real_of_1 y\\<rbrakk>\n  \\<Longrightarrow> invariant_2\n                     (mult_1_pos (uminus_1 (p1, l1, r1)) y) \\<and>\n                    real_of_2 (mult_1_pos (uminus_1 (p1, l1, r1)) y) =\n                    real_of_1 (uminus_1 (p1, l1, r1)) * real_of_1 y\n  invariant_2\n   (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2)) \\<Longrightarrow>\n  real_of_2 (uminus_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2))) =\n  - real_of_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2))\n  invariant_2\n   (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2)) \\<Longrightarrow>\n  invariant_2 (uminus_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2)))", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_1 (p1, l1, r1) < 0\n  0 < real_of_1 (p2, l2, r2)\n  \\<lbrakk>0 < real_of_1 (uminus_1 (p1, l1, r1)); 0 < real_of_1 y\\<rbrakk>\n  \\<Longrightarrow> invariant_2\n                     (mult_1_pos (uminus_1 (p1, l1, r1)) y) \\<and>\n                    real_of_2 (mult_1_pos (uminus_1 (p1, l1, r1)) y) =\n                    real_of_1 (uminus_1 (p1, l1, r1)) * real_of_1 y\n  invariant_2\n   (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2)) \\<Longrightarrow>\n  real_of_2 (uminus_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2))) =\n  - real_of_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2))\n  invariant_2\n   (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2)) \\<Longrightarrow>\n  invariant_2 (uminus_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2)))\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "unfolding z"], ["proof (prove)\nusing this:\n  real_of_1 (p1, l1, r1) < 0\n  0 < real_of_1 (p2, l2, r2)\n  \\<lbrakk>0 < real_of_1 (uminus_1 (p1, l1, r1)); 0 < real_of_1 y\\<rbrakk>\n  \\<Longrightarrow> invariant_2\n                     (mult_1_pos (uminus_1 (p1, l1, r1)) y) \\<and>\n                    real_of_2 (mult_1_pos (uminus_1 (p1, l1, r1)) y) =\n                    real_of_1 (uminus_1 (p1, l1, r1)) * real_of_1 y\n  invariant_2\n   (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2)) \\<Longrightarrow>\n  real_of_2 (uminus_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2))) =\n  - real_of_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2))\n  invariant_2\n   (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2)) \\<Longrightarrow>\n  invariant_2 (uminus_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2)))\n\ngoal (1 subgoal):\n 1. invariant_2\n     (uminus_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2))) \\<and>\n    real_of_2 (uminus_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (p2, l2, r2))) =\n    real_of_1 x * real_of_1 y", "by auto"], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "with y0"], ["proof (chain)\npicking this:\n  real_of_1 (p2, l2, r2) < 0 \\<or> 0 < real_of_1 (p2, l2, r2)\n  \\<not> 0 < real_of_1 (p2, l2, r2)", "have y0: \"?y < 0\""], ["proof (prove)\nusing this:\n  real_of_1 (p2, l2, r2) < 0 \\<or> 0 < real_of_1 (p2, l2, r2)\n  \\<not> 0 < real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. real_of_1 (p2, l2, r2) < 0", "by simp"], ["proof (state)\nthis:\n  real_of_1 (p2, l2, r2) < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "with x0 x y"], ["proof (chain)\npicking this:\n  real_of_1 (p1, l1, r1) < 0\n  invariant_1_2 x\n  invariant_1_2 y\n  real_of_1 (p2, l2, r2) < 0", "have z: \"z = mult_1_pos ?mxt ?myt\""], ["proof (prove)\nusing this:\n  real_of_1 (p1, l1, r1) < 0\n  invariant_1_2 x\n  invariant_1_2 y\n  real_of_1 (p2, l2, r2) < 0\n\ngoal (1 subgoal):\n 1. z = mult_1_pos (uminus_1 (p1, l1, r1)) (uminus_1 (p2, l2, r2))", "by auto"], ["proof (state)\nthis:\n  z = mult_1_pos (uminus_1 (p1, l1, r1)) (uminus_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. \\<not> 0 < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "with x0 y0 x y mult_1_pos[OF mx my]"], ["proof (chain)\npicking this:\n  real_of_1 (p1, l1, r1) < 0\n  real_of_1 (p2, l2, r2) < 0\n  invariant_1_2 x\n  invariant_1_2 y\n  \\<lbrakk>0 < real_of_1 (uminus_1 (p1, l1, r1));\n   0 < real_of_1 (uminus_1 (p2, l2, r2))\\<rbrakk>\n  \\<Longrightarrow> invariant_2\n                     (mult_1_pos (uminus_1 (p1, l1, r1))\n                       (uminus_1 (p2, l2, r2))) \\<and>\n                    real_of_2\n                     (mult_1_pos (uminus_1 (p1, l1, r1))\n                       (uminus_1 (p2, l2, r2))) =\n                    real_of_1 (uminus_1 (p1, l1, r1)) *\n                    real_of_1 (uminus_1 (p2, l2, r2))\n  z = mult_1_pos (uminus_1 (p1, l1, r1)) (uminus_1 (p2, l2, r2))", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_1 (p1, l1, r1) < 0\n  real_of_1 (p2, l2, r2) < 0\n  invariant_1_2 x\n  invariant_1_2 y\n  \\<lbrakk>0 < real_of_1 (uminus_1 (p1, l1, r1));\n   0 < real_of_1 (uminus_1 (p2, l2, r2))\\<rbrakk>\n  \\<Longrightarrow> invariant_2\n                     (mult_1_pos (uminus_1 (p1, l1, r1))\n                       (uminus_1 (p2, l2, r2))) \\<and>\n                    real_of_2\n                     (mult_1_pos (uminus_1 (p1, l1, r1))\n                       (uminus_1 (p2, l2, r2))) =\n                    real_of_1 (uminus_1 (p1, l1, r1)) *\n                    real_of_1 (uminus_1 (p2, l2, r2))\n  z = mult_1_pos (uminus_1 (p1, l1, r1)) (uminus_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y", "unfolding z"], ["proof (prove)\nusing this:\n  real_of_1 (p1, l1, r1) < 0\n  real_of_1 (p2, l2, r2) < 0\n  invariant_1_2 x\n  invariant_1_2 y\n  \\<lbrakk>0 < real_of_1 (uminus_1 (p1, l1, r1));\n   0 < real_of_1 (uminus_1 (p2, l2, r2))\\<rbrakk>\n  \\<Longrightarrow> invariant_2\n                     (mult_1_pos (uminus_1 (p1, l1, r1))\n                       (uminus_1 (p2, l2, r2))) \\<and>\n                    real_of_2\n                     (mult_1_pos (uminus_1 (p1, l1, r1))\n                       (uminus_1 (p2, l2, r2))) =\n                    real_of_1 (uminus_1 (p1, l1, r1)) *\n                    real_of_1 (uminus_1 (p2, l2, r2))\n  mult_1_pos (uminus_1 (p1, l1, r1)) (uminus_1 (p2, l2, r2)) =\n  mult_1_pos (uminus_1 (p1, l1, r1)) (uminus_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. invariant_2\n     (mult_1_pos (uminus_1 (p1, l1, r1)) (uminus_1 (p2, l2, r2))) \\<and>\n    real_of_2 (mult_1_pos (uminus_1 (p1, l1, r1)) (uminus_1 (p2, l2, r2))) =\n    real_of_1 x * real_of_1 y", "by auto"], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_1 x * real_of_1 y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_rat_1: fixes x assumes y: \"invariant_1 y\"  \n  defines z: \"z \\<equiv> mult_rat_1 x y\"\n  shows \"invariant_2 z \\<and> (real_of_2 z = of_rat x * real_of_1 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "proof (cases y)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "case yt: (fields p2 l2 r2)"], ["proof (state)\nthis:\n  y = (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "let ?yt = \"(p2, l2, r2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "let ?x = \"real_of_rat x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "let ?y = \"real_of_1 ?yt\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "let ?myt = \"mult_rat_1_pos (- x) ?yt\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "note y = y[unfolded yt]"], ["proof (state)\nthis:\n  invariant_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "note z = z[unfolded yt]"], ["proof (state)\nthis:\n  z \\<equiv> mult_rat_1 x (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       y = (a, b, c) \\<Longrightarrow>\n       invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "proof(cases x \"0::rat\" rule:linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. x < 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n 2. x = 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n 3. 0 < x \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "case x: greater"], ["proof (state)\nthis:\n  0 < x\n\ngoal (3 subgoals):\n 1. x < 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n 2. x = 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n 3. 0 < x \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "with z"], ["proof (chain)\npicking this:\n  z \\<equiv> mult_rat_1 x (p2, l2, r2)\n  0 < x", "have z: \"z = mult_rat_1_pos x ?yt\""], ["proof (prove)\nusing this:\n  z \\<equiv> mult_rat_1 x (p2, l2, r2)\n  0 < x\n\ngoal (1 subgoal):\n 1. z = mult_rat_1_pos x (p2, l2, r2)", "by simp"], ["proof (state)\nthis:\n  z = mult_rat_1_pos x (p2, l2, r2)\n\ngoal (3 subgoals):\n 1. x < 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n 2. x = 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n 3. 0 < x \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "from mult_rat_1_pos[OF x y]"], ["proof (chain)\npicking this:\n  invariant_2 (mult_rat_1_pos x (p2, l2, r2)) \\<and>\n  real_of_2 (mult_rat_1_pos x (p2, l2, r2)) =\n  real_of_rat x * real_of_1 (p2, l2, r2)", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant_2 (mult_rat_1_pos x (p2, l2, r2)) \\<and>\n  real_of_2 (mult_rat_1_pos x (p2, l2, r2)) =\n  real_of_rat x * real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "unfolding yt z"], ["proof (prove)\nusing this:\n  invariant_2 (mult_rat_1_pos x (p2, l2, r2)) \\<and>\n  real_of_2 (mult_rat_1_pos x (p2, l2, r2)) =\n  real_of_rat x * real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 (mult_rat_1_pos x (p2, l2, r2)) \\<and>\n    real_of_2 (mult_rat_1_pos x (p2, l2, r2)) =\n    real_of_rat x * real_of_1 (p2, l2, r2)", "by auto"], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n\ngoal (2 subgoals):\n 1. x < 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n 2. x = 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x < 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n 2. x = 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "case less"], ["proof (state)\nthis:\n  x < 0\n\ngoal (2 subgoals):\n 1. x < 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n 2. x = 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "then"], ["proof (chain)\npicking this:\n  x < 0", "have x: \"- x > 0\""], ["proof (prove)\nusing this:\n  x < 0\n\ngoal (1 subgoal):\n 1. 0 < - x", "by auto"], ["proof (state)\nthis:\n  0 < - x\n\ngoal (2 subgoals):\n 1. x < 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n 2. x = 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "hence z: \"z = uminus_2 ?myt\""], ["proof (prove)\nusing this:\n  0 < - x\n\ngoal (1 subgoal):\n 1. z = uminus_2 (mult_rat_1_pos (- x) (p2, l2, r2))", "unfolding z"], ["proof (prove)\nusing this:\n  0 < - x\n\ngoal (1 subgoal):\n 1. mult_rat_1 x (p2, l2, r2) = uminus_2 (mult_rat_1_pos (- x) (p2, l2, r2))", "by simp"], ["proof (state)\nthis:\n  z = uminus_2 (mult_rat_1_pos (- x) (p2, l2, r2))\n\ngoal (2 subgoals):\n 1. x < 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n 2. x = 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "from mult_rat_1_pos[OF x y]"], ["proof (chain)\npicking this:\n  invariant_2 (mult_rat_1_pos (- x) (p2, l2, r2)) \\<and>\n  real_of_2 (mult_rat_1_pos (- x) (p2, l2, r2)) =\n  real_of_rat (- x) * real_of_1 (p2, l2, r2)", "have rc: \"invariant_2 ?myt\"\n      and rr: \"real_of_2 ?myt = - ?x * ?y\""], ["proof (prove)\nusing this:\n  invariant_2 (mult_rat_1_pos (- x) (p2, l2, r2)) \\<and>\n  real_of_2 (mult_rat_1_pos (- x) (p2, l2, r2)) =\n  real_of_rat (- x) * real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 (mult_rat_1_pos (- x) (p2, l2, r2)) &&&\n    real_of_2 (mult_rat_1_pos (- x) (p2, l2, r2)) =\n    - real_of_rat x * real_of_1 (p2, l2, r2)", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  invariant_2 (mult_rat_1_pos (- x) (p2, l2, r2))\n  real_of_2 (mult_rat_1_pos (- x) (p2, l2, r2)) =\n  - real_of_rat x * real_of_1 (p2, l2, r2)\n\ngoal (2 subgoals):\n 1. x < 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n 2. x = 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "from uminus_2[OF rc] rr"], ["proof (chain)\npicking this:\n  real_of_2 (uminus_2 (mult_rat_1_pos (- x) (p2, l2, r2))) =\n  - real_of_2 (mult_rat_1_pos (- x) (p2, l2, r2))\n  invariant_2 (uminus_2 (mult_rat_1_pos (- x) (p2, l2, r2)))\n  real_of_2 (mult_rat_1_pos (- x) (p2, l2, r2)) =\n  - real_of_rat x * real_of_1 (p2, l2, r2)", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_2 (uminus_2 (mult_rat_1_pos (- x) (p2, l2, r2))) =\n  - real_of_2 (mult_rat_1_pos (- x) (p2, l2, r2))\n  invariant_2 (uminus_2 (mult_rat_1_pos (- x) (p2, l2, r2)))\n  real_of_2 (mult_rat_1_pos (- x) (p2, l2, r2)) =\n  - real_of_rat x * real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "unfolding z[symmetric]"], ["proof (prove)\nusing this:\n  real_of_2 z = - real_of_2 (mult_rat_1_pos (- x) (p2, l2, r2))\n  invariant_2 z\n  real_of_2 (mult_rat_1_pos (- x) (p2, l2, r2)) =\n  - real_of_rat x * real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "unfolding yt[symmetric]"], ["proof (prove)\nusing this:\n  real_of_2 z = - real_of_2 (mult_rat_1_pos (- x) y)\n  invariant_2 z\n  real_of_2 (mult_rat_1_pos (- x) y) = - real_of_rat x * real_of_1 y\n\ngoal (1 subgoal):\n 1. invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "by simp"], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow>\n    invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y", "qed (auto simp: z)"], ["proof (state)\nthis:\n  invariant_2 z \\<and> real_of_2 z = real_of_rat x * real_of_1 y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "declare mult_1.simps[simp del]"], ["", "declare mult_rat_1.simps[simp del]"], ["", "(* ********************* *)"], ["", "subsubsection\\<open>Root\\<close>"], ["", "definition ipoly_root_delta :: \"int poly \\<Rightarrow> real\" where\n  \"ipoly_root_delta p = Min (insert 1 { abs (x - y) | x y. ipoly p x = 0 \\<and> ipoly p y = 0 \\<and> x \\<noteq> y}) / 4\""], ["", "lemma ipoly_root_delta: assumes \"p \\<noteq> 0\"\n  shows \"ipoly_root_delta p > 0\"\n    \"2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow> ipoly_root_delta p \\<le> real_of_rat (r - l) / 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ipoly_root_delta p &&&\n    (2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n     ipoly_root_delta p \\<le> real_of_rat (r - l) / 4)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ipoly_root_delta p\n 2. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "let ?z = \"0 :: real\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ipoly_root_delta p\n 2. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "let ?R = \"{x. ipoly p x = ?z}\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ipoly_root_delta p\n 2. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "let ?set = \"{ abs (x - y) | x y. ipoly p x = ?z  \\<and> ipoly p y = 0 \\<and> x \\<noteq> y}\""], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ipoly_root_delta p\n 2. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "define S where \"S = insert 1 ?set\""], ["proof (state)\nthis:\n  S =\n  insert 1\n   {\\<bar>x - y\\<bar> |x y.\n    poly (real_of_int_poly p) x = 0 \\<and>\n    poly (real_of_int_poly p) y = 0 \\<and> x \\<noteq> y}\n\ngoal (2 subgoals):\n 1. 0 < ipoly_root_delta p\n 2. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "from finite_ipoly_roots[OF assms]"], ["proof (chain)\npicking this:\n  finite {x. poly (real_of_int_poly p) x = 0}", "have finR: \"finite ?R\" and fin: \"finite (?R \\<times> ?R)\""], ["proof (prove)\nusing this:\n  finite {x. poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. finite {x. poly (real_of_int_poly p) x = 0} &&&\n    finite\n     ({x. poly (real_of_int_poly p) x = 0} \\<times>\n      {x. poly (real_of_int_poly p) x = 0})", "by auto"], ["proof (state)\nthis:\n  finite {x. poly (real_of_int_poly p) x = 0}\n  finite\n   ({x. poly (real_of_int_poly p) x = 0} \\<times>\n    {x. poly (real_of_int_poly p) x = 0})\n\ngoal (2 subgoals):\n 1. 0 < ipoly_root_delta p\n 2. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "have \"finite ?set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {\\<bar>x - y\\<bar> |x y.\n      poly (real_of_int_poly p) x = 0 \\<and>\n      poly (real_of_int_poly p) y = 0 \\<and> x \\<noteq> y}", "by (rule finite_subset[OF _ finite_imageI[OF fin, of \"\\<lambda> (x,y). abs (x - y)\"]], force)"], ["proof (state)\nthis:\n  finite\n   {\\<bar>x - y\\<bar> |x y.\n    poly (real_of_int_poly p) x = 0 \\<and>\n    poly (real_of_int_poly p) y = 0 \\<and> x \\<noteq> y}\n\ngoal (2 subgoals):\n 1. 0 < ipoly_root_delta p\n 2. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "hence fin: \"finite S\" and ne: \"S \\<noteq> {}\" and pos: \"\\<And> x. x \\<in> S \\<Longrightarrow> x > 0\""], ["proof (prove)\nusing this:\n  finite\n   {\\<bar>x - y\\<bar> |x y.\n    poly (real_of_int_poly p) x = 0 \\<and>\n    poly (real_of_int_poly p) y = 0 \\<and> x \\<noteq> y}\n\ngoal (1 subgoal):\n 1. finite S &&&\n    S \\<noteq> {} &&& (\\<And>x. x \\<in> S \\<Longrightarrow> 0 < x)", "unfolding S_def"], ["proof (prove)\nusing this:\n  finite\n   {\\<bar>x - y\\<bar> |x y.\n    poly (real_of_int_poly p) x = 0 \\<and>\n    poly (real_of_int_poly p) y = 0 \\<and> x \\<noteq> y}\n\ngoal (1 subgoal):\n 1. finite\n     (insert 1\n       {\\<bar>x - y\\<bar> |x y.\n        poly (real_of_int_poly p) x = 0 \\<and>\n        poly (real_of_int_poly p) y = 0 \\<and> x \\<noteq> y}) &&&\n    insert 1\n     {\\<bar>x - y\\<bar> |x y.\n      poly (real_of_int_poly p) x = 0 \\<and>\n      poly (real_of_int_poly p) y = 0 \\<and> x \\<noteq> y} \\<noteq>\n    {} &&&\n    (\\<And>x.\n        x \\<in> insert 1\n                 {\\<bar>x - y\\<bar> |x y.\n                  poly (real_of_int_poly p) x = 0 \\<and>\n                  poly (real_of_int_poly p) y = 0 \\<and>\n                  x \\<noteq> y} \\<Longrightarrow>\n        0 < x)", "by auto"], ["proof (state)\nthis:\n  finite S\n  S \\<noteq> {}\n  ?x \\<in> S \\<Longrightarrow> 0 < ?x\n\ngoal (2 subgoals):\n 1. 0 < ipoly_root_delta p\n 2. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "have delta: \"ipoly_root_delta p = Min S / 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly_root_delta p = Min S / 4", "unfolding ipoly_root_delta_def S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min (insert 1\n          {\\<bar>x - y\\<bar> |x y.\n           poly (real_of_int_poly p) x = 0 \\<and>\n           poly (real_of_int_poly p) y = 0 \\<and> x \\<noteq> y}) /\n    4 =\n    Min (insert 1\n          {\\<bar>x - y\\<bar> |x y.\n           poly (real_of_int_poly p) x = 0 \\<and>\n           poly (real_of_int_poly p) y = 0 \\<and> x \\<noteq> y}) /\n    4", ".."], ["proof (state)\nthis:\n  ipoly_root_delta p = Min S / 4\n\ngoal (2 subgoals):\n 1. 0 < ipoly_root_delta p\n 2. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "have pos: \"Min S > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Min S", "using fin ne pos"], ["proof (prove)\nusing this:\n  finite S\n  S \\<noteq> {}\n  ?x \\<in> S \\<Longrightarrow> 0 < ?x\n\ngoal (1 subgoal):\n 1. 0 < Min S", "by auto"], ["proof (state)\nthis:\n  0 < Min S\n\ngoal (2 subgoals):\n 1. 0 < ipoly_root_delta p\n 2. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "show \"ipoly_root_delta p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ipoly_root_delta p", "unfolding delta"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Min S / 4", "using pos"], ["proof (prove)\nusing this:\n  0 < Min S\n\ngoal (1 subgoal):\n 1. 0 < Min S / 4", "by auto"], ["proof (state)\nthis:\n  0 < ipoly_root_delta p\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "let ?S = \"Collect (root_cond (p, l, r))\""], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "assume \"2 \\<le> card ?S\""], ["proof (state)\nthis:\n  2 \\<le> card (Collect (root_cond (p, l, r)))\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "hence 2: \"Suc (Suc 0) \\<le> card ?S\""], ["proof (prove)\nusing this:\n  2 \\<le> card (Collect (root_cond (p, l, r)))\n\ngoal (1 subgoal):\n 1. Suc (Suc 0) \\<le> card (Collect (root_cond (p, l, r)))", "by simp"], ["proof (state)\nthis:\n  Suc (Suc 0) \\<le> card (Collect (root_cond (p, l, r)))\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "from 2[unfolded card_le_Suc_iff[of _ ?S]]"], ["proof (chain)\npicking this:\n  \\<exists>a B.\n     Collect (root_cond (p, l, r)) = insert a B \\<and>\n     a \\<notin> B \\<and> Suc 0 \\<le> card B \\<and> finite B", "obtain x T where \n    ST: \"?S = insert x T\" and xT: \"x \\<notin> T\" and 1: \"Suc 0 \\<le> card T\""], ["proof (prove)\nusing this:\n  \\<exists>a B.\n     Collect (root_cond (p, l, r)) = insert a B \\<and>\n     a \\<notin> B \\<and> Suc 0 \\<le> card B \\<and> finite B\n\ngoal (1 subgoal):\n 1. (\\<And>x T.\n        \\<lbrakk>Collect (root_cond (p, l, r)) = insert x T; x \\<notin> T;\n         Suc 0 \\<le> card T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Collect (root_cond (p, l, r)) = insert x T\n  x \\<notin> T\n  Suc 0 \\<le> card T\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "from 1[unfolded card_le_Suc_iff[of _ T]]"], ["proof (chain)\npicking this:\n  \\<exists>a B.\n     T = insert a B \\<and>\n     a \\<notin> B \\<and> 0 \\<le> card B \\<and> finite B", "obtain y where yT: \"y \\<in> T\""], ["proof (prove)\nusing this:\n  \\<exists>a B.\n     T = insert a B \\<and>\n     a \\<notin> B \\<and> 0 \\<le> card B \\<and> finite B\n\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> T \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> T\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "from ST xT yT"], ["proof (chain)\npicking this:\n  Collect (root_cond (p, l, r)) = insert x T\n  x \\<notin> T\n  y \\<in> T", "have x: \"x \\<in> ?S\" and y: \"y \\<in> ?S\" and xy: \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  Collect (root_cond (p, l, r)) = insert x T\n  x \\<notin> T\n  y \\<in> T\n\ngoal (1 subgoal):\n 1. x \\<in> Collect (root_cond (p, l, r)) &&&\n    y \\<in> Collect (root_cond (p, l, r)) &&& x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  x \\<in> Collect (root_cond (p, l, r))\n  y \\<in> Collect (root_cond (p, l, r))\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "hence \"abs (x - y) \\<in> S\""], ["proof (prove)\nusing this:\n  x \\<in> Collect (root_cond (p, l, r))\n  y \\<in> Collect (root_cond (p, l, r))\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<bar>x - y\\<bar> \\<in> S", "unfolding S_def root_cond_def[abs_def]"], ["proof (prove)\nusing this:\n  x \\<in> {x. case (p, l, r) of\n              (p, l, r) \\<Rightarrow>\n                real_of_rat l \\<le> x \\<and>\n                x \\<le> real_of_rat r \\<and>\n                poly (real_of_int_poly p) x = 0}\n  y \\<in> {x. case (p, l, r) of\n              (p, l, r) \\<Rightarrow>\n                real_of_rat l \\<le> x \\<and>\n                x \\<le> real_of_rat r \\<and>\n                poly (real_of_int_poly p) x = 0}\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<bar>x - y\\<bar>\n    \\<in> insert 1\n           {\\<bar>x - y\\<bar> |x y.\n            poly (real_of_int_poly p) x = 0 \\<and>\n            poly (real_of_int_poly p) y = 0 \\<and> x \\<noteq> y}", "by auto"], ["proof (state)\nthis:\n  \\<bar>x - y\\<bar> \\<in> S\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "with fin"], ["proof (chain)\npicking this:\n  finite S\n  \\<bar>x - y\\<bar> \\<in> S", "have \"Min S \\<le> abs (x - y)\""], ["proof (prove)\nusing this:\n  finite S\n  \\<bar>x - y\\<bar> \\<in> S\n\ngoal (1 subgoal):\n 1. Min S \\<le> \\<bar>x - y\\<bar>", "by auto"], ["proof (state)\nthis:\n  Min S \\<le> \\<bar>x - y\\<bar>\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "with pos"], ["proof (chain)\npicking this:\n  0 < Min S\n  Min S \\<le> \\<bar>x - y\\<bar>", "have le: \"Min S / 2 \\<le> abs (x - y) / 2\""], ["proof (prove)\nusing this:\n  0 < Min S\n  Min S \\<le> \\<bar>x - y\\<bar>\n\ngoal (1 subgoal):\n 1. Min S / 2 \\<le> \\<bar>x - y\\<bar> / 2", "by auto"], ["proof (state)\nthis:\n  Min S / 2 \\<le> \\<bar>x - y\\<bar> / 2\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "from x y"], ["proof (chain)\npicking this:\n  x \\<in> Collect (root_cond (p, l, r))\n  y \\<in> Collect (root_cond (p, l, r))", "have \"abs (x - y) \\<le> of_rat r - of_rat l\""], ["proof (prove)\nusing this:\n  x \\<in> Collect (root_cond (p, l, r))\n  y \\<in> Collect (root_cond (p, l, r))\n\ngoal (1 subgoal):\n 1. \\<bar>x - y\\<bar> \\<le> real_of_rat r - real_of_rat l", "unfolding root_cond_def[abs_def]"], ["proof (prove)\nusing this:\n  x \\<in> {x. case (p, l, r) of\n              (p, l, r) \\<Rightarrow>\n                real_of_rat l \\<le> x \\<and>\n                x \\<le> real_of_rat r \\<and>\n                poly (real_of_int_poly p) x = 0}\n  y \\<in> {x. case (p, l, r) of\n              (p, l, r) \\<Rightarrow>\n                real_of_rat l \\<le> x \\<and>\n                x \\<le> real_of_rat r \\<and>\n                poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. \\<bar>x - y\\<bar> \\<le> real_of_rat r - real_of_rat l", "by auto"], ["proof (state)\nthis:\n  \\<bar>x - y\\<bar> \\<le> real_of_rat r - real_of_rat l\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "also"], ["proof (state)\nthis:\n  \\<bar>x - y\\<bar> \\<le> real_of_rat r - real_of_rat l\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "have \"\\<dots> = of_rat (r - l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat r - real_of_rat l = real_of_rat (r - l)", "by (auto simp: of_rat_diff)"], ["proof (state)\nthis:\n  real_of_rat r - real_of_rat l = real_of_rat (r - l)\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "finally"], ["proof (chain)\npicking this:\n  \\<bar>x - y\\<bar> \\<le> real_of_rat (r - l)", "have \"abs (x - y) / 2 \\<le> of_rat (r - l) / 2\""], ["proof (prove)\nusing this:\n  \\<bar>x - y\\<bar> \\<le> real_of_rat (r - l)\n\ngoal (1 subgoal):\n 1. \\<bar>x - y\\<bar> / 2 \\<le> real_of_rat (r - l) / 2", "by auto"], ["proof (state)\nthis:\n  \\<bar>x - y\\<bar> / 2 \\<le> real_of_rat (r - l) / 2\n\ngoal (1 subgoal):\n 1. 2 \\<le> card (Collect (root_cond (p, l, r))) \\<Longrightarrow>\n    ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "with le"], ["proof (chain)\npicking this:\n  Min S / 2 \\<le> \\<bar>x - y\\<bar> / 2\n  \\<bar>x - y\\<bar> / 2 \\<le> real_of_rat (r - l) / 2", "show \"ipoly_root_delta p \\<le> real_of_rat (r - l) / 4\""], ["proof (prove)\nusing this:\n  Min S / 2 \\<le> \\<bar>x - y\\<bar> / 2\n  \\<bar>x - y\\<bar> / 2 \\<le> real_of_rat (r - l) / 2\n\ngoal (1 subgoal):\n 1. ipoly_root_delta p \\<le> real_of_rat (r - l) / 4", "unfolding delta"], ["proof (prove)\nusing this:\n  Min S / 2 \\<le> \\<bar>x - y\\<bar> / 2\n  \\<bar>x - y\\<bar> / 2 \\<le> real_of_rat (r - l) / 2\n\ngoal (1 subgoal):\n 1. Min S / 4 \\<le> real_of_rat (r - l) / 4", "by auto"], ["proof (state)\nthis:\n  ipoly_root_delta p \\<le> real_of_rat (r - l) / 4\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sgn_less_eq_1_rat: fixes a b :: rat\n  shows \"sgn a = 1 \\<Longrightarrow> a \\<le> b \\<Longrightarrow> sgn b = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sgn a = 1; a \\<le> b\\<rbrakk> \\<Longrightarrow> sgn b = 1", "by (metis (no_types, hide_lams) not_less one_neq_neg_one one_neq_zero order_trans sgn_rat_def)"], ["", "lemma sgn_less_eq_1_real: fixes a b :: real\n  shows \"sgn a = 1 \\<Longrightarrow> a \\<le> b \\<Longrightarrow> sgn b = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sgn a = 1; a \\<le> b\\<rbrakk> \\<Longrightarrow> sgn b = 1", "by (metis (no_types, hide_lams) not_less one_neq_neg_one one_neq_zero order_trans sgn_real_def)"], ["", "definition compare_1_rat :: \"real_alg_1 \\<Rightarrow> rat \\<Rightarrow> order\" where\n  \"compare_1_rat rai = (let p = poly_real_alg_1 rai in\n    if degree p = 1 then let x = Rat.Fract (- coeff p 0) (coeff p 1)\n     in (\\<lambda> y. compare y x)\n    else (\\<lambda> y. compare_rat_1 y rai))\""], ["", "lemma compare_real_of_rat: \"compare (real_of_rat x) (of_rat y) = compare x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare (real_of_rat x) (real_of_rat y) = compare x y", "unfolding compare_rat_def compare_real_def comparator_of_def of_rat_less"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x < y then Lt\n     else if real_of_rat x = real_of_rat y then Eq else Gt) =\n    (if x < y then Lt else if x = y then Eq else Gt)", "by auto"], ["", "lemma compare_1_rat: assumes rc: \"invariant_1 y\"\n  shows \"compare_1_rat y x = compare (of_rat x) (real_of_1 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "proof (cases \"degree (poly_real_alg_1 y)\" \"Suc 0\" rule: linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. degree (poly_real_alg_1 y) < Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)\n 2. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)\n 3. Suc 0 < degree (poly_real_alg_1 y) \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "case less"], ["proof (state)\nthis:\n  degree (poly_real_alg_1 y) < Suc 0\n\ngoal (3 subgoals):\n 1. degree (poly_real_alg_1 y) < Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)\n 2. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)\n 3. Suc 0 < degree (poly_real_alg_1 y) \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "with invariant_1_degree_0[OF rc]"], ["proof (chain)\npicking this:\n  degree (poly_real_alg_1 y) \\<noteq> 0\n  degree (poly_real_alg_1 y) < Suc 0", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (poly_real_alg_1 y) \\<noteq> 0\n  degree (poly_real_alg_1 y) < Suc 0\n\ngoal (1 subgoal):\n 1. compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "by auto"], ["proof (state)\nthis:\n  compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)\n\ngoal (2 subgoals):\n 1. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)\n 2. Suc 0 < degree (poly_real_alg_1 y) \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)\n 2. Suc 0 < degree (poly_real_alg_1 y) \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "case deg: greater"], ["proof (state)\nthis:\n  Suc 0 < degree (poly_real_alg_1 y)\n\ngoal (2 subgoals):\n 1. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)\n 2. Suc 0 < degree (poly_real_alg_1 y) \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "with rc"], ["proof (chain)\npicking this:\n  invariant_1 y\n  Suc 0 < degree (poly_real_alg_1 y)", "have rc: \"invariant_1_2 y\""], ["proof (prove)\nusing this:\n  invariant_1 y\n  Suc 0 < degree (poly_real_alg_1 y)\n\ngoal (1 subgoal):\n 1. invariant_1_2 y", "by auto"], ["proof (state)\nthis:\n  invariant_1_2 y\n\ngoal (2 subgoals):\n 1. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)\n 2. Suc 0 < degree (poly_real_alg_1 y) \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "from deg compare_rat_1[OF rc, of x]"], ["proof (chain)\npicking this:\n  Suc 0 < degree (poly_real_alg_1 y)\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc 0 < degree (poly_real_alg_1 y)\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n\ngoal (1 subgoal):\n 1. compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "unfolding compare_1_rat_def"], ["proof (prove)\nusing this:\n  Suc 0 < degree (poly_real_alg_1 y)\n  compare_rat_1 x y = compare (real_of_rat x) (real_of_1 y)\n\ngoal (1 subgoal):\n 1. (let p = poly_real_alg_1 y\n     in if degree p = 1\n        then let x = Rat.Fract (- coeff p 0) (coeff p 1)\n             in (\\<lambda>y. compare y x)\n        else (\\<lambda>ya. compare_rat_1 ya y))\n     x =\n    compare (real_of_rat x) (real_of_1 y)", "by auto"], ["proof (state)\nthis:\n  compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)\n\ngoal (1 subgoal):\n 1. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "case deg: equal"], ["proof (state)\nthis:\n  degree (poly_real_alg_1 y) = Suc 0\n\ngoal (1 subgoal):\n 1. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "obtain p l r where y: \"y = (p,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p l r. y = (p, l, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases y)"], ["proof (state)\nthis:\n  y = (p, l, r)\n\ngoal (1 subgoal):\n 1. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "note rc = invariant_1D[OF rc[unfolded y]]"], ["proof (state)\nthis:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "from deg"], ["proof (chain)\npicking this:\n  degree (poly_real_alg_1 y) = Suc 0", "have p: \"degree p = Suc 0\" \n    and id: \"compare_1_rat y x = compare x (Rat.Fract (- coeff p 0) (coeff p 1))\""], ["proof (prove)\nusing this:\n  degree (poly_real_alg_1 y) = Suc 0\n\ngoal (1 subgoal):\n 1. degree p = Suc 0 &&&\n    compare_1_rat y x = compare x (Rat.Fract (- coeff p 0) (coeff p 1))", "unfolding compare_1_rat_def"], ["proof (prove)\nusing this:\n  degree (poly_real_alg_1 y) = Suc 0\n\ngoal (1 subgoal):\n 1. degree p = Suc 0 &&&\n    (let p = poly_real_alg_1 y\n     in if degree p = 1\n        then let x = Rat.Fract (- coeff p 0) (coeff p 1)\n             in (\\<lambda>y. compare y x)\n        else (\\<lambda>ya. compare_rat_1 ya y))\n     x =\n    compare x (Rat.Fract (- coeff p 0) (coeff p 1))", "by (auto simp: Let_def y)"], ["proof (state)\nthis:\n  degree p = Suc 0\n  compare_1_rat y x = compare x (Rat.Fract (- coeff p 0) (coeff p 1))\n\ngoal (1 subgoal):\n 1. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "from rc(1)[unfolded split]"], ["proof (chain)\npicking this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))", "have \"ipoly p (real_of_1 y) = 0\""], ["proof (prove)\nusing this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) (real_of_1 y) = 0", "unfolding y"], ["proof (prove)\nusing this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) (real_of_1 (p, l, r)) = 0", "by auto"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) (real_of_1 y) = 0\n\ngoal (1 subgoal):\n 1. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "with degree_1_ipoly[OF p, of \"real_of_1 y\"]"], ["proof (chain)\npicking this:\n  (poly (real_of_int_poly p) (real_of_1 y) = 0) =\n  (real_of_1 y = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))\n  poly (real_of_int_poly p) (real_of_1 y) = 0", "have id': \"real_of_1 y = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1))\""], ["proof (prove)\nusing this:\n  (poly (real_of_int_poly p) (real_of_1 y) = 0) =\n  (real_of_1 y = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1)))\n  poly (real_of_int_poly p) (real_of_1 y) = 0\n\ngoal (1 subgoal):\n 1. real_of_1 y = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1))", "by simp"], ["proof (state)\nthis:\n  real_of_1 y = real_of_rat (Rat.Fract (- coeff p 0) (coeff p 1))\n\ngoal (1 subgoal):\n 1. degree (poly_real_alg_1 y) = Suc 0 \\<Longrightarrow>\n    compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)", "unfolding id id' compare_real_of_rat"], ["proof (prove)\ngoal (1 subgoal):\n 1. compare x (Rat.Fract (- coeff p 0) (coeff p 1)) =\n    compare x (Rat.Fract (- coeff p 0) (coeff p 1))", ".."], ["proof (state)\nthis:\n  compare_1_rat y x = compare (real_of_rat x) (real_of_1 y)\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes n :: nat\nbegin"], ["", "private"], ["", "definition initial_lower_bound :: \"rat \\<Rightarrow> rat\" where \n  \"initial_lower_bound l = (if l \\<le> 1 then l else of_int (root_rat_floor n l))\""], ["", "private"], ["", "definition initial_upper_bound :: \"rat \\<Rightarrow> rat\" where\n  \"initial_upper_bound r = (of_int (root_rat_ceiling n r))\""], ["", "context\n  fixes cmpx :: \"rat \\<Rightarrow> order\" \nbegin"], ["", "fun tighten_bound_root :: \n  \"rat \\<times> rat \\<Rightarrow> rat \\<times> rat\" where\n  \"tighten_bound_root (l',r') = (let \n      m' = (l' + r') / 2;\n      m = m' ^ n      \n      in case cmpx m of \n         Eq \\<Rightarrow> (m',m')\n       | Lt \\<Rightarrow> (m',r')\n       | Gt \\<Rightarrow> (l',m'))\""], ["", "lemma tighten_bound_root: assumes sgn: \"sgn il = 1\" \"real_of_1 x \\<ge> 0\" and\n  il: \"real_of_rat il \\<le> root n (real_of_1 x)\" and \n  ir: \"root n (real_of_1 x) \\<le> real_of_rat ir\" and\n  rai: \"invariant_1 x\" and\n  cmpx: \"cmpx = compare_1_rat x\" and\n  n: \"n \\<noteq> 0\" \nshows \"converges_to (\\<lambda> i. (tighten_bound_root ^^ i) (il, ir))\n     (root n (real_of_1 x))\" (is \"converges_to ?f ?x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. converges_to (\\<lambda>i. (local.tighten_bound_root ^^ i) (il, ir))\n     (root n (real_of_1 x))", "unfolding converges_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>na.\n        in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n         (root n (real_of_1 x)) \\<and>\n        sub_interval ((local.tighten_bound_root ^^ Suc na) (il, ir))\n         ((local.tighten_bound_root ^^ na) (il, ir))) \\<and>\n    (\\<forall>eps>0.\n        \\<exists>n l r.\n           (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n           real_of_rat r - real_of_rat l \\<le> eps)", "proof (intro conjI impI allI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "fix x :: real"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "have \"x \\<ge> 0 \\<Longrightarrow> (root n x) ^ n = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow> root n x ^ n = x", "using n"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow> root n x ^ n = x", "by simp"], ["proof (state)\nthis:\n  0 \\<le> x \\<Longrightarrow> root n x ^ n = x\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "}"], ["proof (state)\nthis:\n  0 \\<le> ?xa2 \\<Longrightarrow> root n ?xa2 ^ n = ?xa2\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "note root_exp_cancel = this"], ["proof (state)\nthis:\n  0 \\<le> ?xa2 \\<Longrightarrow> root n ?xa2 ^ n = ?xa2\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "{"], ["proof (state)\nthis:\n  0 \\<le> ?xa2 \\<Longrightarrow> root n ?xa2 ^ n = ?xa2\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "fix x :: real"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "have \"x \\<ge> 0 \\<Longrightarrow> root n (x ^ n) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow> root n (x ^ n) = x", "using n"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow> root n (x ^ n) = x", "using real_root_pos_unique"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  \\<lbrakk>0 < ?n; 0 \\<le> ?y; ?y ^ ?n = ?x\\<rbrakk>\n  \\<Longrightarrow> root ?n ?x = ?y\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow> root n (x ^ n) = x", "by blast"], ["proof (state)\nthis:\n  0 \\<le> x \\<Longrightarrow> root n (x ^ n) = x\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "}"], ["proof (state)\nthis:\n  0 \\<le> ?xa2 \\<Longrightarrow> root n (?xa2 ^ n) = ?xa2\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "note root_exp_cancel' = this"], ["proof (state)\nthis:\n  0 \\<le> ?xa2 \\<Longrightarrow> root n (?xa2 ^ n) = ?xa2\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "from il ir"], ["proof (chain)\npicking this:\n  real_of_rat il \\<le> root n (real_of_1 x)\n  root n (real_of_1 x) \\<le> real_of_rat ir", "have \"real_of_rat il \\<le> of_rat ir\""], ["proof (prove)\nusing this:\n  real_of_rat il \\<le> root n (real_of_1 x)\n  root n (real_of_1 x) \\<le> real_of_rat ir\n\ngoal (1 subgoal):\n 1. real_of_rat il \\<le> real_of_rat ir", "by auto"], ["proof (state)\nthis:\n  real_of_rat il \\<le> real_of_rat ir\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "hence ir_il: \"il \\<le> ir\""], ["proof (prove)\nusing this:\n  real_of_rat il \\<le> real_of_rat ir\n\ngoal (1 subgoal):\n 1. il \\<le> ir", "by (auto simp: of_rat_less_eq)"], ["proof (state)\nthis:\n  il \\<le> ir\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "from n"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "have n': \"n > 0\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "{"], ["proof (state)\nthis:\n  0 < n\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "have \"in_interval (?f i) ?x \\<and> sub_interval (?f i) (il,ir) \\<and> (i \\<noteq> 0 \\<longrightarrow> sub_interval (?f i) (?f (i - 1))) \n      \\<and> snd (?f i) - fst (?f i) \\<le> (ir - il) / 2^i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ i) (il, ir)) (il, ir) \\<and>\n    (i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n      ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ i) (il, ir))\n    \\<le> (ir - il) / 2 ^ i", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. in_interval ((local.tighten_bound_root ^^ 0) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ 0) (il, ir)) (il, ir) \\<and>\n    (0 \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ 0) (il, ir))\n      ((local.tighten_bound_root ^^ (0 - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ 0) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ 0) (il, ir))\n    \\<le> (ir - il) / 2 ^ 0\n 2. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. in_interval ((local.tighten_bound_root ^^ 0) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ 0) (il, ir)) (il, ir) \\<and>\n    (0 \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ 0) (il, ir))\n      ((local.tighten_bound_root ^^ (0 - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ 0) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ 0) (il, ir))\n    \\<le> (ir - il) / 2 ^ 0\n 2. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_interval ((local.tighten_bound_root ^^ 0) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ 0) (il, ir)) (il, ir) \\<and>\n    (0 \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ 0) (il, ir))\n      ((local.tighten_bound_root ^^ (0 - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ 0) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ 0) (il, ir))\n    \\<le> (ir - il) / 2 ^ 0", "using il ir"], ["proof (prove)\nusing this:\n  real_of_rat il \\<le> root n (real_of_1 x)\n  root n (real_of_1 x) \\<le> real_of_rat ir\n\ngoal (1 subgoal):\n 1. in_interval ((local.tighten_bound_root ^^ 0) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ 0) (il, ir)) (il, ir) \\<and>\n    (0 \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ 0) (il, ir))\n      ((local.tighten_bound_root ^^ (0 - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ 0) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ 0) (il, ir))\n    \\<le> (ir - il) / 2 ^ 0", "by auto"], ["proof (state)\nthis:\n  in_interval ((local.tighten_bound_root ^^ 0) (il, ir))\n   (root n (real_of_1 x)) \\<and>\n  sub_interval ((local.tighten_bound_root ^^ 0) (il, ir)) (il, ir) \\<and>\n  (0 \\<noteq> 0 \\<longrightarrow>\n   sub_interval ((local.tighten_bound_root ^^ 0) (il, ir))\n    ((local.tighten_bound_root ^^ (0 - 1)) (il, ir))) \\<and>\n  snd ((local.tighten_bound_root ^^ 0) (il, ir)) -\n  fst ((local.tighten_bound_root ^^ 0) (il, ir))\n  \\<le> (ir - il) / 2 ^ 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "case (Suc i)"], ["proof (state)\nthis:\n  in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n   (root n (real_of_1 x)) \\<and>\n  sub_interval ((local.tighten_bound_root ^^ i) (il, ir)) (il, ir) \\<and>\n  (i \\<noteq> 0 \\<longrightarrow>\n   sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n    ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n  snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n  fst ((local.tighten_bound_root ^^ i) (il, ir))\n  \\<le> (ir - il) / 2 ^ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "obtain l' r' where id: \"(tighten_bound_root ^^ i) (il, ir) = (l',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l' r'.\n        (local.tighten_bound_root ^^ i) (il, ir) =\n        (l', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"(tighten_bound_root ^^ i) (il, ir)\", auto)"], ["proof (state)\nthis:\n  (local.tighten_bound_root ^^ i) (il, ir) = (l', r')\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "let ?m' = \"(l' + r') / 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "let ?m = \"?m' ^ n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "define m where \"m = ?m\""], ["proof (state)\nthis:\n  m = ((l' + r') / 2) ^ n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "note IH = Suc[unfolded id split snd_conv fst_conv]"], ["proof (state)\nthis:\n  in_interval (l', r') (root n (real_of_1 x)) \\<and>\n  sub_interval (l', r') (il, ir) \\<and>\n  (i \\<noteq> 0 \\<longrightarrow>\n   sub_interval (l', r')\n    ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n  r' - l' \\<le> (ir - il) / 2 ^ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "from IH"], ["proof (chain)\npicking this:\n  in_interval (l', r') (root n (real_of_1 x)) \\<and>\n  sub_interval (l', r') (il, ir) \\<and>\n  (i \\<noteq> 0 \\<longrightarrow>\n   sub_interval (l', r')\n    ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n  r' - l' \\<le> (ir - il) / 2 ^ i", "have \"sub_interval (l', r') (il, ir)\""], ["proof (prove)\nusing this:\n  in_interval (l', r') (root n (real_of_1 x)) \\<and>\n  sub_interval (l', r') (il, ir) \\<and>\n  (i \\<noteq> 0 \\<longrightarrow>\n   sub_interval (l', r')\n    ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n  r' - l' \\<le> (ir - il) / 2 ^ i\n\ngoal (1 subgoal):\n 1. sub_interval (l', r') (il, ir)", "by auto"], ["proof (state)\nthis:\n  sub_interval (l', r') (il, ir)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "hence ill': \"il \\<le> l'\" \"r' \\<le> ir\""], ["proof (prove)\nusing this:\n  sub_interval (l', r') (il, ir)\n\ngoal (1 subgoal):\n 1. il \\<le> l' &&& r' \\<le> ir", "by auto"], ["proof (state)\nthis:\n  il \\<le> l'\n  r' \\<le> ir\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "with sgn"], ["proof (chain)\npicking this:\n  sgn il = 1\n  0 \\<le> real_of_1 x\n  il \\<le> l'\n  r' \\<le> ir", "have l'0: \"l' > 0\""], ["proof (prove)\nusing this:\n  sgn il = 1\n  0 \\<le> real_of_1 x\n  il \\<le> l'\n  r' \\<le> ir\n\ngoal (1 subgoal):\n 1. 0 < l'", "using sgn_1_pos sgn_less_eq_1_rat"], ["proof (prove)\nusing this:\n  sgn il = 1\n  0 \\<le> real_of_1 x\n  il \\<le> l'\n  r' \\<le> ir\n  (sgn ?a = (1::?'a)) = ((0::?'a) < ?a)\n  \\<lbrakk>sgn ?a = 1; ?a \\<le> ?b\\<rbrakk> \\<Longrightarrow> sgn ?b = 1\n\ngoal (1 subgoal):\n 1. 0 < l'", "by blast"], ["proof (state)\nthis:\n  0 < l'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "from IH"], ["proof (chain)\npicking this:\n  in_interval (l', r') (root n (real_of_1 x)) \\<and>\n  sub_interval (l', r') (il, ir) \\<and>\n  (i \\<noteq> 0 \\<longrightarrow>\n   sub_interval (l', r')\n    ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n  r' - l' \\<le> (ir - il) / 2 ^ i", "have lr'x: \"in_interval (l', r') ?x\""], ["proof (prove)\nusing this:\n  in_interval (l', r') (root n (real_of_1 x)) \\<and>\n  sub_interval (l', r') (il, ir) \\<and>\n  (i \\<noteq> 0 \\<longrightarrow>\n   sub_interval (l', r')\n    ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n  r' - l' \\<le> (ir - il) / 2 ^ i\n\ngoal (1 subgoal):\n 1. in_interval (l', r') (root n (real_of_1 x))", "by auto"], ["proof (state)\nthis:\n  in_interval (l', r') (root n (real_of_1 x))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "hence lr'': \"real_of_rat l' \\<le> of_rat r'\""], ["proof (prove)\nusing this:\n  in_interval (l', r') (root n (real_of_1 x))\n\ngoal (1 subgoal):\n 1. real_of_rat l' \\<le> real_of_rat r'", "by auto"], ["proof (state)\nthis:\n  real_of_rat l' \\<le> real_of_rat r'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "hence lr': \"l' \\<le> r'\""], ["proof (prove)\nusing this:\n  real_of_rat l' \\<le> real_of_rat r'\n\ngoal (1 subgoal):\n 1. l' \\<le> r'", "unfolding of_rat_less_eq"], ["proof (prove)\nusing this:\n  l' \\<le> r'\n\ngoal (1 subgoal):\n 1. l' \\<le> r'", "."], ["proof (state)\nthis:\n  l' \\<le> r'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "with l'0"], ["proof (chain)\npicking this:\n  0 < l'\n  l' \\<le> r'", "have r'0: \"r' > 0\""], ["proof (prove)\nusing this:\n  0 < l'\n  l' \\<le> r'\n\ngoal (1 subgoal):\n 1. 0 < r'", "by auto"], ["proof (state)\nthis:\n  0 < r'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "note compare = compare_1_rat[OF rai, of ?m, folded cmpx]"], ["proof (state)\nthis:\n  cmpx (((l' + r') / 2) ^ n) =\n  compare (real_of_rat (((l' + r') / 2) ^ n)) (real_of_1 x)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "from IH"], ["proof (chain)\npicking this:\n  in_interval (l', r') (root n (real_of_1 x)) \\<and>\n  sub_interval (l', r') (il, ir) \\<and>\n  (i \\<noteq> 0 \\<longrightarrow>\n   sub_interval (l', r')\n    ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n  r' - l' \\<le> (ir - il) / 2 ^ i", "have *: \"r' - l' \\<le> (ir - il) / 2 ^ i\""], ["proof (prove)\nusing this:\n  in_interval (l', r') (root n (real_of_1 x)) \\<and>\n  sub_interval (l', r') (il, ir) \\<and>\n  (i \\<noteq> 0 \\<longrightarrow>\n   sub_interval (l', r')\n    ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n  r' - l' \\<le> (ir - il) / 2 ^ i\n\ngoal (1 subgoal):\n 1. r' - l' \\<le> (ir - il) / 2 ^ i", "by auto"], ["proof (state)\nthis:\n  r' - l' \\<le> (ir - il) / 2 ^ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "have \"r' - (l' + r') / 2 = (r' - l') / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r' - (l' + r') / 2 = (r' - l') / 2", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  r' - (l' + r') / 2 = (r' - l') / 2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "also"], ["proof (state)\nthis:\n  r' - (l' + r') / 2 = (r' - l') / 2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "have \"\\<dots> \\<le> (ir - il) / 2 ^ i / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r' - l') / 2 \\<le> (ir - il) / 2 ^ i / 2", "using *"], ["proof (prove)\nusing this:\n  r' - l' \\<le> (ir - il) / 2 ^ i\n\ngoal (1 subgoal):\n 1. (r' - l') / 2 \\<le> (ir - il) / 2 ^ i / 2", "by (rule divide_right_mono, auto)"], ["proof (state)\nthis:\n  (r' - l') / 2 \\<le> (ir - il) / 2 ^ i / 2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "finally"], ["proof (chain)\npicking this:\n  r' - (l' + r') / 2 \\<le> (ir - il) / 2 ^ i / 2", "have size: \"r' - (l' + r') / 2 \\<le> (ir - il) / (2 * 2 ^ i)\""], ["proof (prove)\nusing this:\n  r' - (l' + r') / 2 \\<le> (ir - il) / 2 ^ i / 2\n\ngoal (1 subgoal):\n 1. r' - (l' + r') / 2 \\<le> (ir - il) / (2 * 2 ^ i)", "by simp"], ["proof (state)\nthis:\n  r' - (l' + r') / 2 \\<le> (ir - il) / (2 * 2 ^ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "also"], ["proof (state)\nthis:\n  r' - (l' + r') / 2 \\<le> (ir - il) / (2 * 2 ^ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "have \"r' - (l' + r') / 2 = (l' + r') / 2 - l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r' - (l' + r') / 2 = (l' + r') / 2 - l'", "by auto"], ["proof (state)\nthis:\n  r' - (l' + r') / 2 = (l' + r') / 2 - l'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "finally"], ["proof (chain)\npicking this:\n  (l' + r') / 2 - l' \\<le> (ir - il) / (2 * 2 ^ i)", "have size': \"(l' + r') / 2 - l' \\<le> (ir - il) / (2 * 2 ^ i)\""], ["proof (prove)\nusing this:\n  (l' + r') / 2 - l' \\<le> (ir - il) / (2 * 2 ^ i)\n\ngoal (1 subgoal):\n 1. (l' + r') / 2 - l' \\<le> (ir - il) / (2 * 2 ^ i)", "by simp"], ["proof (state)\nthis:\n  (l' + r') / 2 - l' \\<le> (ir - il) / (2 * 2 ^ i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "have \"root n (real_of_rat ?m) = root n ((real_of_rat ?m') ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root n (real_of_rat (((l' + r') / 2) ^ n)) =\n    root n (real_of_rat ((l' + r') / 2) ^ n)", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  root n (real_of_rat (((l' + r') / 2) ^ n)) =\n  root n (real_of_rat ((l' + r') / 2) ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "also"], ["proof (state)\nthis:\n  root n (real_of_rat (((l' + r') / 2) ^ n)) =\n  root n (real_of_rat ((l' + r') / 2) ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "have \"\\<dots> = real_of_rat ?m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root n (real_of_rat ((l' + r') / 2) ^ n) = real_of_rat ((l' + r') / 2)", "by (rule root_exp_cancel', insert l'0 lr', auto)"], ["proof (state)\nthis:\n  root n (real_of_rat ((l' + r') / 2) ^ n) = real_of_rat ((l' + r') / 2)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "finally"], ["proof (chain)\npicking this:\n  root n (real_of_rat (((l' + r') / 2) ^ n)) = real_of_rat ((l' + r') / 2)", "have root: \"root n (of_rat ?m) = of_rat ?m'\""], ["proof (prove)\nusing this:\n  root n (real_of_rat (((l' + r') / 2) ^ n)) = real_of_rat ((l' + r') / 2)\n\ngoal (1 subgoal):\n 1. root n (real_of_rat (((l' + r') / 2) ^ n)) = real_of_rat ((l' + r') / 2)", "."], ["proof (state)\nthis:\n  root n (real_of_rat (((l' + r') / 2) ^ n)) = real_of_rat ((l' + r') / 2)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n        (il, ir) \\<and>\n       (i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n         ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ i) (il, ir))\n       \\<le> (ir - il) / 2 ^ i \\<Longrightarrow>\n       in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (root n (real_of_1 x)) \\<and>\n       sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n        (il, ir) \\<and>\n       (Suc i \\<noteq> 0 \\<longrightarrow>\n        sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n         ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n       snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n       fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n       \\<le> (ir - il) / 2 ^ Suc i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "proof (cases \"cmpx ?m\")"], ["proof (state)\ngoal (3 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Eq \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 3. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "case Eq"], ["proof (state)\nthis:\n  cmpx (((l' + r') / 2) ^ n) = Eq\n\ngoal (3 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Eq \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 3. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "from compare[unfolded Eq]"], ["proof (chain)\npicking this:\n  Eq = compare (real_of_rat (((l' + r') / 2) ^ n)) (real_of_1 x)", "have \"real_of_1 x = of_rat ?m\""], ["proof (prove)\nusing this:\n  Eq = compare (real_of_rat (((l' + r') / 2) ^ n)) (real_of_1 x)\n\ngoal (1 subgoal):\n 1. real_of_1 x = real_of_rat (((l' + r') / 2) ^ n)", "unfolding compare_real_def comparator_of_def"], ["proof (prove)\nusing this:\n  Eq =\n  (if real_of_rat (((l' + r') / 2) ^ n) < real_of_1 x then Lt\n   else if real_of_rat (((l' + r') / 2) ^ n) = real_of_1 x then Eq else Gt)\n\ngoal (1 subgoal):\n 1. real_of_1 x = real_of_rat (((l' + r') / 2) ^ n)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  real_of_1 x = real_of_rat (((l' + r') / 2) ^ n)\n\ngoal (3 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Eq \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 3. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "from arg_cong[OF this, of \"root n\"]"], ["proof (chain)\npicking this:\n  root n (real_of_1 x) = root n (real_of_rat (((l' + r') / 2) ^ n))", "have \"?x = root n (of_rat ?m)\""], ["proof (prove)\nusing this:\n  root n (real_of_1 x) = root n (real_of_rat (((l' + r') / 2) ^ n))\n\ngoal (1 subgoal):\n 1. root n (real_of_1 x) = root n (real_of_rat (((l' + r') / 2) ^ n))", "."], ["proof (state)\nthis:\n  root n (real_of_1 x) = root n (real_of_rat (((l' + r') / 2) ^ n))\n\ngoal (3 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Eq \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 3. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "also"], ["proof (state)\nthis:\n  root n (real_of_1 x) = root n (real_of_rat (((l' + r') / 2) ^ n))\n\ngoal (3 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Eq \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 3. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "have \"\\<dots> = root n  (real_of_rat ?m') ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root n (real_of_rat (((l' + r') / 2) ^ n)) =\n    root n (real_of_rat ((l' + r') / 2)) ^ n", "using n real_root_power"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  0 < ?n \\<Longrightarrow> root ?n (?x ^ ?k) = root ?n ?x ^ ?k\n\ngoal (1 subgoal):\n 1. root n (real_of_rat (((l' + r') / 2) ^ n)) =\n    root n (real_of_rat ((l' + r') / 2)) ^ n", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  root n (real_of_rat (((l' + r') / 2) ^ n)) =\n  root n (real_of_rat ((l' + r') / 2)) ^ n\n\ngoal (3 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Eq \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 3. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "also"], ["proof (state)\nthis:\n  root n (real_of_rat (((l' + r') / 2) ^ n)) =\n  root n (real_of_rat ((l' + r') / 2)) ^ n\n\ngoal (3 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Eq \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 3. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "have \"\\<dots> = of_rat ?m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root n (real_of_rat ((l' + r') / 2)) ^ n = real_of_rat ((l' + r') / 2)", "by (rule root_exp_cancel, insert IH sgn(2) l'0 r'0, auto)"], ["proof (state)\nthis:\n  root n (real_of_rat ((l' + r') / 2)) ^ n = real_of_rat ((l' + r') / 2)\n\ngoal (3 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Eq \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 3. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "finally"], ["proof (chain)\npicking this:\n  root n (real_of_1 x) = real_of_rat ((l' + r') / 2)", "have x: \"?x = of_rat ?m'\""], ["proof (prove)\nusing this:\n  root n (real_of_1 x) = real_of_rat ((l' + r') / 2)\n\ngoal (1 subgoal):\n 1. root n (real_of_1 x) = real_of_rat ((l' + r') / 2)", "."], ["proof (state)\nthis:\n  root n (real_of_1 x) = real_of_rat ((l' + r') / 2)\n\ngoal (3 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Eq \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 3. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "using x id Eq lr' ill' ir_il"], ["proof (prove)\nusing this:\n  root n (real_of_1 x) = real_of_rat ((l' + r') / 2)\n  (local.tighten_bound_root ^^ i) (il, ir) = (l', r')\n  cmpx (((l' + r') / 2) ^ n) = Eq\n  l' \\<le> r'\n  il \\<le> l'\n  r' \\<le> ir\n  il \\<le> ir\n\ngoal (1 subgoal):\n 1. in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n   (root n (real_of_1 x)) \\<and>\n  sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n   (il, ir) \\<and>\n  (Suc i \\<noteq> 0 \\<longrightarrow>\n   sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n  snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n  fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n  \\<le> (ir - il) / 2 ^ Suc i\n\ngoal (2 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "case Lt"], ["proof (state)\nthis:\n  cmpx (((l' + r') / 2) ^ n) = Lt\n\ngoal (2 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "from compare[unfolded Lt]"], ["proof (chain)\npicking this:\n  Lt = compare (real_of_rat (((l' + r') / 2) ^ n)) (real_of_1 x)", "have lt: \"of_rat ?m \\<le> real_of_1 x\""], ["proof (prove)\nusing this:\n  Lt = compare (real_of_rat (((l' + r') / 2) ^ n)) (real_of_1 x)\n\ngoal (1 subgoal):\n 1. real_of_rat (((l' + r') / 2) ^ n) \\<le> real_of_1 x", "unfolding compare_real_def comparator_of_def"], ["proof (prove)\nusing this:\n  Lt =\n  (if real_of_rat (((l' + r') / 2) ^ n) < real_of_1 x then Lt\n   else if real_of_rat (((l' + r') / 2) ^ n) = real_of_1 x then Eq else Gt)\n\ngoal (1 subgoal):\n 1. real_of_rat (((l' + r') / 2) ^ n) \\<le> real_of_1 x", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  real_of_rat (((l' + r') / 2) ^ n) \\<le> real_of_1 x\n\ngoal (2 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "have id'': \"?f (Suc i) = (?m',r')\" \"?f (Suc i - 1) = (l',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.tighten_bound_root ^^ Suc i) (il, ir) = ((l' + r') / 2, r') &&&\n    (local.tighten_bound_root ^^ (Suc i - 1)) (il, ir) = (l', r')", "using Lt id"], ["proof (prove)\nusing this:\n  cmpx (((l' + r') / 2) ^ n) = Lt\n  (local.tighten_bound_root ^^ i) (il, ir) = (l', r')\n\ngoal (1 subgoal):\n 1. (local.tighten_bound_root ^^ Suc i) (il, ir) = ((l' + r') / 2, r') &&&\n    (local.tighten_bound_root ^^ (Suc i - 1)) (il, ir) = (l', r')", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  (local.tighten_bound_root ^^ Suc i) (il, ir) = ((l' + r') / 2, r')\n  (local.tighten_bound_root ^^ (Suc i - 1)) (il, ir) = (l', r')\n\ngoal (2 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "from real_root_le_mono[OF n' lt]"], ["proof (chain)\npicking this:\n  root n (real_of_rat (((l' + r') / 2) ^ n)) \\<le> root n (real_of_1 x)", "have \"of_rat ?m' \\<le> ?x\""], ["proof (prove)\nusing this:\n  root n (real_of_rat (((l' + r') / 2) ^ n)) \\<le> root n (real_of_1 x)\n\ngoal (1 subgoal):\n 1. real_of_rat ((l' + r') / 2) \\<le> root n (real_of_1 x)", "unfolding root"], ["proof (prove)\nusing this:\n  real_of_rat ((l' + r') / 2) \\<le> root n (real_of_1 x)\n\ngoal (1 subgoal):\n 1. real_of_rat ((l' + r') / 2) \\<le> root n (real_of_1 x)", "by simp"], ["proof (state)\nthis:\n  real_of_rat ((l' + r') / 2) \\<le> root n (real_of_1 x)\n\ngoal (2 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "with lr'x lr''"], ["proof (chain)\npicking this:\n  in_interval (l', r') (root n (real_of_1 x))\n  real_of_rat l' \\<le> real_of_rat r'\n  real_of_rat ((l' + r') / 2) \\<le> root n (real_of_1 x)", "have ineq': \"real_of_rat l' + real_of_rat r' \\<le> ?x * 2\""], ["proof (prove)\nusing this:\n  in_interval (l', r') (root n (real_of_1 x))\n  real_of_rat l' \\<le> real_of_rat r'\n  real_of_rat ((l' + r') / 2) \\<le> root n (real_of_1 x)\n\ngoal (1 subgoal):\n 1. real_of_rat l' + real_of_rat r' \\<le> root n (real_of_1 x) * 2", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  real_of_rat l' + real_of_rat r' \\<le> root n (real_of_1 x) * 2\n\ngoal (2 subgoals):\n 1. cmpx (((l' + r') / 2) ^ n) = Lt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i\n 2. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "unfolding id''"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_interval ((l' + r') / 2, r') (root n (real_of_1 x)) \\<and>\n    sub_interval ((l' + r') / 2, r') (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((l' + r') / 2, r') (l', r')) \\<and>\n    snd ((l' + r') / 2, r') - fst ((l' + r') / 2, r')\n    \\<le> (ir - il) / 2 ^ Suc i", "by (auto simp: Let_def hom_distribs, insert size ineq' lr' ill' lr'x ir_il, auto)"], ["proof (state)\nthis:\n  in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n   (root n (real_of_1 x)) \\<and>\n  sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n   (il, ir) \\<and>\n  (Suc i \\<noteq> 0 \\<longrightarrow>\n   sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n  snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n  fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n  \\<le> (ir - il) / 2 ^ Suc i\n\ngoal (1 subgoal):\n 1. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "case Gt"], ["proof (state)\nthis:\n  cmpx (((l' + r') / 2) ^ n) = Gt\n\ngoal (1 subgoal):\n 1. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "from compare[unfolded Gt]"], ["proof (chain)\npicking this:\n  Gt = compare (real_of_rat (((l' + r') / 2) ^ n)) (real_of_1 x)", "have lt: \"of_rat ?m \\<ge> real_of_1 x\""], ["proof (prove)\nusing this:\n  Gt = compare (real_of_rat (((l' + r') / 2) ^ n)) (real_of_1 x)\n\ngoal (1 subgoal):\n 1. real_of_1 x \\<le> real_of_rat (((l' + r') / 2) ^ n)", "unfolding compare_real_def comparator_of_def"], ["proof (prove)\nusing this:\n  Gt =\n  (if real_of_rat (((l' + r') / 2) ^ n) < real_of_1 x then Lt\n   else if real_of_rat (((l' + r') / 2) ^ n) = real_of_1 x then Eq else Gt)\n\ngoal (1 subgoal):\n 1. real_of_1 x \\<le> real_of_rat (((l' + r') / 2) ^ n)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  real_of_1 x \\<le> real_of_rat (((l' + r') / 2) ^ n)\n\ngoal (1 subgoal):\n 1. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "have id'': \"?f (Suc i) = (l',?m')\" \"?f (Suc i - 1) = (l',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.tighten_bound_root ^^ Suc i) (il, ir) = (l', (l' + r') / 2) &&&\n    (local.tighten_bound_root ^^ (Suc i - 1)) (il, ir) = (l', r')", "using Gt id"], ["proof (prove)\nusing this:\n  cmpx (((l' + r') / 2) ^ n) = Gt\n  (local.tighten_bound_root ^^ i) (il, ir) = (l', r')\n\ngoal (1 subgoal):\n 1. (local.tighten_bound_root ^^ Suc i) (il, ir) = (l', (l' + r') / 2) &&&\n    (local.tighten_bound_root ^^ (Suc i - 1)) (il, ir) = (l', r')", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  (local.tighten_bound_root ^^ Suc i) (il, ir) = (l', (l' + r') / 2)\n  (local.tighten_bound_root ^^ (Suc i - 1)) (il, ir) = (l', r')\n\ngoal (1 subgoal):\n 1. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "from real_root_le_mono[OF n' lt]"], ["proof (chain)\npicking this:\n  root n (real_of_1 x) \\<le> root n (real_of_rat (((l' + r') / 2) ^ n))", "have \"?x \\<le> of_rat ?m'\""], ["proof (prove)\nusing this:\n  root n (real_of_1 x) \\<le> root n (real_of_rat (((l' + r') / 2) ^ n))\n\ngoal (1 subgoal):\n 1. root n (real_of_1 x) \\<le> real_of_rat ((l' + r') / 2)", "unfolding root"], ["proof (prove)\nusing this:\n  root n (real_of_1 x) \\<le> real_of_rat ((l' + r') / 2)\n\ngoal (1 subgoal):\n 1. root n (real_of_1 x) \\<le> real_of_rat ((l' + r') / 2)", "by simp"], ["proof (state)\nthis:\n  root n (real_of_1 x) \\<le> real_of_rat ((l' + r') / 2)\n\ngoal (1 subgoal):\n 1. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "with lr'x lr''"], ["proof (chain)\npicking this:\n  in_interval (l', r') (root n (real_of_1 x))\n  real_of_rat l' \\<le> real_of_rat r'\n  root n (real_of_1 x) \\<le> real_of_rat ((l' + r') / 2)", "have ineq': \"?x * 2 \\<le> real_of_rat l' + real_of_rat r'\""], ["proof (prove)\nusing this:\n  in_interval (l', r') (root n (real_of_1 x))\n  real_of_rat l' \\<le> real_of_rat r'\n  root n (real_of_1 x) \\<le> real_of_rat ((l' + r') / 2)\n\ngoal (1 subgoal):\n 1. root n (real_of_1 x) * 2 \\<le> real_of_rat l' + real_of_rat r'", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  root n (real_of_1 x) * 2 \\<le> real_of_rat l' + real_of_rat r'\n\ngoal (1 subgoal):\n 1. cmpx (((l' + r') / 2) ^ n) = Gt \\<Longrightarrow>\n    in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (root n (real_of_1 x)) \\<and>\n    sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n      ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n    snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n    fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    \\<le> (ir - il) / 2 ^ Suc i", "unfolding id''"], ["proof (prove)\ngoal (1 subgoal):\n 1. in_interval (l', (l' + r') / 2) (root n (real_of_1 x)) \\<and>\n    sub_interval (l', (l' + r') / 2) (il, ir) \\<and>\n    (Suc i \\<noteq> 0 \\<longrightarrow>\n     sub_interval (l', (l' + r') / 2) (l', r')) \\<and>\n    snd (l', (l' + r') / 2) - fst (l', (l' + r') / 2)\n    \\<le> (ir - il) / 2 ^ Suc i", "by (auto simp: Let_def hom_distribs, insert size' ineq' lr' ill' lr'x ir_il, auto)"], ["proof (state)\nthis:\n  in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n   (root n (real_of_1 x)) \\<and>\n  sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n   (il, ir) \\<and>\n  (Suc i \\<noteq> 0 \\<longrightarrow>\n   sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n  snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n  fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n  \\<le> (ir - il) / 2 ^ Suc i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n   (root n (real_of_1 x)) \\<and>\n  sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n   (il, ir) \\<and>\n  (Suc i \\<noteq> 0 \\<longrightarrow>\n   sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n  snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n  fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n  \\<le> (ir - il) / 2 ^ Suc i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n   (root n (real_of_1 x)) \\<and>\n  sub_interval ((local.tighten_bound_root ^^ i) (il, ir)) (il, ir) \\<and>\n  (i \\<noteq> 0 \\<longrightarrow>\n   sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n    ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n  snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n  fst ((local.tighten_bound_root ^^ i) (il, ir))\n  \\<le> (ir - il) / 2 ^ i\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "}"], ["proof (state)\nthis:\n  in_interval ((local.tighten_bound_root ^^ ?i2) (il, ir))\n   (root n (real_of_1 x)) \\<and>\n  sub_interval ((local.tighten_bound_root ^^ ?i2) (il, ir)) (il, ir) \\<and>\n  (?i2 \\<noteq> 0 \\<longrightarrow>\n   sub_interval ((local.tighten_bound_root ^^ ?i2) (il, ir))\n    ((local.tighten_bound_root ^^ (?i2 - 1)) (il, ir))) \\<and>\n  snd ((local.tighten_bound_root ^^ ?i2) (il, ir)) -\n  fst ((local.tighten_bound_root ^^ ?i2) (il, ir))\n  \\<le> (ir - il) / 2 ^ ?i2\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "note main = this"], ["proof (state)\nthis:\n  in_interval ((local.tighten_bound_root ^^ ?i2) (il, ir))\n   (root n (real_of_1 x)) \\<and>\n  sub_interval ((local.tighten_bound_root ^^ ?i2) (il, ir)) (il, ir) \\<and>\n  (?i2 \\<noteq> 0 \\<longrightarrow>\n   sub_interval ((local.tighten_bound_root ^^ ?i2) (il, ir))\n    ((local.tighten_bound_root ^^ (?i2 - 1)) (il, ir))) \\<and>\n  snd ((local.tighten_bound_root ^^ ?i2) (il, ir)) -\n  fst ((local.tighten_bound_root ^^ ?i2) (il, ir))\n  \\<le> (ir - il) / 2 ^ ?i2\n\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>na.\n       in_interval ((local.tighten_bound_root ^^ na) (il, ir))\n        (root n (real_of_1 x))\n 2. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 3. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "from main[of i]"], ["proof (chain)\npicking this:\n  in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n   (root n (real_of_1 x)) \\<and>\n  sub_interval ((local.tighten_bound_root ^^ i) (il, ir)) (il, ir) \\<and>\n  (i \\<noteq> 0 \\<longrightarrow>\n   sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n    ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n  snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n  fst ((local.tighten_bound_root ^^ i) (il, ir))\n  \\<le> (ir - il) / 2 ^ i", "show \"in_interval (?f i) ?x\""], ["proof (prove)\nusing this:\n  in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n   (root n (real_of_1 x)) \\<and>\n  sub_interval ((local.tighten_bound_root ^^ i) (il, ir)) (il, ir) \\<and>\n  (i \\<noteq> 0 \\<longrightarrow>\n   sub_interval ((local.tighten_bound_root ^^ i) (il, ir))\n    ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n  snd ((local.tighten_bound_root ^^ i) (il, ir)) -\n  fst ((local.tighten_bound_root ^^ i) (il, ir))\n  \\<le> (ir - il) / 2 ^ i\n\ngoal (1 subgoal):\n 1. in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n     (root n (real_of_1 x))", "by auto"], ["proof (state)\nthis:\n  in_interval ((local.tighten_bound_root ^^ i) (il, ir))\n   (root n (real_of_1 x))\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       sub_interval ((local.tighten_bound_root ^^ Suc n) (il, ir))\n        ((local.tighten_bound_root ^^ n) (il, ir))\n 2. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "from main[of \"Suc i\"]"], ["proof (chain)\npicking this:\n  in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n   (root n (real_of_1 x)) \\<and>\n  sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n   (il, ir) \\<and>\n  (Suc i \\<noteq> 0 \\<longrightarrow>\n   sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n  snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n  fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n  \\<le> (ir - il) / 2 ^ Suc i", "show \"sub_interval (?f (Suc i)) (?f i)\""], ["proof (prove)\nusing this:\n  in_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n   (root n (real_of_1 x)) \\<and>\n  sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n   (il, ir) \\<and>\n  (Suc i \\<noteq> 0 \\<longrightarrow>\n   sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n    ((local.tighten_bound_root ^^ (Suc i - 1)) (il, ir))) \\<and>\n  snd ((local.tighten_bound_root ^^ Suc i) (il, ir)) -\n  fst ((local.tighten_bound_root ^^ Suc i) (il, ir))\n  \\<le> (ir - il) / 2 ^ Suc i\n\ngoal (1 subgoal):\n 1. sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n     ((local.tighten_bound_root ^^ i) (il, ir))", "by auto"], ["proof (state)\nthis:\n  sub_interval ((local.tighten_bound_root ^^ Suc i) (il, ir))\n   ((local.tighten_bound_root ^^ i) (il, ir))\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "fix eps :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "assume eps: \"0 < eps\""], ["proof (state)\nthis:\n  0 < eps\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "define c where \"c = eps / (max (real_of_rat (ir - il)) 1)\""], ["proof (state)\nthis:\n  c = eps / max (real_of_rat (ir - il)) 1\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "have c0: \"c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c", "using eps"], ["proof (prove)\nusing this:\n  0 < eps\n\ngoal (1 subgoal):\n 1. 0 < c", "unfolding c_def"], ["proof (prove)\nusing this:\n  0 < eps\n\ngoal (1 subgoal):\n 1. 0 < eps / max (real_of_rat (ir - il)) 1", "by auto"], ["proof (state)\nthis:\n  0 < c\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "from exp_tends_to_zero[OF _ _ this, of \"1/2\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < 1 / 2; 1 / 2 < 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. (1 / 2) ^ x \\<le> c", "obtain i where c: \"(1/2)^i \\<le> c\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 1 / 2; 1 / 2 < 1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. (1 / 2) ^ x \\<le> c\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        (1 / 2) ^ i \\<le> c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (1 / 2) ^ i \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "obtain l' r' where fi: \"?f i = (l',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l' r'.\n        (local.tighten_bound_root ^^ i) (il, ir) =\n        (l', r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (local.tighten_bound_root ^^ i) (il, ir) = (l', r')\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "from main[of i, unfolded fi]"], ["proof (chain)\npicking this:\n  in_interval (l', r') (root n (real_of_1 x)) \\<and>\n  sub_interval (l', r') (il, ir) \\<and>\n  (i \\<noteq> 0 \\<longrightarrow>\n   sub_interval (l', r')\n    ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n  snd (l', r') - fst (l', r') \\<le> (ir - il) / 2 ^ i", "have le: \"r' - l' \\<le> (ir - il) / 2 ^ i\""], ["proof (prove)\nusing this:\n  in_interval (l', r') (root n (real_of_1 x)) \\<and>\n  sub_interval (l', r') (il, ir) \\<and>\n  (i \\<noteq> 0 \\<longrightarrow>\n   sub_interval (l', r')\n    ((local.tighten_bound_root ^^ (i - 1)) (il, ir))) \\<and>\n  snd (l', r') - fst (l', r') \\<le> (ir - il) / 2 ^ i\n\ngoal (1 subgoal):\n 1. r' - l' \\<le> (ir - il) / 2 ^ i", "by auto"], ["proof (state)\nthis:\n  r' - l' \\<le> (ir - il) / 2 ^ i\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "have iril: \"real_of_rat (ir - il) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_rat (ir - il)", "using ir_il"], ["proof (prove)\nusing this:\n  il \\<le> ir\n\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_rat (ir - il)", "by (auto simp: of_rat_less_eq)"], ["proof (state)\nthis:\n  0 \\<le> real_of_rat (ir - il)\n\ngoal (1 subgoal):\n 1. \\<And>eps.\n       0 < eps \\<Longrightarrow>\n       \\<exists>n l r.\n          (local.tighten_bound_root ^^ n) (il, ir) = (l, r) \\<and>\n          real_of_rat r - real_of_rat l \\<le> eps", "show \"\\<exists>n la ra. ?f n = (la, ra) \\<and> real_of_rat ra - real_of_rat la \\<le> eps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n la ra.\n       (local.tighten_bound_root ^^ n) (il, ir) = (la, ra) \\<and>\n       real_of_rat ra - real_of_rat la \\<le> eps", "proof (intro conjI exI, rule fi)"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' \\<le> eps", "have \"real_of_rat r' - of_rat l' = real_of_rat (r' - l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' = real_of_rat (r' - l')", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  real_of_rat r' - real_of_rat l' = real_of_rat (r' - l')\n\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' \\<le> eps", "also"], ["proof (state)\nthis:\n  real_of_rat r' - real_of_rat l' = real_of_rat (r' - l')\n\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' \\<le> eps", "have \"\\<dots> \\<le> real_of_rat ((ir - il) / 2 ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (r' - l') \\<le> real_of_rat ((ir - il) / 2 ^ i)", "using le"], ["proof (prove)\nusing this:\n  r' - l' \\<le> (ir - il) / 2 ^ i\n\ngoal (1 subgoal):\n 1. real_of_rat (r' - l') \\<le> real_of_rat ((ir - il) / 2 ^ i)", "unfolding of_rat_less_eq"], ["proof (prove)\nusing this:\n  r' - l' \\<le> (ir - il) / 2 ^ i\n\ngoal (1 subgoal):\n 1. r' - l' \\<le> (ir - il) / 2 ^ i", "."], ["proof (state)\nthis:\n  real_of_rat (r' - l') \\<le> real_of_rat ((ir - il) / 2 ^ i)\n\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' \\<le> eps", "also"], ["proof (state)\nthis:\n  real_of_rat (r' - l') \\<le> real_of_rat ((ir - il) / 2 ^ i)\n\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' \\<le> eps", "have \"\\<dots> = (real_of_rat (ir - il)) * ((1/2) ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat ((ir - il) / 2 ^ i) = real_of_rat (ir - il) * (1 / 2) ^ i", "by (simp add: field_simps hom_distribs)"], ["proof (state)\nthis:\n  real_of_rat ((ir - il) / 2 ^ i) = real_of_rat (ir - il) * (1 / 2) ^ i\n\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' \\<le> eps", "also"], ["proof (state)\nthis:\n  real_of_rat ((ir - il) / 2 ^ i) = real_of_rat (ir - il) * (1 / 2) ^ i\n\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' \\<le> eps", "have \"\\<dots> \\<le> (real_of_rat (ir - il)) * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (ir - il) * (1 / 2) ^ i \\<le> real_of_rat (ir - il) * c", "by (rule mult_left_mono[OF c iril])"], ["proof (state)\nthis:\n  real_of_rat (ir - il) * (1 / 2) ^ i \\<le> real_of_rat (ir - il) * c\n\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' \\<le> eps", "also"], ["proof (state)\nthis:\n  real_of_rat (ir - il) * (1 / 2) ^ i \\<le> real_of_rat (ir - il) * c\n\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' \\<le> eps", "have \"\\<dots> \\<le> eps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (ir - il) * c \\<le> eps", "proof (cases \"real_of_rat (ir - il) \\<le> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. real_of_rat (ir - il) \\<le> 1 \\<Longrightarrow>\n    real_of_rat (ir - il) * c \\<le> eps\n 2. \\<not> real_of_rat (ir - il) \\<le> 1 \\<Longrightarrow>\n    real_of_rat (ir - il) * c \\<le> eps", "case True"], ["proof (state)\nthis:\n  real_of_rat (ir - il) \\<le> 1\n\ngoal (2 subgoals):\n 1. real_of_rat (ir - il) \\<le> 1 \\<Longrightarrow>\n    real_of_rat (ir - il) * c \\<le> eps\n 2. \\<not> real_of_rat (ir - il) \\<le> 1 \\<Longrightarrow>\n    real_of_rat (ir - il) * c \\<le> eps", "hence \"c = eps\""], ["proof (prove)\nusing this:\n  real_of_rat (ir - il) \\<le> 1\n\ngoal (1 subgoal):\n 1. c = eps", "unfolding c_def"], ["proof (prove)\nusing this:\n  real_of_rat (ir - il) \\<le> 1\n\ngoal (1 subgoal):\n 1. eps / max (real_of_rat (ir - il)) 1 = eps", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  c = eps\n\ngoal (2 subgoals):\n 1. real_of_rat (ir - il) \\<le> 1 \\<Longrightarrow>\n    real_of_rat (ir - il) * c \\<le> eps\n 2. \\<not> real_of_rat (ir - il) \\<le> 1 \\<Longrightarrow>\n    real_of_rat (ir - il) * c \\<le> eps", "thus ?thesis"], ["proof (prove)\nusing this:\n  c = eps\n\ngoal (1 subgoal):\n 1. real_of_rat (ir - il) * c \\<le> eps", "using eps True"], ["proof (prove)\nusing this:\n  c = eps\n  0 < eps\n  real_of_rat (ir - il) \\<le> 1\n\ngoal (1 subgoal):\n 1. real_of_rat (ir - il) * c \\<le> eps", "by auto"], ["proof (state)\nthis:\n  real_of_rat (ir - il) * c \\<le> eps\n\ngoal (1 subgoal):\n 1. \\<not> real_of_rat (ir - il) \\<le> 1 \\<Longrightarrow>\n    real_of_rat (ir - il) * c \\<le> eps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> real_of_rat (ir - il) \\<le> 1 \\<Longrightarrow>\n    real_of_rat (ir - il) * c \\<le> eps", "case False"], ["proof (state)\nthis:\n  \\<not> real_of_rat (ir - il) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> real_of_rat (ir - il) \\<le> 1 \\<Longrightarrow>\n    real_of_rat (ir - il) * c \\<le> eps", "hence \"max (real_of_rat (ir - il)) 1 = real_of_rat (ir - il)\" \"real_of_rat (ir - il) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> real_of_rat (ir - il) \\<le> 1\n\ngoal (1 subgoal):\n 1. max (real_of_rat (ir - il)) 1 = real_of_rat (ir - il) &&&\n    real_of_rat (ir - il) \\<noteq> 0", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  max (real_of_rat (ir - il)) 1 = real_of_rat (ir - il)\n  real_of_rat (ir - il) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> real_of_rat (ir - il) \\<le> 1 \\<Longrightarrow>\n    real_of_rat (ir - il) * c \\<le> eps", "hence \"(real_of_rat (ir - il)) * c = eps\""], ["proof (prove)\nusing this:\n  max (real_of_rat (ir - il)) 1 = real_of_rat (ir - il)\n  real_of_rat (ir - il) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_rat (ir - il) * c = eps", "unfolding c_def"], ["proof (prove)\nusing this:\n  max (real_of_rat (ir - il)) 1 = real_of_rat (ir - il)\n  real_of_rat (ir - il) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_rat (ir - il) * (eps / max (real_of_rat (ir - il)) 1) = eps", "by auto"], ["proof (state)\nthis:\n  real_of_rat (ir - il) * c = eps\n\ngoal (1 subgoal):\n 1. \\<not> real_of_rat (ir - il) \\<le> 1 \\<Longrightarrow>\n    real_of_rat (ir - il) * c \\<le> eps", "thus ?thesis"], ["proof (prove)\nusing this:\n  real_of_rat (ir - il) * c = eps\n\ngoal (1 subgoal):\n 1. real_of_rat (ir - il) * c \\<le> eps", "by simp"], ["proof (state)\nthis:\n  real_of_rat (ir - il) * c \\<le> eps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_rat (ir - il) * c \\<le> eps\n\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' \\<le> eps", "finally"], ["proof (chain)\npicking this:\n  real_of_rat r' - real_of_rat l' \\<le> eps", "show \"real_of_rat r' - of_rat l' \\<le> eps\""], ["proof (prove)\nusing this:\n  real_of_rat r' - real_of_rat l' \\<le> eps\n\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' \\<le> eps", "."], ["proof (state)\nthis:\n  real_of_rat r' - real_of_rat l' \\<le> eps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n la ra.\n     (local.tighten_bound_root ^^ n) (il, ir) = (la, ra) \\<and>\n     real_of_rat ra - real_of_rat la \\<le> eps\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "private"], ["", "fun root_pos_1 :: \"real_alg_1 \\<Rightarrow> real_alg_2\" where\n  \"root_pos_1 (p,l,r) = (\n      (select_correct_factor_int_poly \n        (tighten_bound_root (compare_1_rat (p,l,r)))\n        (\\<lambda> x. x)\n        (initial_lower_bound l, initial_upper_bound r)\n        (poly_nth_root n p)))\""], ["", "fun root_1 :: \"real_alg_1 \\<Rightarrow> real_alg_2\" where\n\"root_1 (p,l,r) = (\n  if n = 0 \\<or> r = 0 then Rational 0\n  else if r > 0 then root_pos_1 (p,l,r)\n  else uminus_2 (root_pos_1 (uminus_1 (p,l,r))))\""], ["", "context\n  assumes n: \"n \\<noteq> 0\"\nbegin"], ["", "lemma initial_upper_bound: assumes x: \"x > 0\" and xr: \"x \\<le> of_rat r\"\n  shows \"sgn (initial_upper_bound r) = 1\" \"root n x \\<le> of_rat (initial_upper_bound r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (initial_upper_bound r) = 1 &&&\n    root n x \\<le> real_of_rat (initial_upper_bound r)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. sgn (initial_upper_bound r) = 1\n 2. root n x \\<le> real_of_rat (initial_upper_bound r)", "have n: \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "using n"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. sgn (initial_upper_bound r) = 1\n 2. root n x \\<le> real_of_rat (initial_upper_bound r)", "note d = initial_upper_bound_def"], ["proof (state)\nthis:\n  initial_upper_bound ?r = rat_of_int (root_rat_ceiling n ?r)\n\ngoal (2 subgoals):\n 1. sgn (initial_upper_bound r) = 1\n 2. root n x \\<le> real_of_rat (initial_upper_bound r)", "let ?r = \"initial_upper_bound r\""], ["proof (state)\ngoal (2 subgoals):\n 1. sgn (initial_upper_bound r) = 1\n 2. root n x \\<le> real_of_rat (initial_upper_bound r)", "from x xr"], ["proof (chain)\npicking this:\n  0 < x\n  x \\<le> real_of_rat r", "have r0: \"r > 0\""], ["proof (prove)\nusing this:\n  0 < x\n  x \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. 0 < r", "by (meson not_less of_rat_le_0_iff order_trans)"], ["proof (state)\nthis:\n  0 < r\n\ngoal (2 subgoals):\n 1. sgn (initial_upper_bound r) = 1\n 2. root n x \\<le> real_of_rat (initial_upper_bound r)", "hence \"of_rat r > (0 :: real)\""], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat r", "by auto"], ["proof (state)\nthis:\n  0 < real_of_rat r\n\ngoal (2 subgoals):\n 1. sgn (initial_upper_bound r) = 1\n 2. root n x \\<le> real_of_rat (initial_upper_bound r)", "hence \"root n (of_rat r) > 0\""], ["proof (prove)\nusing this:\n  0 < real_of_rat r\n\ngoal (1 subgoal):\n 1. 0 < root n (real_of_rat r)", "using n"], ["proof (prove)\nusing this:\n  0 < real_of_rat r\n  0 < n\n\ngoal (1 subgoal):\n 1. 0 < root n (real_of_rat r)", "by simp"], ["proof (state)\nthis:\n  0 < root n (real_of_rat r)\n\ngoal (2 subgoals):\n 1. sgn (initial_upper_bound r) = 1\n 2. root n x \\<le> real_of_rat (initial_upper_bound r)", "hence \"1 \\<le> ceiling (root n (of_rat r))\""], ["proof (prove)\nusing this:\n  0 < root n (real_of_rat r)\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<lceil>root n (real_of_rat r)\\<rceil>", "by auto"], ["proof (state)\nthis:\n  1 \\<le> \\<lceil>root n (real_of_rat r)\\<rceil>\n\ngoal (2 subgoals):\n 1. sgn (initial_upper_bound r) = 1\n 2. root n x \\<le> real_of_rat (initial_upper_bound r)", "hence \"(1 :: rat) \\<le> of_int (ceiling (root n (of_rat r)))\""], ["proof (prove)\nusing this:\n  1 \\<le> \\<lceil>root n (real_of_rat r)\\<rceil>\n\ngoal (1 subgoal):\n 1. 1 \\<le> rat_of_int \\<lceil>root n (real_of_rat r)\\<rceil>", "by linarith"], ["proof (state)\nthis:\n  1 \\<le> rat_of_int \\<lceil>root n (real_of_rat r)\\<rceil>\n\ngoal (2 subgoals):\n 1. sgn (initial_upper_bound r) = 1\n 2. root n x \\<le> real_of_rat (initial_upper_bound r)", "also"], ["proof (state)\nthis:\n  1 \\<le> rat_of_int \\<lceil>root n (real_of_rat r)\\<rceil>\n\ngoal (2 subgoals):\n 1. sgn (initial_upper_bound r) = 1\n 2. root n x \\<le> real_of_rat (initial_upper_bound r)", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int \\<lceil>root n (real_of_rat r)\\<rceil> =\n    initial_upper_bound r", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int \\<lceil>root n (real_of_rat r)\\<rceil> =\n    rat_of_int (root_rat_ceiling n r)", "by simp"], ["proof (state)\nthis:\n  rat_of_int \\<lceil>root n (real_of_rat r)\\<rceil> = initial_upper_bound r\n\ngoal (2 subgoals):\n 1. sgn (initial_upper_bound r) = 1\n 2. root n x \\<le> real_of_rat (initial_upper_bound r)", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> initial_upper_bound r", "show \"sgn ?r = 1\""], ["proof (prove)\nusing this:\n  1 \\<le> initial_upper_bound r\n\ngoal (1 subgoal):\n 1. sgn (initial_upper_bound r) = 1", "unfolding sgn_rat_def"], ["proof (prove)\nusing this:\n  1 \\<le> initial_upper_bound r\n\ngoal (1 subgoal):\n 1. (if initial_upper_bound r = 0 then 0\n     else if 0 < initial_upper_bound r then 1 else - 1) =\n    1", "by auto"], ["proof (state)\nthis:\n  sgn (initial_upper_bound r) = 1\n\ngoal (1 subgoal):\n 1. root n x \\<le> real_of_rat (initial_upper_bound r)", "have \"root n x \\<le> root n (of_rat r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root n x \\<le> root n (real_of_rat r)", "unfolding real_root_le_iff[OF n]"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> real_of_rat r", "by (rule xr)"], ["proof (state)\nthis:\n  root n x \\<le> root n (real_of_rat r)\n\ngoal (1 subgoal):\n 1. root n x \\<le> real_of_rat (initial_upper_bound r)", "also"], ["proof (state)\nthis:\n  root n x \\<le> root n (real_of_rat r)\n\ngoal (1 subgoal):\n 1. root n x \\<le> real_of_rat (initial_upper_bound r)", "have \"\\<dots> \\<le> of_rat ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root n (real_of_rat r) \\<le> real_of_rat (initial_upper_bound r)", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. root n (real_of_rat r)\n    \\<le> real_of_rat (rat_of_int (root_rat_ceiling n r))", "by simp"], ["proof (state)\nthis:\n  root n (real_of_rat r) \\<le> real_of_rat (initial_upper_bound r)\n\ngoal (1 subgoal):\n 1. root n x \\<le> real_of_rat (initial_upper_bound r)", "finally"], ["proof (chain)\npicking this:\n  root n x \\<le> real_of_rat (initial_upper_bound r)", "show \"root n x \\<le> of_rat ?r\""], ["proof (prove)\nusing this:\n  root n x \\<le> real_of_rat (initial_upper_bound r)\n\ngoal (1 subgoal):\n 1. root n x \\<le> real_of_rat (initial_upper_bound r)", "."], ["proof (state)\nthis:\n  root n x \\<le> real_of_rat (initial_upper_bound r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma initial_lower_bound: assumes l: \"l > 0\" and lx: \"of_rat l \\<le> x\"\n  shows \"sgn (initial_lower_bound l) = 1\" \"of_rat (initial_lower_bound l) \\<le> root n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (initial_lower_bound l) = 1 &&&\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. sgn (initial_lower_bound l) = 1\n 2. real_of_rat (initial_lower_bound l) \\<le> root n x", "have n: \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "using n"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. sgn (initial_lower_bound l) = 1\n 2. real_of_rat (initial_lower_bound l) \\<le> root n x", "note d = initial_lower_bound_def"], ["proof (state)\nthis:\n  initial_lower_bound ?l =\n  (if ?l \\<le> 1 then ?l else rat_of_int (root_rat_floor n ?l))\n\ngoal (2 subgoals):\n 1. sgn (initial_lower_bound l) = 1\n 2. real_of_rat (initial_lower_bound l) \\<le> root n x", "let ?l = \"initial_lower_bound l\""], ["proof (state)\ngoal (2 subgoals):\n 1. sgn (initial_lower_bound l) = 1\n 2. real_of_rat (initial_lower_bound l) \\<le> root n x", "from l lx"], ["proof (chain)\npicking this:\n  0 < l\n  real_of_rat l \\<le> x", "have x0: \"x > 0\""], ["proof (prove)\nusing this:\n  0 < l\n  real_of_rat l \\<le> x\n\ngoal (1 subgoal):\n 1. 0 < x", "by (meson not_less of_rat_le_0_iff order_trans)"], ["proof (state)\nthis:\n  0 < x\n\ngoal (2 subgoals):\n 1. sgn (initial_lower_bound l) = 1\n 2. real_of_rat (initial_lower_bound l) \\<le> root n x", "have \"sgn ?l = 1 \\<and> of_rat ?l \\<le> root n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "proof (cases \"l \\<le> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x\n 2. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "case True"], ["proof (state)\nthis:\n  l \\<le> 1\n\ngoal (2 subgoals):\n 1. l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x\n 2. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "hence ll: \"?l = l\" and l0: \"of_rat l \\<ge> (0 :: real)\" and l1: \"of_rat l \\<le> (1 :: real)\""], ["proof (prove)\nusing this:\n  l \\<le> 1\n\ngoal (1 subgoal):\n 1. initial_lower_bound l = l &&&\n    0 \\<le> real_of_rat l &&& real_of_rat l \\<le> 1", "using l"], ["proof (prove)\nusing this:\n  l \\<le> 1\n  0 < l\n\ngoal (1 subgoal):\n 1. initial_lower_bound l = l &&&\n    0 \\<le> real_of_rat l &&& real_of_rat l \\<le> 1", "unfolding True d"], ["proof (prove)\nusing this:\n  l \\<le> 1\n  0 < l\n\ngoal (1 subgoal):\n 1. (if l \\<le> 1 then l else rat_of_int (root_rat_floor n l)) = l &&&\n    0 \\<le> real_of_rat l &&& real_of_rat l \\<le> 1", "by auto"], ["proof (state)\nthis:\n  initial_lower_bound l = l\n  0 \\<le> real_of_rat l\n  real_of_rat l \\<le> 1\n\ngoal (2 subgoals):\n 1. l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x\n 2. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "have sgn: \"sgn ?l = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (initial_lower_bound l) = 1", "using l"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. sgn (initial_lower_bound l) = 1", "unfolding ll"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. sgn l = 1", "by auto"], ["proof (state)\nthis:\n  sgn (initial_lower_bound l) = 1\n\ngoal (2 subgoals):\n 1. l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x\n 2. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "have \"of_rat ?l = of_rat l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat (initial_lower_bound l) = of_rat l", "unfolding ll"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat l = of_rat l", "by simp"], ["proof (state)\nthis:\n  of_rat (initial_lower_bound l) = of_rat l\n\ngoal (2 subgoals):\n 1. l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x\n 2. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "also"], ["proof (state)\nthis:\n  of_rat (initial_lower_bound l) = of_rat l\n\ngoal (2 subgoals):\n 1. l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x\n 2. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "have \"of_rat l \\<le> root n (of_rat l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> root n (real_of_rat l)", "using real_root_increasing[OF _ _ l0 l1, of 1 n] n"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 1; 1 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> root 1 (real_of_rat l) \\<le> root n (real_of_rat l)\n  0 < n\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> root n (real_of_rat l)", "by (cases \"n = 1\", auto)"], ["proof (state)\nthis:\n  real_of_rat l \\<le> root n (real_of_rat l)\n\ngoal (2 subgoals):\n 1. l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x\n 2. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "also"], ["proof (state)\nthis:\n  real_of_rat l \\<le> root n (real_of_rat l)\n\ngoal (2 subgoals):\n 1. l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x\n 2. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "have \"\\<dots> \\<le> root n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root n (real_of_rat l) \\<le> root n x", "using lx"], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x\n\ngoal (1 subgoal):\n 1. root n (real_of_rat l) \\<le> root n x", "unfolding real_root_le_iff[OF n]"], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> x", "."], ["proof (state)\nthis:\n  root n (real_of_rat l) \\<le> root n x\n\ngoal (2 subgoals):\n 1. l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x\n 2. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "finally"], ["proof (chain)\npicking this:\n  real_of_rat (initial_lower_bound l) \\<le> root n x", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_rat (initial_lower_bound l) \\<le> root n x\n\ngoal (1 subgoal):\n 1. sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "using sgn"], ["proof (prove)\nusing this:\n  real_of_rat (initial_lower_bound l) \\<le> root n x\n  sgn (initial_lower_bound l) = 1\n\ngoal (1 subgoal):\n 1. sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "by auto"], ["proof (state)\nthis:\n  sgn (initial_lower_bound l) = 1 \\<and>\n  real_of_rat (initial_lower_bound l) \\<le> root n x\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "case False"], ["proof (state)\nthis:\n  \\<not> l \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "hence l: \"(1 :: real) \\<le> of_rat l\" and ll: \"?l = of_int (floor (root n (of_rat l)))\""], ["proof (prove)\nusing this:\n  \\<not> l \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> real_of_rat l &&&\n    initial_lower_bound l =\n    rat_of_int \\<lfloor>root n (real_of_rat l)\\<rfloor>", "unfolding d"], ["proof (prove)\nusing this:\n  \\<not> l \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> real_of_rat l &&&\n    (if l \\<le> 1 then l else rat_of_int (root_rat_floor n l)) =\n    rat_of_int \\<lfloor>root n (real_of_rat l)\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  1 \\<le> real_of_rat l\n  initial_lower_bound l =\n  rat_of_int \\<lfloor>root n (real_of_rat l)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "hence \"root n 1 \\<le> root n (of_rat l)\""], ["proof (prove)\nusing this:\n  1 \\<le> real_of_rat l\n  initial_lower_bound l =\n  rat_of_int \\<lfloor>root n (real_of_rat l)\\<rfloor>\n\ngoal (1 subgoal):\n 1. root n 1 \\<le> root n (real_of_rat l)", "unfolding real_root_le_iff[OF n]"], ["proof (prove)\nusing this:\n  1 \\<le> real_of_rat l\n  initial_lower_bound l =\n  rat_of_int \\<lfloor>root n (real_of_rat l)\\<rfloor>\n\ngoal (1 subgoal):\n 1. 1 \\<le> real_of_rat l", "by auto"], ["proof (state)\nthis:\n  root n 1 \\<le> root n (real_of_rat l)\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "hence \"1 \\<le> root n (of_rat l)\""], ["proof (prove)\nusing this:\n  root n 1 \\<le> root n (real_of_rat l)\n\ngoal (1 subgoal):\n 1. 1 \\<le> root n (real_of_rat l)", "using n"], ["proof (prove)\nusing this:\n  root n 1 \\<le> root n (real_of_rat l)\n  0 < n\n\ngoal (1 subgoal):\n 1. 1 \\<le> root n (real_of_rat l)", "by auto"], ["proof (state)\nthis:\n  1 \\<le> root n (real_of_rat l)\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "from floor_mono[OF this]"], ["proof (chain)\npicking this:\n  \\<lfloor>1\\<rfloor> \\<le> \\<lfloor>root n (real_of_rat l)\\<rfloor>", "have \"1 \\<le> ?l\""], ["proof (prove)\nusing this:\n  \\<lfloor>1\\<rfloor> \\<le> \\<lfloor>root n (real_of_rat l)\\<rfloor>\n\ngoal (1 subgoal):\n 1. 1 \\<le> initial_lower_bound l", "using one_le_floor"], ["proof (prove)\nusing this:\n  \\<lfloor>1\\<rfloor> \\<le> \\<lfloor>root n (real_of_rat l)\\<rfloor>\n  (1 \\<le> \\<lfloor>?x\\<rfloor>) = ((1::?'a) \\<le> ?x)\n\ngoal (1 subgoal):\n 1. 1 \\<le> initial_lower_bound l", "unfolding ll"], ["proof (prove)\nusing this:\n  \\<lfloor>1\\<rfloor> \\<le> \\<lfloor>root n (real_of_rat l)\\<rfloor>\n  (1 \\<le> \\<lfloor>?x\\<rfloor>) = ((1::?'a) \\<le> ?x)\n\ngoal (1 subgoal):\n 1. 1 \\<le> rat_of_int \\<lfloor>root n (real_of_rat l)\\<rfloor>", "by fastforce"], ["proof (state)\nthis:\n  1 \\<le> initial_lower_bound l\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "hence sgn: \"sgn ?l = 1\""], ["proof (prove)\nusing this:\n  1 \\<le> initial_lower_bound l\n\ngoal (1 subgoal):\n 1. sgn (initial_lower_bound l) = 1", "by simp"], ["proof (state)\nthis:\n  sgn (initial_lower_bound l) = 1\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "have \"of_rat ?l \\<le> root n (of_rat l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (initial_lower_bound l) \\<le> root n (real_of_rat l)", "unfolding ll"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (rat_of_int \\<lfloor>root n (real_of_rat l)\\<rfloor>)\n    \\<le> root n (real_of_rat l)", "by simp"], ["proof (state)\nthis:\n  real_of_rat (initial_lower_bound l) \\<le> root n (real_of_rat l)\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "also"], ["proof (state)\nthis:\n  real_of_rat (initial_lower_bound l) \\<le> root n (real_of_rat l)\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "have \"\\<dots> \\<le> root n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root n (real_of_rat l) \\<le> root n x", "using lx"], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x\n\ngoal (1 subgoal):\n 1. root n (real_of_rat l) \\<le> root n x", "unfolding real_root_le_iff[OF n]"], ["proof (prove)\nusing this:\n  real_of_rat l \\<le> x\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> x", "."], ["proof (state)\nthis:\n  root n (real_of_rat l) \\<le> root n x\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "finally"], ["proof (chain)\npicking this:\n  real_of_rat (initial_lower_bound l) \\<le> root n x", "have \"of_rat ?l \\<le> root n x\""], ["proof (prove)\nusing this:\n  real_of_rat (initial_lower_bound l) \\<le> root n x\n\ngoal (1 subgoal):\n 1. real_of_rat (initial_lower_bound l) \\<le> root n x", "."], ["proof (state)\nthis:\n  real_of_rat (initial_lower_bound l) \\<le> root n x\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le> 1 \\<Longrightarrow>\n    sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "with sgn"], ["proof (chain)\npicking this:\n  sgn (initial_lower_bound l) = 1\n  real_of_rat (initial_lower_bound l) \\<le> root n x", "show ?thesis"], ["proof (prove)\nusing this:\n  sgn (initial_lower_bound l) = 1\n  real_of_rat (initial_lower_bound l) \\<le> root n x\n\ngoal (1 subgoal):\n 1. sgn (initial_lower_bound l) = 1 \\<and>\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "by auto"], ["proof (state)\nthis:\n  sgn (initial_lower_bound l) = 1 \\<and>\n  real_of_rat (initial_lower_bound l) \\<le> root n x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sgn (initial_lower_bound l) = 1 \\<and>\n  real_of_rat (initial_lower_bound l) \\<le> root n x\n\ngoal (2 subgoals):\n 1. sgn (initial_lower_bound l) = 1\n 2. real_of_rat (initial_lower_bound l) \\<le> root n x", "thus \"sgn ?l = 1\" \"of_rat ?l \\<le> root n x\""], ["proof (prove)\nusing this:\n  sgn (initial_lower_bound l) = 1 \\<and>\n  real_of_rat (initial_lower_bound l) \\<le> root n x\n\ngoal (1 subgoal):\n 1. sgn (initial_lower_bound l) = 1 &&&\n    real_of_rat (initial_lower_bound l) \\<le> root n x", "by auto"], ["proof (state)\nthis:\n  sgn (initial_lower_bound l) = 1\n  real_of_rat (initial_lower_bound l) \\<le> root n x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_pos_1:\n  assumes x: \"invariant_1 x\" and pos: \"rai_ub x > 0\"\n  defines y: \"y \\<equiv> root_pos_1 x\"\n  shows \"invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "proof (cases x)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "case (fields p l r)"], ["proof (state)\nthis:\n  x = (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "let ?l = \"initial_lower_bound l\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "let ?r = \"initial_upper_bound r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "from x fields"], ["proof (chain)\npicking this:\n  invariant_1 x\n  x = (p, l, r)", "have rai: \"invariant_1 (p,l,r)\""], ["proof (prove)\nusing this:\n  invariant_1 x\n  x = (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l, r)", "by auto"], ["proof (state)\nthis:\n  invariant_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "note * = invariant_1D[OF this]"], ["proof (state)\nthis:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "let ?x = \"the_unique_root (p,l,r)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "from pos[unfolded fields] *"], ["proof (chain)\npicking this:\n  0 < rai_ub (p, l, r)\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))", "have sgnl: \"sgn l = 1\""], ["proof (prove)\nusing this:\n  0 < rai_ub (p, l, r)\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. sgn l = 1", "by auto"], ["proof (state)\nthis:\n  sgn l = 1\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "from sgnl"], ["proof (chain)\npicking this:\n  sgn l = 1", "have l0: \"l > 0\""], ["proof (prove)\nusing this:\n  sgn l = 1\n\ngoal (1 subgoal):\n 1. 0 < l", "by (unfold sgn_1_pos)"], ["proof (state)\nthis:\n  0 < l\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "hence ll0: \"real_of_rat l > 0\""], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat l", "by auto"], ["proof (state)\nthis:\n  0 < real_of_rat l\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "from *"], ["proof (chain)\npicking this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))", "have lx: \"of_rat l \\<le> ?x\""], ["proof (prove)\nusing this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. real_of_rat l \\<le> real_of_1 (p, l, r)", "by auto"], ["proof (state)\nthis:\n  real_of_rat l \\<le> real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "with ll0"], ["proof (chain)\npicking this:\n  0 < real_of_rat l\n  real_of_rat l \\<le> real_of_1 (p, l, r)", "have x0: \"?x > 0\""], ["proof (prove)\nusing this:\n  0 < real_of_rat l\n  real_of_rat l \\<le> real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. 0 < real_of_1 (p, l, r)", "by linarith"], ["proof (state)\nthis:\n  0 < real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "note il = initial_lower_bound[OF l0 lx]"], ["proof (state)\nthis:\n  sgn (initial_lower_bound l) = 1\n  real_of_rat (initial_lower_bound l) \\<le> root n (real_of_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "from *"], ["proof (chain)\npicking this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))", "have \"?x \\<le> of_rat r\""], ["proof (prove)\nusing this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) \\<le> real_of_rat r", "by auto"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) \\<le> real_of_rat r\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "note iu = initial_upper_bound[OF x0 this]"], ["proof (state)\nthis:\n  sgn (initial_upper_bound r) = 1\n  root n (real_of_1 (p, l, r)) \\<le> real_of_rat (initial_upper_bound r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "let ?p = \"poly_nth_root n p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "from x0"], ["proof (chain)\npicking this:\n  0 < real_of_1 (p, l, r)", "have id: \"root n ?x ^ n = ?x\""], ["proof (prove)\nusing this:\n  0 < real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. root n (real_of_1 (p, l, r)) ^ n = real_of_1 (p, l, r)", "using n real_root_pow_pos"], ["proof (prove)\nusing this:\n  0 < real_of_1 (p, l, r)\n  n \\<noteq> 0\n  \\<lbrakk>0 < ?n; 0 < ?x\\<rbrakk> \\<Longrightarrow> root ?n ?x ^ ?n = ?x\n\ngoal (1 subgoal):\n 1. root n (real_of_1 (p, l, r)) ^ n = real_of_1 (p, l, r)", "by blast"], ["proof (state)\nthis:\n  root n (real_of_1 (p, l, r)) ^ n = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "have rc: \"root_cond (?p, ?l, ?r) (root n ?x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_cond\n     (poly_nth_root n p, initial_lower_bound l, initial_upper_bound r)\n     (root n (real_of_1 (p, l, r)))", "using il iu *"], ["proof (prove)\nusing this:\n  sgn (initial_lower_bound l) = 1\n  real_of_rat (initial_lower_bound l) \\<le> root n (real_of_1 (p, l, r))\n  sgn (initial_upper_bound r) = 1\n  root n (real_of_1 (p, l, r)) \\<le> real_of_rat (initial_upper_bound r)\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. root_cond\n     (poly_nth_root n p, initial_lower_bound l, initial_upper_bound r)\n     (root n (real_of_1 (p, l, r)))", "by (intro root_condI, auto simp: ipoly_nth_root id)"], ["proof (state)\nthis:\n  root_cond\n   (poly_nth_root n p, initial_lower_bound l, initial_upper_bound r)\n   (root n (real_of_1 (p, l, r)))\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "hence root: \"ipoly ?p (root n (real_of_1 x)) = 0\""], ["proof (prove)\nusing this:\n  root_cond\n   (poly_nth_root n p, initial_lower_bound l, initial_upper_bound r)\n   (root n (real_of_1 (p, l, r)))\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly (poly_nth_root n p)) (root n (real_of_1 x)) = 0", "unfolding root_cond_def fields"], ["proof (prove)\nusing this:\n  case (poly_nth_root n p, initial_lower_bound l, initial_upper_bound r) of\n  (pa, la, ra) \\<Rightarrow>\n    real_of_rat la\n    \\<le> root n\n           (THE x.\n               case (p, l, r) of\n               (p, l, r) \\<Rightarrow>\n                 real_of_rat l \\<le> x \\<and>\n                 x \\<le> real_of_rat r \\<and>\n                 poly (real_of_int_poly p) x = 0) \\<and>\n    root n\n     (THE x.\n         case (p, l, r) of\n         (p, l, r) \\<Rightarrow>\n           real_of_rat l \\<le> x \\<and>\n           x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0)\n    \\<le> real_of_rat ra \\<and>\n    poly (real_of_int_poly pa)\n     (root n\n       (THE x.\n           case (p, l, r) of\n           (p, l, r) \\<Rightarrow>\n             real_of_rat l \\<le> x \\<and>\n             x \\<le> real_of_rat r \\<and>\n             poly (real_of_int_poly p) x = 0)) =\n    0\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly (poly_nth_root n p))\n     (root n\n       (THE x.\n           case (p, l, r) of\n           (p, l, r) \\<Rightarrow>\n             real_of_rat l \\<le> x \\<and>\n             x \\<le> real_of_rat r \\<and>\n             poly (real_of_int_poly p) x = 0)) =\n    0", "by auto"], ["proof (state)\nthis:\n  poly (real_of_int_poly (poly_nth_root n p)) (root n (real_of_1 x)) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "from *"], ["proof (chain)\npicking this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))", "have \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n  sgn (rai_lb (p, l, r)) = sgn (rai_ub (p, l, r))\n  sgn (real_of_1 (p, l, r)) = real_of_rat (sgn (rai_ub (p, l, r)))\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond (poly_real_alg_1 (p, l, r))\n  0 < degree (poly_real_alg_1 (p, l, r))\n  primitive (poly_real_alg_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "hence p': \"?p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_nth_root n p \\<noteq> 0", "using poly_nth_root_0[of n p] n"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  n \\<noteq> 0 \\<Longrightarrow> (poly_nth_root n p = 0) = (p = 0)\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_nth_root n p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly_nth_root n p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "have tbr: \"0 \\<le> real_of_1 x\"\n            \"real_of_rat (initial_lower_bound l) \\<le> root n (real_of_1 x)\"\n            \"root n (real_of_1 x) \\<le> real_of_rat (initial_upper_bound r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_1 x &&&\n    real_of_rat (initial_lower_bound l) \\<le> root n (real_of_1 x) &&&\n    root n (real_of_1 x) \\<le> real_of_rat (initial_upper_bound r)", "using x0 il(2) iu(2) fields"], ["proof (prove)\nusing this:\n  0 < real_of_1 (p, l, r)\n  real_of_rat (initial_lower_bound l) \\<le> root n (real_of_1 (p, l, r))\n  root n (real_of_1 (p, l, r)) \\<le> real_of_rat (initial_upper_bound r)\n  x = (p, l, r)\n\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_1 x &&&\n    real_of_rat (initial_lower_bound l) \\<le> root n (real_of_1 x) &&&\n    root n (real_of_1 x) \\<le> real_of_rat (initial_upper_bound r)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> real_of_1 x\n  real_of_rat (initial_lower_bound l) \\<le> root n (real_of_1 x)\n  root n (real_of_1 x) \\<le> real_of_rat (initial_upper_bound r)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       x = (a, b, c) \\<Longrightarrow>\n       invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "from select_correct_factor_int_poly[OF tighten_bound_root[OF il(1)[folded fields] tbr x refl n] refl root p']"], ["proof (chain)\npicking this:\n  invariant_2\n   (select_correct_factor_int_poly\n     (local.tighten_bound_root (compare_1_rat x)) (\\<lambda>a. a)\n     (initial_lower_bound l, initial_upper_bound r)\n     (poly_nth_root n p)) \\<and>\n  real_of_2\n   (select_correct_factor_int_poly\n     (local.tighten_bound_root (compare_1_rat x)) (\\<lambda>a. a)\n     (initial_lower_bound l, initial_upper_bound r) (poly_nth_root n p)) =\n  root n (real_of_1 x)", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant_2\n   (select_correct_factor_int_poly\n     (local.tighten_bound_root (compare_1_rat x)) (\\<lambda>a. a)\n     (initial_lower_bound l, initial_upper_bound r)\n     (poly_nth_root n p)) \\<and>\n  real_of_2\n   (select_correct_factor_int_poly\n     (local.tighten_bound_root (compare_1_rat x)) (\\<lambda>a. a)\n     (initial_lower_bound l, initial_upper_bound r) (poly_nth_root n p)) =\n  root n (real_of_1 x)\n\ngoal (1 subgoal):\n 1. invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "by (simp add: y fields)"], ["proof (state)\nthis:\n  invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma root_1: assumes x: \"invariant_1 x\"\n  defines y: \"y \\<equiv> root_1 x\"\n  shows \"invariant_2 y \\<and> (real_of_2 y = root n (real_of_1 x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "proof (cases \"n = 0 \\<or> rai_ub x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<or> rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. \\<not> (n = 0 \\<or> rai_ub x = 0) \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "case True"], ["proof (state)\nthis:\n  n = 0 \\<or> rai_ub x = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<or> rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. \\<not> (n = 0 \\<or> rai_ub x = 0) \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "with x"], ["proof (chain)\npicking this:\n  invariant_1 x\n  n = 0 \\<or> rai_ub x = 0", "have \"n = 0 \\<or> real_of_1 x = 0\""], ["proof (prove)\nusing this:\n  invariant_1 x\n  n = 0 \\<or> rai_ub x = 0\n\ngoal (1 subgoal):\n 1. n = 0 \\<or> real_of_1 x = 0", "by (cases x, auto)"], ["proof (state)\nthis:\n  n = 0 \\<or> real_of_1 x = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<or> rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. \\<not> (n = 0 \\<or> rai_ub x = 0) \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "then"], ["proof (chain)\npicking this:\n  n = 0 \\<or> real_of_1 x = 0", "have \"root n (real_of_1 x) = 0\""], ["proof (prove)\nusing this:\n  n = 0 \\<or> real_of_1 x = 0\n\ngoal (1 subgoal):\n 1. root n (real_of_1 x) = 0", "by auto"], ["proof (state)\nthis:\n  root n (real_of_1 x) = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<or> rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. \\<not> (n = 0 \\<or> rai_ub x = 0) \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "then"], ["proof (chain)\npicking this:\n  root n (real_of_1 x) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  root n (real_of_1 x) = 0\n\ngoal (1 subgoal):\n 1. invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "unfolding y root_1.simps"], ["proof (prove)\nusing this:\n  root n (real_of_1 x) = 0\n\ngoal (1 subgoal):\n 1. invariant_2 (local.root_1 x) \\<and>\n    real_of_2 (local.root_1 x) = root n (real_of_1 x)", "using x"], ["proof (prove)\nusing this:\n  root n (real_of_1 x) = 0\n  invariant_1 x\n\ngoal (1 subgoal):\n 1. invariant_2 (local.root_1 x) \\<and>\n    real_of_2 (local.root_1 x) = root n (real_of_1 x)", "by (cases x, auto)"], ["proof (state)\nthis:\n  invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> rai_ub x = 0) \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> rai_ub x = 0) \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "case False"], ["proof (state)\nthis:\n  \\<not> (n = 0 \\<or> rai_ub x = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> rai_ub x = 0) \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "with x"], ["proof (chain)\npicking this:\n  invariant_1 x\n  \\<not> (n = 0 \\<or> rai_ub x = 0)", "have n: \"n \\<noteq> 0\" and x0: \"real_of_1 x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  invariant_1 x\n  \\<not> (n = 0 \\<or> rai_ub x = 0)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 &&& real_of_1 x \\<noteq> 0", "by (simp, cases x, auto)"], ["proof (state)\nthis:\n  n \\<noteq> 0\n  real_of_1 x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> rai_ub x = 0) \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "note rt = root_pos_1"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<noteq> 0; invariant_1 ?x; 0 < rai_ub ?x\\<rbrakk>\n  \\<Longrightarrow> invariant_2 (root_pos_1 ?x) \\<and>\n                    real_of_2 (root_pos_1 ?x) = root n (real_of_1 ?x)\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> rai_ub x = 0) \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "proof (cases \"rai_ub x\" \"0::rat\" rule:linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. rai_ub x < 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 3. 0 < rai_ub x \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "case greater"], ["proof (state)\nthis:\n  0 < rai_ub x\n\ngoal (3 subgoals):\n 1. rai_ub x < 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 3. 0 < rai_ub x \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "with rt[OF n x this] n"], ["proof (chain)\npicking this:\n  invariant_2 (root_pos_1 x) \\<and>\n  real_of_2 (root_pos_1 x) = root n (real_of_1 x)\n  n \\<noteq> 0\n  0 < rai_ub x", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant_2 (root_pos_1 x) \\<and>\n  real_of_2 (root_pos_1 x) = root n (real_of_1 x)\n  n \\<noteq> 0\n  0 < rai_ub x\n\ngoal (1 subgoal):\n 1. invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "by (unfold y, cases x, simp)"], ["proof (state)\nthis:\n  invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n\ngoal (2 subgoals):\n 1. rai_ub x < 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. rai_ub x < 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "case less"], ["proof (state)\nthis:\n  rai_ub x < 0\n\ngoal (2 subgoals):\n 1. rai_ub x < 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "let ?um = \"uminus_1\""], ["proof (state)\ngoal (2 subgoals):\n 1. rai_ub x < 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "let ?rt = \"root_pos_1\""], ["proof (state)\ngoal (2 subgoals):\n 1. rai_ub x < 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "from n less y x0"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  rai_ub x < 0\n  y \\<equiv> local.root_1 x\n  real_of_1 x \\<noteq> 0", "have y: \"y = uminus_2 (?rt (?um x))\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  rai_ub x < 0\n  y \\<equiv> local.root_1 x\n  real_of_1 x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y = uminus_2 (root_pos_1 (uminus_1 x))", "by (cases x, auto)"], ["proof (state)\nthis:\n  y = uminus_2 (root_pos_1 (uminus_1 x))\n\ngoal (2 subgoals):\n 1. rai_ub x < 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "from uminus_1[OF x]"], ["proof (chain)\npicking this:\n  invariant_1 (uminus_1 x) \\<and> real_of_1 (uminus_1 x) = - real_of_1 x", "have umx: \"invariant_1 (?um x)\" and umx2: \"real_of_1 (?um x) = - real_of_1 x\""], ["proof (prove)\nusing this:\n  invariant_1 (uminus_1 x) \\<and> real_of_1 (uminus_1 x) = - real_of_1 x\n\ngoal (1 subgoal):\n 1. invariant_1 (uminus_1 x) &&& real_of_1 (uminus_1 x) = - real_of_1 x", "by auto"], ["proof (state)\nthis:\n  invariant_1 (uminus_1 x)\n  real_of_1 (uminus_1 x) = - real_of_1 x\n\ngoal (2 subgoals):\n 1. rai_ub x < 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "with x less"], ["proof (chain)\npicking this:\n  invariant_1 x\n  rai_ub x < 0\n  invariant_1 (uminus_1 x)\n  real_of_1 (uminus_1 x) = - real_of_1 x", "have \"0 < rai_ub (uminus_1 x)\""], ["proof (prove)\nusing this:\n  invariant_1 x\n  rai_ub x < 0\n  invariant_1 (uminus_1 x)\n  real_of_1 (uminus_1 x) = - real_of_1 x\n\ngoal (1 subgoal):\n 1. 0 < rai_ub (uminus_1 x)", "by (cases x, auto simp: uminus_1.simps Let_def)"], ["proof (state)\nthis:\n  0 < rai_ub (uminus_1 x)\n\ngoal (2 subgoals):\n 1. rai_ub x < 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "from rt[OF n umx this] umx2"], ["proof (chain)\npicking this:\n  invariant_2 (root_pos_1 (uminus_1 x)) \\<and>\n  real_of_2 (root_pos_1 (uminus_1 x)) = root n (real_of_1 (uminus_1 x))\n  real_of_1 (uminus_1 x) = - real_of_1 x", "have rumx: \"invariant_2 (?rt (?um x))\" \n      and rumx2: \"real_of_2 (?rt (?um x)) = root n (- real_of_1 x)\""], ["proof (prove)\nusing this:\n  invariant_2 (root_pos_1 (uminus_1 x)) \\<and>\n  real_of_2 (root_pos_1 (uminus_1 x)) = root n (real_of_1 (uminus_1 x))\n  real_of_1 (uminus_1 x) = - real_of_1 x\n\ngoal (1 subgoal):\n 1. invariant_2 (root_pos_1 (uminus_1 x)) &&&\n    real_of_2 (root_pos_1 (uminus_1 x)) = root n (- real_of_1 x)", "by auto"], ["proof (state)\nthis:\n  invariant_2 (root_pos_1 (uminus_1 x))\n  real_of_2 (root_pos_1 (uminus_1 x)) = root n (- real_of_1 x)\n\ngoal (2 subgoals):\n 1. rai_ub x < 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n 2. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "from uminus_2[OF rumx] rumx2 y real_root_minus"], ["proof (chain)\npicking this:\n  real_of_2 (uminus_2 (root_pos_1 (uminus_1 x))) =\n  - real_of_2 (root_pos_1 (uminus_1 x))\n  invariant_2 (uminus_2 (root_pos_1 (uminus_1 x)))\n  real_of_2 (root_pos_1 (uminus_1 x)) = root n (- real_of_1 x)\n  y = uminus_2 (root_pos_1 (uminus_1 x))\n  root ?n (- ?x) = - root ?n ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_2 (uminus_2 (root_pos_1 (uminus_1 x))) =\n  - real_of_2 (root_pos_1 (uminus_1 x))\n  invariant_2 (uminus_2 (root_pos_1 (uminus_1 x)))\n  real_of_2 (root_pos_1 (uminus_1 x)) = root n (- real_of_1 x)\n  y = uminus_2 (root_pos_1 (uminus_1 x))\n  root ?n (- ?x) = - root ?n ?x\n\ngoal (1 subgoal):\n 1. invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "by auto"], ["proof (state)\nthis:\n  invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n\ngoal (1 subgoal):\n 1. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "case equal"], ["proof (state)\nthis:\n  rai_ub x = 0\n\ngoal (1 subgoal):\n 1. rai_ub x = 0 \\<Longrightarrow>\n    invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "with x0 x"], ["proof (chain)\npicking this:\n  real_of_1 x \\<noteq> 0\n  invariant_1 x\n  rai_ub x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_1 x \\<noteq> 0\n  invariant_1 x\n  rai_ub x = 0\n\ngoal (1 subgoal):\n 1. invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)", "by (cases x, auto)"], ["proof (state)\nthis:\n  invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invariant_2 y \\<and> real_of_2 y = root n (real_of_1 x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "declare root_1.simps[simp del]"], ["", "(* ********************** *)"], ["", "subsubsection \\<open>Embedding of Rational Numbers\\<close>"], ["", "definition of_rat_1 :: \"rat \\<Rightarrow> real_alg_1\" where\n  \"of_rat_1 x \\<equiv> (poly_rat x,x,x)\""], ["", "lemma of_rat_1:\n  shows \"invariant_1 (of_rat_1 x)\" and \"real_of_1 (of_rat_1 x) = of_rat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1 (of_rat_1 x) &&& real_of_1 (of_rat_1 x) = real_of_rat x", "unfolding of_rat_1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_1 (poly_rat x, x, x) &&&\n    real_of_1 (poly_rat x, x, x) = real_of_rat x", "by (atomize(full), intro invariant_1_realI unique_rootI poly_condI, auto )"], ["", "fun info_2 :: \"real_alg_2 \\<Rightarrow> rat + int poly \\<times> nat\" where\n  \"info_2 (Rational x) = Inl x\"\n| \"info_2 (Irrational n (p,l,r)) = Inr (p,n)\""], ["", "lemma info_2_card: assumes rc: \"invariant_2 x\"\n  shows \"info_2 x = Inr (p,n) \\<Longrightarrow> poly_cond p \\<and> ipoly p (real_of_2 x) = 0 \\<and> degree p \\<ge> 2 \n    \\<and> card (roots_below p (real_of_2 x)) = n\"\n    \"info_2 x = Inl y \\<Longrightarrow> real_of_2 x = of_rat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (info_2 x = Inr (p, n) \\<Longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) &&&\n    (info_2 x = Inl y \\<Longrightarrow> real_of_2 x = real_of_rat y)", "proof (atomize(full), goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        poly_cond p \\<and>\n        poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n        2 \\<le> degree p \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n) \\<and>\n       (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        poly_cond p \\<and>\n        poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n        2 \\<le> degree p \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n) \\<and>\n       (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "case (Irrational m rai)"], ["proof (state)\nthis:\n  x = Irrational m rai\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        poly_cond p \\<and>\n        poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n        2 \\<le> degree p \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n) \\<and>\n       (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        poly_cond p \\<and>\n        poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n        2 \\<le> degree p \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n) \\<and>\n       (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "then"], ["proof (chain)\npicking this:\n  x = Irrational m rai", "obtain q l r where x: \"x = Irrational m (q,l,r)\""], ["proof (prove)\nusing this:\n  x = Irrational m rai\n\ngoal (1 subgoal):\n 1. (\\<And>q l r.\n        x = Irrational m (q, l, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases rai, auto)"], ["proof (state)\nthis:\n  x = Irrational m (q, l, r)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        poly_cond p \\<and>\n        poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n        2 \\<le> degree p \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n) \\<and>\n       (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        poly_cond p \\<and>\n        poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n        2 \\<le> degree p \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n) \\<and>\n       (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "proof (cases \"q = p \\<and> m = n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q = p \\<and> m = n \\<Longrightarrow>\n    (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)\n 2. \\<not> (q = p \\<and> m = n) \\<Longrightarrow>\n    (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "case False"], ["proof (state)\nthis:\n  \\<not> (q = p \\<and> m = n)\n\ngoal (2 subgoals):\n 1. q = p \\<and> m = n \\<Longrightarrow>\n    (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)\n 2. \\<not> (q = p \\<and> m = n) \\<Longrightarrow>\n    (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (q = p \\<and> m = n)\n\ngoal (1 subgoal):\n 1. (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "using x"], ["proof (prove)\nusing this:\n  \\<not> (q = p \\<and> m = n)\n  x = Irrational m (q, l, r)\n\ngoal (1 subgoal):\n 1. (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "by auto"], ["proof (state)\nthis:\n  (info_2 x = Inr (p, n) \\<longrightarrow>\n   poly_cond p \\<and>\n   poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n   2 \\<le> degree p \\<and>\n   card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n   n) \\<and>\n  (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)\n\ngoal (1 subgoal):\n 1. q = p \\<and> m = n \\<Longrightarrow>\n    (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q = p \\<and> m = n \\<Longrightarrow>\n    (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "case True"], ["proof (state)\nthis:\n  q = p \\<and> m = n\n\ngoal (1 subgoal):\n 1. q = p \\<and> m = n \\<Longrightarrow>\n    (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "with x"], ["proof (chain)\npicking this:\n  x = Irrational m (q, l, r)\n  q = p \\<and> m = n", "have x: \"x = Irrational n (p,l,r)\""], ["proof (prove)\nusing this:\n  x = Irrational m (q, l, r)\n  q = p \\<and> m = n\n\ngoal (1 subgoal):\n 1. x = Irrational n (p, l, r)", "by auto"], ["proof (state)\nthis:\n  x = Irrational n (p, l, r)\n\ngoal (1 subgoal):\n 1. q = p \\<and> m = n \\<Longrightarrow>\n    (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "from rc[unfolded x, simplified]"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l, r) \\<and>\n  n =\n  card\n   {y. y \\<le> real_of_1 (p, l, r) \\<and> poly (real_of_int_poly p) y = 0}", "have inv: \"invariant_1_2 (p,l,r)\" and \n        n: \"card (roots_below p (real_of_2 x)) = n\" and 1: \"degree p \\<noteq> 1\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r) \\<and>\n  n =\n  card\n   {y. y \\<le> real_of_1 (p, l, r) \\<and> poly (real_of_int_poly p) y = 0}\n\ngoal (1 subgoal):\n 1. invariant_1_2 (p, l, r) &&&\n    card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n    n &&&\n    degree p \\<noteq> 1", "by (auto simp: x)"], ["proof (state)\nthis:\n  invariant_1_2 (p, l, r)\n  card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} = n\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. q = p \\<and> m = n \\<Longrightarrow>\n    (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "from inv"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l, r)", "have \"degree p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "unfolding irreducible_def"], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q = p \\<and> m = n \\<Longrightarrow>\n    (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "with 1"], ["proof (chain)\npicking this:\n  degree p \\<noteq> 1\n  degree p \\<noteq> 0", "have \"degree p \\<ge> 2\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 1\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> degree p", "by linarith"], ["proof (state)\nthis:\n  2 \\<le> degree p\n\ngoal (1 subgoal):\n 1. q = p \\<and> m = n \\<Longrightarrow>\n    (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 \\<le> degree p\n\ngoal (1 subgoal):\n 1. (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "unfolding n"], ["proof (prove)\nusing this:\n  2 \\<le> degree p\n\ngoal (1 subgoal):\n 1. (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and> n = n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "using inv x"], ["proof (prove)\nusing this:\n  2 \\<le> degree p\n  invariant_1_2 (p, l, r)\n  x = Irrational n (p, l, r)\n\ngoal (1 subgoal):\n 1. (info_2 x = Inr (p, n) \\<longrightarrow>\n     poly_cond p \\<and>\n     poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n     2 \\<le> degree p \\<and> n = n) \\<and>\n    (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "by (auto elim!: invariant_1E)"], ["proof (state)\nthis:\n  (info_2 x = Inr (p, n) \\<longrightarrow>\n   poly_cond p \\<and>\n   poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n   2 \\<le> degree p \\<and>\n   card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n   n) \\<and>\n  (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (info_2 x = Inr (p, n) \\<longrightarrow>\n   poly_cond p \\<and>\n   poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n   2 \\<le> degree p \\<and>\n   card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n   n) \\<and>\n  (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        poly_cond p \\<and>\n        poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n        2 \\<le> degree p \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n) \\<and>\n       (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)", "qed auto"], ["proof (state)\nthis:\n  (info_2 x = Inr (p, n) \\<longrightarrow>\n   poly_cond p \\<and>\n   poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n   2 \\<le> degree p \\<and>\n   card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n   n) \\<and>\n  (info_2 x = Inl y \\<longrightarrow> real_of_2 x = real_of_rat y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma real_of_2_Irrational: \"invariant_2 (Irrational n rai) \\<Longrightarrow> real_of_2 (Irrational n rai) \\<noteq> of_rat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (Irrational n rai) \\<Longrightarrow>\n    real_of_2 (Irrational n rai) \\<noteq> real_of_rat x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_2 (Irrational n rai);\n     real_of_2 (Irrational n rai) = real_of_rat x\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"invariant_2 (Irrational n rai)\" and rat: \"real_of_2 (Irrational n rai) = real_of_rat x\""], ["proof (state)\nthis:\n  invariant_2 (Irrational n rai)\n  real_of_2 (Irrational n rai) = real_of_rat x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_2 (Irrational n rai);\n     real_of_2 (Irrational n rai) = real_of_rat x\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"real_of_1 rai \\<in> \\<rat>\" \"invariant_1_2 rai\""], ["proof (prove)\nusing this:\n  invariant_2 (Irrational n rai)\n  real_of_2 (Irrational n rai) = real_of_rat x\n\ngoal (1 subgoal):\n 1. real_of_1 rai \\<in> \\<rat> &&& invariant_1_2 rai", "by auto"], ["proof (state)\nthis:\n  real_of_1 rai \\<in> \\<rat>\n  invariant_1_2 rai\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_2 (Irrational n rai);\n     real_of_2 (Irrational n rai) = real_of_rat x\\<rbrakk>\n    \\<Longrightarrow> False", "from invariant_1_2_of_rat[OF this(2)] rat"], ["proof (chain)\npicking this:\n  real_of_1 rai \\<noteq> real_of_rat ?x\n  real_of_2 (Irrational n rai) = real_of_rat x", "show False"], ["proof (prove)\nusing this:\n  real_of_1 rai \\<noteq> real_of_rat ?x\n  real_of_2 (Irrational n rai) = real_of_rat x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma info_2: assumes \n    ix: \"invariant_2 x\" and iy: \"invariant_2 y\"\n  shows \"info_2 x = info_2 y \\<longleftrightarrow> real_of_2 x = real_of_2 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "case x: (Irrational n1 rai1)"], ["proof (state)\nthis:\n  x = Irrational n1 rai1\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "note ix = ix[unfolded x]"], ["proof (state)\nthis:\n  invariant_2 (Irrational n1 rai1)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       y = Rational x1 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n 2. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "case (Rational y)"], ["proof (state)\nthis:\n  y = Rational y\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       y = Rational x1 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n 2. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "with real_of_2_Irrational[OF ix, of y]"], ["proof (chain)\npicking this:\n  real_of_2 (Irrational n1 rai1) \\<noteq> real_of_rat y\n  y = Rational y", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_2 (Irrational n1 rai1) \\<noteq> real_of_rat y\n  y = Rational y\n\ngoal (1 subgoal):\n 1. (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "unfolding x"], ["proof (prove)\nusing this:\n  real_of_2 (Irrational n1 rai1) \\<noteq> real_of_rat y\n  y = Rational y\n\ngoal (1 subgoal):\n 1. (info_2 (Irrational n1 rai1) = info_2 y) =\n    (real_of_2 (Irrational n1 rai1) = real_of_2 y)", "by (cases rai1, auto)"], ["proof (state)\nthis:\n  (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "case y: (Irrational n2 rai2)"], ["proof (state)\nthis:\n  y = Irrational n2 rai2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "obtain p1 l1 r1 where rai1: \"rai1 = (p1,l1,r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 l1 r1.\n        rai1 = (p1, l1, r1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases rai1)"], ["proof (state)\nthis:\n  rai1 = (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "obtain p2 l2 r2 where rai2: \"rai2 = (p2,l2,r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p2 l2 r2.\n        rai2 = (p2, l2, r2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases rai2)"], ["proof (state)\nthis:\n  rai2 = (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "let ?rx = \"the_unique_root (p1,l1,r1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "let ?ry = \"the_unique_root (p2,l2,r2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "have id: \"(info_2 x = info_2 y) = (p1 = p2 \\<and> n1 = n2)\" \n      \"(real_of_2 x = real_of_2 y) = (?rx = ?ry)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (info_2 x = info_2 y) = (p1 = p2 \\<and> n1 = n2) &&&\n    (real_of_2 x = real_of_2 y) =\n    (real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2))", "unfolding x y rai1 rai2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (info_2 (Irrational n1 (p1, l1, r1)) =\n     info_2 (Irrational n2 (p2, l2, r2))) =\n    (p1 = p2 \\<and> n1 = n2) &&&\n    (real_of_2 (Irrational n1 (p1, l1, r1)) =\n     real_of_2 (Irrational n2 (p2, l2, r2))) =\n    (real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2))", "by auto"], ["proof (state)\nthis:\n  (info_2 x = info_2 y) = (p1 = p2 \\<and> n1 = n2)\n  (real_of_2 x = real_of_2 y) =\n  (real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "from ix[unfolded x rai1]"], ["proof (chain)\npicking this:\n  invariant_2 (Irrational n1 (p1, l1, r1))", "have ix: \"invariant_1 (p1, l1, r1)\" and deg1: \"degree p1 > 1\" and n1: \"n1 = card (roots_below p1 ?rx)\""], ["proof (prove)\nusing this:\n  invariant_2 (Irrational n1 (p1, l1, r1))\n\ngoal (1 subgoal):\n 1. invariant_1 (p1, l1, r1) &&&\n    1 < degree p1 &&&\n    n1 =\n    card\n     {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n         poly (real_of_int_poly p1) y = 0}", "by auto"], ["proof (state)\nthis:\n  invariant_1 (p1, l1, r1)\n  1 < degree p1\n  n1 =\n  card\n   {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n       poly (real_of_int_poly p1) y = 0}\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "note Ix = invariant_1D[OF ix]"], ["proof (state)\nthis:\n  root_cond (p1, l1, r1) (real_of_1 (p1, l1, r1))\n  sgn (rai_lb (p1, l1, r1)) = sgn (rai_ub (p1, l1, r1))\n  sgn (real_of_1 (p1, l1, r1)) = real_of_rat (sgn (rai_ub (p1, l1, r1)))\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  poly_cond (poly_real_alg_1 (p1, l1, r1))\n  0 < degree (poly_real_alg_1 (p1, l1, r1))\n  primitive (poly_real_alg_1 (p1, l1, r1))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "from deg1"], ["proof (chain)\npicking this:\n  1 < degree p1", "have p1_0: \"p1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  1 < degree p1\n\ngoal (1 subgoal):\n 1. p1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "from iy[unfolded y rai2]"], ["proof (chain)\npicking this:\n  invariant_2 (Irrational n2 (p2, l2, r2))", "have iy: \"invariant_1 (p2, l2, r2)\" and \"degree p2 > 1\" and n2: \"n2 = card (roots_below p2 ?ry)\""], ["proof (prove)\nusing this:\n  invariant_2 (Irrational n2 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. invariant_1 (p2, l2, r2) &&&\n    1 < degree p2 &&&\n    n2 =\n    card\n     {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n         poly (real_of_int_poly p2) y = 0}", "by auto"], ["proof (state)\nthis:\n  invariant_1 (p2, l2, r2)\n  1 < degree p2\n  n2 =\n  card\n   {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n       poly (real_of_int_poly p2) y = 0}\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "note Iy = invariant_1D[OF iy]"], ["proof (state)\nthis:\n  root_cond (p2, l2, r2) (real_of_1 (p2, l2, r2))\n  sgn (rai_lb (p2, l2, r2)) = sgn (rai_ub (p2, l2, r2))\n  sgn (real_of_1 (p2, l2, r2)) = real_of_rat (sgn (rai_ub (p2, l2, r2)))\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  poly_cond (poly_real_alg_1 (p2, l2, r2))\n  0 < degree (poly_real_alg_1 (p2, l2, r2))\n  primitive (poly_real_alg_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p1 = p2 \\<and> n1 = n2) =\n    (real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p1 = p2 \\<and> n1 = n2 \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 2. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    p1 = p2 \\<and> n1 = n2", "assume eq: \"?rx = ?ry\""], ["proof (state)\nthis:\n  real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n\ngoal (2 subgoals):\n 1. p1 = p2 \\<and> n1 = n2 \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 2. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    p1 = p2 \\<and> n1 = n2", "from Ix"], ["proof (chain)\npicking this:\n  root_cond (p1, l1, r1) (real_of_1 (p1, l1, r1))\n  sgn (rai_lb (p1, l1, r1)) = sgn (rai_ub (p1, l1, r1))\n  sgn (real_of_1 (p1, l1, r1)) = real_of_rat (sgn (rai_ub (p1, l1, r1)))\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  poly_cond (poly_real_alg_1 (p1, l1, r1))\n  0 < degree (poly_real_alg_1 (p1, l1, r1))\n  primitive (poly_real_alg_1 (p1, l1, r1))", "have algx: \"p1 represents ?rx \\<and> irreducible p1 \\<and> lead_coeff p1 > 0\""], ["proof (prove)\nusing this:\n  root_cond (p1, l1, r1) (real_of_1 (p1, l1, r1))\n  sgn (rai_lb (p1, l1, r1)) = sgn (rai_ub (p1, l1, r1))\n  sgn (real_of_1 (p1, l1, r1)) = real_of_rat (sgn (rai_ub (p1, l1, r1)))\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  poly_cond (poly_real_alg_1 (p1, l1, r1))\n  0 < degree (poly_real_alg_1 (p1, l1, r1))\n  primitive (poly_real_alg_1 (p1, l1, r1))\n\ngoal (1 subgoal):\n 1. p1 represents real_of_1 (p1, l1, r1) \\<and>\n    irreducible p1 \\<and> 0 < lead_coeff p1", "unfolding represents_def"], ["proof (prove)\nusing this:\n  root_cond (p1, l1, r1) (real_of_1 (p1, l1, r1))\n  sgn (rai_lb (p1, l1, r1)) = sgn (rai_ub (p1, l1, r1))\n  sgn (real_of_1 (p1, l1, r1)) = real_of_rat (sgn (rai_ub (p1, l1, r1)))\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  poly_cond (poly_real_alg_1 (p1, l1, r1))\n  0 < degree (poly_real_alg_1 (p1, l1, r1))\n  primitive (poly_real_alg_1 (p1, l1, r1))\n\ngoal (1 subgoal):\n 1. (poly (real_of_int_poly p1) (real_of_1 (p1, l1, r1)) = 0 \\<and>\n     p1 \\<noteq> 0) \\<and>\n    irreducible p1 \\<and> 0 < lead_coeff p1", "by auto"], ["proof (state)\nthis:\n  p1 represents real_of_1 (p1, l1, r1) \\<and>\n  irreducible p1 \\<and> 0 < lead_coeff p1\n\ngoal (2 subgoals):\n 1. p1 = p2 \\<and> n1 = n2 \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 2. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    p1 = p2 \\<and> n1 = n2", "from iy"], ["proof (chain)\npicking this:\n  invariant_1 (p2, l2, r2)", "have algy: \"p2 represents ?rx \\<and> irreducible p2 \\<and> lead_coeff p2 > 0\""], ["proof (prove)\nusing this:\n  invariant_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. p2 represents real_of_1 (p1, l1, r1) \\<and>\n    irreducible p2 \\<and> 0 < lead_coeff p2", "unfolding represents_def eq"], ["proof (prove)\nusing this:\n  invariant_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. (poly (real_of_int_poly p2) (real_of_1 (p2, l2, r2)) = 0 \\<and>\n     p2 \\<noteq> 0) \\<and>\n    irreducible p2 \\<and> 0 < lead_coeff p2", "by (auto elim!: invariant_1E)"], ["proof (state)\nthis:\n  p2 represents real_of_1 (p1, l1, r1) \\<and>\n  irreducible p2 \\<and> 0 < lead_coeff p2\n\ngoal (2 subgoals):\n 1. p1 = p2 \\<and> n1 = n2 \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 2. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    p1 = p2 \\<and> n1 = n2", "from algx"], ["proof (chain)\npicking this:\n  p1 represents real_of_1 (p1, l1, r1) \\<and>\n  irreducible p1 \\<and> 0 < lead_coeff p1", "have \"algebraic ?rx\""], ["proof (prove)\nusing this:\n  p1 represents real_of_1 (p1, l1, r1) \\<and>\n  irreducible p1 \\<and> 0 < lead_coeff p1\n\ngoal (1 subgoal):\n 1. algebraic (real_of_1 (p1, l1, r1))", "unfolding algebraic_altdef_ipoly"], ["proof (prove)\nusing this:\n  p1 represents real_of_1 (p1, l1, r1) \\<and>\n  irreducible p1 \\<and> 0 < lead_coeff p1\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       poly (real_of_int_poly p) (real_of_1 (p1, l1, r1)) = 0 \\<and>\n       p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  algebraic (real_of_1 (p1, l1, r1))\n\ngoal (2 subgoals):\n 1. p1 = p2 \\<and> n1 = n2 \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 2. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    p1 = p2 \\<and> n1 = n2", "note unique = algebraic_imp_represents_unique[OF this]"], ["proof (state)\nthis:\n  \\<exists>!p.\n     p represents real_of_1 (p1, l1, r1) \\<and>\n     irreducible p \\<and> 0 < lead_coeff p\n\ngoal (2 subgoals):\n 1. p1 = p2 \\<and> n1 = n2 \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 2. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    p1 = p2 \\<and> n1 = n2", "with algx algy"], ["proof (chain)\npicking this:\n  p1 represents real_of_1 (p1, l1, r1) \\<and>\n  irreducible p1 \\<and> 0 < lead_coeff p1\n  p2 represents real_of_1 (p1, l1, r1) \\<and>\n  irreducible p2 \\<and> 0 < lead_coeff p2\n  \\<exists>!p.\n     p represents real_of_1 (p1, l1, r1) \\<and>\n     irreducible p \\<and> 0 < lead_coeff p", "have id: \"p2 = p1\""], ["proof (prove)\nusing this:\n  p1 represents real_of_1 (p1, l1, r1) \\<and>\n  irreducible p1 \\<and> 0 < lead_coeff p1\n  p2 represents real_of_1 (p1, l1, r1) \\<and>\n  irreducible p2 \\<and> 0 < lead_coeff p2\n  \\<exists>!p.\n     p represents real_of_1 (p1, l1, r1) \\<and>\n     irreducible p \\<and> 0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. p2 = p1", "by auto"], ["proof (state)\nthis:\n  p2 = p1\n\ngoal (2 subgoals):\n 1. p1 = p2 \\<and> n1 = n2 \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 2. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    p1 = p2 \\<and> n1 = n2", "from eq id n1 n2"], ["proof (chain)\npicking this:\n  real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n  p2 = p1\n  n1 =\n  card\n   {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n       poly (real_of_int_poly p1) y = 0}\n  n2 =\n  card\n   {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n       poly (real_of_int_poly p2) y = 0}", "show \"p1 = p2 \\<and> n1 = n2\""], ["proof (prove)\nusing this:\n  real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n  p2 = p1\n  n1 =\n  card\n   {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n       poly (real_of_int_poly p1) y = 0}\n  n2 =\n  card\n   {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n       poly (real_of_int_poly p2) y = 0}\n\ngoal (1 subgoal):\n 1. p1 = p2 \\<and> n1 = n2", "by auto"], ["proof (state)\nthis:\n  p1 = p2 \\<and> n1 = n2\n\ngoal (1 subgoal):\n 1. p1 = p2 \\<and> n1 = n2 \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p1 = p2 \\<and> n1 = n2 \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "assume \"p1 = p2 \\<and> n1 = n2\""], ["proof (state)\nthis:\n  p1 = p2 \\<and> n1 = n2\n\ngoal (1 subgoal):\n 1. p1 = p2 \\<and> n1 = n2 \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "hence id: \"p1 = p2\" \"n1 = n2\""], ["proof (prove)\nusing this:\n  p1 = p2 \\<and> n1 = n2\n\ngoal (1 subgoal):\n 1. p1 = p2 &&& n1 = n2", "by auto"], ["proof (state)\nthis:\n  p1 = p2\n  n1 = n2\n\ngoal (1 subgoal):\n 1. p1 = p2 \\<and> n1 = n2 \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "hence card: \"card (roots_below p1 ?rx) = card (roots_below p1 ?ry)\""], ["proof (prove)\nusing this:\n  p1 = p2\n  n1 = n2\n\ngoal (1 subgoal):\n 1. card\n     {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n         poly (real_of_int_poly p1) y = 0} =\n    card\n     {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n         poly (real_of_int_poly p1) y = 0}", "unfolding n1 n2"], ["proof (prove)\nusing this:\n  p1 = p2\n  card\n   {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n       poly (real_of_int_poly p1) y = 0} =\n  card\n   {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n       poly (real_of_int_poly p2) y = 0}\n\ngoal (1 subgoal):\n 1. card\n     {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n         poly (real_of_int_poly p1) y = 0} =\n    card\n     {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n         poly (real_of_int_poly p1) y = 0}", "by auto"], ["proof (state)\nthis:\n  card\n   {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n       poly (real_of_int_poly p1) y = 0} =\n  card\n   {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n       poly (real_of_int_poly p1) y = 0}\n\ngoal (1 subgoal):\n 1. p1 = p2 \\<and> n1 = n2 \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "show \"?rx = ?ry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "proof (cases ?rx ?ry rule: linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. real_of_1 (p1, l1, r1) < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 2. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 3. real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "case less"], ["proof (state)\nthis:\n  real_of_1 (p1, l1, r1) < real_of_1 (p2, l2, r2)\n\ngoal (3 subgoals):\n 1. real_of_1 (p1, l1, r1) < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 2. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 3. real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "have \"roots_below p1 ?rx = roots_below p1 ?ry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n        poly (real_of_int_poly p1) y = 0} =\n    {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n        poly (real_of_int_poly p1) y = 0}", "proof (intro card_subset_eq finite_subset[OF _ ipoly_roots_finite] card)"], ["proof (state)\ngoal (3 subgoals):\n 1. {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n        poly (real_of_int_poly p1) y = 0}\n    \\<subseteq> {x. poly (real_of_int_poly ?p2) x = 0}\n 2. ?p2 \\<noteq> 0\n 3. {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n        poly (real_of_int_poly p1) y = 0}\n    \\<subseteq> {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n                    poly (real_of_int_poly p1) y = 0}", "from less"], ["proof (chain)\npicking this:\n  real_of_1 (p1, l1, r1) < real_of_1 (p2, l2, r2)", "show \"roots_below p1 ?rx \\<subseteq> roots_below p1 ?ry\""], ["proof (prove)\nusing this:\n  real_of_1 (p1, l1, r1) < real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n        poly (real_of_int_poly p1) y = 0}\n    \\<subseteq> {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n                    poly (real_of_int_poly p1) y = 0}", "by auto"], ["proof (state)\nthis:\n  {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n      poly (real_of_int_poly p1) y = 0}\n  \\<subseteq> {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n                  poly (real_of_int_poly p1) y = 0}\n\ngoal (2 subgoals):\n 1. {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n        poly (real_of_int_poly p1) y = 0}\n    \\<subseteq> {x. poly (real_of_int_poly ?p2) x = 0}\n 2. ?p2 \\<noteq> 0", "qed (insert p1_0, auto)"], ["proof (state)\nthis:\n  {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n      poly (real_of_int_poly p1) y = 0} =\n  {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n      poly (real_of_int_poly p1) y = 0}\n\ngoal (3 subgoals):\n 1. real_of_1 (p1, l1, r1) < real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 2. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 3. real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "then"], ["proof (chain)\npicking this:\n  {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n      poly (real_of_int_poly p1) y = 0} =\n  {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n      poly (real_of_int_poly p1) y = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n      poly (real_of_int_poly p1) y = 0} =\n  {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n      poly (real_of_int_poly p1) y = 0}\n\ngoal (1 subgoal):\n 1. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "using id less unique_rootD(3)[OF Iy(4)]"], ["proof (prove)\nusing this:\n  {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n      poly (real_of_int_poly p1) y = 0} =\n  {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n      poly (real_of_int_poly p1) y = 0}\n  p1 = p2\n  n1 = n2\n  real_of_1 (p1, l1, r1) < real_of_1 (p2, l2, r2)\n  poly (real_of_int_poly (poly_real_alg_1 (p2, l2, r2)))\n   (real_of_1 (p2, l2, r2)) =\n  0\n\ngoal (1 subgoal):\n 1. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "by (auto simp: less_eq_real_def)"], ["proof (state)\nthis:\n  real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n\ngoal (2 subgoals):\n 1. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 2. real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 2. real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "case equal"], ["proof (state)\nthis:\n  real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n\ngoal (2 subgoals):\n 1. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n 2. real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "then"], ["proof (chain)\npicking this:\n  real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "by (simp add: id)"], ["proof (state)\nthis:\n  real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "case greater"], ["proof (state)\nthis:\n  real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "have \"roots_below p1 ?ry = roots_below p1 ?rx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n        poly (real_of_int_poly p1) y = 0} =\n    {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n        poly (real_of_int_poly p1) y = 0}", "proof (intro card_subset_eq card[symmetric] finite_subset[OF _ ipoly_roots_finite[OF p1_0]])"], ["proof (state)\ngoal (2 subgoals):\n 1. {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n        poly (real_of_int_poly p1) y = 0}\n    \\<subseteq> {x. poly (real_of_int_poly p1) x = 0}\n 2. {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n        poly (real_of_int_poly p1) y = 0}\n    \\<subseteq> {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n                    poly (real_of_int_poly p1) y = 0}", "from greater"], ["proof (chain)\npicking this:\n  real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1)", "show \"roots_below p1 ?ry \\<subseteq> roots_below p1 ?rx\""], ["proof (prove)\nusing this:\n  real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1)\n\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n        poly (real_of_int_poly p1) y = 0}\n    \\<subseteq> {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n                    poly (real_of_int_poly p1) y = 0}", "by auto"], ["proof (state)\nthis:\n  {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n      poly (real_of_int_poly p1) y = 0}\n  \\<subseteq> {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n                  poly (real_of_int_poly p1) y = 0}\n\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n        poly (real_of_int_poly p1) y = 0}\n    \\<subseteq> {x. poly (real_of_int_poly p1) x = 0}", "qed auto"], ["proof (state)\nthis:\n  {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n      poly (real_of_int_poly p1) y = 0} =\n  {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n      poly (real_of_int_poly p1) y = 0}\n\ngoal (1 subgoal):\n 1. real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "hence \"roots_below p2 ?ry = roots_below p2 ?rx\""], ["proof (prove)\nusing this:\n  {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n      poly (real_of_int_poly p1) y = 0} =\n  {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n      poly (real_of_int_poly p1) y = 0}\n\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n        poly (real_of_int_poly p2) y = 0} =\n    {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n        poly (real_of_int_poly p2) y = 0}", "unfolding id"], ["proof (prove)\nusing this:\n  {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n      poly (real_of_int_poly p2) y = 0} =\n  {y. y \\<le> real_of_1 (p2, l1, r1) \\<and>\n      poly (real_of_int_poly p2) y = 0}\n\ngoal (1 subgoal):\n 1. {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n        poly (real_of_int_poly p2) y = 0} =\n    {y. y \\<le> real_of_1 (p2, l1, r1) \\<and>\n        poly (real_of_int_poly p2) y = 0}", "by auto"], ["proof (state)\nthis:\n  {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n      poly (real_of_int_poly p2) y = 0} =\n  {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n      poly (real_of_int_poly p2) y = 0}\n\ngoal (1 subgoal):\n 1. real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1) \\<Longrightarrow>\n    real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n      poly (real_of_int_poly p2) y = 0} =\n  {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n      poly (real_of_int_poly p2) y = 0}\n\ngoal (1 subgoal):\n 1. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "using id greater unique_rootD(3)[OF Ix(4)]"], ["proof (prove)\nusing this:\n  {y. y \\<le> real_of_1 (p2, l2, r2) \\<and>\n      poly (real_of_int_poly p2) y = 0} =\n  {y. y \\<le> real_of_1 (p1, l1, r1) \\<and>\n      poly (real_of_int_poly p2) y = 0}\n  p1 = p2\n  n1 = n2\n  real_of_1 (p2, l2, r2) < real_of_1 (p1, l1, r1)\n  poly (real_of_int_poly (poly_real_alg_1 (p1, l1, r1)))\n   (real_of_1 (p1, l1, r1)) =\n  0\n\ngoal (1 subgoal):\n 1. real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)", "by (auto simp: less_eq_real_def)"], ["proof (state)\nthis:\n  real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_1 (p1, l1, r1) = real_of_1 (p2, l2, r2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "case x: (Rational x)"], ["proof (state)\nthis:\n  x = Rational x\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       y = Rational x1 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n 2. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "case (Rational y)"], ["proof (state)\nthis:\n  y = Rational y\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       y = Rational x1 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n 2. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = Rational y\n\ngoal (1 subgoal):\n 1. (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "using x"], ["proof (prove)\nusing this:\n  y = Rational y\n  x = Rational x\n\ngoal (1 subgoal):\n 1. (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "by auto"], ["proof (state)\nthis:\n  (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "case y: (Irrational n rai)"], ["proof (state)\nthis:\n  y = Irrational n rai\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "with real_of_2_Irrational[OF iy[unfolded y], of x]"], ["proof (chain)\npicking this:\n  real_of_2 (Irrational n rai) \\<noteq> real_of_rat x\n  y = Irrational n rai", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_2 (Irrational n rai) \\<noteq> real_of_rat x\n  y = Irrational n rai\n\ngoal (1 subgoal):\n 1. (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)", "unfolding x"], ["proof (prove)\nusing this:\n  real_of_2 (Irrational n rai) \\<noteq> real_of_rat x\n  y = Irrational n rai\n\ngoal (1 subgoal):\n 1. (info_2 (Rational x) = info_2 y) =\n    (real_of_2 (Rational x) = real_of_2 y)", "by (cases rai, auto)"], ["proof (state)\nthis:\n  (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma info_2_unique: \"invariant_2 x \\<Longrightarrow> invariant_2 y \\<Longrightarrow> \n  real_of_2 x = real_of_2 y \\<Longrightarrow> info_2 x = info_2 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_2 x; invariant_2 y;\n     real_of_2 x = real_of_2 y\\<rbrakk>\n    \\<Longrightarrow> info_2 x = info_2 y", "using info_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>invariant_2 ?x; invariant_2 ?y\\<rbrakk>\n  \\<Longrightarrow> (info_2 ?x = info_2 ?y) = (real_of_2 ?x = real_of_2 ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_2 x; invariant_2 y;\n     real_of_2 x = real_of_2 y\\<rbrakk>\n    \\<Longrightarrow> info_2 x = info_2 y", "by blast"], ["", "lemma info_2_inj: \"invariant_2 x \\<Longrightarrow> invariant_2 y \\<Longrightarrow> info_2 x = info_2 y \\<Longrightarrow>\n  real_of_2 x = real_of_2 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_2 x; invariant_2 y; info_2 x = info_2 y\\<rbrakk>\n    \\<Longrightarrow> real_of_2 x = real_of_2 y", "using info_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>invariant_2 ?x; invariant_2 ?y\\<rbrakk>\n  \\<Longrightarrow> (info_2 ?x = info_2 ?y) = (real_of_2 ?x = real_of_2 ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant_2 x; invariant_2 y; info_2 x = info_2 y\\<rbrakk>\n    \\<Longrightarrow> real_of_2 x = real_of_2 y", "by blast"], ["", "context\n  fixes cr1 cr2 :: \"rat \\<Rightarrow> rat \\<Rightarrow> nat\"\nbegin"], ["", "partial_function (tailrec) compare_1 :: \"int poly \\<Rightarrow> int poly \\<Rightarrow> rat \\<Rightarrow> rat \\<Rightarrow> rat \\<Rightarrow> rat \\<Rightarrow> rat \\<Rightarrow> rat \\<Rightarrow> order\" where\n  [code]: \"compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = (if r1 < l2 then Lt else if r2 < l1 then Gt \n    else let \n      (l1',r1',sr1') = tighten_poly_bounds p1 l1 r1 sr1;\n      (l2',r2',sr2') = tighten_poly_bounds p2 l2 r2 sr2\n    in compare_1 p1 p2 l1' r1' sr1' l2' r2' sr2')\n    \""], ["", "lemma compare_1:\n  assumes ur1: \"unique_root (p1,l1,r1)\"\n  and ur2: \"unique_root (p2,l2,r2)\"\n  and pc: \"poly_cond2 p1\" \"poly_cond2 p2\"\n  and diff: \"the_unique_root (p1,l1,r1) \\<noteq> the_unique_root (p2,l2,r2)\"\n  and sr: \"sr1 = sgn (ipoly p1 r1)\" \"sr2 = sgn (ipoly p2 r2)\" \n shows \"compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare (the_unique_root (p1,l1,r1)) (the_unique_root (p2,l2,r2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "let ?r = real_of_rat"], ["proof (state)\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "fix d x y"], ["proof (state)\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "assume d: \"d = (r1 - l1) + (r2 - l2)\" and xy: \"x = the_unique_root (p1,l1,r1)\" \"y = the_unique_root (p2,l2,r2)\""], ["proof (state)\nthis:\n  d = r1 - l1 + (r2 - l2)\n  x = real_of_1 (p1, l1, r1)\n  y = real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "define delta where \"delta = abs (x - y) / 4\""], ["proof (state)\nthis:\n  delta = \\<bar>x - y\\<bar> / 4\n\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "have delta: \"delta > 0\" and diff: \"x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < delta &&& x \\<noteq> y", "unfolding delta_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<bar>x - y\\<bar> / 4 &&& x \\<noteq> y", "using diff xy"], ["proof (prove)\nusing this:\n  real_of_1 (p1, l1, r1) \\<noteq> real_of_1 (p2, l2, r2)\n  x = real_of_1 (p1, l1, r1)\n  y = real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. 0 < \\<bar>x - y\\<bar> / 4 &&& x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  0 < delta\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "let ?rel' = \"{(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\""], ["proof (state)\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "let ?rel = \"inv_image ?rel' ?r\""], ["proof (state)\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "have SN: \"SN ?rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SN (inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y} real_of_rat)", "by (rule SN_inv_image[OF delta_gt_SN[OF delta]])"], ["proof (state)\nthis:\n  SN (inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y} real_of_rat)\n\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "from d ur1 ur2"], ["proof (chain)\npicking this:\n  d = r1 - l1 + (r2 - l2)\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  \\<exists>!x. root_cond (p2, l2, r2) x", "have ?thesis"], ["proof (prove)\nusing this:\n  d = r1 - l1 + (r2 - l2)\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  \\<exists>!x. root_cond (p2, l2, r2) x\n\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "unfolding xy[symmetric]"], ["proof (prove)\nusing this:\n  d = r1 - l1 + (r2 - l2)\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  \\<exists>!x. root_cond (p2, l2, r2) x\n\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "using xy sr"], ["proof (prove)\nusing this:\n  d = r1 - l1 + (r2 - l2)\n  \\<exists>!x. root_cond (p1, l1, r1) x\n  \\<exists>!x. root_cond (p2, l2, r2) x\n  x = real_of_1 (p1, l1, r1)\n  y = real_of_1 (p2, l2, r2)\n  sr1 = sgn (ipoly p1 r1)\n  sr2 = sgn (ipoly p2 r2)\n\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "proof (induct d arbitrary: l1 r1 l2 r2 sr1 sr2 rule: SN_induct[OF SN])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l1 r1 l2 r2 sr1 sr2.\n       \\<lbrakk>\\<And>b l1 r1 l2 r2 sr1 sr2.\n                   \\<lbrakk>(a, b)\n                            \\<in> inv_image\n                                   {(x, y).\n                                    0 \\<le> y \\<and> delta_gt delta x y}\n                                   real_of_rat;\n                    b = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n                    Ex1 (root_cond (p2, l2, r2));\n                    x = real_of_1 (p1, l1, r1); y = real_of_1 (p2, l2, r2);\n                    sr1 = sgn (ipoly p1 r1);\n                    sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n                   \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n                                     compare x y;\n        a = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n        Ex1 (root_cond (p2, l2, r2)); x = real_of_1 (p1, l1, r1);\n        y = real_of_1 (p2, l2, r2); sr1 = sgn (ipoly p1 r1);\n        sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n       \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "case (1 d l1 r1 l2 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>(d, ?b)\n           \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n                  real_of_rat;\n   ?b = ?r1.0 - ?l1.0 + (?r2.0 - ?l2.0);\n   \\<exists>!a. root_cond (p1, ?l1.0, ?r1.0) a;\n   \\<exists>!a. root_cond (p2, ?l2.0, ?r2.0) a;\n   x = real_of_1 (p1, ?l1.0, ?r1.0); y = real_of_1 (p2, ?l2.0, ?r2.0);\n   ?sr1.0 = sgn (ipoly p1 ?r1.0); ?sr2.0 = sgn (ipoly p2 ?r2.0)\\<rbrakk>\n  \\<Longrightarrow> compare_1 p1 p2 ?l1.0 ?r1.0 ?sr1.0 ?l2.0 ?r2.0 ?sr2.0 =\n                    compare x y\n  d = r1 - l1 + (r2 - l2)\n  \\<exists>!a. root_cond (p1, l1, r1) a\n  \\<exists>!a. root_cond (p2, l2, r2) a\n  x = real_of_1 (p1, l1, r1)\n  y = real_of_1 (p2, l2, r2)\n  sr1 = sgn (ipoly p1 r1)\n  sr2 = sgn (ipoly p2 r2)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 r1 l2 r2 sr1 sr2.\n       \\<lbrakk>\\<And>b l1 r1 l2 r2 sr1 sr2.\n                   \\<lbrakk>(a, b)\n                            \\<in> inv_image\n                                   {(x, y).\n                                    0 \\<le> y \\<and> delta_gt delta x y}\n                                   real_of_rat;\n                    b = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n                    Ex1 (root_cond (p2, l2, r2));\n                    x = real_of_1 (p1, l1, r1); y = real_of_1 (p2, l2, r2);\n                    sr1 = sgn (ipoly p1 r1);\n                    sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n                   \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n                                     compare x y;\n        a = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n        Ex1 (root_cond (p2, l2, r2)); x = real_of_1 (p1, l1, r1);\n        y = real_of_1 (p2, l2, r2); sr1 = sgn (ipoly p1 r1);\n        sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n       \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "note IH = 1(1)"], ["proof (state)\nthis:\n  \\<lbrakk>(d, ?b)\n           \\<in> inv_image {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\n                  real_of_rat;\n   ?b = ?r1.0 - ?l1.0 + (?r2.0 - ?l2.0);\n   \\<exists>!a. root_cond (p1, ?l1.0, ?r1.0) a;\n   \\<exists>!a. root_cond (p2, ?l2.0, ?r2.0) a;\n   x = real_of_1 (p1, ?l1.0, ?r1.0); y = real_of_1 (p2, ?l2.0, ?r2.0);\n   ?sr1.0 = sgn (ipoly p1 ?r1.0); ?sr2.0 = sgn (ipoly p2 ?r2.0)\\<rbrakk>\n  \\<Longrightarrow> compare_1 p1 p2 ?l1.0 ?r1.0 ?sr1.0 ?l2.0 ?r2.0 ?sr2.0 =\n                    compare x y\n\ngoal (1 subgoal):\n 1. \\<And>a l1 r1 l2 r2 sr1 sr2.\n       \\<lbrakk>\\<And>b l1 r1 l2 r2 sr1 sr2.\n                   \\<lbrakk>(a, b)\n                            \\<in> inv_image\n                                   {(x, y).\n                                    0 \\<le> y \\<and> delta_gt delta x y}\n                                   real_of_rat;\n                    b = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n                    Ex1 (root_cond (p2, l2, r2));\n                    x = real_of_1 (p1, l1, r1); y = real_of_1 (p2, l2, r2);\n                    sr1 = sgn (ipoly p1 r1);\n                    sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n                   \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n                                     compare x y;\n        a = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n        Ex1 (root_cond (p2, l2, r2)); x = real_of_1 (p1, l1, r1);\n        y = real_of_1 (p2, l2, r2); sr1 = sgn (ipoly p1 r1);\n        sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n       \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "note d = 1(2)"], ["proof (state)\nthis:\n  d = r1 - l1 + (r2 - l2)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 r1 l2 r2 sr1 sr2.\n       \\<lbrakk>\\<And>b l1 r1 l2 r2 sr1 sr2.\n                   \\<lbrakk>(a, b)\n                            \\<in> inv_image\n                                   {(x, y).\n                                    0 \\<le> y \\<and> delta_gt delta x y}\n                                   real_of_rat;\n                    b = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n                    Ex1 (root_cond (p2, l2, r2));\n                    x = real_of_1 (p1, l1, r1); y = real_of_1 (p2, l2, r2);\n                    sr1 = sgn (ipoly p1 r1);\n                    sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n                   \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n                                     compare x y;\n        a = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n        Ex1 (root_cond (p2, l2, r2)); x = real_of_1 (p1, l1, r1);\n        y = real_of_1 (p2, l2, r2); sr1 = sgn (ipoly p1 r1);\n        sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n       \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "note ur = 1(3-4)"], ["proof (state)\nthis:\n  \\<exists>!a. root_cond (p1, l1, r1) a\n  \\<exists>!a. root_cond (p2, l2, r2) a\n\ngoal (1 subgoal):\n 1. \\<And>a l1 r1 l2 r2 sr1 sr2.\n       \\<lbrakk>\\<And>b l1 r1 l2 r2 sr1 sr2.\n                   \\<lbrakk>(a, b)\n                            \\<in> inv_image\n                                   {(x, y).\n                                    0 \\<le> y \\<and> delta_gt delta x y}\n                                   real_of_rat;\n                    b = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n                    Ex1 (root_cond (p2, l2, r2));\n                    x = real_of_1 (p1, l1, r1); y = real_of_1 (p2, l2, r2);\n                    sr1 = sgn (ipoly p1 r1);\n                    sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n                   \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n                                     compare x y;\n        a = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n        Ex1 (root_cond (p2, l2, r2)); x = real_of_1 (p1, l1, r1);\n        y = real_of_1 (p2, l2, r2); sr1 = sgn (ipoly p1 r1);\n        sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n       \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "note xy = 1(5-6)"], ["proof (state)\nthis:\n  x = real_of_1 (p1, l1, r1)\n  y = real_of_1 (p2, l2, r2)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 r1 l2 r2 sr1 sr2.\n       \\<lbrakk>\\<And>b l1 r1 l2 r2 sr1 sr2.\n                   \\<lbrakk>(a, b)\n                            \\<in> inv_image\n                                   {(x, y).\n                                    0 \\<le> y \\<and> delta_gt delta x y}\n                                   real_of_rat;\n                    b = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n                    Ex1 (root_cond (p2, l2, r2));\n                    x = real_of_1 (p1, l1, r1); y = real_of_1 (p2, l2, r2);\n                    sr1 = sgn (ipoly p1 r1);\n                    sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n                   \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n                                     compare x y;\n        a = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n        Ex1 (root_cond (p2, l2, r2)); x = real_of_1 (p1, l1, r1);\n        y = real_of_1 (p2, l2, r2); sr1 = sgn (ipoly p1 r1);\n        sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n       \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "note sr = 1(7-8)"], ["proof (state)\nthis:\n  sr1 = sgn (ipoly p1 r1)\n  sr2 = sgn (ipoly p2 r2)\n\ngoal (1 subgoal):\n 1. \\<And>a l1 r1 l2 r2 sr1 sr2.\n       \\<lbrakk>\\<And>b l1 r1 l2 r2 sr1 sr2.\n                   \\<lbrakk>(a, b)\n                            \\<in> inv_image\n                                   {(x, y).\n                                    0 \\<le> y \\<and> delta_gt delta x y}\n                                   real_of_rat;\n                    b = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n                    Ex1 (root_cond (p2, l2, r2));\n                    x = real_of_1 (p1, l1, r1); y = real_of_1 (p2, l2, r2);\n                    sr1 = sgn (ipoly p1 r1);\n                    sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n                   \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n                                     compare x y;\n        a = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n        Ex1 (root_cond (p2, l2, r2)); x = real_of_1 (p1, l1, r1);\n        y = real_of_1 (p2, l2, r2); sr1 = sgn (ipoly p1 r1);\n        sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n       \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "note simps = compare_1.simps[of p1 p2 l1 r1 sr1 l2 r2 sr2]"], ["proof (state)\nthis:\n  compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n  (if r1 < l2 then Lt\n   else if r2 < l1 then Gt\n        else let (l1', r1', sr1') = tighten_poly_bounds p1 l1 r1 sr1;\n                 (l2', r2', sr2') = tighten_poly_bounds p2 l2 r2 sr2\n             in compare_1 p1 p2 l1' r1' sr1' l2' r2' sr2')\n\ngoal (1 subgoal):\n 1. \\<And>a l1 r1 l2 r2 sr1 sr2.\n       \\<lbrakk>\\<And>b l1 r1 l2 r2 sr1 sr2.\n                   \\<lbrakk>(a, b)\n                            \\<in> inv_image\n                                   {(x, y).\n                                    0 \\<le> y \\<and> delta_gt delta x y}\n                                   real_of_rat;\n                    b = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n                    Ex1 (root_cond (p2, l2, r2));\n                    x = real_of_1 (p1, l1, r1); y = real_of_1 (p2, l2, r2);\n                    sr1 = sgn (ipoly p1 r1);\n                    sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n                   \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n                                     compare x y;\n        a = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n        Ex1 (root_cond (p2, l2, r2)); x = real_of_1 (p1, l1, r1);\n        y = real_of_1 (p2, l2, r2); sr1 = sgn (ipoly p1 r1);\n        sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n       \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "note urx = unique_rootD[OF ur(1), folded xy]"], ["proof (state)\nthis:\n  real_of_rat (rai_lb (p1, l1, r1)) \\<le> x\n  x \\<le> real_of_rat (rai_ub (p1, l1, r1))\n  poly (real_of_int_poly (poly_real_alg_1 (p1, l1, r1))) x = 0\n  root_cond (p1, l1, r1) x\n  (x = ?y) = root_cond (p1, l1, r1) ?y\n  (?y = x) = root_cond (p1, l1, r1) ?y\n\ngoal (1 subgoal):\n 1. \\<And>a l1 r1 l2 r2 sr1 sr2.\n       \\<lbrakk>\\<And>b l1 r1 l2 r2 sr1 sr2.\n                   \\<lbrakk>(a, b)\n                            \\<in> inv_image\n                                   {(x, y).\n                                    0 \\<le> y \\<and> delta_gt delta x y}\n                                   real_of_rat;\n                    b = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n                    Ex1 (root_cond (p2, l2, r2));\n                    x = real_of_1 (p1, l1, r1); y = real_of_1 (p2, l2, r2);\n                    sr1 = sgn (ipoly p1 r1);\n                    sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n                   \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n                                     compare x y;\n        a = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n        Ex1 (root_cond (p2, l2, r2)); x = real_of_1 (p1, l1, r1);\n        y = real_of_1 (p2, l2, r2); sr1 = sgn (ipoly p1 r1);\n        sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n       \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "note ury = unique_rootD[OF ur(2), folded xy]"], ["proof (state)\nthis:\n  real_of_rat (rai_lb (p2, l2, r2)) \\<le> y\n  y \\<le> real_of_rat (rai_ub (p2, l2, r2))\n  poly (real_of_int_poly (poly_real_alg_1 (p2, l2, r2))) y = 0\n  root_cond (p2, l2, r2) y\n  (y = ?y) = root_cond (p2, l2, r2) ?y\n  (?y = y) = root_cond (p2, l2, r2) ?y\n\ngoal (1 subgoal):\n 1. \\<And>a l1 r1 l2 r2 sr1 sr2.\n       \\<lbrakk>\\<And>b l1 r1 l2 r2 sr1 sr2.\n                   \\<lbrakk>(a, b)\n                            \\<in> inv_image\n                                   {(x, y).\n                                    0 \\<le> y \\<and> delta_gt delta x y}\n                                   real_of_rat;\n                    b = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n                    Ex1 (root_cond (p2, l2, r2));\n                    x = real_of_1 (p1, l1, r1); y = real_of_1 (p2, l2, r2);\n                    sr1 = sgn (ipoly p1 r1);\n                    sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n                   \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n                                     compare x y;\n        a = r1 - l1 + (r2 - l2); Ex1 (root_cond (p1, l1, r1));\n        Ex1 (root_cond (p2, l2, r2)); x = real_of_1 (p1, l1, r1);\n        y = real_of_1 (p2, l2, r2); sr1 = sgn (ipoly p1 r1);\n        sr2 = sgn (ipoly p2 r2)\\<rbrakk>\n       \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "show ?case (is \"?l = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "proof (cases \"r1 < l2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r1 < l2 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y\n 2. \\<not> r1 < l2 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "case True"], ["proof (state)\nthis:\n  r1 < l2\n\ngoal (2 subgoals):\n 1. r1 < l2 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y\n 2. \\<not> r1 < l2 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "hence l: \"?l = Lt\" and lt: \"?r r1 < ?r l2\""], ["proof (prove)\nusing this:\n  r1 < l2\n\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = Lt &&&\n    real_of_rat r1 < real_of_rat l2", "unfolding simps of_rat_less"], ["proof (prove)\nusing this:\n  r1 < l2\n\ngoal (1 subgoal):\n 1. (if r1 < l2 then Lt\n     else if r2 < l1 then Gt\n          else let (l1', r1', sr1') = tighten_poly_bounds p1 l1 r1 sr1;\n                   (l2', x, y) = tighten_poly_bounds p2 l2 r2 sr2\n               in compare_1 p1 p2 l1' r1' sr1' l2' x y) =\n    Lt &&&\n    r1 < l2", "by auto"], ["proof (state)\nthis:\n  compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = Lt\n  real_of_rat r1 < real_of_rat l2\n\ngoal (2 subgoals):\n 1. r1 < l2 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y\n 2. \\<not> r1 < l2 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "unfolding l"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lt = compare x y", "using lt True urx(2) ury(1)"], ["proof (prove)\nusing this:\n  real_of_rat r1 < real_of_rat l2\n  r1 < l2\n  x \\<le> real_of_rat (rai_ub (p1, l1, r1))\n  real_of_rat (rai_lb (p2, l2, r2)) \\<le> y\n\ngoal (1 subgoal):\n 1. Lt = compare x y", "by (auto simp: compare_real_def comparator_of_def)"], ["proof (state)\nthis:\n  compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y\n\ngoal (1 subgoal):\n 1. \\<not> r1 < l2 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> r1 < l2 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "case False"], ["proof (state)\nthis:\n  \\<not> r1 < l2\n\ngoal (1 subgoal):\n 1. \\<not> r1 < l2 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "note le = this"], ["proof (state)\nthis:\n  \\<not> r1 < l2\n\ngoal (1 subgoal):\n 1. \\<not> r1 < l2 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "proof (cases \"r2 < l1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y\n 2. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "case True"], ["proof (state)\nthis:\n  r2 < l1\n\ngoal (2 subgoals):\n 1. r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y\n 2. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "with le"], ["proof (chain)\npicking this:\n  \\<not> r1 < l2\n  r2 < l1", "have l: \"?l = Gt\" and lt: \"?r r2 < ?r l1\""], ["proof (prove)\nusing this:\n  \\<not> r1 < l2\n  r2 < l1\n\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = Gt &&&\n    real_of_rat r2 < real_of_rat l1", "unfolding simps of_rat_less"], ["proof (prove)\nusing this:\n  \\<not> r1 < l2\n  r2 < l1\n\ngoal (1 subgoal):\n 1. (if r1 < l2 then Lt\n     else if r2 < l1 then Gt\n          else let (l1', r1', sr1') = tighten_poly_bounds p1 l1 r1 sr1;\n                   (l2', x, y) = tighten_poly_bounds p2 l2 r2 sr2\n               in compare_1 p1 p2 l1' r1' sr1' l2' x y) =\n    Gt &&&\n    r2 < l1", "by auto"], ["proof (state)\nthis:\n  compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = Gt\n  real_of_rat r2 < real_of_rat l1\n\ngoal (2 subgoals):\n 1. r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y\n 2. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "unfolding l"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gt = compare x y", "using lt True ury(2) urx(1)"], ["proof (prove)\nusing this:\n  real_of_rat r2 < real_of_rat l1\n  r2 < l1\n  y \\<le> real_of_rat (rai_ub (p2, l2, r2))\n  real_of_rat (rai_lb (p1, l1, r1)) \\<le> x\n\ngoal (1 subgoal):\n 1. Gt = compare x y", "by (auto simp: compare_real_def comparator_of_def)"], ["proof (state)\nthis:\n  compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "case False"], ["proof (state)\nthis:\n  \\<not> r2 < l1\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "obtain l1' r1' sr1' where tb1: \"tighten_poly_bounds p1 l1 r1 sr1 = (l1',r1',sr1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l1' r1' sr1'.\n        tighten_poly_bounds p1 l1 r1 sr1 =\n        (l1', r1', sr1') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases rule: prod_cases3, auto)"], ["proof (state)\nthis:\n  tighten_poly_bounds p1 l1 r1 sr1 = (l1', r1', sr1')\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "obtain l2' r2' sr2' where tb2: \"tighten_poly_bounds p2 l2 r2 sr2 = (l2',r2',sr2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l2' r2' sr2'.\n        tighten_poly_bounds p2 l2 r2 sr2 =\n        (l2', r2', sr2') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases rule: prod_cases3, auto)"], ["proof (state)\nthis:\n  tighten_poly_bounds p2 l2 r2 sr2 = (l2', r2', sr2')\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "from False le tb1 tb2"], ["proof (chain)\npicking this:\n  \\<not> r2 < l1\n  \\<not> r1 < l2\n  tighten_poly_bounds p1 l1 r1 sr1 = (l1', r1', sr1')\n  tighten_poly_bounds p2 l2 r2 sr2 = (l2', r2', sr2')", "have l: \"?l = compare_1 p1 p2 l1' r1' sr1' l2' r2' sr2'\""], ["proof (prove)\nusing this:\n  \\<not> r2 < l1\n  \\<not> r1 < l2\n  tighten_poly_bounds p1 l1 r1 sr1 = (l1', r1', sr1')\n  tighten_poly_bounds p2 l2 r2 sr2 = (l2', r2', sr2')\n\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare_1 p1 p2 l1' r1' sr1' l2' r2' sr2'", "unfolding simps"], ["proof (prove)\nusing this:\n  \\<not> r2 < l1\n  \\<not> r1 < l2\n  tighten_poly_bounds p1 l1 r1 sr1 = (l1', r1', sr1')\n  tighten_poly_bounds p2 l2 r2 sr2 = (l2', r2', sr2')\n\ngoal (1 subgoal):\n 1. (if r1 < l2 then Lt\n     else if r2 < l1 then Gt\n          else let (l1', r1', sr1') = tighten_poly_bounds p1 l1 r1 sr1;\n                   (l2', x, y) = tighten_poly_bounds p2 l2 r2 sr2\n               in compare_1 p1 p2 l1' r1' sr1' l2' x y) =\n    compare_1 p1 p2 l1' r1' sr1' l2' r2' sr2'", "by auto"], ["proof (state)\nthis:\n  compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n  compare_1 p1 p2 l1' r1' sr1' l2' r2' sr2'\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "from tighten_poly_bounds[OF tb1 ur(1) pc(1) sr(1)]"], ["proof (chain)\npicking this:\n  root_cond (p1, l1', r1') (real_of_1 (p1, l1, r1))\n  l1 \\<le> l1'\n  l1' \\<le> r1'\n  r1' \\<le> r1\n  r1' - l1' = (r1 - l1) / 2\n  sr1' = sgn (ipoly p1 r1')", "have rc1: \"root_cond (p1, l1', r1') (the_unique_root (p1, l1, r1))\" \n            and bnd1: \"l1 \\<le> l1'\" \"l1' \\<le> r1'\" \"r1' \\<le> r1\" and d1: \"r1' - l1' = (r1 - l1) / 2\" \n            and sr1: \"sr1' = sgn (ipoly p1 r1')\""], ["proof (prove)\nusing this:\n  root_cond (p1, l1', r1') (real_of_1 (p1, l1, r1))\n  l1 \\<le> l1'\n  l1' \\<le> r1'\n  r1' \\<le> r1\n  r1' - l1' = (r1 - l1) / 2\n  sr1' = sgn (ipoly p1 r1')\n\ngoal (1 subgoal):\n 1. (root_cond (p1, l1', r1') (real_of_1 (p1, l1, r1)) &&&\n     l1 \\<le> l1' &&& l1' \\<le> r1' &&& r1' \\<le> r1) &&&\n    r1' - l1' = (r1 - l1) / 2 &&& sr1' = sgn (ipoly p1 r1')", "by auto"], ["proof (state)\nthis:\n  root_cond (p1, l1', r1') (real_of_1 (p1, l1, r1))\n  l1 \\<le> l1'\n  l1' \\<le> r1'\n  r1' \\<le> r1\n  r1' - l1' = (r1 - l1) / 2\n  sr1' = sgn (ipoly p1 r1')\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "from pc"], ["proof (chain)\npicking this:\n  poly_cond2 p1\n  poly_cond2 p2", "have \"p1 \\<noteq> 0\" \"p2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly_cond2 p1\n  poly_cond2 p2\n\ngoal (1 subgoal):\n 1. p1 \\<noteq> 0 &&& p2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p1 \\<noteq> 0\n  p2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "from unique_root_sub_interval[OF ur(1) rc1 bnd1(1,3)] xy ur this"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond (p1, l1', r1') x\n  real_of_1 (p1, l1', r1') = real_of_1 (p1, l1, r1)\n  x = real_of_1 (p1, l1, r1)\n  y = real_of_1 (p2, l2, r2)\n  \\<exists>!a. root_cond (p1, l1, r1) a\n  \\<exists>!a. root_cond (p2, l2, r2) a\n  p1 \\<noteq> 0\n  p2 \\<noteq> 0", "have ur1: \"unique_root (p1, l1', r1')\" and x: \"x = the_unique_root (p1, l1', r1')\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond (p1, l1', r1') x\n  real_of_1 (p1, l1', r1') = real_of_1 (p1, l1, r1)\n  x = real_of_1 (p1, l1, r1)\n  y = real_of_1 (p2, l2, r2)\n  \\<exists>!a. root_cond (p1, l1, r1) a\n  \\<exists>!a. root_cond (p2, l2, r2) a\n  p1 \\<noteq> 0\n  p2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p1, l1', r1') x &&& x = real_of_1 (p1, l1', r1')", "by (auto intro!: the_unique_root_eqI)"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p1, l1', r1') x\n  x = real_of_1 (p1, l1', r1')\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "from tighten_poly_bounds[OF tb2 ur(2) pc(2) sr(2)]"], ["proof (chain)\npicking this:\n  root_cond (p2, l2', r2') (real_of_1 (p2, l2, r2))\n  l2 \\<le> l2'\n  l2' \\<le> r2'\n  r2' \\<le> r2\n  r2' - l2' = (r2 - l2) / 2\n  sr2' = sgn (ipoly p2 r2')", "have rc2: \"root_cond (p2, l2', r2') (the_unique_root (p2, l2, r2))\" \n            and bnd2: \"l2 \\<le> l2'\" \"l2' \\<le> r2'\" \"r2' \\<le> r2\" and d2: \"r2' - l2' = (r2 - l2) / 2\" \n            and sr2: \"sr2' = sgn (ipoly p2 r2')\""], ["proof (prove)\nusing this:\n  root_cond (p2, l2', r2') (real_of_1 (p2, l2, r2))\n  l2 \\<le> l2'\n  l2' \\<le> r2'\n  r2' \\<le> r2\n  r2' - l2' = (r2 - l2) / 2\n  sr2' = sgn (ipoly p2 r2')\n\ngoal (1 subgoal):\n 1. (root_cond (p2, l2', r2') (real_of_1 (p2, l2, r2)) &&&\n     l2 \\<le> l2' &&& l2' \\<le> r2' &&& r2' \\<le> r2) &&&\n    r2' - l2' = (r2 - l2) / 2 &&& sr2' = sgn (ipoly p2 r2')", "by auto"], ["proof (state)\nthis:\n  root_cond (p2, l2', r2') (real_of_1 (p2, l2, r2))\n  l2 \\<le> l2'\n  l2' \\<le> r2'\n  r2' \\<le> r2\n  r2' - l2' = (r2 - l2) / 2\n  sr2' = sgn (ipoly p2 r2')\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "from unique_root_sub_interval[OF ur(2) rc2 bnd2(1,3)] xy ur pc"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond (p2, l2', r2') x\n  real_of_1 (p2, l2', r2') = real_of_1 (p2, l2, r2)\n  x = real_of_1 (p1, l1, r1)\n  y = real_of_1 (p2, l2, r2)\n  \\<exists>!a. root_cond (p1, l1, r1) a\n  \\<exists>!a. root_cond (p2, l2, r2) a\n  poly_cond2 p1\n  poly_cond2 p2", "have ur2: \"unique_root (p2, l2', r2')\" and y: \"y = the_unique_root (p2, l2', r2')\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond (p2, l2', r2') x\n  real_of_1 (p2, l2', r2') = real_of_1 (p2, l2, r2)\n  x = real_of_1 (p1, l1, r1)\n  y = real_of_1 (p2, l2, r2)\n  \\<exists>!a. root_cond (p1, l1, r1) a\n  \\<exists>!a. root_cond (p2, l2, r2) a\n  poly_cond2 p1\n  poly_cond2 p2\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p2, l2', r2') x &&& y = real_of_1 (p2, l2', r2')", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p2, l2', r2') x\n  y = real_of_1 (p2, l2', r2')\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "define d' where \"d' = d/2\""], ["proof (state)\nthis:\n  d' = d / 2\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "have d': \"d' = r1' - l1' + (r2' - l2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d' = r1' - l1' + (r2' - l2')", "unfolding d'_def d d1 d2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (r1 - l1 + (r2 - l2)) / 2 = (r1 - l1) / 2 + (r2 - l2) / 2", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  d' = r1' - l1' + (r2' - l2')\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "have d'0: \"d' \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> d'", "using bnd1 bnd2"], ["proof (prove)\nusing this:\n  l1 \\<le> l1'\n  l1' \\<le> r1'\n  r1' \\<le> r1\n  l2 \\<le> l2'\n  l2' \\<le> r2'\n  r2' \\<le> r2\n\ngoal (1 subgoal):\n 1. 0 \\<le> d'", "unfolding d'"], ["proof (prove)\nusing this:\n  l1 \\<le> l1'\n  l1' \\<le> r1'\n  r1' \\<le> r1\n  l2 \\<le> l2'\n  l2' \\<le> r2'\n  r2' \\<le> r2\n\ngoal (1 subgoal):\n 1. 0 \\<le> r1' - l1' + (r2' - l2')", "by auto"], ["proof (state)\nthis:\n  0 \\<le> d'\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "have dd: \"d - d' = d/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d - d' = d / 2", "unfolding d'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d - d / 2 = d / 2", "by simp"], ["proof (state)\nthis:\n  d - d' = d / 2\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "have \"abs (x - y) \\<le> 2 * ?r d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d\n\ngoal (1 subgoal):\n 1. \\<not> \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d \\<Longrightarrow> False", "hence lt: \"2 * ?r d < abs (x - y)\""], ["proof (prove)\nusing this:\n  \\<not> \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d\n\ngoal (1 subgoal):\n 1. 2 * real_of_rat d < \\<bar>x - y\\<bar>", "by auto"], ["proof (state)\nthis:\n  2 * real_of_rat d < \\<bar>x - y\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d \\<Longrightarrow> False", "have \"r1 - l1 \\<le> d\" \"r2 - l2 \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r1 - l1 \\<le> d &&& r2 - l2 \\<le> d", "unfolding d"], ["proof (prove)\ngoal (1 subgoal):\n 1. r1 - l1 \\<le> r1 - l1 + (r2 - l2) &&& r2 - l2 \\<le> r1 - l1 + (r2 - l2)", "using bnd1 bnd2"], ["proof (prove)\nusing this:\n  l1 \\<le> l1'\n  l1' \\<le> r1'\n  r1' \\<le> r1\n  l2 \\<le> l2'\n  l2' \\<le> r2'\n  r2' \\<le> r2\n\ngoal (1 subgoal):\n 1. r1 - l1 \\<le> r1 - l1 + (r2 - l2) &&& r2 - l2 \\<le> r1 - l1 + (r2 - l2)", "by auto"], ["proof (state)\nthis:\n  r1 - l1 \\<le> d\n  r2 - l2 \\<le> d\n\ngoal (1 subgoal):\n 1. \\<not> \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d \\<Longrightarrow> False", "from this[folded of_rat_less_eq[where 'a = real]] lt"], ["proof (chain)\npicking this:\n  real_of_rat (r1 - l1) \\<le> real_of_rat d\n  real_of_rat (r2 - l2) \\<le> real_of_rat d\n  2 * real_of_rat d < \\<bar>x - y\\<bar>", "have \"?r (r1 - l1) < abs (x - y) / 2\" \"?r (r2 - l2) < abs (x - y) / 2\" \n              and dd: \"?r r1 - ?r l1 \\<le> ?r d\" \"?r r2 - ?r l2 \\<le> ?r d\""], ["proof (prove)\nusing this:\n  real_of_rat (r1 - l1) \\<le> real_of_rat d\n  real_of_rat (r2 - l2) \\<le> real_of_rat d\n  2 * real_of_rat d < \\<bar>x - y\\<bar>\n\ngoal (1 subgoal):\n 1. (real_of_rat (r1 - l1) < \\<bar>x - y\\<bar> / 2 &&&\n     real_of_rat (r2 - l2) < \\<bar>x - y\\<bar> / 2) &&&\n    real_of_rat r1 - real_of_rat l1 \\<le> real_of_rat d &&&\n    real_of_rat r2 - real_of_rat l2 \\<le> real_of_rat d", "by (auto simp: of_rat_diff)"], ["proof (state)\nthis:\n  real_of_rat (r1 - l1) < \\<bar>x - y\\<bar> / 2\n  real_of_rat (r2 - l2) < \\<bar>x - y\\<bar> / 2\n  real_of_rat r1 - real_of_rat l1 \\<le> real_of_rat d\n  real_of_rat r2 - real_of_rat l2 \\<le> real_of_rat d\n\ngoal (1 subgoal):\n 1. \\<not> \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d \\<Longrightarrow> False", "from le"], ["proof (chain)\npicking this:\n  \\<not> r1 < l2", "have \"r1 \\<ge> l2\""], ["proof (prove)\nusing this:\n  \\<not> r1 < l2\n\ngoal (1 subgoal):\n 1. l2 \\<le> r1", "by auto"], ["proof (state)\nthis:\n  l2 \\<le> r1\n\ngoal (1 subgoal):\n 1. \\<not> \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d \\<Longrightarrow> False", "hence r1l2: \"?r r1 \\<ge> ?r l2\""], ["proof (prove)\nusing this:\n  l2 \\<le> r1\n\ngoal (1 subgoal):\n 1. real_of_rat l2 \\<le> real_of_rat r1", "unfolding of_rat_less_eq"], ["proof (prove)\nusing this:\n  l2 \\<le> r1\n\ngoal (1 subgoal):\n 1. l2 \\<le> r1", "by auto"], ["proof (state)\nthis:\n  real_of_rat l2 \\<le> real_of_rat r1\n\ngoal (1 subgoal):\n 1. \\<not> \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d \\<Longrightarrow> False", "from False"], ["proof (chain)\npicking this:\n  \\<not> r2 < l1", "have \"r2 \\<ge> l1\""], ["proof (prove)\nusing this:\n  \\<not> r2 < l1\n\ngoal (1 subgoal):\n 1. l1 \\<le> r2", "by auto"], ["proof (state)\nthis:\n  l1 \\<le> r2\n\ngoal (1 subgoal):\n 1. \\<not> \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d \\<Longrightarrow> False", "hence r2l1: \"?r r2 \\<ge> ?r l1\""], ["proof (prove)\nusing this:\n  l1 \\<le> r2\n\ngoal (1 subgoal):\n 1. real_of_rat l1 \\<le> real_of_rat r2", "unfolding of_rat_less_eq"], ["proof (prove)\nusing this:\n  l1 \\<le> r2\n\ngoal (1 subgoal):\n 1. l1 \\<le> r2", "by auto"], ["proof (state)\nthis:\n  real_of_rat l1 \\<le> real_of_rat r2\n\ngoal (1 subgoal):\n 1. \\<not> \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"x \\<le> y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> False\n 2. \\<not> x \\<le> y \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> False\n 2. \\<not> x \\<le> y \\<Longrightarrow> False", "from urx(1-2) dd(1)"], ["proof (chain)\npicking this:\n  real_of_rat (rai_lb (p1, l1, r1)) \\<le> x\n  x \\<le> real_of_rat (rai_ub (p1, l1, r1))\n  real_of_rat r1 - real_of_rat l1 \\<le> real_of_rat d", "have \"?r r1 \\<le> x + ?r d\""], ["proof (prove)\nusing this:\n  real_of_rat (rai_lb (p1, l1, r1)) \\<le> x\n  x \\<le> real_of_rat (rai_ub (p1, l1, r1))\n  real_of_rat r1 - real_of_rat l1 \\<le> real_of_rat d\n\ngoal (1 subgoal):\n 1. real_of_rat r1 \\<le> x + real_of_rat d", "by auto"], ["proof (state)\nthis:\n  real_of_rat r1 \\<le> x + real_of_rat d\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> False\n 2. \\<not> x \\<le> y \\<Longrightarrow> False", "with r1l2"], ["proof (chain)\npicking this:\n  real_of_rat l2 \\<le> real_of_rat r1\n  real_of_rat r1 \\<le> x + real_of_rat d", "have \"?r l2 \\<le> x + ?r d\""], ["proof (prove)\nusing this:\n  real_of_rat l2 \\<le> real_of_rat r1\n  real_of_rat r1 \\<le> x + real_of_rat d\n\ngoal (1 subgoal):\n 1. real_of_rat l2 \\<le> x + real_of_rat d", "by auto"], ["proof (state)\nthis:\n  real_of_rat l2 \\<le> x + real_of_rat d\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> False\n 2. \\<not> x \\<le> y \\<Longrightarrow> False", "with True lt ury(2) dd(2)"], ["proof (chain)\npicking this:\n  x \\<le> y\n  2 * real_of_rat d < \\<bar>x - y\\<bar>\n  y \\<le> real_of_rat (rai_ub (p2, l2, r2))\n  real_of_rat r2 - real_of_rat l2 \\<le> real_of_rat d\n  real_of_rat l2 \\<le> x + real_of_rat d", "show False"], ["proof (prove)\nusing this:\n  x \\<le> y\n  2 * real_of_rat d < \\<bar>x - y\\<bar>\n  y \\<le> real_of_rat (rai_ub (p2, l2, r2))\n  real_of_rat r2 - real_of_rat l2 \\<le> real_of_rat d\n  real_of_rat l2 \\<le> x + real_of_rat d\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> False", "from ury(1-2) dd(2)"], ["proof (chain)\npicking this:\n  real_of_rat (rai_lb (p2, l2, r2)) \\<le> y\n  y \\<le> real_of_rat (rai_ub (p2, l2, r2))\n  real_of_rat r2 - real_of_rat l2 \\<le> real_of_rat d", "have \"?r r2 \\<le> y + ?r d\""], ["proof (prove)\nusing this:\n  real_of_rat (rai_lb (p2, l2, r2)) \\<le> y\n  y \\<le> real_of_rat (rai_ub (p2, l2, r2))\n  real_of_rat r2 - real_of_rat l2 \\<le> real_of_rat d\n\ngoal (1 subgoal):\n 1. real_of_rat r2 \\<le> y + real_of_rat d", "by auto"], ["proof (state)\nthis:\n  real_of_rat r2 \\<le> y + real_of_rat d\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> False", "with r2l1"], ["proof (chain)\npicking this:\n  real_of_rat l1 \\<le> real_of_rat r2\n  real_of_rat r2 \\<le> y + real_of_rat d", "have \"?r l1 \\<le> y + ?r d\""], ["proof (prove)\nusing this:\n  real_of_rat l1 \\<le> real_of_rat r2\n  real_of_rat r2 \\<le> y + real_of_rat d\n\ngoal (1 subgoal):\n 1. real_of_rat l1 \\<le> y + real_of_rat d", "by auto"], ["proof (state)\nthis:\n  real_of_rat l1 \\<le> y + real_of_rat d\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> False", "with False lt urx(2) dd(1)"], ["proof (chain)\npicking this:\n  \\<not> x \\<le> y\n  2 * real_of_rat d < \\<bar>x - y\\<bar>\n  x \\<le> real_of_rat (rai_ub (p1, l1, r1))\n  real_of_rat r1 - real_of_rat l1 \\<le> real_of_rat d\n  real_of_rat l1 \\<le> y + real_of_rat d", "show False"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> y\n  2 * real_of_rat d < \\<bar>x - y\\<bar>\n  x \\<le> real_of_rat (rai_ub (p1, l1, r1))\n  real_of_rat r1 - real_of_rat l1 \\<le> real_of_rat d\n  real_of_rat l1 \\<le> y + real_of_rat d\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "hence dd': \"delta_gt delta (?r d) (?r d')\""], ["proof (prove)\nusing this:\n  \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d\n\ngoal (1 subgoal):\n 1. delta_gt delta (real_of_rat d) (real_of_rat d')", "unfolding delta_gt_def delta_def"], ["proof (prove)\nusing this:\n  \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d\n\ngoal (1 subgoal):\n 1. \\<bar>x - y\\<bar> / 4 \\<le> real_of_rat d - real_of_rat d'", "using dd"], ["proof (prove)\nusing this:\n  \\<bar>x - y\\<bar> \\<le> 2 * real_of_rat d\n  d - d' = d / 2\n\ngoal (1 subgoal):\n 1. \\<bar>x - y\\<bar> / 4 \\<le> real_of_rat d - real_of_rat d'", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  delta_gt delta (real_of_rat d) (real_of_rat d')\n\ngoal (1 subgoal):\n 1. \\<not> r2 < l1 \\<Longrightarrow>\n    compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y", "unfolding l"], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1' r1' sr1' l2' r2' sr2' = compare x y", "by (rule IH[OF _ d' ur1 ur2 x y sr1 sr2], insert d'0 dd', auto)"], ["proof (state)\nthis:\n  compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 = compare x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n  compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?d2 = r1 - l1 + (r2 - l2); ?x2 = real_of_1 (p1, l1, r1);\n   ?y2 = real_of_1 (p2, l2, r2)\\<rbrakk>\n  \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n                    compare (real_of_1 (p1, l1, r1))\n                     (real_of_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?d2 = r1 - l1 + (r2 - l2); ?x2 = real_of_1 (p1, l1, r1);\n   ?y2 = real_of_1 (p2, l2, r2)\\<rbrakk>\n  \\<Longrightarrow> compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n                    compare (real_of_1 (p1, l1, r1))\n                     (real_of_1 (p2, l2, r2))\n\ngoal (1 subgoal):\n 1. compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n    compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))", "by auto"], ["proof (state)\nthis:\n  compare_1 p1 p2 l1 r1 sr1 l2 r2 sr2 =\n  compare (real_of_1 (p1, l1, r1)) (real_of_1 (p2, l2, r2))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* **************************************************************** *)"], ["", "fun real_alg_1 :: \"real_alg_2 \\<Rightarrow> real_alg_1\" where\n  \"real_alg_1 (Rational r) = of_rat_1 r\"\n| \"real_alg_1 (Irrational n rai) = rai\""], ["", "lemma real_alg_1: \"real_of_1 (real_alg_1 x) = real_of_2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 (real_alg_1 x) = real_of_2 x", "by (cases x, auto simp: of_rat_1)"], ["", "definition root_2 :: \"nat \\<Rightarrow> real_alg_2 \\<Rightarrow> real_alg_2\" where\n  \"root_2 n x = root_1 n (real_alg_1 x)\""], ["", "lemma root_2: assumes \"invariant_2 x\"\n  shows \"real_of_2 (root_2 n x) = root n (real_of_2 x)\"\n  \"invariant_2 (root_2 n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 (root_2 n x) = root n (real_of_2 x) &&&\n    invariant_2 (root_2 n x)", "proof (atomize(full), cases x, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       real_of_2 (root_2 n x) = root n (real_of_2 x) \\<and>\n       invariant_2 (root_2 n x)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       real_of_2 (root_2 n x) = root n (real_of_2 x) \\<and>\n       invariant_2 (root_2 n x)", "case (1 y)"], ["proof (state)\nthis:\n  x = Rational y\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       real_of_2 (root_2 n x) = root n (real_of_2 x) \\<and>\n       invariant_2 (root_2 n x)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       real_of_2 (root_2 n x) = root n (real_of_2 x) \\<and>\n       invariant_2 (root_2 n x)", "from of_rat_1[of y] root_1[of \"of_rat_1 y\" n] assms 1 real_alg_2"], ["proof (chain)\npicking this:\n  invariant_1 (of_rat_1 y)\n  real_of_1 (of_rat_1 y) = real_of_rat y\n  invariant_1 (of_rat_1 y) \\<Longrightarrow>\n  invariant_2 (root_1 n (of_rat_1 y)) \\<and>\n  real_of_2 (root_1 n (of_rat_1 y)) = root n (real_of_1 (of_rat_1 y))\n  invariant_2 x\n  x = Rational y\n  invariant_1 ?rai \\<Longrightarrow> invariant_2 (real_alg_2 ?rai)\n  invariant_1 ?rai \\<Longrightarrow>\n  real_of_2 (real_alg_2 ?rai) = real_of_1 ?rai", "show ?case"], ["proof (prove)\nusing this:\n  invariant_1 (of_rat_1 y)\n  real_of_1 (of_rat_1 y) = real_of_rat y\n  invariant_1 (of_rat_1 y) \\<Longrightarrow>\n  invariant_2 (root_1 n (of_rat_1 y)) \\<and>\n  real_of_2 (root_1 n (of_rat_1 y)) = root n (real_of_1 (of_rat_1 y))\n  invariant_2 x\n  x = Rational y\n  invariant_1 ?rai \\<Longrightarrow> invariant_2 (real_alg_2 ?rai)\n  invariant_1 ?rai \\<Longrightarrow>\n  real_of_2 (real_alg_2 ?rai) = real_of_1 ?rai\n\ngoal (1 subgoal):\n 1. real_of_2 (root_2 n x) = root n (real_of_2 x) \\<and>\n    invariant_2 (root_2 n x)", "by (simp add: root_2_def)"], ["proof (state)\nthis:\n  real_of_2 (root_2 n x) = root n (real_of_2 x) \\<and>\n  invariant_2 (root_2 n x)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       real_of_2 (root_2 n x) = root n (real_of_2 x) \\<and>\n       invariant_2 (root_2 n x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       real_of_2 (root_2 n x) = root n (real_of_2 x) \\<and>\n       invariant_2 (root_2 n x)", "case (2 i rai)"], ["proof (state)\nthis:\n  x = Irrational i rai\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       real_of_2 (root_2 n x) = root n (real_of_2 x) \\<and>\n       invariant_2 (root_2 n x)", "from root_1[of rai n] assms 2 real_alg_2"], ["proof (chain)\npicking this:\n  invariant_1 rai \\<Longrightarrow>\n  invariant_2 (root_1 n rai) \\<and>\n  real_of_2 (root_1 n rai) = root n (real_of_1 rai)\n  invariant_2 x\n  x = Irrational i rai\n  invariant_1 ?rai \\<Longrightarrow> invariant_2 (real_alg_2 ?rai)\n  invariant_1 ?rai \\<Longrightarrow>\n  real_of_2 (real_alg_2 ?rai) = real_of_1 ?rai", "show ?case"], ["proof (prove)\nusing this:\n  invariant_1 rai \\<Longrightarrow>\n  invariant_2 (root_1 n rai) \\<and>\n  real_of_2 (root_1 n rai) = root n (real_of_1 rai)\n  invariant_2 x\n  x = Irrational i rai\n  invariant_1 ?rai \\<Longrightarrow> invariant_2 (real_alg_2 ?rai)\n  invariant_1 ?rai \\<Longrightarrow>\n  real_of_2 (real_alg_2 ?rai) = real_of_1 ?rai\n\ngoal (1 subgoal):\n 1. real_of_2 (root_2 n x) = root n (real_of_2 x) \\<and>\n    invariant_2 (root_2 n x)", "by (auto simp: root_2_def)"], ["proof (state)\nthis:\n  real_of_2 (root_2 n x) = root n (real_of_2 x) \\<and>\n  invariant_2 (root_2 n x)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun add_2 :: \"real_alg_2 \\<Rightarrow> real_alg_2 \\<Rightarrow> real_alg_2\" where\n  \"add_2 (Rational r) (Rational q) = Rational (r + q)\"\n| \"add_2 (Rational r) (Irrational n x) = Irrational n (add_rat_1 r x)\"\n| \"add_2 (Irrational n x) (Rational q) = Irrational n (add_rat_1 q x)\"\n| \"add_2 (Irrational n x) (Irrational m y) = add_1 x y\""], ["", "lemma add_2: assumes x: \"invariant_2 x\" and y: \"invariant_2 y\" \n  shows \"invariant_2 (add_2 x y)\" (is ?g1)\n    and \"real_of_2 (add_2 x y) = real_of_2 x + real_of_2 y\" (is ?g2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 (add_2 x y) &&&\n    real_of_2 (add_2 x y) = real_of_2 x + real_of_2 y", "using assms add_rat_1 add_1"], ["proof (prove)\nusing this:\n  invariant_2 x\n  invariant_2 y\n  invariant_1_2 ?y \\<Longrightarrow>\n  invariant_1_2 (add_rat_1 ?r1.0 ?y) \\<and>\n  real_of_1 (add_rat_1 ?r1.0 ?y) = real_of_rat ?r1.0 + real_of_1 ?y\n  \\<lbrakk>invariant_1_2 ?x; invariant_1_2 ?y\\<rbrakk>\n  \\<Longrightarrow> invariant_2 (add_1 ?x ?y) \\<and>\n                    real_of_2 (add_1 ?x ?y) = real_of_1 ?x + real_of_1 ?y\n\ngoal (1 subgoal):\n 1. invariant_2 (add_2 x y) &&&\n    real_of_2 (add_2 x y) = real_of_2 x + real_of_2 y", "by (atomize (full), (cases x; cases y), auto simp: hom_distribs)"], ["", "fun mult_2 :: \"real_alg_2 \\<Rightarrow> real_alg_2 \\<Rightarrow> real_alg_2\" where\n  \"mult_2 (Rational r) (Rational q) = Rational (r * q)\"\n| \"mult_2 (Rational r) (Irrational n y) = mult_rat_1 r y\"\n| \"mult_2 (Irrational n x) (Rational q) = mult_rat_1 q x\"\n| \"mult_2 (Irrational n x) (Irrational m y) = mult_1 x y\""], ["", "lemma mult_2: assumes \"invariant_2 x\" \"invariant_2 y\"\n  shows \"real_of_2 (mult_2 x y) = real_of_2 x * real_of_2 y\"\n  \"invariant_2 (mult_2 x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 (mult_2 x y) = real_of_2 x * real_of_2 y &&&\n    invariant_2 (mult_2 x y)", "using assms"], ["proof (prove)\nusing this:\n  invariant_2 x\n  invariant_2 y\n\ngoal (1 subgoal):\n 1. real_of_2 (mult_2 x y) = real_of_2 x * real_of_2 y &&&\n    invariant_2 (mult_2 x y)", "by (atomize(full), (cases x; cases y; auto simp: mult_rat_1 mult_1 hom_distribs))"], ["", "fun to_rat_2 :: \"real_alg_2 \\<Rightarrow> rat option\" where\n  \"to_rat_2 (Rational r) = Some r\"\n| \"to_rat_2 (Irrational n rai) = None\""], ["", "lemma to_rat_2: assumes rc: \"invariant_2 x\" \n  shows \"to_rat_2 x = (if real_of_2 x \\<in> \\<rat> then Some (THE q. real_of_2 x = of_rat q) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_rat_2 x =\n    (if real_of_2 x \\<in> \\<rat>\n     then Some (THE q. real_of_2 x = real_of_rat q) else None)", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       to_rat_2 x =\n       (if real_of_2 x \\<in> \\<rat>\n        then Some (THE q. real_of_2 x = real_of_rat q) else None)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       to_rat_2 x =\n       (if real_of_2 x \\<in> \\<rat>\n        then Some (THE q. real_of_2 x = real_of_rat q) else None)", "case (Irrational n rai)"], ["proof (state)\nthis:\n  x = Irrational n rai\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       to_rat_2 x =\n       (if real_of_2 x \\<in> \\<rat>\n        then Some (THE q. real_of_2 x = real_of_rat q) else None)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       to_rat_2 x =\n       (if real_of_2 x \\<in> \\<rat>\n        then Some (THE q. real_of_2 x = real_of_rat q) else None)", "from real_of_2_Irrational[OF rc[unfolded this]]"], ["proof (chain)\npicking this:\n  real_of_2 (Irrational n rai) \\<noteq> real_of_rat ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_2 (Irrational n rai) \\<noteq> real_of_rat ?x\n\ngoal (1 subgoal):\n 1. to_rat_2 x =\n    (if real_of_2 x \\<in> \\<rat>\n     then Some (THE q. real_of_2 x = real_of_rat q) else None)", "unfolding Irrational Rats_def"], ["proof (prove)\nusing this:\n  real_of_2 (Irrational n rai) \\<noteq> real_of_rat ?x\n\ngoal (1 subgoal):\n 1. to_rat_2 (Irrational n rai) =\n    (if real_of_2 (Irrational n rai) \\<in> range real_of_rat\n     then Some (THE q. real_of_2 (Irrational n rai) = real_of_rat q)\n     else None)", "by auto"], ["proof (state)\nthis:\n  to_rat_2 x =\n  (if real_of_2 x \\<in> \\<rat>\n   then Some (THE q. real_of_2 x = real_of_rat q) else None)\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       to_rat_2 x =\n       (if real_of_2 x \\<in> \\<rat>\n        then Some (THE q. real_of_2 x = real_of_rat q) else None)", "qed simp"], ["", "fun equal_2 :: \"real_alg_2 \\<Rightarrow> real_alg_2 \\<Rightarrow> bool\" where\n  \"equal_2 (Rational r) (Rational q) = (r = q)\" \n| \"equal_2 (Irrational n (p,_)) (Irrational m (q,_)) = (p = q \\<and> n = m)\"\n| \"equal_2 (Rational r) (Irrational _ yy) = False\"\n| \"equal_2 (Irrational _ xx) (Rational q) = False\""], ["", "lemma equal_2[simp]: assumes rc: \"invariant_2 x\" \"invariant_2 y\" \n  shows \"equal_2 x y = (real_of_2 x = real_of_2 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_2 x y = (real_of_2 x = real_of_2 y)", "using info_2[OF rc]"], ["proof (prove)\nusing this:\n  (info_2 x = info_2 y) = (real_of_2 x = real_of_2 y)\n\ngoal (1 subgoal):\n 1. equal_2 x y = (real_of_2 x = real_of_2 y)", "by (cases x; cases y, auto)"], ["", "fun compare_2 :: \"real_alg_2 \\<Rightarrow> real_alg_2 \\<Rightarrow> order\" where \n  \"compare_2 (Rational r) (Rational q) = (compare r q)\"\n| \"compare_2 (Irrational n (p,l,r)) (Irrational m (q,l',r')) = (if p = q \\<and> n = m then Eq\n    else compare_1 p q l r (sgn (ipoly p r)) l' r' (sgn (ipoly q r')))\" \n| \"compare_2 (Rational r) (Irrational _ xx) = (compare_rat_1 r xx)\"\n| \"compare_2 (Irrational _ xx) (Rational r) = (invert_order (compare_rat_1 r xx))\""], ["", "lemma compare_2: assumes rc: \"invariant_2 x\" \"invariant_2 y\"\n  shows \"compare_2 x y = compare (real_of_2 x) (real_of_2 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "case (Rational r)"], ["proof (state)\nthis:\n  x = Rational r\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "note xx = this"], ["proof (state)\nthis:\n  x = Rational r\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       y = Rational x1 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n 2. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "case (Rational q)"], ["proof (state)\nthis:\n  y = Rational q\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       y = Rational x1 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n 2. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "note yy = this"], ["proof (state)\nthis:\n  y = Rational q\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       y = Rational x1 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n 2. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "unfolding xx yy"], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_2 (Rational r) (Rational q) =\n    compare (real_of_2 (Rational r)) (real_of_2 (Rational q))", "by (simp add: compare_rat_def compare_real_def comparator_of_def of_rat_less)"], ["proof (state)\nthis:\n  compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "case (Irrational n yy)"], ["proof (state)\nthis:\n  y = Irrational n yy\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "note yy = this"], ["proof (state)\nthis:\n  y = Irrational n yy\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "from compare_rat_1 rc"], ["proof (chain)\npicking this:\n  invariant_1_2 ?y \\<Longrightarrow>\n  compare_rat_1 ?x ?y = compare (real_of_rat ?x) (real_of_1 ?y)\n  invariant_2 x\n  invariant_2 y", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant_1_2 ?y \\<Longrightarrow>\n  compare_rat_1 ?x ?y = compare (real_of_rat ?x) (real_of_1 ?y)\n  invariant_2 x\n  invariant_2 y\n\ngoal (1 subgoal):\n 1. compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "unfolding xx yy"], ["proof (prove)\nusing this:\n  invariant_1_2 ?y \\<Longrightarrow>\n  compare_rat_1 ?x ?y = compare (real_of_rat ?x) (real_of_1 ?y)\n  invariant_2 (Rational r)\n  invariant_2 (Irrational n yy)\n\ngoal (1 subgoal):\n 1. compare_2 (Rational r) (Irrational n yy) =\n    compare (real_of_2 (Rational r)) (real_of_2 (Irrational n yy))", "by (simp add: of_rat_1)"], ["proof (state)\nthis:\n  compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "case (Irrational n xx)"], ["proof (state)\nthis:\n  x = Irrational n xx\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "note xx = this"], ["proof (state)\nthis:\n  x = Irrational n xx\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       y = Rational x1 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n 2. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "case (Rational q)"], ["proof (state)\nthis:\n  y = Rational q\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       y = Rational x1 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n 2. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "note yy = this"], ["proof (state)\nthis:\n  y = Rational q\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       y = Rational x1 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n 2. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "from compare_rat_1 rc"], ["proof (chain)\npicking this:\n  invariant_1_2 ?y \\<Longrightarrow>\n  compare_rat_1 ?x ?y = compare (real_of_rat ?x) (real_of_1 ?y)\n  invariant_2 x\n  invariant_2 y", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant_1_2 ?y \\<Longrightarrow>\n  compare_rat_1 ?x ?y = compare (real_of_rat ?x) (real_of_1 ?y)\n  invariant_2 x\n  invariant_2 y\n\ngoal (1 subgoal):\n 1. compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "unfolding xx yy"], ["proof (prove)\nusing this:\n  invariant_1_2 ?y \\<Longrightarrow>\n  compare_rat_1 ?x ?y = compare (real_of_rat ?x) (real_of_1 ?y)\n  invariant_2 (Irrational n xx)\n  invariant_2 (Rational q)\n\ngoal (1 subgoal):\n 1. compare_2 (Irrational n xx) (Rational q) =\n    compare (real_of_2 (Irrational n xx)) (real_of_2 (Rational q))", "by simp"], ["proof (state)\nthis:\n  compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "case (Irrational m yy)"], ["proof (state)\nthis:\n  y = Irrational m yy\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "note yy = this"], ["proof (state)\nthis:\n  y = Irrational m yy\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "obtain p l r where xxx: \"xx = (p,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p l r. xx = (p, l, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases xx)"], ["proof (state)\nthis:\n  xx = (p, l, r)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "obtain q l' r' where yyy: \"yy = (q,l',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q l' r'.\n        yy = (q, l', r') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases yy)"], ["proof (state)\nthis:\n  yy = (q, l', r')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "note rc = rc[unfolded xx xxx yy yyy]"], ["proof (state)\nthis:\n  invariant_2 (Irrational n (p, l, r))\n  invariant_2 (Irrational m (q, l', r'))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "from rc"], ["proof (chain)\npicking this:\n  invariant_2 (Irrational n (p, l, r))\n  invariant_2 (Irrational m (q, l', r'))", "have I: \"invariant_1_2 (p,l,r)\" \"invariant_1_2 (q,l',r')\""], ["proof (prove)\nusing this:\n  invariant_2 (Irrational n (p, l, r))\n  invariant_2 (Irrational m (q, l', r'))\n\ngoal (1 subgoal):\n 1. invariant_1_2 (p, l, r) &&& invariant_1_2 (q, l', r')", "by auto"], ["proof (state)\nthis:\n  invariant_1_2 (p, l, r)\n  invariant_1_2 (q, l', r')\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "then"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l, r)\n  invariant_1_2 (q, l', r')", "have \"unique_root (p,l,r)\" \"unique_root (q,l',r')\" \"poly_cond2 p\" \"poly_cond2 q\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n  invariant_1_2 (q, l', r')\n\ngoal (1 subgoal):\n 1. (\\<exists>!x. root_cond (p, l, r) x &&&\n     \\<exists>!x. root_cond (q, l', r') x) &&&\n    poly_cond2 p &&& poly_cond2 q", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, l, r) x\n  \\<exists>!x. root_cond (q, l', r') x\n  poly_cond2 p\n  poly_cond2 q\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       y = Irrational x21 x22 \\<Longrightarrow>\n       compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "from compare_1[OF this _ refl refl]"], ["proof (chain)\npicking this:\n  real_of_1 (p, l, r) \\<noteq> real_of_1 (q, l', r') \\<Longrightarrow>\n  compare_1 p q l r (sgn (ipoly p r)) l' r' (sgn (ipoly q r')) =\n  compare (real_of_1 (p, l, r)) (real_of_1 (q, l', r'))", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) \\<noteq> real_of_1 (q, l', r') \\<Longrightarrow>\n  compare_1 p q l r (sgn (ipoly p r)) l' r' (sgn (ipoly q r')) =\n  compare (real_of_1 (p, l, r)) (real_of_1 (q, l', r'))\n\ngoal (1 subgoal):\n 1. compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "using equal_2[OF rc]"], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) \\<noteq> real_of_1 (q, l', r') \\<Longrightarrow>\n  compare_1 p q l r (sgn (ipoly p r)) l' r' (sgn (ipoly q r')) =\n  compare (real_of_1 (p, l, r)) (real_of_1 (q, l', r'))\n  equal_2 (Irrational n (p, l, r)) (Irrational m (q, l', r')) =\n  (real_of_2 (Irrational n (p, l, r)) =\n   real_of_2 (Irrational m (q, l', r')))\n\ngoal (1 subgoal):\n 1. compare_2 x y = compare (real_of_2 x) (real_of_2 y)", "unfolding xx xxx yy yyy"], ["proof (prove)\nusing this:\n  real_of_1 (p, l, r) \\<noteq> real_of_1 (q, l', r') \\<Longrightarrow>\n  compare_1 p q l r (sgn (ipoly p r)) l' r' (sgn (ipoly q r')) =\n  compare (real_of_1 (p, l, r)) (real_of_1 (q, l', r'))\n  equal_2 (Irrational n (p, l, r)) (Irrational m (q, l', r')) =\n  (real_of_2 (Irrational n (p, l, r)) =\n   real_of_2 (Irrational m (q, l', r')))\n\ngoal (1 subgoal):\n 1. compare_2 (Irrational n (p, l, r)) (Irrational m (q, l', r')) =\n    compare (real_of_2 (Irrational n (p, l, r)))\n     (real_of_2 (Irrational m (q, l', r')))", "by simp"], ["proof (state)\nthis:\n  compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compare_2 x y = compare (real_of_2 x) (real_of_2 y)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun sgn_2 :: \"real_alg_2 \\<Rightarrow> rat\" where\n  \"sgn_2 (Rational r) = sgn r\"\n| \"sgn_2 (Irrational n rai) = sgn_1 rai\""], ["", "lemma sgn_2: \"invariant_2 x \\<Longrightarrow> real_of_rat (sgn_2 x) = sgn (real_of_2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 x \\<Longrightarrow>\n    real_of_rat (sgn_2 x) = sgn (real_of_2 x)", "using sgn_1"], ["proof (prove)\nusing this:\n  invariant_1 ?x \\<Longrightarrow>\n  real_of_rat (sgn_1 ?x) = sgn (real_of_1 ?x)\n\ngoal (1 subgoal):\n 1. invariant_2 x \\<Longrightarrow>\n    real_of_rat (sgn_2 x) = sgn (real_of_2 x)", "by (cases x, auto simp: real_of_rat_sgn)"], ["", "fun floor_2 :: \"real_alg_2 \\<Rightarrow> int\" where\n  \"floor_2 (Rational r) = floor r\"\n| \"floor_2 (Irrational n rai) = floor_1 rai\""], ["", "lemma floor_2: \"invariant_2 x \\<Longrightarrow> floor_2 x = floor (real_of_2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant_2 x \\<Longrightarrow>\n    floor_2 x = \\<lfloor>real_of_2 x\\<rfloor>", "by (cases x, auto simp: floor_1)"], ["", "(* *************** *)"], ["", "subsubsection \\<open>Definitions and Algorithms on Type with Invariant\\<close>"], ["", "lift_definition of_rat_3 :: \"rat \\<Rightarrow> real_alg_3\" is of_rat_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rat. of_rat_2 rat \\<in> Collect invariant_2", "by (auto simp: of_rat_2)"], ["", "lemma of_rat_3: \"real_of_3 (of_rat_3 x) = of_rat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 (of_rat_3 x) = real_of_rat x", "by (transfer, auto simp: of_rat_2)"], ["", "lift_definition root_3 :: \"nat \\<Rightarrow> real_alg_3 \\<Rightarrow> real_alg_3\" is root_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat real_alg_2.\n       real_alg_2 \\<in> Collect invariant_2 \\<Longrightarrow>\n       root_2 nat real_alg_2 \\<in> Collect invariant_2", "by (auto simp: root_2)"], ["", "lemma root_3: \"real_of_3 (root_3 n x) = root n (real_of_3 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 (root_3 n x) = root n (real_of_3 x)", "by (transfer, auto simp: root_2)"], ["", "lift_definition equal_3 :: \"real_alg_3 \\<Rightarrow> real_alg_3 \\<Rightarrow> bool\" is equal_2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma equal_3: \"equal_3 x y = (real_of_3 x = real_of_3 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_3 x y = (real_of_3 x = real_of_3 y)", "by (transfer, auto)"], ["", "lift_definition compare_3 :: \"real_alg_3 \\<Rightarrow> real_alg_3 \\<Rightarrow> order\" is compare_2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma compare_3: \"compare_3 x y = (compare (real_of_3 x) (real_of_3 y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare_3 x y = compare (real_of_3 x) (real_of_3 y)", "by (transfer, auto simp: compare_2)"], ["", "lift_definition add_3 :: \"real_alg_3 \\<Rightarrow> real_alg_3 \\<Rightarrow> real_alg_3\" is add_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_21 real_alg_22.\n       \\<lbrakk>real_alg_21 \\<in> Collect invariant_2;\n        real_alg_22 \\<in> Collect invariant_2\\<rbrakk>\n       \\<Longrightarrow> add_2 real_alg_21 real_alg_22\n                         \\<in> Collect invariant_2", "by (auto simp: add_2)"], ["", "lemma add_3: \"real_of_3 (add_3 x y) = real_of_3 x + real_of_3 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 (add_3 x y) = real_of_3 x + real_of_3 y", "by (transfer, auto simp: add_2)"], ["", "lift_definition mult_3 :: \"real_alg_3 \\<Rightarrow> real_alg_3 \\<Rightarrow> real_alg_3\" is mult_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_21 real_alg_22.\n       \\<lbrakk>real_alg_21 \\<in> Collect invariant_2;\n        real_alg_22 \\<in> Collect invariant_2\\<rbrakk>\n       \\<Longrightarrow> mult_2 real_alg_21 real_alg_22\n                         \\<in> Collect invariant_2", "by (auto simp: mult_2)"], ["", "lemma mult_3: \"real_of_3 (mult_3 x y) = real_of_3 x * real_of_3 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 (mult_3 x y) = real_of_3 x * real_of_3 y", "by (transfer, auto simp: mult_2)"], ["", "lift_definition sgn_3 :: \"real_alg_3 \\<Rightarrow> rat\" is sgn_2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma sgn_3: \"real_of_rat (sgn_3 x) = sgn (real_of_3 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (sgn_3 x) = sgn (real_of_3 x)", "by (transfer, auto simp: sgn_2)"], ["", "lift_definition to_rat_3 :: \"real_alg_3 \\<Rightarrow> rat option\" is to_rat_2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma to_rat_3: \"to_rat_3 x = \n  (if real_of_3 x \\<in> \\<rat> then Some (THE q. real_of_3 x = of_rat q) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_rat_3 x =\n    (if real_of_3 x \\<in> \\<rat>\n     then Some (THE q. real_of_3 x = real_of_rat q) else None)", "by (transfer, simp add: to_rat_2)"], ["", "lift_definition floor_3 :: \"real_alg_3 \\<Rightarrow> int\" is floor_2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma floor_3: \"floor_3 x = floor (real_of_3 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. floor_3 x = \\<lfloor>real_of_3 x\\<rfloor>", "by (transfer, auto simp: floor_2)"], ["", "(* *************** *)\n(* info *)"], ["", "lift_definition info_3 :: \"real_alg_3 \\<Rightarrow> rat + int poly \\<times> nat\" is info_2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma info_3_fun: \"real_of_3 x = real_of_3 y \\<Longrightarrow> info_3 x = info_3 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 x = real_of_3 y \\<Longrightarrow> info_3 x = info_3 y", "by (transfer, intro info_2_unique, auto)"], ["", "lift_definition info_real_alg :: \"real_alg \\<Rightarrow> rat + int poly \\<times> nat\" is info_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_31 real_alg_32.\n       real_of_3 real_alg_31 = real_of_3 real_alg_32 \\<Longrightarrow>\n       info_3 real_alg_31 = info_3 real_alg_32", "by (metis info_3_fun)"], ["", "lemma info_real_alg: \n  \"info_real_alg x = Inr (p,n) \\<Longrightarrow> p represents (real_of x) \\<and> card {y. y \\<le> real_of x \\<and> ipoly p y = 0} = n \\<and> irreducible p\" \n  \"info_real_alg x = Inl q \\<Longrightarrow> real_of x = of_rat q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (info_real_alg x = Inr (p, n) \\<Longrightarrow>\n     p represents real_of x \\<and>\n     card {y. y \\<le> real_of x \\<and> poly (real_of_int_poly p) y = 0} =\n     n \\<and>\n     irreducible p) &&&\n    (info_real_alg x = Inl q \\<Longrightarrow> real_of x = real_of_rat q)", "proof (atomize(full), transfer, transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x p n q.\n       x \\<in> Collect invariant_2 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        p represents real_of_2 x \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n \\<and>\n        irreducible p) \\<and>\n       (info_2 x = Inl q \\<longrightarrow> real_of_2 x = real_of_rat q)", "case (1 x p n q)"], ["proof (state)\nthis:\n  x \\<in> Collect invariant_2\n\ngoal (1 subgoal):\n 1. \\<And>x p n q.\n       x \\<in> Collect invariant_2 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        p represents real_of_2 x \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n \\<and>\n        irreducible p) \\<and>\n       (info_2 x = Inl q \\<longrightarrow> real_of_2 x = real_of_rat q)", "from 1"], ["proof (chain)\npicking this:\n  x \\<in> Collect invariant_2", "have x: \"invariant_2 x\""], ["proof (prove)\nusing this:\n  x \\<in> Collect invariant_2\n\ngoal (1 subgoal):\n 1. invariant_2 x", "by auto"], ["proof (state)\nthis:\n  invariant_2 x\n\ngoal (1 subgoal):\n 1. \\<And>x p n q.\n       x \\<in> Collect invariant_2 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        p represents real_of_2 x \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n \\<and>\n        irreducible p) \\<and>\n       (info_2 x = Inl q \\<longrightarrow> real_of_2 x = real_of_rat q)", "note info = info_2_card[OF this]"], ["proof (state)\nthis:\n  info_2 x = Inr (?p, ?n) \\<Longrightarrow>\n  poly_cond ?p \\<and>\n  poly (real_of_int_poly ?p) (real_of_2 x) = 0 \\<and>\n  2 \\<le> degree ?p \\<and>\n  card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly ?p) y = 0} = ?n\n  info_2 x = Inl ?y \\<Longrightarrow> real_of_2 x = real_of_rat ?y\n\ngoal (1 subgoal):\n 1. \\<And>x p n q.\n       x \\<in> Collect invariant_2 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        p represents real_of_2 x \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n \\<and>\n        irreducible p) \\<and>\n       (info_2 x = Inl q \\<longrightarrow> real_of_2 x = real_of_rat q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (info_2 x = Inr (p, n) \\<longrightarrow>\n     p represents real_of_2 x \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n \\<and>\n     irreducible p) \\<and>\n    (info_2 x = Inl q \\<longrightarrow> real_of_2 x = real_of_rat q)", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        p represents real_of_2 x \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n \\<and>\n        irreducible p) \\<and>\n       (info_2 x = Inl q \\<longrightarrow> real_of_2 x = real_of_rat q)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        p represents real_of_2 x \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n \\<and>\n        irreducible p) \\<and>\n       (info_2 x = Inl q \\<longrightarrow> real_of_2 x = real_of_rat q)", "case irr: (Irrational m rai)"], ["proof (state)\nthis:\n  x = Irrational m rai\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        p represents real_of_2 x \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n \\<and>\n        irreducible p) \\<and>\n       (info_2 x = Inl q \\<longrightarrow> real_of_2 x = real_of_rat q)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        p represents real_of_2 x \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n \\<and>\n        irreducible p) \\<and>\n       (info_2 x = Inl q \\<longrightarrow> real_of_2 x = real_of_rat q)", "from info(1)[of p n]"], ["proof (chain)\npicking this:\n  info_2 x = Inr (p, n) \\<Longrightarrow>\n  poly_cond p \\<and>\n  poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n  2 \\<le> degree p \\<and>\n  card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} = n", "show ?thesis"], ["proof (prove)\nusing this:\n  info_2 x = Inr (p, n) \\<Longrightarrow>\n  poly_cond p \\<and>\n  poly (real_of_int_poly p) (real_of_2 x) = 0 \\<and>\n  2 \\<le> degree p \\<and>\n  card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} = n\n\ngoal (1 subgoal):\n 1. (info_2 x = Inr (p, n) \\<longrightarrow>\n     p represents real_of_2 x \\<and>\n     card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n     n \\<and>\n     irreducible p) \\<and>\n    (info_2 x = Inl q \\<longrightarrow> real_of_2 x = real_of_rat q)", "unfolding irr"], ["proof (prove)\nusing this:\n  info_2 (Irrational m rai) = Inr (p, n) \\<Longrightarrow>\n  poly_cond p \\<and>\n  poly (real_of_int_poly p) (real_of_2 (Irrational m rai)) = 0 \\<and>\n  2 \\<le> degree p \\<and>\n  card\n   {y. y \\<le> real_of_2 (Irrational m rai) \\<and>\n       poly (real_of_int_poly p) y = 0} =\n  n\n\ngoal (1 subgoal):\n 1. (info_2 (Irrational m rai) = Inr (p, n) \\<longrightarrow>\n     p represents real_of_2 (Irrational m rai) \\<and>\n     card\n      {y. y \\<le> real_of_2 (Irrational m rai) \\<and>\n          poly (real_of_int_poly p) y = 0} =\n     n \\<and>\n     irreducible p) \\<and>\n    (info_2 (Irrational m rai) = Inl q \\<longrightarrow>\n     real_of_2 (Irrational m rai) = real_of_rat q)", "by (cases rai, auto simp: poly_cond_def)"], ["proof (state)\nthis:\n  (info_2 x = Inr (p, n) \\<longrightarrow>\n   p represents real_of_2 x \\<and>\n   card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n   n \\<and>\n   irreducible p) \\<and>\n  (info_2 x = Inl q \\<longrightarrow> real_of_2 x = real_of_rat q)\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       (info_2 x = Inr (p, n) \\<longrightarrow>\n        p represents real_of_2 x \\<and>\n        card\n         {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n        n \\<and>\n        irreducible p) \\<and>\n       (info_2 x = Inl q \\<longrightarrow> real_of_2 x = real_of_rat q)", "qed (insert 1 info, auto)"], ["proof (state)\nthis:\n  (info_2 x = Inr (p, n) \\<longrightarrow>\n   p represents real_of_2 x \\<and>\n   card {y. y \\<le> real_of_2 x \\<and> poly (real_of_int_poly p) y = 0} =\n   n \\<and>\n   irreducible p) \\<and>\n  (info_2 x = Inl q \\<longrightarrow> real_of_2 x = real_of_rat q)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* add *)"], ["", "instantiation real_alg :: plus\nbegin"], ["", "lift_definition plus_real_alg :: \"real_alg \\<Rightarrow> real_alg \\<Rightarrow> real_alg\" is add_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_31 real_alg_32 real_alg_33 real_alg_34.\n       \\<lbrakk>real_of_3 real_alg_31 = real_of_3 real_alg_32;\n        real_of_3 real_alg_33 = real_of_3 real_alg_34\\<rbrakk>\n       \\<Longrightarrow> real_of_3 (add_3 real_alg_31 real_alg_33) =\n                         real_of_3 (add_3 real_alg_32 real_alg_34)", "by (simp add: add_3)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, plus_class)", ".."], ["", "end"], ["", "lemma plus_real_alg: \"(real_of x) + (real_of y) = real_of (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of x + real_of y = real_of (x + y)", "by (transfer, rule add_3[symmetric])"], ["", "(* minus *)"], ["", "instantiation real_alg :: minus\nbegin"], ["", "definition minus_real_alg :: \"real_alg \\<Rightarrow> real_alg \\<Rightarrow> real_alg\" where\n  \"minus_real_alg x y = x + (-y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, minus_class)", ".."], ["", "end"], ["", "lemma minus_real_alg: \"(real_of x) - (real_of y) = real_of (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of x - real_of y = real_of (x - y)", "unfolding minus_real_alg_def minus_real_def uminus_real_alg plus_real_alg"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of (x + - y) = real_of (x + - y)", ".."], ["", "(* of_rat *)"], ["", "lift_definition of_rat_real_alg :: \"rat \\<Rightarrow> real_alg\" is of_rat_3"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma of_rat_real_alg: \"real_of_rat x = real_of (of_rat_real_alg x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat x = real_of (of_rat_real_alg x)", "by (transfer, rule of_rat_3[symmetric])"], ["", "(* zero *)"], ["", "instantiation real_alg :: zero\nbegin"], ["", "definition zero_real_alg :: \"real_alg\" where \"zero_real_alg \\<equiv> of_rat_real_alg 0\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, zero_class)", ".."], ["", "end"], ["", "lemma zero_real_alg: \"0 = real_of 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = real_of 0", "unfolding zero_real_alg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = real_of (of_rat_real_alg 0)", "by (simp add: of_rat_real_alg[symmetric])"], ["", "(* one *)"], ["", "instantiation real_alg :: one\nbegin"], ["", "definition one_real_alg :: \"real_alg\" where \"one_real_alg \\<equiv> of_rat_real_alg 1\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, one_class)", ".."], ["", "end"], ["", "lemma one_real_alg: \"1 = real_of 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = real_of 1", "unfolding one_real_alg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = real_of (of_rat_real_alg 1)", "by (simp add: of_rat_real_alg[symmetric])"], ["", "(* times *)"], ["", "instantiation real_alg :: times\nbegin"], ["", "lift_definition times_real_alg :: \"real_alg \\<Rightarrow> real_alg \\<Rightarrow> real_alg\" is mult_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_31 real_alg_32 real_alg_33 real_alg_34.\n       \\<lbrakk>real_of_3 real_alg_31 = real_of_3 real_alg_32;\n        real_of_3 real_alg_33 = real_of_3 real_alg_34\\<rbrakk>\n       \\<Longrightarrow> real_of_3 (mult_3 real_alg_31 real_alg_33) =\n                         real_of_3 (mult_3 real_alg_32 real_alg_34)", "by (simp add: mult_3)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, times_class)", ".."], ["", "end"], ["", "lemma times_real_alg: \"(real_of x) * (real_of y) = real_of (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of x * real_of y = real_of (x * y)", "by (transfer, rule mult_3[symmetric])"], ["", "(* inverse *)"], ["", "instantiation real_alg :: inverse\nbegin"], ["", "lift_definition inverse_real_alg :: \"real_alg \\<Rightarrow> real_alg\" is inverse_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_31 real_alg_32.\n       real_of_3 real_alg_31 = real_of_3 real_alg_32 \\<Longrightarrow>\n       real_of_3 (inverse_3 real_alg_31) = real_of_3 (inverse_3 real_alg_32)", "by (simp add: inverse_3)"], ["", "definition divide_real_alg :: \"real_alg \\<Rightarrow> real_alg \\<Rightarrow> real_alg\" where\n  \"divide_real_alg x y = x * inverse y\""], ["", "(* TODO: better to use poly_div *)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, inverse_class)", ".."], ["", "end"], ["", "lemma inverse_real_alg: \"inverse (real_of x) = real_of (inverse x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (real_of x) = real_of (inverse x)", "by (transfer, rule inverse_3[symmetric])"], ["", "lemma divide_real_alg: \"(real_of x) / (real_of y) = real_of (x / y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of x / real_of y = real_of (x / y)", "unfolding divide_real_alg_def times_real_alg[symmetric] divide_real_def inverse_real_alg"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of x * real_of (inverse y) = real_of x * real_of (inverse y)", ".."], ["", "(* group *)"], ["", "instance real_alg :: ab_group_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, ab_group_add_class)", "apply intro_classes"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a\n 4. \\<And>a. - a + a = 0\n 5. \\<And>a b. a - b = a + - b", "apply (transfer, unfold add_3, force)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b. a + b = b + a\n 2. \\<And>a. 0 + a = a\n 3. \\<And>a. - a + a = 0\n 4. \\<And>a b. a - b = a + - b", "apply (unfold zero_real_alg_def, transfer, unfold add_3 of_rat_3, force)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a. of_rat_real_alg 0 + a = a\n 2. \\<And>a. - a + a = of_rat_real_alg 0\n 3. \\<And>a b. a - b = a + - b", "apply (transfer, unfold add_3 of_rat_3, force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. - a + a = of_rat_real_alg 0\n 2. \\<And>a b. a - b = a + - b", "apply (transfer, unfold add_3 uminus_3 of_rat_3, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. a - b = a + - b", "apply (unfold minus_real_alg_def, force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* field *)"], ["", "instance real_alg :: field"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, field_class)", "apply intro_classes"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a. 1 * a = a\n 4. \\<And>a b c. (a + b) * c = a * c + b * c\n 5. 0 \\<noteq> 1\n 6. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> inverse a * a = 1\n 7. \\<And>a b. a / b = a * inverse b\n 8. inverse 0 = 0", "apply (transfer, unfold mult_3, force)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b. a * b = b * a\n 2. \\<And>a. 1 * a = a\n 3. \\<And>a b c. (a + b) * c = a * c + b * c\n 4. 0 \\<noteq> 1\n 5. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> inverse a * a = 1\n 6. \\<And>a b. a / b = a * inverse b\n 7. inverse 0 = 0", "apply (transfer, unfold mult_3, force)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a. 1 * a = a\n 2. \\<And>a b c. (a + b) * c = a * c + b * c\n 3. 0 \\<noteq> 1\n 4. \\<And>a. a \\<noteq> 0 \\<Longrightarrow> inverse a * a = 1\n 5. \\<And>a b. a / b = a * inverse b\n 6. inverse 0 = 0", "apply (unfold one_real_alg_def, transfer, unfold mult_3 of_rat_3, force)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b c. (a + b) * c = a * c + b * c\n 2. 0 \\<noteq> of_rat_real_alg 1\n 3. \\<And>a.\n       a \\<noteq> 0 \\<Longrightarrow> inverse a * a = of_rat_real_alg 1\n 4. \\<And>a b. a / b = a * inverse b\n 5. inverse 0 = 0", "apply (transfer, unfold mult_3 add_3, force simp: field_simps)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<noteq> of_rat_real_alg 1\n 2. \\<And>a.\n       a \\<noteq> 0 \\<Longrightarrow> inverse a * a = of_rat_real_alg 1\n 3. \\<And>a b. a / b = a * inverse b\n 4. inverse 0 = 0", "apply (unfold zero_real_alg_def, transfer, unfold of_rat_3, force)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<noteq> of_rat_real_alg 0 \\<Longrightarrow>\n       inverse a * a = of_rat_real_alg 1\n 2. \\<And>a b. a / b = a * inverse b\n 3. inverse (of_rat_real_alg 0) = of_rat_real_alg 0", "apply (transfer, unfold mult_3 inverse_3 of_rat_3, force simp: field_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b. a / b = a * inverse b\n 2. inverse (of_rat_real_alg 0) = of_rat_real_alg 0", "apply (unfold divide_real_alg_def, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (of_rat_real_alg 0) = of_rat_real_alg 0", "apply (transfer, unfold inverse_3 of_rat_3, force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* numeral *)"], ["", "instance real_alg :: numeral"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, numeral_class)", ".."], ["", "(* root *)"], ["", "lift_definition root_real_alg :: \"nat \\<Rightarrow> real_alg \\<Rightarrow> real_alg\" is root_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat real_alg_31 real_alg_32.\n       real_of_3 real_alg_31 = real_of_3 real_alg_32 \\<Longrightarrow>\n       real_of_3 (root_3 nat real_alg_31) =\n       real_of_3 (root_3 nat real_alg_32)", "by (simp add: root_3)"], ["", "lemma root_real_alg: \"root n (real_of x) = real_of (root_real_alg n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root n (real_of x) = real_of (root_real_alg n x)", "by (transfer, rule root_3[symmetric])"], ["", "(* sgn *)"], ["", "lift_definition sgn_real_alg_rat :: \"real_alg \\<Rightarrow> rat\" is sgn_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_31 real_alg_32.\n       real_of_3 real_alg_31 = real_of_3 real_alg_32 \\<Longrightarrow>\n       sgn_3 real_alg_31 = sgn_3 real_alg_32", "by (insert sgn_3, metis to_rat_of_rat)"], ["", "lemma sgn_real_alg_rat: \"real_of_rat (sgn_real_alg_rat x) = sgn (real_of x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (sgn_real_alg_rat x) = sgn (real_of x)", "by (transfer, auto simp: sgn_3)"], ["", "instantiation real_alg :: sgn\nbegin"], ["", "definition sgn_real_alg :: \"real_alg \\<Rightarrow> real_alg\" where\n  \"sgn_real_alg x = of_rat_real_alg (sgn_real_alg_rat x)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, sgn_class)", ".."], ["", "end"], ["", "lemma sgn_real_alg: \"sgn (real_of x) = real_of (sgn x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (real_of x) = real_of (sgn x)", "unfolding sgn_real_alg_def of_rat_real_alg[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (real_of x) = real_of_rat (sgn_real_alg_rat x)", "by (transfer, simp add: sgn_3)"], ["", "(* equal *)"], ["", "instantiation real_alg :: equal\nbegin"], ["", "lift_definition equal_real_alg :: \"real_alg \\<Rightarrow> real_alg \\<Rightarrow> bool\" is equal_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_31 real_alg_32 real_alg_33 real_alg_34.\n       \\<lbrakk>real_of_3 real_alg_31 = real_of_3 real_alg_32;\n        real_of_3 real_alg_33 = real_of_3 real_alg_34\\<rbrakk>\n       \\<Longrightarrow> equal_3 real_alg_31 real_alg_33 =\n                         equal_3 real_alg_32 real_alg_34", "by (simp add: equal_3)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, equal_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "fix x y :: real_alg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "show \"equal_class.equal x y = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal x y = (x = y)", "by (transfer, simp add: equal_3)"], ["proof (state)\nthis:\n  equal_class.equal x y = (x = y)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma equal_real_alg: \"HOL.equal (real_of x) (real_of y) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal (real_of x) (real_of y) = (x = y)", "unfolding equal_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (real_of x - real_of y = 0) = (x = y)", "by (transfer, auto)"], ["", "(* comparisons *)"], ["", "instantiation real_alg :: ord \nbegin"], ["", "definition less_real_alg :: \"real_alg \\<Rightarrow> real_alg \\<Rightarrow> bool\" where\n  [code del]: \"less_real_alg x y = (real_of x < real_of y)\""], ["", "definition less_eq_real_alg :: \"real_alg \\<Rightarrow> real_alg \\<Rightarrow> bool\" where\n  [code del]: \"less_eq_real_alg x y = (real_of x \\<le> real_of y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, ord_class)", ".."], ["", "end"], ["", "lemma less_real_alg: \"less (real_of x) (real_of y) = (x < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real_of x < real_of y) = (x < y)", "unfolding less_real_alg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (real_of x < real_of y) = (real_of x < real_of y)", ".."], ["", "lemma less_eq_real_alg: \"less_eq (real_of x) (real_of y) = (x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real_of x \\<le> real_of y) = (x \\<le> y)", "unfolding less_eq_real_alg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (real_of x \\<le> real_of y) = (real_of x \\<le> real_of y)", ".."], ["", "instantiation real_alg :: compare_order\nbegin"], ["", "lift_definition compare_real_alg :: \"real_alg \\<Rightarrow> real_alg \\<Rightarrow> order\" is compare_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_31 real_alg_32 real_alg_33 real_alg_34.\n       \\<lbrakk>real_of_3 real_alg_31 = real_of_3 real_alg_32;\n        real_of_3 real_alg_33 = real_of_3 real_alg_34\\<rbrakk>\n       \\<Longrightarrow> compare_3 real_alg_31 real_alg_33 =\n                         compare_3 real_alg_32 real_alg_34", "by (simp add: compare_3)"], ["", "lemma compare_real_alg: \"compare (real_of x) (real_of y) = (compare x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compare (real_of x) (real_of y) = compare x y", "by (transfer, simp add: compare_3)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, compare_order_class)", "proof (intro_classes, unfold compare_real_alg[symmetric, abs_def])"], ["proof (state)\ngoal (3 subgoals):\n 1. comparator (\\<lambda>x y. compare (real_of x) (real_of y))\n 2. le_of_comp (\\<lambda>x y. compare (real_of x) (real_of y)) = (\\<le>)\n 3. lt_of_comp (\\<lambda>x y. compare (real_of x) (real_of y)) = (<)", "show \"le_of_comp (\\<lambda>x y. compare (real_of x) (real_of y)) = (\\<le>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le_of_comp (\\<lambda>x y. compare (real_of x) (real_of y)) = (\\<le>)", "by (intro ext, auto simp: compare_real_def comparator_of_def le_of_comp_def less_eq_real_alg_def)"], ["proof (state)\nthis:\n  le_of_comp (\\<lambda>x y. compare (real_of x) (real_of y)) = (\\<le>)\n\ngoal (2 subgoals):\n 1. comparator (\\<lambda>x y. compare (real_of x) (real_of y))\n 2. lt_of_comp (\\<lambda>x y. compare (real_of x) (real_of y)) = (<)", "show \"lt_of_comp (\\<lambda>x y. compare (real_of x) (real_of y)) = (<)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt_of_comp (\\<lambda>x y. compare (real_of x) (real_of y)) = (<)", "by (intro ext, auto simp: compare_real_def comparator_of_def lt_of_comp_def less_real_alg_def)"], ["proof (state)\nthis:\n  lt_of_comp (\\<lambda>x y. compare (real_of x) (real_of y)) = (<)\n\ngoal (1 subgoal):\n 1. comparator (\\<lambda>x y. compare (real_of x) (real_of y))", "show \"comparator (\\<lambda>x y. compare (real_of x) (real_of y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator (\\<lambda>x y. compare (real_of x) (real_of y))", "unfolding comparator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y.\n        invert_order (compare (real_of x) (real_of y)) =\n        compare (real_of y) (real_of x)) \\<and>\n    (\\<forall>x y.\n        compare (real_of x) (real_of y) = Eq \\<longrightarrow> x = y) \\<and>\n    (\\<forall>x y z.\n        compare (real_of x) (real_of y) = Lt \\<longrightarrow>\n        compare (real_of y) (real_of z) = Lt \\<longrightarrow>\n        compare (real_of x) (real_of z) = Lt)", "proof (intro conjI impI allI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       invert_order (compare (real_of x) (real_of y)) =\n       compare (real_of y) (real_of x)\n 2. \\<And>x y. compare (real_of x) (real_of y) = Eq \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>compare (real_of x) (real_of y) = Lt;\n        compare (real_of y) (real_of z) = Lt\\<rbrakk>\n       \\<Longrightarrow> compare (real_of x) (real_of z) = Lt", "fix x y z :: \"real_alg\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       invert_order (compare (real_of x) (real_of y)) =\n       compare (real_of y) (real_of x)\n 2. \\<And>x y. compare (real_of x) (real_of y) = Eq \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>compare (real_of x) (real_of y) = Lt;\n        compare (real_of y) (real_of z) = Lt\\<rbrakk>\n       \\<Longrightarrow> compare (real_of x) (real_of z) = Lt", "let ?r = real_of"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       invert_order (compare (real_of x) (real_of y)) =\n       compare (real_of y) (real_of x)\n 2. \\<And>x y. compare (real_of x) (real_of y) = Eq \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>compare (real_of x) (real_of y) = Lt;\n        compare (real_of y) (real_of z) = Lt\\<rbrakk>\n       \\<Longrightarrow> compare (real_of x) (real_of z) = Lt", "note rc = comparator_compare[where 'a = real, unfolded comparator_def]"], ["proof (state)\nthis:\n  (\\<forall>x y. invert_order (compare x y) = compare y x) \\<and>\n  (\\<forall>x y. compare x y = Eq \\<longrightarrow> x = y) \\<and>\n  (\\<forall>x y z.\n      compare x y = Lt \\<longrightarrow>\n      compare y z = Lt \\<longrightarrow> compare x z = Lt)\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       invert_order (compare (real_of x) (real_of y)) =\n       compare (real_of y) (real_of x)\n 2. \\<And>x y. compare (real_of x) (real_of y) = Eq \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>compare (real_of x) (real_of y) = Lt;\n        compare (real_of y) (real_of z) = Lt\\<rbrakk>\n       \\<Longrightarrow> compare (real_of x) (real_of z) = Lt", "from rc"], ["proof (chain)\npicking this:\n  (\\<forall>x y. invert_order (compare x y) = compare y x) \\<and>\n  (\\<forall>x y. compare x y = Eq \\<longrightarrow> x = y) \\<and>\n  (\\<forall>x y z.\n      compare x y = Lt \\<longrightarrow>\n      compare y z = Lt \\<longrightarrow> compare x z = Lt)", "show \"invert_order (compare (?r x) (?r y)) = compare (?r y) (?r x)\""], ["proof (prove)\nusing this:\n  (\\<forall>x y. invert_order (compare x y) = compare y x) \\<and>\n  (\\<forall>x y. compare x y = Eq \\<longrightarrow> x = y) \\<and>\n  (\\<forall>x y z.\n      compare x y = Lt \\<longrightarrow>\n      compare y z = Lt \\<longrightarrow> compare x z = Lt)\n\ngoal (1 subgoal):\n 1. invert_order (compare (real_of x) (real_of y)) =\n    compare (real_of y) (real_of x)", "by blast"], ["proof (state)\nthis:\n  invert_order (compare (real_of x) (real_of y)) =\n  compare (real_of y) (real_of x)\n\ngoal (2 subgoals):\n 1. \\<And>x y. compare (real_of x) (real_of y) = Eq \\<Longrightarrow> x = y\n 2. \\<And>x y z.\n       \\<lbrakk>compare (real_of x) (real_of y) = Lt;\n        compare (real_of y) (real_of z) = Lt\\<rbrakk>\n       \\<Longrightarrow> compare (real_of x) (real_of z) = Lt", "from rc"], ["proof (chain)\npicking this:\n  (\\<forall>x y. invert_order (compare x y) = compare y x) \\<and>\n  (\\<forall>x y. compare x y = Eq \\<longrightarrow> x = y) \\<and>\n  (\\<forall>x y z.\n      compare x y = Lt \\<longrightarrow>\n      compare y z = Lt \\<longrightarrow> compare x z = Lt)", "show \"compare (?r x) (?r y) = Lt \\<Longrightarrow> compare (?r y) (?r z) = Lt \\<Longrightarrow> compare (?r x) (?r z) = Lt\""], ["proof (prove)\nusing this:\n  (\\<forall>x y. invert_order (compare x y) = compare y x) \\<and>\n  (\\<forall>x y. compare x y = Eq \\<longrightarrow> x = y) \\<and>\n  (\\<forall>x y z.\n      compare x y = Lt \\<longrightarrow>\n      compare y z = Lt \\<longrightarrow> compare x z = Lt)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>compare (real_of x) (real_of y) = Lt;\n     compare (real_of y) (real_of z) = Lt\\<rbrakk>\n    \\<Longrightarrow> compare (real_of x) (real_of z) = Lt", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>compare (real_of x) (real_of y) = Lt;\n   compare (real_of y) (real_of z) = Lt\\<rbrakk>\n  \\<Longrightarrow> compare (real_of x) (real_of z) = Lt\n\ngoal (1 subgoal):\n 1. \\<And>x y. compare (real_of x) (real_of y) = Eq \\<Longrightarrow> x = y", "assume \"compare (?r x) (?r y) = Eq\""], ["proof (state)\nthis:\n  compare (real_of x) (real_of y) = Eq\n\ngoal (1 subgoal):\n 1. \\<And>x y. compare (real_of x) (real_of y) = Eq \\<Longrightarrow> x = y", "with rc"], ["proof (chain)\npicking this:\n  (\\<forall>x y. invert_order (compare x y) = compare y x) \\<and>\n  (\\<forall>x y. compare x y = Eq \\<longrightarrow> x = y) \\<and>\n  (\\<forall>x y z.\n      compare x y = Lt \\<longrightarrow>\n      compare y z = Lt \\<longrightarrow> compare x z = Lt)\n  compare (real_of x) (real_of y) = Eq", "have \"?r x = ?r y\""], ["proof (prove)\nusing this:\n  (\\<forall>x y. invert_order (compare x y) = compare y x) \\<and>\n  (\\<forall>x y. compare x y = Eq \\<longrightarrow> x = y) \\<and>\n  (\\<forall>x y z.\n      compare x y = Lt \\<longrightarrow>\n      compare y z = Lt \\<longrightarrow> compare x z = Lt)\n  compare (real_of x) (real_of y) = Eq\n\ngoal (1 subgoal):\n 1. real_of x = real_of y", "by blast"], ["proof (state)\nthis:\n  real_of x = real_of y\n\ngoal (1 subgoal):\n 1. \\<And>x y. compare (real_of x) (real_of y) = Eq \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  real_of x = real_of y\n\ngoal (1 subgoal):\n 1. x = y", "unfolding real_of_inj"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y", "."], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  comparator (\\<lambda>x y. compare (real_of x) (real_of y))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma less_eq_real_alg_code[code]: \n  \"(less_eq :: real_alg \\<Rightarrow> real_alg \\<Rightarrow> bool) = le_of_comp compare\"\n  \"(less :: real_alg \\<Rightarrow> real_alg \\<Rightarrow> bool) = lt_of_comp compare\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<le>) = le_of_comp compare &&& (<) = lt_of_comp compare", "by (rule ord_defs(1)[symmetric], rule ord_defs(2)[symmetric])"], ["", "instantiation real_alg :: abs\nbegin"], ["", "definition abs_real_alg :: \"real_alg \\<Rightarrow> real_alg\" where\n  \"abs_real_alg x = (if real_of x < 0 then uminus x else x)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, abs_class)", ".."], ["", "end"], ["", "lemma abs_real_alg: \"abs (real_of x) = real_of (abs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real_of x\\<bar> = real_of \\<bar>x\\<bar>", "unfolding abs_real_alg_def abs_real_def if_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. if real_of x < 0\n    then (if real_of x < 0 then (=) (- real_of x) else (=) (real_of x))\n          (real_of (- x))\n    else (if real_of x < 0 then (=) (- real_of x) else (=) (real_of x))\n          (real_of x)", "by (auto simp: uminus_real_alg)"], ["", "lemma sgn_real_alg_sound: \"sgn x = (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)\"\n  (is \"_ = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn x = (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sgn x = (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)", "have \"real_of (sgn x) = sgn (real_of x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of (sgn x) = sgn (real_of x)", "by (simp add: sgn_real_alg)"], ["proof (state)\nthis:\n  real_of (sgn x) = sgn (real_of x)\n\ngoal (1 subgoal):\n 1. sgn x = (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)", "also"], ["proof (state)\nthis:\n  real_of (sgn x) = sgn (real_of x)\n\ngoal (1 subgoal):\n 1. sgn x = (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)", "have \"\\<dots> = real_of ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (real_of x) =\n    real_of (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)", "unfolding sgn_real_def if_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. if x = 0\n    then (if real_of x = 0\n          then (=) ((if real_of x = 0 then If (0 < real_of x) 0\n                     else If (0 < real_of x) 1)\n                     0)\n          else (=) ((if real_of x = 0 then If (0 < real_of x) 0\n                     else If (0 < real_of x) 1)\n                     (- 1)))\n          (real_of\n            ((if x = 0 then If (0 < real_of x) 0 else If (0 < real_of x) 1)\n              0))\n    else (if real_of x = 0\n          then (=) ((if real_of x = 0 then If (0 < real_of x) 0\n                     else If (0 < real_of x) 1)\n                     0)\n          else (=) ((if real_of x = 0 then If (0 < real_of x) 0\n                     else If (0 < real_of x) 1)\n                     (- 1)))\n          (real_of\n            ((if x = 0 then If (0 < real_of x) 0 else If (0 < real_of x) 1)\n              (- 1)))", "by (auto simp: less_real_alg_def \n    zero_real_alg_def one_real_alg_def of_rat_real_alg[symmetric] equal_real_alg[symmetric]\n    equal_real_def uminus_real_alg[symmetric])"], ["proof (state)\nthis:\n  sgn (real_of x) =\n  real_of (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. sgn x = (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)", "finally"], ["proof (chain)\npicking this:\n  real_of (sgn x) =\n  real_of (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)", "show \"sgn x = ?r\""], ["proof (prove)\nusing this:\n  real_of (sgn x) =\n  real_of (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. sgn x = (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)", "unfolding equal_real_alg[symmetric] equal_real_def"], ["proof (prove)\nusing this:\n  real_of (sgn x) =\n  real_of\n   (if real_of x - real_of 0 = 0 then 0\n    else if 0 < real_of x then 1 else - 1)\n\ngoal (1 subgoal):\n 1. real_of (sgn x) -\n    real_of\n     (if real_of x - real_of 0 = 0 then 0\n      else if 0 < real_of x then 1 else - 1) =\n    0", "by simp"], ["proof (state)\nthis:\n  sgn x = (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma real_of_of_int: \"real_of_rat (rat_of_int z) = real_of (of_int z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (rat_of_int z) = real_of (of_int z)", "proof (cases \"z \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> z \\<Longrightarrow>\n    real_of_rat (rat_of_int z) = real_of (of_int z)\n 2. \\<not> 0 \\<le> z \\<Longrightarrow>\n    real_of_rat (rat_of_int z) = real_of (of_int z)", "case True"], ["proof (state)\nthis:\n  0 \\<le> z\n\ngoal (2 subgoals):\n 1. 0 \\<le> z \\<Longrightarrow>\n    real_of_rat (rat_of_int z) = real_of (of_int z)\n 2. \\<not> 0 \\<le> z \\<Longrightarrow>\n    real_of_rat (rat_of_int z) = real_of (of_int z)", "define n where \"n = nat z\""], ["proof (state)\nthis:\n  n = nat z\n\ngoal (2 subgoals):\n 1. 0 \\<le> z \\<Longrightarrow>\n    real_of_rat (rat_of_int z) = real_of (of_int z)\n 2. \\<not> 0 \\<le> z \\<Longrightarrow>\n    real_of_rat (rat_of_int z) = real_of (of_int z)", "from True"], ["proof (chain)\npicking this:\n  0 \\<le> z", "have z: \"z = int n\""], ["proof (prove)\nusing this:\n  0 \\<le> z\n\ngoal (1 subgoal):\n 1. z = int n", "unfolding n_def"], ["proof (prove)\nusing this:\n  0 \\<le> z\n\ngoal (1 subgoal):\n 1. z = int (nat z)", "by simp"], ["proof (state)\nthis:\n  z = int n\n\ngoal (2 subgoals):\n 1. 0 \\<le> z \\<Longrightarrow>\n    real_of_rat (rat_of_int z) = real_of (of_int z)\n 2. \\<not> 0 \\<le> z \\<Longrightarrow>\n    real_of_rat (rat_of_int z) = real_of (of_int z)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (rat_of_int z) = real_of (of_int z)", "unfolding z"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (rat_of_int (int n)) = real_of (of_int (int n))", "by (induct n, auto simp: zero_real_alg plus_real_alg[symmetric] one_real_alg hom_distribs)"], ["proof (state)\nthis:\n  real_of_rat (rat_of_int z) = real_of (of_int z)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> z \\<Longrightarrow>\n    real_of_rat (rat_of_int z) = real_of (of_int z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> z \\<Longrightarrow>\n    real_of_rat (rat_of_int z) = real_of (of_int z)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> z\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> z \\<Longrightarrow>\n    real_of_rat (rat_of_int z) = real_of (of_int z)", "define n where \"n = nat (-z)\""], ["proof (state)\nthis:\n  n = nat (- z)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> z \\<Longrightarrow>\n    real_of_rat (rat_of_int z) = real_of (of_int z)", "from False"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> z", "have z: \"z = - int n\""], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> z\n\ngoal (1 subgoal):\n 1. z = - int n", "unfolding n_def"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> z\n\ngoal (1 subgoal):\n 1. z = - int (nat (- z))", "by simp"], ["proof (state)\nthis:\n  z = - int n\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> z \\<Longrightarrow>\n    real_of_rat (rat_of_int z) = real_of (of_int z)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (rat_of_int z) = real_of (of_int z)", "unfolding z"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (rat_of_int (- int n)) = real_of (of_int (- int n))", "by (induct n, auto simp: zero_real_alg plus_real_alg[symmetric] one_real_alg uminus_real_alg[symmetric]\n      minus_real_alg[symmetric] hom_distribs)"], ["proof (state)\nthis:\n  real_of_rat (rat_of_int z) = real_of (of_int z)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance real_alg :: linordered_field"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, linordered_field_class)", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 2. \\<And>a. \\<bar>a\\<bar> = (if a < 0 then - a else a)\n 3. \\<And>a b c.\n       \\<lbrakk>a < b; 0 < c\\<rbrakk> \\<Longrightarrow> c * a < c * b\n 4. \\<And>x. sgn x = (if x = 0 then 0 else if 0 < x then 1 else - 1)", "apply (unfold less_eq_real_alg_def plus_real_alg[symmetric], force)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a. \\<bar>a\\<bar> = (if a < 0 then - a else a)\n 2. \\<And>a b c.\n       \\<lbrakk>a < b; 0 < c\\<rbrakk> \\<Longrightarrow> c * a < c * b\n 3. \\<And>x. sgn x = (if x = 0 then 0 else if 0 < x then 1 else - 1)", "apply (unfold abs_real_alg_def less_real_alg_def zero_real_alg[symmetric], rule refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>real_of a < real_of b; 0 < real_of c\\<rbrakk>\n       \\<Longrightarrow> real_of (c * a) < real_of (c * b)\n 2. \\<And>x. sgn x = (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)", "apply (unfold less_real_alg_def times_real_alg[symmetric], force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. sgn x = (if x = 0 then 0 else if 0 < real_of x then 1 else - 1)", "apply (rule sgn_real_alg_sound)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instantiation real_alg :: floor_ceiling\nbegin"], ["", "lift_definition floor_real_alg :: \"real_alg \\<Rightarrow> int\" is floor_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_31 real_alg_32.\n       real_of_3 real_alg_31 = real_of_3 real_alg_32 \\<Longrightarrow>\n       floor_3 real_alg_31 = floor_3 real_alg_32", "by (auto simp: floor_3)"], ["", "lemma floor_real_alg: \"floor (real_of x) = floor x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real_of x\\<rfloor> = \\<lfloor>x\\<rfloor>", "by (transfer, auto simp: floor_3)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real_alg, floor_ceiling_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. \\<exists>z. x \\<le> of_int z\n 2. \\<And>x.\n       of_int \\<lfloor>x\\<rfloor> \\<le> x \\<and>\n       x < of_int (\\<lfloor>x\\<rfloor> + 1)", "fix x :: real_alg"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. \\<exists>z. x \\<le> of_int z\n 2. \\<And>x.\n       of_int \\<lfloor>x\\<rfloor> \\<le> x \\<and>\n       x < of_int (\\<lfloor>x\\<rfloor> + 1)", "show \"of_int \\<lfloor>x\\<rfloor> \\<le> x \\<and> x < of_int (\\<lfloor>x\\<rfloor> + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int \\<lfloor>x\\<rfloor> \\<le> x \\<and>\n    x < of_int (\\<lfloor>x\\<rfloor> + 1)", "unfolding floor_real_alg[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int \\<lfloor>real_of x\\<rfloor> \\<le> x \\<and>\n    x < of_int (\\<lfloor>real_of x\\<rfloor> + 1)", "using floor_correct[of \"real_of x\"]"], ["proof (prove)\nusing this:\n  real_of_int \\<lfloor>real_of x\\<rfloor> \\<le> real_of x \\<and>\n  real_of x < real_of_int (\\<lfloor>real_of x\\<rfloor> + 1)\n\ngoal (1 subgoal):\n 1. of_int \\<lfloor>real_of x\\<rfloor> \\<le> x \\<and>\n    x < of_int (\\<lfloor>real_of x\\<rfloor> + 1)", "unfolding less_eq_real_alg_def less_real_alg_def\n    real_of_of_int[symmetric]"], ["proof (prove)\nusing this:\n  real_of_int \\<lfloor>real_of x\\<rfloor> \\<le> real_of x \\<and>\n  real_of x < real_of_int (\\<lfloor>real_of x\\<rfloor> + 1)\n\ngoal (1 subgoal):\n 1. real_of_rat (rat_of_int \\<lfloor>real_of x\\<rfloor>)\n    \\<le> real_of x \\<and>\n    real_of x < real_of_rat (rat_of_int (\\<lfloor>real_of x\\<rfloor> + 1))", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  of_int \\<lfloor>x\\<rfloor> \\<le> x \\<and>\n  x < of_int (\\<lfloor>x\\<rfloor> + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>z. x \\<le> of_int z", "hence \"x \\<le> of_int (\\<lfloor>x\\<rfloor> + 1)\""], ["proof (prove)\nusing this:\n  of_int \\<lfloor>x\\<rfloor> \\<le> x \\<and>\n  x < of_int (\\<lfloor>x\\<rfloor> + 1)\n\ngoal (1 subgoal):\n 1. x \\<le> of_int (\\<lfloor>x\\<rfloor> + 1)", "by auto"], ["proof (state)\nthis:\n  x \\<le> of_int (\\<lfloor>x\\<rfloor> + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>z. x \\<le> of_int z", "thus \"\\<exists>z. x \\<le> of_int z\""], ["proof (prove)\nusing this:\n  x \\<le> of_int (\\<lfloor>x\\<rfloor> + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>z. x \\<le> of_int z", "by blast"], ["proof (state)\nthis:\n  \\<exists>z. x \\<le> of_int z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition real_alg_of_real :: \"real \\<Rightarrow> real_alg\" where\n  \"real_alg_of_real x = (if (\\<exists> y. x = real_of y) then (THE y. x = real_of y) else 0)\""], ["", "lemma real_alg_of_real_code[code]: \"real_alg_of_real (real_of x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_alg_of_real (real_of x) = x", "using real_of_inj"], ["proof (prove)\nusing this:\n  (real_of ?x = real_of ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. real_alg_of_real (real_of x) = x", "unfolding real_alg_of_real_def"], ["proof (prove)\nusing this:\n  (real_of ?x = real_of ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. (if \\<exists>y. real_of x = real_of y then THE y. real_of x = real_of y\n     else 0) =\n    x", "by auto"], ["", "lift_definition to_rat_real_alg_main :: \"real_alg \\<Rightarrow> rat option\" is to_rat_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_31 real_alg_32.\n       real_of_3 real_alg_31 = real_of_3 real_alg_32 \\<Longrightarrow>\n       to_rat_3 real_alg_31 = to_rat_3 real_alg_32", "by (simp add: to_rat_3)"], ["", "lemma to_rat_real_alg_main: \"to_rat_real_alg_main x = (if real_of x \\<in> \\<rat> then \n  Some (THE q. real_of x = of_rat q) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_rat_real_alg_main x =\n    (if real_of x \\<in> \\<rat> then Some (THE q. real_of x = real_of_rat q)\n     else None)", "by (transfer, simp add: to_rat_3)"], ["", "definition to_rat_real_alg :: \"real_alg \\<Rightarrow> rat\" where\n  \"to_rat_real_alg x = (case to_rat_real_alg_main x of Some q \\<Rightarrow> q | None \\<Rightarrow> 0)\""], ["", "definition is_rat_real_alg :: \"real_alg \\<Rightarrow> bool\" where\n  \"is_rat_real_alg x = (case to_rat_real_alg_main x of Some q \\<Rightarrow> True | None \\<Rightarrow> False)\""], ["", "lemma is_rat_real_alg: \"is_rat (real_of x) = (is_rat_real_alg x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rat (real_of x) = is_rat_real_alg x", "unfolding is_rat_real_alg_def is_rat to_rat_real_alg_main"], ["proof (prove)\ngoal (1 subgoal):\n 1. (real_of x \\<in> \\<rat>) =\n    (case if real_of x \\<in> \\<rat>\n          then Some (THE q. real_of x = real_of_rat q) else None of\n     None \\<Rightarrow> False | Some q \\<Rightarrow> True)", "by auto"], ["", "lemma to_rat_real_alg: \"to_rat (real_of x) = (to_rat_real_alg x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_rat (real_of x) = to_rat_real_alg x", "unfolding to_rat to_rat_real_alg_def to_rat_real_alg_main"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if real_of x \\<in> \\<rat> then THE y. real_of x = real_of_rat y\n     else 0) =\n    (case if real_of x \\<in> \\<rat>\n          then Some (THE q. real_of x = real_of_rat q) else None of\n     None \\<Rightarrow> 0 | Some q \\<Rightarrow> q)", "by auto"], ["", "subsection \\<open>Real Algebraic Numbers as Implementation for Real Numbers\\<close>"], ["", "lemmas real_alg_code_eqns =  \n  one_real_alg\n  zero_real_alg\n  uminus_real_alg\n  root_real_alg\n  minus_real_alg\n  plus_real_alg\n  times_real_alg\n  inverse_real_alg\n  divide_real_alg\n  equal_real_alg\n  less_real_alg\n  less_eq_real_alg\n  compare_real_alg\n  sgn_real_alg\n  abs_real_alg\n  floor_real_alg\n  is_rat_real_alg\n  to_rat_real_alg"], ["", "code_datatype real_of"], ["", "declare [[code drop:\n  \"plus :: real \\<Rightarrow> real \\<Rightarrow> real\"\n  \"uminus :: real \\<Rightarrow> real\"\n  \"minus :: real \\<Rightarrow> real \\<Rightarrow> real\"\n  \"times :: real \\<Rightarrow> real \\<Rightarrow> real\"\n  \"inverse :: real \\<Rightarrow> real\"\n  \"divide :: real \\<Rightarrow> real \\<Rightarrow> real\"\n  \"floor :: real \\<Rightarrow> int\"\n  \"HOL.equal :: real \\<Rightarrow> real \\<Rightarrow> bool\"\n  \"compare :: real \\<Rightarrow> real \\<Rightarrow> order\"\n  \"less_eq :: real \\<Rightarrow> real \\<Rightarrow> bool\"\n  \"less :: real \\<Rightarrow> real \\<Rightarrow> bool\"\n  \"0 :: real\"\n  \"1 :: real\"\n  \"sgn :: real \\<Rightarrow> real\"\n  \"abs :: real \\<Rightarrow> real\"\n  root]]"], ["", "declare real_alg_code_eqns [code equation]"], ["", "lemma Ratreal_code[code]:\n  \"Ratreal = real_of \\<circ> of_rat_real_alg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ratreal = real_of \\<circ> of_rat_real_alg", "by (transfer, transfer) (simp add: fun_eq_iff of_rat_2)"], ["", "lemma real_of_post[code_post]: \"real_of (Real_Alg_Quotient (Real_Alg_Invariant (Rational x))) = of_rat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of (Real_Alg_Quotient (Real_Alg_Invariant (Rational x))) =\n    real_of_rat x", "proof (transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. real_of_3 (Real_Alg_Invariant (Rational x)) = real_of_rat x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. real_of_3 (Real_Alg_Invariant (Rational x)) = real_of_rat x", "show \"real_of_3 (Real_Alg_Invariant (Rational x)) = real_of_rat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 (Real_Alg_Invariant (Rational x)) = real_of_rat x", "by (simp add: Real_Alg_Invariant_inverse real_of_3.rep_eq)"], ["proof (state)\nthis:\n  real_of_3 (Real_Alg_Invariant (Rational x)) = real_of_rat x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}