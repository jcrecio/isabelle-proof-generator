{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers/Resultant.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers", "problem_names": ["lemma vec_of_poly_rev_shifted_dim[simp]: \"dim_vec (vec_of_poly_rev_shifted p n j) = n\"", "lemma col_sylvester:\n  fixes p q\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes j: \"j < m+n\"\n  shows \"col (sylvester_mat p q) j =\n    vec_of_poly_rev_shifted p n j @\\<^sub>v vec_of_poly_rev_shifted q m j\" (is \"?l = ?r\")", "lemma inj_on_diff_nat2: \"inj_on (\\<lambda>i. (n::nat) - i) {..n}\"", "lemma image_diff_atMost: \"(\\<lambda>i. (n::nat) - i) ` {..n} = {..n}\" (is \"?l = ?r\")", "lemma sylvester_sum_mat_upper:\n  fixes p q :: \"'a :: comm_semiring_1 poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes i: \"i < n\"\n  shows \"(\\<Sum>j<m+n. monom (sylvester_mat p q $$ (i,j)) (m + n - Suc j)) =\n    monom 1 (n - Suc i) * p\" (is \"sum ?f _ = ?r\")", "lemma sylvester_sum_mat_lower:\n  fixes p q :: \"'a :: comm_semiring_1 poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes ni: \"n \\<le> i\" and imn: \"i < m+n\"\n  shows \"(\\<Sum>j<m+n. monom (sylvester_mat p q $$ (i,j)) (m + n - Suc j)) =\n    monom 1 (m + n - Suc i) * q\" (is \"sum ?f _ = ?r\")", "lemma poly_of_vec_of_poly[simp]:\n  fixes p :: \"'a :: comm_monoid_add poly\"\n  shows \"poly_of_vec (vec_of_poly p) = p\"", "lemma poly_of_vec_0[simp]: \"poly_of_vec (0\\<^sub>v n) = 0\"", "lemma poly_of_vec_0_iff[simp]:\n  fixes v  :: \"'a :: comm_monoid_add vec\"\n  shows \"poly_of_vec v = 0 \\<longleftrightarrow> v = 0\\<^sub>v (dim_vec v)\" (is \"?v = _ \\<longleftrightarrow> _ = ?z\")", "lemma degree_sum_smaller:\n  assumes \"n > 0\" \"finite A\"\n  shows \"(\\<And> x. x \\<in>A \\<Longrightarrow> degree (f x) < n) \\<Longrightarrow> degree (\\<Sum>x\\<in>A. f x) < n\"", "lemma degree_poly_of_vec_less:\n  fixes v :: \"'a :: comm_monoid_add vec\"\n  assumes dim: \"dim_vec v > 0\"\n  shows \"degree (poly_of_vec v) < dim_vec v\"", "lemma coeff_poly_of_vec:\n  \"coeff (poly_of_vec v) i = (if i < dim_vec v then v $ (dim_vec v - Suc i) else 0)\"\n  (is \"?l = ?r\")", "lemma vec_of_poly_rev_shifted_scalar_prod:\n  fixes p v\n  defines \"q \\<equiv> poly_of_vec v\"\n  assumes m[simp]: \"degree p = m\" and n: \"dim_vec v = n\"\n  assumes j: \"j < m+n\"\n  shows \"vec_of_poly_rev_shifted p n (n+m-Suc j) \\<bullet> v = coeff (p * q) j\" (is \"?l = ?r\")", "lemma sylvester_vec_poly:\n  fixes p q :: \"'a :: comm_semiring_0 poly\"\n  defines \"m \\<equiv> degree p\"\n      and \"n \\<equiv> degree q\"\n  assumes v: \"v \\<in> carrier_vec (m+n)\"\n  shows \"poly_of_vec (transpose_mat (sylvester_mat p q) *\\<^sub>v v) =\n    poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q\" (is \"?l = ?r\")", "lemma(in comm_ring_hom) resultant_sub_map_poly:\n  fixes p q :: \"'a poly\"\n  shows \"hom (resultant_sub m n p q) = resultant_sub m n (map_poly hom p) (map_poly hom q)\"\n    (is \"?l = ?r'\")", "lemma mk_poly_sub_dim[simp]:\n  \"dim_row (mk_poly_sub A l j) = dim_row A\"\n  \"dim_col (mk_poly_sub A l j) = dim_col A\"", "lemma mk_poly_sub_carrier:\n  assumes \"A \\<in> carrier_mat nr nc\" shows \"mk_poly_sub A l j \\<in> carrier_mat nr nc\"", "lemma mk_poly_dim[simp]:\n  \"dim_col (mk_poly A) = dim_col A\"\n  \"dim_row (mk_poly A) = dim_row A\"", "lemma mk_poly_sub_others[simp]:\n  assumes \"l \\<noteq> j'\" and \"i < dim_row A\" and \"j' < dim_col A\"\n  shows \"mk_poly_sub A l j $$ (i,j') = A $$ (i,j')\"", "lemma mk_poly_others[simp]:\n  assumes i: \"i < dim_row A\" and j: \"j < dim_col A - 1\"\n  shows \"mk_poly A $$ (i,j) = [: A $$ (i,j) :]\"", "lemma mk_poly_delete[simp]:\n  assumes i: \"i < dim_row A\"\n  shows \"mat_delete (mk_poly A) i (dim_col A - 1) = map_mat coeff_lift (mat_delete A i (dim_col A - 1))\"", "lemma col_mk_poly_sub[simp]:\n  assumes \"l \\<noteq> j'\" and \"j' < dim_col A\"\n  shows \"col (mk_poly_sub A l j) j' = col A j'\"", "lemma det_mk_poly_sub:\n  assumes A: \"(A :: 'a :: comm_ring_1 poly mat) \\<in> carrier_mat n n\" and i: \"i < n\"\n  shows \"det (mk_poly_sub A (n-1) i) = det A\"", "lemma det_mk_poly:\n  fixes A :: \"'a :: comm_ring_1 mat\"\n  shows \"det (mk_poly A) = [: det A :]\"", "lemma mk_poly2_row_dim[simp]: \"dim_vec (mk_poly2_row A d j pv i) = dim_vec pv\"", "lemma mk_poly2_col_dim[simp]: \"dim_vec (mk_poly2_col A pv j) = dim_vec pv\"", "lemma mk_poly2_row:\n  assumes n: \"n \\<le> dim_vec pv\"\n  shows \"mk_poly2_row A d j pv n $ i =\n    (if i < n then pv $ i + monom (A $$ (i,j)) d else pv $ i)\"", "lemma mk_poly2_row_col:\n  assumes dim[simp]: \"dim_vec pv = n\" \"dim_row A = n\" and j: \"j < dim_col A\"\n  shows \"mk_poly2_row A d j pv n = pv + map_vec (\\<lambda>a. monom a d) (col A j)\"", "lemma mk_poly2_col:\n  fixes pv :: \"'a :: comm_semiring_1 poly vec\" and A :: \"'a mat\"\n  assumes i: \"i < dim_row A\" and dim: \"dim_row A = dim_vec pv\"\n  shows \"mk_poly2_col A pv j $ i = pv $ i + (\\<Sum>j'<j. monom (A $$ (i, dim_col A - Suc j')) j')\"", "lemma mk_poly2_pre:\n  fixes A :: \"'a :: comm_semiring_1 mat\"\n  assumes i: \"i < dim_row A\"\n  shows \"mk_poly2 A $ i = (\\<Sum>j'<dim_col A. monom (A $$ (i, dim_col A - Suc j')) j')\"", "lemma mk_poly2:\n  fixes A :: \"'a :: comm_semiring_1 mat\"\n  assumes i: \"i < dim_row A\"\n      and c: \"dim_col A > 0\"\n  shows \"mk_poly2 A $ i = (\\<Sum>j'<dim_col A. monom (A $$ (i,j')) (dim_col A - Suc  j'))\"\n    (is \"?l = sum ?f ?S\")", "lemma mk_poly2_sylvester_upper:\n  fixes p q :: \"'a :: comm_semiring_1 poly\"\n  assumes i: \"i < degree q\"\n  shows \"mk_poly2 (sylvester_mat p q) $ i = monom 1 (degree q - Suc i) * p\"", "lemma mk_poly2_sylvester_lower:\n  fixes p q :: \"'a :: comm_semiring_1 poly\"\n  assumes mi: \"i \\<ge> degree q\" and imn: \"i < degree p + degree q\"\n  shows \"mk_poly2 (sylvester_mat p q) $ i = monom 1 (degree p + degree q - Suc i) * q\"", "lemma foo:\n  fixes v :: \"'a :: comm_semiring_1 vec\"\n  shows \"monom 1 d \\<cdot>\\<^sub>v map_vec coeff_lift v = map_vec (\\<lambda>a. monom a d) v\"", "lemma mk_poly_sub_corresp:\n  assumes dimA[simp]: \"dim_col A = Suc l\" and dimpv[simp]: \"dim_vec pv = dim_row A\"\n      and j: \"j < dim_col A\"\n  shows \"pv + col (mk_poly_sub (map_mat coeff_lift A) l j) l =\n    mk_poly2_col A pv (Suc j)\"", "lemma col_mk_poly_mk_poly2:\n  fixes A :: \"'a :: comm_semiring_1 mat\"\n  assumes dim: \"dim_col A > 0\"\n  shows \"col (mk_poly A) (dim_col A - 1) = mk_poly2 A\"", "lemma mk_poly_mk_poly2:\n  fixes A :: \"'a :: comm_semiring_1 mat\"\n  assumes dim: \"dim_col A > 0\" and i: \"i < dim_row A\"\n  shows \"mk_poly A $$ (i,dim_col A - 1) = mk_poly2 A $ i\"", "lemma mk_poly_sylvester_upper:\n  fixes p q :: \"'a :: comm_ring_1 poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes i: \"i < n\"\n  shows \"mk_poly (sylvester_mat p q) $$ (i, m + n - 1) = monom 1 (n - Suc i) * p\" (is \"?l = ?r\")", "lemma mk_poly_sylvester_lower:\n  fixes p q :: \"'a :: comm_ring_1 poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes ni: \"n \\<le> i\" and imn: \"i < m+n\"\n  shows \"mk_poly (sylvester_mat p q) $$ (i, m + n - 1) = monom 1 (m + n - Suc i) * q\" (is \"?l = ?r\")", "lemma resultant_as_poly:\n  fixes p q :: \"'a :: comm_ring_1 poly\"\n  assumes degp: \"degree p > 0\" and degq: \"degree q > 0\"\n  shows \"\\<exists>p' q'. degree p' < degree q \\<and> degree q' < degree p \\<and>\n         [: resultant p q :] = p' * p + q' * q\"", "lemma resultant_zero:\n  fixes p q :: \"'a :: comm_ring_1 poly\"\n  assumes deg: \"degree p > 0 \\<or> degree q > 0\"\n      and xp: \"poly p x = 0\" and xq: \"poly q x = 0\"\n  shows \"resultant p q = 0\"", "lemma poly_resultant_zero:\n  fixes p q :: \"'a :: comm_ring_1 poly poly\"\n  assumes deg: \"degree p > 0 \\<or> degree q > 0\"\n  assumes p0: \"poly2 p x y = 0\" and q0: \"poly2 q x y = 0\"\n  shows \"poly (resultant p q) x = 0\"", "lemma resultant_as_nonzero_poly_weak:\n  fixes p q :: \"'a :: idom poly\"\n  assumes degp: \"degree p > 0\" and degq: \"degree q > 0\"\n      and r0: \"resultant p q \\<noteq> 0\"\n  shows \"\\<exists>p' q'. degree p' < degree q \\<and> degree q' < degree p \\<and>\n         [: resultant p q :] = p' * p + q' * q \\<and> p' \\<noteq> 0 \\<and> q' \\<noteq> 0\"", "lemma resultant_as_nonzero_poly:\n  fixes p q :: \"'a :: idom poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes degp: \"m > 0\" and degq: \"n > 0\"\n  shows \"\\<exists>p' q'. degree p' < n \\<and> degree q' < m \\<and>\n         [: resultant p q :] = p' * p + q' * q \\<and> p' \\<noteq> 0 \\<and> q' \\<noteq> 0\"", "lemma resultant_zero_imp_common_factor:\n  fixes p q :: \"'a :: ufd poly\"\n  assumes deg: \"degree p > 0 \\<or> degree q > 0\" and r0: \"resultant p q = 0\"\n  shows \"\\<not> coprime p q\"", "lemma resultant_non_zero_imp_coprime:\n  assumes nz: \"resultant (f :: 'a :: field poly) g \\<noteq> 0\" \n  and nz': \"f \\<noteq> 0 \\<or> g \\<noteq> 0\" \nshows \"coprime f g\""], "translations": [["", "lemma vec_of_poly_rev_shifted_dim[simp]: \"dim_vec (vec_of_poly_rev_shifted p n j) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_of_poly_rev_shifted p n j) = n", "unfolding vec_of_poly_rev_shifted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec n\n       (\\<lambda>i.\n           if i \\<le> j \\<and> j \\<le> degree p + i\n           then coeff p (degree p + i - j) else (0::'a))) =\n    n", "by auto"], ["", "lemma col_sylvester:\n  fixes p q\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes j: \"j < m+n\"\n  shows \"col (sylvester_mat p q) j =\n    vec_of_poly_rev_shifted p n j @\\<^sub>v vec_of_poly_rev_shifted q m j\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (sylvester_mat p q) j =\n    vec_of_poly_rev_shifted p n j @\\<^sub>v vec_of_poly_rev_shifted q m j", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (vec_of_poly_rev_shifted p n j @\\<^sub>v\n             vec_of_poly_rev_shifted q m j) \\<Longrightarrow>\n       col (sylvester_mat p q) j $ i =\n       (vec_of_poly_rev_shifted p n j @\\<^sub>v\n        vec_of_poly_rev_shifted q m j) $\n       i\n 2. dim_vec (col (sylvester_mat p q) j) =\n    dim_vec\n     (vec_of_poly_rev_shifted p n j @\\<^sub>v vec_of_poly_rev_shifted q m j)", "note [simp] = m_def[symmetric] n_def[symmetric]"], ["proof (state)\nthis:\n  degree p \\<equiv> m\n  degree q \\<equiv> n\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (vec_of_poly_rev_shifted p n j @\\<^sub>v\n             vec_of_poly_rev_shifted q m j) \\<Longrightarrow>\n       col (sylvester_mat p q) j $ i =\n       (vec_of_poly_rev_shifted p n j @\\<^sub>v\n        vec_of_poly_rev_shifted q m j) $\n       i\n 2. dim_vec (col (sylvester_mat p q) j) =\n    dim_vec\n     (vec_of_poly_rev_shifted p n j @\\<^sub>v vec_of_poly_rev_shifted q m j)", "show \"dim_vec ?l = dim_vec ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (col (sylvester_mat p q) j) =\n    dim_vec\n     (vec_of_poly_rev_shifted p n j @\\<^sub>v vec_of_poly_rev_shifted q m j)", "by simp"], ["proof (state)\nthis:\n  dim_vec (col (sylvester_mat p q) j) =\n  dim_vec\n   (vec_of_poly_rev_shifted p n j @\\<^sub>v vec_of_poly_rev_shifted q m j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (vec_of_poly_rev_shifted p n j @\\<^sub>v\n             vec_of_poly_rev_shifted q m j) \\<Longrightarrow>\n       col (sylvester_mat p q) j $ i =\n       (vec_of_poly_rev_shifted p n j @\\<^sub>v\n        vec_of_poly_rev_shifted q m j) $\n       i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (vec_of_poly_rev_shifted p n j @\\<^sub>v\n             vec_of_poly_rev_shifted q m j) \\<Longrightarrow>\n       col (sylvester_mat p q) j $ i =\n       (vec_of_poly_rev_shifted p n j @\\<^sub>v\n        vec_of_poly_rev_shifted q m j) $\n       i", "assume \"i < dim_vec ?r\""], ["proof (state)\nthis:\n  i < dim_vec\n       (vec_of_poly_rev_shifted p n j @\\<^sub>v\n        vec_of_poly_rev_shifted q m j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (vec_of_poly_rev_shifted p n j @\\<^sub>v\n             vec_of_poly_rev_shifted q m j) \\<Longrightarrow>\n       col (sylvester_mat p q) j $ i =\n       (vec_of_poly_rev_shifted p n j @\\<^sub>v\n        vec_of_poly_rev_shifted q m j) $\n       i", "hence i: \"i < m+n\""], ["proof (prove)\nusing this:\n  i < dim_vec\n       (vec_of_poly_rev_shifted p n j @\\<^sub>v\n        vec_of_poly_rev_shifted q m j)\n\ngoal (1 subgoal):\n 1. i < m + n", "by auto"], ["proof (state)\nthis:\n  i < m + n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (vec_of_poly_rev_shifted p n j @\\<^sub>v\n             vec_of_poly_rev_shifted q m j) \\<Longrightarrow>\n       col (sylvester_mat p q) j $ i =\n       (vec_of_poly_rev_shifted p n j @\\<^sub>v\n        vec_of_poly_rev_shifted q m j) $\n       i", "show \"?l $ i = ?r $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (sylvester_mat p q) j $ i =\n    (vec_of_poly_rev_shifted p n j @\\<^sub>v\n     vec_of_poly_rev_shifted q m j) $\n    i", "unfolding vec_of_poly_rev_shifted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (sylvester_mat p q) j $ i =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "apply (subst index_col)"], ["proof (prove)\ngoal (3 subgoals):\n 1. i < dim_row (sylvester_mat p q)\n 2. j < dim_col (sylvester_mat p q)\n 3. sylvester_mat p q $$ (i, j) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "using i"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (3 subgoals):\n 1. i < dim_row (sylvester_mat p q)\n 2. j < dim_col (sylvester_mat p q)\n 3. sylvester_mat p q $$ (i, j) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. j < dim_col (sylvester_mat p q)\n 2. sylvester_mat p q $$ (i, j) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "using j"], ["proof (prove)\nusing this:\n  j < m + n\n\ngoal (2 subgoals):\n 1. j < dim_col (sylvester_mat p q)\n 2. sylvester_mat p q $$ (i, j) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sylvester_mat p q $$ (i, j) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "apply (subst sylvester_index_mat)"], ["proof (prove)\ngoal (3 subgoals):\n 1. i < degree p + degree q\n 2. j < degree p + degree q\n 3. (if i < degree q\n     then if i \\<le> j \\<and> j - i \\<le> degree p\n          then coeff p (degree p + i - j) else (0::'a)\n     else if i - degree q \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "using i"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (3 subgoals):\n 1. i < degree p + degree q\n 2. j < degree p + degree q\n 3. (if i < degree q\n     then if i \\<le> j \\<and> j - i \\<le> degree p\n          then coeff p (degree p + i - j) else (0::'a)\n     else if i - degree q \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. j < degree p + degree q\n 2. (if i < degree q\n     then if i \\<le> j \\<and> j - i \\<le> degree p\n          then coeff p (degree p + i - j) else (0::'a)\n     else if i - degree q \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "using j"], ["proof (prove)\nusing this:\n  j < m + n\n\ngoal (2 subgoals):\n 1. j < degree p + degree q\n 2. (if i < degree q\n     then if i \\<le> j \\<and> j - i \\<le> degree p\n          then coeff p (degree p + i - j) else (0::'a)\n     else if i - degree q \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < degree q\n     then if i \\<le> j \\<and> j - i \\<le> degree p\n          then coeff p (degree p + i - j) else (0::'a)\n     else if i - degree q \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "apply (cases \"i < n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < n \\<Longrightarrow>\n    (if i < degree q\n     then if i \\<le> j \\<and> j - i \\<le> degree p\n          then coeff p (degree p + i - j) else (0::'a)\n     else if i - degree q \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i\n 2. \\<not> i < n \\<Longrightarrow>\n    (if i < degree q\n     then if i \\<le> j \\<and> j - i \\<le> degree p\n          then coeff p (degree p + i - j) else (0::'a)\n     else if i - degree q \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    (if i < degree q\n     then if i \\<le> j \\<and> j - i \\<le> degree p\n          then coeff p (degree p + i - j) else (0::'a)\n     else if i - degree q \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "using i"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (1 subgoal):\n 1. \\<not> i < n \\<Longrightarrow>\n    (if i < degree q\n     then if i \\<le> j \\<and> j - i \\<le> degree p\n          then coeff p (degree p + i - j) else (0::'a)\n     else if i - degree q \\<le> j \\<and> j \\<le> i then coeff q (i - j)\n          else (0::'a)) =\n    (vec n\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree p + i\n          then coeff p (degree p + i - j) else (0::'a)) @\\<^sub>v\n     vec m\n      (\\<lambda>i.\n          if i \\<le> j \\<and> j \\<le> degree q + i\n          then coeff q (degree q + i - j) else (0::'a))) $\n    i", "by simp"], ["proof (state)\nthis:\n  col (sylvester_mat p q) j $ i =\n  (vec_of_poly_rev_shifted p n j @\\<^sub>v vec_of_poly_rev_shifted q m j) $\n  i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_diff_nat2: \"inj_on (\\<lambda>i. (n::nat) - i) {..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((-) n) {..n}", "by (rule inj_onI, auto)"], ["", "lemma image_diff_atMost: \"(\\<lambda>i. (n::nat) - i) ` {..n} = {..n}\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (-) n ` {..n} = {..n}", "unfolding set_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (x \\<in> (-) n ` {..n}) = (x \\<in> {..n})", "proof (intro allI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> (-) n ` {..n} \\<Longrightarrow> x \\<in> {..n}\n 2. \\<And>x. x \\<in> {..n} \\<Longrightarrow> x \\<in> (-) n ` {..n}", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> (-) n ` {..n} \\<Longrightarrow> x \\<in> {..n}\n 2. \\<And>x. x \\<in> {..n} \\<Longrightarrow> x \\<in> (-) n ` {..n}", "assume x: \"x \\<in> ?r\""], ["proof (state)\nthis:\n  x \\<in> {..n}\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> (-) n ` {..n} \\<Longrightarrow> x \\<in> {..n}\n 2. \\<And>x. x \\<in> {..n} \\<Longrightarrow> x \\<in> (-) n ` {..n}", "thus \"x \\<in> ?l\""], ["proof (prove)\nusing this:\n  x \\<in> {..n}\n\ngoal (1 subgoal):\n 1. x \\<in> (-) n ` {..n}", "unfolding image_def mem_Collect_eq"], ["proof (prove)\nusing this:\n  x \\<in> {..n}\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>{..n}. x = n - xa", "by(intro bexI[of _ \"n-x\"],auto)"], ["proof (state)\nthis:\n  x \\<in> (-) n ` {..n}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> (-) n ` {..n} \\<Longrightarrow> x \\<in> {..n}", "qed auto"], ["", "lemma sylvester_sum_mat_upper:\n  fixes p q :: \"'a :: comm_semiring_1 poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes i: \"i < n\"\n  shows \"(\\<Sum>j<m+n. monom (sylvester_mat p q $$ (i,j)) (m + n - Suc j)) =\n    monom 1 (n - Suc i) * p\" (is \"sum ?f _ = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "have n1: \"n \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> n", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. 1 \\<le> n", "by auto"], ["proof (state)\nthis:\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "define ni1 where \"ni1 = n-Suc i\""], ["proof (state)\nthis:\n  ni1 = n - Suc i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "hence ni1: \"n-i = Suc ni1\""], ["proof (prove)\nusing this:\n  ni1 = n - Suc i\n\ngoal (1 subgoal):\n 1. n - i = Suc ni1", "using i"], ["proof (prove)\nusing this:\n  ni1 = n - Suc i\n  i < n\n\ngoal (1 subgoal):\n 1. n - i = Suc ni1", "by auto"], ["proof (state)\nthis:\n  n - i = Suc ni1\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "define l where \"l = m+n-1\""], ["proof (state)\nthis:\n  l = m + n - 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "hence l: \"Suc l = m+n\""], ["proof (prove)\nusing this:\n  l = m + n - 1\n\ngoal (1 subgoal):\n 1. Suc l = m + n", "using n1"], ["proof (prove)\nusing this:\n  l = m + n - 1\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. Suc l = m + n", "by auto"], ["proof (state)\nthis:\n  Suc l = m + n\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "let ?g = \"\\<lambda>j. monom (coeff (monom 1 (n-Suc i) * p) j) j\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "let ?p = \"\\<lambda>j. l-j\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "have \"sum ?f {..<m+n} = sum ?f {..l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j))", "unfolding l[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<Suc l. monom (sylvester_mat p q $$ (i, j)) (Suc l - Suc j)) =\n    (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (Suc l - Suc j))", "unfolding lessThan_Suc_atMost"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (Suc l - Suc j)) =\n    (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (Suc l - Suc j))", ".."], ["proof (state)\nthis:\n  (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "also"], ["proof (state)\nthis:\n  (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "{"], ["proof (state)\nthis:\n  (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "assume j: \"j\\<le>l\""], ["proof (state)\nthis:\n  j \\<le> l\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "have \"?f j = ((\\<lambda>j. monom (coeff (monom 1 (n-i) * p) (Suc j)) j) \\<circ> ?p) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n    ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (n - i) * p) (Suc j)) j) \\<circ>\n     (-) l)\n     j", "apply(subst sylvester_index_mat2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. i < degree p + degree q\n 2. j < degree p + degree q\n 3. monom\n     (if i < degree q\n      then coeff (monom (1::'a) (degree q - i) * p)\n            (degree p + degree q - j)\n      else coeff (monom (1::'a) (degree p + degree q - i) * q)\n            (degree p + degree q - j))\n     (m + n - Suc j) =\n    ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (n - i) * p) (Suc j)) j) \\<circ>\n     (-) l)\n     j", "using i j"], ["proof (prove)\nusing this:\n  i < n\n  j \\<le> l\n\ngoal (3 subgoals):\n 1. i < degree p + degree q\n 2. j < degree p + degree q\n 3. monom\n     (if i < degree q\n      then coeff (monom (1::'a) (degree q - i) * p)\n            (degree p + degree q - j)\n      else coeff (monom (1::'a) (degree p + degree q - i) * q)\n            (degree p + degree q - j))\n     (m + n - Suc j) =\n    ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (n - i) * p) (Suc j)) j) \\<circ>\n     (-) l)\n     j", "unfolding l_def m_def[symmetric] n_def[symmetric]"], ["proof (prove)\nusing this:\n  i < n\n  j \\<le> m + n - 1\n\ngoal (3 subgoals):\n 1. i < m + n\n 2. j < m + n\n 3. monom\n     (if i < n then coeff (monom (1::'a) (n - i) * p) (m + n - j)\n      else coeff (monom (1::'a) (m + n - i) * q) (m + n - j))\n     (m + n - Suc j) =\n    ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (n - i) * p) (Suc j)) j) \\<circ>\n     (-) (m + n - 1))\n     j", "by (auto simp add: Suc_diff_Suc)"], ["proof (state)\nthis:\n  monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n  ((\\<lambda>j. monom (coeff (monom (1::'a) (n - i) * p) (Suc j)) j) \\<circ>\n   (-) l)\n   j\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "also"], ["proof (state)\nthis:\n  monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n  ((\\<lambda>j. monom (coeff (monom (1::'a) (n - i) * p) (Suc j)) j) \\<circ>\n   (-) l)\n   j\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "have \"... = (?g \\<circ> ?p) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (n - i) * p) (Suc j)) j) \\<circ>\n     (-) l)\n     j =\n    ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n     (-) l)\n     j", "unfolding ni1"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (Suc ni1) * p) (Suc j)) j) \\<circ>\n     (-) l)\n     j =\n    ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n     (-) l)\n     j", "unfolding coeff_monom_Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>j. monom (coeff (monom (1::'a) ni1 * p) j) j) \\<circ> (-) l)\n     j =\n    ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n     (-) l)\n     j", "unfolding ni1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n     (-) l)\n     j =\n    ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n     (-) l)\n     j", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n     (-) l)\n     j =\n    ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n     (-) l)\n     j", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>j. monom (coeff (monom (1::'a) (n - i) * p) (Suc j)) j) \\<circ>\n   (-) l)\n   j =\n  ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n   (-) l)\n   j\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "finally"], ["proof (chain)\npicking this:\n  monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n  ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n   (-) l)\n   j", "have \"?f j = (?g \\<circ> ?p) j\""], ["proof (prove)\nusing this:\n  monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n  ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n   (-) l)\n   j\n\ngoal (1 subgoal):\n 1. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n    ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n     (-) l)\n     j", "."], ["proof (state)\nthis:\n  monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n  ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n   (-) l)\n   j\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "}"], ["proof (state)\nthis:\n  ?j2 \\<le> l \\<Longrightarrow>\n  monom (sylvester_mat p q $$ (i, ?j2)) (m + n - Suc ?j2) =\n  ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n   (-) l)\n   ?j2\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "hence \"(\\<Sum>j\\<le>l. ?f j) = (\\<Sum>j\\<le>l. (?g\\<circ>?p) j)\""], ["proof (prove)\nusing this:\n  ?j2 \\<le> l \\<Longrightarrow>\n  monom (sylvester_mat p q $$ (i, ?j2)) (m + n - Suc ?j2) =\n  ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n   (-) l)\n   ?j2\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    sum ((\\<lambda>j.\n             monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n         (-) l)\n     {..l}", "using l"], ["proof (prove)\nusing this:\n  ?j2 \\<le> l \\<Longrightarrow>\n  monom (sylvester_mat p q $$ (i, ?j2)) (m + n - Suc ?j2) =\n  ((\\<lambda>j. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n   (-) l)\n   ?j2\n  Suc l = m + n\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    sum ((\\<lambda>j.\n             monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n         (-) l)\n     {..l}", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  sum ((\\<lambda>j.\n           monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n       (-) l)\n   {..l}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  sum ((\\<lambda>j.\n           monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n       (-) l)\n   {..l}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "have \"... = (\\<Sum>j\\<le>l. ?g j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>j.\n             monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n         (-) l)\n     {..l} =\n    (\\<Sum>j\\<le>l. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j)", "unfolding l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>j.\n             monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n         (-) (m + n - 1))\n     {..m + n - 1} =\n    (\\<Sum>j\\<le>m + n - 1.\n        monom (coeff (monom (1::'a) (n - Suc i) * p) j) j)", "using sum.reindex[OF inj_on_diff_nat2,symmetric,unfolded image_diff_atMost]"], ["proof (prove)\nusing this:\n  sum (?g \\<circ> (-) ?n) {..?n} = sum ?g {..?n}\n\ngoal (1 subgoal):\n 1. sum ((\\<lambda>j.\n             monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n         (-) (m + n - 1))\n     {..m + n - 1} =\n    (\\<Sum>j\\<le>m + n - 1.\n        monom (coeff (monom (1::'a) (n - Suc i) * p) j) j)", "."], ["proof (state)\nthis:\n  sum ((\\<lambda>j.\n           monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n       (-) l)\n   {..l} =\n  (\\<Sum>j\\<le>l. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "also"], ["proof (state)\nthis:\n  sum ((\\<lambda>j.\n           monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) \\<circ>\n       (-) l)\n   {..l} =\n  (\\<Sum>j\\<le>l. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "have \"degree ?r \\<le> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (n - Suc i) * p) \\<le> l", "using degree_mult_le[of \"monom 1 (n-Suc i)\" p]"], ["proof (prove)\nusing this:\n  degree (monom (1::'a) (n - Suc i) * p)\n  \\<le> degree (monom (1::'a) (n - Suc i)) + degree p\n\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (n - Suc i) * p) \\<le> l", "unfolding l_def m_def"], ["proof (prove)\nusing this:\n  degree (monom (1::'a) (n - Suc i) * p)\n  \\<le> degree (monom (1::'a) (n - Suc i)) + degree p\n\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (n - Suc i) * p) \\<le> degree p + n - 1", "unfolding degree_monom_eq[OF one_neq_zero]"], ["proof (prove)\nusing this:\n  degree (monom (1::'a) (n - Suc i) * p) \\<le> n - Suc i + degree p\n\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (n - Suc i) * p) \\<le> degree p + n - 1", "using i"], ["proof (prove)\nusing this:\n  degree (monom (1::'a) (n - Suc i) * p) \\<le> n - Suc i + degree p\n  i < n\n\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (n - Suc i) * p) \\<le> degree p + n - 1", "by auto"], ["proof (state)\nthis:\n  degree (monom (1::'a) (n - Suc i) * p) \\<le> l\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "from poly_as_sum_of_monoms'[OF this]"], ["proof (chain)\npicking this:\n  (\\<Sum>ia\\<le>l. monom (coeff (monom (1::'a) (n - Suc i) * p) ia) ia) =\n  monom (1::'a) (n - Suc i) * p", "have \"(\\<Sum>j\\<le>l. ?g j) = ?r\""], ["proof (prove)\nusing this:\n  (\\<Sum>ia\\<le>l. monom (coeff (monom (1::'a) (n - Suc i) * p) ia) ia) =\n  monom (1::'a) (n - Suc i) * p\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>l. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) =\n    monom (1::'a) (n - Suc i) * p", "."], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>l. monom (coeff (monom (1::'a) (n - Suc i) * p) j) j) =\n  monom (1::'a) (n - Suc i) * p\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  monom (1::'a) (n - Suc i) * p", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  monom (1::'a) (n - Suc i) * p\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (n - Suc i) * p", "."], ["proof (state)\nthis:\n  (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  monom (1::'a) (n - Suc i) * p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sylvester_sum_mat_lower:\n  fixes p q :: \"'a :: comm_semiring_1 poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes ni: \"n \\<le> i\" and imn: \"i < m+n\"\n  shows \"(\\<Sum>j<m+n. monom (sylvester_mat p q $$ (i,j)) (m + n - Suc j)) =\n    monom 1 (m + n - Suc i) * q\" (is \"sum ?f _ = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "define l where \"l = m+n-1\""], ["proof (state)\nthis:\n  l = m + n - 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "hence l: \"Suc l = m+n\""], ["proof (prove)\nusing this:\n  l = m + n - 1\n\ngoal (1 subgoal):\n 1. Suc l = m + n", "using imn"], ["proof (prove)\nusing this:\n  l = m + n - 1\n  i < m + n\n\ngoal (1 subgoal):\n 1. Suc l = m + n", "by auto"], ["proof (state)\nthis:\n  Suc l = m + n\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "define mni1 where \"mni1 = m + n - Suc i\""], ["proof (state)\nthis:\n  mni1 = m + n - Suc i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "hence mni1: \"m+n-i = Suc mni1\""], ["proof (prove)\nusing this:\n  mni1 = m + n - Suc i\n\ngoal (1 subgoal):\n 1. m + n - i = Suc mni1", "using imn"], ["proof (prove)\nusing this:\n  mni1 = m + n - Suc i\n  i < m + n\n\ngoal (1 subgoal):\n 1. m + n - i = Suc mni1", "by auto"], ["proof (state)\nthis:\n  m + n - i = Suc mni1\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "let ?g = \"\\<lambda>j. monom (coeff (monom 1 (m + n - Suc i) * q) j) j\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "let ?p = \"\\<lambda>j. l-j\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "have \"sum ?f {..<m+n} = sum ?f {..l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j))", "unfolding l[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<Suc l. monom (sylvester_mat p q $$ (i, j)) (Suc l - Suc j)) =\n    (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (Suc l - Suc j))", "unfolding lessThan_Suc_atMost"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (Suc l - Suc j)) =\n    (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (Suc l - Suc j))", ".."], ["proof (state)\nthis:\n  (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "also"], ["proof (state)\nthis:\n  (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "{"], ["proof (state)\nthis:\n  (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "assume j: \"j\\<le>l\""], ["proof (state)\nthis:\n  j \\<le> l\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "have \"?f j = ((\\<lambda>j. monom (coeff (monom 1 (m+n-i) * q) (Suc j)) j) \\<circ> ?p) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n    ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (m + n - i) * q) (Suc j)) j) \\<circ>\n     (-) l)\n     j", "apply(subst sylvester_index_mat2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. i < degree p + degree q\n 2. j < degree p + degree q\n 3. monom\n     (if i < degree q\n      then coeff (monom (1::'a) (degree q - i) * p)\n            (degree p + degree q - j)\n      else coeff (monom (1::'a) (degree p + degree q - i) * q)\n            (degree p + degree q - j))\n     (m + n - Suc j) =\n    ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (m + n - i) * q) (Suc j)) j) \\<circ>\n     (-) l)\n     j", "using ni imn j"], ["proof (prove)\nusing this:\n  n \\<le> i\n  i < m + n\n  j \\<le> l\n\ngoal (3 subgoals):\n 1. i < degree p + degree q\n 2. j < degree p + degree q\n 3. monom\n     (if i < degree q\n      then coeff (monom (1::'a) (degree q - i) * p)\n            (degree p + degree q - j)\n      else coeff (monom (1::'a) (degree p + degree q - i) * q)\n            (degree p + degree q - j))\n     (m + n - Suc j) =\n    ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (m + n - i) * q) (Suc j)) j) \\<circ>\n     (-) l)\n     j", "unfolding l_def m_def[symmetric] n_def[symmetric]"], ["proof (prove)\nusing this:\n  n \\<le> i\n  i < m + n\n  j \\<le> m + n - 1\n\ngoal (3 subgoals):\n 1. i < m + n\n 2. j < m + n\n 3. monom\n     (if i < n then coeff (monom (1::'a) (n - i) * p) (m + n - j)\n      else coeff (monom (1::'a) (m + n - i) * q) (m + n - j))\n     (m + n - Suc j) =\n    ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (m + n - i) * q) (Suc j)) j) \\<circ>\n     (-) (m + n - 1))\n     j", "by (auto simp add: Suc_diff_Suc)"], ["proof (state)\nthis:\n  monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n  ((\\<lambda>j.\n       monom (coeff (monom (1::'a) (m + n - i) * q) (Suc j)) j) \\<circ>\n   (-) l)\n   j\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "also"], ["proof (state)\nthis:\n  monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n  ((\\<lambda>j.\n       monom (coeff (monom (1::'a) (m + n - i) * q) (Suc j)) j) \\<circ>\n   (-) l)\n   j\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "have \"... = (?g \\<circ> ?p) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (m + n - i) * q) (Suc j)) j) \\<circ>\n     (-) l)\n     j =\n    ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n     (-) l)\n     j", "unfolding mni1"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (Suc mni1) * q) (Suc j)) j) \\<circ>\n     (-) l)\n     j =\n    ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n     (-) l)\n     j", "unfolding coeff_monom_Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>j. monom (coeff (monom (1::'a) mni1 * q) j) j) \\<circ> (-) l)\n     j =\n    ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n     (-) l)\n     j", "unfolding mni1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n     (-) l)\n     j =\n    ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n     (-) l)\n     j", ".."], ["proof (state)\nthis:\n  ((\\<lambda>j.\n       monom (coeff (monom (1::'a) (m + n - i) * q) (Suc j)) j) \\<circ>\n   (-) l)\n   j =\n  ((\\<lambda>j.\n       monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n   (-) l)\n   j\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "finally"], ["proof (chain)\npicking this:\n  monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n  ((\\<lambda>j.\n       monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n   (-) l)\n   j", "have \"?f j = ...\""], ["proof (prove)\nusing this:\n  monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n  ((\\<lambda>j.\n       monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n   (-) l)\n   j\n\ngoal (1 subgoal):\n 1. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n    ((\\<lambda>j.\n         monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n     (-) l)\n     j", "."], ["proof (state)\nthis:\n  monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j) =\n  ((\\<lambda>j.\n       monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n   (-) l)\n   j\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "}"], ["proof (state)\nthis:\n  ?j2 \\<le> l \\<Longrightarrow>\n  monom (sylvester_mat p q $$ (i, ?j2)) (m + n - Suc ?j2) =\n  ((\\<lambda>j.\n       monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n   (-) l)\n   ?j2\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "hence \"(\\<Sum>j\\<le>l. ?f j) = (\\<Sum>j\\<le>l. (?g\\<circ>?p) j)\""], ["proof (prove)\nusing this:\n  ?j2 \\<le> l \\<Longrightarrow>\n  monom (sylvester_mat p q $$ (i, ?j2)) (m + n - Suc ?j2) =\n  ((\\<lambda>j.\n       monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n   (-) l)\n   ?j2\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    sum ((\\<lambda>j.\n             monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n         (-) l)\n     {..l}", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  sum ((\\<lambda>j.\n           monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n       (-) l)\n   {..l}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>l. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  sum ((\\<lambda>j.\n           monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n       (-) l)\n   {..l}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "have \"... = (\\<Sum>j\\<le>l. ?g j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>j.\n             monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n         (-) l)\n     {..l} =\n    (\\<Sum>j\\<le>l. monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j)", "using sum.reindex[OF inj_on_diff_nat2,symmetric,unfolded image_diff_atMost]"], ["proof (prove)\nusing this:\n  sum (?g \\<circ> (-) ?n) {..?n} = sum ?g {..?n}\n\ngoal (1 subgoal):\n 1. sum ((\\<lambda>j.\n             monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n         (-) l)\n     {..l} =\n    (\\<Sum>j\\<le>l. monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j)", "."], ["proof (state)\nthis:\n  sum ((\\<lambda>j.\n           monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n       (-) l)\n   {..l} =\n  (\\<Sum>j\\<le>l. monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "also"], ["proof (state)\nthis:\n  sum ((\\<lambda>j.\n           monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) \\<circ>\n       (-) l)\n   {..l} =\n  (\\<Sum>j\\<le>l. monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "have \"degree ?r \\<le> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (m + n - Suc i) * q) \\<le> l", "using degree_mult_le[of \"monom 1 (m+n-1-i)\" q]"], ["proof (prove)\nusing this:\n  degree (monom (1::'a) (m + n - 1 - i) * q)\n  \\<le> degree (monom (1::'a) (m + n - 1 - i)) + degree q\n\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (m + n - Suc i) * q) \\<le> l", "unfolding l_def n_def[symmetric]"], ["proof (prove)\nusing this:\n  degree (monom (1::'a) (m + n - 1 - i) * q)\n  \\<le> degree (monom (1::'a) (m + n - 1 - i)) + n\n\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (m + n - Suc i) * q) \\<le> m + n - 1", "unfolding degree_monom_eq[OF one_neq_zero]"], ["proof (prove)\nusing this:\n  degree (monom (1::'a) (m + n - 1 - i) * q) \\<le> m + n - 1 - i + n\n\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (m + n - Suc i) * q) \\<le> m + n - 1", "using ni imn"], ["proof (prove)\nusing this:\n  degree (monom (1::'a) (m + n - 1 - i) * q) \\<le> m + n - 1 - i + n\n  n \\<le> i\n  i < m + n\n\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (m + n - Suc i) * q) \\<le> m + n - 1", "by auto"], ["proof (state)\nthis:\n  degree (monom (1::'a) (m + n - Suc i) * q) \\<le> l\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "from poly_as_sum_of_monoms'[OF this]"], ["proof (chain)\npicking this:\n  (\\<Sum>ia\\<le>l.\n      monom (coeff (monom (1::'a) (m + n - Suc i) * q) ia) ia) =\n  monom (1::'a) (m + n - Suc i) * q", "have \"(\\<Sum>j\\<le>l. ?g j) = ?r\""], ["proof (prove)\nusing this:\n  (\\<Sum>ia\\<le>l.\n      monom (coeff (monom (1::'a) (m + n - Suc i) * q) ia) ia) =\n  monom (1::'a) (m + n - Suc i) * q\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>l. monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) =\n    monom (1::'a) (m + n - Suc i) * q", "."], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>l. monom (coeff (monom (1::'a) (m + n - Suc i) * q) j) j) =\n  monom (1::'a) (m + n - Suc i) * q\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  monom (1::'a) (m + n - Suc i) * q", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  monom (1::'a) (m + n - Suc i) * q\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n    monom (1::'a) (m + n - Suc i) * q", "."], ["proof (state)\nthis:\n  (\\<Sum>j<m + n. monom (sylvester_mat p q $$ (i, j)) (m + n - Suc j)) =\n  monom (1::'a) (m + n - Suc i) * q\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"vec_of_poly p \\<equiv> let m = degree p in vec (Suc m) (\\<lambda>i. coeff p (m-i))\""], ["", "definition \"poly_of_vec v \\<equiv> let d = dim_vec v in \\<Sum>i<d. monom (v $ (d - Suc i)) i\""], ["", "lemma poly_of_vec_of_poly[simp]:\n  fixes p :: \"'a :: comm_monoid_add poly\"\n  shows \"poly_of_vec (vec_of_poly p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (vec_of_poly p) = p", "unfolding poly_of_vec_def vec_of_poly_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<dim_vec\n              (vec (Suc (degree p)) (\\<lambda>i. coeff p (degree p - i))).\n        monom\n         (vec (Suc (degree p)) (\\<lambda>i. coeff p (degree p - i)) $\n          (dim_vec\n            (vec (Suc (degree p)) (\\<lambda>i. coeff p (degree p - i))) -\n           Suc i))\n         i) =\n    p", "unfolding dim_vec"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<Suc (degree p).\n        monom\n         (vec (Suc (degree p)) (\\<lambda>i. coeff p (degree p - i)) $\n          (Suc (degree p) - Suc i))\n         i) =\n    p", "unfolding lessThan_Suc_atMost"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p.\n        monom\n         (vec (Suc (degree p)) (\\<lambda>i. coeff p (degree p - i)) $\n          (Suc (degree p) - Suc i))\n         i) =\n    p", "using poly_as_sum_of_monoms[of p]"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>degree p. monom (coeff p i) i) = p\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p.\n        monom\n         (vec (Suc (degree p)) (\\<lambda>i. coeff p (degree p - i)) $\n          (Suc (degree p) - Suc i))\n         i) =\n    p", "by auto"], ["", "lemma poly_of_vec_0[simp]: \"poly_of_vec (0\\<^sub>v n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (0\\<^sub>v n) = 0", "unfolding poly_of_vec_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<dim_vec (0\\<^sub>v n).\n        monom (0\\<^sub>v n $ (dim_vec (0\\<^sub>v n) - Suc i)) i) =\n    0", "by auto"], ["", "lemma poly_of_vec_0_iff[simp]:\n  fixes v  :: \"'a :: comm_monoid_add vec\"\n  shows \"poly_of_vec v = 0 \\<longleftrightarrow> v = 0\\<^sub>v (dim_vec v)\" (is \"?v = _ \\<longleftrightarrow> _ = ?z\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_of_vec v = 0) = (v = 0\\<^sub>v (dim_vec v))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_of_vec v = 0 \\<Longrightarrow> v = 0\\<^sub>v (dim_vec v)\n 2. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> poly_of_vec v = 0", "assume \"?v = 0\""], ["proof (state)\nthis:\n  poly_of_vec v = 0\n\ngoal (2 subgoals):\n 1. poly_of_vec v = 0 \\<Longrightarrow> v = 0\\<^sub>v (dim_vec v)\n 2. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> poly_of_vec v = 0", "hence \"\\<forall>i\\<in>{..<dim_vec v}. v $ (dim_vec v - Suc i) = 0\""], ["proof (prove)\nusing this:\n  poly_of_vec v = 0\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{..<dim_vec v}. v $ (dim_vec v - Suc i) = (0::'a)", "unfolding poly_of_vec_def Let_def"], ["proof (prove)\nusing this:\n  (\\<Sum>i<dim_vec v. monom (v $ (dim_vec v - Suc i)) i) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{..<dim_vec v}. v $ (dim_vec v - Suc i) = (0::'a)", "by (subst sum_monom_0_iff[symmetric],auto)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{..<dim_vec v}. v $ (dim_vec v - Suc i) = (0::'a)\n\ngoal (2 subgoals):\n 1. poly_of_vec v = 0 \\<Longrightarrow> v = 0\\<^sub>v (dim_vec v)\n 2. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> poly_of_vec v = 0", "hence a: \"\\<And>i. i < dim_vec v \\<Longrightarrow> v $ (dim_vec v - Suc i) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{..<dim_vec v}. v $ (dim_vec v - Suc i) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow> v $ (dim_vec v - Suc i) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  ?i < dim_vec v \\<Longrightarrow> v $ (dim_vec v - Suc ?i) = (0::'a)\n\ngoal (2 subgoals):\n 1. poly_of_vec v = 0 \\<Longrightarrow> v = 0\\<^sub>v (dim_vec v)\n 2. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> poly_of_vec v = 0", "{"], ["proof (state)\nthis:\n  ?i < dim_vec v \\<Longrightarrow> v $ (dim_vec v - Suc ?i) = (0::'a)\n\ngoal (2 subgoals):\n 1. poly_of_vec v = 0 \\<Longrightarrow> v = 0\\<^sub>v (dim_vec v)\n 2. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> poly_of_vec v = 0", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_of_vec v = 0 \\<Longrightarrow> v = 0\\<^sub>v (dim_vec v)\n 2. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> poly_of_vec v = 0", "assume \"i < dim_vec v\""], ["proof (state)\nthis:\n  i < dim_vec v\n\ngoal (2 subgoals):\n 1. poly_of_vec v = 0 \\<Longrightarrow> v = 0\\<^sub>v (dim_vec v)\n 2. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> poly_of_vec v = 0", "hence \"v $ i = 0\""], ["proof (prove)\nusing this:\n  i < dim_vec v\n\ngoal (1 subgoal):\n 1. v $ i = (0::'a)", "using a[of \"dim_vec v - Suc i\"]"], ["proof (prove)\nusing this:\n  i < dim_vec v\n  dim_vec v - Suc i < dim_vec v \\<Longrightarrow>\n  v $ (dim_vec v - Suc (dim_vec v - Suc i)) = (0::'a)\n\ngoal (1 subgoal):\n 1. v $ i = (0::'a)", "by auto"], ["proof (state)\nthis:\n  v $ i = (0::'a)\n\ngoal (2 subgoals):\n 1. poly_of_vec v = 0 \\<Longrightarrow> v = 0\\<^sub>v (dim_vec v)\n 2. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> poly_of_vec v = 0", "}"], ["proof (state)\nthis:\n  ?i2 < dim_vec v \\<Longrightarrow> v $ ?i2 = (0::'a)\n\ngoal (2 subgoals):\n 1. poly_of_vec v = 0 \\<Longrightarrow> v = 0\\<^sub>v (dim_vec v)\n 2. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> poly_of_vec v = 0", "thus \"v = ?z\""], ["proof (prove)\nusing this:\n  ?i2 < dim_vec v \\<Longrightarrow> v $ ?i2 = (0::'a)\n\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v (dim_vec v)", "by auto"], ["proof (state)\nthis:\n  v = 0\\<^sub>v (dim_vec v)\n\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> poly_of_vec v = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> poly_of_vec v = 0", "assume r: \"v = ?z\""], ["proof (state)\nthis:\n  v = 0\\<^sub>v (dim_vec v)\n\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v (dim_vec v) \\<Longrightarrow> poly_of_vec v = 0", "show \"?v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec v = 0", "apply (subst r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (0\\<^sub>v (dim_vec v)) = 0", "by auto"], ["proof (state)\nthis:\n  poly_of_vec v = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: move, copied from no longer existing Cayley-Hamilton/Polynomial_extension *)"], ["", "lemma degree_sum_smaller:\n  assumes \"n > 0\" \"finite A\"\n  shows \"(\\<And> x. x \\<in>A \\<Longrightarrow> degree (f x) < n) \\<Longrightarrow> degree (\\<Sum>x\\<in>A. f x) < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> A \\<Longrightarrow> degree (f x) < n) \\<Longrightarrow>\n    degree (sum f A) < n", "using \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> A \\<Longrightarrow> degree (f x) < n) \\<Longrightarrow>\n    degree (sum f A) < n", "by(induct rule: finite_induct)\n    (simp_all add: degree_add_less assms)"], ["", "lemma degree_poly_of_vec_less:\n  fixes v :: \"'a :: comm_monoid_add vec\"\n  assumes dim: \"dim_vec v > 0\"\n  shows \"degree (poly_of_vec v) < dim_vec v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_of_vec v) < dim_vec v", "unfolding poly_of_vec_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Sum>i<dim_vec v. monom (v $ (dim_vec v - Suc i)) i)\n    < dim_vec v", "apply(rule degree_sum_smaller)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < dim_vec v\n 2. finite {..<dim_vec v}\n 3. \\<And>i.\n       i \\<in> {..<dim_vec v} \\<Longrightarrow>\n       degree (monom (v $ (dim_vec v - Suc i)) i) < dim_vec v", "using dim"], ["proof (prove)\nusing this:\n  0 < dim_vec v\n\ngoal (3 subgoals):\n 1. 0 < dim_vec v\n 2. finite {..<dim_vec v}\n 3. \\<And>i.\n       i \\<in> {..<dim_vec v} \\<Longrightarrow>\n       degree (monom (v $ (dim_vec v - Suc i)) i) < dim_vec v", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {..<dim_vec v}\n 2. \\<And>i.\n       i \\<in> {..<dim_vec v} \\<Longrightarrow>\n       degree (monom (v $ (dim_vec v - Suc i)) i) < dim_vec v", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<dim_vec v} \\<Longrightarrow>\n       degree (monom (v $ (dim_vec v - Suc i)) i) < dim_vec v", "unfolding lessThan_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       degree (monom (v $ (dim_vec v - Suc i)) i) < dim_vec v", "by (metis degree_0 degree_monom_eq dim monom_eq_0_iff)"], ["", "lemma coeff_poly_of_vec:\n  \"coeff (poly_of_vec v) i = (if i < dim_vec v then v $ (dim_vec v - Suc i) else 0)\"\n  (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_of_vec v) i =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (poly_of_vec v) i =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "have \"?l = (\\<Sum>x<dim_vec v. if x = i then v $ (dim_vec v - Suc x) else 0)\" (is \"_ = ?m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_of_vec v) i =\n    (\\<Sum>x<dim_vec v. if x = i then v $ (dim_vec v - Suc x) else (0::'a))", "unfolding poly_of_vec_def Let_def coeff_sum coeff_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x<dim_vec v.\n        if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n    (\\<Sum>x<dim_vec v. if x = i then v $ (dim_vec v - Suc x) else (0::'a))", ".."], ["proof (state)\nthis:\n  coeff (poly_of_vec v) i =\n  (\\<Sum>x<dim_vec v. if x = i then v $ (dim_vec v - Suc x) else (0::'a))\n\ngoal (1 subgoal):\n 1. coeff (poly_of_vec v) i =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "also"], ["proof (state)\nthis:\n  coeff (poly_of_vec v) i =\n  (\\<Sum>x<dim_vec v. if x = i then v $ (dim_vec v - Suc x) else (0::'a))\n\ngoal (1 subgoal):\n 1. coeff (poly_of_vec v) i =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x<dim_vec v.\n        if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "proof (cases \"i < dim_vec v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < dim_vec v \\<Longrightarrow>\n    (\\<Sum>x<dim_vec v.\n        if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))\n 2. \\<not> i < dim_vec v \\<Longrightarrow>\n    (\\<Sum>x<dim_vec v.\n        if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "case False"], ["proof (state)\nthis:\n  \\<not> i < dim_vec v\n\ngoal (2 subgoals):\n 1. i < dim_vec v \\<Longrightarrow>\n    (\\<Sum>x<dim_vec v.\n        if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))\n 2. \\<not> i < dim_vec v \\<Longrightarrow>\n    (\\<Sum>x<dim_vec v.\n        if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x<dim_vec v.\n        if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "by (subst sum.neutral, insert False, auto)"], ["proof (state)\nthis:\n  (\\<Sum>x<dim_vec v. if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n  (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))\n\ngoal (1 subgoal):\n 1. i < dim_vec v \\<Longrightarrow>\n    (\\<Sum>x<dim_vec v.\n        if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < dim_vec v \\<Longrightarrow>\n    (\\<Sum>x<dim_vec v.\n        if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "case True"], ["proof (state)\nthis:\n  i < dim_vec v\n\ngoal (1 subgoal):\n 1. i < dim_vec v \\<Longrightarrow>\n    (\\<Sum>x<dim_vec v.\n        if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x<dim_vec v.\n        if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "by (subst sum.remove[of _ i], force, force simp: True, subst sum.neutral, insert True, auto)"], ["proof (state)\nthis:\n  (\\<Sum>x<dim_vec v. if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n  (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x<dim_vec v. if x = i then v $ (dim_vec v - Suc x) else (0::'a)) =\n  (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))\n\ngoal (1 subgoal):\n 1. coeff (poly_of_vec v) i =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "finally"], ["proof (chain)\npicking this:\n  coeff (poly_of_vec v) i =\n  (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff (poly_of_vec v) i =\n  (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))\n\ngoal (1 subgoal):\n 1. coeff (poly_of_vec v) i =\n    (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))", "."], ["proof (state)\nthis:\n  coeff (poly_of_vec v) i =\n  (if i < dim_vec v then v $ (dim_vec v - Suc i) else (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_of_poly_rev_shifted_scalar_prod:\n  fixes p v\n  defines \"q \\<equiv> poly_of_vec v\"\n  assumes m[simp]: \"degree p = m\" and n: \"dim_vec v = n\"\n  assumes j: \"j < m+n\"\n  shows \"vec_of_poly_rev_shifted p n (n+m-Suc j) \\<bullet> v = coeff (p * q) j\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v =\n    coeff (p * q) j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v =\n    coeff (p * q) j", "have id1: \"\\<And> i. m + i - (n + m - Suc j) = i + Suc j - n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. m + i - (n + m - Suc j) = i + Suc j - n", "using j"], ["proof (prove)\nusing this:\n  j < m + n\n\ngoal (1 subgoal):\n 1. \\<And>i. m + i - (n + m - Suc j) = i + Suc j - n", "by auto"], ["proof (state)\nthis:\n  m + ?i - (n + m - Suc j) = ?i + Suc j - n\n\ngoal (1 subgoal):\n 1. vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v =\n    coeff (p * q) j", "let ?g = \"\\<lambda> i. if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i then coeff p (i + Suc j - n) *  v $ i else 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v =\n    coeff (p * q) j", "have \"?thesis = ((\\<Sum>i = 0..<n. ?g i) =          \n        (\\<Sum>i\\<le>j. coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else 0)))\" (is \"_ = (?l = ?r)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v =\n     coeff (p * q) j) =\n    ((\\<Sum>i = 0..<n.\n         if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n         then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n     (\\<Sum>i\\<le>j.\n         coeff p i *\n         (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))))", "unfolding vec_of_poly_rev_shifted_def coeff_mult m scalar_prod_def n q_def\n      coeff_poly_of_vec"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i = 0..<n.\n         vec n\n          (\\<lambda>i.\n              if i \\<le> n + m - Suc j \\<and> n + m - Suc j \\<le> m + i\n              then coeff p (m + i - (n + m - Suc j)) else (0::'a)) $\n         i *\n         v $ i) =\n     (\\<Sum>i\\<le>j.\n         coeff p i *\n         (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))) =\n    ((\\<Sum>i = 0..<n.\n         if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n         then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n     (\\<Sum>i\\<le>j.\n         coeff p i *\n         (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))))", "by (subst sum.cong, insert id1, auto)"], ["proof (state)\nthis:\n  (vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v =\n   coeff (p * q) j) =\n  ((\\<Sum>i = 0..<n.\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n   (\\<Sum>i\\<le>j.\n       coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))))\n\ngoal (1 subgoal):\n 1. vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v =\n    coeff (p * q) j", "also"], ["proof (state)\nthis:\n  (vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v =\n   coeff (p * q) j) =\n  ((\\<Sum>i = 0..<n.\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n   (\\<Sum>i\\<le>j.\n       coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))))\n\ngoal (1 subgoal):\n 1. vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v =\n    coeff (p * q) j", "have \"...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"?r = (\\<Sum>i\\<le>j. (if j - i < n then coeff p i * v $ (n - Suc (j - i)) else 0))\" (is \"_ = sum ?f _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>j.\n        coeff p i *\n        (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n    (\\<Sum>i\\<le>j.\n        if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n  (\\<Sum>i\\<le>j.\n      if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n  (\\<Sum>i\\<le>j.\n      if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?f {..j} = sum ?f ({i. i \\<le> j \\<and> j - i < n} \\<union> {i. i \\<le> j \\<and> \\<not> j - i < n})\" \n      (is \"_ = sum _ (?R1 \\<union> ?R2)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>j.\n        if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n    (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<union>\n                 {i. i \\<le> j \\<and> \\<not> j - i < n}.\n       if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>j.\n      if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<union>\n               {i. i \\<le> j \\<and> \\<not> j - i < n}.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>j.\n      if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<union>\n               {i. i \\<le> j \\<and> \\<not> j - i < n}.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"\\<dots> = sum ?f ?R1 + sum ?f ?R2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<union>\n                 {i. i \\<le> j \\<and> \\<not> j - i < n}.\n       if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n    (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n       if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) +\n    (\\<Sum>i | i \\<le> j \\<and> \\<not> j - i < n.\n       if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))", "by (subst sum.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<union>\n               {i. i \\<le> j \\<and> \\<not> j - i < n}.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) +\n  (\\<Sum>i | i \\<le> j \\<and> \\<not> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<union>\n               {i. i \\<le> j \\<and> \\<not> j - i < n}.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) +\n  (\\<Sum>i | i \\<le> j \\<and> \\<not> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?f ?R2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<le> j \\<and> \\<not> j - i < n.\n       if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n    (0::'a)", "by (rule sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<le> j \\<and> \\<not> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<le> j \\<and> \\<not> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?f ?R1 + 0 = sum (\\<lambda> i. coeff p i * v $ (i + n - Suc j)) ?R1\"\n      (is \"_ = sum ?F _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n       if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) +\n    (0::'a) =\n    (\\<Sum>i | i \\<le> j \\<and> j - i < n. coeff p i * v $ (i + n - Suc j))", "by (subst sum.cong, auto simp: ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) +\n  (0::'a) =\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n. coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n     if j - i < n then coeff p i * v $ (n - Suc (j - i)) else (0::'a)) +\n  (0::'a) =\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n. coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"\\<dots> = sum ?F ((?R1 \\<inter> {..m}) \\<union> (?R1 - {..m}))\"\n      (is \"_ = sum _ (?R \\<union> ?R')\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i \\<le> j \\<and> j - i < n.\n       coeff p i * v $ (i + n - Suc j)) =\n    (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m} \\<union>\n                 ({i. i \\<le> j \\<and> j - i < n} - {..m}).\n       coeff p i * v $ (i + n - Suc j))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n. coeff p i * v $ (i + n - Suc j)) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m} \\<union>\n               ({i. i \\<le> j \\<and> j - i < n} - {..m}).\n     coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i \\<le> j \\<and> j - i < n. coeff p i * v $ (i + n - Suc j)) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m} \\<union>\n               ({i. i \\<le> j \\<and> j - i < n} - {..m}).\n     coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"\\<dots> = sum ?F ?R + sum ?F ?R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m} \\<union>\n                 ({i. i \\<le> j \\<and> j - i < n} - {..m}).\n       coeff p i * v $ (i + n - Suc j)) =\n    (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n       coeff p i * v $ (i + n - Suc j)) +\n    (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j))", "by (subst sum.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m} \\<union>\n               ({i. i \\<le> j \\<and> j - i < n} - {..m}).\n     coeff p i * v $ (i + n - Suc j)) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n     coeff p i * v $ (i + n - Suc j)) +\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n     coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m} \\<union>\n               ({i. i \\<le> j \\<and> j - i < n} - {..m}).\n     coeff p i * v $ (i + n - Suc j)) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n     coeff p i * v $ (i + n - Suc j)) +\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n     coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?F ?R' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "assume \"x > m\""], ["proof (state)\nthis:\n  m < x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "from coeff_eq_0[OF this[folded m]]"], ["proof (chain)\npicking this:\n  coeff p x = (0::'a)", "have \"?F x = 0\""], ["proof (prove)\nusing this:\n  coeff p x = (0::'a)\n\ngoal (1 subgoal):\n 1. coeff p x * v $ (x + n - Suc j) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  coeff p x * v $ (x + n - Suc j) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "}"], ["proof (state)\nthis:\n  m < ?x2 \\<Longrightarrow> coeff p ?x2 * v $ (?x2 + n - Suc j) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  m < ?x2 \\<Longrightarrow> coeff p ?x2 * v $ (?x2 + n - Suc j) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n       coeff p i * v $ (i + n - Suc j)) =\n    (0::'a)", "by (subst sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n     coeff p i * v $ (i + n - Suc j)) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} - {..m}.\n     coeff p i * v $ (i + n - Suc j)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n     coeff p i * v $ (i + n - Suc j)) +\n  (0::'a)", "have r: \"?r = sum ?F ?R\""], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n     coeff p i * v $ (i + n - Suc j)) +\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>j.\n        coeff p i *\n        (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n    (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n       coeff p i * v $ (i + n - Suc j))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n  (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n     coeff p i * v $ (i + n - Suc j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"?l = sum ?g ({i. i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \n      \\<union> {i. i < n \\<and> \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i)})\" \n      (is \"_ = sum _ (?L1 \\<union> ?L2)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<union>\n                 {i. i < n \\<and>\n                     \\<not> (i \\<le> n + m - Suc j \\<and>\n                             n - Suc j \\<le> i)}.\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<union>\n               {i. i < n \\<and>\n                   \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i)}.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<union>\n               {i. i < n \\<and>\n                   \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i)}.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"\\<dots> = sum ?g ?L1 + sum ?g ?L2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<union>\n                 {i. i < n \\<and>\n                     \\<not> (i \\<le> n + m - Suc j \\<and>\n                             n - Suc j \\<le> i)}.\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a)) +\n    (\\<Sum>i | i < n \\<and>\n               \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i).\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a))", "by (subst sum.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<union>\n               {i. i < n \\<and>\n                   \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i)}.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) +\n  (\\<Sum>i | i < n \\<and>\n             \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i).\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<union>\n               {i. i < n \\<and>\n                   \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i)}.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) +\n  (\\<Sum>i | i < n \\<and>\n             \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i).\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?g ?L2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < n \\<and>\n               \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i).\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (0::'a)", "by (rule sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n \\<and>\n             \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i).\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n \\<and>\n             \\<not> (i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i).\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?g ?L1 + 0 = sum (\\<lambda> i. coeff p (i + Suc j - n) * v $ i) ?L1\"\n      (is \"_ = sum ?G _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n       if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n       then coeff p (i + Suc j - n) * v $ i else (0::'a)) +\n    (0::'a) =\n    (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n       coeff p (i + Suc j - n) * v $ i)", "by (subst sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) +\n  (0::'a) =\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n     then coeff p (i + Suc j - n) * v $ i else (0::'a)) +\n  (0::'a) =\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"\\<dots> = sum ?G (?L1 \\<inter> {i. i + Suc j - n \\<le> m} \\<union> (?L1 - {i. i + Suc j - n \\<le> m}))\"\n      (is \"_ = sum _ (?L \\<union> ?L')\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n       coeff p (i + Suc j - n) * v $ i) =\n    (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<inter>\n                 {i. i + Suc j - n \\<le> m} \\<union>\n                 ({i. i < n \\<and>\n                      i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                  {i. i + Suc j - n \\<le> m}).\n       coeff p (i + Suc j - n) * v $ i)", "by (subst sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     coeff p (i + Suc j - n) * v $ i) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m} \\<union>\n               ({i. i < n \\<and>\n                    i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                {i. i + Suc j - n \\<le> m}).\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i | i < n \\<and> i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i.\n     coeff p (i + Suc j - n) * v $ i) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m} \\<union>\n               ({i. i < n \\<and>\n                    i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                {i. i + Suc j - n \\<le> m}).\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"\\<dots> = sum ?G ?L + sum ?G ?L'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<inter>\n                 {i. i + Suc j - n \\<le> m} \\<union>\n                 ({i. i < n \\<and>\n                      i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                  {i. i + Suc j - n \\<le> m}).\n       coeff p (i + Suc j - n) * v $ i) =\n    (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<inter>\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) +\n    (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i)", "by (subst sum.union_disjoint, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m} \\<union>\n               ({i. i < n \\<and>\n                    i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                {i. i + Suc j - n \\<le> m}).\n     coeff p (i + Suc j - n) * v $ i) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i) +\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m} \\<union>\n               ({i. i < n \\<and>\n                    i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                {i. i + Suc j - n \\<le> m}).\n     coeff p (i + Suc j - n) * v $ i) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i) +\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"sum ?G ?L' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "assume \"x + Suc j - n > m\""], ["proof (state)\nthis:\n  m < x + Suc j - n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "from coeff_eq_0[OF this[folded m]]"], ["proof (chain)\npicking this:\n  coeff p (x + Suc j - n) = (0::'a)", "have \"?G x = 0\""], ["proof (prove)\nusing this:\n  coeff p (x + Suc j - n) = (0::'a)\n\ngoal (1 subgoal):\n 1. coeff p (x + Suc j - n) * v $ x = (0::'a)", "by simp"], ["proof (state)\nthis:\n  coeff p (x + Suc j - n) * v $ x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "}"], ["proof (state)\nthis:\n  m < ?x2 + Suc j - n \\<Longrightarrow>\n  coeff p (?x2 + Suc j - n) * v $ ?x2 = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  m < ?x2 + Suc j - n \\<Longrightarrow>\n  coeff p (?x2 + Suc j - n) * v $ ?x2 = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (0::'a)", "by (subst sum.neutral, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} -\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i) +\n  (0::'a)", "have l: \"?l = sum ?G ?L\""], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i) +\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<inter>\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<in>{i. i < n \\<and>\n                   i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i} \\<inter>\n               {i. i + Suc j - n \\<le> m}.\n     coeff p (i + Suc j - n) * v $ i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "let ?bij = \"\\<lambda> i. i + n - Suc j\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "assume x: \"j < m + n\" \"Suc (x + j) - n \\<le> m\" \"x < n\" \"n - Suc j \\<le> x\""], ["proof (state)\nthis:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "define y where \"y = x + Suc j - n\""], ["proof (state)\nthis:\n  y = x + Suc j - n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "from x"], ["proof (chain)\npicking this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x", "have \"x + Suc j \\<ge> n\""], ["proof (prove)\nusing this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n\ngoal (1 subgoal):\n 1. n \\<le> x + Suc j", "by auto"], ["proof (state)\nthis:\n  n \\<le> x + Suc j\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "with x"], ["proof (chain)\npicking this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n  n \\<le> x + Suc j", "have xy: \"x = ?bij y\""], ["proof (prove)\nusing this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n  n \\<le> x + Suc j\n\ngoal (1 subgoal):\n 1. x = y + n - Suc j", "unfolding y_def"], ["proof (prove)\nusing this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n  n \\<le> x + Suc j\n\ngoal (1 subgoal):\n 1. x = x + Suc j - n + n - Suc j", "by auto"], ["proof (state)\nthis:\n  x = y + n - Suc j\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "from x"], ["proof (chain)\npicking this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x", "have y: \"y \\<in> ?R\""], ["proof (prove)\nusing this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n\ngoal (1 subgoal):\n 1. y \\<in> {i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}", "unfolding y_def"], ["proof (prove)\nusing this:\n  j < m + n\n  Suc (x + j) - n \\<le> m\n  x < n\n  n - Suc j \\<le> x\n\ngoal (1 subgoal):\n 1. x + Suc j - n \\<in> {i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}", "by auto"], ["proof (state)\nthis:\n  y \\<in> {i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "have \"x \\<in> ?bij ` ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>i. i + n - Suc j) `\n            ({i. i \\<le> j \\<and> j - i < n} \\<inter> {..m})", "unfolding xy"], ["proof (prove)\ngoal (1 subgoal):\n 1. y + n - Suc j\n    \\<in> (\\<lambda>i. i + n - Suc j) `\n          ({i. i \\<le> j \\<and> j - i < n} \\<inter> {..m})", "using y"], ["proof (prove)\nusing this:\n  y \\<in> {i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}\n\ngoal (1 subgoal):\n 1. y + n - Suc j\n    \\<in> (\\<lambda>i. i + n - Suc j) `\n          ({i. i \\<le> j \\<and> j - i < n} \\<inter> {..m})", "by blast"], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>i. i + n - Suc j) `\n          ({i. i \\<le> j \\<and> j - i < n} \\<inter> {..m})\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>j < m + n; Suc (?x2 + j) - n \\<le> m; ?x2 < n;\n   n - Suc j \\<le> ?x2\\<rbrakk>\n  \\<Longrightarrow> ?x2\n                    \\<in> (\\<lambda>i. i + n - Suc j) `\n                          ({i. i \\<le> j \\<and> j - i < n} \\<inter> {..m})\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "note tedious = this"], ["proof (state)\nthis:\n  \\<lbrakk>j < m + n; Suc (?x2 + j) - n \\<le> m; ?x2 < n;\n   n - Suc j \\<le> ?x2\\<rbrakk>\n  \\<Longrightarrow> ?x2\n                    \\<in> (\\<lambda>i. i + n - Suc j) `\n                          ({i. i \\<le> j \\<and> j - i < n} \\<inter> {..m})\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n        then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n    (\\<Sum>i\\<le>j.\n        coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))", "unfolding l r"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i. i < n \\<and>\n                     i \\<le> n + m - Suc j \\<and>\n                     n - Suc j \\<le> i} \\<inter>\n                 {i. i + Suc j - n \\<le> m}.\n       coeff p (i + Suc j - n) * v $ i) =\n    (\\<Sum>i\\<in>{i. i \\<le> j \\<and> j - i < n} \\<inter> {..m}.\n       coeff p i * v $ (i + n - Suc j))", "by (rule sum.reindex_cong[of ?bij], insert j, auto simp: inj_on_def tedious)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n.\n      if i \\<le> n + m - Suc j \\<and> n - Suc j \\<le> i\n      then coeff p (i + Suc j - n) * v $ i else (0::'a)) =\n  (\\<Sum>i\\<le>j.\n      coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a)))\n\ngoal (1 subgoal):\n 1. vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v =\n    coeff (p * q) j", "finally"], ["proof (chain)\npicking this:\n  (vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v =\n   coeff (p * q) j) =\n  ((\\<Sum>i\\<le>j.\n       coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n   (\\<Sum>i\\<le>j.\n       coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))))", "show ?thesis"], ["proof (prove)\nusing this:\n  (vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v =\n   coeff (p * q) j) =\n  ((\\<Sum>i\\<le>j.\n       coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))) =\n   (\\<Sum>i\\<le>j.\n       coeff p i * (if j - i < n then v $ (n - Suc (j - i)) else (0::'a))))\n\ngoal (1 subgoal):\n 1. vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v =\n    coeff (p * q) j", "by simp"], ["proof (state)\nthis:\n  vec_of_poly_rev_shifted p n (n + m - Suc j) \\<bullet> v = coeff (p * q) j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sylvester_vec_poly:\n  fixes p q :: \"'a :: comm_semiring_0 poly\"\n  defines \"m \\<equiv> degree p\"\n      and \"n \\<equiv> degree q\"\n  assumes v: \"v \\<in> carrier_vec (m+n)\"\n  shows \"poly_of_vec (transpose_mat (sylvester_mat p q) *\\<^sub>v v) =\n    poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v) =\n    poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q", "proof (rule poly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) na =\n       coeff\n        (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n        na", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) na =\n       coeff\n        (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n        na", "note mn[simp] = m_def[symmetric] n_def[symmetric]"], ["proof (state)\nthis:\n  degree p \\<equiv> m\n  degree q \\<equiv> n\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) na =\n       coeff\n        (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n        na", "let ?Tv = \"transpose_mat (sylvester_mat p q) *\\<^sub>v v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) na =\n       coeff\n        (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n        na", "have dim: \"dim_vec (vec_first v n) = n\" \"dim_vec (vec_last v m) = m\" \"dim_vec ?Tv = n + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_first v n) = n &&&\n    dim_vec (vec_last v m) = m &&&\n    dim_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v) = n + m", "using v"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (m + n)\n\ngoal (1 subgoal):\n 1. dim_vec (vec_first v n) = n &&&\n    dim_vec (vec_last v m) = m &&&\n    dim_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v) = n + m", "by auto"], ["proof (state)\nthis:\n  dim_vec (vec_first v n) = n\n  dim_vec (vec_last v m) = m\n  dim_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v) = n + m\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) na =\n       coeff\n        (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n        na", "have if_distrib: \"\\<And> x y z. (if x then y else (0 :: 'a)) * z = (if x then y * z else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       (if x then y else (0::'a)) * z = (if x then y * z else (0::'a))", "by auto"], ["proof (state)\nthis:\n  (if ?x then ?y else (0::'a)) * ?z = (if ?x then ?y * ?z else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) na =\n       coeff\n        (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n        na", "show \"coeff ?l i = coeff ?r i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "proof (cases \"i < m+n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "case False"], ["proof (state)\nthis:\n  \\<not> i < m + n\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "hence i_mn: \"i \\<ge> m+n\"\n        and i_n: \"\\<And>x. x \\<le> i \\<and> x < n \\<longleftrightarrow> x < n\"\n        and i_m: \"\\<And>x. x \\<le> i \\<and> x < m \\<longleftrightarrow> x < m\""], ["proof (prove)\nusing this:\n  \\<not> i < m + n\n\ngoal (1 subgoal):\n 1. m + n \\<le> i &&&\n    (\\<And>x. (x \\<le> i \\<and> x < n) = (x < n)) &&&\n    (\\<And>x. (x \\<le> i \\<and> x < m) = (x < m))", "by auto"], ["proof (state)\nthis:\n  m + n \\<le> i\n  (?x \\<le> i \\<and> ?x < n) = (?x < n)\n  (?x \\<le> i \\<and> ?x < m) = (?x < m)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "have \"coeff ?r i =\n            (\\<Sum> x < n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n            (\\<Sum> x < m. vec_last v m $ (m - Suc x) * coeff q (i - x))\"\n        (is \"_ = sum ?f _ + sum ?g _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "unfolding coeff_add coeff_mult Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<le>i.\n        coeff (poly_of_vec (vec_first v n)) ia * coeff p (i - ia)) +\n    (\\<Sum>ia\\<le>i.\n        coeff (poly_of_vec (vec_last v m)) ia * coeff q (i - ia)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "unfolding coeff_poly_of_vec dim if_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<le>i.\n        if ia < n then vec_first v n $ (n - Suc ia) * coeff p (i - ia)\n        else (0::'a)) +\n    (\\<Sum>ia\\<le>i.\n        if ia < m then vec_last v m $ (m - Suc ia) * coeff q (i - ia)\n        else (0::'a)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "unfolding atMost_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>{x. x \\<le> i}.\n       if ia < n then vec_first v n $ (n - Suc ia) * coeff p (i - ia)\n       else (0::'a)) +\n    (\\<Sum>ia\\<in>{x. x \\<le> i}.\n       if ia < m then vec_last v m $ (m - Suc ia) * coeff q (i - ia)\n       else (0::'a)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "apply(subst sum.inter_filter[symmetric],simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>{x \\<in> {x. x \\<le> i}. x < n}.\n       vec_first v n $ (n - Suc ia) * coeff p (i - ia)) +\n    (\\<Sum>ia\\<in>{x. x \\<le> i}.\n       if ia < m then vec_last v m $ (m - Suc ia) * coeff q (i - ia)\n       else (0::'a)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "apply(subst sum.inter_filter[symmetric],simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>{x \\<in> {x. x \\<le> i}. x < n}.\n       vec_first v n $ (n - Suc ia) * coeff p (i - ia)) +\n    (\\<Sum>ia\\<in>{x \\<in> {x. x \\<le> i}. x < m}.\n       vec_last v m $ (m - Suc ia) * coeff q (i - ia)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "unfolding mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>{x. x \\<le> i \\<and> x < n}.\n       vec_first v n $ (n - Suc ia) * coeff p (i - ia)) +\n    (\\<Sum>ia\\<in>{x. x \\<le> i \\<and> x < m}.\n       vec_last v m $ (m - Suc ia) * coeff q (i - ia)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "unfolding i_n i_m"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>{x. x < n}.\n       vec_first v n $ (n - Suc ia) * coeff p (i - ia)) +\n    (\\<Sum>ia\\<in>{x. x < m}.\n       vec_last v m $ (m - Suc ia) * coeff q (i - ia)) =\n    (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "unfolding lessThan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<in>{x. x < n}.\n       vec_first v n $ (n - Suc ia) * coeff p (i - ia)) +\n    (\\<Sum>ia\\<in>{x. x < m}.\n       vec_last v m $ (m - Suc ia) * coeff q (i - ia)) =\n    (\\<Sum>x | x < n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n    (\\<Sum>x | x < m. vec_last v m $ (m - Suc x) * coeff q (i - x))", "by simp"], ["proof (state)\nthis:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n  (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "also"], ["proof (state)\nthis:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n  (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "{"], ["proof (state)\nthis:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) +\n  (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x))\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "assume x: \"x < n\""], ["proof (state)\nthis:\n  x < n\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "have \"coeff p (i-x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff p (i - x) = (0::'a)", "apply(rule coeff_eq_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p < i - x", "using i_mn x"], ["proof (prove)\nusing this:\n  m + n \\<le> i\n  x < n\n\ngoal (1 subgoal):\n 1. degree p < i - x", "unfolding m_def"], ["proof (prove)\nusing this:\n  degree p + n \\<le> i\n  x < n\n\ngoal (1 subgoal):\n 1. degree p < i - x", "by auto"], ["proof (state)\nthis:\n  coeff p (i - x) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "hence \"?f x = 0\""], ["proof (prove)\nusing this:\n  coeff p (i - x) = (0::'a)\n\ngoal (1 subgoal):\n 1. vec_first v n $ (n - Suc x) * coeff p (i - x) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  vec_first v n $ (n - Suc x) * coeff p (i - x) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "}"], ["proof (state)\nthis:\n  ?x2 < n \\<Longrightarrow>\n  vec_first v n $ (n - Suc ?x2) * coeff p (i - ?x2) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "hence \"sum ?f {..<n} = 0\""], ["proof (prove)\nusing this:\n  ?x2 < n \\<Longrightarrow>\n  vec_first v n $ (n - Suc ?x2) * coeff p (i - ?x2) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "also"], ["proof (state)\nthis:\n  (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "{"], ["proof (state)\nthis:\n  (\\<Sum>x<n. vec_first v n $ (n - Suc x) * coeff p (i - x)) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "assume x: \"x < m\""], ["proof (state)\nthis:\n  x < m\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "have \"coeff q (i-x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff q (i - x) = (0::'a)", "apply(rule coeff_eq_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q < i - x", "using i_mn x"], ["proof (prove)\nusing this:\n  m + n \\<le> i\n  x < m\n\ngoal (1 subgoal):\n 1. degree q < i - x", "unfolding n_def"], ["proof (prove)\nusing this:\n  m + degree q \\<le> i\n  x < m\n\ngoal (1 subgoal):\n 1. degree q < i - x", "by auto"], ["proof (state)\nthis:\n  coeff q (i - x) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "hence \"?g x = 0\""], ["proof (prove)\nusing this:\n  coeff q (i - x) = (0::'a)\n\ngoal (1 subgoal):\n 1. vec_last v m $ (m - Suc x) * coeff q (i - x) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  vec_last v m $ (m - Suc x) * coeff q (i - x) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "}"], ["proof (state)\nthis:\n  ?x2 < m \\<Longrightarrow>\n  vec_last v m $ (m - Suc ?x2) * coeff q (i - ?x2) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "hence \"sum ?g {..<m} = 0\""], ["proof (prove)\nusing this:\n  ?x2 < m \\<Longrightarrow>\n  vec_last v m $ (m - Suc ?x2) * coeff q (i - ?x2) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x)) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x<m. vec_last v m $ (m - Suc x) * coeff q (i - x)) = (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "finally"], ["proof (chain)\npicking this:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (0::'a) + (0::'a)", "have \"coeff ?r i = 0\""], ["proof (prove)\nusing this:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (0::'a) + (0::'a)\n\ngoal (1 subgoal):\n 1. coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i =\n    (0::'a)", "by auto"], ["proof (state)\nthis:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "also"], ["proof (state)\nthis:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "from False"], ["proof (chain)\npicking this:\n  \\<not> i < m + n", "have \"0 = coeff ?l i\""], ["proof (prove)\nusing this:\n  \\<not> i < m + n\n\ngoal (1 subgoal):\n 1. (0::'a) =\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i", "unfolding coeff_poly_of_vec dim sum.distrib[symmetric]"], ["proof (prove)\nusing this:\n  \\<not> i < m + n\n\ngoal (1 subgoal):\n 1. (0::'a) =\n    (if i < n + m\n     then ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i)\n     else (0::'a))", "by auto"], ["proof (state)\nthis:\n  (0::'a) = coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i\n\ngoal (2 subgoals):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i\n 2. \\<not> i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "finally"], ["proof (chain)\npicking this:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n   i =\n  coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i\n\ngoal (1 subgoal):\n 1. coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "by auto"], ["proof (state)\nthis:\n  coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q) i\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "case True"], ["proof (state)\nthis:\n  i < m + n\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "hence \"coeff ?l i = (transpose_mat (sylvester_mat p q) *\\<^sub>v v) $ (n + m - Suc i)\""], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (1 subgoal):\n 1. coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i)", "unfolding coeff_poly_of_vec dim sum.distrib[symmetric]"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (1 subgoal):\n 1. (if i < n + m\n     then ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i)\n     else (0::'a)) =\n    ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i)", "by auto"], ["proof (state)\nthis:\n  coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n  ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i)\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "also"], ["proof (state)\nthis:\n  coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n  ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i)\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "have \"... = coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i) =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply(subst index_mult_mat_vec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n + m - Suc i < dim_row (sylvester_mat p q)\\<^sup>T\n 2. row (sylvester_mat p q)\\<^sup>T (n + m - Suc i) \\<bullet> v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "using True"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (2 subgoals):\n 1. n + m - Suc i < dim_row (sylvester_mat p q)\\<^sup>T\n 2. row (sylvester_mat p q)\\<^sup>T (n + m - Suc i) \\<bullet> v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (sylvester_mat p q)\\<^sup>T (n + m - Suc i) \\<bullet> v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply(subst row_transpose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n + m - Suc i < dim_col (sylvester_mat p q)\n 2. col (sylvester_mat p q) (n + m - Suc i) \\<bullet> v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "using True"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (2 subgoals):\n 1. n + m - Suc i < dim_col (sylvester_mat p q)\n 2. col (sylvester_mat p q) (n + m - Suc i) \\<bullet> v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (sylvester_mat p q) (n + m - Suc i) \\<bullet> v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply(subst col_sylvester)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n + m - Suc i < degree p + degree q\n 2. (vec_of_poly_rev_shifted p (degree q) (n + m - Suc i) @\\<^sub>v\n     vec_of_poly_rev_shifted q (degree p) (n + m - Suc i)) \\<bullet>\n    v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "unfolding mn"], ["proof (prove)\ngoal (2 subgoals):\n 1. n + m - Suc i < m + n\n 2. (vec_of_poly_rev_shifted p n (n + m - Suc i) @\\<^sub>v\n     vec_of_poly_rev_shifted q m (n + m - Suc i)) \\<bullet>\n    v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "using True"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (2 subgoals):\n 1. n + m - Suc i < m + n\n 2. (vec_of_poly_rev_shifted p n (n + m - Suc i) @\\<^sub>v\n     vec_of_poly_rev_shifted q m (n + m - Suc i)) \\<bullet>\n    v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_of_poly_rev_shifted p n (n + m - Suc i) @\\<^sub>v\n     vec_of_poly_rev_shifted q m (n + m - Suc i)) \\<bullet>\n    v =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply(subst vec_first_last_append[of v n m,symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<in> carrier_vec (n + m)\n 2. (vec_of_poly_rev_shifted p n (n + m - Suc i) @\\<^sub>v\n     vec_of_poly_rev_shifted q m (n + m - Suc i)) \\<bullet>\n    (vec_first v n @\\<^sub>v vec_last v m) =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "using v"], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (m + n)\n\ngoal (2 subgoals):\n 1. v \\<in> carrier_vec (n + m)\n 2. (vec_of_poly_rev_shifted p n (n + m - Suc i) @\\<^sub>v\n     vec_of_poly_rev_shifted q m (n + m - Suc i)) \\<bullet>\n    (vec_first v n @\\<^sub>v vec_last v m) =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply(simp add: add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (vec_of_poly_rev_shifted p n (n + m - Suc i) @\\<^sub>v\n     vec_of_poly_rev_shifted q m (n + m - Suc i)) \\<bullet>\n    (vec_first v n @\\<^sub>v vec_last v m) =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply(subst scalar_prod_append)"], ["proof (prove)\ngoal (5 subgoals):\n 1. vec_of_poly_rev_shifted p n (n + m - Suc i) \\<in> carrier_vec ?n1.55\n 2. vec_of_poly_rev_shifted q m (n + m - Suc i) \\<in> carrier_vec ?n2.55\n 3. vec_first v n \\<in> carrier_vec ?n1.55\n 4. vec_last v m \\<in> carrier_vec ?n2.55\n 5. vec_of_poly_rev_shifted p n (n + m - Suc i) \\<bullet> vec_first v n +\n    vec_of_poly_rev_shifted q m (n + m - Suc i) \\<bullet> vec_last v m =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply (rule carrier_vecI,simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_poly_rev_shifted p n (n + m - Suc i) \\<bullet> vec_first v n +\n    vec_of_poly_rev_shifted q m (n + m - Suc i) \\<bullet> vec_last v m =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply (subst vec_of_poly_rev_shifted_scalar_prod,simp,simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < m + n\n 2. coeff (p * poly_of_vec (vec_first v n)) i +\n    vec_of_poly_rev_shifted q m (n + m - Suc i) \\<bullet> vec_last v m =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "using True"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (2 subgoals):\n 1. i < m + n\n 2. coeff (p * poly_of_vec (vec_first v n)) i +\n    vec_of_poly_rev_shifted q m (n + m - Suc i) \\<bullet> vec_last v m =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n)) i +\n    vec_of_poly_rev_shifted q m (n + m - Suc i) \\<bullet> vec_last v m =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply (subst add.commute[of n m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n)) i +\n    vec_of_poly_rev_shifted q m (m + n - Suc i) \\<bullet> vec_last v m =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply (subst vec_of_poly_rev_shifted_scalar_prod,simp,simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < n + m\n 2. coeff (p * poly_of_vec (vec_first v n)) i +\n    coeff (q * poly_of_vec (vec_last v m)) i =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "using True"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (2 subgoals):\n 1. i < n + m\n 2. coeff (p * poly_of_vec (vec_first v n)) i +\n    coeff (q * poly_of_vec (vec_last v m)) i =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n)) i +\n    coeff (q * poly_of_vec (vec_last v m)) i =\n    coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i", "by simp"], ["proof (state)\nthis:\n  ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i) =\n  coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m)) i\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "also"], ["proof (state)\nthis:\n  ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v) $ (n + m - Suc i) =\n  coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m)) i\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "have \"... =\n        (\\<Sum>x\\<le>i. (if x < n then vec_first v n $ (n - Suc x) else 0) * coeff p (i - x)) +\n        (\\<Sum>x\\<le>i. (if x < m then vec_last v m $ (m - Suc x) else 0) * coeff q (i - x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i =\n    (\\<Sum>x\\<le>i.\n        (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n        coeff p (i - x)) +\n    (\\<Sum>x\\<le>i.\n        (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n        coeff q (i - x))", "unfolding coeff_poly_of_vec[of \"vec_first v n\",unfolded dim_vec_first,symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i =\n    (\\<Sum>x\\<le>i.\n        coeff (poly_of_vec (vec_first v n)) x * coeff p (i - x)) +\n    (\\<Sum>x\\<le>i.\n        (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n        coeff q (i - x))", "unfolding coeff_poly_of_vec[of \"vec_last v m\",unfolded dim_vec_last,symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i =\n    (\\<Sum>x\\<le>i.\n        coeff (poly_of_vec (vec_first v n)) x * coeff p (i - x)) +\n    (\\<Sum>x\\<le>i. coeff (poly_of_vec (vec_last v m)) x * coeff q (i - x))", "unfolding coeff_mult[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n     i =\n    coeff (poly_of_vec (vec_first v n) * p) i +\n    coeff (poly_of_vec (vec_last v m) * q) i", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n   i =\n  (\\<Sum>x\\<le>i.\n      (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n      coeff p (i - x)) +\n  (\\<Sum>x\\<le>i.\n      (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n      coeff q (i - x))\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "also"], ["proof (state)\nthis:\n  coeff (p * poly_of_vec (vec_first v n) + q * poly_of_vec (vec_last v m))\n   i =\n  (\\<Sum>x\\<le>i.\n      (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n      coeff p (i - x)) +\n  (\\<Sum>x\\<le>i.\n      (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n      coeff q (i - x))\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "have \"... = coeff ?r i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n        coeff p (i - x)) +\n    (\\<Sum>x\\<le>i.\n        (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n        coeff q (i - x)) =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "unfolding coeff_add coeff_mult Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n        coeff p (i - x)) +\n    (\\<Sum>x\\<le>i.\n        (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n        coeff q (i - x)) =\n    (\\<Sum>ia\\<le>i.\n        coeff (poly_of_vec (vec_first v n)) ia * coeff p (i - ia)) +\n    (\\<Sum>ia\\<le>i.\n        coeff (poly_of_vec (vec_last v m)) ia * coeff q (i - ia))", "unfolding coeff_poly_of_vec dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<le>i.\n        (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n        coeff p (i - x)) +\n    (\\<Sum>x\\<le>i.\n        (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n        coeff q (i - x)) =\n    (\\<Sum>ia\\<le>i.\n        (if ia < n then vec_first v n $ (n - Suc ia) else (0::'a)) *\n        coeff p (i - ia)) +\n    (\\<Sum>ia\\<le>i.\n        (if ia < m then vec_last v m $ (m - Suc ia) else (0::'a)) *\n        coeff q (i - ia))", ".."], ["proof (state)\nthis:\n  (\\<Sum>x\\<le>i.\n      (if x < n then vec_first v n $ (n - Suc x) else (0::'a)) *\n      coeff p (i - x)) +\n  (\\<Sum>x\\<le>i.\n      (if x < m then vec_last v m $ (m - Suc x) else (0::'a)) *\n      coeff q (i - x)) =\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q) i\n\ngoal (1 subgoal):\n 1. i < m + n \\<Longrightarrow>\n    coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "finally"], ["proof (chain)\npicking this:\n  coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q) i", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q) i\n\ngoal (1 subgoal):\n 1. coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n    coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q)\n     i", "."], ["proof (state)\nthis:\n  coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coeff (poly_of_vec ((sylvester_mat p q)\\<^sup>T *\\<^sub>v v)) i =\n  coeff (poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q) i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Homomorphism and Resultant\\<close>"], ["", "text \\<open>Here we prove Lemma~7.3.1 of the textbook.\\<close>"], ["", "lemma(in comm_ring_hom) resultant_sub_map_poly:\n  fixes p q :: \"'a poly\"\n  shows \"hom (resultant_sub m n p q) = resultant_sub m n (map_poly hom p) (map_poly hom q)\"\n    (is \"?l = ?r'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (resultant_sub m n p q) =\n    resultant_sub m n (map_poly hom p) (map_poly hom q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hom (resultant_sub m n p q) =\n    resultant_sub m n (map_poly hom p) (map_poly hom q)", "let ?mh = \"map_poly hom\""], ["proof (state)\ngoal (1 subgoal):\n 1. hom (resultant_sub m n p q) =\n    resultant_sub m n (map_poly hom p) (map_poly hom q)", "have \"?l = det (sylvester_mat_sub m n (?mh p) (?mh q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (resultant_sub m n p q) =\n    det (sylvester_mat_sub m n (map_poly hom p) (map_poly hom q))", "unfolding resultant_sub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hom (det (sylvester_mat_sub m n p q)) =\n    det (sylvester_mat_sub m n (map_poly hom p) (map_poly hom q))", "apply(subst sylvester_mat_sub_map[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. hom (0::'a) = (0::'b)\n 2. hom (det (sylvester_mat_sub m n p q)) =\n    det (mat\\<^sub>h (sylvester_mat_sub m n p q))", "by auto"], ["proof (state)\nthis:\n  hom (resultant_sub m n p q) =\n  det (sylvester_mat_sub m n (map_poly hom p) (map_poly hom q))\n\ngoal (1 subgoal):\n 1. hom (resultant_sub m n p q) =\n    resultant_sub m n (map_poly hom p) (map_poly hom q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  hom (resultant_sub m n p q) =\n  det (sylvester_mat_sub m n (map_poly hom p) (map_poly hom q))\n\ngoal (1 subgoal):\n 1. hom (resultant_sub m n p q) =\n    resultant_sub m n (map_poly hom p) (map_poly hom q)", "unfolding resultant_sub_def"], ["proof (prove)\nusing this:\n  hom (det (sylvester_mat_sub m n p q)) =\n  det (sylvester_mat_sub m n (map_poly hom p) (map_poly hom q))\n\ngoal (1 subgoal):\n 1. hom (det (sylvester_mat_sub m n p q)) =\n    det (sylvester_mat_sub m n (map_poly hom p) (map_poly hom q))", "."], ["proof (state)\nthis:\n  hom (resultant_sub m n p q) =\n  resultant_sub m n (map_poly hom p) (map_poly hom q)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma (in comm_ring_hom) resultant_map_poly:\n  fixes p q :: \"'a poly\"\n    defines \"p' \\<equiv> map_poly hom p\"\n    defines \"q' \\<equiv> map_poly hom q\"\n    defines \"m \\<equiv> degree p\"\n    defines \"n \\<equiv> degree q\"\n    defines \"m' \\<equiv> degree p'\"\n    defines \"n' \\<equiv> degree q'\"\n    defines \"r \\<equiv> resultant p q\"\n    defines \"r' \\<equiv> resultant p' q'\"\n  shows \"m' = m \\<Longrightarrow> n' = n \\<Longrightarrow> hom r = r'\"\n    and \"m' = m \\<Longrightarrow> hom r = hom (coeff p m')^(n-n') * r'\"\n    and \"m' \\<noteq> m \\<Longrightarrow> n' = n \\<Longrightarrow>\n      hom r = (if even n then 1 else (-1)^(m-m')) * hom (coeff q n)^(m-m') * r'\"\n      (is \"_ \\<Longrightarrow> _ \\<Longrightarrow> ?goal\")\n    and \"m' \\<noteq> m \\<Longrightarrow> n' \\<noteq> n \\<Longrightarrow> hom r = 0\"\nproof -\n  have m'm: \"m' \\<le> m\" unfolding m_def m'_def p'_def using degree_map_poly_le by auto\n  have n'n: \"n' \\<le> n\" unfolding n_def n'_def q'_def using degree_map_poly_le by auto\n\n  have coeffp'[simp]: \"\\<And>i. coeff p' i = hom (coeff p i)\" unfolding p'_def by auto\n  have coeffq'[simp]: \"\\<And>i. coeff q' i = hom (coeff q i)\" unfolding q'_def by auto\n\n  let ?f = \"\\<lambda>i. (if even n then 1 else (-1)^i) * hom (coeff q n)^i\"\n\n  have \"hom r = resultant_sub m n p' q'\"\n    unfolding r_def resultant_sub\n    unfolding m_def n_def p'_def q'_def\n    by(rule resultant_sub_map_poly)\n  also have \"... = ?f (m-m') * resultant_sub m' n p' q'\"\n    using resultant_sub_trim_upper[of p' \"m-m'\" n q',folded m'_def] m'm\n    by (auto simp: power_minus[symmetric])\n  also have \"... = ?f (m-m') * hom (coeff p m')^(n-n') * r'\"\n    using resultant_sub_trim_lower[of m' q' \"n-n'\" p'] n'n\n    unfolding r'_def resultant_sub m'_def n'_def by auto\n  finally have main: \"hom r = ?f (m-m') * hom (coeff p m')^(n-n') * r'\" by auto\n\n  { assume \"m' = m\"\n    thus \"hom r = hom (coeff p m')^(n-n') * r'\" using main by auto\n    thus \"n' = n \\<Longrightarrow> hom r = r'\" by auto\n  }\n  assume \"m' \\<noteq> m\"\n  hence m'm: \"m' < m\" using m'm by auto\n  thus \"n' = n \\<Longrightarrow> ?goal\" using main by simp\n  assume \"n' \\<noteq> n\"\n  hence \"n' < n\" using n'n by auto\n  hence \"hom (coeff q n) = 0\"\n    unfolding coeffq'[symmetric] unfolding n'_def by(rule coeff_eq_0)\n  hence \"hom (coeff q n) ^ (m-m') = 0\" using m'm by (simp add: power_0_left)\n  from main[unfolded this]\n  show \"hom r = 0\" using power_0_Suc by auto\nqed\n*)"], ["", "subsubsection\\<open>Resultant as Polynomial Expression\\<close>"], ["", "context begin"], ["", "text \\<open>This context provides notions for proving Lemma 7.2.1 of the textbook.\\<close>"], ["", "private"], ["", "fun mk_poly_sub where\n  \"mk_poly_sub A l 0 = A\"\n| \"mk_poly_sub A l (Suc j) = mat_addcol (monom 1 (Suc j)) l (l-Suc j) (mk_poly_sub A l j)\""], ["", "definition  \"mk_poly A = mk_poly_sub (map_mat coeff_lift A) (dim_col A - 1) (dim_col A - 1)\""], ["", "private"], ["", "lemma mk_poly_sub_dim[simp]:\n  \"dim_row (mk_poly_sub A l j) = dim_row A\"\n  \"dim_col (mk_poly_sub A l j) = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mk_poly_sub A l j) = dim_row A &&&\n    dim_col (mk_poly_sub A l j) = dim_col A", "by (induct j,auto)"], ["", "private"], ["", "lemma mk_poly_sub_carrier:\n  assumes \"A \\<in> carrier_mat nr nc\" shows \"mk_poly_sub A l j \\<in> carrier_mat nr nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly_sub A l j \\<in> carrier_mat nr nc", "apply (rule carrier_matI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dim_row (mk_poly_sub A l j) = nr\n 2. dim_col (mk_poly_sub A l j) = nc", "using assms"], ["proof (prove)\nusing this:\n  A \\<in> carrier_mat nr nc\n\ngoal (2 subgoals):\n 1. dim_row (mk_poly_sub A l j) = nr\n 2. dim_col (mk_poly_sub A l j) = nc", "by auto"], ["", "private"], ["", "lemma mk_poly_dim[simp]:\n  \"dim_col (mk_poly A) = dim_col A\"\n  \"dim_row (mk_poly A) = dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (mk_poly A) = dim_col A &&& dim_row (mk_poly A) = dim_row A", "unfolding mk_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col\n     (mk_poly_sub (coeff_lift_hom.mat_hom A) (dim_col A - 1)\n       (dim_col A - 1)) =\n    dim_col A &&&\n    dim_row\n     (mk_poly_sub (coeff_lift_hom.mat_hom A) (dim_col A - 1)\n       (dim_col A - 1)) =\n    dim_row A", "by auto"], ["", "private"], ["", "lemma mk_poly_sub_others[simp]:\n  assumes \"l \\<noteq> j'\" and \"i < dim_row A\" and \"j' < dim_col A\"\n  shows \"mk_poly_sub A l j $$ (i,j') = A $$ (i,j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly_sub A l j $$ (i, j') = A $$ (i, j')", "using assms"], ["proof (prove)\nusing this:\n  l \\<noteq> j'\n  i < dim_row A\n  j' < dim_col A\n\ngoal (1 subgoal):\n 1. mk_poly_sub A l j $$ (i, j') = A $$ (i, j')", "by (induct j; simp)"], ["", "private"], ["", "lemma mk_poly_others[simp]:\n  assumes i: \"i < dim_row A\" and j: \"j < dim_col A - 1\"\n  shows \"mk_poly A $$ (i,j) = [: A $$ (i,j) :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly A $$ (i, j) = [:A $$ (i, j):]", "unfolding mk_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly_sub (coeff_lift_hom.mat_hom A) (dim_col A - 1)\n     (dim_col A - 1) $$\n    (i, j) =\n    [:A $$ (i, j):]", "apply(subst mk_poly_sub_others)"], ["proof (prove)\ngoal (4 subgoals):\n 1. dim_col A - 1 \\<noteq> j\n 2. i < dim_row (coeff_lift_hom.mat_hom A)\n 3. j < dim_col (coeff_lift_hom.mat_hom A)\n 4. coeff_lift_hom.mat_hom A $$ (i, j) = [:A $$ (i, j):]", "using i j"], ["proof (prove)\nusing this:\n  i < dim_row A\n  j < dim_col A - 1\n\ngoal (4 subgoals):\n 1. dim_col A - 1 \\<noteq> j\n 2. i < dim_row (coeff_lift_hom.mat_hom A)\n 3. j < dim_col (coeff_lift_hom.mat_hom A)\n 4. coeff_lift_hom.mat_hom A $$ (i, j) = [:A $$ (i, j):]", "by auto"], ["", "private"], ["", "lemma mk_poly_delete[simp]:\n  assumes i: \"i < dim_row A\"\n  shows \"mat_delete (mk_poly A) i (dim_col A - 1) = map_mat coeff_lift (mat_delete A i (dim_col A - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_delete (mk_poly A) i (dim_col A - 1) =\n    coeff_lift_hom.mat_hom (mat_delete A i (dim_col A - 1))", "apply(rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < dim_row\n                      (coeff_lift_hom.mat_hom\n                        (mat_delete A i (dim_col A - 1)));\n        j < dim_col\n             (coeff_lift_hom.mat_hom\n               (mat_delete A i (dim_col A - 1)))\\<rbrakk>\n       \\<Longrightarrow> mat_delete (mk_poly A) i (dim_col A - 1) $$\n                         (ia, j) =\n                         coeff_lift_hom.mat_hom\n                          (mat_delete A i (dim_col A - 1)) $$\n                         (ia, j)\n 2. dim_row (mat_delete (mk_poly A) i (dim_col A - 1)) =\n    dim_row (coeff_lift_hom.mat_hom (mat_delete A i (dim_col A - 1)))\n 3. dim_col (mat_delete (mk_poly A) i (dim_col A - 1)) =\n    dim_col (coeff_lift_hom.mat_hom (mat_delete A i (dim_col A - 1)))", "unfolding mat_delete_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ia j.\n       \\<lbrakk>ia < dim_row\n                      (coeff_lift_hom.mat_hom\n                        (mat (dim_row A - 1) (dim_col A - 1)\n                          (\\<lambda>(i', j').\n                              A $$\n                              (if i' < i then i' else Suc i',\n                               if j' < dim_col A - 1 then j'\n                               else Suc j'))));\n        j < dim_col\n             (coeff_lift_hom.mat_hom\n               (mat (dim_row A - 1) (dim_col A - 1)\n                 (\\<lambda>(i', j').\n                     A $$\n                     (if i' < i then i' else Suc i',\n                      if j' < dim_col A - 1 then j' else Suc j'))))\\<rbrakk>\n       \\<Longrightarrow> mat (dim_row (mk_poly A) - 1)\n                          (dim_col (mk_poly A) - 1)\n                          (\\<lambda>(i', j').\n                              mk_poly A $$\n                              (if i' < i then i' else Suc i',\n                               if j' < dim_col A - 1 then j'\n                               else Suc j')) $$\n                         (ia, j) =\n                         coeff_lift_hom.mat_hom\n                          (mat (dim_row A - 1) (dim_col A - 1)\n                            (\\<lambda>(i', j').\n                                A $$\n                                (if i' < i then i' else Suc i',\n                                 if j' < dim_col A - 1 then j'\n                                 else Suc j'))) $$\n                         (ia, j)\n 2. dim_row\n     (mat (dim_row (mk_poly A) - 1) (dim_col (mk_poly A) - 1)\n       (\\<lambda>(i', j').\n           mk_poly A $$\n           (if i' < i then i' else Suc i',\n            if j' < dim_col A - 1 then j' else Suc j'))) =\n    dim_row\n     (coeff_lift_hom.mat_hom\n       (mat (dim_row A - 1) (dim_col A - 1)\n         (\\<lambda>(i', j').\n             A $$\n             (if i' < i then i' else Suc i',\n              if j' < dim_col A - 1 then j' else Suc j'))))\n 3. dim_col\n     (mat (dim_row (mk_poly A) - 1) (dim_col (mk_poly A) - 1)\n       (\\<lambda>(i', j').\n           mk_poly A $$\n           (if i' < i then i' else Suc i',\n            if j' < dim_col A - 1 then j' else Suc j'))) =\n    dim_col\n     (coeff_lift_hom.mat_hom\n       (mat (dim_row A - 1) (dim_col A - 1)\n         (\\<lambda>(i', j').\n             A $$\n             (if i' < i then i' else Suc i',\n              if j' < dim_col A - 1 then j' else Suc j'))))", "by auto"], ["", "private"], ["", "lemma col_mk_poly_sub[simp]:\n  assumes \"l \\<noteq> j'\" and \"j' < dim_col A\"\n  shows \"col (mk_poly_sub A l j) j' = col A j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mk_poly_sub A l j) j' = col A j'", "by(rule eq_vecI; insert assms; simp)"], ["", "private"], ["", "lemma det_mk_poly_sub:\n  assumes A: \"(A :: 'a :: comm_ring_1 poly mat) \\<in> carrier_mat n n\" and i: \"i < n\"\n  shows \"det (mk_poly_sub A (n-1) i) = det A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mk_poly_sub A (n - 1) i) = det A", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. det (mk_poly_sub A (n - 1) i) = det A", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> det (mk_poly_sub A (n - 1) 0) = det A\n 2. \\<And>i.\n       \\<lbrakk>i < n \\<Longrightarrow>\n                det (mk_poly_sub A (n - 1) i) = det A;\n        Suc i < n\\<rbrakk>\n       \\<Longrightarrow> det (mk_poly_sub A (n - 1) (Suc i)) = det A", "case (Suc i)"], ["proof (state)\nthis:\n  i < n \\<Longrightarrow> det (mk_poly_sub A (n - 1) i) = det A\n  Suc i < n\n\ngoal (2 subgoals):\n 1. 0 < n \\<Longrightarrow> det (mk_poly_sub A (n - 1) 0) = det A\n 2. \\<And>i.\n       \\<lbrakk>i < n \\<Longrightarrow>\n                det (mk_poly_sub A (n - 1) i) = det A;\n        Suc i < n\\<rbrakk>\n       \\<Longrightarrow> det (mk_poly_sub A (n - 1) (Suc i)) = det A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mk_poly_sub A (n - 1) (Suc i)) = det A", "unfolding mk_poly_sub.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (addcol (monom (1::'a) (Suc i)) (n - 1) (n - 1 - Suc i)\n          (mk_poly_sub A (n - 1) i)) =\n    det A", "apply(subst det_addcol[of _ n])"], ["proof (prove)\ngoal (4 subgoals):\n 1. n - 1 - Suc i < n\n 2. n - 1 \\<noteq> n - 1 - Suc i\n 3. mk_poly_sub A (n - 1) i \\<in> carrier_mat n n\n 4. det (mk_poly_sub A (n - 1) i) = det A", "using Suc"], ["proof (prove)\nusing this:\n  i < n \\<Longrightarrow> det (mk_poly_sub A (n - 1) i) = det A\n  Suc i < n\n\ngoal (4 subgoals):\n 1. n - 1 - Suc i < n\n 2. n - 1 \\<noteq> n - 1 - Suc i\n 3. mk_poly_sub A (n - 1) i \\<in> carrier_mat n n\n 4. det (mk_poly_sub A (n - 1) i) = det A", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. n - 1 \\<noteq> n - 1 - Suc i\n 2. mk_poly_sub A (n - 1) i \\<in> carrier_mat n n\n 3. det (mk_poly_sub A (n - 1) i) = det A", "using Suc"], ["proof (prove)\nusing this:\n  i < n \\<Longrightarrow> det (mk_poly_sub A (n - 1) i) = det A\n  Suc i < n\n\ngoal (3 subgoals):\n 1. n - 1 \\<noteq> n - 1 - Suc i\n 2. mk_poly_sub A (n - 1) i \\<in> carrier_mat n n\n 3. det (mk_poly_sub A (n - 1) i) = det A", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. mk_poly_sub A (n - 1) i \\<in> carrier_mat n n\n 2. det (mk_poly_sub A (n - 1) i) = det A", "apply (rule mk_poly_sub_carrier[OF A])"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mk_poly_sub A (n - 1) i) = det A", "using Suc"], ["proof (prove)\nusing this:\n  i < n \\<Longrightarrow> det (mk_poly_sub A (n - 1) i) = det A\n  Suc i < n\n\ngoal (1 subgoal):\n 1. det (mk_poly_sub A (n - 1) i) = det A", "by auto"], ["proof (state)\nthis:\n  det (mk_poly_sub A (n - 1) (Suc i)) = det A\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> det (mk_poly_sub A (n - 1) 0) = det A", "qed simp"], ["", "private"], ["", "lemma det_mk_poly:\n  fixes A :: \"'a :: comm_ring_1 mat\"\n  shows \"det (mk_poly A) = [: det A :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mk_poly A) = [:det A:]", "proof (cases \"dim_row A = dim_col A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dim_row A = dim_col A \\<Longrightarrow> det (mk_poly A) = [:det A:]\n 2. dim_row A \\<noteq> dim_col A \\<Longrightarrow>\n    det (mk_poly A) = [:det A:]", "case True"], ["proof (state)\nthis:\n  dim_row A = dim_col A\n\ngoal (2 subgoals):\n 1. dim_row A = dim_col A \\<Longrightarrow> det (mk_poly A) = [:det A:]\n 2. dim_row A \\<noteq> dim_col A \\<Longrightarrow>\n    det (mk_poly A) = [:det A:]", "define n where \"n = dim_col A\""], ["proof (state)\nthis:\n  n = dim_col A\n\ngoal (2 subgoals):\n 1. dim_row A = dim_col A \\<Longrightarrow> det (mk_poly A) = [:det A:]\n 2. dim_row A \\<noteq> dim_col A \\<Longrightarrow>\n    det (mk_poly A) = [:det A:]", "have \"map_mat coeff_lift A \\<in> carrier_mat (dim_row A) (dim_col A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff_lift_hom.mat_hom A \\<in> carrier_mat (dim_row A) (dim_col A)", "by simp"], ["proof (state)\nthis:\n  coeff_lift_hom.mat_hom A \\<in> carrier_mat (dim_row A) (dim_col A)\n\ngoal (2 subgoals):\n 1. dim_row A = dim_col A \\<Longrightarrow> det (mk_poly A) = [:det A:]\n 2. dim_row A \\<noteq> dim_col A \\<Longrightarrow>\n    det (mk_poly A) = [:det A:]", "hence sq: \"map_mat coeff_lift A \\<in> carrier_mat (dim_col A) (dim_col A)\""], ["proof (prove)\nusing this:\n  coeff_lift_hom.mat_hom A \\<in> carrier_mat (dim_row A) (dim_col A)\n\ngoal (1 subgoal):\n 1. coeff_lift_hom.mat_hom A \\<in> carrier_mat (dim_col A) (dim_col A)", "unfolding True"], ["proof (prove)\nusing this:\n  coeff_lift_hom.mat_hom A \\<in> carrier_mat (dim_col A) (dim_col A)\n\ngoal (1 subgoal):\n 1. coeff_lift_hom.mat_hom A \\<in> carrier_mat (dim_col A) (dim_col A)", "."], ["proof (state)\nthis:\n  coeff_lift_hom.mat_hom A \\<in> carrier_mat (dim_col A) (dim_col A)\n\ngoal (2 subgoals):\n 1. dim_row A = dim_col A \\<Longrightarrow> det (mk_poly A) = [:det A:]\n 2. dim_row A \\<noteq> dim_col A \\<Longrightarrow>\n    det (mk_poly A) = [:det A:]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mk_poly A) = [:det A:]", "proof(cases \"dim_col A = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dim_col A = 0 \\<Longrightarrow> det (mk_poly A) = [:det A:]\n 2. dim_col A \\<noteq> 0 \\<Longrightarrow> det (mk_poly A) = [:det A:]", "case True"], ["proof (state)\nthis:\n  dim_col A = 0\n\ngoal (2 subgoals):\n 1. dim_col A = 0 \\<Longrightarrow> det (mk_poly A) = [:det A:]\n 2. dim_col A \\<noteq> 0 \\<Longrightarrow> det (mk_poly A) = [:det A:]", "thus ?thesis"], ["proof (prove)\nusing this:\n  dim_col A = 0\n\ngoal (1 subgoal):\n 1. det (mk_poly A) = [:det A:]", "unfolding det_def"], ["proof (prove)\nusing this:\n  dim_col A = 0\n\ngoal (1 subgoal):\n 1. (if dim_row (mk_poly A) = dim_col (mk_poly A)\n     then \\<Sum>p | p permutes {0..<dim_row (mk_poly A)}.\n            signof p *\n            (\\<Prod>i = 0..<dim_row (mk_poly A). mk_poly A $$ (i, p i))\n     else 0) =\n    [:if dim_row A = dim_col A\n      then \\<Sum>p | p permutes {0..<dim_row A}.\n             signof p * (\\<Prod>i = 0..<dim_row A. A $$ (i, p i))\n      else (0::'a):]", "by simp"], ["proof (state)\nthis:\n  det (mk_poly A) = [:det A:]\n\ngoal (1 subgoal):\n 1. dim_col A \\<noteq> 0 \\<Longrightarrow> det (mk_poly A) = [:det A:]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dim_col A \\<noteq> 0 \\<Longrightarrow> det (mk_poly A) = [:det A:]", "case False"], ["proof (state)\nthis:\n  dim_col A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dim_col A \\<noteq> 0 \\<Longrightarrow> det (mk_poly A) = [:det A:]", "thus ?thesis"], ["proof (prove)\nusing this:\n  dim_col A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. det (mk_poly A) = [:det A:]", "unfolding mk_poly_def"], ["proof (prove)\nusing this:\n  dim_col A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. det (mk_poly_sub (coeff_lift_hom.mat_hom A) (dim_col A - 1)\n          (dim_col A - 1)) =\n    [:det A:]", "by (subst det_mk_poly_sub[OF sq]; simp)"], ["proof (state)\nthis:\n  det (mk_poly A) = [:det A:]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  det (mk_poly A) = [:det A:]\n\ngoal (1 subgoal):\n 1. dim_row A \\<noteq> dim_col A \\<Longrightarrow>\n    det (mk_poly A) = [:det A:]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dim_row A \\<noteq> dim_col A \\<Longrightarrow>\n    det (mk_poly A) = [:det A:]", "case False"], ["proof (state)\nthis:\n  dim_row A \\<noteq> dim_col A\n\ngoal (1 subgoal):\n 1. dim_row A \\<noteq> dim_col A \\<Longrightarrow>\n    det (mk_poly A) = [:det A:]", "hence f2: \"dim_row A = dim_col A \\<longleftrightarrow> False\""], ["proof (prove)\nusing this:\n  dim_row A \\<noteq> dim_col A\n\ngoal (1 subgoal):\n 1. (dim_row A = dim_col A) = False", "by simp"], ["proof (state)\nthis:\n  (dim_row A = dim_col A) = False\n\ngoal (1 subgoal):\n 1. dim_row A \\<noteq> dim_col A \\<Longrightarrow>\n    det (mk_poly A) = [:det A:]", "hence f3: \"dim_row (mk_poly A) = dim_col (mk_poly A) \\<longleftrightarrow> False\""], ["proof (prove)\nusing this:\n  (dim_row A = dim_col A) = False\n\ngoal (1 subgoal):\n 1. (dim_row (mk_poly A) = dim_col (mk_poly A)) = False", "unfolding mk_poly_dim"], ["proof (prove)\nusing this:\n  (dim_row A = dim_col A) = False\n\ngoal (1 subgoal):\n 1. (dim_row A = dim_col A) = False", "by auto"], ["proof (state)\nthis:\n  (dim_row (mk_poly A) = dim_col (mk_poly A)) = False\n\ngoal (1 subgoal):\n 1. dim_row A \\<noteq> dim_col A \\<Longrightarrow>\n    det (mk_poly A) = [:det A:]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mk_poly A) = [:det A:]", "unfolding det_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_row (mk_poly A) = dim_col (mk_poly A)\n     then \\<Sum>p | p permutes {0..<dim_row (mk_poly A)}.\n            signof p *\n            (\\<Prod>i = 0..<dim_row (mk_poly A). mk_poly A $$ (i, p i))\n     else 0) =\n    [:if dim_row A = dim_col A\n      then \\<Sum>p | p permutes {0..<dim_row A}.\n             signof p * (\\<Prod>i = 0..<dim_row A. A $$ (i, p i))\n      else (0::'a):]", "unfolding f2 f3 if_False"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = [:0::'a:]", "by simp"], ["proof (state)\nthis:\n  det (mk_poly A) = [:det A:]\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "fun mk_poly2_row where\n  \"mk_poly2_row A d j pv 0 = pv\"\n| \"mk_poly2_row A d j pv (Suc n) =\n   mk_poly2_row A d j pv n |\\<^sub>v n \\<mapsto> pv $ n + monom (A$$(n,j)) d\""], ["", "private"], ["", "fun mk_poly2_col where\n  \"mk_poly2_col A pv 0 = pv\"\n| \"mk_poly2_col A pv (Suc m) =\n   mk_poly2_row A m (dim_col A - Suc m) (mk_poly2_col A pv m) (dim_row A)\""], ["", "private"], ["", "definition \"mk_poly2 A \\<equiv> mk_poly2_col A (0\\<^sub>v (dim_row A)) (dim_col A)\""], ["", "private"], ["", "lemma mk_poly2_row_dim[simp]: \"dim_vec (mk_poly2_row A d j pv i) = dim_vec pv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (mk_poly2_row A d j pv i) = dim_vec pv", "by(induct i arbitrary: pv, auto)"], ["", "private"], ["", "lemma mk_poly2_col_dim[simp]: \"dim_vec (mk_poly2_col A pv j) = dim_vec pv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (mk_poly2_col A pv j) = dim_vec pv", "by (induct j arbitrary: pv, auto)"], ["", "private"], ["", "lemma mk_poly2_row:\n  assumes n: \"n \\<le> dim_vec pv\"\n  shows \"mk_poly2_row A d j pv n $ i =\n    (if i < n then pv $ i + monom (A $$ (i,j)) d else pv $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2_row A d j pv n $ i =\n    (if i < n then pv $ i + monom (A $$ (i, j)) d else pv $ i)", "using n"], ["proof (prove)\nusing this:\n  n \\<le> dim_vec pv\n\ngoal (1 subgoal):\n 1. mk_poly2_row A d j pv n $ i =\n    (if i < n then pv $ i + monom (A $$ (i, j)) d else pv $ i)", "proof (induct n arbitrary: pv)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>pv.\n       0 \\<le> dim_vec pv \\<Longrightarrow>\n       mk_poly2_row A d j pv 0 $ i =\n       (if i < 0 then pv $ i + monom (A $$ (i, j)) d else pv $ i)\n 2. \\<And>n pv.\n       \\<lbrakk>\\<And>pv.\n                   n \\<le> dim_vec pv \\<Longrightarrow>\n                   mk_poly2_row A d j pv n $ i =\n                   (if i < n then pv $ i + monom (A $$ (i, j)) d\n                    else pv $ i);\n        Suc n \\<le> dim_vec pv\\<rbrakk>\n       \\<Longrightarrow> mk_poly2_row A d j pv (Suc n) $ i =\n                         (if i < Suc n then pv $ i + monom (A $$ (i, j)) d\n                          else pv $ i)", "case (Suc n)"], ["proof (state)\nthis:\n  n \\<le> dim_vec ?pv \\<Longrightarrow>\n  mk_poly2_row A d j ?pv n $ i =\n  (if i < n then ?pv $ i + monom (A $$ (i, j)) d else ?pv $ i)\n  Suc n \\<le> dim_vec pv\n\ngoal (2 subgoals):\n 1. \\<And>pv.\n       0 \\<le> dim_vec pv \\<Longrightarrow>\n       mk_poly2_row A d j pv 0 $ i =\n       (if i < 0 then pv $ i + monom (A $$ (i, j)) d else pv $ i)\n 2. \\<And>n pv.\n       \\<lbrakk>\\<And>pv.\n                   n \\<le> dim_vec pv \\<Longrightarrow>\n                   mk_poly2_row A d j pv n $ i =\n                   (if i < n then pv $ i + monom (A $$ (i, j)) d\n                    else pv $ i);\n        Suc n \\<le> dim_vec pv\\<rbrakk>\n       \\<Longrightarrow> mk_poly2_row A d j pv (Suc n) $ i =\n                         (if i < Suc n then pv $ i + monom (A $$ (i, j)) d\n                          else pv $ i)", "thus ?case"], ["proof (prove)\nusing this:\n  n \\<le> dim_vec ?pv \\<Longrightarrow>\n  mk_poly2_row A d j ?pv n $ i =\n  (if i < n then ?pv $ i + monom (A $$ (i, j)) d else ?pv $ i)\n  Suc n \\<le> dim_vec pv\n\ngoal (1 subgoal):\n 1. mk_poly2_row A d j pv (Suc n) $ i =\n    (if i < Suc n then pv $ i + monom (A $$ (i, j)) d else pv $ i)", "unfolding mk_poly2_row.simps"], ["proof (prove)\nusing this:\n  n \\<le> dim_vec ?pv \\<Longrightarrow>\n  mk_poly2_row A d j ?pv n $ i =\n  (if i < n then ?pv $ i + monom (A $$ (i, j)) d else ?pv $ i)\n  Suc n \\<le> dim_vec pv\n\ngoal (1 subgoal):\n 1. (mk_poly2_row A d j pv\n      n |\\<^sub>v n \\<mapsto> pv $ n + monom (A $$ (n, j)) d) $\n    i =\n    (if i < Suc n then pv $ i + monom (A $$ (i, j)) d else pv $ i)", "by (cases rule: linorder_cases[of \"i\" \"n\"],auto)"], ["proof (state)\nthis:\n  mk_poly2_row A d j pv (Suc n) $ i =\n  (if i < Suc n then pv $ i + monom (A $$ (i, j)) d else pv $ i)\n\ngoal (1 subgoal):\n 1. \\<And>pv.\n       0 \\<le> dim_vec pv \\<Longrightarrow>\n       mk_poly2_row A d j pv 0 $ i =\n       (if i < 0 then pv $ i + monom (A $$ (i, j)) d else pv $ i)", "qed simp"], ["", "private"], ["", "lemma mk_poly2_row_col:\n  assumes dim[simp]: \"dim_vec pv = n\" \"dim_row A = n\" and j: \"j < dim_col A\"\n  shows \"mk_poly2_row A d j pv n = pv + map_vec (\\<lambda>a. monom a d) (col A j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2_row A d j pv n = pv + map_vec (\\<lambda>a. monom a d) (col A j)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (pv +\n             map_vec (\\<lambda>a. monom a d) (col A j)) \\<Longrightarrow>\n       mk_poly2_row A d j pv n $ i =\n       (pv + map_vec (\\<lambda>a. monom a d) (col A j)) $ i\n 2. dim_vec (mk_poly2_row A d j pv n) =\n    dim_vec (pv + map_vec (\\<lambda>a. monom a d) (col A j))", "using mk_poly2_row[of _ pv] j"], ["proof (prove)\nusing this:\n  ?n \\<le> dim_vec pv \\<Longrightarrow>\n  mk_poly2_row ?A ?d ?j pv ?n $ ?i =\n  (if ?i < ?n then pv $ ?i + monom (?A $$ (?i, ?j)) ?d else pv $ ?i)\n  j < dim_col A\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (pv +\n             map_vec (\\<lambda>a. monom a d) (col A j)) \\<Longrightarrow>\n       mk_poly2_row A d j pv n $ i =\n       (pv + map_vec (\\<lambda>a. monom a d) (col A j)) $ i\n 2. dim_vec (mk_poly2_row A d j pv n) =\n    dim_vec (pv + map_vec (\\<lambda>a. monom a d) (col A j))", "by auto"], ["", "private"], ["", "lemma mk_poly2_col:\n  fixes pv :: \"'a :: comm_semiring_1 poly vec\" and A :: \"'a mat\"\n  assumes i: \"i < dim_row A\" and dim: \"dim_row A = dim_vec pv\"\n  shows \"mk_poly2_col A pv j $ i = pv $ i + (\\<Sum>j'<j. monom (A $$ (i, dim_col A - Suc j')) j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2_col A pv j $ i =\n    pv $ i + (\\<Sum>j'<j. monom (A $$ (i, dim_col A - Suc j')) j')", "using dim"], ["proof (prove)\nusing this:\n  dim_row A = dim_vec pv\n\ngoal (1 subgoal):\n 1. mk_poly2_col A pv j $ i =\n    pv $ i + (\\<Sum>j'<j. monom (A $$ (i, dim_col A - Suc j')) j')", "proof (induct j arbitrary: pv)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>pv.\n       dim_row A = dim_vec pv \\<Longrightarrow>\n       mk_poly2_col A pv 0 $ i =\n       pv $ i + (\\<Sum>j'<0. monom (A $$ (i, dim_col A - Suc j')) j')\n 2. \\<And>j pv.\n       \\<lbrakk>\\<And>pv.\n                   dim_row A = dim_vec pv \\<Longrightarrow>\n                   mk_poly2_col A pv j $ i =\n                   pv $ i +\n                   (\\<Sum>j'<j. monom (A $$ (i, dim_col A - Suc j')) j');\n        dim_row A = dim_vec pv\\<rbrakk>\n       \\<Longrightarrow> mk_poly2_col A pv (Suc j) $ i =\n                         pv $ i +\n                         (\\<Sum>j'<Suc j.\n                             monom (A $$ (i, dim_col A - Suc j')) j')", "case (Suc j)"], ["proof (state)\nthis:\n  dim_row A = dim_vec ?pv \\<Longrightarrow>\n  mk_poly2_col A ?pv j $ i =\n  ?pv $ i + (\\<Sum>j'<j. monom (A $$ (i, dim_col A - Suc j')) j')\n  dim_row A = dim_vec pv\n\ngoal (2 subgoals):\n 1. \\<And>pv.\n       dim_row A = dim_vec pv \\<Longrightarrow>\n       mk_poly2_col A pv 0 $ i =\n       pv $ i + (\\<Sum>j'<0. monom (A $$ (i, dim_col A - Suc j')) j')\n 2. \\<And>j pv.\n       \\<lbrakk>\\<And>pv.\n                   dim_row A = dim_vec pv \\<Longrightarrow>\n                   mk_poly2_col A pv j $ i =\n                   pv $ i +\n                   (\\<Sum>j'<j. monom (A $$ (i, dim_col A - Suc j')) j');\n        dim_row A = dim_vec pv\\<rbrakk>\n       \\<Longrightarrow> mk_poly2_col A pv (Suc j) $ i =\n                         pv $ i +\n                         (\\<Sum>j'<Suc j.\n                             monom (A $$ (i, dim_col A - Suc j')) j')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2_col A pv (Suc j) $ i =\n    pv $ i + (\\<Sum>j'<Suc j. monom (A $$ (i, dim_col A - Suc j')) j')", "unfolding mk_poly2_col.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2_row A j (dim_col A - Suc j) (mk_poly2_col A pv j) (dim_row A) $\n    i =\n    pv $ i + (\\<Sum>j'<Suc j. monom (A $$ (i, dim_col A - Suc j')) j')", "apply (subst mk_poly2_row)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dim_row A \\<le> dim_vec (mk_poly2_col A pv j)\n 2. (if i < dim_row A\n     then mk_poly2_col A pv j $ i + monom (A $$ (i, dim_col A - Suc j)) j\n     else mk_poly2_col A pv j $ i) =\n    pv $ i + (\\<Sum>j'<Suc j. monom (A $$ (i, dim_col A - Suc j')) j')", "using Suc"], ["proof (prove)\nusing this:\n  dim_row A = dim_vec ?pv \\<Longrightarrow>\n  mk_poly2_col A ?pv j $ i =\n  ?pv $ i + (\\<Sum>j'<j. monom (A $$ (i, dim_col A - Suc j')) j')\n  dim_row A = dim_vec pv\n\ngoal (2 subgoals):\n 1. dim_row A \\<le> dim_vec (mk_poly2_col A pv j)\n 2. (if i < dim_row A\n     then mk_poly2_col A pv j $ i + monom (A $$ (i, dim_col A - Suc j)) j\n     else mk_poly2_col A pv j $ i) =\n    pv $ i + (\\<Sum>j'<Suc j. monom (A $$ (i, dim_col A - Suc j')) j')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < dim_row A\n     then mk_poly2_col A pv j $ i + monom (A $$ (i, dim_col A - Suc j)) j\n     else mk_poly2_col A pv j $ i) =\n    pv $ i + (\\<Sum>j'<Suc j. monom (A $$ (i, dim_col A - Suc j')) j')", "unfolding Suc(1)[OF Suc(2)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < dim_row A\n     then pv $ i + (\\<Sum>j'<j. monom (A $$ (i, dim_col A - Suc j')) j') +\n          monom (A $$ (i, dim_col A - Suc j)) j\n     else pv $ i + (\\<Sum>j'<j. monom (A $$ (i, dim_col A - Suc j')) j')) =\n    pv $ i + (\\<Sum>j'<Suc j. monom (A $$ (i, dim_col A - Suc j')) j')", "using i"], ["proof (prove)\nusing this:\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. (if i < dim_row A\n     then pv $ i + (\\<Sum>j'<j. monom (A $$ (i, dim_col A - Suc j')) j') +\n          monom (A $$ (i, dim_col A - Suc j)) j\n     else pv $ i + (\\<Sum>j'<j. monom (A $$ (i, dim_col A - Suc j')) j')) =\n    pv $ i + (\\<Sum>j'<Suc j. monom (A $$ (i, dim_col A - Suc j')) j')", "by (simp add: add.assoc)"], ["proof (state)\nthis:\n  mk_poly2_col A pv (Suc j) $ i =\n  pv $ i + (\\<Sum>j'<Suc j. monom (A $$ (i, dim_col A - Suc j')) j')\n\ngoal (1 subgoal):\n 1. \\<And>pv.\n       dim_row A = dim_vec pv \\<Longrightarrow>\n       mk_poly2_col A pv 0 $ i =\n       pv $ i + (\\<Sum>j'<0. monom (A $$ (i, dim_col A - Suc j')) j')", "qed simp"], ["", "private"], ["", "lemma mk_poly2_pre:\n  fixes A :: \"'a :: comm_semiring_1 mat\"\n  assumes i: \"i < dim_row A\"\n  shows \"mk_poly2 A $ i = (\\<Sum>j'<dim_col A. monom (A $$ (i, dim_col A - Suc j')) j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2 A $ i =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, dim_col A - Suc j')) j')", "unfolding mk_poly2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2_col A (0\\<^sub>v (dim_row A)) (dim_col A) $ i =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, dim_col A - Suc j')) j')", "apply(subst mk_poly2_col)"], ["proof (prove)\ngoal (3 subgoals):\n 1. i < dim_row A\n 2. dim_row A = dim_vec (0\\<^sub>v (dim_row A))\n 3. 0\\<^sub>v (dim_row A) $ i +\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, dim_col A - Suc j')) j') =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, dim_col A - Suc j')) j')", "using i"], ["proof (prove)\nusing this:\n  i < dim_row A\n\ngoal (3 subgoals):\n 1. i < dim_row A\n 2. dim_row A = dim_vec (0\\<^sub>v (dim_row A))\n 3. 0\\<^sub>v (dim_row A) $ i +\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, dim_col A - Suc j')) j') =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, dim_col A - Suc j')) j')", "by auto"], ["", "private"], ["", "lemma mk_poly2:\n  fixes A :: \"'a :: comm_semiring_1 mat\"\n  assumes i: \"i < dim_row A\"\n      and c: \"dim_col A > 0\"\n  shows \"mk_poly2 A $ i = (\\<Sum>j'<dim_col A. monom (A $$ (i,j')) (dim_col A - Suc  j'))\"\n    (is \"?l = sum ?f ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2 A $ i =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mk_poly2 A $ i =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))", "define l where \"l = dim_col A - 1\""], ["proof (state)\nthis:\n  l = dim_col A - 1\n\ngoal (1 subgoal):\n 1. mk_poly2 A $ i =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))", "have dim: \"dim_col A = Suc l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col A = Suc l", "unfolding l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col A = Suc (dim_col A - 1)", "using i c"], ["proof (prove)\nusing this:\n  i < dim_row A\n  0 < dim_col A\n\ngoal (1 subgoal):\n 1. dim_col A = Suc (dim_col A - 1)", "by auto"], ["proof (state)\nthis:\n  dim_col A = Suc l\n\ngoal (1 subgoal):\n 1. mk_poly2 A $ i =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))", "let ?g = \"\\<lambda>j. l - j\""], ["proof (state)\ngoal (1 subgoal):\n 1. mk_poly2 A $ i =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))", "have \"?l = sum (?f \\<circ> ?g) ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2 A $ i =\n    sum ((\\<lambda>j'. monom (A $$ (i, j')) (dim_col A - Suc j')) \\<circ>\n         (-) l)\n     {..<dim_col A}", "unfolding l_def mk_poly2_pre[OF i]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j'<dim_col A. monom (A $$ (i, dim_col A - Suc j')) j') =\n    sum ((\\<lambda>j'. monom (A $$ (i, j')) (dim_col A - Suc j')) \\<circ>\n         (-) (dim_col A - 1))\n     {..<dim_col A}", "by auto"], ["proof (state)\nthis:\n  mk_poly2 A $ i =\n  sum ((\\<lambda>j'. monom (A $$ (i, j')) (dim_col A - Suc j')) \\<circ>\n       (-) l)\n   {..<dim_col A}\n\ngoal (1 subgoal):\n 1. mk_poly2 A $ i =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))", "also"], ["proof (state)\nthis:\n  mk_poly2 A $ i =\n  sum ((\\<lambda>j'. monom (A $$ (i, j')) (dim_col A - Suc j')) \\<circ>\n       (-) l)\n   {..<dim_col A}\n\ngoal (1 subgoal):\n 1. mk_poly2 A $ i =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))", "have \"... = sum ?f ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>j'. monom (A $$ (i, j')) (dim_col A - Suc j')) \\<circ>\n         (-) l)\n     {..<dim_col A} =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))", "unfolding dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>j'. monom (A $$ (i, j')) (Suc l - Suc j')) \\<circ> (-) l)\n     {..<Suc l} =\n    (\\<Sum>j'<Suc l. monom (A $$ (i, j')) (Suc l - Suc j'))", "unfolding lessThan_Suc_atMost"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>j'. monom (A $$ (i, j')) (Suc l - Suc j')) \\<circ> (-) l)\n     {..l} =\n    (\\<Sum>j'\\<le>l. monom (A $$ (i, j')) (Suc l - Suc j'))", "using sum.reindex[OF inj_on_diff_nat2,symmetric,unfolded image_diff_atMost]"], ["proof (prove)\nusing this:\n  sum (?g \\<circ> (-) ?n) {..?n} = sum ?g {..?n}\n\ngoal (1 subgoal):\n 1. sum ((\\<lambda>j'. monom (A $$ (i, j')) (Suc l - Suc j')) \\<circ> (-) l)\n     {..l} =\n    (\\<Sum>j'\\<le>l. monom (A $$ (i, j')) (Suc l - Suc j'))", "."], ["proof (state)\nthis:\n  sum ((\\<lambda>j'. monom (A $$ (i, j')) (dim_col A - Suc j')) \\<circ>\n       (-) l)\n   {..<dim_col A} =\n  (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))\n\ngoal (1 subgoal):\n 1. mk_poly2 A $ i =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))", "finally"], ["proof (chain)\npicking this:\n  mk_poly2 A $ i =\n  (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))", "show ?thesis"], ["proof (prove)\nusing this:\n  mk_poly2 A $ i =\n  (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))\n\ngoal (1 subgoal):\n 1. mk_poly2 A $ i =\n    (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))", "."], ["proof (state)\nthis:\n  mk_poly2 A $ i =\n  (\\<Sum>j'<dim_col A. monom (A $$ (i, j')) (dim_col A - Suc j'))\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma mk_poly2_sylvester_upper:\n  fixes p q :: \"'a :: comm_semiring_1 poly\"\n  assumes i: \"i < degree q\"\n  shows \"mk_poly2 (sylvester_mat p q) $ i = monom 1 (degree q - Suc i) * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2 (sylvester_mat p q) $ i = monom (1::'a) (degree q - Suc i) * p", "apply (subst mk_poly2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. i < dim_row (sylvester_mat p q)\n 2. 0 < dim_col (sylvester_mat p q)\n 3. (\\<Sum>j'<dim_col (sylvester_mat p q).\n        monom (sylvester_mat p q $$ (i, j'))\n         (dim_col (sylvester_mat p q) - Suc j')) =\n    monom (1::'a) (degree q - Suc i) * p", "using i"], ["proof (prove)\nusing this:\n  i < degree q\n\ngoal (3 subgoals):\n 1. i < dim_row (sylvester_mat p q)\n 2. 0 < dim_col (sylvester_mat p q)\n 3. (\\<Sum>j'<dim_col (sylvester_mat p q).\n        monom (sylvester_mat p q $$ (i, j'))\n         (dim_col (sylvester_mat p q) - Suc j')) =\n    monom (1::'a) (degree q - Suc i) * p", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < dim_col (sylvester_mat p q)\n 2. (\\<Sum>j'<dim_col (sylvester_mat p q).\n        monom (sylvester_mat p q $$ (i, j'))\n         (dim_col (sylvester_mat p q) - Suc j')) =\n    monom (1::'a) (degree q - Suc i) * p", "using i"], ["proof (prove)\nusing this:\n  i < degree q\n\ngoal (2 subgoals):\n 1. 0 < dim_col (sylvester_mat p q)\n 2. (\\<Sum>j'<dim_col (sylvester_mat p q).\n        monom (sylvester_mat p q $$ (i, j'))\n         (dim_col (sylvester_mat p q) - Suc j')) =\n    monom (1::'a) (degree q - Suc i) * p", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j'<dim_col (sylvester_mat p q).\n        monom (sylvester_mat p q $$ (i, j'))\n         (dim_col (sylvester_mat p q) - Suc j')) =\n    monom (1::'a) (degree q - Suc i) * p", "apply (subst sylvester_sum_mat_upper[OF i,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j'<dim_col (sylvester_mat p q).\n        monom (sylvester_mat p q $$ (i, j'))\n         (dim_col (sylvester_mat p q) - Suc j')) =\n    (\\<Sum>j<degree p + degree q.\n        monom (sylvester_mat p q $$ (i, j)) (degree p + degree q - Suc j))", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {..<dim_col (sylvester_mat p q)} = {..<degree p + degree q}\n 2. \\<And>x.\n       x \\<in> {..<degree p + degree q} \\<Longrightarrow>\n       monom (sylvester_mat p q $$ (i, x))\n        (dim_col (sylvester_mat p q) - Suc x) =\n       monom (sylvester_mat p q $$ (i, x)) (degree p + degree q - Suc x)", "unfolding sylvester_mat_dim lessThan_Suc_atMost"], ["proof (prove)\ngoal (2 subgoals):\n 1. {..<degree p + degree q} = {..<degree p + degree q}\n 2. \\<And>x.\n       x \\<in> {..<degree p + degree q} \\<Longrightarrow>\n       monom (sylvester_mat p q $$ (i, x)) (degree p + degree q - Suc x) =\n       monom (sylvester_mat p q $$ (i, x)) (degree p + degree q - Suc x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {..<degree p + degree q} \\<Longrightarrow>\n       monom (sylvester_mat p q $$ (i, x)) (degree p + degree q - Suc x) =\n       monom (sylvester_mat p q $$ (i, x)) (degree p + degree q - Suc x)", "by auto"], ["", "private"], ["", "lemma mk_poly2_sylvester_lower:\n  fixes p q :: \"'a :: comm_semiring_1 poly\"\n  assumes mi: \"i \\<ge> degree q\" and imn: \"i < degree p + degree q\"\n  shows \"mk_poly2 (sylvester_mat p q) $ i = monom 1 (degree p + degree q - Suc i) * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2 (sylvester_mat p q) $ i =\n    monom (1::'a) (degree p + degree q - Suc i) * q", "apply (subst mk_poly2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. i < dim_row (sylvester_mat p q)\n 2. 0 < dim_col (sylvester_mat p q)\n 3. (\\<Sum>j'<dim_col (sylvester_mat p q).\n        monom (sylvester_mat p q $$ (i, j'))\n         (dim_col (sylvester_mat p q) - Suc j')) =\n    monom (1::'a) (degree p + degree q - Suc i) * q", "using imn"], ["proof (prove)\nusing this:\n  i < degree p + degree q\n\ngoal (3 subgoals):\n 1. i < dim_row (sylvester_mat p q)\n 2. 0 < dim_col (sylvester_mat p q)\n 3. (\\<Sum>j'<dim_col (sylvester_mat p q).\n        monom (sylvester_mat p q $$ (i, j'))\n         (dim_col (sylvester_mat p q) - Suc j')) =\n    monom (1::'a) (degree p + degree q - Suc i) * q", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < dim_col (sylvester_mat p q)\n 2. (\\<Sum>j'<dim_col (sylvester_mat p q).\n        monom (sylvester_mat p q $$ (i, j'))\n         (dim_col (sylvester_mat p q) - Suc j')) =\n    monom (1::'a) (degree p + degree q - Suc i) * q", "using mi imn"], ["proof (prove)\nusing this:\n  degree q \\<le> i\n  i < degree p + degree q\n\ngoal (2 subgoals):\n 1. 0 < dim_col (sylvester_mat p q)\n 2. (\\<Sum>j'<dim_col (sylvester_mat p q).\n        monom (sylvester_mat p q $$ (i, j'))\n         (dim_col (sylvester_mat p q) - Suc j')) =\n    monom (1::'a) (degree p + degree q - Suc i) * q", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j'<dim_col (sylvester_mat p q).\n        monom (sylvester_mat p q $$ (i, j'))\n         (dim_col (sylvester_mat p q) - Suc j')) =\n    monom (1::'a) (degree p + degree q - Suc i) * q", "unfolding sylvester_mat_dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j'<degree p + degree q.\n        monom (sylvester_mat p q $$ (i, j'))\n         (degree p + degree q - Suc j')) =\n    monom (1::'a) (degree p + degree q - Suc i) * q", "using sylvester_sum_mat_lower[OF mi imn]"], ["proof (prove)\nusing this:\n  (\\<Sum>j<degree p + degree q.\n      monom (sylvester_mat p q $$ (i, j)) (degree p + degree q - Suc j)) =\n  monom (1::'a) (degree p + degree q - Suc i) * q\n\ngoal (1 subgoal):\n 1. (\\<Sum>j'<degree p + degree q.\n        monom (sylvester_mat p q $$ (i, j'))\n         (degree p + degree q - Suc j')) =\n    monom (1::'a) (degree p + degree q - Suc i) * q", "apply (subst sylvester_sum_mat_lower)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<Sum>j<degree p + degree q.\n        monom (sylvester_mat p q $$ (i, j)) (degree p + degree q - Suc j)) =\n    monom (1::'a) (degree p + degree q - Suc i) * q \\<Longrightarrow>\n    degree q \\<le> i\n 2. (\\<Sum>j<degree p + degree q.\n        monom (sylvester_mat p q $$ (i, j)) (degree p + degree q - Suc j)) =\n    monom (1::'a) (degree p + degree q - Suc i) * q \\<Longrightarrow>\n    i < degree p + degree q\n 3. (\\<Sum>j<degree p + degree q.\n        monom (sylvester_mat p q $$ (i, j)) (degree p + degree q - Suc j)) =\n    monom (1::'a) (degree p + degree q - Suc i) * q \\<Longrightarrow>\n    monom (1::'a) (degree p + degree q - Suc i) * q =\n    monom (1::'a) (degree p + degree q - Suc i) * q", "using mi imn"], ["proof (prove)\nusing this:\n  degree q \\<le> i\n  i < degree p + degree q\n\ngoal (3 subgoals):\n 1. (\\<Sum>j<degree p + degree q.\n        monom (sylvester_mat p q $$ (i, j)) (degree p + degree q - Suc j)) =\n    monom (1::'a) (degree p + degree q - Suc i) * q \\<Longrightarrow>\n    degree q \\<le> i\n 2. (\\<Sum>j<degree p + degree q.\n        monom (sylvester_mat p q $$ (i, j)) (degree p + degree q - Suc j)) =\n    monom (1::'a) (degree p + degree q - Suc i) * q \\<Longrightarrow>\n    i < degree p + degree q\n 3. (\\<Sum>j<degree p + degree q.\n        monom (sylvester_mat p q $$ (i, j)) (degree p + degree q - Suc j)) =\n    monom (1::'a) (degree p + degree q - Suc i) * q \\<Longrightarrow>\n    monom (1::'a) (degree p + degree q - Suc i) * q =\n    monom (1::'a) (degree p + degree q - Suc i) * q", "by auto"], ["", "private"], ["", "lemma foo:\n  fixes v :: \"'a :: comm_semiring_1 vec\"\n  shows \"monom 1 d \\<cdot>\\<^sub>v map_vec coeff_lift v = map_vec (\\<lambda>a. monom a d) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) d \\<cdot>\\<^sub>v coeff_lift_hom.vec_hom v =\n    map_vec (\\<lambda>a. monom a d) v", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (map_vec (\\<lambda>a. monom a d) v) \\<Longrightarrow>\n       (monom (1::'a) d \\<cdot>\\<^sub>v coeff_lift_hom.vec_hom v) $ i =\n       map_vec (\\<lambda>a. monom a d) v $ i\n 2. dim_vec (monom (1::'a) d \\<cdot>\\<^sub>v coeff_lift_hom.vec_hom v) =\n    dim_vec (map_vec (\\<lambda>a. monom a d) v)", "unfolding index_map_vec index_col"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       (monom (1::'a) d \\<cdot>\\<^sub>v coeff_lift_hom.vec_hom v) $ i =\n       monom (v $ i) d\n 2. dim_vec (monom (1::'a) d \\<cdot>\\<^sub>v coeff_lift_hom.vec_hom v) =\n    dim_vec v", "by (auto simp add: Polynomial.smult_monom)"], ["", "private"], ["", "lemma mk_poly_sub_corresp:\n  assumes dimA[simp]: \"dim_col A = Suc l\" and dimpv[simp]: \"dim_vec pv = dim_row A\"\n      and j: \"j < dim_col A\"\n  shows \"pv + col (mk_poly_sub (map_mat coeff_lift A) l j) l =\n    mk_poly2_col A pv (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n    mk_poly2_col A pv (Suc j)", "proof(insert j, induct j)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < dim_col A \\<Longrightarrow>\n    pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l 0) l =\n    mk_poly2_col A pv (Suc 0)\n 2. \\<And>j.\n       \\<lbrakk>j < dim_col A \\<Longrightarrow>\n                pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n                mk_poly2_col A pv (Suc j);\n        Suc j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> pv +\n                         col (mk_poly_sub (coeff_lift_hom.mat_hom A) l\n                               (Suc j))\n                          l =\n                         mk_poly2_col A pv (Suc (Suc j))", "have le: \"dim_row A \\<le> dim_vec pv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row A \\<le> dim_vec pv", "using dimpv"], ["proof (prove)\nusing this:\n  dim_vec pv = dim_row A\n\ngoal (1 subgoal):\n 1. dim_row A \\<le> dim_vec pv", "by simp"], ["proof (state)\nthis:\n  dim_row A \\<le> dim_vec pv\n\ngoal (2 subgoals):\n 1. 0 < dim_col A \\<Longrightarrow>\n    pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l 0) l =\n    mk_poly2_col A pv (Suc 0)\n 2. \\<And>j.\n       \\<lbrakk>j < dim_col A \\<Longrightarrow>\n                pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n                mk_poly2_col A pv (Suc j);\n        Suc j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> pv +\n                         col (mk_poly_sub (coeff_lift_hom.mat_hom A) l\n                               (Suc j))\n                          l =\n                         mk_poly2_col A pv (Suc (Suc j))", "have l: \"l < dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < dim_col A", "using dimA"], ["proof (prove)\nusing this:\n  dim_col A = Suc l\n\ngoal (1 subgoal):\n 1. l < dim_col A", "by simp"], ["proof (state)\nthis:\n  l < dim_col A\n\ngoal (2 subgoals):\n 1. 0 < dim_col A \\<Longrightarrow>\n    pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l 0) l =\n    mk_poly2_col A pv (Suc 0)\n 2. \\<And>j.\n       \\<lbrakk>j < dim_col A \\<Longrightarrow>\n                pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n                mk_poly2_col A pv (Suc j);\n        Suc j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> pv +\n                         col (mk_poly_sub (coeff_lift_hom.mat_hom A) l\n                               (Suc j))\n                          l =\n                         mk_poly2_col A pv (Suc (Suc j))", "{"], ["proof (state)\nthis:\n  l < dim_col A\n\ngoal (2 subgoals):\n 1. 0 < dim_col A \\<Longrightarrow>\n    pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l 0) l =\n    mk_poly2_col A pv (Suc 0)\n 2. \\<And>j.\n       \\<lbrakk>j < dim_col A \\<Longrightarrow>\n                pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n                mk_poly2_col A pv (Suc j);\n        Suc j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> pv +\n                         col (mk_poly_sub (coeff_lift_hom.mat_hom A) l\n                               (Suc j))\n                          l =\n                         mk_poly2_col A pv (Suc (Suc j))", "case 0"], ["proof (state)\nthis:\n  0 < dim_col A\n\ngoal (2 subgoals):\n 1. 0 < dim_col A \\<Longrightarrow>\n    pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l 0) l =\n    mk_poly2_col A pv (Suc 0)\n 2. \\<And>j.\n       \\<lbrakk>j < dim_col A \\<Longrightarrow>\n                pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n                mk_poly2_col A pv (Suc j);\n        Suc j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> pv +\n                         col (mk_poly_sub (coeff_lift_hom.mat_hom A) l\n                               (Suc j))\n                          l =\n                         mk_poly2_col A pv (Suc (Suc j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l 0) l =\n    mk_poly2_col A pv (Suc 0)", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (mk_poly2_col A pv (Suc 0)) \\<Longrightarrow>\n       (pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l 0) l) $ i =\n       mk_poly2_col A pv (Suc 0) $ i\n 2. dim_vec (pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l 0) l) =\n    dim_vec (mk_poly2_col A pv (Suc 0))", "using mk_poly2_row[OF le]"], ["proof (prove)\nusing this:\n  mk_poly2_row ?A ?d ?j pv (dim_row A) $ ?i =\n  (if ?i < dim_row A then pv $ ?i + monom (?A $$ (?i, ?j)) ?d else pv $ ?i)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (mk_poly2_col A pv (Suc 0)) \\<Longrightarrow>\n       (pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l 0) l) $ i =\n       mk_poly2_col A pv (Suc 0) $ i\n 2. dim_vec (pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l 0) l) =\n    dim_vec (mk_poly2_col A pv (Suc 0))", "by (auto simp add: monom_0)"], ["proof (state)\nthis:\n  pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l 0) l =\n  mk_poly2_col A pv (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < dim_col A \\<Longrightarrow>\n                pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n                mk_poly2_col A pv (Suc j);\n        Suc j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> pv +\n                         col (mk_poly_sub (coeff_lift_hom.mat_hom A) l\n                               (Suc j))\n                          l =\n                         mk_poly2_col A pv (Suc (Suc j))", "}"], ["proof (state)\nthis:\n  0 < dim_col A \\<Longrightarrow>\n  pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l 0) l =\n  mk_poly2_col A pv (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < dim_col A \\<Longrightarrow>\n                pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n                mk_poly2_col A pv (Suc j);\n        Suc j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> pv +\n                         col (mk_poly_sub (coeff_lift_hom.mat_hom A) l\n                               (Suc j))\n                          l =\n                         mk_poly2_col A pv (Suc (Suc j))", "{"], ["proof (state)\nthis:\n  0 < dim_col A \\<Longrightarrow>\n  pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l 0) l =\n  mk_poly2_col A pv (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < dim_col A \\<Longrightarrow>\n                pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n                mk_poly2_col A pv (Suc j);\n        Suc j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> pv +\n                         col (mk_poly_sub (coeff_lift_hom.mat_hom A) l\n                               (Suc j))\n                          l =\n                         mk_poly2_col A pv (Suc (Suc j))", "case (Suc j)"], ["proof (state)\nthis:\n  j < dim_col A \\<Longrightarrow>\n  pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n  mk_poly2_col A pv (Suc j)\n  Suc j < dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < dim_col A \\<Longrightarrow>\n                pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n                mk_poly2_col A pv (Suc j);\n        Suc j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> pv +\n                         col (mk_poly_sub (coeff_lift_hom.mat_hom A) l\n                               (Suc j))\n                          l =\n                         mk_poly2_col A pv (Suc (Suc j))", "hence j: \"j < dim_col A\""], ["proof (prove)\nusing this:\n  j < dim_col A \\<Longrightarrow>\n  pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n  mk_poly2_col A pv (Suc j)\n  Suc j < dim_col A\n\ngoal (1 subgoal):\n 1. j < dim_col A", "by simp"], ["proof (state)\nthis:\n  j < dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < dim_col A \\<Longrightarrow>\n                pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n                mk_poly2_col A pv (Suc j);\n        Suc j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> pv +\n                         col (mk_poly_sub (coeff_lift_hom.mat_hom A) l\n                               (Suc j))\n                          l =\n                         mk_poly2_col A pv (Suc (Suc j))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l (Suc j)) l =\n    mk_poly2_col A pv (Suc (Suc j))", "unfolding mk_poly_sub.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. pv +\n    col (addcol (monom (1::'a) (Suc j)) l (l - Suc j)\n          (mk_poly_sub (coeff_lift_hom.mat_hom A) l j))\n     l =\n    mk_poly2_col A pv (Suc (Suc j))", "apply(subst col_addcol)"], ["proof (prove)\ngoal (3 subgoals):\n 1. l < dim_col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j)\n 2. l - Suc j < dim_col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j)\n 3. pv +\n    (monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n     col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) +\n     col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l) =\n    mk_poly2_col A pv (Suc (Suc j))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. l - Suc j < dim_col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j)\n 2. pv +\n    (monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n     col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) +\n     col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l) =\n    mk_poly2_col A pv (Suc (Suc j))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. pv +\n    (monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n     col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) +\n     col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l) =\n    mk_poly2_col A pv (Suc (Suc j))", "apply(subst(2) comm_add_vec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j)\n    \\<in> carrier_vec ?n15\n 2. col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l\n    \\<in> carrier_vec ?n15\n 3. pv +\n    (col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l +\n     monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n     col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j)) =\n    mk_poly2_col A pv (Suc (Suc j))", "apply(rule carrier_vecI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l\n    \\<in> carrier_vec (dim_row A)\n 2. pv +\n    (col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l +\n     monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n     col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j)) =\n    mk_poly2_col A pv (Suc (Suc j))", "apply(rule carrier_vecI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pv +\n    (col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l +\n     monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n     col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j)) =\n    mk_poly2_col A pv (Suc (Suc j))", "apply(subst assoc_add_vec[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. pv \\<in> carrier_vec ?n21\n 2. col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l\n    \\<in> carrier_vec ?n21\n 3. monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j)\n    \\<in> carrier_vec ?n21\n 4. pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) =\n    mk_poly2_col A pv (Suc (Suc j))", "apply(rule carrier_vecI, rule refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l\n    \\<in> carrier_vec (dim_vec pv)\n 2. monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j)\n    \\<in> carrier_vec (dim_vec pv)\n 3. pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) =\n    mk_poly2_col A pv (Suc (Suc j))", "apply(rule carrier_vecI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j)\n    \\<in> carrier_vec (dim_vec pv)\n 2. pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) =\n    mk_poly2_col A pv (Suc (Suc j))", "apply(rule carrier_vecI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) =\n    mk_poly2_col A pv (Suc (Suc j))", "unfolding Suc(1)[OF j]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) =\n    mk_poly2_col A pv (Suc (Suc j))", "apply(subst(2) mk_poly2_col.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) =\n    mk_poly2_row A (Suc j) (dim_col A - Suc (Suc j))\n     (mk_poly2_col A pv (Suc j)) (dim_row A)", "apply(subst mk_poly2_row_col)"], ["proof (prove)\ngoal (4 subgoals):\n 1. dim_vec (mk_poly2_col A pv (Suc j)) = dim_row A\n 2. dim_row A = dim_row A\n 3. dim_col A - Suc (Suc j) < dim_col A\n 4. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (dim_col A - Suc (Suc j)))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. dim_row A = dim_row A\n 2. dim_col A - Suc (Suc j) < dim_col A\n 3. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (dim_col A - Suc (Suc j)))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. dim_col A - Suc (Suc j) < dim_col A\n 2. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (dim_col A - Suc (Suc j)))", "using Suc"], ["proof (prove)\nusing this:\n  j < dim_col A \\<Longrightarrow>\n  pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n  mk_poly2_col A pv (Suc j)\n  Suc j < dim_col A\n\ngoal (2 subgoals):\n 1. dim_col A - Suc (Suc j) < dim_col A\n 2. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (dim_col A - Suc (Suc j)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) (l - Suc j) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (dim_col A - Suc (Suc j)))", "apply(subst col_mk_poly_sub)"], ["proof (prove)\ngoal (3 subgoals):\n 1. l \\<noteq> l - Suc j\n 2. l - Suc j < dim_col (coeff_lift_hom.mat_hom A)\n 3. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (coeff_lift_hom.mat_hom A) (l - Suc j) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (dim_col A - Suc (Suc j)))", "using Suc"], ["proof (prove)\nusing this:\n  j < dim_col A \\<Longrightarrow>\n  pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n  mk_poly2_col A pv (Suc j)\n  Suc j < dim_col A\n\ngoal (3 subgoals):\n 1. l \\<noteq> l - Suc j\n 2. l - Suc j < dim_col (coeff_lift_hom.mat_hom A)\n 3. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (coeff_lift_hom.mat_hom A) (l - Suc j) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (dim_col A - Suc (Suc j)))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. l - Suc j < dim_col (coeff_lift_hom.mat_hom A)\n 2. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (coeff_lift_hom.mat_hom A) (l - Suc j) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (dim_col A - Suc (Suc j)))", "using Suc"], ["proof (prove)\nusing this:\n  j < dim_col A \\<Longrightarrow>\n  pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l j) l =\n  mk_poly2_col A pv (Suc j)\n  Suc j < dim_col A\n\ngoal (2 subgoals):\n 1. l - Suc j < dim_col (coeff_lift_hom.mat_hom A)\n 2. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (coeff_lift_hom.mat_hom A) (l - Suc j) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (dim_col A - Suc (Suc j)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    col (coeff_lift_hom.mat_hom A) (l - Suc j) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (dim_col A - Suc (Suc j)))", "apply(subst col_map_mat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. l - Suc j < dim_col A\n 2. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    coeff_lift_hom.vec_hom (col A (l - Suc j)) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (dim_col A - Suc (Suc j)))", "using dimA"], ["proof (prove)\nusing this:\n  dim_col A = Suc l\n\ngoal (2 subgoals):\n 1. l - Suc j < dim_col A\n 2. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    coeff_lift_hom.vec_hom (col A (l - Suc j)) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (dim_col A - Suc (Suc j)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2_col A pv (Suc j) +\n    monom (1::'a) (Suc j) \\<cdot>\\<^sub>v\n    coeff_lift_hom.vec_hom (col A (l - Suc j)) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (dim_col A - Suc (Suc j)))", "unfolding foo dimA"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (l - Suc j)) =\n    mk_poly2_col A pv (Suc j) +\n    map_vec (\\<lambda>a. monom a (Suc j)) (col A (Suc l - Suc (Suc j)))", "by simp"], ["proof (state)\nthis:\n  pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l (Suc j)) l =\n  mk_poly2_col A pv (Suc (Suc j))\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ja2 < dim_col A \\<Longrightarrow>\n           pv + col (mk_poly_sub (coeff_lift_hom.mat_hom A) l ?ja2) l =\n           mk_poly2_col A pv (Suc ?ja2);\n   Suc ?ja2 < dim_col A\\<rbrakk>\n  \\<Longrightarrow> pv +\n                    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l\n                          (Suc ?ja2))\n                     l =\n                    mk_poly2_col A pv (Suc (Suc ?ja2))\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma col_mk_poly_mk_poly2:\n  fixes A :: \"'a :: comm_semiring_1 mat\"\n  assumes dim: \"dim_col A > 0\"\n  shows \"col (mk_poly A) (dim_col A - 1) = mk_poly2 A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mk_poly A) (dim_col A - 1) = mk_poly2 A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. col (mk_poly A) (dim_col A - 1) = mk_poly2 A", "define l where \"l = dim_col A - 1\""], ["proof (state)\nthis:\n  l = dim_col A - 1\n\ngoal (1 subgoal):\n 1. col (mk_poly A) (dim_col A - 1) = mk_poly2 A", "have dim: \"dim_col A = Suc l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col A = Suc l", "unfolding l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col A = Suc (dim_col A - 1)", "using dim"], ["proof (prove)\nusing this:\n  0 < dim_col A\n\ngoal (1 subgoal):\n 1. dim_col A = Suc (dim_col A - 1)", "by auto"], ["proof (state)\nthis:\n  dim_col A = Suc l\n\ngoal (1 subgoal):\n 1. col (mk_poly A) (dim_col A - 1) = mk_poly2 A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mk_poly A) (dim_col A - 1) = mk_poly2 A", "unfolding mk_poly_def mk_poly2_def dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mk_poly_sub (coeff_lift_hom.mat_hom A) (Suc l - 1) (Suc l - 1))\n     (Suc l - 1) =\n    mk_poly2_col A (0\\<^sub>v (dim_row A)) (Suc l)", "apply(subst mk_poly_sub_corresp[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. dim_col A = Suc ?l\n 2. dim_vec (0\\<^sub>v (dim_row A)) = dim_row A\n 3. l < dim_col A\n 4. col (mk_poly_sub (coeff_lift_hom.mat_hom A) (Suc l - 1) (Suc l - 1))\n     (Suc l - 1) =\n    0\\<^sub>v (dim_row A) +\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) ?l l) ?l", "apply(rule dim)"], ["proof (prove)\ngoal (3 subgoals):\n 1. dim_vec (0\\<^sub>v (dim_row A)) = dim_row A\n 2. l < dim_col A\n 3. col (mk_poly_sub (coeff_lift_hom.mat_hom A) (Suc l - 1) (Suc l - 1))\n     (Suc l - 1) =\n    0\\<^sub>v (dim_row A) +\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l l) l", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. l < dim_col A\n 2. col (mk_poly_sub (coeff_lift_hom.mat_hom A) (Suc l - 1) (Suc l - 1))\n     (Suc l - 1) =\n    0\\<^sub>v (dim_row A) +\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l l) l", "using dim"], ["proof (prove)\nusing this:\n  dim_col A = Suc l\n\ngoal (2 subgoals):\n 1. l < dim_col A\n 2. col (mk_poly_sub (coeff_lift_hom.mat_hom A) (Suc l - 1) (Suc l - 1))\n     (Suc l - 1) =\n    0\\<^sub>v (dim_row A) +\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l l) l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mk_poly_sub (coeff_lift_hom.mat_hom A) (Suc l - 1) (Suc l - 1))\n     (Suc l - 1) =\n    0\\<^sub>v (dim_row A) +\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l l) l", "apply(subst left_zero_vec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. col (mk_poly_sub (coeff_lift_hom.mat_hom A) l l) l\n    \\<in> carrier_vec (dim_row A)\n 2. col (mk_poly_sub (coeff_lift_hom.mat_hom A) (Suc l - 1) (Suc l - 1))\n     (Suc l - 1) =\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l l) l", "apply(rule carrier_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dim_vec (col (mk_poly_sub (coeff_lift_hom.mat_hom A) l l) l) = dim_row A\n 2. col (mk_poly_sub (coeff_lift_hom.mat_hom A) (Suc l - 1) (Suc l - 1))\n     (Suc l - 1) =\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l l) l", "using dim"], ["proof (prove)\nusing this:\n  dim_col A = Suc l\n\ngoal (2 subgoals):\n 1. dim_vec (col (mk_poly_sub (coeff_lift_hom.mat_hom A) l l) l) = dim_row A\n 2. col (mk_poly_sub (coeff_lift_hom.mat_hom A) (Suc l - 1) (Suc l - 1))\n     (Suc l - 1) =\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l l) l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mk_poly_sub (coeff_lift_hom.mat_hom A) (Suc l - 1) (Suc l - 1))\n     (Suc l - 1) =\n    col (mk_poly_sub (coeff_lift_hom.mat_hom A) l l) l", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  col (mk_poly A) (dim_col A - 1) = mk_poly2 A\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma mk_poly_mk_poly2:\n  fixes A :: \"'a :: comm_semiring_1 mat\"\n  assumes dim: \"dim_col A > 0\" and i: \"i < dim_row A\"\n  shows \"mk_poly A $$ (i,dim_col A - 1) = mk_poly2 A $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly A $$ (i, dim_col A - 1) = mk_poly2 A $ i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mk_poly A $$ (i, dim_col A - 1) = mk_poly2 A $ i", "have \"mk_poly A $$ (i,dim_col A - 1) = col (mk_poly A) (dim_col A - 1) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly A $$ (i, dim_col A - 1) = col (mk_poly A) (dim_col A - 1) $ i", "apply (subst index_col(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. i < dim_row (mk_poly A)\n 2. dim_col A - 1 < dim_col (mk_poly A)\n 3. mk_poly A $$ (i, dim_col A - 1) = mk_poly A $$ (i, dim_col A - 1)", "using dim i"], ["proof (prove)\nusing this:\n  0 < dim_col A\n  i < dim_row A\n\ngoal (3 subgoals):\n 1. i < dim_row (mk_poly A)\n 2. dim_col A - 1 < dim_col (mk_poly A)\n 3. mk_poly A $$ (i, dim_col A - 1) = mk_poly A $$ (i, dim_col A - 1)", "by auto"], ["proof (state)\nthis:\n  mk_poly A $$ (i, dim_col A - 1) = col (mk_poly A) (dim_col A - 1) $ i\n\ngoal (1 subgoal):\n 1. mk_poly A $$ (i, dim_col A - 1) = mk_poly2 A $ i", "also"], ["proof (state)\nthis:\n  mk_poly A $$ (i, dim_col A - 1) = col (mk_poly A) (dim_col A - 1) $ i\n\ngoal (1 subgoal):\n 1. mk_poly A $$ (i, dim_col A - 1) = mk_poly2 A $ i", "note col_mk_poly_mk_poly2[OF dim]"], ["proof (state)\nthis:\n  col (mk_poly A) (dim_col A - 1) = mk_poly2 A\n\ngoal (1 subgoal):\n 1. mk_poly A $$ (i, dim_col A - 1) = mk_poly2 A $ i", "finally"], ["proof (chain)\npicking this:\n  mk_poly A $$ (i, dim_col A - 1) = mk_poly2 A $ i", "show ?thesis"], ["proof (prove)\nusing this:\n  mk_poly A $$ (i, dim_col A - 1) = mk_poly2 A $ i\n\ngoal (1 subgoal):\n 1. mk_poly A $$ (i, dim_col A - 1) = mk_poly2 A $ i", "."], ["proof (state)\nthis:\n  mk_poly A $$ (i, dim_col A - 1) = mk_poly2 A $ i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_poly_sylvester_upper:\n  fixes p q :: \"'a :: comm_ring_1 poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes i: \"i < n\"\n  shows \"mk_poly (sylvester_mat p q) $$ (i, m + n - 1) = monom 1 (n - Suc i) * p\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (n - Suc i) * p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (n - Suc i) * p", "let ?S = \"sylvester_mat p q\""], ["proof (state)\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (n - Suc i) * p", "have c: \"m+n = dim_col ?S\" and r: \"m+n = dim_row ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m + n = dim_col (sylvester_mat p q) &&&\n    m + n = dim_row (sylvester_mat p q)", "unfolding m_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p + degree q = dim_col (sylvester_mat p q) &&&\n    degree p + degree q = dim_row (sylvester_mat p q)", "by auto"], ["proof (state)\nthis:\n  m + n = dim_col (sylvester_mat p q)\n  m + n = dim_row (sylvester_mat p q)\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (n - Suc i) * p", "hence \"dim_col ?S > 0\" \"i < dim_row ?S\""], ["proof (prove)\nusing this:\n  m + n = dim_col (sylvester_mat p q)\n  m + n = dim_row (sylvester_mat p q)\n\ngoal (1 subgoal):\n 1. 0 < dim_col (sylvester_mat p q) &&& i < dim_row (sylvester_mat p q)", "using i"], ["proof (prove)\nusing this:\n  m + n = dim_col (sylvester_mat p q)\n  m + n = dim_row (sylvester_mat p q)\n  i < n\n\ngoal (1 subgoal):\n 1. 0 < dim_col (sylvester_mat p q) &&& i < dim_row (sylvester_mat p q)", "by auto"], ["proof (state)\nthis:\n  0 < dim_col (sylvester_mat p q)\n  i < dim_row (sylvester_mat p q)\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (n - Suc i) * p", "from mk_poly_mk_poly2[OF this]"], ["proof (chain)\npicking this:\n  mk_poly (sylvester_mat p q) $$ (i, dim_col (sylvester_mat p q) - 1) =\n  mk_poly2 (sylvester_mat p q) $ i", "have \"?l = mk_poly2 (sylvester_mat p q) $ i\""], ["proof (prove)\nusing this:\n  mk_poly (sylvester_mat p q) $$ (i, dim_col (sylvester_mat p q) - 1) =\n  mk_poly2 (sylvester_mat p q) $ i\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    mk_poly2 (sylvester_mat p q) $ i", "unfolding m_def n_def"], ["proof (prove)\nusing this:\n  mk_poly (sylvester_mat p q) $$ (i, dim_col (sylvester_mat p q) - 1) =\n  mk_poly2 (sylvester_mat p q) $ i\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, degree p + degree q - 1) =\n    mk_poly2 (sylvester_mat p q) $ i", "by auto"], ["proof (state)\nthis:\n  mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n  mk_poly2 (sylvester_mat p q) $ i\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (n - Suc i) * p", "also"], ["proof (state)\nthis:\n  mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n  mk_poly2 (sylvester_mat p q) $ i\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (n - Suc i) * p", "have \"... = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2 (sylvester_mat p q) $ i = monom (1::'a) (n - Suc i) * p", "apply(subst mk_poly2_sylvester_upper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < degree q\n 2. monom (1::'a) (degree q - Suc i) * p = monom (1::'a) (n - Suc i) * p", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (2 subgoals):\n 1. i < degree q\n 2. monom (1::'a) (degree q - Suc i) * p = monom (1::'a) (n - Suc i) * p", "unfolding n_def m_def"], ["proof (prove)\nusing this:\n  i < degree q\n\ngoal (2 subgoals):\n 1. i < degree q\n 2. monom (1::'a) (degree q - Suc i) * p =\n    monom (1::'a) (degree q - Suc i) * p", "by auto"], ["proof (state)\nthis:\n  mk_poly2 (sylvester_mat p q) $ i = monom (1::'a) (n - Suc i) * p\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (n - Suc i) * p", "finally"], ["proof (chain)\npicking this:\n  mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n  monom (1::'a) (n - Suc i) * p", "show ?thesis"], ["proof (prove)\nusing this:\n  mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n  monom (1::'a) (n - Suc i) * p\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (n - Suc i) * p", "."], ["proof (state)\nthis:\n  mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n  monom (1::'a) (n - Suc i) * p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mk_poly_sylvester_lower:\n  fixes p q :: \"'a :: comm_ring_1 poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes ni: \"n \\<le> i\" and imn: \"i < m+n\"\n  shows \"mk_poly (sylvester_mat p q) $$ (i, m + n - 1) = monom 1 (m + n - Suc i) * q\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (m + n - Suc i) * q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (m + n - Suc i) * q", "let ?S = \"sylvester_mat p q\""], ["proof (state)\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (m + n - Suc i) * q", "have c: \"m+n = dim_col ?S\" and r: \"m+n = dim_row ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m + n = dim_col (sylvester_mat p q) &&&\n    m + n = dim_row (sylvester_mat p q)", "unfolding m_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p + degree q = dim_col (sylvester_mat p q) &&&\n    degree p + degree q = dim_row (sylvester_mat p q)", "by auto"], ["proof (state)\nthis:\n  m + n = dim_col (sylvester_mat p q)\n  m + n = dim_row (sylvester_mat p q)\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (m + n - Suc i) * q", "hence \"dim_col ?S > 0\" \"i < dim_row ?S\""], ["proof (prove)\nusing this:\n  m + n = dim_col (sylvester_mat p q)\n  m + n = dim_row (sylvester_mat p q)\n\ngoal (1 subgoal):\n 1. 0 < dim_col (sylvester_mat p q) &&& i < dim_row (sylvester_mat p q)", "using imn"], ["proof (prove)\nusing this:\n  m + n = dim_col (sylvester_mat p q)\n  m + n = dim_row (sylvester_mat p q)\n  i < m + n\n\ngoal (1 subgoal):\n 1. 0 < dim_col (sylvester_mat p q) &&& i < dim_row (sylvester_mat p q)", "by auto"], ["proof (state)\nthis:\n  0 < dim_col (sylvester_mat p q)\n  i < dim_row (sylvester_mat p q)\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (m + n - Suc i) * q", "from mk_poly_mk_poly2[OF this]"], ["proof (chain)\npicking this:\n  mk_poly (sylvester_mat p q) $$ (i, dim_col (sylvester_mat p q) - 1) =\n  mk_poly2 (sylvester_mat p q) $ i", "have \"?l = mk_poly2 (sylvester_mat p q) $ i\""], ["proof (prove)\nusing this:\n  mk_poly (sylvester_mat p q) $$ (i, dim_col (sylvester_mat p q) - 1) =\n  mk_poly2 (sylvester_mat p q) $ i\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    mk_poly2 (sylvester_mat p q) $ i", "unfolding m_def n_def"], ["proof (prove)\nusing this:\n  mk_poly (sylvester_mat p q) $$ (i, dim_col (sylvester_mat p q) - 1) =\n  mk_poly2 (sylvester_mat p q) $ i\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, degree p + degree q - 1) =\n    mk_poly2 (sylvester_mat p q) $ i", "by auto"], ["proof (state)\nthis:\n  mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n  mk_poly2 (sylvester_mat p q) $ i\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (m + n - Suc i) * q", "also"], ["proof (state)\nthis:\n  mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n  mk_poly2 (sylvester_mat p q) $ i\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (m + n - Suc i) * q", "have \"... = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly2 (sylvester_mat p q) $ i = monom (1::'a) (m + n - Suc i) * q", "apply(subst mk_poly2_sylvester_lower)"], ["proof (prove)\ngoal (3 subgoals):\n 1. degree q \\<le> i\n 2. i < degree p + degree q\n 3. monom (1::'a) (degree p + degree q - Suc i) * q =\n    monom (1::'a) (m + n - Suc i) * q", "using ni imn"], ["proof (prove)\nusing this:\n  n \\<le> i\n  i < m + n\n\ngoal (3 subgoals):\n 1. degree q \\<le> i\n 2. i < degree p + degree q\n 3. monom (1::'a) (degree p + degree q - Suc i) * q =\n    monom (1::'a) (m + n - Suc i) * q", "unfolding n_def m_def"], ["proof (prove)\nusing this:\n  degree q \\<le> i\n  i < degree p + degree q\n\ngoal (3 subgoals):\n 1. degree q \\<le> i\n 2. i < degree p + degree q\n 3. monom (1::'a) (degree p + degree q - Suc i) * q =\n    monom (1::'a) (degree p + degree q - Suc i) * q", "by auto"], ["proof (state)\nthis:\n  mk_poly2 (sylvester_mat p q) $ i = monom (1::'a) (m + n - Suc i) * q\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (m + n - Suc i) * q", "finally"], ["proof (chain)\npicking this:\n  mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n  monom (1::'a) (m + n - Suc i) * q", "show ?thesis"], ["proof (prove)\nusing this:\n  mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n  monom (1::'a) (m + n - Suc i) * q\n\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n    monom (1::'a) (m + n - Suc i) * q", "."], ["proof (state)\nthis:\n  mk_poly (sylvester_mat p q) $$ (i, m + n - 1) =\n  monom (1::'a) (m + n - Suc i) * q\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next lemma corresponds to Lemma 7.2.1.\\<close>"], ["", "lemma resultant_as_poly:\n  fixes p q :: \"'a :: comm_ring_1 poly\"\n  assumes degp: \"degree p > 0\" and degq: \"degree q > 0\"\n  shows \"\\<exists>p' q'. degree p' < degree q \\<and> degree q' < degree p \\<and>\n         [: resultant p q :] = p' * p + q' * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p' q'.\n       degree p' < degree q \\<and>\n       degree q' < degree p \\<and> [:resultant p q:] = p' * p + q' * q", "proof (intro exI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "define m where \"m = degree p\""], ["proof (state)\nthis:\n  m = degree p\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "define n where \"n = degree q\""], ["proof (state)\nthis:\n  n = degree q\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "define d where \"d = dim_row (mk_poly (sylvester_mat p q))\""], ["proof (state)\nthis:\n  d = dim_row (mk_poly (sylvester_mat p q))\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "define c where \"c = (\\<lambda>i. coeff_lift (cofactor (sylvester_mat p q) i (m+n-1)))\""], ["proof (state)\nthis:\n  c = (\\<lambda>i. [:cofactor (sylvester_mat p q) i (m + n - 1):])\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "define p' where \"p' = (\\<Sum>i<n. monom 1 (n - Suc i) * c i)\""], ["proof (state)\nthis:\n  p' = (\\<Sum>i<n. monom (1::'a) (n - Suc i) * c i)\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "define q' where \"q' = (\\<Sum>i<m. monom 1 (m - Suc i) * c (n+i))\""], ["proof (state)\nthis:\n  q' = (\\<Sum>i<m. monom (1::'a) (m - Suc i) * c (n + i))\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have degc: \"\\<And>i. degree (c i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. degree (c i) = 0", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. degree [:cofactor (sylvester_mat p q) i (m + n - 1):] = 0", "by auto"], ["proof (state)\nthis:\n  degree (c ?i) = 0\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have dmn: \"d = m+n\" and mnd: \"m + n = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d = m + n &&& m + n = d", "unfolding d_def m_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mk_poly (sylvester_mat p q)) = degree p + degree q &&&\n    degree p + degree q = dim_row (mk_poly (sylvester_mat p q))", "by auto"], ["proof (state)\nthis:\n  d = m + n\n  m + n = d\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have \"[: resultant p q :] =\n    (\\<Sum>i<d. mk_poly (sylvester_mat p q) $$ (i,m+n-1) *\n        cofactor (mk_poly (sylvester_mat p q)) i (m+n-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:resultant p q:] =\n    (\\<Sum>i<d.\n        mk_poly (sylvester_mat p q) $$ (i, m + n - 1) *\n        cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1))", "unfolding resultant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:det (sylvester_mat p q):] =\n    (\\<Sum>i<d.\n        mk_poly (sylvester_mat p q) $$ (i, m + n - 1) *\n        cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1))", "unfolding det_mk_poly[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mk_poly (sylvester_mat p q)) =\n    (\\<Sum>i<d.\n        mk_poly (sylvester_mat p q) $$ (i, m + n - 1) *\n        cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1))", "unfolding m_def n_def d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. det (mk_poly (sylvester_mat p q)) =\n    (\\<Sum>i<dim_row (mk_poly (sylvester_mat p q)).\n        mk_poly (sylvester_mat p q) $$ (i, degree p + degree q - 1) *\n        cofactor (mk_poly (sylvester_mat p q)) i (degree p + degree q - 1))", "apply(rule laplace_expansion_column[of _ _ \"degree p + degree q - 1\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. mk_poly (sylvester_mat p q)\n    \\<in> carrier_mat (dim_row (mk_poly (sylvester_mat p q)))\n           (dim_row (mk_poly (sylvester_mat p q)))\n 2. degree p + degree q - 1 < dim_row (mk_poly (sylvester_mat p q))", "apply(rule carrier_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. dim_row (mk_poly (sylvester_mat p q)) =\n    dim_row (mk_poly (sylvester_mat p q))\n 2. dim_col (mk_poly (sylvester_mat p q)) =\n    dim_row (mk_poly (sylvester_mat p q))\n 3. degree p + degree q - 1 < dim_row (mk_poly (sylvester_mat p q))", "using degp"], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (3 subgoals):\n 1. dim_row (mk_poly (sylvester_mat p q)) =\n    dim_row (mk_poly (sylvester_mat p q))\n 2. dim_col (mk_poly (sylvester_mat p q)) =\n    dim_row (mk_poly (sylvester_mat p q))\n 3. degree p + degree q - 1 < dim_row (mk_poly (sylvester_mat p q))", "by auto"], ["proof (state)\nthis:\n  [:resultant p q:] =\n  (\\<Sum>i<d.\n      mk_poly (sylvester_mat p q) $$ (i, m + n - 1) *\n      cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1))\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "also"], ["proof (state)\nthis:\n  [:resultant p q:] =\n  (\\<Sum>i<d.\n      mk_poly (sylvester_mat p q) $$ (i, m + n - 1) *\n      cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1))\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "{"], ["proof (state)\nthis:\n  [:resultant p q:] =\n  (\\<Sum>i<d.\n      mk_poly (sylvester_mat p q) $$ (i, m + n - 1) *\n      cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1))\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "assume i: \"i<d\""], ["proof (state)\nthis:\n  i < d\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have d2: \"d = dim_row (sylvester_mat p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d = dim_row (sylvester_mat p q)", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mk_poly (sylvester_mat p q)) = dim_row (sylvester_mat p q)", "by auto"], ["proof (state)\nthis:\n  d = dim_row (sylvester_mat p q)\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have \"cofactor (mk_poly (sylvester_mat p q)) i (m+n-1) =\n      (- 1) ^ (i + (m+n-1)) * det (mat_delete (mk_poly (sylvester_mat p q)) i (m+n-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1) =\n    (- 1) ^ (i + (m + n - 1)) *\n    det (mat_delete (mk_poly (sylvester_mat p q)) i (m + n - 1))", "using cofactor_def"], ["proof (prove)\nusing this:\n  cofactor ?A ?i ?j = (- (1::?'a)) ^ (?i + ?j) * det (mat_delete ?A ?i ?j)\n\ngoal (1 subgoal):\n 1. cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1) =\n    (- 1) ^ (i + (m + n - 1)) *\n    det (mat_delete (mk_poly (sylvester_mat p q)) i (m + n - 1))", "."], ["proof (state)\nthis:\n  cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1) =\n  (- 1) ^ (i + (m + n - 1)) *\n  det (mat_delete (mk_poly (sylvester_mat p q)) i (m + n - 1))\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "also"], ["proof (state)\nthis:\n  cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1) =\n  (- 1) ^ (i + (m + n - 1)) *\n  det (mat_delete (mk_poly (sylvester_mat p q)) i (m + n - 1))\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have \"... =\n      (- 1) ^ (i+m+n-1) * coeff_lift (det (mat_delete (sylvester_mat p q) i (m+n-1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ (i + (m + n - 1)) *\n    det (mat_delete (mk_poly (sylvester_mat p q)) i (m + n - 1)) =\n    (- 1) ^ (i + m + n - 1) *\n    [:det (mat_delete (sylvester_mat p q) i (m + n - 1)):]", "using mk_poly_delete[OF i[unfolded d2]] degp degq"], ["proof (prove)\nusing this:\n  mat_delete (mk_poly (sylvester_mat p q)) i\n   (dim_col (sylvester_mat p q) - 1) =\n  coeff_lift_hom.mat_hom\n   (mat_delete (sylvester_mat p q) i (dim_col (sylvester_mat p q) - 1))\n  0 < degree p\n  0 < degree q\n\ngoal (1 subgoal):\n 1. (- 1) ^ (i + (m + n - 1)) *\n    det (mat_delete (mk_poly (sylvester_mat p q)) i (m + n - 1)) =\n    (- 1) ^ (i + m + n - 1) *\n    [:det (mat_delete (sylvester_mat p q) i (m + n - 1)):]", "unfolding m_def n_def"], ["proof (prove)\nusing this:\n  mat_delete (mk_poly (sylvester_mat p q)) i\n   (dim_col (sylvester_mat p q) - 1) =\n  coeff_lift_hom.mat_hom\n   (mat_delete (sylvester_mat p q) i (dim_col (sylvester_mat p q) - 1))\n  0 < degree p\n  0 < degree q\n\ngoal (1 subgoal):\n 1. (- 1) ^ (i + (degree p + degree q - 1)) *\n    det (mat_delete (mk_poly (sylvester_mat p q)) i\n          (degree p + degree q - 1)) =\n    (- 1) ^ (i + degree p + degree q - 1) *\n    [:det (mat_delete (sylvester_mat p q) i (degree p + degree q - 1)):]", "by (auto simp add: add.assoc)"], ["proof (state)\nthis:\n  (- 1) ^ (i + (m + n - 1)) *\n  det (mat_delete (mk_poly (sylvester_mat p q)) i (m + n - 1)) =\n  (- 1) ^ (i + m + n - 1) *\n  [:det (mat_delete (sylvester_mat p q) i (m + n - 1)):]\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "also"], ["proof (state)\nthis:\n  (- 1) ^ (i + (m + n - 1)) *\n  det (mat_delete (mk_poly (sylvester_mat p q)) i (m + n - 1)) =\n  (- 1) ^ (i + m + n - 1) *\n  [:det (mat_delete (sylvester_mat p q) i (m + n - 1)):]\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have \"i+m+n-1 = i+(m+n-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + m + n - 1 = i + (m + n - 1)", "using i[folded mnd]"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (1 subgoal):\n 1. i + m + n - 1 = i + (m + n - 1)", "by auto"], ["proof (state)\nthis:\n  i + m + n - 1 = i + (m + n - 1)\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "finally"], ["proof (chain)\npicking this:\n  cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1) =\n  (- 1) ^ (i + (m + n - 1)) *\n  [:det (mat_delete (sylvester_mat p q) i (m + n - 1)):]", "have \"cofactor (mk_poly (sylvester_mat p q)) i (m+n-1) = c i\""], ["proof (prove)\nusing this:\n  cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1) =\n  (- 1) ^ (i + (m + n - 1)) *\n  [:det (mat_delete (sylvester_mat p q) i (m + n - 1)):]\n\ngoal (1 subgoal):\n 1. cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1) = c i", "unfolding c_def cofactor_def hom_distribs"], ["proof (prove)\nusing this:\n  (- 1) ^ (i + (m + n - 1)) *\n  det (mat_delete (mk_poly (sylvester_mat p q)) i (m + n - 1)) =\n  (- 1) ^ (i + (m + n - 1)) *\n  [:det (mat_delete (sylvester_mat p q) i (m + n - 1)):]\n\ngoal (1 subgoal):\n 1. (- 1) ^ (i + (m + n - 1)) *\n    det (mat_delete (mk_poly (sylvester_mat p q)) i (m + n - 1)) =\n    (- [:1::'a:]) ^ (i + (m + n - 1)) *\n    [:det (mat_delete (sylvester_mat p q) i (m + n - 1)):]", "by simp"], ["proof (state)\nthis:\n  cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1) = c i\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "}"], ["proof (state)\nthis:\n  ?i2 < d \\<Longrightarrow>\n  cofactor (mk_poly (sylvester_mat p q)) ?i2 (m + n - 1) = c ?i2\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "hence \"... = (\\<Sum>i<d. mk_poly (sylvester_mat p q) $$ (i, m+n-1) * c i)\"\n    (is \"_ = sum ?f _\")"], ["proof (prove)\nusing this:\n  ?i2 < d \\<Longrightarrow>\n  cofactor (mk_poly (sylvester_mat p q)) ?i2 (m + n - 1) = c ?i2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<d.\n        mk_poly (sylvester_mat p q) $$ (i, m + n - 1) *\n        cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1)) =\n    (\\<Sum>i<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<d.\n      mk_poly (sylvester_mat p q) $$ (i, m + n - 1) *\n      cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1)) =\n  (\\<Sum>i<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i)\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<d.\n      mk_poly (sylvester_mat p q) $$ (i, m + n - 1) *\n      cofactor (mk_poly (sylvester_mat p q)) i (m + n - 1)) =\n  (\\<Sum>i<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i)\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have \"... = sum ?f ({..<n} \\<union> {n ..<d})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n    (\\<Sum>i\\<in>{..<n} \\<union> {n..<d}.\n       mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i)", "unfolding dmn"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<m + n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n    (\\<Sum>i\\<in>{..<n} \\<union> {n..<m + n}.\n       mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i)", "apply(subst ivl_disj_un(8))"], ["proof (prove)\ngoal (2 subgoals):\n 1. n \\<le> m + n\n 2. (\\<Sum>i<m + n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n    (\\<Sum>i<m + n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n  (\\<Sum>i\\<in>{..<n} \\<union> {n..<d}.\n     mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i)\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n  (\\<Sum>i\\<in>{..<n} \\<union> {n..<d}.\n     mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i)\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have \"... = sum ?f {..<n} + sum ?f {n..<d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{..<n} \\<union> {n..<d}.\n       mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n    (\\<Sum>i<n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) +\n    (\\<Sum>i = n..<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i)", "apply(subst sum.union_disjoint)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {..<n}\n 2. finite {n..<d}\n 3. {..<n} \\<inter> {n..<d} = {}\n 4. (\\<Sum>i<n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) +\n    (\\<Sum>i = n..<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n    (\\<Sum>i<n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) +\n    (\\<Sum>i = n..<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<n} \\<union> {n..<d}.\n     mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n  (\\<Sum>i<n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) +\n  (\\<Sum>i = n..<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i)\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<n} \\<union> {n..<d}.\n     mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n  (\\<Sum>i<n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) +\n  (\\<Sum>i = n..<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i)\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "{"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{..<n} \\<union> {n..<d}.\n     mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n  (\\<Sum>i<n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) +\n  (\\<Sum>i = n..<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i)\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "assume i: \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have \"?f i = monom 1 (n - Suc i) * c i * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i =\n    monom (1::'a) (n - Suc i) * c i * p", "unfolding m_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, degree p + degree q - 1) * c i =\n    monom (1::'a) (degree q - Suc i) * c i * p", "apply(subst mk_poly_sylvester_upper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < degree q\n 2. monom (1::'a) (degree q - Suc i) * p * c i =\n    monom (1::'a) (degree q - Suc i) * c i * p", "using i"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (2 subgoals):\n 1. i < degree q\n 2. monom (1::'a) (degree q - Suc i) * p * c i =\n    monom (1::'a) (degree q - Suc i) * c i * p", "unfolding n_def"], ["proof (prove)\nusing this:\n  i < degree q\n\ngoal (2 subgoals):\n 1. i < degree q\n 2. monom (1::'a) (degree q - Suc i) * p * c i =\n    monom (1::'a) (degree q - Suc i) * c i * p", "by auto"], ["proof (state)\nthis:\n  mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i =\n  monom (1::'a) (n - Suc i) * c i * p\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "}"], ["proof (state)\nthis:\n  ?i2 < n \\<Longrightarrow>\n  mk_poly (sylvester_mat p q) $$ (?i2, m + n - 1) * c ?i2 =\n  monom (1::'a) (n - Suc ?i2) * c ?i2 * p\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "hence \"sum ?f {..<n} = p' * p\""], ["proof (prove)\nusing this:\n  ?i2 < n \\<Longrightarrow>\n  mk_poly (sylvester_mat p q) $$ (?i2, m + n - 1) * c ?i2 =\n  monom (1::'a) (n - Suc ?i2) * c ?i2 * p\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n    p' * p", "unfolding p'_def sum_distrib_right"], ["proof (prove)\nusing this:\n  ?i2 < n \\<Longrightarrow>\n  mk_poly (sylvester_mat p q) $$ (?i2, m + n - 1) * c ?i2 =\n  monom (1::'a) (n - Suc ?i2) * c ?i2 * p\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n    (\\<Sum>na<n. monom (1::'a) (n - Suc na) * c na * p)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) = p' * p\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) = p' * p\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "{"], ["proof (state)\nthis:\n  (\\<Sum>i<n. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) = p' * p\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "assume i: \"i \\<in> {n..<d}\""], ["proof (state)\nthis:\n  i \\<in> {n..<d}\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have \"?f i = monom 1 (m + n - Suc i) * c i * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i =\n    monom (1::'a) (m + n - Suc i) * c i * q", "unfolding m_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_poly (sylvester_mat p q) $$ (i, degree p + degree q - 1) * c i =\n    monom (1::'a) (degree p + degree q - Suc i) * c i * q", "apply(subst mk_poly_sylvester_lower)"], ["proof (prove)\ngoal (3 subgoals):\n 1. degree q \\<le> i\n 2. i < degree p + degree q\n 3. monom (1::'a) (degree p + degree q - Suc i) * q * c i =\n    monom (1::'a) (degree p + degree q - Suc i) * c i * q", "using i"], ["proof (prove)\nusing this:\n  i \\<in> {n..<d}\n\ngoal (3 subgoals):\n 1. degree q \\<le> i\n 2. i < degree p + degree q\n 3. monom (1::'a) (degree p + degree q - Suc i) * q * c i =\n    monom (1::'a) (degree p + degree q - Suc i) * c i * q", "unfolding dmn n_def m_def"], ["proof (prove)\nusing this:\n  i \\<in> {degree q..<degree p + degree q}\n\ngoal (3 subgoals):\n 1. degree q \\<le> i\n 2. i < degree p + degree q\n 3. monom (1::'a) (degree p + degree q - Suc i) * q * c i =\n    monom (1::'a) (degree p + degree q - Suc i) * c i * q", "by auto"], ["proof (state)\nthis:\n  mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i =\n  monom (1::'a) (m + n - Suc i) * c i * q\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "}"], ["proof (state)\nthis:\n  ?i2 \\<in> {n..<d} \\<Longrightarrow>\n  mk_poly (sylvester_mat p q) $$ (?i2, m + n - 1) * c ?i2 =\n  monom (1::'a) (m + n - Suc ?i2) * c ?i2 * q\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "hence \"sum ?f {n..<d} = (\\<Sum>i=n..<d. monom 1 (m + n - Suc i) * c i) * q\"\n    (is \"_ = sum ?h _ * _\")"], ["proof (prove)\nusing this:\n  ?i2 \\<in> {n..<d} \\<Longrightarrow>\n  mk_poly (sylvester_mat p q) $$ (?i2, m + n - 1) * c ?i2 =\n  monom (1::'a) (m + n - Suc ?i2) * c ?i2 * q\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n..<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n    (\\<Sum>i = n..<d. monom (1::'a) (m + n - Suc i) * c i) * q", "unfolding sum_distrib_right"], ["proof (prove)\nusing this:\n  ?i2 \\<in> {n..<d} \\<Longrightarrow>\n  mk_poly (sylvester_mat p q) $$ (?i2, m + n - 1) * c ?i2 =\n  monom (1::'a) (m + n - Suc ?i2) * c ?i2 * q\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = n..<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n    (\\<Sum>na = n..<d. monom (1::'a) (m + n - Suc na) * c na * q)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = n..<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n  (\\<Sum>i = n..<d. monom (1::'a) (m + n - Suc i) * c i) * q\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = n..<d. mk_poly (sylvester_mat p q) $$ (i, m + n - 1) * c i) =\n  (\\<Sum>i = n..<d. monom (1::'a) (m + n - Suc i) * c i) * q\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have \"{n..<d} = (\\<lambda>i. i+n) ` {0..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n..<d} = (\\<lambda>i. i + n) ` {0..<m}", "by (simp add: dmn)"], ["proof (state)\nthis:\n  {n..<d} = (\\<lambda>i. i + n) ` {0..<m}\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "also"], ["proof (state)\nthis:\n  {n..<d} = (\\<lambda>i. i + n) ` {0..<m}\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have \"sum ?h ... = sum (?h \\<circ> (\\<lambda>i. i+n)) {0..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>(\\<lambda>i. i + n) ` {0..<m}.\n       monom (1::'a) (m + n - Suc i) * c i) =\n    sum ((\\<lambda>i. monom (1::'a) (m + n - Suc i) * c i) \\<circ>\n         (\\<lambda>i. i + n))\n     {0..<m}", "apply(subst sum.reindex[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>i. i + n) {0..<m}\n 2. (\\<Sum>i\\<in>(\\<lambda>i. i + n) ` {0..<m}.\n       monom (1::'a) (m + n - Suc i) * c i) =\n    (\\<Sum>i\\<in>(\\<lambda>i. i + n) ` {0..<m}.\n       monom (1::'a) (m + n - Suc i) * c i)", "apply (rule inj_onI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {0..<m}; y \\<in> {0..<m}; x + n = y + n\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. (\\<Sum>i\\<in>(\\<lambda>i. i + n) ` {0..<m}.\n       monom (1::'a) (m + n - Suc i) * c i) =\n    (\\<Sum>i\\<in>(\\<lambda>i. i + n) ` {0..<m}.\n       monom (1::'a) (m + n - Suc i) * c i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>(\\<lambda>i. i + n) ` {0..<m}.\n     monom (1::'a) (m + n - Suc i) * c i) =\n  sum ((\\<lambda>i. monom (1::'a) (m + n - Suc i) * c i) \\<circ>\n       (\\<lambda>i. i + n))\n   {0..<m}\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>(\\<lambda>i. i + n) ` {0..<m}.\n     monom (1::'a) (m + n - Suc i) * c i) =\n  sum ((\\<lambda>i. monom (1::'a) (m + n - Suc i) * c i) \\<circ>\n       (\\<lambda>i. i + n))\n   {0..<m}\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "have \"... = q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>i. monom (1::'a) (m + n - Suc i) * c i) \\<circ>\n         (\\<lambda>i. i + n))\n     {0..<m} =\n    q'", "unfolding q'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>i. monom (1::'a) (m + n - Suc i) * c i) \\<circ>\n         (\\<lambda>i. i + n))\n     {0..<m} =\n    (\\<Sum>i<m. monom (1::'a) (m - Suc i) * c (n + i))", "apply(rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {0..<m} = {..<m}\n 2. \\<And>x.\n       x \\<in> {..<m} \\<Longrightarrow>\n       ((\\<lambda>i. monom (1::'a) (m + n - Suc i) * c i) \\<circ>\n        (\\<lambda>i. i + n))\n        x =\n       monom (1::'a) (m - Suc x) * c (n + x)", "by (auto simp add: add.commute)"], ["proof (state)\nthis:\n  sum ((\\<lambda>i. monom (1::'a) (m + n - Suc i) * c i) \\<circ>\n       (\\<lambda>i. i + n))\n   {0..<m} =\n  q'\n\ngoal (3 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q", "finally"], ["proof (chain)\npicking this:\n  [:resultant p q:] = p' * p + q' * q", "show main: \"[:resultant p q:] = p' * p + q' * q\""], ["proof (prove)\nusing this:\n  [:resultant p q:] = p' * p + q' * q\n\ngoal (1 subgoal):\n 1. [:resultant p q:] = p' * p + q' * q", "."], ["proof (state)\nthis:\n  [:resultant p q:] = p' * p + q' * q\n\ngoal (2 subgoals):\n 1. degree\n     (\\<Sum>i<degree q.\n         monom (1::'a) (degree q - Suc i) *\n         [:cofactor (sylvester_mat p q) i (degree p + degree q - 1):])\n    < degree q\n 2. degree\n     (\\<Sum>i<degree p.\n         monom (1::'a) (degree p - Suc i) *\n         [:cofactor (sylvester_mat p q) (degree q + i)\n            (degree p + degree q - 1):])\n    < degree p", "show \"degree p' < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p' < n", "unfolding p'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Sum>i<n. monom (1::'a) (n - Suc i) * c i) < n", "apply(rule degree_sum_smaller)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < n\n 2. finite {..<n}\n 3. \\<And>i.\n       i \\<in> {..<n} \\<Longrightarrow>\n       degree (monom (1::'a) (n - Suc i) * c i) < n", "using degq[folded n_def]"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (3 subgoals):\n 1. 0 < n\n 2. finite {..<n}\n 3. \\<And>i.\n       i \\<in> {..<n} \\<Longrightarrow>\n       degree (monom (1::'a) (n - Suc i) * c i) < n", "apply force+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<n} \\<Longrightarrow>\n       degree (monom (1::'a) (n - Suc i) * c i) < n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<n} \\<Longrightarrow>\n       degree (monom (1::'a) (n - Suc i) * c i) < n", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<n} \\<Longrightarrow>\n       degree (monom (1::'a) (n - Suc i) * c i) < n", "assume i: \"i \\<in> {..<n}\""], ["proof (state)\nthis:\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<n} \\<Longrightarrow>\n       degree (monom (1::'a) (n - Suc i) * c i) < n", "show \"degree (monom 1 (n - Suc i) * c i) < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (n - Suc i) * c i) < n", "apply (rule order.strict_trans1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree (monom (1::'a) (n - Suc i) * c i) \\<le> ?b\n 2. ?b < n", "apply (rule degree_mult_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (n - Suc i)) + degree (c i) < n", "unfolding add.right_neutral degc"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (n - Suc i)) < n", "apply (rule order.strict_trans1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree (monom (1::'a) (n - Suc i)) \\<le> ?b4\n 2. ?b4 < n", "apply (rule degree_monom_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n - Suc i < n", "using i"], ["proof (prove)\nusing this:\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. n - Suc i < n", "by auto"], ["proof (state)\nthis:\n  degree (monom (1::'a) (n - Suc i) * c i) < n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree p' < n\n\ngoal (1 subgoal):\n 1. degree\n     (\\<Sum>i<degree p.\n         monom (1::'a) (degree p - Suc i) *\n         [:cofactor (sylvester_mat p q) (degree q + i)\n            (degree p + degree q - 1):])\n    < degree p", "show \"degree q' < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree q' < m", "unfolding q'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Sum>i<m. monom (1::'a) (m - Suc i) * c (n + i)) < m", "apply (rule degree_sum_smaller)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < m\n 2. finite {..<m}\n 3. \\<And>i.\n       i \\<in> {..<m} \\<Longrightarrow>\n       degree (monom (1::'a) (m - Suc i) * c (n + i)) < m", "using degp[folded m_def]"], ["proof (prove)\nusing this:\n  0 < m\n\ngoal (3 subgoals):\n 1. 0 < m\n 2. finite {..<m}\n 3. \\<And>i.\n       i \\<in> {..<m} \\<Longrightarrow>\n       degree (monom (1::'a) (m - Suc i) * c (n + i)) < m", "apply force+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<m} \\<Longrightarrow>\n       degree (monom (1::'a) (m - Suc i) * c (n + i)) < m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<m} \\<Longrightarrow>\n       degree (monom (1::'a) (m - Suc i) * c (n + i)) < m", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<m} \\<Longrightarrow>\n       degree (monom (1::'a) (m - Suc i) * c (n + i)) < m", "assume i: \"i \\<in> {..<m}\""], ["proof (state)\nthis:\n  i \\<in> {..<m}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<m} \\<Longrightarrow>\n       degree (monom (1::'a) (m - Suc i) * c (n + i)) < m", "show \"degree (monom 1 (m-Suc i) * c (n+i)) < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (m - Suc i) * c (n + i)) < m", "apply (rule order.strict_trans1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree (monom (1::'a) (m - Suc i) * c (n + i)) \\<le> ?b\n 2. ?b < m", "apply (rule degree_mult_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (m - Suc i)) + degree (c (n + i)) < m", "unfolding add.right_neutral degc"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (monom (1::'a) (m - Suc i)) < m", "apply (rule order.strict_trans1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree (monom (1::'a) (m - Suc i)) \\<le> ?b4\n 2. ?b4 < m", "apply (rule degree_monom_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m - Suc i < m", "using i"], ["proof (prove)\nusing this:\n  i \\<in> {..<m}\n\ngoal (1 subgoal):\n 1. m - Suc i < m", "by auto"], ["proof (state)\nthis:\n  degree (monom (1::'a) (m - Suc i) * c (n + i)) < m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree q' < m\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Resultant as Nonzero Polynomial Expression\\<close>"], ["", "lemma resultant_zero:\n  fixes p q :: \"'a :: comm_ring_1 poly\"\n  assumes deg: \"degree p > 0 \\<or> degree q > 0\"\n      and xp: \"poly p x = 0\" and xq: \"poly q x = 0\"\n  shows \"resultant p q = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "assume degp: \"degree p > 0\" and degq: \"degree q > 0\""], ["proof (state)\nthis:\n  0 < degree p\n  0 < degree q\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "obtain p' q' where \"[: resultant p q :] = p' * p + q' * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p' q'.\n        [:resultant p q:] = p' * p + q' * q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using resultant_as_poly[OF degp degq]"], ["proof (prove)\nusing this:\n  \\<exists>p' q'.\n     degree p' < degree q \\<and>\n     degree q' < degree p \\<and> [:resultant p q:] = p' * p + q' * q\n\ngoal (1 subgoal):\n 1. (\\<And>p' q'.\n        [:resultant p q:] = p' * p + q' * q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  [:resultant p q:] = p' * p + q' * q\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "hence \"resultant p q = poly (p' * p + q' * q) x\""], ["proof (prove)\nusing this:\n  [:resultant p q:] = p' * p + q' * q\n\ngoal (1 subgoal):\n 1. resultant p q = poly (p' * p + q' * q) x", "using mpoly_base_conv(2)[of \"resultant p q\"]"], ["proof (prove)\nusing this:\n  [:resultant p q:] = p' * p + q' * q\n  resultant p q = poly [:resultant p q:] ?x\n\ngoal (1 subgoal):\n 1. resultant p q = poly (p' * p + q' * q) x", "by auto"], ["proof (state)\nthis:\n  resultant p q = poly (p' * p + q' * q) x\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "also"], ["proof (state)\nthis:\n  resultant p q = poly (p' * p + q' * q) x\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "have \"... = poly p x * poly p' x + poly q x * poly q' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (p' * p + q' * q) x = poly p x * poly p' x + poly q x * poly q' x", "unfolding poly2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (p' * p + q' * q) x = poly p x * poly p' x + poly q x * poly q' x", "by simp"], ["proof (state)\nthis:\n  poly (p' * p + q' * q) x = poly p x * poly p' x + poly q x * poly q' x\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  resultant p q = poly p x * poly p' x + poly q x * poly q' x", "have ?thesis"], ["proof (prove)\nusing this:\n  resultant p q = poly p x * poly p' x + poly q x * poly q' x\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "using xp xq"], ["proof (prove)\nusing this:\n  resultant p q = poly p x * poly p' x + poly q x * poly q' x\n  poly p x = (0::'a)\n  poly q x = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "by simp"], ["proof (state)\nthis:\n  resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < degree p; 0 < degree q\\<rbrakk>\n  \\<Longrightarrow> resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < degree p; 0 < degree q\\<rbrakk>\n  \\<Longrightarrow> resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>0 < degree p; 0 < degree q\\<rbrakk>\n  \\<Longrightarrow> resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "assume degp: \"degree p = 0\""], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "have p: \"p = [:0:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = [:0::'a:]", "using xp degree_0_id[OF degp,symmetric]"], ["proof (prove)\nusing this:\n  poly p x = (0::'a)\n  p = [:coeff p 0:]\n\ngoal (1 subgoal):\n 1. p = [:0::'a:]", "by (metis mpoly_base_conv(2))"], ["proof (state)\nthis:\n  p = [:0::'a:]\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant [:0::'a:] q = (0::'a)", "using degp deg"], ["proof (prove)\nusing this:\n  degree p = 0\n  0 < degree p \\<or> 0 < degree q\n\ngoal (1 subgoal):\n 1. resultant [:0::'a:] q = (0::'a)", "by simp"], ["proof (state)\nthis:\n  resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "}"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow> resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "moreover"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow> resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "{"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow> resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "assume degq: \"degree q = 0\""], ["proof (state)\nthis:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "have q: \"q = [:0:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = [:0::'a:]", "using xq degree_0_id[OF degq,symmetric]"], ["proof (prove)\nusing this:\n  poly q x = (0::'a)\n  q = [:coeff q 0:]\n\ngoal (1 subgoal):\n 1. q = [:0::'a:]", "by (metis mpoly_base_conv(2))"], ["proof (state)\nthis:\n  q = [:0::'a:]\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "unfolding q"], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant p [:0::'a:] = (0::'a)", "using degq deg"], ["proof (prove)\nusing this:\n  degree q = 0\n  0 < degree p \\<or> 0 < degree q\n\ngoal (1 subgoal):\n 1. resultant p [:0::'a:] = (0::'a)", "by simp"], ["proof (state)\nthis:\n  resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "}"], ["proof (state)\nthis:\n  degree q = 0 \\<Longrightarrow> resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < degree p; 0 < degree q\\<rbrakk>\n  \\<Longrightarrow> resultant p q = (0::'a)\n  degree p = 0 \\<Longrightarrow> resultant p q = (0::'a)\n  degree q = 0 \\<Longrightarrow> resultant p q = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < degree p; 0 < degree q\\<rbrakk>\n  \\<Longrightarrow> resultant p q = (0::'a)\n  degree p = 0 \\<Longrightarrow> resultant p q = (0::'a)\n  degree q = 0 \\<Longrightarrow> resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a)", "by auto"], ["proof (state)\nthis:\n  resultant p q = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_resultant_zero:\n  fixes p q :: \"'a :: comm_ring_1 poly poly\"\n  assumes deg: \"degree p > 0 \\<or> degree q > 0\"\n  assumes p0: \"poly2 p x y = 0\" and q0: \"poly2 q x y = 0\"\n  shows \"poly (resultant p q) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "assume \"degree p > 0\" \"degree q > 0\""], ["proof (state)\nthis:\n  0 < degree p\n  0 < degree q\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "from resultant_as_poly[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>p' q'.\n     degree p' < degree q \\<and>\n     degree q' < degree p \\<and> [:resultant p q:] = p' * p + q' * q", "obtain p' q' where \"[: resultant p q :] = p' * p + q' * q\""], ["proof (prove)\nusing this:\n  \\<exists>p' q'.\n     degree p' < degree q \\<and>\n     degree q' < degree p \\<and> [:resultant p q:] = p' * p + q' * q\n\ngoal (1 subgoal):\n 1. (\\<And>p' q'.\n        [:resultant p q:] = p' * p + q' * q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  [:resultant p q:] = p' * p + q' * q\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "hence \"resultant p q = poly (p' * p + q' * q) [:y:]\""], ["proof (prove)\nusing this:\n  [:resultant p q:] = p' * p + q' * q\n\ngoal (1 subgoal):\n 1. resultant p q = poly (p' * p + q' * q) [:y:]", "using mpoly_base_conv(2)[of \"resultant p q\"]"], ["proof (prove)\nusing this:\n  [:resultant p q:] = p' * p + q' * q\n  resultant p q = poly [:resultant p q:] ?x\n\ngoal (1 subgoal):\n 1. resultant p q = poly (p' * p + q' * q) [:y:]", "by auto"], ["proof (state)\nthis:\n  resultant p q = poly (p' * p + q' * q) [:y:]\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "also"], ["proof (state)\nthis:\n  resultant p q = poly (p' * p + q' * q) [:y:]\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "have \"poly ... x = poly2 p x y * poly2 p' x y + poly2 q x y * poly2 q' x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly (p' * p + q' * q) [:y:]) x =\n    poly2 p x y * poly2 p' x y + poly2 q x y * poly2 q' x y", "unfolding poly2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly (p' * p + q' * q) [:y:]) x =\n    poly (poly p [:y:]) x * poly (poly p' [:y:]) x +\n    poly (poly q [:y:]) x * poly (poly q' [:y:]) x", "by simp"], ["proof (state)\nthis:\n  poly (poly (p' * p + q' * q) [:y:]) x =\n  poly2 p x y * poly2 p' x y + poly2 q x y * poly2 q' x y\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  poly (resultant p q) x =\n  poly2 p x y * poly2 p' x y + poly2 q x y * poly2 q' x y", "have ?thesis"], ["proof (prove)\nusing this:\n  poly (resultant p q) x =\n  poly2 p x y * poly2 p' x y + poly2 q x y * poly2 q' x y\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "unfolding p0 q0"], ["proof (prove)\nusing this:\n  poly (resultant p q) x = (0::'a) * poly2 p' x y + (0::'a) * poly2 q' x y\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "by simp"], ["proof (state)\nthis:\n  poly (resultant p q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < degree p; 0 < degree q\\<rbrakk>\n  \\<Longrightarrow> poly (resultant p q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < degree p; 0 < degree q\\<rbrakk>\n  \\<Longrightarrow> poly (resultant p q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>0 < degree p; 0 < degree q\\<rbrakk>\n  \\<Longrightarrow> poly (resultant p q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "assume degp: \"degree p = 0\""], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "hence p: \"p = [: coeff p 0 :]\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. p = [:coeff p 0:]", "by(subst degree_0_id[OF degp,symmetric],simp)"], ["proof (state)\nthis:\n  p = [:coeff p 0:]\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "hence \"resultant p q = coeff p 0 ^ degree q\""], ["proof (prove)\nusing this:\n  p = [:coeff p 0:]\n\ngoal (1 subgoal):\n 1. resultant p q = coeff p 0 ^ degree q", "using resultant_const(1)"], ["proof (prove)\nusing this:\n  p = [:coeff p 0:]\n  resultant [:?a:] ?q = ?a ^ degree ?q\n\ngoal (1 subgoal):\n 1. resultant p q = coeff p 0 ^ degree q", "by metis"], ["proof (state)\nthis:\n  resultant p q = coeff p 0 ^ degree q\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "also"], ["proof (state)\nthis:\n  resultant p q = coeff p 0 ^ degree q\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "have \"poly ... x = poly (coeff p 0) x ^ degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (coeff p 0 ^ degree q) x = poly (coeff p 0) x ^ degree q", "by auto"], ["proof (state)\nthis:\n  poly (coeff p 0 ^ degree q) x = poly (coeff p 0) x ^ degree q\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "also"], ["proof (state)\nthis:\n  poly (coeff p 0 ^ degree q) x = poly (coeff p 0) x ^ degree q\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "have \"... = poly2 p x y ^ degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (coeff p 0) x ^ degree q = poly2 p x y ^ degree q", "unfolding poly2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (coeff p 0) x ^ degree q = poly (poly p [:y:]) x ^ degree q", "by(subst p, auto)"], ["proof (state)\nthis:\n  poly (coeff p 0) x ^ degree q = poly2 p x y ^ degree q\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  poly (resultant p q) x = poly2 p x y ^ degree q", "have ?thesis"], ["proof (prove)\nusing this:\n  poly (resultant p q) x = poly2 p x y ^ degree q\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "unfolding p0"], ["proof (prove)\nusing this:\n  poly (resultant p q) x = (0::'a) ^ degree q\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "using deg degp zero_power"], ["proof (prove)\nusing this:\n  poly (resultant p q) x = (0::'a) ^ degree q\n  0 < degree p \\<or> 0 < degree q\n  degree p = 0\n  0 < ?n \\<Longrightarrow> (0::?'a) ^ ?n = (0::?'a)\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  poly (resultant p q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "}"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow> poly (resultant p q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "moreover"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow> poly (resultant p q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "{"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow> poly (resultant p q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "assume degq: \"degree q = 0\""], ["proof (state)\nthis:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "hence q: \"q = [: coeff q 0 :]\""], ["proof (prove)\nusing this:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. q = [:coeff q 0:]", "by(subst degree_0_id[OF degq,symmetric],simp)"], ["proof (state)\nthis:\n  q = [:coeff q 0:]\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "hence \"resultant p q = coeff q 0 ^ degree p\""], ["proof (prove)\nusing this:\n  q = [:coeff q 0:]\n\ngoal (1 subgoal):\n 1. resultant p q = coeff q 0 ^ degree p", "using resultant_const(2)"], ["proof (prove)\nusing this:\n  q = [:coeff q 0:]\n  resultant ?p [:?a:] = ?a ^ degree ?p\n\ngoal (1 subgoal):\n 1. resultant p q = coeff q 0 ^ degree p", "by metis"], ["proof (state)\nthis:\n  resultant p q = coeff q 0 ^ degree p\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "also"], ["proof (state)\nthis:\n  resultant p q = coeff q 0 ^ degree p\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "have \"poly ... x = poly (coeff q 0) x ^ degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (coeff q 0 ^ degree p) x = poly (coeff q 0) x ^ degree p", "by auto"], ["proof (state)\nthis:\n  poly (coeff q 0 ^ degree p) x = poly (coeff q 0) x ^ degree p\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "also"], ["proof (state)\nthis:\n  poly (coeff q 0 ^ degree p) x = poly (coeff q 0) x ^ degree p\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "have \"... = poly2 q x y ^ degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (coeff q 0) x ^ degree p = poly2 q x y ^ degree p", "unfolding poly2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (coeff q 0) x ^ degree p = poly (poly q [:y:]) x ^ degree p", "by(subst q, auto)"], ["proof (state)\nthis:\n  poly (coeff q 0) x ^ degree p = poly2 q x y ^ degree p\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  poly (resultant p q) x = poly2 q x y ^ degree p", "have ?thesis"], ["proof (prove)\nusing this:\n  poly (resultant p q) x = poly2 q x y ^ degree p\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "unfolding q0"], ["proof (prove)\nusing this:\n  poly (resultant p q) x = (0::'a) ^ degree p\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "using deg degq zero_power"], ["proof (prove)\nusing this:\n  poly (resultant p q) x = (0::'a) ^ degree p\n  0 < degree p \\<or> 0 < degree q\n  degree q = 0\n  0 < ?n \\<Longrightarrow> (0::?'a) ^ ?n = (0::?'a)\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  poly (resultant p q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "}"], ["proof (state)\nthis:\n  degree q = 0 \\<Longrightarrow> poly (resultant p q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < degree p; 0 < degree q\\<rbrakk>\n  \\<Longrightarrow> poly (resultant p q) x = (0::'a)\n  degree p = 0 \\<Longrightarrow> poly (resultant p q) x = (0::'a)\n  degree q = 0 \\<Longrightarrow> poly (resultant p q) x = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < degree p; 0 < degree q\\<rbrakk>\n  \\<Longrightarrow> poly (resultant p q) x = (0::'a)\n  degree p = 0 \\<Longrightarrow> poly (resultant p q) x = (0::'a)\n  degree q = 0 \\<Longrightarrow> poly (resultant p q) x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (resultant p q) x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  poly (resultant p q) x = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resultant_as_nonzero_poly_weak:\n  fixes p q :: \"'a :: idom poly\"\n  assumes degp: \"degree p > 0\" and degq: \"degree q > 0\"\n      and r0: \"resultant p q \\<noteq> 0\"\n  shows \"\\<exists>p' q'. degree p' < degree q \\<and> degree q' < degree p \\<and>\n         [: resultant p q :] = p' * p + q' * q \\<and> p' \\<noteq> 0 \\<and> q' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p' q'.\n       degree p' < degree q \\<and>\n       degree q' < degree p \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p' q'.\n       degree p' < degree q \\<and>\n       degree q' < degree p \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "obtain p' q'\n    where deg: \"degree p' < degree q\" \"degree q' < degree p\"\n      and main: \"[: resultant p q :] = p' * p + q' * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p' q'.\n        \\<lbrakk>degree p' < degree q; degree q' < degree p;\n         [:resultant p q:] = p' * p + q' * q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using resultant_as_poly[OF degp degq]"], ["proof (prove)\nusing this:\n  \\<exists>p' q'.\n     degree p' < degree q \\<and>\n     degree q' < degree p \\<and> [:resultant p q:] = p' * p + q' * q\n\ngoal (1 subgoal):\n 1. (\\<And>p' q'.\n        \\<lbrakk>degree p' < degree q; degree q' < degree p;\n         [:resultant p q:] = p' * p + q' * q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  degree p' < degree q\n  degree q' < degree p\n  [:resultant p q:] = p' * p + q' * q\n\ngoal (1 subgoal):\n 1. \\<exists>p' q'.\n       degree p' < degree q \\<and>\n       degree q' < degree p \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "have p0: \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using degp"], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>p' q'.\n       degree p' < degree q \\<and>\n       degree q' < degree p \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "have q0: \"q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using degq"], ["proof (prove)\nusing this:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>p' q'.\n       degree p' < degree q \\<and>\n       degree q' < degree p \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p' q'.\n       degree p' < degree q \\<and>\n       degree q' < degree p \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "proof (intro exI conjI notI)"], ["proof (state)\ngoal (5 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q\n 4. ?p' = 0 \\<Longrightarrow> False\n 5. ?q'1 = 0 \\<Longrightarrow> False", "assume \"p' = 0\""], ["proof (state)\nthis:\n  p' = 0\n\ngoal (5 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q\n 4. ?p' = 0 \\<Longrightarrow> False\n 5. ?q'1 = 0 \\<Longrightarrow> False", "hence \"[: resultant p q :] = q' * q\""], ["proof (prove)\nusing this:\n  p' = 0\n\ngoal (1 subgoal):\n 1. [:resultant p q:] = q' * q", "using main"], ["proof (prove)\nusing this:\n  p' = 0\n  [:resultant p q:] = p' * p + q' * q\n\ngoal (1 subgoal):\n 1. [:resultant p q:] = q' * q", "by auto"], ["proof (state)\nthis:\n  [:resultant p q:] = q' * q\n\ngoal (5 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q\n 4. ?p' = 0 \\<Longrightarrow> False\n 5. ?q'1 = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  [:resultant p q:] = q' * q\n\ngoal (5 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q\n 4. ?p' = 0 \\<Longrightarrow> False\n 5. ?q'1 = 0 \\<Longrightarrow> False", "hence d0: \"0 = degree (q' * q)\""], ["proof (prove)\nusing this:\n  [:resultant p q:] = q' * q\n\ngoal (1 subgoal):\n 1. 0 = degree (q' * q)", "by (metis degree_pCons_0)"], ["proof (state)\nthis:\n  0 = degree (q' * q)\n\ngoal (5 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q\n 4. ?p' = 0 \\<Longrightarrow> False\n 5. ?q'1 = 0 \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  0 = degree (q' * q)\n\ngoal (5 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q\n 4. ?p' = 0 \\<Longrightarrow> False\n 5. ?q'1 = 0 \\<Longrightarrow> False", "assume \"q' \\<noteq> 0\""], ["proof (state)\nthis:\n  q' \\<noteq> 0\n\ngoal (5 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q\n 4. ?p' = 0 \\<Longrightarrow> False\n 5. ?q'1 = 0 \\<Longrightarrow> False", "hence \"degree (q' * q) = degree q' + degree q\""], ["proof (prove)\nusing this:\n  q' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (q' * q) = degree q' + degree q", "apply(rule degree_mult_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using q0"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree (q' * q) = degree q' + degree q\n\ngoal (5 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q\n 4. ?p' = 0 \\<Longrightarrow> False\n 5. ?q'1 = 0 \\<Longrightarrow> False", "hence False"], ["proof (prove)\nusing this:\n  degree (q' * q) = degree q' + degree q\n\ngoal (1 subgoal):\n 1. False", "using d0 degq"], ["proof (prove)\nusing this:\n  degree (q' * q) = degree q' + degree q\n  0 = degree (q' * q)\n  0 < degree q\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q\n 4. ?p' = 0 \\<Longrightarrow> False\n 5. ?q'1 = 0 \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  q' \\<noteq> 0 \\<Longrightarrow> False\n\ngoal (5 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q\n 4. ?p' = 0 \\<Longrightarrow> False\n 5. ?q'1 = 0 \\<Longrightarrow> False", "hence \"q' = 0\""], ["proof (prove)\nusing this:\n  q' \\<noteq> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. q' = 0", "by auto"], ["proof (state)\nthis:\n  q' = 0\n\ngoal (5 subgoals):\n 1. degree ?p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q\n 4. ?p' = 0 \\<Longrightarrow> False\n 5. ?q'1 = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  [:resultant p q:] = 0 * q", "show False"], ["proof (prove)\nusing this:\n  [:resultant p q:] = 0 * q\n\ngoal (1 subgoal):\n 1. False", "using r0"], ["proof (prove)\nusing this:\n  [:resultant p q:] = 0 * q\n  resultant p q \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. degree p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = p' * p + ?q'1 * q\n 4. ?q'1 = 0 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. degree p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = p' * p + ?q'1 * q\n 4. ?q'1 = 0 \\<Longrightarrow> False", "assume \"q' = 0\""], ["proof (state)\nthis:\n  q' = 0\n\ngoal (4 subgoals):\n 1. degree p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = p' * p + ?q'1 * q\n 4. ?q'1 = 0 \\<Longrightarrow> False", "hence \"[: resultant p q :] = p' * p\""], ["proof (prove)\nusing this:\n  q' = 0\n\ngoal (1 subgoal):\n 1. [:resultant p q:] = p' * p", "using main"], ["proof (prove)\nusing this:\n  q' = 0\n  [:resultant p q:] = p' * p + q' * q\n\ngoal (1 subgoal):\n 1. [:resultant p q:] = p' * p", "by auto"], ["proof (state)\nthis:\n  [:resultant p q:] = p' * p\n\ngoal (4 subgoals):\n 1. degree p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = p' * p + ?q'1 * q\n 4. ?q'1 = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  [:resultant p q:] = p' * p\n\ngoal (4 subgoals):\n 1. degree p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = p' * p + ?q'1 * q\n 4. ?q'1 = 0 \\<Longrightarrow> False", "hence d0: \"0 = degree (p' * p)\""], ["proof (prove)\nusing this:\n  [:resultant p q:] = p' * p\n\ngoal (1 subgoal):\n 1. 0 = degree (p' * p)", "by (metis degree_pCons_0)"], ["proof (state)\nthis:\n  0 = degree (p' * p)\n\ngoal (4 subgoals):\n 1. degree p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = p' * p + ?q'1 * q\n 4. ?q'1 = 0 \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  0 = degree (p' * p)\n\ngoal (4 subgoals):\n 1. degree p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = p' * p + ?q'1 * q\n 4. ?q'1 = 0 \\<Longrightarrow> False", "assume \"p' \\<noteq> 0\""], ["proof (state)\nthis:\n  p' \\<noteq> 0\n\ngoal (4 subgoals):\n 1. degree p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = p' * p + ?q'1 * q\n 4. ?q'1 = 0 \\<Longrightarrow> False", "hence \"degree (p' * p) = degree p' + degree p\""], ["proof (prove)\nusing this:\n  p' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (p' * p) = degree p' + degree p", "apply(rule degree_mult_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using p0"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree (p' * p) = degree p' + degree p\n\ngoal (4 subgoals):\n 1. degree p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = p' * p + ?q'1 * q\n 4. ?q'1 = 0 \\<Longrightarrow> False", "hence False"], ["proof (prove)\nusing this:\n  degree (p' * p) = degree p' + degree p\n\ngoal (1 subgoal):\n 1. False", "using d0 degp"], ["proof (prove)\nusing this:\n  degree (p' * p) = degree p' + degree p\n  0 = degree (p' * p)\n  0 < degree p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. degree p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = p' * p + ?q'1 * q\n 4. ?q'1 = 0 \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  p' \\<noteq> 0 \\<Longrightarrow> False\n\ngoal (4 subgoals):\n 1. degree p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = p' * p + ?q'1 * q\n 4. ?q'1 = 0 \\<Longrightarrow> False", "hence \"p' = 0\""], ["proof (prove)\nusing this:\n  p' \\<noteq> 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. p' = 0", "by auto"], ["proof (state)\nthis:\n  p' = 0\n\ngoal (4 subgoals):\n 1. degree p' < degree q\n 2. degree ?q'1 < degree p\n 3. [:resultant p q:] = p' * p + ?q'1 * q\n 4. ?q'1 = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  [:resultant p q:] = 0 * p", "show False"], ["proof (prove)\nusing this:\n  [:resultant p q:] = 0 * p\n\ngoal (1 subgoal):\n 1. False", "using r0"], ["proof (prove)\nusing this:\n  [:resultant p q:] = 0 * p\n  resultant p q \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. degree p' < degree q\n 2. degree q' < degree p\n 3. [:resultant p q:] = p' * p + q' * q", "qed fact+"], ["proof (state)\nthis:\n  \\<exists>p' q'.\n     degree p' < degree q \\<and>\n     degree q' < degree p \\<and>\n     [:resultant p q:] = p' * p + q' * q \\<and>\n     p' \\<noteq> 0 \\<and> q' \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Next lemma corresponds to Lemma 7.2.2 of the textbook \\<close>"], ["", "lemma resultant_as_nonzero_poly:\n  fixes p q :: \"'a :: idom poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes degp: \"m > 0\" and degq: \"n > 0\"\n  shows \"\\<exists>p' q'. degree p' < n \\<and> degree q' < m \\<and>\n         [: resultant p q :] = p' * p + q' * q \\<and> p' \\<noteq> 0 \\<and> q' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "proof (cases \"resultant p q = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. resultant p q = (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0\n 2. resultant p q \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "case False"], ["proof (state)\nthis:\n  resultant p q \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. resultant p q = (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0\n 2. resultant p q \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  resultant p q \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "using resultant_as_nonzero_poly_weak degp degq"], ["proof (prove)\nusing this:\n  resultant p q \\<noteq> (0::'a)\n  \\<lbrakk>0 < degree ?p; 0 < degree ?q;\n   resultant ?p ?q \\<noteq> (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p' q'.\n                       degree p' < degree ?q \\<and>\n                       degree q' < degree ?p \\<and>\n                       [:resultant ?p ?q:] = p' * ?p + q' * ?q \\<and>\n                       p' \\<noteq> 0 \\<and> q' \\<noteq> 0\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "unfolding m_def n_def"], ["proof (prove)\nusing this:\n  resultant p q \\<noteq> (0::'a)\n  \\<lbrakk>0 < degree ?p; 0 < degree ?q;\n   resultant ?p ?q \\<noteq> (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p' q'.\n                       degree p' < degree ?q \\<and>\n                       degree q' < degree ?p \\<and>\n                       [:resultant ?p ?q:] = p' * ?p + q' * ?q \\<and>\n                       p' \\<noteq> 0 \\<and> q' \\<noteq> 0\n  0 < degree p\n  0 < degree q\n\ngoal (1 subgoal):\n 1. \\<exists>p' q'.\n       degree p' < degree q \\<and>\n       degree q' < degree p \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>p' q'.\n     degree p' < n \\<and>\n     degree q' < m \\<and>\n     [:resultant p q:] = p' * p + q' * q \\<and>\n     p' \\<noteq> 0 \\<and> q' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. resultant p q = (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "case True"], ["proof (state)\nthis:\n  resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "define S where \"S = transpose_mat (sylvester_mat p q)\""], ["proof (state)\nthis:\n  S = (sylvester_mat p q)\\<^sup>T\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "have S: \"S \\<in> carrier_mat (m+n) (m+n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in> carrier_mat (m + n) (m + n)", "unfolding S_def m_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sylvester_mat p q)\\<^sup>T\n    \\<in> carrier_mat (degree p + degree q) (degree p + degree q)", "by auto"], ["proof (state)\nthis:\n  S \\<in> carrier_mat (m + n) (m + n)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "have \"det S = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det S = (0::'a)", "using True"], ["proof (prove)\nusing this:\n  resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. det S = (0::'a)", "unfolding resultant_def S_def"], ["proof (prove)\nusing this:\n  det (sylvester_mat p q) = (0::'a)\n\ngoal (1 subgoal):\n 1. det (sylvester_mat p q)\\<^sup>T = (0::'a)", "apply (subst det_transpose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. det (sylvester_mat p q) = (0::'a) \\<Longrightarrow>\n    sylvester_mat p q \\<in> carrier_mat ?n1 ?n1\n 2. det (sylvester_mat p q) = (0::'a) \\<Longrightarrow>\n    det (sylvester_mat p q) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  det S = (0::'a)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  det S = (0::'a)", "obtain v\n    where v: \"v \\<in> carrier_vec (m+n)\" and v0: \"v \\<noteq> 0\\<^sub>v (m+n)\" and \"S *\\<^sub>v v = 0\\<^sub>v (m+n)\""], ["proof (prove)\nusing this:\n  det S = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> carrier_vec (m + n); v \\<noteq> 0\\<^sub>v (m + n);\n         S *\\<^sub>v v = 0\\<^sub>v (m + n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using det_0_iff_vec_prod_zero[OF S]"], ["proof (prove)\nusing this:\n  det S = (0::'a)\n  (det S = (0::'a)) =\n  (\\<exists>v.\n      v \\<in> carrier_vec (m + n) \\<and>\n      v \\<noteq> 0\\<^sub>v (m + n) \\<and> S *\\<^sub>v v = 0\\<^sub>v (m + n))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> carrier_vec (m + n); v \\<noteq> 0\\<^sub>v (m + n);\n         S *\\<^sub>v v = 0\\<^sub>v (m + n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> carrier_vec (m + n)\n  v \\<noteq> 0\\<^sub>v (m + n)\n  S *\\<^sub>v v = 0\\<^sub>v (m + n)\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "hence \"poly_of_vec (S *\\<^sub>v v) = 0\""], ["proof (prove)\nusing this:\n  v \\<in> carrier_vec (m + n)\n  v \\<noteq> 0\\<^sub>v (m + n)\n  S *\\<^sub>v v = 0\\<^sub>v (m + n)\n\ngoal (1 subgoal):\n 1. poly_of_vec (S *\\<^sub>v v) = 0", "by auto"], ["proof (state)\nthis:\n  poly_of_vec (S *\\<^sub>v v) = 0\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "hence main: \"poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q = 0\"\n    (is \"?p * _ + ?q * _ = _\")"], ["proof (prove)\nusing this:\n  poly_of_vec (S *\\<^sub>v v) = 0\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q = 0", "using sylvester_vec_poly[OF v[unfolded m_def n_def], folded m_def n_def S_def]"], ["proof (prove)\nusing this:\n  poly_of_vec (S *\\<^sub>v v) = 0\n  poly_of_vec (S *\\<^sub>v v) =\n  poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q = 0", "by auto"], ["proof (state)\nthis:\n  poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q = 0\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "have split: \"vec_first v n @\\<^sub>v vec_last v m = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_first v n @\\<^sub>v vec_last v m = v", "using vec_first_last_append[simplified add.commute] v"], ["proof (prove)\nusing this:\n  ?v \\<in> carrier_vec (?m + ?n) \\<Longrightarrow>\n  vec_first ?v ?n @\\<^sub>v vec_last ?v ?m = ?v\n  v \\<in> carrier_vec (m + n)\n\ngoal (1 subgoal):\n 1. vec_first v n @\\<^sub>v vec_last v m = v", "by auto"], ["proof (state)\nthis:\n  vec_first v n @\\<^sub>v vec_last v m = v\n\ngoal (1 subgoal):\n 1. resultant p q = (0::'a) \\<Longrightarrow>\n    \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p' q'.\n       degree p' < n \\<and>\n       degree q' < m \\<and>\n       [:resultant p q:] = p' * p + q' * q \\<and>\n       p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "proof(intro exI conjI)"], ["proof (state)\ngoal (5 subgoals):\n 1. degree ?p' < n\n 2. degree ?q'1 < m\n 3. [:resultant p q:] = ?p' * p + ?q'1 * q\n 4. ?p' \\<noteq> 0\n 5. ?q'1 \\<noteq> 0", "show \"[: resultant p q :] = ?p * p + ?q * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:resultant p q:] =\n    poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0::'a:] =\n    poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q", "using main"], ["proof (prove)\nusing this:\n  poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q = 0\n\ngoal (1 subgoal):\n 1. [:0::'a:] =\n    poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q", "by auto"], ["proof (state)\nthis:\n  [:resultant p q:] =\n  poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q\n\ngoal (4 subgoals):\n 1. degree (poly_of_vec (vec_first v n)) < n\n 2. degree (poly_of_vec (vec_last v m)) < m\n 3. poly_of_vec (vec_first v n) \\<noteq> 0\n 4. poly_of_vec (vec_last v m) \\<noteq> 0", "show \"?p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) = 0 \\<Longrightarrow> False", "assume p'0: \"?p = 0\""], ["proof (state)\nthis:\n  poly_of_vec (vec_first v n) = 0\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) = 0 \\<Longrightarrow> False", "hence \"?q * q = 0\""], ["proof (prove)\nusing this:\n  poly_of_vec (vec_first v n) = 0\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_last v m) * q = 0", "using main"], ["proof (prove)\nusing this:\n  poly_of_vec (vec_first v n) = 0\n  poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q = 0\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_last v m) * q = 0", "by auto"], ["proof (state)\nthis:\n  poly_of_vec (vec_last v m) * q = 0\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) = 0 \\<Longrightarrow> False", "hence \"?q = 0\""], ["proof (prove)\nusing this:\n  poly_of_vec (vec_last v m) * q = 0\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_last v m) = 0", "using degq n_def"], ["proof (prove)\nusing this:\n  poly_of_vec (vec_last v m) * q = 0\n  0 < n\n  n \\<equiv> degree q\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_last v m) = 0", "by auto"], ["proof (state)\nthis:\n  poly_of_vec (vec_last v m) = 0\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) = 0 \\<Longrightarrow> False", "hence \"vec_last v m = 0\\<^sub>v m\""], ["proof (prove)\nusing this:\n  poly_of_vec (vec_last v m) = 0\n\ngoal (1 subgoal):\n 1. vec_last v m = 0\\<^sub>v m", "unfolding poly_of_vec_0_iff"], ["proof (prove)\nusing this:\n  vec_last v m = 0\\<^sub>v (dim_vec (vec_last v m))\n\ngoal (1 subgoal):\n 1. vec_last v m = 0\\<^sub>v m", "by auto"], ["proof (state)\nthis:\n  vec_last v m = 0\\<^sub>v m\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  vec_last v m = 0\\<^sub>v m\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) = 0 \\<Longrightarrow> False", "have \"vec_first v n @\\<^sub>v ... = 0\\<^sub>v (m+n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_first v n @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v (m + n)", "using p'0"], ["proof (prove)\nusing this:\n  poly_of_vec (vec_first v n) = 0\n\ngoal (1 subgoal):\n 1. vec_first v n @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v (m + n)", "unfolding poly_of_vec_0_iff"], ["proof (prove)\nusing this:\n  vec_first v n = 0\\<^sub>v (dim_vec (vec_first v n))\n\ngoal (1 subgoal):\n 1. vec_first v n @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v (m + n)", "by auto"], ["proof (state)\nthis:\n  vec_first v n @\\<^sub>v 0\\<^sub>v m = 0\\<^sub>v (m + n)\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  vec_first v n @\\<^sub>v vec_last v m = 0\\<^sub>v (m + n)", "have \"v = 0\\<^sub>v (m+n)\""], ["proof (prove)\nusing this:\n  vec_first v n @\\<^sub>v vec_last v m = 0\\<^sub>v (m + n)\n\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v (m + n)", "using split"], ["proof (prove)\nusing this:\n  vec_first v n @\\<^sub>v vec_last v m = 0\\<^sub>v (m + n)\n  vec_first v n @\\<^sub>v vec_last v m = v\n\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v (m + n)", "by auto"], ["proof (state)\nthis:\n  v = 0\\<^sub>v (m + n)\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) = 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v (m + n)\n\ngoal (1 subgoal):\n 1. False", "using v0"], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v (m + n)\n  v \\<noteq> 0\\<^sub>v (m + n)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_of_vec (vec_first v n) \\<noteq> 0\n\ngoal (3 subgoals):\n 1. degree (poly_of_vec (vec_first v n)) < n\n 2. degree (poly_of_vec (vec_last v m)) < m\n 3. poly_of_vec (vec_last v m) \\<noteq> 0", "show \"?q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_vec (vec_last v m) \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_of_vec (vec_last v m) = 0 \\<Longrightarrow> False", "assume q'0: \"?q = 0\""], ["proof (state)\nthis:\n  poly_of_vec (vec_last v m) = 0\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_last v m) = 0 \\<Longrightarrow> False", "hence \"?p * p = 0\""], ["proof (prove)\nusing this:\n  poly_of_vec (vec_last v m) = 0\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) * p = 0", "using main"], ["proof (prove)\nusing this:\n  poly_of_vec (vec_last v m) = 0\n  poly_of_vec (vec_first v n) * p + poly_of_vec (vec_last v m) * q = 0\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) * p = 0", "by auto"], ["proof (state)\nthis:\n  poly_of_vec (vec_first v n) * p = 0\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_last v m) = 0 \\<Longrightarrow> False", "hence \"?p = 0\""], ["proof (prove)\nusing this:\n  poly_of_vec (vec_first v n) * p = 0\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) = 0", "using degp m_def"], ["proof (prove)\nusing this:\n  poly_of_vec (vec_first v n) * p = 0\n  0 < m\n  m \\<equiv> degree p\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_first v n) = 0", "by auto"], ["proof (state)\nthis:\n  poly_of_vec (vec_first v n) = 0\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_last v m) = 0 \\<Longrightarrow> False", "hence \"vec_first v n = 0\\<^sub>v n\""], ["proof (prove)\nusing this:\n  poly_of_vec (vec_first v n) = 0\n\ngoal (1 subgoal):\n 1. vec_first v n = 0\\<^sub>v n", "unfolding poly_of_vec_0_iff"], ["proof (prove)\nusing this:\n  vec_first v n = 0\\<^sub>v (dim_vec (vec_first v n))\n\ngoal (1 subgoal):\n 1. vec_first v n = 0\\<^sub>v n", "by auto"], ["proof (state)\nthis:\n  vec_first v n = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_last v m) = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  vec_first v n = 0\\<^sub>v n\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_last v m) = 0 \\<Longrightarrow> False", "have \"... @\\<^sub>v vec_last v m = 0\\<^sub>v (m+n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v n @\\<^sub>v vec_last v m = 0\\<^sub>v (m + n)", "using q'0"], ["proof (prove)\nusing this:\n  poly_of_vec (vec_last v m) = 0\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n @\\<^sub>v vec_last v m = 0\\<^sub>v (m + n)", "unfolding poly_of_vec_0_iff"], ["proof (prove)\nusing this:\n  vec_last v m = 0\\<^sub>v (dim_vec (vec_last v m))\n\ngoal (1 subgoal):\n 1. 0\\<^sub>v n @\\<^sub>v vec_last v m = 0\\<^sub>v (m + n)", "by auto"], ["proof (state)\nthis:\n  0\\<^sub>v n @\\<^sub>v vec_last v m = 0\\<^sub>v (m + n)\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_last v m) = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  vec_first v n @\\<^sub>v vec_last v m = 0\\<^sub>v (m + n)", "have \"v = 0\\<^sub>v (m+n)\""], ["proof (prove)\nusing this:\n  vec_first v n @\\<^sub>v vec_last v m = 0\\<^sub>v (m + n)\n\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v (m + n)", "using split"], ["proof (prove)\nusing this:\n  vec_first v n @\\<^sub>v vec_last v m = 0\\<^sub>v (m + n)\n  vec_first v n @\\<^sub>v vec_last v m = v\n\ngoal (1 subgoal):\n 1. v = 0\\<^sub>v (m + n)", "by auto"], ["proof (state)\nthis:\n  v = 0\\<^sub>v (m + n)\n\ngoal (1 subgoal):\n 1. poly_of_vec (vec_last v m) = 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v (m + n)\n\ngoal (1 subgoal):\n 1. False", "using v0"], ["proof (prove)\nusing this:\n  v = 0\\<^sub>v (m + n)\n  v \\<noteq> 0\\<^sub>v (m + n)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_of_vec (vec_last v m) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree (poly_of_vec (vec_first v n)) < n\n 2. degree (poly_of_vec (vec_last v m)) < m", "show \"degree ?p < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_of_vec (vec_first v n)) < n", "using degree_poly_of_vec_less[of \"vec_first v n\"]"], ["proof (prove)\nusing this:\n  0 < dim_vec (vec_first v n) \\<Longrightarrow>\n  degree (poly_of_vec (vec_first v n)) < dim_vec (vec_first v n)\n\ngoal (1 subgoal):\n 1. degree (poly_of_vec (vec_first v n)) < n", "using degq"], ["proof (prove)\nusing this:\n  0 < dim_vec (vec_first v n) \\<Longrightarrow>\n  degree (poly_of_vec (vec_first v n)) < dim_vec (vec_first v n)\n  0 < n\n\ngoal (1 subgoal):\n 1. degree (poly_of_vec (vec_first v n)) < n", "by auto"], ["proof (state)\nthis:\n  degree (poly_of_vec (vec_first v n)) < n\n\ngoal (1 subgoal):\n 1. degree (poly_of_vec (vec_last v m)) < m", "show \"degree ?q < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_of_vec (vec_last v m)) < m", "using degree_poly_of_vec_less[of \"vec_last v m\"]"], ["proof (prove)\nusing this:\n  0 < dim_vec (vec_last v m) \\<Longrightarrow>\n  degree (poly_of_vec (vec_last v m)) < dim_vec (vec_last v m)\n\ngoal (1 subgoal):\n 1. degree (poly_of_vec (vec_last v m)) < m", "using degp"], ["proof (prove)\nusing this:\n  0 < dim_vec (vec_last v m) \\<Longrightarrow>\n  degree (poly_of_vec (vec_last v m)) < dim_vec (vec_last v m)\n  0 < m\n\ngoal (1 subgoal):\n 1. degree (poly_of_vec (vec_last v m)) < m", "by auto"], ["proof (state)\nthis:\n  degree (poly_of_vec (vec_last v m)) < m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p' q'.\n     degree p' < n \\<and>\n     degree q' < m \\<and>\n     [:resultant p q:] = p' * p + q' * q \\<and>\n     p' \\<noteq> 0 \\<and> q' \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Corresponds to Lemma 7.2.3 of the textbook\\<close>"], ["", "lemma resultant_zero_imp_common_factor:\n  fixes p q :: \"'a :: ufd poly\"\n  assumes deg: \"degree p > 0 \\<or> degree q > 0\" and r0: \"resultant p q = 0\"\n  shows \"\\<not> coprime p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "unfolding neq0_conv[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "assume degp: \"degree p > 0\" and degq: \"degree q > 0\""], ["proof (state)\nthis:\n  0 < degree p\n  0 < degree q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "assume cop: \"coprime p q\""], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime p q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "obtain p' q' where \"p' * p + q' * q = 0\"\n      and p': \"degree p' < degree q\" and q': \"degree q' < degree p\"\n      and p'0: \"p' \\<noteq> 0\" and q'0: \"q' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p' q'.\n        \\<lbrakk>p' * p + q' * q = 0; degree p' < degree q;\n         degree q' < degree p; p' \\<noteq> 0; q' \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using resultant_as_nonzero_poly[OF degp degq] r0"], ["proof (prove)\nusing this:\n  \\<exists>p' q'.\n     degree p' < degree q \\<and>\n     degree q' < degree p \\<and>\n     [:resultant p q:] = p' * p + q' * q \\<and>\n     p' \\<noteq> 0 \\<and> q' \\<noteq> 0\n  resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>p' q'.\n        \\<lbrakk>p' * p + q' * q = 0; degree p' < degree q;\n         degree q' < degree p; p' \\<noteq> 0; q' \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p' * p + q' * q = 0\n  degree p' < degree q\n  degree q' < degree p\n  p' \\<noteq> 0\n  q' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "hence \"p' * p = - q' * q\""], ["proof (prove)\nusing this:\n  p' * p + q' * q = 0\n  degree p' < degree q\n  degree q' < degree p\n  p' \\<noteq> 0\n  q' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p' * p = - q' * q", "by (simp add: eq_neg_iff_add_eq_0)"], ["proof (state)\nthis:\n  p' * p = - q' * q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "from some_gcd.coprime_mult_cross_dvd[OF cop this]"], ["proof (chain)\npicking this:\n  p dvd - q'\n  q dvd p'", "have \"p dvd q'\""], ["proof (prove)\nusing this:\n  p dvd - q'\n  q dvd p'\n\ngoal (1 subgoal):\n 1. p dvd q'", "by auto"], ["proof (state)\nthis:\n  p dvd q'\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "from dvd_imp_degree_le[OF this q'0]"], ["proof (chain)\npicking this:\n  degree p \\<le> degree q'", "have \"degree p \\<le> degree q'\""], ["proof (prove)\nusing this:\n  degree p \\<le> degree q'\n\ngoal (1 subgoal):\n 1. degree p \\<le> degree q'", "by auto"], ["proof (state)\nthis:\n  degree p \\<le> degree q'\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "hence False"], ["proof (prove)\nusing this:\n  degree p \\<le> degree q'\n\ngoal (1 subgoal):\n 1. False", "using q'"], ["proof (prove)\nusing this:\n  degree p \\<le> degree q'\n  degree q' < degree p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < degree p; 0 < degree q;\n   comm_monoid_mult_class.coprime p q\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < degree p; 0 < degree q;\n   comm_monoid_mult_class.coprime p q\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "{"], ["proof (state)\nthis:\n  \\<lbrakk>0 < degree p; 0 < degree q;\n   comm_monoid_mult_class.coprime p q\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "assume degp: \"degree p = 0\""], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "then"], ["proof (chain)\npicking this:\n  degree p = 0", "obtain x where \"p = [:x:]\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x. p = [:x:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (elim degree_eq_zeroE)"], ["proof (state)\nthis:\n  p = [:x:]\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "moreover"], ["proof (state)\nthis:\n  p = [:x:]\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "hence \"resultant p q = x ^ degree q\""], ["proof (prove)\nusing this:\n  p = [:x:]\n\ngoal (1 subgoal):\n 1. resultant p q = x ^ degree q", "using resultant_const"], ["proof (prove)\nusing this:\n  p = [:x:]\n  resultant [:?a:] ?q = ?a ^ degree ?q\n  resultant ?p [:?a:] = ?a ^ degree ?p\n\ngoal (1 subgoal):\n 1. resultant p q = x ^ degree q", "by auto"], ["proof (state)\nthis:\n  resultant p q = x ^ degree q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "hence \"x = 0\""], ["proof (prove)\nusing this:\n  resultant p q = x ^ degree q\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "using r0"], ["proof (prove)\nusing this:\n  resultant p q = x ^ degree q\n  resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "ultimately"], ["proof (chain)\npicking this:\n  p = [:x:]\n  x = (0::'a)", "have \"p = 0\""], ["proof (prove)\nusing this:\n  p = [:x:]\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. p = 0", "by auto"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "hence ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "unfolding not_coprime_iff_common_factor"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. \\<exists>r. r dvd p \\<and> r dvd q \\<and> \\<not> r dvd 1", "by (metis deg degp dvd_0_right dvd_refl less_numeral_extra(3) poly_dvd_1)"], ["proof (state)\nthis:\n  \\<not> comm_monoid_mult_class.coprime p q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "}"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow> \\<not> comm_monoid_mult_class.coprime p q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "moreover"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow> \\<not> comm_monoid_mult_class.coprime p q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "{"], ["proof (state)\nthis:\n  degree p = 0 \\<Longrightarrow> \\<not> comm_monoid_mult_class.coprime p q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "assume degq: \"degree q = 0\""], ["proof (state)\nthis:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "then"], ["proof (chain)\npicking this:\n  degree q = 0", "obtain x where \"q = [:x:]\""], ["proof (prove)\nusing this:\n  degree q = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x. q = [:x:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (elim degree_eq_zeroE)"], ["proof (state)\nthis:\n  q = [:x:]\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "moreover"], ["proof (state)\nthis:\n  q = [:x:]\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "hence \"resultant p q = x ^ degree p\""], ["proof (prove)\nusing this:\n  q = [:x:]\n\ngoal (1 subgoal):\n 1. resultant p q = x ^ degree p", "using resultant_const"], ["proof (prove)\nusing this:\n  q = [:x:]\n  resultant [:?a:] ?q = ?a ^ degree ?q\n  resultant ?p [:?a:] = ?a ^ degree ?p\n\ngoal (1 subgoal):\n 1. resultant p q = x ^ degree p", "by auto"], ["proof (state)\nthis:\n  resultant p q = x ^ degree p\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "hence \"x = 0\""], ["proof (prove)\nusing this:\n  resultant p q = x ^ degree p\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "using r0"], ["proof (prove)\nusing this:\n  resultant p q = x ^ degree p\n  resultant p q = (0::'a)\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "ultimately"], ["proof (chain)\npicking this:\n  q = [:x:]\n  x = (0::'a)", "have \"q = 0\""], ["proof (prove)\nusing this:\n  q = [:x:]\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. q = 0", "by auto"], ["proof (state)\nthis:\n  q = 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "hence ?thesis"], ["proof (prove)\nusing this:\n  q = 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "unfolding not_coprime_iff_common_factor"], ["proof (prove)\nusing this:\n  q = 0\n\ngoal (1 subgoal):\n 1. \\<exists>r. r dvd p \\<and> r dvd q \\<and> \\<not> r dvd 1", "by (metis deg degq dvd_0_right dvd_refl less_numeral_extra(3) poly_dvd_1)"], ["proof (state)\nthis:\n  \\<not> comm_monoid_mult_class.coprime p q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "}"], ["proof (state)\nthis:\n  degree q = 0 \\<Longrightarrow> \\<not> comm_monoid_mult_class.coprime p q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < degree p; 0 < degree q;\n   comm_monoid_mult_class.coprime p q\\<rbrakk>\n  \\<Longrightarrow> False\n  degree p = 0 \\<Longrightarrow> \\<not> comm_monoid_mult_class.coprime p q\n  degree q = 0 \\<Longrightarrow> \\<not> comm_monoid_mult_class.coprime p q", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < degree p; 0 < degree q;\n   comm_monoid_mult_class.coprime p q\\<rbrakk>\n  \\<Longrightarrow> False\n  degree p = 0 \\<Longrightarrow> \\<not> comm_monoid_mult_class.coprime p q\n  degree q = 0 \\<Longrightarrow> \\<not> comm_monoid_mult_class.coprime p q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime p q", "by auto"], ["proof (state)\nthis:\n  \\<not> comm_monoid_mult_class.coprime p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resultant_non_zero_imp_coprime:\n  assumes nz: \"resultant (f :: 'a :: field poly) g \\<noteq> 0\" \n  and nz': \"f \\<noteq> 0 \\<or> g \\<noteq> 0\" \nshows \"coprime f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "proof (cases \"degree f = 0 \\<or> degree g = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "case False"], ["proof (state)\nthis:\n  \\<not> (degree f = 0 \\<or> degree g = 0)\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "define r where \"r = [:resultant f g:]\""], ["proof (state)\nthis:\n  r = [:resultant f g:]\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "from nz"], ["proof (chain)\npicking this:\n  resultant f g \\<noteq> (0::'a)", "have r: \"r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  resultant f g \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "unfolding r_def"], ["proof (prove)\nusing this:\n  resultant f g \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. [:resultant f g:] \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "from False"], ["proof (chain)\npicking this:\n  \\<not> (degree f = 0 \\<or> degree g = 0)", "have \"degree f > 0\" \"degree g > 0\""], ["proof (prove)\nusing this:\n  \\<not> (degree f = 0 \\<or> degree g = 0)\n\ngoal (1 subgoal):\n 1. 0 < degree f &&& 0 < degree g", "by auto"], ["proof (state)\nthis:\n  0 < degree f\n  0 < degree g\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "from resultant_as_nonzero_poly_weak[OF this nz]"], ["proof (chain)\npicking this:\n  \\<exists>p' q'.\n     degree p' < degree g \\<and>\n     degree q' < degree f \\<and>\n     [:resultant f g:] = p' * f + q' * g \\<and>\n     p' \\<noteq> 0 \\<and> q' \\<noteq> 0", "obtain p q where \"degree p < degree g\" \"degree q < degree f\" \n    and id: \"r = p * f + q * g\"\n    and \"p \\<noteq> 0\" \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>p' q'.\n     degree p' < degree g \\<and>\n     degree q' < degree f \\<and>\n     [:resultant f g:] = p' * f + q' * g \\<and>\n     p' \\<noteq> 0 \\<and> q' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>degree p < degree g; degree q < degree f;\n         r = p * f + q * g; p \\<noteq> 0; q \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding r_def"], ["proof (prove)\nusing this:\n  \\<exists>p' q'.\n     degree p' < degree g \\<and>\n     degree q' < degree f \\<and>\n     [:resultant f g:] = p' * f + q' * g \\<and>\n     p' \\<noteq> 0 \\<and> q' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>degree p < degree g; degree q < degree f;\n         [:resultant f g:] = p * f + q * g; p \\<noteq> 0;\n         q \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  degree p < degree g\n  degree q < degree f\n  r = p * f + q * g\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "define h where \"h = some_gcd f g\""], ["proof (state)\nthis:\n  h = some_gcd f g\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "have \"h dvd f\" \"h dvd g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h dvd f &&& h dvd g", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. some_gcd f g dvd f &&& some_gcd f g dvd g", "by auto"], ["proof (state)\nthis:\n  h dvd f\n  h dvd g\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "then"], ["proof (chain)\npicking this:\n  h dvd f\n  h dvd g", "obtain j k where f: \"f = h * j\" and g: \"g = h * k\""], ["proof (prove)\nusing this:\n  h dvd f\n  h dvd g\n\ngoal (1 subgoal):\n 1. (\\<And>j k.\n        \\<lbrakk>f = h * j; g = h * k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. f = h * k\n  \\<exists>k. g = h * k\n\ngoal (1 subgoal):\n 1. (\\<And>j k.\n        \\<lbrakk>f = h * j; g = h * k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f = h * j\n  g = h * k\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "from id[unfolded f g]"], ["proof (chain)\npicking this:\n  r = p * (h * j) + q * (h * k)", "have id: \"h * (p * j + q * k) = r\""], ["proof (prove)\nusing this:\n  r = p * (h * j) + q * (h * k)\n\ngoal (1 subgoal):\n 1. h * (p * j + q * k) = r", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  h * (p * j + q * k) = r\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "from arg_cong[OF id, of degree]"], ["proof (chain)\npicking this:\n  degree (h * (p * j + q * k)) = degree r", "have \"degree (h * (p * j + q * k)) = 0\""], ["proof (prove)\nusing this:\n  degree (h * (p * j + q * k)) = degree r\n\ngoal (1 subgoal):\n 1. degree (h * (p * j + q * k)) = 0", "unfolding r_def"], ["proof (prove)\nusing this:\n  degree (h * (p * j + q * k)) = degree [:resultant f g:]\n\ngoal (1 subgoal):\n 1. degree (h * (p * j + q * k)) = 0", "by auto"], ["proof (state)\nthis:\n  degree (h * (p * j + q * k)) = 0\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "also"], ["proof (state)\nthis:\n  degree (h * (p * j + q * k)) = 0\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "have \"degree (h * (p * j + q * k)) = degree h + degree (p * j + q * k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (h * (p * j + q * k)) = degree h + degree (p * j + q * k)", "by (subst degree_mult_eq, insert id r, auto)"], ["proof (state)\nthis:\n  degree (h * (p * j + q * k)) = degree h + degree (p * j + q * k)\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "finally"], ["proof (chain)\npicking this:\n  degree h + degree (p * j + q * k) = 0", "have h: \"degree h = 0\" \"h \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree h + degree (p * j + q * k) = 0\n\ngoal (1 subgoal):\n 1. degree h = 0 &&& h \\<noteq> 0", "using r id"], ["proof (prove)\nusing this:\n  degree h + degree (p * j + q * k) = 0\n  r \\<noteq> 0\n  h * (p * j + q * k) = r\n\ngoal (1 subgoal):\n 1. degree h = 0 &&& h \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree h = 0\n  h \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g\n 2. \\<not> (degree f = 0 \\<or> degree g = 0) \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree h = 0\n  h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "unfolding h_def"], ["proof (prove)\nusing this:\n  degree (some_gcd f g) = 0\n  some_gcd f g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "using is_unit_iff_degree some_gcd.gcd_dvd_1"], ["proof (prove)\nusing this:\n  degree (some_gcd f g) = 0\n  some_gcd f g \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> is_unit ?p = (degree ?p = 0)\n  (some_gcd ?a ?b dvd (1::?'a)) = comm_monoid_mult_class.coprime ?a ?b\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "by blast"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f g\n\ngoal (1 subgoal):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "case True"], ["proof (state)\nthis:\n  degree f = 0 \\<or> degree g = 0\n\ngoal (1 subgoal):\n 1. degree f = 0 \\<or> degree g = 0 \\<Longrightarrow>\n    comm_monoid_mult_class.coprime f g", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree f = 0 \\<or> degree g = 0\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. degree f = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g\n 2. degree g = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "assume deg_g: \"degree g = 0\""], ["proof (state)\nthis:\n  degree g = 0\n\ngoal (2 subgoals):\n 1. degree f = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g\n 2. degree g = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "proof (cases \"g = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. g = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g\n 2. g \\<noteq> 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "case False"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (2 subgoals):\n 1. g = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g\n 2. g \\<noteq> 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "then"], ["proof (chain)\npicking this:\n  g \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "using divides_degree[of _ g, unfolded deg_g]"], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n  ?p dvd g \\<Longrightarrow> degree ?p \\<le> 0 \\<or> g = 0\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "by (simp add: is_unit_right_imp_coprime)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f g\n\ngoal (1 subgoal):\n 1. g = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. g = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "case g: True"], ["proof (state)\nthis:\n  g = 0\n\ngoal (1 subgoal):\n 1. g = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "then"], ["proof (chain)\npicking this:\n  g = 0", "have \"g = [:0:]\""], ["proof (prove)\nusing this:\n  g = 0\n\ngoal (1 subgoal):\n 1. g = [:0::'a:]", "by auto"], ["proof (state)\nthis:\n  g = [:0::'a:]\n\ngoal (1 subgoal):\n 1. g = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "from nz[unfolded this resultant_const]"], ["proof (chain)\npicking this:\n  (0::'a) ^ degree f \\<noteq> (0::'a)", "have \"degree f = 0\""], ["proof (prove)\nusing this:\n  (0::'a) ^ degree f \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree f = 0", "by auto"], ["proof (state)\nthis:\n  degree f = 0\n\ngoal (1 subgoal):\n 1. g = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "with nz'"], ["proof (chain)\npicking this:\n  f \\<noteq> 0 \\<or> g \\<noteq> 0\n  degree f = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<noteq> 0 \\<or> g \\<noteq> 0\n  degree f = 0\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "unfolding g"], ["proof (prove)\nusing this:\n  f \\<noteq> 0 \\<or> 0 \\<noteq> 0\n  degree f = 0\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f 0", "by auto"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f g\n\ngoal (1 subgoal):\n 1. degree f = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree f = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "assume deg_f: \"degree f = 0\""], ["proof (state)\nthis:\n  degree f = 0\n\ngoal (1 subgoal):\n 1. degree f = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "proof (cases \"f = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g\n 2. f \\<noteq> 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "case False"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g\n 2. f \\<noteq> 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "then"], ["proof (chain)\npicking this:\n  f \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "using divides_degree[of _ f, unfolded deg_f]"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  ?p dvd f \\<Longrightarrow> degree ?p \\<le> 0 \\<or> f = 0\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "by (simp add: is_unit_left_imp_coprime)"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f g\n\ngoal (1 subgoal):\n 1. f = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "case f: True"], ["proof (state)\nthis:\n  f = 0\n\ngoal (1 subgoal):\n 1. f = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "then"], ["proof (chain)\npicking this:\n  f = 0", "have \"f = [:0:]\""], ["proof (prove)\nusing this:\n  f = 0\n\ngoal (1 subgoal):\n 1. f = [:0::'a:]", "by auto"], ["proof (state)\nthis:\n  f = [:0::'a:]\n\ngoal (1 subgoal):\n 1. f = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "from nz[unfolded this resultant_const]"], ["proof (chain)\npicking this:\n  (0::'a) ^ degree g \\<noteq> (0::'a)", "have \"degree g = 0\""], ["proof (prove)\nusing this:\n  (0::'a) ^ degree g \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree g = 0", "by auto"], ["proof (state)\nthis:\n  degree g = 0\n\ngoal (1 subgoal):\n 1. f = 0 \\<Longrightarrow> comm_monoid_mult_class.coprime f g", "with nz'"], ["proof (chain)\npicking this:\n  f \\<noteq> 0 \\<or> g \\<noteq> 0\n  degree g = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<noteq> 0 \\<or> g \\<noteq> 0\n  degree g = 0\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime f g", "unfolding f"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0 \\<or> g \\<noteq> 0\n  degree g = 0\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime 0 g", "by auto"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime f g\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}