{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers/Compare_Complex.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers", "problem_names": ["lemma [code]:\n  \"gcds xs = fold gcd xs 0\"", "lemma [code]:\n  \"lcms xs = fold lcm xs 1\"", "lemma in_reals_code [code_unfold]:\n  \"x \\<in> \\<real> \\<longleftrightarrow> Im x = 0\"", "lemma is_norm_1[simp]: \"is_norm_1 x = (norm x = 1)\"", "lemma is_norm_le_1[simp]: \"is_norm_le_1 x = (norm x \\<le> 1)\""], "translations": [["", "lemma [code]:\n  \"gcds xs = fold gcd xs 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcds xs = fold gcd xs (0::'a)", "by (simp add: Gcd_fin.set_eq_fold)"], ["", "definition lcms :: \"'a::semiring_gcd list \\<Rightarrow> 'a\"\n  where [simp, code_abbrev]: \"lcms xs = lcm_list xs\""], ["", "lemma [code]:\n  \"lcms xs = fold lcm xs 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcms xs = fold lcm xs (1::'a)", "by (simp add: Lcm_fin.set_eq_fold)"], ["", "lemma in_reals_code [code_unfold]:\n  \"x \\<in> \\<real> \\<longleftrightarrow> Im x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> \\<real>) = (Im x = 0)", "by (fact complex_is_Real_iff)"], ["", "definition is_norm_1 :: \"complex \\<Rightarrow> bool\" where\n  \"is_norm_1 z = ((Re z)\\<^sup>2 + (Im z)\\<^sup>2 = 1)\""], ["", "lemma is_norm_1[simp]: \"is_norm_1 x = (norm x = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_norm_1 x = (cmod x = 1)", "unfolding is_norm_1_def norm_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Re x)\\<^sup>2 + (Im x)\\<^sup>2 = 1) =\n    (sqrt ((Re x)\\<^sup>2 + (Im x)\\<^sup>2) = 1)", "by simp"], ["", "definition is_norm_le_1 :: \"complex \\<Rightarrow> bool\" where\n  \"is_norm_le_1 z = ((Re z)\\<^sup>2 + (Im z)\\<^sup>2 \\<le> 1)\""], ["", "lemma is_norm_le_1[simp]: \"is_norm_le_1 x = (norm x \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_norm_le_1 x = (cmod x \\<le> 1)", "unfolding is_norm_le_1_def norm_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Re x)\\<^sup>2 + (Im x)\\<^sup>2 \\<le> 1) =\n    (sqrt ((Re x)\\<^sup>2 + (Im x)\\<^sup>2) \\<le> 1)", "by simp"], ["", "instantiation complex :: finite_UNIV\nbegin"], ["", "definition \"finite_UNIV = Phantom(complex) False\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(complex, finite_UNIV_class)", "by (intro_classes, unfold finite_UNIV_complex_def, simp add: infinite_UNIV_char_0)"], ["", "end"], ["", "instantiation complex :: compare\nbegin"], ["", "definition compare_complex :: \"complex \\<Rightarrow> complex \\<Rightarrow> order\" where\n  \"compare_complex x y = compare (Re x, Im x) (Re y, Im y)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(complex, compare_class)", "proof (intro_classes, unfold_locales; unfold compare_complex_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       invert_order (compare (Re x, Im x) (Re y, Im y)) =\n       compare (Re y, Im y) (Re x, Im x)\n 2. \\<And>x y.\n       compare (Re x, Im x) (Re y, Im y) = Eq \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>compare (Re x, Im x) (Re y, Im y) = Lt;\n        compare (Re y, Im y) (Re z, Im z) = Lt\\<rbrakk>\n       \\<Longrightarrow> compare (Re x, Im x) (Re z, Im z) = Lt", "fix x y z :: complex"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       invert_order (compare (Re x, Im x) (Re y, Im y)) =\n       compare (Re y, Im y) (Re x, Im x)\n 2. \\<And>x y.\n       compare (Re x, Im x) (Re y, Im y) = Eq \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>compare (Re x, Im x) (Re y, Im y) = Lt;\n        compare (Re y, Im y) (Re z, Im z) = Lt\\<rbrakk>\n       \\<Longrightarrow> compare (Re x, Im x) (Re z, Im z) = Lt", "let ?c = \"compare :: (real \\<times> real) comparator\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       invert_order (compare (Re x, Im x) (Re y, Im y)) =\n       compare (Re y, Im y) (Re x, Im x)\n 2. \\<And>x y.\n       compare (Re x, Im x) (Re y, Im y) = Eq \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>compare (Re x, Im x) (Re y, Im y) = Lt;\n        compare (Re y, Im y) (Re z, Im z) = Lt\\<rbrakk>\n       \\<Longrightarrow> compare (Re x, Im x) (Re z, Im z) = Lt", "interpret comparator ?c"], ["proof (prove)\ngoal (1 subgoal):\n 1. comparator compare", "by (rule comparator_compare)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       invert_order (compare (Re x, Im x) (Re y, Im y)) =\n       compare (Re y, Im y) (Re x, Im x)\n 2. \\<And>x y.\n       compare (Re x, Im x) (Re y, Im y) = Eq \\<Longrightarrow> x = y\n 3. \\<And>x y z.\n       \\<lbrakk>compare (Re x, Im x) (Re y, Im y) = Lt;\n        compare (Re y, Im y) (Re z, Im z) = Lt\\<rbrakk>\n       \\<Longrightarrow> compare (Re x, Im x) (Re z, Im z) = Lt", "show \"invert_order (?c (Re x, Im x) (Re y, Im y)) = ?c (Re y, Im y) (Re x, Im x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invert_order (compare (Re x, Im x) (Re y, Im y)) =\n    compare (Re y, Im y) (Re x, Im x)", "by (rule sym)"], ["proof (state)\nthis:\n  invert_order (compare (Re x, Im x) (Re y, Im y)) =\n  compare (Re y, Im y) (Re x, Im x)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       compare (Re x, Im x) (Re y, Im y) = Eq \\<Longrightarrow> x = y\n 2. \\<And>x y z.\n       \\<lbrakk>compare (Re x, Im x) (Re y, Im y) = Lt;\n        compare (Re y, Im y) (Re z, Im z) = Lt\\<rbrakk>\n       \\<Longrightarrow> compare (Re x, Im x) (Re z, Im z) = Lt", "{"], ["proof (state)\nthis:\n  invert_order (compare (Re x, Im x) (Re y, Im y)) =\n  compare (Re y, Im y) (Re x, Im x)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       compare (Re x, Im x) (Re y, Im y) = Eq \\<Longrightarrow> x = y\n 2. \\<And>x y z.\n       \\<lbrakk>compare (Re x, Im x) (Re y, Im y) = Lt;\n        compare (Re y, Im y) (Re z, Im z) = Lt\\<rbrakk>\n       \\<Longrightarrow> compare (Re x, Im x) (Re z, Im z) = Lt", "assume \"?c (Re x, Im x) (Re y, Im y) = Lt\"\n      \"?c (Re y, Im y) (Re z, Im z) = Lt\""], ["proof (state)\nthis:\n  compare (Re x, Im x) (Re y, Im y) = Lt\n  compare (Re y, Im y) (Re z, Im z) = Lt\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       compare (Re x, Im x) (Re y, Im y) = Eq \\<Longrightarrow> x = y\n 2. \\<And>x y z.\n       \\<lbrakk>compare (Re x, Im x) (Re y, Im y) = Lt;\n        compare (Re y, Im y) (Re z, Im z) = Lt\\<rbrakk>\n       \\<Longrightarrow> compare (Re x, Im x) (Re z, Im z) = Lt", "thus \"?c (Re x, Im x) (Re z, Im z) = Lt\""], ["proof (prove)\nusing this:\n  compare (Re x, Im x) (Re y, Im y) = Lt\n  compare (Re y, Im y) (Re z, Im z) = Lt\n\ngoal (1 subgoal):\n 1. compare (Re x, Im x) (Re z, Im z) = Lt", "by (rule trans)"], ["proof (state)\nthis:\n  compare (Re x, Im x) (Re z, Im z) = Lt\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       compare (Re x, Im x) (Re y, Im y) = Eq \\<Longrightarrow> x = y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>compare (Re x, Im x) (Re y, Im y) = Lt;\n   compare (Re y, Im y) (Re z, Im z) = Lt\\<rbrakk>\n  \\<Longrightarrow> compare (Re x, Im x) (Re z, Im z) = Lt\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       compare (Re x, Im x) (Re y, Im y) = Eq \\<Longrightarrow> x = y", "{"], ["proof (state)\nthis:\n  \\<lbrakk>compare (Re x, Im x) (Re y, Im y) = Lt;\n   compare (Re y, Im y) (Re z, Im z) = Lt\\<rbrakk>\n  \\<Longrightarrow> compare (Re x, Im x) (Re z, Im z) = Lt\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       compare (Re x, Im x) (Re y, Im y) = Eq \\<Longrightarrow> x = y", "assume \"?c (Re x, Im x) (Re y, Im y) = Eq\""], ["proof (state)\nthis:\n  compare (Re x, Im x) (Re y, Im y) = Eq\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       compare (Re x, Im x) (Re y, Im y) = Eq \\<Longrightarrow> x = y", "from weak_eq[OF this]"], ["proof (chain)\npicking this:\n  (Re x, Im x) = (Re y, Im y)", "show \"x = y\""], ["proof (prove)\nusing this:\n  (Re x, Im x) = (Re y, Im y)\n\ngoal (1 subgoal):\n 1. x = y", "unfolding complex_eq_iff"], ["proof (prove)\nusing this:\n  (Re x, Im x) = (Re y, Im y)\n\ngoal (1 subgoal):\n 1. Re x = Re y \\<and> Im x = Im y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  compare (Re x, Im x) (Re y, Im y) = Eq \\<Longrightarrow> x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "derive (eq) ceq complex real"], ["", "derive (compare) ccompare complex"], ["", "derive (compare) ccompare real"], ["", "derive (dlist) set_impl complex real"], ["", "end"]]}