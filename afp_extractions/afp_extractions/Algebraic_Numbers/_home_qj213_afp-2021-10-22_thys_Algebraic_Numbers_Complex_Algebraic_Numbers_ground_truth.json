{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers/Complex_Algebraic_Numbers.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers", "problem_names": ["lemma poly_complex_to_real: \"(poly (complex_of_int_poly p) (complex_of_real x) = 0)\n  = (poly (real_of_int_poly p) x = 0)\"", "lemma represents_cnj: assumes \"p represents x\" shows \"p represents (cnj x)\"", "lemma represents_2i: \"poly_2i represents (2 * \\<i>)\"", "lemma root_poly_Re_code[code]: \n  \"root_poly_Re p = (let fs = coeffs (poly_add p p); k = length fs \n     in cf_pos_poly (poly_of_list (map (\\<lambda>(fi, i). fi * 2 ^ i) (zip fs [0..<k]))))\"", "lemma represents_root_poly:\n  assumes \"ipoly p x = 0\" and p: \"p \\<noteq> 0\"\n  shows \"(root_poly_Re p) represents (Re x)\"\n    and \"\\<exists> q \\<in> set (root_poly_Im p). q represents (Im x)\"", "lemma real_of_3_remdups_equal_3[simp]: \"real_of_3 ` set (remdups_gen equal_3 xs) = real_of_3 ` set xs\"", "lemma distinct_remdups_equal_3: \"distinct (map real_of_3 (remdups_gen equal_3 xs))\"", "lemma real_of_3_code [code]: \"real_of_3 x = real_of (Real_Alg_Quotient x)\"", "lemma real_parts_3: assumes p: \"p \\<noteq> 0\" and \"ipoly p x = 0\" \n  shows \"Re x \\<in> real_of_3 ` set (real_parts_3 p)\"", "lemma distinct_real_parts_3: \"distinct (map real_of_3 (real_parts_3 p))\"", "lemma pos_imaginary_parts_3: assumes p: \"p \\<noteq> 0\" and \"ipoly p x = 0\" and \"Im x > 0\" \n  shows \"Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)\"", "lemma distinct_pos_imaginary_parts_3: \"distinct (map real_of_3 (pos_imaginary_parts_3 p))\"", "lemma remdups_gen_subset: \"set (remdups_gen eq xs) \\<subseteq> set xs\"", "lemma positive_pos_imaginary_parts_3: assumes \"x \\<in> set (pos_imaginary_parts_3 p)\"\n  shows \"0 < real_of_3 x\"", "lemma get_bounds_2: assumes \"invariant_2 x\"\n  shows \"real_of_2 x \\<in>\\<^sub>i get_itvl_2 x\"", "lemma get_itvl_3: \"real_of_3 x \\<in>\\<^sub>i get_itvl_3 x\"", "lemma tighten_bounds_2: assumes inv: \"invariant_2 x\" \n  shows \"real_of_2 (tighten_bounds_2 x) = real_of_2 x\" \"invariant_2 (tighten_bounds_2 x)\" \n  \"get_itvl_2 x = Interval l r \\<Longrightarrow>\n   get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<Longrightarrow> r' - l' = (r-l) / 2\"", "lemma tighten_bounds_3:  \n  \"real_of_3 (tighten_bounds_3 x) = real_of_3 x\"  \n  \"get_itvl_3 x = Interval l r \\<Longrightarrow>\n   get_itvl_3 (tighten_bounds_3 x) = Interval l' r' \\<Longrightarrow> r' - l' = (r-l) / 2\"", "lemma filter_list_length: assumes \"length (filter P xs) = n\"\n  and \"\\<And> i x. x \\<in> set xs \\<Longrightarrow> P x \\<Longrightarrow> p ((f ^^ i) x)\" \n  and \"\\<And> x. x \\<in> set xs \\<Longrightarrow> \\<not> P x \\<Longrightarrow> \\<exists> i. \\<not> p ((f ^^ i) x)\" \n  and g: \"\\<And> x. g (f x) = g x\"\n  and P: \"\\<And> x. P (f x) = P x\" \nshows \"map g (filter_list_length f p n xs) = map g (filter P xs)\"", "lemma in_real_itvl_get_bounds_tighten: \"real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ n) x)\"", "lemma sandwitch_real:\n fixes l r :: \"nat \\<Rightarrow> real\"\n assumes la: \"l \\<longlonglongrightarrow> a\" and ra: \"r \\<longlonglongrightarrow> a\"\n and lm: \"\\<And>i. l i \\<le> m i\" and mr: \"\\<And>i. m i \\<le> r i\"\nshows \"m \\<longlonglongrightarrow> a\"", "lemma real_of_tighten_bounds_many[simp]: \"real_of_3 ((tighten_bounds_3 ^^ i) x) = real_of_3 x\"", "lemma interval_size_3: \"upper_3 x i - lower_3 x i = (upper_3 x 0 - lower_3 x 0)/2^i\"", "lemma interval_size_3_tendsto_0: \"(\\<lambda>i. (upper_3 x i - lower_3 x i)) \\<longlonglongrightarrow> 0\"", "lemma dist_tendsto_0_imp_tendsto: \"(\\<lambda>i. \\<bar>f i - a\\<bar> :: real) \\<longlonglongrightarrow> 0 \\<Longrightarrow> f \\<longlonglongrightarrow> a\"", "lemma upper_3_tendsto: \"upper_3 x \\<longlonglongrightarrow> real_of_3 x\"", "lemma lower_3_tendsto: \"lower_3 x \\<longlonglongrightarrow> real_of_3 x\"", "lemma tends_to_tight_bounds_3: \"(\\<lambda>x. get_itvl_3 ((tighten_bounds_3 ^^ x) y)) \\<longlonglongrightarrow>\\<^sub>i real_of_3 y\"", "lemma complex_roots_of_int_poly3: assumes p: \"p \\<noteq> 0\" and sf: \"square_free p\" \n  shows \"set (complex_roots_of_int_poly3 p) = {x. ipoly p x = 0}\" (is \"?l = ?r\")\n    \"distinct (complex_roots_of_int_poly3 p)\"", "lemma complex_roots_of_int_poly_all: assumes sf: \"degree p \\<ge> 3 \\<Longrightarrow> square_free p\" \n  shows \"p \\<noteq> 0 \\<Longrightarrow> set (complex_roots_of_int_poly_all p) = {x. ipoly p x = 0}\" (is \"_ \\<Longrightarrow> set ?l = ?r\")\n    and \"distinct (complex_roots_of_int_poly_all p)\"", "lemma complex_roots_of_int_poly:\n  shows \"p \\<noteq> 0 \\<Longrightarrow> set (complex_roots_of_int_poly p) = {x. ipoly p x = 0}\" (is \"_ \\<Longrightarrow> ?l = ?r\")\n  and \"distinct (complex_roots_of_int_poly p)\"", "lemma complex_roots_of_rat_poly: \n  \"p \\<noteq> 0 \\<Longrightarrow> set (complex_roots_of_rat_poly p) = {x. rpoly p x = 0}\" (is \"_ \\<Longrightarrow> ?l = ?r\")\n  \"distinct (complex_roots_of_rat_poly p)\"", "lemma roots_of_complex_main: assumes p: \"p \\<noteq> 0\" and deg: \"degree p \\<le> 2 \\<or> set (coeffs p) \\<subseteq> \\<rat>\"\n  shows \"set (roots_of_complex_main p) = {x. poly p x = 0}\" (is \"set ?l = ?r\")\n    and \"distinct (roots_of_complex_main p)\"", "lemma roots_of_complex_poly: assumes rt: \"roots_of_complex_poly p = Some xs\"\n  shows \"set xs = {x. poly p x = 0}\"", "lemma factorize_complex_main: assumes rt: \"factorize_complex_main p = Some (c,xis)\"\n  shows \"p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)\"", "lemma distinct_factorize_complex_main:\n  assumes \"factorize_complex_main p = Some fctrs\"\n  shows   \"distinct (map fst (snd fctrs))\"", "lemma factorize_complex_poly: assumes fp: \"factorize_complex_poly p = Some (c,qis)\"\n  shows \n  \"p = smult c (\\<Prod>(q, i)\\<leftarrow>qis. q ^ i)\" \n  \"(q,i) \\<in> set qis \\<Longrightarrow> irreducible q \\<and> i \\<noteq> 0 \\<and> monic q \\<and> degree q = 1\""], "translations": [["", "lemma poly_complex_to_real: \"(poly (complex_of_int_poly p) (complex_of_real x) = 0)\n  = (poly (real_of_int_poly p) x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (complex_of_int_poly p) (complex_of_real x) = 0) =\n    (poly (real_of_int_poly p) x = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly (complex_of_int_poly p) (complex_of_real x) = 0) =\n    (poly (real_of_int_poly p) x = 0)", "have id: \"of_int = complex_of_real o real_of_int\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_int = complex_of_real \\<circ> real_of_int", "by auto"], ["proof (state)\nthis:\n  complex_of_int = complex_of_real \\<circ> real_of_int\n\ngoal (1 subgoal):\n 1. (poly (complex_of_int_poly p) (complex_of_real x) = 0) =\n    (poly (real_of_int_poly p) x = 0)", "interpret cr: semiring_hom complex_of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring_hom complex_of_real", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly (complex_of_int_poly p) (complex_of_real x) = 0) =\n    (poly (real_of_int_poly p) x = 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (complex_of_int_poly p) (complex_of_real x) = 0) =\n    (poly (real_of_int_poly p) x = 0)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (map_poly (complex_of_real \\<circ> real_of_int) p)\n      (complex_of_real x) =\n     0) =\n    (poly (real_of_int_poly p) x = 0)", "by (subst map_poly_map_poly[symmetric], force+)"], ["proof (state)\nthis:\n  (poly (complex_of_int_poly p) (complex_of_real x) = 0) =\n  (poly (real_of_int_poly p) x = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represents_cnj: assumes \"p represents x\" shows \"p represents (cnj x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p represents cnj x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p represents cnj x", "from assms"], ["proof (chain)\npicking this:\n  p represents x", "have p: \"p \\<noteq> 0\" and \"ipoly p x = 0\""], ["proof (prove)\nusing this:\n  p represents x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& poly (complex_of_int_poly p) x = 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  poly (complex_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. p represents cnj x", "hence rt: \"poly (complex_of_int_poly p) x = 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly (complex_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. poly (complex_of_int_poly p) x = 0", "by auto"], ["proof (state)\nthis:\n  poly (complex_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. p represents cnj x", "have \"poly (complex_of_int_poly p) (cnj x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (complex_of_int_poly p) (cnj x) = 0", "by (rule complex_conjugate_root[OF _ rt], subst coeffs_map_poly, auto)"], ["proof (state)\nthis:\n  poly (complex_of_int_poly p) (cnj x) = 0\n\ngoal (1 subgoal):\n 1. p represents cnj x", "with p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  poly (complex_of_int_poly p) (cnj x) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly (complex_of_int_poly p) (cnj x) = 0\n\ngoal (1 subgoal):\n 1. p represents cnj x", "by auto"], ["proof (state)\nthis:\n  p represents cnj x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition poly_2i :: \"int poly\" where\n  \"poly_2i \\<equiv> [: 4, 0, 1:]\""], ["", "lemma represents_2i: \"poly_2i represents (2 * \\<i>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_2i represents 2 * \\<i>", "unfolding represents_def poly_2i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (complex_of_int_poly [:4, 0, 1:]) (2 * \\<i>) = 0 \\<and>\n    [:4, 0, 1:] \\<noteq> 0", "by simp"], ["", "definition root_poly_Re :: \"int poly \\<Rightarrow> int poly\" where\n  \"root_poly_Re p = cf_pos_poly (poly_mult_rat (inverse 2) (poly_add p p))\""], ["", "lemma root_poly_Re_code[code]: \n  \"root_poly_Re p = (let fs = coeffs (poly_add p p); k = length fs \n     in cf_pos_poly (poly_of_list (map (\\<lambda>(fi, i). fi * 2 ^ i) (zip fs [0..<k]))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_poly_Re p =\n    (let fs = coeffs (poly_add p p); k = length fs\n     in cf_pos_poly\n         (poly_of_list (map2 (\\<lambda>fi i. fi * 2 ^ i) fs [0..<k])))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. root_poly_Re p =\n    (let fs = coeffs (poly_add p p); k = length fs\n     in cf_pos_poly\n         (poly_of_list (map2 (\\<lambda>fi i. fi * 2 ^ i) fs [0..<k])))", "have [simp]: \"quotient_of (1 / 2) = (1,2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quotient_of (1 / 2) = (1, 2)", "by eval"], ["proof (state)\nthis:\n  quotient_of (1 / 2) = (1, 2)\n\ngoal (1 subgoal):\n 1. root_poly_Re p =\n    (let fs = coeffs (poly_add p p); k = length fs\n     in cf_pos_poly\n         (poly_of_list (map2 (\\<lambda>fi i. fi * 2 ^ i) fs [0..<k])))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_poly_Re p =\n    (let fs = coeffs (poly_add p p); k = length fs\n     in cf_pos_poly\n         (poly_of_list (map2 (\\<lambda>fi i. fi * 2 ^ i) fs [0..<k])))", "unfolding root_poly_Re_def poly_mult_rat_def poly_mult_rat_main_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cf_pos_poly\n     (case quotient_of (inverse 2) of\n      (n, d) \\<Rightarrow>\n        poly_of_list\n         (map2\n           (\\<lambda>fi i.\n               fi * d ^ i * n ^ (length (coeffs (poly_add p p)) - Suc i))\n           (coeffs (poly_add p p)) [0..<length (coeffs (poly_add p p))])) =\n    cf_pos_poly\n     (poly_of_list\n       (map2 (\\<lambda>fi i. fi * 2 ^ i) (coeffs (poly_add p p))\n         [0..<length (coeffs (poly_add p p))]))", "by simp"], ["proof (state)\nthis:\n  root_poly_Re p =\n  (let fs = coeffs (poly_add p p); k = length fs\n   in cf_pos_poly\n       (poly_of_list (map2 (\\<lambda>fi i. fi * 2 ^ i) fs [0..<k])))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition root_poly_Im :: \"int poly \\<Rightarrow> int poly list\" where\n  \"root_poly_Im p = (let fs = factors_of_int_poly \n    (poly_add p (poly_uminus p))\n    in remdups ((if (\\<exists> f \\<in> set fs. coeff f 0 = 0) then [[:0,1:]] else [])) @ \n      [ cf_pos_poly (poly_div f poly_2i) . f \\<leftarrow> fs, coeff f 0 \\<noteq> 0])\""], ["", "lemma represents_root_poly:\n  assumes \"ipoly p x = 0\" and p: \"p \\<noteq> 0\"\n  shows \"(root_poly_Re p) represents (Re x)\"\n    and \"\\<exists> q \\<in> set (root_poly_Im p). q represents (Im x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_poly_Re p represents Re x &&&\n    \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. root_poly_Re p represents Re x\n 2. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "let ?Rep = \"root_poly_Re p\""], ["proof (state)\ngoal (2 subgoals):\n 1. root_poly_Re p represents Re x\n 2. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "let ?Imp = \"root_poly_Im p\""], ["proof (state)\ngoal (2 subgoals):\n 1. root_poly_Re p represents Re x\n 2. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "from assms"], ["proof (chain)\npicking this:\n  poly (complex_of_int_poly p) x = 0\n  p \\<noteq> 0", "have ap: \"p represents x\""], ["proof (prove)\nusing this:\n  poly (complex_of_int_poly p) x = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p represents x", "by auto"], ["proof (state)\nthis:\n  p represents x\n\ngoal (2 subgoals):\n 1. root_poly_Re p represents Re x\n 2. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "from represents_cnj[OF this]"], ["proof (chain)\npicking this:\n  p represents cnj x", "have apc: \"p represents (cnj x)\""], ["proof (prove)\nusing this:\n  p represents cnj x\n\ngoal (1 subgoal):\n 1. p represents cnj x", "."], ["proof (state)\nthis:\n  p represents cnj x\n\ngoal (2 subgoals):\n 1. root_poly_Re p represents Re x\n 2. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "from represents_mult_rat[OF _ represents_add[OF ap apc], of \"inverse 2\"]"], ["proof (chain)\npicking this:\n  inverse 2 \\<noteq> 0 \\<Longrightarrow>\n  poly_mult_rat (inverse 2) (poly_add p p) represents\n  of_rat (inverse 2) * (x + cnj x)", "have \"?Rep represents (1 / 2 * (x + cnj x))\""], ["proof (prove)\nusing this:\n  inverse 2 \\<noteq> 0 \\<Longrightarrow>\n  poly_mult_rat (inverse 2) (poly_add p p) represents\n  of_rat (inverse 2) * (x + cnj x)\n\ngoal (1 subgoal):\n 1. root_poly_Re p represents 1 / 2 * (x + cnj x)", "unfolding root_poly_Re_def Let_def"], ["proof (prove)\nusing this:\n  inverse 2 \\<noteq> 0 \\<Longrightarrow>\n  poly_mult_rat (inverse 2) (poly_add p p) represents\n  of_rat (inverse 2) * (x + cnj x)\n\ngoal (1 subgoal):\n 1. cf_pos_poly (poly_mult_rat (inverse 2) (poly_add p p)) represents\n    1 / 2 * (x + cnj x)", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  root_poly_Re p represents 1 / 2 * (x + cnj x)\n\ngoal (2 subgoals):\n 1. root_poly_Re p represents Re x\n 2. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "also"], ["proof (state)\nthis:\n  root_poly_Re p represents 1 / 2 * (x + cnj x)\n\ngoal (2 subgoals):\n 1. root_poly_Re p represents Re x\n 2. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "have \"1 / 2 * (x + cnj x) = of_real (Re x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * (x + cnj x) = complex_of_real (Re x)", "by (simp add: complex_add_cnj)"], ["proof (state)\nthis:\n  1 / 2 * (x + cnj x) = complex_of_real (Re x)\n\ngoal (2 subgoals):\n 1. root_poly_Re p represents Re x\n 2. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "finally"], ["proof (chain)\npicking this:\n  root_poly_Re p represents complex_of_real (Re x)", "have Rep: \"?Rep \\<noteq> 0\" and rt: \"ipoly ?Rep (complex_of_real (Re x)) = 0\""], ["proof (prove)\nusing this:\n  root_poly_Re p represents complex_of_real (Re x)\n\ngoal (1 subgoal):\n 1. root_poly_Re p \\<noteq> 0 &&&\n    poly (complex_of_int_poly (root_poly_Re p)) (complex_of_real (Re x)) = 0", "unfolding represents_def"], ["proof (prove)\nusing this:\n  poly (complex_of_int_poly (root_poly_Re p)) (complex_of_real (Re x)) =\n  0 \\<and>\n  root_poly_Re p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root_poly_Re p \\<noteq> 0 &&&\n    poly (complex_of_int_poly (root_poly_Re p)) (complex_of_real (Re x)) = 0", "by auto"], ["proof (state)\nthis:\n  root_poly_Re p \\<noteq> 0\n  poly (complex_of_int_poly (root_poly_Re p)) (complex_of_real (Re x)) = 0\n\ngoal (2 subgoals):\n 1. root_poly_Re p represents Re x\n 2. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "from rt[unfolded poly_complex_to_real]"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly (root_poly_Re p)) (Re x) = 0", "have \"ipoly ?Rep (Re x) = 0\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly (root_poly_Re p)) (Re x) = 0\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly (root_poly_Re p)) (Re x) = 0", "."], ["proof (state)\nthis:\n  poly (real_of_int_poly (root_poly_Re p)) (Re x) = 0\n\ngoal (2 subgoals):\n 1. root_poly_Re p represents Re x\n 2. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "with Rep"], ["proof (chain)\npicking this:\n  root_poly_Re p \\<noteq> 0\n  poly (real_of_int_poly (root_poly_Re p)) (Re x) = 0", "show \"?Rep represents (Re x)\""], ["proof (prove)\nusing this:\n  root_poly_Re p \\<noteq> 0\n  poly (real_of_int_poly (root_poly_Re p)) (Re x) = 0\n\ngoal (1 subgoal):\n 1. root_poly_Re p represents Re x", "by auto"], ["proof (state)\nthis:\n  root_poly_Re p represents Re x\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "let ?q = \"poly_add p (poly_uminus p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "from represents_add[OF ap, of \"poly_uminus p\" \"- cnj x\"] represents_uminus[OF apc]"], ["proof (chain)\npicking this:\n  poly_uminus p represents - cnj x \\<Longrightarrow>\n  poly_add p (poly_uminus p) represents x + - cnj x\n  poly_uminus p represents - cnj x", "have apq: \"?q represents (x - cnj x)\""], ["proof (prove)\nusing this:\n  poly_uminus p represents - cnj x \\<Longrightarrow>\n  poly_add p (poly_uminus p) represents x + - cnj x\n  poly_uminus p represents - cnj x\n\ngoal (1 subgoal):\n 1. poly_add p (poly_uminus p) represents x - cnj x", "by auto"], ["proof (state)\nthis:\n  poly_add p (poly_uminus p) represents x - cnj x\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "from factors_int_poly_represents[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>q\\<in>set (factors_of_int_poly (poly_add p (poly_uminus p))).\n     q represents x - cnj x \\<and>\n     irreducible q \\<and>\n     0 < lead_coeff q \\<and>\n     degree q \\<le> degree (poly_add p (poly_uminus p))", "obtain pi where pi: \"pi \\<in> set (factors_of_int_poly ?q)\"\n    and appi: \"pi represents (x - cnj x)\" and irr_pi: \"irreducible pi\""], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>set (factors_of_int_poly (poly_add p (poly_uminus p))).\n     q represents x - cnj x \\<and>\n     irreducible q \\<and>\n     0 < lead_coeff q \\<and>\n     degree q \\<le> degree (poly_add p (poly_uminus p))\n\ngoal (1 subgoal):\n 1. (\\<And>pi.\n        \\<lbrakk>pi \\<in> set (factors_of_int_poly\n                                (poly_add p (poly_uminus p)));\n         pi represents x - cnj x; irreducible pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pi \\<in> set (factors_of_int_poly (poly_add p (poly_uminus p)))\n  pi represents x - cnj x\n  irreducible pi\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "have id: \"inverse (2 * \\<i>) * (x - cnj x) = of_real (Im x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (2 * \\<i>) * (x - cnj x) = complex_of_real (Im x)", "apply (cases x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x = Complex x1 x2 \\<Longrightarrow>\n       inverse (2 * \\<i>) * (x - cnj x) = complex_of_real (Im x)", "by (simp add: complex_split imaginary_unit.ctr legacy_Complex_simps)"], ["proof (state)\nthis:\n  inverse (2 * \\<i>) * (x - cnj x) = complex_of_real (Im x)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "from represents_2i"], ["proof (chain)\npicking this:\n  poly_2i represents 2 * \\<i>", "have 12: \"poly_2i represents (2 * \\<i>)\""], ["proof (prove)\nusing this:\n  poly_2i represents 2 * \\<i>\n\ngoal (1 subgoal):\n 1. poly_2i represents 2 * \\<i>", "by simp"], ["proof (state)\nthis:\n  poly_2i represents 2 * \\<i>\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "have \"\\<exists> qi \\<in> set ?Imp. qi represents (inverse (2 * \\<i>) * (x - cnj x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "proof (cases \"x - cnj x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x - cnj x = 0 \\<Longrightarrow>\n    \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)\n 2. x - cnj x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "case False"], ["proof (state)\nthis:\n  x - cnj x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x - cnj x = 0 \\<Longrightarrow>\n    \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)\n 2. x - cnj x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "have \"poly poly_2i 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly poly_2i 0 \\<noteq> 0", "unfolding poly_2i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly [:4, 0, 1:] 0 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly poly_2i 0 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x - cnj x = 0 \\<Longrightarrow>\n    \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)\n 2. x - cnj x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "from represents_div[OF appi 12 this]\n      represents_irr_non_0[OF irr_pi appi False, unfolded poly_0_coeff_0] pi"], ["proof (chain)\npicking this:\n  poly_div pi poly_2i represents (x - cnj x) / (2 * \\<i>)\n  coeff pi 0 \\<noteq> 0\n  pi \\<in> set (factors_of_int_poly (poly_add p (poly_uminus p)))", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_div pi poly_2i represents (x - cnj x) / (2 * \\<i>)\n  coeff pi 0 \\<noteq> 0\n  pi \\<in> set (factors_of_int_poly (poly_add p (poly_uminus p)))\n\ngoal (1 subgoal):\n 1. \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "unfolding root_poly_Im_def Let_def"], ["proof (prove)\nusing this:\n  poly_div pi poly_2i represents (x - cnj x) / (2 * \\<i>)\n  coeff pi 0 \\<noteq> 0\n  pi \\<in> set (factors_of_int_poly (poly_add p (poly_uminus p)))\n\ngoal (1 subgoal):\n 1. \\<exists>qi\\<in>set (remdups\n                          (if \\<exists>f\n \\<in>set (factors_of_int_poly (poly_add p (poly_uminus p))).\n                                 coeff f 0 = 0\n                           then [[:0, 1:]] else []) @\n                         concat\n                          (map (\\<lambda>f.\n                                   if coeff f 0 \\<noteq> 0\n                                   then [cf_pos_poly (poly_div f poly_2i)]\n                                   else [])\n                            (factors_of_int_poly\n                              (poly_add p (poly_uminus p))))).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "by (auto intro: bexI[of _ \"cf_pos_poly (poly_div pi poly_2i)\"])"], ["proof (state)\nthis:\n  \\<exists>qi\\<in>set (root_poly_Im p).\n     qi represents inverse (2 * \\<i>) * (x - cnj x)\n\ngoal (1 subgoal):\n 1. x - cnj x = 0 \\<Longrightarrow>\n    \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x - cnj x = 0 \\<Longrightarrow>\n    \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "case True"], ["proof (state)\nthis:\n  x - cnj x = 0\n\ngoal (1 subgoal):\n 1. x - cnj x = 0 \\<Longrightarrow>\n    \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "hence id2: \"Im x = 0\""], ["proof (prove)\nusing this:\n  x - cnj x = 0\n\ngoal (1 subgoal):\n 1. Im x = 0", "by (simp add: complex_eq_iff)"], ["proof (state)\nthis:\n  Im x = 0\n\ngoal (1 subgoal):\n 1. x - cnj x = 0 \\<Longrightarrow>\n    \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "from appi[unfolded True represents_def]"], ["proof (chain)\npicking this:\n  poly (complex_of_int_poly pi) 0 = 0 \\<and> pi \\<noteq> 0", "have \"coeff pi 0 = 0\""], ["proof (prove)\nusing this:\n  poly (complex_of_int_poly pi) 0 = 0 \\<and> pi \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coeff pi 0 = 0", "by (cases pi, auto)"], ["proof (state)\nthis:\n  coeff pi 0 = 0\n\ngoal (1 subgoal):\n 1. x - cnj x = 0 \\<Longrightarrow>\n    \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "with pi"], ["proof (chain)\npicking this:\n  pi \\<in> set (factors_of_int_poly (poly_add p (poly_uminus p)))\n  coeff pi 0 = 0", "have mem: \"[:0,1:] \\<in> set ?Imp\""], ["proof (prove)\nusing this:\n  pi \\<in> set (factors_of_int_poly (poly_add p (poly_uminus p)))\n  coeff pi 0 = 0\n\ngoal (1 subgoal):\n 1. [:0, 1:] \\<in> set (root_poly_Im p)", "unfolding root_poly_Im_def Let_def"], ["proof (prove)\nusing this:\n  pi \\<in> set (factors_of_int_poly (poly_add p (poly_uminus p)))\n  coeff pi 0 = 0\n\ngoal (1 subgoal):\n 1. [:0, 1:]\n    \\<in> set (remdups\n                (if \\<exists>f\\<in>set (factors_of_int_poly\n   (poly_add p (poly_uminus p))).\n                       coeff f 0 = 0\n                 then [[:0, 1:]] else []) @\n               concat\n                (map (\\<lambda>f.\n                         if coeff f 0 \\<noteq> 0\n                         then [cf_pos_poly (poly_div f poly_2i)] else [])\n                  (factors_of_int_poly (poly_add p (poly_uminus p)))))", "by auto"], ["proof (state)\nthis:\n  [:0, 1:] \\<in> set (root_poly_Im p)\n\ngoal (1 subgoal):\n 1. x - cnj x = 0 \\<Longrightarrow>\n    \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "have \"[:0,1:] represents (complex_of_real (Im x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:0, 1:] represents complex_of_real (Im x)", "unfolding id2 represents_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (complex_of_int_poly [:0, 1:]) (complex_of_real 0) = 0 \\<and>\n    [:0, 1:] \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  [:0, 1:] represents complex_of_real (Im x)\n\ngoal (1 subgoal):\n 1. x - cnj x = 0 \\<Longrightarrow>\n    \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "with mem"], ["proof (chain)\npicking this:\n  [:0, 1:] \\<in> set (root_poly_Im p)\n  [:0, 1:] represents complex_of_real (Im x)", "show ?thesis"], ["proof (prove)\nusing this:\n  [:0, 1:] \\<in> set (root_poly_Im p)\n  [:0, 1:] represents complex_of_real (Im x)\n\ngoal (1 subgoal):\n 1. \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents inverse (2 * \\<i>) * (x - cnj x)", "unfolding id"], ["proof (prove)\nusing this:\n  [:0, 1:] \\<in> set (root_poly_Im p)\n  [:0, 1:] represents complex_of_real (Im x)\n\ngoal (1 subgoal):\n 1. \\<exists>qi\\<in>set (root_poly_Im p).\n       qi represents complex_of_real (Im x)", "by auto"], ["proof (state)\nthis:\n  \\<exists>qi\\<in>set (root_poly_Im p).\n     qi represents inverse (2 * \\<i>) * (x - cnj x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>qi\\<in>set (root_poly_Im p).\n     qi represents inverse (2 * \\<i>) * (x - cnj x)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "then"], ["proof (chain)\npicking this:\n  \\<exists>qi\\<in>set (root_poly_Im p).\n     qi represents inverse (2 * \\<i>) * (x - cnj x)", "obtain qi where qi: \"qi \\<in> set ?Imp\" \"qi \\<noteq> 0\" and rt: \"ipoly qi (complex_of_real (Im x)) = 0\""], ["proof (prove)\nusing this:\n  \\<exists>qi\\<in>set (root_poly_Im p).\n     qi represents inverse (2 * \\<i>) * (x - cnj x)\n\ngoal (1 subgoal):\n 1. (\\<And>qi.\n        \\<lbrakk>qi \\<in> set (root_poly_Im p); qi \\<noteq> 0;\n         poly (complex_of_int_poly qi) (complex_of_real (Im x)) = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding id represents_def"], ["proof (prove)\nusing this:\n  \\<exists>qi\\<in>set (root_poly_Im p).\n     poly (complex_of_int_poly qi) (complex_of_real (Im x)) = 0 \\<and>\n     qi \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>qi.\n        \\<lbrakk>qi \\<in> set (root_poly_Im p); qi \\<noteq> 0;\n         poly (complex_of_int_poly qi) (complex_of_real (Im x)) = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qi \\<in> set (root_poly_Im p)\n  qi \\<noteq> 0\n  poly (complex_of_int_poly qi) (complex_of_real (Im x)) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "from qi rt[unfolded poly_complex_to_real]"], ["proof (chain)\npicking this:\n  qi \\<in> set (root_poly_Im p)\n  qi \\<noteq> 0\n  poly (real_of_int_poly qi) (Im x) = 0", "show \"\\<exists> qi \\<in> set ?Imp. qi represents (Im x)\""], ["proof (prove)\nusing this:\n  qi \\<in> set (root_poly_Im p)\n  qi \\<noteq> 0\n  poly (real_of_int_poly qi) (Im x) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>qi\\<in>set (root_poly_Im p). qi represents Im x", "by auto"], ["proof (state)\nthis:\n  \\<exists>qi\\<in>set (root_poly_Im p). qi represents Im x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Determine complex roots of a polynomial, \n   intended for polynomials of degree 3 or higher,\n   for lower degree polynomials use @{const roots1} or @{const croots2}\\<close>"], ["", "hide_const (open) eq"], ["", "primrec remdups_gen :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"remdups_gen eq [] = []\"\n| \"remdups_gen eq (x # xs) = (if (\\<exists> y \\<in> set xs. eq x y) then \n     remdups_gen eq xs else x # remdups_gen eq xs)\""], ["", "lemma real_of_3_remdups_equal_3[simp]: \"real_of_3 ` set (remdups_gen equal_3 xs) = real_of_3 ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 ` set (Complex_Algebraic_Numbers.remdups_gen equal_3 xs) =\n    real_of_3 ` set xs", "by (induct xs, auto simp: equal_3)"], ["", "lemma distinct_remdups_equal_3: \"distinct (map real_of_3 (remdups_gen equal_3 xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map real_of_3 (Complex_Algebraic_Numbers.remdups_gen equal_3 xs))", "by (induct xs, auto, auto simp: equal_3)"], ["", "lemma real_of_3_code [code]: \"real_of_3 x = real_of (Real_Alg_Quotient x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 x = real_of (Real_Alg_Quotient x)", "by (transfer, auto)"], ["", "definition \"real_parts_3 p = roots_of_3 (root_poly_Re p)\""], ["", "definition \"pos_imaginary_parts_3 p = \n  remdups_gen equal_3 (filter (\\<lambda> x. sgn_3 x = 1) (concat (map roots_of_3 (root_poly_Im p))))\""], ["", "lemma real_parts_3: assumes p: \"p \\<noteq> 0\" and \"ipoly p x = 0\" \n  shows \"Re x \\<in> real_of_3 ` set (real_parts_3 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re x \\<in> real_of_3 ` set (real_parts_3 p)", "unfolding real_parts_3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re x \\<in> real_of_3 ` set (roots_of_3 (root_poly_Re p))", "using represents_root_poly(1)[OF assms(2,1)]\n    roots_of_3(1)"], ["proof (prove)\nusing this:\n  root_poly_Re p represents Re x\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  real_of_3 ` set (roots_of_3 ?p) = {x. poly (real_of_int_poly ?p) x = 0}\n\ngoal (1 subgoal):\n 1. Re x \\<in> real_of_3 ` set (roots_of_3 (root_poly_Re p))", "unfolding represents_def"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly (root_poly_Re p)) (Re x) = 0 \\<and>\n  root_poly_Re p \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  real_of_3 ` set (roots_of_3 ?p) = {x. poly (real_of_int_poly ?p) x = 0}\n\ngoal (1 subgoal):\n 1. Re x \\<in> real_of_3 ` set (roots_of_3 (root_poly_Re p))", "by auto"], ["", "lemma distinct_real_parts_3: \"distinct (map real_of_3 (real_parts_3 p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map real_of_3 (real_parts_3 p))", "unfolding real_parts_3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map real_of_3 (roots_of_3 (root_poly_Re p)))", "using roots_of_3(2)"], ["proof (prove)\nusing this:\n  distinct (map real_of_3 (roots_of_3 ?p))\n\ngoal (1 subgoal):\n 1. distinct (map real_of_3 (roots_of_3 (root_poly_Re p)))", "."], ["", "lemma pos_imaginary_parts_3: assumes p: \"p \\<noteq> 0\" and \"ipoly p x = 0\" and \"Im x > 0\" \n  shows \"Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)", "from represents_root_poly(2)[OF assms(2,1)]"], ["proof (chain)\npicking this:\n  \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "obtain q where \n    q: \"q \\<in> set (root_poly_Im p)\" \"q represents Im x\""], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>set (root_poly_Im p). q represents Im x\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (root_poly_Im p); q represents Im x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> set (root_poly_Im p)\n  q represents Im x\n\ngoal (1 subgoal):\n 1. Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)", "from roots_of_3(1)[of q]"], ["proof (chain)\npicking this:\n  q \\<noteq> 0 \\<Longrightarrow>\n  real_of_3 ` set (roots_of_3 q) = {x. poly (real_of_int_poly q) x = 0}", "have \"Im x \\<in> real_of_3 ` set (roots_of_3 q)\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0 \\<Longrightarrow>\n  real_of_3 ` set (roots_of_3 q) = {x. poly (real_of_int_poly q) x = 0}\n\ngoal (1 subgoal):\n 1. Im x \\<in> real_of_3 ` set (roots_of_3 q)", "using q"], ["proof (prove)\nusing this:\n  q \\<noteq> 0 \\<Longrightarrow>\n  real_of_3 ` set (roots_of_3 q) = {x. poly (real_of_int_poly q) x = 0}\n  q \\<in> set (root_poly_Im p)\n  q represents Im x\n\ngoal (1 subgoal):\n 1. Im x \\<in> real_of_3 ` set (roots_of_3 q)", "unfolding represents_def"], ["proof (prove)\nusing this:\n  q \\<noteq> 0 \\<Longrightarrow>\n  real_of_3 ` set (roots_of_3 q) = {x. poly (real_of_int_poly q) x = 0}\n  q \\<in> set (root_poly_Im p)\n  poly (real_of_int_poly q) (Im x) = 0 \\<and> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im x \\<in> real_of_3 ` set (roots_of_3 q)", "by auto"], ["proof (state)\nthis:\n  Im x \\<in> real_of_3 ` set (roots_of_3 q)\n\ngoal (1 subgoal):\n 1. Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)", "then"], ["proof (chain)\npicking this:\n  Im x \\<in> real_of_3 ` set (roots_of_3 q)", "obtain i3 where i3: \"i3 \\<in> set (roots_of_3 q)\" and id: \"Im x = real_of_3 i3\""], ["proof (prove)\nusing this:\n  Im x \\<in> real_of_3 ` set (roots_of_3 q)\n\ngoal (1 subgoal):\n 1. (\\<And>i3.\n        \\<lbrakk>i3 \\<in> set (roots_of_3 q); Im x = real_of_3 i3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i3 \\<in> set (roots_of_3 q)\n  Im x = real_of_3 i3\n\ngoal (1 subgoal):\n 1. Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)", "from \\<open>Im x > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < Im x", "have \"sgn (Im x) = 1\""], ["proof (prove)\nusing this:\n  0 < Im x\n\ngoal (1 subgoal):\n 1. sgn (Im x) = 1", "by simp"], ["proof (state)\nthis:\n  sgn (Im x) = 1\n\ngoal (1 subgoal):\n 1. Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)", "hence sgn: \"sgn_3 i3 = 1\""], ["proof (prove)\nusing this:\n  sgn (Im x) = 1\n\ngoal (1 subgoal):\n 1. sgn_3 i3 = 1", "unfolding id"], ["proof (prove)\nusing this:\n  sgn (real_of_3 i3) = 1\n\ngoal (1 subgoal):\n 1. sgn_3 i3 = 1", "by (metis of_rat_eq_1_iff sgn_3)"], ["proof (state)\nthis:\n  sgn_3 i3 = 1\n\ngoal (1 subgoal):\n 1. Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)", "unfolding pos_imaginary_parts_3_def real_of_3_remdups_equal_3 id"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 i3\n    \\<in> real_of_3 `\n          set (filter (\\<lambda>x. sgn_3 x = 1)\n                (concat (map roots_of_3 (root_poly_Im p))))", "using sgn i3 q(1)"], ["proof (prove)\nusing this:\n  sgn_3 i3 = 1\n  i3 \\<in> set (roots_of_3 q)\n  q \\<in> set (root_poly_Im p)\n\ngoal (1 subgoal):\n 1. real_of_3 i3\n    \\<in> real_of_3 `\n          set (filter (\\<lambda>x. sgn_3 x = 1)\n                (concat (map roots_of_3 (root_poly_Im p))))", "by auto"], ["proof (state)\nthis:\n  Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_pos_imaginary_parts_3: \"distinct (map real_of_3 (pos_imaginary_parts_3 p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map real_of_3 (pos_imaginary_parts_3 p))", "unfolding pos_imaginary_parts_3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map real_of_3\n       (Complex_Algebraic_Numbers.remdups_gen equal_3\n         (filter (\\<lambda>x. sgn_3 x = 1)\n           (concat (map roots_of_3 (root_poly_Im p))))))", "by (rule distinct_remdups_equal_3)"], ["", "lemma remdups_gen_subset: \"set (remdups_gen eq xs) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Complex_Algebraic_Numbers.remdups_gen eq xs) \\<subseteq> set xs", "by (induct xs, auto)"], ["", "lemma positive_pos_imaginary_parts_3: assumes \"x \\<in> set (pos_imaginary_parts_3 p)\"\n  shows \"0 < real_of_3 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < real_of_3 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < real_of_3 x", "from subsetD[OF remdups_gen_subset assms[unfolded pos_imaginary_parts_3_def]]"], ["proof (chain)\npicking this:\n  x \\<in> set (filter (\\<lambda>x. sgn_3 x = 1)\n                (concat (map roots_of_3 (root_poly_Im p))))", "have \"sgn_3 x = 1\""], ["proof (prove)\nusing this:\n  x \\<in> set (filter (\\<lambda>x. sgn_3 x = 1)\n                (concat (map roots_of_3 (root_poly_Im p))))\n\ngoal (1 subgoal):\n 1. sgn_3 x = 1", "by auto"], ["proof (state)\nthis:\n  sgn_3 x = 1\n\ngoal (1 subgoal):\n 1. 0 < real_of_3 x", "thus ?thesis"], ["proof (prove)\nusing this:\n  sgn_3 x = 1\n\ngoal (1 subgoal):\n 1. 0 < real_of_3 x", "using sgn_3[of x]"], ["proof (prove)\nusing this:\n  sgn_3 x = 1\n  real_of_rat (sgn_3 x) = sgn (real_of_3 x)\n\ngoal (1 subgoal):\n 1. 0 < real_of_3 x", "by (simp add: sgn_1_pos)"], ["proof (state)\nthis:\n  0 < real_of_3 x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"pair_to_complex ri \\<equiv> case ri of (r,i) \\<Rightarrow> Complex (real_of_3 r) (real_of_3 i)\""], ["", "fun get_itvl_2 :: \"real_alg_2 \\<Rightarrow> real interval\" where\n  \"get_itvl_2 (Irrational n (p,l,r)) = Interval (of_rat l) (of_rat r)\" \n| \"get_itvl_2 (Rational r) = (let rr = of_rat r in Interval rr rr)\""], ["", "lemma get_bounds_2: assumes \"invariant_2 x\"\n  shows \"real_of_2 x \\<in>\\<^sub>i get_itvl_2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 x \\<in>\\<^sub>i get_itvl_2 x", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       real_of_2 x \\<in>\\<^sub>i get_itvl_2 x\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       real_of_2 x \\<in>\\<^sub>i get_itvl_2 x", "case (Irrational n plr)"], ["proof (state)\nthis:\n  x = Irrational n plr\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       real_of_2 x \\<in>\\<^sub>i get_itvl_2 x\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       real_of_2 x \\<in>\\<^sub>i get_itvl_2 x", "with assms"], ["proof (chain)\npicking this:\n  invariant_2 x\n  x = Irrational n plr", "obtain p l r where plr: \"plr = (p,l,r)\""], ["proof (prove)\nusing this:\n  invariant_2 x\n  x = Irrational n plr\n\ngoal (1 subgoal):\n 1. (\\<And>p l r.\n        plr = (p, l, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases plr, auto)"], ["proof (state)\nthis:\n  plr = (p, l, r)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       real_of_2 x \\<in>\\<^sub>i get_itvl_2 x\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       real_of_2 x \\<in>\\<^sub>i get_itvl_2 x", "from assms Irrational plr"], ["proof (chain)\npicking this:\n  invariant_2 x\n  x = Irrational n plr\n  plr = (p, l, r)", "have inv1: \"invariant_1 (p,l,r)\" \n    and id: \"real_of_2 x = real_of_1 (p,l,r)\""], ["proof (prove)\nusing this:\n  invariant_2 x\n  x = Irrational n plr\n  plr = (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l, r) &&& real_of_2 x = real_of_1 (p, l, r)", "by auto"], ["proof (state)\nthis:\n  invariant_1 (p, l, r)\n  real_of_2 x = real_of_1 (p, l, r)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       real_of_2 x \\<in>\\<^sub>i get_itvl_2 x\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       real_of_2 x \\<in>\\<^sub>i get_itvl_2 x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 x \\<in>\\<^sub>i get_itvl_2 x", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) \\<in>\\<^sub>i get_itvl_2 x", "using invariant_1D(1)[OF inv1]"], ["proof (prove)\nusing this:\n  root_cond (p, l, r) (real_of_1 (p, l, r))\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) \\<in>\\<^sub>i get_itvl_2 x", "by (auto simp: plr Irrational)"], ["proof (state)\nthis:\n  real_of_2 x \\<in>\\<^sub>i get_itvl_2 x\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       real_of_2 x \\<in>\\<^sub>i get_itvl_2 x", "qed (insert assms, auto simp: Let_def)"], ["", "lift_definition get_itvl_3 :: \"real_alg_3 \\<Rightarrow> real interval\" is get_itvl_2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma get_itvl_3: \"real_of_3 x \\<in>\\<^sub>i get_itvl_3 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 x \\<in>\\<^sub>i get_itvl_3 x", "by (transfer, insert get_bounds_2, auto)"], ["", "fun tighten_bounds_2 :: \"real_alg_2 \\<Rightarrow> real_alg_2\" where\n  \"tighten_bounds_2 (Irrational n (p,l,r)) = (case tighten_poly_bounds p l r (sgn (ipoly p r))\n    of (l',r',_) \\<Rightarrow> Irrational n (p,l',r'))\" \n| \"tighten_bounds_2 (Rational r) = Rational r\""], ["", "lemma tighten_bounds_2: assumes inv: \"invariant_2 x\" \n  shows \"real_of_2 (tighten_bounds_2 x) = real_of_2 x\" \"invariant_2 (tighten_bounds_2 x)\" \n  \"get_itvl_2 x = Interval l r \\<Longrightarrow>\n   get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<Longrightarrow> r' - l' = (r-l) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x &&&\n    invariant_2 (tighten_bounds_2 x) &&&\n    (\\<lbrakk>get_itvl_2 x = Interval l r;\n      get_itvl_2 (tighten_bounds_2 x) = Interval l' r'\\<rbrakk>\n     \\<Longrightarrow> r' - l' = (r - l) / 2)", "proof (atomize(full), cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n       invariant_2 (tighten_bounds_2 x) \\<and>\n       (get_itvl_2 x = Interval l r \\<longrightarrow>\n        get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n        r' - l' = (r - l) / 2)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n       invariant_2 (tighten_bounds_2 x) \\<and>\n       (get_itvl_2 x = Interval l r \\<longrightarrow>\n        get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n        r' - l' = (r - l) / 2)", "case (Irrational n plr)"], ["proof (state)\nthis:\n  x = Irrational n plr\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n       invariant_2 (tighten_bounds_2 x) \\<and>\n       (get_itvl_2 x = Interval l r \\<longrightarrow>\n        get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n        r' - l' = (r - l) / 2)\n 2. \\<And>x21 x22.\n       x = Irrational x21 x22 \\<Longrightarrow>\n       real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n       invariant_2 (tighten_bounds_2 x) \\<and>\n       (get_itvl_2 x = Interval l r \\<longrightarrow>\n        get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n        r' - l' = (r - l) / 2)", "show \"real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n       invariant_2 (tighten_bounds_2 x) \\<and>\n       (get_itvl_2 x = Interval l r \\<longrightarrow>\n        get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow> r' - l' = (r - l) / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "obtain p l r where plr: \"plr = (p,l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p l r.\n        plr = (p, l, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases plr, auto)"], ["proof (state)\nthis:\n  plr = (p, l, r)\n\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "let ?tb = \"tighten_poly_bounds p l r (sgn (ipoly p r))\""], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "obtain l' r' sr' where tb: \"?tb = (l',r',sr')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l' r' sr'.\n        tighten_poly_bounds p l r (sgn (ipoly p r)) =\n        (l', r', sr') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?tb, auto)"], ["proof (state)\nthis:\n  tighten_poly_bounds p l r (sgn (ipoly p r)) = (l', r', sr')\n\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "have id: \"tighten_bounds_2 x = Irrational n (p,l',r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tighten_bounds_2 x = Irrational n (p, l', r')", "unfolding Irrational plr"], ["proof (prove)\ngoal (1 subgoal):\n 1. tighten_bounds_2 (Irrational n (p, l, r)) = Irrational n (p, l', r')", "using tb"], ["proof (prove)\nusing this:\n  tighten_poly_bounds p l r (sgn (ipoly p r)) = (l', r', sr')\n\ngoal (1 subgoal):\n 1. tighten_bounds_2 (Irrational n (p, l, r)) = Irrational n (p, l', r')", "by auto"], ["proof (state)\nthis:\n  tighten_bounds_2 x = Irrational n (p, l', r')\n\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "from inv[unfolded Irrational plr]"], ["proof (chain)\npicking this:\n  invariant_2 (Irrational n (p, l, r))", "have inv: \"invariant_1_2 (p, l, r)\"\n      \"n = card {y. y \\<le> real_of_1 (p, l, r) \\<and> ipoly p y = 0}\""], ["proof (prove)\nusing this:\n  invariant_2 (Irrational n (p, l, r))\n\ngoal (1 subgoal):\n 1. invariant_1_2 (p, l, r) &&&\n    n =\n    card\n     {y. y \\<le> real_of_1 (p, l, r) \\<and> poly (real_of_int_poly p) y = 0}", "by auto"], ["proof (state)\nthis:\n  invariant_1_2 (p, l, r)\n  n =\n  card\n   {y. y \\<le> real_of_1 (p, l, r) \\<and> poly (real_of_int_poly p) y = 0}\n\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "have rof: \"real_of_2 x = real_of_1 (p, l, r)\" \n      \"real_of_2 (tighten_bounds_2 x) = real_of_1 (p, l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 x = real_of_1 (p, l, r) &&&\n    real_of_2 (tighten_bounds_2 x) = real_of_1 (p, l', r')", "using Irrational plr id"], ["proof (prove)\nusing this:\n  x = Irrational n plr\n  plr = (p, l, r)\n  tighten_bounds_2 x = Irrational n (p, l', r')\n\ngoal (1 subgoal):\n 1. real_of_2 x = real_of_1 (p, l, r) &&&\n    real_of_2 (tighten_bounds_2 x) = real_of_1 (p, l', r')", "by auto"], ["proof (state)\nthis:\n  real_of_2 x = real_of_1 (p, l, r)\n  real_of_2 (tighten_bounds_2 x) = real_of_1 (p, l', r')\n\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "from inv"], ["proof (chain)\npicking this:\n  invariant_1_2 (p, l, r)\n  n =\n  card\n   {y. y \\<le> real_of_1 (p, l, r) \\<and> poly (real_of_int_poly p) y = 0}", "have inv1: \"invariant_1 (p, l, r)\" and \"poly_cond2 p\""], ["proof (prove)\nusing this:\n  invariant_1_2 (p, l, r)\n  n =\n  card\n   {y. y \\<le> real_of_1 (p, l, r) \\<and> poly (real_of_int_poly p) y = 0}\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l, r) &&& poly_cond2 p", "by auto"], ["proof (state)\nthis:\n  invariant_1 (p, l, r)\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "hence rc: \"\\<exists>!x. root_cond (p, l, r) x\" \"poly_cond2 p\""], ["proof (prove)\nusing this:\n  invariant_1 (p, l, r)\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, l, r) x &&& poly_cond2 p", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, l, r) x\n  poly_cond2 p\n\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "note tb' = tighten_poly_bounds[OF tb rc refl]"], ["proof (state)\nthis:\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  r' - l' = (r - l) / 2\n  sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "have eq: \"real_of_1 (p, l, r) = real_of_1 (p, l', r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) = real_of_1 (p, l', r')", "using tb' inv1"], ["proof (prove)\nusing this:\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  r' - l' = (r - l) / 2\n  sr' = sgn (ipoly p r')\n  invariant_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) = real_of_1 (p, l', r')", "using invariant_1_sub_interval(2)"], ["proof (prove)\nusing this:\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  r' - l' = (r - l) / 2\n  sr' = sgn (ipoly p r')\n  invariant_1 (p, l, r)\n  \\<lbrakk>invariant_1 (?p, ?l, ?r);\n   root_cond (?p, ?l', ?r') (real_of_1 (?p, ?l, ?r)); ?l \\<le> ?l';\n   ?r' \\<le> ?r\\<rbrakk>\n  \\<Longrightarrow> real_of_1 (?p, ?l', ?r') = real_of_1 (?p, ?l, ?r)\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l, r) = real_of_1 (p, l', r')", "by presburger"], ["proof (state)\nthis:\n  real_of_1 (p, l, r) = real_of_1 (p, l', r')\n\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "from inv1 tb'"], ["proof (chain)\npicking this:\n  invariant_1 (p, l, r)\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  r' - l' = (r - l) / 2\n  sr' = sgn (ipoly p r')", "have \"invariant_1 (p, l', r')\""], ["proof (prove)\nusing this:\n  invariant_1 (p, l, r)\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  r' - l' = (r - l) / 2\n  sr' = sgn (ipoly p r')\n\ngoal (1 subgoal):\n 1. invariant_1 (p, l', r')", "by (metis invariant_1_sub_interval(1))"], ["proof (state)\nthis:\n  invariant_1 (p, l', r')\n\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "hence inv2: \"invariant_2 (tighten_bounds_2 x)\""], ["proof (prove)\nusing this:\n  invariant_1 (p, l', r')\n\ngoal (1 subgoal):\n 1. invariant_2 (tighten_bounds_2 x)", "unfolding id"], ["proof (prove)\nusing this:\n  invariant_1 (p, l', r')\n\ngoal (1 subgoal):\n 1. invariant_2 (Irrational n (p, l', r'))", "using inv eq"], ["proof (prove)\nusing this:\n  invariant_1 (p, l', r')\n  invariant_1_2 (p, l, r)\n  n =\n  card\n   {y. y \\<le> real_of_1 (p, l, r) \\<and> poly (real_of_int_poly p) y = 0}\n  real_of_1 (p, l, r) = real_of_1 (p, l', r')\n\ngoal (1 subgoal):\n 1. invariant_2 (Irrational n (p, l', r'))", "by auto"], ["proof (state)\nthis:\n  invariant_2 (tighten_bounds_2 x)\n\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  invariant_2 (tighten_bounds_2 x)\n\ngoal (1 subgoal):\n 1. real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "unfolding rof eq"], ["proof (prove)\nusing this:\n  invariant_2 (tighten_bounds_2 x)\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l', r') = real_of_1 (p, l', r') \\<and>\n    invariant_2 (tighten_bounds_2 x) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "unfolding id"], ["proof (prove)\nusing this:\n  invariant_2 (Irrational n (p, l', r'))\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l', r') = real_of_1 (p, l', r') \\<and>\n    invariant_2 (Irrational n (p, l', r')) \\<and>\n    (get_itvl_2 x = Interval l r \\<longrightarrow>\n     get_itvl_2 (Irrational n (p, l', r')) =\n     Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "unfolding Irrational plr"], ["proof (prove)\nusing this:\n  invariant_2 (Irrational n (p, l', r'))\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l', r') = real_of_1 (p, l', r') \\<and>\n    invariant_2 (Irrational n (p, l', r')) \\<and>\n    (get_itvl_2 (Irrational n (p, l, r)) = Interval l r \\<longrightarrow>\n     get_itvl_2 (Irrational n (p, l', r')) =\n     Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "using tb'(1-4) arg_cong[OF tb'(5), of real_of_rat]"], ["proof (prove)\nusing this:\n  invariant_2 (Irrational n (p, l', r'))\n  root_cond (p, l', r') (real_of_1 (p, l, r))\n  l \\<le> l'\n  l' \\<le> r'\n  r' \\<le> r\n  real_of_rat (r' - l') = real_of_rat ((r - l) / 2)\n\ngoal (1 subgoal):\n 1. real_of_1 (p, l', r') = real_of_1 (p, l', r') \\<and>\n    invariant_2 (Irrational n (p, l', r')) \\<and>\n    (get_itvl_2 (Irrational n (p, l, r)) = Interval l r \\<longrightarrow>\n     get_itvl_2 (Irrational n (p, l', r')) =\n     Interval l' r' \\<longrightarrow>\n     r' - l' = (r - l) / 2)", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n  invariant_2 (tighten_bounds_2 x) \\<and>\n  (get_itvl_2 x = Interval l r \\<longrightarrow>\n   get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n   r' - l' = (r - l) / 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n  invariant_2 (tighten_bounds_2 x) \\<and>\n  (get_itvl_2 x = Interval l r \\<longrightarrow>\n   get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n   r' - l' = (r - l) / 2)\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       x = Rational x1 \\<Longrightarrow>\n       real_of_2 (tighten_bounds_2 x) = real_of_2 x \\<and>\n       invariant_2 (tighten_bounds_2 x) \\<and>\n       (get_itvl_2 x = Interval l r \\<longrightarrow>\n        get_itvl_2 (tighten_bounds_2 x) = Interval l' r' \\<longrightarrow>\n        r' - l' = (r - l) / 2)", "qed (auto simp: Let_def)"], ["", "lift_definition tighten_bounds_3 :: \"real_alg_3 \\<Rightarrow> real_alg_3\" is tighten_bounds_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real_alg_2.\n       real_alg_2 \\<in> Collect invariant_2 \\<Longrightarrow>\n       tighten_bounds_2 real_alg_2 \\<in> Collect invariant_2", "using tighten_bounds_2"], ["proof (prove)\nusing this:\n  invariant_2 ?x \\<Longrightarrow>\n  real_of_2 (tighten_bounds_2 ?x) = real_of_2 ?x\n  invariant_2 ?x \\<Longrightarrow> invariant_2 (tighten_bounds_2 ?x)\n  \\<lbrakk>invariant_2 ?x; get_itvl_2 ?x = Interval ?l ?r;\n   get_itvl_2 (tighten_bounds_2 ?x) = Interval ?l' ?r'\\<rbrakk>\n  \\<Longrightarrow> ?r' - ?l' = (?r - ?l) / 2\n\ngoal (1 subgoal):\n 1. \\<And>real_alg_2.\n       real_alg_2 \\<in> Collect invariant_2 \\<Longrightarrow>\n       tighten_bounds_2 real_alg_2 \\<in> Collect invariant_2", "by auto"], ["", "lemma tighten_bounds_3:  \n  \"real_of_3 (tighten_bounds_3 x) = real_of_3 x\"  \n  \"get_itvl_3 x = Interval l r \\<Longrightarrow>\n   get_itvl_3 (tighten_bounds_3 x) = Interval l' r' \\<Longrightarrow> r' - l' = (r-l) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 (tighten_bounds_3 x) = real_of_3 x &&&\n    (\\<lbrakk>get_itvl_3 x = Interval l r;\n      get_itvl_3 (tighten_bounds_3 x) = Interval l' r'\\<rbrakk>\n     \\<Longrightarrow> r' - l' = (r - l) / 2)", "by (transfer, insert tighten_bounds_2, auto)+"], ["", "partial_function (tailrec) filter_list_length \n  :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  [code]: \"filter_list_length f p n xs = (let ys = filter p xs \n     in if length ys = n then ys else\n     filter_list_length f p n (map f ys))\""], ["", "lemma filter_list_length: assumes \"length (filter P xs) = n\"\n  and \"\\<And> i x. x \\<in> set xs \\<Longrightarrow> P x \\<Longrightarrow> p ((f ^^ i) x)\" \n  and \"\\<And> x. x \\<in> set xs \\<Longrightarrow> \\<not> P x \\<Longrightarrow> \\<exists> i. \\<not> p ((f ^^ i) x)\" \n  and g: \"\\<And> x. g (f x) = g x\"\n  and P: \"\\<And> x. P (f x) = P x\" \nshows \"map g (filter_list_length f p n xs) = map g (filter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map g (filter_list_length f p n xs) = map g (filter P xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map g (filter_list_length f p n xs) = map g (filter P xs)", "from assms(3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set xs; \\<not> P ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i. \\<not> p ((f ^^ i) ?x)", "have \"\\<forall> x. \\<exists> i. x \\<in> set xs \\<longrightarrow> \\<not> P x \\<longrightarrow> \\<not> p ((f ^^ i) x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs; \\<not> P ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i. \\<not> p ((f ^^ i) ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>i.\n          x \\<in> set xs \\<longrightarrow>\n          \\<not> P x \\<longrightarrow> \\<not> p ((f ^^ i) x)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     \\<exists>i.\n        x \\<in> set xs \\<longrightarrow>\n        \\<not> P x \\<longrightarrow> \\<not> p ((f ^^ i) x)\n\ngoal (1 subgoal):\n 1. map g (filter_list_length f p n xs) = map g (filter P xs)", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>fa.\n     \\<forall>x.\n        x \\<in> set xs \\<longrightarrow>\n        \\<not> P x \\<longrightarrow> \\<not> p ((f ^^ fa x) x)", "obtain i where i: \"\\<And> x. x \\<in> set xs \\<Longrightarrow> \\<not> P x \\<Longrightarrow> \\<not> p ((f ^^ (i x)) x)\""], ["proof (prove)\nusing this:\n  \\<exists>fa.\n     \\<forall>x.\n        x \\<in> set xs \\<longrightarrow>\n        \\<not> P x \\<longrightarrow> \\<not> p ((f ^^ fa x) x)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        (\\<And>x.\n            \\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n            \\<Longrightarrow> \\<not> p ((f ^^ i x) x)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set xs; \\<not> P ?x\\<rbrakk>\n  \\<Longrightarrow> \\<not> p ((f ^^ i ?x) ?x)\n\ngoal (1 subgoal):\n 1. map g (filter_list_length f p n xs) = map g (filter P xs)", "define m where \"m = max_list (map i xs)\""], ["proof (state)\nthis:\n  m = max_list (map i xs)\n\ngoal (1 subgoal):\n 1. map g (filter_list_length f p n xs) = map g (filter P xs)", "have m: \"\\<And> x. x \\<in> set xs \\<Longrightarrow> \\<not> P x \\<Longrightarrow> \\<exists> i \\<le> m. \\<not> p ((f ^^ i) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>m. \\<not> p ((f ^^ i) x)", "using max_list[of _ \"map i xs\", folded m_def] i"], ["proof (prove)\nusing this:\n  ?x \\<in> set (map i xs) \\<Longrightarrow> ?x \\<le> m\n  \\<lbrakk>?x \\<in> set xs; \\<not> P ?x\\<rbrakk>\n  \\<Longrightarrow> \\<not> p ((f ^^ i ?x) ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>m. \\<not> p ((f ^^ i) x)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set xs; \\<not> P ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i\\<le>m. \\<not> p ((f ^^ i) ?x)\n\ngoal (1 subgoal):\n 1. map g (filter_list_length f p n xs) = map g (filter P xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map g (filter_list_length f p n xs) = map g (filter P xs)", "using assms(1-2) m"], ["proof (prove)\nusing this:\n  length (filter P xs) = n\n  \\<lbrakk>?x \\<in> set xs; P ?x\\<rbrakk> \\<Longrightarrow> p ((f ^^ ?i) ?x)\n  \\<lbrakk>?x \\<in> set xs; \\<not> P ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i\\<le>m. \\<not> p ((f ^^ i) ?x)\n\ngoal (1 subgoal):\n 1. map g (filter_list_length f p n xs) = map g (filter P xs)", "proof (induct m arbitrary: xs rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x; length (filter P xs) = n;\n                    \\<And>x i.\n                       \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                       \\<Longrightarrow> p ((f ^^ i) x);\n                    \\<And>x.\n                       \\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>i\\<le>y.\n      \\<not> p ((f ^^ i) x)\\<rbrakk>\n                   \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                                     map g (filter P xs);\n        length (filter P xs) = n;\n        \\<And>x i.\n           \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n           \\<Longrightarrow> p ((f ^^ i) x);\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set xs; \\<not> P xa\\<rbrakk>\n           \\<Longrightarrow> \\<exists>i\\<le>x.\n                                \\<not> p ((f ^^ i) xa)\\<rbrakk>\n       \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                         map g (filter P xs)", "case (less m xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < m; length (filter P ?xs) = n;\n   \\<And>x i.\n      \\<lbrakk>x \\<in> set ?xs; P x\\<rbrakk>\n      \\<Longrightarrow> p ((f ^^ i) x);\n   \\<And>x.\n      \\<lbrakk>x \\<in> set ?xs; \\<not> P x\\<rbrakk>\n      \\<Longrightarrow> \\<exists>i\\<le>?y. \\<not> p ((f ^^ i) x)\\<rbrakk>\n  \\<Longrightarrow> map g (filter_list_length f p n ?xs) =\n                    map g (filter P ?xs)\n  length (filter P xs) = n\n  \\<lbrakk>?x \\<in> set xs; P ?x\\<rbrakk> \\<Longrightarrow> p ((f ^^ ?i) ?x)\n  \\<lbrakk>?x \\<in> set xs; \\<not> P ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i\\<le>m. \\<not> p ((f ^^ i) ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x; length (filter P xs) = n;\n                    \\<And>x i.\n                       \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                       \\<Longrightarrow> p ((f ^^ i) x);\n                    \\<And>x.\n                       \\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>i\\<le>y.\n      \\<not> p ((f ^^ i) x)\\<rbrakk>\n                   \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                                     map g (filter P xs);\n        length (filter P xs) = n;\n        \\<And>x i.\n           \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n           \\<Longrightarrow> p ((f ^^ i) x);\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set xs; \\<not> P xa\\<rbrakk>\n           \\<Longrightarrow> \\<exists>i\\<le>x.\n                                \\<not> p ((f ^^ i) xa)\\<rbrakk>\n       \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                         map g (filter P xs)", "define ys where \"ys = filter p xs\""], ["proof (state)\nthis:\n  ys = filter p xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x; length (filter P xs) = n;\n                    \\<And>x i.\n                       \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                       \\<Longrightarrow> p ((f ^^ i) x);\n                    \\<And>x.\n                       \\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>i\\<le>y.\n      \\<not> p ((f ^^ i) x)\\<rbrakk>\n                   \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                                     map g (filter P xs);\n        length (filter P xs) = n;\n        \\<And>x i.\n           \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n           \\<Longrightarrow> p ((f ^^ i) x);\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set xs; \\<not> P xa\\<rbrakk>\n           \\<Longrightarrow> \\<exists>i\\<le>x.\n                                \\<not> p ((f ^^ i) xa)\\<rbrakk>\n       \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                         map g (filter P xs)", "have xs_ys: \"filter P xs = filter P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P xs = filter P ys", "unfolding ys_def filter_filter"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter P xs = filter (\\<lambda>x. p x \\<and> P x) xs", "by (rule filter_cong[OF refl], insert less(3)[of _ 0], auto)"], ["proof (state)\nthis:\n  filter P xs = filter P ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x; length (filter P xs) = n;\n                    \\<And>x i.\n                       \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                       \\<Longrightarrow> p ((f ^^ i) x);\n                    \\<And>x.\n                       \\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>i\\<le>y.\n      \\<not> p ((f ^^ i) x)\\<rbrakk>\n                   \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                                     map g (filter P xs);\n        length (filter P xs) = n;\n        \\<And>x i.\n           \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n           \\<Longrightarrow> p ((f ^^ i) x);\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set xs; \\<not> P xa\\<rbrakk>\n           \\<Longrightarrow> \\<exists>i\\<le>x.\n                                \\<not> p ((f ^^ i) xa)\\<rbrakk>\n       \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                         map g (filter P xs)", "have \"filter (P \\<circ> f) ys = filter P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (P \\<circ> f) ys = filter P ys", "using P"], ["proof (prove)\nusing this:\n  P (f ?x) = P ?x\n\ngoal (1 subgoal):\n 1. filter (P \\<circ> f) ys = filter P ys", "unfolding o_def"], ["proof (prove)\nusing this:\n  P (f ?x) = P ?x\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. P (f x)) ys = filter P ys", "by auto"], ["proof (state)\nthis:\n  filter (P \\<circ> f) ys = filter P ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x; length (filter P xs) = n;\n                    \\<And>x i.\n                       \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                       \\<Longrightarrow> p ((f ^^ i) x);\n                    \\<And>x.\n                       \\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>i\\<le>y.\n      \\<not> p ((f ^^ i) x)\\<rbrakk>\n                   \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                                     map g (filter P xs);\n        length (filter P xs) = n;\n        \\<And>x i.\n           \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n           \\<Longrightarrow> p ((f ^^ i) x);\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set xs; \\<not> P xa\\<rbrakk>\n           \\<Longrightarrow> \\<exists>i\\<le>x.\n                                \\<not> p ((f ^^ i) xa)\\<rbrakk>\n       \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                         map g (filter P xs)", "hence id3: \"filter P (map f ys) = map f (filter P ys)\""], ["proof (prove)\nusing this:\n  filter (P \\<circ> f) ys = filter P ys\n\ngoal (1 subgoal):\n 1. filter P (map f ys) = map f (filter P ys)", "unfolding filter_map"], ["proof (prove)\nusing this:\n  filter (P \\<circ> f) ys = filter P ys\n\ngoal (1 subgoal):\n 1. map f (filter (P \\<circ> f) ys) = map f (filter P ys)", "by simp"], ["proof (state)\nthis:\n  filter P (map f ys) = map f (filter P ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x; length (filter P xs) = n;\n                    \\<And>x i.\n                       \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                       \\<Longrightarrow> p ((f ^^ i) x);\n                    \\<And>x.\n                       \\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>i\\<le>y.\n      \\<not> p ((f ^^ i) x)\\<rbrakk>\n                   \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                                     map g (filter P xs);\n        length (filter P xs) = n;\n        \\<And>x i.\n           \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n           \\<Longrightarrow> p ((f ^^ i) x);\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set xs; \\<not> P xa\\<rbrakk>\n           \\<Longrightarrow> \\<exists>i\\<le>x.\n                                \\<not> p ((f ^^ i) xa)\\<rbrakk>\n       \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                         map g (filter P xs)", "hence id2: \"map g (filter P (map f ys)) = map g (filter P ys)\""], ["proof (prove)\nusing this:\n  filter P (map f ys) = map f (filter P ys)\n\ngoal (1 subgoal):\n 1. map g (filter P (map f ys)) = map g (filter P ys)", "by (simp add: g)"], ["proof (state)\nthis:\n  map g (filter P (map f ys)) = map g (filter P ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x; length (filter P xs) = n;\n                    \\<And>x i.\n                       \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n                       \\<Longrightarrow> p ((f ^^ i) x);\n                    \\<And>x.\n                       \\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n                       \\<Longrightarrow> \\<exists>i\\<le>y.\n      \\<not> p ((f ^^ i) x)\\<rbrakk>\n                   \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                                     map g (filter P xs);\n        length (filter P xs) = n;\n        \\<And>x i.\n           \\<lbrakk>x \\<in> set xs; P x\\<rbrakk>\n           \\<Longrightarrow> p ((f ^^ i) x);\n        \\<And>xa.\n           \\<lbrakk>xa \\<in> set xs; \\<not> P xa\\<rbrakk>\n           \\<Longrightarrow> \\<exists>i\\<le>x.\n                                \\<not> p ((f ^^ i) xa)\\<rbrakk>\n       \\<Longrightarrow> map g (filter_list_length f p n xs) =\n                         map g (filter P xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map g (filter_list_length f p n xs) = map g (filter P xs)", "proof (cases \"length ys = n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length ys = n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)\n 2. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "case True"], ["proof (state)\nthis:\n  length ys = n\n\ngoal (2 subgoals):\n 1. length ys = n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)\n 2. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "hence id: \"filter_list_length f p n xs = ys\""], ["proof (prove)\nusing this:\n  length ys = n\n\ngoal (1 subgoal):\n 1. filter_list_length f p n xs = ys", "unfolding ys_def \n        filter_list_length.simps[of _ _ _ xs] Let_def"], ["proof (prove)\nusing this:\n  length (filter p xs) = n\n\ngoal (1 subgoal):\n 1. (if length (filter p xs) = n then filter p xs\n     else filter_list_length f p n (map f (filter p xs))) =\n    filter p xs", "by auto"], ["proof (state)\nthis:\n  filter_list_length f p n xs = ys\n\ngoal (2 subgoals):\n 1. length ys = n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)\n 2. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map g (filter_list_length f p n xs) = map g (filter P xs)", "using True"], ["proof (prove)\nusing this:\n  length ys = n\n\ngoal (1 subgoal):\n 1. map g (filter_list_length f p n xs) = map g (filter P xs)", "unfolding id xs_ys"], ["proof (prove)\nusing this:\n  length ys = n\n\ngoal (1 subgoal):\n 1. map g ys = map g (filter P ys)", "using less(2)"], ["proof (prove)\nusing this:\n  length ys = n\n  length (filter P xs) = n\n\ngoal (1 subgoal):\n 1. map g ys = map g (filter P ys)", "by (metis filter_id_conv length_filter_less less_le xs_ys)"], ["proof (state)\nthis:\n  map g (filter_list_length f p n xs) = map g (filter P xs)\n\ngoal (1 subgoal):\n 1. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "case False"], ["proof (state)\nthis:\n  length ys \\<noteq> n\n\ngoal (1 subgoal):\n 1. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "{"], ["proof (state)\nthis:\n  length ys \\<noteq> n\n\ngoal (1 subgoal):\n 1. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "assume \"m = 0\""], ["proof (state)\nthis:\n  m = 0\n\ngoal (1 subgoal):\n 1. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "from less(4)[unfolded this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set xs; \\<not> P ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i\\<le>0. \\<not> p ((f ^^ i) ?x)", "have Pp: \"x \\<in> set xs \\<Longrightarrow> \\<not> P x \\<Longrightarrow> \\<not> p x\" for x"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set xs; \\<not> P ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i\\<le>0. \\<not> p ((f ^^ i) ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; \\<not> P x\\<rbrakk>\n    \\<Longrightarrow> \\<not> p x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set xs; \\<not> P ?x\\<rbrakk>\n  \\<Longrightarrow> \\<not> p ?x\n\ngoal (1 subgoal):\n 1. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "with xs_ys False[folded less(2)]"], ["proof (chain)\npicking this:\n  filter P xs = filter P ys\n  length ys \\<noteq> length (filter P xs)\n  \\<lbrakk>?x \\<in> set xs; \\<not> P ?x\\<rbrakk>\n  \\<Longrightarrow> \\<not> p ?x", "have False"], ["proof (prove)\nusing this:\n  filter P xs = filter P ys\n  length ys \\<noteq> length (filter P xs)\n  \\<lbrakk>?x \\<in> set xs; \\<not> P ?x\\<rbrakk>\n  \\<Longrightarrow> \\<not> p ?x\n\ngoal (1 subgoal):\n 1. False", "by (metis (mono_tags, lifting) filter_True mem_Collect_eq set_filter ys_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "}"], ["proof (state)\nthis:\n  m = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "note m0 = this"], ["proof (state)\nthis:\n  m = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "then"], ["proof (chain)\npicking this:\n  m = 0 \\<Longrightarrow> False", "obtain M where mM: \"m = Suc M\""], ["proof (prove)\nusing this:\n  m = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<And>M. m = Suc M \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases m, auto)"], ["proof (state)\nthis:\n  m = Suc M\n\ngoal (1 subgoal):\n 1. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "hence m: \"M < m\""], ["proof (prove)\nusing this:\n  m = Suc M\n\ngoal (1 subgoal):\n 1. M < m", "by simp"], ["proof (state)\nthis:\n  M < m\n\ngoal (1 subgoal):\n 1. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "from False"], ["proof (chain)\npicking this:\n  length ys \\<noteq> n", "have id: \"filter_list_length f p n xs = filter_list_length f p n (map f ys)\""], ["proof (prove)\nusing this:\n  length ys \\<noteq> n\n\ngoal (1 subgoal):\n 1. filter_list_length f p n xs = filter_list_length f p n (map f ys)", "unfolding ys_def filter_list_length.simps[of _ _ _ xs] Let_def"], ["proof (prove)\nusing this:\n  length (filter p xs) \\<noteq> n\n\ngoal (1 subgoal):\n 1. (if length (filter p xs) = n then filter p xs\n     else filter_list_length f p n (map f (filter p xs))) =\n    filter_list_length f p n (map f (filter p xs))", "by auto"], ["proof (state)\nthis:\n  filter_list_length f p n xs = filter_list_length f p n (map f ys)\n\ngoal (1 subgoal):\n 1. length ys \\<noteq> n \\<Longrightarrow>\n    map g (filter_list_length f p n xs) = map g (filter P xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map g (filter_list_length f p n xs) = map g (filter P xs)", "unfolding id xs_ys id2[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map g (filter_list_length f p n (map f ys)) =\n    map g (filter P (map f ys))", "proof (rule less(1)[OF m])"], ["proof (state)\ngoal (3 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (map f ys); \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>M. \\<not> p ((f ^^ i) x)", "fix y"], ["proof (state)\ngoal (3 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (map f ys); \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>M. \\<not> p ((f ^^ i) x)", "assume \"y \\<in> set (map f ys)\""], ["proof (state)\nthis:\n  y \\<in> set (map f ys)\n\ngoal (3 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (map f ys); \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>M. \\<not> p ((f ^^ i) x)", "then"], ["proof (chain)\npicking this:\n  y \\<in> set (map f ys)", "obtain x where x: \"x \\<in> set xs\" \"p x\" and y: \"y = f x\""], ["proof (prove)\nusing this:\n  y \\<in> set (map f ys)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set xs; p x; y = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ys_def"], ["proof (prove)\nusing this:\n  y \\<in> set (map f (filter p xs))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set xs; p x; y = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> set xs\n  p x\n  y = f x\n\ngoal (3 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (map f ys); \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>M. \\<not> p ((f ^^ i) x)", "{"], ["proof (state)\nthis:\n  x \\<in> set xs\n  p x\n  y = f x\n\ngoal (3 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (map f ys); \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>M. \\<not> p ((f ^^ i) x)", "assume \"\\<not> P y\""], ["proof (state)\nthis:\n  \\<not> P y\n\ngoal (3 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (map f ys); \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>M. \\<not> p ((f ^^ i) x)", "hence \"\\<not> P x\""], ["proof (prove)\nusing this:\n  \\<not> P y\n\ngoal (1 subgoal):\n 1. \\<not> P x", "unfolding y P"], ["proof (prove)\nusing this:\n  \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<not> P x", "."], ["proof (state)\nthis:\n  \\<not> P x\n\ngoal (3 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (map f ys); \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>M. \\<not> p ((f ^^ i) x)", "from less(4)[OF x(1) this]"], ["proof (chain)\npicking this:\n  \\<exists>i\\<le>m. \\<not> p ((f ^^ i) x)", "obtain i where i: \"i \\<le> m\" and p: \"\\<not> p ((f ^^ i) x)\""], ["proof (prove)\nusing this:\n  \\<exists>i\\<le>m. \\<not> p ((f ^^ i) x)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<le> m; \\<not> p ((f ^^ i) x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<le> m\n  \\<not> p ((f ^^ i) x)\n\ngoal (3 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (map f ys); \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>M. \\<not> p ((f ^^ i) x)", "with x"], ["proof (chain)\npicking this:\n  x \\<in> set xs\n  p x\n  i \\<le> m\n  \\<not> p ((f ^^ i) x)", "obtain j where ij: \"i = Suc j\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  p x\n  i \\<le> m\n  \\<not> p ((f ^^ i) x)\n\ngoal (1 subgoal):\n 1. (\\<And>j. i = Suc j \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases i, auto)"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (3 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (map f ys); \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>M. \\<not> p ((f ^^ i) x)", "with i"], ["proof (chain)\npicking this:\n  i \\<le> m\n  i = Suc j", "have j: \"j \\<le> M\""], ["proof (prove)\nusing this:\n  i \\<le> m\n  i = Suc j\n\ngoal (1 subgoal):\n 1. j \\<le> M", "unfolding mM"], ["proof (prove)\nusing this:\n  i \\<le> Suc M\n  i = Suc j\n\ngoal (1 subgoal):\n 1. j \\<le> M", "by auto"], ["proof (state)\nthis:\n  j \\<le> M\n\ngoal (3 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (map f ys); \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>M. \\<not> p ((f ^^ i) x)", "have \"\\<not> p ((f ^^ j) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p ((f ^^ j) y)", "using p"], ["proof (prove)\nusing this:\n  \\<not> p ((f ^^ i) x)\n\ngoal (1 subgoal):\n 1. \\<not> p ((f ^^ j) y)", "unfolding ij y funpow_Suc_right"], ["proof (prove)\nusing this:\n  \\<not> p ((f ^^ j \\<circ> f) x)\n\ngoal (1 subgoal):\n 1. \\<not> p ((f ^^ j) (f x))", "by simp"], ["proof (state)\nthis:\n  \\<not> p ((f ^^ j) y)\n\ngoal (3 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (map f ys); \\<not> P x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>M. \\<not> p ((f ^^ i) x)", "thus \"\\<exists>i\\<le> M. \\<not> p ((f ^^ i) y)\""], ["proof (prove)\nusing this:\n  \\<not> p ((f ^^ j) y)\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>M. \\<not> p ((f ^^ i) y)", "using j"], ["proof (prove)\nusing this:\n  \\<not> p ((f ^^ j) y)\n  j \\<le> M\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>M. \\<not> p ((f ^^ i) y)", "by auto"], ["proof (state)\nthis:\n  \\<exists>i\\<le>M. \\<not> p ((f ^^ i) y)\n\ngoal (2 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)", "}"], ["proof (state)\nthis:\n  \\<not> P y \\<Longrightarrow> \\<exists>i\\<le>M. \\<not> p ((f ^^ i) y)\n\ngoal (2 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)", "{"], ["proof (state)\nthis:\n  \\<not> P y \\<Longrightarrow> \\<exists>i\\<le>M. \\<not> p ((f ^^ i) y)\n\ngoal (2 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)", "assume \"P y\""], ["proof (state)\nthis:\n  P y\n\ngoal (2 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)", "hence \"P x\""], ["proof (prove)\nusing this:\n  P y\n\ngoal (1 subgoal):\n 1. P x", "unfolding y P"], ["proof (prove)\nusing this:\n  P x\n\ngoal (1 subgoal):\n 1. P x", "."], ["proof (state)\nthis:\n  P x\n\ngoal (2 subgoals):\n 1. length (filter P (map f ys)) = n\n 2. \\<And>x i.\n       \\<lbrakk>x \\<in> set (map f ys); P x\\<rbrakk>\n       \\<Longrightarrow> p ((f ^^ i) x)", "from less(3)[OF x(1) this, of \"Suc i\"]"], ["proof (chain)\npicking this:\n  p ((f ^^ Suc i) x)", "show \"p ((f ^^ i) y)\""], ["proof (prove)\nusing this:\n  p ((f ^^ Suc i) x)\n\ngoal (1 subgoal):\n 1. p ((f ^^ i) y)", "unfolding y funpow_Suc_right"], ["proof (prove)\nusing this:\n  p ((f ^^ i \\<circ> f) x)\n\ngoal (1 subgoal):\n 1. p ((f ^^ i) (f x))", "by simp"], ["proof (state)\nthis:\n  p ((f ^^ i) y)\n\ngoal (1 subgoal):\n 1. length (filter P (map f ys)) = n", "}"], ["proof (state)\nthis:\n  P y \\<Longrightarrow> p ((f ^^ ?ia2) y)\n\ngoal (1 subgoal):\n 1. length (filter P (map f ys)) = n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter P (map f ys)) = n", "show \"length (filter P (map f ys)) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter P (map f ys)) = n", "unfolding id3 length_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter P ys) = n", "using xs_ys less(2)"], ["proof (prove)\nusing this:\n  filter P xs = filter P ys\n  length (filter P xs) = n\n\ngoal (1 subgoal):\n 1. length (filter P ys) = n", "by auto"], ["proof (state)\nthis:\n  length (filter P (map f ys)) = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map g (filter_list_length f p n xs) = map g (filter P xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map g (filter_list_length f p n xs) = map g (filter P xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map g (filter_list_length f p n xs) = map g (filter P xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition complex_roots_of_int_poly3 :: \"int poly \\<Rightarrow> complex list\" where\n  \"complex_roots_of_int_poly3 p \\<equiv> let n = degree p; \n    rrts = real_roots_of_int_poly p;\n    nr = length rrts; \n    crts = map (\\<lambda> r. Complex r 0) rrts\n    in \n    if n = nr then crts \n    else let nr_crts = n - nr in if nr_crts = 2 then \n    let pp = real_of_int_poly p div (prod_list (map (\\<lambda> x. [:-x,1:]) rrts));\n        cpp = map_poly (\\<lambda> r. Complex r 0) pp\n      in crts @ croots2 cpp else\n    let\n        nr_pos_crts = nr_crts div 2;\n        rxs = real_parts_3 p;\n        ixs = pos_imaginary_parts_3 p;\n        rts = [(rx, ix). rx <- rxs, ix <- ixs];\n        crts' = map pair_to_complex \n           (filter_list_length (map_prod tighten_bounds_3 tighten_bounds_3) \n              (\\<lambda> (r, i). 0 \\<in>\\<^sub>c ipoly_complex_interval p (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))) nr_pos_crts rts)\n    in crts @ (concat (map (\\<lambda> x. [x, cnj x]) crts'))\""], ["", "definition complex_roots_of_int_poly_all :: \"int poly \\<Rightarrow> complex list\" where\n  \"complex_roots_of_int_poly_all p = (let n = degree p in \n    if n \\<ge> 3 then complex_roots_of_int_poly3 p\n    else if n = 1 then [roots1 (map_poly of_int p)] else if n = 2 then croots2 (map_poly of_int p)\n    else [])\""], ["", "lemma in_real_itvl_get_bounds_tighten: \"real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ n) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ n) x)", "proof (induct n arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ 0) x)\n 2. \\<And>n x.\n       (\\<And>x.\n           real_of_3 x\n           \\<in>\\<^sub>i get_itvl_3\n                          ((tighten_bounds_3 ^^ n) x)) \\<Longrightarrow>\n       real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ Suc n) x)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ 0) x)\n 2. \\<And>n x.\n       (\\<And>x.\n           real_of_3 x\n           \\<in>\\<^sub>i get_itvl_3\n                          ((tighten_bounds_3 ^^ n) x)) \\<Longrightarrow>\n       real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ Suc n) x)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ 0) x)", "using get_itvl_3[of x]"], ["proof (prove)\nusing this:\n  real_of_3 x \\<in>\\<^sub>i get_itvl_3 x\n\ngoal (1 subgoal):\n 1. real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ 0) x)", "by simp"], ["proof (state)\nthis:\n  real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ 0) x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           real_of_3 x\n           \\<in>\\<^sub>i get_itvl_3\n                          ((tighten_bounds_3 ^^ n) x)) \\<Longrightarrow>\n       real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ Suc n) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           real_of_3 x\n           \\<in>\\<^sub>i get_itvl_3\n                          ((tighten_bounds_3 ^^ n) x)) \\<Longrightarrow>\n       real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ Suc n) x)", "case (Suc n x)"], ["proof (state)\nthis:\n  real_of_3 ?x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ n) ?x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           real_of_3 x\n           \\<in>\\<^sub>i get_itvl_3\n                          ((tighten_bounds_3 ^^ n) x)) \\<Longrightarrow>\n       real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ Suc n) x)", "have id: \"(tighten_bounds_3 ^^ (Suc n)) x = (tighten_bounds_3 ^^ n) (tighten_bounds_3 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tighten_bounds_3 ^^ Suc n) x =\n    (tighten_bounds_3 ^^ n) (tighten_bounds_3 x)", "by (metis comp_apply funpow_Suc_right)"], ["proof (state)\nthis:\n  (tighten_bounds_3 ^^ Suc n) x =\n  (tighten_bounds_3 ^^ n) (tighten_bounds_3 x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           real_of_3 x\n           \\<in>\\<^sub>i get_itvl_3\n                          ((tighten_bounds_3 ^^ n) x)) \\<Longrightarrow>\n       real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ Suc n) x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ Suc n) x)", "unfolding id tighten_bounds_3(1)[of x, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 (tighten_bounds_3 x)\n    \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ n) (tighten_bounds_3 x))", "by (rule Suc)"], ["proof (state)\nthis:\n  real_of_3 x \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ Suc n) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sandwitch_real:\n fixes l r :: \"nat \\<Rightarrow> real\"\n assumes la: \"l \\<longlonglongrightarrow> a\" and ra: \"r \\<longlonglongrightarrow> a\"\n and lm: \"\\<And>i. l i \\<le> m i\" and mr: \"\\<And>i. m i \\<le> r i\"\nshows \"m \\<longlonglongrightarrow> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<longlonglongrightarrow> a", "proof (rule LIMSEQ_I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no. \\<forall>n\\<ge>no. norm (m n - a) < r", "fix e :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no. \\<forall>n\\<ge>no. norm (m n - a) < r", "assume \"0 < e\""], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no. \\<forall>n\\<ge>no. norm (m n - a) < r", "hence e: \"0 < e / 2\""], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. 0 < e / 2", "by simp"], ["proof (state)\nthis:\n  0 < e / 2\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no. \\<forall>n\\<ge>no. norm (m n - a) < r", "from LIMSEQ_D[OF la e]"], ["proof (chain)\npicking this:\n  \\<exists>no. \\<forall>n\\<ge>no. norm (l n - a) < e / 2", "obtain n1 where n1: \"\\<And> n. n \\<ge> n1 \\<Longrightarrow> norm (l n - a) < e/2\""], ["proof (prove)\nusing this:\n  \\<exists>no. \\<forall>n\\<ge>no. norm (l n - a) < e / 2\n\ngoal (1 subgoal):\n 1. (\\<And>n1.\n        (\\<And>n.\n            n1 \\<le> n \\<Longrightarrow>\n            norm (l n - a) < e / 2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n1 \\<le> ?n \\<Longrightarrow> norm (l ?n - a) < e / 2\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no. \\<forall>n\\<ge>no. norm (m n - a) < r", "from LIMSEQ_D[OF ra e]"], ["proof (chain)\npicking this:\n  \\<exists>no. \\<forall>n\\<ge>no. norm (r n - a) < e / 2", "obtain n2 where n2: \"\\<And> n. n \\<ge> n2 \\<Longrightarrow> norm (r n - a) < e/2\""], ["proof (prove)\nusing this:\n  \\<exists>no. \\<forall>n\\<ge>no. norm (r n - a) < e / 2\n\ngoal (1 subgoal):\n 1. (\\<And>n2.\n        (\\<And>n.\n            n2 \\<le> n \\<Longrightarrow>\n            norm (r n - a) < e / 2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n2 \\<le> ?n \\<Longrightarrow> norm (r ?n - a) < e / 2\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no. \\<forall>n\\<ge>no. norm (m n - a) < r", "show \"\\<exists>no. \\<forall>n\\<ge>no. norm (m n - a) < e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>no. \\<forall>n\\<ge>no. norm (m n - a) < e", "proof (rule exI[of _ \"max n1 n2\"], intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. max n1 n2 \\<le> n \\<Longrightarrow> norm (m n - a) < e", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. max n1 n2 \\<le> n \\<Longrightarrow> norm (m n - a) < e", "assume \"max n1 n2 \\<le> n\""], ["proof (state)\nthis:\n  max n1 n2 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>n. max n1 n2 \\<le> n \\<Longrightarrow> norm (m n - a) < e", "with n1 n2"], ["proof (chain)\npicking this:\n  n1 \\<le> ?n \\<Longrightarrow> norm (l ?n - a) < e / 2\n  n2 \\<le> ?n \\<Longrightarrow> norm (r ?n - a) < e / 2\n  max n1 n2 \\<le> n", "have *: \"norm (l n - a) < e/2\" \"norm (r n - a) < e/2\""], ["proof (prove)\nusing this:\n  n1 \\<le> ?n \\<Longrightarrow> norm (l ?n - a) < e / 2\n  n2 \\<le> ?n \\<Longrightarrow> norm (r ?n - a) < e / 2\n  max n1 n2 \\<le> n\n\ngoal (1 subgoal):\n 1. norm (l n - a) < e / 2 &&& norm (r n - a) < e / 2", "by auto"], ["proof (state)\nthis:\n  norm (l n - a) < e / 2\n  norm (r n - a) < e / 2\n\ngoal (1 subgoal):\n 1. \\<And>n. max n1 n2 \\<le> n \\<Longrightarrow> norm (m n - a) < e", "from lm[of n] mr[of n]"], ["proof (chain)\npicking this:\n  l n \\<le> m n\n  m n \\<le> r n", "have \"norm (m n - a) \\<le> norm (l n - a) + norm (r n - a)\""], ["proof (prove)\nusing this:\n  l n \\<le> m n\n  m n \\<le> r n\n\ngoal (1 subgoal):\n 1. norm (m n - a) \\<le> norm (l n - a) + norm (r n - a)", "by simp"], ["proof (state)\nthis:\n  norm (m n - a) \\<le> norm (l n - a) + norm (r n - a)\n\ngoal (1 subgoal):\n 1. \\<And>n. max n1 n2 \\<le> n \\<Longrightarrow> norm (m n - a) < e", "with *"], ["proof (chain)\npicking this:\n  norm (l n - a) < e / 2\n  norm (r n - a) < e / 2\n  norm (m n - a) \\<le> norm (l n - a) + norm (r n - a)", "show \"norm (m n - a) < e\""], ["proof (prove)\nusing this:\n  norm (l n - a) < e / 2\n  norm (r n - a) < e / 2\n  norm (m n - a) \\<le> norm (l n - a) + norm (r n - a)\n\ngoal (1 subgoal):\n 1. norm (m n - a) < e", "by auto"], ["proof (state)\nthis:\n  norm (m n - a) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>no. \\<forall>n\\<ge>no. norm (m n - a) < e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma real_of_tighten_bounds_many[simp]: \"real_of_3 ((tighten_bounds_3 ^^ i) x) = real_of_3 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_3 ((tighten_bounds_3 ^^ i) x) = real_of_3 x", "apply (induct i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. real_of_3 ((tighten_bounds_3 ^^ 0) x) = real_of_3 x\n 2. \\<And>i.\n       real_of_3 ((tighten_bounds_3 ^^ i) x) = real_of_3 x \\<Longrightarrow>\n       real_of_3 ((tighten_bounds_3 ^^ Suc i) x) = real_of_3 x", "using tighten_bounds_3"], ["proof (prove)\nusing this:\n  real_of_3 (tighten_bounds_3 ?x) = real_of_3 ?x\n  \\<lbrakk>get_itvl_3 ?x = Interval ?l ?r;\n   get_itvl_3 (tighten_bounds_3 ?x) = Interval ?l' ?r'\\<rbrakk>\n  \\<Longrightarrow> ?r' - ?l' = (?r - ?l) / 2\n\ngoal (2 subgoals):\n 1. real_of_3 ((tighten_bounds_3 ^^ 0) x) = real_of_3 x\n 2. \\<And>i.\n       real_of_3 ((tighten_bounds_3 ^^ i) x) = real_of_3 x \\<Longrightarrow>\n       real_of_3 ((tighten_bounds_3 ^^ Suc i) x) = real_of_3 x", "by auto"], ["", "definition lower_3 where \"lower_3 x i \\<equiv> interval.lower (get_itvl_3 ((tighten_bounds_3 ^^ i) x))\""], ["", "definition upper_3 where \"upper_3 x i \\<equiv> interval.upper (get_itvl_3 ((tighten_bounds_3 ^^ i) x))\""], ["", "lemma interval_size_3: \"upper_3 x i - lower_3 x i = (upper_3 x 0 - lower_3 x 0)/2^i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_3 x i - lower_3 x i = (upper_3 x 0 - lower_3 x 0) / 2 ^ i", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. upper_3 x 0 - lower_3 x 0 = (upper_3 x 0 - lower_3 x 0) / 2 ^ 0\n 2. \\<And>i.\n       upper_3 x i - lower_3 x i =\n       (upper_3 x 0 - lower_3 x 0) / 2 ^ i \\<Longrightarrow>\n       upper_3 x (Suc i) - lower_3 x (Suc i) =\n       (upper_3 x 0 - lower_3 x 0) / 2 ^ Suc i", "case (Suc i)"], ["proof (state)\nthis:\n  upper_3 x i - lower_3 x i = (upper_3 x 0 - lower_3 x 0) / 2 ^ i\n\ngoal (2 subgoals):\n 1. upper_3 x 0 - lower_3 x 0 = (upper_3 x 0 - lower_3 x 0) / 2 ^ 0\n 2. \\<And>i.\n       upper_3 x i - lower_3 x i =\n       (upper_3 x 0 - lower_3 x 0) / 2 ^ i \\<Longrightarrow>\n       upper_3 x (Suc i) - lower_3 x (Suc i) =\n       (upper_3 x 0 - lower_3 x 0) / 2 ^ Suc i", "have \"upper_3 x (Suc i) - lower_3 x (Suc i) = (upper_3 x i - lower_3 x i) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_3 x (Suc i) - lower_3 x (Suc i) = (upper_3 x i - lower_3 x i) / 2", "unfolding upper_3_def lower_3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interval.upper (get_itvl_3 ((tighten_bounds_3 ^^ Suc i) x)) -\n    interval.lower (get_itvl_3 ((tighten_bounds_3 ^^ Suc i) x)) =\n    (interval.upper (get_itvl_3 ((tighten_bounds_3 ^^ i) x)) -\n     interval.lower (get_itvl_3 ((tighten_bounds_3 ^^ i) x))) /\n    2", "using tighten_bounds_3 get_itvl_3"], ["proof (prove)\nusing this:\n  real_of_3 (tighten_bounds_3 ?x) = real_of_3 ?x\n  \\<lbrakk>get_itvl_3 ?x = Interval ?l ?r;\n   get_itvl_3 (tighten_bounds_3 ?x) = Interval ?l' ?r'\\<rbrakk>\n  \\<Longrightarrow> ?r' - ?l' = (?r - ?l) / 2\n  real_of_3 ?x \\<in>\\<^sub>i get_itvl_3 ?x\n\ngoal (1 subgoal):\n 1. interval.upper (get_itvl_3 ((tighten_bounds_3 ^^ Suc i) x)) -\n    interval.lower (get_itvl_3 ((tighten_bounds_3 ^^ Suc i) x)) =\n    (interval.upper (get_itvl_3 ((tighten_bounds_3 ^^ i) x)) -\n     interval.lower (get_itvl_3 ((tighten_bounds_3 ^^ i) x))) /\n    2", "by auto"], ["proof (state)\nthis:\n  upper_3 x (Suc i) - lower_3 x (Suc i) = (upper_3 x i - lower_3 x i) / 2\n\ngoal (2 subgoals):\n 1. upper_3 x 0 - lower_3 x 0 = (upper_3 x 0 - lower_3 x 0) / 2 ^ 0\n 2. \\<And>i.\n       upper_3 x i - lower_3 x i =\n       (upper_3 x 0 - lower_3 x 0) / 2 ^ i \\<Longrightarrow>\n       upper_3 x (Suc i) - lower_3 x (Suc i) =\n       (upper_3 x 0 - lower_3 x 0) / 2 ^ Suc i", "with Suc"], ["proof (chain)\npicking this:\n  upper_3 x i - lower_3 x i = (upper_3 x 0 - lower_3 x 0) / 2 ^ i\n  upper_3 x (Suc i) - lower_3 x (Suc i) = (upper_3 x i - lower_3 x i) / 2", "show ?case"], ["proof (prove)\nusing this:\n  upper_3 x i - lower_3 x i = (upper_3 x 0 - lower_3 x 0) / 2 ^ i\n  upper_3 x (Suc i) - lower_3 x (Suc i) = (upper_3 x i - lower_3 x i) / 2\n\ngoal (1 subgoal):\n 1. upper_3 x (Suc i) - lower_3 x (Suc i) =\n    (upper_3 x 0 - lower_3 x 0) / 2 ^ Suc i", "by auto"], ["proof (state)\nthis:\n  upper_3 x (Suc i) - lower_3 x (Suc i) =\n  (upper_3 x 0 - lower_3 x 0) / 2 ^ Suc i\n\ngoal (1 subgoal):\n 1. upper_3 x 0 - lower_3 x 0 = (upper_3 x 0 - lower_3 x 0) / 2 ^ 0", "qed auto"], ["", "lemma interval_size_3_tendsto_0: \"(\\<lambda>i. (upper_3 x i - lower_3 x i)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. upper_3 x i - lower_3 x i) \\<longlonglongrightarrow> 0", "by (subst interval_size_3, auto intro: LIMSEQ_divide_realpow_zero)"], ["", "lemma dist_tendsto_0_imp_tendsto: \"(\\<lambda>i. \\<bar>f i - a\\<bar> :: real) \\<longlonglongrightarrow> 0 \\<Longrightarrow> f \\<longlonglongrightarrow> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<bar>f i - a\\<bar>)\n    \\<longlonglongrightarrow> 0 \\<Longrightarrow>\n    f \\<longlonglongrightarrow> a", "using LIM_zero_cancel tendsto_rabs_zero_iff"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. ?f x - ?l) \\<longlongrightarrow> (0::?'b))\n   ?F \\<Longrightarrow>\n  (?f \\<longlongrightarrow> ?l) ?F\n  ((\\<lambda>x. \\<bar>?f x\\<bar>) \\<longlongrightarrow> 0) ?F =\n  (?f \\<longlongrightarrow> 0) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<bar>f i - a\\<bar>)\n    \\<longlonglongrightarrow> 0 \\<Longrightarrow>\n    f \\<longlonglongrightarrow> a", "by blast"], ["", "lemma upper_3_tendsto: \"upper_3 x \\<longlonglongrightarrow> real_of_3 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upper_3 x \\<longlonglongrightarrow> real_of_3 x", "proof(rule dist_tendsto_0_imp_tendsto, rule sandwitch_real)"], ["proof (state)\ngoal (4 subgoals):\n 1. ?l2 \\<longlonglongrightarrow> 0\n 2. ?r2 \\<longlonglongrightarrow> 0\n 3. \\<And>i. ?l2 i \\<le> \\<bar>upper_3 x i - real_of_3 x\\<bar>\n 4. \\<And>i. \\<bar>upper_3 x i - real_of_3 x\\<bar> \\<le> ?r2 i", "fix i"], ["proof (state)\ngoal (4 subgoals):\n 1. ?l2 \\<longlonglongrightarrow> 0\n 2. ?r2 \\<longlonglongrightarrow> 0\n 3. \\<And>i. ?l2 i \\<le> \\<bar>upper_3 x i - real_of_3 x\\<bar>\n 4. \\<And>i. \\<bar>upper_3 x i - real_of_3 x\\<bar> \\<le> ?r2 i", "obtain l r where lr: \"get_itvl_3 ((tighten_bounds_3 ^^ i) x) = Interval l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l r.\n        get_itvl_3 ((tighten_bounds_3 ^^ i) x) =\n        Interval l r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis interval.collapse)"], ["proof (state)\nthis:\n  get_itvl_3 ((tighten_bounds_3 ^^ i) x) = Interval l r\n\ngoal (4 subgoals):\n 1. ?l2 \\<longlonglongrightarrow> 0\n 2. ?r2 \\<longlonglongrightarrow> 0\n 3. \\<And>i. ?l2 i \\<le> \\<bar>upper_3 x i - real_of_3 x\\<bar>\n 4. \\<And>i. \\<bar>upper_3 x i - real_of_3 x\\<bar> \\<le> ?r2 i", "with get_itvl_3[of \"(tighten_bounds_3 ^^ i) x\"]"], ["proof (chain)\npicking this:\n  real_of_3 ((tighten_bounds_3 ^^ i) x)\n  \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ i) x)\n  get_itvl_3 ((tighten_bounds_3 ^^ i) x) = Interval l r", "show \"\\<bar>(upper_3 x) i - real_of_3 x\\<bar> \\<le> (upper_3 x i - lower_3 x i)\""], ["proof (prove)\nusing this:\n  real_of_3 ((tighten_bounds_3 ^^ i) x)\n  \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ i) x)\n  get_itvl_3 ((tighten_bounds_3 ^^ i) x) = Interval l r\n\ngoal (1 subgoal):\n 1. \\<bar>upper_3 x i - real_of_3 x\\<bar> \\<le> upper_3 x i - lower_3 x i", "unfolding upper_3_def lower_3_def"], ["proof (prove)\nusing this:\n  real_of_3 ((tighten_bounds_3 ^^ i) x)\n  \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ i) x)\n  get_itvl_3 ((tighten_bounds_3 ^^ i) x) = Interval l r\n\ngoal (1 subgoal):\n 1. \\<bar>interval.upper (get_itvl_3 ((tighten_bounds_3 ^^ i) x)) -\n          real_of_3 x\\<bar>\n    \\<le> interval.upper (get_itvl_3 ((tighten_bounds_3 ^^ i) x)) -\n          interval.lower (get_itvl_3 ((tighten_bounds_3 ^^ i) x))", "by auto"], ["proof (state)\nthis:\n  \\<bar>upper_3 x i - real_of_3 x\\<bar> \\<le> upper_3 x i - lower_3 x i\n\ngoal (3 subgoals):\n 1. ?l2 \\<longlonglongrightarrow> 0\n 2. (\\<lambda>i. upper_3 x i - lower_3 x i) \\<longlonglongrightarrow> 0\n 3. \\<And>i. ?l2 i \\<le> \\<bar>upper_3 x i - real_of_3 x\\<bar>", "qed (insert interval_size_3_tendsto_0, auto)"], ["", "lemma lower_3_tendsto: \"lower_3 x \\<longlonglongrightarrow> real_of_3 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lower_3 x \\<longlonglongrightarrow> real_of_3 x", "proof(rule dist_tendsto_0_imp_tendsto, rule sandwitch_real)"], ["proof (state)\ngoal (4 subgoals):\n 1. ?l2 \\<longlonglongrightarrow> 0\n 2. ?r2 \\<longlonglongrightarrow> 0\n 3. \\<And>i. ?l2 i \\<le> \\<bar>lower_3 x i - real_of_3 x\\<bar>\n 4. \\<And>i. \\<bar>lower_3 x i - real_of_3 x\\<bar> \\<le> ?r2 i", "fix i"], ["proof (state)\ngoal (4 subgoals):\n 1. ?l2 \\<longlonglongrightarrow> 0\n 2. ?r2 \\<longlonglongrightarrow> 0\n 3. \\<And>i. ?l2 i \\<le> \\<bar>lower_3 x i - real_of_3 x\\<bar>\n 4. \\<And>i. \\<bar>lower_3 x i - real_of_3 x\\<bar> \\<le> ?r2 i", "obtain l r where lr: \"get_itvl_3 ((tighten_bounds_3 ^^ i) x) = Interval l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l r.\n        get_itvl_3 ((tighten_bounds_3 ^^ i) x) =\n        Interval l r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis interval.collapse)"], ["proof (state)\nthis:\n  get_itvl_3 ((tighten_bounds_3 ^^ i) x) = Interval l r\n\ngoal (4 subgoals):\n 1. ?l2 \\<longlonglongrightarrow> 0\n 2. ?r2 \\<longlonglongrightarrow> 0\n 3. \\<And>i. ?l2 i \\<le> \\<bar>lower_3 x i - real_of_3 x\\<bar>\n 4. \\<And>i. \\<bar>lower_3 x i - real_of_3 x\\<bar> \\<le> ?r2 i", "with get_itvl_3[of \"(tighten_bounds_3 ^^ i) x\"]"], ["proof (chain)\npicking this:\n  real_of_3 ((tighten_bounds_3 ^^ i) x)\n  \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ i) x)\n  get_itvl_3 ((tighten_bounds_3 ^^ i) x) = Interval l r", "show \"\\<bar>lower_3 x i - real_of_3 x\\<bar> \\<le> (upper_3 x i - lower_3 x i)\""], ["proof (prove)\nusing this:\n  real_of_3 ((tighten_bounds_3 ^^ i) x)\n  \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ i) x)\n  get_itvl_3 ((tighten_bounds_3 ^^ i) x) = Interval l r\n\ngoal (1 subgoal):\n 1. \\<bar>lower_3 x i - real_of_3 x\\<bar> \\<le> upper_3 x i - lower_3 x i", "unfolding upper_3_def lower_3_def"], ["proof (prove)\nusing this:\n  real_of_3 ((tighten_bounds_3 ^^ i) x)\n  \\<in>\\<^sub>i get_itvl_3 ((tighten_bounds_3 ^^ i) x)\n  get_itvl_3 ((tighten_bounds_3 ^^ i) x) = Interval l r\n\ngoal (1 subgoal):\n 1. \\<bar>interval.lower (get_itvl_3 ((tighten_bounds_3 ^^ i) x)) -\n          real_of_3 x\\<bar>\n    \\<le> interval.upper (get_itvl_3 ((tighten_bounds_3 ^^ i) x)) -\n          interval.lower (get_itvl_3 ((tighten_bounds_3 ^^ i) x))", "by auto"], ["proof (state)\nthis:\n  \\<bar>lower_3 x i - real_of_3 x\\<bar> \\<le> upper_3 x i - lower_3 x i\n\ngoal (3 subgoals):\n 1. ?l2 \\<longlonglongrightarrow> 0\n 2. (\\<lambda>i. upper_3 x i - lower_3 x i) \\<longlonglongrightarrow> 0\n 3. \\<And>i. ?l2 i \\<le> \\<bar>lower_3 x i - real_of_3 x\\<bar>", "qed (insert interval_size_3_tendsto_0, auto)"], ["", "lemma tends_to_tight_bounds_3: \"(\\<lambda>x. get_itvl_3 ((tighten_bounds_3 ^^ x) y)) \\<longlonglongrightarrow>\\<^sub>i real_of_3 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        get_itvl_3\n         ((tighten_bounds_3 ^^ x) y)) \\<longlonglongrightarrow>\\<^sub>i\n    real_of_3 y", "using lower_3_tendsto[of y] upper_3_tendsto[of y]"], ["proof (prove)\nusing this:\n  lower_3 y \\<longlonglongrightarrow> real_of_3 y\n  upper_3 y \\<longlonglongrightarrow> real_of_3 y\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        get_itvl_3\n         ((tighten_bounds_3 ^^ x) y)) \\<longlonglongrightarrow>\\<^sub>i\n    real_of_3 y", "unfolding lower_3_def upper_3_def\n    interval_tendsto_def o_def"], ["proof (prove)\nusing this:\n  (\\<lambda>i. interval.lower (get_itvl_3 ((tighten_bounds_3 ^^ i) y)))\n  \\<longlonglongrightarrow> real_of_3 y\n  (\\<lambda>i. interval.upper (get_itvl_3 ((tighten_bounds_3 ^^ i) y)))\n  \\<longlonglongrightarrow> real_of_3 y\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. interval.upper (get_itvl_3 ((tighten_bounds_3 ^^ x) y)))\n    \\<longlonglongrightarrow> real_of_3 y \\<and>\n    (\\<lambda>x. interval.lower (get_itvl_3 ((tighten_bounds_3 ^^ x) y)))\n    \\<longlonglongrightarrow> real_of_3 y", "by auto"], ["", "lemma complex_roots_of_int_poly3: assumes p: \"p \\<noteq> 0\" and sf: \"square_free p\" \n  shows \"set (complex_roots_of_int_poly3 p) = {x. ipoly p x = 0}\" (is \"?l = ?r\")\n    \"distinct (complex_roots_of_int_poly3 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} &&&\n    distinct (complex_roots_of_int_poly3 p)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "interpret map_poly_inj_idom_hom of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_idom_hom of_real", ".."], ["proof (state)\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "define q where \"q = real_of_int_poly p\""], ["proof (state)\nthis:\n  q = real_of_int_poly p\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "let ?q = \"map_poly complex_of_real q\""], ["proof (state)\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "from p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have q0: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "unfolding q_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_int_poly p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "hence q: \"?q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map_poly complex_of_real q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  map_poly complex_of_real q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "define rr where \"rr = real_roots_of_int_poly p\""], ["proof (state)\nthis:\n  rr = real_roots_of_int_poly p\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "define rrts where \"rrts = map (\\<lambda>r. Complex r 0) rr\""], ["proof (state)\nthis:\n  rrts = map (\\<lambda>r. Complex r 0) rr\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "note d = complex_roots_of_int_poly3_def[of p, unfolded Let_def, folded rr_def, folded rrts_def]"], ["proof (state)\nthis:\n  complex_roots_of_int_poly3 p \\<equiv>\n  if degree p = length rr then rrts\n  else if degree p - length rr = 2\n       then rrts @\n            croots2\n             (map_poly (\\<lambda>r. Complex r 0)\n               (real_of_int_poly p div\n                (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])))\n       else rrts @\n            concat\n             (map (\\<lambda>x. [x, cnj x])\n               (map pair_to_complex\n                 (filter_list_length\n                   (map_prod tighten_bounds_3 tighten_bounds_3)\n                   (\\<lambda>(r, i).\n                       0 \\<in>\\<^sub>c ipoly_complex_interval p\n  (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n                   ((degree p - length rr) div 2)\n                   (concat\n                     (map (\\<lambda>rx.\n                              map (Pair rx) (pos_imaginary_parts_3 p))\n                       (real_parts_3 p))))))\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "have rr: \"set rr = {x. ipoly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set rr = {x. poly (real_of_int_poly p) x = 0}", "unfolding rr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (real_roots_of_int_poly p) = {x. poly (real_of_int_poly p) x = 0}", "using real_roots_of_int_poly(1)[OF p]"], ["proof (prove)\nusing this:\n  set (real_roots_of_int_poly p) = {x. poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. set (real_roots_of_int_poly p) = {x. poly (real_of_int_poly p) x = 0}", "."], ["proof (state)\nthis:\n  set rr = {x. poly (real_of_int_poly p) x = 0}\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "have rrts: \"set rrts = {x. poly ?q x = 0 \\<and> x \\<in> \\<real>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set rrts =\n    {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}", "unfolding rrts_def set_map rr q_def\n    complex_of_real_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real ` {x. poly (real_of_int_poly p) x = 0} =\n    {x. poly (map_poly complex_of_real (real_of_int_poly p)) x = 0 \\<and>\n        x \\<in> \\<real>}", "by (auto elim: Reals_cases)"], ["proof (state)\nthis:\n  set rrts =\n  {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "have dist: \"distinct rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct rr", "unfolding rr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (real_roots_of_int_poly p)", "using real_roots_of_int_poly(2)"], ["proof (prove)\nusing this:\n  distinct (real_roots_of_int_poly ?p)\n\ngoal (1 subgoal):\n 1. distinct (real_roots_of_int_poly p)", "."], ["proof (state)\nthis:\n  distinct rr\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "from dist"], ["proof (chain)\npicking this:\n  distinct rr", "have dist1: \"distinct rrts\""], ["proof (prove)\nusing this:\n  distinct rr\n\ngoal (1 subgoal):\n 1. distinct rrts", "unfolding rrts_def distinct_map inj_on_def"], ["proof (prove)\nusing this:\n  distinct rr\n\ngoal (1 subgoal):\n 1. distinct rr \\<and>\n    (\\<forall>x\\<in>set rr.\n        \\<forall>y\\<in>set rr.\n           Complex x 0 = Complex y 0 \\<longrightarrow> x = y)", "by auto"], ["proof (state)\nthis:\n  distinct rrts\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "have lrr: \"length rr = card {x. poly (real_of_int_poly p) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length rr = card {x. poly (real_of_int_poly p) x = 0}", "unfolding rr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (real_roots_of_int_poly p) =\n    card {x. poly (real_of_int_poly p) x = 0}", "using real_roots_of_int_poly[of p] p distinct_card"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  set (real_roots_of_int_poly p) = {x. poly (real_of_int_poly p) x = 0}\n  distinct (real_roots_of_int_poly p)\n  p \\<noteq> 0\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. length (real_roots_of_int_poly p) =\n    card {x. poly (real_of_int_poly p) x = 0}", "by fastforce"], ["proof (state)\nthis:\n  length rr = card {x. poly (real_of_int_poly p) x = 0}\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "have cr: \"length rr = card {x. poly ?q x = 0 \\<and> x \\<in> \\<real>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length rr =\n    card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}", "unfolding lrr q_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly q x = 0} =\n    card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card {x. poly q x = 0} =\n    card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}", "have \"card {x. poly q x = 0} \\<le> card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\" (is \"?l \\<le> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly q x = 0}\n    \\<le> card\n           {x. poly (map_poly complex_of_real q) x = 0 \\<and>\n               x \\<in> \\<real>}", "by (rule card_inj_on_le[of of_real], insert poly_roots_finite[OF q], auto simp: inj_on_def)"], ["proof (state)\nthis:\n  card {x. poly q x = 0}\n  \\<le> card\n         {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n\ngoal (1 subgoal):\n 1. card {x. poly q x = 0} =\n    card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}", "moreover"], ["proof (state)\nthis:\n  card {x. poly q x = 0}\n  \\<le> card\n         {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n\ngoal (1 subgoal):\n 1. card {x. poly q x = 0} =\n    card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}", "have \"?l \\<ge> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n    \\<le> card {x. poly q x = 0}", "by (rule card_inj_on_le[of Re, OF _ _ poly_roots_finite[OF q0]], auto simp: inj_on_def elim!: Reals_cases)"], ["proof (state)\nthis:\n  card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n  \\<le> card {x. poly q x = 0}\n\ngoal (1 subgoal):\n 1. card {x. poly q x = 0} =\n    card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}", "ultimately"], ["proof (chain)\npicking this:\n  card {x. poly q x = 0}\n  \\<le> card\n         {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n  card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n  \\<le> card {x. poly q x = 0}", "show \"?l = ?r\""], ["proof (prove)\nusing this:\n  card {x. poly q x = 0}\n  \\<le> card\n         {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n  card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n  \\<le> card {x. poly q x = 0}\n\ngoal (1 subgoal):\n 1. card {x. poly q x = 0} =\n    card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}", "by simp"], ["proof (state)\nthis:\n  card {x. poly q x = 0} =\n  card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length rr =\n  card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "have conv: \"\\<And> x. ipoly p x = 0 \\<longleftrightarrow> poly ?q x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (poly (complex_of_int_poly p) x = 0) =\n       (poly (map_poly complex_of_real q) x = 0)", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (poly (complex_of_int_poly p) x = 0) =\n       (poly (map_poly complex_of_real (real_of_int_poly p)) x = 0)", "by (subst map_poly_map_poly, auto simp: o_def)"], ["proof (state)\nthis:\n  (poly (complex_of_int_poly p) ?x1 = 0) =\n  (poly (map_poly complex_of_real q) ?x1 = 0)\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "have r: \"?r = {x. poly ?q x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (complex_of_int_poly p) x = 0} =\n    {x. poly (map_poly complex_of_real q) x = 0}", "unfolding conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (map_poly complex_of_real q) x = 0} =\n    {x. poly (map_poly complex_of_real q) x = 0}", ".."], ["proof (state)\nthis:\n  {x. poly (complex_of_int_poly p) x = 0} =\n  {x. poly (map_poly complex_of_real q) x = 0}\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "have \"?l = {x. ipoly p x = 0} \\<and> distinct (complex_roots_of_int_poly3 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "proof (cases \"degree p = length rr\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p \\<noteq> length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> length rr\n\ngoal (2 subgoals):\n 1. degree p = length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p \\<noteq> length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "note oFalse = this"], ["proof (state)\nthis:\n  degree p \\<noteq> length rr\n\ngoal (2 subgoals):\n 1. degree p = length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p \\<noteq> length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "proof (cases \"degree p - length rr = 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "case False"], ["proof (state)\nthis:\n  degree p - length rr \\<noteq> 2\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?nr = \"(degree p - length rr) div 2\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "define cpxI where \"cpxI = pos_imaginary_parts_3 p\""], ["proof (state)\nthis:\n  cpxI = pos_imaginary_parts_3 p\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "define cpxR where \"cpxR = real_parts_3 p\""], ["proof (state)\nthis:\n  cpxR = real_parts_3 p\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?rts = \"[(rx,ix). rx <- cpxR, ix <- cpxI]\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "define cpx where \"cpx = map pair_to_complex (filter (\\<lambda> c. ipoly p (pair_to_complex c) = 0) \n         ?rts)\""], ["proof (state)\nthis:\n  cpx =\n  map pair_to_complex\n   (filter\n     (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n     (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR)))\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?LL = \"cpx @ map cnj cpx\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?LL' = \"concat (map (\\<lambda> x. [x,cnj x]) cpx)\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?ll = \"rrts @ ?LL\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?ll' = \"rrts @ ?LL'\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have cpx: \"set cpx \\<subseteq> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set cpx \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}", "unfolding cpx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map pair_to_complex\n          (filter\n            (\\<lambda>c.\n                poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n            (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))))\n    \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}", "by auto"], ["proof (state)\nthis:\n  set cpx \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have ccpx: \"cnj ` set cpx \\<subseteq> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj ` set cpx \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}", "using cpx"], ["proof (prove)\nusing this:\n  set cpx \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. cnj ` set cpx \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}", "unfolding r"], ["proof (prove)\nusing this:\n  set cpx \\<subseteq> {x. poly (map_poly complex_of_real q) x = 0}\n\ngoal (1 subgoal):\n 1. cnj ` set cpx \\<subseteq> {x. poly (map_poly complex_of_real q) x = 0}", "by (auto intro!: complex_conjugate_root[of ?q] simp: Reals_def)"], ["proof (state)\nthis:\n  cnj ` set cpx \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"set ?ll \\<subseteq> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rrts @ cpx @ map cnj cpx)\n    \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}", "using rrts cpx ccpx"], ["proof (prove)\nusing this:\n  set rrts =\n  {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n  set cpx \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}\n  cnj ` set cpx \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. set (rrts @ cpx @ map cnj cpx)\n    \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}", "unfolding r"], ["proof (prove)\nusing this:\n  set rrts =\n  {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n  set cpx \\<subseteq> {x. poly (map_poly complex_of_real q) x = 0}\n  cnj ` set cpx \\<subseteq> {x. poly (map_poly complex_of_real q) x = 0}\n\ngoal (1 subgoal):\n 1. set (rrts @ cpx @ map cnj cpx)\n    \\<subseteq> {x. poly (map_poly complex_of_real q) x = 0}", "by auto"], ["proof (state)\nthis:\n  set (rrts @ cpx @ map cnj cpx)\n  \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "moreover"], ["proof (state)\nthis:\n  set (rrts @ cpx @ map cnj cpx)\n  \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "{"], ["proof (state)\nthis:\n  set (rrts @ cpx @ map cnj cpx)\n  \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "fix x :: complex"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "assume rt: \"ipoly p x = 0\""], ["proof (state)\nthis:\n  poly (complex_of_int_poly p) x = 0\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "{"], ["proof (state)\nthis:\n  poly (complex_of_int_poly p) x = 0\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "assume rt: \"ipoly p x = 0\"\n            and gt: \"Im x > 0\""], ["proof (state)\nthis:\n  poly (complex_of_int_poly p) x = 0\n  0 < Im x\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "define rx where \"rx = Re x\""], ["proof (state)\nthis:\n  rx = Re x\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?x = \"Complex rx (Im x)\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have x: \"x = ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = Complex rx (Im x)", "by (cases x, auto simp: rx_def)"], ["proof (state)\nthis:\n  x = Complex rx (Im x)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from rt x"], ["proof (chain)\npicking this:\n  poly (complex_of_int_poly p) x = 0\n  x = Complex rx (Im x)", "have rt': \"ipoly p ?x = 0\""], ["proof (prove)\nusing this:\n  poly (complex_of_int_poly p) x = 0\n  x = Complex rx (Im x)\n\ngoal (1 subgoal):\n 1. poly (complex_of_int_poly p) (Complex rx (Im x)) = 0", "by auto"], ["proof (state)\nthis:\n  poly (complex_of_int_poly p) (Complex rx (Im x)) = 0\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from real_parts_3[OF p rt, folded rx_def] pos_imaginary_parts_3[OF p rt gt] rt'"], ["proof (chain)\npicking this:\n  rx \\<in> real_of_3 ` set (real_parts_3 p)\n  Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)\n  poly (complex_of_int_poly p) (Complex rx (Im x)) = 0", "have \"?x \\<in> set cpx\""], ["proof (prove)\nusing this:\n  rx \\<in> real_of_3 ` set (real_parts_3 p)\n  Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)\n  poly (complex_of_int_poly p) (Complex rx (Im x)) = 0\n\ngoal (1 subgoal):\n 1. Complex rx (Im x) \\<in> set cpx", "unfolding cpx_def cpxI_def cpxR_def"], ["proof (prove)\nusing this:\n  rx \\<in> real_of_3 ` set (real_parts_3 p)\n  Im x \\<in> real_of_3 ` set (pos_imaginary_parts_3 p)\n  poly (complex_of_int_poly p) (Complex rx (Im x)) = 0\n\ngoal (1 subgoal):\n 1. Complex rx (Im x)\n    \\<in> set (map pair_to_complex\n                (filter\n                  (\\<lambda>c.\n                      poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n                  (concat\n                    (map (\\<lambda>rx.\n                             map (Pair rx) (pos_imaginary_parts_3 p))\n                      (real_parts_3 p)))))", "by (force simp: pair_to_complex_def[abs_def])"], ["proof (state)\nthis:\n  Complex rx (Im x) \\<in> set cpx\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "hence \"x \\<in> set cpx\""], ["proof (prove)\nusing this:\n  Complex rx (Im x) \\<in> set cpx\n\ngoal (1 subgoal):\n 1. x \\<in> set cpx", "using x"], ["proof (prove)\nusing this:\n  Complex rx (Im x) \\<in> set cpx\n  x = Complex rx (Im x)\n\ngoal (1 subgoal):\n 1. x \\<in> set cpx", "by simp"], ["proof (state)\nthis:\n  x \\<in> set cpx\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>poly (complex_of_int_poly p) ?xa3 = 0; 0 < Im ?xa3\\<rbrakk>\n  \\<Longrightarrow> ?xa3 \\<in> set cpx\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "note gt = this"], ["proof (state)\nthis:\n  \\<lbrakk>poly (complex_of_int_poly p) ?xa3 = 0; 0 < Im ?xa3\\<rbrakk>\n  \\<Longrightarrow> ?xa3 \\<in> set cpx\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have cases: \"Im x = 0 \\<or> Im x > 0 \\<or> Im x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im x = 0 \\<or> 0 < Im x \\<or> Im x < 0", "by auto"], ["proof (state)\nthis:\n  Im x = 0 \\<or> 0 < Im x \\<or> Im x < 0\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from rt"], ["proof (chain)\npicking this:\n  poly (complex_of_int_poly p) x = 0", "have rt': \"ipoly p (cnj x) = 0\""], ["proof (prove)\nusing this:\n  poly (complex_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. poly (complex_of_int_poly p) (cnj x) = 0", "unfolding conv"], ["proof (prove)\nusing this:\n  poly (map_poly complex_of_real q) x = 0\n\ngoal (1 subgoal):\n 1. poly (map_poly complex_of_real q) (cnj x) = 0", "by (intro complex_conjugate_root[of ?q x], auto simp: Reals_def)"], ["proof (state)\nthis:\n  poly (complex_of_int_poly p) (cnj x) = 0\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "{"], ["proof (state)\nthis:\n  poly (complex_of_int_poly p) (cnj x) = 0\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "assume \"Im x > 0\""], ["proof (state)\nthis:\n  0 < Im x\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from gt[OF rt this]"], ["proof (chain)\npicking this:\n  x \\<in> set cpx", "have \"x \\<in> set ?ll\""], ["proof (prove)\nusing this:\n  x \\<in> set cpx\n\ngoal (1 subgoal):\n 1. x \\<in> set (rrts @ cpx @ map cnj cpx)", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "}"], ["proof (state)\nthis:\n  0 < Im x \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "moreover"], ["proof (state)\nthis:\n  0 < Im x \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "{"], ["proof (state)\nthis:\n  0 < Im x \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "assume \"Im x < 0\""], ["proof (state)\nthis:\n  Im x < 0\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "hence \"Im (cnj x) > 0\""], ["proof (prove)\nusing this:\n  Im x < 0\n\ngoal (1 subgoal):\n 1. 0 < Im (cnj x)", "by simp"], ["proof (state)\nthis:\n  0 < Im (cnj x)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from gt[OF rt' this]"], ["proof (chain)\npicking this:\n  cnj x \\<in> set cpx", "have \"cnj (cnj x) \\<in> set ?ll\""], ["proof (prove)\nusing this:\n  cnj x \\<in> set cpx\n\ngoal (1 subgoal):\n 1. cnj (cnj x) \\<in> set (rrts @ cpx @ map cnj cpx)", "unfolding set_append set_map"], ["proof (prove)\nusing this:\n  cnj x \\<in> set cpx\n\ngoal (1 subgoal):\n 1. cnj (cnj x) \\<in> set rrts \\<union> (set cpx \\<union> cnj ` set cpx)", "by blast"], ["proof (state)\nthis:\n  cnj (cnj x) \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "hence \"x \\<in> set ?ll\""], ["proof (prove)\nusing this:\n  cnj (cnj x) \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (1 subgoal):\n 1. x \\<in> set (rrts @ cpx @ map cnj cpx)", "by simp"], ["proof (state)\nthis:\n  x \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "}"], ["proof (state)\nthis:\n  Im x < 0 \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "moreover"], ["proof (state)\nthis:\n  Im x < 0 \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "{"], ["proof (state)\nthis:\n  Im x < 0 \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "assume \"Im x = 0\""], ["proof (state)\nthis:\n  Im x = 0\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "hence \"x \\<in> \\<real>\""], ["proof (prove)\nusing this:\n  Im x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> \\<real>", "using complex_is_Real_iff"], ["proof (prove)\nusing this:\n  Im x = 0\n  (?z \\<in> \\<real>) = (Im ?z = 0)\n\ngoal (1 subgoal):\n 1. x \\<in> \\<real>", "by blast"], ["proof (state)\nthis:\n  x \\<in> \\<real>\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "with rt rrts"], ["proof (chain)\npicking this:\n  poly (complex_of_int_poly p) x = 0\n  set rrts =\n  {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n  x \\<in> \\<real>", "have \"x \\<in> set ?ll\""], ["proof (prove)\nusing this:\n  poly (complex_of_int_poly p) x = 0\n  set rrts =\n  {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n  x \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. x \\<in> set (rrts @ cpx @ map cnj cpx)", "unfolding conv"], ["proof (prove)\nusing this:\n  poly (map_poly complex_of_real q) x = 0\n  set rrts =\n  {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n  x \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. x \\<in> set (rrts @ cpx @ map cnj cpx)", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "}"], ["proof (state)\nthis:\n  Im x = 0 \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "ultimately"], ["proof (chain)\npicking this:\n  0 < Im x \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n  Im x < 0 \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n  Im x = 0 \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)", "have \"x \\<in> set ?ll\""], ["proof (prove)\nusing this:\n  0 < Im x \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n  Im x < 0 \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n  Im x = 0 \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (1 subgoal):\n 1. x \\<in> set (rrts @ cpx @ map cnj cpx)", "using cases"], ["proof (prove)\nusing this:\n  0 < Im x \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n  Im x < 0 \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n  Im x = 0 \\<Longrightarrow> x \\<in> set (rrts @ cpx @ map cnj cpx)\n  Im x = 0 \\<or> 0 < Im x \\<or> Im x < 0\n\ngoal (1 subgoal):\n 1. x \\<in> set (rrts @ cpx @ map cnj cpx)", "by blast"], ["proof (state)\nthis:\n  x \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "}"], ["proof (state)\nthis:\n  poly (complex_of_int_poly p) ?x3 = 0 \\<Longrightarrow>\n  ?x3 \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "ultimately"], ["proof (chain)\npicking this:\n  set (rrts @ cpx @ map cnj cpx)\n  \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}\n  poly (complex_of_int_poly p) ?x3 = 0 \\<Longrightarrow>\n  ?x3 \\<in> set (rrts @ cpx @ map cnj cpx)", "have lr: \"set ?ll = {x. ipoly p x = 0}\""], ["proof (prove)\nusing this:\n  set (rrts @ cpx @ map cnj cpx)\n  \\<subseteq> {x. poly (complex_of_int_poly p) x = 0}\n  poly (complex_of_int_poly p) ?x3 = 0 \\<Longrightarrow>\n  ?x3 \\<in> set (rrts @ cpx @ map cnj cpx)\n\ngoal (1 subgoal):\n 1. set (rrts @ cpx @ map cnj cpx) = {x. poly (complex_of_int_poly p) x = 0}", "by blast"], ["proof (state)\nthis:\n  set (rrts @ cpx @ map cnj cpx) = {x. poly (complex_of_int_poly p) x = 0}\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?rr = \"map real_of_3 cpxR\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?pi = \"map real_of_3 cpxI\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have dist2: \"distinct ?rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map real_of_3 cpxR)", "unfolding cpxR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map real_of_3 (real_parts_3 p))", "by (rule distinct_real_parts_3)"], ["proof (state)\nthis:\n  distinct (map real_of_3 cpxR)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have dist3: \"distinct ?pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map real_of_3 cpxI)", "unfolding cpxI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map real_of_3 (pos_imaginary_parts_3 p))", "by (rule distinct_pos_imaginary_parts_3)"], ["proof (state)\nthis:\n  distinct (map real_of_3 cpxI)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have idd: \"concat (map (map pair_to_complex) (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))\n        = concat (map (\\<lambda>r. map (\\<lambda> i. Complex (real_of_3 r) (real_of_3 i)) cpxI) cpxR)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (map pair_to_complex)\n       (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR)) =\n    concat\n     (map (\\<lambda>r.\n              map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n       cpxR)", "unfolding pair_to_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (map (\\<lambda>ri.\n                   case ri of\n                   (r, i) \\<Rightarrow>\n                     Complex (real_of_3 r) (real_of_3 i)))\n       (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR)) =\n    concat\n     (map (\\<lambda>r.\n              map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n       cpxR)", "by (auto simp: o_def)"], ["proof (state)\nthis:\n  concat\n   (map (map pair_to_complex)\n     (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR)) =\n  concat\n   (map (\\<lambda>r.\n            map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n     cpxR)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have dist4: \"distinct cpx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct cpx", "unfolding cpx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map pair_to_complex\n       (filter\n         (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n         (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))))", "proof (rule distinct_map_filter, unfold map_concat idd, unfold distinct_conv_nth, intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat\n                       (map (\\<lambda>r.\n                                map (\\<lambda>i.\n  Complex (real_of_3 r) (real_of_3 i))\n                                 cpxI)\n                         cpxR));\n        j < length\n             (concat\n               (map (\\<lambda>r.\n                        map (\\<lambda>i.\n                                Complex (real_of_3 r) (real_of_3 i))\n                         cpxI)\n                 cpxR));\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map (\\<lambda>r.\n                                   map (\\<lambda>i.\n     Complex (real_of_3 r) (real_of_3 i))\n                                    cpxI)\n                            cpxR) !\n                         i \\<noteq>\n                         concat\n                          (map (\\<lambda>r.\n                                   map (\\<lambda>i.\n     Complex (real_of_3 r) (real_of_3 i))\n                                    cpxI)\n                            cpxR) !\n                         j", "case (1 i j)"], ["proof (state)\nthis:\n  i < length\n       (concat\n         (map (\\<lambda>r.\n                  map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i))\n                   cpxI)\n           cpxR))\n  j < length\n       (concat\n         (map (\\<lambda>r.\n                  map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i))\n                   cpxI)\n           cpxR))\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat\n                       (map (\\<lambda>r.\n                                map (\\<lambda>i.\n  Complex (real_of_3 r) (real_of_3 i))\n                                 cpxI)\n                         cpxR));\n        j < length\n             (concat\n               (map (\\<lambda>r.\n                        map (\\<lambda>i.\n                                Complex (real_of_3 r) (real_of_3 i))\n                         cpxI)\n                 cpxR));\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map (\\<lambda>r.\n                                   map (\\<lambda>i.\n     Complex (real_of_3 r) (real_of_3 i))\n                                    cpxI)\n                            cpxR) !\n                         i \\<noteq>\n                         concat\n                          (map (\\<lambda>r.\n                                   map (\\<lambda>i.\n     Complex (real_of_3 r) (real_of_3 i))\n                                    cpxI)\n                            cpxR) !\n                         j", "from nth_concat_diff[OF 1, unfolded length_map] dist2[unfolded distinct_conv_nth]\n         dist3[unfolded distinct_conv_nth]"], ["proof (chain)\npicking this:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length cpxR \\<and>\n     j2 < length cpxR \\<and>\n     k1 < length\n           (map (\\<lambda>r.\n                    map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i))\n                     cpxI)\n             cpxR !\n            j1) \\<and>\n     k2 < length\n           (map (\\<lambda>r.\n                    map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i))\n                     cpxI)\n             cpxR !\n            j2) \\<and>\n     concat\n      (map (\\<lambda>r.\n               map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n        cpxR) !\n     i =\n     map (\\<lambda>r.\n             map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n      cpxR !\n     j1 !\n     k1 \\<and>\n     concat\n      (map (\\<lambda>r.\n               map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n        cpxR) !\n     j =\n     map (\\<lambda>r.\n             map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n      cpxR !\n     j2 !\n     k2\n  \\<forall>i<length (map real_of_3 cpxR).\n     \\<forall>j<length (map real_of_3 cpxR).\n        i \\<noteq> j \\<longrightarrow>\n        map real_of_3 cpxR ! i \\<noteq> map real_of_3 cpxR ! j\n  \\<forall>i<length (map real_of_3 cpxI).\n     \\<forall>j<length (map real_of_3 cpxI).\n        i \\<noteq> j \\<longrightarrow>\n        map real_of_3 cpxI ! i \\<noteq> map real_of_3 cpxI ! j", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length cpxR \\<and>\n     j2 < length cpxR \\<and>\n     k1 < length\n           (map (\\<lambda>r.\n                    map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i))\n                     cpxI)\n             cpxR !\n            j1) \\<and>\n     k2 < length\n           (map (\\<lambda>r.\n                    map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i))\n                     cpxI)\n             cpxR !\n            j2) \\<and>\n     concat\n      (map (\\<lambda>r.\n               map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n        cpxR) !\n     i =\n     map (\\<lambda>r.\n             map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n      cpxR !\n     j1 !\n     k1 \\<and>\n     concat\n      (map (\\<lambda>r.\n               map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n        cpxR) !\n     j =\n     map (\\<lambda>r.\n             map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n      cpxR !\n     j2 !\n     k2\n  \\<forall>i<length (map real_of_3 cpxR).\n     \\<forall>j<length (map real_of_3 cpxR).\n        i \\<noteq> j \\<longrightarrow>\n        map real_of_3 cpxR ! i \\<noteq> map real_of_3 cpxR ! j\n  \\<forall>i<length (map real_of_3 cpxI).\n     \\<forall>j<length (map real_of_3 cpxI).\n        i \\<noteq> j \\<longrightarrow>\n        map real_of_3 cpxI ! i \\<noteq> map real_of_3 cpxI ! j\n\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>r.\n              map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n       cpxR) !\n    i \\<noteq>\n    concat\n     (map (\\<lambda>r.\n              map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n       cpxR) !\n    j", "by auto"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>r.\n            map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n     cpxR) !\n  i \\<noteq>\n  concat\n   (map (\\<lambda>r.\n            map (\\<lambda>i. Complex (real_of_3 r) (real_of_3 i)) cpxI)\n     cpxR) !\n  j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct cpx\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have dist5: \"distinct (map cnj cpx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map cnj cpx)", "using dist4"], ["proof (prove)\nusing this:\n  distinct cpx\n\ngoal (1 subgoal):\n 1. distinct (map cnj cpx)", "unfolding distinct_map"], ["proof (prove)\nusing this:\n  distinct cpx\n\ngoal (1 subgoal):\n 1. distinct cpx \\<and> inj_on cnj (set cpx)", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  distinct (map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "{"], ["proof (state)\nthis:\n  distinct (map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "fix x :: complex"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have rrts: \"x \\<in> set rrts \\<Longrightarrow> Im x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set rrts \\<Longrightarrow> Im x = 0", "unfolding rrts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (map (\\<lambda>r. Complex r 0) rr) \\<Longrightarrow>\n    Im x = 0", "by auto"], ["proof (state)\nthis:\n  x \\<in> set rrts \\<Longrightarrow> Im x = 0\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have cpx: \"\\<And> x. x \\<in> set cpx \\<Longrightarrow> Im x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set cpx \\<Longrightarrow> 0 < Im x", "unfolding cpx_def cpxI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (map pair_to_complex\n                     (filter\n                       (\\<lambda>c.\n                           poly (complex_of_int_poly p)\n                            (pair_to_complex c) =\n                           0)\n                       (concat\n                         (map (\\<lambda>rx.\n                                  map (Pair rx) (pos_imaginary_parts_3 p))\n                           cpxR)))) \\<Longrightarrow>\n       0 < Im x", "by (auto simp: pair_to_complex_def[abs_def] positive_pos_imaginary_parts_3)"], ["proof (state)\nthis:\n  ?x1 \\<in> set cpx \\<Longrightarrow> 0 < Im ?x1\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have cpx': \"x \\<in> cnj ` set cpx \\<Longrightarrow> sgn (Im x) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> cnj ` set cpx \\<Longrightarrow> sgn (Im x) = - 1", "using cpx"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set cpx \\<Longrightarrow> 0 < Im ?x1\n\ngoal (1 subgoal):\n 1. x \\<in> cnj ` set cpx \\<Longrightarrow> sgn (Im x) = - 1", "by auto"], ["proof (state)\nthis:\n  x \\<in> cnj ` set cpx \\<Longrightarrow> sgn (Im x) = - 1\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"x \\<notin> set rrts \\<inter> set cpx \\<union> set rrts \\<inter> cnj ` set cpx \\<union> set cpx \\<inter> cnj ` set cpx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set rrts \\<inter> set cpx \\<union>\n               set rrts \\<inter> cnj ` set cpx \\<union>\n               set cpx \\<inter> cnj ` set cpx", "using rrts cpx[of x] cpx'"], ["proof (prove)\nusing this:\n  x \\<in> set rrts \\<Longrightarrow> Im x = 0\n  x \\<in> set cpx \\<Longrightarrow> 0 < Im x\n  x \\<in> cnj ` set cpx \\<Longrightarrow> sgn (Im x) = - 1\n\ngoal (1 subgoal):\n 1. x \\<notin> set rrts \\<inter> set cpx \\<union>\n               set rrts \\<inter> cnj ` set cpx \\<union>\n               set cpx \\<inter> cnj ` set cpx", "by auto"], ["proof (state)\nthis:\n  x \\<notin> set rrts \\<inter> set cpx \\<union>\n             set rrts \\<inter> cnj ` set cpx \\<union>\n             set cpx \\<inter> cnj ` set cpx\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "}"], ["proof (state)\nthis:\n  ?x3\n  \\<notin> set rrts \\<inter> set cpx \\<union>\n           set rrts \\<inter> cnj ` set cpx \\<union>\n           set cpx \\<inter> cnj ` set cpx\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "note dist6 = this"], ["proof (state)\nthis:\n  ?x3\n  \\<notin> set rrts \\<inter> set cpx \\<union>\n           set rrts \\<inter> cnj ` set cpx \\<union>\n           set cpx \\<inter> cnj ` set cpx\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have dist: \"distinct ?ll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (rrts @ cpx @ map cnj cpx)", "unfolding distinct_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct rrts \\<and>\n    (distinct cpx \\<and>\n     distinct (map cnj cpx) \\<and>\n     set cpx \\<inter> set (map cnj cpx) = {}) \\<and>\n    set rrts \\<inter> set (cpx @ map cnj cpx) = {}", "using dist6"], ["proof (prove)\nusing this:\n  ?x3\n  \\<notin> set rrts \\<inter> set cpx \\<union>\n           set rrts \\<inter> cnj ` set cpx \\<union>\n           set cpx \\<inter> cnj ` set cpx\n\ngoal (1 subgoal):\n 1. distinct rrts \\<and>\n    (distinct cpx \\<and>\n     distinct (map cnj cpx) \\<and>\n     set cpx \\<inter> set (map cnj cpx) = {}) \\<and>\n    set rrts \\<inter> set (cpx @ map cnj cpx) = {}", "by (auto simp: dist1 dist4 dist5)"], ["proof (state)\nthis:\n  distinct (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?p = \"complex_of_int_poly p\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have pp: \"?p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_int_poly p \\<noteq> 0", "using p"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. complex_of_int_poly p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  complex_of_int_poly p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from p square_free_of_int_poly[OF sf] square_free_rsquarefree"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  square_free (of_int_poly p)\n  square_free ?f \\<Longrightarrow> rsquarefree ?f", "have rsf:\"rsquarefree ?p\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  square_free (of_int_poly p)\n  square_free ?f \\<Longrightarrow> rsquarefree ?f\n\ngoal (1 subgoal):\n 1. rsquarefree (complex_of_int_poly p)", "by auto"], ["proof (state)\nthis:\n  rsquarefree (complex_of_int_poly p)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from dist lr"], ["proof (chain)\npicking this:\n  distinct (rrts @ cpx @ map cnj cpx)\n  set (rrts @ cpx @ map cnj cpx) = {x. poly (complex_of_int_poly p) x = 0}", "have \"length ?ll = card {x. poly ?p x = 0}\""], ["proof (prove)\nusing this:\n  distinct (rrts @ cpx @ map cnj cpx)\n  set (rrts @ cpx @ map cnj cpx) = {x. poly (complex_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. length (rrts @ cpx @ map cnj cpx) =\n    card {x. poly (complex_of_int_poly p) x = 0}", "by (metis distinct_card)"], ["proof (state)\nthis:\n  length (rrts @ cpx @ map cnj cpx) =\n  card {x. poly (complex_of_int_poly p) x = 0}\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "also"], ["proof (state)\nthis:\n  length (rrts @ cpx @ map cnj cpx) =\n  card {x. poly (complex_of_int_poly p) x = 0}\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"\\<dots> = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly (complex_of_int_poly p) x = 0} = degree p", "using rsf"], ["proof (prove)\nusing this:\n  rsquarefree (complex_of_int_poly p)\n\ngoal (1 subgoal):\n 1. card {x. poly (complex_of_int_poly p) x = 0} = degree p", "unfolding rsquarefree_card_degree[OF pp]"], ["proof (prove)\nusing this:\n  card {x. poly (complex_of_int_poly p) x = 0} =\n  degree (complex_of_int_poly p)\n\ngoal (1 subgoal):\n 1. card {x. poly (complex_of_int_poly p) x = 0} = degree p", "by simp"], ["proof (state)\nthis:\n  card {x. poly (complex_of_int_poly p) x = 0} = degree p\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "finally"], ["proof (chain)\npicking this:\n  length (rrts @ cpx @ map cnj cpx) = degree p", "have deg_len: \"degree p = length ?ll\""], ["proof (prove)\nusing this:\n  length (rrts @ cpx @ map cnj cpx) = degree p\n\ngoal (1 subgoal):\n 1. degree p = length (rrts @ cpx @ map cnj cpx)", "by simp"], ["proof (state)\nthis:\n  degree p = length (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?P = \"\\<lambda> c.  ipoly p (pair_to_complex c) = 0\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?itvl = \"\\<lambda> r i. ipoly_complex_interval p (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?itv = \"\\<lambda> (r,i). ?itvl r i\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?p = \"(\\<lambda> (r,i). 0 \\<in>\\<^sub>c (?itvl r i))\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?tb = tighten_bounds_3"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?f = \"map_prod ?tb ?tb\""], ["proof (state)\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have filter: \"map pair_to_complex (filter_list_length ?f ?p ?nr ?rts) = map pair_to_complex (filter ?P ?rts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map pair_to_complex\n     (filter_list_length (map_prod tighten_bounds_3 tighten_bounds_3)\n       (\\<lambda>(r, i).\n           0 \\<in>\\<^sub>c ipoly_complex_interval p\n                            (Complex_Interval (get_itvl_3 r)\n                              (get_itvl_3 i)))\n       ((degree p - length rr) div 2)\n       (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n    map pair_to_complex\n     (filter\n       (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n       (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR)))", "proof (rule filter_list_length)"], ["proof (state)\ngoal (5 subgoals):\n 1. length\n     (filter\n       (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n       (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n    (degree p - length rr) div 2\n 2. \\<And>i x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) = 0\\<rbrakk>\n       \\<Longrightarrow> case (map_prod tighten_bounds_3 tighten_bounds_3 ^^\n                               i)\n                               x of\n                         (r, i) \\<Rightarrow>\n                           0 \\<in>\\<^sub>c ipoly_complex_interval p\n      (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 4. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 5. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "have \"length (filter ?P ?rts) = length cpx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (filter\n       (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n       (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n    length cpx", "unfolding cpx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (filter\n       (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n       (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n    length\n     (map pair_to_complex\n       (filter\n         (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n         (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))))", "by simp"], ["proof (state)\nthis:\n  length\n   (filter\n     (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n     (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n  length cpx\n\ngoal (5 subgoals):\n 1. length\n     (filter\n       (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n       (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n    (degree p - length rr) div 2\n 2. \\<And>i x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) = 0\\<rbrakk>\n       \\<Longrightarrow> case (map_prod tighten_bounds_3 tighten_bounds_3 ^^\n                               i)\n                               x of\n                         (r, i) \\<Rightarrow>\n                           0 \\<in>\\<^sub>c ipoly_complex_interval p\n      (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 4. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 5. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "also"], ["proof (state)\nthis:\n  length\n   (filter\n     (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n     (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n  length cpx\n\ngoal (5 subgoals):\n 1. length\n     (filter\n       (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n       (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n    (degree p - length rr) div 2\n 2. \\<And>i x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) = 0\\<rbrakk>\n       \\<Longrightarrow> case (map_prod tighten_bounds_3 tighten_bounds_3 ^^\n                               i)\n                               x of\n                         (r, i) \\<Rightarrow>\n                           0 \\<in>\\<^sub>c ipoly_complex_interval p\n      (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 4. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 5. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "have \"\\<dots> = ?nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cpx = (degree p - length rr) div 2", "unfolding deg_len"], ["proof (prove)\ngoal (1 subgoal):\n 1. length cpx = (length (rrts @ cpx @ map cnj cpx) - length rr) div 2", "by (simp add: rrts_def)"], ["proof (state)\nthis:\n  length cpx = (degree p - length rr) div 2\n\ngoal (5 subgoals):\n 1. length\n     (filter\n       (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n       (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n    (degree p - length rr) div 2\n 2. \\<And>i x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) = 0\\<rbrakk>\n       \\<Longrightarrow> case (map_prod tighten_bounds_3 tighten_bounds_3 ^^\n                               i)\n                               x of\n                         (r, i) \\<Rightarrow>\n                           0 \\<in>\\<^sub>c ipoly_complex_interval p\n      (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 4. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 5. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "finally"], ["proof (chain)\npicking this:\n  length\n   (filter\n     (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n     (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n  (degree p - length rr) div 2", "show \"length (filter ?P ?rts) = ?nr\""], ["proof (prove)\nusing this:\n  length\n   (filter\n     (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n     (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n  (degree p - length rr) div 2\n\ngoal (1 subgoal):\n 1. length\n     (filter\n       (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n       (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n    (degree p - length rr) div 2", "by auto"], ["proof (state)\nthis:\n  length\n   (filter\n     (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n     (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n  (degree p - length rr) div 2\n\ngoal (4 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) = 0\\<rbrakk>\n       \\<Longrightarrow> case (map_prod tighten_bounds_3 tighten_bounds_3 ^^\n                               i)\n                               x of\n                         (r, i) \\<Rightarrow>\n                           0 \\<in>\\<^sub>c ipoly_complex_interval p\n      (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 3. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 4. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) = 0\\<rbrakk>\n       \\<Longrightarrow> case (map_prod tighten_bounds_3 tighten_bounds_3 ^^\n                               i)\n                               x of\n                         (r, i) \\<Rightarrow>\n                           0 \\<in>\\<^sub>c ipoly_complex_interval p\n      (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 3. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 4. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "fix n x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) = 0\\<rbrakk>\n       \\<Longrightarrow> case (map_prod tighten_bounds_3 tighten_bounds_3 ^^\n                               i)\n                               x of\n                         (r, i) \\<Rightarrow>\n                           0 \\<in>\\<^sub>c ipoly_complex_interval p\n      (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 3. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 4. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "assume x: \"?P x\""], ["proof (state)\nthis:\n  poly (complex_of_int_poly p) (pair_to_complex x) = 0\n\ngoal (4 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) = 0\\<rbrakk>\n       \\<Longrightarrow> case (map_prod tighten_bounds_3 tighten_bounds_3 ^^\n                               i)\n                               x of\n                         (r, i) \\<Rightarrow>\n                           0 \\<in>\\<^sub>c ipoly_complex_interval p\n      (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 3. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 4. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "obtain r i where xri: \"x = (r,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r i. x = (r, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x = (r, i)\n\ngoal (4 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) = 0\\<rbrakk>\n       \\<Longrightarrow> case (map_prod tighten_bounds_3 tighten_bounds_3 ^^\n                               i)\n                               x of\n                         (r, i) \\<Rightarrow>\n                           0 \\<in>\\<^sub>c ipoly_complex_interval p\n      (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 3. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 4. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "have id: \"(?f ^^ n) x = ((?tb ^^ n) r, (?tb ^^ n) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_prod tighten_bounds_3 tighten_bounds_3 ^^ n) x =\n    ((tighten_bounds_3 ^^ n) r, (tighten_bounds_3 ^^ n) i)", "unfolding xri"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_prod tighten_bounds_3 tighten_bounds_3 ^^ n) (r, i) =\n    ((tighten_bounds_3 ^^ n) r, (tighten_bounds_3 ^^ n) i)", "by (induct n, auto)"], ["proof (state)\nthis:\n  (map_prod tighten_bounds_3 tighten_bounds_3 ^^ n) x =\n  ((tighten_bounds_3 ^^ n) r, (tighten_bounds_3 ^^ n) i)\n\ngoal (4 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) = 0\\<rbrakk>\n       \\<Longrightarrow> case (map_prod tighten_bounds_3 tighten_bounds_3 ^^\n                               i)\n                               x of\n                         (r, i) \\<Rightarrow>\n                           0 \\<in>\\<^sub>c ipoly_complex_interval p\n      (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 3. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 4. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "have px: \"pair_to_complex x = Complex (real_of_3 r) (real_of_3 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_to_complex x = Complex (real_of_3 r) (real_of_3 i)", "unfolding xri pair_to_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (r, i) of\n     (r, i) \\<Rightarrow> Complex (real_of_3 r) (real_of_3 i)) =\n    Complex (real_of_3 r) (real_of_3 i)", "by auto"], ["proof (state)\nthis:\n  pair_to_complex x = Complex (real_of_3 r) (real_of_3 i)\n\ngoal (4 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) = 0\\<rbrakk>\n       \\<Longrightarrow> case (map_prod tighten_bounds_3 tighten_bounds_3 ^^\n                               i)\n                               x of\n                         (r, i) \\<Rightarrow>\n                           0 \\<in>\\<^sub>c ipoly_complex_interval p\n      (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 3. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 4. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "show \"?p ((?f ^^ n) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case (map_prod tighten_bounds_3 tighten_bounds_3 ^^ n) x of\n    (r, i) \\<Rightarrow>\n      0 \\<in>\\<^sub>c ipoly_complex_interval p\n                       (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))", "unfolding id split"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in>\\<^sub>c ipoly_complex_interval p\n                     (Complex_Interval\n                       (get_itvl_3 ((tighten_bounds_3 ^^ n) r))\n                       (get_itvl_3 ((tighten_bounds_3 ^^ n) i)))", "by (rule ipoly_complex_interval[of \"pair_to_complex x\" _ p, unfolded x], unfold px,\n            auto simp: in_complex_interval_def in_real_itvl_get_bounds_tighten)"], ["proof (state)\nthis:\n  case (map_prod tighten_bounds_3 tighten_bounds_3 ^^ n) x of\n  (r, i) \\<Rightarrow>\n    0 \\<in>\\<^sub>c ipoly_complex_interval p\n                     (Complex_Interval (get_itvl_3 r) (get_itvl_3 i))\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 2. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 3. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 2. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 3. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 2. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 3. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "assume x: \"x \\<in> set ?rts\" \"\\<not> ?P x\""], ["proof (state)\nthis:\n  x \\<in> set (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))\n  poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 2. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 3. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "let ?x = \"pair_to_complex x\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 2. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 3. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "obtain r i where xri: \"x = (r,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r i. x = (r, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x = (r, i)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 2. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 3. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "have id: \"(?f ^^ n) x = ((?tb ^^ n) r, (?tb ^^ n) i)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_prod tighten_bounds_3 tighten_bounds_3 ^^ n) x =\n    ((tighten_bounds_3 ^^ n) r, (tighten_bounds_3 ^^ n) i)", "unfolding xri"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_prod tighten_bounds_3 tighten_bounds_3 ^^ n) (r, i) =\n    ((tighten_bounds_3 ^^ n) r, (tighten_bounds_3 ^^ n) i)", "by (induct n, auto)"], ["proof (state)\nthis:\n  (map_prod tighten_bounds_3 tighten_bounds_3 ^^ ?n1) x =\n  ((tighten_bounds_3 ^^ ?n1) r, (tighten_bounds_3 ^^ ?n1) i)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 2. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 3. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "have px: \"?x = Complex (real_of_3 r) (real_of_3 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_to_complex x = Complex (real_of_3 r) (real_of_3 i)", "unfolding xri pair_to_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (r, i) of\n     (r, i) \\<Rightarrow> Complex (real_of_3 r) (real_of_3 i)) =\n    Complex (real_of_3 r) (real_of_3 i)", "by auto"], ["proof (state)\nthis:\n  pair_to_complex x = Complex (real_of_3 r) (real_of_3 i)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 2. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 3. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "have cvg: \"(\\<lambda> n. ?itv ((?f ^^ n) x)) \\<longlonglongrightarrow>\\<^sub>c ipoly p ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        case (map_prod tighten_bounds_3 tighten_bounds_3 ^^ n) x of\n        (r, i) \\<Rightarrow>\n          ipoly_complex_interval p\n           (Complex_Interval (get_itvl_3 r)\n             (get_itvl_3 i))) \\<longlonglongrightarrow>\\<^sub>c\n    poly (complex_of_int_poly p) (pair_to_complex x)", "unfolding id split px"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ipoly_complex_interval p\n         (Complex_Interval (get_itvl_3 ((tighten_bounds_3 ^^ n) r))\n           (get_itvl_3\n             ((tighten_bounds_3 ^^ n)\n               i)))) \\<longlonglongrightarrow>\\<^sub>c\n    poly (complex_of_int_poly p) (Complex (real_of_3 r) (real_of_3 i))", "proof (rule ipoly_complex_interval_tendsto)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>ia.\n        Complex_Interval (get_itvl_3 ((tighten_bounds_3 ^^ ia) r))\n         (get_itvl_3\n           ((tighten_bounds_3 ^^ ia) i))) \\<longlonglongrightarrow>\\<^sub>c\n    Complex (real_of_3 r) (real_of_3 i)", "show \"(\\<lambda>ia. Complex_Interval (get_itvl_3 ((?tb ^^ ia) r)) (get_itvl_3 ((?tb ^^ ia) i))) \\<longlonglongrightarrow>\\<^sub>c\n            Complex (real_of_3 r) (real_of_3 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ia.\n        Complex_Interval (get_itvl_3 ((tighten_bounds_3 ^^ ia) r))\n         (get_itvl_3\n           ((tighten_bounds_3 ^^ ia) i))) \\<longlonglongrightarrow>\\<^sub>c\n    Complex (real_of_3 r) (real_of_3 i)", "unfolding complex_interval_tendsto_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re_interval \\<circ>\n     (\\<lambda>ia.\n         Complex_Interval (get_itvl_3 ((tighten_bounds_3 ^^ ia) r))\n          (get_itvl_3\n            ((tighten_bounds_3 ^^ ia)\n              i)))) \\<longlonglongrightarrow>\\<^sub>i\n    Re (Complex (real_of_3 r) (real_of_3 i)) \\<and>\n    (Im_interval \\<circ>\n     (\\<lambda>ia.\n         Complex_Interval (get_itvl_3 ((tighten_bounds_3 ^^ ia) r))\n          (get_itvl_3\n            ((tighten_bounds_3 ^^ ia)\n              i)))) \\<longlonglongrightarrow>\\<^sub>i\n    Im (Complex (real_of_3 r) (real_of_3 i))", "by (simp add: tends_to_tight_bounds_3 o_def)"], ["proof (state)\nthis:\n  (\\<lambda>ia.\n      Complex_Interval (get_itvl_3 ((tighten_bounds_3 ^^ ia) r))\n       (get_itvl_3\n         ((tighten_bounds_3 ^^ ia) i))) \\<longlonglongrightarrow>\\<^sub>c\n  Complex (real_of_3 r) (real_of_3 i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      case (map_prod tighten_bounds_3 tighten_bounds_3 ^^ n) x of\n      (r, i) \\<Rightarrow>\n        ipoly_complex_interval p\n         (Complex_Interval (get_itvl_3 r)\n           (get_itvl_3 i))) \\<longlonglongrightarrow>\\<^sub>c\n  poly (complex_of_int_poly p) (pair_to_complex x)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (concat\n                              (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR));\n        poly (complex_of_int_poly p) (pair_to_complex x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> (case (map_prod tighten_bounds_3\n     tighten_bounds_3 ^^\n    i)\n    x of\n                                    (r, i) \\<Rightarrow>\n0 \\<in>\\<^sub>c ipoly_complex_interval p\n                 (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n 2. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 3. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "from complex_interval_tendsto_neq[OF this x(2)]"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     \\<not> 0 \\<in>\\<^sub>c (case (map_prod tighten_bounds_3\n                                    tighten_bounds_3 ^^\n                                   n)\n                                   x of\n                             (r, i) \\<Rightarrow>\n                               ipoly_complex_interval p\n                                (Complex_Interval (get_itvl_3 r)\n                                  (get_itvl_3 i)))", "show \"\\<exists> i. \\<not> ?p ((?f ^^ i) x)\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     \\<not> 0 \\<in>\\<^sub>c (case (map_prod tighten_bounds_3\n                                    tighten_bounds_3 ^^\n                                   n)\n                                   x of\n                             (r, i) \\<Rightarrow>\n                               ipoly_complex_interval p\n                                (Complex_Interval (get_itvl_3 r)\n                                  (get_itvl_3 i)))\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       \\<not> (case (map_prod tighten_bounds_3 tighten_bounds_3 ^^ i) x of\n               (r, i) \\<Rightarrow>\n                 0 \\<in>\\<^sub>c ipoly_complex_interval p\n                                  (Complex_Interval (get_itvl_3 r)\n                                    (get_itvl_3 i)))", "unfolding id"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     \\<not> 0 \\<in>\\<^sub>c (case ((tighten_bounds_3 ^^ n) r,\n                                   (tighten_bounds_3 ^^ n) i) of\n                             (r, i) \\<Rightarrow>\n                               ipoly_complex_interval p\n                                (Complex_Interval (get_itvl_3 r)\n                                  (get_itvl_3 i)))\n\ngoal (1 subgoal):\n 1. \\<exists>ia.\n       \\<not> (case ((tighten_bounds_3 ^^ ia) r,\n                     (tighten_bounds_3 ^^ ia) i) of\n               (r, i) \\<Rightarrow>\n                 0 \\<in>\\<^sub>c ipoly_complex_interval p\n                                  (Complex_Interval (get_itvl_3 r)\n                                    (get_itvl_3 i)))", "by auto"], ["proof (state)\nthis:\n  \\<exists>i.\n     \\<not> (case (map_prod tighten_bounds_3 tighten_bounds_3 ^^ i) x of\n             (r, i) \\<Rightarrow>\n               0 \\<in>\\<^sub>c ipoly_complex_interval p\n                                (Complex_Interval (get_itvl_3 r)\n                                  (get_itvl_3 i)))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 2. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n       pair_to_complex x\n 2. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "show \"pair_to_complex (?f x) = pair_to_complex x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x) =\n    pair_to_complex x", "by (cases x, auto simp: pair_to_complex_def tighten_bounds_3(1))"], ["proof (state)\nthis:\n  pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 ?x1) =\n  pair_to_complex ?x1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (poly (complex_of_int_poly p)\n         (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n        0) =\n       (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "show \"?P (?f x) = ?P x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (complex_of_int_poly p)\n      (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 x)) =\n     0) =\n    (poly (complex_of_int_poly p) (pair_to_complex x) = 0)", "by (cases x, auto simp: pair_to_complex_def tighten_bounds_3(1))"], ["proof (state)\nthis:\n  (poly (complex_of_int_poly p)\n    (pair_to_complex (map_prod tighten_bounds_3 tighten_bounds_3 ?x1)) =\n   0) =\n  (poly (complex_of_int_poly p) (pair_to_complex ?x1) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map pair_to_complex\n   (filter_list_length (map_prod tighten_bounds_3 tighten_bounds_3)\n     (\\<lambda>(r, i).\n         0 \\<in>\\<^sub>c ipoly_complex_interval p\n                          (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n     ((degree p - length rr) div 2)\n     (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR))) =\n  map pair_to_complex\n   (filter\n     (\\<lambda>c. poly (complex_of_int_poly p) (pair_to_complex c) = 0)\n     (concat (map (\\<lambda>rx. map (Pair rx) cpxI) cpxR)))\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have l: \"complex_roots_of_int_poly3 p = ?ll'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly3 p =\n    rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)", "unfolding d filter cpx_def[symmetric] cpxI_def[symmetric] cpxR_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if degree p = length rr then rrts\n     else if degree p - length rr = 2\n          then rrts @\n               croots2\n                (map_poly (\\<lambda>r. Complex r 0)\n                  (real_of_int_poly p div\n                   (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])))\n          else rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n    rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)", "using False oFalse"], ["proof (prove)\nusing this:\n  degree p - length rr \\<noteq> 2\n  degree p \\<noteq> length rr\n\ngoal (1 subgoal):\n 1. (if degree p = length rr then rrts\n     else if degree p - length rr = 2\n          then rrts @\n               croots2\n                (map_poly (\\<lambda>r. Complex r 0)\n                  (real_of_int_poly p div\n                   (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])))\n          else rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n    rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)", "by auto"], ["proof (state)\nthis:\n  complex_roots_of_int_poly3 p =\n  rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"distinct ?ll' = (distinct rrts \\<and> distinct ?LL' \\<and> set rrts \\<inter> set ?LL' = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n    (distinct rrts \\<and>\n     distinct (concat (map (\\<lambda>x. [x, cnj x]) cpx)) \\<and>\n     set rrts \\<inter> set (concat (map (\\<lambda>x. [x, cnj x]) cpx)) = {})", "unfolding distinct_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. (distinct rrts \\<and>\n     distinct (concat (map (\\<lambda>x. [x, cnj x]) cpx)) \\<and>\n     set rrts \\<inter> set (concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n     {}) =\n    (distinct rrts \\<and>\n     distinct (concat (map (\\<lambda>x. [x, cnj x]) cpx)) \\<and>\n     set rrts \\<inter> set (concat (map (\\<lambda>x. [x, cnj x]) cpx)) = {})", ".."], ["proof (state)\nthis:\n  distinct (rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n  (distinct rrts \\<and>\n   distinct (concat (map (\\<lambda>x. [x, cnj x]) cpx)) \\<and>\n   set rrts \\<inter> set (concat (map (\\<lambda>x. [x, cnj x]) cpx)) = {})\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "also"], ["proof (state)\nthis:\n  distinct (rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n  (distinct rrts \\<and>\n   distinct (concat (map (\\<lambda>x. [x, cnj x]) cpx)) \\<and>\n   set rrts \\<inter> set (concat (map (\\<lambda>x. [x, cnj x]) cpx)) = {})\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"set ?LL' = set ?LL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n    set (cpx @ map cnj cpx)", "by auto"], ["proof (state)\nthis:\n  set (concat (map (\\<lambda>x. [x, cnj x]) cpx)) = set (cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "also"], ["proof (state)\nthis:\n  set (concat (map (\\<lambda>x. [x, cnj x]) cpx)) = set (cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"distinct ?LL' = distinct ?LL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n    distinct (cpx @ map cnj cpx)", "by (induct cpx, auto)"], ["proof (state)\nthis:\n  distinct (concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n  distinct (cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "finally"], ["proof (chain)\npicking this:\n  distinct (rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n  (distinct rrts \\<and>\n   distinct (cpx @ map cnj cpx) \\<and>\n   set rrts \\<inter> set (cpx @ map cnj cpx) = {})", "have \"distinct ?ll' = distinct ?ll\""], ["proof (prove)\nusing this:\n  distinct (rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n  (distinct rrts \\<and>\n   distinct (cpx @ map cnj cpx) \\<and>\n   set rrts \\<inter> set (cpx @ map cnj cpx) = {})\n\ngoal (1 subgoal):\n 1. distinct (rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n    distinct (rrts @ cpx @ map cnj cpx)", "unfolding distinct_append"], ["proof (prove)\nusing this:\n  (distinct rrts \\<and>\n   distinct (concat (map (\\<lambda>x. [x, cnj x]) cpx)) \\<and>\n   set rrts \\<inter> set (concat (map (\\<lambda>x. [x, cnj x]) cpx)) = {}) =\n  (distinct rrts \\<and>\n   (distinct cpx \\<and>\n    distinct (map cnj cpx) \\<and>\n    set cpx \\<inter> set (map cnj cpx) = {}) \\<and>\n   set rrts \\<inter> set (cpx @ map cnj cpx) = {})\n\ngoal (1 subgoal):\n 1. (distinct rrts \\<and>\n     distinct (concat (map (\\<lambda>x. [x, cnj x]) cpx)) \\<and>\n     set rrts \\<inter> set (concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n     {}) =\n    (distinct rrts \\<and>\n     (distinct cpx \\<and>\n      distinct (map cnj cpx) \\<and>\n      set cpx \\<inter> set (map cnj cpx) = {}) \\<and>\n     set rrts \\<inter> set (cpx @ map cnj cpx) = {})", "by auto"], ["proof (state)\nthis:\n  distinct (rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n  distinct (rrts @ cpx @ map cnj cpx)\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "with dist"], ["proof (chain)\npicking this:\n  distinct (rrts @ cpx @ map cnj cpx)\n  distinct (rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n  distinct (rrts @ cpx @ map cnj cpx)", "have \"distinct ?ll'\""], ["proof (prove)\nusing this:\n  distinct (rrts @ cpx @ map cnj cpx)\n  distinct (rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)) =\n  distinct (rrts @ cpx @ map cnj cpx)\n\ngoal (1 subgoal):\n 1. distinct (rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx))", "by auto"], ["proof (state)\nthis:\n  distinct (rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx))\n\ngoal (2 subgoals):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)\n 2. degree p - length rr \\<noteq> 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "with lr l"], ["proof (chain)\npicking this:\n  set (rrts @ cpx @ map cnj cpx) = {x. poly (complex_of_int_poly p) x = 0}\n  complex_roots_of_int_poly3 p =\n  rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)\n  distinct (rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (rrts @ cpx @ map cnj cpx) = {x. poly (complex_of_int_poly p) x = 0}\n  complex_roots_of_int_poly3 p =\n  rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx)\n  distinct (rrts @ concat (map (\\<lambda>x. [x, cnj x]) cpx))\n\ngoal (1 subgoal):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "by auto"], ["proof (state)\nthis:\n  set (complex_roots_of_int_poly3 p) =\n  {x. poly (complex_of_int_poly p) x = 0} \\<and>\n  distinct (complex_roots_of_int_poly3 p)\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "case True"], ["proof (state)\nthis:\n  degree p - length rr = 2\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?cr = \"map_poly of_real :: real poly \\<Rightarrow> complex poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "define pp where \"pp = complex_of_int_poly p\""], ["proof (state)\nthis:\n  pp = complex_of_int_poly p\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have id: \"pp = map_poly of_real q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp = map_poly complex_of_real q", "unfolding q_def pp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_int_poly p = map_poly complex_of_real (real_of_int_poly p)", "by (subst map_poly_map_poly, auto simp: o_def)"], ["proof (state)\nthis:\n  pp = map_poly complex_of_real q\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?rts = \"map (\\<lambda> x. [:-x,1:]) rr\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "define rts where \"rts = prod_list ?rts\""], ["proof (state)\nthis:\n  rts = (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "let ?c2 = \"?cr (q div rts)\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have pq: \"\\<And> x. ipoly p x = 0 \\<longleftrightarrow> poly q x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (poly (real_of_int_poly p) x = 0) = (poly q x = 0)", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (poly (real_of_int_poly p) x = 0) = (poly (real_of_int_poly p) x = 0)", "by simp"], ["proof (state)\nthis:\n  (poly (real_of_int_poly p) ?x1 = 0) = (poly q ?x1 = 0)\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from True"], ["proof (chain)\npicking this:\n  degree p - length rr = 2", "have 2: \"degree q - card {x. poly q x = 0} = 2\""], ["proof (prove)\nusing this:\n  degree p - length rr = 2\n\ngoal (1 subgoal):\n 1. degree q - card {x. poly q x = 0} = 2", "unfolding pq[symmetric] lrr"], ["proof (prove)\nusing this:\n  degree p - card {x. poly (real_of_int_poly p) x = 0} = 2\n\ngoal (1 subgoal):\n 1. degree q - card {x. poly (real_of_int_poly p) x = 0} = 2", "unfolding q_def"], ["proof (prove)\nusing this:\n  degree p - card {x. poly (real_of_int_poly p) x = 0} = 2\n\ngoal (1 subgoal):\n 1. degree (real_of_int_poly p) -\n    card {x. poly (real_of_int_poly p) x = 0} =\n    2", "by simp"], ["proof (state)\nthis:\n  degree q - card {x. poly q x = 0} = 2\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from True"], ["proof (chain)\npicking this:\n  degree p - length rr = 2", "have id: \"degree p = length rr \\<longleftrightarrow> False\" \n        \"degree p - length rr = 2 \\<longleftrightarrow> True\""], ["proof (prove)\nusing this:\n  degree p - length rr = 2\n\ngoal (1 subgoal):\n 1. (degree p = length rr) = False &&& (degree p - length rr = 2) = True", "by auto"], ["proof (state)\nthis:\n  (degree p = length rr) = False\n  (degree p - length rr = 2) = True\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have l: \"?l = of_real ` {x. poly q x = 0} \\<union> set (croots2 ?c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (complex_roots_of_int_poly3 p) =\n    complex_of_real ` {x. poly q x = 0} \\<union>\n    set (croots2 (map_poly complex_of_real (q div rts)))", "unfolding d rts_def id if_False if_True set_append rrts Reals_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (map_poly complex_of_real q) x = 0 \\<and>\n        x \\<in> range complex_of_real} \\<union>\n    set (croots2\n          (map_poly (\\<lambda>r. Complex r 0)\n            (real_of_int_poly p div\n             (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])))) =\n    complex_of_real ` {x. poly q x = 0} \\<union>\n    set (croots2\n          (map_poly complex_of_real\n            (q div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]))))", "by (fold complex_of_real_def q_def, auto)"], ["proof (state)\nthis:\n  set (complex_roots_of_int_poly3 p) =\n  complex_of_real ` {x. poly q x = 0} \\<union>\n  set (croots2 (map_poly complex_of_real (q div rts)))\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from dist"], ["proof (chain)\npicking this:\n  distinct rr", "have len_rr: \"length rr = card {x. poly q x = 0}\""], ["proof (prove)\nusing this:\n  distinct rr\n\ngoal (1 subgoal):\n 1. length rr = card {x. poly q x = 0}", "unfolding rr[unfolded pq, symmetric]"], ["proof (prove)\nusing this:\n  distinct rr\n\ngoal (1 subgoal):\n 1. length rr = card (set rr)", "by (simp add: distinct_card)"], ["proof (state)\nthis:\n  length rr = card {x. poly q x = 0}\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have rr': \"\\<And> r. r \\<in> set rr \\<Longrightarrow> poly q r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> set rr \\<Longrightarrow> poly q r = 0", "using rr"], ["proof (prove)\nusing this:\n  set rr = {x. poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> set rr \\<Longrightarrow> poly q r = 0", "unfolding q_def"], ["proof (prove)\nusing this:\n  set rr = {x. poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> set rr \\<Longrightarrow> poly (real_of_int_poly p) r = 0", "by simp"], ["proof (state)\nthis:\n  ?r1 \\<in> set rr \\<Longrightarrow> poly q ?r1 = 0\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "with dist"], ["proof (chain)\npicking this:\n  distinct rr\n  ?r1 \\<in> set rr \\<Longrightarrow> poly q ?r1 = 0", "have \"q = q div prod_list ?rts * prod_list ?rts\""], ["proof (prove)\nusing this:\n  distinct rr\n  ?r1 \\<in> set rr \\<Longrightarrow> poly q ?r1 = 0\n\ngoal (1 subgoal):\n 1. q =\n    q div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n    (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])", "proof (induct rr arbitrary: q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "case (Cons r rr q)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct rr;\n   \\<And>r. r \\<in> set rr \\<Longrightarrow> poly ?q1 r = 0\\<rbrakk>\n  \\<Longrightarrow> ?q1 =\n                    ?q1 div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                    (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])\n  distinct (r # rr)\n  ?r1 \\<in> set (r # rr) \\<Longrightarrow> poly q ?r1 = 0\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "note dist = Cons(2)"], ["proof (state)\nthis:\n  distinct (r # rr)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "let ?p = \"q div [:-r,1:]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "from Cons.prems(2)"], ["proof (chain)\npicking this:\n  ?r1 \\<in> set (r # rr) \\<Longrightarrow> poly q ?r1 = 0", "have \"poly q r = 0\""], ["proof (prove)\nusing this:\n  ?r1 \\<in> set (r # rr) \\<Longrightarrow> poly q ?r1 = 0\n\ngoal (1 subgoal):\n 1. poly q r = 0", "by simp"], ["proof (state)\nthis:\n  poly q r = 0\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "hence \"[:-r,1:] dvd q\""], ["proof (prove)\nusing this:\n  poly q r = 0\n\ngoal (1 subgoal):\n 1. [:- r, 1:] dvd q", "using poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  poly q r = 0\n  (poly ?p ?c = (0::?'a)) = ([:- ?c, 1::?'a:] dvd ?p)\n\ngoal (1 subgoal):\n 1. [:- r, 1:] dvd q", "by blast"], ["proof (state)\nthis:\n  [:- r, 1:] dvd q\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "from dvd_mult_div_cancel[OF this]"], ["proof (chain)\npicking this:\n  [:- r, 1:] * (q div [:- r, 1:]) = q", "have \"q = ?p * [:-r,1:]\""], ["proof (prove)\nusing this:\n  [:- r, 1:] * (q div [:- r, 1:]) = q\n\ngoal (1 subgoal):\n 1. q = q div [:- r, 1:] * [:- r, 1:]", "by simp"], ["proof (state)\nthis:\n  q = q div [:- r, 1:] * [:- r, 1:]\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "moreover"], ["proof (state)\nthis:\n  q = q div [:- r, 1:] * [:- r, 1:]\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "have \"?p = ?p div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) * (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q div [:- r, 1:] =\n    q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n    (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])", "proof (rule Cons.hyps)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct rr\n 2. \\<And>ra.\n       ra \\<in> set rr \\<Longrightarrow> poly (q div [:- r, 1:]) ra = 0", "show \"distinct rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct rr", "using dist"], ["proof (prove)\nusing this:\n  distinct (r # rr)\n\ngoal (1 subgoal):\n 1. distinct rr", "by auto"], ["proof (state)\nthis:\n  distinct rr\n\ngoal (1 subgoal):\n 1. \\<And>ra.\n       ra \\<in> set rr \\<Longrightarrow> poly (q div [:- r, 1:]) ra = 0", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ra.\n       ra \\<in> set rr \\<Longrightarrow> poly (q div [:- r, 1:]) ra = 0", "assume \"s \\<in> set rr\""], ["proof (state)\nthis:\n  s \\<in> set rr\n\ngoal (1 subgoal):\n 1. \\<And>ra.\n       ra \\<in> set rr \\<Longrightarrow> poly (q div [:- r, 1:]) ra = 0", "with dist Cons(3)"], ["proof (chain)\npicking this:\n  distinct (r # rr)\n  ?r1 \\<in> set (r # rr) \\<Longrightarrow> poly q ?r1 = 0\n  s \\<in> set rr", "have \"s \\<noteq> r\" \"poly q s = 0\""], ["proof (prove)\nusing this:\n  distinct (r # rr)\n  ?r1 \\<in> set (r # rr) \\<Longrightarrow> poly q ?r1 = 0\n  s \\<in> set rr\n\ngoal (1 subgoal):\n 1. s \\<noteq> r &&& poly q s = 0", "by auto"], ["proof (state)\nthis:\n  s \\<noteq> r\n  poly q s = 0\n\ngoal (1 subgoal):\n 1. \\<And>ra.\n       ra \\<in> set rr \\<Longrightarrow> poly (q div [:- r, 1:]) ra = 0", "hence \"poly (?p * [:- 1 * r, 1:]) s = 0\""], ["proof (prove)\nusing this:\n  s \\<noteq> r\n  poly q s = 0\n\ngoal (1 subgoal):\n 1. poly (q div [:- r, 1:] * [:- 1 * r, 1:]) s = 0", "using calculation"], ["proof (prove)\nusing this:\n  s \\<noteq> r\n  poly q s = 0\n  q = q div [:- r, 1:] * [:- r, 1:]\n\ngoal (1 subgoal):\n 1. poly (q div [:- r, 1:] * [:- 1 * r, 1:]) s = 0", "by force"], ["proof (state)\nthis:\n  poly (q div [:- r, 1:] * [:- 1 * r, 1:]) s = 0\n\ngoal (1 subgoal):\n 1. \\<And>ra.\n       ra \\<in> set rr \\<Longrightarrow> poly (q div [:- r, 1:]) ra = 0", "thus \"poly ?p s = 0\""], ["proof (prove)\nusing this:\n  poly (q div [:- r, 1:] * [:- 1 * r, 1:]) s = 0\n\ngoal (1 subgoal):\n 1. poly (q div [:- r, 1:]) s = 0", "by (simp add: \\<open>s \\<noteq> r\\<close>)"], ["proof (state)\nthis:\n  poly (q div [:- r, 1:]) s = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q div [:- r, 1:] =\n  q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "ultimately"], ["proof (chain)\npicking this:\n  q = q div [:- r, 1:] * [:- r, 1:]\n  q div [:- r, 1:] =\n  q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])", "have q: \"q = ?p div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) * (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) * [:-r,1:]\""], ["proof (prove)\nusing this:\n  q = q div [:- r, 1:] * [:- r, 1:]\n  q div [:- r, 1:] =\n  q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. q =\n    q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n    (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n    [:- r, 1:]", "by auto"], ["proof (state)\nthis:\n  q =\n  q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  [:- r, 1:]\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "also"], ["proof (state)\nthis:\n  q =\n  q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  [:- r, 1:]\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "have \"\\<dots> = (?p div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])) * (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n    (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n    [:- r, 1:] =\n    q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n    (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:])", "unfolding mult.assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n    ((\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) * [:- r, 1:]) =\n    q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n    (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:])", "by simp"], ["proof (state)\nthis:\n  q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  [:- r, 1:] =\n  q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:])\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "also"], ["proof (state)\nthis:\n  q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  [:- r, 1:] =\n  q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:])\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "have \"?p div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) = q div (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) =\n    q div (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:])", "unfolding poly_div_mult_right[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. q div ([:- r, 1:] * (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])) =\n    q div (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:])", "by simp"], ["proof (state)\nthis:\n  q div [:- r, 1:] div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) =\n  q div (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:])\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])\n 2. \\<And>a rr q.\n       \\<lbrakk>\\<And>q.\n                   \\<lbrakk>distinct rr;\n                    \\<And>r.\n                       r \\<in> set rr \\<Longrightarrow>\n                       poly q r = 0\\<rbrakk>\n                   \\<Longrightarrow> q =\n                                     q div\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n                                     (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]);\n        distinct (a # rr);\n        \\<And>r.\n           r \\<in> set (a # rr) \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>a # rr. [:- x, 1:])", "finally"], ["proof (chain)\npicking this:\n  q =\n  q div (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:])", "show ?case"], ["proof (prove)\nusing this:\n  q =\n  q div (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. q =\n    q div (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:]) *\n    (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:])", "."], ["proof (state)\nthis:\n  q =\n  q div (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>r # rr. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>distinct [];\n        \\<And>r. r \\<in> set [] \\<Longrightarrow> poly q r = 0\\<rbrakk>\n       \\<Longrightarrow> q =\n                         q div (\\<Prod>x\\<leftarrow>[]. [:- x, 1:]) *\n                         (\\<Prod>x\\<leftarrow>[]. [:- x, 1:])", "qed simp"], ["proof (state)\nthis:\n  q =\n  q div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "hence q_div: \"q = q div rts * rts\""], ["proof (prove)\nusing this:\n  q =\n  q div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. q = q div rts * rts", "unfolding rts_def"], ["proof (prove)\nusing this:\n  q =\n  q div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n  (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. q =\n    q div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) *\n    (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])", "."], ["proof (state)\nthis:\n  q = q div rts * rts\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from q_div q0"], ["proof (chain)\npicking this:\n  q = q div rts * rts\n  q \\<noteq> 0", "have \"q div rts \\<noteq> 0\" \"rts \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q = q div rts * rts\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q div rts \\<noteq> 0 &&& rts \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q div rts \\<noteq> 0\n  rts \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from degree_mult_eq[OF this]"], ["proof (chain)\npicking this:\n  degree (q div rts * rts) = degree (q div rts) + degree rts", "have \"degree q = degree (q div rts) + degree rts\""], ["proof (prove)\nusing this:\n  degree (q div rts * rts) = degree (q div rts) + degree rts\n\ngoal (1 subgoal):\n 1. degree q = degree (q div rts) + degree rts", "using q_div"], ["proof (prove)\nusing this:\n  degree (q div rts * rts) = degree (q div rts) + degree rts\n  q = q div rts * rts\n\ngoal (1 subgoal):\n 1. degree q = degree (q div rts) + degree rts", "by simp"], ["proof (state)\nthis:\n  degree q = degree (q div rts) + degree rts\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "also"], ["proof (state)\nthis:\n  degree q = degree (q div rts) + degree rts\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"degree rts = length rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree rts = length rr", "unfolding rts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]) = length rr", "by (rule degree_linear_factors)"], ["proof (state)\nthis:\n  degree rts = length rr\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "also"], ["proof (state)\nthis:\n  degree rts = length rr\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"\\<dots> = card {x. poly q x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length rr = card {x. poly q x = 0}", "unfolding len_rr"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly q x = 0} = card {x. poly q x = 0}", "by simp"], ["proof (state)\nthis:\n  length rr = card {x. poly q x = 0}\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "finally"], ["proof (chain)\npicking this:\n  degree q = degree (q div rts) + card {x. poly q x = 0}", "have deg2: \"degree ?c2 = 2\""], ["proof (prove)\nusing this:\n  degree q = degree (q div rts) + card {x. poly q x = 0}\n\ngoal (1 subgoal):\n 1. degree (map_poly complex_of_real (q div rts)) = 2", "using 2"], ["proof (prove)\nusing this:\n  degree q = degree (q div rts) + card {x. poly q x = 0}\n  degree q - card {x. poly q x = 0} = 2\n\ngoal (1 subgoal):\n 1. degree (map_poly complex_of_real (q div rts)) = 2", "by simp"], ["proof (state)\nthis:\n  degree (map_poly complex_of_real (q div rts)) = 2\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "note croots2 = croots2[OF deg2, symmetric]"], ["proof (state)\nthis:\n  set (croots2 (map_poly complex_of_real (q div rts))) =\n  {x. poly (map_poly complex_of_real (q div rts)) x = 0}\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"?q = ?cr (q div rts * rts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real q = map_poly complex_of_real (q div rts * rts)", "using q_div"], ["proof (prove)\nusing this:\n  q = q div rts * rts\n\ngoal (1 subgoal):\n 1. map_poly complex_of_real q = map_poly complex_of_real (q div rts * rts)", "by simp"], ["proof (state)\nthis:\n  map_poly complex_of_real q = map_poly complex_of_real (q div rts * rts)\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "also"], ["proof (state)\nthis:\n  map_poly complex_of_real q = map_poly complex_of_real (q div rts * rts)\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"\\<dots> = ?cr rts * ?c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real (q div rts * rts) =\n    map_poly complex_of_real rts * map_poly complex_of_real (q div rts)", "unfolding hom_distribs"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real q div map_poly complex_of_real rts *\n    map_poly complex_of_real rts =\n    map_poly complex_of_real rts *\n    (map_poly complex_of_real q div map_poly complex_of_real rts)", "by simp"], ["proof (state)\nthis:\n  map_poly complex_of_real (q div rts * rts) =\n  map_poly complex_of_real rts * map_poly complex_of_real (q div rts)\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "finally"], ["proof (chain)\npicking this:\n  map_poly complex_of_real q =\n  map_poly complex_of_real rts * map_poly complex_of_real (q div rts)", "have q_prod: \"?q = ?cr rts * ?c2\""], ["proof (prove)\nusing this:\n  map_poly complex_of_real q =\n  map_poly complex_of_real rts * map_poly complex_of_real (q div rts)\n\ngoal (1 subgoal):\n 1. map_poly complex_of_real q =\n    map_poly complex_of_real rts * map_poly complex_of_real (q div rts)", "."], ["proof (state)\nthis:\n  map_poly complex_of_real q =\n  map_poly complex_of_real rts * map_poly complex_of_real (q div rts)\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from croots2 l"], ["proof (chain)\npicking this:\n  set (croots2 (map_poly complex_of_real (q div rts))) =\n  {x. poly (map_poly complex_of_real (q div rts)) x = 0}\n  set (complex_roots_of_int_poly3 p) =\n  complex_of_real ` {x. poly q x = 0} \\<union>\n  set (croots2 (map_poly complex_of_real (q div rts)))", "have l: \"?l = of_real ` {x. poly q x = 0} \\<union> {x. poly ?c2 x = 0}\""], ["proof (prove)\nusing this:\n  set (croots2 (map_poly complex_of_real (q div rts))) =\n  {x. poly (map_poly complex_of_real (q div rts)) x = 0}\n  set (complex_roots_of_int_poly3 p) =\n  complex_of_real ` {x. poly q x = 0} \\<union>\n  set (croots2 (map_poly complex_of_real (q div rts)))\n\ngoal (1 subgoal):\n 1. set (complex_roots_of_int_poly3 p) =\n    complex_of_real ` {x. poly q x = 0} \\<union>\n    {x. poly (map_poly complex_of_real (q div rts)) x = 0}", "by simp"], ["proof (state)\nthis:\n  set (complex_roots_of_int_poly3 p) =\n  complex_of_real ` {x. poly q x = 0} \\<union>\n  {x. poly (map_poly complex_of_real (q div rts)) x = 0}\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "from r[unfolded q_prod]"], ["proof (chain)\npicking this:\n  {x. poly (complex_of_int_poly p) x = 0} =\n  {x. poly\n       (map_poly complex_of_real rts * map_poly complex_of_real (q div rts))\n       x =\n      0}", "have r: \"?r = {x. poly (?cr rts) x = 0} \\<union> {x. poly ?c2 x = 0}\""], ["proof (prove)\nusing this:\n  {x. poly (complex_of_int_poly p) x = 0} =\n  {x. poly\n       (map_poly complex_of_real rts * map_poly complex_of_real (q div rts))\n       x =\n      0}\n\ngoal (1 subgoal):\n 1. {x. poly (complex_of_int_poly p) x = 0} =\n    {x. poly (map_poly complex_of_real rts) x = 0} \\<union>\n    {x. poly (map_poly complex_of_real (q div rts)) x = 0}", "by auto"], ["proof (state)\nthis:\n  {x. poly (complex_of_int_poly p) x = 0} =\n  {x. poly (map_poly complex_of_real rts) x = 0} \\<union>\n  {x. poly (map_poly complex_of_real (q div rts)) x = 0}\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "also"], ["proof (state)\nthis:\n  {x. poly (complex_of_int_poly p) x = 0} =\n  {x. poly (map_poly complex_of_real rts) x = 0} \\<union>\n  {x. poly (map_poly complex_of_real (q div rts)) x = 0}\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"?cr rts = (\\<Prod>x\\<leftarrow>rr. ?cr [:- x, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly complex_of_real rts =\n    (\\<Prod>x\\<leftarrow>rr. map_poly complex_of_real [:- x, 1:])", "by (simp add: rts_def o_def of_real_poly_hom.hom_prod_list)"], ["proof (state)\nthis:\n  map_poly complex_of_real rts =\n  (\\<Prod>x\\<leftarrow>rr. map_poly complex_of_real [:- x, 1:])\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "also"], ["proof (state)\nthis:\n  map_poly complex_of_real rts =\n  (\\<Prod>x\\<leftarrow>rr. map_poly complex_of_real [:- x, 1:])\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"{x. poly \\<dots> x = 0} = of_real ` set rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (\\<Prod>x\\<leftarrow>rr. map_poly complex_of_real [:- x, 1:])\n         x =\n        0} =\n    complex_of_real ` set rr", "unfolding poly_prod_list_zero_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>p\\<in>set (map (\\<lambda>x.\n                                    map_poly complex_of_real [:- x, 1:])\n                             rr).\n           poly p x = 0} =\n    complex_of_real ` set rr", "by auto"], ["proof (state)\nthis:\n  {x. poly (\\<Prod>x\\<leftarrow>rr. map_poly complex_of_real [:- x, 1:]) x =\n      0} =\n  complex_of_real ` set rr\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "also"], ["proof (state)\nthis:\n  {x. poly (\\<Prod>x\\<leftarrow>rr. map_poly complex_of_real [:- x, 1:]) x =\n      0} =\n  complex_of_real ` set rr\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"set rr = {x. poly q x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set rr = {x. poly q x = 0}", "unfolding rr q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (real_of_int_poly p) x = 0} =\n    {x. poly (real_of_int_poly p) x = 0}", "by simp"], ["proof (state)\nthis:\n  set rr = {x. poly q x = 0}\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "finally"], ["proof (chain)\npicking this:\n  {x. poly (complex_of_int_poly p) x = 0} =\n  complex_of_real ` {x. poly q x = 0} \\<union>\n  {x. poly (map_poly complex_of_real (q div rts)) x = 0}", "have lr: \"?l = ?r\""], ["proof (prove)\nusing this:\n  {x. poly (complex_of_int_poly p) x = 0} =\n  complex_of_real ` {x. poly q x = 0} \\<union>\n  {x. poly (map_poly complex_of_real (q div rts)) x = 0}\n\ngoal (1 subgoal):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}", "unfolding l"], ["proof (prove)\nusing this:\n  {x. poly (complex_of_int_poly p) x = 0} =\n  complex_of_real ` {x. poly q x = 0} \\<union>\n  {x. poly (map_poly complex_of_real (q div rts)) x = 0}\n\ngoal (1 subgoal):\n 1. complex_of_real ` {x. poly q x = 0} \\<union>\n    {x. poly (map_poly complex_of_real (q div rts)) x = 0} =\n    {x. poly (complex_of_int_poly p) x = 0}", "by simp"], ["proof (state)\nthis:\n  set (complex_roots_of_int_poly3 p) =\n  {x. poly (complex_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. degree p - length rr = 2 \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "proof (intro conjI[OF lr])"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "from sf"], ["proof (chain)\npicking this:\n  square_free p", "have sf: \"square_free q\""], ["proof (prove)\nusing this:\n  square_free p\n\ngoal (1 subgoal):\n 1. square_free q", "unfolding q_def"], ["proof (prove)\nusing this:\n  square_free p\n\ngoal (1 subgoal):\n 1. square_free (real_of_int_poly p)", "by (rule square_free_of_int_poly)"], ["proof (state)\nthis:\n  square_free q\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "{"], ["proof (state)\nthis:\n  square_free q\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "interpret field_hom_0' complex_of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. field_hom_0' complex_of_real", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "from sf"], ["proof (chain)\npicking this:\n  square_free q", "have \"square_free ?q\""], ["proof (prove)\nusing this:\n  square_free q\n\ngoal (1 subgoal):\n 1. square_free (map_poly complex_of_real q)", "unfolding square_free_map_poly"], ["proof (prove)\nusing this:\n  square_free q\n\ngoal (1 subgoal):\n 1. square_free q", "."], ["proof (state)\nthis:\n  square_free (map_poly complex_of_real q)\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "}"], ["proof (state)\nthis:\n  square_free (map_poly complex_of_real q)\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "note sf = this"], ["proof (state)\nthis:\n  square_free (map_poly complex_of_real q)\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "have l: \"complex_roots_of_int_poly3 p = rrts @ croots2 ?c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly3 p =\n    rrts @ croots2 (map_poly complex_of_real (q div rts))", "unfolding d rts_def id if_False if_True set_append rrts q_def complex_of_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rrts @\n    croots2\n     (map_poly (\\<lambda>r. Complex r 0)\n       (real_of_int_poly p div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:]))) =\n    rrts @\n    croots2\n     (map_poly (\\<lambda>r. Complex r 0)\n       (real_of_int_poly p div (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])))", "by auto"], ["proof (state)\nthis:\n  complex_roots_of_int_poly3 p =\n  rrts @ croots2 (map_poly complex_of_real (q div rts))\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "have dist2: \"distinct (croots2 ?c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (croots2 (map_poly complex_of_real (q div rts)))", "unfolding croots2_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (remdups\n       [- (coeff (map_poly complex_of_real (q div rts)) 1 /\n           (2 * coeff (map_poly complex_of_real (q div rts)) 2)) +\n        csqrt\n         ((coeff (map_poly complex_of_real (q div rts)) 1 /\n           (2 * coeff (map_poly complex_of_real (q div rts)) 2))\\<^sup>2 -\n          coeff (map_poly complex_of_real (q div rts)) 0 /\n          coeff (map_poly complex_of_real (q div rts)) 2),\n        - (coeff (map_poly complex_of_real (q div rts)) 1 /\n           (2 * coeff (map_poly complex_of_real (q div rts)) 2)) -\n        csqrt\n         ((coeff (map_poly complex_of_real (q div rts)) 1 /\n           (2 * coeff (map_poly complex_of_real (q div rts)) 2))\\<^sup>2 -\n          coeff (map_poly complex_of_real (q div rts)) 0 /\n          coeff (map_poly complex_of_real (q div rts)) 2)])", "by auto"], ["proof (state)\nthis:\n  distinct (croots2 (map_poly complex_of_real (q div rts)))\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "{"], ["proof (state)\nthis:\n  distinct (croots2 (map_poly complex_of_real (q div rts)))\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "assume x: \"x \\<in> set (croots2 ?c2)\" \"x \\<in> set rrts\""], ["proof (state)\nthis:\n  x \\<in> set (croots2 (map_poly complex_of_real (q div rts)))\n  x \\<in> set rrts\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "from x(1)[unfolded croots2]"], ["proof (chain)\npicking this:\n  x \\<in> {x. poly (map_poly complex_of_real (q div rts)) x = 0}", "have x1: \"poly ?c2 x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> {x. poly (map_poly complex_of_real (q div rts)) x = 0}\n\ngoal (1 subgoal):\n 1. poly (map_poly complex_of_real (q div rts)) x = 0", "by auto"], ["proof (state)\nthis:\n  poly (map_poly complex_of_real (q div rts)) x = 0\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "from x(2)"], ["proof (chain)\npicking this:\n  x \\<in> set rrts", "have x2: \"poly (?cr rts) x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> set rrts\n\ngoal (1 subgoal):\n 1. poly (map_poly complex_of_real rts) x = 0", "unfolding rrts_def rts_def complex_of_real_def[symmetric]"], ["proof (prove)\nusing this:\n  x \\<in> set (map complex_of_real rr)\n\ngoal (1 subgoal):\n 1. poly (map_poly complex_of_real (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])) x =\n    0", "by (auto simp: poly_prod_list_zero_iff o_def)"], ["proof (state)\nthis:\n  poly (map_poly complex_of_real rts) x = 0\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "from square_free_multD(1)[OF sf[unfolded q_prod], of \"[: -x, 1:]\"]\n            x1 x2"], ["proof (chain)\npicking this:\n  \\<lbrakk>[:- x, 1:] dvd map_poly complex_of_real rts;\n   [:- x, 1:] dvd map_poly complex_of_real (q div rts)\\<rbrakk>\n  \\<Longrightarrow> degree [:- x, 1:] = 0\n  poly (map_poly complex_of_real (q div rts)) x = 0\n  poly (map_poly complex_of_real rts) x = 0", "have False"], ["proof (prove)\nusing this:\n  \\<lbrakk>[:- x, 1:] dvd map_poly complex_of_real rts;\n   [:- x, 1:] dvd map_poly complex_of_real (q div rts)\\<rbrakk>\n  \\<Longrightarrow> degree [:- x, 1:] = 0\n  poly (map_poly complex_of_real (q div rts)) x = 0\n  poly (map_poly complex_of_real rts) x = 0\n\ngoal (1 subgoal):\n 1. False", "unfolding poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  \\<lbrakk>[:- x, 1:] dvd map_poly complex_of_real rts;\n   [:- x, 1:] dvd map_poly complex_of_real (q div rts)\\<rbrakk>\n  \\<Longrightarrow> degree [:- x, 1:] = 0\n  [:- x, 1:] dvd map_poly complex_of_real (q div rts)\n  [:- x, 1:] dvd map_poly complex_of_real rts\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x3 \\<in> set (croots2 (map_poly complex_of_real (q div rts)));\n   ?x3 \\<in> set rrts\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "note dist3 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?x3 \\<in> set (croots2 (map_poly complex_of_real (q div rts)));\n   ?x3 \\<in> set rrts\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "show \"distinct (complex_roots_of_int_poly3 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p)", "unfolding l distinct_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct rrts \\<and>\n    distinct (croots2 (map_poly complex_of_real (q div rts))) \\<and>\n    set rrts \\<inter> set (croots2 (map_poly complex_of_real (q div rts))) =\n    {}", "by (intro conjI dist1 dist2, insert dist3, auto)"], ["proof (state)\nthis:\n  distinct (complex_roots_of_int_poly3 p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (complex_roots_of_int_poly3 p) =\n  {x. poly (complex_of_int_poly p) x = 0} \\<and>\n  distinct (complex_roots_of_int_poly3 p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (complex_roots_of_int_poly3 p) =\n  {x. poly (complex_of_int_poly p) x = 0} \\<and>\n  distinct (complex_roots_of_int_poly3 p)\n\ngoal (1 subgoal):\n 1. degree p = length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p = length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "case True"], ["proof (state)\nthis:\n  degree p = length rr\n\ngoal (1 subgoal):\n 1. degree p = length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"card {x. poly ?q x = 0} \\<le> degree ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly (map_poly complex_of_real q) x = 0}\n    \\<le> degree (map_poly complex_of_real q)", "by (rule poly_roots_degree[OF q])"], ["proof (state)\nthis:\n  card {x. poly (map_poly complex_of_real q) x = 0}\n  \\<le> degree (map_poly complex_of_real q)\n\ngoal (1 subgoal):\n 1. degree p = length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "also"], ["proof (state)\nthis:\n  card {x. poly (map_poly complex_of_real q) x = 0}\n  \\<le> degree (map_poly complex_of_real q)\n\ngoal (1 subgoal):\n 1. degree p = length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"\\<dots> = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly complex_of_real q) = degree p", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly complex_of_real (real_of_int_poly p)) = degree p", "by simp"], ["proof (state)\nthis:\n  degree (map_poly complex_of_real q) = degree p\n\ngoal (1 subgoal):\n 1. degree p = length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "also"], ["proof (state)\nthis:\n  degree (map_poly complex_of_real q) = degree p\n\ngoal (1 subgoal):\n 1. degree p = length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"\\<dots> = card {x. poly ?q x = 0 \\<and> x \\<in> \\<real>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p =\n    card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}", "using True cr"], ["proof (prove)\nusing this:\n  degree p = length rr\n  length rr =\n  card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n\ngoal (1 subgoal):\n 1. degree p =\n    card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}", "by simp"], ["proof (state)\nthis:\n  degree p =\n  card {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n\ngoal (1 subgoal):\n 1. degree p = length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "finally"], ["proof (chain)\npicking this:\n  card {x. poly (map_poly complex_of_real q) x = 0}\n  \\<le> card\n         {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}", "have le: \"card {x. poly ?q x = 0} \\<le> card {x. poly ?q x = 0 \\<and> x \\<in> \\<real>}\""], ["proof (prove)\nusing this:\n  card {x. poly (map_poly complex_of_real q) x = 0}\n  \\<le> card\n         {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n\ngoal (1 subgoal):\n 1. card {x. poly (map_poly complex_of_real q) x = 0}\n    \\<le> card\n           {x. poly (map_poly complex_of_real q) x = 0 \\<and>\n               x \\<in> \\<real>}", "by auto"], ["proof (state)\nthis:\n  card {x. poly (map_poly complex_of_real q) x = 0}\n  \\<le> card\n         {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n\ngoal (1 subgoal):\n 1. degree p = length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "have \"{x. poly ?q x = 0 \\<and> x \\<in> \\<real>} = {x. poly ?q x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>} =\n    {x. poly (map_poly complex_of_real q) x = 0}", "by (rule card_seteq[OF _ _ le], insert poly_roots_finite[OF q], auto)"], ["proof (state)\nthis:\n  {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>} =\n  {x. poly (map_poly complex_of_real q) x = 0}\n\ngoal (1 subgoal):\n 1. degree p = length rr \\<Longrightarrow>\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "with True rrts dist1"], ["proof (chain)\npicking this:\n  degree p = length rr\n  set rrts =\n  {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n  distinct rrts\n  {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>} =\n  {x. poly (map_poly complex_of_real q) x = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  degree p = length rr\n  set rrts =\n  {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n  distinct rrts\n  {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>} =\n  {x. poly (map_poly complex_of_real q) x = 0}\n\ngoal (1 subgoal):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0} \\<and>\n    distinct (complex_roots_of_int_poly3 p)", "unfolding r d"], ["proof (prove)\nusing this:\n  degree p = length rr\n  set rrts =\n  {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>}\n  distinct rrts\n  {x. poly (map_poly complex_of_real q) x = 0 \\<and> x \\<in> \\<real>} =\n  {x. poly (map_poly complex_of_real q) x = 0}\n\ngoal (1 subgoal):\n 1. set (if degree p = length rr then rrts\n         else if degree p - length rr = 2\n              then rrts @\n                   croots2\n                    (map_poly (\\<lambda>r. Complex r 0)\n                      (real_of_int_poly p div\n                       (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])))\n              else rrts @\n                   concat\n                    (map (\\<lambda>x. [x, cnj x])\n                      (map pair_to_complex\n                        (filter_list_length\n                          (map_prod tighten_bounds_3 tighten_bounds_3)\n                          (\\<lambda>(r, i).\n                              0 \\<in>\\<^sub>c ipoly_complex_interval p\n         (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n                          ((degree p - length rr) div 2)\n                          (concat\n                            (map (\\<lambda>rx.\n                                     map (Pair rx)\n(pos_imaginary_parts_3 p))\n                              (real_parts_3 p))))))) =\n    {x. poly (map_poly complex_of_real q) x = 0} \\<and>\n    distinct\n     (if degree p = length rr then rrts\n      else if degree p - length rr = 2\n           then rrts @\n                croots2\n                 (map_poly (\\<lambda>r. Complex r 0)\n                   (real_of_int_poly p div\n                    (\\<Prod>x\\<leftarrow>rr. [:- x, 1:])))\n           else rrts @\n                concat\n                 (map (\\<lambda>x. [x, cnj x])\n                   (map pair_to_complex\n                     (filter_list_length\n                       (map_prod tighten_bounds_3 tighten_bounds_3)\n                       (\\<lambda>(r, i).\n                           0 \\<in>\\<^sub>c ipoly_complex_interval p\n      (Complex_Interval (get_itvl_3 r) (get_itvl_3 i)))\n                       ((degree p - length rr) div 2)\n                       (concat\n                         (map (\\<lambda>rx.\n                                  map (Pair rx) (pos_imaginary_parts_3 p))\n                           (real_parts_3 p)))))))", "by auto"], ["proof (state)\nthis:\n  set (complex_roots_of_int_poly3 p) =\n  {x. poly (complex_of_int_poly p) x = 0} \\<and>\n  distinct (complex_roots_of_int_poly3 p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (complex_roots_of_int_poly3 p) =\n  {x. poly (complex_of_int_poly p) x = 0} \\<and>\n  distinct (complex_roots_of_int_poly3 p)\n\ngoal (2 subgoals):\n 1. set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly3 p)", "thus \"distinct (complex_roots_of_int_poly3 p)\" \"?l = ?r\""], ["proof (prove)\nusing this:\n  set (complex_roots_of_int_poly3 p) =\n  {x. poly (complex_of_int_poly p) x = 0} \\<and>\n  distinct (complex_roots_of_int_poly3 p)\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly3 p) &&&\n    set (complex_roots_of_int_poly3 p) =\n    {x. poly (complex_of_int_poly p) x = 0}", "by auto"], ["proof (state)\nthis:\n  distinct (complex_roots_of_int_poly3 p)\n  set (complex_roots_of_int_poly3 p) =\n  {x. poly (complex_of_int_poly p) x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complex_roots_of_int_poly_all: assumes sf: \"degree p \\<ge> 3 \\<Longrightarrow> square_free p\" \n  shows \"p \\<noteq> 0 \\<Longrightarrow> set (complex_roots_of_int_poly_all p) = {x. ipoly p x = 0}\" (is \"_ \\<Longrightarrow> set ?l = ?r\")\n    and \"distinct (complex_roots_of_int_poly_all p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<Longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) &&&\n    distinct (complex_roots_of_int_poly_all p)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (complex_roots_of_int_poly_all p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly_all p)", "note d = complex_roots_of_int_poly_all_def Let_def"], ["proof (state)\nthis:\n  complex_roots_of_int_poly_all ?p =\n  (let n = degree ?p\n   in if 3 \\<le> n then complex_roots_of_int_poly3 ?p\n      else if n = 1 then [roots1 (complex_of_int_poly ?p)]\n           else if n = 2 then croots2 (complex_of_int_poly ?p) else [])\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (complex_roots_of_int_poly_all p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly_all p)", "have \"(p \\<noteq> 0 \\<longrightarrow> set ?l = ?r) \\<and> (distinct (complex_roots_of_int_poly_all p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "proof (cases \"degree p \\<ge> 3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)\n 2. \\<not> 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "case True"], ["proof (state)\nthis:\n  3 \\<le> degree p\n\ngoal (2 subgoals):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)\n 2. \\<not> 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "hence p: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  3 \\<le> degree p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)\n 2. \\<not> 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "from True complex_roots_of_int_poly3[OF p] sf"], ["proof (chain)\npicking this:\n  3 \\<le> degree p\n  square_free p \\<Longrightarrow>\n  set (complex_roots_of_int_poly3 p) =\n  {x. poly (complex_of_int_poly p) x = 0}\n  square_free p \\<Longrightarrow> distinct (complex_roots_of_int_poly3 p)\n  3 \\<le> degree p \\<Longrightarrow> square_free p", "show ?thesis"], ["proof (prove)\nusing this:\n  3 \\<le> degree p\n  square_free p \\<Longrightarrow>\n  set (complex_roots_of_int_poly3 p) =\n  {x. poly (complex_of_int_poly p) x = 0}\n  square_free p \\<Longrightarrow> distinct (complex_roots_of_int_poly3 p)\n  3 \\<le> degree p \\<Longrightarrow> square_free p\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "unfolding d"], ["proof (prove)\nusing this:\n  3 \\<le> degree p\n  square_free p \\<Longrightarrow>\n  set (complex_roots_of_int_poly3 p) =\n  {x. poly (complex_of_int_poly p) x = 0}\n  square_free p \\<Longrightarrow> distinct (complex_roots_of_int_poly3 p)\n  3 \\<le> degree p \\<Longrightarrow> square_free p\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set (if 3 \\<le> degree p then complex_roots_of_int_poly3 p\n          else if degree p = 1 then [roots1 (complex_of_int_poly p)]\n               else if degree p = 2 then croots2 (complex_of_int_poly p)\n                    else []) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct\n     (if 3 \\<le> degree p then complex_roots_of_int_poly3 p\n      else if degree p = 1 then [roots1 (complex_of_int_poly p)]\n           else if degree p = 2 then croots2 (complex_of_int_poly p)\n                else [])", "by auto"], ["proof (state)\nthis:\n  (p \\<noteq> 0 \\<longrightarrow>\n   set (complex_roots_of_int_poly_all p) =\n   {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n  distinct (complex_roots_of_int_poly_all p)\n\ngoal (1 subgoal):\n 1. \\<not> 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "case False"], ["proof (state)\nthis:\n  \\<not> 3 \\<le> degree p\n\ngoal (1 subgoal):\n 1. \\<not> 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "let ?p = \"map_poly (of_int :: int \\<Rightarrow> complex) p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "have deg: \"degree ?p = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (complex_of_int_poly p) = degree p", "by (simp add: degree_map_poly)"], ["proof (state)\nthis:\n  degree (complex_of_int_poly p) = degree p\n\ngoal (1 subgoal):\n 1. \\<not> 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "proof (cases \"degree p = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "case True"], ["proof (state)\nthis:\n  degree p = 1\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "hence l: \"?l = [roots1 ?p]\""], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all p = [roots1 (complex_of_int_poly p)]", "unfolding d"], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. (if 3 \\<le> degree p then complex_roots_of_int_poly3 p\n     else if degree p = 1 then [roots1 (complex_of_int_poly p)]\n          else if degree p = 2 then croots2 (complex_of_int_poly p)\n               else []) =\n    [roots1 (complex_of_int_poly p)]", "by auto"], ["proof (state)\nthis:\n  complex_roots_of_int_poly_all p = [roots1 (complex_of_int_poly p)]\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "from True"], ["proof (chain)\npicking this:\n  degree p = 1", "have \"degree ?p = 1\""], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. degree (complex_of_int_poly p) = 1", "unfolding deg"], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. degree p = 1", "by auto"], ["proof (state)\nthis:\n  degree (complex_of_int_poly p) = 1\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "from roots1[OF this]"], ["proof (chain)\npicking this:\n  {x. poly (complex_of_int_poly p) x = 0} = {roots1 (complex_of_int_poly p)}", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. poly (complex_of_int_poly p) x = 0} = {roots1 (complex_of_int_poly p)}\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "unfolding l roots1_def"], ["proof (prove)\nusing this:\n  {x. poly (complex_of_int_poly p) x = 0} =\n  {- coeff (complex_of_int_poly p) 0 / coeff (complex_of_int_poly p) 1}\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set [- coeff (complex_of_int_poly p) 0 /\n          coeff (complex_of_int_poly p) 1] =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct\n     [- coeff (complex_of_int_poly p) 0 / coeff (complex_of_int_poly p) 1]", "by auto"], ["proof (state)\nthis:\n  (p \\<noteq> 0 \\<longrightarrow>\n   set (complex_roots_of_int_poly_all p) =\n   {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n  distinct (complex_roots_of_int_poly_all p)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "proof (cases \"degree p = 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)\n 2. degree p \\<noteq> 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "case True"], ["proof (state)\nthis:\n  degree p = 2\n\ngoal (2 subgoals):\n 1. degree p = 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)\n 2. degree p \\<noteq> 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "hence l: \"?l = croots2 ?p\""], ["proof (prove)\nusing this:\n  degree p = 2\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all p = croots2 (complex_of_int_poly p)", "unfolding d"], ["proof (prove)\nusing this:\n  degree p = 2\n\ngoal (1 subgoal):\n 1. (if 3 \\<le> degree p then complex_roots_of_int_poly3 p\n     else if degree p = 1 then [roots1 (complex_of_int_poly p)]\n          else if degree p = 2 then croots2 (complex_of_int_poly p)\n               else []) =\n    croots2 (complex_of_int_poly p)", "by auto"], ["proof (state)\nthis:\n  complex_roots_of_int_poly_all p = croots2 (complex_of_int_poly p)\n\ngoal (2 subgoals):\n 1. degree p = 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)\n 2. degree p \\<noteq> 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "from True"], ["proof (chain)\npicking this:\n  degree p = 2", "have \"degree ?p = 2\""], ["proof (prove)\nusing this:\n  degree p = 2\n\ngoal (1 subgoal):\n 1. degree (complex_of_int_poly p) = 2", "unfolding deg"], ["proof (prove)\nusing this:\n  degree p = 2\n\ngoal (1 subgoal):\n 1. degree p = 2", "by auto"], ["proof (state)\nthis:\n  degree (complex_of_int_poly p) = 2\n\ngoal (2 subgoals):\n 1. degree p = 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)\n 2. degree p \\<noteq> 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "from croots2[OF this]"], ["proof (chain)\npicking this:\n  {x. poly (complex_of_int_poly p) x = 0} =\n  set (croots2 (complex_of_int_poly p))", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. poly (complex_of_int_poly p) x = 0} =\n  set (croots2 (complex_of_int_poly p))\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "unfolding l"], ["proof (prove)\nusing this:\n  {x. poly (complex_of_int_poly p) x = 0} =\n  set (croots2 (complex_of_int_poly p))\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set (croots2 (complex_of_int_poly p)) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (croots2 (complex_of_int_poly p))", "by (simp add: croots2_def Let_def)"], ["proof (state)\nthis:\n  (p \\<noteq> 0 \\<longrightarrow>\n   set (complex_roots_of_int_poly_all p) =\n   {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n  distinct (complex_roots_of_int_poly_all p)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "with \\<open>degree p \\<noteq> 1\\<close> \\<open>degree p \\<noteq> 2\\<close> \\<open>\\<not> (degree p \\<ge> 3)\\<close>"], ["proof (chain)\npicking this:\n  degree p \\<noteq> 1\n  degree p \\<noteq> 2\n  \\<not> 3 \\<le> degree p\n  degree p \\<noteq> 2", "have True: \"degree p = 0\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 1\n  degree p \\<noteq> 2\n  \\<not> 3 \\<le> degree p\n  degree p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. degree p = 0", "by auto"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "hence l: \"?l = []\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all p = []", "unfolding d"], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. (if 3 \\<le> degree p then complex_roots_of_int_poly3 p\n     else if degree p = 1 then [roots1 (complex_of_int_poly p)]\n          else if degree p = 2 then croots2 (complex_of_int_poly p)\n               else []) =\n    []", "by auto"], ["proof (state)\nthis:\n  complex_roots_of_int_poly_all p = []\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "from True"], ["proof (chain)\npicking this:\n  degree p = 0", "have \"degree ?p = 0\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. degree (complex_of_int_poly p) = 0", "unfolding deg"], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. degree p = 0", "by auto"], ["proof (state)\nthis:\n  degree (complex_of_int_poly p) = 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "from roots0[OF _ this]"], ["proof (chain)\npicking this:\n  complex_of_int_poly p \\<noteq> 0 \\<Longrightarrow>\n  {x. poly (complex_of_int_poly p) x = 0} = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  complex_of_int_poly p \\<noteq> 0 \\<Longrightarrow>\n  {x. poly (complex_of_int_poly p) x = 0} = {}\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly_all p)", "unfolding l"], ["proof (prove)\nusing this:\n  complex_of_int_poly p \\<noteq> 0 \\<Longrightarrow>\n  {x. poly (complex_of_int_poly p) x = 0} = {}\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set [] = {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct []", "by simp"], ["proof (state)\nthis:\n  (p \\<noteq> 0 \\<longrightarrow>\n   set (complex_roots_of_int_poly_all p) =\n   {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n  distinct (complex_roots_of_int_poly_all p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (p \\<noteq> 0 \\<longrightarrow>\n   set (complex_roots_of_int_poly_all p) =\n   {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n  distinct (complex_roots_of_int_poly_all p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (p \\<noteq> 0 \\<longrightarrow>\n   set (complex_roots_of_int_poly_all p) =\n   {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n  distinct (complex_roots_of_int_poly_all p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (p \\<noteq> 0 \\<longrightarrow>\n   set (complex_roots_of_int_poly_all p) =\n   {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n  distinct (complex_roots_of_int_poly_all p)\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (complex_roots_of_int_poly_all p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly_all p)", "thus \"p \\<noteq> 0 \\<Longrightarrow> set ?l = ?r\" \"distinct (complex_roots_of_int_poly_all p)\""], ["proof (prove)\nusing this:\n  (p \\<noteq> 0 \\<longrightarrow>\n   set (complex_roots_of_int_poly_all p) =\n   {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n  distinct (complex_roots_of_int_poly_all p)\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<Longrightarrow>\n     set (complex_roots_of_int_poly_all p) =\n     {x. poly (complex_of_int_poly p) x = 0}) &&&\n    distinct (complex_roots_of_int_poly_all p)", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  set (complex_roots_of_int_poly_all p) =\n  {x. poly (complex_of_int_poly p) x = 0}\n  distinct (complex_roots_of_int_poly_all p)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>It now comes the preferred function to compute complex roots of a integer polynomial.\\<close>"], ["", "definition complex_roots_of_int_poly :: \"int poly \\<Rightarrow> complex list\" where\n  \"complex_roots_of_int_poly p = (\n    let ps = (if degree p \\<ge> 3 then factors_of_int_poly p else [p])\n    in concat (map complex_roots_of_int_poly_all ps))\""], ["", "definition complex_roots_of_rat_poly :: \"rat poly \\<Rightarrow> complex list\" where\n  \"complex_roots_of_rat_poly p = complex_roots_of_int_poly (snd (rat_to_int_poly p))\""], ["", "lemma complex_roots_of_int_poly:\n  shows \"p \\<noteq> 0 \\<Longrightarrow> set (complex_roots_of_int_poly p) = {x. ipoly p x = 0}\" (is \"_ \\<Longrightarrow> ?l = ?r\")\n  and \"distinct (complex_roots_of_int_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<Longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) &&&\n    distinct (complex_roots_of_int_poly p)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (complex_roots_of_int_poly p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly p)", "have \"(p \\<noteq> 0 \\<longrightarrow> ?l = ?r) \\<and> (distinct (complex_roots_of_int_poly p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "proof (cases \"degree p \\<ge> 3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)\n 2. \\<not> 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "case False"], ["proof (state)\nthis:\n  \\<not> 3 \\<le> degree p\n\ngoal (2 subgoals):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)\n 2. \\<not> 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "hence \"complex_roots_of_int_poly p = complex_roots_of_int_poly_all p\""], ["proof (prove)\nusing this:\n  \\<not> 3 \\<le> degree p\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly p = complex_roots_of_int_poly_all p", "unfolding complex_roots_of_int_poly_def Let_def"], ["proof (prove)\nusing this:\n  \\<not> 3 \\<le> degree p\n\ngoal (1 subgoal):\n 1. concat\n     (map complex_roots_of_int_poly_all\n       (if 3 \\<le> degree p then factors_of_int_poly p else [p])) =\n    complex_roots_of_int_poly_all p", "by auto"], ["proof (state)\nthis:\n  complex_roots_of_int_poly p = complex_roots_of_int_poly_all p\n\ngoal (2 subgoals):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)\n 2. \\<not> 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "with complex_roots_of_int_poly_all[of p] False"], ["proof (chain)\npicking this:\n  \\<lbrakk>3 \\<le> degree p \\<Longrightarrow> square_free p;\n   p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> set (complex_roots_of_int_poly_all p) =\n                    {x. poly (complex_of_int_poly p) x = 0}\n  (3 \\<le> degree p \\<Longrightarrow> square_free p) \\<Longrightarrow>\n  distinct (complex_roots_of_int_poly_all p)\n  \\<not> 3 \\<le> degree p\n  complex_roots_of_int_poly p = complex_roots_of_int_poly_all p", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>3 \\<le> degree p \\<Longrightarrow> square_free p;\n   p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> set (complex_roots_of_int_poly_all p) =\n                    {x. poly (complex_of_int_poly p) x = 0}\n  (3 \\<le> degree p \\<Longrightarrow> square_free p) \\<Longrightarrow>\n  distinct (complex_roots_of_int_poly_all p)\n  \\<not> 3 \\<le> degree p\n  complex_roots_of_int_poly p = complex_roots_of_int_poly_all p\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "by auto"], ["proof (state)\nthis:\n  (p \\<noteq> 0 \\<longrightarrow>\n   set (complex_roots_of_int_poly p) =\n   {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n  distinct (complex_roots_of_int_poly p)\n\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "case True"], ["proof (state)\nthis:\n  3 \\<le> degree p\n\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "{"], ["proof (state)\nthis:\n  3 \\<le> degree p\n\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "assume \"q \\<in> set (factors_of_int_poly p)\""], ["proof (state)\nthis:\n  q \\<in> set (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "from factors_of_int_poly(1)[OF refl this] irreducible_imp_square_free[of q]"], ["proof (chain)\npicking this:\n  irreducible q \\<and>\n  0 < lead_coeff q \\<and> degree q \\<le> degree p \\<and> degree q \\<noteq> 0\n  irreducible q \\<Longrightarrow> square_free q", "have 0: \"q \\<noteq> 0\" and sf: \"square_free q\""], ["proof (prove)\nusing this:\n  irreducible q \\<and>\n  0 < lead_coeff q \\<and> degree q \\<le> degree p \\<and> degree q \\<noteq> 0\n  irreducible q \\<Longrightarrow> square_free q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& square_free q", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  square_free q\n\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "from complex_roots_of_int_poly_all(1)[OF sf 0] complex_roots_of_int_poly_all(2)[OF sf]"], ["proof (chain)\npicking this:\n  set (complex_roots_of_int_poly_all q) =\n  {x. poly (complex_of_int_poly q) x = 0}\n  distinct (complex_roots_of_int_poly_all q)", "have \"set (complex_roots_of_int_poly_all q) = {x. ipoly q x = 0}\" \n        \"distinct (complex_roots_of_int_poly_all q)\""], ["proof (prove)\nusing this:\n  set (complex_roots_of_int_poly_all q) =\n  {x. poly (complex_of_int_poly q) x = 0}\n  distinct (complex_roots_of_int_poly_all q)\n\ngoal (1 subgoal):\n 1. set (complex_roots_of_int_poly_all q) =\n    {x. poly (complex_of_int_poly q) x = 0} &&&\n    distinct (complex_roots_of_int_poly_all q)", "by auto"], ["proof (state)\nthis:\n  set (complex_roots_of_int_poly_all q) =\n  {x. poly (complex_of_int_poly q) x = 0}\n  distinct (complex_roots_of_int_poly_all q)\n\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "}"], ["proof (state)\nthis:\n  ?q2 \\<in> set (factors_of_int_poly p) \\<Longrightarrow>\n  set (complex_roots_of_int_poly_all ?q2) =\n  {x. poly (complex_of_int_poly ?q2) x = 0}\n  ?q2 \\<in> set (factors_of_int_poly p) \\<Longrightarrow>\n  distinct (complex_roots_of_int_poly_all ?q2)\n\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "note all = this"], ["proof (state)\nthis:\n  ?q2 \\<in> set (factors_of_int_poly p) \\<Longrightarrow>\n  set (complex_roots_of_int_poly_all ?q2) =\n  {x. poly (complex_of_int_poly ?q2) x = 0}\n  ?q2 \\<in> set (factors_of_int_poly p) \\<Longrightarrow>\n  distinct (complex_roots_of_int_poly_all ?q2)\n\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "from True"], ["proof (chain)\npicking this:\n  3 \\<le> degree p", "have \n      \"?l = (\\<Union> ((\\<lambda> p. set (complex_roots_of_int_poly_all p)) ` set (factors_of_int_poly p)))\""], ["proof (prove)\nusing this:\n  3 \\<le> degree p\n\ngoal (1 subgoal):\n 1. set (complex_roots_of_int_poly p) =\n    (\\<Union>p\\<in>set (factors_of_int_poly p).\n        set (complex_roots_of_int_poly_all p))", "unfolding complex_roots_of_int_poly_def Let_def"], ["proof (prove)\nusing this:\n  3 \\<le> degree p\n\ngoal (1 subgoal):\n 1. set (concat\n          (map complex_roots_of_int_poly_all\n            (if 3 \\<le> degree p then factors_of_int_poly p else [p]))) =\n    (\\<Union>p\\<in>set (factors_of_int_poly p).\n        set (complex_roots_of_int_poly_all p))", "by auto"], ["proof (state)\nthis:\n  set (complex_roots_of_int_poly p) =\n  (\\<Union>p\\<in>set (factors_of_int_poly p).\n      set (complex_roots_of_int_poly_all p))\n\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "also"], ["proof (state)\nthis:\n  set (complex_roots_of_int_poly p) =\n  (\\<Union>p\\<in>set (factors_of_int_poly p).\n      set (complex_roots_of_int_poly_all p))\n\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "have \"\\<dots> = (\\<Union> ((\\<lambda> p. {x. ipoly p x = 0}) ` set (factors_of_int_poly p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        set (complex_roots_of_int_poly_all p)) =\n    (\\<Union>p\\<in>set (factors_of_int_poly p).\n        {x. poly (complex_of_int_poly p) x = 0})", "using all"], ["proof (prove)\nusing this:\n  ?q2 \\<in> set (factors_of_int_poly p) \\<Longrightarrow>\n  set (complex_roots_of_int_poly_all ?q2) =\n  {x. poly (complex_of_int_poly ?q2) x = 0}\n  ?q2 \\<in> set (factors_of_int_poly p) \\<Longrightarrow>\n  distinct (complex_roots_of_int_poly_all ?q2)\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        set (complex_roots_of_int_poly_all p)) =\n    (\\<Union>p\\<in>set (factors_of_int_poly p).\n        {x. poly (complex_of_int_poly p) x = 0})", "by blast"], ["proof (state)\nthis:\n  (\\<Union>p\\<in>set (factors_of_int_poly p).\n      set (complex_roots_of_int_poly_all p)) =\n  (\\<Union>p\\<in>set (factors_of_int_poly p).\n      {x. poly (complex_of_int_poly p) x = 0})\n\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "finally"], ["proof (chain)\npicking this:\n  set (complex_roots_of_int_poly p) =\n  (\\<Union>p\\<in>set (factors_of_int_poly p).\n      {x. poly (complex_of_int_poly p) x = 0})", "have l: \"?l = (\\<Union> ((\\<lambda> p. {x. ipoly p x = 0}) ` set (factors_of_int_poly p)))\""], ["proof (prove)\nusing this:\n  set (complex_roots_of_int_poly p) =\n  (\\<Union>p\\<in>set (factors_of_int_poly p).\n      {x. poly (complex_of_int_poly p) x = 0})\n\ngoal (1 subgoal):\n 1. set (complex_roots_of_int_poly p) =\n    (\\<Union>p\\<in>set (factors_of_int_poly p).\n        {x. poly (complex_of_int_poly p) x = 0})", "."], ["proof (state)\nthis:\n  set (complex_roots_of_int_poly p) =\n  (\\<Union>p\\<in>set (factors_of_int_poly p).\n      {x. poly (complex_of_int_poly p) x = 0})\n\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "have lr: \"p \\<noteq> 0 \\<longrightarrow> ?l = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<longrightarrow>\n    set (complex_roots_of_int_poly p) =\n    {x. poly (complex_of_int_poly p) x = 0}", "using l factors_of_int_poly(2)[OF refl, of p]"], ["proof (prove)\nusing this:\n  set (complex_roots_of_int_poly p) =\n  (\\<Union>p\\<in>set (factors_of_int_poly p).\n      {x. poly (complex_of_int_poly p) x = 0})\n  p \\<noteq> 0 \\<Longrightarrow>\n  (ipoly p ?x = (0::?'a)) =\n  (\\<exists>q\\<in>set (factors_of_int_poly p). ipoly q ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<longrightarrow>\n    set (complex_roots_of_int_poly p) =\n    {x. poly (complex_of_int_poly p) x = 0}", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<longrightarrow>\n  set (complex_roots_of_int_poly p) =\n  {x. poly (complex_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. 3 \\<le> degree p \\<Longrightarrow>\n    (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n    distinct (complex_roots_of_int_poly p)", "proof (rule conjI[OF lr])"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly p)", "from True"], ["proof (chain)\npicking this:\n  3 \\<le> degree p", "have id: \"complex_roots_of_int_poly p = \n          concat (map complex_roots_of_int_poly_all (factors_of_int_poly p))\""], ["proof (prove)\nusing this:\n  3 \\<le> degree p\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly p =\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p))", "unfolding complex_roots_of_int_poly_def Let_def"], ["proof (prove)\nusing this:\n  3 \\<le> degree p\n\ngoal (1 subgoal):\n 1. concat\n     (map complex_roots_of_int_poly_all\n       (if 3 \\<le> degree p then factors_of_int_poly p else [p])) =\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p))", "by auto"], ["proof (state)\nthis:\n  complex_roots_of_int_poly p =\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p))\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly p)", "show \"distinct (complex_roots_of_int_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly p)", "unfolding id distinct_conv_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (concat\n                  (map complex_roots_of_int_poly_all\n                    (factors_of_int_poly p))).\n       \\<forall>j<length\n                   (concat\n                     (map complex_roots_of_int_poly_all\n                       (factors_of_int_poly p))).\n          i \\<noteq> j \\<longrightarrow>\n          concat\n           (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n          i \\<noteq>\n          concat\n           (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n          j", "proof (intro allI impI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat\n                       (map complex_roots_of_int_poly_all\n                         (factors_of_int_poly p)));\n        j < length\n             (concat\n               (map complex_roots_of_int_poly_all (factors_of_int_poly p)));\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         i \\<noteq>\n                         concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         j", "case (1 i j)"], ["proof (state)\nthis:\n  i < length\n       (concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)))\n  j < length\n       (concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)))\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat\n                       (map complex_roots_of_int_poly_all\n                         (factors_of_int_poly p)));\n        j < length\n             (concat\n               (map complex_roots_of_int_poly_all (factors_of_int_poly p)));\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         i \\<noteq>\n                         concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         j", "let ?fp = \"factors_of_int_poly p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat\n                       (map complex_roots_of_int_poly_all\n                         (factors_of_int_poly p)));\n        j < length\n             (concat\n               (map complex_roots_of_int_poly_all (factors_of_int_poly p)));\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         i \\<noteq>\n                         concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         j", "let ?rr = \"complex_roots_of_int_poly_all\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat\n                       (map complex_roots_of_int_poly_all\n                         (factors_of_int_poly p)));\n        j < length\n             (concat\n               (map complex_roots_of_int_poly_all (factors_of_int_poly p)));\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         i \\<noteq>\n                         concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         j", "let ?cc = \"concat (map ?rr (factors_of_int_poly p))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat\n                       (map complex_roots_of_int_poly_all\n                         (factors_of_int_poly p)));\n        j < length\n             (concat\n               (map complex_roots_of_int_poly_all (factors_of_int_poly p)));\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         i \\<noteq>\n                         concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         j", "from nth_concat_diff[OF 1, unfolded length_map]"], ["proof (chain)\npicking this:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length (factors_of_int_poly p) \\<and>\n     j2 < length (factors_of_int_poly p) \\<and>\n     k1 < length\n           (map complex_roots_of_int_poly_all (factors_of_int_poly p) !\n            j1) \\<and>\n     k2 < length\n           (map complex_roots_of_int_poly_all (factors_of_int_poly p) !\n            j2) \\<and>\n     concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n     i =\n     map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j1 !\n     k1 \\<and>\n     concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n     j =\n     map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j2 ! k2", "obtain j1 k1 j2 k2 where \n          *: \"(j1,k1) \\<noteq> (j2,k2)\"\n          \"j1 < length ?fp\" \"j2 < length ?fp\" and\n          \"k1 < length (map ?rr ?fp ! j1)\"\n          \"k2 < length (map ?rr ?fp ! j2)\"\n          \"?cc ! i = map ?rr ?fp ! j1 ! k1\" \n          \"?cc ! j = map ?rr ?fp ! j2 ! k2\""], ["proof (prove)\nusing this:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length (factors_of_int_poly p) \\<and>\n     j2 < length (factors_of_int_poly p) \\<and>\n     k1 < length\n           (map complex_roots_of_int_poly_all (factors_of_int_poly p) !\n            j1) \\<and>\n     k2 < length\n           (map complex_roots_of_int_poly_all (factors_of_int_poly p) !\n            j2) \\<and>\n     concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n     i =\n     map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j1 !\n     k1 \\<and>\n     concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n     j =\n     map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j2 ! k2\n\ngoal (1 subgoal):\n 1. (\\<And>j1 k1 j2 k2.\n        \\<lbrakk>(j1, k1) \\<noteq> (j2, k2);\n         j1 < length (factors_of_int_poly p);\n         j2 < length (factors_of_int_poly p);\n         k1 < length\n               (map complex_roots_of_int_poly_all (factors_of_int_poly p) !\n                j1);\n         k2 < length\n               (map complex_roots_of_int_poly_all (factors_of_int_poly p) !\n                j2);\n         concat\n          (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n         i =\n         map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j1 !\n         k1;\n         concat\n          (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n         j =\n         map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j2 !\n         k2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n  k1 < length\n        (map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j1)\n  k2 < length\n        (map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j2)\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! i =\n  map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j1 ! k1\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j =\n  map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j2 ! k2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat\n                       (map complex_roots_of_int_poly_all\n                         (factors_of_int_poly p)));\n        j < length\n             (concat\n               (map complex_roots_of_int_poly_all (factors_of_int_poly p)));\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         i \\<noteq>\n                         concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         j", "hence **: \"k1 < length (?rr (?fp ! j1))\" \n          \"k2 < length (?rr (?fp ! j2))\" \n          \"?cc ! i = ?rr (?fp ! j1) ! k1\"\n          \"?cc ! j = ?rr (?fp ! j2) ! k2\""], ["proof (prove)\nusing this:\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n  k1 < length\n        (map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j1)\n  k2 < length\n        (map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j2)\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! i =\n  map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j1 ! k1\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j =\n  map complex_roots_of_int_poly_all (factors_of_int_poly p) ! j2 ! k2\n\ngoal (1 subgoal):\n 1. (k1 < length\n           (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1)) &&&\n     k2 < length\n           (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))) &&&\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! i =\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1 &&&\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j =\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k2", "by auto"], ["proof (state)\nthis:\n  k1 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))\n  k2 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! i =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat\n                       (map complex_roots_of_int_poly_all\n                         (factors_of_int_poly p)));\n        j < length\n             (concat\n               (map complex_roots_of_int_poly_all (factors_of_int_poly p)));\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         i \\<noteq>\n                         concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         j", "from *"], ["proof (chain)\npicking this:\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)", "have mem: \"?fp ! j1 \\<in> set ?fp\" \"?fp ! j2 \\<in> set ?fp\""], ["proof (prove)\nusing this:\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. factors_of_int_poly p ! j1 \\<in> set (factors_of_int_poly p) &&&\n    factors_of_int_poly p ! j2 \\<in> set (factors_of_int_poly p)", "by auto"], ["proof (state)\nthis:\n  factors_of_int_poly p ! j1 \\<in> set (factors_of_int_poly p)\n  factors_of_int_poly p ! j2 \\<in> set (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat\n                       (map complex_roots_of_int_poly_all\n                         (factors_of_int_poly p)));\n        j < length\n             (concat\n               (map complex_roots_of_int_poly_all (factors_of_int_poly p)));\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         i \\<noteq>\n                         concat\n                          (map complex_roots_of_int_poly_all\n                            (factors_of_int_poly p)) !\n                         j", "show \"?cc ! i \\<noteq> ?cc ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j", "proof (cases \"j1 = j2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j1 = j2 \\<Longrightarrow>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j\n 2. j1 \\<noteq> j2 \\<Longrightarrow>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j", "case True"], ["proof (state)\nthis:\n  j1 = j2\n\ngoal (2 subgoals):\n 1. j1 = j2 \\<Longrightarrow>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j\n 2. j1 \\<noteq> j2 \\<Longrightarrow>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j", "with *"], ["proof (chain)\npicking this:\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n  j1 = j2", "have \"k1 \\<noteq> k2\""], ["proof (prove)\nusing this:\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n  j1 = j2\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> k2", "by auto"], ["proof (state)\nthis:\n  k1 \\<noteq> k2\n\ngoal (2 subgoals):\n 1. j1 = j2 \\<Longrightarrow>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j\n 2. j1 \\<noteq> j2 \\<Longrightarrow>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j", "with all(2)[OF mem(2)] **(1-2)"], ["proof (chain)\npicking this:\n  distinct (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  k1 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))\n  k2 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  k1 \\<noteq> k2", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  k1 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))\n  k2 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  k1 \\<noteq> k2\n\ngoal (1 subgoal):\n 1. concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j", "unfolding **(3-4)"], ["proof (prove)\nusing this:\n  distinct (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  k1 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))\n  k2 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  k1 \\<noteq> k2\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1 \\<noteq>\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k2", "unfolding True\n            distinct_conv_nth"], ["proof (prove)\nusing this:\n  \\<forall>i<length\n              (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2)).\n     \\<forall>j<length\n                 (complex_roots_of_int_poly_all\n                   (factors_of_int_poly p ! j2)).\n        i \\<noteq> j \\<longrightarrow>\n        complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) !\n        i \\<noteq>\n        complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! j\n  k1 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  k2 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  k1 \\<noteq> k2\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k1 \\<noteq>\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k2", "by auto"], ["proof (state)\nthis:\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n  i \\<noteq>\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j\n\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j", "case False"], ["proof (state)\nthis:\n  j1 \\<noteq> j2\n\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j", "from \\<open>degree p \\<ge> 3\\<close>"], ["proof (chain)\npicking this:\n  3 \\<le> degree p", "have p: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  3 \\<le> degree p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j", "note fip = factors_of_int_poly(2-3)[OF refl this]"], ["proof (state)\nthis:\n  (ipoly p ?x = (0::?'a)) =\n  (\\<exists>q\\<in>set (factors_of_int_poly p). ipoly q ?x = (0::?'a))\n  ipoly p ?x = (0::?'a) \\<Longrightarrow>\n  \\<exists>!q.\n     q \\<in> set (factors_of_int_poly p) \\<and> ipoly q ?x = (0::?'a)\n\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n    i \\<noteq>\n    concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j", "unfolding **(3-4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1 \\<noteq>\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1 =\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) !\n    k2 \\<Longrightarrow>\n    False", "define x where \"x = ?rr (?fp ! j2) ! k2\""], ["proof (state)\nthis:\n  x = complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k2\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1 =\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) !\n    k2 \\<Longrightarrow>\n    False", "assume id: \"?rr (?fp ! j1) ! k1 = ?rr (?fp ! j2) ! k2\""], ["proof (state)\nthis:\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1 =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k2\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1 =\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) !\n    k2 \\<Longrightarrow>\n    False", "from **"], ["proof (chain)\npicking this:\n  k1 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))\n  k2 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! i =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k2", "have x1: \"x \\<in> set (?rr (?fp ! j1))\""], ["proof (prove)\nusing this:\n  k1 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))\n  k2 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! i =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k2\n\ngoal (1 subgoal):\n 1. x \\<in> set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))", "unfolding x_def id[symmetric]"], ["proof (prove)\nusing this:\n  k1 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))\n  k2 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! i =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1\n    \\<in> set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1 =\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) !\n    k2 \\<Longrightarrow>\n    False", "from **"], ["proof (chain)\npicking this:\n  k1 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))\n  k2 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! i =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k2", "have x2: \"x \\<in> set (?rr (?fp ! j2))\""], ["proof (prove)\nusing this:\n  k1 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))\n  k2 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! i =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k2\n\ngoal (1 subgoal):\n 1. x \\<in> set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))", "unfolding x_def"], ["proof (prove)\nusing this:\n  k1 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))\n  k2 < length (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! i =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j =\n  complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k2\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) ! k2\n    \\<in> set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1 =\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) !\n    k2 \\<Longrightarrow>\n    False", "from all(1)[OF mem(1)] x1"], ["proof (chain)\npicking this:\n  set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1)) =\n  {x. poly (complex_of_int_poly (factors_of_int_poly p ! j1)) x = 0}\n  x \\<in> set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))", "have x1: \"ipoly (?fp ! j1) x = 0\""], ["proof (prove)\nusing this:\n  set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1)) =\n  {x. poly (complex_of_int_poly (factors_of_int_poly p ! j1)) x = 0}\n  x \\<in> set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j1))\n\ngoal (1 subgoal):\n 1. poly (complex_of_int_poly (factors_of_int_poly p ! j1)) x = 0", "by auto"], ["proof (state)\nthis:\n  poly (complex_of_int_poly (factors_of_int_poly p ! j1)) x = 0\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1 =\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) !\n    k2 \\<Longrightarrow>\n    False", "from all(1)[OF mem(2)] x2"], ["proof (chain)\npicking this:\n  set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2)) =\n  {x. poly (complex_of_int_poly (factors_of_int_poly p ! j2)) x = 0}\n  x \\<in> set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))", "have x2: \"ipoly (?fp ! j2) x = 0\""], ["proof (prove)\nusing this:\n  set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2)) =\n  {x. poly (complex_of_int_poly (factors_of_int_poly p ! j2)) x = 0}\n  x \\<in> set (complex_roots_of_int_poly_all (factors_of_int_poly p ! j2))\n\ngoal (1 subgoal):\n 1. poly (complex_of_int_poly (factors_of_int_poly p ! j2)) x = 0", "by auto"], ["proof (state)\nthis:\n  poly (complex_of_int_poly (factors_of_int_poly p ! j2)) x = 0\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1 =\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) !\n    k2 \\<Longrightarrow>\n    False", "from False factors_of_int_poly(4)[OF refl, of p]"], ["proof (chain)\npicking this:\n  j1 \\<noteq> j2\n  distinct (factors_of_int_poly p)", "have neq: \"?fp ! j1 \\<noteq> ?fp ! j2\""], ["proof (prove)\nusing this:\n  j1 \\<noteq> j2\n  distinct (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. factors_of_int_poly p ! j1 \\<noteq> factors_of_int_poly p ! j2", "using *"], ["proof (prove)\nusing this:\n  j1 \\<noteq> j2\n  distinct (factors_of_int_poly p)\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. factors_of_int_poly p ! j1 \\<noteq> factors_of_int_poly p ! j2", "unfolding distinct_conv_nth"], ["proof (prove)\nusing this:\n  j1 \\<noteq> j2\n  \\<forall>i<length (factors_of_int_poly p).\n     \\<forall>j<length (factors_of_int_poly p).\n        i \\<noteq> j \\<longrightarrow>\n        factors_of_int_poly p ! i \\<noteq> factors_of_int_poly p ! j\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. factors_of_int_poly p ! j1 \\<noteq> factors_of_int_poly p ! j2", "by auto"], ["proof (state)\nthis:\n  factors_of_int_poly p ! j1 \\<noteq> factors_of_int_poly p ! j2\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1 =\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) !\n    k2 \\<Longrightarrow>\n    False", "have \"poly (complex_of_int_poly p) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (complex_of_int_poly p) x = 0", "by (meson fip(1) mem(2) x2)"], ["proof (state)\nthis:\n  poly (complex_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. complex_roots_of_int_poly_all (factors_of_int_poly p ! j1) ! k1 =\n    complex_roots_of_int_poly_all (factors_of_int_poly p ! j2) !\n    k2 \\<Longrightarrow>\n    False", "from fip(2)[OF this] mem x1 x2 neq"], ["proof (chain)\npicking this:\n  \\<exists>!q.\n     q \\<in> set (factors_of_int_poly p) \\<and>\n     poly (complex_of_int_poly q) x = 0\n  factors_of_int_poly p ! j1 \\<in> set (factors_of_int_poly p)\n  factors_of_int_poly p ! j2 \\<in> set (factors_of_int_poly p)\n  poly (complex_of_int_poly (factors_of_int_poly p ! j1)) x = 0\n  poly (complex_of_int_poly (factors_of_int_poly p ! j2)) x = 0\n  factors_of_int_poly p ! j1 \\<noteq> factors_of_int_poly p ! j2", "show False"], ["proof (prove)\nusing this:\n  \\<exists>!q.\n     q \\<in> set (factors_of_int_poly p) \\<and>\n     poly (complex_of_int_poly q) x = 0\n  factors_of_int_poly p ! j1 \\<in> set (factors_of_int_poly p)\n  factors_of_int_poly p ! j2 \\<in> set (factors_of_int_poly p)\n  poly (complex_of_int_poly (factors_of_int_poly p ! j1)) x = 0\n  poly (complex_of_int_poly (factors_of_int_poly p ! j2)) x = 0\n  factors_of_int_poly p ! j1 \\<noteq> factors_of_int_poly p ! j2\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n  i \\<noteq>\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) !\n  i \\<noteq>\n  concat (map complex_roots_of_int_poly_all (factors_of_int_poly p)) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (complex_roots_of_int_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (p \\<noteq> 0 \\<longrightarrow>\n   set (complex_roots_of_int_poly p) =\n   {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n  distinct (complex_roots_of_int_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (p \\<noteq> 0 \\<longrightarrow>\n   set (complex_roots_of_int_poly p) =\n   {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n  distinct (complex_roots_of_int_poly p)\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (complex_roots_of_int_poly p) =\n    {x. poly (complex_of_int_poly p) x = 0}\n 2. distinct (complex_roots_of_int_poly p)", "thus \"p \\<noteq> 0 \\<Longrightarrow> ?l = ?r\" \"distinct (complex_roots_of_int_poly p)\""], ["proof (prove)\nusing this:\n  (p \\<noteq> 0 \\<longrightarrow>\n   set (complex_roots_of_int_poly p) =\n   {x. poly (complex_of_int_poly p) x = 0}) \\<and>\n  distinct (complex_roots_of_int_poly p)\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<Longrightarrow>\n     set (complex_roots_of_int_poly p) =\n     {x. poly (complex_of_int_poly p) x = 0}) &&&\n    distinct (complex_roots_of_int_poly p)", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  set (complex_roots_of_int_poly p) =\n  {x. poly (complex_of_int_poly p) x = 0}\n  distinct (complex_roots_of_int_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complex_roots_of_rat_poly: \n  \"p \\<noteq> 0 \\<Longrightarrow> set (complex_roots_of_rat_poly p) = {x. rpoly p x = 0}\" (is \"_ \\<Longrightarrow> ?l = ?r\")\n  \"distinct (complex_roots_of_rat_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<Longrightarrow>\n     set (complex_roots_of_rat_poly p) = {x. rpoly p x = 0}) &&&\n    distinct (complex_roots_of_rat_poly p)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (complex_roots_of_rat_poly p) = {x. rpoly p x = 0}\n 2. distinct (complex_roots_of_rat_poly p)", "obtain c q where cq: \"rat_to_int_poly p = (c,q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c q.\n        rat_to_int_poly p = (c, q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rat_to_int_poly p = (c, q)\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (complex_roots_of_rat_poly p) = {x. rpoly p x = 0}\n 2. distinct (complex_roots_of_rat_poly p)", "from rat_to_int_poly[OF this]"], ["proof (chain)\npicking this:\n  p = smult (inverse (rat_of_int c)) (of_int_poly q)\n  0 < c", "have pq: \"p = smult (inverse (of_int c)) (of_int_poly q)\" \n    and c: \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p = smult (inverse (rat_of_int c)) (of_int_poly q)\n  0 < c\n\ngoal (1 subgoal):\n 1. p = smult (inverse (rat_of_int c)) (of_int_poly q) &&& c \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p = smult (inverse (rat_of_int c)) (of_int_poly q)\n  c \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (complex_roots_of_rat_poly p) = {x. rpoly p x = 0}\n 2. distinct (complex_roots_of_rat_poly p)", "show \"distinct (complex_roots_of_rat_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_rat_poly p)", "unfolding complex_roots_of_rat_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly (snd (rat_to_int_poly p)))", "using complex_roots_of_int_poly(2)"], ["proof (prove)\nusing this:\n  distinct (complex_roots_of_int_poly ?p)\n\ngoal (1 subgoal):\n 1. distinct (complex_roots_of_int_poly (snd (rat_to_int_poly p)))", "."], ["proof (state)\nthis:\n  distinct (complex_roots_of_rat_poly p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (complex_roots_of_rat_poly p) = {x. rpoly p x = 0}", "assume p: \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (complex_roots_of_rat_poly p) = {x. rpoly p x = 0}", "with pq c"], ["proof (chain)\npicking this:\n  p = smult (inverse (rat_of_int c)) (of_int_poly q)\n  c \\<noteq> 0\n  p \\<noteq> 0", "have q: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p = smult (inverse (rat_of_int c)) (of_int_poly q)\n  c \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (complex_roots_of_rat_poly p) = {x. rpoly p x = 0}", "have id: \"{x. rpoly p x = (0 :: complex)} = {x. ipoly q x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. rpoly p x = 0} = {x. poly (complex_of_int_poly q) x = 0}", "unfolding pq"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. rpoly (smult (inverse (rat_of_int c)) (of_int_poly q)) x = 0} =\n    {x. poly (complex_of_int_poly q) x = 0}", "by (simp add: c of_rat_of_int_poly hom_distribs)"], ["proof (state)\nthis:\n  {x. rpoly p x = 0} = {x. poly (complex_of_int_poly q) x = 0}\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (complex_roots_of_rat_poly p) = {x. rpoly p x = 0}", "show \"?l = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (complex_roots_of_rat_poly p) = {x. rpoly p x = 0}", "unfolding complex_roots_of_rat_poly_def cq snd_conv id\n    complex_roots_of_int_poly(1)[OF q]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (complex_of_int_poly q) x = 0} =\n    {x. poly (complex_of_int_poly q) x = 0}", ".."], ["proof (state)\nthis:\n  set (complex_roots_of_rat_poly p) = {x. rpoly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition roots_of_complex_main :: \"complex poly \\<Rightarrow> complex list\" where \n  \"roots_of_complex_main p \\<equiv> let n = degree p in \n    if n = 0 then [] else if n = 1 then [roots1 p] else if n = 2 then croots2 p\n    else (complex_roots_of_rat_poly (map_poly to_rat p))\""], ["", "definition roots_of_complex_poly :: \"complex poly \\<Rightarrow> complex list option\" where\n  \"roots_of_complex_poly p \\<equiv> let (c,pis) = yun_factorization gcd p in\n    if (c \\<noteq> 0 \\<and> (\\<forall> (p,i) \\<in> set pis. degree p \\<le> 2 \\<or> (\\<forall> x \\<in> set (coeffs p). x \\<in> \\<rat>))) then \n    Some (concat (map (roots_of_complex_main o fst) pis)) else None\""], ["", "lemma roots_of_complex_main: assumes p: \"p \\<noteq> 0\" and deg: \"degree p \\<le> 2 \\<or> set (coeffs p) \\<subseteq> \\<rat>\"\n  shows \"set (roots_of_complex_main p) = {x. poly p x = 0}\" (is \"set ?l = ?r\")\n    and \"distinct (roots_of_complex_main p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots_of_complex_main p) = {x. poly p x = 0} &&&\n    distinct (roots_of_complex_main p)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. set (roots_of_complex_main p) = {x. poly p x = 0}\n 2. distinct (roots_of_complex_main p)", "note d = roots_of_complex_main_def Let_def"], ["proof (state)\nthis:\n  roots_of_complex_main ?p \\<equiv>\n  let n = degree ?p\n  in if n = 0 then []\n     else if n = 1 then [roots1 ?p]\n          else if n = 2 then croots2 ?p\n               else complex_roots_of_rat_poly (map_poly to_rat ?p)\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (2 subgoals):\n 1. set (roots_of_complex_main p) = {x. poly p x = 0}\n 2. distinct (roots_of_complex_main p)", "have \"set ?l = ?r \\<and> distinct (roots_of_complex_main p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "proof (cases \"degree p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "case True"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "hence \"?l = []\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. roots_of_complex_main p = []", "unfolding d"], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. (if degree p = 0 then []\n     else if degree p = 1 then [roots1 p]\n          else if degree p = 2 then croots2 p\n               else complex_roots_of_rat_poly (map_poly to_rat p)) =\n    []", "by auto"], ["proof (state)\nthis:\n  roots_of_complex_main p = []\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "with roots0[OF p True]"], ["proof (chain)\npicking this:\n  {x. poly p x = 0} = {}\n  roots_of_complex_main p = []", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. poly p x = 0} = {}\n  roots_of_complex_main p = []\n\ngoal (1 subgoal):\n 1. set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "by auto"], ["proof (state)\nthis:\n  set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n  distinct (roots_of_complex_main p)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "note 0 = this"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "proof (cases \"degree p = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "case True"], ["proof (state)\nthis:\n  degree p = 1\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "hence \"?l = [roots1 p]\""], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. roots_of_complex_main p = [roots1 p]", "unfolding d"], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. (if degree p = 0 then []\n     else if degree p = 1 then [roots1 p]\n          else if degree p = 2 then croots2 p\n               else complex_roots_of_rat_poly (map_poly to_rat p)) =\n    [roots1 p]", "by auto"], ["proof (state)\nthis:\n  roots_of_complex_main p = [roots1 p]\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "with roots1[OF True]"], ["proof (chain)\npicking this:\n  {x. poly p x = 0} = {roots1 p}\n  roots_of_complex_main p = [roots1 p]", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. poly p x = 0} = {roots1 p}\n  roots_of_complex_main p = [roots1 p]\n\ngoal (1 subgoal):\n 1. set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "by auto"], ["proof (state)\nthis:\n  set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n  distinct (roots_of_complex_main p)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "note 1 = this"], ["proof (state)\nthis:\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "proof (cases \"degree p = 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)\n 2. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "case True"], ["proof (state)\nthis:\n  degree p = 2\n\ngoal (2 subgoals):\n 1. degree p = 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)\n 2. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "hence \"?l = croots2 p\""], ["proof (prove)\nusing this:\n  degree p = 2\n\ngoal (1 subgoal):\n 1. roots_of_complex_main p = croots2 p", "unfolding d"], ["proof (prove)\nusing this:\n  degree p = 2\n\ngoal (1 subgoal):\n 1. (if degree p = 0 then []\n     else if degree p = 1 then [roots1 p]\n          else if degree p = 2 then croots2 p\n               else complex_roots_of_rat_poly (map_poly to_rat p)) =\n    croots2 p", "by auto"], ["proof (state)\nthis:\n  roots_of_complex_main p = croots2 p\n\ngoal (2 subgoals):\n 1. degree p = 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)\n 2. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "with croots2[OF True]"], ["proof (chain)\npicking this:\n  {x. poly p x = 0} = set (croots2 p)\n  roots_of_complex_main p = croots2 p", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. poly p x = 0} = set (croots2 p)\n  roots_of_complex_main p = croots2 p\n\ngoal (1 subgoal):\n 1. set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "by (auto simp: croots2_def Let_def)"], ["proof (state)\nthis:\n  set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n  distinct (roots_of_complex_main p)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "note 2 = this"], ["proof (state)\nthis:\n  degree p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "let ?q = \"map_poly to_rat p\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "from 0 1 2"], ["proof (chain)\npicking this:\n  degree p \\<noteq> 0\n  degree p \\<noteq> 1\n  degree p \\<noteq> 2", "have l: \"?l = complex_roots_of_rat_poly ?q\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n  degree p \\<noteq> 1\n  degree p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. roots_of_complex_main p = complex_roots_of_rat_poly (map_poly to_rat p)", "unfolding d"], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n  degree p \\<noteq> 1\n  degree p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. (if degree p = 0 then []\n     else if degree p = 1 then [roots1 p]\n          else if degree p = 2 then croots2 p\n               else complex_roots_of_rat_poly (map_poly to_rat p)) =\n    complex_roots_of_rat_poly (map_poly to_rat p)", "by auto"], ["proof (state)\nthis:\n  roots_of_complex_main p = complex_roots_of_rat_poly (map_poly to_rat p)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "from deg 0 1 2"], ["proof (chain)\npicking this:\n  degree p \\<le> 2 \\<or> set (coeffs p) \\<subseteq> \\<rat>\n  degree p \\<noteq> 0\n  degree p \\<noteq> 1\n  degree p \\<noteq> 2", "have rat: \"set (coeffs p) \\<subseteq> \\<rat>\""], ["proof (prove)\nusing this:\n  degree p \\<le> 2 \\<or> set (coeffs p) \\<subseteq> \\<rat>\n  degree p \\<noteq> 0\n  degree p \\<noteq> 1\n  degree p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. set (coeffs p) \\<subseteq> \\<rat>", "by auto"], ["proof (state)\nthis:\n  set (coeffs p) \\<subseteq> \\<rat>\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "have \"p = map_poly (of_rat o to_rat) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = map_poly (of_rat \\<circ> to_rat) p", "by (rule sym, rule map_poly_idI, insert rat, auto)"], ["proof (state)\nthis:\n  p = map_poly (of_rat \\<circ> to_rat) p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "also"], ["proof (state)\nthis:\n  p = map_poly (of_rat \\<circ> to_rat) p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "have \"\\<dots> = complex_of_rat_poly ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (of_rat \\<circ> to_rat) p =\n    complex_of_rat_poly (map_poly to_rat p)", "by (subst map_poly_map_poly, auto simp: to_rat)"], ["proof (state)\nthis:\n  map_poly (of_rat \\<circ> to_rat) p =\n  complex_of_rat_poly (map_poly to_rat p)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "finally"], ["proof (chain)\npicking this:\n  p = complex_of_rat_poly (map_poly to_rat p)", "have id: \"{x. poly p x = 0} = {x. poly (complex_of_rat_poly ?q) x = 0}\" and q: \"?q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p = complex_of_rat_poly (map_poly to_rat p)\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = {x. rpoly (map_poly to_rat p) x = 0} &&&\n    map_poly to_rat p \\<noteq> 0", "using p"], ["proof (prove)\nusing this:\n  p = complex_of_rat_poly (map_poly to_rat p)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = {x. rpoly (map_poly to_rat p) x = 0} &&&\n    map_poly to_rat p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = 0} = {x. rpoly (map_poly to_rat p) x = 0}\n  map_poly to_rat p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "from complex_roots_of_rat_poly[of ?q, folded id l] q"], ["proof (chain)\npicking this:\n  map_poly to_rat p \\<noteq> 0 \\<Longrightarrow>\n  set (roots_of_complex_main p) = {x. poly p x = 0}\n  distinct (roots_of_complex_main p)\n  map_poly to_rat p \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  map_poly to_rat p \\<noteq> 0 \\<Longrightarrow>\n  set (roots_of_complex_main p) = {x. poly p x = 0}\n  distinct (roots_of_complex_main p)\n  map_poly to_rat p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n    distinct (roots_of_complex_main p)", "by auto"], ["proof (state)\nthis:\n  set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n  distinct (roots_of_complex_main p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n  distinct (roots_of_complex_main p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n  distinct (roots_of_complex_main p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n  distinct (roots_of_complex_main p)\n\ngoal (2 subgoals):\n 1. set (roots_of_complex_main p) = {x. poly p x = 0}\n 2. distinct (roots_of_complex_main p)", "thus \"set ?l = ?r\" \"distinct ?l\""], ["proof (prove)\nusing this:\n  set (roots_of_complex_main p) = {x. poly p x = 0} \\<and>\n  distinct (roots_of_complex_main p)\n\ngoal (1 subgoal):\n 1. set (roots_of_complex_main p) = {x. poly p x = 0} &&&\n    distinct (roots_of_complex_main p)", "by auto"], ["proof (state)\nthis:\n  set (roots_of_complex_main p) = {x. poly p x = 0}\n  distinct (roots_of_complex_main p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma roots_of_complex_poly: assumes rt: \"roots_of_complex_poly p = Some xs\"\n  shows \"set xs = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "obtain c pis where yun: \"yun_factorization gcd p = (c,pis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c pis.\n        yun_factorization gcd p = (c, pis) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  yun_factorization gcd p = (c, pis)\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "from rt[unfolded roots_of_complex_poly_def yun split Let_def]"], ["proof (chain)\npicking this:\n  (if c \\<noteq> 0 \\<and>\n      (\\<forall>(p, i)\\<in>set pis.\n          degree p \\<le> 2 \\<or>\n          (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>))\n   then Some (concat (map (roots_of_complex_main \\<circ> fst) pis))\n   else None) =\n  Some xs", "have c: \"c \\<noteq> 0\" and pis: \"\\<And> p i. (p, i)\\<in> set pis \\<Longrightarrow> degree p \\<le> 2 \\<or> (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>)\"\n    and xs: \"xs = concat (map (roots_of_complex_main \\<circ> fst) pis)\""], ["proof (prove)\nusing this:\n  (if c \\<noteq> 0 \\<and>\n      (\\<forall>(p, i)\\<in>set pis.\n          degree p \\<le> 2 \\<or>\n          (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>))\n   then Some (concat (map (roots_of_complex_main \\<circ> fst) pis))\n   else None) =\n  Some xs\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 &&&\n    (\\<And>p i.\n        (p, i) \\<in> set pis \\<Longrightarrow>\n        degree p \\<le> 2 \\<or>\n        (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>)) &&&\n    xs = concat (map (roots_of_complex_main \\<circ> fst) pis)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  c \\<noteq> 0\n  (?p, ?i) \\<in> set pis \\<Longrightarrow>\n  degree ?p \\<le> 2 \\<or> (\\<forall>x\\<in>set (coeffs ?p). x \\<in> \\<rat>)\n  xs = concat (map (roots_of_complex_main \\<circ> fst) pis)\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "note yun = square_free_factorizationD(1,2,4)[OF yun_factorization(1)[OF yun]]"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)\n  (?a, ?i) \\<in> set pis \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  p = 0 \\<Longrightarrow> c = 0 \\<and> pis = []\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "from yun(1)"], ["proof (chain)\npicking this:\n  p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)", "have p: \"p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)\""], ["proof (prove)\nusing this:\n  p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)", "."], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "have \"{x. poly p x = 0} = {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} =\n    {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0}", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)) x = 0} =\n    {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0}", "using c"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. poly (smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)) x = 0} =\n    {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0}", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = 0} = {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0}\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "also"], ["proof (state)\nthis:\n  {x. poly p x = 0} = {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0}\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "have \"\\<dots> = \\<Union> ((\\<lambda> p. {x. poly p x = 0}) ` fst ` set pis)\" (is \"_ = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0} =\n    (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "by (subst poly_prod_0, force+)"], ["proof (state)\nthis:\n  {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0} =\n  (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "finally"], ["proof (chain)\npicking this:\n  {x. poly p x = 0} = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "have r: \"{x. poly p x = 0} = ?r\""], ["proof (prove)\nusing this:\n  {x. poly p x = 0} = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "."], ["proof (state)\nthis:\n  {x. poly p x = 0} = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "{"], ["proof (state)\nthis:\n  {x. poly p x = 0} = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "fix p i"], ["proof (state)\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "assume p: \"(p,i) \\<in> set pis\""], ["proof (state)\nthis:\n  (p, i) \\<in> set pis\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "have \"set (roots_of_complex_main p) = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots_of_complex_main p) = {x. poly p x = 0}", "by (rule roots_of_complex_main, insert yun(2)[OF p] pis[OF p], auto)"], ["proof (state)\nthis:\n  set (roots_of_complex_main p) = {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "}"], ["proof (state)\nthis:\n  (?pa2, ?i2) \\<in> set pis \\<Longrightarrow>\n  set (roots_of_complex_main ?pa2) = {x. poly ?pa2 x = 0}\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "note main = this"], ["proof (state)\nthis:\n  (?pa2, ?i2) \\<in> set pis \\<Longrightarrow>\n  set (roots_of_complex_main ?pa2) = {x. poly ?pa2 x = 0}\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "have \"set xs = \\<Union> ((\\<lambda> (p, i). set (roots_of_complex_main p)) ` set pis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = (\\<Union>(p, i)\\<in>set pis. set (roots_of_complex_main p))", "unfolding xs o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat (map (\\<lambda>x. roots_of_complex_main (fst x)) pis)) =\n    (\\<Union>(p, i)\\<in>set pis. set (roots_of_complex_main p))", "by auto"], ["proof (state)\nthis:\n  set xs = (\\<Union>(p, i)\\<in>set pis. set (roots_of_complex_main p))\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "also"], ["proof (state)\nthis:\n  set xs = (\\<Union>(p, i)\\<in>set pis. set (roots_of_complex_main p))\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(p, i)\\<in>set pis. set (roots_of_complex_main p)) =\n    (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "using main"], ["proof (prove)\nusing this:\n  (?pa2, ?i2) \\<in> set pis \\<Longrightarrow>\n  set (roots_of_complex_main ?pa2) = {x. poly ?pa2 x = 0}\n\ngoal (1 subgoal):\n 1. (\\<Union>(p, i)\\<in>set pis. set (roots_of_complex_main p)) =\n    (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "by auto"], ["proof (state)\nthis:\n  (\\<Union>(p, i)\\<in>set pis. set (roots_of_complex_main p)) =\n  (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "finally"], ["proof (chain)\npicking this:\n  set xs = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "show ?thesis"], ["proof (prove)\nusing this:\n  set xs = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "unfolding r"], ["proof (prove)\nusing this:\n  set xs = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. set xs = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "by simp"], ["proof (state)\nthis:\n  set xs = {x. poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Factorization of Complex Polynomials\\<close>"], ["", "definition factorize_complex_main :: \"complex poly \\<Rightarrow> (complex \\<times> (complex \\<times> nat) list) option\" where\n  \"factorize_complex_main p \\<equiv> let (c,pis) = yun_factorization gcd p in\n    if ((\\<forall> (p,i) \\<in> set pis. degree p \\<le> 2 \\<or> (\\<forall> x \\<in> set (coeffs p). x \\<in> \\<rat>))) then \n    Some (c, concat (map (\\<lambda> (p,i). map (\\<lambda> r. (r,i)) (roots_of_complex_main p)) pis)) else None\""], ["", "definition factorize_complex_poly :: \"complex poly \\<Rightarrow> (complex \\<times> (complex poly \\<times> nat) list) option\" where\n  \"factorize_complex_poly p \\<equiv> map_option \n    (\\<lambda> (c,ris). (c, map (\\<lambda> (r,i). ([:-r,1:],Suc i)) ris)) (factorize_complex_main p)\""], ["", "lemma factorize_complex_main: assumes rt: \"factorize_complex_main p = Some (c,xis)\"\n  shows \"p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "obtain d pis where yun: \"yun_factorization gcd p = (d,pis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d pis.\n        yun_factorization gcd p = (d, pis) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  yun_factorization gcd p = (d, pis)\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "from rt[unfolded factorize_complex_main_def yun split Let_def]"], ["proof (chain)\npicking this:\n  (if \\<forall>(p, i)\\<in>set pis.\n         degree p \\<le> 2 \\<or>\n         (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>)\n   then Some\n         (d, concat\n              (map (\\<lambda>(p, i).\n                       map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                pis))\n   else None) =\n  Some (c, xis)", "have pis: \"\\<And> p i. (p, i)\\<in>set pis \\<Longrightarrow> degree p \\<le> 2 \\<or> (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>)\"\n    and xis: \"xis = concat (map (\\<lambda>(p, i). map (\\<lambda>r. (r, i)) (roots_of_complex_main p)) pis)\"\n    and d: \"d = c\""], ["proof (prove)\nusing this:\n  (if \\<forall>(p, i)\\<in>set pis.\n         degree p \\<le> 2 \\<or>\n         (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>)\n   then Some\n         (d, concat\n              (map (\\<lambda>(p, i).\n                       map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                pis))\n   else None) =\n  Some (c, xis)\n\ngoal (1 subgoal):\n 1. (\\<And>p i.\n        (p, i) \\<in> set pis \\<Longrightarrow>\n        degree p \\<le> 2 \\<or>\n        (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>)) &&&\n    xis =\n    concat\n     (map (\\<lambda>(p, i).\n              map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n       pis) &&&\n    d = c", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  (?p, ?i) \\<in> set pis \\<Longrightarrow>\n  degree ?p \\<le> 2 \\<or> (\\<forall>x\\<in>set (coeffs ?p). x \\<in> \\<rat>)\n  xis =\n  concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     pis)\n  d = c\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "note yun = yun_factorization[OF yun[unfolded d]]"], ["proof (state)\nthis:\n  square_free_factorization p (c, pis)\n  (?b, ?i) \\<in> set (snd (c, pis)) \\<Longrightarrow> monic ?b\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "note yun = square_free_factorizationD[OF yun(1)] yun(2)[unfolded snd_conv]"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)\n  (?a, ?i) \\<in> set pis \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  \\<lbrakk>(?a, ?i) \\<in> set pis; (?b, ?j) \\<in> set pis;\n   (?a, ?i) \\<noteq> (?b, ?j)\\<rbrakk>\n  \\<Longrightarrow> algebraic_semidom_class.coprime ?a ?b\n  p = 0 \\<Longrightarrow> c = 0 \\<and> pis = []\n  distinct pis\n  (?b, ?i) \\<in> set pis \\<Longrightarrow> monic ?b\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "let ?exp = \"\\<lambda> pis. \\<Prod>(x, i)\\<leftarrow>concat\n    (map (\\<lambda>(p, i). map (\\<lambda>r. (r, i)) (roots_of_complex_main p)) pis). [:- x, 1:] ^ Suc i\""], ["proof (state)\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "from yun(1)"], ["proof (chain)\npicking this:\n  p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)", "have p: \"p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)\""], ["proof (prove)\nusing this:\n  p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)", "."], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "also"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "have \"(\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) = (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) =\n    (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i)", "by (rule prod.distinct_set_conv_list[OF yun(5)])"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) =\n  (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "also"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) =\n  (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "have \"\\<dots> = ?exp pis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i) =\n    (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         pis). [:- x, 1:] ^ Suc i)", "using pis yun(2,6)"], ["proof (prove)\nusing this:\n  (?p, ?i) \\<in> set pis \\<Longrightarrow>\n  degree ?p \\<le> 2 \\<or> (\\<forall>x\\<in>set (coeffs ?p). x \\<in> \\<rat>)\n  (?a, ?i) \\<in> set pis \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  (?b, ?i) \\<in> set pis \\<Longrightarrow> monic ?b\n\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i) =\n    (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         pis). [:- x, 1:] ^ Suc i)", "proof (induct pis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "case (Cons pi pis)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>p i.\n              (p, i) \\<in> set pis \\<Longrightarrow>\n              degree p \\<le> 2 \\<or>\n              (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n   \\<And>a i.\n      (a, i) \\<in> set pis \\<Longrightarrow>\n      square_free a \\<and> degree a \\<noteq> 0;\n   \\<And>b i. (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>a\\<leftarrow>pis. case a of\n        (a, i) \\<Rightarrow> a ^ Suc i) =\n                    (\\<Prod>a\\<leftarrow>concat\n    (map (\\<lambda>a.\n             case a of\n             (p, i) \\<Rightarrow>\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n      pis). case a of (x, i) \\<Rightarrow> [:- x, 1:] ^ Suc i)\n  (?p, ?i) \\<in> set (pi # pis) \\<Longrightarrow>\n  degree ?p \\<le> 2 \\<or> (\\<forall>x\\<in>set (coeffs ?p). x \\<in> \\<rat>)\n  (?a, ?i) \\<in> set (pi # pis) \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  (?b, ?i) \\<in> set (pi # pis) \\<Longrightarrow> monic ?b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "obtain p i where pi: \"pi = (p,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p i. pi = (p, i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  pi = (p, i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "let ?rts = \"roots_of_complex_main p\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "note Cons = Cons[unfolded pi]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>p i.\n              (p, i) \\<in> set pis \\<Longrightarrow>\n              degree p \\<le> 2 \\<or>\n              (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n   \\<And>a i.\n      (a, i) \\<in> set pis \\<Longrightarrow>\n      square_free a \\<and> degree a \\<noteq> 0;\n   \\<And>b i. (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>a\\<leftarrow>pis. case a of\n        (a, i) \\<Rightarrow> a ^ Suc i) =\n                    (\\<Prod>a\\<leftarrow>concat\n    (map (\\<lambda>a.\n             case a of\n             (p, i) \\<Rightarrow>\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n      pis). case a of (x, i) \\<Rightarrow> [:- x, 1:] ^ Suc i)\n  (?p, ?i) \\<in> set ((p, i) # pis) \\<Longrightarrow>\n  degree ?p \\<le> 2 \\<or> (\\<forall>x\\<in>set (coeffs ?p). x \\<in> \\<rat>)\n  (?a, ?i) \\<in> set ((p, i) # pis) \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  (?b, ?i) \\<in> set ((p, i) # pis) \\<Longrightarrow> monic ?b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "have IH: \"(\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i) = (?exp pis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i) =\n    (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         pis). [:- x, 1:] ^ Suc i)", "by (rule Cons(1)[OF Cons(2-4)], auto)"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i) =\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       pis). [:- x, 1:] ^ Suc i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "from Cons(2-4)[of p i]"], ["proof (chain)\npicking this:\n  (p, i) \\<in> set ((p, i) # pis) \\<Longrightarrow>\n  degree p \\<le> 2 \\<or> (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>)\n  (p, i) \\<in> set ((p, i) # pis) \\<Longrightarrow>\n  square_free p \\<and> degree p \\<noteq> 0\n  (p, i) \\<in> set ((p, i) # pis) \\<Longrightarrow> monic p", "have deg: \"degree p \\<le> 2 \\<or> (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>)\"\n      and p: \"square_free p\" \"degree p \\<noteq> 0\" \"p \\<noteq> 0\" \"monic p\""], ["proof (prove)\nusing this:\n  (p, i) \\<in> set ((p, i) # pis) \\<Longrightarrow>\n  degree p \\<le> 2 \\<or> (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>)\n  (p, i) \\<in> set ((p, i) # pis) \\<Longrightarrow>\n  square_free p \\<and> degree p \\<noteq> 0\n  (p, i) \\<in> set ((p, i) # pis) \\<Longrightarrow> monic p\n\ngoal (1 subgoal):\n 1. degree p \\<le> 2 \\<or>\n    (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>) &&&\n    (square_free p &&& degree p \\<noteq> 0) &&& p \\<noteq> 0 &&& monic p", "by auto"], ["proof (state)\nthis:\n  degree p \\<le> 2 \\<or> (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>)\n  square_free p\n  degree p \\<noteq> 0\n  p \\<noteq> 0\n  monic p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "have \"(\\<Prod>(a, i)\\<leftarrow>(pi # pis). a ^ Suc i) = p ^ Suc i * (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<leftarrow>pi # pis. a ^ Suc i) =\n    p ^ Suc i * (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i)", "unfolding pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<leftarrow>(p, i) # pis. a ^ Suc i) =\n    p ^ Suc i * (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i)", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<leftarrow>pi # pis. a ^ Suc i) =\n  p ^ Suc i * (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "also"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<leftarrow>pi # pis. a ^ Suc i) =\n  p ^ Suc i * (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "have \"(\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i) = ?exp pis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i) =\n    (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         pis). [:- x, 1:] ^ Suc i)", "by (rule IH)"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i) =\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       pis). [:- x, 1:] ^ Suc i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>a\\<leftarrow>pi # pis. case a of (a, i) \\<Rightarrow> a ^ Suc i) =\n  p ^ Suc i *\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       pis). [:- x, 1:] ^ Suc i)", "have id: \"(\\<Prod>(a, i)\\<leftarrow>(pi # pis). a ^ Suc i) = p ^ Suc i * ?exp pis\""], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<leftarrow>pi # pis. case a of (a, i) \\<Rightarrow> a ^ Suc i) =\n  p ^ Suc i *\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       pis). [:- x, 1:] ^ Suc i)\n\ngoal (1 subgoal):\n 1. (\\<Prod>(a, i)\\<leftarrow>pi # pis. a ^ Suc i) =\n    p ^ Suc i *\n    (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         pis). [:- x, 1:] ^ Suc i)", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<leftarrow>pi # pis. a ^ Suc i) =\n  p ^ Suc i *\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       pis). [:- x, 1:] ^ Suc i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "have \"?exp (pi # pis) = ?exp [(p,i)] * ?exp pis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         (pi # pis)). [:- x, 1:] ^ Suc i) =\n    (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         [(p, i)]). [:- x, 1:] ^ Suc i) *\n    (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         pis). [:- x, 1:] ^ Suc i)", "unfolding pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         ((p, i) # pis)). [:- x, 1:] ^ Suc i) =\n    (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         [(p, i)]). [:- x, 1:] ^ Suc i) *\n    (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         pis). [:- x, 1:] ^ Suc i)", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       (pi # pis)). [:- x, 1:] ^ Suc i) =\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       [(p, i)]). [:- x, 1:] ^ Suc i) *\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       pis). [:- x, 1:] ^ Suc i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "also"], ["proof (state)\nthis:\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       (pi # pis)). [:- x, 1:] ^ Suc i) =\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       [(p, i)]). [:- x, 1:] ^ Suc i) *\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       pis). [:- x, 1:] ^ Suc i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "have \"?exp [(p,i)] = (\\<Prod>(x, i)\\<leftarrow> (map (\\<lambda>r. (r, i)) ?rts). [:- x, 1:] ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         [(p, i)]). [:- x, 1:] ^ Suc i) =\n    (\\<Prod>(x,\n        i)\\<leftarrow>map (\\<lambda>r. (r, i))\n                       (roots_of_complex_main p). [:- x, 1:] ^ Suc i)", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       [(p, i)]). [:- x, 1:] ^ Suc i) =\n  (\\<Prod>(x,\n      i)\\<leftarrow>map (\\<lambda>r. (r, i))\n                     (roots_of_complex_main p). [:- x, 1:] ^ Suc i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "also"], ["proof (state)\nthis:\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       [(p, i)]). [:- x, 1:] ^ Suc i) =\n  (\\<Prod>(x,\n      i)\\<leftarrow>map (\\<lambda>r. (r, i))\n                     (roots_of_complex_main p). [:- x, 1:] ^ Suc i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "have \"\\<dots> = (\\<Prod> x \\<leftarrow> ?rts. [:- x, 1:])^Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x,\n        i)\\<leftarrow>map (\\<lambda>r. (r, i))\n                       (roots_of_complex_main p). [:- x, 1:] ^ Suc i) =\n    (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) ^ Suc i", "unfolding prod_list_power"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x,\n        i)\\<leftarrow>map (\\<lambda>r. (r, i))\n                       (roots_of_complex_main p). [:- x, 1:] ^ Suc i) =\n    (\\<Prod>x\\<leftarrow>map (\\<lambda>x. [:- x, 1:])\n                          (roots_of_complex_main p). x ^ Suc i)", "by (rule arg_cong[of _ _ prod_list], auto)"], ["proof (state)\nthis:\n  (\\<Prod>(x,\n      i)\\<leftarrow>map (\\<lambda>r. (r, i))\n                     (roots_of_complex_main p). [:- x, 1:] ^ Suc i) =\n  (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) ^ Suc i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "also"], ["proof (state)\nthis:\n  (\\<Prod>(x,\n      i)\\<leftarrow>map (\\<lambda>r. (r, i))\n                     (roots_of_complex_main p). [:- x, 1:] ^ Suc i) =\n  (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) ^ Suc i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "have \"(\\<Prod> x \\<leftarrow> ?rts. [:- x, 1:]) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p", "from fundamental_theorem_algebra_factorized[of p, unfolded \\<open>monic p\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     smult 1 (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = p \\<and>\n     length as = degree p", "obtain as where as: \"p = (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\""], ["proof (prove)\nusing this:\n  \\<exists>as.\n     smult 1 (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = p \\<and>\n     length as = degree p\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        p = (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p", "also"], ["proof (state)\nthis:\n  p = (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p", "have \"\\<dots> = (\\<Prod>a\\<in>set as. [:- a, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = (\\<Prod>a\\<in>set as. [:- a, 1:])", "proof (rule sym, rule prod.distinct_set_conv_list, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct as \\<Longrightarrow> False", "assume \"\\<not> distinct as\""], ["proof (state)\nthis:\n  \\<not> distinct as\n\ngoal (1 subgoal):\n 1. \\<not> distinct as \\<Longrightarrow> False", "from not_distinct_decomp[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>xs ys zs y. as = xs @ [y] @ ys @ [y] @ zs", "obtain as1 as2 as3 a where\n          a: \"as = as1 @ [a] @ as2 @ [a] @ as3\""], ["proof (prove)\nusing this:\n  \\<exists>xs ys zs y. as = xs @ [y] @ ys @ [y] @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>as1 a as2 as3.\n        as = as1 @ [a] @ as2 @ [a] @ as3 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = as1 @ [a] @ as2 @ [a] @ as3\n\ngoal (1 subgoal):\n 1. \\<not> distinct as \\<Longrightarrow> False", "define q where \"q = (\\<Prod>a\\<leftarrow>as1 @ as2 @ as3. [:- a, 1:])\""], ["proof (state)\nthis:\n  q = (\\<Prod>a\\<leftarrow>as1 @ as2 @ as3. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. \\<not> distinct as \\<Longrightarrow> False", "have \"p = (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = (\\<Prod>a\\<leftarrow>as. [:- a, 1:])", "by fact"], ["proof (state)\nthis:\n  p = (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. \\<not> distinct as \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  p = (\\<Prod>a\\<leftarrow>as. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. \\<not> distinct as \\<Longrightarrow> False", "have \"\\<dots> = (\\<Prod>a\\<leftarrow>([a] @ [a]). [:- a, 1:]) * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n    (\\<Prod>a\\<leftarrow>[a] @ [a]. [:- a, 1:]) * q", "unfolding q_def a map_append prod_list.append"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>as1. [:- a, 1:]) *\n    ((\\<Prod>a\\<leftarrow>[a]. [:- a, 1:]) *\n     ((\\<Prod>a\\<leftarrow>as2. [:- a, 1:]) *\n      ((\\<Prod>a\\<leftarrow>[a]. [:- a, 1:]) *\n       (\\<Prod>a\\<leftarrow>as3. [:- a, 1:])))) =\n    (\\<Prod>a\\<leftarrow>[a]. [:- a, 1:]) *\n    (\\<Prod>a\\<leftarrow>[a]. [:- a, 1:]) *\n    ((\\<Prod>a\\<leftarrow>as1. [:- a, 1:]) *\n     ((\\<Prod>a\\<leftarrow>as2. [:- a, 1:]) *\n      (\\<Prod>a\\<leftarrow>as3. [:- a, 1:])))", "by (simp only: ac_simps)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n  (\\<Prod>a\\<leftarrow>[a] @ [a]. [:- a, 1:]) * q\n\ngoal (1 subgoal):\n 1. \\<not> distinct as \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n  (\\<Prod>a\\<leftarrow>[a] @ [a]. [:- a, 1:]) * q\n\ngoal (1 subgoal):\n 1. \\<not> distinct as \\<Longrightarrow> False", "have \"\\<dots> = [:-a,1:] * [:-a,1:] * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>[a] @ [a]. [:- a, 1:]) * q =\n    [:- a, 1:] * [:- a, 1:] * q", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>[a] @ [a]. [:- a, 1:]) * q =\n  [:- a, 1:] * [:- a, 1:] * q\n\ngoal (1 subgoal):\n 1. \\<not> distinct as \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  p = [:- a, 1:] * [:- a, 1:] * q", "have \"p = ([:-a,1:] * [:-a,1:]) * q\""], ["proof (prove)\nusing this:\n  p = [:- a, 1:] * [:- a, 1:] * q\n\ngoal (1 subgoal):\n 1. p = [:- a, 1:] * [:- a, 1:] * q", "by simp"], ["proof (state)\nthis:\n  p = [:- a, 1:] * [:- a, 1:] * q\n\ngoal (1 subgoal):\n 1. \\<not> distinct as \\<Longrightarrow> False", "hence \"[:-a,1:] * [:-a,1:] dvd p\""], ["proof (prove)\nusing this:\n  p = [:- a, 1:] * [:- a, 1:] * q\n\ngoal (1 subgoal):\n 1. [:- a, 1:] * [:- a, 1:] dvd p", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  p = [:- a, 1:] * [:- a, 1:] * q\n\ngoal (1 subgoal):\n 1. \\<exists>k. p = [:- a, 1:] * [:- a, 1:] * k", ".."], ["proof (state)\nthis:\n  [:- a, 1:] * [:- a, 1:] dvd p\n\ngoal (1 subgoal):\n 1. \\<not> distinct as \\<Longrightarrow> False", "with \\<open>square_free p\\<close>[unfolded square_free_def, THEN conjunct2, rule_format, of \"[:-a,1:]\"]"], ["proof (chain)\npicking this:\n  0 < degree [:- a, 1:] \\<Longrightarrow>\n  \\<not> [:- a, 1:] * [:- a, 1:] dvd p\n  [:- a, 1:] * [:- a, 1:] dvd p", "show False"], ["proof (prove)\nusing this:\n  0 < degree [:- a, 1:] \\<Longrightarrow>\n  \\<not> [:- a, 1:] * [:- a, 1:] dvd p\n  [:- a, 1:] * [:- a, 1:] dvd p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = (\\<Prod>a\\<in>set as. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = (\\<Prod>a\\<in>set as. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p", "have \"set as = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set as = {x. poly p x = 0}", "unfolding as poly_prod_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. set as =\n    {x. (\\<Prod>p\\<leftarrow>map (\\<lambda>a. [:- a, 1:]) as. poly p x) = 0}", "by (simp add: o_def, induct as, auto)"], ["proof (state)\nthis:\n  set as = {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p", "also"], ["proof (state)\nthis:\n  set as = {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p", "have \"\\<dots> = set ?rts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = set (roots_of_complex_main p)", "by (rule roots_of_complex_main(1)[symmetric], insert p deg, auto)"], ["proof (state)\nthis:\n  {x. poly p x = 0} = set (roots_of_complex_main p)\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p", "also"], ["proof (state)\nthis:\n  {x. poly p x = 0} = set (roots_of_complex_main p)\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p", "have \"(\\<Prod>a\\<in>set ?rts. [:- a, 1:]) = (\\<Prod>a\\<leftarrow>?rts. [:- a, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>set (roots_of_complex_main p). [:- a, 1:]) =\n    (\\<Prod>a\\<leftarrow>roots_of_complex_main p. [:- a, 1:])", "by (rule prod.distinct_set_conv_list[OF roots_of_complex_main(2)], insert deg p, auto)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>set (roots_of_complex_main p). [:- a, 1:]) =\n  (\\<Prod>a\\<leftarrow>roots_of_complex_main p. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p", "finally"], ["proof (chain)\npicking this:\n  p = (\\<Prod>a\\<leftarrow>roots_of_complex_main p. [:- a, 1:])", "show ?thesis"], ["proof (prove)\nusing this:\n  p = (\\<Prod>a\\<leftarrow>roots_of_complex_main p. [:- a, 1:])\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>x\\<leftarrow>roots_of_complex_main p. [:- x, 1:]) = p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>a\\<leftarrow>concat\n                        (map (\\<lambda>a.\n                                 case a of\n                                 (p, i) \\<Rightarrow>\n                                   map (\\<lambda>r. (r, i))\n                                    (roots_of_complex_main p))\n                          (pi #\n                           pis)). case a of\n                                  (x, i) \\<Rightarrow> [:- x, 1:] ^ Suc i) =\n  p ^ Suc i *\n  (\\<Prod>a\\<leftarrow>concat\n                        (map (\\<lambda>a.\n                                 case a of\n                                 (p, i) \\<Rightarrow>\n                                   map (\\<lambda>r. (r, i))\n                                    (roots_of_complex_main p))\n                          pis). case a of\n                                (x, i) \\<Rightarrow> [:- x, 1:] ^ Suc i)", "have id2: \"?exp (pi # pis) = p ^ Suc i * ?exp pis\""], ["proof (prove)\nusing this:\n  (\\<Prod>a\\<leftarrow>concat\n                        (map (\\<lambda>a.\n                                 case a of\n                                 (p, i) \\<Rightarrow>\n                                   map (\\<lambda>r. (r, i))\n                                    (roots_of_complex_main p))\n                          (pi #\n                           pis)). case a of\n                                  (x, i) \\<Rightarrow> [:- x, 1:] ^ Suc i) =\n  p ^ Suc i *\n  (\\<Prod>a\\<leftarrow>concat\n                        (map (\\<lambda>a.\n                                 case a of\n                                 (p, i) \\<Rightarrow>\n                                   map (\\<lambda>r. (r, i))\n                                    (roots_of_complex_main p))\n                          pis). case a of\n                                (x, i) \\<Rightarrow> [:- x, 1:] ^ Suc i)\n\ngoal (1 subgoal):\n 1. (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         (pi # pis)). [:- x, 1:] ^ Suc i) =\n    p ^ Suc i *\n    (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         pis). [:- x, 1:] ^ Suc i)", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       (pi # pis)). [:- x, 1:] ^ Suc i) =\n  p ^ Suc i *\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       pis). [:- x, 1:] ^ Suc i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)\n 2. \\<And>a pis.\n       \\<lbrakk>\\<lbrakk>\\<And>p i.\n                            (p, i) \\<in> set pis \\<Longrightarrow>\n                            degree p \\<le> 2 \\<or>\n                            (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n                 \\<And>a i.\n                    (a, i) \\<in> set pis \\<Longrightarrow>\n                    square_free a \\<and> degree a \\<noteq> 0;\n                 \\<And>b i.\n                    (b, i) \\<in> set pis \\<Longrightarrow> monic b\\<rbrakk>\n                \\<Longrightarrow> (\\<Prod>(a,\ni)\\<leftarrow>pis. a ^ Suc i) =\n                                  (\\<Prod>(x,\ni)\\<leftarrow>concat\n               (map (\\<lambda>(p, i).\n                        map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n                 pis). [:- x, 1:] ^ Suc i);\n        \\<And>p i.\n           (p, i) \\<in> set (a # pis) \\<Longrightarrow>\n           degree p \\<le> 2 \\<or>\n           (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n        \\<And>aa i.\n           (aa, i) \\<in> set (a # pis) \\<Longrightarrow>\n           square_free aa \\<and> degree aa \\<noteq> 0;\n        \\<And>b i.\n           (b, i) \\<in> set (a # pis) \\<Longrightarrow> monic b\\<rbrakk>\n       \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>a # pis. a ^ Suc i) =\n                         (\\<Prod>(x,\n                             i)\\<leftarrow>concat\n      (map (\\<lambda>(p, i).\n               map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n        (a # pis)). [:- x, 1:] ^ Suc i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<leftarrow>pi #\n                         pis. case a of (a, i) \\<Rightarrow> a ^ Suc i) =\n    (\\<Prod>a\\<leftarrow>concat\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (p, i) \\<Rightarrow>\n                                     map (\\<lambda>r. (r, i))\n(roots_of_complex_main p))\n                            (pi #\n                             pis)). case a of\n                                    (x, i) \\<Rightarrow> [:- x, 1:] ^ Suc i)", "unfolding id id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ Suc i *\n    (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         pis). [:- x, 1:] ^ Suc i) =\n    p ^ Suc i *\n    (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         pis). [:- x, 1:] ^ Suc i)", ".."], ["proof (state)\nthis:\n  (\\<Prod>a\\<leftarrow>pi # pis. case a of (a, i) \\<Rightarrow> a ^ Suc i) =\n  (\\<Prod>a\\<leftarrow>concat\n                        (map (\\<lambda>a.\n                                 case a of\n                                 (p, i) \\<Rightarrow>\n                                   map (\\<lambda>r. (r, i))\n                                    (roots_of_complex_main p))\n                          (pi #\n                           pis)). case a of\n                                  (x, i) \\<Rightarrow> [:- x, 1:] ^ Suc i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p i.\n                (p, i) \\<in> set [] \\<Longrightarrow>\n                degree p \\<le> 2 \\<or>\n                (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>);\n     \\<And>a i.\n        (a, i) \\<in> set [] \\<Longrightarrow>\n        square_free a \\<and> degree a \\<noteq> 0;\n     \\<And>b i. (b, i) \\<in> set [] \\<Longrightarrow> monic b\\<rbrakk>\n    \\<Longrightarrow> (\\<Prod>(a, i)\\<leftarrow>[]. a ^ Suc i) =\n                      (\\<Prod>(x,\n                          i)\\<leftarrow>concat\n   (map (\\<lambda>(p, i).\n            map (\\<lambda>r. (r, i)) (roots_of_complex_main p))\n     []). [:- x, 1:] ^ Suc i)", "qed simp"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i) =\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       pis). [:- x, 1:] ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "also"], ["proof (state)\nthis:\n  (\\<Prod>(a, i)\\<leftarrow>pis. a ^ Suc i) =\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       pis). [:- x, 1:] ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "have \"?exp pis = (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         pis). [:- x, 1:] ^ Suc i) =\n    (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "unfolding xis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         pis). [:- x, 1:] ^ Suc i) =\n    (\\<Prod>(x,\n        i)\\<leftarrow>concat\n                       (map (\\<lambda>(p, i).\n                                map (\\<lambda>r. (r, i))\n                                 (roots_of_complex_main p))\n                         pis). [:- x, 1:] ^ Suc i)", ".."], ["proof (state)\nthis:\n  (\\<Prod>(x,\n      i)\\<leftarrow>concat\n                     (map (\\<lambda>(p, i).\n                              map (\\<lambda>r. (r, i))\n                               (roots_of_complex_main p))\n                       pis). [:- x, 1:] ^ Suc i) =\n  (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "finally"], ["proof (chain)\npicking this:\n  p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "show ?thesis"], ["proof (prove)\nusing this:\n  p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)", "unfolding p xis"], ["proof (prove)\nusing this:\n  smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) =\n  smult c\n   (\\<Prod>(x,\n       i)\\<leftarrow>concat\n                      (map (\\<lambda>(p, i).\n                               map (\\<lambda>r. (r, i))\n                                (roots_of_complex_main p))\n                        pis). [:- x, 1:] ^ Suc i)\n\ngoal (1 subgoal):\n 1. smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) =\n    smult c\n     (\\<Prod>(x,\n         i)\\<leftarrow>concat\n                        (map (\\<lambda>(p, i).\n                                 map (\\<lambda>r. (r, i))\n                                  (roots_of_complex_main p))\n                          pis). [:- x, 1:] ^ Suc i)", "by simp"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(x, i)\\<leftarrow>xis. [:- x, 1:] ^ Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_factorize_complex_main:\n  assumes \"factorize_complex_main p = Some fctrs\"\n  shows   \"distinct (map fst (snd fctrs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (snd fctrs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map fst (snd fctrs))", "from assms"], ["proof (chain)\npicking this:\n  factorize_complex_main p = Some fctrs", "have solvable: \"\\<forall>x\\<in>set (snd (yun_factorization gcd p)). degree (fst x) \\<le> 2 \\<or> \n                                 (\\<forall>x\\<in>set (coeffs (fst x)). x \\<in> \\<rat>)\""], ["proof (prove)\nusing this:\n  factorize_complex_main p = Some fctrs\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (snd (yun_factorization gcd p)).\n       degree (fst x) \\<le> 2 \\<or>\n       (\\<forall>x\\<in>set (coeffs (fst x)). x \\<in> \\<rat>)", "by (auto simp add: factorize_complex_main_def case_prod_unfold \n                       Let_def map_concat o_def split: if_splits)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (snd (yun_factorization gcd p)).\n     degree (fst x) \\<le> 2 \\<or>\n     (\\<forall>x\\<in>set (coeffs (fst x)). x \\<in> \\<rat>)\n\ngoal (1 subgoal):\n 1. distinct (map fst (snd fctrs))", "have sqf: \"square_free_factorization p \n               (fst (yun_factorization gcd p), snd (yun_factorization gcd p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free_factorization p\n     (fst (yun_factorization gcd p), snd (yun_factorization gcd p))", "by (rule yun_factorization) simp"], ["proof (state)\nthis:\n  square_free_factorization p\n   (fst (yun_factorization gcd p), snd (yun_factorization gcd p))\n\ngoal (1 subgoal):\n 1. distinct (map fst (snd fctrs))", "have \"map fst (snd fctrs) = \n        concat (map (\\<lambda>x. (roots_of_complex_main (fst x))) (snd (yun_factorization gcd p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (snd fctrs) =\n    concat\n     (map (\\<lambda>x. roots_of_complex_main (fst x))\n       (snd (yun_factorization gcd p)))", "using assms"], ["proof (prove)\nusing this:\n  factorize_complex_main p = Some fctrs\n\ngoal (1 subgoal):\n 1. map fst (snd fctrs) =\n    concat\n     (map (\\<lambda>x. roots_of_complex_main (fst x))\n       (snd (yun_factorization gcd p)))", "by (auto simp add: factorize_complex_main_def case_prod_unfold \n                           Let_def map_concat o_def split: if_splits)"], ["proof (state)\nthis:\n  map fst (snd fctrs) =\n  concat\n   (map (\\<lambda>x. roots_of_complex_main (fst x))\n     (snd (yun_factorization gcd p)))\n\ngoal (1 subgoal):\n 1. distinct (map fst (snd fctrs))", "also"], ["proof (state)\nthis:\n  map fst (snd fctrs) =\n  concat\n   (map (\\<lambda>x. roots_of_complex_main (fst x))\n     (snd (yun_factorization gcd p)))\n\ngoal (1 subgoal):\n 1. distinct (map fst (snd fctrs))", "have \"distinct \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (concat\n       (map (\\<lambda>x. roots_of_complex_main (fst x))\n         (snd (yun_factorization gcd p))))", "proof (rule distinct_concat, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct\n     (map (\\<lambda>x. roots_of_complex_main (fst x))\n       (snd (yun_factorization gcd p)))\n 2. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                      (snd (yun_factorization gcd p))) \\<Longrightarrow>\n       distinct ys\n 3. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. distinct\n     (map (\\<lambda>x. roots_of_complex_main (fst x))\n       (snd (yun_factorization gcd p)))\n 2. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                      (snd (yun_factorization gcd p))) \\<Longrightarrow>\n       distinct ys\n 3. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x. roots_of_complex_main (fst x))\n       (snd (yun_factorization gcd p)))", "proof (subst distinct_map, safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (snd (yun_factorization gcd p))\n 2. inj_on (\\<lambda>x. roots_of_complex_main (fst x))\n     (set (snd (yun_factorization gcd p)))", "from square_free_factorizationD(5)[OF sqf]"], ["proof (chain)\npicking this:\n  distinct (snd (yun_factorization gcd p))", "show \"distinct (snd (yun_factorization gcd p))\""], ["proof (prove)\nusing this:\n  distinct (snd (yun_factorization gcd p))\n\ngoal (1 subgoal):\n 1. distinct (snd (yun_factorization gcd p))", "."], ["proof (state)\nthis:\n  distinct (snd (yun_factorization gcd p))\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. roots_of_complex_main (fst x))\n     (set (snd (yun_factorization gcd p)))", "show \"inj_on (\\<lambda>x. (roots_of_complex_main (fst x))) (set (snd (yun_factorization gcd p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. roots_of_complex_main (fst x))\n     (set (snd (yun_factorization gcd p)))", "proof (rule inj_onI, clarify, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "case (1 a1 b1 a2 b2)"], ["proof (state)\nthis:\n  (a1, b1) \\<in> set (snd (yun_factorization gcd p))\n  (a2, b2) \\<in> set (snd (yun_factorization gcd p))\n  roots_of_complex_main (fst (a1, b1)) =\n  roots_of_complex_main (fst (a2, b2))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "{"], ["proof (state)\nthis:\n  (a1, b1) \\<in> set (snd (yun_factorization gcd p))\n  (a2, b2) \\<in> set (snd (yun_factorization gcd p))\n  roots_of_complex_main (fst (a1, b1)) =\n  roots_of_complex_main (fst (a2, b2))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "assume neq: \"(a1, b1) \\<noteq> (a2, b2)\""], ["proof (state)\nthis:\n  (a1, b1) \\<noteq> (a2, b2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "from 1(1,2)[THEN square_free_factorizationD(2)[OF sqf]]"], ["proof (chain)\npicking this:\n  square_free a1 \\<and> degree a1 \\<noteq> 0\n  square_free a2 \\<and> degree a2 \\<noteq> 0", "have \"degree a1 \\<noteq> 0\" \"degree a2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  square_free a1 \\<and> degree a1 \\<noteq> 0\n  square_free a2 \\<and> degree a2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree a1 \\<noteq> 0 &&& degree a2 \\<noteq> 0", "by blast+"], ["proof (state)\nthis:\n  degree a1 \\<noteq> 0\n  degree a2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "hence [simp]: \"a1 \\<noteq> 0\" \"a2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree a1 \\<noteq> 0\n  degree a2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a1 \\<noteq> 0 &&& a2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a1 \\<noteq> 0\n  a2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "from square_free_factorizationD(3)[OF sqf 1(1,2) neq]"], ["proof (chain)\npicking this:\n  algebraic_semidom_class.coprime a1 a2", "have \"coprime a1 a2\""], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime a1 a2\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime a1 a2", "by simp"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime a1 a2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "from solvable 1(1)"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (snd (yun_factorization gcd p)).\n     degree (fst x) \\<le> 2 \\<or>\n     (\\<forall>x\\<in>set (coeffs (fst x)). x \\<in> \\<rat>)\n  (a1, b1) \\<in> set (snd (yun_factorization gcd p))", "have \"{z. poly a1 z = 0} = set (roots_of_complex_main a1)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (snd (yun_factorization gcd p)).\n     degree (fst x) \\<le> 2 \\<or>\n     (\\<forall>x\\<in>set (coeffs (fst x)). x \\<in> \\<rat>)\n  (a1, b1) \\<in> set (snd (yun_factorization gcd p))\n\ngoal (1 subgoal):\n 1. {z. poly a1 z = 0} = set (roots_of_complex_main a1)", "by (intro roots_of_complex_main(1) [symmetric]) auto"], ["proof (state)\nthis:\n  {z. poly a1 z = 0} = set (roots_of_complex_main a1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "also"], ["proof (state)\nthis:\n  {z. poly a1 z = 0} = set (roots_of_complex_main a1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "have \"set (roots_of_complex_main a1) = set (roots_of_complex_main a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots_of_complex_main a1) = set (roots_of_complex_main a2)", "using 1(3)"], ["proof (prove)\nusing this:\n  roots_of_complex_main (fst (a1, b1)) =\n  roots_of_complex_main (fst (a2, b2))\n\ngoal (1 subgoal):\n 1. set (roots_of_complex_main a1) = set (roots_of_complex_main a2)", "by (subst (1 2) set_remdups [symmetric]) (simp only: fst_conv)"], ["proof (state)\nthis:\n  set (roots_of_complex_main a1) = set (roots_of_complex_main a2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "also"], ["proof (state)\nthis:\n  set (roots_of_complex_main a1) = set (roots_of_complex_main a2)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "from solvable 1(2)"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (snd (yun_factorization gcd p)).\n     degree (fst x) \\<le> 2 \\<or>\n     (\\<forall>x\\<in>set (coeffs (fst x)). x \\<in> \\<rat>)\n  (a2, b2) \\<in> set (snd (yun_factorization gcd p))", "have \"\\<dots> = {z. poly a2 z = 0}\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (snd (yun_factorization gcd p)).\n     degree (fst x) \\<le> 2 \\<or>\n     (\\<forall>x\\<in>set (coeffs (fst x)). x \\<in> \\<rat>)\n  (a2, b2) \\<in> set (snd (yun_factorization gcd p))\n\ngoal (1 subgoal):\n 1. set (roots_of_complex_main a2) = {z. poly a2 z = 0}", "by (intro roots_of_complex_main) auto"], ["proof (state)\nthis:\n  set (roots_of_complex_main a2) = {z. poly a2 z = 0}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "finally"], ["proof (chain)\npicking this:\n  {z. poly a1 z = 0} = {z. poly a2 z = 0}", "have \"{z. poly a1 z = 0} = {z. poly a2 z = 0}\""], ["proof (prove)\nusing this:\n  {z. poly a1 z = 0} = {z. poly a2 z = 0}\n\ngoal (1 subgoal):\n 1. {z. poly a1 z = 0} = {z. poly a2 z = 0}", "."], ["proof (state)\nthis:\n  {z. poly a1 z = 0} = {z. poly a2 z = 0}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "with coprime_imp_no_common_roots \\<open>coprime a1 a2\\<close>"], ["proof (chain)\npicking this:\n  algebraic_semidom_class.coprime ?p ?q \\<Longrightarrow>\n  \\<not> (poly ?p ?x = (0::?'a) \\<and> poly ?q ?x = (0::?'a))\n  comm_monoid_mult_class.coprime a1 a2\n  {z. poly a1 z = 0} = {z. poly a2 z = 0}", "have \"{z. poly a1 z = 0} = {}\""], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime ?p ?q \\<Longrightarrow>\n  \\<not> (poly ?p ?x = (0::?'a) \\<and> poly ?q ?x = (0::?'a))\n  comm_monoid_mult_class.coprime a1 a2\n  {z. poly a1 z = 0} = {z. poly a2 z = 0}\n\ngoal (1 subgoal):\n 1. {z. poly a1 z = 0} = {}", "by auto"], ["proof (state)\nthis:\n  {z. poly a1 z = 0} = {}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "with fundamental_theorem_of_algebra constant_degree"], ["proof (chain)\npicking this:\n  \\<not> constant (poly ?p) \\<Longrightarrow> \\<exists>z. poly ?p z = 0\n  constant (poly ?p) = (degree ?p = 0)\n  {z. poly a1 z = 0} = {}", "have \"degree a1 = 0\""], ["proof (prove)\nusing this:\n  \\<not> constant (poly ?p) \\<Longrightarrow> \\<exists>z. poly ?p z = 0\n  constant (poly ?p) = (degree ?p = 0)\n  {z. poly a1 z = 0} = {}\n\ngoal (1 subgoal):\n 1. degree a1 = 0", "by auto"], ["proof (state)\nthis:\n  degree a1 = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "with \\<open>degree a1 \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  degree a1 \\<noteq> 0\n  degree a1 = 0", "have False"], ["proof (prove)\nusing this:\n  degree a1 \\<noteq> 0\n  degree a1 = 0\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "}"], ["proof (state)\nthis:\n  (a1, b1) \\<noteq> (a2, b2) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> set (snd (yun_factorization gcd p));\n        (aa, ba) \\<in> set (snd (yun_factorization gcd p));\n        roots_of_complex_main (fst (a, b)) =\n        roots_of_complex_main (fst (aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a = aa \\<and> b = ba", "thus ?case"], ["proof (prove)\nusing this:\n  (a1, b1) \\<noteq> (a2, b2) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. a1 = a2 \\<and> b1 = b2", "by blast"], ["proof (state)\nthis:\n  a1 = a2 \\<and> b1 = b2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. roots_of_complex_main (fst x))\n   (set (snd (yun_factorization gcd p)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>x. roots_of_complex_main (fst x))\n     (snd (yun_factorization gcd p)))\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                      (snd (yun_factorization gcd p))) \\<Longrightarrow>\n       distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                      (snd (yun_factorization gcd p))) \\<Longrightarrow>\n       distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "case (2 ys)"], ["proof (state)\nthis:\n  ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                 (snd (yun_factorization gcd p)))\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                      (snd (yun_factorization gcd p))) \\<Longrightarrow>\n       distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "then"], ["proof (chain)\npicking this:\n  ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                 (snd (yun_factorization gcd p)))", "obtain f b where fb: \"(f, b) \\<in> set (snd (yun_factorization gcd p))\" \n      and ys: \"ys = roots_of_complex_main f\""], ["proof (prove)\nusing this:\n  ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                 (snd (yun_factorization gcd p)))\n\ngoal (1 subgoal):\n 1. (\\<And>f b.\n        \\<lbrakk>(f, b) \\<in> set (snd (yun_factorization gcd p));\n         ys = roots_of_complex_main f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (f, b) \\<in> set (snd (yun_factorization gcd p))\n  ys = roots_of_complex_main f\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                      (snd (yun_factorization gcd p))) \\<Longrightarrow>\n       distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "from square_free_factorizationD(2)[OF sqf fb]"], ["proof (chain)\npicking this:\n  square_free f \\<and> degree f \\<noteq> 0", "have 0: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  square_free f \\<and> degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                      (snd (yun_factorization gcd p))) \\<Longrightarrow>\n       distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "from solvable[rule_format, OF fb]"], ["proof (chain)\npicking this:\n  degree (fst (f, b)) \\<le> 2 \\<or>\n  (\\<forall>x\\<in>set (coeffs (fst (f, b))). x \\<in> \\<rat>)", "have f: \"degree f \\<le> 2 \\<or> (set (coeffs f) \\<subseteq> \\<rat>)\""], ["proof (prove)\nusing this:\n  degree (fst (f, b)) \\<le> 2 \\<or>\n  (\\<forall>x\\<in>set (coeffs (fst (f, b))). x \\<in> \\<rat>)\n\ngoal (1 subgoal):\n 1. degree f \\<le> 2 \\<or> set (coeffs f) \\<subseteq> \\<rat>", "by auto"], ["proof (state)\nthis:\n  degree f \\<le> 2 \\<or> set (coeffs f) \\<subseteq> \\<rat>\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                      (snd (yun_factorization gcd p))) \\<Longrightarrow>\n       distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ys", "unfolding ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (roots_of_complex_main f)", "by (rule roots_of_complex_main[OF 0 f])"], ["proof (state)\nthis:\n  distinct ys\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "case (3 ys zs)"], ["proof (state)\nthis:\n  ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                 (snd (yun_factorization gcd p)))\n  zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                 (snd (yun_factorization gcd p)))\n  ys \\<noteq> zs\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "then"], ["proof (chain)\npicking this:\n  ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                 (snd (yun_factorization gcd p)))\n  zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                 (snd (yun_factorization gcd p)))\n  ys \\<noteq> zs", "obtain a1 b1 a2 b2 where ab:\n      \"(a1, b1) \\<in> set (snd (yun_factorization gcd p))\"\n      \"(a2, b2) \\<in> set (snd (yun_factorization gcd p))\"\n      \"ys = roots_of_complex_main a1\" \"zs = roots_of_complex_main a2\""], ["proof (prove)\nusing this:\n  ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                 (snd (yun_factorization gcd p)))\n  zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                 (snd (yun_factorization gcd p)))\n  ys \\<noteq> zs\n\ngoal (1 subgoal):\n 1. (\\<And>a1 b1 a2 b2.\n        \\<lbrakk>(a1, b1) \\<in> set (snd (yun_factorization gcd p));\n         (a2, b2) \\<in> set (snd (yun_factorization gcd p));\n         ys = roots_of_complex_main a1;\n         zs = roots_of_complex_main a2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (a1, b1) \\<in> set (snd (yun_factorization gcd p))\n  (a2, b2) \\<in> set (snd (yun_factorization gcd p))\n  ys = roots_of_complex_main a1\n  zs = roots_of_complex_main a2\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "with 3"], ["proof (chain)\npicking this:\n  ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                 (snd (yun_factorization gcd p)))\n  zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                 (snd (yun_factorization gcd p)))\n  ys \\<noteq> zs\n  (a1, b1) \\<in> set (snd (yun_factorization gcd p))\n  (a2, b2) \\<in> set (snd (yun_factorization gcd p))\n  ys = roots_of_complex_main a1\n  zs = roots_of_complex_main a2", "have neq: \"(a1,b1) \\<noteq> (a2,b2)\""], ["proof (prove)\nusing this:\n  ys \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                 (snd (yun_factorization gcd p)))\n  zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                 (snd (yun_factorization gcd p)))\n  ys \\<noteq> zs\n  (a1, b1) \\<in> set (snd (yun_factorization gcd p))\n  (a2, b2) \\<in> set (snd (yun_factorization gcd p))\n  ys = roots_of_complex_main a1\n  zs = roots_of_complex_main a2\n\ngoal (1 subgoal):\n 1. (a1, b1) \\<noteq> (a2, b2)", "by auto"], ["proof (state)\nthis:\n  (a1, b1) \\<noteq> (a2, b2)\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "from ab(1,2)[THEN square_free_factorizationD(2)[OF sqf]]"], ["proof (chain)\npicking this:\n  square_free a1 \\<and> degree a1 \\<noteq> 0\n  square_free a2 \\<and> degree a2 \\<noteq> 0", "have [simp]: \"a1 \\<noteq> 0\" \"a2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  square_free a1 \\<and> degree a1 \\<noteq> 0\n  square_free a2 \\<and> degree a2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a1 \\<noteq> 0 &&& a2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a1 \\<noteq> 0\n  a2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "from square_free_factorizationD(3)[OF sqf ab(1,2) neq]"], ["proof (chain)\npicking this:\n  algebraic_semidom_class.coprime a1 a2", "have \"coprime a1 a2\""], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime a1 a2\n\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime a1 a2", "by simp"], ["proof (state)\nthis:\n  comm_monoid_mult_class.coprime a1 a2\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "have \"set ys = {z. poly a1 z = 0}\" \"set zs = {z. poly a2 z = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys = {z. poly a1 z = 0} &&& set zs = {z. poly a2 z = 0}", "by (insert solvable ab(1,2), subst ab,\n          rule roots_of_complex_main; (auto) [])+"], ["proof (state)\nthis:\n  set ys = {z. poly a1 z = 0}\n  set zs = {z. poly a2 z = 0}\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (\\<lambda>x.\nroots_of_complex_main (fst x))\n                               (snd (yun_factorization gcd p)));\n        zs \\<in> set (map (\\<lambda>x. roots_of_complex_main (fst x))\n                       (snd (yun_factorization gcd p)));\n        ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "with coprime_imp_no_common_roots \\<open>coprime a1 a2\\<close>"], ["proof (chain)\npicking this:\n  algebraic_semidom_class.coprime ?p ?q \\<Longrightarrow>\n  \\<not> (poly ?p ?x = (0::?'a) \\<and> poly ?q ?x = (0::?'a))\n  comm_monoid_mult_class.coprime a1 a2\n  set ys = {z. poly a1 z = 0}\n  set zs = {z. poly a2 z = 0}", "show ?case"], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime ?p ?q \\<Longrightarrow>\n  \\<not> (poly ?p ?x = (0::?'a) \\<and> poly ?q ?x = (0::?'a))\n  comm_monoid_mult_class.coprime a1 a2\n  set ys = {z. poly a1 z = 0}\n  set zs = {z. poly a2 z = 0}\n\ngoal (1 subgoal):\n 1. set ys \\<inter> set zs = {}", "by auto"], ["proof (state)\nthis:\n  set ys \\<inter> set zs = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct\n   (concat\n     (map (\\<lambda>x. roots_of_complex_main (fst x))\n       (snd (yun_factorization gcd p))))\n\ngoal (1 subgoal):\n 1. distinct (map fst (snd fctrs))", "finally"], ["proof (chain)\npicking this:\n  distinct (map fst (snd fctrs))", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (map fst (snd fctrs))\n\ngoal (1 subgoal):\n 1. distinct (map fst (snd fctrs))", "."], ["proof (state)\nthis:\n  distinct (map fst (snd fctrs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma factorize_complex_poly: assumes fp: \"factorize_complex_poly p = Some (c,qis)\"\n  shows \n  \"p = smult c (\\<Prod>(q, i)\\<leftarrow>qis. q ^ i)\" \n  \"(q,i) \\<in> set qis \\<Longrightarrow> irreducible q \\<and> i \\<noteq> 0 \\<and> monic q \\<and> degree q = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(q, i)\\<leftarrow>qis. q ^ i) &&&\n    ((q, i) \\<in> set qis \\<Longrightarrow>\n     irreducible q \\<and> i \\<noteq> 0 \\<and> monic q \\<and> degree q = 1)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. p = smult c (\\<Prod>(q, i)\\<leftarrow>qis. q ^ i)\n 2. (q, i) \\<in> set qis \\<Longrightarrow>\n    irreducible q \\<and> i \\<noteq> 0 \\<and> monic q \\<and> degree q = 1", "from fp[unfolded factorize_complex_poly_def]"], ["proof (chain)\npicking this:\n  map_option\n   (\\<lambda>(c, ris). (c, map (\\<lambda>(r, i). ([:- r, 1:], Suc i)) ris))\n   (factorize_complex_main p) =\n  Some (c, qis)", "obtain pis where fp: \"factorize_complex_main p = Some (c,pis)\"\n    and qis: \"qis = map (\\<lambda>(r, i). ([:- r, 1:], Suc i)) pis\""], ["proof (prove)\nusing this:\n  map_option\n   (\\<lambda>(c, ris). (c, map (\\<lambda>(r, i). ([:- r, 1:], Suc i)) ris))\n   (factorize_complex_main p) =\n  Some (c, qis)\n\ngoal (1 subgoal):\n 1. (\\<And>pis.\n        \\<lbrakk>factorize_complex_main p = Some (c, pis);\n         qis = map (\\<lambda>(r, i). ([:- r, 1:], Suc i)) pis\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  factorize_complex_main p = Some (c, pis)\n  qis = map (\\<lambda>(r, i). ([:- r, 1:], Suc i)) pis\n\ngoal (2 subgoals):\n 1. p = smult c (\\<Prod>(q, i)\\<leftarrow>qis. q ^ i)\n 2. (q, i) \\<in> set qis \\<Longrightarrow>\n    irreducible q \\<and> i \\<noteq> 0 \\<and> monic q \\<and> degree q = 1", "from factorize_complex_main[OF fp]"], ["proof (chain)\npicking this:\n  p = smult c (\\<Prod>(x, i)\\<leftarrow>pis. [:- x, 1:] ^ Suc i)", "have p: \"p = smult c (\\<Prod>(x, i)\\<leftarrow>pis. [:- x, 1:] ^ Suc i)\""], ["proof (prove)\nusing this:\n  p = smult c (\\<Prod>(x, i)\\<leftarrow>pis. [:- x, 1:] ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(x, i)\\<leftarrow>pis. [:- x, 1:] ^ Suc i)", "."], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(x, i)\\<leftarrow>pis. [:- x, 1:] ^ Suc i)\n\ngoal (2 subgoals):\n 1. p = smult c (\\<Prod>(q, i)\\<leftarrow>qis. q ^ i)\n 2. (q, i) \\<in> set qis \\<Longrightarrow>\n    irreducible q \\<and> i \\<noteq> 0 \\<and> monic q \\<and> degree q = 1", "show \"p = smult c (\\<Prod>(q, i)\\<leftarrow>qis. q ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(q, i)\\<leftarrow>qis. q ^ i)", "unfolding p qis"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult c (\\<Prod>(x, i)\\<leftarrow>pis. [:- x, 1:] ^ Suc i) =\n    smult c\n     (\\<Prod>(q,\n         i)\\<leftarrow>map (\\<lambda>(r, i). ([:- r, 1:], Suc i))\n                        pis. q ^ i)", "by (rule arg_cong[of _ _ \"\\<lambda> p. smult c (prod_list p)\"], auto)"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(q, i)\\<leftarrow>qis. q ^ i)\n\ngoal (1 subgoal):\n 1. (q, i) \\<in> set qis \\<Longrightarrow>\n    irreducible q \\<and> i \\<noteq> 0 \\<and> monic q \\<and> degree q = 1", "show \"(q,i) \\<in> set qis \\<Longrightarrow> irreducible q \\<and> i \\<noteq> 0 \\<and> monic q \\<and> degree q = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q, i) \\<in> set qis \\<Longrightarrow>\n    irreducible q \\<and> i \\<noteq> 0 \\<and> monic q \\<and> degree q = 1", "using linear_irreducible_field[of q]"], ["proof (prove)\nusing this:\n  degree q = 1 \\<Longrightarrow> irreducible q\n\ngoal (1 subgoal):\n 1. (q, i) \\<in> set qis \\<Longrightarrow>\n    irreducible q \\<and> i \\<noteq> 0 \\<and> monic q \\<and> degree q = 1", "unfolding qis"], ["proof (prove)\nusing this:\n  degree q = 1 \\<Longrightarrow> irreducible q\n\ngoal (1 subgoal):\n 1. (q, i)\n    \\<in> set (map (\\<lambda>(r, i). ([:- r, 1:], Suc i))\n                pis) \\<Longrightarrow>\n    irreducible q \\<and> i \\<noteq> 0 \\<and> monic q \\<and> degree q = 1", "by auto"], ["proof (state)\nthis:\n  (q, i) \\<in> set qis \\<Longrightarrow>\n  irreducible q \\<and> i \\<noteq> 0 \\<and> monic q \\<and> degree q = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}