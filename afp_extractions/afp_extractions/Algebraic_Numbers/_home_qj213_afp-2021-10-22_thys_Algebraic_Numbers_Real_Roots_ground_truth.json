{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers/Real_Roots.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers", "problem_names": ["lemma root_imp_deg_nonzero: assumes \"p \\<noteq> 0\" \"poly p x = 0\"\n  shows \"degree p \\<noteq> 0\"", "lemma cauchy_root_bound: fixes x :: \"'a :: real_normed_field\"\n  assumes x: \"poly p x = 0\" and p: \"p \\<noteq> 0\" \n  shows \"norm x \\<le> 1 + max_list_non_empty (map (\\<lambda> i. norm (coeff p i)) [0 ..< degree p]) \n    / norm (lead_coeff p)\" (is \"_ \\<le> _ + ?max / ?nlc\")", "lemma div_le_div_ceiling: \"x div y \\<le> div_ceiling x y\"", "lemma div_ceiling: assumes q: \"q \\<noteq> 0\"  \n  shows \"(of_int x :: 'a :: floor_ceiling) / of_int q \\<le> of_int (div_ceiling x q)\"", "lemma max_list_non_empty_map: assumes hom: \"\\<And> x y. max (f x) (f y) = f (max x y)\"  \n  shows \"xs \\<noteq> [] \\<Longrightarrow> max_list_non_empty (map f xs) = f (max_list_non_empty xs)\"", "lemma root_bound: assumes \"root_bound p = B\" and deg: \"degree p > 0\"\n  shows \"ipoly p (x :: real) = 0 \\<Longrightarrow> norm x \\<le> of_rat B\" \"B \\<ge> 0\"", "lemma roots_of_2_irr: assumes pc: \"poly_cond p\" and deg: \"degree p > 0\"\n  shows \"real_of_2 ` set (roots_of_2_irr p) = {x. ipoly p x = 0}\" (is ?one)\n    \"Ball (set (roots_of_2_irr p)) invariant_2\" (is ?two)\n    \"distinct (map real_of_2 (roots_of_2_irr p))\" (is ?three)", "lemma roots_of_2:\n  shows \"p \\<noteq> 0 \\<Longrightarrow> real_of_2 ` set (roots_of_2 p) = {x. ipoly p x = 0}\"\n    \"Ball (set (roots_of_2 p)) invariant_2\"\n    \"distinct (map real_of_2 (roots_of_2 p))\"", "lemma roots_of_3: \n  shows \"p \\<noteq> 0 \\<Longrightarrow> real_of_3 ` set (roots_of_3 p) = {x. ipoly p x = 0}\"\n    \"distinct (map real_of_3 (roots_of_3 p))\"", "lemma roots_of_real_alg: \n  \"p \\<noteq> 0 \\<Longrightarrow> real_of ` set (roots_of_real_alg p) = {x. ipoly p x = 0}\" \n  \"distinct (map real_of (roots_of_real_alg p))\"", "lemma real_alg_2_list_length[simp]: \"\\<not> real_alg_2_list_nil xs \\<Longrightarrow> real_alg_2_list_length (real_alg_2_list_tl xs) < real_alg_2_list_length xs\"", "lemma real_alg_2_list_convert: \"real_alg_2_list_convert xs = real_alg_2_list_convert_id xs\"", "lemma roots_of_3_code[code]: \"roots_of_3 p = roots_of_3_impl p\"", "lemma real_roots_of_int_poly: \"p \\<noteq> 0 \\<Longrightarrow> set (real_roots_of_int_poly p) = {x. ipoly p x = 0}\" \n  \"distinct (real_roots_of_int_poly p)\"", "lemma real_roots_of_rat_poly: \"p \\<noteq> 0 \\<Longrightarrow> set (real_roots_of_rat_poly p) = {x. rpoly p x = 0}\" \n  \"distinct (real_roots_of_rat_poly p)\"", "lemma roots_of_real_main: assumes p: \"p \\<noteq> 0\" and deg: \"degree p \\<le> 2 \\<or> set (coeffs p) \\<subseteq> \\<rat>\"\n  shows \"set (roots_of_real_main p) = {x. poly p x = 0}\" (is \"?l = ?r\")", "lemma roots_of_real_poly: assumes rt: \"roots_of_real_poly p = Some xs\"\n  shows \"set xs = {x. poly p x = 0}\""], "translations": [["", "lemma root_imp_deg_nonzero: assumes \"p \\<noteq> 0\" \"poly p x = 0\"\n  shows \"degree p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow> False", "assume \"degree p = 0\""], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow> False", "from degree0_coeffs[OF this] assms"], ["proof (chain)\npicking this:\n  \\<exists>a. p = [:a:]\n  p \\<noteq> 0\n  poly p x = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  \\<exists>a. p = [:a:]\n  p \\<noteq> 0\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cauchy_root_bound: fixes x :: \"'a :: real_normed_field\"\n  assumes x: \"poly p x = 0\" and p: \"p \\<noteq> 0\" \n  shows \"norm x \\<le> 1 + max_list_non_empty (map (\\<lambda> i. norm (coeff p i)) [0 ..< degree p]) \n    / norm (lead_coeff p)\" (is \"_ \\<le> _ + ?max / ?nlc\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "let ?n = \"degree p\""], ["proof (state)\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "let ?p = \"coeff p\""], ["proof (state)\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "let ?lc = \"lead_coeff p\""], ["proof (state)\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "define ml where \"ml = ?max / ?nlc\""], ["proof (state)\nthis:\n  ml =\n  max_list_non_empty (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n  norm (lead_coeff p)\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "from p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have lc: \"?lc \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff p \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  lead_coeff p \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "hence nlc: \"norm ?lc > 0\""], ["proof (prove)\nusing this:\n  lead_coeff p \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < norm (lead_coeff p)", "by auto"], ["proof (state)\nthis:\n  0 < norm (lead_coeff p)\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "from root_imp_deg_nonzero[OF p x]"], ["proof (chain)\npicking this:\n  degree p \\<noteq> 0", "have *: \"0 \\<in> set [0 ..< degree p]\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<in> set [0..<degree p]", "by auto"], ["proof (state)\nthis:\n  0 \\<in> set [0..<degree p]\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "have \"0 \\<le> norm (?p 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> norm (coeff p 0)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> norm (coeff p 0)\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "also"], ["proof (state)\nthis:\n  0 \\<le> norm (coeff p 0)\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "have \"\\<dots> \\<le> ?max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (coeff p 0)\n    \\<le> max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p])", "by (rule max_list_non_empty, insert *, auto)"], ["proof (state)\nthis:\n  norm (coeff p 0)\n  \\<le> max_list_non_empty\n         (map (\\<lambda>i. norm (coeff p i)) [0..<degree p])\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p])", "have max0: \"?max \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p])\n\ngoal (1 subgoal):\n 1. 0 \\<le> max_list_non_empty\n             (map (\\<lambda>i. norm (coeff p i)) [0..<degree p])", "."], ["proof (state)\nthis:\n  0 \\<le> max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p])\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "with nlc"], ["proof (chain)\npicking this:\n  0 < norm (lead_coeff p)\n  0 \\<le> max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p])", "have ml0: \"ml \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 < norm (lead_coeff p)\n  0 \\<le> max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p])\n\ngoal (1 subgoal):\n 1. 0 \\<le> ml", "unfolding ml_def"], ["proof (prove)\nusing this:\n  0 < norm (lead_coeff p)\n  0 \\<le> max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p])\n\ngoal (1 subgoal):\n 1. 0 \\<le> max_list_non_empty\n             (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n            norm (lead_coeff p)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> ml\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "hence easy: \"norm x \\<le> 1 \\<Longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  0 \\<le> ml\n\ngoal (1 subgoal):\n 1. norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "unfolding ml_def[symmetric]"], ["proof (prove)\nusing this:\n  0 \\<le> ml\n\ngoal (1 subgoal):\n 1. norm x \\<le> 1 \\<Longrightarrow> norm x \\<le> 1 + ml", "by auto"], ["proof (state)\nthis:\n  norm x \\<le> 1 \\<Longrightarrow>\n  norm x\n  \\<le> 1 +\n        max_list_non_empty\n         (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n        norm (lead_coeff p)\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "proof (cases \"norm x \\<le> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)\n 2. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "case True"], ["proof (state)\nthis:\n  norm x \\<le> 1\n\ngoal (2 subgoals):\n 1. norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)\n 2. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  norm x \\<le> 1\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "using easy"], ["proof (prove)\nusing this:\n  norm x \\<le> 1\n  norm x \\<le> 1 \\<Longrightarrow>\n  norm x\n  \\<le> 1 +\n        max_list_non_empty\n         (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n        norm (lead_coeff p)\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "by auto"], ["proof (state)\nthis:\n  norm x\n  \\<le> 1 +\n        max_list_non_empty\n         (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n        norm (lead_coeff p)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "case False"], ["proof (state)\nthis:\n  \\<not> norm x \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "hence nx: \"norm x > 1\""], ["proof (prove)\nusing this:\n  \\<not> norm x \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 < norm x", "by simp"], ["proof (state)\nthis:\n  1 < norm x\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "hence x0: \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  1 < norm x\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "hence xn0: \"0 < norm x ^ ?n\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < norm x ^ degree p", "by auto"], ["proof (state)\nthis:\n  0 < norm x ^ degree p\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "from x[unfolded poly_altdef]"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<le>degree p. coeff p i * x ^ i) = (0::'a)", "have \"x ^ ?n * ?lc = x ^ ?n * ?lc - (\\<Sum>i\\<le>?n. x ^ i * ?p i)\""], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>degree p. coeff p i * x ^ i) = (0::'a)\n\ngoal (1 subgoal):\n 1. x ^ degree p * lead_coeff p =\n    x ^ degree p * lead_coeff p - (\\<Sum>i\\<le>degree p. x ^ i * coeff p i)", "unfolding poly_altdef"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<le>degree p. coeff p i * x ^ i) = (0::'a)\n\ngoal (1 subgoal):\n 1. x ^ degree p * lead_coeff p =\n    x ^ degree p * lead_coeff p - (\\<Sum>i\\<le>degree p. x ^ i * coeff p i)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  x ^ degree p * lead_coeff p =\n  x ^ degree p * lead_coeff p - (\\<Sum>i\\<le>degree p. x ^ i * coeff p i)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "also"], ["proof (state)\nthis:\n  x ^ degree p * lead_coeff p =\n  x ^ degree p * lead_coeff p - (\\<Sum>i\\<le>degree p. x ^ i * coeff p i)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "have \"(\\<Sum>i\\<le>?n. x ^ i * ?p i) = x ^ ?n * ?lc + (\\<Sum>i < ?n. x ^ i * ?p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p. x ^ i * coeff p i) =\n    x ^ degree p * lead_coeff p + (\\<Sum>i<degree p. x ^ i * coeff p i)", "by (subst sum.remove[of _ ?n], auto intro: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>degree p. x ^ i * coeff p i) =\n  x ^ degree p * lead_coeff p + (\\<Sum>i<degree p. x ^ i * coeff p i)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "finally"], ["proof (chain)\npicking this:\n  x ^ degree p * lead_coeff p =\n  x ^ degree p * lead_coeff p -\n  (x ^ degree p * lead_coeff p + (\\<Sum>i<degree p. x ^ i * coeff p i))", "have \"x ^ ?n * ?lc = - (\\<Sum>i < ?n. x ^ i * ?p i)\""], ["proof (prove)\nusing this:\n  x ^ degree p * lead_coeff p =\n  x ^ degree p * lead_coeff p -\n  (x ^ degree p * lead_coeff p + (\\<Sum>i<degree p. x ^ i * coeff p i))\n\ngoal (1 subgoal):\n 1. x ^ degree p * lead_coeff p = - (\\<Sum>i<degree p. x ^ i * coeff p i)", "by simp"], ["proof (state)\nthis:\n  x ^ degree p * lead_coeff p = - (\\<Sum>i<degree p. x ^ i * coeff p i)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "with lc"], ["proof (chain)\npicking this:\n  lead_coeff p \\<noteq> (0::'a)\n  x ^ degree p * lead_coeff p = - (\\<Sum>i<degree p. x ^ i * coeff p i)", "have \"x ^ ?n = - (\\<Sum>i < ?n. x ^ i * ?p i) / ?lc\""], ["proof (prove)\nusing this:\n  lead_coeff p \\<noteq> (0::'a)\n  x ^ degree p * lead_coeff p = - (\\<Sum>i<degree p. x ^ i * coeff p i)\n\ngoal (1 subgoal):\n 1. x ^ degree p = - (\\<Sum>i<degree p. x ^ i * coeff p i) / lead_coeff p", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  x ^ degree p = - (\\<Sum>i<degree p. x ^ i * coeff p i) / lead_coeff p\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "from arg_cong[OF this, of norm]"], ["proof (chain)\npicking this:\n  norm (x ^ degree p) =\n  norm (- (\\<Sum>i<degree p. x ^ i * coeff p i) / lead_coeff p)", "have \"norm x ^ ?n = norm ((\\<Sum>i < ?n. x ^ i * ?p i) / ?lc)\""], ["proof (prove)\nusing this:\n  norm (x ^ degree p) =\n  norm (- (\\<Sum>i<degree p. x ^ i * coeff p i) / lead_coeff p)\n\ngoal (1 subgoal):\n 1. norm x ^ degree p =\n    norm ((\\<Sum>i<degree p. x ^ i * coeff p i) / lead_coeff p)", "unfolding norm_power"], ["proof (prove)\nusing this:\n  norm x ^ degree p =\n  norm (- (\\<Sum>i<degree p. x ^ i * coeff p i) / lead_coeff p)\n\ngoal (1 subgoal):\n 1. norm x ^ degree p =\n    norm ((\\<Sum>i<degree p. x ^ i * coeff p i) / lead_coeff p)", "by simp"], ["proof (state)\nthis:\n  norm x ^ degree p =\n  norm ((\\<Sum>i<degree p. x ^ i * coeff p i) / lead_coeff p)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "also"], ["proof (state)\nthis:\n  norm x ^ degree p =\n  norm ((\\<Sum>i<degree p. x ^ i * coeff p i) / lead_coeff p)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "have \"(\\<Sum>i < ?n. x ^ i * ?p i) / ?lc = (\\<Sum>i < ?n. x ^ i * ?p i / ?lc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p. x ^ i * coeff p i) / lead_coeff p =\n    (\\<Sum>i<degree p. x ^ i * coeff p i / lead_coeff p)", "by (rule sum_divide_distrib)"], ["proof (state)\nthis:\n  (\\<Sum>i<degree p. x ^ i * coeff p i) / lead_coeff p =\n  (\\<Sum>i<degree p. x ^ i * coeff p i / lead_coeff p)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree p. x ^ i * coeff p i) / lead_coeff p =\n  (\\<Sum>i<degree p. x ^ i * coeff p i / lead_coeff p)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "have \"norm \\<dots> \\<le> (\\<Sum>i < ?n. norm (x ^ i * (?p i / ?lc)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (\\<Sum>i<degree p. x ^ i * coeff p i / lead_coeff p)\n    \\<le> (\\<Sum>i<degree p. norm (x ^ i * (coeff p i / lead_coeff p)))", "by (simp add: field_simps, rule norm_sum)"], ["proof (state)\nthis:\n  norm (\\<Sum>i<degree p. x ^ i * coeff p i / lead_coeff p)\n  \\<le> (\\<Sum>i<degree p. norm (x ^ i * (coeff p i / lead_coeff p)))\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "also"], ["proof (state)\nthis:\n  norm (\\<Sum>i<degree p. x ^ i * coeff p i / lead_coeff p)\n  \\<le> (\\<Sum>i<degree p. norm (x ^ i * (coeff p i / lead_coeff p)))\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "have \"\\<dots> = (\\<Sum>i < ?n. norm x ^ i * norm (?p i / ?lc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p. norm (x ^ i * (coeff p i / lead_coeff p))) =\n    (\\<Sum>i<degree p. norm x ^ i * norm (coeff p i / lead_coeff p))", "unfolding norm_mult norm_power"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p. norm x ^ i * norm (coeff p i / lead_coeff p)) =\n    (\\<Sum>i<degree p. norm x ^ i * norm (coeff p i / lead_coeff p))", ".."], ["proof (state)\nthis:\n  (\\<Sum>i<degree p. norm (x ^ i * (coeff p i / lead_coeff p))) =\n  (\\<Sum>i<degree p. norm x ^ i * norm (coeff p i / lead_coeff p))\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree p. norm (x ^ i * (coeff p i / lead_coeff p))) =\n  (\\<Sum>i<degree p. norm x ^ i * norm (coeff p i / lead_coeff p))\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "have \"\\<dots> \\<le> (\\<Sum>i < ?n. norm x ^ i * ml)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p. norm x ^ i * norm (coeff p i / lead_coeff p))\n    \\<le> (\\<Sum>i<degree p. norm x ^ i * ml)", "proof (rule sum_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<degree p} \\<Longrightarrow>\n       norm x ^ i * norm (coeff p i / lead_coeff p) \\<le> norm x ^ i * ml", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<degree p} \\<Longrightarrow>\n       norm x ^ i * norm (coeff p i / lead_coeff p) \\<le> norm x ^ i * ml", "assume \"i \\<in> {..<?n}\""], ["proof (state)\nthis:\n  i \\<in> {..<degree p}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<degree p} \\<Longrightarrow>\n       norm x ^ i * norm (coeff p i / lead_coeff p) \\<le> norm x ^ i * ml", "hence i: \"i < ?n\""], ["proof (prove)\nusing this:\n  i \\<in> {..<degree p}\n\ngoal (1 subgoal):\n 1. i < degree p", "by simp"], ["proof (state)\nthis:\n  i < degree p\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<degree p} \\<Longrightarrow>\n       norm x ^ i * norm (coeff p i / lead_coeff p) \\<le> norm x ^ i * ml", "show \"norm x ^ i * norm (?p i / ?lc) \\<le> norm x ^ i * ml\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x ^ i * norm (coeff p i / lead_coeff p) \\<le> norm x ^ i * ml", "proof (rule mult_left_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. norm (coeff p i / lead_coeff p) \\<le> ml\n 2. 0 \\<le> norm x ^ i", "show \"0 \\<le> norm x ^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> norm x ^ i", "using nx"], ["proof (prove)\nusing this:\n  1 < norm x\n\ngoal (1 subgoal):\n 1. 0 \\<le> norm x ^ i", "by auto"], ["proof (state)\nthis:\n  0 \\<le> norm x ^ i\n\ngoal (1 subgoal):\n 1. norm (coeff p i / lead_coeff p) \\<le> ml", "show \"norm (?p i / ?lc) \\<le> ml\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (coeff p i / lead_coeff p) \\<le> ml", "unfolding norm_divide ml_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (coeff p i) / norm (lead_coeff p)\n    \\<le> max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "by (rule divide_right_mono[OF max_list_non_empty], insert nlc i, auto)"], ["proof (state)\nthis:\n  norm (coeff p i / lead_coeff p) \\<le> ml\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm x ^ i * norm (coeff p i / lead_coeff p) \\<le> norm x ^ i * ml\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i<degree p. norm x ^ i * norm (coeff p i / lead_coeff p))\n  \\<le> (\\<Sum>i<degree p. norm x ^ i * ml)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree p. norm x ^ i * norm (coeff p i / lead_coeff p))\n  \\<le> (\\<Sum>i<degree p. norm x ^ i * ml)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "have \"\\<dots> = ml * (\\<Sum>i < ?n. norm x ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<degree p. norm x ^ i * ml) =\n    ml * sum ((^) (norm x)) {..<degree p}", "unfolding sum_distrib_right[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) (norm x)) {..<degree p} * ml =\n    ml * sum ((^) (norm x)) {..<degree p}", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<degree p. norm x ^ i * ml) =\n  ml * sum ((^) (norm x)) {..<degree p}\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<degree p. norm x ^ i * ml) =\n  ml * sum ((^) (norm x)) {..<degree p}\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "have \"(\\<Sum>i < ?n. norm x ^ i) = (norm x ^ ?n - 1) / (norm x - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) (norm x)) {..<degree p} =\n    (norm x ^ degree p - 1) / (norm x - 1)", "by (rule geometric_sum, insert nx, auto)"], ["proof (state)\nthis:\n  sum ((^) (norm x)) {..<degree p} = (norm x ^ degree p - 1) / (norm x - 1)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "finally"], ["proof (chain)\npicking this:\n  norm x ^ degree p \\<le> ml * ((norm x ^ degree p - 1) / (norm x - 1))", "have \"norm x ^ ?n \\<le> ml * (norm x ^ ?n - 1) / (norm x - 1)\""], ["proof (prove)\nusing this:\n  norm x ^ degree p \\<le> ml * ((norm x ^ degree p - 1) / (norm x - 1))\n\ngoal (1 subgoal):\n 1. norm x ^ degree p \\<le> ml * (norm x ^ degree p - 1) / (norm x - 1)", "by simp"], ["proof (state)\nthis:\n  norm x ^ degree p \\<le> ml * (norm x ^ degree p - 1) / (norm x - 1)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "from mult_left_mono[OF this, of \"norm x - 1\"]"], ["proof (chain)\npicking this:\n  0 \\<le> norm x - 1 \\<Longrightarrow>\n  (norm x - 1) * norm x ^ degree p\n  \\<le> (norm x - 1) * (ml * (norm x ^ degree p - 1) / (norm x - 1))", "have \"(norm x - 1) * (norm x ^ ?n) \\<le> ml * (norm x ^ ?n - 1)\""], ["proof (prove)\nusing this:\n  0 \\<le> norm x - 1 \\<Longrightarrow>\n  (norm x - 1) * norm x ^ degree p\n  \\<le> (norm x - 1) * (ml * (norm x ^ degree p - 1) / (norm x - 1))\n\ngoal (1 subgoal):\n 1. (norm x - 1) * norm x ^ degree p \\<le> ml * (norm x ^ degree p - 1)", "using nx"], ["proof (prove)\nusing this:\n  0 \\<le> norm x - 1 \\<Longrightarrow>\n  (norm x - 1) * norm x ^ degree p\n  \\<le> (norm x - 1) * (ml * (norm x ^ degree p - 1) / (norm x - 1))\n  1 < norm x\n\ngoal (1 subgoal):\n 1. (norm x - 1) * norm x ^ degree p \\<le> ml * (norm x ^ degree p - 1)", "by auto"], ["proof (state)\nthis:\n  (norm x - 1) * norm x ^ degree p \\<le> ml * (norm x ^ degree p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "also"], ["proof (state)\nthis:\n  (norm x - 1) * norm x ^ degree p \\<le> ml * (norm x ^ degree p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "have \"\\<dots> = (ml * (1 - 1 / (norm x ^ ?n))) * norm x ^ ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ml * (norm x ^ degree p - 1) =\n    ml * (1 - 1 / norm x ^ degree p) * norm x ^ degree p", "using nx False x0"], ["proof (prove)\nusing this:\n  1 < norm x\n  \\<not> norm x \\<le> 1\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. ml * (norm x ^ degree p - 1) =\n    ml * (1 - 1 / norm x ^ degree p) * norm x ^ degree p", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  ml * (norm x ^ degree p - 1) =\n  ml * (1 - 1 / norm x ^ degree p) * norm x ^ degree p\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "finally"], ["proof (chain)\npicking this:\n  (norm x - 1) * norm x ^ degree p\n  \\<le> ml * (1 - 1 / norm x ^ degree p) * norm x ^ degree p", "have \"(norm x - 1) * (norm x ^ ?n) \\<le> (ml * (1 - 1 / (norm x ^ ?n))) * norm x ^ ?n\""], ["proof (prove)\nusing this:\n  (norm x - 1) * norm x ^ degree p\n  \\<le> ml * (1 - 1 / norm x ^ degree p) * norm x ^ degree p\n\ngoal (1 subgoal):\n 1. (norm x - 1) * norm x ^ degree p\n    \\<le> ml * (1 - 1 / norm x ^ degree p) * norm x ^ degree p", "."], ["proof (state)\nthis:\n  (norm x - 1) * norm x ^ degree p\n  \\<le> ml * (1 - 1 / norm x ^ degree p) * norm x ^ degree p\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "from mult_right_le_imp_le[OF this xn0]"], ["proof (chain)\npicking this:\n  norm x - 1 \\<le> ml * (1 - 1 / norm x ^ degree p)", "have \"norm x - 1 \\<le> ml * (1 - 1 / (norm x ^ ?n))\""], ["proof (prove)\nusing this:\n  norm x - 1 \\<le> ml * (1 - 1 / norm x ^ degree p)\n\ngoal (1 subgoal):\n 1. norm x - 1 \\<le> ml * (1 - 1 / norm x ^ degree p)", "by simp"], ["proof (state)\nthis:\n  norm x - 1 \\<le> ml * (1 - 1 / norm x ^ degree p)\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "hence \"norm x \\<le> 1 + ml - ml / (norm x ^ ?n)\""], ["proof (prove)\nusing this:\n  norm x - 1 \\<le> ml * (1 - 1 / norm x ^ degree p)\n\ngoal (1 subgoal):\n 1. norm x \\<le> 1 + ml - ml / norm x ^ degree p", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  norm x \\<le> 1 + ml - ml / norm x ^ degree p\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "also"], ["proof (state)\nthis:\n  norm x \\<le> 1 + ml - ml / norm x ^ degree p\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "have \"\\<dots> \\<le> 1 + ml\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + ml - ml / norm x ^ degree p \\<le> 1 + ml", "using ml0 xn0"], ["proof (prove)\nusing this:\n  0 \\<le> ml\n  0 < norm x ^ degree p\n\ngoal (1 subgoal):\n 1. 1 + ml - ml / norm x ^ degree p \\<le> 1 + ml", "by auto"], ["proof (state)\nthis:\n  1 + ml - ml / norm x ^ degree p \\<le> 1 + ml\n\ngoal (1 subgoal):\n 1. \\<not> norm x \\<le> 1 \\<Longrightarrow>\n    norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "finally"], ["proof (chain)\npicking this:\n  norm x \\<le> 1 + ml", "show ?thesis"], ["proof (prove)\nusing this:\n  norm x \\<le> 1 + ml\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "unfolding ml_def"], ["proof (prove)\nusing this:\n  norm x\n  \\<le> 1 +\n        max_list_non_empty\n         (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n        norm (lead_coeff p)\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n          norm (lead_coeff p)", "."], ["proof (state)\nthis:\n  norm x\n  \\<le> 1 +\n        max_list_non_empty\n         (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n        norm (lead_coeff p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm x\n  \\<le> 1 +\n        max_list_non_empty\n         (map (\\<lambda>i. norm (coeff p i)) [0..<degree p]) /\n        norm (lead_coeff p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma div_le_div_ceiling: \"x div y \\<le> div_ceiling x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y \\<le> div_ceiling x y", "unfolding div_ceiling_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x div y \\<le> (if x div y * y = x then x div y else x div y + 1)", "by auto"], ["", "lemma div_ceiling: assumes q: \"q \\<noteq> 0\"  \n  shows \"(of_int x :: 'a :: floor_ceiling) / of_int q \\<le> of_int (div_ceiling x q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int x / of_int q \\<le> of_int (div_ceiling x q)", "proof (cases \"q dvd x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)\n 2. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "case True"], ["proof (state)\nthis:\n  q dvd x\n\ngoal (2 subgoals):\n 1. q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)\n 2. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "then"], ["proof (chain)\npicking this:\n  q dvd x", "obtain k where xqk: \"x = q * k\""], ["proof (prove)\nusing this:\n  q dvd x\n\ngoal (1 subgoal):\n 1. (\\<And>k. x = q * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<exists>k. x = q * k\n\ngoal (1 subgoal):\n 1. (\\<And>k. x = q * k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x = q * k\n\ngoal (2 subgoals):\n 1. q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)\n 2. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "hence id: \"div_ceiling x q = k\""], ["proof (prove)\nusing this:\n  x = q * k\n\ngoal (1 subgoal):\n 1. div_ceiling x q = k", "unfolding div_ceiling_def Let_def"], ["proof (prove)\nusing this:\n  x = q * k\n\ngoal (1 subgoal):\n 1. (if x div q * q = x then x div q else x div q + 1) = k", "using q"], ["proof (prove)\nusing this:\n  x = q * k\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if x div q * q = x then x div q else x div q + 1) = k", "by auto"], ["proof (state)\nthis:\n  div_ceiling x q = k\n\ngoal (2 subgoals):\n 1. q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)\n 2. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int x / of_int q \\<le> of_int (div_ceiling x q)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int x / of_int q \\<le> of_int k", "unfolding xqk"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (q * k) / of_int q \\<le> of_int k", "using q"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int (q * k) / of_int q \\<le> of_int k", "by simp"], ["proof (state)\nthis:\n  of_int x / of_int q \\<le> of_int (div_ceiling x q)\n\ngoal (1 subgoal):\n 1. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "case False"], ["proof (state)\nthis:\n  \\<not> q dvd x\n\ngoal (1 subgoal):\n 1. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "{"], ["proof (state)\nthis:\n  \\<not> q dvd x\n\ngoal (1 subgoal):\n 1. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "assume \"x div q * q = x\""], ["proof (state)\nthis:\n  x div q * q = x\n\ngoal (1 subgoal):\n 1. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "hence \"x = q * (x div q)\""], ["proof (prove)\nusing this:\n  x div q * q = x\n\ngoal (1 subgoal):\n 1. x = q * (x div q)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  x = q * (x div q)\n\ngoal (1 subgoal):\n 1. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "hence \"q dvd x\""], ["proof (prove)\nusing this:\n  x = q * (x div q)\n\ngoal (1 subgoal):\n 1. q dvd x", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  x = q * (x div q)\n\ngoal (1 subgoal):\n 1. \\<exists>k. x = q * k", "by auto"], ["proof (state)\nthis:\n  q dvd x\n\ngoal (1 subgoal):\n 1. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "with False"], ["proof (chain)\npicking this:\n  \\<not> q dvd x\n  q dvd x", "have False"], ["proof (prove)\nusing this:\n  \\<not> q dvd x\n  q dvd x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "}"], ["proof (state)\nthis:\n  x div q * q = x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "hence id: \"div_ceiling x q = x div q + 1\""], ["proof (prove)\nusing this:\n  x div q * q = x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. div_ceiling x q = x div q + 1", "unfolding div_ceiling_def Let_def"], ["proof (prove)\nusing this:\n  x div q * q = x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (if x div q * q = x then x div q else x div q + 1) = x div q + 1", "using q"], ["proof (prove)\nusing this:\n  x div q * q = x \\<Longrightarrow> False\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if x div q * q = x then x div q else x div q + 1) = x div q + 1", "by auto"], ["proof (state)\nthis:\n  div_ceiling x q = x div q + 1\n\ngoal (1 subgoal):\n 1. \\<not> q dvd x \\<Longrightarrow>\n    of_int x / of_int q \\<le> of_int (div_ceiling x q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int x / of_int q \\<le> of_int (div_ceiling x q)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int x / of_int q \\<le> of_int (x div q + 1)", "by (metis floor_divide_of_int_eq le_less add1_zle_eq floor_less_iff)"], ["proof (state)\nthis:\n  of_int x / of_int q \\<le> of_int (div_ceiling x q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_list_non_empty_map: assumes hom: \"\\<And> x y. max (f x) (f y) = f (max x y)\"  \n  shows \"xs \\<noteq> [] \\<Longrightarrow> max_list_non_empty (map f xs) = f (max_list_non_empty xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    max_list_non_empty (map f xs) = f (max_list_non_empty xs)", "by (induct xs rule: max_list_non_empty.induct, auto simp: hom)"], ["", "lemma root_bound: assumes \"root_bound p = B\" and deg: \"degree p > 0\"\n  shows \"ipoly p (x :: real) = 0 \\<Longrightarrow> norm x \\<le> of_rat B\" \"B \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n     norm x \\<le> real_of_rat B) &&&\n    0 \\<le> B", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "let ?r = real_of_rat"], ["proof (state)\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "let ?i = real_of_int"], ["proof (state)\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "let ?p = \"real_of_int_poly p\""], ["proof (state)\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "define n where \"n = degree p\""], ["proof (state)\nthis:\n  n = degree p\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "let ?lc = \"coeff p n\""], ["proof (state)\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "let ?list = \"map (\\<lambda>i. abs (coeff p i)) [0..<n]\""], ["proof (state)\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "let ?list' = \"(map (\\<lambda>i. ?i (abs ((coeff p i)))) [0..<n])\""], ["proof (state)\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "define m where \"m = max_list_non_empty ?list\""], ["proof (state)\nthis:\n  m = max_list_non_empty (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<n])\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "define m_up where \"m_up = 1 + div_ceiling m (abs ?lc)\""], ["proof (state)\nthis:\n  m_up = 1 + div_ceiling m \\<bar>coeff p n\\<bar>\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "define C where \"C = rat_of_int (2^(log_ceiling 2 m_up))\""], ["proof (state)\nthis:\n  C = rat_of_int (2 ^ log_ceiling 2 m_up)\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "from deg"], ["proof (chain)\npicking this:\n  0 < degree p", "have p0: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "from p0"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have alc0: \"abs ?lc \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>coeff p n\\<bar> \\<noteq> 0", "unfolding n_def"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>lead_coeff p\\<bar> \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<bar>coeff p n\\<bar> \\<noteq> 0\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "from deg"], ["proof (chain)\npicking this:\n  0 < degree p", "have mem: \"abs (coeff p 0) \\<in> set ?list\""], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. \\<bar>coeff p 0\\<bar>\n    \\<in> set (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<n])", "unfolding n_def"], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. \\<bar>coeff p 0\\<bar>\n    \\<in> set (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<degree p])", "by auto"], ["proof (state)\nthis:\n  \\<bar>coeff p 0\\<bar>\n  \\<in> set (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<n])\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "from max_list_non_empty[OF this, folded m_def]"], ["proof (chain)\npicking this:\n  \\<bar>coeff p 0\\<bar> \\<le> m", "have m0: \"m \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<bar>coeff p 0\\<bar> \\<le> m\n\ngoal (1 subgoal):\n 1. 0 \\<le> m", "by auto"], ["proof (state)\nthis:\n  0 \\<le> m\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "have \"div_ceiling m (abs ?lc) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> div_ceiling m \\<bar>coeff p n\\<bar>", "by (rule order_trans[OF _ div_le_div_ceiling[of m \"abs ?lc\"]], subst\n    pos_imp_zdiv_nonneg_iff, insert p0 m0, auto simp: n_def)"], ["proof (state)\nthis:\n  0 \\<le> div_ceiling m \\<bar>coeff p n\\<bar>\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "hence mup: \"m_up \\<ge> 1\""], ["proof (prove)\nusing this:\n  0 \\<le> div_ceiling m \\<bar>coeff p n\\<bar>\n\ngoal (1 subgoal):\n 1. 1 \\<le> m_up", "unfolding m_up_def"], ["proof (prove)\nusing this:\n  0 \\<le> div_ceiling m \\<bar>coeff p n\\<bar>\n\ngoal (1 subgoal):\n 1. 1 \\<le> 1 + div_ceiling m \\<bar>coeff p n\\<bar>", "by auto"], ["proof (state)\nthis:\n  1 \\<le> m_up\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "have \"m_up \\<le> 2 ^ (log_ceiling 2 m_up)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m_up \\<le> 2 ^ log_ceiling 2 m_up", "using  mup log_ceiling_sound(1)"], ["proof (prove)\nusing this:\n  1 \\<le> m_up\n  \\<lbrakk>1 < ?b; 0 < ?x; log_ceiling ?b ?x = ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?b ^ ?y\n\ngoal (1 subgoal):\n 1. m_up \\<le> 2 ^ log_ceiling 2 m_up", "by auto"], ["proof (state)\nthis:\n  m_up \\<le> 2 ^ log_ceiling 2 m_up\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "hence Cmup: \"C \\<ge> of_int m_up\""], ["proof (prove)\nusing this:\n  m_up \\<le> 2 ^ log_ceiling 2 m_up\n\ngoal (1 subgoal):\n 1. rat_of_int m_up \\<le> C", "unfolding C_def"], ["proof (prove)\nusing this:\n  m_up \\<le> 2 ^ log_ceiling 2 m_up\n\ngoal (1 subgoal):\n 1. rat_of_int m_up \\<le> rat_of_int (2 ^ log_ceiling 2 m_up)", "by linarith"], ["proof (state)\nthis:\n  rat_of_int m_up \\<le> C\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "with mup"], ["proof (chain)\npicking this:\n  1 \\<le> m_up\n  rat_of_int m_up \\<le> C", "have C: \"C \\<ge> 1\""], ["proof (prove)\nusing this:\n  1 \\<le> m_up\n  rat_of_int m_up \\<le> C\n\ngoal (1 subgoal):\n 1. 1 \\<le> C", "by auto"], ["proof (state)\nthis:\n  1 \\<le> C\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "from assms(1)[unfolded root_bound_def Let_def]"], ["proof (chain)\npicking this:\n  rat_of_int\n   (2 ^\n    log_ceiling 2\n     (1 +\n      div_ceiling\n       (max_list_non_empty\n         (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<degree p]))\n       \\<bar>lead_coeff p\\<bar>)) =\n  B", "have B: \"C = of_rat B\""], ["proof (prove)\nusing this:\n  rat_of_int\n   (2 ^\n    log_ceiling 2\n     (1 +\n      div_ceiling\n       (max_list_non_empty\n         (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<degree p]))\n       \\<bar>lead_coeff p\\<bar>)) =\n  B\n\ngoal (1 subgoal):\n 1. C = of_rat B", "unfolding C_def m_up_def n_def m_def"], ["proof (prove)\nusing this:\n  rat_of_int\n   (2 ^\n    log_ceiling 2\n     (1 +\n      div_ceiling\n       (max_list_non_empty\n         (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<degree p]))\n       \\<bar>lead_coeff p\\<bar>)) =\n  B\n\ngoal (1 subgoal):\n 1. rat_of_int\n     (2 ^\n      log_ceiling 2\n       (1 +\n        div_ceiling\n         (max_list_non_empty\n           (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<degree p]))\n         \\<bar>lead_coeff p\\<bar>)) =\n    of_rat B", "by auto"], ["proof (state)\nthis:\n  C = of_rat B\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "note dc = div_le_div_ceiling[of m \"abs ?lc\"]"], ["proof (state)\nthis:\n  m div \\<bar>coeff p n\\<bar> \\<le> div_ceiling m \\<bar>coeff p n\\<bar>\n\ngoal (2 subgoals):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B\n 2. 0 \\<le> B", "with C"], ["proof (chain)\npicking this:\n  1 \\<le> C\n  m div \\<bar>coeff p n\\<bar> \\<le> div_ceiling m \\<bar>coeff p n\\<bar>", "show \"B \\<ge> 0\""], ["proof (prove)\nusing this:\n  1 \\<le> C\n  m div \\<bar>coeff p n\\<bar> \\<le> div_ceiling m \\<bar>coeff p n\\<bar>\n\ngoal (1 subgoal):\n 1. 0 \\<le> B", "unfolding B"], ["proof (prove)\nusing this:\n  1 \\<le> of_rat B\n  m div \\<bar>coeff p n\\<bar> \\<le> div_ceiling m \\<bar>coeff p n\\<bar>\n\ngoal (1 subgoal):\n 1. 0 \\<le> B", "by auto"], ["proof (state)\nthis:\n  0 \\<le> B\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "assume \"ipoly p x = 0\""], ["proof (state)\nthis:\n  poly (real_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "hence rt: \"poly ?p x = 0\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0", "by simp"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "from root_imp_deg_nonzero[OF _ this] p0"], ["proof (chain)\npicking this:\n  real_of_int_poly p \\<noteq> 0 \\<Longrightarrow>\n  degree (real_of_int_poly p) \\<noteq> 0\n  p \\<noteq> 0", "have n0: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  real_of_int_poly p \\<noteq> 0 \\<Longrightarrow>\n  degree (real_of_int_poly p) \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "unfolding n_def"], ["proof (prove)\nusing this:\n  real_of_int_poly p \\<noteq> 0 \\<Longrightarrow>\n  degree (real_of_int_poly p) \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "from cauchy_root_bound[OF rt] p0"], ["proof (chain)\npicking this:\n  real_of_int_poly p \\<noteq> 0 \\<Longrightarrow>\n  norm x\n  \\<le> 1 +\n        max_list_non_empty\n         (map (\\<lambda>i. norm (coeff (real_of_int_poly p) i))\n           [0..<degree (real_of_int_poly p)]) /\n        norm (lead_coeff (real_of_int_poly p))\n  p \\<noteq> 0", "have \"norm x \\<le> 1 + max_list_non_empty ?list' / ?i (abs ?lc)\""], ["proof (prove)\nusing this:\n  real_of_int_poly p \\<noteq> 0 \\<Longrightarrow>\n  norm x\n  \\<le> 1 +\n        max_list_non_empty\n         (map (\\<lambda>i. norm (coeff (real_of_int_poly p) i))\n           [0..<degree (real_of_int_poly p)]) /\n        norm (lead_coeff (real_of_int_poly p))\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. norm x\n    \\<le> 1 +\n          max_list_non_empty\n           (map (\\<lambda>i. real_of_int \\<bar>coeff p i\\<bar>) [0..<n]) /\n          real_of_int \\<bar>coeff p n\\<bar>", "by (simp add: n_def)"], ["proof (state)\nthis:\n  norm x\n  \\<le> 1 +\n        max_list_non_empty\n         (map (\\<lambda>i. real_of_int \\<bar>coeff p i\\<bar>) [0..<n]) /\n        real_of_int \\<bar>coeff p n\\<bar>\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "also"], ["proof (state)\nthis:\n  norm x\n  \\<le> 1 +\n        max_list_non_empty\n         (map (\\<lambda>i. real_of_int \\<bar>coeff p i\\<bar>) [0..<n]) /\n        real_of_int \\<bar>coeff p n\\<bar>\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "have \"?list' = map ?i ?list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. real_of_int \\<bar>coeff p i\\<bar>) [0..<n] =\n    map real_of_int (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<n])", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>i. real_of_int \\<bar>coeff p i\\<bar>) [0..<n] =\n  map real_of_int (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<n])\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "also"], ["proof (state)\nthis:\n  map (\\<lambda>i. real_of_int \\<bar>coeff p i\\<bar>) [0..<n] =\n  map real_of_int (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<n])\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "have \"max_list_non_empty \\<dots> = ?i m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_list_non_empty\n     (map real_of_int (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<n])) =\n    real_of_int m", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_list_non_empty\n     (map real_of_int (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<n])) =\n    real_of_int\n     (max_list_non_empty (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<n]))", "by (rule max_list_non_empty_map, insert mem, auto)"], ["proof (state)\nthis:\n  max_list_non_empty\n   (map real_of_int (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<n])) =\n  real_of_int m\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "also"], ["proof (state)\nthis:\n  max_list_non_empty\n   (map real_of_int (map (\\<lambda>i. \\<bar>coeff p i\\<bar>) [0..<n])) =\n  real_of_int m\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "have \"1 + m / ?i (abs ?lc) \\<le> ?i m_up\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + real_of_int m / real_of_int \\<bar>coeff p n\\<bar>\n    \\<le> real_of_int m_up", "unfolding m_up_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + real_of_int m / real_of_int \\<bar>coeff p n\\<bar>\n    \\<le> real_of_int (1 + div_ceiling m \\<bar>coeff p n\\<bar>)", "using div_ceiling[OF alc0, of m]"], ["proof (prove)\nusing this:\n  of_int m / of_int \\<bar>coeff p n\\<bar>\n  \\<le> of_int (div_ceiling m \\<bar>coeff p n\\<bar>)\n\ngoal (1 subgoal):\n 1. 1 + real_of_int m / real_of_int \\<bar>coeff p n\\<bar>\n    \\<le> real_of_int (1 + div_ceiling m \\<bar>coeff p n\\<bar>)", "by auto"], ["proof (state)\nthis:\n  1 + real_of_int m / real_of_int \\<bar>coeff p n\\<bar>\n  \\<le> real_of_int m_up\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "also"], ["proof (state)\nthis:\n  1 + real_of_int m / real_of_int \\<bar>coeff p n\\<bar>\n  \\<le> real_of_int m_up\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "have \"\\<dots> \\<le> ?r C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int m_up \\<le> real_of_rat C", "using Cmup"], ["proof (prove)\nusing this:\n  rat_of_int m_up \\<le> C\n\ngoal (1 subgoal):\n 1. real_of_int m_up \\<le> real_of_rat C", "using of_rat_less_eq"], ["proof (prove)\nusing this:\n  rat_of_int m_up \\<le> C\n  (of_rat ?r \\<le> of_rat ?s) = (?r \\<le> ?s)\n\ngoal (1 subgoal):\n 1. real_of_int m_up \\<le> real_of_rat C", "by force"], ["proof (state)\nthis:\n  real_of_int m_up \\<le> real_of_rat C\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "finally"], ["proof (chain)\npicking this:\n  norm x \\<le> real_of_rat C", "have \"norm x \\<le> ?r C\""], ["proof (prove)\nusing this:\n  norm x \\<le> real_of_rat C\n\ngoal (1 subgoal):\n 1. norm x \\<le> real_of_rat C", "."], ["proof (state)\nthis:\n  norm x \\<le> real_of_rat C\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    norm x \\<le> real_of_rat B", "thus \"norm x \\<le> ?r B\""], ["proof (prove)\nusing this:\n  norm x \\<le> real_of_rat C\n\ngoal (1 subgoal):\n 1. norm x \\<le> real_of_rat B", "unfolding B"], ["proof (prove)\nusing this:\n  norm x \\<le> real_of_rat (of_rat B)\n\ngoal (1 subgoal):\n 1. norm x \\<le> real_of_rat B", "by simp"], ["proof (state)\nthis:\n  norm x \\<le> real_of_rat B\n\ngoal:\nNo subgoals!", "qed"], ["", "fun pairwise_disjoint :: \"'a set list \\<Rightarrow> bool\" where\n  \"pairwise_disjoint [] = True\" \n| \"pairwise_disjoint (x # xs) = ((x \\<inter> (\\<Union> y \\<in> set xs. y) = {}) \\<and> pairwise_disjoint xs)\""], ["", "lemma roots_of_2_irr: assumes pc: \"poly_cond p\" and deg: \"degree p > 0\"\n  shows \"real_of_2 ` set (roots_of_2_irr p) = {x. ipoly p x = 0}\" (is ?one)\n    \"Ball (set (roots_of_2_irr p)) invariant_2\" (is ?two)\n    \"distinct (map real_of_2 (roots_of_2_irr p))\" (is ?three)"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} &&&\n    Ball (set (roots_of_2_irr p)) invariant_2 &&&\n    distinct (map real_of_2 (roots_of_2_irr p))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2_irr p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2_irr p))", "note d = roots_of_2_irr_def"], ["proof (state)\nthis:\n  roots_of_2_irr ?p =\n  (if degree ?p = 1 then [Rational (Rat.Fract (- coeff ?p 0) (coeff ?p 1))]\n   else let ri = root_info ?p; cr = root_info.l_r ri; B = root_bound ?p\n        in roots_of_2_main ?p ri cr [(- B, B)] [])\n\ngoal (3 subgoals):\n 1. real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2_irr p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2_irr p))", "from poly_condD[OF pc]"], ["proof (chain)\npicking this:\n  irreducible p\n  0 < lead_coeff p\n  root_free p\n  square_free p\n  p \\<noteq> 0", "have mon: \"lead_coeff p > 0\" and irr: \"irreducible p\""], ["proof (prove)\nusing this:\n  irreducible p\n  0 < lead_coeff p\n  root_free p\n  square_free p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff p &&& irreducible p", "by auto"], ["proof (state)\nthis:\n  0 < lead_coeff p\n  irreducible p\n\ngoal (3 subgoals):\n 1. real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2_irr p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2_irr p))", "let ?norm = \"real_alg_2'\""], ["proof (state)\ngoal (3 subgoals):\n 1. real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2_irr p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2_irr p))", "have \"?one \\<and> ?two \\<and> ?three\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "proof (cases \"degree p = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "case True"], ["proof (state)\nthis:\n  degree p = 1\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "define c where \"c = coeff p 0\""], ["proof (state)\nthis:\n  c = coeff p 0\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "define d where \"d = coeff p 1\""], ["proof (state)\nthis:\n  d = coeff p 1\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "from True"], ["proof (chain)\npicking this:\n  degree p = 1", "have rr: \"roots_of_2_irr p = [Rational (Rat.Fract (- c) (d))]\""], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. roots_of_2_irr p = [Rational (Rat.Fract (- c) d)]", "unfolding d d_def c_def"], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. (if degree p = 1 then [Rational (Rat.Fract (- coeff p 0) (coeff p 1))]\n     else let ri = root_info p; cr = root_info.l_r ri; B = root_bound p\n          in roots_of_2_main p ri cr [(- B, B)] []) =\n    [Rational (Rat.Fract (- coeff p 0) (coeff p 1))]", "by auto"], ["proof (state)\nthis:\n  roots_of_2_irr p = [Rational (Rat.Fract (- c) d)]\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "from degree1_coeffs[OF True]"], ["proof (chain)\npicking this:\n  \\<exists>a b. p = [:b, a:] \\<and> a \\<noteq> 0", "have p: \"p = [:c,d:]\" and d: \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>a b. p = [:b, a:] \\<and> a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p = [:c, d:] &&& d \\<noteq> 0", "unfolding c_def d_def"], ["proof (prove)\nusing this:\n  \\<exists>a b. p = [:b, a:] \\<and> a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p = [:coeff p 0, coeff p 1:] &&& coeff p 1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p = [:c, d:]\n  d \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "have *: \"real_of_int c + x * real_of_int d = 0 \\<Longrightarrow> x = - (real_of_int c / real_of_int d)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int c + x * real_of_int d = 0 \\<Longrightarrow>\n    x = - (real_of_int c / real_of_int d)", "using d"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_int c + x * real_of_int d = 0 \\<Longrightarrow>\n    x = - (real_of_int c / real_of_int d)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  real_of_int c + ?x * real_of_int d = 0 \\<Longrightarrow>\n  ?x = - (real_of_int c / real_of_int d)\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "unfolding rr"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set [Rational (Rat.Fract (- c) d)] =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set [Rational (Rat.Fract (- c) d)]) invariant_2 \\<and>\n    distinct (map real_of_2 [Rational (Rat.Fract (- c) d)])", "using d *"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n  real_of_int c + ?x * real_of_int d = 0 \\<Longrightarrow>\n  ?x = - (real_of_int c / real_of_int d)\n\ngoal (1 subgoal):\n 1. real_of_2 ` set [Rational (Rat.Fract (- c) d)] =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set [Rational (Rat.Fract (- c) d)]) invariant_2 \\<and>\n    distinct (map real_of_2 [Rational (Rat.Fract (- c) d)])", "unfolding p"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n  real_of_int c + ?x * real_of_int d = 0 \\<Longrightarrow>\n  ?x = - (real_of_int c / real_of_int d)\n\ngoal (1 subgoal):\n 1. real_of_2 ` set [Rational (Rat.Fract (- c) d)] =\n    {x. poly (real_of_int_poly [:c, d:]) x = 0} \\<and>\n    Ball (set [Rational (Rat.Fract (- c) d)]) invariant_2 \\<and>\n    distinct (map real_of_2 [Rational (Rat.Fract (- c) d)])", "using of_rat_1[of \"Rat.Fract (- c) (d)\"]"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n  real_of_int c + ?x * real_of_int d = 0 \\<Longrightarrow>\n  ?x = - (real_of_int c / real_of_int d)\n  invariant_1 (of_rat_1 (Rat.Fract (- c) d))\n  real_of_1 (of_rat_1 (Rat.Fract (- c) d)) = real_of_rat (Rat.Fract (- c) d)\n\ngoal (1 subgoal):\n 1. real_of_2 ` set [Rational (Rat.Fract (- c) d)] =\n    {x. poly (real_of_int_poly [:c, d:]) x = 0} \\<and>\n    Ball (set [Rational (Rat.Fract (- c) d)]) invariant_2 \\<and>\n    distinct (map real_of_2 [Rational (Rat.Fract (- c) d)])", "by (auto simp: Fract_of_int_quotient hom_distribs)"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2_irr p) =\n  {x. poly (real_of_int_poly p) x = 0} \\<and>\n  Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n  distinct (map real_of_2 (roots_of_2_irr p))\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "let ?r = real_of_rat"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "let ?rp = \"map_poly ?r\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "let ?rr = \"set (roots_of_2_irr p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "define ri where \"ri = root_info p\""], ["proof (state)\nthis:\n  ri = root_info p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "define cr where \"cr = root_info.l_r ri\""], ["proof (state)\nthis:\n  cr = root_info.l_r ri\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "define bnds where \"bnds = [(-root_bound p, root_bound p)]\""], ["proof (state)\nthis:\n  bnds = [(- root_bound p, root_bound p)]\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "define empty where \"empty = (Nil :: real_alg_2 list)\""], ["proof (state)\nthis:\n  empty = []\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "have empty: \"Ball (set empty) invariant_2 \\<and> distinct (map real_of_2 empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set empty) invariant_2 \\<and> distinct (map real_of_2 empty)", "unfolding empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set []) invariant_2 \\<and> distinct (map real_of_2 [])", "by auto"], ["proof (state)\nthis:\n  Ball (set empty) invariant_2 \\<and> distinct (map real_of_2 empty)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "from mon"], ["proof (chain)\npicking this:\n  0 < lead_coeff p", "have p: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "from root_info[OF irr deg]"], ["proof (chain)\npicking this:\n  root_info_cond (root_info p) p", "have ri: \"root_info_cond ri p\""], ["proof (prove)\nusing this:\n  root_info_cond (root_info p) p\n\ngoal (1 subgoal):\n 1. root_info_cond ri p", "unfolding ri_def"], ["proof (prove)\nusing this:\n  root_info_cond (root_info p) p\n\ngoal (1 subgoal):\n 1. root_info_cond (root_info p) p", "."], ["proof (state)\nthis:\n  root_info_cond ri p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "from False"], ["proof (chain)\npicking this:\n  degree p \\<noteq> 1", "have rr: \"roots_of_2_irr p = roots_of_2_main p ri cr bnds empty\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. roots_of_2_irr p = roots_of_2_main p ri cr bnds empty", "unfolding d ri_def cr_def Let_def bnds_def empty_def"], ["proof (prove)\nusing this:\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (if degree p = 1 then [Rational (Rat.Fract (- coeff p 0) (coeff p 1))]\n     else roots_of_2_main p (root_info p) (root_info.l_r (root_info p))\n           [(- root_bound p, root_bound p)] []) =\n    roots_of_2_main p (root_info p) (root_info.l_r (root_info p))\n     [(- root_bound p, root_bound p)] []", "by auto"], ["proof (state)\nthis:\n  roots_of_2_irr p = roots_of_2_main p ri cr bnds empty\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "note root_bound = root_bound[OF refl deg]"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) ?x = 0 \\<Longrightarrow>\n  norm ?x \\<le> real_of_rat (root_bound p)\n  0 \\<le> root_bound p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "from root_bound(2)"], ["proof (chain)\npicking this:\n  0 \\<le> root_bound p", "have bnds: \"\\<And> l r. (l,r) \\<in> set bnds \\<Longrightarrow> l \\<le> r\""], ["proof (prove)\nusing this:\n  0 \\<le> root_bound p\n\ngoal (1 subgoal):\n 1. \\<And>l r. (l, r) \\<in> set bnds \\<Longrightarrow> l \\<le> r", "unfolding bnds_def"], ["proof (prove)\nusing this:\n  0 \\<le> root_bound p\n\ngoal (1 subgoal):\n 1. \\<And>l r.\n       (l, r) \\<in> set [(- root_bound p, root_bound p)] \\<Longrightarrow>\n       l \\<le> r", "by auto"], ["proof (state)\nthis:\n  (?l, ?r) \\<in> set bnds \\<Longrightarrow> ?l \\<le> ?r\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "have \"ipoly p x = 0 \\<Longrightarrow> ?r (- root_bound p) \\<le> x \\<and> x \\<le> ?r (root_bound p)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    real_of_rat (- root_bound p) \\<le> x \\<and>\n    x \\<le> real_of_rat (root_bound p)", "using root_bound(1)[of x]"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n  norm x \\<le> real_of_rat (root_bound p)\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0 \\<Longrightarrow>\n    real_of_rat (- root_bound p) \\<le> x \\<and>\n    x \\<le> real_of_rat (root_bound p)", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) ?x = 0 \\<Longrightarrow>\n  real_of_rat (- root_bound p) \\<le> ?x \\<and>\n  ?x \\<le> real_of_rat (root_bound p)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "hence rts: \"{x. ipoly p x = 0} \n      = real_of_2 ` set empty \\<union> {x. \\<exists> l r. root_cond (p,l,r) x \\<and> (l,r) \\<in> set bnds}\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) ?x = 0 \\<Longrightarrow>\n  real_of_rat (- root_bound p) \\<le> ?x \\<and>\n  ?x \\<le> real_of_rat (root_bound p)\n\ngoal (1 subgoal):\n 1. {x. poly (real_of_int_poly p) x = 0} =\n    real_of_2 ` set empty \\<union>\n    {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds}", "unfolding empty_def bnds_def"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) ?x = 0 \\<Longrightarrow>\n  real_of_rat (- root_bound p) \\<le> ?x \\<and>\n  ?x \\<le> real_of_rat (root_bound p)\n\ngoal (1 subgoal):\n 1. {x. poly (real_of_int_poly p) x = 0} =\n    real_of_2 ` set [] \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and>\n           (l, r) \\<in> set [(- root_bound p, root_bound p)]}", "by (force simp: root_cond_def)"], ["proof (state)\nthis:\n  {x. poly (real_of_int_poly p) x = 0} =\n  real_of_2 ` set empty \\<union>\n  {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds}\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "define rts where \"rts lr = Collect (root_cond (p,lr))\" for lr"], ["proof (state)\nthis:\n  rts ?lr = Collect (root_cond (p, ?lr))\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "have disj: \"pairwise_disjoint (real_of_2 ` set empty # map rts bnds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise_disjoint (real_of_2 ` set empty # map rts bnds)", "unfolding empty_def bnds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise_disjoint\n     (real_of_2 ` set [] # map rts [(- root_bound p, root_bound p)])", "by auto"], ["proof (state)\nthis:\n  pairwise_disjoint (real_of_2 ` set empty # map rts bnds)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "from deg False"], ["proof (chain)\npicking this:\n  0 < degree p\n  degree p \\<noteq> 1", "have deg1: \"degree p > 1\""], ["proof (prove)\nusing this:\n  0 < degree p\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < degree p", "by auto"], ["proof (state)\nthis:\n  1 < degree p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "define delta where \"delta = ipoly_root_delta p\""], ["proof (state)\nthis:\n  delta = ipoly_root_delta p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "note delta = ipoly_root_delta[OF p, folded delta_def]"], ["proof (state)\nthis:\n  0 < delta\n  2 \\<le> card (Collect (root_cond (p, ?l, ?r))) \\<Longrightarrow>\n  delta \\<le> real_of_rat (?r - ?l) / 4\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "define rel' where \"rel' = ({(x, y). 0 \\<le> y \\<and> delta_gt delta x y})^-1\""], ["proof (state)\nthis:\n  rel' = {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\\<inverse>\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "define mm where \"mm = (\\<lambda>bnds. mset (map (\\<lambda> (l,r). ?r r - ?r l) bnds))\""], ["proof (state)\nthis:\n  mm =\n  (\\<lambda>bnds.\n      mset (map (\\<lambda>(l, r). real_of_rat r - real_of_rat l) bnds))\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "define rel where \"rel = inv_image (mult1 rel') mm\""], ["proof (state)\nthis:\n  rel = inv_image (mult1 rel') mm\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "have wf: \"wf rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf rel", "unfolding rel_def rel'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image\n         (mult1 ({(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\\<inverse>))\n         mm)", "by (rule wf_inv_image[OF wf_mult1[OF SN_imp_wf[OF delta_gt_SN[OF delta(1)]]]])"], ["proof (state)\nthis:\n  wf rel\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "let ?main = \"roots_of_2_main p ri cr\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "have \"real_of_2 ` set (?main bnds empty) =\n      real_of_2 ` set empty \\<union>\n      {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds} \\<and>\n      Ball (set (?main bnds empty)) invariant_2 \\<and> distinct (map real_of_2 (?main bnds empty))\" (is \"?one' \\<and> ?two' \\<and> ?three'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr bnds empty) =\n    real_of_2 ` set empty \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds} \\<and>\n    Ball (set (roots_of_2_main p ri cr bnds empty)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr bnds empty))", "using empty bnds disj"], ["proof (prove)\nusing this:\n  Ball (set empty) invariant_2 \\<and> distinct (map real_of_2 empty)\n  (?l, ?r) \\<in> set bnds \\<Longrightarrow> ?l \\<le> ?r\n  pairwise_disjoint (real_of_2 ` set empty # map rts bnds)\n\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr bnds empty) =\n    real_of_2 ` set empty \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds} \\<and>\n    Ball (set (roots_of_2_main p ri cr bnds empty)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr bnds empty))", "proof (induct bnds arbitrary: empty rule: wf_induct[OF wf])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x empty.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> rel \\<longrightarrow>\n                   (\\<forall>x.\n                       Ball (set x) invariant_2 \\<and>\n                       distinct (map real_of_2 x) \\<longrightarrow>\n                       (\\<forall>x xa.\n                           (x, xa) \\<in> set y \\<longrightarrow>\n                           x \\<le> xa) \\<longrightarrow>\n                       pairwise_disjoint\n                        (real_of_2 ` set x # map rts y) \\<longrightarrow>\n                       real_of_2 ` set (roots_of_2_main p ri cr y x) =\n                       real_of_2 ` set x \\<union>\n                       {x. \\<exists>l r.\n                              root_cond (p, l, r) x \\<and>\n                              (l, r) \\<in> set y} \\<and>\n                       Ball (set (roots_of_2_main p ri cr y x))\n                        invariant_2 \\<and>\n                       distinct\n                        (map real_of_2 (roots_of_2_main p ri cr y x)));\n        Ball (set empty) invariant_2 \\<and> distinct (map real_of_2 empty);\n        \\<And>l r. (l, r) \\<in> set x \\<Longrightarrow> l \\<le> r;\n        pairwise_disjoint (real_of_2 ` set empty # map rts x)\\<rbrakk>\n       \\<Longrightarrow> real_of_2 ` set (roots_of_2_main p ri cr x empty) =\n                         real_of_2 ` set empty \\<union>\n                         {xa.\n                          \\<exists>l r.\n                             root_cond (p, l, r) xa \\<and>\n                             (l, r) \\<in> set x} \\<and>\n                         Ball (set (roots_of_2_main p ri cr x empty))\n                          invariant_2 \\<and>\n                         distinct\n                          (map real_of_2 (roots_of_2_main p ri cr x empty))", "case (1 lrss rais)"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, lrss) \\<in> rel \\<longrightarrow>\n     (\\<forall>x.\n         (\\<forall>a\\<in>set x. invariant_2 a) \\<and>\n         distinct (map real_of_2 x) \\<longrightarrow>\n         (\\<forall>x xa.\n             (x, xa) \\<in> set y \\<longrightarrow>\n             x \\<le> xa) \\<longrightarrow>\n         pairwise_disjoint (real_of_2 ` set x # map rts y) \\<longrightarrow>\n         real_of_2 ` set (roots_of_2_main p ri cr y x) =\n         real_of_2 ` set x \\<union>\n         {x. \\<exists>l r.\n                root_cond (p, l, r) x \\<and> (l, r) \\<in> set y} \\<and>\n         (\\<forall>a\\<in>set (roots_of_2_main p ri cr y x).\n             invariant_2 a) \\<and>\n         distinct (map real_of_2 (roots_of_2_main p ri cr y x)))\n  (\\<forall>a\\<in>set rais. invariant_2 a) \\<and>\n  distinct (map real_of_2 rais)\n  (?l, ?r) \\<in> set lrss \\<Longrightarrow> ?l \\<le> ?r\n  pairwise_disjoint (real_of_2 ` set rais # map rts lrss)\n\ngoal (1 subgoal):\n 1. \\<And>x empty.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> rel \\<longrightarrow>\n                   (\\<forall>x.\n                       Ball (set x) invariant_2 \\<and>\n                       distinct (map real_of_2 x) \\<longrightarrow>\n                       (\\<forall>x xa.\n                           (x, xa) \\<in> set y \\<longrightarrow>\n                           x \\<le> xa) \\<longrightarrow>\n                       pairwise_disjoint\n                        (real_of_2 ` set x # map rts y) \\<longrightarrow>\n                       real_of_2 ` set (roots_of_2_main p ri cr y x) =\n                       real_of_2 ` set x \\<union>\n                       {x. \\<exists>l r.\n                              root_cond (p, l, r) x \\<and>\n                              (l, r) \\<in> set y} \\<and>\n                       Ball (set (roots_of_2_main p ri cr y x))\n                        invariant_2 \\<and>\n                       distinct\n                        (map real_of_2 (roots_of_2_main p ri cr y x)));\n        Ball (set empty) invariant_2 \\<and> distinct (map real_of_2 empty);\n        \\<And>l r. (l, r) \\<in> set x \\<Longrightarrow> l \\<le> r;\n        pairwise_disjoint (real_of_2 ` set empty # map rts x)\\<rbrakk>\n       \\<Longrightarrow> real_of_2 ` set (roots_of_2_main p ri cr x empty) =\n                         real_of_2 ` set empty \\<union>\n                         {xa.\n                          \\<exists>l r.\n                             root_cond (p, l, r) xa \\<and>\n                             (l, r) \\<in> set x} \\<and>\n                         Ball (set (roots_of_2_main p ri cr x empty))\n                          invariant_2 \\<and>\n                         distinct\n                          (map real_of_2 (roots_of_2_main p ri cr x empty))", "note rais = 1(2)[rule_format]"], ["proof (state)\nthis:\n  (\\<forall>a\\<in>set rais. invariant_2 a) \\<and>\n  distinct (map real_of_2 rais)\n\ngoal (1 subgoal):\n 1. \\<And>x empty.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> rel \\<longrightarrow>\n                   (\\<forall>x.\n                       Ball (set x) invariant_2 \\<and>\n                       distinct (map real_of_2 x) \\<longrightarrow>\n                       (\\<forall>x xa.\n                           (x, xa) \\<in> set y \\<longrightarrow>\n                           x \\<le> xa) \\<longrightarrow>\n                       pairwise_disjoint\n                        (real_of_2 ` set x # map rts y) \\<longrightarrow>\n                       real_of_2 ` set (roots_of_2_main p ri cr y x) =\n                       real_of_2 ` set x \\<union>\n                       {x. \\<exists>l r.\n                              root_cond (p, l, r) x \\<and>\n                              (l, r) \\<in> set y} \\<and>\n                       Ball (set (roots_of_2_main p ri cr y x))\n                        invariant_2 \\<and>\n                       distinct\n                        (map real_of_2 (roots_of_2_main p ri cr y x)));\n        Ball (set empty) invariant_2 \\<and> distinct (map real_of_2 empty);\n        \\<And>l r. (l, r) \\<in> set x \\<Longrightarrow> l \\<le> r;\n        pairwise_disjoint (real_of_2 ` set empty # map rts x)\\<rbrakk>\n       \\<Longrightarrow> real_of_2 ` set (roots_of_2_main p ri cr x empty) =\n                         real_of_2 ` set empty \\<union>\n                         {xa.\n                          \\<exists>l r.\n                             root_cond (p, l, r) xa \\<and>\n                             (l, r) \\<in> set x} \\<and>\n                         Ball (set (roots_of_2_main p ri cr x empty))\n                          invariant_2 \\<and>\n                         distinct\n                          (map real_of_2 (roots_of_2_main p ri cr x empty))", "note lrs = 1(3)"], ["proof (state)\nthis:\n  (?l, ?r) \\<in> set lrss \\<Longrightarrow> ?l \\<le> ?r\n\ngoal (1 subgoal):\n 1. \\<And>x empty.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> rel \\<longrightarrow>\n                   (\\<forall>x.\n                       Ball (set x) invariant_2 \\<and>\n                       distinct (map real_of_2 x) \\<longrightarrow>\n                       (\\<forall>x xa.\n                           (x, xa) \\<in> set y \\<longrightarrow>\n                           x \\<le> xa) \\<longrightarrow>\n                       pairwise_disjoint\n                        (real_of_2 ` set x # map rts y) \\<longrightarrow>\n                       real_of_2 ` set (roots_of_2_main p ri cr y x) =\n                       real_of_2 ` set x \\<union>\n                       {x. \\<exists>l r.\n                              root_cond (p, l, r) x \\<and>\n                              (l, r) \\<in> set y} \\<and>\n                       Ball (set (roots_of_2_main p ri cr y x))\n                        invariant_2 \\<and>\n                       distinct\n                        (map real_of_2 (roots_of_2_main p ri cr y x)));\n        Ball (set empty) invariant_2 \\<and> distinct (map real_of_2 empty);\n        \\<And>l r. (l, r) \\<in> set x \\<Longrightarrow> l \\<le> r;\n        pairwise_disjoint (real_of_2 ` set empty # map rts x)\\<rbrakk>\n       \\<Longrightarrow> real_of_2 ` set (roots_of_2_main p ri cr x empty) =\n                         real_of_2 ` set empty \\<union>\n                         {xa.\n                          \\<exists>l r.\n                             root_cond (p, l, r) xa \\<and>\n                             (l, r) \\<in> set x} \\<and>\n                         Ball (set (roots_of_2_main p ri cr x empty))\n                          invariant_2 \\<and>\n                         distinct\n                          (map real_of_2 (roots_of_2_main p ri cr x empty))", "note disj = 1(4)"], ["proof (state)\nthis:\n  pairwise_disjoint (real_of_2 ` set rais # map rts lrss)\n\ngoal (1 subgoal):\n 1. \\<And>x empty.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> rel \\<longrightarrow>\n                   (\\<forall>x.\n                       Ball (set x) invariant_2 \\<and>\n                       distinct (map real_of_2 x) \\<longrightarrow>\n                       (\\<forall>x xa.\n                           (x, xa) \\<in> set y \\<longrightarrow>\n                           x \\<le> xa) \\<longrightarrow>\n                       pairwise_disjoint\n                        (real_of_2 ` set x # map rts y) \\<longrightarrow>\n                       real_of_2 ` set (roots_of_2_main p ri cr y x) =\n                       real_of_2 ` set x \\<union>\n                       {x. \\<exists>l r.\n                              root_cond (p, l, r) x \\<and>\n                              (l, r) \\<in> set y} \\<and>\n                       Ball (set (roots_of_2_main p ri cr y x))\n                        invariant_2 \\<and>\n                       distinct\n                        (map real_of_2 (roots_of_2_main p ri cr y x)));\n        Ball (set empty) invariant_2 \\<and> distinct (map real_of_2 empty);\n        \\<And>l r. (l, r) \\<in> set x \\<Longrightarrow> l \\<le> r;\n        pairwise_disjoint (real_of_2 ` set empty # map rts x)\\<rbrakk>\n       \\<Longrightarrow> real_of_2 ` set (roots_of_2_main p ri cr x empty) =\n                         real_of_2 ` set empty \\<union>\n                         {xa.\n                          \\<exists>l r.\n                             root_cond (p, l, r) xa \\<and>\n                             (l, r) \\<in> set x} \\<and>\n                         Ball (set (roots_of_2_main p ri cr x empty))\n                          invariant_2 \\<and>\n                         distinct\n                          (map real_of_2 (roots_of_2_main p ri cr x empty))", "note IH = 1(1)[rule_format]"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, lrss) \\<in> rel;\n   Ball (set ?x) invariant_2 \\<and> distinct (map real_of_2 ?x);\n   \\<And>x xa. (x, xa) \\<in> set ?y \\<Longrightarrow> x \\<le> xa;\n   pairwise_disjoint (real_of_2 ` set ?x # map rts ?y)\\<rbrakk>\n  \\<Longrightarrow> real_of_2 ` set (roots_of_2_main p ri cr ?y ?x) =\n                    real_of_2 ` set ?x \\<union>\n                    {x. \\<exists>l r.\n                           root_cond (p, l, r) x \\<and>\n                           (l, r) \\<in> set ?y} \\<and>\n                    Ball (set (roots_of_2_main p ri cr ?y ?x))\n                     invariant_2 \\<and>\n                    distinct (map real_of_2 (roots_of_2_main p ri cr ?y ?x))\n\ngoal (1 subgoal):\n 1. \\<And>x empty.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> rel \\<longrightarrow>\n                   (\\<forall>x.\n                       Ball (set x) invariant_2 \\<and>\n                       distinct (map real_of_2 x) \\<longrightarrow>\n                       (\\<forall>x xa.\n                           (x, xa) \\<in> set y \\<longrightarrow>\n                           x \\<le> xa) \\<longrightarrow>\n                       pairwise_disjoint\n                        (real_of_2 ` set x # map rts y) \\<longrightarrow>\n                       real_of_2 ` set (roots_of_2_main p ri cr y x) =\n                       real_of_2 ` set x \\<union>\n                       {x. \\<exists>l r.\n                              root_cond (p, l, r) x \\<and>\n                              (l, r) \\<in> set y} \\<and>\n                       Ball (set (roots_of_2_main p ri cr y x))\n                        invariant_2 \\<and>\n                       distinct\n                        (map real_of_2 (roots_of_2_main p ri cr y x)));\n        Ball (set empty) invariant_2 \\<and> distinct (map real_of_2 empty);\n        \\<And>l r. (l, r) \\<in> set x \\<Longrightarrow> l \\<le> r;\n        pairwise_disjoint (real_of_2 ` set empty # map rts x)\\<rbrakk>\n       \\<Longrightarrow> real_of_2 ` set (roots_of_2_main p ri cr x empty) =\n                         real_of_2 ` set empty \\<union>\n                         {xa.\n                          \\<exists>l r.\n                             root_cond (p, l, r) xa \\<and>\n                             (l, r) \\<in> set x} \\<and>\n                         Ball (set (roots_of_2_main p ri cr x empty))\n                          invariant_2 \\<and>\n                         distinct\n                          (map real_of_2 (roots_of_2_main p ri cr x empty))", "note simp = roots_of_2_main.simps[of p ri cr lrss rais]"], ["proof (state)\nthis:\n  roots_of_2_main p ri cr lrss rais =\n  (case lrss of [] \\<Rightarrow> rais\n   | (l, r) # lrs \\<Rightarrow>\n       let c = cr l r\n       in if c = 0 then roots_of_2_main p ri cr lrs rais\n          else if c = 1\n               then roots_of_2_main p ri cr lrs\n                     (real_alg_2'' ri p l r # rais)\n               else let m = (l + r) / 2\n                    in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais)\n\ngoal (1 subgoal):\n 1. \\<And>x empty.\n       \\<lbrakk>\\<forall>y.\n                   (y, x) \\<in> rel \\<longrightarrow>\n                   (\\<forall>x.\n                       Ball (set x) invariant_2 \\<and>\n                       distinct (map real_of_2 x) \\<longrightarrow>\n                       (\\<forall>x xa.\n                           (x, xa) \\<in> set y \\<longrightarrow>\n                           x \\<le> xa) \\<longrightarrow>\n                       pairwise_disjoint\n                        (real_of_2 ` set x # map rts y) \\<longrightarrow>\n                       real_of_2 ` set (roots_of_2_main p ri cr y x) =\n                       real_of_2 ` set x \\<union>\n                       {x. \\<exists>l r.\n                              root_cond (p, l, r) x \\<and>\n                              (l, r) \\<in> set y} \\<and>\n                       Ball (set (roots_of_2_main p ri cr y x))\n                        invariant_2 \\<and>\n                       distinct\n                        (map real_of_2 (roots_of_2_main p ri cr y x)));\n        Ball (set empty) invariant_2 \\<and> distinct (map real_of_2 empty);\n        \\<And>l r. (l, r) \\<in> set x \\<Longrightarrow> l \\<le> r;\n        pairwise_disjoint (real_of_2 ` set empty # map rts x)\\<rbrakk>\n       \\<Longrightarrow> real_of_2 ` set (roots_of_2_main p ri cr x empty) =\n                         real_of_2 ` set empty \\<union>\n                         {xa.\n                          \\<exists>l r.\n                             root_cond (p, l, r) xa \\<and>\n                             (l, r) \\<in> set x} \\<and>\n                         Ball (set (roots_of_2_main p ri cr x empty))\n                          invariant_2 \\<and>\n                         distinct\n                          (map real_of_2 (roots_of_2_main p ri cr x empty))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "proof (cases lrss)"], ["proof (state)\ngoal (2 subgoals):\n 1. lrss = [] \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "case Nil"], ["proof (state)\nthis:\n  lrss = []\n\ngoal (2 subgoals):\n 1. lrss = [] \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "with rais"], ["proof (chain)\npicking this:\n  (\\<forall>a\\<in>set rais. invariant_2 a) \\<and>\n  distinct (map real_of_2 rais)\n  lrss = []", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>a\\<in>set rais. invariant_2 a) \\<and>\n  distinct (map real_of_2 rais)\n  lrss = []\n\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "unfolding simp"], ["proof (prove)\nusing this:\n  (\\<forall>a\\<in>set rais. invariant_2 a) \\<and>\n  distinct (map real_of_2 rais)\n  lrss = []\n\ngoal (1 subgoal):\n 1. real_of_2 `\n    set (case lrss of [] \\<Rightarrow> rais\n         | (l, r) # lrs \\<Rightarrow>\n             let c = cr l r\n             in if c = 0 then roots_of_2_main p ri cr lrs rais\n                else if c = 1\n                     then roots_of_2_main p ri cr lrs\n                           (real_alg_2'' ri p l r # rais)\n                     else let m = (l + r) / 2\n                          in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs)\n                              rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (case lrss of [] \\<Rightarrow> rais\n                         | (l, r) # lrs \\<Rightarrow>\n                             let c = cr l r\n                             in if c = 0\n                                then roots_of_2_main p ri cr lrs rais\n                                else if c = 1\n                                     then roots_of_2_main p ri cr lrs\n     (real_alg_2'' ri p l r # rais)\n                                     else let m = (l + r) / 2\n    in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais).\n        invariant_2 a) \\<and>\n    distinct\n     (map real_of_2\n       (case lrss of [] \\<Rightarrow> rais\n        | (l, r) # lrs \\<Rightarrow>\n            let c = cr l r\n            in if c = 0 then roots_of_2_main p ri cr lrs rais\n               else if c = 1\n                    then roots_of_2_main p ri cr lrs\n                          (real_alg_2'' ri p l r # rais)\n                    else let m = (l + r) / 2\n                         in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs)\n                             rais))", "by auto"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n  real_of_2 ` set rais \\<union>\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n  (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n      invariant_2 a) \\<and>\n  distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "case (Cons lr lrs)"], ["proof (state)\nthis:\n  lrss = lr # lrs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "obtain l r where lr': \"lr = (l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l r. lr = (l, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  lr = (l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "{"], ["proof (state)\nthis:\n  lr = (l, r)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "fix lr'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "assume lt: \"\\<And> l' r'. (l',r') \\<in> set lr' \\<Longrightarrow> \n            l' \\<le> r' \\<and> delta_gt delta (?r r - ?r l) (?r r' - ?r l')\""], ["proof (state)\nthis:\n  (?l', ?r') \\<in> set lr' \\<Longrightarrow>\n  ?l' \\<le> ?r' \\<and>\n  delta_gt delta (real_of_rat r - real_of_rat l)\n   (real_of_rat ?r' - real_of_rat ?l')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have l: \"mm (lr' @ lrs) = mm lrs + mm lr'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mm (lr' @ lrs) = mm lrs + mm lr'", "unfolding mm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (map (\\<lambda>(l, r). real_of_rat r - real_of_rat l) (lr' @ lrs)) =\n    mset (map (\\<lambda>(l, r). real_of_rat r - real_of_rat l) lrs) +\n    mset (map (\\<lambda>(l, r). real_of_rat r - real_of_rat l) lr')", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  mm (lr' @ lrs) = mm lrs + mm lr'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have r: \"mm lrss = mm lrs + {# ?r r - ?r l #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mm lrss = mm lrs + {#real_of_rat r - real_of_rat l#}", "unfolding Cons lr' rel_def mm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset\n     (map (\\<lambda>(l, r). real_of_rat r - real_of_rat l) ((l, r) # lrs)) =\n    mset (map (\\<lambda>(l, r). real_of_rat r - real_of_rat l) lrs) +\n    {#real_of_rat r - real_of_rat l#}", "by auto"], ["proof (state)\nthis:\n  mm lrss = mm lrs + {#real_of_rat r - real_of_rat l#}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have \"(mm (lr' @ lrs), mm lrss) \\<in> mult1 rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mm (lr' @ lrs), mm lrss) \\<in> mult1 rel'", "unfolding l r mult1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mm lrs + mm lr', mm lrs + {#real_of_rat r - real_of_rat l#})\n    \\<in> {(N, M).\n           \\<exists>a M0 K.\n              M = add_mset a M0 \\<and>\n              N = M0 + K \\<and>\n              (\\<forall>b. b \\<in># K \\<longrightarrow> (b, a) \\<in> rel')}", "proof (rule, unfold split, intro exI conjI, unfold add_mset_add_single[symmetric], rule refl, rule refl, intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in># mm lr' \\<Longrightarrow>\n       (b, real_of_rat r - real_of_rat l) \\<in> rel'", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in># mm lr' \\<Longrightarrow>\n       (b, real_of_rat r - real_of_rat l) \\<in> rel'", "assume \"d \\<in># mm lr'\""], ["proof (state)\nthis:\n  d \\<in># mm lr'\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in># mm lr' \\<Longrightarrow>\n       (b, real_of_rat r - real_of_rat l) \\<in> rel'", "then"], ["proof (chain)\npicking this:\n  d \\<in># mm lr'", "obtain l' r' where d: \"d = ?r r' - ?r l'\" and lr': \"(l',r') \\<in> set lr'\""], ["proof (prove)\nusing this:\n  d \\<in># mm lr'\n\ngoal (1 subgoal):\n 1. (\\<And>r' l'.\n        \\<lbrakk>d = real_of_rat r' - real_of_rat l';\n         (l', r') \\<in> set lr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mm_def in_multiset_in_set"], ["proof (prove)\nusing this:\n  d \\<in> set (map (\\<lambda>(l, r). real_of_rat r - real_of_rat l) lr')\n\ngoal (1 subgoal):\n 1. (\\<And>r' l'.\n        \\<lbrakk>d = real_of_rat r' - real_of_rat l';\n         (l', r') \\<in> set lr'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d = real_of_rat r' - real_of_rat l'\n  (l', r') \\<in> set lr'\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in># mm lr' \\<Longrightarrow>\n       (b, real_of_rat r - real_of_rat l) \\<in> rel'", "from lt[OF lr']"], ["proof (chain)\npicking this:\n  l' \\<le> r' \\<and>\n  delta_gt delta (real_of_rat r - real_of_rat l)\n   (real_of_rat r' - real_of_rat l')", "show \"(d, ?r r - ?r l) \\<in> rel'\""], ["proof (prove)\nusing this:\n  l' \\<le> r' \\<and>\n  delta_gt delta (real_of_rat r - real_of_rat l)\n   (real_of_rat r' - real_of_rat l')\n\ngoal (1 subgoal):\n 1. (d, real_of_rat r - real_of_rat l) \\<in> rel'", "unfolding d rel'_def"], ["proof (prove)\nusing this:\n  l' \\<le> r' \\<and>\n  delta_gt delta (real_of_rat r - real_of_rat l)\n   (real_of_rat r' - real_of_rat l')\n\ngoal (1 subgoal):\n 1. (real_of_rat r' - real_of_rat l', real_of_rat r - real_of_rat l)\n    \\<in> {(x, y). 0 \\<le> y \\<and> delta_gt delta x y}\\<inverse>", "by (auto simp: of_rat_less_eq)"], ["proof (state)\nthis:\n  (d, real_of_rat r - real_of_rat l) \\<in> rel'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mm (lr' @ lrs), mm lrss) \\<in> mult1 rel'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "hence \"(lr' @ lrs, lrss) \\<in> rel\""], ["proof (prove)\nusing this:\n  (mm (lr' @ lrs), mm lrss) \\<in> mult1 rel'\n\ngoal (1 subgoal):\n 1. (lr' @ lrs, lrss) \\<in> rel", "unfolding rel_def"], ["proof (prove)\nusing this:\n  (mm (lr' @ lrs), mm lrss) \\<in> mult1 rel'\n\ngoal (1 subgoal):\n 1. (lr' @ lrs, lrss) \\<in> inv_image (mult1 rel') mm", "by auto"], ["proof (state)\nthis:\n  (lr' @ lrs, lrss) \\<in> rel\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "}"], ["proof (state)\nthis:\n  (\\<And>l' r'.\n      (l', r') \\<in> set ?lr'2 \\<Longrightarrow>\n      l' \\<le> r' \\<and>\n      delta_gt delta (real_of_rat r - real_of_rat l)\n       (real_of_rat r' - real_of_rat l')) \\<Longrightarrow>\n  (?lr'2 @ lrs, lrss) \\<in> rel\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "note rel = this"], ["proof (state)\nthis:\n  (\\<And>l' r'.\n      (l', r') \\<in> set ?lr'2 \\<Longrightarrow>\n      l' \\<le> r' \\<and>\n      delta_gt delta (real_of_rat r - real_of_rat l)\n       (real_of_rat r' - real_of_rat l')) \\<Longrightarrow>\n  (?lr'2 @ lrs, lrss) \\<in> rel\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "from rel[of Nil]"], ["proof (chain)\npicking this:\n  (\\<And>l' r'.\n      (l', r') \\<in> set [] \\<Longrightarrow>\n      l' \\<le> r' \\<and>\n      delta_gt delta (real_of_rat r - real_of_rat l)\n       (real_of_rat r' - real_of_rat l')) \\<Longrightarrow>\n  ([] @ lrs, lrss) \\<in> rel", "have easy_rel: \"(lrs,lrss) \\<in> rel\""], ["proof (prove)\nusing this:\n  (\\<And>l' r'.\n      (l', r') \\<in> set [] \\<Longrightarrow>\n      l' \\<le> r' \\<and>\n      delta_gt delta (real_of_rat r - real_of_rat l)\n       (real_of_rat r' - real_of_rat l')) \\<Longrightarrow>\n  ([] @ lrs, lrss) \\<in> rel\n\ngoal (1 subgoal):\n 1. (lrs, lrss) \\<in> rel", "by auto"], ["proof (state)\nthis:\n  (lrs, lrss) \\<in> rel\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "define c where \"c = cr l r\""], ["proof (state)\nthis:\n  c = cr l r\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "from simp Cons lr'"], ["proof (chain)\npicking this:\n  roots_of_2_main p ri cr lrss rais =\n  (case lrss of [] \\<Rightarrow> rais\n   | (l, r) # lrs \\<Rightarrow>\n       let c = cr l r\n       in if c = 0 then roots_of_2_main p ri cr lrs rais\n          else if c = 1\n               then roots_of_2_main p ri cr lrs\n                     (real_alg_2'' ri p l r # rais)\n               else let m = (l + r) / 2\n                    in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais)\n  lrss = lr # lrs\n  lr = (l, r)", "have simp: \"?main lrss rais = \n          (if c = 0 then ?main lrs rais else if c = 1 then \n             ?main lrs (real_alg_2' ri p l r # rais)\n               else let m = (l + r) / 2 in ?main ((m, r) # (l, m) # lrs) rais)\""], ["proof (prove)\nusing this:\n  roots_of_2_main p ri cr lrss rais =\n  (case lrss of [] \\<Rightarrow> rais\n   | (l, r) # lrs \\<Rightarrow>\n       let c = cr l r\n       in if c = 0 then roots_of_2_main p ri cr lrs rais\n          else if c = 1\n               then roots_of_2_main p ri cr lrs\n                     (real_alg_2'' ri p l r # rais)\n               else let m = (l + r) / 2\n                    in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais)\n  lrss = lr # lrs\n  lr = (l, r)\n\ngoal (1 subgoal):\n 1. roots_of_2_main p ri cr lrss rais =\n    (if c = 0 then roots_of_2_main p ri cr lrs rais\n     else if c = 1\n          then roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)\n          else let m = (l + r) / 2\n               in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais)", "unfolding c_def simp Cons lr'"], ["proof (prove)\nusing this:\n  roots_of_2_main p ri cr ((l, r) # lrs) rais =\n  (case (l, r) # lrs of [] \\<Rightarrow> rais\n   | (l, r) # lrs \\<Rightarrow>\n       let c = cr l r\n       in if c = 0 then roots_of_2_main p ri cr lrs rais\n          else if c = 1\n               then roots_of_2_main p ri cr lrs\n                     (real_alg_2'' ri p l r # rais)\n               else let m = (l + r) / 2\n                    in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais)\n  (l, r) # lrs = (l, r) # lrs\n  (l, r) = (l, r)\n\ngoal (1 subgoal):\n 1. roots_of_2_main p ri cr ((l, r) # lrs) rais =\n    (if cr l r = 0 then roots_of_2_main p ri cr lrs rais\n     else if cr l r = 1\n          then roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)\n          else let m = (l + r) / 2\n               in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais)", "using real_alg_2''[OF False]"], ["proof (prove)\nusing this:\n  roots_of_2_main p ri cr ((l, r) # lrs) rais =\n  (case (l, r) # lrs of [] \\<Rightarrow> rais\n   | (l, r) # lrs \\<Rightarrow>\n       let c = cr l r\n       in if c = 0 then roots_of_2_main p ri cr lrs rais\n          else if c = 1\n               then roots_of_2_main p ri cr lrs\n                     (real_alg_2'' ri p l r # rais)\n               else let m = (l + r) / 2\n                    in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais)\n  (l, r) # lrs = (l, r) # lrs\n  (l, r) = (l, r)\n  real_alg_2'' ?ri p ?l ?r = real_alg_2' ?ri p ?l ?r\n\ngoal (1 subgoal):\n 1. roots_of_2_main p ri cr ((l, r) # lrs) rais =\n    (if cr l r = 0 then roots_of_2_main p ri cr lrs rais\n     else if cr l r = 1\n          then roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)\n          else let m = (l + r) / 2\n               in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais)", "by auto"], ["proof (state)\nthis:\n  roots_of_2_main p ri cr lrss rais =\n  (if c = 0 then roots_of_2_main p ri cr lrs rais\n   else if c = 1\n        then roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)\n        else let m = (l + r) / 2\n             in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "note lrs = lrs[unfolded Cons lr']"], ["proof (state)\nthis:\n  (?l, ?r) \\<in> set ((l, r) # lrs) \\<Longrightarrow> ?l \\<le> ?r\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "from lrs"], ["proof (chain)\npicking this:\n  (?l, ?r) \\<in> set ((l, r) # lrs) \\<Longrightarrow> ?l \\<le> ?r", "have lr: \"l \\<le> r\""], ["proof (prove)\nusing this:\n  (?l, ?r) \\<in> set ((l, r) # lrs) \\<Longrightarrow> ?l \\<le> ?r\n\ngoal (1 subgoal):\n 1. l \\<le> r", "by auto"], ["proof (state)\nthis:\n  l \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "from root_info_condD(1)[OF ri lr, folded cr_def]"], ["proof (chain)\npicking this:\n  cr l r = card {x. root_cond (p, l, r) x}", "have c: \"c = card {x. root_cond (p,l,r) x}\""], ["proof (prove)\nusing this:\n  cr l r = card {x. root_cond (p, l, r) x}\n\ngoal (1 subgoal):\n 1. c = card {x. root_cond (p, l, r) x}", "unfolding c_def"], ["proof (prove)\nusing this:\n  cr l r = card {x. root_cond (p, l, r) x}\n\ngoal (1 subgoal):\n 1. cr l r = card {x. root_cond (p, l, r) x}", "by auto"], ["proof (state)\nthis:\n  c = card {x. root_cond (p, l, r) x}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "let ?rt = \"\\<lambda> lrs. {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have rts: \"?rt lrss = ?rt lrs \\<union> {x. root_cond (p,l,r) x}\" (is \"?rt1 = ?rt2 \\<union> ?rt3\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} =\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<union>\n    {x. root_cond (p, l, r) x}", "unfolding Cons lr'"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>la ra.\n           root_cond (p, la, ra) x \\<and>\n           (la, ra) \\<in> set ((l, r) # lrs)} =\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<union>\n    {x. root_cond (p, l, r) x}", "by auto"], ["proof (state)\nthis:\n  {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} =\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<union>\n  {x. root_cond (p, l, r) x}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       lrss = a # list \\<Longrightarrow>\n       real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n       real_of_2 ` set rais \\<union>\n       {x. \\<exists>l r.\n              root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n       (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n           invariant_2 a) \\<and>\n       distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "proof (cases \"c = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "with simp"], ["proof (chain)\npicking this:\n  roots_of_2_main p ri cr lrss rais =\n  (if c = 0 then roots_of_2_main p ri cr lrs rais\n   else if c = 1\n        then roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)\n        else let m = (l + r) / 2\n             in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais)\n  c = 0", "have simp: \"?main lrss rais = ?main lrs rais\""], ["proof (prove)\nusing this:\n  roots_of_2_main p ri cr lrss rais =\n  (if c = 0 then roots_of_2_main p ri cr lrs rais\n   else if c = 1\n        then roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)\n        else let m = (l + r) / 2\n             in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais)\n  c = 0\n\ngoal (1 subgoal):\n 1. roots_of_2_main p ri cr lrss rais = roots_of_2_main p ri cr lrs rais", "by simp"], ["proof (state)\nthis:\n  roots_of_2_main p ri cr lrss rais = roots_of_2_main p ri cr lrs rais\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "from disj"], ["proof (chain)\npicking this:\n  pairwise_disjoint (real_of_2 ` set rais # map rts lrss)", "have disj: \"pairwise_disjoint (real_of_2 ` set rais # map rts lrs)\""], ["proof (prove)\nusing this:\n  pairwise_disjoint (real_of_2 ` set rais # map rts lrss)\n\ngoal (1 subgoal):\n 1. pairwise_disjoint (real_of_2 ` set rais # map rts lrs)", "unfolding Cons"], ["proof (prove)\nusing this:\n  pairwise_disjoint (real_of_2 ` set rais # map rts (lr # lrs))\n\ngoal (1 subgoal):\n 1. pairwise_disjoint (real_of_2 ` set rais # map rts lrs)", "by auto"], ["proof (state)\nthis:\n  pairwise_disjoint (real_of_2 ` set rais # map rts lrs)\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "from finite_ipoly_roots[OF p] True[unfolded c]"], ["proof (chain)\npicking this:\n  finite {x. poly (real_of_int_poly p) x = 0}\n  card (Collect (root_cond (p, l, r))) = 0", "have empty: \"?rt3 = {}\""], ["proof (prove)\nusing this:\n  finite {x. poly (real_of_int_poly p) x = 0}\n  card (Collect (root_cond (p, l, r))) = 0\n\ngoal (1 subgoal):\n 1. {x. root_cond (p, l, r) x} = {}", "unfolding root_cond_def[abs_def] split"], ["proof (prove)\nusing this:\n  finite {x. poly (real_of_int_poly p) x = 0}\n  card\n   {x. real_of_rat l \\<le> x \\<and>\n       x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0} =\n  0\n\ngoal (1 subgoal):\n 1. {x. real_of_rat l \\<le> x \\<and>\n        x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0} =\n    {}", "by simp"], ["proof (state)\nthis:\n  {x. root_cond (p, l, r) x} = {}\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "with rts"], ["proof (chain)\npicking this:\n  {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} =\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<union>\n  {x. root_cond (p, l, r) x}\n  {x. root_cond (p, l, r) x} = {}", "have rts: \"?rt1 = ?rt2\""], ["proof (prove)\nusing this:\n  {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} =\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<union>\n  {x. root_cond (p, l, r) x}\n  {x. root_cond (p, l, r) x} = {}\n\ngoal (1 subgoal):\n 1. {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} =\n    {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs}", "by auto"], ["proof (state)\nthis:\n  {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} =\n  {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs}\n\ngoal (2 subgoals):\n 1. c = 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "unfolding simp rts"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr lrs rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrs rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrs rais))", "by (rule IH[OF easy_rel rais lrs disj], auto)"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n  real_of_2 ` set rais \\<union>\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n  (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n      invariant_2 a) \\<and>\n  distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "proof (cases \"c = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "case True"], ["proof (state)\nthis:\n  c = 1\n\ngoal (2 subgoals):\n 1. c = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "let ?rai = \"real_alg_2' ri p l r\""], ["proof (state)\ngoal (2 subgoals):\n 1. c = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "from True simp"], ["proof (chain)\npicking this:\n  c = 1\n  roots_of_2_main p ri cr lrss rais =\n  (if c = 0 then roots_of_2_main p ri cr lrs rais\n   else if c = 1\n        then roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)\n        else let m = (l + r) / 2\n             in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais)", "have simp: \"?main lrss rais = ?main lrs (?rai # rais)\""], ["proof (prove)\nusing this:\n  c = 1\n  roots_of_2_main p ri cr lrss rais =\n  (if c = 0 then roots_of_2_main p ri cr lrs rais\n   else if c = 1\n        then roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)\n        else let m = (l + r) / 2\n             in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais)\n\ngoal (1 subgoal):\n 1. roots_of_2_main p ri cr lrss rais =\n    roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)", "by auto"], ["proof (state)\nthis:\n  roots_of_2_main p ri cr lrss rais =\n  roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)\n\ngoal (2 subgoals):\n 1. c = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "from card_1_Collect_ex1[OF c[symmetric, unfolded True]]"], ["proof (chain)\npicking this:\n  \\<exists>!x. root_cond (p, l, r) x", "have ur: \"unique_root (p,l,r)\""], ["proof (prove)\nusing this:\n  \\<exists>!x. root_cond (p, l, r) x\n\ngoal (1 subgoal):\n 1. \\<exists>!x. root_cond (p, l, r) x", "."], ["proof (state)\nthis:\n  \\<exists>!x. root_cond (p, l, r) x\n\ngoal (2 subgoals):\n 1. c = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "from real_alg_2'[OF ur pc ri]"], ["proof (chain)\npicking this:\n  invariant_2 (real_alg_2' ri p l r) \\<and>\n  real_of_2 (real_alg_2' ri p l r) = real_of_1 (p, l, r)", "have rai: \"invariant_2 ?rai\" \"real_of_2 ?rai = the_unique_root (p, l, r)\""], ["proof (prove)\nusing this:\n  invariant_2 (real_alg_2' ri p l r) \\<and>\n  real_of_2 (real_alg_2' ri p l r) = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. invariant_2 (real_alg_2' ri p l r) &&&\n    real_of_2 (real_alg_2' ri p l r) = real_of_1 (p, l, r)", "by auto"], ["proof (state)\nthis:\n  invariant_2 (real_alg_2' ri p l r)\n  real_of_2 (real_alg_2' ri p l r) = real_of_1 (p, l, r)\n\ngoal (2 subgoals):\n 1. c = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "with rais"], ["proof (chain)\npicking this:\n  (\\<forall>a\\<in>set rais. invariant_2 a) \\<and>\n  distinct (map real_of_2 rais)\n  invariant_2 (real_alg_2' ri p l r)\n  real_of_2 (real_alg_2' ri p l r) = real_of_1 (p, l, r)", "have rais: \"\\<And> x. x \\<in> set (?rai # rais) \\<Longrightarrow> invariant_2 x\" \n              and dist: \"distinct (map real_of_2 rais)\""], ["proof (prove)\nusing this:\n  (\\<forall>a\\<in>set rais. invariant_2 a) \\<and>\n  distinct (map real_of_2 rais)\n  invariant_2 (real_alg_2' ri p l r)\n  real_of_2 (real_alg_2' ri p l r) = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set (real_alg_2' ri p l r # rais) \\<Longrightarrow>\n        invariant_2 x) &&&\n    distinct (map real_of_2 rais)", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> set (real_alg_2' ri p l r # rais) \\<Longrightarrow>\n  invariant_2 ?x\n  distinct (map real_of_2 rais)\n\ngoal (2 subgoals):\n 1. c = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have rt3: \"?rt3 = {real_of_2 ?rai}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. root_cond (p, l, r) x} = {real_of_2 (real_alg_2' ri p l r)}", "using rc1 ur rai"], ["proof (prove)\nusing this:\n  source_size revcast + ?n = target_size revcast \\<Longrightarrow>\n  ucast ?w = word_reverse (ucast (word_reverse ?w) << ?n)\n  \\<exists>!x. root_cond (p, l, r) x\n  invariant_2 (real_alg_2' ri p l r)\n  real_of_2 (real_alg_2' ri p l r) = real_of_1 (p, l, r)\n\ngoal (1 subgoal):\n 1. {x. root_cond (p, l, r) x} = {real_of_2 (real_alg_2' ri p l r)}", "by (auto intro: the_unique_root_eqI theI')"], ["proof (state)\nthis:\n  {x. root_cond (p, l, r) x} = {real_of_2 (real_alg_2' ri p l r)}\n\ngoal (2 subgoals):\n 1. c = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have \"real_of_2 ` set (roots_of_2_main p ri cr lrs (?rai # rais)) =\n              real_of_2 ` set (?rai # rais) \\<union> ?rt2 \\<and>\n              Ball (set (roots_of_2_main p ri cr lrs (?rai # rais))) invariant_2 \\<and>\n              distinct (map real_of_2 (roots_of_2_main p ri cr lrs (?rai # rais)))\"\n              (is \"?one \\<and> ?two \\<and> ?three\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 `\n    set (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)) =\n    real_of_2 ` set (real_alg_2' ri p l r # rais) \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<and>\n    Ball (set (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)))\n     invariant_2 \\<and>\n    distinct\n     (map real_of_2\n       (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)))", "proof (rule IH[OF easy_rel, of \"?rai # rais\", OF conjI lrs])"], ["proof (state)\ngoal (4 subgoals):\n 1. Ball (set (real_alg_2' ri p l r # rais)) invariant_2\n 2. distinct (map real_of_2 (real_alg_2' ri p l r # rais))\n 3. \\<And>x xa.\n       (x, xa) \\<in> set lrs \\<Longrightarrow>\n       (x, xa) \\<in> set ((l, r) # lrs)\n 4. pairwise_disjoint\n     (real_of_2 ` set (real_alg_2' ri p l r # rais) # map rts lrs)", "show \"Ball (set (real_alg_2' ri p l r # rais)) invariant_2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (real_alg_2' ri p l r # rais)) invariant_2", "using rais"], ["proof (prove)\nusing this:\n  ?x \\<in> set (real_alg_2' ri p l r # rais) \\<Longrightarrow>\n  invariant_2 ?x\n\ngoal (1 subgoal):\n 1. Ball (set (real_alg_2' ri p l r # rais)) invariant_2", "by auto"], ["proof (state)\nthis:\n  Ball (set (real_alg_2' ri p l r # rais)) invariant_2\n\ngoal (3 subgoals):\n 1. distinct (map real_of_2 (real_alg_2' ri p l r # rais))\n 2. \\<And>x xa.\n       (x, xa) \\<in> set lrs \\<Longrightarrow>\n       (x, xa) \\<in> set ((l, r) # lrs)\n 3. pairwise_disjoint\n     (real_of_2 ` set (real_alg_2' ri p l r # rais) # map rts lrs)", "have \"real_of_2 (real_alg_2' ri p l r) \\<notin> set (map real_of_2 rais)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 (real_alg_2' ri p l r) \\<notin> set (map real_of_2 rais)", "using disj rt3"], ["proof (prove)\nusing this:\n  pairwise_disjoint (real_of_2 ` set rais # map rts lrss)\n  {x. root_cond (p, l, r) x} = {real_of_2 (real_alg_2' ri p l r)}\n\ngoal (1 subgoal):\n 1. real_of_2 (real_alg_2' ri p l r) \\<notin> set (map real_of_2 rais)", "unfolding Cons lr' rts_def"], ["proof (prove)\nusing this:\n  pairwise_disjoint\n   (real_of_2 ` set rais #\n    map (\\<lambda>a. Collect (root_cond (p, a))) ((l, r) # lrs))\n  {x. root_cond (p, l, r) x} = {real_of_2 (real_alg_2' ri p l r)}\n\ngoal (1 subgoal):\n 1. real_of_2 (real_alg_2' ri p l r) \\<notin> set (map real_of_2 rais)", "by auto"], ["proof (state)\nthis:\n  real_of_2 (real_alg_2' ri p l r) \\<notin> set (map real_of_2 rais)\n\ngoal (3 subgoals):\n 1. distinct (map real_of_2 (real_alg_2' ri p l r # rais))\n 2. \\<And>x xa.\n       (x, xa) \\<in> set lrs \\<Longrightarrow>\n       (x, xa) \\<in> set ((l, r) # lrs)\n 3. pairwise_disjoint\n     (real_of_2 ` set (real_alg_2' ri p l r # rais) # map rts lrs)", "thus \"distinct (map real_of_2 (real_alg_2' ri p l r # rais))\""], ["proof (prove)\nusing this:\n  real_of_2 (real_alg_2' ri p l r) \\<notin> set (map real_of_2 rais)\n\ngoal (1 subgoal):\n 1. distinct (map real_of_2 (real_alg_2' ri p l r # rais))", "using dist"], ["proof (prove)\nusing this:\n  real_of_2 (real_alg_2' ri p l r) \\<notin> set (map real_of_2 rais)\n  distinct (map real_of_2 rais)\n\ngoal (1 subgoal):\n 1. distinct (map real_of_2 (real_alg_2' ri p l r # rais))", "by auto"], ["proof (state)\nthis:\n  distinct (map real_of_2 (real_alg_2' ri p l r # rais))\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set lrs \\<Longrightarrow>\n       (x, xa) \\<in> set ((l, r) # lrs)\n 2. pairwise_disjoint\n     (real_of_2 ` set (real_alg_2' ri p l r # rais) # map rts lrs)", "show \"pairwise_disjoint (real_of_2 ` set (real_alg_2' ri p l r # rais) # map rts lrs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise_disjoint\n     (real_of_2 ` set (real_alg_2' ri p l r # rais) # map rts lrs)", "using disj rt3"], ["proof (prove)\nusing this:\n  pairwise_disjoint (real_of_2 ` set rais # map rts lrss)\n  {x. root_cond (p, l, r) x} = {real_of_2 (real_alg_2' ri p l r)}\n\ngoal (1 subgoal):\n 1. pairwise_disjoint\n     (real_of_2 ` set (real_alg_2' ri p l r # rais) # map rts lrs)", "unfolding Cons lr' rts_def"], ["proof (prove)\nusing this:\n  pairwise_disjoint\n   (real_of_2 ` set rais #\n    map (\\<lambda>a. Collect (root_cond (p, a))) ((l, r) # lrs))\n  {x. root_cond (p, l, r) x} = {real_of_2 (real_alg_2' ri p l r)}\n\ngoal (1 subgoal):\n 1. pairwise_disjoint\n     (real_of_2 ` set (real_alg_2' ri p l r # rais) #\n      map (\\<lambda>lr. Collect (root_cond (p, lr))) lrs)", "by auto"], ["proof (state)\nthis:\n  pairwise_disjoint\n   (real_of_2 ` set (real_alg_2' ri p l r # rais) # map rts lrs)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (x, xa) \\<in> set lrs \\<Longrightarrow>\n       (x, xa) \\<in> set ((l, r) # lrs)", "qed auto"], ["proof (state)\nthis:\n  real_of_2 `\n  set (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)) =\n  real_of_2 ` set (real_alg_2' ri p l r # rais) \\<union>\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<and>\n  Ball (set (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)))\n   invariant_2 \\<and>\n  distinct\n   (map real_of_2\n     (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)))\n\ngoal (2 subgoals):\n 1. c = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "hence ?one ?two ?three"], ["proof (prove)\nusing this:\n  real_of_2 `\n  set (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)) =\n  real_of_2 ` set (real_alg_2' ri p l r # rais) \\<union>\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<and>\n  Ball (set (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)))\n   invariant_2 \\<and>\n  distinct\n   (map real_of_2\n     (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)))\n\ngoal (1 subgoal):\n 1. real_of_2 `\n    set (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)) =\n    real_of_2 ` set (real_alg_2' ri p l r # rais) \\<union>\n    {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} &&&\n    Ball (set (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)))\n     invariant_2 &&&\n    distinct\n     (map real_of_2\n       (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)))", "by blast+"], ["proof (state)\nthis:\n  real_of_2 `\n  set (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)) =\n  real_of_2 ` set (real_alg_2' ri p l r # rais) \\<union>\n  {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs}\n  Ball (set (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)))\n   invariant_2\n  distinct\n   (map real_of_2\n     (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)))\n\ngoal (2 subgoals):\n 1. c = 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n 2. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "unfolding simp rts rt3"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 `\n    set (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)) =\n    real_of_2 ` set rais \\<union>\n    ({x. \\<exists>l r.\n            root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<union>\n     {real_of_2 (real_alg_2' ri p l r)}) \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrs\n                          (real_alg_2' ri p l r # rais)).\n        invariant_2 a) \\<and>\n    distinct\n     (map real_of_2\n       (roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)))", "by (rule conjI[OF _ conjI[OF \\<open>?two\\<close> \\<open>?three\\<close>]], unfold \\<open>?one\\<close>, auto)"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n  real_of_2 ` set rais \\<union>\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n  (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n      invariant_2 a) \\<and>\n  distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 1\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "let ?m = \"(l+r)/2\""], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "let ?lrs = \"[(?m,r),(l,?m)] @ lrs\""], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "from False \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> 1\n  c \\<noteq> 0", "have simp: \"?main lrss rais = ?main ?lrs rais\""], ["proof (prove)\nusing this:\n  c \\<noteq> 1\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. roots_of_2_main p ri cr lrss rais =\n    roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n     rais", "unfolding simp"], ["proof (prove)\nusing this:\n  c \\<noteq> 1\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if c = 0 then roots_of_2_main p ri cr lrs rais\n     else if c = 1\n          then roots_of_2_main p ri cr lrs (real_alg_2' ri p l r # rais)\n          else let m = (l + r) / 2\n               in roots_of_2_main p ri cr ((m, r) # (l, m) # lrs) rais) =\n    roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n     rais", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  roots_of_2_main p ri cr lrss rais =\n  roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "from False \\<open>c \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  c \\<noteq> 1\n  c \\<noteq> 0", "have \"c \\<ge> 2\""], ["proof (prove)\nusing this:\n  c \\<noteq> 1\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> c", "by auto"], ["proof (state)\nthis:\n  2 \\<le> c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "from delta(2)[OF this[unfolded c]]"], ["proof (chain)\npicking this:\n  delta \\<le> real_of_rat (r - l) / 4", "have delta: \"delta \\<le> ?r (r - l) / 4\""], ["proof (prove)\nusing this:\n  delta \\<le> real_of_rat (r - l) / 4\n\ngoal (1 subgoal):\n 1. delta \\<le> real_of_rat (r - l) / 4", "by auto"], ["proof (state)\nthis:\n  delta \\<le> real_of_rat (r - l) / 4\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have lrs: \"\\<And> l r. (l,r) \\<in> set ?lrs \\<Longrightarrow> l \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>la ra.\n       (la, ra)\n       \\<in> set ([((l + r) / 2, r), (l, (l + r) / 2)] @\n                  lrs) \\<Longrightarrow>\n       la \\<le> ra", "using lr lrs"], ["proof (prove)\nusing this:\n  l \\<le> r\n  (?l, ?r) \\<in> set ((l, r) # lrs) \\<Longrightarrow> ?l \\<le> ?r\n\ngoal (1 subgoal):\n 1. \\<And>la ra.\n       (la, ra)\n       \\<in> set ([((l + r) / 2, r), (l, (l + r) / 2)] @\n                  lrs) \\<Longrightarrow>\n       la \\<le> ra", "by (fastforce simp: field_simps)"], ["proof (state)\nthis:\n  (?l, ?r)\n  \\<in> set ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) \\<Longrightarrow>\n  ?l \\<le> ?r\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have \"?r ?m \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat ((l + r) / 2) \\<in> \\<rat>", "unfolding Rats_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat ((l + r) / 2) \\<in> range real_of_rat", "by blast"], ["proof (state)\nthis:\n  real_of_rat ((l + r) / 2) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "with poly_cond_degree_gt_1[OF pc deg1, of \"?r ?m\"]"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly p) (real_of_rat ((l + r) / 2)) =\n  0 \\<Longrightarrow>\n  real_of_rat ((l + r) / 2) \\<notin> \\<rat>\n  real_of_rat ((l + r) / 2) \\<in> \\<rat>", "have disj1: \"?r ?m \\<notin> rts lr\" for lr"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (real_of_rat ((l + r) / 2)) =\n  0 \\<Longrightarrow>\n  real_of_rat ((l + r) / 2) \\<notin> \\<rat>\n  real_of_rat ((l + r) / 2) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. real_of_rat ((l + r) / 2) \\<notin> rts lr", "unfolding rts_def root_cond_def"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) (real_of_rat ((l + r) / 2)) =\n  0 \\<Longrightarrow>\n  real_of_rat ((l + r) / 2) \\<notin> \\<rat>\n  real_of_rat ((l + r) / 2) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. real_of_rat ((l + r) / 2)\n    \\<notin> {x. case (p, lr) of\n                 (p, l, r) \\<Rightarrow>\n                   real_of_rat l \\<le> x \\<and>\n                   x \\<le> real_of_rat r \\<and>\n                   poly (real_of_int_poly p) x = 0}", "by auto"], ["proof (state)\nthis:\n  real_of_rat ((l + r) / 2) \\<notin> rts ?lr\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have disj2: \"rts (?m, r) \\<inter> rts (l, ?m) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rts ((l + r) / 2, r) \\<inter> rts (l, (l + r) / 2) = {}", "using disj1[of \"(l,?m)\"] disj1[of \"(?m,r)\"]"], ["proof (prove)\nusing this:\n  real_of_rat ((l + r) / 2) \\<notin> rts (l, (l + r) / 2)\n  real_of_rat ((l + r) / 2) \\<notin> rts ((l + r) / 2, r)\n\ngoal (1 subgoal):\n 1. rts ((l + r) / 2, r) \\<inter> rts (l, (l + r) / 2) = {}", "unfolding rts_def root_cond_def"], ["proof (prove)\nusing this:\n  real_of_rat ((l + r) / 2)\n  \\<notin> {x. case (p, l, (l + r) / 2) of\n               (p, l, r) \\<Rightarrow>\n                 real_of_rat l \\<le> x \\<and>\n                 x \\<le> real_of_rat r \\<and>\n                 poly (real_of_int_poly p) x = 0}\n  real_of_rat ((l + r) / 2)\n  \\<notin> {x. case (p, (l + r) / 2, r) of\n               (p, l, r) \\<Rightarrow>\n                 real_of_rat l \\<le> x \\<and>\n                 x \\<le> real_of_rat r \\<and>\n                 poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. {x. case (p, (l + r) / 2, r) of\n        (p, l, r) \\<Rightarrow>\n          real_of_rat l \\<le> x \\<and>\n          x \\<le> real_of_rat r \\<and>\n          poly (real_of_int_poly p) x = 0} \\<inter>\n    {x. case (p, l, (l + r) / 2) of\n        (p, l, r) \\<Rightarrow>\n          real_of_rat l \\<le> x \\<and>\n          x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0} =\n    {}", "by auto"], ["proof (state)\nthis:\n  rts ((l + r) / 2, r) \\<inter> rts (l, (l + r) / 2) = {}\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have disj3: \"(rts (l,?m) \\<union> rts (?m,r)) = rts (l,r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rts (l, (l + r) / 2) \\<union> rts ((l + r) / 2, r) = rts (l, r)", "unfolding rts_def root_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. case (p, l, (l + r) / 2) of\n        (p, l, r) \\<Rightarrow>\n          real_of_rat l \\<le> x \\<and>\n          x \\<le> real_of_rat r \\<and>\n          poly (real_of_int_poly p) x = 0} \\<union>\n    {x. case (p, (l + r) / 2, r) of\n        (p, l, r) \\<Rightarrow>\n          real_of_rat l \\<le> x \\<and>\n          x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0} =\n    {x. case (p, l, r) of\n        (p, l, r) \\<Rightarrow>\n          real_of_rat l \\<le> x \\<and>\n          x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0}", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  rts (l, (l + r) / 2) \\<union> rts ((l + r) / 2, r) = rts (l, r)\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have disj4: \"real_of_2 ` set rais \\<inter> rts (l,r) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set rais \\<inter> rts (l, r) = {}", "using disj"], ["proof (prove)\nusing this:\n  pairwise_disjoint (real_of_2 ` set rais # map rts lrss)\n\ngoal (1 subgoal):\n 1. real_of_2 ` set rais \\<inter> rts (l, r) = {}", "unfolding Cons lr'"], ["proof (prove)\nusing this:\n  pairwise_disjoint (real_of_2 ` set rais # map rts ((l, r) # lrs))\n\ngoal (1 subgoal):\n 1. real_of_2 ` set rais \\<inter> rts (l, r) = {}", "by auto"], ["proof (state)\nthis:\n  real_of_2 ` set rais \\<inter> rts (l, r) = {}\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have disj: \"pairwise_disjoint (real_of_2 ` set rais # map rts ([(?m, r), (l, ?m)] @ lrs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise_disjoint\n     (real_of_2 ` set rais #\n      map rts ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs))", "using disj disj2 disj3 disj4"], ["proof (prove)\nusing this:\n  pairwise_disjoint (real_of_2 ` set rais # map rts lrss)\n  rts ((l + r) / 2, r) \\<inter> rts (l, (l + r) / 2) = {}\n  rts (l, (l + r) / 2) \\<union> rts ((l + r) / 2, r) = rts (l, r)\n  real_of_2 ` set rais \\<inter> rts (l, r) = {}\n\ngoal (1 subgoal):\n 1. pairwise_disjoint\n     (real_of_2 ` set rais #\n      map rts ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs))", "by (auto simp: Cons lr')"], ["proof (state)\nthis:\n  pairwise_disjoint\n   (real_of_2 ` set rais #\n    map rts ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have \"(?lrs,lrss) \\<in> rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs, lrss) \\<in> rel", "proof (rule rel, intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l' r'.\n       (l', r')\n       \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)] \\<Longrightarrow>\n       l' \\<le> r'\n 2. \\<And>l' r'.\n       (l', r')\n       \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)] \\<Longrightarrow>\n       delta_gt delta (real_of_rat r - real_of_rat l)\n        (real_of_rat r' - real_of_rat l')", "fix l' r'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l' r'.\n       (l', r')\n       \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)] \\<Longrightarrow>\n       l' \\<le> r'\n 2. \\<And>l' r'.\n       (l', r')\n       \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)] \\<Longrightarrow>\n       delta_gt delta (real_of_rat r - real_of_rat l)\n        (real_of_rat r' - real_of_rat l')", "assume mem: \"(l', r') \\<in> set [(?m,r),(l,?m)]\""], ["proof (state)\nthis:\n  (l', r') \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)]\n\ngoal (2 subgoals):\n 1. \\<And>l' r'.\n       (l', r')\n       \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)] \\<Longrightarrow>\n       l' \\<le> r'\n 2. \\<And>l' r'.\n       (l', r')\n       \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)] \\<Longrightarrow>\n       delta_gt delta (real_of_rat r - real_of_rat l)\n        (real_of_rat r' - real_of_rat l')", "from mem lr"], ["proof (chain)\npicking this:\n  (l', r') \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)]\n  l \\<le> r", "show \"l' \\<le> r'\""], ["proof (prove)\nusing this:\n  (l', r') \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)]\n  l \\<le> r\n\ngoal (1 subgoal):\n 1. l' \\<le> r'", "by auto"], ["proof (state)\nthis:\n  l' \\<le> r'\n\ngoal (1 subgoal):\n 1. \\<And>l' r'.\n       (l', r')\n       \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)] \\<Longrightarrow>\n       delta_gt delta (real_of_rat r - real_of_rat l)\n        (real_of_rat r' - real_of_rat l')", "from mem"], ["proof (chain)\npicking this:\n  (l', r') \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)]", "have diff: \"?r r' - ?r l' = (?r r - ?r l) / 2\""], ["proof (prove)\nusing this:\n  (l', r') \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)]\n\ngoal (1 subgoal):\n 1. real_of_rat r' - real_of_rat l' = (real_of_rat r - real_of_rat l) / 2", "by auto \n               (metis eq_diff_eq minus_diff_eq mult_2_right of_rat_add of_rat_diff,\n                metis of_rat_add of_rat_mult of_rat_numeral_eq)"], ["proof (state)\nthis:\n  real_of_rat r' - real_of_rat l' = (real_of_rat r - real_of_rat l) / 2\n\ngoal (1 subgoal):\n 1. \\<And>l' r'.\n       (l', r')\n       \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)] \\<Longrightarrow>\n       delta_gt delta (real_of_rat r - real_of_rat l)\n        (real_of_rat r' - real_of_rat l')", "show \"delta_gt delta (?r r - ?r l) (?r r' - ?r l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delta_gt delta (real_of_rat r - real_of_rat l)\n     (real_of_rat r' - real_of_rat l')", "unfolding diff\n                delta_gt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. delta\n    \\<le> real_of_rat r - real_of_rat l -\n          (real_of_rat r - real_of_rat l) / 2", "by (rule order.trans[OF delta], insert lr, \n                auto simp: field_simps of_rat_diff of_rat_less_eq)"], ["proof (state)\nthis:\n  delta_gt delta (real_of_rat r - real_of_rat l)\n   (real_of_rat r' - real_of_rat l')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs, lrss) \\<in> rel\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "note IH = IH[OF this, of rais, OF rais lrs disj]"], ["proof (state)\nthis:\n  (\\<And>x xa.\n      (x, xa)\n      \\<in> set ([((l + r) / 2, r), (l, (l + r) / 2)] @\n                 lrs) \\<Longrightarrow>\n      (x, xa)\n      \\<in> set ([((l + r) / 2, r), (l, (l + r) / 2)] @\n                 lrs)) \\<Longrightarrow>\n  real_of_2 `\n  set (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n        rais) =\n  real_of_2 ` set rais \\<union>\n  {x. \\<exists>la ra.\n         root_cond (p, la, ra) x \\<and>\n         (la, ra)\n         \\<in> set ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)} \\<and>\n  Ball\n   (set (roots_of_2_main p ri cr\n          ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais))\n   invariant_2 \\<and>\n  distinct\n   (map real_of_2\n     (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n       rais))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have \"real_of_2 ` set (?main ?lrs rais) =\n              real_of_2 ` set rais \\<union> ?rt ?lrs \\<and>\n              Ball (set (?main ?lrs rais)) invariant_2 \\<and> distinct (map real_of_2 (?main ?lrs rais))\"\n              (is \"?one \\<and> ?two\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 `\n    set (roots_of_2_main p ri cr\n          ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>la ra.\n           root_cond (p, la, ra) x \\<and>\n           (la, ra)\n           \\<in> set ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)} \\<and>\n    Ball\n     (set (roots_of_2_main p ri cr\n            ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais))\n     invariant_2 \\<and>\n    distinct\n     (map real_of_2\n       (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n         rais))", "by (rule IH)"], ["proof (state)\nthis:\n  real_of_2 `\n  set (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n        rais) =\n  real_of_2 ` set rais \\<union>\n  {x. \\<exists>la ra.\n         root_cond (p, la, ra) x \\<and>\n         (la, ra)\n         \\<in> set ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)} \\<and>\n  Ball\n   (set (roots_of_2_main p ri cr\n          ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais))\n   invariant_2 \\<and>\n  distinct\n   (map real_of_2\n     (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n       rais))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "hence ?one ?two"], ["proof (prove)\nusing this:\n  real_of_2 `\n  set (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n        rais) =\n  real_of_2 ` set rais \\<union>\n  {x. \\<exists>la ra.\n         root_cond (p, la, ra) x \\<and>\n         (la, ra)\n         \\<in> set ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)} \\<and>\n  Ball\n   (set (roots_of_2_main p ri cr\n          ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais))\n   invariant_2 \\<and>\n  distinct\n   (map real_of_2\n     (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n       rais))\n\ngoal (1 subgoal):\n 1. real_of_2 `\n    set (roots_of_2_main p ri cr\n          ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>la ra.\n           root_cond (p, la, ra) x \\<and>\n           (la, ra)\n           \\<in> set ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)} &&&\n    Ball\n     (set (roots_of_2_main p ri cr\n            ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais))\n     invariant_2 \\<and>\n    distinct\n     (map real_of_2\n       (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n         rais))", "by blast+"], ["proof (state)\nthis:\n  real_of_2 `\n  set (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n        rais) =\n  real_of_2 ` set rais \\<union>\n  {x. \\<exists>la ra.\n         root_cond (p, la, ra) x \\<and>\n         (la, ra) \\<in> set ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)}\n  Ball\n   (set (roots_of_2_main p ri cr\n          ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais))\n   invariant_2 \\<and>\n  distinct\n   (map real_of_2\n     (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n       rais))\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have cong: \"\\<And> a b c. b = c \\<Longrightarrow> a \\<union> b = a \\<union> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. b = c \\<Longrightarrow> a \\<union> b = a \\<union> c", "by auto"], ["proof (state)\nthis:\n  ?b = ?c \\<Longrightarrow> ?a \\<union> ?b = ?a \\<union> ?c\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "have id: \"?rt ?lrs = ?rt lrs \\<union> ?rt [(?m,r),(l,?m)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>la ra.\n           root_cond (p, la, ra) x \\<and>\n           (la, ra)\n           \\<in> set ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)} =\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<union>\n    {x. \\<exists>la ra.\n           root_cond (p, la, ra) x \\<and>\n           (la, ra) \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)]}", "by auto"], ["proof (state)\nthis:\n  {x. \\<exists>la ra.\n         root_cond (p, la, ra) x \\<and>\n         (la, ra) \\<in> set ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)} =\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<union>\n  {x. \\<exists>la ra.\n         root_cond (p, la, ra) x \\<and>\n         (la, ra) \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)]}\n\ngoal (1 subgoal):\n 1. c \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n    real_of_2 ` set rais \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n        invariant_2 a) \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))", "unfolding rts simp \\<open>?one\\<close> id"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set rais \\<union>\n    ({x. \\<exists>l r.\n            root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<union>\n     {x. \\<exists>la ra.\n            root_cond (p, la, ra) x \\<and>\n            (la, ra) \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)]}) =\n    real_of_2 ` set rais \\<union>\n    ({x. \\<exists>l r.\n            root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrs} \\<union>\n     Collect (root_cond (p, l, r))) \\<and>\n    (\\<forall>a\\<in>set (roots_of_2_main p ri cr\n                          ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n                          rais).\n        invariant_2 a) \\<and>\n    distinct\n     (map real_of_2\n       (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n         rais))", "proof (rule conjI[OF cong[OF cong] conjI])"], ["proof (state)\ngoal (3 subgoals):\n 1. {x. \\<exists>la ra.\n           root_cond (p, la, ra) x \\<and>\n           (la, ra) \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)]} =\n    Collect (root_cond (p, l, r))\n 2. \\<forall>a\\<in>set (roots_of_2_main p ri cr\n                         ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais).\n       invariant_2 a\n 3. distinct\n     (map real_of_2\n       (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n         rais))", "have \"\\<And> x. root_cond (p,l,r) x = (root_cond (p,l,?m) x \\<or> root_cond (p,?m,r) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       root_cond (p, l, r) x =\n       (root_cond (p, l, (l + r) / 2) x \\<or>\n        root_cond (p, (l + r) / 2, r) x)", "unfolding root_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case (p, l, r) of\n        (p, l, r) \\<Rightarrow>\n          real_of_rat l \\<le> x \\<and>\n          x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0) =\n       ((case (p, l, (l + r) / 2) of\n         (p, l, r) \\<Rightarrow>\n           real_of_rat l \\<le> x \\<and>\n           x \\<le> real_of_rat r \\<and>\n           poly (real_of_int_poly p) x = 0) \\<or>\n        (case (p, (l + r) / 2, r) of\n         (p, l, r) \\<Rightarrow>\n           real_of_rat l \\<le> x \\<and>\n           x \\<le> real_of_rat r \\<and> poly (real_of_int_poly p) x = 0))", "by (auto simp:hom_distribs)"], ["proof (state)\nthis:\n  root_cond (p, l, r) ?x1 =\n  (root_cond (p, l, (l + r) / 2) ?x1 \\<or>\n   root_cond (p, (l + r) / 2, r) ?x1)\n\ngoal (3 subgoals):\n 1. {x. \\<exists>la ra.\n           root_cond (p, la, ra) x \\<and>\n           (la, ra) \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)]} =\n    Collect (root_cond (p, l, r))\n 2. \\<forall>a\\<in>set (roots_of_2_main p ri cr\n                         ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais).\n       invariant_2 a\n 3. distinct\n     (map real_of_2\n       (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n         rais))", "hence id: \"Collect (root_cond (p,l,r)) = {x. (root_cond (p,l,?m) x \\<or> root_cond (p,?m,r) x)}\""], ["proof (prove)\nusing this:\n  root_cond (p, l, r) ?x1 =\n  (root_cond (p, l, (l + r) / 2) ?x1 \\<or>\n   root_cond (p, (l + r) / 2, r) ?x1)\n\ngoal (1 subgoal):\n 1. Collect (root_cond (p, l, r)) =\n    {x. root_cond (p, l, (l + r) / 2) x \\<or>\n        root_cond (p, (l + r) / 2, r) x}", "by auto"], ["proof (state)\nthis:\n  Collect (root_cond (p, l, r)) =\n  {x. root_cond (p, l, (l + r) / 2) x \\<or> root_cond (p, (l + r) / 2, r) x}\n\ngoal (3 subgoals):\n 1. {x. \\<exists>la ra.\n           root_cond (p, la, ra) x \\<and>\n           (la, ra) \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)]} =\n    Collect (root_cond (p, l, r))\n 2. \\<forall>a\\<in>set (roots_of_2_main p ri cr\n                         ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais).\n       invariant_2 a\n 3. distinct\n     (map real_of_2\n       (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n         rais))", "show \"?rt [(?m,r),(l,?m)] = Collect (root_cond (p,l,r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>la ra.\n           root_cond (p, la, ra) x \\<and>\n           (la, ra) \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)]} =\n    Collect (root_cond (p, l, r))", "unfolding id list.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<exists>la ra.\n           root_cond (p, la, ra) x \\<and>\n           (la, ra) \\<in> {((l + r) / 2, r), (l, (l + r) / 2)}} =\n    {x. root_cond (p, l, (l + r) / 2) x \\<or>\n        root_cond (p, (l + r) / 2, r) x}", "by blast"], ["proof (state)\nthis:\n  {x. \\<exists>la ra.\n         root_cond (p, la, ra) x \\<and>\n         (la, ra) \\<in> set [((l + r) / 2, r), (l, (l + r) / 2)]} =\n  Collect (root_cond (p, l, r))\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>set (roots_of_2_main p ri cr\n                         ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais).\n       invariant_2 a\n 2. distinct\n     (map real_of_2\n       (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n         rais))", "show \"\\<forall> a \\<in> set (?main ?lrs rais). invariant_2 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (roots_of_2_main p ri cr\n                         ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais).\n       invariant_2 a", "using \\<open>?two\\<close>"], ["proof (prove)\nusing this:\n  Ball\n   (set (roots_of_2_main p ri cr\n          ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais))\n   invariant_2 \\<and>\n  distinct\n   (map real_of_2\n     (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n       rais))\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (roots_of_2_main p ri cr\n                         ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais).\n       invariant_2 a", "by auto"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (roots_of_2_main p ri cr\n                       ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais).\n     invariant_2 a\n\ngoal (1 subgoal):\n 1. distinct\n     (map real_of_2\n       (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n         rais))", "show \"distinct (map real_of_2 (?main ?lrs rais))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map real_of_2\n       (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n         rais))", "using \\<open>?two\\<close>"], ["proof (prove)\nusing this:\n  Ball\n   (set (roots_of_2_main p ri cr\n          ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs) rais))\n   invariant_2 \\<and>\n  distinct\n   (map real_of_2\n     (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n       rais))\n\ngoal (1 subgoal):\n 1. distinct\n     (map real_of_2\n       (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n         rais))", "by auto"], ["proof (state)\nthis:\n  distinct\n   (map real_of_2\n     (roots_of_2_main p ri cr ([((l + r) / 2, r), (l, (l + r) / 2)] @ lrs)\n       rais))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n  real_of_2 ` set rais \\<union>\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n  (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n      invariant_2 a) \\<and>\n  distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n  real_of_2 ` set rais \\<union>\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n  (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n      invariant_2 a) \\<and>\n  distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n  real_of_2 ` set rais \\<union>\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n  (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n      invariant_2 a) \\<and>\n  distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2_main p ri cr lrss rais) =\n  real_of_2 ` set rais \\<union>\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set lrss} \\<and>\n  (\\<forall>a\\<in>set (roots_of_2_main p ri cr lrss rais).\n      invariant_2 a) \\<and>\n  distinct (map real_of_2 (roots_of_2_main p ri cr lrss rais))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2_main p ri cr bnds empty) =\n  real_of_2 ` set empty \\<union>\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds} \\<and>\n  Ball (set (roots_of_2_main p ri cr bnds empty)) invariant_2 \\<and>\n  distinct (map real_of_2 (roots_of_2_main p ri cr bnds empty))\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "hence idd: \"?one'\" and cond: ?two' ?three'"], ["proof (prove)\nusing this:\n  real_of_2 ` set (roots_of_2_main p ri cr bnds empty) =\n  real_of_2 ` set empty \\<union>\n  {x. \\<exists>l r.\n         root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds} \\<and>\n  Ball (set (roots_of_2_main p ri cr bnds empty)) invariant_2 \\<and>\n  distinct (map real_of_2 (roots_of_2_main p ri cr bnds empty))\n\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr bnds empty) =\n    real_of_2 ` set empty \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds} &&&\n    Ball (set (roots_of_2_main p ri cr bnds empty)) invariant_2 &&&\n    distinct (map real_of_2 (roots_of_2_main p ri cr bnds empty))", "by blast+"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2_main p ri cr bnds empty) =\n  real_of_2 ` set empty \\<union>\n  {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds}\n  Ball (set (roots_of_2_main p ri cr bnds empty)) invariant_2\n  distinct (map real_of_2 (roots_of_2_main p ri cr bnds empty))\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "define res where \"res = roots_of_2_main p ri cr bnds empty\""], ["proof (state)\nthis:\n  res = roots_of_2_main p ri cr bnds empty\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "have e: \"set empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set empty = {}", "unfolding empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set [] = {}", "by auto"], ["proof (state)\nthis:\n  set empty = {}\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "from idd[folded res_def] e"], ["proof (chain)\npicking this:\n  real_of_2 ` set res =\n  real_of_2 ` set empty \\<union>\n  {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds}\n  set empty = {}", "have idd: \"real_of_2 ` set res = {} \\<union> {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds}\""], ["proof (prove)\nusing this:\n  real_of_2 ` set res =\n  real_of_2 ` set empty \\<union>\n  {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds}\n  set empty = {}\n\ngoal (1 subgoal):\n 1. real_of_2 ` set res =\n    {} \\<union>\n    {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds}", "by auto"], ["proof (state)\nthis:\n  real_of_2 ` set res =\n  {} \\<union>\n  {x. \\<exists>l r. root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds}\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_irr p))", "unfolding rr"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr bnds empty) =\n    {x. poly (real_of_int_poly p) x = 0} \\<and>\n    Ball (set (roots_of_2_main p ri cr bnds empty)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr bnds empty))", "unfolding rts id e norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr bnds empty) =\n    real_of_2 ` {} \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds} \\<and>\n    Ball (set (roots_of_2_main p ri cr bnds empty)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr bnds empty))", "using cond"], ["proof (prove)\nusing this:\n  Ball (set (roots_of_2_main p ri cr bnds empty)) invariant_2\n  distinct (map real_of_2 (roots_of_2_main p ri cr bnds empty))\n\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_main p ri cr bnds empty) =\n    real_of_2 ` {} \\<union>\n    {x. \\<exists>l r.\n           root_cond (p, l, r) x \\<and> (l, r) \\<in> set bnds} \\<and>\n    Ball (set (roots_of_2_main p ri cr bnds empty)) invariant_2 \\<and>\n    distinct (map real_of_2 (roots_of_2_main p ri cr bnds empty))", "unfolding res_def[symmetric] image_empty e idd[symmetric]"], ["proof (prove)\nusing this:\n  Ball (set res) invariant_2\n  distinct (map real_of_2 res)\n\ngoal (1 subgoal):\n 1. real_of_2 ` set res = real_of_2 ` set res \\<and>\n    Ball (set res) invariant_2 \\<and> distinct (map real_of_2 res)", "by auto"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2_irr p) =\n  {x. poly (real_of_int_poly p) x = 0} \\<and>\n  Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n  distinct (map real_of_2 (roots_of_2_irr p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2_irr p) =\n  {x. poly (real_of_int_poly p) x = 0} \\<and>\n  Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n  distinct (map real_of_2 (roots_of_2_irr p))\n\ngoal (3 subgoals):\n 1. real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2_irr p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2_irr p))", "thus ?one ?two ?three"], ["proof (prove)\nusing this:\n  real_of_2 ` set (roots_of_2_irr p) =\n  {x. poly (real_of_int_poly p) x = 0} \\<and>\n  Ball (set (roots_of_2_irr p)) invariant_2 \\<and>\n  distinct (map real_of_2 (roots_of_2_irr p))\n\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2_irr p) =\n    {x. poly (real_of_int_poly p) x = 0} &&&\n    Ball (set (roots_of_2_irr p)) invariant_2 &&&\n    distinct (map real_of_2 (roots_of_2_irr p))", "by blast+"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2_irr p) = {x. poly (real_of_int_poly p) x = 0}\n  Ball (set (roots_of_2_irr p)) invariant_2\n  distinct (map real_of_2 (roots_of_2_irr p))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition roots_of_2 :: \"int poly \\<Rightarrow> real_alg_2 list\" where\n  \"roots_of_2 p = concat (map roots_of_2_irr \n     (factors_of_int_poly p))\""], ["", "lemma roots_of_2:\n  shows \"p \\<noteq> 0 \\<Longrightarrow> real_of_2 ` set (roots_of_2 p) = {x. ipoly p x = 0}\"\n    \"Ball (set (roots_of_2 p)) invariant_2\"\n    \"distinct (map real_of_2 (roots_of_2 p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<Longrightarrow>\n     real_of_2 ` set (roots_of_2 p) =\n     {x. poly (real_of_int_poly p) x = 0}) &&&\n    Ball (set (roots_of_2 p)) invariant_2 &&&\n    distinct (map real_of_2 (roots_of_2 p))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2 p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2 p))", "let ?rr = \"roots_of_2 p\""], ["proof (state)\ngoal (3 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2 p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2 p))", "note d = roots_of_2_def"], ["proof (state)\nthis:\n  roots_of_2 ?p = concat (map roots_of_2_irr (factors_of_int_poly ?p))\n\ngoal (3 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2 p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2 p))", "note frp1 = factors_of_int_poly"], ["proof (state)\nthis:\n  \\<lbrakk>factors_of_int_poly ?p = ?qs; ?q \\<in> set ?qs\\<rbrakk>\n  \\<Longrightarrow> irreducible ?q \\<and>\n                    0 < lead_coeff ?q \\<and>\n                    degree ?q \\<le> degree ?p \\<and> degree ?q \\<noteq> 0\n  \\<lbrakk>factors_of_int_poly ?p = ?qs; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (ipoly ?p ?x = (0::?'a)) =\n                    (\\<exists>q\\<in>set ?qs. ipoly q ?x = (0::?'a))\n  \\<lbrakk>factors_of_int_poly ?p = ?qs; ?p \\<noteq> 0;\n   ipoly ?p ?x = (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!q.\n                       q \\<in> set ?qs \\<and> ipoly q ?x = (0::?'a)\n  factors_of_int_poly ?p = ?qs \\<Longrightarrow> distinct ?qs\n\ngoal (3 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2 p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2 p))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>factors_of_int_poly ?p = ?qs; ?q \\<in> set ?qs\\<rbrakk>\n  \\<Longrightarrow> irreducible ?q \\<and>\n                    0 < lead_coeff ?q \\<and>\n                    degree ?q \\<le> degree ?p \\<and> degree ?q \\<noteq> 0\n  \\<lbrakk>factors_of_int_poly ?p = ?qs; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (ipoly ?p ?x = (0::?'a)) =\n                    (\\<exists>q\\<in>set ?qs. ipoly q ?x = (0::?'a))\n  \\<lbrakk>factors_of_int_poly ?p = ?qs; ?p \\<noteq> 0;\n   ipoly ?p ?x = (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!q.\n                       q \\<in> set ?qs \\<and> ipoly q ?x = (0::?'a)\n  factors_of_int_poly ?p = ?qs \\<Longrightarrow> distinct ?qs\n\ngoal (3 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2 p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2 p))", "fix q r"], ["proof (state)\ngoal (3 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2 p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2 p))", "assume \"q \\<in> set ?rr\""], ["proof (state)\nthis:\n  q \\<in> set (roots_of_2 p)\n\ngoal (3 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2 p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2 p))", "then"], ["proof (chain)\npicking this:\n  q \\<in> set (roots_of_2 p)", "obtain s where \n      s: \"s \\<in> set (factors_of_int_poly p)\" and\n      q: \"q \\<in> set (roots_of_2_irr s)\""], ["proof (prove)\nusing this:\n  q \\<in> set (roots_of_2 p)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> set (factors_of_int_poly p);\n         q \\<in> set (roots_of_2_irr s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding d"], ["proof (prove)\nusing this:\n  q \\<in> set (concat (map roots_of_2_irr (factors_of_int_poly p)))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> set (factors_of_int_poly p);\n         q \\<in> set (roots_of_2_irr s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<in> set (factors_of_int_poly p)\n  q \\<in> set (roots_of_2_irr s)\n\ngoal (3 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2 p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2 p))", "from frp1(1)[OF refl s]"], ["proof (chain)\npicking this:\n  irreducible s \\<and>\n  0 < lead_coeff s \\<and> degree s \\<le> degree p \\<and> degree s \\<noteq> 0", "have \"poly_cond s\" \"degree s > 0\""], ["proof (prove)\nusing this:\n  irreducible s \\<and>\n  0 < lead_coeff s \\<and> degree s \\<le> degree p \\<and> degree s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_cond s &&& 0 < degree s", "by (auto simp: poly_cond_def)"], ["proof (state)\nthis:\n  poly_cond s\n  0 < degree s\n\ngoal (3 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2 p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2 p))", "from roots_of_2_irr[OF this] q"], ["proof (chain)\npicking this:\n  real_of_2 ` set (roots_of_2_irr s) = {x. poly (real_of_int_poly s) x = 0}\n  Ball (set (roots_of_2_irr s)) invariant_2\n  distinct (map real_of_2 (roots_of_2_irr s))\n  q \\<in> set (roots_of_2_irr s)", "have \"invariant_2 q\""], ["proof (prove)\nusing this:\n  real_of_2 ` set (roots_of_2_irr s) = {x. poly (real_of_int_poly s) x = 0}\n  Ball (set (roots_of_2_irr s)) invariant_2\n  distinct (map real_of_2 (roots_of_2_irr s))\n  q \\<in> set (roots_of_2_irr s)\n\ngoal (1 subgoal):\n 1. invariant_2 q", "by auto"], ["proof (state)\nthis:\n  invariant_2 q\n\ngoal (3 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2 p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2 p))", "}"], ["proof (state)\nthis:\n  ?q2 \\<in> set (roots_of_2 p) \\<Longrightarrow> invariant_2 ?q2\n\ngoal (3 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. Ball (set (roots_of_2 p)) invariant_2\n 3. distinct (map real_of_2 (roots_of_2 p))", "thus \"Ball (set ?rr) invariant_2\""], ["proof (prove)\nusing this:\n  ?q2 \\<in> set (roots_of_2 p) \\<Longrightarrow> invariant_2 ?q2\n\ngoal (1 subgoal):\n 1. Ball (set (roots_of_2 p)) invariant_2", "by auto"], ["proof (state)\nthis:\n  Ball (set (roots_of_2 p)) invariant_2\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. distinct (map real_of_2 (roots_of_2 p))", "{"], ["proof (state)\nthis:\n  Ball (set (roots_of_2 p)) invariant_2\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. distinct (map real_of_2 (roots_of_2 p))", "assume p: \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. distinct (map real_of_2 (roots_of_2 p))", "have \"real_of_2 ` set ?rr = (\\<Union> ((\\<lambda> p. real_of_2 ` set (roots_of_2_irr p)) ` \n      (set (factors_of_int_poly p))))\"\n      (is \"_ = ?rrr\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2 p) =\n    (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p))", "unfolding d set_concat set_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 `\n    \\<Union> (set ` roots_of_2_irr ` set (factors_of_int_poly p)) =\n    (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p))", "by auto"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2 p) =\n  (\\<Union>p\\<in>set (factors_of_int_poly p).\n      real_of_2 ` set (roots_of_2_irr p))\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. distinct (map real_of_2 (roots_of_2 p))", "also"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2 p) =\n  (\\<Union>p\\<in>set (factors_of_int_poly p).\n      real_of_2 ` set (roots_of_2_irr p))\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. distinct (map real_of_2 (roots_of_2 p))", "have \"\\<dots> = {x. ipoly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "assume \"x \\<in> ?rrr\""], ["proof (state)\nthis:\n  x \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n              real_of_2 ` set (roots_of_2_irr p))\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n              real_of_2 ` set (roots_of_2_irr p))", "obtain q s where \n          s: \"s \\<in> set (factors_of_int_poly p)\" and\n          q: \"q \\<in> set (roots_of_2_irr s)\" and\n          x: \"x = real_of_2 q\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n              real_of_2 ` set (roots_of_2_irr p))\n\ngoal (1 subgoal):\n 1. (\\<And>s q.\n        \\<lbrakk>s \\<in> set (factors_of_int_poly p);\n         q \\<in> set (roots_of_2_irr s); x = real_of_2 q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<in> set (factors_of_int_poly p)\n  q \\<in> set (roots_of_2_irr s)\n  x = real_of_2 q\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "from frp1(1)[OF refl s]"], ["proof (chain)\npicking this:\n  irreducible s \\<and>\n  0 < lead_coeff s \\<and> degree s \\<le> degree p \\<and> degree s \\<noteq> 0", "have s0: \"s \\<noteq> 0\" and pt: \"poly_cond s\" \"degree s > 0\""], ["proof (prove)\nusing this:\n  irreducible s \\<and>\n  0 < lead_coeff s \\<and> degree s \\<le> degree p \\<and> degree s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 &&& poly_cond s &&& 0 < degree s", "by (auto simp: poly_cond_def)"], ["proof (state)\nthis:\n  s \\<noteq> 0\n  poly_cond s\n  0 < degree s\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "from roots_of_2_irr[OF pt] q"], ["proof (chain)\npicking this:\n  real_of_2 ` set (roots_of_2_irr s) = {x. poly (real_of_int_poly s) x = 0}\n  Ball (set (roots_of_2_irr s)) invariant_2\n  distinct (map real_of_2 (roots_of_2_irr s))\n  q \\<in> set (roots_of_2_irr s)", "have rt: \"ipoly s x = 0\""], ["proof (prove)\nusing this:\n  real_of_2 ` set (roots_of_2_irr s) = {x. poly (real_of_int_poly s) x = 0}\n  Ball (set (roots_of_2_irr s)) invariant_2\n  distinct (map real_of_2 (roots_of_2_irr s))\n  q \\<in> set (roots_of_2_irr s)\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly s) x = 0", "unfolding x"], ["proof (prove)\nusing this:\n  real_of_2 ` set (roots_of_2_irr s) = {x. poly (real_of_int_poly s) x = 0}\n  Ball (set (roots_of_2_irr s)) invariant_2\n  distinct (map real_of_2 (roots_of_2_irr s))\n  q \\<in> set (roots_of_2_irr s)\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly s) (real_of_2 q) = 0", "by auto"], ["proof (state)\nthis:\n  poly (real_of_int_poly s) x = 0\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "from frp1(2)[OF refl p, of x] rt s"], ["proof (chain)\npicking this:\n  (poly (real_of_int_poly p) x = 0) =\n  (\\<exists>q\\<in>set (factors_of_int_poly p).\n      poly (real_of_int_poly q) x = 0)\n  poly (real_of_int_poly s) x = 0\n  s \\<in> set (factors_of_int_poly p)", "have rt: \"ipoly p x = 0\""], ["proof (prove)\nusing this:\n  (poly (real_of_int_poly p) x = 0) =\n  (\\<exists>q\\<in>set (factors_of_int_poly p).\n      poly (real_of_int_poly q) x = 0)\n  poly (real_of_int_poly s) x = 0\n  s \\<in> set (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0", "by auto"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "}"], ["proof (state)\nthis:\n  ?x2\n  \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n            real_of_2 ` set (roots_of_2_irr p)) \\<Longrightarrow>\n  poly (real_of_int_poly p) ?x2 = 0\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "moreover"], ["proof (state)\nthis:\n  ?x2\n  \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n            real_of_2 ` set (roots_of_2_irr p)) \\<Longrightarrow>\n  poly (real_of_int_poly p) ?x2 = 0\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "{"], ["proof (state)\nthis:\n  ?x2\n  \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n            real_of_2 ` set (roots_of_2_irr p)) \\<Longrightarrow>\n  poly (real_of_int_poly p) ?x2 = 0\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "fix x :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "assume rt: \"ipoly p x = 0\""], ["proof (state)\nthis:\n  poly (real_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "from rt frp1(2)[OF refl p, of x]"], ["proof (chain)\npicking this:\n  poly (real_of_int_poly p) x = 0\n  (poly (real_of_int_poly p) x = 0) =\n  (\\<exists>q\\<in>set (factors_of_int_poly p).\n      poly (real_of_int_poly q) x = 0)", "obtain s where s: \"s \\<in> set (factors_of_int_poly p)\" \n          and rt: \"ipoly s x = 0\""], ["proof (prove)\nusing this:\n  poly (real_of_int_poly p) x = 0\n  (poly (real_of_int_poly p) x = 0) =\n  (\\<exists>q\\<in>set (factors_of_int_poly p).\n      poly (real_of_int_poly q) x = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> set (factors_of_int_poly p);\n         poly (real_of_int_poly s) x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<in> set (factors_of_int_poly p)\n  poly (real_of_int_poly s) x = 0\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "from frp1(1)[OF refl s]"], ["proof (chain)\npicking this:\n  irreducible s \\<and>\n  0 < lead_coeff s \\<and> degree s \\<le> degree p \\<and> degree s \\<noteq> 0", "have s0: \"s \\<noteq> 0\" and ty: \"poly_cond s\" \"degree s > 0\""], ["proof (prove)\nusing this:\n  irreducible s \\<and>\n  0 < lead_coeff s \\<and> degree s \\<le> degree p \\<and> degree s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 &&& poly_cond s &&& 0 < degree s", "by (auto simp: poly_cond_def)"], ["proof (state)\nthis:\n  s \\<noteq> 0\n  poly_cond s\n  0 < degree s\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "from roots_of_2_irr(1)[OF ty] rt"], ["proof (chain)\npicking this:\n  real_of_2 ` set (roots_of_2_irr s) = {x. poly (real_of_int_poly s) x = 0}\n  poly (real_of_int_poly s) x = 0", "obtain q where \n          q: \"q \\<in> set (roots_of_2_irr s)\" and\n          x: \"x = real_of_2 q\""], ["proof (prove)\nusing this:\n  real_of_2 ` set (roots_of_2_irr s) = {x. poly (real_of_int_poly s) x = 0}\n  poly (real_of_int_poly s) x = 0\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> set (roots_of_2_irr s); x = real_of_2 q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q \\<in> set (roots_of_2_irr s)\n  x = real_of_2 q\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "have \"x \\<in> ?rrr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n                real_of_2 ` set (roots_of_2_irr p))", "unfolding x"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_2 q\n    \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n              real_of_2 ` set (roots_of_2_irr p))", "using q s"], ["proof (prove)\nusing this:\n  q \\<in> set (roots_of_2_irr s)\n  s \\<in> set (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. real_of_2 q\n    \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n              real_of_2 ` set (roots_of_2_irr p))", "by auto"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n              real_of_2 ` set (roots_of_2_irr p))\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "}"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) ?x2 = 0 \\<Longrightarrow>\n  ?x2\n  \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n            real_of_2 ` set (roots_of_2_irr p))\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "ultimately"], ["proof (chain)\npicking this:\n  ?x2\n  \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n            real_of_2 ` set (roots_of_2_irr p)) \\<Longrightarrow>\n  poly (real_of_int_poly p) ?x2 = 0\n  poly (real_of_int_poly p) ?x2 = 0 \\<Longrightarrow>\n  ?x2\n  \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n            real_of_2 ` set (roots_of_2_irr p))", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x2\n  \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n            real_of_2 ` set (roots_of_2_irr p)) \\<Longrightarrow>\n  poly (real_of_int_poly p) ?x2 = 0\n  poly (real_of_int_poly p) ?x2 = 0 \\<Longrightarrow>\n  ?x2\n  \\<in> (\\<Union>p\\<in>set (factors_of_int_poly p).\n            real_of_2 ` set (roots_of_2_irr p))\n\ngoal (1 subgoal):\n 1. (\\<Union>p\\<in>set (factors_of_int_poly p).\n        real_of_2 ` set (roots_of_2_irr p)) =\n    {x. poly (real_of_int_poly p) x = 0}", "by auto"], ["proof (state)\nthis:\n  (\\<Union>p\\<in>set (factors_of_int_poly p).\n      real_of_2 ` set (roots_of_2_irr p)) =\n  {x. poly (real_of_int_poly p) x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>p\\<in>set (factors_of_int_poly p).\n      real_of_2 ` set (roots_of_2_irr p)) =\n  {x. poly (real_of_int_poly p) x = 0}\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. distinct (map real_of_2 (roots_of_2 p))", "finally"], ["proof (chain)\npicking this:\n  real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}", "show \"real_of_2 ` set ?rr = {x. ipoly p x = 0}\""], ["proof (prove)\nusing this:\n  real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}", "by auto"], ["proof (state)\nthis:\n  real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. distinct (map real_of_2 (roots_of_2 p))", "}"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  real_of_2 ` set (roots_of_2 p) = {x. poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. distinct (map real_of_2 (roots_of_2 p))", "show \"distinct (map real_of_2 (roots_of_2 p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map real_of_2 (roots_of_2 p))", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> distinct (map real_of_2 (roots_of_2 p))\n 2. p \\<noteq> 0 \\<Longrightarrow> distinct (map real_of_2 (roots_of_2 p))", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> distinct (map real_of_2 (roots_of_2 p))\n 2. p \\<noteq> 0 \\<Longrightarrow> distinct (map real_of_2 (roots_of_2 p))", "from factors_of_int_poly_const[of 0] True"], ["proof (chain)\npicking this:\n  degree 0 = 0 \\<Longrightarrow> factors_of_int_poly 0 = []\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  degree 0 = 0 \\<Longrightarrow> factors_of_int_poly 0 = []\n  p = 0\n\ngoal (1 subgoal):\n 1. distinct (map real_of_2 (roots_of_2 p))", "unfolding roots_of_2_def"], ["proof (prove)\nusing this:\n  degree 0 = 0 \\<Longrightarrow> factors_of_int_poly 0 = []\n  p = 0\n\ngoal (1 subgoal):\n 1. distinct\n     (map real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p))))", "by auto"], ["proof (state)\nthis:\n  distinct (map real_of_2 (roots_of_2 p))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> distinct (map real_of_2 (roots_of_2 p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> distinct (map real_of_2 (roots_of_2 p))", "case p: False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> distinct (map real_of_2 (roots_of_2 p))", "note frp1 = frp1[OF refl]"], ["proof (state)\nthis:\n  ?q \\<in> set (factors_of_int_poly ?p) \\<Longrightarrow>\n  irreducible ?q \\<and>\n  0 < lead_coeff ?q \\<and>\n  degree ?q \\<le> degree ?p \\<and> degree ?q \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  (ipoly ?p ?x = (0::?'a)) =\n  (\\<exists>q\\<in>set (factors_of_int_poly ?p). ipoly q ?x = (0::?'a))\n  \\<lbrakk>?p \\<noteq> 0; ipoly ?p ?x = (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!q.\n                       q \\<in> set (factors_of_int_poly ?p) \\<and>\n                       ipoly q ?x = (0::?'a)\n  distinct (factors_of_int_poly ?p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> distinct (map real_of_2 (roots_of_2 p))", "let ?fp = \"factors_of_int_poly p\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> distinct (map real_of_2 (roots_of_2 p))", "let ?cc = \"concat (map roots_of_2_irr ?fp)\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> distinct (map real_of_2 (roots_of_2 p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map real_of_2 (roots_of_2 p))", "unfolding roots_of_2_def distinct_conv_nth length_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (concat (map roots_of_2_irr (factors_of_int_poly p))).\n       \\<forall>j<length\n                   (concat (map roots_of_2_irr (factors_of_int_poly p))).\n          i \\<noteq> j \\<longrightarrow>\n          map real_of_2\n           (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n          i \\<noteq>\n          map real_of_2\n           (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n          j", "proof (intro allI impI notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        j < length (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        i \\<noteq> j;\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        i =\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        j\\<rbrakk>\n       \\<Longrightarrow> False", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        j < length (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        i \\<noteq> j;\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        i =\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        j\\<rbrakk>\n       \\<Longrightarrow> False", "assume ij: \"i < length ?cc\" \"j < length ?cc\" \"i \\<noteq> j\" and id: \"map real_of_2 ?cc ! i = map real_of_2 ?cc ! j\""], ["proof (state)\nthis:\n  i < length (concat (map roots_of_2_irr (factors_of_int_poly p)))\n  j < length (concat (map roots_of_2_irr (factors_of_int_poly p)))\n  i \\<noteq> j\n  map real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p))) ! i =\n  map real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p))) ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        j < length (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        i \\<noteq> j;\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        i =\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        j\\<rbrakk>\n       \\<Longrightarrow> False", "from ij id"], ["proof (chain)\npicking this:\n  i < length (concat (map roots_of_2_irr (factors_of_int_poly p)))\n  j < length (concat (map roots_of_2_irr (factors_of_int_poly p)))\n  i \\<noteq> j\n  map real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p))) ! i =\n  map real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p))) ! j", "have id: \"real_of_2 (?cc ! i) = real_of_2 (?cc ! j)\""], ["proof (prove)\nusing this:\n  i < length (concat (map roots_of_2_irr (factors_of_int_poly p)))\n  j < length (concat (map roots_of_2_irr (factors_of_int_poly p)))\n  i \\<noteq> j\n  map real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p))) ! i =\n  map real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p))) ! j\n\ngoal (1 subgoal):\n 1. real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! i) =\n    real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)", "by auto"], ["proof (state)\nthis:\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! i) =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        j < length (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        i \\<noteq> j;\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        i =\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        j\\<rbrakk>\n       \\<Longrightarrow> False", "from nth_concat_diff[OF ij, unfolded length_map]"], ["proof (chain)\npicking this:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length (factors_of_int_poly p) \\<and>\n     j2 < length (factors_of_int_poly p) \\<and>\n     k1 < length (map roots_of_2_irr (factors_of_int_poly p) ! j1) \\<and>\n     k2 < length (map roots_of_2_irr (factors_of_int_poly p) ! j2) \\<and>\n     concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n     map roots_of_2_irr (factors_of_int_poly p) ! j1 ! k1 \\<and>\n     concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n     map roots_of_2_irr (factors_of_int_poly p) ! j2 ! k2", "obtain j1 k1 j2 k2 where \n        *: \"(j1,k1) \\<noteq> (j2,k2)\"\n        \"j1 < length ?fp\" \"j2 < length ?fp\" and\n        \"k1 < length (map roots_of_2_irr ?fp ! j1)\"\n        \"k2 < length (map roots_of_2_irr ?fp ! j2)\"\n        \"?cc ! i = map roots_of_2_irr ?fp ! j1 ! k1\" \n        \"?cc ! j = map roots_of_2_irr ?fp ! j2 ! k2\""], ["proof (prove)\nusing this:\n  \\<exists>j1 k1 j2 k2.\n     (j1, k1) \\<noteq> (j2, k2) \\<and>\n     j1 < length (factors_of_int_poly p) \\<and>\n     j2 < length (factors_of_int_poly p) \\<and>\n     k1 < length (map roots_of_2_irr (factors_of_int_poly p) ! j1) \\<and>\n     k2 < length (map roots_of_2_irr (factors_of_int_poly p) ! j2) \\<and>\n     concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n     map roots_of_2_irr (factors_of_int_poly p) ! j1 ! k1 \\<and>\n     concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n     map roots_of_2_irr (factors_of_int_poly p) ! j2 ! k2\n\ngoal (1 subgoal):\n 1. (\\<And>j1 k1 j2 k2.\n        \\<lbrakk>(j1, k1) \\<noteq> (j2, k2);\n         j1 < length (factors_of_int_poly p);\n         j2 < length (factors_of_int_poly p);\n         k1 < length (map roots_of_2_irr (factors_of_int_poly p) ! j1);\n         k2 < length (map roots_of_2_irr (factors_of_int_poly p) ! j2);\n         concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n         map roots_of_2_irr (factors_of_int_poly p) ! j1 ! k1;\n         concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n         map roots_of_2_irr (factors_of_int_poly p) ! j2 ! k2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n  k1 < length (map roots_of_2_irr (factors_of_int_poly p) ! j1)\n  k2 < length (map roots_of_2_irr (factors_of_int_poly p) ! j2)\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n  map roots_of_2_irr (factors_of_int_poly p) ! j1 ! k1\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n  map roots_of_2_irr (factors_of_int_poly p) ! j2 ! k2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        j < length (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        i \\<noteq> j;\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        i =\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        j\\<rbrakk>\n       \\<Longrightarrow> False", "hence **: \"k1 < length (roots_of_2_irr (?fp ! j1))\" \n        \"k2 < length (roots_of_2_irr (?fp ! j2))\" \n        \"?cc ! i = roots_of_2_irr (?fp ! j1) ! k1\"\n        \"?cc ! j = roots_of_2_irr (?fp ! j2) ! k2\""], ["proof (prove)\nusing this:\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n  k1 < length (map roots_of_2_irr (factors_of_int_poly p) ! j1)\n  k2 < length (map roots_of_2_irr (factors_of_int_poly p) ! j2)\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n  map roots_of_2_irr (factors_of_int_poly p) ! j1 ! k1\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n  map roots_of_2_irr (factors_of_int_poly p) ! j2 ! k2\n\ngoal (1 subgoal):\n 1. (k1 < length (roots_of_2_irr (factors_of_int_poly p ! j1)) &&&\n     k2 < length (roots_of_2_irr (factors_of_int_poly p ! j2))) &&&\n    concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n    roots_of_2_irr (factors_of_int_poly p ! j1) ! k1 &&&\n    concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n    roots_of_2_irr (factors_of_int_poly p ! j2) ! k2", "by auto"], ["proof (state)\nthis:\n  k1 < length (roots_of_2_irr (factors_of_int_poly p ! j1))\n  k2 < length (roots_of_2_irr (factors_of_int_poly p ! j2))\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n  roots_of_2_irr (factors_of_int_poly p ! j1) ! k1\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n  roots_of_2_irr (factors_of_int_poly p ! j2) ! k2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        j < length (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        i \\<noteq> j;\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        i =\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        j\\<rbrakk>\n       \\<Longrightarrow> False", "from *"], ["proof (chain)\npicking this:\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)", "have mem: \"?fp ! j1 \\<in> set ?fp\" \"?fp ! j2 \\<in> set ?fp\""], ["proof (prove)\nusing this:\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. factors_of_int_poly p ! j1 \\<in> set (factors_of_int_poly p) &&&\n    factors_of_int_poly p ! j2 \\<in> set (factors_of_int_poly p)", "by auto"], ["proof (state)\nthis:\n  factors_of_int_poly p ! j1 \\<in> set (factors_of_int_poly p)\n  factors_of_int_poly p ! j2 \\<in> set (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        j < length (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        i \\<noteq> j;\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        i =\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        j\\<rbrakk>\n       \\<Longrightarrow> False", "from frp1(1)[OF mem(1)] frp1(1)[OF mem(2)]"], ["proof (chain)\npicking this:\n  irreducible (factors_of_int_poly p ! j1) \\<and>\n  0 < lead_coeff (factors_of_int_poly p ! j1) \\<and>\n  degree (factors_of_int_poly p ! j1) \\<le> degree p \\<and>\n  degree (factors_of_int_poly p ! j1) \\<noteq> 0\n  irreducible (factors_of_int_poly p ! j2) \\<and>\n  0 < lead_coeff (factors_of_int_poly p ! j2) \\<and>\n  degree (factors_of_int_poly p ! j2) \\<le> degree p \\<and>\n  degree (factors_of_int_poly p ! j2) \\<noteq> 0", "have pc1: \"poly_cond (?fp ! j1)\" \"degree (?fp ! j1) > 0\" and pc10: \"?fp ! j1 \\<noteq> 0\" \n        and pc2: \"poly_cond (?fp ! j2)\" \"degree (?fp ! j2) > 0\""], ["proof (prove)\nusing this:\n  irreducible (factors_of_int_poly p ! j1) \\<and>\n  0 < lead_coeff (factors_of_int_poly p ! j1) \\<and>\n  degree (factors_of_int_poly p ! j1) \\<le> degree p \\<and>\n  degree (factors_of_int_poly p ! j1) \\<noteq> 0\n  irreducible (factors_of_int_poly p ! j2) \\<and>\n  0 < lead_coeff (factors_of_int_poly p ! j2) \\<and>\n  degree (factors_of_int_poly p ! j2) \\<le> degree p \\<and>\n  degree (factors_of_int_poly p ! j2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (poly_cond (factors_of_int_poly p ! j1) &&&\n     0 < degree (factors_of_int_poly p ! j1)) &&&\n    factors_of_int_poly p ! j1 \\<noteq> 0 &&&\n    poly_cond (factors_of_int_poly p ! j2) &&&\n    0 < degree (factors_of_int_poly p ! j2)", "by (auto simp: poly_cond_def)"], ["proof (state)\nthis:\n  poly_cond (factors_of_int_poly p ! j1)\n  0 < degree (factors_of_int_poly p ! j1)\n  factors_of_int_poly p ! j1 \\<noteq> 0\n  poly_cond (factors_of_int_poly p ! j2)\n  0 < degree (factors_of_int_poly p ! j2)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length\n                     (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        j < length (concat (map roots_of_2_irr (factors_of_int_poly p)));\n        i \\<noteq> j;\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        i =\n        map real_of_2\n         (concat (map roots_of_2_irr (factors_of_int_poly p))) !\n        j\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"j1 = j2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j1 = j2 \\<Longrightarrow> False\n 2. j1 \\<noteq> j2 \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  j1 = j2\n\ngoal (2 subgoals):\n 1. j1 = j2 \\<Longrightarrow> False\n 2. j1 \\<noteq> j2 \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n  j1 = j2", "have neq: \"k1 \\<noteq> k2\""], ["proof (prove)\nusing this:\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n  j1 = j2\n\ngoal (1 subgoal):\n 1. k1 \\<noteq> k2", "by auto"], ["proof (state)\nthis:\n  k1 \\<noteq> k2\n\ngoal (2 subgoals):\n 1. j1 = j2 \\<Longrightarrow> False\n 2. j1 \\<noteq> j2 \\<Longrightarrow> False", "from **[unfolded True] id *"], ["proof (chain)\npicking this:\n  k1 < length (roots_of_2_irr (factors_of_int_poly p ! j2))\n  k2 < length (roots_of_2_irr (factors_of_int_poly p ! j2))\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n  roots_of_2_irr (factors_of_int_poly p ! j2) ! k1\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n  roots_of_2_irr (factors_of_int_poly p ! j2) ! k2\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! i) =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)", "have \"map real_of_2 (roots_of_2_irr (?fp ! j2)) ! k1 = real_of_2 (?cc ! j)\" \n          \"map real_of_2 (roots_of_2_irr (?fp ! j2)) ! k1 = real_of_2 (?cc ! j)\""], ["proof (prove)\nusing this:\n  k1 < length (roots_of_2_irr (factors_of_int_poly p ! j2))\n  k2 < length (roots_of_2_irr (factors_of_int_poly p ! j2))\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n  roots_of_2_irr (factors_of_int_poly p ! j2) ! k1\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n  roots_of_2_irr (factors_of_int_poly p ! j2) ! k2\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! i) =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)) ! k1 =\n    real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j) &&&\n    map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)) ! k1 =\n    real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)", "by auto"], ["proof (state)\nthis:\n  map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)) ! k1 =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)\n  map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)) ! k1 =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)\n\ngoal (2 subgoals):\n 1. j1 = j2 \\<Longrightarrow> False\n 2. j1 \\<noteq> j2 \\<Longrightarrow> False", "hence \"\\<not> distinct (map real_of_2 (roots_of_2_irr (?fp ! j2)))\""], ["proof (prove)\nusing this:\n  map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)) ! k1 =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)\n  map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)) ! k1 =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)\n\ngoal (1 subgoal):\n 1. \\<not> distinct\n            (map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)))", "unfolding distinct_conv_nth"], ["proof (prove)\nusing this:\n  map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)) ! k1 =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)\n  map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)) ! k1 =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length\n                        (map real_of_2\n                          (roots_of_2_irr (factors_of_int_poly p ! j2))).\n               \\<forall>j<length\n                           (map real_of_2\n                             (roots_of_2_irr (factors_of_int_poly p ! j2))).\n                  i \\<noteq> j \\<longrightarrow>\n                  map real_of_2\n                   (roots_of_2_irr (factors_of_int_poly p ! j2)) !\n                  i \\<noteq>\n                  map real_of_2\n                   (roots_of_2_irr (factors_of_int_poly p ! j2)) !\n                  j)", "using * ** True"], ["proof (prove)\nusing this:\n  map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)) ! k1 =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)\n  map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)) ! k1 =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n  k1 < length (roots_of_2_irr (factors_of_int_poly p ! j1))\n  k2 < length (roots_of_2_irr (factors_of_int_poly p ! j2))\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n  roots_of_2_irr (factors_of_int_poly p ! j1) ! k1\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n  roots_of_2_irr (factors_of_int_poly p ! j2) ! k2\n  j1 = j2\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length\n                        (map real_of_2\n                          (roots_of_2_irr (factors_of_int_poly p ! j2))).\n               \\<forall>j<length\n                           (map real_of_2\n                             (roots_of_2_irr (factors_of_int_poly p ! j2))).\n                  i \\<noteq> j \\<longrightarrow>\n                  map real_of_2\n                   (roots_of_2_irr (factors_of_int_poly p ! j2)) !\n                  i \\<noteq>\n                  map real_of_2\n                   (roots_of_2_irr (factors_of_int_poly p ! j2)) !\n                  j)", "by auto"], ["proof (state)\nthis:\n  \\<not> distinct\n          (map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)))\n\ngoal (2 subgoals):\n 1. j1 = j2 \\<Longrightarrow> False\n 2. j1 \\<noteq> j2 \\<Longrightarrow> False", "with roots_of_2_irr(3)[OF pc2]"], ["proof (chain)\npicking this:\n  distinct (map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)))\n  \\<not> distinct\n          (map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)))", "show False"], ["proof (prove)\nusing this:\n  distinct (map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)))\n  \\<not> distinct\n          (map real_of_2 (roots_of_2_irr (factors_of_int_poly p ! j2)))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow> False", "case neq: False"], ["proof (state)\nthis:\n  j1 \\<noteq> j2\n\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow> False", "with frp1(4)[of p] *"], ["proof (chain)\npicking this:\n  distinct (factors_of_int_poly p)\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n  j1 \\<noteq> j2", "have neq: \"?fp ! j1 \\<noteq> ?fp ! j2\""], ["proof (prove)\nusing this:\n  distinct (factors_of_int_poly p)\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n  j1 \\<noteq> j2\n\ngoal (1 subgoal):\n 1. factors_of_int_poly p ! j1 \\<noteq> factors_of_int_poly p ! j2", "unfolding distinct_conv_nth"], ["proof (prove)\nusing this:\n  \\<forall>i<length (factors_of_int_poly p).\n     \\<forall>j<length (factors_of_int_poly p).\n        i \\<noteq> j \\<longrightarrow>\n        factors_of_int_poly p ! i \\<noteq> factors_of_int_poly p ! j\n  (j1, k1) \\<noteq> (j2, k2)\n  j1 < length (factors_of_int_poly p)\n  j2 < length (factors_of_int_poly p)\n  j1 \\<noteq> j2\n\ngoal (1 subgoal):\n 1. factors_of_int_poly p ! j1 \\<noteq> factors_of_int_poly p ! j2", "by auto"], ["proof (state)\nthis:\n  factors_of_int_poly p ! j1 \\<noteq> factors_of_int_poly p ! j2\n\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow> False", "let ?x = \"real_of_2 (?cc ! i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow> False", "define x where \"x = ?x\""], ["proof (state)\nthis:\n  x = real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! i)\n\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow> False", "from **"], ["proof (chain)\npicking this:\n  k1 < length (roots_of_2_irr (factors_of_int_poly p ! j1))\n  k2 < length (roots_of_2_irr (factors_of_int_poly p ! j2))\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n  roots_of_2_irr (factors_of_int_poly p ! j1) ! k1\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n  roots_of_2_irr (factors_of_int_poly p ! j2) ! k2", "have \"x \\<in> real_of_2 ` set (roots_of_2_irr (?fp ! j1))\""], ["proof (prove)\nusing this:\n  k1 < length (roots_of_2_irr (factors_of_int_poly p ! j1))\n  k2 < length (roots_of_2_irr (factors_of_int_poly p ! j2))\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n  roots_of_2_irr (factors_of_int_poly p ! j1) ! k1\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n  roots_of_2_irr (factors_of_int_poly p ! j2) ! k2\n\ngoal (1 subgoal):\n 1. x \\<in> real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j1))", "unfolding x_def"], ["proof (prove)\nusing this:\n  k1 < length (roots_of_2_irr (factors_of_int_poly p ! j1))\n  k2 < length (roots_of_2_irr (factors_of_int_poly p ! j2))\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n  roots_of_2_irr (factors_of_int_poly p ! j1) ! k1\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n  roots_of_2_irr (factors_of_int_poly p ! j2) ! k2\n\ngoal (1 subgoal):\n 1. real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! i)\n    \\<in> real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j1))", "by auto"], ["proof (state)\nthis:\n  x \\<in> real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j1))\n\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow> False", "with roots_of_2_irr(1)[OF pc1]"], ["proof (chain)\npicking this:\n  real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j1)) =\n  {x. poly (real_of_int_poly (factors_of_int_poly p ! j1)) x = 0}\n  x \\<in> real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j1))", "have x1: \"ipoly (?fp ! j1) x = 0\""], ["proof (prove)\nusing this:\n  real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j1)) =\n  {x. poly (real_of_int_poly (factors_of_int_poly p ! j1)) x = 0}\n  x \\<in> real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j1))\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly (factors_of_int_poly p ! j1)) x = 0", "by auto"], ["proof (state)\nthis:\n  poly (real_of_int_poly (factors_of_int_poly p ! j1)) x = 0\n\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow> False", "from ** id"], ["proof (chain)\npicking this:\n  k1 < length (roots_of_2_irr (factors_of_int_poly p ! j1))\n  k2 < length (roots_of_2_irr (factors_of_int_poly p ! j2))\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n  roots_of_2_irr (factors_of_int_poly p ! j1) ! k1\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n  roots_of_2_irr (factors_of_int_poly p ! j2) ! k2\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! i) =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)", "have \"x \\<in> real_of_2 ` set (roots_of_2_irr (?fp ! j2))\""], ["proof (prove)\nusing this:\n  k1 < length (roots_of_2_irr (factors_of_int_poly p ! j1))\n  k2 < length (roots_of_2_irr (factors_of_int_poly p ! j2))\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n  roots_of_2_irr (factors_of_int_poly p ! j1) ! k1\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n  roots_of_2_irr (factors_of_int_poly p ! j2) ! k2\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! i) =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)\n\ngoal (1 subgoal):\n 1. x \\<in> real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j2))", "unfolding x_def"], ["proof (prove)\nusing this:\n  k1 < length (roots_of_2_irr (factors_of_int_poly p ! j1))\n  k2 < length (roots_of_2_irr (factors_of_int_poly p ! j2))\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! i =\n  roots_of_2_irr (factors_of_int_poly p ! j1) ! k1\n  concat (map roots_of_2_irr (factors_of_int_poly p)) ! j =\n  roots_of_2_irr (factors_of_int_poly p ! j2) ! k2\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! i) =\n  real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! j)\n\ngoal (1 subgoal):\n 1. real_of_2 (concat (map roots_of_2_irr (factors_of_int_poly p)) ! i)\n    \\<in> real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j2))", "by (metis image_eqI nth_mem)"], ["proof (state)\nthis:\n  x \\<in> real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j2))\n\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow> False", "with roots_of_2_irr(1)[OF pc2]"], ["proof (chain)\npicking this:\n  real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j2)) =\n  {x. poly (real_of_int_poly (factors_of_int_poly p ! j2)) x = 0}\n  x \\<in> real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j2))", "have x2: \"ipoly (?fp ! j2) x = 0\""], ["proof (prove)\nusing this:\n  real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j2)) =\n  {x. poly (real_of_int_poly (factors_of_int_poly p ! j2)) x = 0}\n  x \\<in> real_of_2 ` set (roots_of_2_irr (factors_of_int_poly p ! j2))\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly (factors_of_int_poly p ! j2)) x = 0", "by auto"], ["proof (state)\nthis:\n  poly (real_of_int_poly (factors_of_int_poly p ! j2)) x = 0\n\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow> False", "have \"ipoly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0", "using x1 mem"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly (factors_of_int_poly p ! j1)) x = 0\n  factors_of_int_poly p ! j1 \\<in> set (factors_of_int_poly p)\n  factors_of_int_poly p ! j2 \\<in> set (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0", "unfolding roots_of_2_def"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly (factors_of_int_poly p ! j1)) x = 0\n  factors_of_int_poly p ! j1 \\<in> set (factors_of_int_poly p)\n  factors_of_int_poly p ! j2 \\<in> set (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. poly (real_of_int_poly p) x = 0", "by (metis frp1(2) p)"], ["proof (state)\nthis:\n  poly (real_of_int_poly p) x = 0\n\ngoal (1 subgoal):\n 1. j1 \\<noteq> j2 \\<Longrightarrow> False", "from frp1(3)[OF p this] x1 x2 neq mem"], ["proof (chain)\npicking this:\n  \\<exists>!q.\n     q \\<in> set (factors_of_int_poly p) \\<and>\n     poly (real_of_int_poly q) x = 0\n  poly (real_of_int_poly (factors_of_int_poly p ! j1)) x = 0\n  poly (real_of_int_poly (factors_of_int_poly p ! j2)) x = 0\n  factors_of_int_poly p ! j1 \\<noteq> factors_of_int_poly p ! j2\n  factors_of_int_poly p ! j1 \\<in> set (factors_of_int_poly p)\n  factors_of_int_poly p ! j2 \\<in> set (factors_of_int_poly p)", "show False"], ["proof (prove)\nusing this:\n  \\<exists>!q.\n     q \\<in> set (factors_of_int_poly p) \\<and>\n     poly (real_of_int_poly q) x = 0\n  poly (real_of_int_poly (factors_of_int_poly p ! j1)) x = 0\n  poly (real_of_int_poly (factors_of_int_poly p ! j2)) x = 0\n  factors_of_int_poly p ! j1 \\<noteq> factors_of_int_poly p ! j2\n  factors_of_int_poly p ! j1 \\<in> set (factors_of_int_poly p)\n  factors_of_int_poly p ! j2 \\<in> set (factors_of_int_poly p)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map real_of_2 (roots_of_2 p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map real_of_2 (roots_of_2 p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition roots_of_3 :: \"int poly \\<Rightarrow> real_alg_3 list\" is roots_of_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>poly.\n       list_all (\\<lambda>x. x \\<in> Collect invariant_2) (roots_of_2 poly)", "by (insert roots_of_2, auto simp: list_all_iff)"], ["", "lemma roots_of_3: \n  shows \"p \\<noteq> 0 \\<Longrightarrow> real_of_3 ` set (roots_of_3 p) = {x. ipoly p x = 0}\"\n    \"distinct (map real_of_3 (roots_of_3 p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<Longrightarrow>\n     real_of_3 ` set (roots_of_3 p) =\n     {x. poly (real_of_int_poly p) x = 0}) &&&\n    distinct (map real_of_3 (roots_of_3 p))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_3 ` set (roots_of_3 p) = {x. poly (real_of_int_poly p) x = 0}\n 2. distinct (map real_of_3 (roots_of_3 p))", "show \"p \\<noteq> 0 \\<Longrightarrow> real_of_3 ` set (roots_of_3 p) = {x. ipoly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of_3 ` set (roots_of_3 p) = {x. poly (real_of_int_poly p) x = 0}", "by (transfer; intro roots_of_2, auto)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  real_of_3 ` set (roots_of_3 p) = {x. poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. distinct (map real_of_3 (roots_of_3 p))", "show \"distinct (map real_of_3 (roots_of_3 p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map real_of_3 (roots_of_3 p))", "by (transfer; insert roots_of_2, auto)"], ["proof (state)\nthis:\n  distinct (map real_of_3 (roots_of_3 p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition roots_of_real_alg :: \"int poly \\<Rightarrow> real_alg list\" is roots_of_3"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma roots_of_real_alg: \n  \"p \\<noteq> 0 \\<Longrightarrow> real_of ` set (roots_of_real_alg p) = {x. ipoly p x = 0}\" \n  \"distinct (map real_of (roots_of_real_alg p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<Longrightarrow>\n     real_of ` set (roots_of_real_alg p) =\n     {x. poly (real_of_int_poly p) x = 0}) &&&\n    distinct (map real_of (roots_of_real_alg p))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of ` set (roots_of_real_alg p) =\n    {x. poly (real_of_int_poly p) x = 0}\n 2. distinct (map real_of (roots_of_real_alg p))", "show \"p \\<noteq> 0 \\<Longrightarrow> real_of ` set (roots_of_real_alg p) = {x. ipoly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    real_of ` set (roots_of_real_alg p) =\n    {x. poly (real_of_int_poly p) x = 0}", "by (transfer', insert roots_of_3, auto)"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  real_of ` set (roots_of_real_alg p) = {x. poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. distinct (map real_of (roots_of_real_alg p))", "show \"distinct (map real_of (roots_of_real_alg p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map real_of (roots_of_real_alg p))", "by (transfer, insert roots_of_3(2), auto)"], ["proof (state)\nthis:\n  distinct (map real_of (roots_of_real_alg p))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>It follows an implementation for @{const roots_of_3}, \n  since the current definition does not provide a code equation.\\<close>"], ["", "context\nbegin"], ["", "private"], ["", "typedef real_alg_2_list = \"{xs. Ball (set xs) invariant_2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {xs. Ball (set xs) invariant_2}", "by (intro exI[of _ Nil], auto)"], ["", "setup_lifting type_definition_real_alg_2_list"], ["", "private"], ["", "lift_definition roots_of_2_list :: \"int poly \\<Rightarrow> real_alg_2_list\" is roots_of_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>poly real_alg_2.\n       real_alg_2 \\<in> set (roots_of_2 poly) \\<Longrightarrow>\n       invariant_2 real_alg_2", "by (insert roots_of_2, auto)"], ["", "private"], ["", "lift_definition real_alg_2_list_nil :: \"real_alg_2_list \\<Rightarrow> bool\" is \"\\<lambda> xs. case xs of Nil \\<Rightarrow> True | _ \\<Rightarrow> False\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "private"], ["", "fun real_alg_2_list_hd_intern :: \"real_alg_2 list \\<Rightarrow> real_alg_2\" where\n  \"real_alg_2_list_hd_intern (Cons x xs) = x\"\n| \"real_alg_2_list_hd_intern Nil = of_rat_2 0\""], ["", "private"], ["", "lift_definition real_alg_2_list_hd :: \"real_alg_2_list \\<Rightarrow> real_alg_3\" is real_alg_2_list_hd_intern"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       (\\<And>x.\n           x \\<in> set list \\<Longrightarrow>\n           invariant_2 x) \\<Longrightarrow>\n       real_alg_2_list_hd_intern list \\<in> Collect invariant_2", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>list.\n       (\\<And>x.\n           x \\<in> set list \\<Longrightarrow>\n           invariant_2 x) \\<Longrightarrow>\n       real_alg_2_list_hd_intern list \\<in> Collect invariant_2", "case (1 xs)"], ["proof (state)\nthis:\n  ?x \\<in> set xs \\<Longrightarrow> invariant_2 ?x\n\ngoal (1 subgoal):\n 1. \\<And>list.\n       (\\<And>x.\n           x \\<in> set list \\<Longrightarrow>\n           invariant_2 x) \\<Longrightarrow>\n       real_alg_2_list_hd_intern list \\<in> Collect invariant_2", "thus ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> invariant_2 ?x\n\ngoal (1 subgoal):\n 1. real_alg_2_list_hd_intern xs \\<in> Collect invariant_2", "using of_rat_2[of 0]"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> invariant_2 ?x\n  real_of_2 (of_rat_2 0) = real_of_rat 0\n  invariant_2 (of_rat_2 0)\n\ngoal (1 subgoal):\n 1. real_alg_2_list_hd_intern xs \\<in> Collect invariant_2", "by (cases xs, auto)"], ["proof (state)\nthis:\n  real_alg_2_list_hd_intern xs \\<in> Collect invariant_2\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lift_definition real_alg_2_list_tl :: \"real_alg_2_list \\<Rightarrow> real_alg_2_list\" is tl"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list real_alg_2.\n       \\<lbrakk>\\<And>x. x \\<in> set list \\<Longrightarrow> invariant_2 x;\n        real_alg_2 \\<in> set (tl list)\\<rbrakk>\n       \\<Longrightarrow> invariant_2 real_alg_2", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>list real_alg_2.\n       \\<lbrakk>\\<And>x. x \\<in> set list \\<Longrightarrow> invariant_2 x;\n        real_alg_2 \\<in> set (tl list)\\<rbrakk>\n       \\<Longrightarrow> invariant_2 real_alg_2", "case (1 xs)"], ["proof (state)\nthis:\n  ?x \\<in> set xs \\<Longrightarrow> invariant_2 ?x\n  real_alg_2_ \\<in> set (tl xs)\n\ngoal (1 subgoal):\n 1. \\<And>list real_alg_2.\n       \\<lbrakk>\\<And>x. x \\<in> set list \\<Longrightarrow> invariant_2 x;\n        real_alg_2 \\<in> set (tl list)\\<rbrakk>\n       \\<Longrightarrow> invariant_2 real_alg_2", "thus ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> invariant_2 ?x\n  real_alg_2_ \\<in> set (tl xs)\n\ngoal (1 subgoal):\n 1. invariant_2 real_alg_2_", "by (cases xs, auto)"], ["proof (state)\nthis:\n  invariant_2 real_alg_2_\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lift_definition real_alg_2_list_length :: \"real_alg_2_list \\<Rightarrow> nat\" is length"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "private"], ["", "lemma real_alg_2_list_length[simp]: \"\\<not> real_alg_2_list_nil xs \\<Longrightarrow> real_alg_2_list_length (real_alg_2_list_tl xs) < real_alg_2_list_length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_length (real_alg_2_list_tl xs)\n    < real_alg_2_list_length xs", "by (transfer, auto split: list.splits)"], ["", "private"], ["", "function real_alg_2_list_convert :: \"real_alg_2_list \\<Rightarrow> real_alg_3 list\" where\n  \"real_alg_2_list_convert xs = (if real_alg_2_list_nil xs then [] else real_alg_2_list_hd xs \n    # real_alg_2_list_convert (real_alg_2_list_tl xs))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>xs. x = xs \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>xs xsa.\n       xs = xsa \\<Longrightarrow>\n       (if real_alg_2_list_nil xs then []\n        else real_alg_2_list_hd xs #\n             real_alg_2_list_convert_sumC (real_alg_2_list_tl xs)) =\n       (if real_alg_2_list_nil xsa then []\n        else real_alg_2_list_hd xsa #\n             real_alg_2_list_convert_sumC (real_alg_2_list_tl xsa))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All real_alg_2_list_convert_dom", "by (relation \"measure real_alg_2_list_length\", auto)"], ["", "private"], ["", "definition roots_of_3_impl :: \"int poly \\<Rightarrow> real_alg_3 list\" where\n  \"roots_of_3_impl p = real_alg_2_list_convert (roots_of_2_list p)\""], ["", "private"], ["", "lift_definition real_alg_2_list_convert_id :: \"real_alg_2_list \\<Rightarrow> real_alg_3 list\" is id"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list.\n       (\\<And>x.\n           x \\<in> set list \\<Longrightarrow>\n           invariant_2 x) \\<Longrightarrow>\n       list_all (\\<lambda>x. x \\<in> Collect invariant_2) (id list)", "by (auto simp: list_all_iff)"], ["", "lemma real_alg_2_list_convert: \"real_alg_2_list_convert xs = real_alg_2_list_convert_id xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "proof (induct xs rule: wf_induct[OF wf_measure[of real_alg_2_list_length], rule_format])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> measure real_alg_2_list_length \\<Longrightarrow>\n           real_alg_2_list_convert y =\n           real_alg_2_list_convert_id y) \\<Longrightarrow>\n       real_alg_2_list_convert x = real_alg_2_list_convert_id x", "case (1 xs)"], ["proof (state)\nthis:\n  (?y, xs) \\<in> measure real_alg_2_list_length \\<Longrightarrow>\n  real_alg_2_list_convert ?y = real_alg_2_list_convert_id ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> measure real_alg_2_list_length \\<Longrightarrow>\n           real_alg_2_list_convert y =\n           real_alg_2_list_convert_id y) \\<Longrightarrow>\n       real_alg_2_list_convert x = real_alg_2_list_convert_id x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "proof (cases \"real_alg_2_list_nil xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs\n 2. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "case True"], ["proof (state)\nthis:\n  real_alg_2_list_nil xs\n\ngoal (2 subgoals):\n 1. real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs\n 2. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "hence \"real_alg_2_list_convert xs = []\""], ["proof (prove)\nusing this:\n  real_alg_2_list_nil xs\n\ngoal (1 subgoal):\n 1. real_alg_2_list_convert xs = []", "by auto"], ["proof (state)\nthis:\n  real_alg_2_list_convert xs = []\n\ngoal (2 subgoals):\n 1. real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs\n 2. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "also"], ["proof (state)\nthis:\n  real_alg_2_list_convert xs = []\n\ngoal (2 subgoals):\n 1. real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs\n 2. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "have \"[] = real_alg_2_list_convert_id xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] = real_alg_2_list_convert_id xs", "using True"], ["proof (prove)\nusing this:\n  real_alg_2_list_nil xs\n\ngoal (1 subgoal):\n 1. [] = real_alg_2_list_convert_id xs", "by (transfer', auto split: list.splits)"], ["proof (state)\nthis:\n  [] = real_alg_2_list_convert_id xs\n\ngoal (2 subgoals):\n 1. real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs\n 2. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "finally"], ["proof (chain)\npicking this:\n  real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "show ?thesis"], ["proof (prove)\nusing this:\n  real_alg_2_list_convert xs = real_alg_2_list_convert_id xs\n\ngoal (1 subgoal):\n 1. real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "."], ["proof (state)\nthis:\n  real_alg_2_list_convert xs = real_alg_2_list_convert_id xs\n\ngoal (1 subgoal):\n 1. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "case False"], ["proof (state)\nthis:\n  \\<not> real_alg_2_list_nil xs\n\ngoal (1 subgoal):\n 1. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "hence \"real_alg_2_list_convert xs = real_alg_2_list_hd xs # real_alg_2_list_convert (real_alg_2_list_tl xs)\""], ["proof (prove)\nusing this:\n  \\<not> real_alg_2_list_nil xs\n\ngoal (1 subgoal):\n 1. real_alg_2_list_convert xs =\n    real_alg_2_list_hd xs # real_alg_2_list_convert (real_alg_2_list_tl xs)", "by simp"], ["proof (state)\nthis:\n  real_alg_2_list_convert xs =\n  real_alg_2_list_hd xs # real_alg_2_list_convert (real_alg_2_list_tl xs)\n\ngoal (1 subgoal):\n 1. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "also"], ["proof (state)\nthis:\n  real_alg_2_list_convert xs =\n  real_alg_2_list_hd xs # real_alg_2_list_convert (real_alg_2_list_tl xs)\n\ngoal (1 subgoal):\n 1. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "have \"real_alg_2_list_convert (real_alg_2_list_tl xs) = real_alg_2_list_convert_id (real_alg_2_list_tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_alg_2_list_convert (real_alg_2_list_tl xs) =\n    real_alg_2_list_convert_id (real_alg_2_list_tl xs)", "by (rule 1, insert False, simp)"], ["proof (state)\nthis:\n  real_alg_2_list_convert (real_alg_2_list_tl xs) =\n  real_alg_2_list_convert_id (real_alg_2_list_tl xs)\n\ngoal (1 subgoal):\n 1. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "also"], ["proof (state)\nthis:\n  real_alg_2_list_convert (real_alg_2_list_tl xs) =\n  real_alg_2_list_convert_id (real_alg_2_list_tl xs)\n\ngoal (1 subgoal):\n 1. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "have \"real_alg_2_list_hd xs # \\<dots> = real_alg_2_list_convert_id xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_alg_2_list_hd xs #\n    real_alg_2_list_convert_id (real_alg_2_list_tl xs) =\n    real_alg_2_list_convert_id xs", "using False"], ["proof (prove)\nusing this:\n  \\<not> real_alg_2_list_nil xs\n\ngoal (1 subgoal):\n 1. real_alg_2_list_hd xs #\n    real_alg_2_list_convert_id (real_alg_2_list_tl xs) =\n    real_alg_2_list_convert_id xs", "by (transfer', auto split: list.splits)"], ["proof (state)\nthis:\n  real_alg_2_list_hd xs #\n  real_alg_2_list_convert_id (real_alg_2_list_tl xs) =\n  real_alg_2_list_convert_id xs\n\ngoal (1 subgoal):\n 1. \\<not> real_alg_2_list_nil xs \\<Longrightarrow>\n    real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "finally"], ["proof (chain)\npicking this:\n  real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "show ?thesis"], ["proof (prove)\nusing this:\n  real_alg_2_list_convert xs = real_alg_2_list_convert_id xs\n\ngoal (1 subgoal):\n 1. real_alg_2_list_convert xs = real_alg_2_list_convert_id xs", "."], ["proof (state)\nthis:\n  real_alg_2_list_convert xs = real_alg_2_list_convert_id xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_alg_2_list_convert xs = real_alg_2_list_convert_id xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma roots_of_3_code[code]: \"roots_of_3 p = roots_of_3_impl p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. roots_of_3 p = roots_of_3_impl p", "unfolding roots_of_3_impl_def real_alg_2_list_convert"], ["proof (prove)\ngoal (1 subgoal):\n 1. roots_of_3 p = real_alg_2_list_convert_id (roots_of_2_list p)", "by (transfer, simp)"], ["", "end"], ["", "definition real_roots_of_int_poly :: \"int poly \\<Rightarrow> real list\" where\n  \"real_roots_of_int_poly p = map real_of (roots_of_real_alg p)\""], ["", "definition real_roots_of_rat_poly :: \"rat poly \\<Rightarrow> real list\" where\n  \"real_roots_of_rat_poly p = map real_of (roots_of_real_alg (snd (rat_to_int_poly p)))\""], ["", "abbreviation rpoly :: \"rat poly \\<Rightarrow> 'a :: field_char_0 \\<Rightarrow> 'a\"\nwhere \"rpoly f \\<equiv> poly (map_poly of_rat f)\""], ["", "lemma real_roots_of_int_poly: \"p \\<noteq> 0 \\<Longrightarrow> set (real_roots_of_int_poly p) = {x. ipoly p x = 0}\" \n  \"distinct (real_roots_of_int_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<Longrightarrow>\n     set (real_roots_of_int_poly p) =\n     {x. poly (real_of_int_poly p) x = 0}) &&&\n    distinct (real_roots_of_int_poly p)", "unfolding real_roots_of_int_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<Longrightarrow>\n     set (map real_of (roots_of_real_alg p)) =\n     {x. poly (real_of_int_poly p) x = 0}) &&&\n    distinct (map real_of (roots_of_real_alg p))", "using roots_of_real_alg[of p]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  real_of ` set (roots_of_real_alg p) = {x. poly (real_of_int_poly p) x = 0}\n  distinct (map real_of (roots_of_real_alg p))\n\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<Longrightarrow>\n     set (map real_of (roots_of_real_alg p)) =\n     {x. poly (real_of_int_poly p) x = 0}) &&&\n    distinct (map real_of (roots_of_real_alg p))", "by auto"], ["", "lemma real_roots_of_rat_poly: \"p \\<noteq> 0 \\<Longrightarrow> set (real_roots_of_rat_poly p) = {x. rpoly p x = 0}\" \n  \"distinct (real_roots_of_rat_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0 \\<Longrightarrow>\n     set (real_roots_of_rat_poly p) = {x. rpoly p x = 0}) &&&\n    distinct (real_roots_of_rat_poly p)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (real_roots_of_rat_poly p) = {x. rpoly p x = 0}\n 2. distinct (real_roots_of_rat_poly p)", "obtain c q where cq: \"rat_to_int_poly p = (c,q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c q.\n        rat_to_int_poly p = (c, q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  rat_to_int_poly p = (c, q)\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (real_roots_of_rat_poly p) = {x. rpoly p x = 0}\n 2. distinct (real_roots_of_rat_poly p)", "from rat_to_int_poly[OF this]"], ["proof (chain)\npicking this:\n  p = smult (inverse (rat_of_int c)) (of_int_poly q)\n  0 < c", "have pq: \"p = smult (inverse (of_int c)) (of_int_poly q)\" \n    and c: \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p = smult (inverse (rat_of_int c)) (of_int_poly q)\n  0 < c\n\ngoal (1 subgoal):\n 1. p = smult (inverse (rat_of_int c)) (of_int_poly q) &&& c \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p = smult (inverse (rat_of_int c)) (of_int_poly q)\n  c \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (real_roots_of_rat_poly p) = {x. rpoly p x = 0}\n 2. distinct (real_roots_of_rat_poly p)", "have id: \"{x. rpoly p x = (0 :: real)} = {x. ipoly q x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. rpoly p x = 0} = {x. poly (real_of_int_poly q) x = 0}", "unfolding pq"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. rpoly (smult (inverse (rat_of_int c)) (of_int_poly q)) x = 0} =\n    {x. poly (real_of_int_poly q) x = 0}", "by (simp add: c of_rat_of_int_poly hom_distribs)"], ["proof (state)\nthis:\n  {x. rpoly p x = 0} = {x. poly (real_of_int_poly q) x = 0}\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (real_roots_of_rat_poly p) = {x. rpoly p x = 0}\n 2. distinct (real_roots_of_rat_poly p)", "show \"distinct (real_roots_of_rat_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (real_roots_of_rat_poly p)", "unfolding real_roots_of_rat_poly_def cq snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map real_of (roots_of_real_alg q))", "using roots_of_real_alg(2)[of q]"], ["proof (prove)\nusing this:\n  distinct (map real_of (roots_of_real_alg q))\n\ngoal (1 subgoal):\n 1. distinct (map real_of (roots_of_real_alg q))", "."], ["proof (state)\nthis:\n  distinct (real_roots_of_rat_poly p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (real_roots_of_rat_poly p) = {x. rpoly p x = 0}", "assume \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (real_roots_of_rat_poly p) = {x. rpoly p x = 0}", "with pq c"], ["proof (chain)\npicking this:\n  p = smult (inverse (rat_of_int c)) (of_int_poly q)\n  c \\<noteq> 0\n  p \\<noteq> 0", "have q: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p = smult (inverse (rat_of_int c)) (of_int_poly q)\n  c \\<noteq> 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set (real_roots_of_rat_poly p) = {x. rpoly p x = 0}", "show \"set (real_roots_of_rat_poly p) = {x. rpoly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (real_roots_of_rat_poly p) = {x. rpoly p x = 0}", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (real_roots_of_rat_poly p) = {x. poly (real_of_int_poly q) x = 0}", "unfolding real_roots_of_rat_poly_def cq snd_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map real_of (roots_of_real_alg q)) =\n    {x. poly (real_of_int_poly q) x = 0}", "using roots_of_real_alg(1)[OF q]"], ["proof (prove)\nusing this:\n  real_of ` set (roots_of_real_alg q) = {x. poly (real_of_int_poly q) x = 0}\n\ngoal (1 subgoal):\n 1. set (map real_of (roots_of_real_alg q)) =\n    {x. poly (real_of_int_poly q) x = 0}", "by auto"], ["proof (state)\nthis:\n  set (real_roots_of_rat_poly p) = {x. rpoly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The upcoming functions no longer demand an integer or rational polynomial as input.\\<close>"], ["", "definition roots_of_real_main :: \"real poly \\<Rightarrow> real list\" where \n  \"roots_of_real_main p \\<equiv> let n = degree p in \n    if n = 0 then [] else if n = 1 then [roots1 p] else if n = 2 then rroots2 p\n    else (real_roots_of_rat_poly (map_poly to_rat p))\""], ["", "definition roots_of_real_poly :: \"real poly \\<Rightarrow> real list option\" where\n  \"roots_of_real_poly p \\<equiv> let (c,pis) = yun_factorization gcd p in\n    if (c \\<noteq> 0 \\<and> (\\<forall> (p,i) \\<in> set pis. degree p \\<le> 2 \\<or> (\\<forall> x \\<in> set (coeffs p). x \\<in> \\<rat>))) then \n    Some (concat (map (roots_of_real_main o fst) pis)) else None\""], ["", "lemma roots_of_real_main: assumes p: \"p \\<noteq> 0\" and deg: \"degree p \\<le> 2 \\<or> set (coeffs p) \\<subseteq> \\<rat>\"\n  shows \"set (roots_of_real_main p) = {x. poly p x = 0}\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = {x. poly p x = 0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = {x. poly p x = 0}", "note d = roots_of_real_main_def Let_def"], ["proof (state)\nthis:\n  roots_of_real_main ?p \\<equiv>\n  let n = degree ?p\n  in if n = 0 then []\n     else if n = 1 then [roots1 ?p]\n          else if n = 2 then rroots2 ?p\n               else real_roots_of_rat_poly (map_poly to_rat ?p)\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = {x. poly p x = 0}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = {x. poly p x = 0}", "proof (cases \"degree p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "case True"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "hence \"?l = {}\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = {}", "unfolding d"], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. set (if degree p = 0 then []\n         else if degree p = 1 then [roots1 p]\n              else if degree p = 2 then rroots2 p\n                   else real_roots_of_rat_poly (map_poly to_rat p)) =\n    {}", "by auto"], ["proof (state)\nthis:\n  set (roots_of_real_main p) = {}\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "with roots0[OF p True]"], ["proof (chain)\npicking this:\n  {x. poly p x = 0} = {}\n  set (roots_of_real_main p) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. poly p x = 0} = {}\n  set (roots_of_real_main p) = {}\n\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = {x. poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  set (roots_of_real_main p) = {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "note 0 = this"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = {x. poly p x = 0}", "proof (cases \"degree p = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "case True"], ["proof (state)\nthis:\n  degree p = 1\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "hence \"?l = {roots1 p}\""], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = {roots1 p}", "unfolding d"], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. set (if degree p = 0 then []\n         else if degree p = 1 then [roots1 p]\n              else if degree p = 2 then rroots2 p\n                   else real_roots_of_rat_poly (map_poly to_rat p)) =\n    {roots1 p}", "by auto"], ["proof (state)\nthis:\n  set (roots_of_real_main p) = {roots1 p}\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}\n 2. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "with roots1[OF True]"], ["proof (chain)\npicking this:\n  {x. poly p x = 0} = {roots1 p}\n  set (roots_of_real_main p) = {roots1 p}", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. poly p x = 0} = {roots1 p}\n  set (roots_of_real_main p) = {roots1 p}\n\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = {x. poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  set (roots_of_real_main p) = {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "note 1 = this"], ["proof (state)\nthis:\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = {x. poly p x = 0}", "proof (cases \"degree p = 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}\n 2. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "case True"], ["proof (state)\nthis:\n  degree p = 2\n\ngoal (2 subgoals):\n 1. degree p = 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}\n 2. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "hence \"?l = set (rroots2 p)\""], ["proof (prove)\nusing this:\n  degree p = 2\n\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = set (rroots2 p)", "unfolding d"], ["proof (prove)\nusing this:\n  degree p = 2\n\ngoal (1 subgoal):\n 1. set (if degree p = 0 then []\n         else if degree p = 1 then [roots1 p]\n              else if degree p = 2 then rroots2 p\n                   else real_roots_of_rat_poly (map_poly to_rat p)) =\n    set (rroots2 p)", "by auto"], ["proof (state)\nthis:\n  set (roots_of_real_main p) = set (rroots2 p)\n\ngoal (2 subgoals):\n 1. degree p = 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}\n 2. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "with rroots2[OF True]"], ["proof (chain)\npicking this:\n  {x. poly p x = 0} = set (rroots2 p)\n  set (roots_of_real_main p) = set (rroots2 p)", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. poly p x = 0} = set (rroots2 p)\n  set (roots_of_real_main p) = set (rroots2 p)\n\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = {x. poly p x = 0}", "by auto"], ["proof (state)\nthis:\n  set (roots_of_real_main p) = {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "note 2 = this"], ["proof (state)\nthis:\n  degree p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "let ?q = \"map_poly to_rat p\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "from 0 1 2"], ["proof (chain)\npicking this:\n  degree p \\<noteq> 0\n  degree p \\<noteq> 1\n  degree p \\<noteq> 2", "have l: \"?l = set (real_roots_of_rat_poly ?q)\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n  degree p \\<noteq> 1\n  degree p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) =\n    set (real_roots_of_rat_poly (map_poly to_rat p))", "unfolding d"], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n  degree p \\<noteq> 1\n  degree p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. set (if degree p = 0 then []\n         else if degree p = 1 then [roots1 p]\n              else if degree p = 2 then rroots2 p\n                   else real_roots_of_rat_poly (map_poly to_rat p)) =\n    set (real_roots_of_rat_poly (map_poly to_rat p))", "by auto"], ["proof (state)\nthis:\n  set (roots_of_real_main p) =\n  set (real_roots_of_rat_poly (map_poly to_rat p))\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "from deg 0 1 2"], ["proof (chain)\npicking this:\n  degree p \\<le> 2 \\<or> set (coeffs p) \\<subseteq> \\<rat>\n  degree p \\<noteq> 0\n  degree p \\<noteq> 1\n  degree p \\<noteq> 2", "have rat: \"set (coeffs p) \\<subseteq> \\<rat>\""], ["proof (prove)\nusing this:\n  degree p \\<le> 2 \\<or> set (coeffs p) \\<subseteq> \\<rat>\n  degree p \\<noteq> 0\n  degree p \\<noteq> 1\n  degree p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. set (coeffs p) \\<subseteq> \\<rat>", "by auto"], ["proof (state)\nthis:\n  set (coeffs p) \\<subseteq> \\<rat>\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "have \"p = map_poly (of_rat o to_rat) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = map_poly (real_of_rat \\<circ> to_rat) p", "by (rule sym, rule map_poly_idI, insert rat, auto)"], ["proof (state)\nthis:\n  p = map_poly (real_of_rat \\<circ> to_rat) p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "also"], ["proof (state)\nthis:\n  p = map_poly (real_of_rat \\<circ> to_rat) p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "have \"\\<dots> = real_of_rat_poly ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (real_of_rat \\<circ> to_rat) p =\n    real_of_rat_poly (map_poly to_rat p)", "by (subst map_poly_map_poly, auto simp: to_rat)"], ["proof (state)\nthis:\n  map_poly (real_of_rat \\<circ> to_rat) p =\n  real_of_rat_poly (map_poly to_rat p)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "finally"], ["proof (chain)\npicking this:\n  p = real_of_rat_poly (map_poly to_rat p)", "have id: \"{x. poly p x = 0} = {x. poly (real_of_rat_poly ?q) x = 0}\" and q: \"?q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p = real_of_rat_poly (map_poly to_rat p)\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = {x. rpoly (map_poly to_rat p) x = 0} &&&\n    map_poly to_rat p \\<noteq> 0", "using p"], ["proof (prove)\nusing this:\n  p = real_of_rat_poly (map_poly to_rat p)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = {x. rpoly (map_poly to_rat p) x = 0} &&&\n    map_poly to_rat p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = 0} = {x. rpoly (map_poly to_rat p) x = 0}\n  map_poly to_rat p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 2 \\<Longrightarrow>\n    set (roots_of_real_main p) = {x. poly p x = 0}", "from real_roots_of_rat_poly(1)[OF q, folded id l]"], ["proof (chain)\npicking this:\n  set (roots_of_real_main p) = {x. poly p x = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  set (roots_of_real_main p) = {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = {x. poly p x = 0}", "by simp"], ["proof (state)\nthis:\n  set (roots_of_real_main p) = {x. poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (roots_of_real_main p) = {x. poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (roots_of_real_main p) = {x. poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (roots_of_real_main p) = {x. poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma roots_of_real_poly: assumes rt: \"roots_of_real_poly p = Some xs\"\n  shows \"set xs = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "obtain c pis where yun: \"yun_factorization gcd p = (c,pis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c pis.\n        yun_factorization gcd p = (c, pis) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  yun_factorization gcd p = (c, pis)\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "from rt[unfolded roots_of_real_poly_def yun split Let_def]"], ["proof (chain)\npicking this:\n  (if c \\<noteq> 0 \\<and>\n      (\\<forall>(p, i)\\<in>set pis.\n          degree p \\<le> 2 \\<or>\n          (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>))\n   then Some (concat (map (roots_of_real_main \\<circ> fst) pis))\n   else None) =\n  Some xs", "have c: \"c \\<noteq> 0\" and pis: \"\\<And> p i. (p, i)\\<in>set pis \\<Longrightarrow> degree p \\<le> 2 \\<or> (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>)\"\n    and xs: \"xs = concat (map (roots_of_real_main \\<circ> fst) pis)\""], ["proof (prove)\nusing this:\n  (if c \\<noteq> 0 \\<and>\n      (\\<forall>(p, i)\\<in>set pis.\n          degree p \\<le> 2 \\<or>\n          (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>))\n   then Some (concat (map (roots_of_real_main \\<circ> fst) pis))\n   else None) =\n  Some xs\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0 &&&\n    (\\<And>p i.\n        (p, i) \\<in> set pis \\<Longrightarrow>\n        degree p \\<le> 2 \\<or>\n        (\\<forall>x\\<in>set (coeffs p). x \\<in> \\<rat>)) &&&\n    xs = concat (map (roots_of_real_main \\<circ> fst) pis)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  c \\<noteq> 0\n  (?p, ?i) \\<in> set pis \\<Longrightarrow>\n  degree ?p \\<le> 2 \\<or> (\\<forall>x\\<in>set (coeffs ?p). x \\<in> \\<rat>)\n  xs = concat (map (roots_of_real_main \\<circ> fst) pis)\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "note yun = square_free_factorizationD(1,2,4)[OF yun_factorization(1)[OF yun]]"], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)\n  (?a, ?i) \\<in> set pis \\<Longrightarrow>\n  square_free ?a \\<and> degree ?a \\<noteq> 0\n  p = 0 \\<Longrightarrow> c = 0 \\<and> pis = []\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "from yun(1)"], ["proof (chain)\npicking this:\n  p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)", "have p: \"p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)\""], ["proof (prove)\nusing this:\n  p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)", "."], ["proof (state)\nthis:\n  p = smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "have \"{x. poly p x = 0} = {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} =\n    {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0}", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)) x = 0} =\n    {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0}", "using c"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {x. poly (smult c (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i)) x = 0} =\n    {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0}", "by auto"], ["proof (state)\nthis:\n  {x. poly p x = 0} = {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0}\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "also"], ["proof (state)\nthis:\n  {x. poly p x = 0} = {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0}\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "have \"\\<dots> = \\<Union> ((\\<lambda> p. {x. poly p x = 0}) ` fst ` set pis)\" (is \"_ = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0} =\n    (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "by (subst poly_prod_0, force+)"], ["proof (state)\nthis:\n  {x. poly (\\<Prod>(a, i)\\<in>set pis. a ^ Suc i) x = 0} =\n  (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "finally"], ["proof (chain)\npicking this:\n  {x. poly p x = 0} = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "have r: \"{x. poly p x = 0} = ?r\""], ["proof (prove)\nusing this:\n  {x. poly p x = 0} = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "."], ["proof (state)\nthis:\n  {x. poly p x = 0} = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "{"], ["proof (state)\nthis:\n  {x. poly p x = 0} = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "fix p i"], ["proof (state)\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "assume p: \"(p,i) \\<in> set pis\""], ["proof (state)\nthis:\n  (p, i) \\<in> set pis\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "have \"set (roots_of_real_main p) = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots_of_real_main p) = {x. poly p x = 0}", "by (rule roots_of_real_main, insert yun(2)[OF p] pis[OF p], auto)"], ["proof (state)\nthis:\n  set (roots_of_real_main p) = {x. poly p x = 0}\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "}"], ["proof (state)\nthis:\n  (?pa2, ?i2) \\<in> set pis \\<Longrightarrow>\n  set (roots_of_real_main ?pa2) = {x. poly ?pa2 x = 0}\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "note main = this"], ["proof (state)\nthis:\n  (?pa2, ?i2) \\<in> set pis \\<Longrightarrow>\n  set (roots_of_real_main ?pa2) = {x. poly ?pa2 x = 0}\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "have \"set xs = \\<Union> ((\\<lambda> (p, i). set (roots_of_real_main p)) ` set pis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = (\\<Union>(p, i)\\<in>set pis. set (roots_of_real_main p))", "unfolding xs o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat (map (\\<lambda>x. roots_of_real_main (fst x)) pis)) =\n    (\\<Union>(p, i)\\<in>set pis. set (roots_of_real_main p))", "by auto"], ["proof (state)\nthis:\n  set xs = (\\<Union>(p, i)\\<in>set pis. set (roots_of_real_main p))\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "also"], ["proof (state)\nthis:\n  set xs = (\\<Union>(p, i)\\<in>set pis. set (roots_of_real_main p))\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(p, i)\\<in>set pis. set (roots_of_real_main p)) =\n    (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "using main"], ["proof (prove)\nusing this:\n  (?pa2, ?i2) \\<in> set pis \\<Longrightarrow>\n  set (roots_of_real_main ?pa2) = {x. poly ?pa2 x = 0}\n\ngoal (1 subgoal):\n 1. (\\<Union>(p, i)\\<in>set pis. set (roots_of_real_main p)) =\n    (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "by auto"], ["proof (state)\nthis:\n  (\\<Union>(p, i)\\<in>set pis. set (roots_of_real_main p)) =\n  (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "finally"], ["proof (chain)\npicking this:\n  set xs = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "show ?thesis"], ["proof (prove)\nusing this:\n  set xs = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. set xs = {x. poly p x = 0}", "unfolding r"], ["proof (prove)\nusing this:\n  set xs = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})\n\ngoal (1 subgoal):\n 1. set xs = (\\<Union>p\\<in>fst ` set pis. {x. poly p x = 0})", "by simp"], ["proof (state)\nthis:\n  set xs = {x. poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}