{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers/Sturm_Rat.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers", "problem_names": ["lemma root_primitive_part [simp]:\n  fixes p :: \"'a :: {semiring_gcd, semiring_no_zero_divisors} poly\"\n  shows  \"poly (primitive_part p) x = 0 \\<longleftrightarrow> poly p x = 0\"", "lemma irreducible_primitive_part:\n  assumes \"irreducible p\" and \"degree p > 0\"\n  shows \"primitive_part p = p\"", "lemma count_roots_interval_iff: \"square_free p \\<Longrightarrow> count_roots_interval p = count_roots_interval_sf p\"", "lemma count_roots_interval_sf: assumes p: \"p \\<noteq> 0\" \n  and cr: \"count_roots_interval_sf p = (cr,nr)\"\n  shows \"a \\<le> b \\<Longrightarrow> cr a b = (card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0})\"\n    \"nr a = card {x. x \\<le> a \\<and> poly p x = 0}\"", "lemma count_roots_interval: assumes cr: \"count_roots_interval p = (cr,nr)\"\n  and sf: \"square_free p\"\n  shows \"a \\<le> b \\<Longrightarrow> cr a b = (card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0})\"\n    \"nr a = card {x. x \\<le> a \\<and> poly p x = 0}\"", "lemma root_info_condD: \"root_info_cond ri p \\<Longrightarrow> a \\<le> b \\<Longrightarrow> root_info.l_r ri a b = card {x. root_cond (p,a,b) x}\"\n  \"root_info_cond ri p \\<Longrightarrow> root_info.number_root ri a = card {x. x \\<le> real_of_rat a \\<and> ipoly p x = 0}\"", "lemma count_roots_interval_sf_rat: assumes p: \"p \\<noteq> 0\" \n  shows \"root_info_cond (count_roots_interval_sf_rat p) p\"", "lemma of_rat_of_int_poly: \"map_poly of_rat (of_int_poly p) = of_int_poly p\"", "lemma square_free_of_int_poly: assumes \"square_free p\" \n  shows \"square_free (of_int_poly p :: 'a :: {field_gcd, field_char_0} poly)\"", "lemma count_roots_interval_rat: assumes sf: \"square_free p\"\n  shows \"root_info_cond (count_roots_interval_rat p) p\"", "lemma count_roots_rat: \"count_roots_rat p = card {x. ipoly p x = (0 :: real)}\"", "lemma sturm_aux_rat: \"sturm_aux (real_of_rat_poly p) (real_of_rat_poly q) = \n  map real_of_rat_poly (sturm_aux_rat p q)\"", "lemma sturm_rat: \"sturm (real_of_rat_poly p) = map real_of_rat_poly (sturm_rat p)\"", "lemma poly_number_rootat: \"poly_inf (real_of_rat_poly p) = real_of_rat (poly_number_rootat p)\"", "lemma poly_neg_number_rootat: \"poly_neg_inf (real_of_rat_poly p) = real_of_rat (poly_neg_number_rootat p)\"", "lemma real_of_rat_list_neq: \"list_neq (map real_of_rat xs) 0 \n  = map real_of_rat (list_neq xs 0)\"", "lemma real_of_rat_remdups_adj: \"remdups_adj (map real_of_rat xs) = map real_of_rat (remdups_adj xs)\"", "lemma sign_changes_rat: \"sign_changes (map real_of_rat_poly ps) (real_of_rat x)\n  = sign_changes_rat ps x\" (is \"?l = ?r\")", "lemma sign_changes_neg_number_rootat: \"sign_changes_neg_inf (map real_of_rat_poly ps)\n  =  sign_changes_neg_number_rootat ps\" (is \"?l = ?r\")", "lemma sign_changes_number_rootat: \"sign_changes_inf (map real_of_rat_poly ps)\n  =  sign_changes_number_rootat ps\" (is \"?l = ?r\")", "lemma count_roots_interval_rat_code[code]:\n  \"count_roots_interval_rat p = (let rp = map_poly rat_of_int p; ps = sturm_rat rp\n    in Root_Info \n      (\\<lambda> a b. sign_changes_rat ps a - sign_changes_rat ps b + (if poly rp a = 0 then 1 else 0))\n      (\\<lambda> a. sign_changes_neg_number_rootat ps - sign_changes_rat ps a))\"", "lemma count_roots_rat_code[code]:\n  \"count_roots_rat p = (let rp = map_poly rat_of_int p in if p = 0 then 0 else let ps = sturm_rat rp\n    in sign_changes_neg_number_rootat ps - sign_changes_number_rootat ps)\"", "lemma root_info:\n  assumes irr: \"irreducible p\" and deg: \"degree p > 0\"\n  shows \"root_info_cond (root_info p) p\""], "translations": [["", "lemma root_primitive_part [simp]:\n  fixes p :: \"'a :: {semiring_gcd, semiring_no_zero_divisors} poly\"\n  shows  \"poly (primitive_part p) x = 0 \\<longleftrightarrow> poly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))", "proof(cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))", "by auto"], ["proof (state)\nthis:\n  (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))", "have \"poly p x = content p * poly (primitive_part p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = content p * poly (primitive_part p) x", "by (metis content_times_primitive_part poly_smult)"], ["proof (state)\nthis:\n  poly p x = content p * poly (primitive_part p) x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))", "also"], ["proof (state)\nthis:\n  poly p x = content p * poly (primitive_part p) x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))", "have \"\\<dots> = 0 \\<longleftrightarrow> poly (primitive_part p) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (content p * poly (primitive_part p) x = (0::'a)) =\n    (poly (primitive_part p) x = (0::'a))", "by (simp add: False)"], ["proof (state)\nthis:\n  (content p * poly (primitive_part p) x = (0::'a)) =\n  (poly (primitive_part p) x = (0::'a))\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))", "finally"], ["proof (chain)\npicking this:\n  (poly p x = (0::'a)) = (poly (primitive_part p) x = (0::'a))", "show ?thesis"], ["proof (prove)\nusing this:\n  (poly p x = (0::'a)) = (poly (primitive_part p) x = (0::'a))\n\ngoal (1 subgoal):\n 1. (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))", "by auto"], ["proof (state)\nthis:\n  (poly (primitive_part p) x = (0::'a)) = (poly p x = (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*TODO: Move*)"], ["", "lemma irreducible_primitive_part:\n  assumes \"irreducible p\" and \"degree p > 0\"\n  shows \"primitive_part p = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_part p = p", "using irreducible_content[OF assms(1), unfolded primitive_iff_content_eq_1] assms(2)"], ["proof (prove)\nusing this:\n  degree p = 0 \\<or> content p = (1::'a)\n  0 < degree p\n\ngoal (1 subgoal):\n 1. primitive_part p = p", "by (auto simp: primitive_part_def abs_poly_def)"], ["", "subsection \\<open>Interface for Separating Roots\\<close>"], ["", "text \\<open>For a given rational polynomial, we need to know how many real roots are in a given closed interval,\n  and how many real roots are in an interval $(-\\infty,r]$.\\<close>"], ["", "datatype root_info = Root_Info (l_r: \"rat \\<Rightarrow> rat \\<Rightarrow> nat\") (number_root: \"rat \\<Rightarrow> nat\")"], ["", "hide_const (open) l_r"], ["", "hide_const (open) number_root"], ["", "definition count_roots_interval_sf :: \"real poly \\<Rightarrow> (real \\<Rightarrow> real \\<Rightarrow> nat) \\<times> (real \\<Rightarrow> nat)\" where\n  \"count_roots_interval_sf p = (let ps = sturm_squarefree p\n    in ((\\<lambda> a b. sign_changes ps a - sign_changes ps b + (if poly p a = 0 then 1 else 0)),\n       (\\<lambda> a. sign_changes_neg_inf ps - sign_changes ps a)))\""], ["", "definition count_roots_interval :: \"real poly \\<Rightarrow> (real \\<Rightarrow> real \\<Rightarrow> nat) \\<times> (real \\<Rightarrow> nat)\" where\n  \"count_roots_interval p = (let ps = sturm p\n    in ((\\<lambda> a b. sign_changes ps a - sign_changes ps b + (if poly p a = 0 then 1 else 0)),\n       (\\<lambda> a. sign_changes_neg_inf ps - sign_changes ps a)))\""], ["", "lemma count_roots_interval_iff: \"square_free p \\<Longrightarrow> count_roots_interval p = count_roots_interval_sf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free p \\<Longrightarrow>\n    count_roots_interval p = count_roots_interval_sf p", "unfolding count_roots_interval_def count_roots_interval_sf_def sturm_squarefree_def\n    square_free_iff_separable separable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime p (pderiv p) \\<Longrightarrow>\n    (let ps = sturm p\n     in (\\<lambda>a b.\n            sign_changes ps a - sign_changes ps b +\n            (if poly p a = 0 then 1 else 0),\n         \\<lambda>a. sign_changes_neg_inf ps - sign_changes ps a)) =\n    (let ps = sturm (p div gcd p (pderiv p))\n     in (\\<lambda>a b.\n            sign_changes ps a - sign_changes ps b +\n            (if poly p a = 0 then 1 else 0),\n         \\<lambda>a. sign_changes_neg_inf ps - sign_changes ps a))", "by (cases \"p = 0\", auto)"], ["", "lemma count_roots_interval_sf: assumes p: \"p \\<noteq> 0\" \n  and cr: \"count_roots_interval_sf p = (cr,nr)\"\n  shows \"a \\<le> b \\<Longrightarrow> cr a b = (card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0})\"\n    \"nr a = card {x. x \\<le> a \\<and> poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> b \\<Longrightarrow>\n     cr a b = card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0}) &&&\n    nr a = card {x. x \\<le> a \\<and> poly p x = 0}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    cr a b = card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0}\n 2. nr a = card {x. x \\<le> a \\<and> poly p x = 0}", "have id: \"a \\<le> b \\<Longrightarrow> { x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0} = \n    { x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<union> (if poly p a = 0 then {a} else {})\" \n    (is \"_ \\<Longrightarrow> _ = ?R \\<union> ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow>\n    {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0} =\n    {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<union>\n    (if poly p a = 0 then {a} else {})", "using not_less"], ["proof (prove)\nusing this:\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow>\n    {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0} =\n    {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<union>\n    (if poly p a = 0 then {a} else {})", "by force"], ["proof (state)\nthis:\n  a \\<le> b \\<Longrightarrow>\n  {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0} =\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<union>\n  (if poly p a = 0 then {a} else {})\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    cr a b = card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0}\n 2. nr a = card {x. x \\<le> a \\<and> poly p x = 0}", "have RS: \"finite ?R\" \"finite ?S\" \"?R \\<inter> ?S = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} &&&\n    finite (if poly p a = 0 then {a} else {}) &&&\n    {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<inter>\n    (if poly p a = 0 then {a} else {}) =\n    {}", "using p"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} &&&\n    finite (if poly p a = 0 then {a} else {}) &&&\n    {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<inter>\n    (if poly p a = 0 then {a} else {}) =\n    {}", "by (auto simp: poly_roots_finite)"], ["proof (state)\nthis:\n  finite {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0}\n  finite (if poly p a = 0 then {a} else {})\n  {x. a < x \\<and> x \\<le> b \\<and> poly p x = 0} \\<inter>\n  (if poly p a = 0 then {a} else {}) =\n  {}\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    cr a b = card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0}\n 2. nr a = card {x. x \\<le> a \\<and> poly p x = 0}", "show \"a \\<le> b \\<Longrightarrow> cr a b = (card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0})\"\n    \"nr a = card {x. x \\<le> a \\<and> poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> b \\<Longrightarrow>\n     cr a b = card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0}) &&&\n    nr a = card {x. x \\<le> a \\<and> poly p x = 0}", "using cr"], ["proof (prove)\nusing this:\n  count_roots_interval_sf p = (cr, nr)\n\ngoal (1 subgoal):\n 1. (a \\<le> b \\<Longrightarrow>\n     cr a b = card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0}) &&&\n    nr a = card {x. x \\<le> a \\<and> poly p x = 0}", "unfolding arg_cong[OF id, of card] card_Un_disjoint[OF RS] \n    count_roots_interval_sf_def count_roots_between_correct[symmetric]\n    count_roots_below_correct[symmetric] count_roots_below_def\n    count_roots_between_def Let_def"], ["proof (prove)\nusing this:\n  (\\<lambda>a b.\n      sign_changes (sturm_squarefree p) a -\n      sign_changes (sturm_squarefree p) b +\n      (if poly p a = 0 then 1 else 0),\n   \\<lambda>a.\n      sign_changes_neg_inf (sturm_squarefree p) -\n      sign_changes (sturm_squarefree p) a) =\n  (cr, nr)\n\ngoal (1 subgoal):\n 1. (a \\<le> b \\<Longrightarrow>\n     cr a b =\n     (if a \\<le> b \\<and> p \\<noteq> 0\n      then sign_changes (sturm_squarefree p) a -\n           sign_changes (sturm_squarefree p) b\n      else 0) +\n     card (if poly p a = 0 then {a} else {})) &&&\n    nr a =\n    (if p = 0 then 0\n     else sign_changes_neg_inf (sturm_squarefree p) -\n          sign_changes (sturm_squarefree p) a)", "using p"], ["proof (prove)\nusing this:\n  (\\<lambda>a b.\n      sign_changes (sturm_squarefree p) a -\n      sign_changes (sturm_squarefree p) b +\n      (if poly p a = 0 then 1 else 0),\n   \\<lambda>a.\n      sign_changes_neg_inf (sturm_squarefree p) -\n      sign_changes (sturm_squarefree p) a) =\n  (cr, nr)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (a \\<le> b \\<Longrightarrow>\n     cr a b =\n     (if a \\<le> b \\<and> p \\<noteq> 0\n      then sign_changes (sturm_squarefree p) a -\n           sign_changes (sturm_squarefree p) b\n      else 0) +\n     card (if poly p a = 0 then {a} else {})) &&&\n    nr a =\n    (if p = 0 then 0\n     else sign_changes_neg_inf (sturm_squarefree p) -\n          sign_changes (sturm_squarefree p) a)", "by auto"], ["proof (state)\nthis:\n  a \\<le> b \\<Longrightarrow>\n  cr a b = card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0}\n  nr a = card {x. x \\<le> a \\<and> poly p x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_roots_interval: assumes cr: \"count_roots_interval p = (cr,nr)\"\n  and sf: \"square_free p\"\n  shows \"a \\<le> b \\<Longrightarrow> cr a b = (card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0})\"\n    \"nr a = card {x. x \\<le> a \\<and> poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> b \\<Longrightarrow>\n     cr a b = card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0}) &&&\n    nr a = card {x. x \\<le> a \\<and> poly p x = 0}", "using count_roots_interval_sf[OF _ cr[unfolded count_roots_interval_iff[OF sf]]] \n    sf[unfolded square_free_def]"], ["proof (prove)\nusing this:\n  \\<lbrakk>p \\<noteq> 0; ?a \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> cr ?a ?b =\n                    card\n                     {x. ?a \\<le> x \\<and> x \\<le> ?b \\<and> poly p x = 0}\n  p \\<noteq> 0 \\<Longrightarrow>\n  nr ?a = card {x. x \\<le> ?a \\<and> poly p x = 0}\n  p \\<noteq> 0 \\<and>\n  (\\<forall>q. 0 < degree q \\<longrightarrow> \\<not> q * q dvd p)\n\ngoal (1 subgoal):\n 1. (a \\<le> b \\<Longrightarrow>\n     cr a b = card {x. a \\<le> x \\<and> x \\<le> b \\<and> poly p x = 0}) &&&\n    nr a = card {x. x \\<le> a \\<and> poly p x = 0}", "by blast+"], ["", "definition root_cond :: \"int poly \\<times> rat \\<times> rat \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"root_cond plr x = (case plr of (p,l,r) \\<Rightarrow> of_rat l \\<le> x \\<and> x \\<le> of_rat r \\<and> ipoly p x = 0)\""], ["", "definition root_info_cond :: \"root_info \\<Rightarrow> int poly \\<Rightarrow> bool\" where\n  \"root_info_cond ri p \\<equiv> (\\<forall> a b. a \\<le> b \\<longrightarrow> root_info.l_r ri a b = card {x. root_cond (p,a,b) x})\n    \\<and> (\\<forall> a. root_info.number_root ri a = card {x. x \\<le> real_of_rat a \\<and> ipoly p x = 0})\""], ["", "lemma root_info_condD: \"root_info_cond ri p \\<Longrightarrow> a \\<le> b \\<Longrightarrow> root_info.l_r ri a b = card {x. root_cond (p,a,b) x}\"\n  \"root_info_cond ri p \\<Longrightarrow> root_info.number_root ri a = card {x. x \\<le> real_of_rat a \\<and> ipoly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>root_info_cond ri p; a \\<le> b\\<rbrakk>\n     \\<Longrightarrow> root_info.l_r ri a b =\n                       card {x. root_cond (p, a, b) x}) &&&\n    (root_info_cond ri p \\<Longrightarrow>\n     root_info.number_root ri a =\n     card {x. x \\<le> real_of_rat a \\<and> poly (real_of_int_poly p) x = 0})", "unfolding root_info_cond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>(\\<forall>a b.\n                  a \\<le> b \\<longrightarrow>\n                  root_info.l_r ri a b =\n                  card {x. root_cond (p, a, b) x}) \\<and>\n              (\\<forall>a.\n                  root_info.number_root ri a =\n                  card\n                   {x. x \\<le> real_of_rat a \\<and>\n                       poly (real_of_int_poly p) x = 0});\n      a \\<le> b\\<rbrakk>\n     \\<Longrightarrow> root_info.l_r ri a b =\n                       card {x. root_cond (p, a, b) x}) &&&\n    ((\\<forall>a b.\n         a \\<le> b \\<longrightarrow>\n         root_info.l_r ri a b = card {x. root_cond (p, a, b) x}) \\<and>\n     (\\<forall>a.\n         root_info.number_root ri a =\n         card\n          {x. x \\<le> real_of_rat a \\<and>\n              poly (real_of_int_poly p) x = 0}) \\<Longrightarrow>\n     root_info.number_root ri a =\n     card {x. x \\<le> real_of_rat a \\<and> poly (real_of_int_poly p) x = 0})", "by auto"], ["", "definition count_roots_interval_sf_rat :: \"int poly \\<Rightarrow> root_info\" where\n  \"count_roots_interval_sf_rat  p = (let pp = real_of_int_poly p;\n    (cr,nr) = count_roots_interval_sf pp\n  in Root_Info (\\<lambda> a b. cr (of_rat a) (of_rat b)) (\\<lambda> a. nr (of_rat a)))\""], ["", "definition count_roots_interval_rat :: \"int poly \\<Rightarrow> root_info\" where\n  [code del]: \"count_roots_interval_rat  p = (let pp = real_of_int_poly p;\n    (cr,nr) = count_roots_interval pp\n  in Root_Info (\\<lambda> a b. cr (of_rat a) (of_rat b)) (\\<lambda> a. nr (of_rat a)))\""], ["", "definition count_roots_rat :: \"int poly \\<Rightarrow> nat\" where\n  [code del]: \"count_roots_rat  p = (count_roots (real_of_int_poly p))\""], ["", "lemma count_roots_interval_sf_rat: assumes p: \"p \\<noteq> 0\" \n  shows \"root_info_cond (count_roots_interval_sf_rat p) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_sf_rat p) p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_sf_rat p) p", "let ?p = \"real_of_int_poly p\""], ["proof (state)\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_sf_rat p) p", "let ?r = real_of_rat"], ["proof (state)\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_sf_rat p) p", "let ?ri = \"count_roots_interval_sf_rat p\""], ["proof (state)\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_sf_rat p) p", "from p"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have p: \"?p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_int_poly p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  real_of_int_poly p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_sf_rat p) p", "obtain cr nr where cr: \"count_roots_interval_sf ?p = (cr,nr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cr nr.\n        count_roots_interval_sf (real_of_int_poly p) =\n        (cr, nr) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  count_roots_interval_sf (real_of_int_poly p) = (cr, nr)\n\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_sf_rat p) p", "have \"?ri = Root_Info (\\<lambda>a b. cr (?r a) (?r b)) (\\<lambda>a. nr (?r a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_interval_sf_rat p =\n    Root_Info (\\<lambda>a b. cr (real_of_rat a) (real_of_rat b))\n     (\\<lambda>a. nr (real_of_rat a))", "unfolding count_roots_interval_sf_rat_def Let_def cr"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (cr, nr) of\n     (cr, nr) \\<Rightarrow>\n       Root_Info (\\<lambda>a b. cr (real_of_rat a) (real_of_rat b))\n        (\\<lambda>a. nr (real_of_rat a))) =\n    Root_Info (\\<lambda>a b. cr (real_of_rat a) (real_of_rat b))\n     (\\<lambda>a. nr (real_of_rat a))", "by auto"], ["proof (state)\nthis:\n  count_roots_interval_sf_rat p =\n  Root_Info (\\<lambda>a b. cr (real_of_rat a) (real_of_rat b))\n   (\\<lambda>a. nr (real_of_rat a))\n\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_sf_rat p) p", "hence id: \"root_info.l_r ?ri = (\\<lambda>a b. cr (?r a) (?r b))\" \"root_info.number_root ?ri = (\\<lambda>a. nr (?r a))\""], ["proof (prove)\nusing this:\n  count_roots_interval_sf_rat p =\n  Root_Info (\\<lambda>a b. cr (real_of_rat a) (real_of_rat b))\n   (\\<lambda>a. nr (real_of_rat a))\n\ngoal (1 subgoal):\n 1. root_info.l_r (count_roots_interval_sf_rat p) =\n    (\\<lambda>a b. cr (real_of_rat a) (real_of_rat b)) &&&\n    root_info.number_root (count_roots_interval_sf_rat p) =\n    (\\<lambda>a. nr (real_of_rat a))", "by auto"], ["proof (state)\nthis:\n  root_info.l_r (count_roots_interval_sf_rat p) =\n  (\\<lambda>a b. cr (real_of_rat a) (real_of_rat b))\n  root_info.number_root (count_roots_interval_sf_rat p) =\n  (\\<lambda>a. nr (real_of_rat a))\n\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_sf_rat p) p", "note cr = count_roots_interval_sf[OF p cr]"], ["proof (state)\nthis:\n  ?a \\<le> ?b \\<Longrightarrow>\n  cr ?a ?b =\n  card\n   {x. ?a \\<le> x \\<and> x \\<le> ?b \\<and> poly (real_of_int_poly p) x = 0}\n  nr ?a = card {x. x \\<le> ?a \\<and> poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_sf_rat p) p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_sf_rat p) p", "unfolding root_info_cond_def id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b.\n        a \\<le> b \\<longrightarrow>\n        cr (real_of_rat a) (real_of_rat b) =\n        card {x. root_cond (p, a, b) x}) \\<and>\n    (\\<forall>a.\n        nr (real_of_rat a) =\n        card\n         {x. x \\<le> real_of_rat a \\<and> poly (real_of_int_poly p) x = 0})", "proof (intro conjI impI allI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       a \\<le> b \\<Longrightarrow>\n       cr (real_of_rat a) (real_of_rat b) = card {x. root_cond (p, a, b) x}\n 2. \\<And>a.\n       nr (real_of_rat a) =\n       card\n        {x. x \\<le> real_of_rat a \\<and> poly (real_of_int_poly p) x = 0}", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       a \\<le> b \\<Longrightarrow>\n       cr (real_of_rat a) (real_of_rat b) = card {x. root_cond (p, a, b) x}\n 2. \\<And>a.\n       nr (real_of_rat a) =\n       card\n        {x. x \\<le> real_of_rat a \\<and> poly (real_of_int_poly p) x = 0}", "show \"nr (?r a) = card {x. x \\<le> (?r a) \\<and> ipoly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nr (real_of_rat a) =\n    card {x. x \\<le> real_of_rat a \\<and> poly (real_of_int_poly p) x = 0}", "using cr(2)[of \"?r a\"]"], ["proof (prove)\nusing this:\n  nr (real_of_rat a) =\n  card {x. x \\<le> real_of_rat a \\<and> poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. nr (real_of_rat a) =\n    card {x. x \\<le> real_of_rat a \\<and> poly (real_of_int_poly p) x = 0}", "by simp"], ["proof (state)\nthis:\n  nr (real_of_rat a) =\n  card {x. x \\<le> real_of_rat a \\<and> poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       a \\<le> b \\<Longrightarrow>\n       cr (real_of_rat a) (real_of_rat b) = card {x. root_cond (p, a, b) x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       a \\<le> b \\<Longrightarrow>\n       cr (real_of_rat a) (real_of_rat b) = card {x. root_cond (p, a, b) x}", "fix a b :: rat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       a \\<le> b \\<Longrightarrow>\n       cr (real_of_rat a) (real_of_rat b) = card {x. root_cond (p, a, b) x}", "assume ab: \"a \\<le> b\""], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       a \\<le> b \\<Longrightarrow>\n       cr (real_of_rat a) (real_of_rat b) = card {x. root_cond (p, a, b) x}", "from ab"], ["proof (chain)\npicking this:\n  a \\<le> b", "have ab: \"?r a \\<le> ?r b\""], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. real_of_rat a \\<le> real_of_rat b", "by (simp add: of_rat_less_eq)"], ["proof (state)\nthis:\n  real_of_rat a \\<le> real_of_rat b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       a \\<le> b \\<Longrightarrow>\n       cr (real_of_rat a) (real_of_rat b) = card {x. root_cond (p, a, b) x}", "from cr(1)[OF this]"], ["proof (chain)\npicking this:\n  cr (real_of_rat a) (real_of_rat b) =\n  card\n   {x. real_of_rat a \\<le> x \\<and>\n       x \\<le> real_of_rat b \\<and> poly (real_of_int_poly p) x = 0}", "show \"cr (?r a) (?r b) = card (Collect (root_cond (p, a, b)))\""], ["proof (prove)\nusing this:\n  cr (real_of_rat a) (real_of_rat b) =\n  card\n   {x. real_of_rat a \\<le> x \\<and>\n       x \\<le> real_of_rat b \\<and> poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. cr (real_of_rat a) (real_of_rat b) =\n    card (Collect (root_cond (p, a, b)))", "unfolding root_cond_def[abs_def] split"], ["proof (prove)\nusing this:\n  cr (real_of_rat a) (real_of_rat b) =\n  card\n   {x. real_of_rat a \\<le> x \\<and>\n       x \\<le> real_of_rat b \\<and> poly (real_of_int_poly p) x = 0}\n\ngoal (1 subgoal):\n 1. cr (real_of_rat a) (real_of_rat b) =\n    card\n     {x. real_of_rat a \\<le> x \\<and>\n         x \\<le> real_of_rat b \\<and> poly (real_of_int_poly p) x = 0}", "by simp"], ["proof (state)\nthis:\n  cr (real_of_rat a) (real_of_rat b) = card (Collect (root_cond (p, a, b)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root_info_cond (count_roots_interval_sf_rat p) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_rat_of_int_poly: \"map_poly of_rat (of_int_poly p) = of_int_poly p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly of_rat (of_int_poly p) = of_int_poly p", "by (subst map_poly_map_poly, auto simp: o_def)"], ["", "lemma square_free_of_int_poly: assumes \"square_free p\" \n  shows \"square_free (of_int_poly p :: 'a :: {field_gcd, field_char_0} poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (of_int_poly p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. square_free (of_int_poly p)", "have \"square_free (map_poly of_rat (of_int_poly p) :: 'a poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (map_poly of_rat (of_int_poly p))", "unfolding of_rat_hom.square_free_map_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. square_free (of_int_poly p)", "by (rule square_free_int_rat[OF assms])"], ["proof (state)\nthis:\n  square_free (map_poly of_rat (of_int_poly p))\n\ngoal (1 subgoal):\n 1. square_free (of_int_poly p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  square_free (map_poly of_rat (of_int_poly p))\n\ngoal (1 subgoal):\n 1. square_free (of_int_poly p)", "unfolding of_rat_of_int_poly"], ["proof (prove)\nusing this:\n  square_free (of_int_poly p)\n\ngoal (1 subgoal):\n 1. square_free (of_int_poly p)", "."], ["proof (state)\nthis:\n  square_free (of_int_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_roots_interval_rat: assumes sf: \"square_free p\"\n  shows \"root_info_cond (count_roots_interval_rat p) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_rat p) p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_rat p) p", "from sf"], ["proof (chain)\npicking this:\n  square_free p", "have sf: \"square_free (real_of_int_poly p)\""], ["proof (prove)\nusing this:\n  square_free p\n\ngoal (1 subgoal):\n 1. square_free (real_of_int_poly p)", "by (rule square_free_of_int_poly)"], ["proof (state)\nthis:\n  square_free (real_of_int_poly p)\n\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_rat p) p", "from sf"], ["proof (chain)\npicking this:\n  square_free (real_of_int_poly p)", "have p: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  square_free (real_of_int_poly p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "unfolding square_free_def"], ["proof (prove)\nusing this:\n  real_of_int_poly p \\<noteq> 0 \\<and>\n  (\\<forall>q.\n      0 < degree q \\<longrightarrow> \\<not> q * q dvd real_of_int_poly p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_rat p) p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_rat p) p", "using count_roots_interval_sf_rat[OF p]"], ["proof (prove)\nusing this:\n  root_info_cond (count_roots_interval_sf_rat p) p\n\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_rat p) p", "unfolding count_roots_interval_rat_def count_roots_interval_sf_rat_def \n    Let_def count_roots_interval_iff[OF sf]"], ["proof (prove)\nusing this:\n  root_info_cond\n   (case count_roots_interval_sf (real_of_int_poly p) of\n    (cr, nr) \\<Rightarrow>\n      Root_Info (\\<lambda>a b. cr (real_of_rat a) (real_of_rat b))\n       (\\<lambda>a. nr (real_of_rat a)))\n   p\n\ngoal (1 subgoal):\n 1. root_info_cond\n     (case count_roots_interval_sf (real_of_int_poly p) of\n      (cr, nr) \\<Rightarrow>\n        Root_Info (\\<lambda>a b. cr (real_of_rat a) (real_of_rat b))\n         (\\<lambda>a. nr (real_of_rat a)))\n     p", "."], ["proof (state)\nthis:\n  root_info_cond (count_roots_interval_rat p) p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_roots_rat: \"count_roots_rat p = card {x. ipoly p x = (0 :: real)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_rat p = card {x. poly (real_of_int_poly p) x = 0}", "unfolding count_roots_rat_def count_roots_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly (real_of_int_poly p) x = 0} =\n    card {x. poly (real_of_int_poly p) x = 0}", ".."], ["", "subsection \\<open>Implementing Sturm on Rational Polynomials\\<close>"], ["", "function sturm_aux_rat where\n\"sturm_aux_rat (p :: rat poly) q =\n    (if degree q = 0 then [p,q] else p # sturm_aux_rat q (-(p mod q)))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>p q. x = (p, q) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>p q pa qa.\n       (p, q) = (pa, qa) \\<Longrightarrow>\n       (if degree q = 0 then [p, q]\n        else p # sturm_aux_rat_sumC (q, - (p mod q))) =\n       (if degree qa = 0 then [pa, qa]\n        else pa # sturm_aux_rat_sumC (qa, - (pa mod qa)))", "by (pat_completeness, simp_all)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All sturm_aux_rat_dom", "by (relation \"measure (degree \\<circ> snd)\",\n                simp_all add: o_def degree_mod_less')"], ["", "lemma sturm_aux_rat: \"sturm_aux (real_of_rat_poly p) (real_of_rat_poly q) = \n  map real_of_rat_poly (sturm_aux_rat p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_aux (real_of_rat_poly p) (real_of_rat_poly q) =\n    map real_of_rat_poly (sturm_aux_rat p q)", "proof (induct p q rule: sturm_aux_rat.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       (degree q \\<noteq> 0 \\<Longrightarrow>\n        sturm_aux (real_of_rat_poly q) (real_of_rat_poly (- (p mod q))) =\n        map real_of_rat_poly\n         (sturm_aux_rat q (- (p mod q)))) \\<Longrightarrow>\n       sturm_aux (real_of_rat_poly p) (real_of_rat_poly q) =\n       map real_of_rat_poly (sturm_aux_rat p q)", "case (1 p q)"], ["proof (state)\nthis:\n  degree q \\<noteq> 0 \\<Longrightarrow>\n  sturm_aux (real_of_rat_poly q) (real_of_rat_poly (- (p mod q))) =\n  map real_of_rat_poly (sturm_aux_rat q (- (p mod q)))\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       (degree q \\<noteq> 0 \\<Longrightarrow>\n        sturm_aux (real_of_rat_poly q) (real_of_rat_poly (- (p mod q))) =\n        map real_of_rat_poly\n         (sturm_aux_rat q (- (p mod q)))) \\<Longrightarrow>\n       sturm_aux (real_of_rat_poly p) (real_of_rat_poly q) =\n       map real_of_rat_poly (sturm_aux_rat p q)", "interpret map_poly_inj_idom_hom of_rat"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_idom_hom of_rat", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       (degree q \\<noteq> 0 \\<Longrightarrow>\n        sturm_aux (real_of_rat_poly q) (real_of_rat_poly (- (p mod q))) =\n        map real_of_rat_poly\n         (sturm_aux_rat q (- (p mod q)))) \\<Longrightarrow>\n       sturm_aux (real_of_rat_poly p) (real_of_rat_poly q) =\n       map real_of_rat_poly (sturm_aux_rat p q)", "note deg = of_int_hom.degree_map_poly_hom"], ["proof (state)\nthis:\n  degree (of_int_poly ?p) = degree ?p\n\ngoal (1 subgoal):\n 1. \\<And>p q.\n       (degree q \\<noteq> 0 \\<Longrightarrow>\n        sturm_aux (real_of_rat_poly q) (real_of_rat_poly (- (p mod q))) =\n        map real_of_rat_poly\n         (sturm_aux_rat q (- (p mod q)))) \\<Longrightarrow>\n       sturm_aux (real_of_rat_poly p) (real_of_rat_poly q) =\n       map real_of_rat_poly (sturm_aux_rat p q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_aux (real_of_rat_poly p) (real_of_rat_poly q) =\n    map real_of_rat_poly (sturm_aux_rat p q)", "unfolding sturm_aux.simps[of \"real_of_rat_poly p\"] sturm_aux_rat.simps[of p]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if degree (real_of_rat_poly q) = 0\n     then [real_of_rat_poly p, real_of_rat_poly q]\n     else real_of_rat_poly p #\n          sturm_aux (real_of_rat_poly q)\n           (- (real_of_rat_poly p mod real_of_rat_poly q))) =\n    map real_of_rat_poly\n     (if degree q = 0 then [p, q] else p # sturm_aux_rat q (- (p mod q)))", "using 1"], ["proof (prove)\nusing this:\n  degree q \\<noteq> 0 \\<Longrightarrow>\n  sturm_aux (real_of_rat_poly q) (real_of_rat_poly (- (p mod q))) =\n  map real_of_rat_poly (sturm_aux_rat q (- (p mod q)))\n\ngoal (1 subgoal):\n 1. (if degree (real_of_rat_poly q) = 0\n     then [real_of_rat_poly p, real_of_rat_poly q]\n     else real_of_rat_poly p #\n          sturm_aux (real_of_rat_poly q)\n           (- (real_of_rat_poly p mod real_of_rat_poly q))) =\n    map real_of_rat_poly\n     (if degree q = 0 then [p, q] else p # sturm_aux_rat q (- (p mod q)))", "by (cases \"degree q = 0\"; simp add: hom_distribs)"], ["proof (state)\nthis:\n  sturm_aux (real_of_rat_poly p) (real_of_rat_poly q) =\n  map real_of_rat_poly (sturm_aux_rat p q)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition sturm_rat where \"sturm_rat p = sturm_aux_rat p (pderiv p)\""], ["", "lemma sturm_rat: \"sturm (real_of_rat_poly p) = map real_of_rat_poly (sturm_rat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm (real_of_rat_poly p) = map real_of_rat_poly (sturm_rat p)", "unfolding sturm_rat_def sturm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_aux (real_of_rat_poly p) (pderiv (real_of_rat_poly p)) =\n    map real_of_rat_poly (sturm_aux_rat p (pderiv p))", "apply (fold of_rat_hom.map_poly_pderiv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sturm_aux (real_of_rat_poly p) (real_of_rat_poly (pderiv p)) =\n    map real_of_rat_poly (sturm_aux_rat p (pderiv p))", "unfolding sturm_aux_rat"], ["proof (prove)\ngoal (1 subgoal):\n 1. map real_of_rat_poly (sturm_aux_rat p (pderiv p)) =\n    map real_of_rat_poly (sturm_aux_rat p (pderiv p))", ".."], ["", "definition poly_number_rootat :: \"rat poly \\<Rightarrow> rat\" where \n  \"poly_number_rootat p \\<equiv> sgn (coeff p (degree p))\""], ["", "definition poly_neg_number_rootat :: \"rat poly \\<Rightarrow> rat\" where \n  \"poly_neg_number_rootat p \\<equiv> if even (degree p) then sgn (coeff p (degree p))\n                                       else -sgn (coeff p (degree p))\""], ["", "lemma poly_number_rootat: \"poly_inf (real_of_rat_poly p) = real_of_rat (poly_number_rootat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_inf (real_of_rat_poly p) = real_of_rat (poly_number_rootat p)", "unfolding poly_inf_def poly_number_rootat_def of_int_hom.degree_map_poly_hom of_rat_hom.coeff_map_poly_hom\n    real_of_rat_sgn"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (sgn (coeff p (degree (real_of_rat_poly p)))) =\n    real_of_rat (sgn (lead_coeff p))", "by simp"], ["", "lemma poly_neg_number_rootat: \"poly_neg_inf (real_of_rat_poly p) = real_of_rat (poly_neg_number_rootat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_neg_inf (real_of_rat_poly p) =\n    real_of_rat (poly_neg_number_rootat p)", "unfolding poly_neg_inf_def poly_neg_number_rootat_def of_int_hom.degree_map_poly_hom of_rat_hom.coeff_map_poly_hom\n    real_of_rat_sgn"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even (degree (real_of_rat_poly p))\n     then real_of_rat (sgn (coeff p (degree (real_of_rat_poly p))))\n     else - real_of_rat (sgn (coeff p (degree (real_of_rat_poly p))))) =\n    real_of_rat\n     (if even (degree p) then sgn (lead_coeff p) else - sgn (lead_coeff p))", "by (simp add:hom_distribs)"], ["", "definition sign_changes_rat where\n\"sign_changes_rat ps (x::rat) =\n    length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map (\\<lambda>p. sgn (poly p x)) ps))) - 1\""], ["", "definition sign_changes_number_rootat where\n  \"sign_changes_number_rootat ps = \n    length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_number_rootat ps))) - 1\""], ["", "definition sign_changes_neg_number_rootat where\n  \"sign_changes_neg_number_rootat ps = \n      length (remdups_adj (filter (\\<lambda>x. x \\<noteq> 0) (map poly_neg_number_rootat ps))) - 1\""], ["", "lemma real_of_rat_list_neq: \"list_neq (map real_of_rat xs) 0 \n  = map real_of_rat (list_neq xs 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_neq (map real_of_rat xs) 0 = map real_of_rat (list_neq xs 0)", "by (induct xs, auto)"], ["", "lemma real_of_rat_remdups_adj: \"remdups_adj (map real_of_rat xs) = map real_of_rat (remdups_adj xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups_adj (map real_of_rat xs) = map real_of_rat (remdups_adj xs)", "by (induct xs rule: remdups_adj.induct, auto)"], ["", "lemma sign_changes_rat: \"sign_changes (map real_of_rat_poly ps) (real_of_rat x)\n  = sign_changes_rat ps x\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (map real_of_rat_poly ps) (real_of_rat x) =\n    sign_changes_rat ps x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes (map real_of_rat_poly ps) (real_of_rat x) =\n    sign_changes_rat ps x", "define xs where \"xs = list_neq (map (\\<lambda>p. sgn (poly p x)) ps) 0\""], ["proof (state)\nthis:\n  xs = list_neq (map (\\<lambda>p. sgn (poly p x)) ps) 0\n\ngoal (1 subgoal):\n 1. sign_changes (map real_of_rat_poly ps) (real_of_rat x) =\n    sign_changes_rat ps x", "have \"?l = length (remdups_adj (list_neq (map real_of_rat (map (\\<lambda>xa.  (sgn (poly xa x))) ps)) 0)) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes (map real_of_rat_poly ps) (real_of_rat x) =\n    length\n     (remdups_adj\n       (list_neq (map real_of_rat (map (\\<lambda>xa. sgn (poly xa x)) ps))\n         0)) -\n    1", "by (simp add: sign_changes_def real_of_rat_sgn o_def)"], ["proof (state)\nthis:\n  sign_changes (map real_of_rat_poly ps) (real_of_rat x) =\n  length\n   (remdups_adj\n     (list_neq (map real_of_rat (map (\\<lambda>xa. sgn (poly xa x)) ps))\n       0)) -\n  1\n\ngoal (1 subgoal):\n 1. sign_changes (map real_of_rat_poly ps) (real_of_rat x) =\n    sign_changes_rat ps x", "also"], ["proof (state)\nthis:\n  sign_changes (map real_of_rat_poly ps) (real_of_rat x) =\n  length\n   (remdups_adj\n     (list_neq (map real_of_rat (map (\\<lambda>xa. sgn (poly xa x)) ps))\n       0)) -\n  1\n\ngoal (1 subgoal):\n 1. sign_changes (map real_of_rat_poly ps) (real_of_rat x) =\n    sign_changes_rat ps x", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (list_neq (map real_of_rat (map (\\<lambda>xa. sgn (poly xa x)) ps))\n         0)) -\n    1 =\n    sign_changes_rat ps x", "unfolding sign_changes_rat_def real_of_rat_list_neq"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (map real_of_rat\n         (list_neq (map (\\<lambda>xa. sgn (poly xa x)) ps) 0))) -\n    1 =\n    length\n     (remdups_adj (list_neq (map (\\<lambda>p. sgn (poly p x)) ps) 0)) -\n    1", "unfolding real_of_rat_remdups_adj"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map real_of_rat\n       (remdups_adj (list_neq (map (\\<lambda>xa. sgn (poly xa x)) ps) 0))) -\n    1 =\n    length\n     (remdups_adj (list_neq (map (\\<lambda>p. sgn (poly p x)) ps) 0)) -\n    1", "by simp"], ["proof (state)\nthis:\n  length\n   (remdups_adj\n     (list_neq (map real_of_rat (map (\\<lambda>xa. sgn (poly xa x)) ps))\n       0)) -\n  1 =\n  sign_changes_rat ps x\n\ngoal (1 subgoal):\n 1. sign_changes (map real_of_rat_poly ps) (real_of_rat x) =\n    sign_changes_rat ps x", "finally"], ["proof (chain)\npicking this:\n  sign_changes (map real_of_rat_poly ps) (real_of_rat x) =\n  sign_changes_rat ps x", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes (map real_of_rat_poly ps) (real_of_rat x) =\n  sign_changes_rat ps x\n\ngoal (1 subgoal):\n 1. sign_changes (map real_of_rat_poly ps) (real_of_rat x) =\n    sign_changes_rat ps x", "."], ["proof (state)\nthis:\n  sign_changes (map real_of_rat_poly ps) (real_of_rat x) =\n  sign_changes_rat ps x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_changes_neg_number_rootat: \"sign_changes_neg_inf (map real_of_rat_poly ps)\n  =  sign_changes_neg_number_rootat ps\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes_neg_inf (map real_of_rat_poly ps) =\n    sign_changes_neg_number_rootat ps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes_neg_inf (map real_of_rat_poly ps) =\n    sign_changes_neg_number_rootat ps", "have \"?l = length (remdups_adj (list_neq (map real_of_rat (map poly_neg_number_rootat ps)) 0)) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes_neg_inf (map real_of_rat_poly ps) =\n    length\n     (remdups_adj\n       (list_neq (map real_of_rat (map poly_neg_number_rootat ps)) 0)) -\n    1", "by (simp add: sign_changes_neg_inf_def o_def real_of_rat_sgn poly_neg_number_rootat)"], ["proof (state)\nthis:\n  sign_changes_neg_inf (map real_of_rat_poly ps) =\n  length\n   (remdups_adj\n     (list_neq (map real_of_rat (map poly_neg_number_rootat ps)) 0)) -\n  1\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf (map real_of_rat_poly ps) =\n    sign_changes_neg_number_rootat ps", "also"], ["proof (state)\nthis:\n  sign_changes_neg_inf (map real_of_rat_poly ps) =\n  length\n   (remdups_adj\n     (list_neq (map real_of_rat (map poly_neg_number_rootat ps)) 0)) -\n  1\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf (map real_of_rat_poly ps) =\n    sign_changes_neg_number_rootat ps", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (list_neq (map real_of_rat (map poly_neg_number_rootat ps)) 0)) -\n    1 =\n    sign_changes_neg_number_rootat ps", "unfolding sign_changes_neg_number_rootat_def real_of_rat_list_neq"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (map real_of_rat (list_neq (map poly_neg_number_rootat ps) 0))) -\n    1 =\n    length (remdups_adj (list_neq (map poly_neg_number_rootat ps) 0)) - 1", "unfolding real_of_rat_remdups_adj"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map real_of_rat\n       (remdups_adj (list_neq (map poly_neg_number_rootat ps) 0))) -\n    1 =\n    length (remdups_adj (list_neq (map poly_neg_number_rootat ps) 0)) - 1", "by simp"], ["proof (state)\nthis:\n  length\n   (remdups_adj\n     (list_neq (map real_of_rat (map poly_neg_number_rootat ps)) 0)) -\n  1 =\n  sign_changes_neg_number_rootat ps\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf (map real_of_rat_poly ps) =\n    sign_changes_neg_number_rootat ps", "finally"], ["proof (chain)\npicking this:\n  sign_changes_neg_inf (map real_of_rat_poly ps) =\n  sign_changes_neg_number_rootat ps", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes_neg_inf (map real_of_rat_poly ps) =\n  sign_changes_neg_number_rootat ps\n\ngoal (1 subgoal):\n 1. sign_changes_neg_inf (map real_of_rat_poly ps) =\n    sign_changes_neg_number_rootat ps", "."], ["proof (state)\nthis:\n  sign_changes_neg_inf (map real_of_rat_poly ps) =\n  sign_changes_neg_number_rootat ps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sign_changes_number_rootat: \"sign_changes_inf (map real_of_rat_poly ps)\n  =  sign_changes_number_rootat ps\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes_inf (map real_of_rat_poly ps) =\n    sign_changes_number_rootat ps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sign_changes_inf (map real_of_rat_poly ps) =\n    sign_changes_number_rootat ps", "have \"?l = length (remdups_adj (list_neq (map real_of_rat (map poly_number_rootat ps)) 0)) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign_changes_inf (map real_of_rat_poly ps) =\n    length\n     (remdups_adj\n       (list_neq (map real_of_rat (map poly_number_rootat ps)) 0)) -\n    1", "unfolding sign_changes_inf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj (list_neq (map poly_inf (map real_of_rat_poly ps)) 0)) -\n    1 =\n    length\n     (remdups_adj\n       (list_neq (map real_of_rat (map poly_number_rootat ps)) 0)) -\n    1", "unfolding map_map o_def real_of_rat_sgn poly_number_rootat"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (list_neq (map (\\<lambda>x. real_of_rat (poly_number_rootat x)) ps)\n         0)) -\n    1 =\n    length\n     (remdups_adj\n       (list_neq (map (\\<lambda>x. real_of_rat (poly_number_rootat x)) ps)\n         0)) -\n    1", ".."], ["proof (state)\nthis:\n  sign_changes_inf (map real_of_rat_poly ps) =\n  length\n   (remdups_adj\n     (list_neq (map real_of_rat (map poly_number_rootat ps)) 0)) -\n  1\n\ngoal (1 subgoal):\n 1. sign_changes_inf (map real_of_rat_poly ps) =\n    sign_changes_number_rootat ps", "also"], ["proof (state)\nthis:\n  sign_changes_inf (map real_of_rat_poly ps) =\n  length\n   (remdups_adj\n     (list_neq (map real_of_rat (map poly_number_rootat ps)) 0)) -\n  1\n\ngoal (1 subgoal):\n 1. sign_changes_inf (map real_of_rat_poly ps) =\n    sign_changes_number_rootat ps", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (list_neq (map real_of_rat (map poly_number_rootat ps)) 0)) -\n    1 =\n    sign_changes_number_rootat ps", "unfolding sign_changes_number_rootat_def real_of_rat_list_neq"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remdups_adj\n       (map real_of_rat (list_neq (map poly_number_rootat ps) 0))) -\n    1 =\n    length (remdups_adj (list_neq (map poly_number_rootat ps) 0)) - 1", "unfolding real_of_rat_remdups_adj"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map real_of_rat\n       (remdups_adj (list_neq (map poly_number_rootat ps) 0))) -\n    1 =\n    length (remdups_adj (list_neq (map poly_number_rootat ps) 0)) - 1", "by simp"], ["proof (state)\nthis:\n  length\n   (remdups_adj\n     (list_neq (map real_of_rat (map poly_number_rootat ps)) 0)) -\n  1 =\n  sign_changes_number_rootat ps\n\ngoal (1 subgoal):\n 1. sign_changes_inf (map real_of_rat_poly ps) =\n    sign_changes_number_rootat ps", "finally"], ["proof (chain)\npicking this:\n  sign_changes_inf (map real_of_rat_poly ps) = sign_changes_number_rootat ps", "show ?thesis"], ["proof (prove)\nusing this:\n  sign_changes_inf (map real_of_rat_poly ps) = sign_changes_number_rootat ps\n\ngoal (1 subgoal):\n 1. sign_changes_inf (map real_of_rat_poly ps) =\n    sign_changes_number_rootat ps", "."], ["proof (state)\nthis:\n  sign_changes_inf (map real_of_rat_poly ps) = sign_changes_number_rootat ps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma count_roots_interval_rat_code[code]:\n  \"count_roots_interval_rat p = (let rp = map_poly rat_of_int p; ps = sturm_rat rp\n    in Root_Info \n      (\\<lambda> a b. sign_changes_rat ps a - sign_changes_rat ps b + (if poly rp a = 0 then 1 else 0))\n      (\\<lambda> a. sign_changes_neg_number_rootat ps - sign_changes_rat ps a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_interval_rat p =\n    (let rp = of_int_poly p; ps = sturm_rat rp\n     in Root_Info\n         (\\<lambda>a b.\n             sign_changes_rat ps a - sign_changes_rat ps b +\n             (if poly rp a = 0 then 1 else 0))\n         (\\<lambda>a.\n             sign_changes_neg_number_rootat ps - sign_changes_rat ps a))", "unfolding count_roots_interval_rat_def Let_def count_roots_interval_def split of_rat_of_int_poly[symmetric, where 'a = real]\n    sturm_rat sign_changes_rat"], ["proof (prove)\ngoal (1 subgoal):\n 1. Root_Info\n     (\\<lambda>a b.\n         sign_changes_rat (sturm_rat (of_int_poly p)) a -\n         sign_changes_rat (sturm_rat (of_int_poly p)) b +\n         (if poly (real_of_rat_poly (of_int_poly p)) (real_of_rat a) = 0\n          then 1 else 0))\n     (\\<lambda>a.\n         sign_changes_neg_inf\n          (map real_of_rat_poly (sturm_rat (of_int_poly p))) -\n         sign_changes_rat (sturm_rat (of_int_poly p)) a) =\n    Root_Info\n     (\\<lambda>a b.\n         sign_changes_rat (sturm_rat (of_int_poly p)) a -\n         sign_changes_rat (sturm_rat (of_int_poly p)) b +\n         (if ipoly p a = 0 then 1 else 0))\n     (\\<lambda>a.\n         sign_changes_neg_number_rootat (sturm_rat (of_int_poly p)) -\n         sign_changes_rat (sturm_rat (of_int_poly p)) a)", "by (simp add: sign_changes_neg_number_rootat)"], ["", "lemma count_roots_rat_code[code]:\n  \"count_roots_rat p = (let rp = map_poly rat_of_int p in if p = 0 then 0 else let ps = sturm_rat rp\n    in sign_changes_neg_number_rootat ps - sign_changes_number_rootat ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_roots_rat p =\n    (let rp = of_int_poly p\n     in if p = 0 then 0\n        else let ps = sturm_rat rp\n             in sign_changes_neg_number_rootat ps -\n                sign_changes_number_rootat ps)", "unfolding count_roots_rat_def Let_def sturm_rat count_roots_code of_rat_of_int_poly[symmetric, where 'a = real]\n    sign_changes_neg_number_rootat sign_changes_number_rootat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if real_of_rat_poly (of_int_poly p) = 0 then 0\n     else sign_changes_neg_number_rootat (sturm_rat (of_int_poly p)) -\n          sign_changes_number_rootat (sturm_rat (of_int_poly p))) =\n    (if p = 0 then 0\n     else sign_changes_neg_number_rootat (sturm_rat (of_int_poly p)) -\n          sign_changes_number_rootat (sturm_rat (of_int_poly p)))", "by simp"], ["", "hide_const (open) count_roots_interval_sf_rat"], ["", "text \\<open>Finally we provide an even more efficient implementation which\n  avoids the \"poly p x = 0\" test, but it is restricted to irreducible polynomials.\\<close>"], ["", "definition root_info :: \"int poly \\<Rightarrow> root_info\" where\n  \"root_info p = (if degree p = 1 then \n    (let x = Rat.Fract (- coeff p 0) (coeff p 1)\n     in Root_Info (\\<lambda> l r. if l \\<le> x \\<and> x \\<le> r then 1 else 0)  (\\<lambda> b. if x \\<le> b then 1 else 0)) else \n    (let rp = map_poly rat_of_int p; ps = sturm_rat rp in \n   Root_Info (\\<lambda> a b. sign_changes_rat ps a - sign_changes_rat ps b)\n      (\\<lambda> a. sign_changes_neg_number_rootat ps - sign_changes_rat ps a)))\""], ["", "lemma root_info:\n  assumes irr: \"irreducible p\" and deg: \"degree p > 0\"\n  shows \"root_info_cond (root_info p) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_info_cond (root_info p) p", "proof (cases \"degree p = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow> root_info_cond (root_info p) p\n 2. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "case deg: True"], ["proof (state)\nthis:\n  degree p = 1\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow> root_info_cond (root_info p) p\n 2. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "from degree1_coeffs[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>a b. p = [:b, a:] \\<and> a \\<noteq> 0", "obtain a b where p: \"p = [:b,a:]\" and \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>a b. p = [:b, a:] \\<and> a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>b a.\n        \\<lbrakk>p = [:b, a:]; a \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = [:b, a:]\n  a \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow> root_info_cond (root_info p) p\n 2. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "from deg"], ["proof (chain)\npicking this:\n  degree p = 1", "have \"degree (real_of_int_poly p) = 1\""], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. degree (real_of_int_poly p) = 1", "by simp"], ["proof (state)\nthis:\n  degree (real_of_int_poly p) = 1\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow> root_info_cond (root_info p) p\n 2. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "from roots1[OF this, unfolded roots1_def] p"], ["proof (chain)\npicking this:\n  {x. poly (real_of_int_poly p) x = 0} =\n  {- coeff (real_of_int_poly p) 0 / coeff (real_of_int_poly p) 1}\n  p = [:b, a:]", "have id: \"(ipoly p x = 0) = ((x :: real) = - b / a)\" for x"], ["proof (prove)\nusing this:\n  {x. poly (real_of_int_poly p) x = 0} =\n  {- coeff (real_of_int_poly p) 0 / coeff (real_of_int_poly p) 1}\n  p = [:b, a:]\n\ngoal (1 subgoal):\n 1. (poly (real_of_int_poly p) x = 0) =\n    (x = real_of_int (- b) / real_of_int a)", "by auto"], ["proof (state)\nthis:\n  (poly (real_of_int_poly p) ?x = 0) =\n  (?x = real_of_int (- b) / real_of_int a)\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow> root_info_cond (root_info p) p\n 2. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "have idd: \"{x. real_of_rat aa \\<le> x \\<and>\n                 x \\<le> real_of_rat ba \\<and> x = real_of_int (- b) / real_of_int a} \n   = (if real_of_rat aa \\<le> real_of_int (- b) / real_of_int a \\<and>\n                 real_of_int (- b) / real_of_int a \\<le> real_of_rat ba then {real_of_int (- b) / real_of_int a} else {})\" \n    for aa ba"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. real_of_rat aa \\<le> x \\<and>\n        x \\<le> real_of_rat ba \\<and>\n        x = real_of_int (- b) / real_of_int a} =\n    (if real_of_rat aa \\<le> real_of_int (- b) / real_of_int a \\<and>\n        real_of_int (- b) / real_of_int a \\<le> real_of_rat ba\n     then {real_of_int (- b) / real_of_int a} else {})", "by auto"], ["proof (state)\nthis:\n  {x. real_of_rat ?aa \\<le> x \\<and>\n      x \\<le> real_of_rat ?ba \\<and>\n      x = real_of_int (- b) / real_of_int a} =\n  (if real_of_rat ?aa \\<le> real_of_int (- b) / real_of_int a \\<and>\n      real_of_int (- b) / real_of_int a \\<le> real_of_rat ?ba\n   then {real_of_int (- b) / real_of_int a} else {})\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow> root_info_cond (root_info p) p\n 2. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "have iddd: \"{x. x \\<le> real_of_rat aa \\<and> x = real_of_int (- b) / real_of_int a}\n    = (if real_of_int (- b) / real_of_int a \\<le> real_of_rat aa then {real_of_int (- b) / real_of_int a} else {})\" for aa"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x \\<le> real_of_rat aa \\<and>\n        x = real_of_int (- b) / real_of_int a} =\n    (if real_of_int (- b) / real_of_int a \\<le> real_of_rat aa\n     then {real_of_int (- b) / real_of_int a} else {})", "by auto"], ["proof (state)\nthis:\n  {x. x \\<le> real_of_rat ?aa \\<and>\n      x = real_of_int (- b) / real_of_int a} =\n  (if real_of_int (- b) / real_of_int a \\<le> real_of_rat ?aa\n   then {real_of_int (- b) / real_of_int a} else {})\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow> root_info_cond (root_info p) p\n 2. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "have id4: \"real_of_int x = real_of_rat (rat_of_int x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int x = real_of_rat (rat_of_int x)", "by simp"], ["proof (state)\nthis:\n  real_of_int ?x = real_of_rat (rat_of_int ?x)\n\ngoal (2 subgoals):\n 1. degree p = 1 \\<Longrightarrow> root_info_cond (root_info p) p\n 2. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_info_cond (root_info p) p", "unfolding root_info_def deg"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_info_cond\n     (if 1 = 1\n      then let x = Rat.Fract (- coeff p 0) (coeff p 1)\n           in Root_Info\n               (\\<lambda>l r. if l \\<le> x \\<and> x \\<le> r then 1 else 0)\n               (\\<lambda>b. if x \\<le> b then 1 else 0)\n      else let rp = of_int_poly p; ps = sturm_rat rp\n           in Root_Info\n               (\\<lambda>a b. sign_changes_rat ps a - sign_changes_rat ps b)\n               (\\<lambda>a.\n                   sign_changes_neg_number_rootat ps -\n                   sign_changes_rat ps a))\n     p", "unfolding root_info_cond_def id root_cond_def split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>aa ba.\n        aa \\<le> ba \\<longrightarrow>\n        root_info.l_r\n         (if 1 = 1\n          then let x = Rat.Fract (- coeff p 0) (coeff p 1)\n               in Root_Info\n                   (\\<lambda>l r.\n                       if l \\<le> x \\<and> x \\<le> r then 1 else 0)\n                   (\\<lambda>b. if x \\<le> b then 1 else 0)\n          else let rp = of_int_poly p; ps = sturm_rat rp\n               in Root_Info\n                   (\\<lambda>a b.\n                       sign_changes_rat ps a - sign_changes_rat ps b)\n                   (\\<lambda>a.\n                       sign_changes_neg_number_rootat ps -\n                       sign_changes_rat ps a))\n         aa ba =\n        card\n         {x. real_of_rat aa \\<le> x \\<and>\n             x \\<le> real_of_rat ba \\<and>\n             x = real_of_int (- b) / real_of_int a}) \\<and>\n    (\\<forall>aa.\n        root_info.number_root\n         (if 1 = 1\n          then let x = Rat.Fract (- coeff p 0) (coeff p 1)\n               in Root_Info\n                   (\\<lambda>l r.\n                       if l \\<le> x \\<and> x \\<le> r then 1 else 0)\n                   (\\<lambda>b. if x \\<le> b then 1 else 0)\n          else let rp = of_int_poly p; ps = sturm_rat rp\n               in Root_Info\n                   (\\<lambda>a b.\n                       sign_changes_rat ps a - sign_changes_rat ps b)\n                   (\\<lambda>a.\n                       sign_changes_neg_number_rootat ps -\n                       sign_changes_rat ps a))\n         aa =\n        card\n         {x. x \\<le> real_of_rat aa \\<and>\n             x = real_of_int (- b) / real_of_int a})", "unfolding p Fract_of_int_quotient Let_def idd iddd"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>aa ba.\n        aa \\<le> ba \\<longrightarrow>\n        root_info.l_r\n         (if 1 = 1\n          then Root_Info\n                (\\<lambda>l r.\n                    if l \\<le> rat_of_int (- coeff [:b, a:] 0) /\n                               rat_of_int (coeff [:b, a:] 1) \\<and>\n                       rat_of_int (- coeff [:b, a:] 0) /\n                       rat_of_int (coeff [:b, a:] 1)\n                       \\<le> r\n                    then 1 else 0)\n                (\\<lambda>ba.\n                    if rat_of_int (- coeff [:b, a:] 0) /\n                       rat_of_int (coeff [:b, a:] 1)\n                       \\<le> ba\n                    then 1 else 0)\n          else Root_Info\n                (\\<lambda>aa ba.\n                    sign_changes_rat (sturm_rat (of_int_poly [:b, a:])) aa -\n                    sign_changes_rat (sturm_rat (of_int_poly [:b, a:])) ba)\n                (\\<lambda>aa.\n                    sign_changes_neg_number_rootat\n                     (sturm_rat (of_int_poly [:b, a:])) -\n                    sign_changes_rat (sturm_rat (of_int_poly [:b, a:])) aa))\n         aa ba =\n        card\n         (if real_of_rat aa \\<le> real_of_int (- b) / real_of_int a \\<and>\n             real_of_int (- b) / real_of_int a \\<le> real_of_rat ba\n          then {real_of_int (- b) / real_of_int a} else {})) \\<and>\n    (\\<forall>aa.\n        root_info.number_root\n         (if 1 = 1\n          then Root_Info\n                (\\<lambda>l r.\n                    if l \\<le> rat_of_int (- coeff [:b, a:] 0) /\n                               rat_of_int (coeff [:b, a:] 1) \\<and>\n                       rat_of_int (- coeff [:b, a:] 0) /\n                       rat_of_int (coeff [:b, a:] 1)\n                       \\<le> r\n                    then 1 else 0)\n                (\\<lambda>ba.\n                    if rat_of_int (- coeff [:b, a:] 0) /\n                       rat_of_int (coeff [:b, a:] 1)\n                       \\<le> ba\n                    then 1 else 0)\n          else Root_Info\n                (\\<lambda>aa ba.\n                    sign_changes_rat (sturm_rat (of_int_poly [:b, a:])) aa -\n                    sign_changes_rat (sturm_rat (of_int_poly [:b, a:])) ba)\n                (\\<lambda>aa.\n                    sign_changes_neg_number_rootat\n                     (sturm_rat (of_int_poly [:b, a:])) -\n                    sign_changes_rat (sturm_rat (of_int_poly [:b, a:])) aa))\n         aa =\n        card\n         (if real_of_int (- b) / real_of_int a \\<le> real_of_rat aa\n          then {real_of_int (- b) / real_of_int a} else {}))", "unfolding id4 of_rat_divide[symmetric] of_rat_less_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>aa ba.\n        aa \\<le> ba \\<longrightarrow>\n        root_info.l_r\n         (if 1 = 1\n          then Root_Info\n                (\\<lambda>l r.\n                    if l \\<le> rat_of_int (- coeff [:b, a:] 0) /\n                               rat_of_int (coeff [:b, a:] 1) \\<and>\n                       rat_of_int (- coeff [:b, a:] 0) /\n                       rat_of_int (coeff [:b, a:] 1)\n                       \\<le> r\n                    then 1 else 0)\n                (\\<lambda>ba.\n                    if rat_of_int (- coeff [:b, a:] 0) /\n                       rat_of_int (coeff [:b, a:] 1)\n                       \\<le> ba\n                    then 1 else 0)\n          else Root_Info\n                (\\<lambda>aa ba.\n                    sign_changes_rat (sturm_rat (of_int_poly [:b, a:])) aa -\n                    sign_changes_rat (sturm_rat (of_int_poly [:b, a:])) ba)\n                (\\<lambda>aa.\n                    sign_changes_neg_number_rootat\n                     (sturm_rat (of_int_poly [:b, a:])) -\n                    sign_changes_rat (sturm_rat (of_int_poly [:b, a:])) aa))\n         aa ba =\n        card\n         (if aa \\<le> rat_of_int (- b) / rat_of_int a \\<and>\n             rat_of_int (- b) / rat_of_int a \\<le> ba\n          then {real_of_rat (rat_of_int (- b) / rat_of_int a)}\n          else {})) \\<and>\n    (\\<forall>aa.\n        root_info.number_root\n         (if 1 = 1\n          then Root_Info\n                (\\<lambda>l r.\n                    if l \\<le> rat_of_int (- coeff [:b, a:] 0) /\n                               rat_of_int (coeff [:b, a:] 1) \\<and>\n                       rat_of_int (- coeff [:b, a:] 0) /\n                       rat_of_int (coeff [:b, a:] 1)\n                       \\<le> r\n                    then 1 else 0)\n                (\\<lambda>ba.\n                    if rat_of_int (- coeff [:b, a:] 0) /\n                       rat_of_int (coeff [:b, a:] 1)\n                       \\<le> ba\n                    then 1 else 0)\n          else Root_Info\n                (\\<lambda>aa ba.\n                    sign_changes_rat (sturm_rat (of_int_poly [:b, a:])) aa -\n                    sign_changes_rat (sturm_rat (of_int_poly [:b, a:])) ba)\n                (\\<lambda>aa.\n                    sign_changes_neg_number_rootat\n                     (sturm_rat (of_int_poly [:b, a:])) -\n                    sign_changes_rat (sturm_rat (of_int_poly [:b, a:])) aa))\n         aa =\n        card\n         (if rat_of_int (- b) / rat_of_int a \\<le> aa\n          then {real_of_rat (rat_of_int (- b) / rat_of_int a)} else {}))", "by auto"], ["proof (state)\nthis:\n  root_info_cond (root_info p) p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "have irr_d: \"irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "by (simp add: deg irr irreducible_connect_rev)"], ["proof (state)\nthis:\n  irreducible\\<^sub>d p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "from irreducible\\<^sub>d_int_rat[OF this]"], ["proof (chain)\npicking this:\n  irreducible\\<^sub>d (of_int_poly p)", "have \"irreducible (of_int_poly p :: rat poly)\""], ["proof (prove)\nusing this:\n  irreducible\\<^sub>d (of_int_poly p)\n\ngoal (1 subgoal):\n 1. irreducible (of_int_poly p)", "by auto"], ["proof (state)\nthis:\n  irreducible (of_int_poly p)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "from irreducible_root_free[OF this]"], ["proof (chain)\npicking this:\n  root_free (of_int_poly p)", "have idd: \"(poly (of_int_poly p) a = 0) = False\" for a :: rat"], ["proof (prove)\nusing this:\n  root_free (of_int_poly p)\n\ngoal (1 subgoal):\n 1. (ipoly p a = 0) = False", "unfolding root_free_def"], ["proof (prove)\nusing this:\n  degree (of_int_poly p) = 1 \\<or> (\\<forall>x. ipoly p x \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (ipoly p a = 0) = False", "using False"], ["proof (prove)\nusing this:\n  degree (of_int_poly p) = 1 \\<or> (\\<forall>x. ipoly p x \\<noteq> 0)\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (ipoly p a = 0) = False", "by auto"], ["proof (state)\nthis:\n  (ipoly p ?a = 0) = False\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "have id: \"root_info p = count_roots_interval_rat p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_info p = count_roots_interval_rat p", "unfolding root_info_def if_False count_roots_interval_rat_code Let_def idd"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if degree p = 1\n     then Root_Info\n           (\\<lambda>l r.\n               if l \\<le> Rat.Fract (- coeff p 0) (coeff p 1) \\<and>\n                  Rat.Fract (- coeff p 0) (coeff p 1) \\<le> r\n               then 1 else 0)\n           (\\<lambda>b.\n               if Rat.Fract (- coeff p 0) (coeff p 1) \\<le> b then 1 else 0)\n     else Root_Info\n           (\\<lambda>a b.\n               sign_changes_rat (sturm_rat (of_int_poly p)) a -\n               sign_changes_rat (sturm_rat (of_int_poly p)) b)\n           (\\<lambda>a.\n               sign_changes_neg_number_rootat (sturm_rat (of_int_poly p)) -\n               sign_changes_rat (sturm_rat (of_int_poly p)) a)) =\n    Root_Info\n     (\\<lambda>a b.\n         sign_changes_rat (sturm_rat (of_int_poly p)) a -\n         sign_changes_rat (sturm_rat (of_int_poly p)) b +\n         0)\n     (\\<lambda>a.\n         sign_changes_neg_number_rootat (sturm_rat (of_int_poly p)) -\n         sign_changes_rat (sturm_rat (of_int_poly p)) a)", "using False"], ["proof (prove)\nusing this:\n  degree p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (if degree p = 1\n     then Root_Info\n           (\\<lambda>l r.\n               if l \\<le> Rat.Fract (- coeff p 0) (coeff p 1) \\<and>\n                  Rat.Fract (- coeff p 0) (coeff p 1) \\<le> r\n               then 1 else 0)\n           (\\<lambda>b.\n               if Rat.Fract (- coeff p 0) (coeff p 1) \\<le> b then 1 else 0)\n     else Root_Info\n           (\\<lambda>a b.\n               sign_changes_rat (sturm_rat (of_int_poly p)) a -\n               sign_changes_rat (sturm_rat (of_int_poly p)) b)\n           (\\<lambda>a.\n               sign_changes_neg_number_rootat (sturm_rat (of_int_poly p)) -\n               sign_changes_rat (sturm_rat (of_int_poly p)) a)) =\n    Root_Info\n     (\\<lambda>a b.\n         sign_changes_rat (sturm_rat (of_int_poly p)) a -\n         sign_changes_rat (sturm_rat (of_int_poly p)) b +\n         0)\n     (\\<lambda>a.\n         sign_changes_neg_number_rootat (sturm_rat (of_int_poly p)) -\n         sign_changes_rat (sturm_rat (of_int_poly p)) a)", "by auto"], ["proof (state)\nthis:\n  root_info p = count_roots_interval_rat p\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 1 \\<Longrightarrow> root_info_cond (root_info p) p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_info_cond (root_info p) p", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_info_cond (count_roots_interval_rat p) p", "by (rule count_roots_interval_rat[OF irreducible\\<^sub>d_square_free[OF irr_d]])"], ["proof (state)\nthis:\n  root_info_cond (root_info p) p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}