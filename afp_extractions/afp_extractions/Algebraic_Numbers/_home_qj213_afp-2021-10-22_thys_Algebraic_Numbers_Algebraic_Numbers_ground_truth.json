{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers/Algebraic_Numbers.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers", "problem_names": ["lemma coeff_xy_power:\n  assumes \"k \\<le> n\"\n  shows  \"coeff (x_y ^ n :: 'a :: comm_ring_1 poly poly) k =\n          monom (of_nat (n choose (n - k)) * (- 1) ^ k) (n - k)\"", "lemma poly2_x_y[simp]:\n  fixes x :: \"'a :: comm_ring_1\"\n  shows \"poly2 x_y x y = x - y\"", "lemma degree_poly_x_minus_y[simp]:\n  fixes p :: \"'a::idom poly\"\n  shows \"degree (poly_x_minus_y p) = degree p\"", "lemma poly_x_minus_y_pCons[simp]:\n  \"poly_x_minus_y (pCons a p) = [:[: a :]:] + poly_x_minus_y p * x_y\"", "lemma poly_poly_poly_x_minus_y[simp]:\n  fixes p :: \"'a :: comm_ring_1 poly\"\n  shows \"poly (poly (poly_x_minus_y p) q) x = poly p (x - poly q x)\"", "lemma poly2_poly_x_minus_y[simp]:\n  fixes p :: \"'a :: comm_ring_1 poly\"\n  shows \"poly2 (poly_x_minus_y p) x y = poly p (x-y)\"", "lemma x_y_nonzero[simp]: \"x_y \\<noteq> 0\"", "lemma degree_x_y[simp]: \"degree x_y = 1\"", "lemma poly_add:\n  fixes p q :: \"'a ::comm_ring_1 poly\"\n  assumes q0: \"q \\<noteq> 0\" and x: \"poly p x = 0\" and y: \"poly q y = 0\"\n  shows \"poly (poly_add p q) (x+y) = 0\"", "lemma poly_x_minus_y_as_comp: \"poly_x_minus_y = (\\<lambda>p. p \\<circ>\\<^sub>p x_y) \\<circ> poly_lift\"", "lemma poly_y_x_const[simp]: \"poly_y_x [:[:a:]:] = [:[:a:]:]\"", "lemma poly_y_x_x_y[simp]: \"poly_y_x x_y = y_x\"", "lemma y_x[simp]: fixes x :: \"'a :: comm_ring_1\" shows \"poly2 y_x x y = y - x\"", "lemma poly_y_minus_x_0[simp]: \"poly_y_minus_x 0 = 0\"", "lemma poly_y_minus_x_pCons[simp]:\n  \"poly_y_minus_x (pCons a p) = [:[: a :]:] + poly_y_minus_x p * y_x\"", "lemma poly_y_x_poly_x_minus_y:\n  fixes p :: \"'a :: idom poly\"\n  shows \"poly_y_x (poly_x_minus_y p) = poly_y_minus_x p\"", "lemma degree_poly_y_minus_x[simp]:\n  fixes p :: \"'a :: idom poly\"\n  shows \"degree (poly_y_x (poly_x_minus_y p)) = degree p\"", "lemma dvd_all_coeffs_iff:\n  fixes x :: \"'a :: comm_semiring_1\" (* No addition needed! *)\n  shows \"(\\<forall>pi \\<in> set (coeffs p). x dvd pi) \\<longleftrightarrow> (\\<forall>i. x dvd coeff p i)\" (is \"?l = ?r\")", "lemma primitive_imp_no_constant_factor:\n  fixes p :: \"'a :: {comm_semiring_1, semiring_no_zero_divisors} poly\"\n  assumes pr: \"primitive p\" and F: \"mset_factors F p\" and fF: \"f \\<in># F\"\n  shows \"degree f \\<noteq> 0\"", "lemma coprime_poly_x_minus_y_poly_lift:\n  fixes p q :: \"'a :: ufd poly\"\n  assumes degp: \"degree p > 0\" and degq: \"degree q > 0\"\n    and pr: \"primitive p\"\n  shows \"coprime (poly_x_minus_y p) (poly_lift q)\"", "lemma poly_add_nonzero:\n  fixes p q :: \"'a :: ufd poly\"\n  assumes p0: \"p \\<noteq> 0\" and q0: \"q \\<noteq> 0\" and x: \"poly p x = 0\" and y: \"poly q y = 0\"\n      and pr: \"primitive p\"\n  shows \"poly_add p q \\<noteq> 0\"", "lemma (in comm_ring_hom) map_poly_x_minus_y:\n  \"map_poly (map_poly hom) (poly_x_minus_y p) = poly_x_minus_y (map_poly hom p)\"", "lemma (in comm_ring_hom) hom_poly_lift[simp]:\n  \"map_poly (map_poly hom) (poly_lift q) = poly_lift (map_poly hom q)\"", "lemma lead_coeff_poly_x_minus_y:\n  fixes p :: \"'a::idom poly\"\n  shows \"lead_coeff (poly_x_minus_y p) = [:lead_coeff p * ((- 1) ^ degree p):]\" (is \"?l = ?r\")", "lemma degree_coeff_poly_x_minus_y:\n  fixes p q :: \"'a :: {idom, semiring_char_0} poly\"\n  shows \"degree (coeff (poly_x_minus_y p) i) = degree p - i\"", "lemma coeff_0_poly_x_minus_y [simp]: \"coeff (poly_x_minus_y p) 0 = p\"", "lemma (in idom_hom) poly_add_hom:\n  assumes p0: \"hom (lead_coeff p) \\<noteq> 0\" and q0: \"hom (lead_coeff q) \\<noteq> 0\"\n  shows \"map_poly hom (poly_add p q) = poly_add (map_poly hom p) (map_poly hom q)\"", "lemma(in zero_hom) hom_lead_coeff_nonzero_imp_map_poly_hom:\n  assumes \"hom (lead_coeff p) \\<noteq> 0\"\n  shows \"map_poly hom p \\<noteq> 0\"", "lemma ipoly_poly_add:\n  fixes x y :: \"'a :: idom\"\n  assumes p0: \"(of_int (lead_coeff p) :: 'a) \\<noteq> 0\" and q0: \"(of_int (lead_coeff q) :: 'a) \\<noteq> 0\"\n      and x: \"ipoly p x = 0\" and y: \"ipoly q y = 0\"\n  shows \"ipoly (poly_add p q) (x+y) = 0\"", "lemma (in comm_monoid_gcd) gcd_list_eq_0_iff[simp]: \"listgcd xs = 0 \\<longleftrightarrow> (\\<forall>x \\<in> set xs. x = 0)\"", "lemma primitive_field_poly[simp]: \"primitive (p :: 'a :: field poly) \\<longleftrightarrow> p \\<noteq> 0\"", "lemma ipoly_poly_add_nonzero:\n  fixes x y :: \"'a :: field\"\n  assumes \"p \\<noteq> 0\" and \"q \\<noteq> 0\" and \"ipoly p x = 0\" and \"ipoly q y = 0\"\n      and \"(of_int (lead_coeff p) :: 'a) \\<noteq> 0\" and \"(of_int (lead_coeff q) :: 'a) \\<noteq> 0\"\n  shows \"poly_add p q \\<noteq> 0\"", "lemma represents_add:\n  assumes x: \"p represents x\" and y: \"q represents y\"\n  shows \"(poly_add p q) represents (x + y)\"", "lemma coeff_poly_x_mult_y:\n  shows \"coeff (poly_x_mult_y p) i = monom (coeff p i) i\" (is \"?l = ?r\")", "lemma poly_x_mult_y_code[code]: \"poly_x_mult_y p = (let cs = coeffs p\n  in poly_of_list (map (\\<lambda> (i, ai). monom ai i) (zip [0 ..< length cs] cs)))\"", "lemma poly2_poly_x_mult_y:\n  fixes p :: \"'a :: comm_ring_1 poly\"\n  shows \"poly2 (poly_x_mult_y p) x y = poly p (x * y)\"", "lemma poly_div:\n  fixes p q :: \"'a ::field poly\"\n  assumes q0: \"q \\<noteq> 0\" and x: \"poly p x = 0\" and y: \"poly q y = 0\" and y0: \"y \\<noteq> 0\"\n  shows \"poly (poly_div p q) (x/y) = 0\"", "lemma degree_poly_x_mult_y[simp]:\n  fixes p :: \"'a :: {idom, ring_char_0} poly\"\n  shows \"degree (poly_x_mult_y p) = degree p\" (is \"?l = ?r\")", "lemmas poly_y_x_o_poly_lift = o_def[of poly_y_x poly_lift, unfolded poly_y_x_poly_lift]", "lemma irreducible_dvd_degree: assumes \"(f::'a::field poly) dvd g\"\n \"irreducible g\"\n \"degree f > 0\"\n shows \"degree f = degree g\"", "lemma coprime_poly_x_mult_y_poly_lift:\n  fixes p q :: \"'a :: field_char_0 poly\"\n  assumes degp: \"degree p > 0\" and degq: \"degree q > 0\"\n    and nz: \"poly p 0 \\<noteq> 0 \\<or> poly q 0 \\<noteq> 0\" \n  shows \"coprime (poly_x_mult_y p) (poly_lift q)\"", "lemma poly_div_nonzero:\n  fixes p q :: \"'a :: field_char_0 poly\"\n  assumes p0: \"p \\<noteq> 0\" and q0: \"q \\<noteq> 0\" and x: \"poly p x = 0\" and y: \"poly q y = 0\"\n      and p_0: \"poly p 0 \\<noteq> 0 \\<or> poly q 0 \\<noteq> 0\"\n  shows \"poly_div p q \\<noteq> 0\"", "lemma (in inj_comm_ring_hom) poly_x_mult_y_hom:\n  \"poly_x_mult_y (map_poly hom p) = map_poly (map_poly hom) (poly_x_mult_y p)\"", "lemma (in inj_comm_ring_hom) poly_div_hom:\n  \"map_poly hom (poly_div p q) = poly_div (map_poly hom p) (map_poly hom q)\"", "lemma ipoly_poly_div:\n  fixes x y :: \"'a :: field_char_0\"\n  assumes \"q \\<noteq> 0\" and \"ipoly p x = 0\" and \"ipoly q y = 0\" and \"y \\<noteq> 0\"\n  shows \"ipoly (poly_div p q) (x/y) = 0\"", "lemma ipoly_poly_div_nonzero:\n  fixes x y :: \"'a :: field_char_0\"\n  assumes \"p \\<noteq> 0\" and \"q \\<noteq> 0\" and \"ipoly p x = 0\" and \"ipoly q y = 0\" and \"poly p 0 \\<noteq> 0 \\<or> poly q 0 \\<noteq> 0\"\n  shows \"poly_div p q \\<noteq> 0\"", "lemma represents_div:\n  fixes x y :: \"'a :: field_char_0\"\n  assumes \"p represents x\" and \"q represents y\" and \"poly q 0 \\<noteq> 0\"\n  shows \"(poly_div p q) represents (x / y)\"", "lemma represents_mult:\n  assumes px: \"p represents x\" and qy: \"q represents y\" and q_0: \"poly q 0 \\<noteq> 0\" \n  shows \"(poly_mult p q) represents (x * y)\"", "lemma algebraic_representsI: \"p represents x \\<Longrightarrow> algebraic x\"", "lemma algebraic_of_rat: \"algebraic (of_rat x)\"", "lemma algebraic_uminus: \"algebraic x \\<Longrightarrow> algebraic (-x)\"", "lemma algebraic_inverse: \"algebraic x \\<Longrightarrow> algebraic (inverse x)\"", "lemma algebraic_plus: \"algebraic x \\<Longrightarrow> algebraic y \\<Longrightarrow> algebraic (x + y)\"", "lemma algebraic_div:\n  assumes x: \"algebraic x\" and y: \"algebraic y\" shows \"algebraic (x/y)\"", "lemma algebraic_times: \"algebraic x \\<Longrightarrow> algebraic y \\<Longrightarrow> algebraic (x * y)\"", "lemma algebraic_root: \"algebraic x \\<Longrightarrow> algebraic (root n x)\"", "lemma algebraic_nth_root: \"n \\<noteq> 0 \\<Longrightarrow> algebraic x \\<Longrightarrow> y^n = x \\<Longrightarrow> algebraic y\"", "lemma lead_coeff_poly_add:\n  fixes p q :: \"'a :: {idom, semiring_char_0} poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes \"lead_coeff p = 1\" \"lead_coeff q = 1\" \"m > 0\" \"n > 0\"\n  shows \"lead_coeff (poly_add p q :: 'a poly) = poly_add_sign m n\"", "lemma lead_coeff_poly_mult:\n  fixes p q :: \"'a :: {idom, ring_char_0} poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes \"lead_coeff p = 1\" \"lead_coeff q = 1\" \"m > 0\" \"n > 0\"\n  assumes \"coeff q 0 \\<noteq> 0\"\n  shows \"lead_coeff (poly_mult p q :: 'a poly) = 1\"", "lemma algebraic_int_plus [intro]:\n  fixes x y :: \"'a :: field_char_0\"\n  assumes \"algebraic_int x\" \"algebraic_int y\"\n  shows   \"algebraic_int (x + y)\"", "lemma algebraic_int_times [intro]:\n  fixes x y :: \"'a :: field_char_0\"\n  assumes \"algebraic_int x\" \"algebraic_int y\"\n  shows   \"algebraic_int (x * y)\"", "lemma algebraic_int_power [intro]:\n  \"algebraic_int (x :: 'a :: field_char_0) \\<Longrightarrow> algebraic_int (x ^ n)\"", "lemma algebraic_int_diff [intro]:\n  fixes x y :: \"'a :: field_char_0\"\n  assumes \"algebraic_int x\" \"algebraic_int y\"\n  shows   \"algebraic_int (x - y)\"", "lemma algebraic_int_sum [intro]:\n  \"(\\<And>x. x \\<in> A \\<Longrightarrow> algebraic_int (f x :: 'a :: field_char_0))\n    \\<Longrightarrow> algebraic_int (sum f A)\"", "lemma algebraic_int_prod [intro]:\n  \"(\\<And>x. x \\<in> A \\<Longrightarrow> algebraic_int (f x :: 'a :: field_char_0))\n    \\<Longrightarrow> algebraic_int (prod f A)\"", "lemma algebraic_int_nth_root_real_iff:\n  \"algebraic_int (root n x) \\<longleftrightarrow> n = 0 \\<or> algebraic_int x\"", "lemma algebraic_int_power_iff:\n  \"algebraic_int (x ^ n :: 'a :: field_char_0) \\<longleftrightarrow> n = 0 \\<or> algebraic_int x\"", "lemma algebraic_int_power_iff' [simp]:\n  \"n > 0 \\<Longrightarrow> algebraic_int (x ^ n :: 'a :: field_char_0) \\<longleftrightarrow> algebraic_int x\"", "lemma algebraic_int_sqrt_iff [simp]: \"algebraic_int (sqrt x) \\<longleftrightarrow> algebraic_int x\"", "lemma algebraic_int_csqrt_iff [simp]: \"algebraic_int (csqrt x) \\<longleftrightarrow> algebraic_int x\"", "lemma algebraic_int_norm_complex [intro]:\n  assumes \"algebraic_int (z :: complex)\"\n  shows   \"algebraic_int (norm z)\""], "translations": [["", "lemma coeff_xy_power:\n  assumes \"k \\<le> n\"\n  shows  \"coeff (x_y ^ n :: 'a :: comm_ring_1 poly poly) k =\n          monom (of_nat (n choose (n - k)) * (- 1) ^ k) (n - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "define X :: \"'a poly poly\" where \"X = monom (monom 1 1) 0\""], ["proof (state)\nthis:\n  X = monom (monom (1::'a) 1) 0\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "define Y :: \"'a poly poly\" where \"Y = monom (-1) 1\""], ["proof (state)\nthis:\n  Y = monom (- 1) 1\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "have [simp]: \"monom 1 b * (-1) ^ k = monom ((-1)^k :: 'a) b\" for b k"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) b * (- 1) ^ k = monom ((- (1::'a)) ^ k) b", "by (auto simp: monom_altdef minus_one_power_iff)"], ["proof (state)\nthis:\n  monom (1::'a) ?b * (- 1) ^ ?k = monom ((- (1::'a)) ^ ?k) ?b\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "have \"(X + Y) ^ n = (\\<Sum>i\\<le>n. of_nat (n choose i) * X ^ i * Y ^ (n - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X + Y) ^ n = (\\<Sum>i\\<le>n. of_nat (n choose i) * X ^ i * Y ^ (n - i))", "by (subst binomial_ring) auto"], ["proof (state)\nthis:\n  (X + Y) ^ n = (\\<Sum>i\\<le>n. of_nat (n choose i) * X ^ i * Y ^ (n - i))\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "also"], ["proof (state)\nthis:\n  (X + Y) ^ n = (\\<Sum>i\\<le>n. of_nat (n choose i) * X ^ i * Y ^ (n - i))\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "have \"\\<dots> = (\\<Sum>i\\<le>n. of_nat (n choose i) * monom (monom ((-1) ^ (n - i)) i) (n - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. of_nat (n choose i) * X ^ i * Y ^ (n - i)) =\n    (\\<Sum>i\\<le>n.\n        of_nat (n choose i) *\n        monom (monom ((- (1::'a)) ^ (n - i)) i) (n - i))", "by (simp add: X_def Y_def monom_power mult_monom mult.assoc)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. of_nat (n choose i) * X ^ i * Y ^ (n - i)) =\n  (\\<Sum>i\\<le>n.\n      of_nat (n choose i) * monom (monom ((- (1::'a)) ^ (n - i)) i) (n - i))\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. of_nat (n choose i) * X ^ i * Y ^ (n - i)) =\n  (\\<Sum>i\\<le>n.\n      of_nat (n choose i) * monom (monom ((- (1::'a)) ^ (n - i)) i) (n - i))\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "have \"\\<dots> = (\\<Sum>i\\<le>n. monom (monom (of_nat (n choose i) * (-1) ^ (n - i)) i) (n - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n.\n        of_nat (n choose i) *\n        monom (monom ((- (1::'a)) ^ (n - i)) i) (n - i)) =\n    (\\<Sum>i\\<le>n.\n        monom (monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i)\n         (n - i))", "by (simp add: of_nat_poly smult_monom)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      of_nat (n choose i) *\n      monom (monom ((- (1::'a)) ^ (n - i)) i) (n - i)) =\n  (\\<Sum>i\\<le>n.\n      monom (monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i) (n - i))\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      of_nat (n choose i) *\n      monom (monom ((- (1::'a)) ^ (n - i)) i) (n - i)) =\n  (\\<Sum>i\\<le>n.\n      monom (monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i) (n - i))\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "have \"coeff \\<dots> k =\n    (\\<Sum>i\\<le>n. if n - i = k then monom (of_nat (n choose i) * (- 1) ^ (n - i)) i else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff\n     (\\<Sum>i\\<le>n.\n         monom (monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i)\n          (n - i))\n     k =\n    (\\<Sum>i\\<le>n.\n        if n - i = k\n        then monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i else 0)", "by (simp add: of_nat_poly coeff_sum)"], ["proof (state)\nthis:\n  coeff\n   (\\<Sum>i\\<le>n.\n       monom (monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i)\n        (n - i))\n   k =\n  (\\<Sum>i\\<le>n.\n      if n - i = k\n      then monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i else 0)\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "also"], ["proof (state)\nthis:\n  coeff\n   (\\<Sum>i\\<le>n.\n       monom (monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i)\n        (n - i))\n   k =\n  (\\<Sum>i\\<le>n.\n      if n - i = k\n      then monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i else 0)\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "have \"\\<dots> = (\\<Sum>i\\<in>{n-k}. monom (of_nat (n choose i) * (- 1) ^ (n - i)) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n.\n        if n - i = k\n        then monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i else 0) =\n    (\\<Sum>i\\<in>{n - k}.\n       monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i)", "using \\<open>k \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n.\n        if n - i = k\n        then monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i else 0) =\n    (\\<Sum>i\\<in>{n - k}.\n       monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i)", "by (intro sum.mono_neutral_cong_right) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      if n - i = k\n      then monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i else 0) =\n  (\\<Sum>i\\<in>{n - k}.\n     monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i)\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      if n - i = k\n      then monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i else 0) =\n  (\\<Sum>i\\<in>{n - k}.\n     monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i)\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "have \"X + Y = x_y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X + Y = x_y", "by (simp add: X_def Y_def x_y_def monom_altdef)"], ["proof (state)\nthis:\n  X + Y = x_y\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "finally"], ["proof (chain)\npicking this:\n  coeff (x_y ^ n) k =\n  (\\<Sum>i\\<in>{n - k}.\n     monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i)", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff (x_y ^ n) k =\n  (\\<Sum>i\\<in>{n - k}.\n     monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i)\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "using \\<open>k \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  coeff (x_y ^ n) k =\n  (\\<Sum>i\\<in>{n - k}.\n     monom (of_nat (n choose i) * (- (1::'a)) ^ (n - i)) i)\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ n) k =\n    monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)", "by simp"], ["proof (state)\nthis:\n  coeff (x_y ^ n) k =\n  monom (of_nat (n choose (n - k)) * (- (1::'a)) ^ k) (n - k)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following polynomial represents the sum of two algebraic numbers.\\<close>"], ["", "definition poly_add :: \"'a :: comm_ring_1 poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly\" where\n  \"poly_add p q = resultant (poly_x_minus_y p) (poly_lift q)\""], ["", "subsubsection \\<open>@{term poly_add} has desired root\\<close>"], ["", "interpretation poly_x_minus_y_hom:\n  comm_ring_hom poly_x_minus_y"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_ring_hom poly_x_minus_y", "by (unfold_locales; simp add: poly_x_minus_y_def hom_distribs)"], ["", "lemma poly2_x_y[simp]:\n  fixes x :: \"'a :: comm_ring_1\"\n  shows \"poly2 x_y x y = x - y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly2 x_y x y = x - y", "unfolding poly2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly x_y [:y:]) x = x - y", "by (simp add: x_y_def)"], ["", "lemma degree_poly_x_minus_y[simp]:\n  fixes p :: \"'a::idom poly\"\n  shows \"degree (poly_x_minus_y p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_x_minus_y p) = degree p", "unfolding poly_x_minus_y_def x_y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_lift p \\<circ>\\<^sub>p [:[:0::'a, 1::'a:], - 1:]) =\n    degree p", "by auto"], ["", "lemma poly_x_minus_y_pCons[simp]:\n  \"poly_x_minus_y (pCons a p) = [:[: a :]:] + poly_x_minus_y p * x_y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_x_minus_y (pCons a p) = [:[:a:]:] + poly_x_minus_y p * x_y", "unfolding poly_x_minus_y_def x_y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_lift (pCons a p) \\<circ>\\<^sub>p [:[:0::'a, 1::'a:], - 1:] =\n    [:[:a:]:] +\n    poly_lift p \\<circ>\\<^sub>p [:[:0::'a, 1::'a:], - 1:] *\n    [:[:0::'a, 1::'a:], - 1:]", "by simp"], ["", "lemma poly_poly_poly_x_minus_y[simp]:\n  fixes p :: \"'a :: comm_ring_1 poly\"\n  shows \"poly (poly (poly_x_minus_y p) q) x = poly p (x - poly q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly (poly_x_minus_y p) q) x = poly p (x - poly q x)", "by (induct p; simp add: ring_distribs x_y_def)"], ["", "lemma poly2_poly_x_minus_y[simp]:\n  fixes p :: \"'a :: comm_ring_1 poly\"\n  shows \"poly2 (poly_x_minus_y p) x y = poly p (x-y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly2 (poly_x_minus_y p) x y = poly p (x - y)", "unfolding poly2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly (poly_x_minus_y p) [:y:]) x = poly p (x - y)", "by simp"], ["", "interpretation x_y_mult_hom: zero_hom_0 \"\\<lambda>p :: 'a :: comm_ring_1 poly poly. x_y * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_hom_0 ((*) x_y)", "proof (unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x_y * x = 0 \\<Longrightarrow> x = 0", "fix p :: \"'a poly poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x_y * x = 0 \\<Longrightarrow> x = 0", "assume \"x_y * p = 0\""], ["proof (state)\nthis:\n  x_y * p = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x_y * x = 0 \\<Longrightarrow> x = 0", "then"], ["proof (chain)\npicking this:\n  x_y * p = 0", "show \"p = 0\""], ["proof (prove)\nusing this:\n  x_y * p = 0\n\ngoal (1 subgoal):\n 1. p = 0", "apply (simp add: x_y_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (pCons (0::'a) 1) p + pCons 0 (- p) =\n    0 \\<Longrightarrow>\n    p = 0", "by (metis eq_neg_iff_add_eq_0 minus_equation_iff minus_pCons synthetic_div_unique_lemma)"], ["proof (state)\nthis:\n  p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma x_y_nonzero[simp]: \"x_y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x_y \\<noteq> 0", "by (simp add: x_y_def)"], ["", "lemma degree_x_y[simp]: \"degree x_y = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree x_y = 1", "by (simp add: x_y_def)"], ["", "interpretation x_y_mult_hom: inj_comm_monoid_add_hom \"\\<lambda>p :: 'a :: idom poly poly. x_y * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_comm_monoid_add_hom ((*) x_y)", "proof (unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x_y * x = x_y * y \\<Longrightarrow> x = y", "show \"x_y * p = x_y * q \\<Longrightarrow> p = q\" for p q :: \"'a poly poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x_y * p = x_y * q \\<Longrightarrow> p = q", "proof (induct p arbitrary:q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q. x_y * 0 = x_y * q \\<Longrightarrow> 0 = q\n 2. \\<And>a p q.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>q. x_y * p = x_y * q \\<Longrightarrow> p = q;\n        x_y * pCons a p = x_y * q\\<rbrakk>\n       \\<Longrightarrow> pCons a p = q", "case 0"], ["proof (state)\nthis:\n  x_y * 0 = x_y * q\n\ngoal (2 subgoals):\n 1. \\<And>q. x_y * 0 = x_y * q \\<Longrightarrow> 0 = q\n 2. \\<And>a p q.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>q. x_y * p = x_y * q \\<Longrightarrow> p = q;\n        x_y * pCons a p = x_y * q\\<rbrakk>\n       \\<Longrightarrow> pCons a p = q", "then"], ["proof (chain)\npicking this:\n  x_y * 0 = x_y * q", "show ?case"], ["proof (prove)\nusing this:\n  x_y * 0 = x_y * q\n\ngoal (1 subgoal):\n 1. 0 = q", "by simp"], ["proof (state)\nthis:\n  0 = q\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>q. x_y * p = x_y * q \\<Longrightarrow> p = q;\n        x_y * pCons a p = x_y * q\\<rbrakk>\n       \\<Longrightarrow> pCons a p = q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>q. x_y * p = x_y * q \\<Longrightarrow> p = q;\n        x_y * pCons a p = x_y * q\\<rbrakk>\n       \\<Longrightarrow> pCons a p = q", "case p: (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n  x_y * p = x_y * ?q \\<Longrightarrow> p = ?q\n  x_y * pCons a p = x_y * q\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>q. x_y * p = x_y * q \\<Longrightarrow> p = q;\n        x_y * pCons a p = x_y * q\\<rbrakk>\n       \\<Longrightarrow> pCons a p = q", "from p(3)[unfolded mult_pCons_right]"], ["proof (chain)\npicking this:\n  Polynomial.smult a x_y + pCons 0 (x_y * p) = x_y * q", "have \"x_y * (monom a 0 + pCons 0 1 * p) = x_y * q\""], ["proof (prove)\nusing this:\n  Polynomial.smult a x_y + pCons 0 (x_y * p) = x_y * q\n\ngoal (1 subgoal):\n 1. x_y * (monom a 0 + pCons 0 1 * p) = x_y * q", "apply (subst(asm) pCons_0_as_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult a x_y + pCons 0 1 * (x_y * p) =\n    x_y * q \\<Longrightarrow>\n    x_y * (monom a 0 + pCons 0 1 * p) = x_y * q", "apply (subst(asm) smult_prod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom a 0 * x_y + pCons 0 1 * (x_y * p) = x_y * q \\<Longrightarrow>\n    x_y * (monom a 0 + pCons 0 1 * p) = x_y * q", "by (simp only: field_simps distrib_left)"], ["proof (state)\nthis:\n  x_y * (monom a 0 + pCons 0 1 * p) = x_y * q\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>q. x_y * p = x_y * q \\<Longrightarrow> p = q;\n        x_y * pCons a p = x_y * q\\<rbrakk>\n       \\<Longrightarrow> pCons a p = q", "then"], ["proof (chain)\npicking this:\n  x_y * (monom a 0 + pCons 0 1 * p) = x_y * q", "have \"monom a 0 + pCons 0 1 * p = q\""], ["proof (prove)\nusing this:\n  x_y * (monom a 0 + pCons 0 1 * p) = x_y * q\n\ngoal (1 subgoal):\n 1. monom a 0 + pCons 0 1 * p = q", "by simp"], ["proof (state)\nthis:\n  monom a 0 + pCons 0 1 * p = q\n\ngoal (1 subgoal):\n 1. \\<And>a p q.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        \\<And>q. x_y * p = x_y * q \\<Longrightarrow> p = q;\n        x_y * pCons a p = x_y * q\\<rbrakk>\n       \\<Longrightarrow> pCons a p = q", "then"], ["proof (chain)\npicking this:\n  monom a 0 + pCons 0 1 * p = q", "show \"pCons a p = q\""], ["proof (prove)\nusing this:\n  monom a 0 + pCons 0 1 * p = q\n\ngoal (1 subgoal):\n 1. pCons a p = q", "using pCons_as_add"], ["proof (prove)\nusing this:\n  monom a 0 + pCons 0 1 * p = q\n  pCons ?a ?p = [:?a:] + monom (1::?'a) 1 * ?p\n\ngoal (1 subgoal):\n 1. pCons a p = q", "by (simp add: monom_0 monom_Suc)"], ["proof (state)\nthis:\n  pCons a p = q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x_y * ?p = x_y * ?q \\<Longrightarrow> ?p = ?q\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation poly_x_minus_y_hom: inj_idom_hom poly_x_minus_y"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_idom_hom poly_x_minus_y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. poly_x_minus_y x = 0 \\<Longrightarrow> x = 0", "fix p :: \"'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. poly_x_minus_y x = 0 \\<Longrightarrow> x = 0", "assume 0: \"poly_x_minus_y p = 0\""], ["proof (state)\nthis:\n  poly_x_minus_y p = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. poly_x_minus_y x = 0 \\<Longrightarrow> x = 0", "then"], ["proof (chain)\npicking this:\n  poly_x_minus_y p = 0", "have \"poly_lift p \\<circ>\\<^sub>p x_y = 0\""], ["proof (prove)\nusing this:\n  poly_x_minus_y p = 0\n\ngoal (1 subgoal):\n 1. poly_lift p \\<circ>\\<^sub>p x_y = 0", "by (simp add: poly_x_minus_y_def)"], ["proof (state)\nthis:\n  poly_lift p \\<circ>\\<^sub>p x_y = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. poly_x_minus_y x = 0 \\<Longrightarrow> x = 0", "then"], ["proof (chain)\npicking this:\n  poly_lift p \\<circ>\\<^sub>p x_y = 0", "show \"p = 0\""], ["proof (prove)\nusing this:\n  poly_lift p \\<circ>\\<^sub>p x_y = 0\n\ngoal (1 subgoal):\n 1. p = 0", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_lift 0 \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> 0 = 0\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0;\n        poly_lift (pCons a p) \\<circ>\\<^sub>p x_y = 0\\<rbrakk>\n       \\<Longrightarrow> pCons a p = 0", "case 0"], ["proof (state)\nthis:\n  poly_lift 0 \\<circ>\\<^sub>p x_y = 0\n\ngoal (2 subgoals):\n 1. poly_lift 0 \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> 0 = 0\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0;\n        poly_lift (pCons a p) \\<circ>\\<^sub>p x_y = 0\\<rbrakk>\n       \\<Longrightarrow> pCons a p = 0", "then"], ["proof (chain)\npicking this:\n  poly_lift 0 \\<circ>\\<^sub>p x_y = 0", "show ?case"], ["proof (prove)\nusing this:\n  poly_lift 0 \\<circ>\\<^sub>p x_y = 0\n\ngoal (1 subgoal):\n 1. 0 = 0", "by simp"], ["proof (state)\nthis:\n  0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0;\n        poly_lift (pCons a p) \\<circ>\\<^sub>p x_y = 0\\<rbrakk>\n       \\<Longrightarrow> pCons a p = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0;\n        poly_lift (pCons a p) \\<circ>\\<^sub>p x_y = 0\\<rbrakk>\n       \\<Longrightarrow> pCons a p = 0", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0\n  poly_lift (pCons a p) \\<circ>\\<^sub>p x_y = 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0;\n        poly_lift (pCons a p) \\<circ>\\<^sub>p x_y = 0\\<rbrakk>\n       \\<Longrightarrow> pCons a p = 0", "note p = this[unfolded poly_lift_pCons pcompose_pCons]"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0\n  [:[:a:]:] + x_y * poly_lift p \\<circ>\\<^sub>p x_y = 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0;\n        poly_lift (pCons a p) \\<circ>\\<^sub>p x_y = 0\\<rbrakk>\n       \\<Longrightarrow> pCons a p = 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pCons a p = 0", "proof (cases \"a=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow> pCons a p = 0\n 2. a \\<noteq> (0::'a) \\<Longrightarrow> pCons a p = 0", "case a0: True"], ["proof (state)\nthis:\n  a = (0::'a)\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow> pCons a p = 0\n 2. a \\<noteq> (0::'a) \\<Longrightarrow> pCons a p = 0", "with p"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0\n  [:[:a:]:] + x_y * poly_lift p \\<circ>\\<^sub>p x_y = 0\n  a = (0::'a)", "have \"x_y * poly_lift p \\<circ>\\<^sub>p x_y = 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0\n  [:[:a:]:] + x_y * poly_lift p \\<circ>\\<^sub>p x_y = 0\n  a = (0::'a)\n\ngoal (1 subgoal):\n 1. x_y * poly_lift p \\<circ>\\<^sub>p x_y = 0", "by simp"], ["proof (state)\nthis:\n  x_y * poly_lift p \\<circ>\\<^sub>p x_y = 0\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow> pCons a p = 0\n 2. a \\<noteq> (0::'a) \\<Longrightarrow> pCons a p = 0", "then"], ["proof (chain)\npicking this:\n  x_y * poly_lift p \\<circ>\\<^sub>p x_y = 0", "have \"poly_lift p \\<circ>\\<^sub>p x_y = 0\""], ["proof (prove)\nusing this:\n  x_y * poly_lift p \\<circ>\\<^sub>p x_y = 0\n\ngoal (1 subgoal):\n 1. poly_lift p \\<circ>\\<^sub>p x_y = 0", "by simp"], ["proof (state)\nthis:\n  poly_lift p \\<circ>\\<^sub>p x_y = 0\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow> pCons a p = 0\n 2. a \\<noteq> (0::'a) \\<Longrightarrow> pCons a p = 0", "then"], ["proof (chain)\npicking this:\n  poly_lift p \\<circ>\\<^sub>p x_y = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_lift p \\<circ>\\<^sub>p x_y = 0\n\ngoal (1 subgoal):\n 1. pCons a p = 0", "using p"], ["proof (prove)\nusing this:\n  poly_lift p \\<circ>\\<^sub>p x_y = 0\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0\n  [:[:a:]:] + x_y * poly_lift p \\<circ>\\<^sub>p x_y = 0\n\ngoal (1 subgoal):\n 1. pCons a p = 0", "by simp"], ["proof (state)\nthis:\n  pCons a p = 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow> pCons a p = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow> pCons a p = 0", "case a0: False"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow> pCons a p = 0", "with p"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0\n  [:[:a:]:] + x_y * poly_lift p \\<circ>\\<^sub>p x_y = 0\n  a \\<noteq> (0::'a)", "have p0: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0\n  [:[:a:]:] + x_y * poly_lift p \\<circ>\\<^sub>p x_y = 0\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow> pCons a p = 0", "from p"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0\n  [:[:a:]:] + x_y * poly_lift p \\<circ>\\<^sub>p x_y = 0", "have \"[:[:a:]:] = - x_y * poly_lift p \\<circ>\\<^sub>p x_y\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  poly_lift p \\<circ>\\<^sub>p x_y = 0 \\<Longrightarrow> p = 0\n  [:[:a:]:] + x_y * poly_lift p \\<circ>\\<^sub>p x_y = 0\n\ngoal (1 subgoal):\n 1. [:[:a:]:] = - x_y * poly_lift p \\<circ>\\<^sub>p x_y", "by (simp add: eq_neg_iff_add_eq_0)"], ["proof (state)\nthis:\n  [:[:a:]:] = - x_y * poly_lift p \\<circ>\\<^sub>p x_y\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow> pCons a p = 0", "then"], ["proof (chain)\npicking this:\n  [:[:a:]:] = - x_y * poly_lift p \\<circ>\\<^sub>p x_y", "have \"degree [:[:a:]:] = degree (x_y * poly_lift p \\<circ>\\<^sub>p x_y)\""], ["proof (prove)\nusing this:\n  [:[:a:]:] = - x_y * poly_lift p \\<circ>\\<^sub>p x_y\n\ngoal (1 subgoal):\n 1. degree [:[:a:]:] = degree (x_y * poly_lift p \\<circ>\\<^sub>p x_y)", "by simp"], ["proof (state)\nthis:\n  degree [:[:a:]:] = degree (x_y * poly_lift p \\<circ>\\<^sub>p x_y)\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow> pCons a p = 0", "also"], ["proof (state)\nthis:\n  degree [:[:a:]:] = degree (x_y * poly_lift p \\<circ>\\<^sub>p x_y)\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow> pCons a p = 0", "have \"... = degree (x_y::'a poly poly) + degree (poly_lift p \\<circ>\\<^sub>p x_y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (x_y * poly_lift p \\<circ>\\<^sub>p x_y) =\n    degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y)", "apply (subst degree_mult_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x_y \\<noteq> 0\n 2. poly_lift p \\<circ>\\<^sub>p x_y \\<noteq> 0\n 3. degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y) =\n    degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. poly_lift p \\<circ>\\<^sub>p x_y \\<noteq> 0\n 2. degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y) =\n    degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y)", "apply (subst pcompose_eq_0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. degree x_y \\<noteq> 0\n 2. poly_lift p \\<noteq> 0\n 3. degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y) =\n    degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y)", "apply (simp add: x_y_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. poly_lift p \\<noteq> 0\n 2. degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y) =\n    degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y)", "apply (simp add: p0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y) =\n    degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  degree (x_y * poly_lift p \\<circ>\\<^sub>p x_y) =\n  degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y)\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow> pCons a p = 0", "finally"], ["proof (chain)\npicking this:\n  degree [:[:a:]:] = degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y)", "have False"], ["proof (prove)\nusing this:\n  degree [:[:a:]:] = degree x_y + degree (poly_lift p \\<circ>\\<^sub>p x_y)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a) \\<Longrightarrow> pCons a p = 0", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. pCons a p = 0", ".."], ["proof (state)\nthis:\n  pCons a p = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pCons a p = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_add:\n  fixes p q :: \"'a ::comm_ring_1 poly\"\n  assumes q0: \"q \\<noteq> 0\" and x: \"poly p x = 0\" and y: \"poly q y = 0\"\n  shows \"poly (poly_add p q) (x+y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_add p q) (x + y) = (0::'a)", "proof (unfold poly_add_def, rule poly_resultant_zero[OF disjI2])"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < degree (poly_lift q)\n 2. poly2 (poly_x_minus_y p) (x + y) ?y = (0::'a)\n 3. poly2 (poly_lift q) (x + y) ?y = (0::'a)", "have \"degree q > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree q", "using poly_zero q0 y"], ["proof (prove)\nusing this:\n  poly ?p ?x = (0::?'a) \\<Longrightarrow> (?p = 0) = (degree ?p = 0)\n  q \\<noteq> 0\n  poly q y = (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < degree q", "by auto"], ["proof (state)\nthis:\n  0 < degree q\n\ngoal (3 subgoals):\n 1. 0 < degree (poly_lift q)\n 2. poly2 (poly_x_minus_y p) (x + y) ?y = (0::'a)\n 3. poly2 (poly_lift q) (x + y) ?y = (0::'a)", "thus degq: \"degree (poly_lift q) > 0\""], ["proof (prove)\nusing this:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. 0 < degree (poly_lift q)", "by auto"], ["proof (state)\nthis:\n  0 < degree (poly_lift q)\n\ngoal (2 subgoals):\n 1. poly2 (poly_x_minus_y p) (x + y) ?y = (0::'a)\n 2. poly2 (poly_lift q) (x + y) ?y = (0::'a)", "qed (insert x y, simp_all)"], ["", "subsubsection \\<open>@{const poly_add} is nonzero\\<close>"], ["", "text \\<open>\n  We first prove that @{const poly_lift} preserves factorization. The result will be essential\n  also in the next section for division of algebraic numbers.\n\\<close>"], ["", "interpretation poly_lift_hom:\n  unit_preserving_hom \"poly_lift :: 'a :: {comm_semiring_1,semiring_no_zero_divisors} poly \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_preserving_hom poly_lift", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. poly_lift x dvd 1 \\<Longrightarrow> x dvd 1", "fix x :: \"'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. poly_lift x dvd 1 \\<Longrightarrow> x dvd 1", "assume \"poly_lift x dvd 1\""], ["proof (state)\nthis:\n  poly_lift x dvd 1\n\ngoal (1 subgoal):\n 1. \\<And>x. poly_lift x dvd 1 \\<Longrightarrow> x dvd 1", "then"], ["proof (chain)\npicking this:\n  poly_lift x dvd 1", "have \"poly_y_x (poly_lift x) dvd poly_y_x 1\""], ["proof (prove)\nusing this:\n  poly_lift x dvd 1\n\ngoal (1 subgoal):\n 1. poly_y_x (poly_lift x) dvd poly_y_x 1", "by simp"], ["proof (state)\nthis:\n  poly_y_x (poly_lift x) dvd poly_y_x 1\n\ngoal (1 subgoal):\n 1. \\<And>x. poly_lift x dvd 1 \\<Longrightarrow> x dvd 1", "then"], ["proof (chain)\npicking this:\n  poly_y_x (poly_lift x) dvd poly_y_x 1", "show \"x dvd 1\""], ["proof (prove)\nusing this:\n  poly_y_x (poly_lift x) dvd poly_y_x 1\n\ngoal (1 subgoal):\n 1. x dvd 1", "by (auto simp add: poly_y_x_poly_lift)"], ["proof (state)\nthis:\n  x dvd 1\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation poly_lift_hom:\n  factor_preserving_hom \"poly_lift::'a::idom poly \\<Rightarrow> 'a poly poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factor_preserving_hom poly_lift", "proof unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. irreducible a \\<Longrightarrow> irreducible (poly_lift a)", "fix p :: \"'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. irreducible a \\<Longrightarrow> irreducible (poly_lift a)", "assume p: \"irreducible p\""], ["proof (state)\nthis:\n  irreducible p\n\ngoal (1 subgoal):\n 1. \\<And>a. irreducible a \\<Longrightarrow> irreducible (poly_lift a)", "show \"irreducible (poly_lift p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible (poly_lift p)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "from p"], ["proof (chain)\npicking this:\n  irreducible p", "have p0: \"p \\<noteq> 0\" and \"\\<not> p dvd 1\""], ["proof (prove)\nusing this:\n  irreducible p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& \\<not> p dvd 1", "by (auto dest: irreducible_not_unit)"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  \\<not> p dvd 1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "with poly_lift_hom.hom_dvd[of p 1]"], ["proof (chain)\npicking this:\n  p dvd 1 \\<Longrightarrow> poly_lift p dvd poly_lift 1\n  p \\<noteq> 0\n  \\<not> p dvd 1", "have p1: \"\\<not> poly_lift p dvd 1\""], ["proof (prove)\nusing this:\n  p dvd 1 \\<Longrightarrow> poly_lift p dvd poly_lift 1\n  p \\<noteq> 0\n  \\<not> p dvd 1\n\ngoal (1 subgoal):\n 1. \\<not> poly_lift p dvd 1", "by auto"], ["proof (state)\nthis:\n  \\<not> poly_lift p dvd 1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "assume \"\\<not> irreducible (poly_lift p)\""], ["proof (state)\nthis:\n  \\<not> irreducible (poly_lift p)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "from this[unfolded irreducible_altdef,simplified] p0 p1"], ["proof (chain)\npicking this:\n  p = 0 \\<or>\n  p dvd 1 \\<or>\n  (\\<exists>b.\n      b dvd poly_lift p \\<and>\n      \\<not> poly_lift p dvd b \\<and> \\<not> b dvd 1)\n  p \\<noteq> 0\n  \\<not> poly_lift p dvd 1", "obtain q where \"q dvd poly_lift p\" and pq: \"\\<not> poly_lift p dvd q\" and q: \"\\<not> q dvd 1\""], ["proof (prove)\nusing this:\n  p = 0 \\<or>\n  p dvd 1 \\<or>\n  (\\<exists>b.\n      b dvd poly_lift p \\<and>\n      \\<not> poly_lift p dvd b \\<and> \\<not> b dvd 1)\n  p \\<noteq> 0\n  \\<not> poly_lift p dvd 1\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q dvd poly_lift p; \\<not> poly_lift p dvd q;\n         \\<not> q dvd 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q dvd poly_lift p\n  \\<not> poly_lift p dvd q\n  \\<not> q dvd 1\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  q dvd poly_lift p\n  \\<not> poly_lift p dvd q\n  \\<not> q dvd 1", "obtain r where \"q * r = poly_lift p\""], ["proof (prove)\nusing this:\n  q dvd poly_lift p\n  \\<not> poly_lift p dvd q\n  \\<not> q dvd 1\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        q * r = poly_lift p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE, auto)"], ["proof (state)\nthis:\n  q * r = poly_lift p\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  q * r = poly_lift p", "have \"poly_y_x (q * r) = poly_y_x (poly_lift p)\""], ["proof (prove)\nusing this:\n  q * r = poly_lift p\n\ngoal (1 subgoal):\n 1. poly_y_x (q * r) = poly_y_x (poly_lift p)", "by auto"], ["proof (state)\nthis:\n  poly_y_x (q * r) = poly_y_x (poly_lift p)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  poly_y_x (q * r) = poly_y_x (poly_lift p)\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "have \"... = [:p:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_y_x (poly_lift p) = [:p:]", "by (auto simp: poly_y_x_poly_lift monom_0)"], ["proof (state)\nthis:\n  poly_y_x (poly_lift p) = [:p:]\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  poly_y_x (poly_lift p) = [:p:]\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "have \"poly_y_x (q * r) = poly_y_x q * poly_y_x r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_y_x (q * r) = poly_y_x q * poly_y_x r", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  poly_y_x (q * r) = poly_y_x q * poly_y_x r\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  poly_y_x q * poly_y_x r = [:p:]", "have \"... = [:p:]\""], ["proof (prove)\nusing this:\n  poly_y_x q * poly_y_x r = [:p:]\n\ngoal (1 subgoal):\n 1. poly_y_x q * poly_y_x r = [:p:]", "by auto"], ["proof (state)\nthis:\n  poly_y_x q * poly_y_x r = [:p:]\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  poly_y_x q * poly_y_x r = [:p:]", "have qp: \"poly_y_x q dvd [:p:]\""], ["proof (prove)\nusing this:\n  poly_y_x q * poly_y_x r = [:p:]\n\ngoal (1 subgoal):\n 1. poly_y_x q dvd [:p:]", "by (metis dvdI)"], ["proof (state)\nthis:\n  poly_y_x q dvd [:p:]\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "from dvd_const[OF this] p0"], ["proof (chain)\npicking this:\n  \\<lbrakk>[:p:] \\<noteq> 0; degree [:p:] = 0\\<rbrakk>\n  \\<Longrightarrow> degree (poly_y_x q) = 0\n  p \\<noteq> 0", "have \"degree (poly_y_x q) = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>[:p:] \\<noteq> 0; degree [:p:] = 0\\<rbrakk>\n  \\<Longrightarrow> degree (poly_y_x q) = 0\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (poly_y_x q) = 0", "by auto"], ["proof (state)\nthis:\n  degree (poly_y_x q) = 0\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "from degree_0_id[OF this,symmetric]"], ["proof (chain)\npicking this:\n  poly_y_x q = [:coeff (poly_y_x q) 0:]", "obtain s\n      where qs: \"poly_y_x q = [:s:]\""], ["proof (prove)\nusing this:\n  poly_y_x q = [:coeff (poly_y_x q) 0:]\n\ngoal (1 subgoal):\n 1. (\\<And>s. poly_y_x q = [:s:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly_y_x q = [:s:]\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "have \"poly_lift s = poly_y_x (poly_y_x (poly_lift s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_lift s = poly_y_x (poly_y_x (poly_lift s))", "by auto"], ["proof (state)\nthis:\n  poly_lift s = poly_y_x (poly_y_x (poly_lift s))\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  poly_lift s = poly_y_x (poly_y_x (poly_lift s))\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "have \"... = poly_y_x [:s:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_y_x (poly_y_x (poly_lift s)) = poly_y_x [:s:]", "by (auto simp: poly_y_x_poly_lift monom_0)"], ["proof (state)\nthis:\n  poly_y_x (poly_y_x (poly_lift s)) = poly_y_x [:s:]\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  poly_y_x (poly_y_x (poly_lift s)) = poly_y_x [:s:]\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "have \"... = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_y_x [:s:] = q", "by (auto simp: qs[symmetric])"], ["proof (state)\nthis:\n  poly_y_x [:s:] = q\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  poly_lift s = q", "have sq: \"poly_lift s = q\""], ["proof (prove)\nusing this:\n  poly_lift s = q\n\ngoal (1 subgoal):\n 1. poly_lift s = q", "by auto"], ["proof (state)\nthis:\n  poly_lift s = q\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "from qp[unfolded qs]"], ["proof (chain)\npicking this:\n  [:s:] dvd [:p:]", "have sp: \"s dvd p\""], ["proof (prove)\nusing this:\n  [:s:] dvd [:p:]\n\ngoal (1 subgoal):\n 1. s dvd p", "by (auto simp: const_poly_dvd)"], ["proof (state)\nthis:\n  s dvd p\n\ngoal (1 subgoal):\n 1. \\<not> irreducible (poly_lift p) \\<Longrightarrow> False", "from irreducibleD'[OF p this] sq q pq"], ["proof (chain)\npicking this:\n  p dvd s \\<or> s dvd 1\n  poly_lift s = q\n  \\<not> q dvd 1\n  \\<not> poly_lift p dvd q", "show False"], ["proof (prove)\nusing this:\n  p dvd s \\<or> s dvd 1\n  poly_lift s = q\n  \\<not> q dvd 1\n  \\<not> poly_lift p dvd q\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  irreducible (poly_lift p)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We now show that @{const poly_x_minus_y} is a factor-preserving homomorphism. This is\n  essential for this section. This is easy since @{const poly_x_minus_y} can be represented\n  as the composition of two factor-preserving homomorphisms.\n\\<close>"], ["", "lemma poly_x_minus_y_as_comp: \"poly_x_minus_y = (\\<lambda>p. p \\<circ>\\<^sub>p x_y) \\<circ> poly_lift\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_x_minus_y = (\\<lambda>p. p \\<circ>\\<^sub>p x_y) \\<circ> poly_lift", "by (intro ext, unfold poly_x_minus_y_def, auto)"], ["", "context idom_isom begin"], ["", "sublocale comm_semiring_isom"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_semiring_isom hom", ".."], ["", "end"], ["", "interpretation poly_x_minus_y_hom:\n  factor_preserving_hom \"poly_x_minus_y :: 'a :: idom poly \\<Rightarrow> 'a poly poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factor_preserving_hom poly_x_minus_y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. factor_preserving_hom poly_x_minus_y", "interpret x_y_hom: bijective \"\\<lambda>p :: 'a poly poly. p \\<circ>\\<^sub>p x_y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective (\\<lambda>p. p \\<circ>\\<^sub>p x_y)", "proof (unfold bijective_eq_bij, rule id_imp_bij)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<circ>\\<^sub>p x_y \\<circ>\\<^sub>p x_y = x", "fix p :: \"'a poly poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<circ>\\<^sub>p x_y \\<circ>\\<^sub>p x_y = x", "show \"p \\<circ>\\<^sub>p x_y \\<circ>\\<^sub>p x_y = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<circ>\\<^sub>p x_y \\<circ>\\<^sub>p x_y = p", "apply (induct p,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        p \\<circ>\\<^sub>p x_y \\<circ>\\<^sub>p x_y = p\\<rbrakk>\n       \\<Longrightarrow> pCons a p \\<circ>\\<^sub>p x_y \\<circ>\\<^sub>p x_y =\n                         pCons a p", "apply(unfold x_y_def hom_distribs pcompose_pCons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        p \\<circ>\\<^sub>p pCons [:0::'a, 1::'a:] (- [:1:]) \\<circ>\\<^sub>p\n        pCons [:0::'a, 1::'a:] (- [:1:]) =\n        p\\<rbrakk>\n       \\<Longrightarrow> [:a:] +\n                         pCons [:0::'a, 1::'a:] (- [:1:]) *\n                         0 \\<circ>\\<^sub>p\n                         pCons [:0::'a, 1::'a:] (- [:1:]) +\n                         ([:[:0::'a, 1::'a:]:] +\n                          pCons [:0::'a, 1::'a:] (- [:1:]) *\n                          - ([:1:] +\n                             pCons [:0::'a, 1::'a:] (- [:1:]) *\n                             0 \\<circ>\\<^sub>p\n                             pCons [:0::'a, 1::'a:] (- [:1:]))) *\n                         p \\<circ>\\<^sub>p\n                         pCons [:0::'a, 1::'a:] (- [:1:]) \\<circ>\\<^sub>p\n                         pCons [:0::'a, 1::'a:] (- [:1:]) =\n                         pCons a p", "by (simp)"], ["proof (state)\nthis:\n  p \\<circ>\\<^sub>p x_y \\<circ>\\<^sub>p x_y = p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. factor_preserving_hom poly_x_minus_y", "interpret x_y_hom: idom_isom \"\\<lambda>p :: 'a poly poly. p \\<circ>\\<^sub>p x_y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idom_isom (\\<lambda>p. p \\<circ>\\<^sub>p x_y)", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. factor_preserving_hom poly_x_minus_y", "show \"factor_preserving_hom (poly_x_minus_y :: 'a poly \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factor_preserving_hom poly_x_minus_y", "by (unfold poly_x_minus_y_as_comp, rule factor_preserving_hom_comp, unfold_locales)"], ["proof (state)\nthis:\n  factor_preserving_hom poly_x_minus_y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Now we show that results of @{const poly_x_minus_y} and @{const poly_lift} are coprime.\n\\<close>"], ["", "lemma poly_y_x_const[simp]: \"poly_y_x [:[:a:]:] = [:[:a:]:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_y_x [:[:a:]:] = [:[:a:]:]", "by (simp add: poly_y_x_def monom_0)"], ["", "context begin"], ["", "private"], ["", "abbreviation \"y_x == [: [: 0, -1 :], 1 :]\""], ["", "lemma poly_y_x_x_y[simp]: \"poly_y_x x_y = y_x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_y_x x_y = y_x", "by (simp add: x_y_def poly_y_x_def monom_Suc monom_0)"], ["", "private"], ["", "lemma y_x[simp]: fixes x :: \"'a :: comm_ring_1\" shows \"poly2 y_x x y = y - x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly2 y_x x y = y - x", "unfolding poly2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly y_x [:y:]) x = y - x", "by simp"], ["", "private"], ["", "definition \"poly_y_minus_x p \\<equiv> poly_lift p \\<circ>\\<^sub>p y_x\""], ["", "private"], ["", "lemma poly_y_minus_x_0[simp]: \"poly_y_minus_x 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_y_minus_x 0 = 0", "by (simp add: poly_y_minus_x_def)"], ["", "private"], ["", "lemma poly_y_minus_x_pCons[simp]:\n  \"poly_y_minus_x (pCons a p) = [:[: a :]:] + poly_y_minus_x p * y_x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_y_minus_x (pCons a p) = [:[:a:]:] + poly_y_minus_x p * y_x", "by (simp add: poly_y_minus_x_def)"], ["", "private"], ["", "lemma poly_y_x_poly_x_minus_y:\n  fixes p :: \"'a :: idom poly\"\n  shows \"poly_y_x (poly_x_minus_y p) = poly_y_minus_x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_y_x (poly_x_minus_y p) = poly_y_minus_x p", "apply (induct p, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly_y_x (poly_x_minus_y p) = poly_y_minus_x p\\<rbrakk>\n       \\<Longrightarrow> poly_y_x (poly_x_minus_y (pCons a p)) =\n                         poly_y_minus_x (pCons a p)", "apply (unfold poly_x_minus_y_pCons hom_distribs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        poly_y_x (poly_x_minus_y p) = poly_y_minus_x p\\<rbrakk>\n       \\<Longrightarrow> poly_y_x [:[:a:]:] +\n                         poly_y_x (poly_x_minus_y p) * poly_y_x x_y =\n                         poly_y_minus_x (pCons a p)", "by simp"], ["", "lemma degree_poly_y_minus_x[simp]:\n  fixes p :: \"'a :: idom poly\"\n  shows \"degree (poly_y_x (poly_x_minus_y p)) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_y_x (poly_x_minus_y p)) = degree p", "by (simp add: poly_y_minus_x_def poly_y_x_poly_x_minus_y)"], ["", "end"], ["", "lemma dvd_all_coeffs_iff:\n  fixes x :: \"'a :: comm_semiring_1\" (* No addition needed! *)\n  shows \"(\\<forall>pi \\<in> set (coeffs p). x dvd pi) \\<longleftrightarrow> (\\<forall>i. x dvd coeff p i)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>pi\\<in>set (coeffs p). x dvd pi) =\n    (\\<forall>i. x dvd coeff p i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>pi\\<in>set (coeffs p). x dvd pi) =\n    (\\<forall>i. x dvd coeff p i)", "have \"?r = (\\<forall>i\\<in>{..degree p} \\<union> {Suc (degree p)..}. x dvd coeff p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. x dvd coeff p i) =\n    (\\<forall>i\\<in>{..degree p} \\<union> {Suc (degree p)..}.\n        x dvd coeff p i)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>i. x dvd coeff p i) =\n  (\\<forall>i\\<in>{..degree p} \\<union> {Suc (degree p)..}. x dvd coeff p i)\n\ngoal (1 subgoal):\n 1. (\\<forall>pi\\<in>set (coeffs p). x dvd pi) =\n    (\\<forall>i. x dvd coeff p i)", "also"], ["proof (state)\nthis:\n  (\\<forall>i. x dvd coeff p i) =\n  (\\<forall>i\\<in>{..degree p} \\<union> {Suc (degree p)..}. x dvd coeff p i)\n\ngoal (1 subgoal):\n 1. (\\<forall>pi\\<in>set (coeffs p). x dvd pi) =\n    (\\<forall>i. x dvd coeff p i)", "have \"... = (\\<forall>i\\<le>degree p. x dvd coeff p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>{..degree p} \\<union> {Suc (degree p)..}.\n        x dvd coeff p i) =\n    (\\<forall>i\\<le>degree p. x dvd coeff p i)", "by (auto simp add: ball_Un coeff_eq_0)"], ["proof (state)\nthis:\n  (\\<forall>i\\<in>{..degree p} \\<union> {Suc (degree p)..}.\n      x dvd coeff p i) =\n  (\\<forall>i\\<le>degree p. x dvd coeff p i)\n\ngoal (1 subgoal):\n 1. (\\<forall>pi\\<in>set (coeffs p). x dvd pi) =\n    (\\<forall>i. x dvd coeff p i)", "also"], ["proof (state)\nthis:\n  (\\<forall>i\\<in>{..degree p} \\<union> {Suc (degree p)..}.\n      x dvd coeff p i) =\n  (\\<forall>i\\<le>degree p. x dvd coeff p i)\n\ngoal (1 subgoal):\n 1. (\\<forall>pi\\<in>set (coeffs p). x dvd pi) =\n    (\\<forall>i. x dvd coeff p i)", "have \"... = ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<le>degree p. x dvd coeff p i) =\n    (\\<forall>pi\\<in>set (coeffs p). x dvd pi)", "by (auto simp: coeffs_def)"], ["proof (state)\nthis:\n  (\\<forall>i\\<le>degree p. x dvd coeff p i) =\n  (\\<forall>pi\\<in>set (coeffs p). x dvd pi)\n\ngoal (1 subgoal):\n 1. (\\<forall>pi\\<in>set (coeffs p). x dvd pi) =\n    (\\<forall>i. x dvd coeff p i)", "finally"], ["proof (chain)\npicking this:\n  (\\<forall>i. x dvd coeff p i) = (\\<forall>pi\\<in>set (coeffs p). x dvd pi)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>i. x dvd coeff p i) = (\\<forall>pi\\<in>set (coeffs p). x dvd pi)\n\ngoal (1 subgoal):\n 1. (\\<forall>pi\\<in>set (coeffs p). x dvd pi) =\n    (\\<forall>i. x dvd coeff p i)", ".."], ["proof (state)\nthis:\n  (\\<forall>pi\\<in>set (coeffs p). x dvd pi) = (\\<forall>i. x dvd coeff p i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma primitive_imp_no_constant_factor:\n  fixes p :: \"'a :: {comm_semiring_1, semiring_no_zero_divisors} poly\"\n  assumes pr: \"primitive p\" and F: \"mset_factors F p\" and fF: \"f \\<in># F\"\n  shows \"degree f \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. degree f = 0 \\<Longrightarrow> False", "from F fF"], ["proof (chain)\npicking this:\n  mset_factors F p\n  f \\<in># F", "have irr: \"irreducible f\" and fp: \"f dvd p\""], ["proof (prove)\nusing this:\n  mset_factors F p\n  f \\<in># F\n\ngoal (1 subgoal):\n 1. irreducible f &&& f dvd p", "by (auto dest: mset_factors_imp_dvd)"], ["proof (state)\nthis:\n  irreducible f\n  f dvd p\n\ngoal (1 subgoal):\n 1. degree f = 0 \\<Longrightarrow> False", "assume deg: \"degree f = 0\""], ["proof (state)\nthis:\n  degree f = 0\n\ngoal (1 subgoal):\n 1. degree f = 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  degree f = 0", "obtain f0 where f0: \"f = [:f0:]\""], ["proof (prove)\nusing this:\n  degree f = 0\n\ngoal (1 subgoal):\n 1. (\\<And>f0. f = [:f0:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto dest: degree0_coeffs)"], ["proof (state)\nthis:\n  f = [:f0:]\n\ngoal (1 subgoal):\n 1. degree f = 0 \\<Longrightarrow> False", "with fp"], ["proof (chain)\npicking this:\n  f dvd p\n  f = [:f0:]", "have \"[:f0:] dvd p\""], ["proof (prove)\nusing this:\n  f dvd p\n  f = [:f0:]\n\ngoal (1 subgoal):\n 1. [:f0:] dvd p", "by simp"], ["proof (state)\nthis:\n  [:f0:] dvd p\n\ngoal (1 subgoal):\n 1. degree f = 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  [:f0:] dvd p", "have \"f0 dvd coeff p i\" for i"], ["proof (prove)\nusing this:\n  [:f0:] dvd p\n\ngoal (1 subgoal):\n 1. f0 dvd coeff p i", "by (simp add: const_poly_dvd_iff)"], ["proof (state)\nthis:\n  f0 dvd coeff p ?i\n\ngoal (1 subgoal):\n 1. degree f = 0 \\<Longrightarrow> False", "with primitiveD[OF pr] dvd_all_coeffs_iff"], ["proof (chain)\npicking this:\n  (\\<And>y.\n      y \\<in> set (coeffs p) \\<Longrightarrow> ?x dvd y) \\<Longrightarrow>\n  ?x dvd (1::'a)\n  (\\<forall>pi\\<in>set (coeffs ?p). ?x dvd pi) =\n  (\\<forall>i. ?x dvd coeff ?p i)\n  f0 dvd coeff p ?i", "have \"f0 dvd 1\""], ["proof (prove)\nusing this:\n  (\\<And>y.\n      y \\<in> set (coeffs p) \\<Longrightarrow> ?x dvd y) \\<Longrightarrow>\n  ?x dvd (1::'a)\n  (\\<forall>pi\\<in>set (coeffs ?p). ?x dvd pi) =\n  (\\<forall>i. ?x dvd coeff ?p i)\n  f0 dvd coeff p ?i\n\ngoal (1 subgoal):\n 1. f0 dvd (1::'a)", "by (auto simp: coeffs_def)"], ["proof (state)\nthis:\n  f0 dvd (1::'a)\n\ngoal (1 subgoal):\n 1. degree f = 0 \\<Longrightarrow> False", "with f0 irr"], ["proof (chain)\npicking this:\n  f = [:f0:]\n  irreducible f\n  f0 dvd (1::'a)", "show False"], ["proof (prove)\nusing this:\n  f = [:f0:]\n  irreducible f\n  f0 dvd (1::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_poly_x_minus_y_poly_lift:\n  fixes p q :: \"'a :: ufd poly\"\n  assumes degp: \"degree p > 0\" and degq: \"degree q > 0\"\n    and pr: \"primitive p\"\n  shows \"coprime (poly_x_minus_y p) (poly_lift q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (poly_x_minus_y p) (poly_lift q)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from degp"], ["proof (chain)\npicking this:\n  0 < degree p", "have p: \"\\<not> p dvd 1\""], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. \\<not> p dvd 1", "by (auto simp: dvd_const)"], ["proof (state)\nthis:\n  \\<not> p dvd 1\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from degp"], ["proof (chain)\npicking this:\n  0 < degree p", "have p0: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from mset_factors_exist[of p, OF p0 p]"], ["proof (chain)\npicking this:\n  \\<exists>F. mset_factors F p", "obtain F where F: \"mset_factors F p\""], ["proof (prove)\nusing this:\n  \\<exists>F. mset_factors F p\n\ngoal (1 subgoal):\n 1. (\\<And>F. mset_factors F p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mset_factors F p\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "with poly_x_minus_y_hom.hom_mset_factors"], ["proof (chain)\npicking this:\n  mset_factors ?F ?p \\<Longrightarrow>\n  mset_factors (image_mset poly_x_minus_y ?F) (poly_x_minus_y ?p)\n  mset_factors F p", "have pF: \"mset_factors (image_mset poly_x_minus_y F) (poly_x_minus_y p)\""], ["proof (prove)\nusing this:\n  mset_factors ?F ?p \\<Longrightarrow>\n  mset_factors (image_mset poly_x_minus_y ?F) (poly_x_minus_y ?p)\n  mset_factors F p\n\ngoal (1 subgoal):\n 1. mset_factors (image_mset poly_x_minus_y F) (poly_x_minus_y p)", "by auto"], ["proof (state)\nthis:\n  mset_factors (image_mset poly_x_minus_y F) (poly_x_minus_y p)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from degq"], ["proof (chain)\npicking this:\n  0 < degree q", "have q: \"\\<not> q dvd 1\""], ["proof (prove)\nusing this:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. \\<not> q dvd 1", "by (auto simp: dvd_const)"], ["proof (state)\nthis:\n  \\<not> q dvd 1\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from degq"], ["proof (chain)\npicking this:\n  0 < degree q", "have q0: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from mset_factors_exist[OF q0 q]"], ["proof (chain)\npicking this:\n  \\<exists>F. mset_factors F q", "obtain G where G: \"mset_factors G q\""], ["proof (prove)\nusing this:\n  \\<exists>F. mset_factors F q\n\ngoal (1 subgoal):\n 1. (\\<And>G. mset_factors G q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mset_factors G q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "with poly_lift_hom.hom_mset_factors"], ["proof (chain)\npicking this:\n  mset_factors ?F ?p \\<Longrightarrow>\n  mset_factors (image_mset poly_lift ?F) (poly_lift ?p)\n  mset_factors G q", "have pG: \"mset_factors (image_mset poly_lift G) (poly_lift q)\""], ["proof (prove)\nusing this:\n  mset_factors ?F ?p \\<Longrightarrow>\n  mset_factors (image_mset poly_lift ?F) (poly_lift ?p)\n  mset_factors G q\n\ngoal (1 subgoal):\n 1. mset_factors (image_mset poly_lift G) (poly_lift q)", "by auto"], ["proof (state)\nthis:\n  mset_factors (image_mset poly_lift G) (poly_lift q)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "assume \"\\<not> coprime (poly_x_minus_y p) (poly_lift q)\""], ["proof (state)\nthis:\n  \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p) (poly_lift q)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from this[unfolded not_coprime_iff_common_factor]"], ["proof (chain)\npicking this:\n  \\<exists>r.\n     r dvd poly_x_minus_y p \\<and> r dvd poly_lift q \\<and> \\<not> r dvd 1", "obtain r\n  where rp: \"r dvd (poly_x_minus_y p)\"\n    and rq: \"r dvd (poly_lift q)\"\n    and rU: \"\\<not> r dvd 1\""], ["proof (prove)\nusing this:\n  \\<exists>r.\n     r dvd poly_x_minus_y p \\<and> r dvd poly_lift q \\<and> \\<not> r dvd 1\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>r dvd poly_x_minus_y p; r dvd poly_lift q;\n         \\<not> r dvd 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r dvd poly_x_minus_y p\n  r dvd poly_lift q\n  \\<not> r dvd 1\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "note poly_lift_hom.hom_dvd"], ["proof (state)\nthis:\n  ?p dvd ?q \\<Longrightarrow> poly_lift ?p dvd poly_lift ?q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from rp p0"], ["proof (chain)\npicking this:\n  r dvd poly_x_minus_y p\n  p \\<noteq> 0", "have r0: \"r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  r dvd poly_x_minus_y p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from mset_factors_exist[OF r0 rU]"], ["proof (chain)\npicking this:\n  \\<exists>F. mset_factors F r", "obtain H where H: \"mset_factors H r\""], ["proof (prove)\nusing this:\n  \\<exists>F. mset_factors F r\n\ngoal (1 subgoal):\n 1. (\\<And>H. mset_factors H r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mset_factors H r\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  mset_factors H r", "have \"H \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  mset_factors H r\n\ngoal (1 subgoal):\n 1. H \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  H \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  H \\<noteq> {#}", "obtain h where hH: \"h \\<in># H\""], ["proof (prove)\nusing this:\n  H \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (\\<And>h. h \\<in># H \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  h \\<in># H\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "with H mset_factors_imp_dvd"], ["proof (chain)\npicking this:\n  mset_factors H r\n  \\<lbrakk>mset_factors ?F ?x; ?f \\<in># ?F\\<rbrakk>\n  \\<Longrightarrow> ?f dvd ?x\n  h \\<in># H", "have hr: \"h dvd r\" and h: \"irreducible h\""], ["proof (prove)\nusing this:\n  mset_factors H r\n  \\<lbrakk>mset_factors ?F ?x; ?f \\<in># ?F\\<rbrakk>\n  \\<Longrightarrow> ?f dvd ?x\n  h \\<in># H\n\ngoal (1 subgoal):\n 1. h dvd r &&& irreducible h", "by auto"], ["proof (state)\nthis:\n  h dvd r\n  irreducible h\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from irreducible_not_unit[OF h]"], ["proof (chain)\npicking this:\n  \\<not> h dvd 1", "have hU: \"\\<not> h dvd 1\""], ["proof (prove)\nusing this:\n  \\<not> h dvd 1\n\ngoal (1 subgoal):\n 1. \\<not> h dvd 1", "by auto"], ["proof (state)\nthis:\n  \\<not> h dvd 1\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from hr rp"], ["proof (chain)\npicking this:\n  h dvd r\n  r dvd poly_x_minus_y p", "have \"h dvd (poly_x_minus_y p)\""], ["proof (prove)\nusing this:\n  h dvd r\n  r dvd poly_x_minus_y p\n\ngoal (1 subgoal):\n 1. h dvd poly_x_minus_y p", "by (rule dvd_trans)"], ["proof (state)\nthis:\n  h dvd poly_x_minus_y p\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from irreducible_dvd_imp_factor[OF this h pF] p0"], ["proof (chain)\npicking this:\n  \\<exists>g\\<in>#image_mset poly_x_minus_y F. h ddvd g\n  p \\<noteq> 0", "obtain f where f: \"f \\<in># F\" and fh: \"poly_x_minus_y f ddvd h\""], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>#image_mset poly_x_minus_y F. h ddvd g\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in># F; poly_x_minus_y f ddvd h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f \\<in># F\n  poly_x_minus_y f ddvd h\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from hr rq"], ["proof (chain)\npicking this:\n  h dvd r\n  r dvd poly_lift q", "have \"h dvd (poly_lift q)\""], ["proof (prove)\nusing this:\n  h dvd r\n  r dvd poly_lift q\n\ngoal (1 subgoal):\n 1. h dvd poly_lift q", "by (rule dvd_trans)"], ["proof (state)\nthis:\n  h dvd poly_lift q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from irreducible_dvd_imp_factor[OF this h pG] q0"], ["proof (chain)\npicking this:\n  \\<exists>g\\<in>#image_mset poly_lift G. h ddvd g\n  q \\<noteq> 0", "obtain g where g: \"g \\<in># G\" and gh: \"poly_lift g ddvd h\""], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>#image_mset poly_lift G. h ddvd g\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in># G; poly_lift g ddvd h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g \\<in># G\n  poly_lift g ddvd h\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from fh gh"], ["proof (chain)\npicking this:\n  poly_x_minus_y f ddvd h\n  poly_lift g ddvd h", "have \"poly_x_minus_y f ddvd poly_lift g\""], ["proof (prove)\nusing this:\n  poly_x_minus_y f ddvd h\n  poly_lift g ddvd h\n\ngoal (1 subgoal):\n 1. poly_x_minus_y f ddvd poly_lift g", "using ddvd_trans"], ["proof (prove)\nusing this:\n  poly_x_minus_y f ddvd h\n  poly_lift g ddvd h\n  \\<lbrakk>?x ddvd ?y; ?y ddvd ?z\\<rbrakk> \\<Longrightarrow> ?x ddvd ?z\n\ngoal (1 subgoal):\n 1. poly_x_minus_y f ddvd poly_lift g", "by auto"], ["proof (state)\nthis:\n  poly_x_minus_y f ddvd poly_lift g\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  poly_x_minus_y f ddvd poly_lift g", "have \"poly_y_x (poly_x_minus_y f) ddvd poly_y_x (poly_lift g)\""], ["proof (prove)\nusing this:\n  poly_x_minus_y f ddvd poly_lift g\n\ngoal (1 subgoal):\n 1. poly_y_x (poly_x_minus_y f) ddvd poly_y_x (poly_lift g)", "by simp"], ["proof (state)\nthis:\n  poly_y_x (poly_x_minus_y f) ddvd poly_y_x (poly_lift g)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  poly_y_x (poly_x_minus_y f) ddvd poly_y_x (poly_lift g)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "have \"poly_y_x (poly_lift g) = [:g:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_y_x (poly_lift g) = [:g:]", "unfolding poly_y_x_poly_lift monom_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. [:g:] = [:g:]", "by auto"], ["proof (state)\nthis:\n  poly_y_x (poly_lift g) = [:g:]\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  poly_y_x (poly_x_minus_y f) ddvd [:g:]", "have ddvd: \"poly_y_x (poly_x_minus_y f) ddvd [:g:]\""], ["proof (prove)\nusing this:\n  poly_y_x (poly_x_minus_y f) ddvd [:g:]\n\ngoal (1 subgoal):\n 1. poly_y_x (poly_x_minus_y f) ddvd [:g:]", "by auto"], ["proof (state)\nthis:\n  poly_y_x (poly_x_minus_y f) ddvd [:g:]\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  poly_y_x (poly_x_minus_y f) ddvd [:g:]", "have \"degree (poly_y_x (poly_x_minus_y f)) = 0\""], ["proof (prove)\nusing this:\n  poly_y_x (poly_x_minus_y f) ddvd [:g:]\n\ngoal (1 subgoal):\n 1. degree (poly_y_x (poly_x_minus_y f)) = 0", "by (metis degree_pCons_0 dvd_0_left_iff dvd_const)"], ["proof (state)\nthis:\n  degree (poly_y_x (poly_x_minus_y f)) = 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  degree (poly_y_x (poly_x_minus_y f)) = 0", "have \"degree f = 0\""], ["proof (prove)\nusing this:\n  degree (poly_y_x (poly_x_minus_y f)) = 0\n\ngoal (1 subgoal):\n 1. degree f = 0", "by simp"], ["proof (state)\nthis:\n  degree f = 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "with primitive_imp_no_constant_factor[OF pr F f]"], ["proof (chain)\npicking this:\n  degree f \\<noteq> 0\n  degree f = 0", "show False"], ["proof (prove)\nusing this:\n  degree f \\<noteq> 0\n  degree f = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_add_nonzero:\n  fixes p q :: \"'a :: ufd poly\"\n  assumes p0: \"p \\<noteq> 0\" and q0: \"q \\<noteq> 0\" and x: \"poly p x = 0\" and y: \"poly q y = 0\"\n      and pr: \"primitive p\"\n  shows \"poly_add p q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_add p q \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_add p q = 0 \\<Longrightarrow> False", "have degp: \"degree p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree p", "using le_0_eq order_degree order_root p0 x"], ["proof (prove)\nusing this:\n  (?n \\<le> 0) = (?n = 0)\n  ?p \\<noteq> 0 \\<Longrightarrow> Polynomial.order ?a ?p \\<le> degree ?p\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> Polynomial.order ?a ?p \\<noteq> 0)\n  p \\<noteq> 0\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < degree p", "by (metis gr0I)"], ["proof (state)\nthis:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. poly_add p q = 0 \\<Longrightarrow> False", "have degq: \"degree q > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree q", "using le_0_eq order_degree order_root q0 y"], ["proof (prove)\nusing this:\n  (?n \\<le> 0) = (?n = 0)\n  ?p \\<noteq> 0 \\<Longrightarrow> Polynomial.order ?a ?p \\<le> degree ?p\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> Polynomial.order ?a ?p \\<noteq> 0)\n  q \\<noteq> 0\n  poly q y = (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < degree q", "by (metis gr0I)"], ["proof (state)\nthis:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. poly_add p q = 0 \\<Longrightarrow> False", "assume 0: \"poly_add p q = 0\""], ["proof (state)\nthis:\n  poly_add p q = 0\n\ngoal (1 subgoal):\n 1. poly_add p q = 0 \\<Longrightarrow> False", "from resultant_zero_imp_common_factor[OF _ this[unfolded poly_add_def]] degp\n   and coprime_poly_x_minus_y_poly_lift[OF degp degq pr]"], ["proof (chain)\npicking this:\n  0 < degree (poly_x_minus_y p) \\<or>\n  0 < degree (poly_lift q) \\<Longrightarrow>\n  \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p) (poly_lift q)\n  0 < degree p\n  comm_monoid_mult_class.coprime (poly_x_minus_y p) (poly_lift q)", "show False"], ["proof (prove)\nusing this:\n  0 < degree (poly_x_minus_y p) \\<or>\n  0 < degree (poly_lift q) \\<Longrightarrow>\n  \\<not> comm_monoid_mult_class.coprime (poly_x_minus_y p) (poly_lift q)\n  0 < degree p\n  comm_monoid_mult_class.coprime (poly_x_minus_y p) (poly_lift q)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Summary for addition\\<close>"], ["", "text \\<open>Now we lift the results to one that uses @{const ipoly}, by showing some homomorphism lemmas.\\<close>"], ["", "lemma (in comm_ring_hom) map_poly_x_minus_y:\n  \"map_poly (map_poly hom) (poly_x_minus_y p) = poly_x_minus_y (map_poly hom p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (map_poly hom) (poly_x_minus_y p) =\n    poly_x_minus_y (map_poly hom p)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly (map_poly hom) (poly_x_minus_y p) =\n    poly_x_minus_y (map_poly hom p)", "interpret mp: map_poly_comm_ring_hom hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_ring_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly (map_poly hom) (poly_x_minus_y p) =\n    poly_x_minus_y (map_poly hom p)", "interpret mmp: map_poly_comm_ring_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_comm_ring_hom (map_poly hom)", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly (map_poly hom) (poly_x_minus_y p) =\n    poly_x_minus_y (map_poly hom p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (map_poly hom) (poly_x_minus_y p) =\n    poly_x_minus_y (map_poly hom p)", "apply (induct p, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        map_poly (map_poly hom) (poly_x_minus_y p) =\n        poly_x_minus_y (map_poly hom p)\\<rbrakk>\n       \\<Longrightarrow> map_poly (map_poly hom)\n                          (poly_x_minus_y (pCons a p)) =\n                         poly_x_minus_y (map_poly hom (pCons a p))", "apply(unfold x_y_def hom_distribs poly_x_minus_y_pCons, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_poly (map_poly hom) (poly_x_minus_y p) =\n  poly_x_minus_y (map_poly hom p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comm_ring_hom) hom_poly_lift[simp]:\n  \"map_poly (map_poly hom) (poly_lift q) = poly_lift (map_poly hom q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (map_poly hom) (poly_lift q) = poly_lift (map_poly hom q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly (map_poly hom) (poly_lift q) = poly_lift (map_poly hom q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (map_poly hom) (poly_lift q) = poly_lift (map_poly hom q)", "unfolding poly_lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (map_poly hom) (map_poly (\\<lambda>a. [:a:]) q) =\n    map_poly (\\<lambda>a. [:a:]) (map_poly hom q)", "unfolding map_poly_map_poly[of coeff_lift,OF coeff_lift_hom.hom_zero]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (map_poly hom) (map_poly (\\<lambda>a. [:a:]) q) =\n    map_poly ((\\<lambda>a. [:a:]) \\<circ> hom) q", "unfolding map_poly_coeff_lift_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (map_poly hom) (map_poly (\\<lambda>a. [:a:]) q) =\n    map_poly (map_poly hom) (map_poly (\\<lambda>a. [:a:]) q)", "by simp"], ["proof (state)\nthis:\n  map_poly (map_poly hom) (poly_lift q) = poly_lift (map_poly hom q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_coeff_poly_x_minus_y:\n  fixes p :: \"'a::idom poly\"\n  shows \"lead_coeff (poly_x_minus_y p) = [:lead_coeff p * ((- 1) ^ degree p):]\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (poly_x_minus_y p) =\n    [:lead_coeff p * (- (1::'a)) ^ degree p:]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_coeff (poly_x_minus_y p) =\n    [:lead_coeff p * (- (1::'a)) ^ degree p:]", "have \"?l = Polynomial.smult (lead_coeff p) ((- 1) ^ degree p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (poly_x_minus_y p) =\n    Polynomial.smult (lead_coeff p) ((- 1) ^ degree p)", "by (unfold poly_x_minus_y_def, subst lead_coeff_comp; simp add: x_y_def)"], ["proof (state)\nthis:\n  lead_coeff (poly_x_minus_y p) =\n  Polynomial.smult (lead_coeff p) ((- 1) ^ degree p)\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_x_minus_y p) =\n    [:lead_coeff p * (- (1::'a)) ^ degree p:]", "also"], ["proof (state)\nthis:\n  lead_coeff (poly_x_minus_y p) =\n  Polynomial.smult (lead_coeff p) ((- 1) ^ degree p)\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_x_minus_y p) =\n    [:lead_coeff p * (- (1::'a)) ^ degree p:]", "have \"... = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (lead_coeff p) ((- 1) ^ degree p) =\n    [:lead_coeff p * (- (1::'a)) ^ degree p:]", "by (unfold hom_distribs, simp add: smult_as_map_poly[symmetric])"], ["proof (state)\nthis:\n  Polynomial.smult (lead_coeff p) ((- 1) ^ degree p) =\n  [:lead_coeff p * (- (1::'a)) ^ degree p:]\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_x_minus_y p) =\n    [:lead_coeff p * (- (1::'a)) ^ degree p:]", "finally"], ["proof (chain)\npicking this:\n  lead_coeff (poly_x_minus_y p) = [:lead_coeff p * (- (1::'a)) ^ degree p:]", "show ?thesis"], ["proof (prove)\nusing this:\n  lead_coeff (poly_x_minus_y p) = [:lead_coeff p * (- (1::'a)) ^ degree p:]\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_x_minus_y p) =\n    [:lead_coeff p * (- (1::'a)) ^ degree p:]", "."], ["proof (state)\nthis:\n  lead_coeff (poly_x_minus_y p) = [:lead_coeff p * (- (1::'a)) ^ degree p:]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_coeff_poly_x_minus_y:\n  fixes p q :: \"'a :: {idom, semiring_char_0} poly\"\n  shows \"degree (coeff (poly_x_minus_y p) i) = degree p - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (coeff (poly_x_minus_y p) i) = degree p - i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (coeff (poly_x_minus_y p) i) = degree p - i", "consider \"i = degree p\" | \"i > degree p\" | \"i < degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = degree p \\<Longrightarrow> thesis;\n     degree p < i \\<Longrightarrow> thesis;\n     i < degree p \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>i = degree p \\<Longrightarrow> ?thesis;\n   degree p < i \\<Longrightarrow> ?thesis;\n   i < degree p \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. degree (coeff (poly_x_minus_y p) i) = degree p - i", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>i = degree p \\<Longrightarrow> ?thesis;\n   degree p < i \\<Longrightarrow> ?thesis;\n   i < degree p \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. degree (coeff (poly_x_minus_y p) i) = degree p - i", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. i = degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i\n 2. degree p < i \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i\n 3. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "assume \"i > degree p\""], ["proof (state)\nthis:\n  degree p < i\n\ngoal (3 subgoals):\n 1. i = degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i\n 2. degree p < i \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i\n 3. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "thus ?thesis"], ["proof (prove)\nusing this:\n  degree p < i\n\ngoal (1 subgoal):\n 1. degree (coeff (poly_x_minus_y p) i) = degree p - i", "by (subst coeff_eq_0) auto"], ["proof (state)\nthis:\n  degree (coeff (poly_x_minus_y p) i) = degree p - i\n\ngoal (2 subgoals):\n 1. i = degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i\n 2. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i = degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i\n 2. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "assume \"i = degree p\""], ["proof (state)\nthis:\n  i = degree p\n\ngoal (2 subgoals):\n 1. i = degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i\n 2. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = degree p\n\ngoal (1 subgoal):\n 1. degree (coeff (poly_x_minus_y p) i) = degree p - i", "using lead_coeff_poly_x_minus_y[of p]"], ["proof (prove)\nusing this:\n  i = degree p\n  lead_coeff (poly_x_minus_y p) = [:lead_coeff p * (- (1::'a)) ^ degree p:]\n\ngoal (1 subgoal):\n 1. degree (coeff (poly_x_minus_y p) i) = degree p - i", "by (simp add: lead_coeff_poly_x_minus_y)"], ["proof (state)\nthis:\n  degree (coeff (poly_x_minus_y p) i) = degree p - i\n\ngoal (1 subgoal):\n 1. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "assume \"i < degree p\""], ["proof (state)\nthis:\n  i < degree p\n\ngoal (1 subgoal):\n 1. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "define n where \"n = degree p\""], ["proof (state)\nthis:\n  n = degree p\n\ngoal (1 subgoal):\n 1. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "have \"degree (coeff (poly_x_minus_y p) i) =\n            degree (\\<Sum>j\\<le>n. [:coeff p j:] * coeff (x_y ^ j) i)\" (is \"_ = degree (sum ?f _)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (coeff (poly_x_minus_y p) i) =\n    degree (\\<Sum>j\\<le>n. [:coeff p j:] * coeff (x_y ^ j) i)", "by (simp add: poly_x_minus_y_def pcompose_conv_poly poly_altdef coeff_sum n_def)"], ["proof (state)\nthis:\n  degree (coeff (poly_x_minus_y p) i) =\n  degree (\\<Sum>j\\<le>n. [:coeff p j:] * coeff (x_y ^ j) i)\n\ngoal (1 subgoal):\n 1. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "also"], ["proof (state)\nthis:\n  degree (coeff (poly_x_minus_y p) i) =\n  degree (\\<Sum>j\\<le>n. [:coeff p j:] * coeff (x_y ^ j) i)\n\ngoal (1 subgoal):\n 1. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "have \"{..n} = insert n {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..n} = insert n {..<n}", "by auto"], ["proof (state)\nthis:\n  {..n} = insert n {..<n}\n\ngoal (1 subgoal):\n 1. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "also"], ["proof (state)\nthis:\n  {..n} = insert n {..<n}\n\ngoal (1 subgoal):\n 1. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "have \"sum ?f \\<dots> = ?f n + sum ?f {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>insert n {..<n}. [:coeff p j:] * coeff (x_y ^ j) i) =\n    [:coeff p n:] * coeff (x_y ^ n) i +\n    (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i)", "by (subst sum.insert) auto"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>insert n {..<n}. [:coeff p j:] * coeff (x_y ^ j) i) =\n  [:coeff p n:] * coeff (x_y ^ n) i +\n  (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i)\n\ngoal (1 subgoal):\n 1. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>insert n {..<n}. [:coeff p j:] * coeff (x_y ^ j) i) =\n  [:coeff p n:] * coeff (x_y ^ n) i +\n  (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i)\n\ngoal (1 subgoal):\n 1. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "have \"degree \\<dots> = n - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     ([:coeff p n:] * coeff (x_y ^ n) i +\n      (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i)) =\n    n - i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree\n     ([:coeff p n:] * coeff (x_y ^ n) i +\n      (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i)) =\n    n - i", "have \"degree (?f n) = n - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ([:coeff p n:] * coeff (x_y ^ n) i) = n - i", "using \\<open>i < degree p\\<close>"], ["proof (prove)\nusing this:\n  i < degree p\n\ngoal (1 subgoal):\n 1. degree ([:coeff p n:] * coeff (x_y ^ n) i) = n - i", "by (simp add: n_def coeff_xy_power degree_monom_eq)"], ["proof (state)\nthis:\n  degree ([:coeff p n:] * coeff (x_y ^ n) i) = n - i\n\ngoal (1 subgoal):\n 1. degree\n     ([:coeff p n:] * coeff (x_y ^ n) i +\n      (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i)) =\n    n - i", "moreover"], ["proof (state)\nthis:\n  degree ([:coeff p n:] * coeff (x_y ^ n) i) = n - i\n\ngoal (1 subgoal):\n 1. degree\n     ([:coeff p n:] * coeff (x_y ^ n) i +\n      (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i)) =\n    n - i", "have \"degree (sum ?f {..<n}) < n - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i) < n - i", "proof (intro degree_sum_smaller)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < n - i\n 2. finite {..<n}\n 3. \\<And>j.\n       j \\<in> {..<n} \\<Longrightarrow>\n       degree ([:coeff p j:] * coeff (x_y ^ j) i) < n - i", "fix j"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < n - i\n 2. finite {..<n}\n 3. \\<And>j.\n       j \\<in> {..<n} \\<Longrightarrow>\n       degree ([:coeff p j:] * coeff (x_y ^ j) i) < n - i", "assume \"j \\<in> {..<n}\""], ["proof (state)\nthis:\n  j \\<in> {..<n}\n\ngoal (3 subgoals):\n 1. 0 < n - i\n 2. finite {..<n}\n 3. \\<And>j.\n       j \\<in> {..<n} \\<Longrightarrow>\n       degree ([:coeff p j:] * coeff (x_y ^ j) i) < n - i", "have \"degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i", "proof (cases \"i \\<le> j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> j \\<Longrightarrow>\n    degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i\n 2. \\<not> i \\<le> j \\<Longrightarrow>\n    degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i", "case True"], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. i \\<le> j \\<Longrightarrow>\n    degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i\n 2. \\<not> i \\<le> j \\<Longrightarrow>\n    degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i", "by (auto simp: n_def coeff_xy_power degree_monom_eq)"], ["proof (state)\nthis:\n  degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow>\n    degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow>\n    degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i", "case False"], ["proof (state)\nthis:\n  \\<not> i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow>\n    degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i", "hence \"coeff (x_y ^ j :: 'a poly poly) i = 0\""], ["proof (prove)\nusing this:\n  \\<not> i \\<le> j\n\ngoal (1 subgoal):\n 1. coeff (x_y ^ j) i = 0", "by (subst coeff_eq_0) (auto simp: degree_power_eq)"], ["proof (state)\nthis:\n  coeff (x_y ^ j) i = 0\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> j \\<Longrightarrow>\n    degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i", "thus ?thesis"], ["proof (prove)\nusing this:\n  coeff (x_y ^ j) i = 0\n\ngoal (1 subgoal):\n 1. degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i", "by simp"], ["proof (state)\nthis:\n  degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i\n\ngoal (3 subgoals):\n 1. 0 < n - i\n 2. finite {..<n}\n 3. \\<And>j.\n       j \\<in> {..<n} \\<Longrightarrow>\n       degree ([:coeff p j:] * coeff (x_y ^ j) i) < n - i", "also"], ["proof (state)\nthis:\n  degree ([:coeff p j:] * coeff (x_y ^ j) i) \\<le> j - i\n\ngoal (3 subgoals):\n 1. 0 < n - i\n 2. finite {..<n}\n 3. \\<And>j.\n       j \\<in> {..<n} \\<Longrightarrow>\n       degree ([:coeff p j:] * coeff (x_y ^ j) i) < n - i", "have \"\\<dots> < n - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j - i < n - i", "using \\<open>j \\<in> {..<n}\\<close> \\<open>i < degree p\\<close>"], ["proof (prove)\nusing this:\n  j \\<in> {..<n}\n  i < degree p\n\ngoal (1 subgoal):\n 1. j - i < n - i", "by (auto simp: n_def)"], ["proof (state)\nthis:\n  j - i < n - i\n\ngoal (3 subgoals):\n 1. 0 < n - i\n 2. finite {..<n}\n 3. \\<And>j.\n       j \\<in> {..<n} \\<Longrightarrow>\n       degree ([:coeff p j:] * coeff (x_y ^ j) i) < n - i", "finally"], ["proof (chain)\npicking this:\n  degree ([:coeff p j:] * coeff (x_y ^ j) i) < n - i", "show \"degree ([:coeff p j:] * coeff (x_y ^ j) i) < n - i\""], ["proof (prove)\nusing this:\n  degree ([:coeff p j:] * coeff (x_y ^ j) i) < n - i\n\ngoal (1 subgoal):\n 1. degree ([:coeff p j:] * coeff (x_y ^ j) i) < n - i", "."], ["proof (state)\nthis:\n  degree ([:coeff p j:] * coeff (x_y ^ j) i) < n - i\n\ngoal (2 subgoals):\n 1. 0 < n - i\n 2. finite {..<n}", "qed (use \\<open>i < degree p\\<close> in \\<open>auto simp: n_def\\<close>)"], ["proof (state)\nthis:\n  degree (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i) < n - i\n\ngoal (1 subgoal):\n 1. degree\n     ([:coeff p n:] * coeff (x_y ^ n) i +\n      (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i)) =\n    n - i", "ultimately"], ["proof (chain)\npicking this:\n  degree ([:coeff p n:] * coeff (x_y ^ n) i) = n - i\n  degree (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i) < n - i", "show ?thesis"], ["proof (prove)\nusing this:\n  degree ([:coeff p n:] * coeff (x_y ^ n) i) = n - i\n  degree (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i) < n - i\n\ngoal (1 subgoal):\n 1. degree\n     ([:coeff p n:] * coeff (x_y ^ n) i +\n      (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i)) =\n    n - i", "by (subst degree_add_eq_left) auto"], ["proof (state)\nthis:\n  degree\n   ([:coeff p n:] * coeff (x_y ^ n) i +\n    (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i)) =\n  n - i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree\n   ([:coeff p n:] * coeff (x_y ^ n) i +\n    (\\<Sum>j<n. [:coeff p j:] * coeff (x_y ^ j) i)) =\n  n - i\n\ngoal (1 subgoal):\n 1. i < degree p \\<Longrightarrow>\n    degree (coeff (poly_x_minus_y p) i) = degree p - i", "finally"], ["proof (chain)\npicking this:\n  degree (coeff (poly_x_minus_y p) i) = n - i", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (coeff (poly_x_minus_y p) i) = n - i\n\ngoal (1 subgoal):\n 1. degree (coeff (poly_x_minus_y p) i) = degree p - i", "by (simp add: n_def)"], ["proof (state)\nthis:\n  degree (coeff (poly_x_minus_y p) i) = degree p - i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (coeff (poly_x_minus_y p) i) = degree p - i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_0_poly_x_minus_y [simp]: \"coeff (poly_x_minus_y p) 0 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_x_minus_y p) 0 = p", "by (induction p) (auto simp: poly_x_minus_y_def x_y_def)"], ["", "lemma (in idom_hom) poly_add_hom:\n  assumes p0: \"hom (lead_coeff p) \\<noteq> 0\" and q0: \"hom (lead_coeff q) \\<noteq> 0\"\n  shows \"map_poly hom (poly_add p q) = poly_add (map_poly hom p) (map_poly hom q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (poly_add p q) = poly_add (map_poly hom p) (map_poly hom q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly hom (poly_add p q) = poly_add (map_poly hom p) (map_poly hom q)", "interpret mh: map_poly_idom_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_idom_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly hom (poly_add p q) = poly_add (map_poly hom p) (map_poly hom q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (poly_add p q) = poly_add (map_poly hom p) (map_poly hom q)", "unfolding poly_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (resultant (poly_x_minus_y p) (poly_lift q)) =\n    resultant (poly_x_minus_y (map_poly hom p)) (poly_lift (map_poly hom q))", "apply (subst mh.resultant_map_poly(1)[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. degree (map_poly (map_poly hom) (poly_x_minus_y p)) =\n    degree (poly_x_minus_y p)\n 2. degree (map_poly (map_poly hom) (poly_lift q)) = degree (poly_lift q)\n 3. resultant (map_poly (map_poly hom) (poly_x_minus_y p))\n     (map_poly (map_poly hom) (poly_lift q)) =\n    resultant (poly_x_minus_y (map_poly hom p)) (poly_lift (map_poly hom q))", "apply (subst degree_map_poly_2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. map_poly hom (lead_coeff (poly_x_minus_y p)) \\<noteq> 0\n 2. degree (poly_x_minus_y p) = degree (poly_x_minus_y p)\n 3. degree (map_poly (map_poly hom) (poly_lift q)) = degree (poly_lift q)\n 4. resultant (map_poly (map_poly hom) (poly_x_minus_y p))\n     (map_poly (map_poly hom) (poly_lift q)) =\n    resultant (poly_x_minus_y (map_poly hom p)) (poly_lift (map_poly hom q))", "apply (unfold lead_coeff_poly_x_minus_y, unfold hom_distribs, simp add: p0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. degree (poly_x_minus_y p) = degree (poly_x_minus_y p)\n 2. degree (map_poly (map_poly hom) (poly_lift q)) = degree (poly_lift q)\n 3. resultant (map_poly (map_poly hom) (poly_x_minus_y p))\n     (map_poly (map_poly hom) (poly_lift q)) =\n    resultant (poly_x_minus_y (map_poly hom p)) (poly_lift (map_poly hom q))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. degree (map_poly (map_poly hom) (poly_lift q)) = degree (poly_lift q)\n 2. resultant (map_poly (map_poly hom) (poly_x_minus_y p))\n     (map_poly (map_poly hom) (poly_lift q)) =\n    resultant (poly_x_minus_y (map_poly hom p)) (poly_lift (map_poly hom q))", "apply (subst degree_map_poly_2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. map_poly hom (lead_coeff (poly_lift q)) \\<noteq> 0\n 2. degree (poly_lift q) = degree (poly_lift q)\n 3. resultant (map_poly (map_poly hom) (poly_x_minus_y p))\n     (map_poly (map_poly hom) (poly_lift q)) =\n    resultant (poly_x_minus_y (map_poly hom p)) (poly_lift (map_poly hom q))", "apply (simp_all add: q0 map_poly_x_minus_y)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_poly hom (poly_add p q) = poly_add (map_poly hom p) (map_poly hom q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma(in zero_hom) hom_lead_coeff_nonzero_imp_map_poly_hom:\n  assumes \"hom (lead_coeff p) \\<noteq> 0\"\n  shows \"map_poly hom p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom p \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly hom p = 0 \\<Longrightarrow> False", "assume \"map_poly hom p = 0\""], ["proof (state)\nthis:\n  map_poly hom p = 0\n\ngoal (1 subgoal):\n 1. map_poly hom p = 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  map_poly hom p = 0", "have \"coeff (map_poly hom p) (degree p) = 0\""], ["proof (prove)\nusing this:\n  map_poly hom p = 0\n\ngoal (1 subgoal):\n 1. coeff (map_poly hom p) (degree p) = (0::'b)", "by simp"], ["proof (state)\nthis:\n  coeff (map_poly hom p) (degree p) = (0::'b)\n\ngoal (1 subgoal):\n 1. map_poly hom p = 0 \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  hom (lead_coeff p) \\<noteq> (0::'b)\n  coeff (map_poly hom p) (degree p) = (0::'b)", "show False"], ["proof (prove)\nusing this:\n  hom (lead_coeff p) \\<noteq> (0::'b)\n  coeff (map_poly hom p) (degree p) = (0::'b)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipoly_poly_add:\n  fixes x y :: \"'a :: idom\"\n  assumes p0: \"(of_int (lead_coeff p) :: 'a) \\<noteq> 0\" and q0: \"(of_int (lead_coeff q) :: 'a) \\<noteq> 0\"\n      and x: \"ipoly p x = 0\" and y: \"ipoly q y = 0\"\n  shows \"ipoly (poly_add p q) (x+y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (poly_add p q) (x + y) = (0::'a)", "using assms of_int_hom.hom_lead_coeff_nonzero_imp_map_poly_hom[OF q0]"], ["proof (prove)\nusing this:\n  of_int (lead_coeff p) \\<noteq> (0::'a)\n  of_int (lead_coeff q) \\<noteq> (0::'a)\n  ipoly p x = (0::'a)\n  ipoly q y = (0::'a)\n  of_int_poly q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ipoly (poly_add p q) (x + y) = (0::'a)", "by (auto intro: poly_add simp: of_int_hom.poly_add_hom[OF p0 q0])"], ["", "lemma (in comm_monoid_gcd) gcd_list_eq_0_iff[simp]: \"listgcd xs = 0 \\<longleftrightarrow> (\\<forall>x \\<in> set xs. x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (listgcd xs = (0::'a)) = (\\<forall>x\\<in>set xs. x = (0::'a))", "by (induct xs, auto)"], ["", "lemma primitive_field_poly[simp]: \"primitive (p :: 'a :: field poly) \\<longleftrightarrow> p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive p = (p \\<noteq> 0)", "by (unfold primitive_iff_some_content_dvd_1,auto simp: dvd_field_iff coeffs_def)"], ["", "lemma ipoly_poly_add_nonzero:\n  fixes x y :: \"'a :: field\"\n  assumes \"p \\<noteq> 0\" and \"q \\<noteq> 0\" and \"ipoly p x = 0\" and \"ipoly q y = 0\"\n      and \"(of_int (lead_coeff p) :: 'a) \\<noteq> 0\" and \"(of_int (lead_coeff q) :: 'a) \\<noteq> 0\"\n  shows \"poly_add p q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_add p q \\<noteq> 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_add p q \\<noteq> 0", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  ipoly p x = (0::'a)\n  ipoly q y = (0::'a)\n  of_int (lead_coeff p) \\<noteq> (0::'a)\n  of_int (lead_coeff q) \\<noteq> (0::'a)", "have \"(of_int_poly (poly_add p q) :: 'a poly) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  ipoly p x = (0::'a)\n  ipoly q y = (0::'a)\n  of_int (lead_coeff p) \\<noteq> (0::'a)\n  of_int (lead_coeff q) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. of_int_poly (poly_add p q) \\<noteq> 0", "apply (subst of_int_hom.poly_add_hom,simp,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; q \\<noteq> 0; ipoly p x = (0::'a);\n     ipoly q y = (0::'a); of_int (lead_coeff p) \\<noteq> (0::'a);\n     of_int (lead_coeff q) \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> poly_add (of_int_poly p) (of_int_poly q) \\<noteq> 0", "by (rule poly_add_nonzero, auto dest:of_int_hom.hom_lead_coeff_nonzero_imp_map_poly_hom)"], ["proof (state)\nthis:\n  of_int_poly (poly_add p q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_add p q \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  of_int_poly (poly_add p q) \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  of_int_poly (poly_add p q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_add p q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly_add p q \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represents_add:\n  assumes x: \"p represents x\" and y: \"q represents y\"\n  shows \"(poly_add p q) represents (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_add p q represents x + y", "using assms"], ["proof (prove)\nusing this:\n  p represents x\n  q represents y\n\ngoal (1 subgoal):\n 1. poly_add p q represents x + y", "by (intro representsI ipoly_poly_add ipoly_poly_add_nonzero, auto)"], ["", "subsection \\<open>Division of Algebraic Numbers\\<close>"], ["", "definition poly_x_mult_y where\n  [code del]: \"poly_x_mult_y p \\<equiv> (\\<Sum> i \\<le> degree p. monom (monom (coeff p i) i) i)\""], ["", "lemma coeff_poly_x_mult_y:\n  shows \"coeff (poly_x_mult_y p) i = monom (coeff p i) i\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_x_mult_y p) i = monom (coeff p i) i", "proof(cases \"degree p < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i\n 2. \\<not> degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i", "case i: False"], ["proof (state)\nthis:\n  \\<not> degree p < i\n\ngoal (2 subgoals):\n 1. degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i\n 2. \\<not> degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i", "have \"?l = sum (\\<lambda>j. if j = i then (monom (coeff p j) j) else 0) {..degree p}\"\n   (is \"_ = sum ?f ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_x_mult_y p) i =\n    (\\<Sum>j\\<le>degree p. if j = i then monom (coeff p j) j else 0)", "by (simp add: poly_x_mult_y_def coeff_sum)"], ["proof (state)\nthis:\n  coeff (poly_x_mult_y p) i =\n  (\\<Sum>j\\<le>degree p. if j = i then monom (coeff p j) j else 0)\n\ngoal (2 subgoals):\n 1. degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i\n 2. \\<not> degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i", "also"], ["proof (state)\nthis:\n  coeff (poly_x_mult_y p) i =\n  (\\<Sum>j\\<le>degree p. if j = i then monom (coeff p j) j else 0)\n\ngoal (2 subgoals):\n 1. degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i\n 2. \\<not> degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i", "have \"... = sum ?f {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>degree p. if j = i then monom (coeff p j) j else 0) =\n    (\\<Sum>j\\<in>{i}. if j = i then monom (coeff p j) j else 0)", "using i"], ["proof (prove)\nusing this:\n  \\<not> degree p < i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>degree p. if j = i then monom (coeff p j) j else 0) =\n    (\\<Sum>j\\<in>{i}. if j = i then monom (coeff p j) j else 0)", "by (intro sum.mono_neutral_right, auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>degree p. if j = i then monom (coeff p j) j else 0) =\n  (\\<Sum>j\\<in>{i}. if j = i then monom (coeff p j) j else 0)\n\ngoal (2 subgoals):\n 1. degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i\n 2. \\<not> degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>degree p. if j = i then monom (coeff p j) j else 0) =\n  (\\<Sum>j\\<in>{i}. if j = i then monom (coeff p j) j else 0)\n\ngoal (2 subgoals):\n 1. degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i\n 2. \\<not> degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i", "have \"... = ?f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{i}. if j = i then monom (coeff p j) j else 0) =\n    (if i = i then monom (coeff p i) i else 0)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{i}. if j = i then monom (coeff p j) j else 0) =\n  (if i = i then monom (coeff p i) i else 0)\n\ngoal (2 subgoals):\n 1. degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i\n 2. \\<not> degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{i}. if j = i then monom (coeff p j) j else 0) =\n  (if i = i then monom (coeff p i) i else 0)\n\ngoal (2 subgoals):\n 1. degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i\n 2. \\<not> degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i", "have \"... = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i = i then monom (coeff p i) i else 0) = monom (coeff p i) i", "by auto"], ["proof (state)\nthis:\n  (if i = i then monom (coeff p i) i else 0) = monom (coeff p i) i\n\ngoal (2 subgoals):\n 1. degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i\n 2. \\<not> degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i", "finally"], ["proof (chain)\npicking this:\n  coeff (poly_x_mult_y p) i = monom (coeff p i) i", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff (poly_x_mult_y p) i = monom (coeff p i) i\n\ngoal (1 subgoal):\n 1. coeff (poly_x_mult_y p) i = monom (coeff p i) i", "."], ["proof (state)\nthis:\n  coeff (poly_x_mult_y p) i = monom (coeff p i) i\n\ngoal (1 subgoal):\n 1. degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i", "case True"], ["proof (state)\nthis:\n  degree p < i\n\ngoal (1 subgoal):\n 1. degree p < i \\<Longrightarrow>\n    coeff (poly_x_mult_y p) i = monom (coeff p i) i", "then"], ["proof (chain)\npicking this:\n  degree p < i", "show ?thesis"], ["proof (prove)\nusing this:\n  degree p < i\n\ngoal (1 subgoal):\n 1. coeff (poly_x_mult_y p) i = monom (coeff p i) i", "by (auto simp: poly_x_mult_y_def coeff_eq_0 coeff_sum)"], ["proof (state)\nthis:\n  coeff (poly_x_mult_y p) i = monom (coeff p i) i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_x_mult_y_code[code]: \"poly_x_mult_y p = (let cs = coeffs p\n  in poly_of_list (map (\\<lambda> (i, ai). monom ai i) (zip [0 ..< length cs] cs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_x_mult_y p =\n    (let cs = coeffs p\n     in poly_of_list (map2 (\\<lambda>i ai. monom ai i) [0..<length cs] cs))", "unfolding Let_def poly_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_x_mult_y p =\n    Poly\n     (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)] (coeffs p))", "proof (rule poly_eqI, unfold coeff_poly_x_mult_y)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       monom (coeff p n) n =\n       coeff\n        (Poly\n          (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n            (coeffs p)))\n        n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       monom (coeff p n) n =\n       coeff\n        (Poly\n          (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n            (coeffs p)))\n        n", "let ?xs = \"zip [0..<length (coeffs p)] (coeffs p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       monom (coeff p n) n =\n       coeff\n        (Poly\n          (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n            (coeffs p)))\n        n", "let ?f = \"(\\<lambda>(i, ai). monom ai i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       monom (coeff p n) n =\n       coeff\n        (Poly\n          (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n            (coeffs p)))\n        n", "show \"monom (coeff p n) n = coeff (Poly (map ?f ?xs)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n", "proof (cases \"n < length (coeffs p)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n < length (coeffs p) \\<Longrightarrow>\n    monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n\n 2. \\<not> n < length (coeffs p) \\<Longrightarrow>\n    monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n", "case True"], ["proof (state)\nthis:\n  n < length (coeffs p)\n\ngoal (2 subgoals):\n 1. n < length (coeffs p) \\<Longrightarrow>\n    monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n\n 2. \\<not> n < length (coeffs p) \\<Longrightarrow>\n    monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n", "hence n: \"n < length (map ?f ?xs)\" and nn: \"n < length ?xs\""], ["proof (prove)\nusing this:\n  n < length (coeffs p)\n\ngoal (1 subgoal):\n 1. n < length\n         (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n           (coeffs p)) &&&\n    n < length (zip [0..<length (coeffs p)] (coeffs p))", "unfolding degree_eq_length_coeffs"], ["proof (prove)\nusing this:\n  n < length (coeffs p)\n\ngoal (1 subgoal):\n 1. n < length\n         (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n           (coeffs p)) &&&\n    n < length (zip [0..<length (coeffs p)] (coeffs p))", "by auto"], ["proof (state)\nthis:\n  n < length\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)] (coeffs p))\n  n < length (zip [0..<length (coeffs p)] (coeffs p))\n\ngoal (2 subgoals):\n 1. n < length (coeffs p) \\<Longrightarrow>\n    monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n\n 2. \\<not> n < length (coeffs p) \\<Longrightarrow>\n    monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n", "unfolding coeff_Poly nth_default_nth[OF n] nth_map[OF nn]"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (coeff p n) n =\n    (case zip [0..<length (coeffs p)] (coeffs p) ! n of\n     (i, ai) \\<Rightarrow> monom ai i)", "using True"], ["proof (prove)\nusing this:\n  n < length (coeffs p)\n\ngoal (1 subgoal):\n 1. monom (coeff p n) n =\n    (case zip [0..<length (coeffs p)] (coeffs p) ! n of\n     (i, ai) \\<Rightarrow> monom ai i)", "by (simp add: nth_coeffs_coeff)"], ["proof (state)\nthis:\n  monom (coeff p n) n =\n  coeff\n   (Poly\n     (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)] (coeffs p)))\n   n\n\ngoal (1 subgoal):\n 1. \\<not> n < length (coeffs p) \\<Longrightarrow>\n    monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < length (coeffs p) \\<Longrightarrow>\n    monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n", "case False"], ["proof (state)\nthis:\n  \\<not> n < length (coeffs p)\n\ngoal (1 subgoal):\n 1. \\<not> n < length (coeffs p) \\<Longrightarrow>\n    monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n", "hence id: \"coeff (Poly (map ?f ?xs)) n = 0\""], ["proof (prove)\nusing this:\n  \\<not> n < length (coeffs p)\n\ngoal (1 subgoal):\n 1. coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n =\n    0", "unfolding coeff_Poly"], ["proof (prove)\nusing this:\n  \\<not> n < length (coeffs p)\n\ngoal (1 subgoal):\n 1. nth_default 0\n     (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)] (coeffs p))\n     n =\n    0", "by (subst nth_default_beyond, auto)"], ["proof (state)\nthis:\n  coeff\n   (Poly\n     (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)] (coeffs p)))\n   n =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> n < length (coeffs p) \\<Longrightarrow>\n    monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n", "from False"], ["proof (chain)\npicking this:\n  \\<not> n < length (coeffs p)", "have \"n > degree p \\<or> p = 0\""], ["proof (prove)\nusing this:\n  \\<not> n < length (coeffs p)\n\ngoal (1 subgoal):\n 1. degree p < n \\<or> p = 0", "unfolding degree_eq_length_coeffs"], ["proof (prove)\nusing this:\n  \\<not> n < length (coeffs p)\n\ngoal (1 subgoal):\n 1. length (coeffs p) - 1 < n \\<or> p = 0", "by (cases n, auto)"], ["proof (state)\nthis:\n  degree p < n \\<or> p = 0\n\ngoal (1 subgoal):\n 1. \\<not> n < length (coeffs p) \\<Longrightarrow>\n    monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n", "hence \"monom (coeff p n) n = 0\""], ["proof (prove)\nusing this:\n  degree p < n \\<or> p = 0\n\ngoal (1 subgoal):\n 1. monom (coeff p n) n = 0", "using coeff_eq_0[of p n]"], ["proof (prove)\nusing this:\n  degree p < n \\<or> p = 0\n  degree p < n \\<Longrightarrow> coeff p n = (0::'a)\n\ngoal (1 subgoal):\n 1. monom (coeff p n) n = 0", "by auto"], ["proof (state)\nthis:\n  monom (coeff p n) n = 0\n\ngoal (1 subgoal):\n 1. \\<not> n < length (coeffs p) \\<Longrightarrow>\n    monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n", "thus ?thesis"], ["proof (prove)\nusing this:\n  monom (coeff p n) n = 0\n\ngoal (1 subgoal):\n 1. monom (coeff p n) n =\n    coeff\n     (Poly\n       (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)]\n         (coeffs p)))\n     n", "unfolding id"], ["proof (prove)\nusing this:\n  monom (coeff p n) n = 0\n\ngoal (1 subgoal):\n 1. monom (coeff p n) n = 0", "by simp"], ["proof (state)\nthis:\n  monom (coeff p n) n =\n  coeff\n   (Poly\n     (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)] (coeffs p)))\n   n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monom (coeff p n) n =\n  coeff\n   (Poly\n     (map2 (\\<lambda>i ai. monom ai i) [0..<length (coeffs p)] (coeffs p)))\n   n\n\ngoal:\nNo subgoals!", "qed"], ["", "definition poly_div :: \"'a :: comm_ring_1 poly \\<Rightarrow> 'a poly \\<Rightarrow> 'a poly\" where\n  \"poly_div p q = resultant (poly_x_mult_y p) (poly_lift q)\""], ["", "text \\<open>@{const poly_div} has desired roots.\\<close>"], ["", "lemma poly2_poly_x_mult_y:\n  fixes p :: \"'a :: comm_ring_1 poly\"\n  shows \"poly2 (poly_x_mult_y p) x y = poly p (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly2 (poly_x_mult_y p) x y = poly p (x * y)", "apply (subst(3) poly_as_sum_of_monoms[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly2 (poly_x_mult_y p) x y =\n    poly (\\<Sum>i\\<le>degree p. monom (coeff p i) i) (x * y)", "apply (unfold poly_x_mult_y_def hom_distribs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<le>degree p. poly2 (monom (monom (coeff p xa) xa) xa) x y) =\n    (\\<Sum>xa\\<le>degree p. poly (monom (coeff p xa) xa) (x * y))", "by (auto simp: poly2_monom poly_monom power_mult_distrib ac_simps)"], ["", "lemma poly_div:\n  fixes p q :: \"'a ::field poly\"\n  assumes q0: \"q \\<noteq> 0\" and x: \"poly p x = 0\" and y: \"poly q y = 0\" and y0: \"y \\<noteq> 0\"\n  shows \"poly (poly_div p q) (x/y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_div p q) (x / y) = (0::'a)", "proof (unfold poly_div_def, rule poly_resultant_zero[OF disjI2])"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < degree (poly_lift q)\n 2. poly2 (poly_x_mult_y p) (x / y) ?y = (0::'a)\n 3. poly2 (poly_lift q) (x / y) ?y = (0::'a)", "have \"degree q > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree q", "using poly_zero q0 y"], ["proof (prove)\nusing this:\n  poly ?p ?x = (0::?'a) \\<Longrightarrow> (?p = 0) = (degree ?p = 0)\n  q \\<noteq> 0\n  poly q y = (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < degree q", "by auto"], ["proof (state)\nthis:\n  0 < degree q\n\ngoal (3 subgoals):\n 1. 0 < degree (poly_lift q)\n 2. poly2 (poly_x_mult_y p) (x / y) ?y = (0::'a)\n 3. poly2 (poly_lift q) (x / y) ?y = (0::'a)", "thus degq: \"degree (poly_lift q) > 0\""], ["proof (prove)\nusing this:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. 0 < degree (poly_lift q)", "by auto"], ["proof (state)\nthis:\n  0 < degree (poly_lift q)\n\ngoal (2 subgoals):\n 1. poly2 (poly_x_mult_y p) (x / y) ?y = (0::'a)\n 2. poly2 (poly_lift q) (x / y) ?y = (0::'a)", "qed (insert x y y0, simp_all add: poly2_poly_x_mult_y)"], ["", "text \\<open>@{const poly_div} is nonzero.\\<close>"], ["", "interpretation poly_x_mult_y_hom: ring_hom \"poly_x_mult_y :: 'a :: {idom,ring_char_0} poly \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ring_Hom.ring_hom poly_x_mult_y", "by (unfold_locales, auto intro: poly2_ext simp: poly2_poly_x_mult_y hom_distribs)"], ["", "interpretation poly_x_mult_y_hom: inj_ring_hom \"poly_x_mult_y :: 'a :: {idom,ring_char_0} poly \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_ring_hom poly_x_mult_y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. poly_x_mult_y x = 0 \\<Longrightarrow> x = 0", "let ?h = poly_x_mult_y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. poly_x_mult_y x = 0 \\<Longrightarrow> x = 0", "fix f :: \"'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. poly_x_mult_y x = 0 \\<Longrightarrow> x = 0", "assume \"?h f = 0\""], ["proof (state)\nthis:\n  poly_x_mult_y f = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. poly_x_mult_y x = 0 \\<Longrightarrow> x = 0", "then"], ["proof (chain)\npicking this:\n  poly_x_mult_y f = 0", "have \"poly2 (?h f) x 1 = 0\" for x"], ["proof (prove)\nusing this:\n  poly_x_mult_y f = 0\n\ngoal (1 subgoal):\n 1. poly2 (poly_x_mult_y f) x (1::'a) = (0::'a)", "by simp"], ["proof (state)\nthis:\n  poly2 (poly_x_mult_y f) ?x1 (1::'a) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x. poly_x_mult_y x = 0 \\<Longrightarrow> x = 0", "from this[unfolded poly2_poly_x_mult_y]"], ["proof (chain)\npicking this:\n  poly f (?x1 * (1::'a)) = (0::'a)", "show \"f = 0\""], ["proof (prove)\nusing this:\n  poly f (?x1 * (1::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. f = 0", "by auto"], ["proof (state)\nthis:\n  f = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_poly_x_mult_y[simp]:\n  fixes p :: \"'a :: {idom, ring_char_0} poly\"\n  shows \"degree (poly_x_mult_y p) = degree p\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_x_mult_y p) = degree p", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. degree (poly_x_mult_y p) \\<le> degree p\n 2. degree p \\<le> degree (poly_x_mult_y p)", "show \"?r \\<le> ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p \\<le> degree (poly_x_mult_y p)", "by (cases \"p=0\", auto intro: le_degree simp: coeff_poly_x_mult_y)"], ["proof (state)\nthis:\n  degree p \\<le> degree (poly_x_mult_y p)\n\ngoal (1 subgoal):\n 1. degree (poly_x_mult_y p) \\<le> degree p", "show \"?l \\<le> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_x_mult_y p) \\<le> degree p", "unfolding poly_x_mult_y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Sum>i\\<le>degree p. monom (monom (coeff p i) i) i)\n    \\<le> degree p", "by (auto intro: degree_sum_le le_trans[OF degree_monom_le])"], ["proof (state)\nthis:\n  degree (poly_x_mult_y p) \\<le> degree p\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation poly_x_mult_y_hom: unit_preserving_hom \"poly_x_mult_y :: 'a :: field_char_0 poly \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_preserving_hom poly_x_mult_y", "proof(unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. is_unit (poly_x_mult_y x) \\<Longrightarrow> is_unit x", "let ?h = \"poly_x_mult_y :: 'a poly \\<Rightarrow> _\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. is_unit (poly_x_mult_y x) \\<Longrightarrow> is_unit x", "fix f :: \"'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. is_unit (poly_x_mult_y x) \\<Longrightarrow> is_unit x", "assume unit: \"?h f dvd 1\""], ["proof (state)\nthis:\n  is_unit (poly_x_mult_y f)\n\ngoal (1 subgoal):\n 1. \\<And>x. is_unit (poly_x_mult_y x) \\<Longrightarrow> is_unit x", "then"], ["proof (chain)\npicking this:\n  is_unit (poly_x_mult_y f)", "have \"degree (?h f) = 0\" and \"coeff (?h f) 0 dvd 1\""], ["proof (prove)\nusing this:\n  is_unit (poly_x_mult_y f)\n\ngoal (1 subgoal):\n 1. degree (poly_x_mult_y f) = 0 &&& is_unit (coeff (poly_x_mult_y f) 0)", "unfolding poly_dvd_1"], ["proof (prove)\nusing this:\n  degree (poly_x_mult_y f) = 0 \\<and>\n  degree (coeff (poly_x_mult_y f) 0) = 0 \\<and>\n  coeff (coeff (poly_x_mult_y f) 0) 0 dvd (1::'a)\n\ngoal (1 subgoal):\n 1. degree (poly_x_mult_y f) = 0 &&&\n    degree (coeff (poly_x_mult_y f) 0) = 0 \\<and>\n    coeff (coeff (poly_x_mult_y f) 0) 0 dvd (1::'a)", "by auto"], ["proof (state)\nthis:\n  degree (poly_x_mult_y f) = 0\n  is_unit (coeff (poly_x_mult_y f) 0)\n\ngoal (1 subgoal):\n 1. \\<And>x. is_unit (poly_x_mult_y x) \\<Longrightarrow> is_unit x", "then"], ["proof (chain)\npicking this:\n  degree (poly_x_mult_y f) = 0\n  is_unit (coeff (poly_x_mult_y f) 0)", "have deg: \"degree f = 0\""], ["proof (prove)\nusing this:\n  degree (poly_x_mult_y f) = 0\n  is_unit (coeff (poly_x_mult_y f) 0)\n\ngoal (1 subgoal):\n 1. degree f = 0", "by (auto simp add: degree_monom_eq)"], ["proof (state)\nthis:\n  degree f = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. is_unit (poly_x_mult_y x) \\<Longrightarrow> is_unit x", "with unit"], ["proof (chain)\npicking this:\n  is_unit (poly_x_mult_y f)\n  degree f = 0", "show \"f dvd 1\""], ["proof (prove)\nusing this:\n  is_unit (poly_x_mult_y f)\n  degree f = 0\n\ngoal (1 subgoal):\n 1. is_unit f", "by(cases \"f = 0\", auto)"], ["proof (state)\nthis:\n  is_unit f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas poly_y_x_o_poly_lift = o_def[of poly_y_x poly_lift, unfolded poly_y_x_poly_lift]"], ["", "lemma irreducible_dvd_degree: assumes \"(f::'a::field poly) dvd g\"\n \"irreducible g\"\n \"degree f > 0\"\n shows \"degree f = degree g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree f = degree g", "using assms"], ["proof (prove)\nusing this:\n  f dvd g\n  irreducible g\n  0 < degree f\n\ngoal (1 subgoal):\n 1. degree f = degree g", "by (metis irreducible_altdef degree_0 dvd_refl is_unit_field_poly linorder_neqE_nat poly_divides_conv0)"], ["", "lemma coprime_poly_x_mult_y_poly_lift:\n  fixes p q :: \"'a :: field_char_0 poly\"\n  assumes degp: \"degree p > 0\" and degq: \"degree q > 0\"\n    and nz: \"poly p 0 \\<noteq> 0 \\<or> poly q 0 \\<noteq> 0\" \n  shows \"coprime (poly_x_mult_y p) (poly_lift q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_mult_class.coprime (poly_x_mult_y p) (poly_lift q)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from degp"], ["proof (chain)\npicking this:\n  0 < degree p", "have p: \"\\<not> p dvd 1\""], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. \\<not> is_unit p", "by (auto simp: dvd_const)"], ["proof (state)\nthis:\n  \\<not> is_unit p\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from degp"], ["proof (chain)\npicking this:\n  0 < degree p", "have p0: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from mset_factors_exist[of p, OF p0 p]"], ["proof (chain)\npicking this:\n  \\<exists>F. mset_factors F p", "obtain F where F: \"mset_factors F p\""], ["proof (prove)\nusing this:\n  \\<exists>F. mset_factors F p\n\ngoal (1 subgoal):\n 1. (\\<And>F. mset_factors F p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mset_factors F p\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  mset_factors F p", "have pF: \"prod_mset (image_mset poly_x_mult_y F) = poly_x_mult_y p\""], ["proof (prove)\nusing this:\n  mset_factors F p\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (image_mset poly_x_mult_y F) = poly_x_mult_y p", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (image_mset poly_x_mult_y F) = poly_x_mult_y p\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from degq"], ["proof (chain)\npicking this:\n  0 < degree q", "have q: \"\\<not> is_unit q\""], ["proof (prove)\nusing this:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. \\<not> is_unit q", "by (auto simp: dvd_const)"], ["proof (state)\nthis:\n  \\<not> is_unit q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from degq"], ["proof (chain)\npicking this:\n  0 < degree q", "have q0: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from mset_factors_exist[OF q0 q]"], ["proof (chain)\npicking this:\n  \\<exists>F. mset_factors F q", "obtain G where G: \"mset_factors G q\""], ["proof (prove)\nusing this:\n  \\<exists>F. mset_factors F q\n\ngoal (1 subgoal):\n 1. (\\<And>G. mset_factors G q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mset_factors G q\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "with poly_lift_hom.hom_mset_factors"], ["proof (chain)\npicking this:\n  mset_factors ?F ?p \\<Longrightarrow>\n  mset_factors (image_mset poly_lift ?F) (poly_lift ?p)\n  mset_factors G q", "have pG: \"mset_factors (image_mset poly_lift G) (poly_lift q)\""], ["proof (prove)\nusing this:\n  mset_factors ?F ?p \\<Longrightarrow>\n  mset_factors (image_mset poly_lift ?F) (poly_lift ?p)\n  mset_factors G q\n\ngoal (1 subgoal):\n 1. mset_factors (image_mset poly_lift G) (poly_lift q)", "by auto"], ["proof (state)\nthis:\n  mset_factors (image_mset poly_lift G) (poly_lift q)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from poly_y_x_hom.hom_mset_factors[OF this]"], ["proof (chain)\npicking this:\n  mset_factors (image_mset poly_y_x (image_mset poly_lift G))\n   (poly_y_x (poly_lift q))", "have pG: \"mset_factors (image_mset coeff_lift G) [:q:]\""], ["proof (prove)\nusing this:\n  mset_factors (image_mset poly_y_x (image_mset poly_lift G))\n   (poly_y_x (poly_lift q))\n\ngoal (1 subgoal):\n 1. mset_factors {#[:a:]. a \\<in># G#} [:q:]", "by (auto simp: poly_y_x_poly_lift monom_0 image_mset.compositionality poly_y_x_o_poly_lift)"], ["proof (state)\nthis:\n  mset_factors {#[:a:]. a \\<in># G#} [:q:]\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "assume \"\\<not> coprime (poly_x_mult_y p) (poly_lift q)\""], ["proof (state)\nthis:\n  \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p) (poly_lift q)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p) (poly_lift q)", "have \"\\<not> coprime (poly_y_x (poly_x_mult_y p)) (poly_y_x (poly_lift q))\""], ["proof (prove)\nusing this:\n  \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p) (poly_lift q)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_y_x (poly_x_mult_y p))\n            (poly_y_x (poly_lift q))", "by (simp del: coprime_iff_coprime)"], ["proof (state)\nthis:\n  \\<not> comm_monoid_mult_class.coprime (poly_y_x (poly_x_mult_y p))\n          (poly_y_x (poly_lift q))\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from this[unfolded not_coprime_iff_common_factor]"], ["proof (chain)\npicking this:\n  \\<exists>r.\n     r dvd poly_y_x (poly_x_mult_y p) \\<and>\n     r dvd poly_y_x (poly_lift q) \\<and> \\<not> is_unit r", "obtain r\n  where rp: \"r dvd poly_y_x (poly_x_mult_y p)\"\n    and rq: \"r dvd poly_y_x (poly_lift q)\"\n    and rU: \"\\<not> r dvd 1\""], ["proof (prove)\nusing this:\n  \\<exists>r.\n     r dvd poly_y_x (poly_x_mult_y p) \\<and>\n     r dvd poly_y_x (poly_lift q) \\<and> \\<not> is_unit r\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>r dvd poly_y_x (poly_x_mult_y p);\n         r dvd poly_y_x (poly_lift q); \\<not> is_unit r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r dvd poly_y_x (poly_x_mult_y p)\n  r dvd poly_y_x (poly_lift q)\n  \\<not> is_unit r\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from rp p0"], ["proof (chain)\npicking this:\n  r dvd poly_y_x (poly_x_mult_y p)\n  p \\<noteq> 0", "have r0: \"r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  r dvd poly_y_x (poly_x_mult_y p)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from mset_factors_exist[OF r0 rU]"], ["proof (chain)\npicking this:\n  \\<exists>F. mset_factors F r", "obtain H where H: \"mset_factors H r\""], ["proof (prove)\nusing this:\n  \\<exists>F. mset_factors F r\n\ngoal (1 subgoal):\n 1. (\\<And>H. mset_factors H r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mset_factors H r\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  mset_factors H r", "have \"H \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  mset_factors H r\n\ngoal (1 subgoal):\n 1. H \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  H \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  H \\<noteq> {#}", "obtain h where hH: \"h \\<in># H\""], ["proof (prove)\nusing this:\n  H \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (\\<And>h. h \\<in># H \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  h \\<in># H\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "with H mset_factors_imp_dvd"], ["proof (chain)\npicking this:\n  mset_factors H r\n  \\<lbrakk>mset_factors ?F ?x; ?f \\<in># ?F\\<rbrakk>\n  \\<Longrightarrow> ?f dvd ?x\n  h \\<in># H", "have hr: \"h dvd r\" and h: \"irreducible h\""], ["proof (prove)\nusing this:\n  mset_factors H r\n  \\<lbrakk>mset_factors ?F ?x; ?f \\<in># ?F\\<rbrakk>\n  \\<Longrightarrow> ?f dvd ?x\n  h \\<in># H\n\ngoal (1 subgoal):\n 1. h dvd r &&& irreducible h", "by auto"], ["proof (state)\nthis:\n  h dvd r\n  irreducible h\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from irreducible_not_unit[OF h]"], ["proof (chain)\npicking this:\n  \\<not> is_unit h", "have hU: \"\\<not> h dvd 1\""], ["proof (prove)\nusing this:\n  \\<not> is_unit h\n\ngoal (1 subgoal):\n 1. \\<not> is_unit h", "by auto"], ["proof (state)\nthis:\n  \\<not> is_unit h\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from hr rp"], ["proof (chain)\npicking this:\n  h dvd r\n  r dvd poly_y_x (poly_x_mult_y p)", "have \"h dvd poly_y_x (poly_x_mult_y p)\""], ["proof (prove)\nusing this:\n  h dvd r\n  r dvd poly_y_x (poly_x_mult_y p)\n\ngoal (1 subgoal):\n 1. h dvd poly_y_x (poly_x_mult_y p)", "by (rule dvd_trans)"], ["proof (state)\nthis:\n  h dvd poly_y_x (poly_x_mult_y p)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "note this[folded pF,unfolded poly_y_x_hom.hom_prod_mset image_mset.compositionality]"], ["proof (state)\nthis:\n  h dvd \\<Prod>\\<^sub># (image_mset (poly_y_x \\<circ> poly_x_mult_y) F)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from prime_elem_dvd_prod_mset[OF h[folded prime_elem_iff_irreducible] this]"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>#image_mset (poly_y_x \\<circ> poly_x_mult_y) F. h dvd a", "obtain f where f: \"f \\<in># F\" and hf: \"h dvd poly_y_x (poly_x_mult_y f)\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>#image_mset (poly_y_x \\<circ> poly_x_mult_y) F. h dvd a\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in># F; h dvd poly_y_x (poly_x_mult_y f)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f \\<in># F\n  h dvd poly_y_x (poly_x_mult_y f)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "have irrF: \"irreducible f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible f", "using f F"], ["proof (prove)\nusing this:\n  f \\<in># F\n  mset_factors F p\n\ngoal (1 subgoal):\n 1. irreducible f", "by blast"], ["proof (state)\nthis:\n  irreducible f\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from dvd_trans[OF hr rq]"], ["proof (chain)\npicking this:\n  h dvd poly_y_x (poly_lift q)", "have \"h dvd [:q:]\""], ["proof (prove)\nusing this:\n  h dvd poly_y_x (poly_lift q)\n\ngoal (1 subgoal):\n 1. h dvd [:q:]", "by (simp add: poly_y_x_poly_lift monom_0)"], ["proof (state)\nthis:\n  h dvd [:q:]\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from irreducible_dvd_imp_factor[OF this h pG] q0"], ["proof (chain)\npicking this:\n  \\<exists>g\\<in>#{#[:a:]. a \\<in># G#}. h ddvd g\n  q \\<noteq> 0", "obtain g where g: \"g \\<in># G\" and gh: \"[:g:] dvd h\""], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>#{#[:a:]. a \\<in># G#}. h ddvd g\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in># G; [:g:] dvd h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g \\<in># G\n  [:g:] dvd h\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "from dvd_trans[OF gh hf]"], ["proof (chain)\npicking this:\n  [:g:] dvd poly_y_x (poly_x_mult_y f)", "have *: \"[:g:] dvd poly_y_x (poly_x_mult_y f)\""], ["proof (prove)\nusing this:\n  [:g:] dvd poly_y_x (poly_x_mult_y f)\n\ngoal (1 subgoal):\n 1. [:g:] dvd poly_y_x (poly_x_mult_y f)", "using dvd_trans"], ["proof (prove)\nusing this:\n  [:g:] dvd poly_y_x (poly_x_mult_y f)\n  \\<lbrakk>?a dvd ?b; ?b dvd ?c\\<rbrakk> \\<Longrightarrow> ?a dvd ?c\n\ngoal (1 subgoal):\n 1. [:g:] dvd poly_y_x (poly_x_mult_y f)", "by auto"], ["proof (state)\nthis:\n  [:g:] dvd poly_y_x (poly_x_mult_y f)\n\ngoal (1 subgoal):\n 1. \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p)\n            (poly_lift q) \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"poly f 0 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False\n 2. poly f (0::'a) \\<noteq> (0::'a) \\<Longrightarrow> False", "case f_0: False"], ["proof (state)\nthis:\n  poly f (0::'a) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False\n 2. poly f (0::'a) \\<noteq> (0::'a) \\<Longrightarrow> False", "from poly_hom.hom_dvd[OF *]"], ["proof (chain)\npicking this:\n  poly [:g:] ?a dvd poly (poly_y_x (poly_x_mult_y f)) ?a", "have \"g dvd poly (poly_y_x (poly_x_mult_y f)) [:0:]\""], ["proof (prove)\nusing this:\n  poly [:g:] ?a dvd poly (poly_y_x (poly_x_mult_y f)) ?a\n\ngoal (1 subgoal):\n 1. g dvd poly (poly_y_x (poly_x_mult_y f)) [:0::'a:]", "by simp"], ["proof (state)\nthis:\n  g dvd poly (poly_y_x (poly_x_mult_y f)) [:0::'a:]\n\ngoal (2 subgoals):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False\n 2. poly f (0::'a) \\<noteq> (0::'a) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  g dvd poly (poly_y_x (poly_x_mult_y f)) [:0::'a:]\n\ngoal (2 subgoals):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False\n 2. poly f (0::'a) \\<noteq> (0::'a) \\<Longrightarrow> False", "have \"... = [:poly f 0:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_y_x (poly_x_mult_y f)) [:0::'a:] = [:poly f (0::'a):]", "by (intro poly_ext, fold poly2_def, simp add: poly2_poly_x_mult_y)"], ["proof (state)\nthis:\n  poly (poly_y_x (poly_x_mult_y f)) [:0::'a:] = [:poly f (0::'a):]\n\ngoal (2 subgoals):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False\n 2. poly f (0::'a) \\<noteq> (0::'a) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  poly (poly_y_x (poly_x_mult_y f)) [:0::'a:] = [:poly f (0::'a):]\n\ngoal (2 subgoals):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False\n 2. poly f (0::'a) \\<noteq> (0::'a) \\<Longrightarrow> False", "have \"... dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit [:poly f (0::'a):]", "using f_0"], ["proof (prove)\nusing this:\n  poly f (0::'a) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. is_unit [:poly f (0::'a):]", "by auto"], ["proof (state)\nthis:\n  is_unit [:poly f (0::'a):]\n\ngoal (2 subgoals):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False\n 2. poly f (0::'a) \\<noteq> (0::'a) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  is_unit g", "have \"g dvd 1\""], ["proof (prove)\nusing this:\n  is_unit g\n\ngoal (1 subgoal):\n 1. is_unit g", "."], ["proof (state)\nthis:\n  is_unit g\n\ngoal (2 subgoals):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False\n 2. poly f (0::'a) \\<noteq> (0::'a) \\<Longrightarrow> False", "with g G"], ["proof (chain)\npicking this:\n  g \\<in># G\n  mset_factors G q\n  is_unit g", "show False"], ["proof (prove)\nusing this:\n  g \\<in># G\n  mset_factors G q\n  is_unit g\n\ngoal (1 subgoal):\n 1. False", "by (auto elim!: mset_factorsE dest!: irreducible_not_unit)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  poly f (0::'a) = (0::'a)\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "hence \"[:0,1:] dvd f\""], ["proof (prove)\nusing this:\n  poly f (0::'a) = (0::'a)\n\ngoal (1 subgoal):\n 1. [:0::'a, 1::'a:] dvd f", "by (unfold dvd_iff_poly_eq_0, simp)"], ["proof (state)\nthis:\n  [:0::'a, 1::'a:] dvd f\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "from irreducible_dvd_degree[OF this irrF]"], ["proof (chain)\npicking this:\n  0 < degree [:0::'a, 1::'a:] \\<Longrightarrow>\n  degree [:0::'a, 1::'a:] = degree f", "have \"degree f = 1\""], ["proof (prove)\nusing this:\n  0 < degree [:0::'a, 1::'a:] \\<Longrightarrow>\n  degree [:0::'a, 1::'a:] = degree f\n\ngoal (1 subgoal):\n 1. degree f = 1", "by auto"], ["proof (state)\nthis:\n  degree f = 1\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "from degree1_coeffs[OF this] True"], ["proof (chain)\npicking this:\n  \\<exists>a b. f = [:b, a:] \\<and> a \\<noteq> (0::'a)\n  poly f (0::'a) = (0::'a)", "obtain c where c: \"c \\<noteq> 0\" and f: \"f = [:0,c:]\""], ["proof (prove)\nusing this:\n  \\<exists>a b. f = [:b, a:] \\<and> a \\<noteq> (0::'a)\n  poly f (0::'a) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<noteq> (0::'a); f = [:0::'a, c:]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  f = [:0::'a, c:]\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "from g G"], ["proof (chain)\npicking this:\n  g \\<in># G\n  mset_factors G q", "have irrG: \"irreducible g\""], ["proof (prove)\nusing this:\n  g \\<in># G\n  mset_factors G q\n\ngoal (1 subgoal):\n 1. irreducible g", "by auto"], ["proof (state)\nthis:\n  irreducible g\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "from poly_hom.hom_dvd[OF *]"], ["proof (chain)\npicking this:\n  poly [:g:] ?a dvd poly (poly_y_x (poly_x_mult_y f)) ?a", "have \"g dvd poly (poly_y_x (poly_x_mult_y f)) 1\""], ["proof (prove)\nusing this:\n  poly [:g:] ?a dvd poly (poly_y_x (poly_x_mult_y f)) ?a\n\ngoal (1 subgoal):\n 1. g dvd poly (poly_y_x (poly_x_mult_y f)) 1", "by simp"], ["proof (state)\nthis:\n  g dvd poly (poly_y_x (poly_x_mult_y f)) 1\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  g dvd poly (poly_y_x (poly_x_mult_y f)) 1\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "have \"\\<dots> = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_y_x (poly_x_mult_y f)) 1 = f", "by (auto simp: f poly_x_mult_y_code Let_def c poly_y_x_pCons map_poly_monom poly_monom poly_lift_def)"], ["proof (state)\nthis:\n  poly (poly_y_x (poly_x_mult_y f)) 1 = f\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  poly (poly_y_x (poly_x_mult_y f)) 1 = f\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "have \"\\<dots> dvd [:0,1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f dvd [:0::'a, 1::'a:]", "unfolding f dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. [:0::'a, 1::'a:] = [:0::'a, c:] * k", "using c"], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>k. [:0::'a, 1::'a:] = [:0::'a, c:] * k", "by (intro exI[of _ \"[: inverse c :]\"], auto)"], ["proof (state)\nthis:\n  f dvd [:0::'a, 1::'a:]\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  g dvd [:0::'a, 1::'a:]", "have g01: \"g dvd [:0,1:]\""], ["proof (prove)\nusing this:\n  g dvd [:0::'a, 1::'a:]\n\ngoal (1 subgoal):\n 1. g dvd [:0::'a, 1::'a:]", "."], ["proof (state)\nthis:\n  g dvd [:0::'a, 1::'a:]\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "from divides_degree[OF this] irrG"], ["proof (chain)\npicking this:\n  degree g \\<le> degree [:0::'a, 1::'a:] \\<or> [:0::'a, 1::'a:] = 0\n  irreducible g", "have \"degree g = 1\""], ["proof (prove)\nusing this:\n  degree g \\<le> degree [:0::'a, 1::'a:] \\<or> [:0::'a, 1::'a:] = 0\n  irreducible g\n\ngoal (1 subgoal):\n 1. degree g = 1", "by auto"], ["proof (state)\nthis:\n  degree g = 1\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "from degree1_coeffs[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>a b. g = [:b, a:] \\<and> a \\<noteq> (0::'a)", "obtain a b where g: \"g = [:b,a:]\" and a: \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>a b. g = [:b, a:] \\<and> a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>b a.\n        \\<lbrakk>g = [:b, a:]; a \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g = [:b, a:]\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "from g01[unfolded dvd_def] g"], ["proof (chain)\npicking this:\n  \\<exists>k. [:0::'a, 1::'a:] = g * k\n  g = [:b, a:]", "obtain k where id: \"[:0,1:] = g * k\""], ["proof (prove)\nusing this:\n  \\<exists>k. [:0::'a, 1::'a:] = g * k\n  g = [:b, a:]\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        [:0::'a, 1::'a:] = g * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [:0::'a, 1::'a:] = g * k\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "from id"], ["proof (chain)\npicking this:\n  [:0::'a, 1::'a:] = g * k", "have 0: \"g \\<noteq> 0\" \"k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  [:0::'a, 1::'a:] = g * k\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0 &&& k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "from arg_cong[OF id, of degree]"], ["proof (chain)\npicking this:\n  degree [:0::'a, 1::'a:] = degree (g * k)", "have \"degree k = 0\""], ["proof (prove)\nusing this:\n  degree [:0::'a, 1::'a:] = degree (g * k)\n\ngoal (1 subgoal):\n 1. degree k = 0", "unfolding degree_mult_eq[OF 0]"], ["proof (prove)\nusing this:\n  degree [:0::'a, 1::'a:] = degree g + degree k\n\ngoal (1 subgoal):\n 1. degree k = 0", "unfolding g"], ["proof (prove)\nusing this:\n  degree [:0::'a, 1::'a:] = degree [:b, a:] + degree k\n\ngoal (1 subgoal):\n 1. degree k = 0", "using a"], ["proof (prove)\nusing this:\n  degree [:0::'a, 1::'a:] = degree [:b, a:] + degree k\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree k = 0", "by auto"], ["proof (state)\nthis:\n  degree k = 0\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "from degree0_coeffs[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>a. k = [:a:]", "obtain kk where k: \"k = [:kk:]\""], ["proof (prove)\nusing this:\n  \\<exists>a. k = [:a:]\n\ngoal (1 subgoal):\n 1. (\\<And>kk. k = [:kk:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  k = [:kk:]\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "from id[unfolded g k] a"], ["proof (chain)\npicking this:\n  [:0::'a, 1::'a:] = [:b, a:] * [:kk:]\n  a \\<noteq> (0::'a)", "have \"b = 0\""], ["proof (prove)\nusing this:\n  [:0::'a, 1::'a:] = [:b, a:] * [:kk:]\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. b = (0::'a)", "by auto"], ["proof (state)\nthis:\n  b = (0::'a)\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "hence \"poly g 0 = 0\""], ["proof (prove)\nusing this:\n  b = (0::'a)\n\ngoal (1 subgoal):\n 1. poly g (0::'a) = (0::'a)", "by (auto simp: g)"], ["proof (state)\nthis:\n  poly g (0::'a) = (0::'a)\n\ngoal (1 subgoal):\n 1. poly f (0::'a) = (0::'a) \\<Longrightarrow> False", "from True this nz \\<open>f \\<in># F\\<close> \\<open>g \\<in># G\\<close> F G"], ["proof (chain)\npicking this:\n  poly f (0::'a) = (0::'a)\n  poly g (0::'a) = (0::'a)\n  poly p (0::'a) \\<noteq> (0::'a) \\<or> poly q (0::'a) \\<noteq> (0::'a)\n  f \\<in># F\n  g \\<in># G\n  mset_factors F p\n  mset_factors G q", "show False"], ["proof (prove)\nusing this:\n  poly f (0::'a) = (0::'a)\n  poly g (0::'a) = (0::'a)\n  poly p (0::'a) \\<noteq> (0::'a) \\<or> poly q (0::'a) \\<noteq> (0::'a)\n  f \\<in># F\n  g \\<in># G\n  mset_factors F p\n  mset_factors G q\n\ngoal (1 subgoal):\n 1. False", "by (auto dest!:mset_factors_imp_dvd elim:dvdE)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_div_nonzero:\n  fixes p q :: \"'a :: field_char_0 poly\"\n  assumes p0: \"p \\<noteq> 0\" and q0: \"q \\<noteq> 0\" and x: \"poly p x = 0\" and y: \"poly q y = 0\"\n      and p_0: \"poly p 0 \\<noteq> 0 \\<or> poly q 0 \\<noteq> 0\"\n  shows \"poly_div p q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_div p q \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_div p q = 0 \\<Longrightarrow> False", "have degp: \"degree p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree p", "using le_0_eq order_degree order_root p0 x"], ["proof (prove)\nusing this:\n  (?n \\<le> 0) = (?n = 0)\n  ?p \\<noteq> 0 \\<Longrightarrow> Polynomial.order ?a ?p \\<le> degree ?p\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> Polynomial.order ?a ?p \\<noteq> 0)\n  p \\<noteq> 0\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < degree p", "by (metis gr0I)"], ["proof (state)\nthis:\n  0 < degree p\n\ngoal (1 subgoal):\n 1. poly_div p q = 0 \\<Longrightarrow> False", "have degq: \"degree q > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree q", "using le_0_eq order_degree order_root q0 y"], ["proof (prove)\nusing this:\n  (?n \\<le> 0) = (?n = 0)\n  ?p \\<noteq> 0 \\<Longrightarrow> Polynomial.order ?a ?p \\<le> degree ?p\n  (poly ?p ?a = (0::?'a)) = (?p = 0 \\<or> Polynomial.order ?a ?p \\<noteq> 0)\n  q \\<noteq> 0\n  poly q y = (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < degree q", "by (metis gr0I)"], ["proof (state)\nthis:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. poly_div p q = 0 \\<Longrightarrow> False", "assume 0: \"poly_div p q = 0\""], ["proof (state)\nthis:\n  poly_div p q = 0\n\ngoal (1 subgoal):\n 1. poly_div p q = 0 \\<Longrightarrow> False", "from resultant_zero_imp_common_factor[OF _ this[unfolded poly_div_def]] degp\n   and coprime_poly_x_mult_y_poly_lift[OF degp degq] p_0"], ["proof (chain)\npicking this:\n  0 < degree (poly_x_mult_y p) \\<or>\n  0 < degree (poly_lift q) \\<Longrightarrow>\n  \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p) (poly_lift q)\n  0 < degree p\n  poly p (0::'a) \\<noteq> (0::'a) \\<or>\n  poly q (0::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (poly_x_mult_y p) (poly_lift q)\n  poly p (0::'a) \\<noteq> (0::'a) \\<or> poly q (0::'a) \\<noteq> (0::'a)", "show False"], ["proof (prove)\nusing this:\n  0 < degree (poly_x_mult_y p) \\<or>\n  0 < degree (poly_lift q) \\<Longrightarrow>\n  \\<not> comm_monoid_mult_class.coprime (poly_x_mult_y p) (poly_lift q)\n  0 < degree p\n  poly p (0::'a) \\<noteq> (0::'a) \\<or>\n  poly q (0::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  comm_monoid_mult_class.coprime (poly_x_mult_y p) (poly_lift q)\n  poly p (0::'a) \\<noteq> (0::'a) \\<or> poly q (0::'a) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Summary for division\\<close>"], ["", "text \\<open>Now we lift the results to one that uses @{const ipoly}, by showing some homomorphism lemmas.\\<close>"], ["", "lemma (in inj_comm_ring_hom) poly_x_mult_y_hom:\n  \"poly_x_mult_y (map_poly hom p) = map_poly (map_poly hom) (poly_x_mult_y p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_x_mult_y (map_poly hom p) =\n    map_poly (map_poly hom) (poly_x_mult_y p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_x_mult_y (map_poly hom p) =\n    map_poly (map_poly hom) (poly_x_mult_y p)", "interpret mh: map_poly_inj_comm_ring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_comm_ring_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. poly_x_mult_y (map_poly hom p) =\n    map_poly (map_poly hom) (poly_x_mult_y p)", "interpret mmh: map_poly_inj_comm_ring_hom \"map_poly hom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_comm_ring_hom (map_poly hom)", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. poly_x_mult_y (map_poly hom p) =\n    map_poly (map_poly hom) (poly_x_mult_y p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_x_mult_y (map_poly hom p) =\n    map_poly (map_poly hom) (poly_x_mult_y p)", "unfolding poly_x_mult_y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree (map_poly hom p).\n        monom (monom (coeff (map_poly hom p) i) i) i) =\n    map_poly (map_poly hom)\n     (\\<Sum>i\\<le>degree p. monom (monom (coeff p i) i) i)", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  poly_x_mult_y (map_poly hom p) = map_poly (map_poly hom) (poly_x_mult_y p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in inj_comm_ring_hom) poly_div_hom:\n  \"map_poly hom (poly_div p q) = poly_div (map_poly hom p) (map_poly hom q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (poly_div p q) = poly_div (map_poly hom p) (map_poly hom q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly hom (poly_div p q) = poly_div (map_poly hom p) (map_poly hom q)", "have zero: \"\\<forall>x. hom x = 0 \\<longrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. hom x = (0::'b) \\<longrightarrow> x = (0::'a)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. hom x = (0::'b) \\<longrightarrow> x = (0::'a)\n\ngoal (1 subgoal):\n 1. map_poly hom (poly_div p q) = poly_div (map_poly hom p) (map_poly hom q)", "interpret mh: map_poly_inj_comm_ring_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_inj_comm_ring_hom hom", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly hom (poly_div p q) = poly_div (map_poly hom p) (map_poly hom q)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom (poly_div p q) = poly_div (map_poly hom p) (map_poly hom q)", "unfolding poly_div_def mh.resultant_hom[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. resultant (map_poly (map_poly hom) (poly_x_mult_y p))\n     (map_poly (map_poly hom) (poly_lift q)) =\n    resultant (poly_x_mult_y (map_poly hom p)) (poly_lift (map_poly hom q))", "by (simp add: poly_x_mult_y_hom)"], ["proof (state)\nthis:\n  map_poly hom (poly_div p q) = poly_div (map_poly hom p) (map_poly hom q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipoly_poly_div:\n  fixes x y :: \"'a :: field_char_0\"\n  assumes \"q \\<noteq> 0\" and \"ipoly p x = 0\" and \"ipoly q y = 0\" and \"y \\<noteq> 0\"\n  shows \"ipoly (poly_div p q) (x/y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (poly_div p q) (x / y) = (0::'a)", "by (unfold of_int_hom.poly_div_hom, rule poly_div, insert assms, auto)"], ["", "lemma ipoly_poly_div_nonzero:\n  fixes x y :: \"'a :: field_char_0\"\n  assumes \"p \\<noteq> 0\" and \"q \\<noteq> 0\" and \"ipoly p x = 0\" and \"ipoly q y = 0\" and \"poly p 0 \\<noteq> 0 \\<or> poly q 0 \\<noteq> 0\"\n  shows \"poly_div p q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_div p q \\<noteq> 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_div p q \\<noteq> 0", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  ipoly p x = (0::'a)\n  ipoly q y = (0::'a)\n  poly p 0 \\<noteq> 0 \\<or> poly q 0 \\<noteq> 0", "have \"(of_int_poly (poly_div p q) :: 'a poly) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  ipoly p x = (0::'a)\n  ipoly q y = (0::'a)\n  poly p 0 \\<noteq> 0 \\<or> poly q 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int_poly (poly_div p q) \\<noteq> 0", "using of_int_hom.poly_map_poly[of p]"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  ipoly p x = (0::'a)\n  ipoly q y = (0::'a)\n  poly p 0 \\<noteq> 0 \\<or> poly q 0 \\<noteq> 0\n  ipoly p (of_int ?x) = of_int (poly p ?x)\n\ngoal (1 subgoal):\n 1. of_int_poly (poly_div p q) \\<noteq> 0", "by (subst of_int_hom.poly_div_hom, subst poly_div_nonzero, auto)"], ["proof (state)\nthis:\n  of_int_poly (poly_div p q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_div p q \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  of_int_poly (poly_div p q) \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  of_int_poly (poly_div p q) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_div p q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly_div p q \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represents_div:\n  fixes x y :: \"'a :: field_char_0\"\n  assumes \"p represents x\" and \"q represents y\" and \"poly q 0 \\<noteq> 0\"\n  shows \"(poly_div p q) represents (x / y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_div p q represents x / y", "using assms"], ["proof (prove)\nusing this:\n  p represents x\n  q represents y\n  poly q 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_div p q represents x / y", "by (intro representsI ipoly_poly_div ipoly_poly_div_nonzero, auto)"], ["", "subsection \\<open>Multiplication of Algebraic Numbers\\<close>"], ["", "definition poly_mult where \"poly_mult p q \\<equiv> poly_div p (reflect_poly q)\""], ["", "lemma represents_mult:\n  assumes px: \"p represents x\" and qy: \"q represents y\" and q_0: \"poly q 0 \\<noteq> 0\" \n  shows \"(poly_mult p q) represents (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mult p q represents x * y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_mult p q represents x * y", "from q_0 qy"], ["proof (chain)\npicking this:\n  poly q 0 \\<noteq> 0\n  q represents y", "have y0: \"y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly q 0 \\<noteq> 0\n  q represents y\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. poly_mult p q represents x * y", "from represents_inverse[OF y0 qy] y0 px q_0"], ["proof (chain)\npicking this:\n  reflect_poly q represents inverse y\n  y \\<noteq> (0::'a)\n  p represents x\n  poly q 0 \\<noteq> 0", "have \"poly_mult p q represents x / (inverse y)\""], ["proof (prove)\nusing this:\n  reflect_poly q represents inverse y\n  y \\<noteq> (0::'a)\n  p represents x\n  poly q 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_mult p q represents x / inverse y", "unfolding poly_mult_def"], ["proof (prove)\nusing this:\n  reflect_poly q represents inverse y\n  y \\<noteq> (0::'a)\n  p represents x\n  poly q 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_div p (reflect_poly q) represents x / inverse y", "by (intro represents_div, auto)"], ["proof (state)\nthis:\n  poly_mult p q represents x / inverse y\n\ngoal (1 subgoal):\n 1. poly_mult p q represents x * y", "with y0"], ["proof (chain)\npicking this:\n  y \\<noteq> (0::'a)\n  poly_mult p q represents x / inverse y", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<noteq> (0::'a)\n  poly_mult p q represents x / inverse y\n\ngoal (1 subgoal):\n 1. poly_mult p q represents x * y", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  poly_mult p q represents x * y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Summary: Closure Properties of Algebraic Numbers\\<close>"], ["", "lemma algebraic_representsI: \"p represents x \\<Longrightarrow> algebraic x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p represents x \\<Longrightarrow> algebraic x", "unfolding represents_def algebraic_altdef_ipoly"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly p x = (0::'a) \\<and> p \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0", "by auto"], ["", "lemma algebraic_of_rat: \"algebraic (of_rat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (of_rat x)", "by (rule algebraic_representsI[OF poly_rat_represents_of_rat])"], ["", "lemma algebraic_uminus: \"algebraic x \\<Longrightarrow> algebraic (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> algebraic (- x)", "by (auto dest: algebraic_imp_represents_irreducible intro: algebraic_representsI represents_uminus)"], ["", "lemma algebraic_inverse: \"algebraic x \\<Longrightarrow> algebraic (inverse x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> algebraic (inverse x)", "using algebraic_of_rat[of 0]"], ["proof (prove)\nusing this:\n  algebraic (of_rat 0)\n\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> algebraic (inverse x)", "by (cases \"x = 0\", auto dest: algebraic_imp_represents_irreducible intro: algebraic_representsI represents_inverse)"], ["", "lemma algebraic_plus: \"algebraic x \\<Longrightarrow> algebraic y \\<Longrightarrow> algebraic (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>algebraic x; algebraic y\\<rbrakk>\n    \\<Longrightarrow> algebraic (x + y)", "by (auto dest!: algebraic_imp_represents_irreducible_cf_pos intro!: algebraic_representsI[OF represents_add])"], ["", "lemma algebraic_div:\n  assumes x: \"algebraic x\" and y: \"algebraic y\" shows \"algebraic (x/y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (x / y)", "proof(cases \"y = 0 \\<or> x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = (0::'a) \\<or> x = (0::'a) \\<Longrightarrow> algebraic (x / y)\n 2. \\<not> (y = (0::'a) \\<or> x = (0::'a)) \\<Longrightarrow>\n    algebraic (x / y)", "case True"], ["proof (state)\nthis:\n  y = (0::'a) \\<or> x = (0::'a)\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<or> x = (0::'a) \\<Longrightarrow> algebraic (x / y)\n 2. \\<not> (y = (0::'a) \\<or> x = (0::'a)) \\<Longrightarrow>\n    algebraic (x / y)", "then"], ["proof (chain)\npicking this:\n  y = (0::'a) \\<or> x = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  y = (0::'a) \\<or> x = (0::'a)\n\ngoal (1 subgoal):\n 1. algebraic (x / y)", "using algebraic_of_rat[of 0]"], ["proof (prove)\nusing this:\n  y = (0::'a) \\<or> x = (0::'a)\n  algebraic (of_rat 0)\n\ngoal (1 subgoal):\n 1. algebraic (x / y)", "by auto"], ["proof (state)\nthis:\n  algebraic (x / y)\n\ngoal (1 subgoal):\n 1. \\<not> (y = (0::'a) \\<or> x = (0::'a)) \\<Longrightarrow>\n    algebraic (x / y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (y = (0::'a) \\<or> x = (0::'a)) \\<Longrightarrow>\n    algebraic (x / y)", "case False"], ["proof (state)\nthis:\n  \\<not> (y = (0::'a) \\<or> x = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<not> (y = (0::'a) \\<or> x = (0::'a)) \\<Longrightarrow>\n    algebraic (x / y)", "then"], ["proof (chain)\npicking this:\n  \\<not> (y = (0::'a) \\<or> x = (0::'a))", "have x0: \"x \\<noteq> 0\" and y0: \"y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (y = (0::'a) \\<or> x = (0::'a))\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) &&& y \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n  y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> (y = (0::'a) \\<or> x = (0::'a)) \\<Longrightarrow>\n    algebraic (x / y)", "from x y"], ["proof (chain)\npicking this:\n  algebraic x\n  algebraic y", "obtain p q\n  where px: \"p represents x\" and irr: \"irreducible q\" and qy: \"q represents y\""], ["proof (prove)\nusing this:\n  algebraic x\n  algebraic y\n\ngoal (1 subgoal):\n 1. (\\<And>p q.\n        \\<lbrakk>p represents x; irreducible q; q represents y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: algebraic_imp_represents_irreducible)"], ["proof (state)\nthis:\n  p represents x\n  irreducible q\n  q represents y\n\ngoal (1 subgoal):\n 1. \\<not> (y = (0::'a) \\<or> x = (0::'a)) \\<Longrightarrow>\n    algebraic (x / y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (x / y)", "using False px represents_irr_non_0[OF irr qy]"], ["proof (prove)\nusing this:\n  \\<not> (y = (0::'a) \\<or> x = (0::'a))\n  p represents x\n  y \\<noteq> (0::'a) \\<Longrightarrow> poly q 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic (x / y)", "by (auto intro!: algebraic_representsI[OF represents_div] qy)"], ["proof (state)\nthis:\n  algebraic (x / y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraic_times: \"algebraic x \\<Longrightarrow> algebraic y \\<Longrightarrow> algebraic (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>algebraic x; algebraic y\\<rbrakk>\n    \\<Longrightarrow> algebraic (x * y)", "using algebraic_div[OF _ algebraic_inverse, of x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>algebraic x; algebraic y\\<rbrakk>\n  \\<Longrightarrow> algebraic (x / inverse y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>algebraic x; algebraic y\\<rbrakk>\n    \\<Longrightarrow> algebraic (x * y)", "by (simp add: field_simps)"], ["", "lemma algebraic_root: \"algebraic x \\<Longrightarrow> algebraic (root n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> algebraic (root n x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> algebraic (root n x)", "assume \"algebraic x\""], ["proof (state)\nthis:\n  algebraic x\n\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> algebraic (root n x)", "then"], ["proof (chain)\npicking this:\n  algebraic x", "obtain p where p: \"p represents x\""], ["proof (prove)\nusing this:\n  algebraic x\n\ngoal (1 subgoal):\n 1. (\\<And>p. p represents x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: algebraic_imp_represents_irreducible_cf_pos)"], ["proof (state)\nthis:\n  p represents x\n\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> algebraic (root n x)", "from \n    algebraic_representsI[OF represents_nth_root_neg_real[OF _ this, of n]]\n    algebraic_representsI[OF represents_nth_root_pos_real[OF _ this, of n]]\n    algebraic_of_rat[of 0]"], ["proof (chain)\npicking this:\n  \\<lbrakk>n \\<noteq> 0; x < 0\\<rbrakk>\n  \\<Longrightarrow> algebraic (root n x)\n  \\<lbrakk>n \\<noteq> 0; 0 < x\\<rbrakk>\n  \\<Longrightarrow> algebraic (root n x)\n  algebraic (of_rat 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<noteq> 0; x < 0\\<rbrakk>\n  \\<Longrightarrow> algebraic (root n x)\n  \\<lbrakk>n \\<noteq> 0; 0 < x\\<rbrakk>\n  \\<Longrightarrow> algebraic (root n x)\n  algebraic (of_rat 0)\n\ngoal (1 subgoal):\n 1. algebraic (root n x)", "by (cases \"n = 0\", force, cases \"n > 0\", force, cases \"n < 0\", auto)"], ["proof (state)\nthis:\n  algebraic (root n x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraic_nth_root: \"n \\<noteq> 0 \\<Longrightarrow> algebraic x \\<Longrightarrow> y^n = x \\<Longrightarrow> algebraic y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 0; algebraic x; y ^ n = x\\<rbrakk>\n    \\<Longrightarrow> algebraic y", "by (auto dest: algebraic_imp_represents_irreducible_cf_pos intro: algebraic_representsI represents_nth_root)"], ["", "subsection \\<open>More on algebraic integers\\<close>"], ["", "(* TODO: this is actually equal to @{term \"(-1)^(m*n)\"}, but we need a bit more theory on\n   permutations to show this with a reasonable amount of effort. *)"], ["", "definition poly_add_sign :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a :: comm_ring_1\" where\n  \"poly_add_sign m n = signof (\\<lambda>i. if i < n then m + i else if i < m + n then i - n else i)\""], ["", "lemma lead_coeff_poly_add:\n  fixes p q :: \"'a :: {idom, semiring_char_0} poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes \"lead_coeff p = 1\" \"lead_coeff q = 1\" \"m > 0\" \"n > 0\"\n  shows \"lead_coeff (poly_add p q :: 'a poly) = poly_add_sign m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "from assms"], ["proof (chain)\npicking this:\n  m \\<equiv> degree p\n  n \\<equiv> degree q\n  monic p\n  monic q\n  0 < m\n  0 < n", "have [simp]: \"p \\<noteq> 0\" \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  m \\<equiv> degree p\n  n \\<equiv> degree q\n  monic p\n  monic q\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "define M where \"M = sylvester_mat (poly_x_minus_y p) (poly_lift q)\""], ["proof (state)\nthis:\n  M = sylvester_mat (poly_x_minus_y p) (poly_lift q)\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "define \\<pi> :: \"nat \\<Rightarrow> nat\" where\n    \"\\<pi> = (\\<lambda>i. if i < n then m + i else if i < m + n then i - n else i)\""], ["proof (state)\nthis:\n  \\<pi> =\n  (\\<lambda>i. if i < n then m + i else if i < m + n then i - n else i)\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have \\<pi>: \"\\<pi> permutes {0..<m+n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> permutes {0..<m + n}", "by (rule inj_on_nat_permutes) (auto simp: \\<pi>_def inj_on_def)"], ["proof (state)\nthis:\n  \\<pi> permutes {0..<m + n}\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have nz: \"M $$ (i, \\<pi> i) \\<noteq> 0\" if \"i < m + n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. M $$ (i, \\<pi> i) \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (1 subgoal):\n 1. M $$ (i, \\<pi> i) \\<noteq> 0", "by (auto simp: M_def \\<pi>_def sylvester_index_mat m_def n_def)"], ["proof (state)\nthis:\n  ?i < m + n \\<Longrightarrow> M $$ (?i, \\<pi> ?i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "(*\n  have \"{(i,j). i \\<in> {..<m+n} \\<and> j \\<in> {..<m+n} \\<and> i < j \\<and> \\<pi> i > \\<pi> j} =\n        {..<n} \\<times> {n..<m+n}\" (is \"?lhs = ?rhs\")\n  proof (intro equalityI subsetI)\n    fix ij assume \"ij \\<in> ?lhs\"\n    thus \"ij \\<in> ?rhs\"\n      by (simp add: \\<pi>_def split: prod.splits if_splits) auto\n  qed (auto simp: \\<pi>_def)\n  hence \"inversions_on {..<m+n} \\<pi> = n * m\"\n    by (simp add: inversions_on_def)\n  hence \"signof \\<pi> = (-1)^(m*n)\"\n    using \\<pi> by (simp add: signof_def sign_def evenperm_iff_even_inversions)\n*)"], ["proof (state)\nthis:\n  ?i < m + n \\<Longrightarrow> M $$ (?i, \\<pi> ?i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have indices_eq: \"{0..<m+n} = {..<n} \\<union> (+) n ` {..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<m + n} = {..<n} \\<union> (+) n ` {..<m}", "by (auto simp flip: atLeast0LessThan)"], ["proof (state)\nthis:\n  {0..<m + n} = {..<n} \\<union> (+) n ` {..<m}\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "define f where \"f = (\\<lambda> \\<sigma>. signof \\<sigma> * (\\<Prod>i=0..<m+n. M $$ (i, \\<sigma> i)))\""], ["proof (state)\nthis:\n  f =\n  (\\<lambda>\\<sigma>.\n      signof \\<sigma> * (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)))\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have \"degree (f \\<pi>) = degree (\\<Prod>i=0..<m + n. M $$ (i, \\<pi> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f \\<pi>) = degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<pi> i))", "using nz"], ["proof (prove)\nusing this:\n  ?i < m + n \\<Longrightarrow> M $$ (?i, \\<pi> ?i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (f \\<pi>) = degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<pi> i))", "by (auto simp: f_def degree_mult_eq signof_def)"], ["proof (state)\nthis:\n  degree (f \\<pi>) = degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<pi> i))\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "also"], ["proof (state)\nthis:\n  degree (f \\<pi>) = degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<pi> i))\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have \"\\<dots> = (\\<Sum>i=0..<m+n. degree (M $$ (i, \\<pi> i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<pi> i)) =\n    (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<pi> i)))", "using nz"], ["proof (prove)\nusing this:\n  ?i < m + n \\<Longrightarrow> M $$ (?i, \\<pi> ?i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<pi> i)) =\n    (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<pi> i)))", "by (subst degree_prod_eq_sum_degree) auto"], ["proof (state)\nthis:\n  degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<pi> i)) =\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<pi> i)))\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "also"], ["proof (state)\nthis:\n  degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<pi> i)) =\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<pi> i)))\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have \"\\<dots> = (\\<Sum>i<n. degree (M $$ (i, \\<pi> i))) + (\\<Sum>i<m. degree (M $$ (n + i, \\<pi> (n + i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<pi> i))) =\n    (\\<Sum>i<n. degree (M $$ (i, \\<pi> i))) +\n    (\\<Sum>i<m. degree (M $$ (n + i, \\<pi> (n + i))))", "by (subst indices_eq, subst sum.union_disjoint) (auto simp: sum.reindex)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<pi> i))) =\n  (\\<Sum>i<n. degree (M $$ (i, \\<pi> i))) +\n  (\\<Sum>i<m. degree (M $$ (n + i, \\<pi> (n + i))))\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<pi> i))) =\n  (\\<Sum>i<n. degree (M $$ (i, \\<pi> i))) +\n  (\\<Sum>i<m. degree (M $$ (n + i, \\<pi> (n + i))))\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have \"(\\<Sum>i<n. degree (M $$ (i, \\<pi> i))) = (\\<Sum>i<n. m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. degree (M $$ (i, \\<pi> i))) = (\\<Sum>i<n. m)", "by (intro sum.cong) (auto simp: M_def sylvester_index_mat \\<pi>_def m_def n_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. degree (M $$ (i, \\<pi> i))) = (\\<Sum>i<n. m)\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. degree (M $$ (i, \\<pi> i))) = (\\<Sum>i<n. m)\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have \"(\\<Sum>i<m. degree (M $$ (n + i, \\<pi> (n + i)))) = (\\<Sum>i<m. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<m. degree (M $$ (n + i, \\<pi> (n + i)))) = (\\<Sum>i<m. 0)", "by (intro sum.cong) (auto simp: M_def sylvester_index_mat \\<pi>_def m_def n_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<m. degree (M $$ (n + i, \\<pi> (n + i)))) = (\\<Sum>i<m. 0)\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "finally"], ["proof (chain)\npicking this:\n  degree (f \\<pi>) = (\\<Sum>i<n. m) + (\\<Sum>i<m. 0)", "have deg_f1: \"degree (f \\<pi>) = m * n\""], ["proof (prove)\nusing this:\n  degree (f \\<pi>) = (\\<Sum>i<n. m) + (\\<Sum>i<m. 0)\n\ngoal (1 subgoal):\n 1. degree (f \\<pi>) = m * n", "by simp"], ["proof (state)\nthis:\n  degree (f \\<pi>) = m * n\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have deg_f2: \"degree (f \\<sigma>) < m * n\" if \"\\<sigma> permutes {0..<m+n}\" \"\\<sigma> \\<noteq> \\<pi>\" for \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f \\<sigma>) < m * n", "proof (cases \"\\<exists>i\\<in>{0..<m+n}. M $$ (i, \\<sigma> i) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0 \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n\n 2. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "case True"], ["proof (state)\nthis:\n  \\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0 \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n\n 2. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "hence *: \"(\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) = 0\""], ["proof (prove)\nusing this:\n  \\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) = 0", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) = 0\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0 \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n\n 2. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f \\<sigma>) < m * n", "using \\<open>m > 0\\<close> \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. degree (f \\<sigma>) < m * n", "by (simp add: f_def *)"], ["proof (state)\nthis:\n  degree (f \\<sigma>) < m * n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "note nz = this"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "from that"], ["proof (chain)\npicking this:\n  \\<sigma> permutes {0..<m + n}\n  \\<sigma> \\<noteq> \\<pi>", "have \\<sigma>_less: \"\\<sigma> i < m + n\" if \"i < m + n\" for i"], ["proof (prove)\nusing this:\n  \\<sigma> permutes {0..<m + n}\n  \\<sigma> \\<noteq> \\<pi>\n\ngoal (1 subgoal):\n 1. \\<sigma> i < m + n", "using permutes_in_image[OF \\<open>\\<sigma> permutes _\\<close>] that"], ["proof (prove)\nusing this:\n  \\<sigma> permutes {0..<m + n}\n  \\<sigma> \\<noteq> \\<pi>\n  (\\<sigma> ?x \\<in> {0..<m + n}) = (?x \\<in> {0..<m + n})\n  i < m + n\n\ngoal (1 subgoal):\n 1. \\<sigma> i < m + n", "by auto"], ["proof (state)\nthis:\n  ?i < m + n \\<Longrightarrow> \\<sigma> ?i < m + n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "have \"degree (f \\<sigma>) = degree (\\<Prod>i=0..<m + n. M $$ (i, \\<sigma> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f \\<sigma>) =\n    degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i))", "using nz"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)\n\ngoal (1 subgoal):\n 1. degree (f \\<sigma>) =\n    degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i))", "by (auto simp: f_def degree_mult_eq signof_def)"], ["proof (state)\nthis:\n  degree (f \\<sigma>) = degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "also"], ["proof (state)\nthis:\n  degree (f \\<sigma>) = degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "have \"\\<dots> = (\\<Sum>i=0..<m+n. degree (M $$ (i, \\<sigma> i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) =\n    (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i)))", "using nz"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)\n\ngoal (1 subgoal):\n 1. degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) =\n    (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i)))", "by (subst degree_prod_eq_sum_degree) auto"], ["proof (state)\nthis:\n  degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) =\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "also"], ["proof (state)\nthis:\n  degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) =\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "have \"\\<dots> = (\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) + (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i))) =\n    (\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) +\n    (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i))))", "by (subst indices_eq, subst sum.union_disjoint) (auto simp: sum.reindex)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i))) =\n  (\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) +\n  (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i))))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i))) =\n  (\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) +\n  (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i))))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "have \"(\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i)))) = (\\<Sum>i<m. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i)))) = (\\<Sum>i<m. 0)", "using \\<sigma>_less"], ["proof (prove)\nusing this:\n  ?i < m + n \\<Longrightarrow> \\<sigma> ?i < m + n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i)))) = (\\<Sum>i<m. 0)", "by (intro sum.cong) (auto simp: M_def sylvester_index_mat \\<pi>_def m_def n_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i)))) = (\\<Sum>i<m. 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i)))) = (\\<Sum>i<m. 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "have \"(\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) < (\\<Sum>i<n. m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) < (\\<Sum>i<n. m)", "proof (rule sum_strict_mono_ex1)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {..<n}\n 2. \\<forall>x\\<in>{..<n}. degree (M $$ (x, \\<sigma> x)) \\<le> m\n 3. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "show \"\\<forall>x\\<in>{..<n}. degree (M $$ (x, \\<sigma> x)) \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{..<n}. degree (M $$ (x, \\<sigma> x)) \\<le> m", "using \\<sigma>_less"], ["proof (prove)\nusing this:\n  ?i < m + n \\<Longrightarrow> \\<sigma> ?i < m + n\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{..<n}. degree (M $$ (x, \\<sigma> x)) \\<le> m", "by (auto simp: M_def sylvester_index_mat \\<pi>_def m_def n_def degree_coeff_poly_x_minus_y)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{..<n}. degree (M $$ (x, \\<sigma> x)) \\<le> m\n\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "have \"\\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i) \\<Longrightarrow>\n    False", "assume nex: \"~(\\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i) \\<Longrightarrow>\n    False", "have \"\\<forall>i\\<ge>m+n-k. \\<sigma> i = \\<pi> i\" if \"k \\<le> m\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i", "using that"], ["proof (prove)\nusing this:\n  k \\<le> m\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> m \\<Longrightarrow>\n    \\<forall>i\\<ge>m + n - 0. \\<sigma> i = \\<pi> i\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i;\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i", "case 0"], ["proof (state)\nthis:\n  0 \\<le> m\n\ngoal (2 subgoals):\n 1. 0 \\<le> m \\<Longrightarrow>\n    \\<forall>i\\<ge>m + n - 0. \\<sigma> i = \\<pi> i\n 2. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i;\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le> m\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<ge>m + n - 0. \\<sigma> i = \\<pi> i", "using \\<open>\\<pi> permutes _\\<close> \\<open>\\<sigma> permutes _\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> m\n  \\<pi> permutes {0..<m + n}\n  \\<sigma> permutes {0..<m + n}\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<ge>m + n - 0. \\<sigma> i = \\<pi> i", "by (fastforce simp: permutes_def)"], ["proof (state)\nthis:\n  \\<forall>i\\<ge>m + n - 0. \\<sigma> i = \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i;\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i;\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i", "case (Suc k)"], ["proof (state)\nthis:\n  k \\<le> m \\<Longrightarrow> \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i\n  Suc k \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i;\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i", "have IH: \"\\<sigma> i = \\<pi> i\" if \"i \\<ge> m+n-k\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> i = \\<pi> i", "using Suc.prems Suc.IH that"], ["proof (prove)\nusing this:\n  Suc k \\<le> m\n  k \\<le> m \\<Longrightarrow> \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i\n  m + n - k \\<le> i\n\ngoal (1 subgoal):\n 1. \\<sigma> i = \\<pi> i", "by auto"], ["proof (state)\nthis:\n  m + n - k \\<le> ?i \\<Longrightarrow> \\<sigma> ?i = \\<pi> ?i\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i;\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i", "from nz"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)", "have \"M $$ (m + n - Suc k, \\<sigma> (m + n - Suc k)) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)\n\ngoal (1 subgoal):\n 1. M $$ (m + n - Suc k, \\<sigma> (m + n - Suc k)) \\<noteq> 0", "using Suc.prems"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)\n  Suc k \\<le> m\n\ngoal (1 subgoal):\n 1. M $$ (m + n - Suc k, \\<sigma> (m + n - Suc k)) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  M $$ (m + n - Suc k, \\<sigma> (m + n - Suc k)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i;\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i", "moreover"], ["proof (state)\nthis:\n  M $$ (m + n - Suc k, \\<sigma> (m + n - Suc k)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i;\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i", "have \"m + n - Suc k \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> m + n - Suc k", "using Suc.prems"], ["proof (prove)\nusing this:\n  Suc k \\<le> m\n\ngoal (1 subgoal):\n 1. n \\<le> m + n - Suc k", "by auto"], ["proof (state)\nthis:\n  n \\<le> m + n - Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i;\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i", "ultimately"], ["proof (chain)\npicking this:\n  M $$ (m + n - Suc k, \\<sigma> (m + n - Suc k)) \\<noteq> 0\n  n \\<le> m + n - Suc k", "have \"\\<sigma> (m+n-Suc k) \\<ge> m-Suc k\""], ["proof (prove)\nusing this:\n  M $$ (m + n - Suc k, \\<sigma> (m + n - Suc k)) \\<noteq> 0\n  n \\<le> m + n - Suc k\n\ngoal (1 subgoal):\n 1. m - Suc k \\<le> \\<sigma> (m + n - Suc k)", "using assms \\<sigma>_less[of \"m+n-Suc k\"] Suc.prems"], ["proof (prove)\nusing this:\n  M $$ (m + n - Suc k, \\<sigma> (m + n - Suc k)) \\<noteq> 0\n  n \\<le> m + n - Suc k\n  m \\<equiv> degree p\n  n \\<equiv> degree q\n  monic p\n  monic q\n  0 < m\n  0 < n\n  m + n - Suc k < m + n \\<Longrightarrow> \\<sigma> (m + n - Suc k) < m + n\n  Suc k \\<le> m\n\ngoal (1 subgoal):\n 1. m - Suc k \\<le> \\<sigma> (m + n - Suc k)", "by (auto simp: M_def sylvester_index_mat m_def n_def split: if_splits)"], ["proof (state)\nthis:\n  m - Suc k \\<le> \\<sigma> (m + n - Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i;\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i", "have \"\\<not>(\\<sigma> (m+n-Suc k) > m - Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> m - Suc k < \\<sigma> (m + n - Suc k)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "assume *: \"\\<sigma> (m+n-Suc k) > m - Suc k\""], ["proof (state)\nthis:\n  m - Suc k < \\<sigma> (m + n - Suc k)\n\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "have less: \"\\<sigma> (m+n-Suc k) < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> (m + n - Suc k) < m", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> (m + n - Suc k) < m \\<Longrightarrow> False", "assume *: \"\\<not>\\<sigma> (m + n - Suc k) < m\""], ["proof (state)\nthis:\n  \\<not> \\<sigma> (m + n - Suc k) < m\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> (m + n - Suc k) < m \\<Longrightarrow> False", "define j where \"j = \\<sigma> (m + n - Suc k) - m\""], ["proof (state)\nthis:\n  j = \\<sigma> (m + n - Suc k) - m\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> (m + n - Suc k) < m \\<Longrightarrow> False", "have \"\\<sigma> (m + n - Suc k) = m + j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> (m + n - Suc k) = m + j", "using *"], ["proof (prove)\nusing this:\n  \\<not> \\<sigma> (m + n - Suc k) < m\n\ngoal (1 subgoal):\n 1. \\<sigma> (m + n - Suc k) = m + j", "by (simp add: j_def)"], ["proof (state)\nthis:\n  \\<sigma> (m + n - Suc k) = m + j\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> (m + n - Suc k) < m \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<sigma> (m + n - Suc k) = m + j\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> (m + n - Suc k) < m \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  \\<sigma> (m + n - Suc k) = m + j\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> (m + n - Suc k) < m \\<Longrightarrow> False", "have \"j < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < n", "using \\<sigma>_less[of \"m+n-Suc k\"] \\<open>m > 0\\<close> \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  m + n - Suc k < m + n \\<Longrightarrow> \\<sigma> (m + n - Suc k) < m + n\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. j < n", "by (simp add: j_def)"], ["proof (state)\nthis:\n  j < n\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> (m + n - Suc k) < m \\<Longrightarrow> False", "hence \"\\<sigma> j = \\<pi> j\""], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. \\<sigma> j = \\<pi> j", "using nex"], ["proof (prove)\nusing this:\n  j < n\n  \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i)\n\ngoal (1 subgoal):\n 1. \\<sigma> j = \\<pi> j", "by auto"], ["proof (state)\nthis:\n  \\<sigma> j = \\<pi> j\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> (m + n - Suc k) < m \\<Longrightarrow> False", "with \\<open>j < n\\<close>"], ["proof (chain)\npicking this:\n  j < n\n  \\<sigma> j = \\<pi> j", "have \"\\<sigma> j = m + j\""], ["proof (prove)\nusing this:\n  j < n\n  \\<sigma> j = \\<pi> j\n\ngoal (1 subgoal):\n 1. \\<sigma> j = m + j", "by (auto simp: \\<pi>_def)"], ["proof (state)\nthis:\n  \\<sigma> j = m + j\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> (m + n - Suc k) < m \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<sigma> j = m + j\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> (m + n - Suc k) < m \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma> (m + n - Suc k) = m + j\n  \\<sigma> j = m + j", "have \"\\<sigma> (m + n - Suc k) = \\<sigma> j\""], ["proof (prove)\nusing this:\n  \\<sigma> (m + n - Suc k) = m + j\n  \\<sigma> j = m + j\n\ngoal (1 subgoal):\n 1. \\<sigma> (m + n - Suc k) = \\<sigma> j", "by simp"], ["proof (state)\nthis:\n  \\<sigma> (m + n - Suc k) = \\<sigma> j\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> (m + n - Suc k) < m \\<Longrightarrow> False", "hence \"m + n - Suc k = j\""], ["proof (prove)\nusing this:\n  \\<sigma> (m + n - Suc k) = \\<sigma> j\n\ngoal (1 subgoal):\n 1. m + n - Suc k = j", "using permutes_inj[OF \\<open>\\<sigma> permutes _\\<close>]"], ["proof (prove)\nusing this:\n  \\<sigma> (m + n - Suc k) = \\<sigma> j\n  inj \\<sigma>\n\ngoal (1 subgoal):\n 1. m + n - Suc k = j", "unfolding inj_def"], ["proof (prove)\nusing this:\n  \\<sigma> (m + n - Suc k) = \\<sigma> j\n  \\<forall>x y. \\<sigma> x = \\<sigma> y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. m + n - Suc k = j", "by blast"], ["proof (state)\nthis:\n  m + n - Suc k = j\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> (m + n - Suc k) < m \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  m + n - Suc k = j\n\ngoal (1 subgoal):\n 1. False", "using \\<open>n \\<le> m + n - Suc k\\<close> \\<sigma>_less[of \"m+n-Suc k\"] \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  m + n - Suc k = j\n  n \\<le> m + n - Suc k\n  m + n - Suc k < m + n \\<Longrightarrow> \\<sigma> (m + n - Suc k) < m + n\n  0 < n\n\ngoal (1 subgoal):\n 1. False", "unfolding j_def"], ["proof (prove)\nusing this:\n  m + n - Suc k = \\<sigma> (m + n - Suc k) - m\n  n \\<le> m + n - Suc k\n  m + n - Suc k < m + n \\<Longrightarrow> \\<sigma> (m + n - Suc k) < m + n\n  0 < n\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<sigma> (m + n - Suc k) < m\n\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "define j where \"j = \\<sigma> (m+n-Suc k) - (m - Suc k)\""], ["proof (state)\nthis:\n  j = \\<sigma> (m + n - Suc k) - (m - Suc k)\n\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "from *"], ["proof (chain)\npicking this:\n  m - Suc k < \\<sigma> (m + n - Suc k)", "have j: \"\\<sigma> (m+n-Suc k) = m - Suc k + j\" \"j > 0\""], ["proof (prove)\nusing this:\n  m - Suc k < \\<sigma> (m + n - Suc k)\n\ngoal (1 subgoal):\n 1. \\<sigma> (m + n - Suc k) = m - Suc k + j &&& 0 < j", "by (auto simp: j_def)"], ["proof (state)\nthis:\n  \\<sigma> (m + n - Suc k) = m - Suc k + j\n  0 < j\n\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "have \"\\<sigma> (m+n-Suc k + j) = \\<pi> (m+n - Suc k + j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> (m + n - Suc k + j) = \\<pi> (m + n - Suc k + j)", "using *"], ["proof (prove)\nusing this:\n  m - Suc k < \\<sigma> (m + n - Suc k)\n\ngoal (1 subgoal):\n 1. \\<sigma> (m + n - Suc k + j) = \\<pi> (m + n - Suc k + j)", "by (intro IH) (auto simp: j_def)"], ["proof (state)\nthis:\n  \\<sigma> (m + n - Suc k + j) = \\<pi> (m + n - Suc k + j)\n\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<sigma> (m + n - Suc k + j) = \\<pi> (m + n - Suc k + j)\n\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  \\<sigma> (m + n - Suc k + j) = \\<pi> (m + n - Suc k + j)\n\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "have \"j < Suc k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < Suc k", "using less"], ["proof (prove)\nusing this:\n  \\<sigma> (m + n - Suc k) < m\n\ngoal (1 subgoal):\n 1. j < Suc k", "by (auto simp: j_def algebra_simps)"], ["proof (state)\nthis:\n  j < Suc k\n\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "hence \"m + n - Suc k + j < m + n\""], ["proof (prove)\nusing this:\n  j < Suc k\n\ngoal (1 subgoal):\n 1. m + n - Suc k + j < m + n", "using \\<open>m > 0\\<close> \\<open>n > 0\\<close> Suc.prems"], ["proof (prove)\nusing this:\n  j < Suc k\n  0 < m\n  0 < n\n  Suc k \\<le> m\n\ngoal (1 subgoal):\n 1. m + n - Suc k + j < m + n", "by linarith"], ["proof (state)\nthis:\n  m + n - Suc k + j < m + n\n\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "hence \"\\<pi> (m +n - Suc k + j) = m - Suc k + j\""], ["proof (prove)\nusing this:\n  m + n - Suc k + j < m + n\n\ngoal (1 subgoal):\n 1. \\<pi> (m + n - Suc k + j) = m - Suc k + j", "unfolding \\<pi>_def"], ["proof (prove)\nusing this:\n  m + n - Suc k + j < m + n\n\ngoal (1 subgoal):\n 1. (if m + n - Suc k + j < n then m + (m + n - Suc k + j)\n     else if m + n - Suc k + j < m + n then m + n - Suc k + j - n\n          else m + n - Suc k + j) =\n    m - Suc k + j", "using Suc.prems"], ["proof (prove)\nusing this:\n  m + n - Suc k + j < m + n\n  Suc k \\<le> m\n\ngoal (1 subgoal):\n 1. (if m + n - Suc k + j < n then m + (m + n - Suc k + j)\n     else if m + n - Suc k + j < m + n then m + n - Suc k + j - n\n          else m + n - Suc k + j) =\n    m - Suc k + j", "by (simp add: \\<pi>_def)"], ["proof (state)\nthis:\n  \\<pi> (m + n - Suc k + j) = m - Suc k + j\n\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<pi> (m + n - Suc k + j) = m - Suc k + j\n\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<sigma> (m + n - Suc k + j) = m - Suc k + j", "have \"\\<sigma> (m + n - Suc k + j) = \\<sigma> (m + n - Suc k)\""], ["proof (prove)\nusing this:\n  \\<sigma> (m + n - Suc k + j) = m - Suc k + j\n\ngoal (1 subgoal):\n 1. \\<sigma> (m + n - Suc k + j) = \\<sigma> (m + n - Suc k)", "using j"], ["proof (prove)\nusing this:\n  \\<sigma> (m + n - Suc k + j) = m - Suc k + j\n  \\<sigma> (m + n - Suc k) = m - Suc k + j\n  0 < j\n\ngoal (1 subgoal):\n 1. \\<sigma> (m + n - Suc k + j) = \\<sigma> (m + n - Suc k)", "by simp"], ["proof (state)\nthis:\n  \\<sigma> (m + n - Suc k + j) = \\<sigma> (m + n - Suc k)\n\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "hence \"m + n - Suc k + j = m + n - Suc k\""], ["proof (prove)\nusing this:\n  \\<sigma> (m + n - Suc k + j) = \\<sigma> (m + n - Suc k)\n\ngoal (1 subgoal):\n 1. m + n - Suc k + j = m + n - Suc k", "using permutes_inj[OF \\<open>\\<sigma> permutes _\\<close>]"], ["proof (prove)\nusing this:\n  \\<sigma> (m + n - Suc k + j) = \\<sigma> (m + n - Suc k)\n  inj \\<sigma>\n\ngoal (1 subgoal):\n 1. m + n - Suc k + j = m + n - Suc k", "unfolding inj_def"], ["proof (prove)\nusing this:\n  \\<sigma> (m + n - Suc k + j) = \\<sigma> (m + n - Suc k)\n  \\<forall>x y. \\<sigma> x = \\<sigma> y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. m + n - Suc k + j = m + n - Suc k", "by blast"], ["proof (state)\nthis:\n  m + n - Suc k + j = m + n - Suc k\n\ngoal (1 subgoal):\n 1. m - Suc k < \\<sigma> (m + n - Suc k) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  m + n - Suc k + j = m + n - Suc k\n\ngoal (1 subgoal):\n 1. False", "using \\<open>j > 0\\<close>"], ["proof (prove)\nusing this:\n  m + n - Suc k + j = m + n - Suc k\n  0 < j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> m - Suc k < \\<sigma> (m + n - Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i;\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i", "with \\<open>\\<sigma> (m+n-Suc k) \\<ge> m-Suc k\\<close>"], ["proof (chain)\npicking this:\n  m - Suc k \\<le> \\<sigma> (m + n - Suc k)\n  \\<not> m - Suc k < \\<sigma> (m + n - Suc k)", "have eq: \"\\<sigma> (m+n-Suc k) = m - Suc k\""], ["proof (prove)\nusing this:\n  m - Suc k \\<le> \\<sigma> (m + n - Suc k)\n  \\<not> m - Suc k < \\<sigma> (m + n - Suc k)\n\ngoal (1 subgoal):\n 1. \\<sigma> (m + n - Suc k) = m - Suc k", "by linarith"], ["proof (state)\nthis:\n  \\<sigma> (m + n - Suc k) = m - Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>k \\<le> m \\<Longrightarrow>\n                \\<forall>i\\<ge>m + n - k. \\<sigma> i = \\<pi> i;\n        Suc k \\<le> m\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. m + n - Suc k \\<le> i \\<Longrightarrow> \\<sigma> i = \\<pi> i", "fix i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. m + n - Suc k \\<le> i \\<Longrightarrow> \\<sigma> i = \\<pi> i", "assume i: \"i \\<ge> m + n - Suc k\""], ["proof (state)\nthis:\n  m + n - Suc k \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>i. m + n - Suc k \\<le> i \\<Longrightarrow> \\<sigma> i = \\<pi> i", "show \"\\<sigma> i = \\<pi> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> i = \\<pi> i", "using eq Suc.prems \\<open>m > 0\\<close> IH i"], ["proof (prove)\nusing this:\n  \\<sigma> (m + n - Suc k) = m - Suc k\n  Suc k \\<le> m\n  0 < m\n  m + n - k \\<le> ?i \\<Longrightarrow> \\<sigma> ?i = \\<pi> ?i\n  m + n - Suc k \\<le> i\n\ngoal (1 subgoal):\n 1. \\<sigma> i = \\<pi> i", "proof (cases \"i = m + n - Suc k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<sigma> (m + n - Suc k) = m - Suc k; Suc k \\<le> m; 0 < m;\n     \\<And>i. m + n - k \\<le> i \\<Longrightarrow> \\<sigma> i = \\<pi> i;\n     m + n - Suc k \\<le> i; i = m + n - Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> i = \\<pi> i\n 2. \\<lbrakk>\\<sigma> (m + n - Suc k) = m - Suc k; Suc k \\<le> m; 0 < m;\n     \\<And>i. m + n - k \\<le> i \\<Longrightarrow> \\<sigma> i = \\<pi> i;\n     m + n - Suc k \\<le> i; i \\<noteq> m + n - Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> i = \\<pi> i", "case True"], ["proof (state)\nthis:\n  i = m + n - Suc k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<sigma> (m + n - Suc k) = m - Suc k; Suc k \\<le> m; 0 < m;\n     \\<And>i. m + n - k \\<le> i \\<Longrightarrow> \\<sigma> i = \\<pi> i;\n     m + n - Suc k \\<le> i; i = m + n - Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> i = \\<pi> i\n 2. \\<lbrakk>\\<sigma> (m + n - Suc k) = m - Suc k; Suc k \\<le> m; 0 < m;\n     \\<And>i. m + n - k \\<le> i \\<Longrightarrow> \\<sigma> i = \\<pi> i;\n     m + n - Suc k \\<le> i; i \\<noteq> m + n - Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> i = \\<pi> i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = m + n - Suc k\n\ngoal (1 subgoal):\n 1. \\<sigma> i = \\<pi> i", "using eq Suc.prems \\<open>m > 0\\<close>"], ["proof (prove)\nusing this:\n  i = m + n - Suc k\n  \\<sigma> (m + n - Suc k) = m - Suc k\n  Suc k \\<le> m\n  0 < m\n\ngoal (1 subgoal):\n 1. \\<sigma> i = \\<pi> i", "by (auto simp: \\<pi>_def)"], ["proof (state)\nthis:\n  \\<sigma> i = \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<sigma> (m + n - Suc k) = m - Suc k; Suc k \\<le> m; 0 < m;\n     \\<And>i. m + n - k \\<le> i \\<Longrightarrow> \\<sigma> i = \\<pi> i;\n     m + n - Suc k \\<le> i; i \\<noteq> m + n - Suc k\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> i = \\<pi> i", "qed (use IH i in auto)"], ["proof (state)\nthis:\n  \\<sigma> i = \\<pi> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<ge>m + n - Suc k. \\<sigma> i = \\<pi> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?k \\<le> m \\<Longrightarrow>\n  \\<forall>i\\<ge>m + n - ?k. \\<sigma> i = \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i) \\<Longrightarrow>\n    False", "from this[of m] and nex"], ["proof (chain)\npicking this:\n  m \\<le> m \\<Longrightarrow> \\<forall>i\\<ge>m + n - m. \\<sigma> i = \\<pi> i\n  \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i)", "have \"\\<sigma> i = \\<pi> i\" for i"], ["proof (prove)\nusing this:\n  m \\<le> m \\<Longrightarrow> \\<forall>i\\<ge>m + n - m. \\<sigma> i = \\<pi> i\n  \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i)\n\ngoal (1 subgoal):\n 1. \\<sigma> i = \\<pi> i", "by (cases \"i \\<ge> n\") auto"], ["proof (state)\nthis:\n  \\<sigma> ?i = \\<pi> ?i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i) \\<Longrightarrow>\n    False", "hence \"\\<sigma> = \\<pi>\""], ["proof (prove)\nusing this:\n  \\<sigma> ?i = \\<pi> ?i\n\ngoal (1 subgoal):\n 1. \\<sigma> = \\<pi>", "by force"], ["proof (state)\nthis:\n  \\<sigma> = \\<pi>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<sigma> = \\<pi>\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<sigma> \\<noteq> \\<pi>\\<close>"], ["proof (prove)\nusing this:\n  \\<sigma> = \\<pi>\n  \\<sigma> \\<noteq> \\<pi>\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i\n\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "then"], ["proof (chain)\npicking this:\n  \\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i", "obtain i where i: \"i < n\" \"\\<sigma> i \\<noteq> \\<pi> i\""], ["proof (prove)\nusing this:\n  \\<exists>i<n. \\<sigma> i \\<noteq> \\<pi> i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < n; \\<sigma> i \\<noteq> \\<pi> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < n\n  \\<sigma> i \\<noteq> \\<pi> i\n\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "have \"\\<sigma> i < m + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> i < m + n", "using i"], ["proof (prove)\nusing this:\n  i < n\n  \\<sigma> i \\<noteq> \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<sigma> i < m + n", "by (intro \\<sigma>_less) auto"], ["proof (state)\nthis:\n  \\<sigma> i < m + n\n\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "moreover"], ["proof (state)\nthis:\n  \\<sigma> i < m + n\n\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "have \"\\<pi> i = m + i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> i = m + i", "using i"], ["proof (prove)\nusing this:\n  i < n\n  \\<sigma> i \\<noteq> \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<pi> i = m + i", "by (auto simp: \\<pi>_def)"], ["proof (state)\nthis:\n  \\<pi> i = m + i\n\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma> i < m + n\n  \\<pi> i = m + i", "have \"degree (M $$ (i, \\<sigma> i)) < m\""], ["proof (prove)\nusing this:\n  \\<sigma> i < m + n\n  \\<pi> i = m + i\n\ngoal (1 subgoal):\n 1. degree (M $$ (i, \\<sigma> i)) < m", "using i \\<open>m > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<sigma> i < m + n\n  \\<pi> i = m + i\n  i < n\n  \\<sigma> i \\<noteq> \\<pi> i\n  0 < m\n\ngoal (1 subgoal):\n 1. degree (M $$ (i, \\<sigma> i)) < m", "by (auto simp: M_def m_def n_def sylvester_index_mat degree_coeff_poly_x_minus_y)"], ["proof (state)\nthis:\n  degree (M $$ (i, \\<sigma> i)) < m\n\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "thus \"\\<exists>i\\<in>{..<n}. degree (M $$ (i, \\<sigma> i)) < m\""], ["proof (prove)\nusing this:\n  degree (M $$ (i, \\<sigma> i)) < m\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>{..<n}. degree (M $$ (i, \\<sigma> i)) < m", "using i"], ["proof (prove)\nusing this:\n  degree (M $$ (i, \\<sigma> i)) < m\n  i < n\n  \\<sigma> i \\<noteq> \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>{..<n}. degree (M $$ (i, \\<sigma> i)) < m", "by blast"], ["proof (state)\nthis:\n  \\<exists>i\\<in>{..<n}. degree (M $$ (i, \\<sigma> i)) < m\n\ngoal (1 subgoal):\n 1. finite {..<n}", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) < (\\<Sum>i<n. m)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x < y \\<Longrightarrow>\n      x + (\\<Sum>i<m. 0) < y + (\\<Sum>i<m. 0)) \\<Longrightarrow>\n  degree (f \\<sigma>) < (\\<Sum>i<n. m) + (\\<Sum>i<m. 0)", "show \"degree (f \\<sigma>) < m * n\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x < y \\<Longrightarrow>\n      x + (\\<Sum>i<m. 0) < y + (\\<Sum>i<m. 0)) \\<Longrightarrow>\n  degree (f \\<sigma>) < (\\<Sum>i<n. m) + (\\<Sum>i<m. 0)\n\ngoal (1 subgoal):\n 1. degree (f \\<sigma>) < m * n", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  degree (f \\<sigma>) < m * n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<sigma> permutes {0..<m + n}; ?\\<sigma> \\<noteq> \\<pi>\\<rbrakk>\n  \\<Longrightarrow> degree (f ?\\<sigma>) < m * n\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have \"lead_coeff (f \\<pi>) = poly_add_sign m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) = poly_add_sign m n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) = poly_add_sign m n", "have \"lead_coeff (f \\<pi>) = signof \\<pi> * (\\<Prod>i=0..<m + n. lead_coeff (M $$ (i, \\<pi> i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) =\n    signof \\<pi> * (\\<Prod>i = 0..<m + n. lead_coeff (M $$ (i, \\<pi> i)))", "by (simp add: f_def signof_def lead_coeff_prod)"], ["proof (state)\nthis:\n  lead_coeff (f \\<pi>) =\n  signof \\<pi> * (\\<Prod>i = 0..<m + n. lead_coeff (M $$ (i, \\<pi> i)))\n\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) = poly_add_sign m n", "also"], ["proof (state)\nthis:\n  lead_coeff (f \\<pi>) =\n  signof \\<pi> * (\\<Prod>i = 0..<m + n. lead_coeff (M $$ (i, \\<pi> i)))\n\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) = poly_add_sign m n", "have \"(\\<Prod>i=0..<m + n. lead_coeff (M $$ (i, \\<pi> i))) =\n               (\\<Prod>i<n. lead_coeff (M $$ (i, \\<pi> i))) * (\\<Prod>i<m. lead_coeff (M $$ (n + i, \\<pi> (n + i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<m + n. lead_coeff (M $$ (i, \\<pi> i))) =\n    (\\<Prod>i<n. lead_coeff (M $$ (i, \\<pi> i))) *\n    (\\<Prod>i<m. lead_coeff (M $$ (n + i, \\<pi> (n + i))))", "by (subst indices_eq, subst prod.union_disjoint) (auto simp: prod.reindex)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<m + n. lead_coeff (M $$ (i, \\<pi> i))) =\n  (\\<Prod>i<n. lead_coeff (M $$ (i, \\<pi> i))) *\n  (\\<Prod>i<m. lead_coeff (M $$ (n + i, \\<pi> (n + i))))\n\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) = poly_add_sign m n", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<m + n. lead_coeff (M $$ (i, \\<pi> i))) =\n  (\\<Prod>i<n. lead_coeff (M $$ (i, \\<pi> i))) *\n  (\\<Prod>i<m. lead_coeff (M $$ (n + i, \\<pi> (n + i))))\n\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) = poly_add_sign m n", "have \"(\\<Prod>i<n. lead_coeff (M $$ (i, \\<pi> i))) = (\\<Prod>i<n. lead_coeff p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n. lead_coeff (M $$ (i, \\<pi> i))) =\n    (\\<Prod>i<n. lead_coeff p)", "by (intro prod.cong) (auto simp: M_def m_def n_def \\<pi>_def sylvester_index_mat)"], ["proof (state)\nthis:\n  (\\<Prod>i<n. lead_coeff (M $$ (i, \\<pi> i))) = (\\<Prod>i<n. lead_coeff p)\n\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) = poly_add_sign m n", "also"], ["proof (state)\nthis:\n  (\\<Prod>i<n. lead_coeff (M $$ (i, \\<pi> i))) = (\\<Prod>i<n. lead_coeff p)\n\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) = poly_add_sign m n", "have \"(\\<Prod>i<m. lead_coeff (M $$ (n + i, \\<pi> (n + i)))) = (\\<Prod>i<m. lead_coeff q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<m. lead_coeff (M $$ (n + i, \\<pi> (n + i)))) =\n    (\\<Prod>i<m. lead_coeff q)", "by (intro prod.cong) (auto simp: M_def m_def n_def \\<pi>_def sylvester_index_mat)"], ["proof (state)\nthis:\n  (\\<Prod>i<m. lead_coeff (M $$ (n + i, \\<pi> (n + i)))) =\n  (\\<Prod>i<m. lead_coeff q)\n\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) = poly_add_sign m n", "also"], ["proof (state)\nthis:\n  (\\<Prod>i<m. lead_coeff (M $$ (n + i, \\<pi> (n + i)))) =\n  (\\<Prod>i<m. lead_coeff q)\n\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) = poly_add_sign m n", "have \"signof \\<pi> = poly_add_sign m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. signof \\<pi> = poly_add_sign m n", "by (simp add: \\<pi>_def poly_add_sign_def m_def n_def cong: if_cong)"], ["proof (state)\nthis:\n  signof \\<pi> = poly_add_sign m n\n\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) = poly_add_sign m n", "finally"], ["proof (chain)\npicking this:\n  lead_coeff (f \\<pi>) =\n  poly_add_sign m n *\n  ((\\<Prod>i<n. lead_coeff p) * (\\<Prod>i<m. lead_coeff q))", "show ?thesis"], ["proof (prove)\nusing this:\n  lead_coeff (f \\<pi>) =\n  poly_add_sign m n *\n  ((\\<Prod>i<n. lead_coeff p) * (\\<Prod>i<m. lead_coeff q))\n\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) = poly_add_sign m n", "using assms"], ["proof (prove)\nusing this:\n  lead_coeff (f \\<pi>) =\n  poly_add_sign m n *\n  ((\\<Prod>i<n. lead_coeff p) * (\\<Prod>i<m. lead_coeff q))\n  m \\<equiv> degree p\n  n \\<equiv> degree q\n  monic p\n  monic q\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. lead_coeff (f \\<pi>) = poly_add_sign m n", "by simp"], ["proof (state)\nthis:\n  lead_coeff (f \\<pi>) = poly_add_sign m n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lead_coeff (f \\<pi>) = poly_add_sign m n\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have \"lead_coeff (poly_add p q) =\n          lead_coeff (det (sylvester_mat (poly_x_minus_y p) (poly_lift q)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) =\n    lead_coeff (det (sylvester_mat (poly_x_minus_y p) (poly_lift q)))", "by (simp add: poly_add_def resultant_def)"], ["proof (state)\nthis:\n  lead_coeff (poly_add p q) =\n  lead_coeff (det (sylvester_mat (poly_x_minus_y p) (poly_lift q)))\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "also"], ["proof (state)\nthis:\n  lead_coeff (poly_add p q) =\n  lead_coeff (det (sylvester_mat (poly_x_minus_y p) (poly_lift q)))\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have \"det (sylvester_mat (poly_x_minus_y p) (poly_lift q)) =\n               (\\<Sum>\\<pi> | \\<pi> permutes {0..<m+n}. f \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det (sylvester_mat (poly_x_minus_y p) (poly_lift q)) =\n    (\\<Sum>\\<pi> | \\<pi> permutes {0..<m + n}. f \\<pi>)", "by (simp add: det_def m_def n_def M_def f_def)"], ["proof (state)\nthis:\n  det (sylvester_mat (poly_x_minus_y p) (poly_lift q)) =\n  (\\<Sum>\\<pi> | \\<pi> permutes {0..<m + n}. f \\<pi>)\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "also"], ["proof (state)\nthis:\n  det (sylvester_mat (poly_x_minus_y p) (poly_lift q)) =\n  (\\<Sum>\\<pi> | \\<pi> permutes {0..<m + n}. f \\<pi>)\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have \"{\\<pi>. \\<pi> permutes {0..<m+n}} = insert \\<pi> ({\\<pi>. \\<pi> permutes {0..<m+n}} - {\\<pi>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<pi>. \\<pi> permutes {0..<m + n}} =\n    insert \\<pi> ({\\<pi>. \\<pi> permutes {0..<m + n}} - {\\<pi>})", "using \\<pi>"], ["proof (prove)\nusing this:\n  \\<pi> permutes {0..<m + n}\n\ngoal (1 subgoal):\n 1. {\\<pi>. \\<pi> permutes {0..<m + n}} =\n    insert \\<pi> ({\\<pi>. \\<pi> permutes {0..<m + n}} - {\\<pi>})", "by auto"], ["proof (state)\nthis:\n  {\\<pi>. \\<pi> permutes {0..<m + n}} =\n  insert \\<pi> ({\\<pi>. \\<pi> permutes {0..<m + n}} - {\\<pi>})\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "also"], ["proof (state)\nthis:\n  {\\<pi>. \\<pi> permutes {0..<m + n}} =\n  insert \\<pi> ({\\<pi>. \\<pi> permutes {0..<m + n}} - {\\<pi>})\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have \"(\\<Sum>\\<sigma>\\<in>\\<dots>. f \\<sigma>) = (\\<Sum>\\<sigma>\\<in>{\\<sigma>. \\<sigma> permutes {0..<m+n}}-{\\<pi>}. f \\<sigma>) + f \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (insert \\<pi> ({\\<pi>. \\<pi> permutes {0..<m + n}} - {\\<pi>})) =\n    sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}) + f \\<pi>", "by (subst sum.insert) (auto simp: finite_permutations)"], ["proof (state)\nthis:\n  sum f (insert \\<pi> ({\\<pi>. \\<pi> permutes {0..<m + n}} - {\\<pi>})) =\n  sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}) + f \\<pi>\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "also"], ["proof (state)\nthis:\n  sum f (insert \\<pi> ({\\<pi>. \\<pi> permutes {0..<m + n}} - {\\<pi>})) =\n  sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}) + f \\<pi>\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "have \"lead_coeff \\<dots> = lead_coeff (f \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff\n     (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}) +\n      f \\<pi>) =\n    lead_coeff (f \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_coeff\n     (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}) +\n      f \\<pi>) =\n    lead_coeff (f \\<pi>)", "have \"degree (\\<Sum>\\<sigma>\\<in>{\\<sigma>. \\<sigma> permutes {0..<m+n}}-{\\<pi>}. f \\<sigma>) < m * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}))\n    < m * n", "using assms"], ["proof (prove)\nusing this:\n  m \\<equiv> degree p\n  n \\<equiv> degree q\n  monic p\n  monic q\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. degree (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}))\n    < m * n", "by (intro degree_sum_smaller deg_f2) (auto simp: m_def n_def finite_permutations)"], ["proof (state)\nthis:\n  degree (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}))\n  < m * n\n\ngoal (1 subgoal):\n 1. lead_coeff\n     (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}) +\n      f \\<pi>) =\n    lead_coeff (f \\<pi>)", "with deg_f1"], ["proof (chain)\npicking this:\n  degree (f \\<pi>) = m * n\n  degree (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}))\n  < m * n", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (f \\<pi>) = m * n\n  degree (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}))\n  < m * n\n\ngoal (1 subgoal):\n 1. lead_coeff\n     (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}) +\n      f \\<pi>) =\n    lead_coeff (f \\<pi>)", "by (subst lead_coeff_add_le) auto"], ["proof (state)\nthis:\n  lead_coeff\n   (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}) + f \\<pi>) =\n  lead_coeff (f \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lead_coeff\n   (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {\\<pi>}) + f \\<pi>) =\n  lead_coeff (f \\<pi>)\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "finally"], ["proof (chain)\npicking this:\n  lead_coeff (poly_add p q) = lead_coeff (f \\<pi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  lead_coeff (poly_add p q) = lead_coeff (f \\<pi>)\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "using \\<open>lead_coeff (f \\<pi>) = _\\<close>"], ["proof (prove)\nusing this:\n  lead_coeff (poly_add p q) = lead_coeff (f \\<pi>)\n  lead_coeff (f \\<pi>) = poly_add_sign m n\n\ngoal (1 subgoal):\n 1. lead_coeff (poly_add p q) = poly_add_sign m n", "by simp"], ["proof (state)\nthis:\n  lead_coeff (poly_add p q) = poly_add_sign m n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lead_coeff_poly_mult:\n  fixes p q :: \"'a :: {idom, ring_char_0} poly\"\n  defines \"m \\<equiv> degree p\" and \"n \\<equiv> degree q\"\n  assumes \"lead_coeff p = 1\" \"lead_coeff q = 1\" \"m > 0\" \"n > 0\"\n  assumes \"coeff q 0 \\<noteq> 0\"\n  shows \"lead_coeff (poly_mult p q :: 'a poly) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "from assms"], ["proof (chain)\npicking this:\n  m \\<equiv> degree p\n  n \\<equiv> degree q\n  monic p\n  monic q\n  0 < m\n  0 < n\n  coeff q 0 \\<noteq> (0::'a)", "have [simp]: \"p \\<noteq> 0\" \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  m \\<equiv> degree p\n  n \\<equiv> degree q\n  monic p\n  monic q\n  0 < m\n  0 < n\n  coeff q 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have [simp]: \"degree (reflect_poly q) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (reflect_poly q) = n", "using assms"], ["proof (prove)\nusing this:\n  m \\<equiv> degree p\n  n \\<equiv> degree q\n  monic p\n  monic q\n  0 < m\n  0 < n\n  coeff q 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree (reflect_poly q) = n", "by (subst degree_reflect_poly_eq) (auto simp: n_def)"], ["proof (state)\nthis:\n  degree (reflect_poly q) = n\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "define M where \"M = sylvester_mat (poly_x_mult_y p) (poly_lift (reflect_poly q))\""], ["proof (state)\nthis:\n  M = sylvester_mat (poly_x_mult_y p) (poly_lift (reflect_poly q))\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have nz: \"M $$ (i, i) \\<noteq> 0\" if \"i < m + n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. M $$ (i, i) \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  i < m + n\n\ngoal (1 subgoal):\n 1. M $$ (i, i) \\<noteq> 0", "by (auto simp: M_def sylvester_index_mat m_def n_def coeff_poly_x_mult_y)"], ["proof (state)\nthis:\n  ?i < m + n \\<Longrightarrow> M $$ (?i, ?i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have indices_eq: \"{0..<m+n} = {..<n} \\<union> (+) n ` {..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..<m + n} = {..<n} \\<union> (+) n ` {..<m}", "by (auto simp flip: atLeast0LessThan)"], ["proof (state)\nthis:\n  {0..<m + n} = {..<n} \\<union> (+) n ` {..<m}\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "define f where \"f = (\\<lambda> \\<sigma>. signof \\<sigma> * (\\<Prod>i=0..<m+n. M $$ (i, \\<sigma> i)))\""], ["proof (state)\nthis:\n  f =\n  (\\<lambda>\\<sigma>.\n      signof \\<sigma> * (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)))\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have \"degree (f id) = degree (\\<Prod>i=0..<m + n. M $$ (i, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f id) = degree (\\<Prod>i = 0..<m + n. M $$ (i, i))", "using nz"], ["proof (prove)\nusing this:\n  ?i < m + n \\<Longrightarrow> M $$ (?i, ?i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (f id) = degree (\\<Prod>i = 0..<m + n. M $$ (i, i))", "by (auto simp: f_def degree_mult_eq signof_def)"], ["proof (state)\nthis:\n  degree (f id) = degree (\\<Prod>i = 0..<m + n. M $$ (i, i))\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "also"], ["proof (state)\nthis:\n  degree (f id) = degree (\\<Prod>i = 0..<m + n. M $$ (i, i))\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have \"\\<dots> = (\\<Sum>i=0..<m+n. degree (M $$ (i, i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>i = 0..<m + n. M $$ (i, i)) =\n    (\\<Sum>i = 0..<m + n. degree (M $$ (i, i)))", "using nz"], ["proof (prove)\nusing this:\n  ?i < m + n \\<Longrightarrow> M $$ (?i, ?i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (\\<Prod>i = 0..<m + n. M $$ (i, i)) =\n    (\\<Sum>i = 0..<m + n. degree (M $$ (i, i)))", "by (subst degree_prod_eq_sum_degree) auto"], ["proof (state)\nthis:\n  degree (\\<Prod>i = 0..<m + n. M $$ (i, i)) =\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, i)))\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "also"], ["proof (state)\nthis:\n  degree (\\<Prod>i = 0..<m + n. M $$ (i, i)) =\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, i)))\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have \"\\<dots> = (\\<Sum>i<n. degree (M $$ (i, i))) + (\\<Sum>i<m. degree (M $$ (n + i, n + i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<m + n. degree (M $$ (i, i))) =\n    (\\<Sum>i<n. degree (M $$ (i, i))) +\n    (\\<Sum>i<m. degree (M $$ (n + i, n + i)))", "by (subst indices_eq, subst sum.union_disjoint) (auto simp: sum.reindex)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, i))) =\n  (\\<Sum>i<n. degree (M $$ (i, i))) +\n  (\\<Sum>i<m. degree (M $$ (n + i, n + i)))\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, i))) =\n  (\\<Sum>i<n. degree (M $$ (i, i))) +\n  (\\<Sum>i<m. degree (M $$ (n + i, n + i)))\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have \"(\\<Sum>i<n. degree (M $$ (i, i))) = (\\<Sum>i<n. m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. degree (M $$ (i, i))) = (\\<Sum>i<n. m)", "by (intro sum.cong)\n       (auto simp: M_def sylvester_index_mat m_def n_def coeff_poly_x_mult_y degree_monom_eq)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. degree (M $$ (i, i))) = (\\<Sum>i<n. m)\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. degree (M $$ (i, i))) = (\\<Sum>i<n. m)\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have \"(\\<Sum>i<m. degree (M $$ (n + i, n + i))) = (\\<Sum>i<m. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<m. degree (M $$ (n + i, n + i))) = (\\<Sum>i<m. 0)", "by (intro sum.cong) (auto simp: M_def sylvester_index_mat m_def n_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<m. degree (M $$ (n + i, n + i))) = (\\<Sum>i<m. 0)\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "finally"], ["proof (chain)\npicking this:\n  degree (f id) = (\\<Sum>i<n. m) + (\\<Sum>i<m. 0)", "have deg_f1: \"degree (f id) = m * n\""], ["proof (prove)\nusing this:\n  degree (f id) = (\\<Sum>i<n. m) + (\\<Sum>i<m. 0)\n\ngoal (1 subgoal):\n 1. degree (f id) = m * n", "by (simp add: mult_ac id_def)"], ["proof (state)\nthis:\n  degree (f id) = m * n\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have deg_f2: \"degree (f \\<sigma>) < m * n\" if \"\\<sigma> permutes {0..<m+n}\" \"\\<sigma> \\<noteq> id\" for \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f \\<sigma>) < m * n", "proof (cases \"\\<exists>i\\<in>{0..<m+n}. M $$ (i, \\<sigma> i) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0 \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n\n 2. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "case True"], ["proof (state)\nthis:\n  \\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0 \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n\n 2. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "hence *: \"(\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) = 0\""], ["proof (prove)\nusing this:\n  \\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) = 0", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) = 0\n\ngoal (2 subgoals):\n 1. \\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0 \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n\n 2. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f \\<sigma>) < m * n", "using \\<open>m > 0\\<close> \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < m\n  0 < n\n\ngoal (1 subgoal):\n 1. degree (f \\<sigma>) < m * n", "by (simp add: f_def *)"], ["proof (state)\nthis:\n  degree (f \\<sigma>) < m * n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "note nz = this"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "from that"], ["proof (chain)\npicking this:\n  \\<sigma> permutes {0..<m + n}\n  \\<sigma> \\<noteq> id", "have \\<sigma>_less: \"\\<sigma> i < m + n\" if \"i < m + n\" for i"], ["proof (prove)\nusing this:\n  \\<sigma> permutes {0..<m + n}\n  \\<sigma> \\<noteq> id\n\ngoal (1 subgoal):\n 1. \\<sigma> i < m + n", "using permutes_in_image[OF \\<open>\\<sigma> permutes _\\<close>] that"], ["proof (prove)\nusing this:\n  \\<sigma> permutes {0..<m + n}\n  \\<sigma> \\<noteq> id\n  (\\<sigma> ?x \\<in> {0..<m + n}) = (?x \\<in> {0..<m + n})\n  i < m + n\n\ngoal (1 subgoal):\n 1. \\<sigma> i < m + n", "by auto"], ["proof (state)\nthis:\n  ?i < m + n \\<Longrightarrow> \\<sigma> ?i < m + n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "have \"degree (f \\<sigma>) = degree (\\<Prod>i=0..<m + n. M $$ (i, \\<sigma> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (f \\<sigma>) =\n    degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i))", "using nz"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)\n\ngoal (1 subgoal):\n 1. degree (f \\<sigma>) =\n    degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i))", "by (auto simp: f_def degree_mult_eq signof_def)"], ["proof (state)\nthis:\n  degree (f \\<sigma>) = degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "also"], ["proof (state)\nthis:\n  degree (f \\<sigma>) = degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "have \"\\<dots> = (\\<Sum>i=0..<m+n. degree (M $$ (i, \\<sigma> i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) =\n    (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i)))", "using nz"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)\n\ngoal (1 subgoal):\n 1. degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) =\n    (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i)))", "by (subst degree_prod_eq_sum_degree) auto"], ["proof (state)\nthis:\n  degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) =\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "also"], ["proof (state)\nthis:\n  degree (\\<Prod>i = 0..<m + n. M $$ (i, \\<sigma> i)) =\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "have \"\\<dots> = (\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) + (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i))) =\n    (\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) +\n    (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i))))", "by (subst indices_eq, subst sum.union_disjoint) (auto simp: sum.reindex)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i))) =\n  (\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) +\n  (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i))))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<m + n. degree (M $$ (i, \\<sigma> i))) =\n  (\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) +\n  (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i))))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "have \"(\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i)))) = (\\<Sum>i<m. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i)))) = (\\<Sum>i<m. 0)", "using \\<sigma>_less"], ["proof (prove)\nusing this:\n  ?i < m + n \\<Longrightarrow> \\<sigma> ?i < m + n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i)))) = (\\<Sum>i<m. 0)", "by (intro sum.cong) (auto simp: M_def sylvester_index_mat m_def n_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i)))) = (\\<Sum>i<m. 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<m. degree (M $$ (n + i, \\<sigma> (n + i)))) = (\\<Sum>i<m. 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "have \"(\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) < (\\<Sum>i<n. m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) < (\\<Sum>i<n. m)", "proof (rule sum_strict_mono_ex1)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {..<n}\n 2. \\<forall>x\\<in>{..<n}. degree (M $$ (x, \\<sigma> x)) \\<le> m\n 3. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "show \"\\<forall>x\\<in>{..<n}. degree (M $$ (x, \\<sigma> x)) \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{..<n}. degree (M $$ (x, \\<sigma> x)) \\<le> m", "using \\<sigma>_less"], ["proof (prove)\nusing this:\n  ?i < m + n \\<Longrightarrow> \\<sigma> ?i < m + n\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{..<n}. degree (M $$ (x, \\<sigma> x)) \\<le> m", "by (auto simp: M_def sylvester_index_mat m_def n_def degree_coeff_poly_x_minus_y coeff_poly_x_mult_y\n                 intro: order.trans[OF degree_monom_le])"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{..<n}. degree (M $$ (x, \\<sigma> x)) \\<le> m\n\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "have \"\\<exists>i<n. \\<sigma> i \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<n. \\<sigma> i \\<noteq> i", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> i) \\<Longrightarrow> False", "assume nex: \"\\<not>(\\<exists>i<n. \\<sigma> i \\<noteq> i)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> i) \\<Longrightarrow> False", "have \"\\<sigma> i = i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> i = i", "using that"], ["proof (prove)\nusing this:\n  \\<sigma> permutes {0..<m + n}\n  \\<sigma> \\<noteq> id\n\ngoal (1 subgoal):\n 1. \\<sigma> i = i", "proof (induction i rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; \\<sigma> permutes {0..<m + n};\n                    \\<sigma> \\<noteq> id\\<rbrakk>\n                   \\<Longrightarrow> \\<sigma> y = y;\n        \\<sigma> permutes {0..<m + n}; \\<sigma> \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> x = x", "case (less i)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < i; \\<sigma> permutes {0..<m + n};\n   \\<sigma> \\<noteq> id\\<rbrakk>\n  \\<Longrightarrow> \\<sigma> ?y = ?y\n  \\<sigma> permutes {0..<m + n}\n  \\<sigma> \\<noteq> id\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; \\<sigma> permutes {0..<m + n};\n                    \\<sigma> \\<noteq> id\\<rbrakk>\n                   \\<Longrightarrow> \\<sigma> y = y;\n        \\<sigma> permutes {0..<m + n}; \\<sigma> \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> x = x", "consider \"i < n\" | \"i \\<in> {n..<m+n}\" | \"i \\<ge> m + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n \\<Longrightarrow> thesis;\n     i \\<in> {n..<m + n} \\<Longrightarrow> thesis;\n     m + n \\<le> i \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>i < n \\<Longrightarrow> ?thesis;\n   i \\<in> {n..<m + n} \\<Longrightarrow> ?thesis;\n   m + n \\<le> i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; \\<sigma> permutes {0..<m + n};\n                    \\<sigma> \\<noteq> id\\<rbrakk>\n                   \\<Longrightarrow> \\<sigma> y = y;\n        \\<sigma> permutes {0..<m + n}; \\<sigma> \\<noteq> id\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> x = x", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>i < n \\<Longrightarrow> ?thesis;\n   i \\<in> {n..<m + n} \\<Longrightarrow> ?thesis;\n   m + n \\<le> i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<sigma> i = i", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. i < n \\<Longrightarrow> \\<sigma> i = i\n 2. i \\<in> {n..<m + n} \\<Longrightarrow> \\<sigma> i = i\n 3. m + n \\<le> i \\<Longrightarrow> \\<sigma> i = i", "assume \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (3 subgoals):\n 1. i < n \\<Longrightarrow> \\<sigma> i = i\n 2. i \\<in> {n..<m + n} \\<Longrightarrow> \\<sigma> i = i\n 3. m + n \\<le> i \\<Longrightarrow> \\<sigma> i = i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<sigma> i = i", "using nex"], ["proof (prove)\nusing this:\n  i < n\n  \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> i)\n\ngoal (1 subgoal):\n 1. \\<sigma> i = i", "by auto"], ["proof (state)\nthis:\n  \\<sigma> i = i\n\ngoal (2 subgoals):\n 1. i \\<in> {n..<m + n} \\<Longrightarrow> \\<sigma> i = i\n 2. m + n \\<le> i \\<Longrightarrow> \\<sigma> i = i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> {n..<m + n} \\<Longrightarrow> \\<sigma> i = i\n 2. m + n \\<le> i \\<Longrightarrow> \\<sigma> i = i", "assume \"i \\<ge> m + n\""], ["proof (state)\nthis:\n  m + n \\<le> i\n\ngoal (2 subgoals):\n 1. i \\<in> {n..<m + n} \\<Longrightarrow> \\<sigma> i = i\n 2. m + n \\<le> i \\<Longrightarrow> \\<sigma> i = i", "thus ?thesis"], ["proof (prove)\nusing this:\n  m + n \\<le> i\n\ngoal (1 subgoal):\n 1. \\<sigma> i = i", "using \\<open>\\<sigma> permutes _\\<close>"], ["proof (prove)\nusing this:\n  m + n \\<le> i\n  \\<sigma> permutes {0..<m + n}\n\ngoal (1 subgoal):\n 1. \\<sigma> i = i", "by (auto simp: permutes_def)"], ["proof (state)\nthis:\n  \\<sigma> i = i\n\ngoal (1 subgoal):\n 1. i \\<in> {n..<m + n} \\<Longrightarrow> \\<sigma> i = i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> {n..<m + n} \\<Longrightarrow> \\<sigma> i = i", "assume i: \"i \\<in> {n..<m+n}\""], ["proof (state)\nthis:\n  i \\<in> {n..<m + n}\n\ngoal (1 subgoal):\n 1. i \\<in> {n..<m + n} \\<Longrightarrow> \\<sigma> i = i", "have IH: \"\\<sigma> j = j\" if \"j < i\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> j = j", "using that less.prems"], ["proof (prove)\nusing this:\n  j < i\n  \\<sigma> permutes {0..<m + n}\n  \\<sigma> \\<noteq> id\n\ngoal (1 subgoal):\n 1. \\<sigma> j = j", "by (intro less.IH) auto"], ["proof (state)\nthis:\n  ?j < i \\<Longrightarrow> \\<sigma> ?j = ?j\n\ngoal (1 subgoal):\n 1. i \\<in> {n..<m + n} \\<Longrightarrow> \\<sigma> i = i", "from nz"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)", "have \"M $$ (i, \\<sigma> i) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)\n\ngoal (1 subgoal):\n 1. M $$ (i, \\<sigma> i) \\<noteq> 0", "using i"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<in>{0..<m + n}. M $$ (i, \\<sigma> i) = 0)\n  i \\<in> {n..<m + n}\n\ngoal (1 subgoal):\n 1. M $$ (i, \\<sigma> i) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  M $$ (i, \\<sigma> i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<in> {n..<m + n} \\<Longrightarrow> \\<sigma> i = i", "hence \"\\<sigma> i \\<le> i\""], ["proof (prove)\nusing this:\n  M $$ (i, \\<sigma> i) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<sigma> i \\<le> i", "using i \\<sigma>_less[of i]"], ["proof (prove)\nusing this:\n  M $$ (i, \\<sigma> i) \\<noteq> 0\n  i \\<in> {n..<m + n}\n  i < m + n \\<Longrightarrow> \\<sigma> i < m + n\n\ngoal (1 subgoal):\n 1. \\<sigma> i \\<le> i", "by (auto simp: M_def sylvester_index_mat m_def n_def)"], ["proof (state)\nthis:\n  \\<sigma> i \\<le> i\n\ngoal (1 subgoal):\n 1. i \\<in> {n..<m + n} \\<Longrightarrow> \\<sigma> i = i", "moreover"], ["proof (state)\nthis:\n  \\<sigma> i \\<le> i\n\ngoal (1 subgoal):\n 1. i \\<in> {n..<m + n} \\<Longrightarrow> \\<sigma> i = i", "have \"\\<sigma> i \\<ge> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> \\<sigma> i", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> \\<sigma> i \\<Longrightarrow> False", "assume *: \"\\<not>\\<sigma> i \\<ge> i\""], ["proof (state)\nthis:\n  \\<not> i \\<le> \\<sigma> i\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> \\<sigma> i \\<Longrightarrow> False", "from *"], ["proof (chain)\npicking this:\n  \\<not> i \\<le> \\<sigma> i", "have \"\\<sigma> (\\<sigma> i) = \\<sigma> i\""], ["proof (prove)\nusing this:\n  \\<not> i \\<le> \\<sigma> i\n\ngoal (1 subgoal):\n 1. \\<sigma> (\\<sigma> i) = \\<sigma> i", "by (subst IH) auto"], ["proof (state)\nthis:\n  \\<sigma> (\\<sigma> i) = \\<sigma> i\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> \\<sigma> i \\<Longrightarrow> False", "hence \"\\<sigma> i = i\""], ["proof (prove)\nusing this:\n  \\<sigma> (\\<sigma> i) = \\<sigma> i\n\ngoal (1 subgoal):\n 1. \\<sigma> i = i", "using permutes_inj[OF \\<open>\\<sigma> permutes _\\<close>]"], ["proof (prove)\nusing this:\n  \\<sigma> (\\<sigma> i) = \\<sigma> i\n  inj \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma> i = i", "unfolding inj_def"], ["proof (prove)\nusing this:\n  \\<sigma> (\\<sigma> i) = \\<sigma> i\n  \\<forall>x y. \\<sigma> x = \\<sigma> y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<sigma> i = i", "by blast"], ["proof (state)\nthis:\n  \\<sigma> i = i\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> \\<sigma> i \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  \\<not> i \\<le> \\<sigma> i\n  \\<sigma> i = i", "show False"], ["proof (prove)\nusing this:\n  \\<not> i \\<le> \\<sigma> i\n  \\<sigma> i = i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<le> \\<sigma> i\n\ngoal (1 subgoal):\n 1. i \\<in> {n..<m + n} \\<Longrightarrow> \\<sigma> i = i", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma> i \\<le> i\n  i \\<le> \\<sigma> i", "show ?case"], ["proof (prove)\nusing this:\n  \\<sigma> i \\<le> i\n  i \\<le> \\<sigma> i\n\ngoal (1 subgoal):\n 1. \\<sigma> i = i", "by simp"], ["proof (state)\nthis:\n  \\<sigma> i = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<sigma> i = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<sigma> ?i = ?i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> i) \\<Longrightarrow> False", "hence \"\\<sigma> = id\""], ["proof (prove)\nusing this:\n  \\<sigma> ?i = ?i\n\ngoal (1 subgoal):\n 1. \\<sigma> = id", "by force"], ["proof (state)\nthis:\n  \\<sigma> = id\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<n. \\<sigma> i \\<noteq> i) \\<Longrightarrow> False", "with \\<open>\\<sigma> \\<noteq> id\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<noteq> id\n  \\<sigma> = id", "show False"], ["proof (prove)\nusing this:\n  \\<sigma> \\<noteq> id\n  \\<sigma> = id\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i<n. \\<sigma> i \\<noteq> i\n\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "then"], ["proof (chain)\npicking this:\n  \\<exists>i<n. \\<sigma> i \\<noteq> i", "obtain i where i: \"i < n\" \"\\<sigma> i \\<noteq> i\""], ["proof (prove)\nusing this:\n  \\<exists>i<n. \\<sigma> i \\<noteq> i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < n; \\<sigma> i \\<noteq> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < n\n  \\<sigma> i \\<noteq> i\n\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "have \"\\<sigma> i < m + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> i < m + n", "using i"], ["proof (prove)\nusing this:\n  i < n\n  \\<sigma> i \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<sigma> i < m + n", "by (intro \\<sigma>_less) auto"], ["proof (state)\nthis:\n  \\<sigma> i < m + n\n\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "hence \"degree (M $$ (i, \\<sigma> i)) < m\""], ["proof (prove)\nusing this:\n  \\<sigma> i < m + n\n\ngoal (1 subgoal):\n 1. degree (M $$ (i, \\<sigma> i)) < m", "using i \\<open>m > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<sigma> i < m + n\n  i < n\n  \\<sigma> i \\<noteq> i\n  0 < m\n\ngoal (1 subgoal):\n 1. degree (M $$ (i, \\<sigma> i)) < m", "by (auto simp: M_def m_def n_def sylvester_index_mat degree_coeff_poly_x_minus_y\n                       coeff_poly_x_mult_y intro: le_less_trans[OF degree_monom_le])"], ["proof (state)\nthis:\n  degree (M $$ (i, \\<sigma> i)) < m\n\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. \\<exists>a\\<in>{..<n}. degree (M $$ (a, \\<sigma> a)) < m", "thus \"\\<exists>i\\<in>{..<n}. degree (M $$ (i, \\<sigma> i)) < m\""], ["proof (prove)\nusing this:\n  degree (M $$ (i, \\<sigma> i)) < m\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>{..<n}. degree (M $$ (i, \\<sigma> i)) < m", "using i"], ["proof (prove)\nusing this:\n  degree (M $$ (i, \\<sigma> i)) < m\n  i < n\n  \\<sigma> i \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>{..<n}. degree (M $$ (i, \\<sigma> i)) < m", "by blast"], ["proof (state)\nthis:\n  \\<exists>i\\<in>{..<n}. degree (M $$ (i, \\<sigma> i)) < m\n\ngoal (1 subgoal):\n 1. finite {..<n}", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n. degree (M $$ (i, \\<sigma> i))) < (\\<Sum>i<n. m)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<in>{0..<m + n}.\n               M $$ (i, \\<sigma> i) = 0) \\<Longrightarrow>\n    degree (f \\<sigma>) < m * n", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x < y \\<Longrightarrow>\n      x + (\\<Sum>i<m. 0) < y + (\\<Sum>i<m. 0)) \\<Longrightarrow>\n  degree (f \\<sigma>) < (\\<Sum>i<n. m) + (\\<Sum>i<m. 0)", "show \"degree (f \\<sigma>) < m * n\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x < y \\<Longrightarrow>\n      x + (\\<Sum>i<m. 0) < y + (\\<Sum>i<m. 0)) \\<Longrightarrow>\n  degree (f \\<sigma>) < (\\<Sum>i<n. m) + (\\<Sum>i<m. 0)\n\ngoal (1 subgoal):\n 1. degree (f \\<sigma>) < m * n", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  degree (f \\<sigma>) < m * n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<sigma> permutes {0..<m + n}; ?\\<sigma> \\<noteq> id\\<rbrakk>\n  \\<Longrightarrow> degree (f ?\\<sigma>) < m * n\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have \"lead_coeff (f id) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (f id)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monic (f id)", "have \"lead_coeff (f id) = (\\<Prod>i=0..<m + n. lead_coeff (M $$ (i, i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (f id) = (\\<Prod>i = 0..<m + n. lead_coeff (M $$ (i, i)))", "by (simp add: f_def signof_def lead_coeff_prod sign_id)"], ["proof (state)\nthis:\n  lead_coeff (f id) = (\\<Prod>i = 0..<m + n. lead_coeff (M $$ (i, i)))\n\ngoal (1 subgoal):\n 1. monic (f id)", "also"], ["proof (state)\nthis:\n  lead_coeff (f id) = (\\<Prod>i = 0..<m + n. lead_coeff (M $$ (i, i)))\n\ngoal (1 subgoal):\n 1. monic (f id)", "have \"(\\<Prod>i=0..<m + n. lead_coeff (M $$ (i, i))) =\n               (\\<Prod>i<n. lead_coeff (M $$ (i, i))) * (\\<Prod>i<m. lead_coeff (M $$ (n + i, n + i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<m + n. lead_coeff (M $$ (i, i))) =\n    (\\<Prod>i<n. lead_coeff (M $$ (i, i))) *\n    (\\<Prod>i<m. lead_coeff (M $$ (n + i, n + i)))", "by (subst indices_eq, subst prod.union_disjoint) (auto simp: prod.reindex)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<m + n. lead_coeff (M $$ (i, i))) =\n  (\\<Prod>i<n. lead_coeff (M $$ (i, i))) *\n  (\\<Prod>i<m. lead_coeff (M $$ (n + i, n + i)))\n\ngoal (1 subgoal):\n 1. monic (f id)", "also"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<m + n. lead_coeff (M $$ (i, i))) =\n  (\\<Prod>i<n. lead_coeff (M $$ (i, i))) *\n  (\\<Prod>i<m. lead_coeff (M $$ (n + i, n + i)))\n\ngoal (1 subgoal):\n 1. monic (f id)", "have \"(\\<Prod>i<n. lead_coeff (M $$ (i, i))) = (\\<Prod>i<n. lead_coeff p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n. lead_coeff (M $$ (i, i))) = (\\<Prod>i<n. lead_coeff p)", "using assms"], ["proof (prove)\nusing this:\n  m \\<equiv> degree p\n  n \\<equiv> degree q\n  monic p\n  monic q\n  0 < m\n  0 < n\n  coeff q 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Prod>i<n. lead_coeff (M $$ (i, i))) = (\\<Prod>i<n. lead_coeff p)", "by (intro prod.cong) (auto simp: M_def m_def n_def sylvester_index_mat\n                                       coeff_poly_x_mult_y degree_monom_eq)"], ["proof (state)\nthis:\n  (\\<Prod>i<n. lead_coeff (M $$ (i, i))) = (\\<Prod>i<n. lead_coeff p)\n\ngoal (1 subgoal):\n 1. monic (f id)", "also"], ["proof (state)\nthis:\n  (\\<Prod>i<n. lead_coeff (M $$ (i, i))) = (\\<Prod>i<n. lead_coeff p)\n\ngoal (1 subgoal):\n 1. monic (f id)", "have \"(\\<Prod>i<m. lead_coeff (M $$ (n + i, n + i))) = (\\<Prod>i<m. lead_coeff q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<m. lead_coeff (M $$ (n + i, n + i))) =\n    (\\<Prod>i<m. lead_coeff q)", "by (intro prod.cong) (auto simp: M_def m_def n_def sylvester_index_mat)"], ["proof (state)\nthis:\n  (\\<Prod>i<m. lead_coeff (M $$ (n + i, n + i))) =\n  (\\<Prod>i<m. lead_coeff q)\n\ngoal (1 subgoal):\n 1. monic (f id)", "finally"], ["proof (chain)\npicking this:\n  lead_coeff (f id) =\n  (\\<Prod>i<n. lead_coeff p) * (\\<Prod>i<m. lead_coeff q)", "show ?thesis"], ["proof (prove)\nusing this:\n  lead_coeff (f id) =\n  (\\<Prod>i<n. lead_coeff p) * (\\<Prod>i<m. lead_coeff q)\n\ngoal (1 subgoal):\n 1. monic (f id)", "using assms"], ["proof (prove)\nusing this:\n  lead_coeff (f id) =\n  (\\<Prod>i<n. lead_coeff p) * (\\<Prod>i<m. lead_coeff q)\n  m \\<equiv> degree p\n  n \\<equiv> degree q\n  monic p\n  monic q\n  0 < m\n  0 < n\n  coeff q 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. monic (f id)", "by (simp add: id_def)"], ["proof (state)\nthis:\n  monic (f id)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monic (f id)\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have \"lead_coeff (poly_mult p q) = lead_coeff (det M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (poly_mult p q) = lead_coeff (det M)", "by (simp add: poly_mult_def resultant_def M_def poly_div_def)"], ["proof (state)\nthis:\n  lead_coeff (poly_mult p q) = lead_coeff (det M)\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "also"], ["proof (state)\nthis:\n  lead_coeff (poly_mult p q) = lead_coeff (det M)\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have \"det M = (\\<Sum>\\<pi> | \\<pi> permutes {0..<m+n}. f \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det M = (\\<Sum>\\<pi> | \\<pi> permutes {0..<m + n}. f \\<pi>)", "by (simp add: det_def m_def n_def M_def f_def)"], ["proof (state)\nthis:\n  det M = (\\<Sum>\\<pi> | \\<pi> permutes {0..<m + n}. f \\<pi>)\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "also"], ["proof (state)\nthis:\n  det M = (\\<Sum>\\<pi> | \\<pi> permutes {0..<m + n}. f \\<pi>)\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have \"{\\<pi>. \\<pi> permutes {0..<m+n}} = insert id ({\\<pi>. \\<pi> permutes {0..<m+n}} - {id})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<pi>. \\<pi> permutes {0..<m + n}} =\n    insert id ({\\<pi>. \\<pi> permutes {0..<m + n}} - {id})", "by (auto simp: permutes_id)"], ["proof (state)\nthis:\n  {\\<pi>. \\<pi> permutes {0..<m + n}} =\n  insert id ({\\<pi>. \\<pi> permutes {0..<m + n}} - {id})\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "also"], ["proof (state)\nthis:\n  {\\<pi>. \\<pi> permutes {0..<m + n}} =\n  insert id ({\\<pi>. \\<pi> permutes {0..<m + n}} - {id})\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have \"(\\<Sum>\\<sigma>\\<in>\\<dots>. f \\<sigma>) = (\\<Sum>\\<sigma>\\<in>{\\<sigma>. \\<sigma> permutes {0..<m+n}}-{id}. f \\<sigma>) + f id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (insert id ({\\<pi>. \\<pi> permutes {0..<m + n}} - {id})) =\n    sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id}) + f id", "by (subst sum.insert) (auto simp: finite_permutations)"], ["proof (state)\nthis:\n  sum f (insert id ({\\<pi>. \\<pi> permutes {0..<m + n}} - {id})) =\n  sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id}) + f id\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "also"], ["proof (state)\nthis:\n  sum f (insert id ({\\<pi>. \\<pi> permutes {0..<m + n}} - {id})) =\n  sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id}) + f id\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "have \"lead_coeff \\<dots> = lead_coeff (f id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff\n     (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id}) + f id) =\n    lead_coeff (f id)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lead_coeff\n     (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id}) + f id) =\n    lead_coeff (f id)", "have \"degree (\\<Sum>\\<sigma>\\<in>{\\<sigma>. \\<sigma> permutes {0..<m+n}}-{id}. f \\<sigma>) < m * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id}))\n    < m * n", "using assms"], ["proof (prove)\nusing this:\n  m \\<equiv> degree p\n  n \\<equiv> degree q\n  monic p\n  monic q\n  0 < m\n  0 < n\n  coeff q 0 \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. degree (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id}))\n    < m * n", "by (intro degree_sum_smaller deg_f2) (auto simp: m_def n_def finite_permutations)"], ["proof (state)\nthis:\n  degree (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id})) < m * n\n\ngoal (1 subgoal):\n 1. lead_coeff\n     (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id}) + f id) =\n    lead_coeff (f id)", "with deg_f1"], ["proof (chain)\npicking this:\n  degree (f id) = m * n\n  degree (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id})) < m * n", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (f id) = m * n\n  degree (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id})) < m * n\n\ngoal (1 subgoal):\n 1. lead_coeff\n     (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id}) + f id) =\n    lead_coeff (f id)", "by (subst lead_coeff_add_le) auto"], ["proof (state)\nthis:\n  lead_coeff\n   (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id}) + f id) =\n  lead_coeff (f id)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lead_coeff\n   (sum f ({\\<sigma>. \\<sigma> permutes {0..<m + n}} - {id}) + f id) =\n  lead_coeff (f id)\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "finally"], ["proof (chain)\npicking this:\n  lead_coeff (poly_mult p q) = lead_coeff (f id)", "show ?thesis"], ["proof (prove)\nusing this:\n  lead_coeff (poly_mult p q) = lead_coeff (f id)\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "using \\<open>lead_coeff (f id) = 1\\<close>"], ["proof (prove)\nusing this:\n  lead_coeff (poly_mult p q) = lead_coeff (f id)\n  monic (f id)\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q)", "by simp"], ["proof (state)\nthis:\n  monic (poly_mult p q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraic_int_plus [intro]:\n  fixes x y :: \"'a :: field_char_0\"\n  assumes \"algebraic_int x\" \"algebraic_int y\"\n  shows   \"algebraic_int (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (x + y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic_int (x + y)", "from assms(1)"], ["proof (chain)\npicking this:\n  algebraic_int x", "obtain p where p: \"lead_coeff p = 1\" \"ipoly p x = 0\""], ["proof (prove)\nusing this:\n  algebraic_int x\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>monic p; ipoly p x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: algebraic_int_altdef_ipoly)"], ["proof (state)\nthis:\n  monic p\n  ipoly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. algebraic_int (x + y)", "from assms(2)"], ["proof (chain)\npicking this:\n  algebraic_int y", "obtain q where q: \"lead_coeff q = 1\" \"ipoly q y = 0\""], ["proof (prove)\nusing this:\n  algebraic_int y\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>monic q; ipoly q y = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: algebraic_int_altdef_ipoly)"], ["proof (state)\nthis:\n  monic q\n  ipoly q y = (0::'a)\n\ngoal (1 subgoal):\n 1. algebraic_int (x + y)", "have deg_pos: \"degree p > 0\" \"degree q > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree p &&& 0 < degree q", "using p q"], ["proof (prove)\nusing this:\n  monic p\n  ipoly p x = (0::'a)\n  monic q\n  ipoly q y = (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < degree p &&& 0 < degree q", "by (auto intro!: Nat.gr0I elim!: degree_eq_zeroE)"], ["proof (state)\nthis:\n  0 < degree p\n  0 < degree q\n\ngoal (1 subgoal):\n 1. algebraic_int (x + y)", "define r where \"r = poly_add_sign (degree p) (degree q) * poly_add p q\""], ["proof (state)\nthis:\n  r = poly_add_sign (degree p) (degree q) * poly_add p q\n\ngoal (1 subgoal):\n 1. algebraic_int (x + y)", "have \"lead_coeff r = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic r", "using p q deg_pos"], ["proof (prove)\nusing this:\n  monic p\n  ipoly p x = (0::'a)\n  monic q\n  ipoly q y = (0::'a)\n  0 < degree p\n  0 < degree q\n\ngoal (1 subgoal):\n 1. monic r", "by (simp add: r_def lead_coeff_mult poly_add_sign_def signof_def lead_coeff_poly_add)"], ["proof (state)\nthis:\n  monic r\n\ngoal (1 subgoal):\n 1. algebraic_int (x + y)", "moreover"], ["proof (state)\nthis:\n  monic r\n\ngoal (1 subgoal):\n 1. algebraic_int (x + y)", "have \"ipoly r (x + y) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly r (x + y) = (0::'a)", "using p q"], ["proof (prove)\nusing this:\n  monic p\n  ipoly p x = (0::'a)\n  monic q\n  ipoly q y = (0::'a)\n\ngoal (1 subgoal):\n 1. ipoly r (x + y) = (0::'a)", "by (simp add: ipoly_poly_add r_def of_int_poly_hom.hom_mult)"], ["proof (state)\nthis:\n  ipoly r (x + y) = (0::'a)\n\ngoal (1 subgoal):\n 1. algebraic_int (x + y)", "ultimately"], ["proof (chain)\npicking this:\n  monic r\n  ipoly r (x + y) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  monic r\n  ipoly r (x + y) = (0::'a)\n\ngoal (1 subgoal):\n 1. algebraic_int (x + y)", "by (auto simp: algebraic_int_altdef_ipoly)"], ["proof (state)\nthis:\n  algebraic_int (x + y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraic_int_times [intro]:\n  fixes x y :: \"'a :: field_char_0\"\n  assumes \"algebraic_int x\" \"algebraic_int y\"\n  shows   \"algebraic_int (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (x * y)", "proof (cases \"y = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "case [simp]: False"], ["proof (state)\nthis:\n  y \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "from assms(1)"], ["proof (chain)\npicking this:\n  algebraic_int x", "obtain p where p: \"lead_coeff p = 1\" \"ipoly p x = 0\""], ["proof (prove)\nusing this:\n  algebraic_int x\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>monic p; ipoly p x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: algebraic_int_altdef_ipoly)"], ["proof (state)\nthis:\n  monic p\n  ipoly p x = (0::'a)\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "from assms(2)"], ["proof (chain)\npicking this:\n  algebraic_int y", "obtain q where q: \"lead_coeff q = 1\" \"ipoly q y = 0\""], ["proof (prove)\nusing this:\n  algebraic_int y\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>monic q; ipoly q y = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: algebraic_int_altdef_ipoly)"], ["proof (state)\nthis:\n  monic q\n  ipoly q y = (0::'a)\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "have deg_pos: \"degree p > 0\" \"degree q > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < degree p &&& 0 < degree q", "using p q"], ["proof (prove)\nusing this:\n  monic p\n  ipoly p x = (0::'a)\n  monic q\n  ipoly q y = (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < degree p &&& 0 < degree q", "by (auto intro!: Nat.gr0I elim!: degree_eq_zeroE)"], ["proof (state)\nthis:\n  0 < degree p\n  0 < degree q\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "have [simp]: \"q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "using q"], ["proof (prove)\nusing this:\n  monic q\n  ipoly q y = (0::'a)\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "define n where \"n = Polynomial.order 0 q\""], ["proof (state)\nthis:\n  n = Polynomial.order 0 q\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "have \"monom 1 n dvd q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom 1 n dvd q", "by (simp add: n_def monom_1_dvd_iff)"], ["proof (state)\nthis:\n  monom 1 n dvd q\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "then"], ["proof (chain)\npicking this:\n  monom 1 n dvd q", "obtain q' where q_split: \"q = q' * monom 1 n\""], ["proof (prove)\nusing this:\n  monom 1 n dvd q\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        q = q' * monom 1 n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q = q' * monom 1 n\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "have \"Polynomial.order 0 q = Polynomial.order 0 q' + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.order 0 q = Polynomial.order 0 q' + n", "using \\<open>q \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Polynomial.order 0 q = Polynomial.order 0 q' + n", "unfolding q_split"], ["proof (prove)\nusing this:\n  q' * monom 1 n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Polynomial.order 0 (q' * monom 1 n) = Polynomial.order 0 q' + n", "by (subst order_mult) auto"], ["proof (state)\nthis:\n  Polynomial.order 0 q = Polynomial.order 0 q' + n\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "hence \"poly q' 0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Polynomial.order 0 q = Polynomial.order 0 q' + n\n\ngoal (1 subgoal):\n 1. poly q' 0 \\<noteq> 0", "unfolding n_def"], ["proof (prove)\nusing this:\n  Polynomial.order 0 q = Polynomial.order 0 q' + Polynomial.order 0 q\n\ngoal (1 subgoal):\n 1. poly q' 0 \\<noteq> 0", "using \\<open>q \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  Polynomial.order 0 q = Polynomial.order 0 q' + Polynomial.order 0 q\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly q' 0 \\<noteq> 0", "by (simp add: q_split order_root)"], ["proof (state)\nthis:\n  poly q' 0 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "have q': \"ipoly q' y = 0\" \"lead_coeff q' = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly q' y = (0::'a) &&& monic q'", "using q_split q"], ["proof (prove)\nusing this:\n  q = q' * monom 1 n\n  monic q\n  ipoly q y = (0::'a)\n\ngoal (1 subgoal):\n 1. ipoly q' y = (0::'a) &&& monic q'", "by (auto simp: of_int_poly_hom.hom_mult poly_monom lead_coeff_mult degree_monom_eq)"], ["proof (state)\nthis:\n  ipoly q' y = (0::'a)\n  monic q'\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "from this"], ["proof (chain)\npicking this:\n  ipoly q' y = (0::'a)\n  monic q'", "have deg_pos': \"degree q' > 0\""], ["proof (prove)\nusing this:\n  ipoly q' y = (0::'a)\n  monic q'\n\ngoal (1 subgoal):\n 1. 0 < degree q'", "by (intro Nat.gr0I) (auto elim!: degree_eq_zeroE)"], ["proof (state)\nthis:\n  0 < degree q'\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "from \\<open>poly q' 0 \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  poly q' 0 \\<noteq> 0", "have [simp]: \"coeff q' 0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly q' 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. coeff q' 0 \\<noteq> 0", "by (auto simp: monom_1_dvd_iff' poly_0_coeff_0)"], ["proof (state)\nthis:\n  coeff q' 0 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "have \"p represents x\" \"q' represents y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p represents x &&& q' represents y", "using p q'"], ["proof (prove)\nusing this:\n  monic p\n  ipoly p x = (0::'a)\n  ipoly q' y = (0::'a)\n  monic q'\n\ngoal (1 subgoal):\n 1. p represents x &&& q' represents y", "by (auto simp: represents_def)"], ["proof (state)\nthis:\n  p represents x\n  q' represents y\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "hence \"poly_mult p q' represents x * y\""], ["proof (prove)\nusing this:\n  p represents x\n  q' represents y\n\ngoal (1 subgoal):\n 1. poly_mult p q' represents x * y", "by (rule represents_mult) (simp add: poly_0_coeff_0)"], ["proof (state)\nthis:\n  poly_mult p q' represents x * y\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "moreover"], ["proof (state)\nthis:\n  poly_mult p q' represents x * y\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "have \"lead_coeff (poly_mult p q') = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monic (poly_mult p q')", "using p deg_pos q' deg_pos'"], ["proof (prove)\nusing this:\n  monic p\n  ipoly p x = (0::'a)\n  0 < degree p\n  0 < degree q\n  ipoly q' y = (0::'a)\n  monic q'\n  0 < degree q'\n\ngoal (1 subgoal):\n 1. monic (poly_mult p q')", "by (simp add: lead_coeff_mult lead_coeff_poly_mult)"], ["proof (state)\nthis:\n  monic (poly_mult p q')\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "ultimately"], ["proof (chain)\npicking this:\n  poly_mult p q' represents x * y\n  monic (poly_mult p q')", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_mult p q' represents x * y\n  monic (poly_mult p q')\n\ngoal (1 subgoal):\n 1. algebraic_int (x * y)", "by (auto simp: algebraic_int_altdef_ipoly represents_def)"], ["proof (state)\nthis:\n  algebraic_int (x * y)\n\ngoal (1 subgoal):\n 1. y = (0::'a) \\<Longrightarrow> algebraic_int (x * y)", "qed auto"], ["", "lemma algebraic_int_power [intro]:\n  \"algebraic_int (x :: 'a :: field_char_0) \\<Longrightarrow> algebraic_int (x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int x \\<Longrightarrow> algebraic_int (x ^ n)", "by (induction n) auto"], ["", "lemma algebraic_int_diff [intro]:\n  fixes x y :: \"'a :: field_char_0\"\n  assumes \"algebraic_int x\" \"algebraic_int y\"\n  shows   \"algebraic_int (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (x - y)", "using algebraic_int_plus[OF assms(1) algebraic_int_minus[OF assms(2)]]"], ["proof (prove)\nusing this:\n  algebraic_int (x + - y)\n\ngoal (1 subgoal):\n 1. algebraic_int (x - y)", "by simp"], ["", "lemma algebraic_int_sum [intro]:\n  \"(\\<And>x. x \\<in> A \\<Longrightarrow> algebraic_int (f x :: 'a :: field_char_0))\n    \\<Longrightarrow> algebraic_int (sum f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> A \\<Longrightarrow> algebraic_int (f x)) \\<Longrightarrow>\n    algebraic_int (sum f A)", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma algebraic_int_prod [intro]:\n  \"(\\<And>x. x \\<in> A \\<Longrightarrow> algebraic_int (f x :: 'a :: field_char_0))\n    \\<Longrightarrow> algebraic_int (prod f A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> A \\<Longrightarrow> algebraic_int (f x)) \\<Longrightarrow>\n    algebraic_int (prod f A)", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma algebraic_int_nth_root_real_iff:\n  \"algebraic_int (root n x) \\<longleftrightarrow> n = 0 \\<or> algebraic_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (root n x) = (n = 0 \\<or> algebraic_int x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic_int (root n x) = (n = 0 \\<or> algebraic_int x)", "have \"algebraic_int x\" if \"algebraic_int (root n x)\" \"n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic_int x", "from that(1)"], ["proof (chain)\npicking this:\n  algebraic_int (root n x)", "have \"algebraic_int (root n x ^ n)\""], ["proof (prove)\nusing this:\n  algebraic_int (root n x)\n\ngoal (1 subgoal):\n 1. algebraic_int (root n x ^ n)", "by auto"], ["proof (state)\nthis:\n  algebraic_int (root n x ^ n)\n\ngoal (1 subgoal):\n 1. algebraic_int x", "also"], ["proof (state)\nthis:\n  algebraic_int (root n x ^ n)\n\ngoal (1 subgoal):\n 1. algebraic_int x", "have \"root n x ^ n = (if even n then \\<bar>x\\<bar> else x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root n x ^ n = (if even n then \\<bar>x\\<bar> else x)", "using sgn_power_root[of n x] that(2)"], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow> sgn (root n x) * \\<bar>root n x\\<bar> ^ n = x\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. root n x ^ n = (if even n then \\<bar>x\\<bar> else x)", "by (auto simp: sgn_if split: if_splits)"], ["proof (state)\nthis:\n  root n x ^ n = (if even n then \\<bar>x\\<bar> else x)\n\ngoal (1 subgoal):\n 1. algebraic_int x", "finally"], ["proof (chain)\npicking this:\n  algebraic_int (if even n then \\<bar>x\\<bar> else x)", "show ?thesis"], ["proof (prove)\nusing this:\n  algebraic_int (if even n then \\<bar>x\\<bar> else x)\n\ngoal (1 subgoal):\n 1. algebraic_int x", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  algebraic_int x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>algebraic_int (root n x); n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> algebraic_int x\n\ngoal (1 subgoal):\n 1. algebraic_int (root n x) = (n = 0 \\<or> algebraic_int x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>algebraic_int (root n x); n \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> algebraic_int x\n\ngoal (1 subgoal):\n 1. algebraic_int (root n x) = (n = 0 \\<or> algebraic_int x)", "by auto"], ["proof (state)\nthis:\n  algebraic_int (root n x) = (n = 0 \\<or> algebraic_int x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraic_int_power_iff:\n  \"algebraic_int (x ^ n :: 'a :: field_char_0) \\<longleftrightarrow> n = 0 \\<or> algebraic_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (x ^ n) = (n = 0 \\<or> algebraic_int x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic_int (x ^ n) = (n = 0 \\<or> algebraic_int x)", "have \"algebraic_int x\" if \"algebraic_int (x ^ n)\" \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int x", "proof (rule algebraic_int_root)"], ["proof (state)\ngoal (5 subgoals):\n 1. algebraic_int ?y\n 2. poly ?p x = ?y\n 3. \\<forall>i. coeff ?p i \\<in> \\<int>\n 4. monic ?p\n 5. 0 < degree ?p", "show \"poly (monom 1 n) x = x ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (monom (1::'a) n) x = x ^ n", "by (auto simp: poly_monom)"], ["proof (state)\nthis:\n  poly (monom (1::'a) n) x = x ^ n\n\ngoal (4 subgoals):\n 1. algebraic_int (x ^ n)\n 2. \\<forall>i. coeff (monom (1::'a) n) i \\<in> \\<int>\n 3. monic (monom (1::'a) n)\n 4. 0 < degree (monom (1::'a) n)", "qed (use that in \\<open>auto simp: degree_monom_eq\\<close>)"], ["proof (state)\nthis:\n  \\<lbrakk>algebraic_int (x ^ n); 0 < n\\<rbrakk>\n  \\<Longrightarrow> algebraic_int x\n\ngoal (1 subgoal):\n 1. algebraic_int (x ^ n) = (n = 0 \\<or> algebraic_int x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>algebraic_int (x ^ n); 0 < n\\<rbrakk>\n  \\<Longrightarrow> algebraic_int x\n\ngoal (1 subgoal):\n 1. algebraic_int (x ^ n) = (n = 0 \\<or> algebraic_int x)", "by auto"], ["proof (state)\nthis:\n  algebraic_int (x ^ n) = (n = 0 \\<or> algebraic_int x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraic_int_power_iff' [simp]:\n  \"n > 0 \\<Longrightarrow> algebraic_int (x ^ n :: 'a :: field_char_0) \\<longleftrightarrow> algebraic_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> algebraic_int (x ^ n) = algebraic_int x", "by (subst algebraic_int_power_iff) auto"], ["", "lemma algebraic_int_sqrt_iff [simp]: \"algebraic_int (sqrt x) \\<longleftrightarrow> algebraic_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (sqrt x) = algebraic_int x", "by (simp add: sqrt_def algebraic_int_nth_root_real_iff)"], ["", "lemma algebraic_int_csqrt_iff [simp]: \"algebraic_int (csqrt x) \\<longleftrightarrow> algebraic_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (csqrt x) = algebraic_int x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. algebraic_int (csqrt x) \\<Longrightarrow> algebraic_int x\n 2. algebraic_int x \\<Longrightarrow> algebraic_int (csqrt x)", "assume \"algebraic_int (csqrt x)\""], ["proof (state)\nthis:\n  algebraic_int (csqrt x)\n\ngoal (2 subgoals):\n 1. algebraic_int (csqrt x) \\<Longrightarrow> algebraic_int x\n 2. algebraic_int x \\<Longrightarrow> algebraic_int (csqrt x)", "hence \"algebraic_int (csqrt x ^ 2)\""], ["proof (prove)\nusing this:\n  algebraic_int (csqrt x)\n\ngoal (1 subgoal):\n 1. algebraic_int ((csqrt x)\\<^sup>2)", "by (rule algebraic_int_power)"], ["proof (state)\nthis:\n  algebraic_int ((csqrt x)\\<^sup>2)\n\ngoal (2 subgoals):\n 1. algebraic_int (csqrt x) \\<Longrightarrow> algebraic_int x\n 2. algebraic_int x \\<Longrightarrow> algebraic_int (csqrt x)", "thus \"algebraic_int x\""], ["proof (prove)\nusing this:\n  algebraic_int ((csqrt x)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. algebraic_int x", "by simp"], ["proof (state)\nthis:\n  algebraic_int x\n\ngoal (1 subgoal):\n 1. algebraic_int x \\<Longrightarrow> algebraic_int (csqrt x)", "qed auto"], ["", "lemma algebraic_int_norm_complex [intro]:\n  assumes \"algebraic_int (z :: complex)\"\n  shows   \"algebraic_int (norm z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (cmod z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic_int (cmod z)", "from assms"], ["proof (chain)\npicking this:\n  algebraic_int z", "have \"algebraic_int (z * cnj z)\""], ["proof (prove)\nusing this:\n  algebraic_int z\n\ngoal (1 subgoal):\n 1. algebraic_int (z * cnj z)", "by auto"], ["proof (state)\nthis:\n  algebraic_int (z * cnj z)\n\ngoal (1 subgoal):\n 1. algebraic_int (cmod z)", "also"], ["proof (state)\nthis:\n  algebraic_int (z * cnj z)\n\ngoal (1 subgoal):\n 1. algebraic_int (cmod z)", "have \"z * cnj z = of_real (norm z ^ 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * cnj z = complex_of_real ((cmod z)\\<^sup>2)", "by (rule complex_norm_square [symmetric])"], ["proof (state)\nthis:\n  z * cnj z = complex_of_real ((cmod z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. algebraic_int (cmod z)", "finally"], ["proof (chain)\npicking this:\n  algebraic_int (complex_of_real ((cmod z)\\<^sup>2))", "show ?thesis"], ["proof (prove)\nusing this:\n  algebraic_int (complex_of_real ((cmod z)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. algebraic_int (cmod z)", "by simp"], ["proof (state)\nthis:\n  algebraic_int (cmod z)\n\ngoal:\nNo subgoals!", "qed"], ["", "hide_const (open) x_y"], ["", "end"]]}