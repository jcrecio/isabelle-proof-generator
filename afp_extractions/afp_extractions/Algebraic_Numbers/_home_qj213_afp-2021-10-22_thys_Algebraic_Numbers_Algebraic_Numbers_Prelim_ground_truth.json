{"file_name": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers/Algebraic_Numbers_Prelim.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Algebraic_Numbers", "problem_names": ["lemma primitive_imp_unit_iff:\n  fixes p :: \"'a :: {comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes pr: \"primitive p\"\n  shows \"p dvd 1 \\<longleftrightarrow> degree p = 0\"", "lemma dvd_all_coeffs_imp_dvd:\n  assumes \"\\<forall>a \\<in> set (coeffs p). c dvd a\" shows \"[:c:] dvd p\"", "lemma irreducible_content:\n  fixes p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes \"irreducible p\" shows \"degree p = 0 \\<or> primitive p\"", "lemma linear_irreducible_field:\n  fixes p :: \"'a :: field poly\"\n  assumes deg: \"degree p = 1\" shows \"irreducible p\"", "lemma linear_irreducible_int:\n  fixes p :: \"int poly\"\n  assumes deg: \"degree p = 1\" and cp: \"content p dvd 1\"\n  shows \"irreducible p\"", "lemma irreducible_connect_rev:\n  fixes p :: \"'a :: {comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes irr: \"irreducible p\" and deg: \"degree p > 0\"\n  shows \"irreducible\\<^sub>d p\"", "lemma poly_map_poly_code[code_unfold]: \"poly (map_poly h p) x = fold_coeffs (\\<lambda> a b. h a + x * b) p 0\"", "lemma of_rat_of_int[simp]: \"of_rat \\<circ> of_int = of_int\"", "lemma ipoly_of_rat[simp]: \"ipoly p (of_rat y) = of_rat (ipoly p y)\"", "lemma ipoly_of_real[simp]:\n  \"ipoly p (of_real x :: 'a :: {field,real_algebra_1}) = of_real (ipoly p x)\"", "lemma finite_ipoly_roots: assumes \"p \\<noteq> 0\"\n  shows \"finite {x :: real. ipoly p x = 0}\"", "lemma algebraic_altdef_ipoly:\n  shows \"algebraic x \\<longleftrightarrow> (\\<exists>p. ipoly p x = 0 \\<and> p \\<noteq> 0)\"", "lemma representsI[intro]: \"ipoly p x = 0 \\<Longrightarrow> p \\<noteq> 0 \\<Longrightarrow> p represents x\"", "lemma representsD:\n  assumes \"p represents x\" shows \"p \\<noteq> 0\" and \"ipoly p x = 0\"", "lemma representsE:\n  assumes \"p represents x\" and \"p \\<noteq> 0 \\<Longrightarrow> ipoly p x = 0 \\<Longrightarrow> thesis\"\n  shows thesis", "lemma represents_imp_degree:\n  fixes x :: \"'a :: field_char_0\"\n  assumes \"p represents x\" shows \"degree p \\<noteq> 0\"", "lemma representsE_full[elim]:\n  assumes rep: \"p represents x\"\n    and main: \"p \\<noteq> 0 \\<Longrightarrow> ipoly p x = 0 \\<Longrightarrow> degree p \\<noteq> 0 \\<Longrightarrow> thesis\"\n  shows thesis", "lemma represents_of_rat[simp]: \"p represents (of_rat x) = p represents x\"", "lemma represents_of_real[simp]: \"p represents (of_real x) = p represents x\"", "lemma algebraic_iff_represents: \"algebraic x \\<longleftrightarrow> (\\<exists> p. p represents x)\"", "lemma represents_irr_non_0:\n  assumes irr: \"irreducible p\" and ap: \"p represents x\" and x0: \"x \\<noteq> 0\"\n  shows \"poly p 0 \\<noteq> 0\"", "lemma pos_poly_abs_poly[simp]:\n  shows \"lead_coeff (abs_int_poly p) > 0 \\<longleftrightarrow> p \\<noteq> 0\"", "lemma abs_int_poly_0[simp]: \"abs_int_poly 0 = 0\"", "lemma abs_int_poly_eq_0_iff[simp]: \"abs_int_poly p = 0 \\<longleftrightarrow> p = 0\"", "lemma degree_abs_int_poly[simp]: \"degree (abs_int_poly p) = degree p\"", "lemma abs_int_poly_dvd[simp]: \"abs_int_poly p dvd q \\<longleftrightarrow> p dvd q\"", "lemma (in idom) irreducible_uminus[simp]: \"irreducible (-x) \\<longleftrightarrow> irreducible x\"", "lemma irreducible_abs_int_poly[simp]:\n  \"irreducible (abs_int_poly p) \\<longleftrightarrow> irreducible p\"", "lemma coeff_abs_int_poly[simp]:\n  \"coeff (abs_int_poly p) n = (if lead_coeff p < 0 then - coeff p n else coeff p n)\"", "lemma lead_coeff_abs_int_poly[simp]:\n  \"lead_coeff (abs_int_poly p) = abs (lead_coeff p)\"", "lemma ipoly_abs_int_poly_eq_zero_iff[simp]:\n  \"ipoly (abs_int_poly p) (x :: 'a :: comm_ring_1) = 0 \\<longleftrightarrow> ipoly p x = 0\"", "lemma abs_int_poly_represents[simp]:\n  \"abs_int_poly p represents x \\<longleftrightarrow> p represents x\"", "lemma content_pCons[simp]: \"content (pCons a p) = gcd a (content p)\"", "lemma content_uminus[simp]:\n  fixes p :: \"'a :: ring_gcd poly\" shows \"content (-p) = content p\"", "lemma primitive_abs_int_poly[simp]:\n  \"primitive (abs_int_poly p) \\<longleftrightarrow> primitive p\"", "lemma abs_int_poly_inv[simp]: \"smult (sgn (lead_coeff p)) (abs_int_poly p) = p\"", "lemma sgn_is_unit[intro!]:\n  fixes x :: \"'a :: linordered_idom\" (* find/make better class *)\n  assumes \"x \\<noteq> 0\"\n  shows \"sgn x dvd 1\"", "lemma cf_pos_poly_0[simp]: \"cf_pos_poly 0 = 0\"", "lemma cf_pos_poly_eq_0[simp]: \"cf_pos_poly f = 0 \\<longleftrightarrow> f = 0\"", "lemma\n  shows cf_pos_poly_main: \"smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\" (is ?g1)\n    and content_cf_pos_poly[simp]: \"content (cf_pos_poly f) = (if f = 0 then 0 else 1)\" (is ?g2)\n    and lead_coeff_cf_pos_poly[simp]: \"lead_coeff (cf_pos_poly f) > 0 \\<longleftrightarrow> f \\<noteq> 0\" (is ?g3)\n    and cf_pos_poly_dvd[simp]: \"cf_pos_poly f dvd f\" (is ?g4)", "lemma irreducible_connect_int:\n  fixes p :: \"int poly\"\n  assumes ir: \"irreducible\\<^sub>d p\" and c: \"content p = 1\"\n  shows \"irreducible p\"", "lemma\n  fixes x :: \"'a :: {idom,ring_char_0}\"\n  shows ipoly_cf_pos_poly_eq_0[simp]: \"ipoly (cf_pos_poly p) x = 0 \\<longleftrightarrow> ipoly p x = 0\"\n    and degree_cf_pos_poly[simp]: \"degree (cf_pos_poly p) = degree p\"\n    and cf_pos_cf_pos_poly[intro]: \"p \\<noteq> 0 \\<Longrightarrow> cf_pos (cf_pos_poly p)\"", "lemma cf_pos_poly_eq_1: \"cf_pos_poly f = 1 \\<longleftrightarrow> degree f = 0 \\<and> f \\<noteq> 0\" (is \"?l \\<longleftrightarrow> ?r\")", "lemma irr_cf_poly_rat[simp]: \"irreducible (poly_rat x)\"\n  \"lead_coeff (poly_rat x) > 0\" \"primitive (poly_rat x)\"", "lemma poly_rat[simp]: \"ipoly (poly_rat x) (of_rat x :: 'a :: field_char_0) = 0\" \"ipoly (poly_rat x) x = 0\"\n  \"poly_rat x \\<noteq> 0\" \"ipoly (poly_rat x) y = 0 \\<longleftrightarrow> y = (of_rat x :: 'a)\"", "lemma poly_rat_represents_of_rat: \"(poly_rat x) represents (of_rat x)\"", "lemma ipoly_smult_0_iff: assumes c: \"c \\<noteq> 0\"\n  shows \"(ipoly (smult c p) x = (0 :: real)) = (ipoly p x = 0)\"", "lemma not_irreducibleD:\n  assumes \"\\<not> irreducible x\" and \"x \\<noteq> 0\" and \"\\<not> x dvd 1\"\n  shows \"\\<exists>y z. x = y * z \\<and> \\<not> y dvd 1 \\<and> \\<not> z dvd 1\"", "lemma cf_pos_poly_represents[simp]: \"(cf_pos_poly p) represents x \\<longleftrightarrow> p represents x\"", "lemma coprime_prod: (* TODO: move *)\n  \"a \\<noteq> 0 \\<Longrightarrow> c \\<noteq> 0 \\<Longrightarrow> coprime (a * b) (c * d) \\<Longrightarrow> coprime b (d::'a::{semiring_gcd})\"", "lemma smult_prod: (* TODO: move or find corresponding lemma *)\n  \"smult a b = monom a 0 * b\"", "lemma degree_map_poly_2:\n  assumes \"f (lead_coeff p) \\<noteq> 0\"\n  shows   \"degree (map_poly f p) = degree p\"", "lemma irreducible_cf_pos_poly:\n  assumes irr: \"irreducible p\" and deg: \"degree p \\<noteq> 0\"\n  shows \"irreducible (cf_pos_poly p)\" (is \"irreducible ?p\")", "lemma hom_dvd_hom_iff[simp]: \"hom x dvd hom y \\<longleftrightarrow> x dvd y\"", "lemma smult_inverse_monom:\"p \\<noteq> 0 \\<Longrightarrow> smult (inverse c) (p::rat poly) = 1 \\<longleftrightarrow> p = [: c :]\"", "lemma of_int_monom:\"of_int_poly p = [:rat_of_int c:] \\<longleftrightarrow> p = [: c :]\"", "lemma degree_0_content:\n  fixes p :: \"int poly\"\n  assumes deg: \"degree p = 0\" shows \"content p = abs (coeff p 0)\"", "lemma prime_elem_imp_gcd_eq:\n  fixes x::\"'a:: ring_gcd\"\n  shows \"prime_elem x \\<Longrightarrow> gcd x y = normalize x \\<or> gcd x y = 1\"", "lemma irreducible_pos_gcd:\n  fixes p :: \"int poly\"\n  assumes ir: \"irreducible p\" and pos: \"lead_coeff p > 0\" shows \"gcd p q \\<in> {1,p}\"", "lemma irreducible_pos_gcd_twice:\n  fixes p q :: \"int poly\"\n  assumes p: \"irreducible p\" \"lead_coeff p > 0\"\n  and q: \"irreducible q\" \"lead_coeff q > 0\"\n  shows \"gcd p q = 1 \\<or> p = q\"", "lemma poly_zero_imp_not_unit:\n  assumes \"poly p x = 0\" shows \"\\<not> p dvd 1\"", "lemma poly_prod_mset_zero_iff:\n  fixes x :: \"'a :: idom\"\n  shows \"poly (prod_mset F) x = 0 \\<longleftrightarrow> (\\<exists>f \\<in># F. poly f x = 0)\"", "lemma algebraic_imp_represents_irreducible:\n  fixes x :: \"'a :: field_char_0\"\n  assumes \"algebraic x\"\n  shows \"\\<exists>p. p represents x \\<and> irreducible p\"", "lemma algebraic_imp_represents_irreducible_cf_pos:\n  assumes \"algebraic (x::'a::field_char_0)\"\n  shows \"\\<exists>p. p represents x \\<and> irreducible p \\<and> lead_coeff p > 0 \\<and> primitive p\"", "lemma gcd_of_int_poly: \"gcd (of_int_poly f) (of_int_poly g :: 'a :: {field_char_0,field_gcd} poly) =\n  smult (inverse (of_int (lead_coeff (gcd f g)))) (of_int_poly (gcd f g))\"", "lemma algebraic_imp_represents_unique:\n  fixes x :: \"'a :: {field_char_0,field_gcd}\"\n  assumes \"algebraic x\"\n  shows \"\\<exists>! p. p represents x \\<and> irreducible p \\<and> lead_coeff p > 0\" (is \"Ex1 ?p\")", "lemma ipoly_poly_compose:\n  fixes x :: \"'a :: idom\"\n  shows \"ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\"", "lemma poly_uminus_pCons_pCons[simp]:\n  \"poly_uminus (pCons a (pCons b p)) = pCons a (pCons (-b) (poly_uminus p))\" (is \"?l = ?r\")", "lemma poly_uminus_code[code,simp]: \"poly_uminus p = poly_uminus_inner (coeffs p)\"", "lemma poly_uminus_inner_0[simp]: \"poly_uminus_inner as = 0 \\<longleftrightarrow> Poly as = 0\"", "lemma degree_poly_uminus_inner[simp]: \"degree (poly_uminus_inner as) = degree (Poly as)\"", "lemma ipoly_uminus_inner[simp]:\n  \"ipoly (poly_uminus_inner as) (x::'a::comm_ring_1) = ipoly (Poly as) (-x)\"", "lemma represents_uminus: assumes alg: \"p represents x\"\n  shows \"(poly_uminus p) represents (-x)\"", "lemma content_poly_uminus_inner[simp]:\n  fixes as :: \"'a :: ring_gcd list\"\n  shows \"content (poly_uminus_inner as) = content (Poly as)\"", "lemma inverse_pow_minus: assumes \"x \\<noteq> (0 :: 'a :: field)\"\n  and \"i \\<le> n\"\n  shows \"inverse x ^ n * x ^ i = inverse x ^ (n - i)\"", "lemma (in inj_idom_hom) reflect_poly_hom:\n  \"reflect_poly (map_poly hom p) = map_poly hom (reflect_poly p)\"", "lemma ipoly_reflect_poly: assumes x: \"(x :: 'a :: field_char_0) \\<noteq> 0\"\n  shows \"ipoly (reflect_poly p) x = x ^ (degree p) * ipoly p (inverse x)\" (is \"?l = ?r\")", "lemma represents_inverse: assumes x: \"x \\<noteq> 0\"\n  and alg: \"p represents x\"\n  shows \"(reflect_poly p) represents (inverse x)\"", "lemma inverse_roots: assumes x: \"(x :: 'a :: field_char_0) \\<noteq> 0\"\n  shows \"ipoly (reflect_poly p) x = 0 \\<longleftrightarrow> ipoly p (inverse x) = 0\"", "lemma ipoly_nth_root:\n  fixes x :: \"'a :: idom\"\n  shows \"ipoly (poly_nth_root p) x = ipoly p (x ^ n)\"", "lemma poly_nth_root_0[simp]: \"poly_nth_root p = 0 \\<longleftrightarrow> p = 0\"", "lemma represents_nth_root:\n  assumes y: \"y^n = x\" and alg: \"p represents x\"\n  shows \"(poly_nth_root p) represents y\"", "lemma represents_nth_root_odd_real:\n  assumes alg: \"p represents x\" and odd: \"odd n\"\n  shows \"(poly_nth_root p) represents (root n x)\"", "lemma represents_nth_root_pos_real:\n  assumes alg: \"p represents x\" and pos: \"x > 0\"\n  shows \"(poly_nth_root p) represents (root n x)\"", "lemma represents_nth_root_neg_real:\n  assumes alg: \"p represents x\" and neg: \"x < 0\"\n  shows \"(poly_uminus (poly_nth_root (poly_uminus p))) represents (root n x)\"", "lemma represents_csqrt:\n  assumes alg: \"p represents x\" shows \"(poly_nth_root 2 p) represents (csqrt x)\"", "lemma represents_sqrt:\n  assumes alg: \"p represents x\" and pos: \"x \\<ge> 0\"\n  shows \"(poly_nth_root 2 p) represents (sqrt x)\"", "lemma represents_degree:\n  assumes \"p represents x\" shows \"degree p \\<noteq> 0\"", "lemma coeff_poly_mult_rat_main: \"coeff (poly_mult_rat_main n d f) i = coeff f i * n ^ (degree f - i) * d ^ i\"", "lemma degree_poly_mult_rat_main: \"n \\<noteq> 0 \\<Longrightarrow> degree (poly_mult_rat_main n d f) = (if d = 0 then 0 else degree f)\"", "lemma ipoly_mult_rat_main:\n  fixes x :: \"'a :: {field,ring_char_0}\"\n  assumes \"d \\<noteq> 0\" and \"n \\<noteq> 0\"\n  shows \"ipoly (poly_mult_rat_main n d p) x = of_int n ^ degree p * ipoly p (x * of_int d / of_int n)\"", "lemma degree_poly_mult_rat[simp]: assumes \"r \\<noteq> 0\" shows \"degree (poly_mult_rat r p) = degree p\"", "lemma ipoly_mult_rat:\n  assumes r0: \"r \\<noteq> 0\"\n  shows \"ipoly (poly_mult_rat r p) x = of_int (fst (quotient_of r)) ^ degree p * ipoly p (x * inverse (of_rat r))\"", "lemma poly_mult_rat_main_0[simp]:\n  assumes \"n \\<noteq> 0\" \"d \\<noteq> 0\" shows \"poly_mult_rat_main n d p = 0 \\<longleftrightarrow> p = 0\"", "lemma poly_mult_rat_0[simp]: assumes r0: \"r \\<noteq> 0\" shows \"poly_mult_rat r p = 0 \\<longleftrightarrow> p = 0\"", "lemma represents_mult_rat:\n  assumes r: \"r \\<noteq> 0\" and \"p represents x\" shows \"(poly_mult_rat r p) represents (of_rat r * x)\"", "lemma poly_add_rat_code[code]: \"poly_add_rat r p \\<equiv> case quotient_of r of (n,d) \\<Rightarrow>\n     let p' = (let fs = coeffs p; k = length fs in poly_of_list (map (\\<lambda>(fi, i). fi * d ^ (k - Suc i)) (zip fs [0..<k])));\n         p'' = p' \\<circ>\\<^sub>p [:-n,d:]\n      in p''\"", "lemma degree_poly_add_rat[simp]: \"degree (poly_add_rat r p) = degree p\"", "lemma ipoly_add_rat: \"ipoly (poly_add_rat r p) x = (of_int (snd (quotient_of r)) ^ degree p) * ipoly p (x - of_rat r)\"", "lemma poly_add_rat_0[simp]: \"poly_add_rat r p = 0 \\<longleftrightarrow> p = 0\"", "lemma add_rat_roots: \"ipoly (poly_add_rat r p) x = 0 \\<longleftrightarrow> ipoly p (x - of_rat r) = 0\"", "lemma represents_add_rat:\n  assumes \"p represents x\" shows \"(poly_add_rat r p) represents (of_rat r + x)\"", "lemmas pos_mult[simplified,simp] = mult_less_cancel_left_pos[of _ 0] mult_less_cancel_left_pos[of _ _ 0]", "lemma ipoly_add_rat_pos_neg:\n  \"ipoly (poly_add_rat r p) (x::'a::linordered_field) < 0 \\<longleftrightarrow> ipoly p (x - of_rat r) < 0\"\n  \"ipoly (poly_add_rat r p) (x::'a::linordered_field) > 0 \\<longleftrightarrow> ipoly p (x - of_rat r) > 0\"", "lemma sgn_ipoly_add_rat[simp]:\n  \"sgn (ipoly (poly_add_rat r p) (x::'a::linordered_field)) = sgn (ipoly p (x - of_rat r))\" (is \"sgn ?l = sgn ?r\")", "lemma deg_nonzero_represents:\n  assumes deg: \"degree p \\<noteq> 0\" shows \"\\<exists> x :: complex. p represents x\""], "translations": [["", "lemma primitive_imp_unit_iff:\n  fixes p :: \"'a :: {comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes pr: \"primitive p\"\n  shows \"p dvd 1 \\<longleftrightarrow> degree p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p dvd 1) = (degree p = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p dvd 1 \\<Longrightarrow> degree p = 0\n 2. degree p = 0 \\<Longrightarrow> p dvd 1", "assume \"degree p = 0\""], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (2 subgoals):\n 1. p dvd 1 \\<Longrightarrow> degree p = 0\n 2. degree p = 0 \\<Longrightarrow> p dvd 1", "from degree0_coeffs[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>a. p = [:a:]", "obtain p0 where p: \"p = [:p0:]\""], ["proof (prove)\nusing this:\n  \\<exists>a. p = [:a:]\n\ngoal (1 subgoal):\n 1. (\\<And>p0. p = [:p0:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p = [:p0:]\n\ngoal (2 subgoals):\n 1. p dvd 1 \\<Longrightarrow> degree p = 0\n 2. degree p = 0 \\<Longrightarrow> p dvd 1", "then"], ["proof (chain)\npicking this:\n  p = [:p0:]", "have \"\\<forall>c \\<in> set (coeffs p). p0 dvd c\""], ["proof (prove)\nusing this:\n  p = [:p0:]\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (coeffs p). p0 dvd c", "by (simp add: cCons_def)"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set (coeffs p). p0 dvd c\n\ngoal (2 subgoals):\n 1. p dvd 1 \\<Longrightarrow> degree p = 0\n 2. degree p = 0 \\<Longrightarrow> p dvd 1", "with pr"], ["proof (chain)\npicking this:\n  primitive p\n  \\<forall>c\\<in>set (coeffs p). p0 dvd c", "have \"p0 dvd 1\""], ["proof (prove)\nusing this:\n  primitive p\n  \\<forall>c\\<in>set (coeffs p). p0 dvd c\n\ngoal (1 subgoal):\n 1. p0 dvd (1::'a)", "by (auto dest: primitiveD)"], ["proof (state)\nthis:\n  p0 dvd (1::'a)\n\ngoal (2 subgoals):\n 1. p dvd 1 \\<Longrightarrow> degree p = 0\n 2. degree p = 0 \\<Longrightarrow> p dvd 1", "with p"], ["proof (chain)\npicking this:\n  p = [:p0:]\n  p0 dvd (1::'a)", "show \"p dvd 1\""], ["proof (prove)\nusing this:\n  p = [:p0:]\n  p0 dvd (1::'a)\n\ngoal (1 subgoal):\n 1. p dvd 1", "by auto"], ["proof (state)\nthis:\n  p dvd 1\n\ngoal (1 subgoal):\n 1. p dvd 1 \\<Longrightarrow> degree p = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p dvd 1 \\<Longrightarrow> degree p = 0", "assume \"p dvd 1\""], ["proof (state)\nthis:\n  p dvd 1\n\ngoal (1 subgoal):\n 1. p dvd 1 \\<Longrightarrow> degree p = 0", "then"], ["proof (chain)\npicking this:\n  p dvd 1", "show \"degree p = 0\""], ["proof (prove)\nusing this:\n  p dvd 1\n\ngoal (1 subgoal):\n 1. degree p = 0", "by (auto simp: poly_dvd_1)"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_all_coeffs_imp_dvd:\n  assumes \"\\<forall>a \\<in> set (coeffs p). c dvd a\" shows \"[:c:] dvd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:c:] dvd p", "proof (insert assms, induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball (set (coeffs 0)) ((dvd) c) \\<Longrightarrow> [:c:] dvd 0\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        Ball (set (coeffs p)) ((dvd) c) \\<Longrightarrow> [:c:] dvd p;\n        Ball (set (coeffs (pCons a p))) ((dvd) c)\\<rbrakk>\n       \\<Longrightarrow> [:c:] dvd pCons a p", "case 0"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (coeffs 0). c dvd a\n\ngoal (2 subgoals):\n 1. Ball (set (coeffs 0)) ((dvd) c) \\<Longrightarrow> [:c:] dvd 0\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        Ball (set (coeffs p)) ((dvd) c) \\<Longrightarrow> [:c:] dvd p;\n        Ball (set (coeffs (pCons a p))) ((dvd) c)\\<rbrakk>\n       \\<Longrightarrow> [:c:] dvd pCons a p", "then"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set (coeffs 0). c dvd a", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (coeffs 0). c dvd a\n\ngoal (1 subgoal):\n 1. [:c:] dvd 0", "by simp"], ["proof (state)\nthis:\n  [:c:] dvd 0\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        Ball (set (coeffs p)) ((dvd) c) \\<Longrightarrow> [:c:] dvd p;\n        Ball (set (coeffs (pCons a p))) ((dvd) c)\\<rbrakk>\n       \\<Longrightarrow> [:c:] dvd pCons a p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        Ball (set (coeffs p)) ((dvd) c) \\<Longrightarrow> [:c:] dvd p;\n        Ball (set (coeffs (pCons a p))) ((dvd) c)\\<rbrakk>\n       \\<Longrightarrow> [:c:] dvd pCons a p", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  \\<forall>a\\<in>set (coeffs p). c dvd a \\<Longrightarrow> [:c:] dvd p\n  \\<forall>a\\<in>set (coeffs (pCons a p)). c dvd a\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        Ball (set (coeffs p)) ((dvd) c) \\<Longrightarrow> [:c:] dvd p;\n        Ball (set (coeffs (pCons a p))) ((dvd) c)\\<rbrakk>\n       \\<Longrightarrow> [:c:] dvd pCons a p", "have \"pCons a p = [:a:] + pCons 0 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pCons a p = [:a:] + pCons (0::'a) p", "by simp"], ["proof (state)\nthis:\n  pCons a p = [:a:] + pCons (0::'a) p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        Ball (set (coeffs p)) ((dvd) c) \\<Longrightarrow> [:c:] dvd p;\n        Ball (set (coeffs (pCons a p))) ((dvd) c)\\<rbrakk>\n       \\<Longrightarrow> [:c:] dvd pCons a p", "also"], ["proof (state)\nthis:\n  pCons a p = [:a:] + pCons (0::'a) p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        Ball (set (coeffs p)) ((dvd) c) \\<Longrightarrow> [:c:] dvd p;\n        Ball (set (coeffs (pCons a p))) ((dvd) c)\\<rbrakk>\n       \\<Longrightarrow> [:c:] dvd pCons a p", "have \"[:c:] dvd ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:c:] dvd [:a:] + pCons (0::'a) p", "proof (rule dvd_add)"], ["proof (state)\ngoal (2 subgoals):\n 1. [:c:] dvd [:a:]\n 2. [:c:] dvd pCons (0::'a) p", "from pCons"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  \\<forall>a\\<in>set (coeffs p). c dvd a \\<Longrightarrow> [:c:] dvd p\n  \\<forall>a\\<in>set (coeffs (pCons a p)). c dvd a", "show \"[:c:] dvd [:a:]\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  \\<forall>a\\<in>set (coeffs p). c dvd a \\<Longrightarrow> [:c:] dvd p\n  \\<forall>a\\<in>set (coeffs (pCons a p)). c dvd a\n\ngoal (1 subgoal):\n 1. [:c:] dvd [:a:]", "by (auto simp: cCons_def)"], ["proof (state)\nthis:\n  [:c:] dvd [:a:]\n\ngoal (1 subgoal):\n 1. [:c:] dvd pCons (0::'a) p", "from pCons"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  \\<forall>a\\<in>set (coeffs p). c dvd a \\<Longrightarrow> [:c:] dvd p\n  \\<forall>a\\<in>set (coeffs (pCons a p)). c dvd a", "have \"[:c:] dvd p\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a) \\<or> p \\<noteq> 0\n  \\<forall>a\\<in>set (coeffs p). c dvd a \\<Longrightarrow> [:c:] dvd p\n  \\<forall>a\\<in>set (coeffs (pCons a p)). c dvd a\n\ngoal (1 subgoal):\n 1. [:c:] dvd p", "by auto"], ["proof (state)\nthis:\n  [:c:] dvd p\n\ngoal (1 subgoal):\n 1. [:c:] dvd pCons (0::'a) p", "from Rings.dvd_mult[OF this]"], ["proof (chain)\npicking this:\n  [:c:] dvd ?b * p", "show \"[:c:] dvd pCons 0 p\""], ["proof (prove)\nusing this:\n  [:c:] dvd ?b * p\n\ngoal (1 subgoal):\n 1. [:c:] dvd pCons (0::'a) p", "by (subst pCons_0_as_mult)"], ["proof (state)\nthis:\n  [:c:] dvd pCons (0::'a) p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [:c:] dvd [:a:] + pCons (0::'a) p\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       \\<lbrakk>a \\<noteq> (0::'a) \\<or> p \\<noteq> 0;\n        Ball (set (coeffs p)) ((dvd) c) \\<Longrightarrow> [:c:] dvd p;\n        Ball (set (coeffs (pCons a p))) ((dvd) c)\\<rbrakk>\n       \\<Longrightarrow> [:c:] dvd pCons a p", "finally"], ["proof (chain)\npicking this:\n  [:c:] dvd pCons a p", "show ?case"], ["proof (prove)\nusing this:\n  [:c:] dvd pCons a p\n\ngoal (1 subgoal):\n 1. [:c:] dvd pCons a p", "."], ["proof (state)\nthis:\n  [:c:] dvd pCons a p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible_content:\n  fixes p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes \"irreducible p\" shows \"degree p = 0 \\<or> primitive p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = 0 \\<or> primitive p", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (degree p = 0 \\<or> primitive p) \\<Longrightarrow> False", "assume not: \"\\<not>?thesis\""], ["proof (state)\nthis:\n  \\<not> (degree p = 0 \\<or> primitive p)\n\ngoal (1 subgoal):\n 1. \\<not> (degree p = 0 \\<or> primitive p) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> (degree p = 0 \\<or> primitive p)", "obtain c where c1: \"\\<not>c dvd 1\" and \"\\<forall>a \\<in> set (coeffs p). c dvd a\""], ["proof (prove)\nusing this:\n  \\<not> (degree p = 0 \\<or> primitive p)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>\\<not> c dvd (1::'a);\n         \\<forall>a\\<in>set (coeffs p). c dvd a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: not_primitiveE)"], ["proof (state)\nthis:\n  \\<not> c dvd (1::'a)\n  \\<forall>a\\<in>set (coeffs p). c dvd a\n\ngoal (1 subgoal):\n 1. \\<not> (degree p = 0 \\<or> primitive p) \\<Longrightarrow> False", "from dvd_all_coeffs_imp_dvd[OF this(2)]"], ["proof (chain)\npicking this:\n  [:c:] dvd p", "obtain r where p: \"p = r * [:c:]\""], ["proof (prove)\nusing this:\n  [:c:] dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>r. p = r * [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE, auto)"], ["proof (state)\nthis:\n  p = r * [:c:]\n\ngoal (1 subgoal):\n 1. \\<not> (degree p = 0 \\<or> primitive p) \\<Longrightarrow> False", "from irreducibleD[OF assms this]"], ["proof (chain)\npicking this:\n  r dvd 1 \\<or> [:c:] dvd 1", "have \"r dvd 1 \\<or> [:c:] dvd 1\""], ["proof (prove)\nusing this:\n  r dvd 1 \\<or> [:c:] dvd 1\n\ngoal (1 subgoal):\n 1. r dvd 1 \\<or> [:c:] dvd 1", "by auto"], ["proof (state)\nthis:\n  r dvd 1 \\<or> [:c:] dvd 1\n\ngoal (1 subgoal):\n 1. \\<not> (degree p = 0 \\<or> primitive p) \\<Longrightarrow> False", "with c1"], ["proof (chain)\npicking this:\n  \\<not> c dvd (1::'a)\n  r dvd 1 \\<or> [:c:] dvd 1", "have \"r dvd 1\""], ["proof (prove)\nusing this:\n  \\<not> c dvd (1::'a)\n  r dvd 1 \\<or> [:c:] dvd 1\n\ngoal (1 subgoal):\n 1. r dvd 1", "unfolding const_poly_dvd_1"], ["proof (prove)\nusing this:\n  \\<not> c dvd (1::'a)\n  r dvd 1 \\<or> c dvd (1::'a)\n\ngoal (1 subgoal):\n 1. r dvd 1", "by auto"], ["proof (state)\nthis:\n  r dvd 1\n\ngoal (1 subgoal):\n 1. \\<not> (degree p = 0 \\<or> primitive p) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  r dvd 1", "have \"degree r = 0\""], ["proof (prove)\nusing this:\n  r dvd 1\n\ngoal (1 subgoal):\n 1. degree r = 0", "unfolding poly_dvd_1"], ["proof (prove)\nusing this:\n  degree r = 0 \\<and> coeff r 0 dvd (1::'a)\n\ngoal (1 subgoal):\n 1. degree r = 0", "by auto"], ["proof (state)\nthis:\n  degree r = 0\n\ngoal (1 subgoal):\n 1. \\<not> (degree p = 0 \\<or> primitive p) \\<Longrightarrow> False", "with p"], ["proof (chain)\npicking this:\n  p = r * [:c:]\n  degree r = 0", "have \"degree p = 0\""], ["proof (prove)\nusing this:\n  p = r * [:c:]\n  degree r = 0\n\ngoal (1 subgoal):\n 1. degree p = 0", "by auto"], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. \\<not> (degree p = 0 \\<or> primitive p) \\<Longrightarrow> False", "with not"], ["proof (chain)\npicking this:\n  \\<not> (degree p = 0 \\<or> primitive p)\n  degree p = 0", "show False"], ["proof (prove)\nusing this:\n  \\<not> (degree p = 0 \\<or> primitive p)\n  degree p = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: move *)"], ["", "lemma linear_irreducible_field:\n  fixes p :: \"'a :: field poly\"\n  assumes deg: \"degree p = 1\" shows \"irreducible p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible p", "proof (intro irreducibleI)"], ["proof (state)\ngoal (3 subgoals):\n 1. p \\<noteq> 0\n 2. \\<not> is_unit p\n 3. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "from deg"], ["proof (chain)\npicking this:\n  degree p = 1", "show p0: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<not> is_unit p\n 2. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "from deg"], ["proof (chain)\npicking this:\n  degree p = 1", "show \"\\<not> p dvd 1\""], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. \\<not> is_unit p", "by (auto simp: poly_dvd_1)"], ["proof (state)\nthis:\n  \\<not> is_unit p\n\ngoal (1 subgoal):\n 1. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "assume p: \"p = a * b\""], ["proof (state)\nthis:\n  p = a * b\n\ngoal (1 subgoal):\n 1. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "with p0"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  p = a * b", "have a0: \"a \\<noteq> 0\" and b0: \"b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = a * b\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 &&& b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "from degree_mult_eq[OF this, folded p] assms"], ["proof (chain)\npicking this:\n  degree p = degree a + degree b\n  degree p = 1", "consider \"degree a = 1\" \"degree b = 0\" | \"degree a = 0\" \"degree b = 1\""], ["proof (prove)\nusing this:\n  degree p = degree a + degree b\n  degree p = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>degree a = 1; degree b = 0\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>degree a = 0; degree b = 1\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>degree a = 1; degree b = 0\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>degree a = 0; degree b = 1\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>degree a = 1; degree b = 0\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>degree a = 0; degree b = 1\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"a dvd 1 \\<or> b dvd 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>degree a = 1; degree b = 0\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>degree a = 0; degree b = 1\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. is_unit a \\<or> is_unit b", "by (cases; insert a0 b0, auto simp: primitive_imp_unit_iff)"], ["proof (state)\nthis:\n  is_unit a \\<or> is_unit b\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: move *)"], ["", "lemma linear_irreducible_int:\n  fixes p :: \"int poly\"\n  assumes deg: \"degree p = 1\" and cp: \"content p dvd 1\"\n  shows \"irreducible p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible p", "proof (intro irreducibleI)"], ["proof (state)\ngoal (3 subgoals):\n 1. p \\<noteq> 0\n 2. \\<not> is_unit p\n 3. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "from deg"], ["proof (chain)\npicking this:\n  degree p = 1", "show p0: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<not> is_unit p\n 2. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "from deg"], ["proof (chain)\npicking this:\n  degree p = 1", "show \"\\<not> p dvd 1\""], ["proof (prove)\nusing this:\n  degree p = 1\n\ngoal (1 subgoal):\n 1. \\<not> is_unit p", "by (auto simp: poly_dvd_1)"], ["proof (state)\nthis:\n  \\<not> is_unit p\n\ngoal (1 subgoal):\n 1. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "assume p: \"p = a * b\""], ["proof (state)\nthis:\n  p = a * b\n\ngoal (1 subgoal):\n 1. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "note * = cp[unfolded p is_unit_content_iff, unfolded content_mult]"], ["proof (state)\nthis:\n  content a * content b = 1\n\ngoal (1 subgoal):\n 1. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "have a1: \"content a dvd 1\" and b1: \"content b dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (content a) &&& is_unit (content b)", "using content_ge_0_int[of a] pos_zmult_eq_1_iff_lemma[OF *] *"], ["proof (prove)\nusing this:\n  0 \\<le> content a\n  content a = 1 \\<or> content a = - 1\n  content a * content b = 1\n\ngoal (1 subgoal):\n 1. is_unit (content a) &&& is_unit (content b)", "by (auto simp: abs_mult)"], ["proof (state)\nthis:\n  is_unit (content a)\n  is_unit (content b)\n\ngoal (1 subgoal):\n 1. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "with p0"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  is_unit (content a)\n  is_unit (content b)", "have a0: \"a \\<noteq> 0\" and b0: \"b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  is_unit (content a)\n  is_unit (content b)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 &&& b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "from degree_mult_eq[OF this, folded p] assms"], ["proof (chain)\npicking this:\n  degree p = degree a + degree b\n  degree p = 1\n  is_unit (content p)", "consider \"degree a = 1\" \"degree b = 0\" | \"degree a = 0\" \"degree b = 1\""], ["proof (prove)\nusing this:\n  degree p = degree a + degree b\n  degree p = 1\n  is_unit (content p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>degree a = 1; degree b = 0\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>degree a = 0; degree b = 1\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>degree a = 1; degree b = 0\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>degree a = 0; degree b = 1\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a b. p = a * b \\<Longrightarrow> is_unit a \\<or> is_unit b", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>degree a = 1; degree b = 0\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>degree a = 0; degree b = 1\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"a dvd 1 \\<or> b dvd 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>degree a = 1; degree b = 0\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>degree a = 0; degree b = 1\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. is_unit a \\<or> is_unit b", "by (cases; insert a1 b1, auto simp: primitive_imp_unit_iff)"], ["proof (state)\nthis:\n  is_unit a \\<or> is_unit b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible_connect_rev:\n  fixes p :: \"'a :: {comm_semiring_1,semiring_no_zero_divisors} poly\"\n  assumes irr: \"irreducible p\" and deg: \"degree p > 0\"\n  shows \"irreducible\\<^sub>d p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible\\<^sub>d p", "proof(intro irreducible\\<^sub>dI deg)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "fix q r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "assume degq: \"degree q > 0\" and diff: \"degree q < degree p\" and p: \"p = q * r\""], ["proof (state)\nthis:\n  0 < degree q\n  degree q < degree p\n  p = q * r\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from degq"], ["proof (chain)\npicking this:\n  0 < degree q", "have nu: \"\\<not> q dvd 1\""], ["proof (prove)\nusing this:\n  0 < degree q\n\ngoal (1 subgoal):\n 1. \\<not> q dvd 1", "by (auto simp: poly_dvd_1)"], ["proof (state)\nthis:\n  \\<not> q dvd 1\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "from irreducibleD[OF irr p] nu"], ["proof (chain)\npicking this:\n  q dvd 1 \\<or> r dvd 1\n  \\<not> q dvd 1", "have \"r dvd 1\""], ["proof (prove)\nusing this:\n  q dvd 1 \\<or> r dvd 1\n  \\<not> q dvd 1\n\ngoal (1 subgoal):\n 1. r dvd 1", "by auto"], ["proof (state)\nthis:\n  r dvd 1\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  r dvd 1", "have \"degree r = 0\""], ["proof (prove)\nusing this:\n  r dvd 1\n\ngoal (1 subgoal):\n 1. degree r = 0", "by (auto simp: poly_dvd_1)"], ["proof (state)\nthis:\n  degree r = 0\n\ngoal (1 subgoal):\n 1. \\<And>q r.\n       \\<lbrakk>0 < degree q; degree q < degree p; 0 < degree r;\n        degree r < degree p; p = q * r\\<rbrakk>\n       \\<Longrightarrow> False", "with degq diff"], ["proof (chain)\npicking this:\n  0 < degree q\n  degree q < degree p\n  degree r = 0", "show False"], ["proof (prove)\nusing this:\n  0 < degree q\n  degree q < degree p\n  degree r = 0\n\ngoal (1 subgoal):\n 1. False", "unfolding p"], ["proof (prove)\nusing this:\n  0 < degree q\n  degree q < degree (q * r)\n  degree r = 0\n\ngoal (1 subgoal):\n 1. False", "using degree_mult_le[of q r]"], ["proof (prove)\nusing this:\n  0 < degree q\n  degree q < degree (q * r)\n  degree r = 0\n  degree (q * r) \\<le> degree q + degree r\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Polynomial Evaluation of Integer and Rational Polynomials in Fields.\\<close>"], ["", "abbreviation ipoly where \"ipoly f x \\<equiv> poly (of_int_poly f) x\""], ["", "lemma poly_map_poly_code[code_unfold]: \"poly (map_poly h p) x = fold_coeffs (\\<lambda> a b. h a + x * b) p 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly h p) x =\n    fold_coeffs (\\<lambda>a b. h a + x * b) p (0::'a)", "by (induct p, auto)"], ["", "abbreviation real_of_int_poly :: \"int poly \\<Rightarrow> real poly\" where\n  \"real_of_int_poly \\<equiv> of_int_poly\""], ["", "abbreviation real_of_rat_poly :: \"rat poly \\<Rightarrow> real poly\" where\n  \"real_of_rat_poly \\<equiv> map_poly of_rat\""], ["", "lemma of_rat_of_int[simp]: \"of_rat \\<circ> of_int = of_int\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat \\<circ> rat_of_int = of_int", "by auto"], ["", "lemma ipoly_of_rat[simp]: \"ipoly p (of_rat y) = of_rat (ipoly p y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly p (of_rat y) = of_rat (ipoly p y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ipoly p (of_rat y) = of_rat (ipoly p y)", "have id: \"of_int = of_rat o of_int\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int = of_rat \\<circ> rat_of_int", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int = (\\<lambda>x. of_rat (rat_of_int x))", "by auto"], ["proof (state)\nthis:\n  of_int = of_rat \\<circ> rat_of_int\n\ngoal (1 subgoal):\n 1. ipoly p (of_rat y) = of_rat (ipoly p y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly p (of_rat y) = of_rat (ipoly p y)", "by (subst id, subst map_poly_map_poly[symmetric], auto)"], ["proof (state)\nthis:\n  ipoly p (of_rat y) = of_rat (ipoly p y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipoly_of_real[simp]:\n  \"ipoly p (of_real x :: 'a :: {field,real_algebra_1}) = of_real (ipoly p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly p (of_real x) = of_real (poly (real_of_int_poly p) x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipoly p (of_real x) = of_real (poly (real_of_int_poly p) x)", "have id: \"of_int = of_real o of_int\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int = of_real \\<circ> real_of_int", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int = (\\<lambda>x. of_real (real_of_int x))", "by auto"], ["proof (state)\nthis:\n  of_int = of_real \\<circ> real_of_int\n\ngoal (1 subgoal):\n 1. ipoly p (of_real x) = of_real (poly (real_of_int_poly p) x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly p (of_real x) = of_real (poly (real_of_int_poly p) x)", "by (subst id, subst map_poly_map_poly[symmetric], auto)"], ["proof (state)\nthis:\n  ipoly p (of_real x) = of_real (poly (real_of_int_poly p) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_ipoly_roots: assumes \"p \\<noteq> 0\"\n  shows \"finite {x :: real. ipoly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. poly (real_of_int_poly p) x = 0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. poly (real_of_int_poly p) x = 0}", "let ?p = \"real_of_int_poly p\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. poly (real_of_int_poly p) x = 0}", "from assms"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"?p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. real_of_int_poly p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  real_of_int_poly p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite {x. poly (real_of_int_poly p) x = 0}", "thus ?thesis"], ["proof (prove)\nusing this:\n  real_of_int_poly p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite {x. poly (real_of_int_poly p) x = 0}", "by (rule poly_roots_finite)"], ["proof (state)\nthis:\n  finite {x. poly (real_of_int_poly p) x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Algebraic Numbers -- Definition, Inverse, and Roots\\<close>"], ["", "text \\<open>A number @{term \"x :: 'a :: field\"} is algebraic iff it is the root of an integer polynomial.\n  Whereas the Isabelle distribution this is defined via the embedding\n  of integers in an field via @{const Ints}, we work with integer polynomials\n  of type @{type int} and then use @{const ipoly} for evaluating the polynomial at\n  a real or complex point.\\<close>"], ["", "lemma algebraic_altdef_ipoly:\n  shows \"algebraic x \\<longleftrightarrow> (\\<exists>p. ipoly p x = 0 \\<and> p \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic x = (\\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0)", "unfolding algebraic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>p.\n        (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n        p \\<noteq> 0 \\<and> poly p x = (0::'a)) =\n    (\\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0)", "proof (safe, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>i. coeff p i \\<in> \\<int>; p \\<noteq> 0;\n        poly p x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n 2. \\<And>p.\n       \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n                            p \\<noteq> 0 \\<and> poly p x = (0::'a)", "case (1 p)"], ["proof (state)\nthis:\n  \\<forall>i. coeff p i \\<in> \\<int>\n  p \\<noteq> 0\n  poly p x = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>i. coeff p i \\<in> \\<int>; p \\<noteq> 0;\n        poly p x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n 2. \\<And>p.\n       \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n                            p \\<noteq> 0 \\<and> poly p x = (0::'a)", "define the_int where \"the_int = (\\<lambda>x::'a. THE r. x = of_int r)\""], ["proof (state)\nthis:\n  the_int = (\\<lambda>x. THE r. x = of_int r)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>i. coeff p i \\<in> \\<int>; p \\<noteq> 0;\n        poly p x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n 2. \\<And>p.\n       \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n                            p \\<noteq> 0 \\<and> poly p x = (0::'a)", "define p' where \"p' = map_poly the_int p\""], ["proof (state)\nthis:\n  p' = map_poly the_int p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>i. coeff p i \\<in> \\<int>; p \\<noteq> 0;\n        poly p x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n 2. \\<And>p.\n       \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n                            p \\<noteq> 0 \\<and> poly p x = (0::'a)", "have of_int_the_int: \"of_int (the_int x) = x\" if \"x \\<in> \\<int>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (the_int x) = x", "unfolding the_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (THE r. x = of_int r) = x", "by (rule sym, rule theI') (insert that, auto simp: Ints_def)"], ["proof (state)\nthis:\n  ?x \\<in> \\<int> \\<Longrightarrow> of_int (the_int ?x) = ?x\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>i. coeff p i \\<in> \\<int>; p \\<noteq> 0;\n        poly p x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n 2. \\<And>p.\n       \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n                            p \\<noteq> 0 \\<and> poly p x = (0::'a)", "have the_int_0_iff: \"the_int x = 0 \\<longleftrightarrow> x = 0\" if \"x \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the_int x = 0) = (x = (0::'a))", "using of_int_the_int[OF that]"], ["proof (prove)\nusing this:\n  of_int (the_int x) = x\n\ngoal (1 subgoal):\n 1. (the_int x = 0) = (x = (0::'a))", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<int> \\<Longrightarrow> (the_int x = 0) = (x = (0::'a))\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>i. coeff p i \\<in> \\<int>; p \\<noteq> 0;\n        poly p x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n 2. \\<And>p.\n       \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n                            p \\<noteq> 0 \\<and> poly p x = (0::'a)", "have \"map_poly of_int p' = map_poly (of_int \\<circ> the_int) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly p' = map_poly (of_int \\<circ> the_int) p", "by (simp add: p'_def map_poly_map_poly)"], ["proof (state)\nthis:\n  of_int_poly p' = map_poly (of_int \\<circ> the_int) p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>i. coeff p i \\<in> \\<int>; p \\<noteq> 0;\n        poly p x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n 2. \\<And>p.\n       \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n                            p \\<noteq> 0 \\<and> poly p x = (0::'a)", "also"], ["proof (state)\nthis:\n  of_int_poly p' = map_poly (of_int \\<circ> the_int) p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>i. coeff p i \\<in> \\<int>; p \\<noteq> 0;\n        poly p x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n 2. \\<And>p.\n       \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n                            p \\<noteq> 0 \\<and> poly p x = (0::'a)", "from 1 of_int_the_int"], ["proof (chain)\npicking this:\n  \\<forall>i. coeff p i \\<in> \\<int>\n  p \\<noteq> 0\n  poly p x = (0::'a)\n  ?x \\<in> \\<int> \\<Longrightarrow> of_int (the_int ?x) = ?x", "have \"\\<dots> = p\""], ["proof (prove)\nusing this:\n  \\<forall>i. coeff p i \\<in> \\<int>\n  p \\<noteq> 0\n  poly p x = (0::'a)\n  ?x \\<in> \\<int> \\<Longrightarrow> of_int (the_int ?x) = ?x\n\ngoal (1 subgoal):\n 1. map_poly (of_int \\<circ> the_int) p = p", "by (subst poly_eq_iff) (auto simp: coeff_map_poly)"], ["proof (state)\nthis:\n  map_poly (of_int \\<circ> the_int) p = p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>i. coeff p i \\<in> \\<int>; p \\<noteq> 0;\n        poly p x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n 2. \\<And>p.\n       \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n                            p \\<noteq> 0 \\<and> poly p x = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  of_int_poly p' = p", "have p_p': \"map_poly of_int p' = p\""], ["proof (prove)\nusing this:\n  of_int_poly p' = p\n\ngoal (1 subgoal):\n 1. of_int_poly p' = p", "."], ["proof (state)\nthis:\n  of_int_poly p' = p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>i. coeff p i \\<in> \\<int>; p \\<noteq> 0;\n        poly p x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n 2. \\<And>p.\n       \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n                            p \\<noteq> 0 \\<and> poly p x = (0::'a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0", "proof (intro exI conjI notI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ipoly ?p x = (0::'a)\n 2. ?p = 0 \\<Longrightarrow> False", "from 1"], ["proof (chain)\npicking this:\n  \\<forall>i. coeff p i \\<in> \\<int>\n  p \\<noteq> 0\n  poly p x = (0::'a)", "show \"ipoly p' x = 0\""], ["proof (prove)\nusing this:\n  \\<forall>i. coeff p i \\<in> \\<int>\n  p \\<noteq> 0\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. ipoly p' x = (0::'a)", "by (simp add: p_p')"], ["proof (state)\nthis:\n  ipoly p' x = (0::'a)\n\ngoal (1 subgoal):\n 1. p' = 0 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p' = 0 \\<Longrightarrow> False", "assume \"p' = 0\""], ["proof (state)\nthis:\n  p' = 0\n\ngoal (1 subgoal):\n 1. p' = 0 \\<Longrightarrow> False", "hence \"p = 0\""], ["proof (prove)\nusing this:\n  p' = 0\n\ngoal (1 subgoal):\n 1. p = 0", "by (simp add: p_p' [symmetric])"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. p' = 0 \\<Longrightarrow> False", "with \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  p = 0", "show False"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = 0\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n                            p \\<noteq> 0 \\<and> poly p x = (0::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n                            p \\<noteq> 0 \\<and> poly p x = (0::'a)", "case (2 p)"], ["proof (state)\nthis:\n  ipoly p x = (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n                            p \\<noteq> 0 \\<and> poly p x = (0::'a)", "thus ?case"], ["proof (prove)\nusing this:\n  ipoly p x = (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n       p \\<noteq> 0 \\<and> poly p x = (0::'a)", "by (intro exI[of _ \"map_poly of_int p\"], auto)"], ["proof (state)\nthis:\n  \\<exists>p.\n     (\\<forall>i. coeff p i \\<in> \\<int>) \\<and>\n     p \\<noteq> 0 \\<and> poly p x = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Definition of being algebraic with explicit witness polynomial.\\<close>"], ["", "definition represents :: \"int poly \\<Rightarrow> 'a :: field_char_0 \\<Rightarrow> bool\" (infix \"represents\" 51)\n  where \"p represents x = (ipoly p x = 0 \\<and> p \\<noteq> 0)\""], ["", "lemma representsI[intro]: \"ipoly p x = 0 \\<Longrightarrow> p \\<noteq> 0 \\<Longrightarrow> p represents x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> p represents x", "unfolding represents_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> ipoly p x = (0::'a) \\<and> p \\<noteq> 0", "by auto"], ["", "lemma representsD:\n  assumes \"p represents x\" shows \"p \\<noteq> 0\" and \"ipoly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& ipoly p x = (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  p represents x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& ipoly p x = (0::'a)", "unfolding represents_def"], ["proof (prove)\nusing this:\n  ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& ipoly p x = (0::'a)", "by auto"], ["", "lemma representsE:\n  assumes \"p represents x\" and \"p \\<noteq> 0 \\<Longrightarrow> ipoly p x = 0 \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  p represents x\n  \\<lbrakk>p \\<noteq> 0; ipoly p x = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "unfolding represents_def"], ["proof (prove)\nusing this:\n  ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n  \\<lbrakk>p \\<noteq> 0; ipoly p x = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["", "lemma represents_imp_degree:\n  fixes x :: \"'a :: field_char_0\"\n  assumes \"p represents x\" shows \"degree p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "from assms"], ["proof (chain)\npicking this:\n  p represents x", "have \"p \\<noteq> 0\" and px: \"ipoly p x = 0\""], ["proof (prove)\nusing this:\n  p represents x\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& ipoly p x = (0::'a)", "by (auto dest:representsD)"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)", "have \"(of_int_poly p :: 'a poly) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. of_int_poly p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  of_int_poly p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  of_int_poly p \\<noteq> 0", "have \"degree (of_int_poly p :: 'a poly) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  of_int_poly p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (of_int_poly p) \\<noteq> 0", "by (fold poly_zero[OF px])"], ["proof (state)\nthis:\n  degree (of_int_poly p) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  degree (of_int_poly p) \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (of_int_poly p) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma representsE_full[elim]:\n  assumes rep: \"p represents x\"\n    and main: \"p \\<noteq> 0 \\<Longrightarrow> ipoly p x = 0 \\<Longrightarrow> degree p \\<noteq> 0 \\<Longrightarrow> thesis\"\n  shows thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by (rule main, insert represents_imp_degree[OF rep] rep, auto elim: representsE)"], ["", "lemma represents_of_rat[simp]: \"p represents (of_rat x) = p represents x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p represents of_rat x = p represents x", "by (auto elim!:representsE)"], ["", "lemma represents_of_real[simp]: \"p represents (of_real x) = p represents x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p represents of_real x = p represents x", "by (auto elim!:representsE)"], ["", "lemma algebraic_iff_represents: \"algebraic x \\<longleftrightarrow> (\\<exists> p. p represents x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic x = (\\<exists>p. p represents x)", "unfolding algebraic_altdef_ipoly represents_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0) =\n    (\\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0)", ".."], ["", "lemma represents_irr_non_0:\n  assumes irr: \"irreducible p\" and ap: \"p represents x\" and x0: \"x \\<noteq> 0\"\n  shows \"poly p 0 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p 0 \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p 0 = 0 \\<Longrightarrow> False", "have nu: \"\\<not> [:0,1::int:] dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_unit [:0, 1:]", "by (auto simp: poly_dvd_1)"], ["proof (state)\nthis:\n  \\<not> is_unit [:0, 1:]\n\ngoal (1 subgoal):\n 1. poly p 0 = 0 \\<Longrightarrow> False", "assume \"poly p 0 = 0\""], ["proof (state)\nthis:\n  poly p 0 = 0\n\ngoal (1 subgoal):\n 1. poly p 0 = 0 \\<Longrightarrow> False", "hence dvd: \"[: 0, 1 :] dvd p\""], ["proof (prove)\nusing this:\n  poly p 0 = 0\n\ngoal (1 subgoal):\n 1. [:0, 1:] dvd p", "by (unfold dvd_iff_poly_eq_0, simp)"], ["proof (state)\nthis:\n  [:0, 1:] dvd p\n\ngoal (1 subgoal):\n 1. poly p 0 = 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  [:0, 1:] dvd p", "obtain q where pq: \"p = [:0,1:] * q\""], ["proof (prove)\nusing this:\n  [:0, 1:] dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>q. p = [:0, 1:] * q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE)"], ["proof (state)\nthis:\n  p = [:0, 1:] * q\n\ngoal (1 subgoal):\n 1. poly p 0 = 0 \\<Longrightarrow> False", "from irreducibleD[OF irr this] nu"], ["proof (chain)\npicking this:\n  is_unit [:0, 1:] \\<or> is_unit q\n  \\<not> is_unit [:0, 1:]", "have \"q dvd 1\""], ["proof (prove)\nusing this:\n  is_unit [:0, 1:] \\<or> is_unit q\n  \\<not> is_unit [:0, 1:]\n\ngoal (1 subgoal):\n 1. is_unit q", "by auto"], ["proof (state)\nthis:\n  is_unit q\n\ngoal (1 subgoal):\n 1. poly p 0 = 0 \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  is_unit q", "obtain r where \"q = [:r:]\" \"r dvd 1\""], ["proof (prove)\nusing this:\n  is_unit q\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>q = [:r:]; is_unit r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: poly_dvd_1 dest: degree0_coeffs)"], ["proof (state)\nthis:\n  q = [:r:]\n  is_unit r\n\ngoal (1 subgoal):\n 1. poly p 0 = 0 \\<Longrightarrow> False", "with pq"], ["proof (chain)\npicking this:\n  p = [:0, 1:] * q\n  q = [:r:]\n  is_unit r", "have \"p = [:0,r:]\""], ["proof (prove)\nusing this:\n  p = [:0, 1:] * q\n  q = [:r:]\n  is_unit r\n\ngoal (1 subgoal):\n 1. p = [:0, r:]", "by auto"], ["proof (state)\nthis:\n  p = [:0, r:]\n\ngoal (1 subgoal):\n 1. poly p 0 = 0 \\<Longrightarrow> False", "with ap"], ["proof (chain)\npicking this:\n  p represents x\n  p = [:0, r:]", "have \"x = 0\""], ["proof (prove)\nusing this:\n  p represents x\n  p = [:0, r:]\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "by (auto simp: of_int_hom.map_poly_pCons_hom)"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly p 0 = 0 \\<Longrightarrow> False", "with x0"], ["proof (chain)\npicking this:\n  x \\<noteq> (0::'a)\n  x = (0::'a)", "show False"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n  x = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The polynomial encoding a rational number.\\<close>"], ["", "definition poly_rat :: \"rat \\<Rightarrow> int poly\" where\n  \"poly_rat x = (case quotient_of x of (n,d) \\<Rightarrow> [:-n,d:])\""], ["", "definition abs_int_poly:: \"int poly \\<Rightarrow> int poly\" where\n  \"abs_int_poly p \\<equiv> if lead_coeff p < 0 then -p else p\""], ["", "lemma pos_poly_abs_poly[simp]:\n  shows \"lead_coeff (abs_int_poly p) > 0 \\<longleftrightarrow> p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < lead_coeff (abs_int_poly p)) = (p \\<noteq> 0)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (0 < lead_coeff (abs_int_poly p)) = (p \\<noteq> 0)", "have \"p \\<noteq> 0 \\<longleftrightarrow> lead_coeff p * sgn (lead_coeff p) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<noteq> 0) = (0 < lead_coeff p * sgn (lead_coeff p))", "by (fold abs_sgn, auto)"], ["proof (state)\nthis:\n  (p \\<noteq> 0) = (0 < lead_coeff p * sgn (lead_coeff p))\n\ngoal (1 subgoal):\n 1. (0 < lead_coeff (abs_int_poly p)) = (p \\<noteq> 0)", "then"], ["proof (chain)\npicking this:\n  (p \\<noteq> 0) = (0 < lead_coeff p * sgn (lead_coeff p))", "show ?thesis"], ["proof (prove)\nusing this:\n  (p \\<noteq> 0) = (0 < lead_coeff p * sgn (lead_coeff p))\n\ngoal (1 subgoal):\n 1. (0 < lead_coeff (abs_int_poly p)) = (p \\<noteq> 0)", "by (auto simp: abs_int_poly_def mult.commute)"], ["proof (state)\nthis:\n  (0 < lead_coeff (abs_int_poly p)) = (p \\<noteq> 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_int_poly_0[simp]: \"abs_int_poly 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_int_poly 0 = 0", "by (auto simp: abs_int_poly_def)"], ["", "lemma abs_int_poly_eq_0_iff[simp]: \"abs_int_poly p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (abs_int_poly p = 0) = (p = 0)", "by (auto simp: abs_int_poly_def sgn_eq_0_iff)"], ["", "lemma degree_abs_int_poly[simp]: \"degree (abs_int_poly p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (abs_int_poly p) = degree p", "by (auto simp: abs_int_poly_def sgn_eq_0_iff)"], ["", "lemma abs_int_poly_dvd[simp]: \"abs_int_poly p dvd q \\<longleftrightarrow> p dvd q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (abs_int_poly p dvd q) = (p dvd q)", "by (unfold abs_int_poly_def, auto)"], ["", "(*TODO: move & generalize *)"], ["", "lemma (in idom) irreducible_uminus[simp]: \"irreducible (-x) \\<longleftrightarrow> irreducible x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible (- x) = irreducible x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. irreducible (- x) = irreducible x", "have \"-x = -1 * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x = - (1::'a) * x", "by simp"], ["proof (state)\nthis:\n  - x = - (1::'a) * x\n\ngoal (1 subgoal):\n 1. irreducible (- x) = irreducible x", "also"], ["proof (state)\nthis:\n  - x = - (1::'a) * x\n\ngoal (1 subgoal):\n 1. irreducible (- x) = irreducible x", "have \"irreducible ... \\<longleftrightarrow> irreducible x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible (- (1::'a) * x) = irreducible x", "by (rule irreducible_mult_unit_left, auto)"], ["proof (state)\nthis:\n  irreducible (- (1::'a) * x) = irreducible x\n\ngoal (1 subgoal):\n 1. irreducible (- x) = irreducible x", "finally"], ["proof (chain)\npicking this:\n  irreducible (- x) = irreducible x", "show ?thesis"], ["proof (prove)\nusing this:\n  irreducible (- x) = irreducible x\n\ngoal (1 subgoal):\n 1. irreducible (- x) = irreducible x", "."], ["proof (state)\nthis:\n  irreducible (- x) = irreducible x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible_abs_int_poly[simp]:\n  \"irreducible (abs_int_poly p) \\<longleftrightarrow> irreducible p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible (abs_int_poly p) = irreducible p", "by (unfold abs_int_poly_def, auto)"], ["", "lemma coeff_abs_int_poly[simp]:\n  \"coeff (abs_int_poly p) n = (if lead_coeff p < 0 then - coeff p n else coeff p n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (abs_int_poly p) n =\n    (if lead_coeff p < 0 then - coeff p n else coeff p n)", "by (simp add: abs_int_poly_def)"], ["", "lemma lead_coeff_abs_int_poly[simp]:\n  \"lead_coeff (abs_int_poly p) = abs (lead_coeff p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff (abs_int_poly p) = \\<bar>lead_coeff p\\<bar>", "by auto"], ["", "lemma ipoly_abs_int_poly_eq_zero_iff[simp]:\n  \"ipoly (abs_int_poly p) (x :: 'a :: comm_ring_1) = 0 \\<longleftrightarrow> ipoly p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipoly (abs_int_poly p) x = (0::'a)) = (ipoly p x = (0::'a))", "by (auto simp: abs_int_poly_def sgn_eq_0_iff of_int_poly_hom.hom_uminus)"], ["", "lemma abs_int_poly_represents[simp]:\n  \"abs_int_poly p represents x \\<longleftrightarrow> p represents x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_int_poly p represents x = p represents x", "by (auto elim!:representsE)"], ["", "(* TODO: Move *)"], ["", "lemma content_pCons[simp]: \"content (pCons a p) = gcd a (content p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (pCons a p) = gcd a (content p)", "by (unfold content_def coeffs_pCons_eq_cCons cCons_def, auto)"], ["", "lemma content_uminus[simp]:\n  fixes p :: \"'a :: ring_gcd poly\" shows \"content (-p) = content p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (- p) = content p", "by (induct p, auto)"], ["", "lemma primitive_abs_int_poly[simp]:\n  \"primitive (abs_int_poly p) \\<longleftrightarrow> primitive p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive (abs_int_poly p) = primitive p", "by (auto simp: abs_int_poly_def)"], ["", "lemma abs_int_poly_inv[simp]: \"smult (sgn (lead_coeff p)) (abs_int_poly p) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (sgn (lead_coeff p)) (abs_int_poly p) = p", "by (cases \"lead_coeff p > 0\", auto simp: abs_int_poly_def)"], ["", "definition cf_pos :: \"int poly \\<Rightarrow> bool\" where\n  \"cf_pos p = (content p = 1 \\<and> lead_coeff p > 0)\""], ["", "definition cf_pos_poly :: \"int poly \\<Rightarrow> int poly\" where\n  \"cf_pos_poly f = (let\n      c = content f;\n      d = (sgn (lead_coeff f) * c)\n    in sdiv_poly f d)\""], ["", "lemma sgn_is_unit[intro!]:\n  fixes x :: \"'a :: linordered_idom\" (* find/make better class *)\n  assumes \"x \\<noteq> 0\"\n  shows \"sgn x dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn x dvd (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. sgn x dvd (1::'a)", "by(cases x \"0::'a\" rule:linorder_cases, auto)"], ["", "lemma cf_pos_poly_0[simp]: \"cf_pos_poly 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf_pos_poly 0 = 0", "by (unfold cf_pos_poly_def sdiv_poly_def, auto)"], ["", "lemma cf_pos_poly_eq_0[simp]: \"cf_pos_poly f = 0 \\<longleftrightarrow> f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cf_pos_poly f = 0) = (f = 0)", "proof(cases \"f = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)\n 2. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "case True"], ["proof (state)\nthis:\n  f = 0\n\ngoal (2 subgoals):\n 1. f = 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)\n 2. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = 0\n\ngoal (1 subgoal):\n 1. (cf_pos_poly f = 0) = (f = 0)", "unfolding cf_pos_poly_def Let_def"], ["proof (prove)\nusing this:\n  f = 0\n\ngoal (1 subgoal):\n 1. (sdiv_poly f (sgn (lead_coeff f) * content f) = 0) = (f = 0)", "by (simp add: sdiv_poly_def)"], ["proof (state)\nthis:\n  (cf_pos_poly f = 0) = (f = 0)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "case False"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "then"], ["proof (chain)\npicking this:\n  f \\<noteq> 0", "have lc0: \"lead_coeff f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "then"], ["proof (chain)\npicking this:\n  lead_coeff f \\<noteq> 0", "have s0: \"sgn (lead_coeff f) \\<noteq> 0\" (is \"?s \\<noteq> 0\") and \"content f \\<noteq> 0\" (is \"?c \\<noteq> 0\")"], ["proof (prove)\nusing this:\n  lead_coeff f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgn (lead_coeff f) \\<noteq> 0 &&& content f \\<noteq> 0", "by (auto simp: sgn_0_0)"], ["proof (state)\nthis:\n  sgn (lead_coeff f) \\<noteq> 0\n  content f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "then"], ["proof (chain)\npicking this:\n  sgn (lead_coeff f) \\<noteq> 0\n  content f \\<noteq> 0", "have sc0: \"?s * ?c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  sgn (lead_coeff f) \\<noteq> 0\n  content f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgn (lead_coeff f) * content f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  sgn (lead_coeff f) * content f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "{"], ["proof (state)\nthis:\n  sgn (lead_coeff f) * content f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "from content_dvd_coeff sgn_is_unit[OF lc0]"], ["proof (chain)\npicking this:\n  content ?p dvd coeff ?p ?n\n  is_unit (sgn (lead_coeff f))", "have \"?s * ?c dvd coeff f i\""], ["proof (prove)\nusing this:\n  content ?p dvd coeff ?p ?n\n  is_unit (sgn (lead_coeff f))\n\ngoal (1 subgoal):\n 1. sgn (lead_coeff f) * content f dvd coeff f i", "by (auto simp: unit_dvd_iff)"], ["proof (state)\nthis:\n  sgn (lead_coeff f) * content f dvd coeff f i\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "then"], ["proof (chain)\npicking this:\n  sgn (lead_coeff f) * content f dvd coeff f i", "have \"coeff f i div (?s * ?c) = 0 \\<longleftrightarrow> coeff f i = 0\""], ["proof (prove)\nusing this:\n  sgn (lead_coeff f) * content f dvd coeff f i\n\ngoal (1 subgoal):\n 1. (coeff f i div (sgn (lead_coeff f) * content f) = 0) = (coeff f i = 0)", "by (auto simp:dvd_div_eq_0_iff)"], ["proof (state)\nthis:\n  (coeff f i div (sgn (lead_coeff f) * content f) = 0) = (coeff f i = 0)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "}"], ["proof (state)\nthis:\n  (coeff f ?i2 div (sgn (lead_coeff f) * content f) = 0) = (coeff f ?i2 = 0)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "note * = this"], ["proof (state)\nthis:\n  (coeff f ?i2 div (sgn (lead_coeff f) * content f) = 0) = (coeff f ?i2 = 0)\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> (cf_pos_poly f = 0) = (f = 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cf_pos_poly f = 0) = (f = 0)", "unfolding cf_pos_poly_def Let_def sdiv_poly_def poly_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n.\n        coeff\n         (map_poly (\\<lambda>c. c div (sgn (lead_coeff f) * content f)) f)\n         n =\n        coeff 0 n) =\n    (\\<forall>n. coeff f n = coeff 0 n)", "by (auto simp: coeff_map_poly *)"], ["proof (state)\nthis:\n  (cf_pos_poly f = 0) = (f = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  shows cf_pos_poly_main: \"smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\" (is ?g1)\n    and content_cf_pos_poly[simp]: \"content (cf_pos_poly f) = (if f = 0 then 0 else 1)\" (is ?g2)\n    and lead_coeff_cf_pos_poly[simp]: \"lead_coeff (cf_pos_poly f) > 0 \\<longleftrightarrow> f \\<noteq> 0\" (is ?g3)\n    and cf_pos_poly_dvd[simp]: \"cf_pos_poly f dvd f\" (is ?g4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f &&&\n     content (cf_pos_poly f) = (if f = 0 then 0 else 1)) &&&\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0) &&&\n    cf_pos_poly f dvd f", "proof(atomize(full), (cases \"f = 0\"; intro conjI))"], ["proof (state)\ngoal (8 subgoals):\n 1. f = 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f = 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f = 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f = 0 \\<Longrightarrow> cf_pos_poly f dvd f\n 5. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 6. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 7. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 8. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "case True"], ["proof (state)\nthis:\n  f = 0\n\ngoal (8 subgoals):\n 1. f = 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f = 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f = 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f = 0 \\<Longrightarrow> cf_pos_poly f dvd f\n 5. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 6. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 7. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 8. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "then"], ["proof (chain)\npicking this:\n  f = 0", "show ?g1 ?g2 ?g3 ?g4"], ["proof (prove)\nusing this:\n  f = 0\n\ngoal (1 subgoal):\n 1. (smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f &&&\n     content (cf_pos_poly f) = (if f = 0 then 0 else 1)) &&&\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0) &&&\n    cf_pos_poly f dvd f", "by simp_all"], ["proof (state)\nthis:\n  smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n  content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n  (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n  cf_pos_poly f dvd f\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "case f0: False"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "let ?s = \"sgn (lead_coeff f)\""], ["proof (state)\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "have s: \"?s \\<in> {-1,1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (lead_coeff f) \\<in> {- 1, 1}", "using f0"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgn (lead_coeff f) \\<in> {- 1, 1}", "unfolding sgn_if"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if lead_coeff f = 0 then 0 else if 0 < lead_coeff f then 1 else - 1)\n    \\<in> {- 1, 1}", "by auto"], ["proof (state)\nthis:\n  sgn (lead_coeff f) \\<in> {- 1, 1}\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "define g where \"g \\<equiv> smult ?s f\""], ["proof (state)\nthis:\n  g \\<equiv> smult (sgn (lead_coeff f)) f\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "define d where \"d \\<equiv> ?s * content f\""], ["proof (state)\nthis:\n  d \\<equiv> sgn (lead_coeff f) * content f\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "have \"content g = content ([:?s:] * f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content g = content ([:sgn (lead_coeff f):] * f)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. content (smult (sgn (lead_coeff f)) f) =\n    content ([:sgn (lead_coeff f):] * f)", "by simp"], ["proof (state)\nthis:\n  content g = content ([:sgn (lead_coeff f):] * f)\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "also"], ["proof (state)\nthis:\n  content g = content ([:sgn (lead_coeff f):] * f)\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "have \"\\<dots> = content [:?s:] * content f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content ([:sgn (lead_coeff f):] * f) =\n    content [:sgn (lead_coeff f):] * content f", "unfolding content_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. content [:sgn (lead_coeff f):] * content f =\n    content [:sgn (lead_coeff f):] * content f", "by simp"], ["proof (state)\nthis:\n  content ([:sgn (lead_coeff f):] * f) =\n  content [:sgn (lead_coeff f):] * content f\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "also"], ["proof (state)\nthis:\n  content ([:sgn (lead_coeff f):] * f) =\n  content [:sgn (lead_coeff f):] * content f\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "have \"content [:?s:] = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content [:sgn (lead_coeff f):] = 1", "using s"], ["proof (prove)\nusing this:\n  sgn (lead_coeff f) \\<in> {- 1, 1}\n\ngoal (1 subgoal):\n 1. content [:sgn (lead_coeff f):] = 1", "by (auto simp: content_def)"], ["proof (state)\nthis:\n  content [:sgn (lead_coeff f):] = 1\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "finally"], ["proof (chain)\npicking this:\n  content g = 1 * content f", "have cg: \"content g = content f\""], ["proof (prove)\nusing this:\n  content g = 1 * content f\n\ngoal (1 subgoal):\n 1. content g = content f", "by simp"], ["proof (state)\nthis:\n  content g = content f\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "from f0"], ["proof (chain)\npicking this:\n  f \\<noteq> 0", "have d: \"cf_pos_poly f = sdiv_poly f d\""], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cf_pos_poly f = sdiv_poly f d", "by (auto simp: cf_pos_poly_def Let_def d_def)"], ["proof (state)\nthis:\n  cf_pos_poly f = sdiv_poly f d\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "let ?g = \"primitive_part g\""], ["proof (state)\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "define ng where \"ng = primitive_part g\""], ["proof (state)\nthis:\n  ng = primitive_part g\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "note d"], ["proof (state)\nthis:\n  cf_pos_poly f = sdiv_poly f d\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "also"], ["proof (state)\nthis:\n  cf_pos_poly f = sdiv_poly f d\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "have \"sdiv_poly f d = sdiv_poly g (content g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdiv_poly f d = sdiv_poly g (content g)", "unfolding cg"], ["proof (prove)\ngoal (1 subgoal):\n 1. sdiv_poly f d = sdiv_poly g (content f)", "unfolding g_def d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sdiv_poly f (sgn (lead_coeff f) * content f) =\n    sdiv_poly (smult (sgn (lead_coeff f)) f) (content f)", "by (rule poly_eqI, unfold coeff_sdiv_poly coeff_smult, insert s, auto simp: div_minus_right)"], ["proof (state)\nthis:\n  sdiv_poly f d = sdiv_poly g (content g)\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "finally"], ["proof (chain)\npicking this:\n  cf_pos_poly f = sdiv_poly g (content g)", "have fg: \"cf_pos_poly f = primitive_part g\""], ["proof (prove)\nusing this:\n  cf_pos_poly f = sdiv_poly g (content g)\n\ngoal (1 subgoal):\n 1. cf_pos_poly f = primitive_part g", "unfolding primitive_part_alt_def"], ["proof (prove)\nusing this:\n  cf_pos_poly f = sdiv_poly g (content g)\n\ngoal (1 subgoal):\n 1. cf_pos_poly f = sdiv_poly g (content g)", "."], ["proof (state)\nthis:\n  cf_pos_poly f = primitive_part g\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "have \"lead_coeff f \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lead_coeff f \\<noteq> 0", "using f0"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lead_coeff f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lead_coeff f \\<noteq> 0\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "hence lg: \"lead_coeff g > 0\""], ["proof (prove)\nusing this:\n  lead_coeff f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff g", "unfolding g_def lead_coeff_smult"], ["proof (prove)\nusing this:\n  lead_coeff f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < sgn (lead_coeff f) * lead_coeff f", "by (meson linorder_neqE_linordered_idom sgn_greater sgn_less zero_less_mult_iff)"], ["proof (state)\nthis:\n  0 < lead_coeff g\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "hence g0: \"g \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < lead_coeff g\n\ngoal (1 subgoal):\n 1. g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (4 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n 3. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 4. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "from f0 content_primitive_part[OF this]"], ["proof (chain)\npicking this:\n  f \\<noteq> 0\n  content (primitive_part g) = 1", "show ?g2"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  content (primitive_part g) = 1\n\ngoal (1 subgoal):\n 1. content (cf_pos_poly f) = (if f = 0 then 0 else 1)", "unfolding fg"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  content (primitive_part g) = 1\n\ngoal (1 subgoal):\n 1. content (primitive_part g) = (if f = 0 then 0 else 1)", "by auto"], ["proof (state)\nthis:\n  content (cf_pos_poly f) = (if f = 0 then 0 else 1)\n\ngoal (3 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 3. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "from g0"], ["proof (chain)\npicking this:\n  g \\<noteq> 0", "have \"content g \\<noteq> 0\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. content g \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  content g \\<noteq> 0\n\ngoal (3 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 3. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "with arg_cong[OF content_times_primitive_part[of g], of lead_coeff, unfolded lead_coeff_smult]\n    lg content_ge_0_int[of g]"], ["proof (chain)\npicking this:\n  content g * lead_coeff (primitive_part g) = lead_coeff g\n  0 < lead_coeff g\n  0 \\<le> content g\n  content g \\<noteq> 0", "have lg': \"lead_coeff ng > 0\""], ["proof (prove)\nusing this:\n  content g * lead_coeff (primitive_part g) = lead_coeff g\n  0 < lead_coeff g\n  0 \\<le> content g\n  content g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff ng", "unfolding ng_def"], ["proof (prove)\nusing this:\n  content g * lead_coeff (primitive_part g) = lead_coeff g\n  0 < lead_coeff g\n  0 \\<le> content g\n  content g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff (primitive_part g)", "by (metis dual_order.antisym dual_order.strict_implies_order zero_less_mult_iff)"], ["proof (state)\nthis:\n  0 < lead_coeff ng\n\ngoal (3 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow>\n    (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n 3. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "with f0"], ["proof (chain)\npicking this:\n  f \\<noteq> 0\n  0 < lead_coeff ng", "show ?g3"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  0 < lead_coeff ng\n\ngoal (1 subgoal):\n 1. (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)", "unfolding fg ng_def"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  0 < lead_coeff (primitive_part g)\n\ngoal (1 subgoal):\n 1. (0 < lead_coeff (primitive_part g)) = (f \\<noteq> 0)", "by auto"], ["proof (state)\nthis:\n  (0 < lead_coeff (cf_pos_poly f)) = (f \\<noteq> 0)\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "have d0: \"d \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "using s f0"], ["proof (prove)\nusing this:\n  sgn (lead_coeff f) \\<in> {- 1, 1}\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "by (force simp add: d_def)"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "have \"smult d (cf_pos_poly f) = smult ?s (smult (content f) (sdiv_poly (smult ?s f) (content f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult d (cf_pos_poly f) =\n    smult (sgn (lead_coeff f))\n     (smult (content f)\n       (sdiv_poly (smult (sgn (lead_coeff f)) f) (content f)))", "unfolding fg primitive_part_alt_def cg"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult d (sdiv_poly g (content f)) =\n    smult (sgn (lead_coeff f))\n     (smult (content f)\n       (sdiv_poly (smult (sgn (lead_coeff f)) f) (content f)))", "by (simp add: g_def d_def)"], ["proof (state)\nthis:\n  smult d (cf_pos_poly f) =\n  smult (sgn (lead_coeff f))\n   (smult (content f)\n     (sdiv_poly (smult (sgn (lead_coeff f)) f) (content f)))\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "also"], ["proof (state)\nthis:\n  smult d (cf_pos_poly f) =\n  smult (sgn (lead_coeff f))\n   (smult (content f)\n     (sdiv_poly (smult (sgn (lead_coeff f)) f) (content f)))\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "have \"sdiv_poly (smult ?s f) (content f) = smult ?s (sdiv_poly f (content f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdiv_poly (smult (sgn (lead_coeff f)) f) (content f) =\n    smult (sgn (lead_coeff f)) (sdiv_poly f (content f))", "using s"], ["proof (prove)\nusing this:\n  sgn (lead_coeff f) \\<in> {- 1, 1}\n\ngoal (1 subgoal):\n 1. sdiv_poly (smult (sgn (lead_coeff f)) f) (content f) =\n    smult (sgn (lead_coeff f)) (sdiv_poly f (content f))", "by (metis cg g_def primitive_part_alt_def primitive_part_smult_int sgn_sgn)"], ["proof (state)\nthis:\n  sdiv_poly (smult (sgn (lead_coeff f)) f) (content f) =\n  smult (sgn (lead_coeff f)) (sdiv_poly f (content f))\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "finally"], ["proof (chain)\npicking this:\n  smult d (cf_pos_poly f) =\n  smult (sgn (lead_coeff f))\n   (smult (content f)\n     (smult (sgn (lead_coeff f)) (sdiv_poly f (content f))))", "have \"smult d (cf_pos_poly f) = smult (content f) (primitive_part f)\""], ["proof (prove)\nusing this:\n  smult d (cf_pos_poly f) =\n  smult (sgn (lead_coeff f))\n   (smult (content f)\n     (smult (sgn (lead_coeff f)) (sdiv_poly f (content f))))\n\ngoal (1 subgoal):\n 1. smult d (cf_pos_poly f) = smult (content f) (primitive_part f)", "unfolding primitive_part_alt_def"], ["proof (prove)\nusing this:\n  smult d (cf_pos_poly f) =\n  smult (sgn (lead_coeff f))\n   (smult (content f)\n     (smult (sgn (lead_coeff f)) (sdiv_poly f (content f))))\n\ngoal (1 subgoal):\n 1. smult d (cf_pos_poly f) = smult (content f) (sdiv_poly f (content f))", "using s"], ["proof (prove)\nusing this:\n  smult d (cf_pos_poly f) =\n  smult (sgn (lead_coeff f))\n   (smult (content f)\n     (smult (sgn (lead_coeff f)) (sdiv_poly f (content f))))\n  sgn (lead_coeff f) \\<in> {- 1, 1}\n\ngoal (1 subgoal):\n 1. smult d (cf_pos_poly f) = smult (content f) (sdiv_poly f (content f))", "by auto"], ["proof (state)\nthis:\n  smult d (cf_pos_poly f) = smult (content f) (primitive_part f)\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "also"], ["proof (state)\nthis:\n  smult d (cf_pos_poly f) = smult (content f) (primitive_part f)\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "have \"\\<dots> = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (content f) (primitive_part f) = f", "by (rule content_times_primitive_part)"], ["proof (state)\nthis:\n  smult (content f) (primitive_part f) = f\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "finally"], ["proof (chain)\npicking this:\n  smult d (cf_pos_poly f) = f", "have df: \"smult d (cf_pos_poly f) = f\""], ["proof (prove)\nusing this:\n  smult d (cf_pos_poly f) = f\n\ngoal (1 subgoal):\n 1. smult d (cf_pos_poly f) = f", "."], ["proof (state)\nthis:\n  smult d (cf_pos_poly f) = f\n\ngoal (2 subgoals):\n 1. f \\<noteq> 0 \\<Longrightarrow>\n    smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n 2. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "with d0"], ["proof (chain)\npicking this:\n  d \\<noteq> 0\n  smult d (cf_pos_poly f) = f", "show ?g1"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n  smult d (cf_pos_poly f) = f\n\ngoal (1 subgoal):\n 1. smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f", "by (auto simp: d_def)"], ["proof (state)\nthis:\n  smult (sgn (lead_coeff f) * content f) (cf_pos_poly f) = f\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "from df"], ["proof (chain)\npicking this:\n  smult d (cf_pos_poly f) = f", "have *: \"f = cf_pos_poly f * [:d:]\""], ["proof (prove)\nusing this:\n  smult d (cf_pos_poly f) = f\n\ngoal (1 subgoal):\n 1. f = cf_pos_poly f * [:d:]", "by simp"], ["proof (state)\nthis:\n  f = cf_pos_poly f * [:d:]\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f dvd f", "from dvdI[OF this]"], ["proof (chain)\npicking this:\n  cf_pos_poly f dvd f", "show ?g4"], ["proof (prove)\nusing this:\n  cf_pos_poly f dvd f\n\ngoal (1 subgoal):\n 1. cf_pos_poly f dvd f", "."], ["proof (state)\nthis:\n  cf_pos_poly f dvd f\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: remove *)"], ["", "lemma irreducible_connect_int:\n  fixes p :: \"int poly\"\n  assumes ir: \"irreducible\\<^sub>d p\" and c: \"content p = 1\"\n  shows \"irreducible p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible p", "using c primitive_iff_content_eq_1 ir irreducible_primitive_connect"], ["proof (prove)\nusing this:\n  content p = 1\n  primitive ?f = (content ?f = (1::?'a))\n  irreducible\\<^sub>d p\n  primitive ?f \\<Longrightarrow> irreducible\\<^sub>d ?f = irreducible ?f\n\ngoal (1 subgoal):\n 1. irreducible p", "by blast"], ["", "lemma\n  fixes x :: \"'a :: {idom,ring_char_0}\"\n  shows ipoly_cf_pos_poly_eq_0[simp]: \"ipoly (cf_pos_poly p) x = 0 \\<longleftrightarrow> ipoly p x = 0\"\n    and degree_cf_pos_poly[simp]: \"degree (cf_pos_poly p) = degree p\"\n    and cf_pos_cf_pos_poly[intro]: \"p \\<noteq> 0 \\<Longrightarrow> cf_pos (cf_pos_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a)) &&&\n    degree (cf_pos_poly p) = degree p &&&\n    (p \\<noteq> 0 \\<Longrightarrow> cf_pos (cf_pos_poly p))", "proof-"], ["proof (state)\ngoal (3 subgoals):\n 1. (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))\n 2. degree (cf_pos_poly p) = degree p\n 3. p \\<noteq> 0 \\<Longrightarrow> cf_pos (cf_pos_poly p)", "show \"degree (cf_pos_poly p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (cf_pos_poly p) = degree p", "by (subst(3) cf_pos_poly_main[symmetric], auto simp:sgn_eq_0_iff)"], ["proof (state)\nthis:\n  degree (cf_pos_poly p) = degree p\n\ngoal (2 subgoals):\n 1. (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))\n 2. p \\<noteq> 0 \\<Longrightarrow> cf_pos (cf_pos_poly p)", "{"], ["proof (state)\nthis:\n  degree (cf_pos_poly p) = degree p\n\ngoal (2 subgoals):\n 1. (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))\n 2. p \\<noteq> 0 \\<Longrightarrow> cf_pos (cf_pos_poly p)", "assume p: \"p \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))\n 2. p \\<noteq> 0 \\<Longrightarrow> cf_pos (cf_pos_poly p)", "show \"cf_pos (cf_pos_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf_pos (cf_pos_poly p)", "using cf_pos_poly_main p"], ["proof (prove)\nusing this:\n  smult (sgn (lead_coeff ?f) * content ?f) (cf_pos_poly ?f) = ?f\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cf_pos (cf_pos_poly p)", "by (auto simp: cf_pos_def)"], ["proof (state)\nthis:\n  cf_pos (cf_pos_poly p)\n\ngoal (1 subgoal):\n 1. (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))", "have \"(ipoly (cf_pos_poly p) x = 0) = (ipoly p x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))", "apply (subst(3) cf_pos_poly_main[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipoly (cf_pos_poly p) x = (0::'a)) =\n    (ipoly (smult (sgn (lead_coeff p) * content p) (cf_pos_poly p)) x =\n     (0::'a))", "by (auto simp: sgn_eq_0_iff hom_distribs)"], ["proof (state)\nthis:\n  (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))\n\ngoal (1 subgoal):\n 1. (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))", "}"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow>\n  (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))\n\ngoal (1 subgoal):\n 1. (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))", "show \"(ipoly (cf_pos_poly p) x = 0) = (ipoly p x = 0)\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<Longrightarrow>\n  (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))\n\ngoal (1 subgoal):\n 1. (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))", "by (cases \"p = 0\", auto)"], ["proof (state)\nthis:\n  (ipoly (cf_pos_poly p) x = (0::'a)) = (ipoly p x = (0::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cf_pos_poly_eq_1: \"cf_pos_poly f = 1 \\<longleftrightarrow> degree f = 0 \\<and> f \\<noteq> 0\" (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cf_pos_poly f = 1) = (degree f = 0 \\<and> f \\<noteq> 0)", "proof(intro iffI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. cf_pos_poly f = 1 \\<Longrightarrow> degree f = 0\n 2. cf_pos_poly f = 1 \\<Longrightarrow> f \\<noteq> 0\n 3. degree f = 0 \\<and> f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f = 1", "assume ?r"], ["proof (state)\nthis:\n  degree f = 0 \\<and> f \\<noteq> 0\n\ngoal (3 subgoals):\n 1. cf_pos_poly f = 1 \\<Longrightarrow> degree f = 0\n 2. cf_pos_poly f = 1 \\<Longrightarrow> f \\<noteq> 0\n 3. degree f = 0 \\<and> f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f = 1", "then"], ["proof (chain)\npicking this:\n  degree f = 0 \\<and> f \\<noteq> 0", "have df0: \"degree f = 0\" and f0: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree f = 0 \\<and> f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree f = 0 &&& f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  degree f = 0\n  f \\<noteq> 0\n\ngoal (3 subgoals):\n 1. cf_pos_poly f = 1 \\<Longrightarrow> degree f = 0\n 2. cf_pos_poly f = 1 \\<Longrightarrow> f \\<noteq> 0\n 3. degree f = 0 \\<and> f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f = 1", "from  degree0_coeffs[OF df0]"], ["proof (chain)\npicking this:\n  \\<exists>a. f = [:a:]", "obtain f0 where f: \"f = [:f0:]\""], ["proof (prove)\nusing this:\n  \\<exists>a. f = [:a:]\n\ngoal (1 subgoal):\n 1. (\\<And>f0. f = [:f0:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  f = [:f0:]\n\ngoal (3 subgoals):\n 1. cf_pos_poly f = 1 \\<Longrightarrow> degree f = 0\n 2. cf_pos_poly f = 1 \\<Longrightarrow> f \\<noteq> 0\n 3. degree f = 0 \\<and> f \\<noteq> 0 \\<Longrightarrow> cf_pos_poly f = 1", "show \"cf_pos_poly f = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf_pos_poly f = 1", "using f0"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cf_pos_poly f = 1", "unfolding f cf_pos_poly_def Let_def sdiv_poly_def"], ["proof (prove)\nusing this:\n  [:f0:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>c. c div (sgn (lead_coeff [:f0:]) * content [:f0:]))\n     [:f0:] =\n    1", "by (auto simp: content_def mult_sgn_abs)"], ["proof (state)\nthis:\n  cf_pos_poly f = 1\n\ngoal (2 subgoals):\n 1. cf_pos_poly f = 1 \\<Longrightarrow> degree f = 0\n 2. cf_pos_poly f = 1 \\<Longrightarrow> f \\<noteq> 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. cf_pos_poly f = 1 \\<Longrightarrow> degree f = 0\n 2. cf_pos_poly f = 1 \\<Longrightarrow> f \\<noteq> 0", "assume l: ?l"], ["proof (state)\nthis:\n  cf_pos_poly f = 1\n\ngoal (2 subgoals):\n 1. cf_pos_poly f = 1 \\<Longrightarrow> degree f = 0\n 2. cf_pos_poly f = 1 \\<Longrightarrow> f \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  cf_pos_poly f = 1", "have \"degree (cf_pos_poly f) = 0\""], ["proof (prove)\nusing this:\n  cf_pos_poly f = 1\n\ngoal (1 subgoal):\n 1. degree (cf_pos_poly f) = 0", "by auto"], ["proof (state)\nthis:\n  degree (cf_pos_poly f) = 0\n\ngoal (2 subgoals):\n 1. cf_pos_poly f = 1 \\<Longrightarrow> degree f = 0\n 2. cf_pos_poly f = 1 \\<Longrightarrow> f \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  degree (cf_pos_poly f) = 0", "show \"degree f = 0\""], ["proof (prove)\nusing this:\n  degree (cf_pos_poly f) = 0\n\ngoal (1 subgoal):\n 1. degree f = 0", "by simp"], ["proof (state)\nthis:\n  degree f = 0\n\ngoal (1 subgoal):\n 1. cf_pos_poly f = 1 \\<Longrightarrow> f \\<noteq> 0", "from l"], ["proof (chain)\npicking this:\n  cf_pos_poly f = 1", "have \"cf_pos_poly f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  cf_pos_poly f = 1\n\ngoal (1 subgoal):\n 1. cf_pos_poly f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  cf_pos_poly f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cf_pos_poly f = 1 \\<Longrightarrow> f \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  cf_pos_poly f \\<noteq> 0", "show \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  cf_pos_poly f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irr_cf_poly_rat[simp]: \"irreducible (poly_rat x)\"\n  \"lead_coeff (poly_rat x) > 0\" \"primitive (poly_rat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible (poly_rat x) &&&\n    0 < lead_coeff (poly_rat x) &&& primitive (poly_rat x)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. irreducible (poly_rat x)\n 2. 0 < lead_coeff (poly_rat x)\n 3. primitive (poly_rat x)", "obtain n d where x: \"quotient_of x = (n,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n d.\n        quotient_of x = (n, d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of x = (n, d)\n\ngoal (3 subgoals):\n 1. irreducible (poly_rat x)\n 2. 0 < lead_coeff (poly_rat x)\n 3. primitive (poly_rat x)", "hence id: \"poly_rat x = [:-n,d:]\""], ["proof (prove)\nusing this:\n  quotient_of x = (n, d)\n\ngoal (1 subgoal):\n 1. poly_rat x = [:- n, d:]", "by (auto simp: poly_rat_def)"], ["proof (state)\nthis:\n  poly_rat x = [:- n, d:]\n\ngoal (3 subgoals):\n 1. irreducible (poly_rat x)\n 2. 0 < lead_coeff (poly_rat x)\n 3. primitive (poly_rat x)", "from quotient_of_denom_pos[OF x]"], ["proof (chain)\npicking this:\n  0 < d", "have d: \"d > 0\""], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. 0 < d", "by auto"], ["proof (state)\nthis:\n  0 < d\n\ngoal (3 subgoals):\n 1. irreducible (poly_rat x)\n 2. 0 < lead_coeff (poly_rat x)\n 3. primitive (poly_rat x)", "show \"lead_coeff (poly_rat x) > 0\" \"primitive (poly_rat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lead_coeff (poly_rat x) &&& primitive (poly_rat x)", "unfolding id cf_pos_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lead_coeff [:- n, d:] &&& primitive [:- n, d:]", "using d quotient_of_coprime[OF x]"], ["proof (prove)\nusing this:\n  0 < d\n  algebraic_semidom_class.coprime n d\n\ngoal (1 subgoal):\n 1. 0 < lead_coeff [:- n, d:] &&& primitive [:- n, d:]", "by (auto simp: content_def)"], ["proof (state)\nthis:\n  0 < lead_coeff (poly_rat x)\n  primitive (poly_rat x)\n\ngoal (1 subgoal):\n 1. irreducible (poly_rat x)", "from this[unfolded cf_pos_def]"], ["proof (chain)\npicking this:\n  0 < lead_coeff (poly_rat x)\n  primitive (poly_rat x)", "show irr: \"irreducible (poly_rat x)\""], ["proof (prove)\nusing this:\n  0 < lead_coeff (poly_rat x)\n  primitive (poly_rat x)\n\ngoal (1 subgoal):\n 1. irreducible (poly_rat x)", "unfolding id"], ["proof (prove)\nusing this:\n  0 < lead_coeff [:- n, d:]\n  primitive [:- n, d:]\n\ngoal (1 subgoal):\n 1. irreducible [:- n, d:]", "using d"], ["proof (prove)\nusing this:\n  0 < lead_coeff [:- n, d:]\n  primitive [:- n, d:]\n  0 < d\n\ngoal (1 subgoal):\n 1. irreducible [:- n, d:]", "by (auto intro!: linear_irreducible_int)"], ["proof (state)\nthis:\n  irreducible (poly_rat x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_rat[simp]: \"ipoly (poly_rat x) (of_rat x :: 'a :: field_char_0) = 0\" \"ipoly (poly_rat x) x = 0\"\n  \"poly_rat x \\<noteq> 0\" \"ipoly (poly_rat x) y = 0 \\<longleftrightarrow> y = (of_rat x :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipoly (poly_rat x) (of_rat x) = (0::'a) &&&\n     ipoly (poly_rat x) x = 0) &&&\n    poly_rat x \\<noteq> 0 &&&\n    (ipoly (poly_rat x) y = (0::'a)) = (y = of_rat x)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. ipoly (poly_rat x) (of_rat x) = (0::'a)\n 2. ipoly (poly_rat x) x = 0\n 3. poly_rat x \\<noteq> 0\n 4. (ipoly (poly_rat x) y = (0::'a)) = (y = of_rat x)", "from irr_cf_poly_rat(1)[of x]"], ["proof (chain)\npicking this:\n  irreducible (poly_rat x)", "show \"poly_rat x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  irreducible (poly_rat x)\n\ngoal (1 subgoal):\n 1. poly_rat x \\<noteq> 0", "unfolding Factorial_Ring.irreducible_def"], ["proof (prove)\nusing this:\n  poly_rat x \\<noteq> 0 \\<and>\n  \\<not> is_unit (poly_rat x) \\<and>\n  (\\<forall>a b.\n      poly_rat x = a * b \\<longrightarrow> is_unit a \\<or> is_unit b)\n\ngoal (1 subgoal):\n 1. poly_rat x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  poly_rat x \\<noteq> 0\n\ngoal (3 subgoals):\n 1. ipoly (poly_rat x) (of_rat x) = (0::'a)\n 2. ipoly (poly_rat x) x = 0\n 3. (ipoly (poly_rat x) y = (0::'a)) = (y = of_rat x)", "obtain n d where x: \"quotient_of x = (n,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n d.\n        quotient_of x = (n, d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of x = (n, d)\n\ngoal (3 subgoals):\n 1. ipoly (poly_rat x) (of_rat x) = (0::'a)\n 2. ipoly (poly_rat x) x = 0\n 3. (ipoly (poly_rat x) y = (0::'a)) = (y = of_rat x)", "hence id: \"poly_rat x = [:-n,d:]\""], ["proof (prove)\nusing this:\n  quotient_of x = (n, d)\n\ngoal (1 subgoal):\n 1. poly_rat x = [:- n, d:]", "by (auto simp: poly_rat_def)"], ["proof (state)\nthis:\n  poly_rat x = [:- n, d:]\n\ngoal (3 subgoals):\n 1. ipoly (poly_rat x) (of_rat x) = (0::'a)\n 2. ipoly (poly_rat x) x = 0\n 3. (ipoly (poly_rat x) y = (0::'a)) = (y = of_rat x)", "from quotient_of_denom_pos[OF x]"], ["proof (chain)\npicking this:\n  0 < d", "have d: \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (3 subgoals):\n 1. ipoly (poly_rat x) (of_rat x) = (0::'a)\n 2. ipoly (poly_rat x) x = 0\n 3. (ipoly (poly_rat x) y = (0::'a)) = (y = of_rat x)", "have \"y * of_int d = of_int n \\<Longrightarrow> y = of_int n / of_int d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * of_int d = of_int n \\<Longrightarrow> y = of_int n / of_int d", "using d"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y * of_int d = of_int n \\<Longrightarrow> y = of_int n / of_int d", "by (simp add: eq_divide_imp)"], ["proof (state)\nthis:\n  y * of_int d = of_int n \\<Longrightarrow> y = of_int n / of_int d\n\ngoal (3 subgoals):\n 1. ipoly (poly_rat x) (of_rat x) = (0::'a)\n 2. ipoly (poly_rat x) x = 0\n 3. (ipoly (poly_rat x) y = (0::'a)) = (y = of_rat x)", "with d id"], ["proof (chain)\npicking this:\n  d \\<noteq> 0\n  poly_rat x = [:- n, d:]\n  y * of_int d = of_int n \\<Longrightarrow> y = of_int n / of_int d", "show \"ipoly (poly_rat x) (of_rat x) = 0\" \"ipoly (poly_rat x) x = 0\"\n    \"ipoly (poly_rat x) y = 0 \\<longleftrightarrow> y = (of_rat x :: 'a)\""], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n  poly_rat x = [:- n, d:]\n  y * of_int d = of_int n \\<Longrightarrow> y = of_int n / of_int d\n\ngoal (1 subgoal):\n 1. ipoly (poly_rat x) (of_rat x) = (0::'b) &&&\n    ipoly (poly_rat x) x = 0 &&&\n    (ipoly (poly_rat x) y = (0::'a)) = (y = of_rat x)", "by (auto simp: of_rat_minus of_rat_divide simp: quotient_of_div[OF x])"], ["proof (state)\nthis:\n  ipoly (poly_rat x) (of_rat x) = (0::?'b)\n  ipoly (poly_rat x) x = 0\n  (ipoly (poly_rat x) y = (0::'a)) = (y = of_rat x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_rat_represents_of_rat: \"(poly_rat x) represents (of_rat x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_rat x represents of_rat x", "by auto"], ["", "lemma ipoly_smult_0_iff: assumes c: \"c \\<noteq> 0\"\n  shows \"(ipoly (smult c p) x = (0 :: real)) = (ipoly p x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (real_of_int_poly (smult c p)) x = 0) =\n    (poly (real_of_int_poly p) x = 0)", "using c"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (poly (real_of_int_poly (smult c p)) x = 0) =\n    (poly (real_of_int_poly p) x = 0)", "by (simp add: hom_distribs)"], ["", "(* TODO *)"], ["", "lemma not_irreducibleD:\n  assumes \"\\<not> irreducible x\" and \"x \\<noteq> 0\" and \"\\<not> x dvd 1\"\n  shows \"\\<exists>y z. x = y * z \\<and> \\<not> y dvd 1 \\<and> \\<not> z dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y z.\n       x = y * z \\<and> \\<not> y dvd (1::'a) \\<and> \\<not> z dvd (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> irreducible x\n  x \\<noteq> (0::'a)\n  \\<not> x dvd (1::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>y z.\n       x = y * z \\<and> \\<not> y dvd (1::'a) \\<and> \\<not> z dvd (1::'a)", "apply (unfold Factorial_Ring.irreducible_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (x \\<noteq> (0::'a) \\<and>\n                     \\<not> x dvd (1::'a) \\<and>\n                     (\\<forall>a b.\n                         x = a * b \\<longrightarrow>\n                         a dvd (1::'a) \\<or> b dvd (1::'a)));\n     x \\<noteq> (0::'a); \\<not> x dvd (1::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y z.\n                         x = y * z \\<and>\n                         \\<not> y dvd (1::'a) \\<and> \\<not> z dvd (1::'a)", "by auto"], ["", "lemma cf_pos_poly_represents[simp]: \"(cf_pos_poly p) represents x \\<longleftrightarrow> p represents x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf_pos_poly p represents x = p represents x", "unfolding represents_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipoly (cf_pos_poly p) x = (0::'a) \\<and> cf_pos_poly p \\<noteq> 0) =\n    (ipoly p x = (0::'a) \\<and> p \\<noteq> 0)", "by auto"], ["", "lemma coprime_prod: (* TODO: move *)\n  \"a \\<noteq> 0 \\<Longrightarrow> c \\<noteq> 0 \\<Longrightarrow> coprime (a * b) (c * d) \\<Longrightarrow> coprime b (d::'a::{semiring_gcd})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> (0::'a); c \\<noteq> (0::'a);\n     comm_monoid_mult_class.coprime (a * b) (c * d)\\<rbrakk>\n    \\<Longrightarrow> comm_monoid_mult_class.coprime b d", "by auto"], ["", "lemma smult_prod: (* TODO: move or find corresponding lemma *)\n  \"smult a b = monom a 0 * b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult a b = monom a 0 * b", "by (simp add: monom_0)"], ["", "lemma degree_map_poly_2:\n  assumes \"f (lead_coeff p) \\<noteq> 0\"\n  shows   \"degree (map_poly f p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (map_poly f p) = degree p", "proof (cases \"p=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> degree (map_poly f p) = degree p\n 2. p \\<noteq> 0 \\<Longrightarrow> degree (map_poly f p) = degree p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> degree (map_poly f p) = degree p\n 2. p \\<noteq> 0 \\<Longrightarrow> degree (map_poly f p) = degree p", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (map_poly f p) = degree p", "unfolding degree_eq_length_coeffs Polynomial.coeffs_map_poly"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length (strip_while ((=) (0::'a)) (map f (coeffs p))) - 1 =\n    length (coeffs p) - 1", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  f (lead_coeff p) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. length (strip_while ((=) (0::'a)) (map f (coeffs p))) - 1 =\n    length (coeffs p) - 1", "by (simp add:coeffs_def)"], ["proof (state)\nthis:\n  degree (map_poly f p) = degree p\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> degree (map_poly f p) = degree p", "qed auto"], ["", "lemma irreducible_cf_pos_poly:\n  assumes irr: \"irreducible p\" and deg: \"degree p \\<noteq> 0\"\n  shows \"irreducible (cf_pos_poly p)\" (is \"irreducible ?p\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible (cf_pos_poly p)", "proof (unfold irreducible_altdef, intro conjI allI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. cf_pos_poly p \\<noteq> 0\n 2. \\<not> is_unit (cf_pos_poly p)\n 3. \\<And>b.\n       b dvd cf_pos_poly p \\<Longrightarrow>\n       cf_pos_poly p dvd b \\<or> is_unit b", "from irr"], ["proof (chain)\npicking this:\n  irreducible p", "show \"?p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  irreducible p\n\ngoal (1 subgoal):\n 1. cf_pos_poly p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  cf_pos_poly p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<not> is_unit (cf_pos_poly p)\n 2. \\<And>b.\n       b dvd cf_pos_poly p \\<Longrightarrow>\n       cf_pos_poly p dvd b \\<or> is_unit b", "from deg"], ["proof (chain)\npicking this:\n  degree p \\<noteq> 0", "have \"degree ?p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (cf_pos_poly p) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  degree (cf_pos_poly p) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<not> is_unit (cf_pos_poly p)\n 2. \\<And>b.\n       b dvd cf_pos_poly p \\<Longrightarrow>\n       cf_pos_poly p dvd b \\<or> is_unit b", "then"], ["proof (chain)\npicking this:\n  degree (cf_pos_poly p) \\<noteq> 0", "show \"\\<not> ?p dvd 1\""], ["proof (prove)\nusing this:\n  degree (cf_pos_poly p) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> is_unit (cf_pos_poly p)", "unfolding poly_dvd_1"], ["proof (prove)\nusing this:\n  degree (cf_pos_poly p) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (degree (cf_pos_poly p) = 0 \\<and>\n            is_unit (coeff (cf_pos_poly p) 0))", "by auto"], ["proof (state)\nthis:\n  \\<not> is_unit (cf_pos_poly p)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b dvd cf_pos_poly p \\<Longrightarrow>\n       cf_pos_poly p dvd b \\<or> is_unit b", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b dvd cf_pos_poly p \\<Longrightarrow>\n       cf_pos_poly p dvd b \\<or> is_unit b", "assume \"b dvd cf_pos_poly p\""], ["proof (state)\nthis:\n  b dvd cf_pos_poly p\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b dvd cf_pos_poly p \\<Longrightarrow>\n       cf_pos_poly p dvd b \\<or> is_unit b", "also"], ["proof (state)\nthis:\n  b dvd cf_pos_poly p\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b dvd cf_pos_poly p \\<Longrightarrow>\n       cf_pos_poly p dvd b \\<or> is_unit b", "note cf_pos_poly_dvd"], ["proof (state)\nthis:\n  cf_pos_poly ?f dvd ?f\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b dvd cf_pos_poly p \\<Longrightarrow>\n       cf_pos_poly p dvd b \\<or> is_unit b", "finally"], ["proof (chain)\npicking this:\n  b dvd p", "have \"b dvd p\""], ["proof (prove)\nusing this:\n  b dvd p\n\ngoal (1 subgoal):\n 1. b dvd p", "."], ["proof (state)\nthis:\n  b dvd p\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b dvd cf_pos_poly p \\<Longrightarrow>\n       cf_pos_poly p dvd b \\<or> is_unit b", "with irr[unfolded irreducible_altdef]"], ["proof (chain)\npicking this:\n  p \\<noteq> 0 \\<and>\n  \\<not> is_unit p \\<and>\n  (\\<forall>b. b dvd p \\<longrightarrow> p dvd b \\<or> is_unit b)\n  b dvd p", "have \"p dvd b \\<or> b dvd 1\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0 \\<and>\n  \\<not> is_unit p \\<and>\n  (\\<forall>b. b dvd p \\<longrightarrow> p dvd b \\<or> is_unit b)\n  b dvd p\n\ngoal (1 subgoal):\n 1. p dvd b \\<or> is_unit b", "by auto"], ["proof (state)\nthis:\n  p dvd b \\<or> is_unit b\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b dvd cf_pos_poly p \\<Longrightarrow>\n       cf_pos_poly p dvd b \\<or> is_unit b", "then"], ["proof (chain)\npicking this:\n  p dvd b \\<or> is_unit b", "show \"?p dvd b \\<or> b dvd 1\""], ["proof (prove)\nusing this:\n  p dvd b \\<or> is_unit b\n\ngoal (1 subgoal):\n 1. cf_pos_poly p dvd b \\<or> is_unit b", "by (auto dest: dvd_trans[OF cf_pos_poly_dvd])"], ["proof (state)\nthis:\n  cf_pos_poly p dvd b \\<or> is_unit b\n\ngoal:\nNo subgoals!", "qed"], ["", "locale dvd_preserving_hom = comm_semiring_1_hom +\n  assumes hom_eq_mult_hom_imp: \"hom x = hom y * hz \\<Longrightarrow> \\<exists>z. hz = hom z \\<and> x = y * z\"\nbegin"], ["", "lemma hom_dvd_hom_iff[simp]: \"hom x dvd hom y \\<longleftrightarrow> x dvd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hom x dvd hom y) = (x dvd y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. hom x dvd hom y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> hom x dvd hom y", "assume \"hom x dvd hom y\""], ["proof (state)\nthis:\n  hom x dvd hom y\n\ngoal (2 subgoals):\n 1. hom x dvd hom y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> hom x dvd hom y", "then"], ["proof (chain)\npicking this:\n  hom x dvd hom y", "obtain hz where \"hom y = hom x * hz\""], ["proof (prove)\nusing this:\n  hom x dvd hom y\n\ngoal (1 subgoal):\n 1. (\\<And>hz.\n        hom y = hom x * hz \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE)"], ["proof (state)\nthis:\n  hom y = hom x * hz\n\ngoal (2 subgoals):\n 1. hom x dvd hom y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> hom x dvd hom y", "from hom_eq_mult_hom_imp[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>z. hz = hom z \\<and> y = x * z", "obtain z\n    where \"hz = hom z\" and mult: \"y = x * z\""], ["proof (prove)\nusing this:\n  \\<exists>z. hz = hom z \\<and> y = x * z\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>hz = hom z; y = x * z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  hz = hom z\n  y = x * z\n\ngoal (2 subgoals):\n 1. hom x dvd hom y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> hom x dvd hom y", "then"], ["proof (chain)\npicking this:\n  hz = hom z\n  y = x * z", "show \"x dvd y\""], ["proof (prove)\nusing this:\n  hz = hom z\n  y = x * z\n\ngoal (1 subgoal):\n 1. x dvd y", "by auto"], ["proof (state)\nthis:\n  x dvd y\n\ngoal (1 subgoal):\n 1. x dvd y \\<Longrightarrow> hom x dvd hom y", "qed auto"], ["", "sublocale unit_preserving_hom"], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_preserving_hom hom", "proof unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. hom x dvd (1::'b) \\<Longrightarrow> x dvd (1::'a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. hom x dvd (1::'b) \\<Longrightarrow> x dvd (1::'a)", "assume \"hom x dvd 1\""], ["proof (state)\nthis:\n  hom x dvd (1::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x. hom x dvd (1::'b) \\<Longrightarrow> x dvd (1::'a)", "then"], ["proof (chain)\npicking this:\n  hom x dvd (1::'b)", "have \"hom x dvd hom 1\""], ["proof (prove)\nusing this:\n  hom x dvd (1::'b)\n\ngoal (1 subgoal):\n 1. hom x dvd hom (1::'a)", "by simp"], ["proof (state)\nthis:\n  hom x dvd hom (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x. hom x dvd (1::'b) \\<Longrightarrow> x dvd (1::'a)", "then"], ["proof (chain)\npicking this:\n  hom x dvd hom (1::'a)", "show \"x dvd 1\""], ["proof (prove)\nusing this:\n  hom x dvd hom (1::'a)\n\ngoal (1 subgoal):\n 1. x dvd (1::'a)", "by (unfold hom_dvd_hom_iff)"], ["proof (state)\nthis:\n  x dvd (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale zero_hom_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. zero_hom_0 hom", "proof (unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. hom x = (0::'b) \\<Longrightarrow> x = (0::'a)", "fix a :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. hom x = (0::'b) \\<Longrightarrow> x = (0::'a)", "assume \"hom a = 0\""], ["proof (state)\nthis:\n  hom a = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x. hom x = (0::'b) \\<Longrightarrow> x = (0::'a)", "then"], ["proof (chain)\npicking this:\n  hom a = (0::'b)", "have \"hom 0 dvd hom a\""], ["proof (prove)\nusing this:\n  hom a = (0::'b)\n\ngoal (1 subgoal):\n 1. hom (0::'a) dvd hom a", "by auto"], ["proof (state)\nthis:\n  hom (0::'a) dvd hom a\n\ngoal (1 subgoal):\n 1. \\<And>x. hom x = (0::'b) \\<Longrightarrow> x = (0::'a)", "then"], ["proof (chain)\npicking this:\n  hom (0::'a) dvd hom a", "have \"0 dvd a\""], ["proof (prove)\nusing this:\n  hom (0::'a) dvd hom a\n\ngoal (1 subgoal):\n 1. (0::'a) dvd a", "by (unfold hom_dvd_hom_iff)"], ["proof (state)\nthis:\n  (0::'a) dvd a\n\ngoal (1 subgoal):\n 1. \\<And>x. hom x = (0::'b) \\<Longrightarrow> x = (0::'a)", "then"], ["proof (chain)\npicking this:\n  (0::'a) dvd a", "show \"a = 0\""], ["proof (prove)\nusing this:\n  (0::'a) dvd a\n\ngoal (1 subgoal):\n 1. a = (0::'a)", "by auto"], ["proof (state)\nthis:\n  a = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma smult_inverse_monom:\"p \\<noteq> 0 \\<Longrightarrow> smult (inverse c) (p::rat poly) = 1 \\<longleftrightarrow> p = [: c :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> (smult (inverse c) p = 1) = (p = [:c:])", "proof (cases \"c=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> 0; c = 0\\<rbrakk>\n    \\<Longrightarrow> (smult (inverse c) p = 1) = (p = [:c:])\n 2. \\<lbrakk>p \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (smult (inverse c) p = 1) = (p = [:c:])", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> 0; c = 0\\<rbrakk>\n    \\<Longrightarrow> (smult (inverse c) p = 1) = (p = [:c:])\n 2. \\<lbrakk>p \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (smult (inverse c) p = 1) = (p = [:c:])", "thus \"p \\<noteq> 0 \\<Longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> (smult (inverse c) p = 1) = (p = [:c:])", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0 \\<Longrightarrow> (smult (inverse c) p = 1) = (p = [:c:])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (smult (inverse c) p = 1) = (p = [:c:])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (smult (inverse c) p = 1) = (p = [:c:])", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> 0; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (smult (inverse c) p = 1) = (p = [:c:])", "thus ?thesis"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (smult (inverse c) p = 1) = (p = [:c:])", "by (metis left_inverse right_inverse smult_1 smult_1_left smult_smult)"], ["proof (state)\nthis:\n  (smult (inverse c) p = 1) = (p = [:c:])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_int_monom:\"of_int_poly p = [:rat_of_int c:] \\<longleftrightarrow> p = [: c :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int_poly p = [:rat_of_int c:]) = (p = [:c:])", "by (induct p, auto)"], ["", "lemma degree_0_content:\n  fixes p :: \"int poly\"\n  assumes deg: \"degree p = 0\" shows \"content p = abs (coeff p 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content p = \\<bar>coeff p 0\\<bar>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. content p = \\<bar>coeff p 0\\<bar>", "from deg"], ["proof (chain)\npicking this:\n  degree p = 0", "obtain a where p: \"p = [:a:]\""], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. (\\<And>a. p = [:a:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto dest: degree0_coeffs)"], ["proof (state)\nthis:\n  p = [:a:]\n\ngoal (1 subgoal):\n 1. content p = \\<bar>coeff p 0\\<bar>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. content p = \\<bar>coeff p 0\\<bar>", "by (auto simp: p)"], ["proof (state)\nthis:\n  content p = \\<bar>coeff p 0\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_elem_imp_gcd_eq:\n  fixes x::\"'a:: ring_gcd\"\n  shows \"prime_elem x \\<Longrightarrow> gcd x y = normalize x \\<or> gcd x y = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_elem x \\<Longrightarrow>\n    gcd x y = normalize x \\<or> gcd x y = (1::'a)", "using prime_elem_imp_coprime [of x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime_elem x; \\<not> x dvd y\\<rbrakk>\n  \\<Longrightarrow> algebraic_semidom_class.coprime x y\n\ngoal (1 subgoal):\n 1. prime_elem x \\<Longrightarrow>\n    gcd x y = normalize x \\<or> gcd x y = (1::'a)", "by (auto simp add: gcd_proj1_iff intro: coprime_imp_gcd_eq_1)"], ["", "lemma irreducible_pos_gcd:\n  fixes p :: \"int poly\"\n  assumes ir: \"irreducible p\" and pos: \"lead_coeff p > 0\" shows \"gcd p q \\<in> {1,p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p q \\<in> {1, p}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd p q \\<in> {1, p}", "from pos"], ["proof (chain)\npicking this:\n  0 < lead_coeff p", "have \"[:sgn (lead_coeff p):] = 1\""], ["proof (prove)\nusing this:\n  0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. [:sgn (lead_coeff p):] = 1", "by auto"], ["proof (state)\nthis:\n  [:sgn (lead_coeff p):] = 1\n\ngoal (1 subgoal):\n 1. gcd p q \\<in> {1, p}", "with prime_elem_imp_gcd_eq[of p, unfolded prime_elem_iff_irreducible, OF ir, of q]"], ["proof (chain)\npicking this:\n  gcd p q = normalize p \\<or> gcd p q = 1\n  [:sgn (lead_coeff p):] = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  gcd p q = normalize p \\<or> gcd p q = 1\n  [:sgn (lead_coeff p):] = 1\n\ngoal (1 subgoal):\n 1. gcd p q \\<in> {1, p}", "by (auto simp: normalize_poly_def)"], ["proof (state)\nthis:\n  gcd p q \\<in> {1, p}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible_pos_gcd_twice:\n  fixes p q :: \"int poly\"\n  assumes p: \"irreducible p\" \"lead_coeff p > 0\"\n  and q: \"irreducible q\" \"lead_coeff q > 0\"\n  shows \"gcd p q = 1 \\<or> p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p q = 1 \\<or> p = q", "proof (cases \"gcd p q = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. gcd p q = 1 \\<Longrightarrow> gcd p q = 1 \\<or> p = q\n 2. gcd p q \\<noteq> 1 \\<Longrightarrow> gcd p q = 1 \\<or> p = q", "case False"], ["proof (state)\nthis:\n  gcd p q \\<noteq> 1\n\ngoal (2 subgoals):\n 1. gcd p q = 1 \\<Longrightarrow> gcd p q = 1 \\<or> p = q\n 2. gcd p q \\<noteq> 1 \\<Longrightarrow> gcd p q = 1 \\<or> p = q", "note pq = this"], ["proof (state)\nthis:\n  gcd p q \\<noteq> 1\n\ngoal (2 subgoals):\n 1. gcd p q = 1 \\<Longrightarrow> gcd p q = 1 \\<or> p = q\n 2. gcd p q \\<noteq> 1 \\<Longrightarrow> gcd p q = 1 \\<or> p = q", "have \"p = gcd p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = gcd p q", "using irreducible_pos_gcd [OF p, of q] pq"], ["proof (prove)\nusing this:\n  gcd p q \\<in> {1, p}\n  gcd p q \\<noteq> 1\n\ngoal (1 subgoal):\n 1. p = gcd p q", "by auto"], ["proof (state)\nthis:\n  p = gcd p q\n\ngoal (2 subgoals):\n 1. gcd p q = 1 \\<Longrightarrow> gcd p q = 1 \\<or> p = q\n 2. gcd p q \\<noteq> 1 \\<Longrightarrow> gcd p q = 1 \\<or> p = q", "also"], ["proof (state)\nthis:\n  p = gcd p q\n\ngoal (2 subgoals):\n 1. gcd p q = 1 \\<Longrightarrow> gcd p q = 1 \\<or> p = q\n 2. gcd p q \\<noteq> 1 \\<Longrightarrow> gcd p q = 1 \\<or> p = q", "have \"\\<dots> = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p q = q", "using irreducible_pos_gcd [OF q, of p] pq"], ["proof (prove)\nusing this:\n  gcd q p \\<in> {1, q}\n  gcd p q \\<noteq> 1\n\ngoal (1 subgoal):\n 1. gcd p q = q", "by (auto simp add: ac_simps)"], ["proof (state)\nthis:\n  gcd p q = q\n\ngoal (2 subgoals):\n 1. gcd p q = 1 \\<Longrightarrow> gcd p q = 1 \\<or> p = q\n 2. gcd p q \\<noteq> 1 \\<Longrightarrow> gcd p q = 1 \\<or> p = q", "finally"], ["proof (chain)\npicking this:\n  p = q", "show ?thesis"], ["proof (prove)\nusing this:\n  p = q\n\ngoal (1 subgoal):\n 1. gcd p q = 1 \\<or> p = q", "by auto"], ["proof (state)\nthis:\n  gcd p q = 1 \\<or> p = q\n\ngoal (1 subgoal):\n 1. gcd p q = 1 \\<Longrightarrow> gcd p q = 1 \\<or> p = q", "qed simp"], ["", "interpretation of_rat_hom: field_hom_0' of_rat"], ["proof (prove)\ngoal (1 subgoal):\n 1. field_hom_0' of_rat", ".."], ["", "lemma poly_zero_imp_not_unit:\n  assumes \"poly p x = 0\" shows \"\\<not> p dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p dvd 1", "proof (rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. p dvd 1 \\<Longrightarrow> False", "assume \"p dvd 1\""], ["proof (state)\nthis:\n  p dvd 1\n\ngoal (1 subgoal):\n 1. p dvd 1 \\<Longrightarrow> False", "from poly_hom.hom_dvd_1[OF this]"], ["proof (chain)\npicking this:\n  poly p ?a dvd (1::'a)", "have \"poly p x dvd 1\""], ["proof (prove)\nusing this:\n  poly p ?a dvd (1::'a)\n\ngoal (1 subgoal):\n 1. poly p x dvd (1::'a)", "by auto"], ["proof (state)\nthis:\n  poly p x dvd (1::'a)\n\ngoal (1 subgoal):\n 1. p dvd 1 \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  poly p x = (0::'a)\n  poly p x dvd (1::'a)", "show False"], ["proof (prove)\nusing this:\n  poly p x = (0::'a)\n  poly p x dvd (1::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_prod_mset_zero_iff:\n  fixes x :: \"'a :: idom\"\n  shows \"poly (prod_mset F) x = 0 \\<longleftrightarrow> (\\<exists>f \\<in># F. poly f x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (\\<Prod>\\<^sub># F) x = (0::'a)) =\n    (\\<exists>f\\<in>#F. poly f x = (0::'a))", "by (induct F, auto simp: poly_mult_zero_iff)"], ["", "lemma algebraic_imp_represents_irreducible:\n  fixes x :: \"'a :: field_char_0\"\n  assumes \"algebraic x\"\n  shows \"\\<exists>p. p represents x \\<and> irreducible p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. p represents x \\<and> irreducible p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. p represents x \\<and> irreducible p", "from assms"], ["proof (chain)\npicking this:\n  algebraic x", "obtain p\n  where px0: \"ipoly p x = 0\" and p0: \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  algebraic x\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding algebraic_altdef_ipoly"], ["proof (prove)\nusing this:\n  \\<exists>p. ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>ipoly p x = (0::'a); p \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ipoly p x = (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>p. p represents x \\<and> irreducible p", "from poly_zero_imp_not_unit[OF px0]"], ["proof (chain)\npicking this:\n  \\<not> is_unit (of_int_poly p)", "have \"\\<not> p dvd 1\""], ["proof (prove)\nusing this:\n  \\<not> is_unit (of_int_poly p)\n\ngoal (1 subgoal):\n 1. \\<not> is_unit p", "by (auto dest: of_int_poly_hom.hom_dvd_1[where 'a = 'a])"], ["proof (state)\nthis:\n  \\<not> is_unit p\n\ngoal (1 subgoal):\n 1. \\<exists>p. p represents x \\<and> irreducible p", "from mset_factors_exist[OF p0 this]"], ["proof (chain)\npicking this:\n  \\<exists>F. mset_factors F p", "obtain F where F: \"mset_factors F p\""], ["proof (prove)\nusing this:\n  \\<exists>F. mset_factors F p\n\ngoal (1 subgoal):\n 1. (\\<And>F. mset_factors F p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mset_factors F p\n\ngoal (1 subgoal):\n 1. \\<exists>p. p represents x \\<and> irreducible p", "then"], ["proof (chain)\npicking this:\n  mset_factors F p", "have \"p = prod_mset F\""], ["proof (prove)\nusing this:\n  mset_factors F p\n\ngoal (1 subgoal):\n 1. p = \\<Prod>\\<^sub># F", "by auto"], ["proof (state)\nthis:\n  p = \\<Prod>\\<^sub># F\n\ngoal (1 subgoal):\n 1. \\<exists>p. p represents x \\<and> irreducible p", "also"], ["proof (state)\nthis:\n  p = \\<Prod>\\<^sub># F\n\ngoal (1 subgoal):\n 1. \\<exists>p. p represents x \\<and> irreducible p", "have \"(of_int_poly ... :: 'a poly) = prod_mset (image_mset of_int_poly F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (\\<Prod>\\<^sub># F) =\n    \\<Prod>\\<^sub># (image_mset of_int_poly F)", "by simp"], ["proof (state)\nthis:\n  of_int_poly (\\<Prod>\\<^sub># F) =\n  \\<Prod>\\<^sub># (image_mset of_int_poly F)\n\ngoal (1 subgoal):\n 1. \\<exists>p. p represents x \\<and> irreducible p", "finally"], ["proof (chain)\npicking this:\n  of_int_poly p = \\<Prod>\\<^sub># (image_mset of_int_poly F)", "have \"poly ... x = 0\""], ["proof (prove)\nusing this:\n  of_int_poly p = \\<Prod>\\<^sub># (image_mset of_int_poly F)\n\ngoal (1 subgoal):\n 1. poly (\\<Prod>\\<^sub># (image_mset of_int_poly F)) x = (0::'a)", "using px0"], ["proof (prove)\nusing this:\n  of_int_poly p = \\<Prod>\\<^sub># (image_mset of_int_poly F)\n  ipoly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (\\<Prod>\\<^sub># (image_mset of_int_poly F)) x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  poly (\\<Prod>\\<^sub># (image_mset of_int_poly F)) x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>p. p represents x \\<and> irreducible p", "from this[unfolded poly_prod_mset_zero_iff]"], ["proof (chain)\npicking this:\n  \\<exists>f\\<in>#image_mset of_int_poly F. poly f x = (0::'a)", "obtain f where \"f \\<in># F\" and fx0: \"ipoly f x = 0\""], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>#image_mset of_int_poly F. poly f x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in># F; ipoly f x = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f \\<in># F\n  ipoly f x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>p. p represents x \\<and> irreducible p", "with F"], ["proof (chain)\npicking this:\n  mset_factors F p\n  f \\<in># F\n  ipoly f x = (0::'a)", "have \"irreducible f\""], ["proof (prove)\nusing this:\n  mset_factors F p\n  f \\<in># F\n  ipoly f x = (0::'a)\n\ngoal (1 subgoal):\n 1. irreducible f", "by auto"], ["proof (state)\nthis:\n  irreducible f\n\ngoal (1 subgoal):\n 1. \\<exists>p. p represents x \\<and> irreducible p", "with fx0"], ["proof (chain)\npicking this:\n  ipoly f x = (0::'a)\n  irreducible f", "show ?thesis"], ["proof (prove)\nusing this:\n  ipoly f x = (0::'a)\n  irreducible f\n\ngoal (1 subgoal):\n 1. \\<exists>p. p represents x \\<and> irreducible p", "by auto"], ["proof (state)\nthis:\n  \\<exists>p. p represents x \\<and> irreducible p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraic_imp_represents_irreducible_cf_pos:\n  assumes \"algebraic (x::'a::field_char_0)\"\n  shows \"\\<exists>p. p represents x \\<and> irreducible p \\<and> lead_coeff p > 0 \\<and> primitive p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p represents x \\<and>\n       irreducible p \\<and> 0 < lead_coeff p \\<and> primitive p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p represents x \\<and>\n       irreducible p \\<and> 0 < lead_coeff p \\<and> primitive p", "from algebraic_imp_represents_irreducible[OF assms(1)]"], ["proof (chain)\npicking this:\n  \\<exists>p. p represents x \\<and> irreducible p", "obtain p where px: \"p represents x\" and irr: \"irreducible p\""], ["proof (prove)\nusing this:\n  \\<exists>p. p represents x \\<and> irreducible p\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p represents x; irreducible p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p represents x\n  irreducible p\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p represents x \\<and>\n       irreducible p \\<and> 0 < lead_coeff p \\<and> primitive p", "let ?p = \"cf_pos_poly p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p represents x \\<and>\n       irreducible p \\<and> 0 < lead_coeff p \\<and> primitive p", "from px irr represents_imp_degree"], ["proof (chain)\npicking this:\n  p represents x\n  irreducible p\n  ?p represents ?x \\<Longrightarrow> degree ?p \\<noteq> 0", "have 1: \"?p represents x\" and 2: \"irreducible ?p\" and 3: \"cf_pos ?p\""], ["proof (prove)\nusing this:\n  p represents x\n  irreducible p\n  ?p represents ?x \\<Longrightarrow> degree ?p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cf_pos_poly p represents x &&&\n    irreducible (cf_pos_poly p) &&& cf_pos (cf_pos_poly p)", "by (auto intro: irreducible_cf_pos_poly)"], ["proof (state)\nthis:\n  cf_pos_poly p represents x\n  irreducible (cf_pos_poly p)\n  cf_pos (cf_pos_poly p)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p represents x \\<and>\n       irreducible p \\<and> 0 < lead_coeff p \\<and> primitive p", "then"], ["proof (chain)\npicking this:\n  cf_pos_poly p represents x\n  irreducible (cf_pos_poly p)\n  cf_pos (cf_pos_poly p)", "show ?thesis"], ["proof (prove)\nusing this:\n  cf_pos_poly p represents x\n  irreducible (cf_pos_poly p)\n  cf_pos (cf_pos_poly p)\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       p represents x \\<and>\n       irreducible p \\<and> 0 < lead_coeff p \\<and> primitive p", "by (auto intro: exI[of _ ?p] simp: cf_pos_def)"], ["proof (state)\nthis:\n  \\<exists>p.\n     p represents x \\<and>\n     irreducible p \\<and> 0 < lead_coeff p \\<and> primitive p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcd_of_int_poly: \"gcd (of_int_poly f) (of_int_poly g :: 'a :: {field_char_0,field_gcd} poly) =\n  smult (inverse (of_int (lead_coeff (gcd f g)))) (of_int_poly (gcd f g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (of_int (lead_coeff (gcd f g)))) (of_int_poly (gcd f g))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (of_int (lead_coeff (gcd f g)))) (of_int_poly (gcd f g))", "let ?ia = \"of_int_poly :: _ \\<Rightarrow> 'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (of_int (lead_coeff (gcd f g)))) (of_int_poly (gcd f g))", "let ?ir = \"of_int_poly :: _ \\<Rightarrow> rat poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (of_int (lead_coeff (gcd f g)))) (of_int_poly (gcd f g))", "let ?ra = \"map_poly of_rat :: _ \\<Rightarrow> 'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (of_int (lead_coeff (gcd f g)))) (of_int_poly (gcd f g))", "have id: \"?ia x = ?ra (?ir x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly x = map_poly of_rat (of_int_poly x)", "by (subst map_poly_map_poly, auto)"], ["proof (state)\nthis:\n  of_int_poly ?x = map_poly of_rat (of_int_poly ?x)\n\ngoal (1 subgoal):\n 1. gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (of_int (lead_coeff (gcd f g)))) (of_int_poly (gcd f g))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (of_int_poly f) (of_int_poly g) =\n    smult (inverse (of_int (lead_coeff (gcd f g)))) (of_int_poly (gcd f g))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (map_poly of_rat (of_int_poly f))\n     (map_poly of_rat (of_int_poly g)) =\n    smult (inverse (of_int (lead_coeff (gcd f g))))\n     (map_poly of_rat (of_int_poly (gcd f g)))", "unfolding of_rat_hom.map_poly_gcd[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly of_rat (gcd (of_int_poly f) (of_int_poly g)) =\n    smult (inverse (of_int (lead_coeff (gcd f g))))\n     (map_poly of_rat (of_int_poly (gcd f g)))", "unfolding gcd_rat_to_gcd_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly of_rat\n     (smult (inverse (rat_of_int (lead_coeff (gcd f g))))\n       (of_int_poly (gcd f g))) =\n    smult (inverse (of_int (lead_coeff (gcd f g))))\n     (map_poly of_rat (of_int_poly (gcd f g)))", "by (auto simp: hom_distribs)"], ["proof (state)\nthis:\n  gcd (of_int_poly f) (of_int_poly g) =\n  smult (inverse (of_int (lead_coeff (gcd f g)))) (of_int_poly (gcd f g))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraic_imp_represents_unique:\n  fixes x :: \"'a :: {field_char_0,field_gcd}\"\n  assumes \"algebraic x\"\n  shows \"\\<exists>! p. p represents x \\<and> irreducible p \\<and> lead_coeff p > 0\" (is \"Ex1 ?p\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!p. p represents x \\<and> irreducible p \\<and> 0 < lead_coeff p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!p. p represents x \\<and> irreducible p \\<and> 0 < lead_coeff p", "from assms"], ["proof (chain)\npicking this:\n  algebraic x", "obtain p\n  where p: \"?p p\" and cfp: \"cf_pos p\""], ["proof (prove)\nusing this:\n  algebraic x\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p represents x \\<and>\n                 irreducible p \\<and> 0 < lead_coeff p;\n         cf_pos p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: cf_pos_def dest: algebraic_imp_represents_irreducible_cf_pos)"], ["proof (state)\nthis:\n  p represents x \\<and> irreducible p \\<and> 0 < lead_coeff p\n  cf_pos p\n\ngoal (1 subgoal):\n 1. \\<exists>!p. p represents x \\<and> irreducible p \\<and> 0 < lead_coeff p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!p. p represents x \\<and> irreducible p \\<and> 0 < lead_coeff p", "proof (rule ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?a represents x \\<and> irreducible ?a \\<and> 0 < lead_coeff ?a\n 2. \\<And>p.\n       p represents x \\<and>\n       irreducible p \\<and> 0 < lead_coeff p \\<Longrightarrow>\n       p = ?a", "show \"?p p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p represents x \\<and> irreducible p \\<and> 0 < lead_coeff p", "by fact"], ["proof (state)\nthis:\n  p represents x \\<and> irreducible p \\<and> 0 < lead_coeff p\n\ngoal (1 subgoal):\n 1. \\<And>pa.\n       pa represents x \\<and>\n       irreducible pa \\<and> 0 < lead_coeff pa \\<Longrightarrow>\n       pa = p", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pa.\n       pa represents x \\<and>\n       irreducible pa \\<and> 0 < lead_coeff pa \\<Longrightarrow>\n       pa = p", "assume q: \"?p q\""], ["proof (state)\nthis:\n  q represents x \\<and> irreducible q \\<and> 0 < lead_coeff q\n\ngoal (1 subgoal):\n 1. \\<And>pa.\n       pa represents x \\<and>\n       irreducible pa \\<and> 0 < lead_coeff pa \\<Longrightarrow>\n       pa = p", "then"], ["proof (chain)\npicking this:\n  q represents x \\<and> irreducible q \\<and> 0 < lead_coeff q", "have \"q represents x\""], ["proof (prove)\nusing this:\n  q represents x \\<and> irreducible q \\<and> 0 < lead_coeff q\n\ngoal (1 subgoal):\n 1. q represents x", "by auto"], ["proof (state)\nthis:\n  q represents x\n\ngoal (1 subgoal):\n 1. \\<And>pa.\n       pa represents x \\<and>\n       irreducible pa \\<and> 0 < lead_coeff pa \\<Longrightarrow>\n       pa = p", "from represents_imp_degree[OF this] q irreducible_content[of q]"], ["proof (chain)\npicking this:\n  degree q \\<noteq> 0\n  q represents x \\<and> irreducible q \\<and> 0 < lead_coeff q\n  irreducible q \\<Longrightarrow> degree q = 0 \\<or> primitive q", "have cfq: \"cf_pos q\""], ["proof (prove)\nusing this:\n  degree q \\<noteq> 0\n  q represents x \\<and> irreducible q \\<and> 0 < lead_coeff q\n  irreducible q \\<Longrightarrow> degree q = 0 \\<or> primitive q\n\ngoal (1 subgoal):\n 1. cf_pos q", "by (auto simp: cf_pos_def)"], ["proof (state)\nthis:\n  cf_pos q\n\ngoal (1 subgoal):\n 1. \\<And>pa.\n       pa represents x \\<and>\n       irreducible pa \\<and> 0 < lead_coeff pa \\<Longrightarrow>\n       pa = p", "show \"q = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "let ?ia = \"map_poly of_int :: int poly \\<Rightarrow> 'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "assume \"q \\<noteq> p\""], ["proof (state)\nthis:\n  q \\<noteq> p\n\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "with irreducible_pos_gcd_twice[of p q] p q cfp cfq"], ["proof (chain)\npicking this:\n  \\<lbrakk>irreducible p; 0 < lead_coeff p; irreducible q;\n   0 < lead_coeff q\\<rbrakk>\n  \\<Longrightarrow> gcd p q = 1 \\<or> p = q\n  p represents x \\<and> irreducible p \\<and> 0 < lead_coeff p\n  q represents x \\<and> irreducible q \\<and> 0 < lead_coeff q\n  cf_pos p\n  cf_pos q\n  q \\<noteq> p", "have gcd: \"gcd p q = 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>irreducible p; 0 < lead_coeff p; irreducible q;\n   0 < lead_coeff q\\<rbrakk>\n  \\<Longrightarrow> gcd p q = 1 \\<or> p = q\n  p represents x \\<and> irreducible p \\<and> 0 < lead_coeff p\n  q represents x \\<and> irreducible q \\<and> 0 < lead_coeff q\n  cf_pos p\n  cf_pos q\n  q \\<noteq> p\n\ngoal (1 subgoal):\n 1. gcd p q = 1", "by auto"], ["proof (state)\nthis:\n  gcd p q = 1\n\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "from p q"], ["proof (chain)\npicking this:\n  p represents x \\<and> irreducible p \\<and> 0 < lead_coeff p\n  q represents x \\<and> irreducible q \\<and> 0 < lead_coeff q", "have rt: \"ipoly p x = 0\" \"ipoly q x = 0\""], ["proof (prove)\nusing this:\n  p represents x \\<and> irreducible p \\<and> 0 < lead_coeff p\n  q represents x \\<and> irreducible q \\<and> 0 < lead_coeff q\n\ngoal (1 subgoal):\n 1. ipoly p x = (0::'a) &&& ipoly q x = (0::'a)", "unfolding represents_def"], ["proof (prove)\nusing this:\n  (ipoly p x = (0::'a) \\<and> p \\<noteq> 0) \\<and>\n  irreducible p \\<and> 0 < lead_coeff p\n  (ipoly q x = (0::'a) \\<and> q \\<noteq> 0) \\<and>\n  irreducible q \\<and> 0 < lead_coeff q\n\ngoal (1 subgoal):\n 1. ipoly p x = (0::'a) &&& ipoly q x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  ipoly p x = (0::'a)\n  ipoly q x = (0::'a)\n\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "define c :: 'a where \"c = inverse (of_int (lead_coeff (gcd p q)))\""], ["proof (state)\nthis:\n  c = inverse (of_int (lead_coeff (gcd p q)))\n\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "have rt: \"poly (?ia p) x = 0\" \"poly (?ia q) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly p x = (0::'a) &&& ipoly q x = (0::'a)", "using rt"], ["proof (prove)\nusing this:\n  ipoly p x = (0::'a)\n  ipoly q x = (0::'a)\n\ngoal (1 subgoal):\n 1. ipoly p x = (0::'a) &&& ipoly q x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  ipoly p x = (0::'a)\n  ipoly q x = (0::'a)\n\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "hence \"[:-x,1:] dvd ?ia p\" \"[:-x,1:] dvd ?ia q\""], ["proof (prove)\nusing this:\n  ipoly p x = (0::'a)\n  ipoly q x = (0::'a)\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] dvd of_int_poly p &&& [:- x, 1::'a:] dvd of_int_poly q", "unfolding poly_eq_0_iff_dvd"], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd of_int_poly p\n  [:- x, 1::'a:] dvd of_int_poly q\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] dvd of_int_poly p &&& [:- x, 1::'a:] dvd of_int_poly q", "by auto"], ["proof (state)\nthis:\n  [:- x, 1::'a:] dvd of_int_poly p\n  [:- x, 1::'a:] dvd of_int_poly q\n\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "hence \"[:-x,1:] dvd gcd (?ia p) (?ia q)\""], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd of_int_poly p\n  [:- x, 1::'a:] dvd of_int_poly q\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] dvd gcd (of_int_poly p) (of_int_poly q)", "by (rule gcd_greatest)"], ["proof (state)\nthis:\n  [:- x, 1::'a:] dvd gcd (of_int_poly p) (of_int_poly q)\n\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  [:- x, 1::'a:] dvd gcd (of_int_poly p) (of_int_poly q)\n\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "have \"\\<dots> = smult c (?ia (gcd p q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (of_int_poly p) (of_int_poly q) = smult c (of_int_poly (gcd p q))", "unfolding gcd_of_int_poly c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (inverse (of_int (lead_coeff (gcd p q))))\n     (of_int_poly (gcd p q)) =\n    smult (inverse (of_int (lead_coeff (gcd p q)))) (of_int_poly (gcd p q))", ".."], ["proof (state)\nthis:\n  gcd (of_int_poly p) (of_int_poly q) = smult c (of_int_poly (gcd p q))\n\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  gcd (of_int_poly p) (of_int_poly q) = smult c (of_int_poly (gcd p q))\n\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "have \"?ia (gcd p q) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (gcd p q) = 1", "by (simp add: gcd)"], ["proof (state)\nthis:\n  of_int_poly (gcd p q) = 1\n\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  of_int_poly (gcd p q) = 1\n\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "have \"smult c 1 = [: c :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult c 1 = [:c:]", "by simp"], ["proof (state)\nthis:\n  smult c 1 = [:c:]\n\ngoal (1 subgoal):\n 1. q \\<noteq> p \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  [:- x, 1::'a:] dvd [:c:]", "show False"], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd [:c:]\n\ngoal (1 subgoal):\n 1. False", "using c_def gcd"], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd [:c:]\n  c = inverse (of_int (lead_coeff (gcd p q)))\n  gcd p q = 1\n\ngoal (1 subgoal):\n 1. False", "by (simp add: dvd_iff_poly_eq_0)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q = p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!p. p represents x \\<and> irreducible p \\<and> 0 < lead_coeff p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipoly_poly_compose:\n  fixes x :: \"'a :: idom\"\n  shows \"ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)", "proof (induct p)"], ["proof (state)\ngoal (2 subgoals):\n 1. ipoly (0 \\<circ>\\<^sub>p q) x = ipoly 0 (ipoly q x)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\\<rbrakk>\n       \\<Longrightarrow> ipoly (pCons a p \\<circ>\\<^sub>p q) x =\n                         ipoly (pCons a p) (ipoly q x)", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n  ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\n\ngoal (2 subgoals):\n 1. ipoly (0 \\<circ>\\<^sub>p q) x = ipoly 0 (ipoly q x)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\\<rbrakk>\n       \\<Longrightarrow> ipoly (pCons a p \\<circ>\\<^sub>p q) x =\n                         ipoly (pCons a p) (ipoly q x)", "have \"ipoly ((pCons a p) \\<circ>\\<^sub>p q) x = of_int a + ipoly (q * p \\<circ>\\<^sub>p q) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (pCons a p \\<circ>\\<^sub>p q) x =\n    of_int a + ipoly (q * p \\<circ>\\<^sub>p q) x", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  ipoly (pCons a p \\<circ>\\<^sub>p q) x =\n  of_int a + ipoly (q * p \\<circ>\\<^sub>p q) x\n\ngoal (2 subgoals):\n 1. ipoly (0 \\<circ>\\<^sub>p q) x = ipoly 0 (ipoly q x)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\\<rbrakk>\n       \\<Longrightarrow> ipoly (pCons a p \\<circ>\\<^sub>p q) x =\n                         ipoly (pCons a p) (ipoly q x)", "also"], ["proof (state)\nthis:\n  ipoly (pCons a p \\<circ>\\<^sub>p q) x =\n  of_int a + ipoly (q * p \\<circ>\\<^sub>p q) x\n\ngoal (2 subgoals):\n 1. ipoly (0 \\<circ>\\<^sub>p q) x = ipoly 0 (ipoly q x)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\\<rbrakk>\n       \\<Longrightarrow> ipoly (pCons a p \\<circ>\\<^sub>p q) x =\n                         ipoly (pCons a p) (ipoly q x)", "have \"ipoly (q * p \\<circ>\\<^sub>p q) x = ipoly q x * ipoly (p \\<circ>\\<^sub>p q) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (q * p \\<circ>\\<^sub>p q) x =\n    ipoly q x * ipoly (p \\<circ>\\<^sub>p q) x", "by (simp add: hom_distribs)"], ["proof (state)\nthis:\n  ipoly (q * p \\<circ>\\<^sub>p q) x =\n  ipoly q x * ipoly (p \\<circ>\\<^sub>p q) x\n\ngoal (2 subgoals):\n 1. ipoly (0 \\<circ>\\<^sub>p q) x = ipoly 0 (ipoly q x)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\\<rbrakk>\n       \\<Longrightarrow> ipoly (pCons a p \\<circ>\\<^sub>p q) x =\n                         ipoly (pCons a p) (ipoly q x)", "also"], ["proof (state)\nthis:\n  ipoly (q * p \\<circ>\\<^sub>p q) x =\n  ipoly q x * ipoly (p \\<circ>\\<^sub>p q) x\n\ngoal (2 subgoals):\n 1. ipoly (0 \\<circ>\\<^sub>p q) x = ipoly 0 (ipoly q x)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\\<rbrakk>\n       \\<Longrightarrow> ipoly (pCons a p \\<circ>\\<^sub>p q) x =\n                         ipoly (pCons a p) (ipoly q x)", "have \"ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)", "unfolding pCons(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly p (ipoly q x) = ipoly p (ipoly q x)", ".."], ["proof (state)\nthis:\n  ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\n\ngoal (2 subgoals):\n 1. ipoly (0 \\<circ>\\<^sub>p q) x = ipoly 0 (ipoly q x)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\\<rbrakk>\n       \\<Longrightarrow> ipoly (pCons a p \\<circ>\\<^sub>p q) x =\n                         ipoly (pCons a p) (ipoly q x)", "also"], ["proof (state)\nthis:\n  ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\n\ngoal (2 subgoals):\n 1. ipoly (0 \\<circ>\\<^sub>p q) x = ipoly 0 (ipoly q x)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\\<rbrakk>\n       \\<Longrightarrow> ipoly (pCons a p \\<circ>\\<^sub>p q) x =\n                         ipoly (pCons a p) (ipoly q x)", "have \"of_int a + ipoly q x * \\<dots> = ipoly (pCons a p) (ipoly q x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int a + ipoly q x * ipoly p (ipoly q x) =\n    ipoly (pCons a p) (ipoly q x)", "unfolding map_poly_pCons[OF pCons(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int a + ipoly q x * ipoly p (ipoly q x) =\n    poly (pCons (of_int a) (of_int_poly p)) (ipoly q x)", "by simp"], ["proof (state)\nthis:\n  of_int a + ipoly q x * ipoly p (ipoly q x) = ipoly (pCons a p) (ipoly q x)\n\ngoal (2 subgoals):\n 1. ipoly (0 \\<circ>\\<^sub>p q) x = ipoly 0 (ipoly q x)\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        ipoly (p \\<circ>\\<^sub>p q) x = ipoly p (ipoly q x)\\<rbrakk>\n       \\<Longrightarrow> ipoly (pCons a p \\<circ>\\<^sub>p q) x =\n                         ipoly (pCons a p) (ipoly q x)", "finally"], ["proof (chain)\npicking this:\n  ipoly (pCons a p \\<circ>\\<^sub>p q) x = ipoly (pCons a p) (ipoly q x)", "show ?case"], ["proof (prove)\nusing this:\n  ipoly (pCons a p \\<circ>\\<^sub>p q) x = ipoly (pCons a p) (ipoly q x)\n\ngoal (1 subgoal):\n 1. ipoly (pCons a p \\<circ>\\<^sub>p q) x = ipoly (pCons a p) (ipoly q x)", "."], ["proof (state)\nthis:\n  ipoly (pCons a p \\<circ>\\<^sub>p q) x = ipoly (pCons a p) (ipoly q x)\n\ngoal (1 subgoal):\n 1. ipoly (0 \\<circ>\\<^sub>p q) x = ipoly 0 (ipoly q x)", "qed simp"], ["", "text \\<open>Polynomial for unary minus.\\<close>"], ["", "definition poly_uminus :: \"'a :: ring_1 poly \\<Rightarrow> 'a poly\" where [code del]:\n  \"poly_uminus p \\<equiv> \\<Sum>i\\<le>degree p. monom ((-1)^i * coeff p i) i\""], ["", "lemma poly_uminus_pCons_pCons[simp]:\n  \"poly_uminus (pCons a (pCons b p)) = pCons a (pCons (-b) (poly_uminus p))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_uminus (pCons a (pCons b p)) =\n    pCons a (pCons (- b) (poly_uminus p))", "proof(cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    poly_uminus (pCons a (pCons b p)) =\n    pCons a (pCons (- b) (poly_uminus p))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_uminus (pCons a (pCons b p)) =\n    pCons a (pCons (- b) (poly_uminus p))", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    poly_uminus (pCons a (pCons b p)) =\n    pCons a (pCons (- b) (poly_uminus p))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_uminus (pCons a (pCons b p)) =\n    pCons a (pCons (- b) (poly_uminus p))", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have deg: \"degree (pCons a (pCons b p)) = Suc (Suc (degree p))\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (pCons a (pCons b p)) = Suc (Suc (degree p))", "by simp"], ["proof (state)\nthis:\n  degree (pCons a (pCons b p)) = Suc (Suc (degree p))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    poly_uminus (pCons a (pCons b p)) =\n    pCons a (pCons (- b) (poly_uminus p))\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_uminus (pCons a (pCons b p)) =\n    pCons a (pCons (- b) (poly_uminus p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_uminus (pCons a (pCons b p)) =\n    pCons a (pCons (- b) (poly_uminus p))", "by (unfold poly_uminus_def deg sum.atMost_Suc_shift monom_Suc monom_0 sum_pCons_0_commute, simp)"], ["proof (state)\nthis:\n  poly_uminus (pCons a (pCons b p)) = pCons a (pCons (- b) (poly_uminus p))\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    poly_uminus (pCons a (pCons b p)) =\n    pCons a (pCons (- b) (poly_uminus p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    poly_uminus (pCons a (pCons b p)) =\n    pCons a (pCons (- b) (poly_uminus p))", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    poly_uminus (pCons a (pCons b p)) =\n    pCons a (pCons (- b) (poly_uminus p))", "then"], ["proof (chain)\npicking this:\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. poly_uminus (pCons a (pCons b p)) =\n    pCons a (pCons (- b) (poly_uminus p))", "by (auto simp add: poly_uminus_def monom_0 monom_Suc)"], ["proof (state)\nthis:\n  poly_uminus (pCons a (pCons b p)) = pCons a (pCons (- b) (poly_uminus p))\n\ngoal:\nNo subgoals!", "qed"], ["", "fun poly_uminus_inner :: \"'a :: ring_1 list \\<Rightarrow> 'a poly\"\nwhere \"poly_uminus_inner [] = 0\"\n  |   \"poly_uminus_inner [a] = [:a:]\"\n  |   \"poly_uminus_inner (a#b#cs) = pCons a (pCons (-b) (poly_uminus_inner cs))\""], ["", "lemma poly_uminus_code[code,simp]: \"poly_uminus p = poly_uminus_inner (coeffs p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_uminus p = poly_uminus_inner (coeffs p)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_uminus p = poly_uminus_inner (coeffs p)", "have \"poly_uminus (Poly as) = poly_uminus_inner as\" for as :: \"'a list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_uminus (Poly as) = poly_uminus_inner as", "proof (induct \"length as\" arbitrary:as rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as.\n       (\\<And>asa.\n           length asa < length as \\<Longrightarrow>\n           poly_uminus (Poly asa) = poly_uminus_inner asa) \\<Longrightarrow>\n       poly_uminus (Poly as) = poly_uminus_inner as", "case less"], ["proof (state)\nthis:\n  length ?as < length as \\<Longrightarrow>\n  poly_uminus (Poly ?as) = poly_uminus_inner ?as\n\ngoal (1 subgoal):\n 1. \\<And>as.\n       (\\<And>asa.\n           length asa < length as \\<Longrightarrow>\n           poly_uminus (Poly asa) = poly_uminus_inner asa) \\<Longrightarrow>\n       poly_uminus (Poly as) = poly_uminus_inner as", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_uminus (Poly as) = poly_uminus_inner as", "proof(cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> poly_uminus (Poly as) = poly_uminus_inner as\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       poly_uminus (Poly as) = poly_uminus_inner as", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> poly_uminus (Poly as) = poly_uminus_inner as\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       poly_uminus (Poly as) = poly_uminus_inner as", "then"], ["proof (chain)\npicking this:\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n\ngoal (1 subgoal):\n 1. poly_uminus (Poly as) = poly_uminus_inner as", "by (simp add: poly_uminus_def)"], ["proof (state)\nthis:\n  poly_uminus (Poly as) = poly_uminus_inner as\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       poly_uminus (Poly as) = poly_uminus_inner as", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       poly_uminus (Poly as) = poly_uminus_inner as", "case [simp]: (Cons a bs)"], ["proof (state)\nthis:\n  as = a # bs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       poly_uminus (Poly as) = poly_uminus_inner as", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_uminus (Poly as) = poly_uminus_inner as", "proof (cases bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow> poly_uminus (Poly as) = poly_uminus_inner as\n 2. \\<And>a list.\n       bs = a # list \\<Longrightarrow>\n       poly_uminus (Poly as) = poly_uminus_inner as", "case Nil"], ["proof (state)\nthis:\n  bs = []\n\ngoal (2 subgoals):\n 1. bs = [] \\<Longrightarrow> poly_uminus (Poly as) = poly_uminus_inner as\n 2. \\<And>a list.\n       bs = a # list \\<Longrightarrow>\n       poly_uminus (Poly as) = poly_uminus_inner as", "then"], ["proof (chain)\npicking this:\n  bs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  bs = []\n\ngoal (1 subgoal):\n 1. poly_uminus (Poly as) = poly_uminus_inner as", "by (simp add: poly_uminus_def monom_0)"], ["proof (state)\nthis:\n  poly_uminus (Poly as) = poly_uminus_inner as\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       bs = a # list \\<Longrightarrow>\n       poly_uminus (Poly as) = poly_uminus_inner as", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       bs = a # list \\<Longrightarrow>\n       poly_uminus (Poly as) = poly_uminus_inner as", "case [simp]: (Cons b cs)"], ["proof (state)\nthis:\n  bs = b # cs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       bs = a # list \\<Longrightarrow>\n       poly_uminus (Poly as) = poly_uminus_inner as", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_uminus (Poly as) = poly_uminus_inner as", "by (simp add: less)"], ["proof (state)\nthis:\n  poly_uminus (Poly as) = poly_uminus_inner as\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_uminus (Poly as) = poly_uminus_inner as\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_uminus (Poly as) = poly_uminus_inner as\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly_uminus (Poly ?as) = poly_uminus_inner ?as\n\ngoal (1 subgoal):\n 1. poly_uminus p = poly_uminus_inner (coeffs p)", "from this[of \"coeffs p\"]"], ["proof (chain)\npicking this:\n  poly_uminus (Poly (coeffs p)) = poly_uminus_inner (coeffs p)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_uminus (Poly (coeffs p)) = poly_uminus_inner (coeffs p)\n\ngoal (1 subgoal):\n 1. poly_uminus p = poly_uminus_inner (coeffs p)", "by simp"], ["proof (state)\nthis:\n  poly_uminus p = poly_uminus_inner (coeffs p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_uminus_inner_0[simp]: \"poly_uminus_inner as = 0 \\<longleftrightarrow> Poly as = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_uminus_inner as = 0) = (Poly as = 0)", "by (induct as rule: poly_uminus_inner.induct, auto)"], ["", "lemma degree_poly_uminus_inner[simp]: \"degree (poly_uminus_inner as) = degree (Poly as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_uminus_inner as) = degree (Poly as)", "by (induct as rule: poly_uminus_inner.induct, auto)"], ["", "lemma ipoly_uminus_inner[simp]:\n  \"ipoly (poly_uminus_inner as) (x::'a::comm_ring_1) = ipoly (Poly as) (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (poly_uminus_inner as) x = ipoly (Poly as) (- x)", "by (induct as rule: poly_uminus_inner.induct, auto simp: hom_distribs ring_distribs)"], ["", "lemma represents_uminus: assumes alg: \"p represents x\"\n  shows \"(poly_uminus p) represents (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_uminus p represents - x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_uminus p represents - x", "from representsD[OF alg]"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)", "have \"p \\<noteq> 0\" and rp: \"ipoly p x = 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& ipoly p x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly_uminus p represents - x", "hence 0: \"poly_uminus p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly_uminus p \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  poly_uminus p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_uminus p represents - x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_uminus p represents - x", "by (rule representsI[OF _ 0], insert rp, auto)"], ["proof (state)\nthis:\n  poly_uminus p represents - x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma content_poly_uminus_inner[simp]:\n  fixes as :: \"'a :: ring_gcd list\"\n  shows \"content (poly_uminus_inner as) = content (Poly as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (poly_uminus_inner as) = content (Poly as)", "by (induct as rule: poly_uminus_inner.induct, auto)"], ["", "text \\<open>Multiplicative inverse is represented by @{const reflect_poly}.\\<close>"], ["", "lemma inverse_pow_minus: assumes \"x \\<noteq> (0 :: 'a :: field)\"\n  and \"i \\<le> n\"\n  shows \"inverse x ^ n * x ^ i = inverse x ^ (n - i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse x ^ n * x ^ i = inverse x ^ (n - i)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. inverse x ^ n * x ^ i = inverse x ^ (n - i)", "by (simp add: field_class.field_divide_inverse power_diff power_inverse)"], ["", "lemma (in inj_idom_hom) reflect_poly_hom:\n  \"reflect_poly (map_poly hom p) = map_poly hom (reflect_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflect_poly (map_poly hom p) = map_poly hom (reflect_poly p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reflect_poly (map_poly hom p) = map_poly hom (reflect_poly p)", "obtain xs where xs: \"rev (coeffs p) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        rev (coeffs p) = xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rev (coeffs p) = xs\n\ngoal (1 subgoal):\n 1. reflect_poly (map_poly hom p) = map_poly hom (reflect_poly p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. reflect_poly (map_poly hom p) = map_poly hom (reflect_poly p)", "unfolding reflect_poly_def coeffs_map_poly_hom rev_map\n    xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. Poly (map hom xs) = map_poly hom (Poly xs)", "by (induct xs, auto simp: hom_distribs)"], ["proof (state)\nthis:\n  reflect_poly (map_poly hom p) = map_poly hom (reflect_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipoly_reflect_poly: assumes x: \"(x :: 'a :: field_char_0) \\<noteq> 0\"\n  shows \"ipoly (reflect_poly p) x = x ^ (degree p) * ipoly p (inverse x)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (reflect_poly p) x = x ^ degree p * ipoly p (inverse x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipoly (reflect_poly p) x = x ^ degree p * ipoly p (inverse x)", "let ?or = \"of_int :: int \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. ipoly (reflect_poly p) x = x ^ degree p * ipoly p (inverse x)", "have hom: \"inj_idom_hom ?or\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_idom_hom of_int", ".."], ["proof (state)\nthis:\n  inj_idom_hom of_int\n\ngoal (1 subgoal):\n 1. ipoly (reflect_poly p) x = x ^ degree p * ipoly p (inverse x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (reflect_poly p) x = x ^ degree p * ipoly p (inverse x)", "using poly_reflect_poly_nz[OF x, of \"map_poly ?or p\"]"], ["proof (prove)\nusing this:\n  poly (reflect_poly (of_int_poly p)) x =\n  x ^ degree (of_int_poly p) * ipoly p (inverse x)\n\ngoal (1 subgoal):\n 1. ipoly (reflect_poly p) x = x ^ degree p * ipoly p (inverse x)", "by (simp add: inj_idom_hom.reflect_poly_hom[OF hom])"], ["proof (state)\nthis:\n  ipoly (reflect_poly p) x = x ^ degree p * ipoly p (inverse x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represents_inverse: assumes x: \"x \\<noteq> 0\"\n  and alg: \"p represents x\"\n  shows \"(reflect_poly p) represents (inverse x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflect_poly p represents inverse x", "proof (intro representsI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ipoly (reflect_poly p) (inverse x) = (0::'a)\n 2. reflect_poly p \\<noteq> 0", "from representsD[OF alg]"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)", "have \"p \\<noteq> 0\" and rp: \"ipoly p x = 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& ipoly p x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)\n\ngoal (2 subgoals):\n 1. ipoly (reflect_poly p) (inverse x) = (0::'a)\n 2. reflect_poly p \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)", "show \"reflect_poly p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. reflect_poly p \\<noteq> 0", "by (metis reflect_poly_0 reflect_poly_at_0_eq_0_iff)"], ["proof (state)\nthis:\n  reflect_poly p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ipoly (reflect_poly p) (inverse x) = (0::'a)", "show \"ipoly (reflect_poly p) (inverse x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (reflect_poly p) (inverse x) = (0::'a)", "by (subst ipoly_reflect_poly, insert x, auto simp:rp)"], ["proof (state)\nthis:\n  ipoly (reflect_poly p) (inverse x) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_roots: assumes x: \"(x :: 'a :: field_char_0) \\<noteq> 0\"\n  shows \"ipoly (reflect_poly p) x = 0 \\<longleftrightarrow> ipoly p (inverse x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipoly (reflect_poly p) x = (0::'a)) = (ipoly p (inverse x) = (0::'a))", "using x"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (ipoly (reflect_poly p) x = (0::'a)) = (ipoly p (inverse x) = (0::'a))", "by (auto simp: ipoly_reflect_poly)"], ["", "context\n  fixes n :: nat\nbegin"], ["", "text \\<open>Polynomial for n-th root.\\<close>"], ["", "definition poly_nth_root :: \"'a :: idom poly \\<Rightarrow> 'a poly\" where\n  \"poly_nth_root p = p \\<circ>\\<^sub>p monom 1 n\""], ["", "lemma ipoly_nth_root:\n  fixes x :: \"'a :: idom\"\n  shows \"ipoly (poly_nth_root p) x = ipoly p (x ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (local.poly_nth_root p) x = ipoly p (x ^ n)", "unfolding poly_nth_root_def ipoly_poly_compose"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly p (ipoly (monom 1 n) x) = ipoly p (x ^ n)", "by (simp add: map_poly_monom poly_monom)"], ["", "context\n  assumes n: \"n \\<noteq> 0\"\nbegin"], ["", "lemma poly_nth_root_0[simp]: \"poly_nth_root p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.poly_nth_root p = 0) = (p = 0)", "unfolding poly_nth_root_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<circ>\\<^sub>p monom (1::'a) n = 0) = (p = 0)", "by (rule pcompose_eq_0, insert n, auto simp: degree_monom_eq)"], ["", "lemma represents_nth_root:\n  assumes y: \"y^n = x\" and alg: \"p represents x\"\n  shows \"(poly_nth_root p) represents y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.poly_nth_root p represents y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.poly_nth_root p represents y", "from representsD[OF alg]"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)", "have \"p \\<noteq> 0\" and rp: \"ipoly p x = 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& ipoly p x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. local.poly_nth_root p represents y", "hence 0: \"poly_nth_root p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  ipoly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. local.poly_nth_root p \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  local.poly_nth_root p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. local.poly_nth_root p represents y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.poly_nth_root p represents y", "by (rule representsI[OF _ 0], unfold ipoly_nth_root y rp, simp)"], ["proof (state)\nthis:\n  local.poly_nth_root p represents y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represents_nth_root_odd_real:\n  assumes alg: \"p represents x\" and odd: \"odd n\"\n  shows \"(poly_nth_root p) represents (root n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.poly_nth_root p represents root n x", "by (rule represents_nth_root[OF odd_real_root_pow[OF odd] alg])"], ["", "lemma represents_nth_root_pos_real:\n  assumes alg: \"p represents x\" and pos: \"x > 0\"\n  shows \"(poly_nth_root p) represents (root n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.poly_nth_root p represents root n x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.poly_nth_root p represents root n x", "from n"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "have id: \"Suc (n - 1) = n\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Suc (n - 1) = n", "by auto"], ["proof (state)\nthis:\n  Suc (n - 1) = n\n\ngoal (1 subgoal):\n 1. local.poly_nth_root p represents root n x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.poly_nth_root p represents root n x", "proof (rule represents_nth_root[OF _ alg])"], ["proof (state)\ngoal (1 subgoal):\n 1. root n x ^ n = x", "show \"root n x ^ n = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root n x ^ n = x", "using id pos"], ["proof (prove)\nusing this:\n  Suc (n - 1) = n\n  0 < x\n\ngoal (1 subgoal):\n 1. root n x ^ n = x", "by auto"], ["proof (state)\nthis:\n  root n x ^ n = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.poly_nth_root p represents root n x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represents_nth_root_neg_real:\n  assumes alg: \"p represents x\" and neg: \"x < 0\"\n  shows \"(poly_uminus (poly_nth_root (poly_uminus p))) represents (root n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_uminus (local.poly_nth_root (poly_uminus p)) represents root n x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_uminus (local.poly_nth_root (poly_uminus p)) represents root n x", "have rt: \"root n x = - root n (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root n x = - root n (- x)", "unfolding real_root_minus"], ["proof (prove)\ngoal (1 subgoal):\n 1. root n x = - (- root n x)", "by simp"], ["proof (state)\nthis:\n  root n x = - root n (- x)\n\ngoal (1 subgoal):\n 1. poly_uminus (local.poly_nth_root (poly_uminus p)) represents root n x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_uminus (local.poly_nth_root (poly_uminus p)) represents root n x", "unfolding rt"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_uminus (local.poly_nth_root (poly_uminus p)) represents\n    - root n (- x)", "by (rule represents_uminus[OF represents_nth_root_pos_real[OF represents_uminus[OF alg]]], insert neg, auto)"], ["proof (state)\nthis:\n  poly_uminus (local.poly_nth_root (poly_uminus p)) represents root n x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "lemma represents_csqrt:\n  assumes alg: \"p represents x\" shows \"(poly_nth_root 2 p) represents (csqrt x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_nth_root 2 p represents csqrt x", "by (rule represents_nth_root[OF _ _ alg], auto)"], ["", "lemma represents_sqrt:\n  assumes alg: \"p represents x\" and pos: \"x \\<ge> 0\"\n  shows \"(poly_nth_root 2 p) represents (sqrt x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_nth_root 2 p represents sqrt x", "by (rule represents_nth_root[OF _ _ alg], insert pos, auto)"], ["", "lemma represents_degree:\n  assumes \"p represents x\" shows \"degree p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow> False", "assume \"degree p = 0\""], ["proof (state)\nthis:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow> False", "from degree0_coeffs[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>a. p = [:a:]", "obtain c where p: \"p = [:c:]\""], ["proof (prove)\nusing this:\n  \\<exists>a. p = [:a:]\n\ngoal (1 subgoal):\n 1. (\\<And>c. p = [:c:] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p = [:c:]\n\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow> False", "from assms[unfolded represents_def p]"], ["proof (chain)\npicking this:\n  ipoly [:c:] x = (0::'a) \\<and> [:c:] \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  ipoly [:c:] x = (0::'a) \\<and> [:c:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Polynomial for multiplying a rational number with an algebraic number.\\<close>"], ["", "definition poly_mult_rat_main where\n  \"poly_mult_rat_main n d (f :: 'a :: idom poly) = (let fs = coeffs f; k = length fs in\n    poly_of_list (map (\\<lambda> (fi, i). fi * d ^ i * n ^ (k - Suc i)) (zip fs [0 ..< k])))\""], ["", "definition poly_mult_rat :: \"rat \\<Rightarrow> int poly \\<Rightarrow> int poly\" where\n  \"poly_mult_rat r p \\<equiv> case quotient_of r of (n,d) \\<Rightarrow> poly_mult_rat_main n d p\""], ["", "lemma coeff_poly_mult_rat_main: \"coeff (poly_mult_rat_main n d f) i = coeff f i * n ^ (degree f - i) * d ^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_mult_rat_main n d f) i =\n    coeff f i * n ^ (degree f - i) * d ^ i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (poly_mult_rat_main n d f) i =\n    coeff f i * n ^ (degree f - i) * d ^ i", "have id: \"coeff (poly_mult_rat_main n d f) i = (coeff f i * d ^ i) * n ^ (length (coeffs f) - Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_mult_rat_main n d f) i =\n    coeff f i * d ^ i * n ^ (length (coeffs f) - Suc i)", "unfolding poly_mult_rat_main_def Let_def poly_of_list_def coeff_Poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a)\n     (map2 (\\<lambda>fi i. fi * d ^ i * n ^ (length (coeffs f) - Suc i))\n       (coeffs f) [0..<length (coeffs f)])\n     i =\n    coeff f i * d ^ i * n ^ (length (coeffs f) - Suc i)", "unfolding nth_default_coeffs_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. nth_default (0::'a)\n     (map2 (\\<lambda>fi i. fi * d ^ i * n ^ (length (coeffs f) - Suc i))\n       (coeffs f) [0..<length (coeffs f)])\n     i =\n    nth_default (0::'a) (coeffs f) i * d ^ i *\n    n ^ (length (coeffs f) - Suc i)", "unfolding nth_default_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i < length\n             (map2\n               (\\<lambda>fi i. fi * d ^ i * n ^ (length (coeffs f) - Suc i))\n               (coeffs f) [0..<length (coeffs f)])\n     then map2 (\\<lambda>fi i. fi * d ^ i * n ^ (length (coeffs f) - Suc i))\n           (coeffs f) [0..<length (coeffs f)] !\n          i\n     else (0::'a)) =\n    (if i < length (coeffs f) then coeffs f ! i else (0::'a)) * d ^ i *\n    n ^ (length (coeffs f) - Suc i)", "by auto"], ["proof (state)\nthis:\n  coeff (poly_mult_rat_main n d f) i =\n  coeff f i * d ^ i * n ^ (length (coeffs f) - Suc i)\n\ngoal (1 subgoal):\n 1. coeff (poly_mult_rat_main n d f) i =\n    coeff f i * n ^ (degree f - i) * d ^ i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_mult_rat_main n d f) i =\n    coeff f i * n ^ (degree f - i) * d ^ i", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff f i * d ^ i * n ^ (length (coeffs f) - Suc i) =\n    coeff f i * n ^ (degree f - i) * d ^ i", "by (simp add: degree_eq_length_coeffs)"], ["proof (state)\nthis:\n  coeff (poly_mult_rat_main n d f) i =\n  coeff f i * n ^ (degree f - i) * d ^ i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_poly_mult_rat_main: \"n \\<noteq> 0 \\<Longrightarrow> degree (poly_mult_rat_main n d f) = (if d = 0 then 0 else degree f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> (0::'a) \\<Longrightarrow>\n    degree (poly_mult_rat_main n d f) =\n    (if d = (0::'a) then 0 else degree f)", "proof (cases \"d = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<noteq> (0::'a); d = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> degree (poly_mult_rat_main n d f) =\n                      (if d = (0::'a) then 0 else degree f)\n 2. \\<lbrakk>n \\<noteq> (0::'a); d \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> degree (poly_mult_rat_main n d f) =\n                      (if d = (0::'a) then 0 else degree f)", "case True"], ["proof (state)\nthis:\n  d = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<noteq> (0::'a); d = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> degree (poly_mult_rat_main n d f) =\n                      (if d = (0::'a) then 0 else degree f)\n 2. \\<lbrakk>n \\<noteq> (0::'a); d \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> degree (poly_mult_rat_main n d f) =\n                      (if d = (0::'a) then 0 else degree f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  d = (0::'a)\n\ngoal (1 subgoal):\n 1. degree (poly_mult_rat_main n d f) =\n    (if d = (0::'a) then 0 else degree f)", "unfolding degree_def"], ["proof (prove)\nusing this:\n  d = (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST na.\n        \\<forall>i>na. coeff (poly_mult_rat_main n d f) i = (0::'a)) =\n    (if d = (0::'a) then 0 else LEAST n. \\<forall>i>n. coeff f i = (0::'a))", "unfolding coeff_poly_mult_rat_main"], ["proof (prove)\nusing this:\n  d = (0::'a)\n\ngoal (1 subgoal):\n 1. (LEAST na.\n        \\<forall>i>na. coeff f i * n ^ (degree f - i) * d ^ i = (0::'a)) =\n    (if d = (0::'a) then 0 else LEAST n. \\<forall>i>n. coeff f i = (0::'a))", "by simp"], ["proof (state)\nthis:\n  degree (poly_mult_rat_main n d f) = (if d = (0::'a) then 0 else degree f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> (0::'a); d \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> degree (poly_mult_rat_main n d f) =\n                      (if d = (0::'a) then 0 else degree f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> (0::'a); d \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> degree (poly_mult_rat_main n d f) =\n                      (if d = (0::'a) then 0 else degree f)", "case False"], ["proof (state)\nthis:\n  d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> (0::'a); d \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> degree (poly_mult_rat_main n d f) =\n                      (if d = (0::'a) then 0 else degree f)", "hence id: \"(d = 0) = False\""], ["proof (prove)\nusing this:\n  d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (d = (0::'a)) = False", "by simp"], ["proof (state)\nthis:\n  (d = (0::'a)) = False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> (0::'a); d \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> degree (poly_mult_rat_main n d f) =\n                      (if d = (0::'a) then 0 else degree f)", "show \"n \\<noteq> 0 \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> (0::'a) \\<Longrightarrow>\n    degree (poly_mult_rat_main n d f) =\n    (if d = (0::'a) then 0 else degree f)", "unfolding degree_def coeff_poly_mult_rat_main id"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> (0::'a) \\<Longrightarrow>\n    (LEAST na.\n        \\<forall>i>na.\n           coeff f i *\n           n ^ ((LEAST n. \\<forall>i>n. coeff f i = (0::'a)) - i) *\n           d ^ i =\n           (0::'a)) =\n    (if False then 0 else LEAST n. \\<forall>i>n. coeff f i = (0::'a))", "by (simp add: id)"], ["proof (state)\nthis:\n  n \\<noteq> (0::'a) \\<Longrightarrow>\n  degree (poly_mult_rat_main n d f) = (if d = (0::'a) then 0 else degree f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipoly_mult_rat_main:\n  fixes x :: \"'a :: {field,ring_char_0}\"\n  assumes \"d \\<noteq> 0\" and \"n \\<noteq> 0\"\n  shows \"ipoly (poly_mult_rat_main n d p) x = of_int n ^ degree p * ipoly p (x * of_int d / of_int n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat_main n d p) x =\n    of_int n ^ degree p * ipoly p (x * of_int d / of_int n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat_main n d p) x =\n    of_int n ^ degree p * ipoly p (x * of_int d / of_int n)", "from assms"], ["proof (chain)\npicking this:\n  d \\<noteq> 0\n  n \\<noteq> 0", "have d: \"(if d = 0 then t else f) = f\" for t f :: 'b"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if d = 0 then t else f) = f", "by simp"], ["proof (state)\nthis:\n  (if d = 0 then ?t1 else ?f1) = ?f1\n\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat_main n d p) x =\n    of_int n ^ degree p * ipoly p (x * of_int d / of_int n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat_main n d p) x =\n    of_int n ^ degree p * ipoly p (x * of_int d / of_int n)", "unfolding poly_altdef of_int_hom.coeff_map_poly_hom mult.assoc[symmetric] of_int_mult[symmetric]\n      sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree (of_int_poly (poly_mult_rat_main n d p)).\n        of_int (coeff (poly_mult_rat_main n d p) i) * x ^ i) =\n    (\\<Sum>na\\<le>degree (of_int_poly p).\n        of_int n ^ degree p * of_int (coeff p na) *\n        (x * of_int d / of_int n) ^ na)", "unfolding of_int_hom.degree_map_poly_hom degree_poly_mult_rat_main[OF assms(2)] d"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>degree p.\n        of_int (coeff (poly_mult_rat_main n d p) i) * x ^ i) =\n    (\\<Sum>na\\<le>degree p.\n        of_int n ^ degree p * of_int (coeff p na) *\n        (x * of_int d / of_int n) ^ na)", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree p} \\<Longrightarrow>\n       of_int (coeff (poly_mult_rat_main n d p) xa) * x ^ xa =\n       of_int n ^ degree p * of_int (coeff p xa) *\n       (x * of_int d / of_int n) ^ xa", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree p} \\<Longrightarrow>\n       of_int (coeff (poly_mult_rat_main n d p) xa) * x ^ xa =\n       of_int n ^ degree p * of_int (coeff p xa) *\n       (x * of_int d / of_int n) ^ xa", "assume \"i \\<in> {..degree p}\""], ["proof (state)\nthis:\n  i \\<in> {..degree p}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree p} \\<Longrightarrow>\n       of_int (coeff (poly_mult_rat_main n d p) xa) * x ^ xa =\n       of_int n ^ degree p * of_int (coeff p xa) *\n       (x * of_int d / of_int n) ^ xa", "hence i: \"i \\<le> degree p\""], ["proof (prove)\nusing this:\n  i \\<in> {..degree p}\n\ngoal (1 subgoal):\n 1. i \\<le> degree p", "by auto"], ["proof (state)\nthis:\n  i \\<le> degree p\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree p} \\<Longrightarrow>\n       of_int (coeff (poly_mult_rat_main n d p) xa) * x ^ xa =\n       of_int n ^ degree p * of_int (coeff p xa) *\n       (x * of_int d / of_int n) ^ xa", "hence id: \"of_int n ^ (degree p - i) = (of_int n ^ degree p / of_int n ^ i :: 'a)\""], ["proof (prove)\nusing this:\n  i \\<le> degree p\n\ngoal (1 subgoal):\n 1. of_int n ^ (degree p - i) = of_int n ^ degree p / of_int n ^ i", "by (simp add: assms(2) power_diff)"], ["proof (state)\nthis:\n  of_int n ^ (degree p - i) = of_int n ^ degree p / of_int n ^ i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree p} \\<Longrightarrow>\n       of_int (coeff (poly_mult_rat_main n d p) xa) * x ^ xa =\n       of_int n ^ degree p * of_int (coeff p xa) *\n       (x * of_int d / of_int n) ^ xa", "thus \"of_int (coeff (poly_mult_rat_main n d p) i) * x ^ i = of_int n ^ degree p * of_int (coeff p i) * (x * of_int d / of_int n) ^ i\""], ["proof (prove)\nusing this:\n  of_int n ^ (degree p - i) = of_int n ^ degree p / of_int n ^ i\n\ngoal (1 subgoal):\n 1. of_int (coeff (poly_mult_rat_main n d p) i) * x ^ i =\n    of_int n ^ degree p * of_int (coeff p i) * (x * of_int d / of_int n) ^ i", "unfolding coeff_poly_mult_rat_main"], ["proof (prove)\nusing this:\n  of_int n ^ (degree p - i) = of_int n ^ degree p / of_int n ^ i\n\ngoal (1 subgoal):\n 1. of_int (coeff p i * n ^ (degree p - i) * d ^ i) * x ^ i =\n    of_int n ^ degree p * of_int (coeff p i) * (x * of_int d / of_int n) ^ i", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  of_int (coeff (poly_mult_rat_main n d p) i) * x ^ i =\n  of_int n ^ degree p * of_int (coeff p i) * (x * of_int d / of_int n) ^ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipoly (poly_mult_rat_main n d p) x =\n  of_int n ^ degree p * ipoly p (x * of_int d / of_int n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_poly_mult_rat[simp]: assumes \"r \\<noteq> 0\" shows \"degree (poly_mult_rat r p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_mult_rat r p) = degree p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (poly_mult_rat r p) = degree p", "obtain n d where quot: \"quotient_of r = (n,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n d.\n        quotient_of r = (n, d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of r = (n, d)\n\ngoal (1 subgoal):\n 1. degree (poly_mult_rat r p) = degree p", "from quotient_of_div[OF quot]"], ["proof (chain)\npicking this:\n  r = rat_of_int n / rat_of_int d", "have r: \"r = of_int n / of_int d\""], ["proof (prove)\nusing this:\n  r = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. r = rat_of_int n / rat_of_int d", "by auto"], ["proof (state)\nthis:\n  r = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. degree (poly_mult_rat r p) = degree p", "from quotient_of_denom_pos[OF quot]"], ["proof (chain)\npicking this:\n  0 < d", "have d: \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (poly_mult_rat r p) = degree p", "with assms r"], ["proof (chain)\npicking this:\n  r \\<noteq> 0\n  r = rat_of_int n / rat_of_int d\n  d \\<noteq> 0", "have n0: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n  r = rat_of_int n / rat_of_int d\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (poly_mult_rat r p) = degree p", "from quot"], ["proof (chain)\npicking this:\n  quotient_of r = (n, d)", "have id: \"poly_mult_rat r p = poly_mult_rat_main n d p\""], ["proof (prove)\nusing this:\n  quotient_of r = (n, d)\n\ngoal (1 subgoal):\n 1. poly_mult_rat r p = poly_mult_rat_main n d p", "unfolding poly_mult_rat_def"], ["proof (prove)\nusing this:\n  quotient_of r = (n, d)\n\ngoal (1 subgoal):\n 1. (case quotient_of r of (n, d) \\<Rightarrow> poly_mult_rat_main n d p) =\n    poly_mult_rat_main n d p", "by simp"], ["proof (state)\nthis:\n  poly_mult_rat r p = poly_mult_rat_main n d p\n\ngoal (1 subgoal):\n 1. degree (poly_mult_rat r p) = degree p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_mult_rat r p) = degree p", "unfolding id degree_poly_mult_rat_main[OF n0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if d = 0 then 0 else degree p) = degree p", "using d"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if d = 0 then 0 else degree p) = degree p", "by simp"], ["proof (state)\nthis:\n  degree (poly_mult_rat r p) = degree p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipoly_mult_rat:\n  assumes r0: \"r \\<noteq> 0\"\n  shows \"ipoly (poly_mult_rat r p) x = of_int (fst (quotient_of r)) ^ degree p * ipoly p (x * inverse (of_rat r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat r p) x =\n    of_int (fst (quotient_of r)) ^ degree p *\n    ipoly p (x * inverse (of_rat r))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat r p) x =\n    of_int (fst (quotient_of r)) ^ degree p *\n    ipoly p (x * inverse (of_rat r))", "obtain n d where quot: \"quotient_of r = (n,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n d.\n        quotient_of r = (n, d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of r = (n, d)\n\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat r p) x =\n    of_int (fst (quotient_of r)) ^ degree p *\n    ipoly p (x * inverse (of_rat r))", "from quotient_of_div[OF quot]"], ["proof (chain)\npicking this:\n  r = rat_of_int n / rat_of_int d", "have r: \"r = of_int n / of_int d\""], ["proof (prove)\nusing this:\n  r = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. r = rat_of_int n / rat_of_int d", "by auto"], ["proof (state)\nthis:\n  r = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat r p) x =\n    of_int (fst (quotient_of r)) ^ degree p *\n    ipoly p (x * inverse (of_rat r))", "from quotient_of_denom_pos[OF quot]"], ["proof (chain)\npicking this:\n  0 < d", "have d: \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat r p) x =\n    of_int (fst (quotient_of r)) ^ degree p *\n    ipoly p (x * inverse (of_rat r))", "from r r0"], ["proof (chain)\npicking this:\n  r = rat_of_int n / rat_of_int d\n  r \\<noteq> 0", "have n: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  r = rat_of_int n / rat_of_int d\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat r p) x =\n    of_int (fst (quotient_of r)) ^ degree p *\n    ipoly p (x * inverse (of_rat r))", "from r d n"], ["proof (chain)\npicking this:\n  r = rat_of_int n / rat_of_int d\n  d \\<noteq> 0\n  n \\<noteq> 0", "have inv: \"of_int d / of_int n = inverse r\""], ["proof (prove)\nusing this:\n  r = rat_of_int n / rat_of_int d\n  d \\<noteq> 0\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int d / rat_of_int n = inverse r", "by simp"], ["proof (state)\nthis:\n  rat_of_int d / rat_of_int n = inverse r\n\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat r p) x =\n    of_int (fst (quotient_of r)) ^ degree p *\n    ipoly p (x * inverse (of_rat r))", "from quot"], ["proof (chain)\npicking this:\n  quotient_of r = (n, d)", "have id: \"poly_mult_rat r p = poly_mult_rat_main n d p\""], ["proof (prove)\nusing this:\n  quotient_of r = (n, d)\n\ngoal (1 subgoal):\n 1. poly_mult_rat r p = poly_mult_rat_main n d p", "unfolding poly_mult_rat_def"], ["proof (prove)\nusing this:\n  quotient_of r = (n, d)\n\ngoal (1 subgoal):\n 1. (case quotient_of r of (n, d) \\<Rightarrow> poly_mult_rat_main n d p) =\n    poly_mult_rat_main n d p", "by simp"], ["proof (state)\nthis:\n  poly_mult_rat r p = poly_mult_rat_main n d p\n\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat r p) x =\n    of_int (fst (quotient_of r)) ^ degree p *\n    ipoly p (x * inverse (of_rat r))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat r p) x =\n    of_int (fst (quotient_of r)) ^ degree p *\n    ipoly p (x * inverse (of_rat r))", "unfolding id ipoly_mult_rat_main[OF d n] quot fst_conv of_rat_inverse[symmetric] inv[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int n ^ degree p * ipoly p (x * of_int d / of_int n) =\n    of_int n ^ degree p * ipoly p (x * of_rat (rat_of_int d / rat_of_int n))", "by (simp add: of_rat_divide)"], ["proof (state)\nthis:\n  ipoly (poly_mult_rat r p) x =\n  of_int (fst (quotient_of r)) ^ degree p * ipoly p (x * inverse (of_rat r))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_mult_rat_main_0[simp]:\n  assumes \"n \\<noteq> 0\" \"d \\<noteq> 0\" shows \"poly_mult_rat_main n d p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_mult_rat_main n d p = 0) = (p = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. poly_mult_rat_main n d p = 0 \\<Longrightarrow> p = 0\n 2. p = 0 \\<Longrightarrow> poly_mult_rat_main n d p = 0", "assume \"p = 0\""], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. poly_mult_rat_main n d p = 0 \\<Longrightarrow> p = 0\n 2. p = 0 \\<Longrightarrow> poly_mult_rat_main n d p = 0", "thus \"poly_mult_rat_main n d p = 0\""], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. poly_mult_rat_main n d p = 0", "by (simp add: poly_mult_rat_main_def)"], ["proof (state)\nthis:\n  poly_mult_rat_main n d p = 0\n\ngoal (1 subgoal):\n 1. poly_mult_rat_main n d p = 0 \\<Longrightarrow> p = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_mult_rat_main n d p = 0 \\<Longrightarrow> p = 0", "assume 0: \"poly_mult_rat_main n d p = 0\""], ["proof (state)\nthis:\n  poly_mult_rat_main n d p = 0\n\ngoal (1 subgoal):\n 1. poly_mult_rat_main n d p = 0 \\<Longrightarrow> p = 0", "{"], ["proof (state)\nthis:\n  poly_mult_rat_main n d p = 0\n\ngoal (1 subgoal):\n 1. poly_mult_rat_main n d p = 0 \\<Longrightarrow> p = 0", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_mult_rat_main n d p = 0 \\<Longrightarrow> p = 0", "from 0"], ["proof (chain)\npicking this:\n  poly_mult_rat_main n d p = 0", "have \"coeff (poly_mult_rat_main n d p) i = 0\""], ["proof (prove)\nusing this:\n  poly_mult_rat_main n d p = 0\n\ngoal (1 subgoal):\n 1. coeff (poly_mult_rat_main n d p) i = (0::'a)", "by simp"], ["proof (state)\nthis:\n  coeff (poly_mult_rat_main n d p) i = (0::'a)\n\ngoal (1 subgoal):\n 1. poly_mult_rat_main n d p = 0 \\<Longrightarrow> p = 0", "hence \"coeff p i = 0\""], ["proof (prove)\nusing this:\n  coeff (poly_mult_rat_main n d p) i = (0::'a)\n\ngoal (1 subgoal):\n 1. coeff p i = (0::'a)", "unfolding coeff_poly_mult_rat_main"], ["proof (prove)\nusing this:\n  coeff p i * n ^ (degree p - i) * d ^ i = (0::'a)\n\ngoal (1 subgoal):\n 1. coeff p i = (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  coeff p i * n ^ (degree p - i) * d ^ i = (0::'a)\n  n \\<noteq> (0::'a)\n  d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. coeff p i = (0::'a)", "by simp"], ["proof (state)\nthis:\n  coeff p i = (0::'a)\n\ngoal (1 subgoal):\n 1. poly_mult_rat_main n d p = 0 \\<Longrightarrow> p = 0", "}"], ["proof (state)\nthis:\n  coeff p ?i2 = (0::'a)\n\ngoal (1 subgoal):\n 1. poly_mult_rat_main n d p = 0 \\<Longrightarrow> p = 0", "thus \"p = 0\""], ["proof (prove)\nusing this:\n  coeff p ?i2 = (0::'a)\n\ngoal (1 subgoal):\n 1. p = 0", "by (intro poly_eqI, auto)"], ["proof (state)\nthis:\n  p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_mult_rat_0[simp]: assumes r0: \"r \\<noteq> 0\" shows \"poly_mult_rat r p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_mult_rat r p = 0) = (p = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly_mult_rat r p = 0) = (p = 0)", "obtain n d where quot: \"quotient_of r = (n,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n d.\n        quotient_of r = (n, d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of r = (n, d)\n\ngoal (1 subgoal):\n 1. (poly_mult_rat r p = 0) = (p = 0)", "from quotient_of_div[OF quot]"], ["proof (chain)\npicking this:\n  r = rat_of_int n / rat_of_int d", "have r: \"r = of_int n / of_int d\""], ["proof (prove)\nusing this:\n  r = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. r = rat_of_int n / rat_of_int d", "by auto"], ["proof (state)\nthis:\n  r = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. (poly_mult_rat r p = 0) = (p = 0)", "from quotient_of_denom_pos[OF quot]"], ["proof (chain)\npicking this:\n  0 < d", "have d: \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (poly_mult_rat r p = 0) = (p = 0)", "from r r0"], ["proof (chain)\npicking this:\n  r = rat_of_int n / rat_of_int d\n  r \\<noteq> 0", "have n: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  r = rat_of_int n / rat_of_int d\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (poly_mult_rat r p = 0) = (p = 0)", "from quot"], ["proof (chain)\npicking this:\n  quotient_of r = (n, d)", "have id: \"poly_mult_rat r p = poly_mult_rat_main n d p\""], ["proof (prove)\nusing this:\n  quotient_of r = (n, d)\n\ngoal (1 subgoal):\n 1. poly_mult_rat r p = poly_mult_rat_main n d p", "unfolding poly_mult_rat_def"], ["proof (prove)\nusing this:\n  quotient_of r = (n, d)\n\ngoal (1 subgoal):\n 1. (case quotient_of r of (n, d) \\<Rightarrow> poly_mult_rat_main n d p) =\n    poly_mult_rat_main n d p", "by simp"], ["proof (state)\nthis:\n  poly_mult_rat r p = poly_mult_rat_main n d p\n\ngoal (1 subgoal):\n 1. (poly_mult_rat r p = 0) = (p = 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_mult_rat r p = 0) = (p = 0)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_mult_rat_main n d p = 0) = (p = 0)", "using n d"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (poly_mult_rat_main n d p = 0) = (p = 0)", "by simp"], ["proof (state)\nthis:\n  (poly_mult_rat r p = 0) = (p = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represents_mult_rat:\n  assumes r: \"r \\<noteq> 0\" and \"p represents x\" shows \"(poly_mult_rat r p) represents (of_rat r * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_mult_rat r p represents of_rat r * x", "using assms"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n  p represents x\n\ngoal (1 subgoal):\n 1. poly_mult_rat r p represents of_rat r * x", "unfolding represents_def ipoly_mult_rat[OF r]"], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n  ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int (fst (quotient_of r)) ^ degree p *\n    ipoly p (of_rat r * x * inverse (of_rat r)) =\n    (0::'a) \\<and>\n    poly_mult_rat r p \\<noteq> 0", "by (simp add: field_simps)"], ["", "text \\<open>Polynomial for adding a rational number on an algebraic number.\n  Again, we do not have to factor afterwards.\\<close>"], ["", "definition poly_add_rat :: \"rat \\<Rightarrow> int poly \\<Rightarrow> int poly\" where\n  \"poly_add_rat r p \\<equiv> case quotient_of r of (n,d) \\<Rightarrow>\n     (poly_mult_rat_main d 1 p \\<circ>\\<^sub>p [:-n,d:])\""], ["", "lemma poly_add_rat_code[code]: \"poly_add_rat r p \\<equiv> case quotient_of r of (n,d) \\<Rightarrow>\n     let p' = (let fs = coeffs p; k = length fs in poly_of_list (map (\\<lambda>(fi, i). fi * d ^ (k - Suc i)) (zip fs [0..<k])));\n         p'' = p' \\<circ>\\<^sub>p [:-n,d:]\n      in p''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_add_rat r p \\<equiv>\n    case quotient_of r of\n    (n, d) \\<Rightarrow>\n      let p' = let fs = coeffs p; k = length fs\n               in poly_of_list\n                   (map2 (\\<lambda>fi i. fi * d ^ (k - Suc i)) fs [0..<k]);\n          p'' = p' \\<circ>\\<^sub>p [:- n, d:]\n      in p''", "unfolding poly_add_rat_def poly_mult_rat_main_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case quotient_of r of\n    (n, d) \\<Rightarrow>\n      poly_of_list\n       (map2 (\\<lambda>fi i. fi * 1 ^ i * d ^ (length (coeffs p) - Suc i))\n         (coeffs p) [0..<length (coeffs p)]) \\<circ>\\<^sub>p\n      [:- n, d:] \\<equiv>\n    case quotient_of r of\n    (n, d) \\<Rightarrow>\n      poly_of_list\n       (map2 (\\<lambda>fi i. fi * d ^ (length (coeffs p) - Suc i))\n         (coeffs p) [0..<length (coeffs p)]) \\<circ>\\<^sub>p\n      [:- n, d:]", "by simp"], ["", "lemma degree_poly_add_rat[simp]: \"degree (poly_add_rat r p) = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_add_rat r p) = degree p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (poly_add_rat r p) = degree p", "obtain n d where quot: \"quotient_of r = (n,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n d.\n        quotient_of r = (n, d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of r = (n, d)\n\ngoal (1 subgoal):\n 1. degree (poly_add_rat r p) = degree p", "from quotient_of_div[OF quot]"], ["proof (chain)\npicking this:\n  r = rat_of_int n / rat_of_int d", "have r: \"r = of_int n / of_int d\""], ["proof (prove)\nusing this:\n  r = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. r = rat_of_int n / rat_of_int d", "by auto"], ["proof (state)\nthis:\n  r = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. degree (poly_add_rat r p) = degree p", "from quotient_of_denom_pos[OF quot]"], ["proof (chain)\npicking this:\n  0 < d", "have d: \"d \\<noteq> 0\" \"d > 0\""], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0 &&& 0 < d", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> 0\n  0 < d\n\ngoal (1 subgoal):\n 1. degree (poly_add_rat r p) = degree p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_add_rat r p) = degree p", "unfolding poly_add_rat_def quot split"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_mult_rat_main d 1 p \\<circ>\\<^sub>p [:- n, d:]) = degree p", "by (simp add: degree_poly_mult_rat_main d)"], ["proof (state)\nthis:\n  degree (poly_add_rat r p) = degree p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipoly_add_rat: \"ipoly (poly_add_rat r p) x = (of_int (snd (quotient_of r)) ^ degree p) * ipoly p (x - of_rat r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (poly_add_rat r p) x =\n    of_int (snd (quotient_of r)) ^ degree p * ipoly p (x - of_rat r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipoly (poly_add_rat r p) x =\n    of_int (snd (quotient_of r)) ^ degree p * ipoly p (x - of_rat r)", "obtain n d where quot: \"quotient_of r = (n,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n d.\n        quotient_of r = (n, d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of r = (n, d)\n\ngoal (1 subgoal):\n 1. ipoly (poly_add_rat r p) x =\n    of_int (snd (quotient_of r)) ^ degree p * ipoly p (x - of_rat r)", "from quotient_of_div[OF quot]"], ["proof (chain)\npicking this:\n  r = rat_of_int n / rat_of_int d", "have r: \"r = of_int n / of_int d\""], ["proof (prove)\nusing this:\n  r = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. r = rat_of_int n / rat_of_int d", "by auto"], ["proof (state)\nthis:\n  r = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. ipoly (poly_add_rat r p) x =\n    of_int (snd (quotient_of r)) ^ degree p * ipoly p (x - of_rat r)", "from quotient_of_denom_pos[OF quot]"], ["proof (chain)\npicking this:\n  0 < d", "have d: \"d \\<noteq> 0\" \"d > 0\""], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0 &&& 0 < d", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> 0\n  0 < d\n\ngoal (1 subgoal):\n 1. ipoly (poly_add_rat r p) x =\n    of_int (snd (quotient_of r)) ^ degree p * ipoly p (x - of_rat r)", "have id: \"ipoly [:- n, 1:] (x / of_int d :: 'a) = - of_int n + x / of_int d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly [:- n, 1:] (x / of_int d) = - of_int n + x / of_int d", "by simp"], ["proof (state)\nthis:\n  ipoly [:- n, 1:] (x / of_int d) = - of_int n + x / of_int d\n\ngoal (1 subgoal):\n 1. ipoly (poly_add_rat r p) x =\n    of_int (snd (quotient_of r)) ^ degree p * ipoly p (x - of_rat r)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (poly_add_rat r p) x =\n    of_int (snd (quotient_of r)) ^ degree p * ipoly p (x - of_rat r)", "unfolding poly_add_rat_def quot split"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipoly (poly_mult_rat_main d 1 p \\<circ>\\<^sub>p [:- n, d:]) x =\n    of_int (snd (n, d)) ^ degree p * ipoly p (x - of_rat r)", "by (simp add: ipoly_mult_rat_main ipoly_poly_compose d r degree_poly_mult_rat_main field_simps id of_rat_divide)"], ["proof (state)\nthis:\n  ipoly (poly_add_rat r p) x =\n  of_int (snd (quotient_of r)) ^ degree p * ipoly p (x - of_rat r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_add_rat_0[simp]: \"poly_add_rat r p = 0 \\<longleftrightarrow> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_add_rat r p = 0) = (p = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly_add_rat r p = 0) = (p = 0)", "obtain n d where quot: \"quotient_of r = (n,d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n d.\n        quotient_of r = (n, d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  quotient_of r = (n, d)\n\ngoal (1 subgoal):\n 1. (poly_add_rat r p = 0) = (p = 0)", "from quotient_of_div[OF quot]"], ["proof (chain)\npicking this:\n  r = rat_of_int n / rat_of_int d", "have r: \"r = of_int n / of_int d\""], ["proof (prove)\nusing this:\n  r = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. r = rat_of_int n / rat_of_int d", "by auto"], ["proof (state)\nthis:\n  r = rat_of_int n / rat_of_int d\n\ngoal (1 subgoal):\n 1. (poly_add_rat r p = 0) = (p = 0)", "from quotient_of_denom_pos[OF quot]"], ["proof (chain)\npicking this:\n  0 < d", "have d: \"d \\<noteq> 0\" \"d > 0\""], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0 &&& 0 < d", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> 0\n  0 < d\n\ngoal (1 subgoal):\n 1. (poly_add_rat r p = 0) = (p = 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_add_rat r p = 0) = (p = 0)", "unfolding poly_add_rat_def quot split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly_mult_rat_main d 1 p \\<circ>\\<^sub>p [:- n, d:] = 0) = (p = 0)", "by (simp add: d pcompose_eq_0)"], ["proof (state)\nthis:\n  (poly_add_rat r p = 0) = (p = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_rat_roots: \"ipoly (poly_add_rat r p) x = 0 \\<longleftrightarrow> ipoly p (x - of_rat r) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipoly (poly_add_rat r p) x = (0::'a)) =\n    (ipoly p (x - of_rat r) = (0::'a))", "unfolding ipoly_add_rat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int (snd (quotient_of r)) ^ degree p * ipoly p (x - of_rat r) =\n     (0::'a)) =\n    (ipoly p (x - of_rat r) = (0::'a))", "using quotient_of_nonzero"], ["proof (prove)\nusing this:\n  0 < snd (quotient_of ?r)\n  snd (quotient_of ?r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (of_int (snd (quotient_of r)) ^ degree p * ipoly p (x - of_rat r) =\n     (0::'a)) =\n    (ipoly p (x - of_rat r) = (0::'a))", "by auto"], ["", "lemma represents_add_rat:\n  assumes \"p represents x\" shows \"(poly_add_rat r p) represents (of_rat r + x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_add_rat r p represents of_rat r + x", "using assms"], ["proof (prove)\nusing this:\n  p represents x\n\ngoal (1 subgoal):\n 1. poly_add_rat r p represents of_rat r + x", "unfolding represents_def ipoly_add_rat"], ["proof (prove)\nusing this:\n  ipoly p x = (0::'a) \\<and> p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_int (snd (quotient_of r)) ^ degree p *\n    ipoly p (of_rat r + x - of_rat r) =\n    (0::'a) \\<and>\n    poly_add_rat r p \\<noteq> 0", "by simp"], ["", "(* TODO: move? *)"], ["", "lemmas pos_mult[simplified,simp] = mult_less_cancel_left_pos[of _ 0] mult_less_cancel_left_pos[of _ _ 0]"], ["", "lemma ipoly_add_rat_pos_neg:\n  \"ipoly (poly_add_rat r p) (x::'a::linordered_field) < 0 \\<longleftrightarrow> ipoly p (x - of_rat r) < 0\"\n  \"ipoly (poly_add_rat r p) (x::'a::linordered_field) > 0 \\<longleftrightarrow> ipoly p (x - of_rat r) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipoly (poly_add_rat r p) x < (0::'a)) =\n    (ipoly p (x - of_rat r) < (0::'a)) &&&\n    ((0::'a) < ipoly (poly_add_rat r p) x) =\n    ((0::'a) < ipoly p (x - of_rat r))", "using quotient_of_nonzero"], ["proof (prove)\nusing this:\n  0 < snd (quotient_of ?r)\n  snd (quotient_of ?r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (ipoly (poly_add_rat r p) x < (0::'a)) =\n    (ipoly p (x - of_rat r) < (0::'a)) &&&\n    ((0::'a) < ipoly (poly_add_rat r p) x) =\n    ((0::'a) < ipoly p (x - of_rat r))", "unfolding ipoly_add_rat"], ["proof (prove)\nusing this:\n  0 < snd (quotient_of ?r)\n  snd (quotient_of ?r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (of_int (snd (quotient_of r)) ^ degree p * ipoly p (x - of_rat r)\n     < (0::'a)) =\n    (ipoly p (x - of_rat r) < (0::'a)) &&&\n    ((0::'a)\n     < of_int (snd (quotient_of r)) ^ degree p * ipoly p (x - of_rat r)) =\n    ((0::'a) < ipoly p (x - of_rat r))", "by auto"], ["", "lemma sgn_ipoly_add_rat[simp]:\n  \"sgn (ipoly (poly_add_rat r p) (x::'a::linordered_field)) = sgn (ipoly p (x - of_rat r))\" (is \"sgn ?l = sgn ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (ipoly (poly_add_rat r p) x) = sgn (ipoly p (x - of_rat r))", "using ipoly_add_rat_pos_neg[of r p x]"], ["proof (prove)\nusing this:\n  (ipoly (poly_add_rat r p) x < (0::'a)) =\n  (ipoly p (x - of_rat r) < (0::'a))\n  ((0::'a) < ipoly (poly_add_rat r p) x) =\n  ((0::'a) < ipoly p (x - of_rat r))\n\ngoal (1 subgoal):\n 1. sgn (ipoly (poly_add_rat r p) x) = sgn (ipoly p (x - of_rat r))", "by (cases ?r \"0::'a\" rule: linorder_cases,auto simp:  sgn_1_pos sgn_1_neg sgn_eq_0_iff)"], ["", "lemma deg_nonzero_represents:\n  assumes deg: \"degree p \\<noteq> 0\" shows \"\\<exists> x :: complex. p represents x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. p represents x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. p represents x", "let ?p = \"of_int_poly p :: complex poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. p represents x", "from fundamental_theorem_algebra_factorized[of ?p]"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     smult (lead_coeff (of_int_poly p))\n      (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n     of_int_poly p \\<and>\n     length as = degree (of_int_poly p)", "obtain as c where id: \"smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = ?p\"\n    and len: \"length as = degree ?p\""], ["proof (prove)\nusing this:\n  \\<exists>as.\n     smult (lead_coeff (of_int_poly p))\n      (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n     of_int_poly p \\<and>\n     length as = degree (of_int_poly p)\n\ngoal (1 subgoal):\n 1. (\\<And>c as.\n        \\<lbrakk>smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) =\n                 of_int_poly p;\n         length as = degree (of_int_poly p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  smult c (\\<Prod>a\\<leftarrow>as. [:- a, 1:]) = of_int_poly p\n  length as = degree (of_int_poly p)\n\ngoal (1 subgoal):\n 1. \\<exists>x. p represents x", "have \"degree ?p = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (of_int_poly p) = degree p", "by simp"], ["proof (state)\nthis:\n  degree (of_int_poly p) = degree p\n\ngoal (1 subgoal):\n 1. \\<exists>x. p represents x", "with deg len"], ["proof (chain)\npicking this:\n  degree p \\<noteq> 0\n  length as = degree (of_int_poly p)\n  degree (of_int_poly p) = degree p", "obtain b bs where as: \"as = b # bs\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n  length as = degree (of_int_poly p)\n  degree (of_int_poly p) = degree p\n\ngoal (1 subgoal):\n 1. (\\<And>b bs. as = b # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases as, auto)"], ["proof (state)\nthis:\n  as = b # bs\n\ngoal (1 subgoal):\n 1. \\<exists>x. p represents x", "have \"p represents b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p represents b", "unfolding represents_def id[symmetric] as"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (smult c (\\<Prod>a\\<leftarrow>b # bs. [:- a, 1:])) b = 0 \\<and>\n    p \\<noteq> 0", "using deg"], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly (smult c (\\<Prod>a\\<leftarrow>b # bs. [:- a, 1:])) b = 0 \\<and>\n    p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p represents b\n\ngoal (1 subgoal):\n 1. \\<exists>x. p represents x", "thus ?thesis"], ["proof (prove)\nusing this:\n  p represents b\n\ngoal (1 subgoal):\n 1. \\<exists>x. p represents x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. p represents x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}