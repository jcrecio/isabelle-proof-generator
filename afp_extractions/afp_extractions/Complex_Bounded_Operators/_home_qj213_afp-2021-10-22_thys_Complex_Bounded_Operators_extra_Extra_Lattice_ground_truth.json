{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators/extra/Extra_Lattice.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators", "problem_names": ["lemma dual_complemented_lattice:\n  \"class.complemented_lattice (\\<lambda>x y. x \\<squnion> (- y)) uminus sup greater_eq greater inf \\<top> \\<bottom>\"", "lemma compl_inf_bot [simp]: \"inf (- x) x = bot\"", "lemma compl_sup_top [simp]: \"sup (- x) x = top\"", "lemma dual_orthocomplemented_lattice:\n  \"class.orthocomplemented_lattice (\\<lambda>x y. x \\<squnion> - y) uminus sup greater_eq greater inf \\<top> \\<bottom>\"", "lemma compl_eq_compl_iff [simp]: \"- x = - y \\<longleftrightarrow> x = y\"", "lemma compl_bot_eq [simp]: \"- bot = top\"", "lemma compl_top_eq [simp]: \"- top = bot\"", "lemma compl_sup [simp]: \"- (x \\<squnion> y) = - x \\<sqinter> - y\"", "lemma compl_inf [simp]: \"- (x \\<sqinter> y) = - x \\<squnion> - y\"", "lemma compl_mono:\n  assumes \"x \\<le> y\"\n  shows \"- y \\<le> - x\"", "lemma compl_le_compl_iff [simp]: \"- x \\<le> - y \\<longleftrightarrow> y \\<le> x\"", "lemma compl_le_swap1:\n  assumes \"y \\<le> - x\"\n  shows \"x \\<le> -y\"", "lemma compl_le_swap2:\n  assumes \"- y \\<le> x\"\n  shows \"- x \\<le> y\"", "lemma compl_less_compl_iff[simp]: \"- x < - y \\<longleftrightarrow> y < x\"", "lemma compl_less_swap1:\n  assumes \"y < - x\"\n  shows \"x < - y\"", "lemma compl_less_swap2:\n  assumes \"- y < x\"\n  shows \"- x < y\"", "lemma sup_cancel_left1: \"sup (sup x a) (sup (- x) b) = top\"", "lemma sup_cancel_left2: \"sup (sup (- x) a) (sup x b) = top\"", "lemma inf_cancel_left1: \"inf (inf x a) (inf (- x) b) = bot\"", "lemma inf_cancel_left2: \"inf (inf (- x) a) (inf x b) = bot\"", "lemma sup_compl_top_left1 [simp]: \"sup (- x) (sup x y) = top\"", "lemma sup_compl_top_left2 [simp]: \"sup x (sup (- x) y) = top\"", "lemma inf_compl_bot_left1 [simp]: \"inf (- x) (inf x y) = bot\"", "lemma inf_compl_bot_left2 [simp]: \"inf x (inf (- x) y) = bot\"", "lemma inf_compl_bot_right [simp]: \"inf x (inf y (- x)) = bot\"", "lemma dual_orthomodular_lattice:\n  \"class.orthomodular_lattice (\\<lambda>x y. x \\<squnion> - y) uminus sup greater_eq greater inf \\<top> \\<bottom>\"", "lemma image_of_maximum:\n  fixes f::\"'a::order \\<Rightarrow> 'b::conditionally_complete_lattice\"\n  assumes \"mono f\"\n    and \"\\<And>x. x:M \\<Longrightarrow> x\\<le>m\"\n    and \"m:M\"\n  shows \"(SUP x\\<in>M. f x) = f m\"", "lemma cSup_eq_cSup:\n  fixes A B :: \\<open>'a::conditionally_complete_lattice set\\<close>\n  assumes bdd: \\<open>bdd_above A\\<close>\n  assumes B: \\<open>\\<And>a. a\\<in>A \\<Longrightarrow> \\<exists>b\\<in>B. b \\<ge> a\\<close>\n  assumes A: \\<open>\\<And>b. b\\<in>B \\<Longrightarrow> \\<exists>a\\<in>A. a \\<ge> b\\<close>\n  shows \\<open>Sup A = Sup B\\<close>"], "translations": [["", "lemma dual_complemented_lattice:\n  \"class.complemented_lattice (\\<lambda>x y. x \\<squnion> (- y)) uminus sup greater_eq greater inf \\<top> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.complemented_lattice (\\<lambda>x y. x \\<squnion> - y) uminus\n     (\\<squnion>) (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y < x)\n     (\\<sqinter>) \\<top> \\<bottom>", "proof (rule class.complemented_lattice.intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. class.bounded_lattice (\\<squnion>) (\\<lambda>x y. y \\<le> x)\n     (\\<lambda>x y. y < x) (\\<sqinter>) \\<top> \\<bottom>\n 2. class.complemented_lattice_axioms (\\<lambda>x y. x \\<squnion> - y)\n     uminus (\\<squnion>) (\\<sqinter>) \\<top> \\<bottom>", "show \"class.bounded_lattice (\\<squnion>) (\\<lambda>x y. (y::'a) \\<le> x) (\\<lambda>x y. y < x) (\\<sqinter>) \\<top> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_lattice (\\<squnion>) (\\<lambda>x y. y \\<le> x)\n     (\\<lambda>x y. y < x) (\\<sqinter>) \\<top> \\<bottom>", "by (rule dual_bounded_lattice)"], ["proof (state)\nthis:\n  class.bounded_lattice (\\<squnion>) (\\<lambda>x y. y \\<le> x)\n   (\\<lambda>x y. y < x) (\\<sqinter>) \\<top> \\<bottom>\n\ngoal (1 subgoal):\n 1. class.complemented_lattice_axioms (\\<lambda>x y. x \\<squnion> - y)\n     uminus (\\<squnion>) (\\<sqinter>) \\<top> \\<bottom>", "show \"class.complemented_lattice_axioms (\\<lambda>x y. (x::'a) \\<squnion> - y) uminus (\\<squnion>) (\\<sqinter>) \\<top> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.complemented_lattice_axioms (\\<lambda>x y. x \\<squnion> - y)\n     uminus (\\<squnion>) (\\<sqinter>) \\<top> \\<bottom>", "by (unfold_locales, auto simp add: diff_eq)"], ["proof (state)\nthis:\n  class.complemented_lattice_axioms (\\<lambda>x y. x \\<squnion> - y) uminus\n   (\\<squnion>) (\\<sqinter>) \\<top> \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compl_inf_bot [simp]: \"inf (- x) x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<sqinter> x = \\<bottom>", "by (simp add: inf_commute)"], ["", "lemma compl_sup_top [simp]: \"sup (- x) x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<squnion> x = \\<top>", "by (simp add: sup_commute)"], ["", "end"], ["", "class complete_complemented_lattice = complemented_lattice + complete_lattice"], ["", "text \\<open>The following class \\<open>complemented_lattice\\<close> describes orthocomplemented lattices,\n  following   \\<^url>\\<open>https://en.wikipedia.org/wiki/Complemented_lattice#Orthocomplementation\\<close>.\\<close>"], ["", "class orthocomplemented_lattice = complemented_lattice +\n  assumes ortho_involution[simp]: \"- (- x) = x\"\n    and ortho_antimono: \"x \\<le> y \\<Longrightarrow> -x \\<ge> -y\" begin"], ["", "lemma dual_orthocomplemented_lattice:\n  \"class.orthocomplemented_lattice (\\<lambda>x y. x \\<squnion> - y) uminus sup greater_eq greater inf \\<top> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.orthocomplemented_lattice (\\<lambda>x y. x \\<squnion> - y) uminus\n     (\\<squnion>) (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y < x)\n     (\\<sqinter>) \\<top> \\<bottom>", "proof (rule class.orthocomplemented_lattice.intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. class.complemented_lattice (\\<lambda>x y. x \\<squnion> - y) uminus\n     (\\<squnion>) (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y < x)\n     (\\<sqinter>) \\<top> \\<bottom>\n 2. class.orthocomplemented_lattice_axioms uminus (\\<lambda>x y. y \\<le> x)", "show \"class.complemented_lattice (\\<lambda>x y. (x::'a) \\<squnion> - y) uminus (\\<squnion>) (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y < x) (\\<sqinter>) \\<top> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.complemented_lattice (\\<lambda>x y. x \\<squnion> - y) uminus\n     (\\<squnion>) (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y < x)\n     (\\<sqinter>) \\<top> \\<bottom>", "by (rule dual_complemented_lattice)"], ["proof (state)\nthis:\n  class.complemented_lattice (\\<lambda>x y. x \\<squnion> - y) uminus\n   (\\<squnion>) (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y < x) (\\<sqinter>)\n   \\<top> \\<bottom>\n\ngoal (1 subgoal):\n 1. class.orthocomplemented_lattice_axioms uminus (\\<lambda>x y. y \\<le> x)", "show \"class.orthocomplemented_lattice_axioms uminus (\\<lambda>x y. (y::'a) \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.orthocomplemented_lattice_axioms uminus (\\<lambda>x y. y \\<le> x)", "by (unfold_locales, auto simp add: diff_eq intro: ortho_antimono)"], ["proof (state)\nthis:\n  class.orthocomplemented_lattice_axioms uminus (\\<lambda>x y. y \\<le> x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compl_eq_compl_iff [simp]: \"- x = - y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- x = - y) = (x = y)", "by (metis ortho_involution)"], ["", "lemma compl_bot_eq [simp]: \"- bot = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<bottom> = \\<top>", "by (metis inf_compl_bot inf_top_left ortho_involution)"], ["", "lemma compl_top_eq [simp]: \"- top = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<top> = \\<bottom>", "using compl_bot_eq ortho_involution"], ["proof (prove)\nusing this:\n  - \\<bottom> = \\<top>\n  - (- ?x) = ?x\n\ngoal (1 subgoal):\n 1. - \\<top> = \\<bottom>", "by blast"], ["", "text \\<open>De Morgan's law\\<close>"], ["", "(* Proof from: https://planetmath.org/orthocomplementedlattice *)"], ["", "lemma compl_sup [simp]: \"- (x \\<squnion> y) = - x \\<sqinter> - y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) = - x \\<sqinter> - y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) = - x \\<sqinter> - y", "have \"- (x \\<squnion> y) \\<le> - x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) \\<le> - x", "by (simp add: ortho_antimono)"], ["proof (state)\nthis:\n  - (x \\<squnion> y) \\<le> - x\n\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) = - x \\<sqinter> - y", "moreover"], ["proof (state)\nthis:\n  - (x \\<squnion> y) \\<le> - x\n\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) = - x \\<sqinter> - y", "have \"- (x \\<squnion> y) \\<le> - y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) \\<le> - y", "by (simp add: ortho_antimono)"], ["proof (state)\nthis:\n  - (x \\<squnion> y) \\<le> - y\n\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) = - x \\<sqinter> - y", "ultimately"], ["proof (chain)\npicking this:\n  - (x \\<squnion> y) \\<le> - x\n  - (x \\<squnion> y) \\<le> - y", "have 1: \"- (x \\<squnion> y) \\<le> - x \\<sqinter> - y\""], ["proof (prove)\nusing this:\n  - (x \\<squnion> y) \\<le> - x\n  - (x \\<squnion> y) \\<le> - y\n\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) \\<le> - x \\<sqinter> - y", "by (simp add: sup.coboundedI1)"], ["proof (state)\nthis:\n  - (x \\<squnion> y) \\<le> - x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) = - x \\<sqinter> - y", "have \\<open>x \\<le> - (-x \\<sqinter> -y)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - (- x \\<sqinter> - y)", "by (metis inf.cobounded1 ortho_antimono ortho_involution)"], ["proof (state)\nthis:\n  x \\<le> - (- x \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) = - x \\<sqinter> - y", "moreover"], ["proof (state)\nthis:\n  x \\<le> - (- x \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) = - x \\<sqinter> - y", "have \\<open>y \\<le> - (-x \\<sqinter> -y)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> - (- x \\<sqinter> - y)", "by (metis inf.cobounded2 ortho_antimono ortho_involution)"], ["proof (state)\nthis:\n  y \\<le> - (- x \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) = - x \\<sqinter> - y", "ultimately"], ["proof (chain)\npicking this:\n  x \\<le> - (- x \\<sqinter> - y)\n  y \\<le> - (- x \\<sqinter> - y)", "have \\<open>x \\<squnion> y \\<le> - (-x \\<sqinter> -y)\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> - (- x \\<sqinter> - y)\n  y \\<le> - (- x \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<le> - (- x \\<sqinter> - y)", "by auto"], ["proof (state)\nthis:\n  x \\<squnion> y \\<le> - (- x \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) = - x \\<sqinter> - y", "hence 2: \\<open>-x \\<sqinter> -y \\<le> - (x \\<squnion> y)\\<close>"], ["proof (prove)\nusing this:\n  x \\<squnion> y \\<le> - (- x \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> - y \\<le> - (x \\<squnion> y)", "using ortho_antimono"], ["proof (prove)\nusing this:\n  x \\<squnion> y \\<le> - (- x \\<sqinter> - y)\n  ?x \\<le> ?y \\<Longrightarrow> - ?y \\<le> - ?x\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> - y \\<le> - (x \\<squnion> y)", "by fastforce"], ["proof (state)\nthis:\n  - x \\<sqinter> - y \\<le> - (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) = - x \\<sqinter> - y", "from 1 2"], ["proof (chain)\npicking this:\n  - (x \\<squnion> y) \\<le> - x \\<sqinter> - y\n  - x \\<sqinter> - y \\<le> - (x \\<squnion> y)", "show ?thesis"], ["proof (prove)\nusing this:\n  - (x \\<squnion> y) \\<le> - x \\<sqinter> - y\n  - x \\<sqinter> - y \\<le> - (x \\<squnion> y)\n\ngoal (1 subgoal):\n 1. - (x \\<squnion> y) = - x \\<sqinter> - y", "by (simp add: eq_iff)"], ["proof (state)\nthis:\n  - (x \\<squnion> y) = - x \\<sqinter> - y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>De Morgan's law\\<close>"], ["", "lemma compl_inf [simp]: \"- (x \\<sqinter> y) = - x \\<squnion> - y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x \\<sqinter> y) = - x \\<squnion> - y", "using compl_sup"], ["proof (prove)\nusing this:\n  - (?x \\<squnion> ?y) = - ?x \\<sqinter> - ?y\n\ngoal (1 subgoal):\n 1. - (x \\<sqinter> y) = - x \\<squnion> - y", "by (metis ortho_involution)"], ["", "lemma compl_mono:\n  assumes \"x \\<le> y\"\n  shows \"- y \\<le> - x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - y \\<le> - x", "by (simp add: assms local.ortho_antimono)"], ["", "lemma compl_le_compl_iff [simp]: \"- x \\<le> - y \\<longleftrightarrow> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- x \\<le> - y) = (y \\<le> x)", "by (auto dest: compl_mono)"], ["", "lemma compl_le_swap1:\n  assumes \"y \\<le> - x\"\n  shows \"x \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - y", "using assms ortho_antimono"], ["proof (prove)\nusing this:\n  y \\<le> - x\n  ?x \\<le> ?y \\<Longrightarrow> - ?y \\<le> - ?x\n\ngoal (1 subgoal):\n 1. x \\<le> - y", "by fastforce"], ["", "lemma compl_le_swap2:\n  assumes \"- y \\<le> x\"\n  shows \"- x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<le> y", "using assms local.ortho_antimono"], ["proof (prove)\nusing this:\n  - y \\<le> x\n  ?x \\<le> ?y \\<Longrightarrow> - ?y \\<le> - ?x\n\ngoal (1 subgoal):\n 1. - x \\<le> y", "by fastforce"], ["", "lemma compl_less_compl_iff[simp]: \"- x < - y \\<longleftrightarrow> y < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- x < - y) = (y < x)", "by (auto simp add: less_le)"], ["", "lemma compl_less_swap1:\n  assumes \"y < - x\"\n  shows \"x < - y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < - y", "using assms compl_less_compl_iff"], ["proof (prove)\nusing this:\n  y < - x\n  (- ?x < - ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. x < - y", "by fastforce"], ["", "lemma compl_less_swap2:\n  assumes \"- y < x\"\n  shows \"- x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x < y", "using assms compl_le_swap1 compl_le_swap2 less_le_not_le"], ["proof (prove)\nusing this:\n  - y < x\n  ?y \\<le> - ?x \\<Longrightarrow> ?x \\<le> - ?y\n  - ?y \\<le> ?x \\<Longrightarrow> - ?x \\<le> ?y\n  (?x < ?y) = (?x \\<le> ?y \\<and> \\<not> ?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. - x < y", "by auto"], ["", "lemma sup_cancel_left1: \"sup (sup x a) (sup (- x) b) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> a \\<squnion> (- x \\<squnion> b) = \\<top>", "by (simp add: sup_commute sup_left_commute)"], ["", "lemma sup_cancel_left2: \"sup (sup (- x) a) (sup x b) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<squnion> a \\<squnion> (x \\<squnion> b) = \\<top>", "by (simp add: sup.commute sup_left_commute)"], ["", "lemma inf_cancel_left1: \"inf (inf x a) (inf (- x) b) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> a \\<sqinter> (- x \\<sqinter> b) = \\<bottom>", "by (simp add: inf.left_commute inf_commute)"], ["", "lemma inf_cancel_left2: \"inf (inf (- x) a) (inf x b) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<sqinter> a \\<sqinter> (x \\<sqinter> b) = \\<bottom>", "using inf.left_commute inf_commute"], ["proof (prove)\nusing this:\n  ?b \\<sqinter> (?a \\<sqinter> ?c) = ?a \\<sqinter> (?b \\<sqinter> ?c)\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. - x \\<sqinter> a \\<sqinter> (x \\<sqinter> b) = \\<bottom>", "by auto"], ["", "lemma sup_compl_top_left1 [simp]: \"sup (- x) (sup x y) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<squnion> (x \\<squnion> y) = \\<top>", "by (simp add: sup_assoc[symmetric])"], ["", "lemma sup_compl_top_left2 [simp]: \"sup x (sup (- x) y) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> (- x \\<squnion> y) = \\<top>", "using sup_compl_top_left1[of \"- x\" y]"], ["proof (prove)\nusing this:\n  - (- x) \\<squnion> (- x \\<squnion> y) = \\<top>\n\ngoal (1 subgoal):\n 1. x \\<squnion> (- x \\<squnion> y) = \\<top>", "by simp"], ["", "lemma inf_compl_bot_left1 [simp]: \"inf (- x) (inf x y) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<sqinter> (x \\<sqinter> y) = \\<bottom>", "by (simp add: inf_assoc[symmetric])"], ["", "lemma inf_compl_bot_left2 [simp]: \"inf x (inf (- x) y) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (- x \\<sqinter> y) = \\<bottom>", "using inf_compl_bot_left1[of \"- x\" y]"], ["proof (prove)\nusing this:\n  - (- x) \\<sqinter> (- x \\<sqinter> y) = \\<bottom>\n\ngoal (1 subgoal):\n 1. x \\<sqinter> (- x \\<sqinter> y) = \\<bottom>", "by simp"], ["", "lemma inf_compl_bot_right [simp]: \"inf x (inf y (- x)) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (y \\<sqinter> - x) = \\<bottom>", "by (subst inf_left_commute) simp"], ["", "end"], ["", "class complete_orthocomplemented_lattice = orthocomplemented_lattice + complete_lattice"], ["", "instance complete_orthocomplemented_lattice \\<subseteq> complete_complemented_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, complete_complemented_lattice_class)", "by intro_classes"], ["", "text \\<open>The following class \\<open>orthomodular_lattice\\<close> describes orthomodular lattices,\nfollowing   \\<^url>\\<open>https://en.wikipedia.org/wiki/Complemented_lattice#Orthomodular_lattices\\<close>.\\<close>"], ["", "class orthomodular_lattice = orthocomplemented_lattice +\n  assumes orthomodular: \"x \\<le> y \\<Longrightarrow> sup x (inf (-x) y) = y\" begin"], ["", "lemma dual_orthomodular_lattice:\n  \"class.orthomodular_lattice (\\<lambda>x y. x \\<squnion> - y) uminus sup greater_eq greater inf \\<top> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.orthomodular_lattice (\\<lambda>x y. x \\<squnion> - y) uminus\n     (\\<squnion>) (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y < x)\n     (\\<sqinter>) \\<top> \\<bottom>", "proof (rule class.orthomodular_lattice.intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. class.orthocomplemented_lattice (\\<lambda>x y. x \\<squnion> - y) uminus\n     (\\<squnion>) (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y < x)\n     (\\<sqinter>) \\<top> \\<bottom>\n 2. class.orthomodular_lattice_axioms uminus (\\<squnion>)\n     (\\<lambda>x y. y \\<le> x) (\\<sqinter>)", "show \"class.orthocomplemented_lattice (\\<lambda>x y. (x::'a) \\<squnion> - y) uminus (\\<squnion>) (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y < x) (\\<sqinter>) \\<top> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.orthocomplemented_lattice (\\<lambda>x y. x \\<squnion> - y) uminus\n     (\\<squnion>) (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y < x)\n     (\\<sqinter>) \\<top> \\<bottom>", "by (rule dual_orthocomplemented_lattice)"], ["proof (state)\nthis:\n  class.orthocomplemented_lattice (\\<lambda>x y. x \\<squnion> - y) uminus\n   (\\<squnion>) (\\<lambda>x y. y \\<le> x) (\\<lambda>x y. y < x) (\\<sqinter>)\n   \\<top> \\<bottom>\n\ngoal (1 subgoal):\n 1. class.orthomodular_lattice_axioms uminus (\\<squnion>)\n     (\\<lambda>x y. y \\<le> x) (\\<sqinter>)", "show \"class.orthomodular_lattice_axioms uminus (\\<squnion>) (\\<lambda>x y. (y::'a) \\<le> x) (\\<sqinter>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.orthomodular_lattice_axioms uminus (\\<squnion>)\n     (\\<lambda>x y. y \\<le> x) (\\<sqinter>)", "proof (unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> (- x \\<squnion> y) = y", "show \"(x::'a) \\<sqinter> (- x \\<squnion> y) = y\"\n      if \"(y::'a) \\<le> x\"\n      for x :: 'a\n        and y :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (- x \\<squnion> y) = y", "using that local.compl_eq_compl_iff local.ortho_antimono local.orthomodular"], ["proof (prove)\nusing this:\n  y \\<le> x\n  (- ?x = - ?y) = (?x = ?y)\n  ?x \\<le> ?y \\<Longrightarrow> - ?y \\<le> - ?x\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<squnion> - ?x \\<sqinter> ?y = ?y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> (- x \\<squnion> y) = y", "by fastforce"], ["proof (state)\nthis:\n  ?y \\<le> ?x \\<Longrightarrow> ?x \\<sqinter> (- ?x \\<squnion> ?y) = ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  class.orthomodular_lattice_axioms uminus (\\<squnion>)\n   (\\<lambda>x y. y \\<le> x) (\\<sqinter>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "class complete_orthomodular_lattice = orthomodular_lattice + complete_lattice begin"], ["", "end"], ["", "instance complete_orthomodular_lattice \\<subseteq> complete_orthocomplemented_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, complete_orthocomplemented_lattice_class)", "by intro_classes"], ["", "instance boolean_algebra \\<subseteq> orthomodular_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, orthomodular_lattice_class)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 2. \\<And>x. x \\<squnion> - x = \\<top>\n 3. \\<And>x y. x - y = x \\<sqinter> - y\n 4. \\<And>x. - (- x) = x\n 5. \\<And>x y. x \\<le> y \\<Longrightarrow> - y \\<le> - x\n 6. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<squnion> - x \\<sqinter> y = y", "fix x y :: 'a"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 2. \\<And>x. x \\<squnion> - x = \\<top>\n 3. \\<And>x y. x - y = x \\<sqinter> - y\n 4. \\<And>x. - (- x) = x\n 5. \\<And>x y. x \\<le> y \\<Longrightarrow> - y \\<le> - x\n 6. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<squnion> - x \\<sqinter> y = y", "show \"sup (x::'a) (inf (- x) y) = y\"\n    if \"(x::'a) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> - x \\<sqinter> y = y", "using that"], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<squnion> - x \\<sqinter> y = y", "by (simp add: sup.absorb_iff2 sup_inf_distrib1)"], ["proof (state)\nthis:\n  x \\<le> y \\<Longrightarrow> x \\<squnion> - x \\<sqinter> y = y\n\ngoal (5 subgoals):\n 1. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 2. \\<And>x. x \\<squnion> - x = \\<top>\n 3. \\<And>x y. x - y = x \\<sqinter> - y\n 4. \\<And>x. - (- x) = x\n 5. \\<And>x y. x \\<le> y \\<Longrightarrow> - y \\<le> - x", "show \"x - y = inf x (- y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - y = x \\<sqinter> - y", "by (simp add: boolean_algebra_class.diff_eq)"], ["proof (state)\nthis:\n  x - y = x \\<sqinter> - y\n\ngoal (4 subgoals):\n 1. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 2. \\<And>x. x \\<squnion> - x = \\<top>\n 3. \\<And>x. - (- x) = x\n 4. \\<And>x y. x \\<le> y \\<Longrightarrow> - y \\<le> - x", "qed auto"], ["", "instance complete_boolean_algebra \\<subseteq> complete_orthomodular_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, complete_orthomodular_lattice_class)", "by intro_classes"], ["", "lemma image_of_maximum:\n  fixes f::\"'a::order \\<Rightarrow> 'b::conditionally_complete_lattice\"\n  assumes \"mono f\"\n    and \"\\<And>x. x:M \\<Longrightarrow> x\\<le>m\"\n    and \"m:M\"\n  shows \"(SUP x\\<in>M. f x) = f m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (f ` M) = f m", "by (smt (verit, ccfv_threshold) assms(1) assms(2) assms(3) cSup_eq_maximum imageE imageI monoD)"], ["", "lemma cSup_eq_cSup:\n  fixes A B :: \\<open>'a::conditionally_complete_lattice set\\<close>\n  assumes bdd: \\<open>bdd_above A\\<close>\n  assumes B: \\<open>\\<And>a. a\\<in>A \\<Longrightarrow> \\<exists>b\\<in>B. b \\<ge> a\\<close>\n  assumes A: \\<open>\\<And>b. b\\<in>B \\<Longrightarrow> \\<exists>a\\<in>A. a \\<ge> b\\<close>\n  shows \\<open>Sup A = Sup B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> A = \\<Squnion> B", "proof (cases \\<open>B = {}\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B\n 2. B \\<noteq> {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B", "case True"], ["proof (state)\nthis:\n  B = {}\n\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B\n 2. B \\<noteq> {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B", "with A B"], ["proof (chain)\npicking this:\n  ?b \\<in> B \\<Longrightarrow> \\<exists>a\\<in>A. ?b \\<le> a\n  ?a \\<in> A \\<Longrightarrow> \\<exists>b\\<in>B. ?a \\<le> b\n  B = {}", "have \\<open>A = {}\\<close>"], ["proof (prove)\nusing this:\n  ?b \\<in> B \\<Longrightarrow> \\<exists>a\\<in>A. ?b \\<le> a\n  ?a \\<in> A \\<Longrightarrow> \\<exists>b\\<in>B. ?a \\<le> b\n  B = {}\n\ngoal (1 subgoal):\n 1. A = {}", "by auto"], ["proof (state)\nthis:\n  A = {}\n\ngoal (2 subgoals):\n 1. B = {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B\n 2. B \\<noteq> {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B", "with True"], ["proof (chain)\npicking this:\n  B = {}\n  A = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  B = {}\n  A = {}\n\ngoal (1 subgoal):\n 1. \\<Squnion> A = \\<Squnion> B", "by simp"], ["proof (state)\nthis:\n  \\<Squnion> A = \\<Squnion> B\n\ngoal (1 subgoal):\n 1. B \\<noteq> {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B \\<noteq> {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B", "case False"], ["proof (state)\nthis:\n  B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. B \\<noteq> {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B", "have \\<open>bdd_above B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above B", "by (meson A bdd bdd_above_def order_trans)"], ["proof (state)\nthis:\n  bdd_above B\n\ngoal (1 subgoal):\n 1. B \\<noteq> {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B", "have \\<open>A \\<noteq> {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {}", "using A False"], ["proof (prove)\nusing this:\n  ?b \\<in> B \\<Longrightarrow> \\<exists>a\\<in>A. ?b \\<le> a\n  B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. B \\<noteq> {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B", "moreover"], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. B \\<noteq> {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B", "have \\<open>a \\<le> Sup B\\<close> if \\<open>a \\<in> A\\<close> for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> \\<Squnion> B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<le> \\<Squnion> B", "obtain b where \\<open>b \\<in> B\\<close> and \\<open>b \\<ge> a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> B; a \\<le> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using B \\<open>a \\<in> A\\<close>"], ["proof (prove)\nusing this:\n  ?a \\<in> A \\<Longrightarrow> \\<exists>b\\<in>B. ?a \\<le> b\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> B; a \\<le> b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b \\<in> B\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. a \\<le> \\<Squnion> B", "then"], ["proof (chain)\npicking this:\n  b \\<in> B\n  a \\<le> b", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> B\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. a \\<le> \\<Squnion> B", "apply (rule cSup_upper2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above B", "using \\<open>bdd_above B\\<close>"], ["proof (prove)\nusing this:\n  bdd_above B\n\ngoal (1 subgoal):\n 1. bdd_above B", "by simp"], ["proof (state)\nthis:\n  a \\<le> \\<Squnion> B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a \\<in> A \\<Longrightarrow> ?a \\<le> \\<Squnion> B\n\ngoal (1 subgoal):\n 1. B \\<noteq> {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B", "moreover"], ["proof (state)\nthis:\n  ?a \\<in> A \\<Longrightarrow> ?a \\<le> \\<Squnion> B\n\ngoal (1 subgoal):\n 1. B \\<noteq> {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B", "have \\<open>Sup B \\<le> c\\<close> if \\<open>\\<And>a. a \\<in> A \\<Longrightarrow> a \\<le> c\\<close> for c"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> B \\<le> c", "using False"], ["proof (prove)\nusing this:\n  B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<Squnion> B \\<le> c", "apply (rule cSup_least)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> B \\<Longrightarrow> x \\<le> c", "using A that"], ["proof (prove)\nusing this:\n  ?b \\<in> B \\<Longrightarrow> \\<exists>a\\<in>A. ?b \\<le> a\n  ?a \\<in> A \\<Longrightarrow> ?a \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> B \\<Longrightarrow> x \\<le> c", "by fastforce"], ["proof (state)\nthis:\n  (\\<And>a. a \\<in> A \\<Longrightarrow> a \\<le> ?c) \\<Longrightarrow>\n  \\<Squnion> B \\<le> ?c\n\ngoal (1 subgoal):\n 1. B \\<noteq> {} \\<Longrightarrow> \\<Squnion> A = \\<Squnion> B", "ultimately"], ["proof (chain)\npicking this:\n  A \\<noteq> {}\n  ?a \\<in> A \\<Longrightarrow> ?a \\<le> \\<Squnion> B\n  (\\<And>a. a \\<in> A \\<Longrightarrow> a \\<le> ?c) \\<Longrightarrow>\n  \\<Squnion> B \\<le> ?c", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n  ?a \\<in> A \\<Longrightarrow> ?a \\<le> \\<Squnion> B\n  (\\<And>a. a \\<in> A \\<Longrightarrow> a \\<le> ?c) \\<Longrightarrow>\n  \\<Squnion> B \\<le> ?c\n\ngoal (1 subgoal):\n 1. \\<Squnion> A = \\<Squnion> B", "by (rule cSup_eq_non_empty)"], ["proof (state)\nthis:\n  \\<Squnion> A = \\<Squnion> B\n\ngoal:\nNo subgoals!", "qed"], ["", "unbundle no_lattice_notation"], ["", "end"]]}