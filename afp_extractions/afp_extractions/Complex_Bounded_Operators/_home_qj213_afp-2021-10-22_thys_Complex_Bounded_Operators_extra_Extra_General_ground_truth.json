{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators/extra/Extra_General.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators", "problem_names": ["lemma reals_zero_comparable_iff:\n  \"(x::complex)\\<in>\\<real> \\<longleftrightarrow> x \\<le> 0 \\<or> x \\<ge> 0\"", "lemma reals_zero_comparable:\n  fixes x::complex\n  assumes \"x\\<in>\\<real>\"\n  shows \"x \\<le> 0 \\<or> x \\<ge> 0\"", "lemma unique_choice: \"\\<forall>x. \\<exists>!y. Q x y \\<Longrightarrow> \\<exists>!f. \\<forall>x. Q x (f x)\"", "lemma sum_single: \n  assumes \"finite A\"\n  assumes \"\\<And>j. j \\<noteq> i \\<Longrightarrow> j\\<in>A \\<Longrightarrow> f j = 0\"\n  shows \"sum f A = (if i\\<in>A then f i else 0)\"", "lemma image_set_plus: \n  assumes \\<open>linear U\\<close>\n  shows \\<open>U ` (A + B) = U ` A + U ` B\\<close>", "lemma bdd_above_image_mono:\n  assumes \\<open>\\<And>x. x\\<in>S \\<Longrightarrow> f x \\<le> g x\\<close>\n  assumes \\<open>bdd_above (g ` S)\\<close>\n  shows \\<open>bdd_above (f ` S)\\<close>", "lemma L2_set_mono2:\n  assumes a1: \"finite L\" and a2: \"K \\<le> L\"\n  shows \"L2_set f K \\<le> L2_set f L\"", "lemma Sup_real_close:\n  fixes e :: real\n  assumes \"0 < e\"\n    and S: \"bdd_above S\" \"S \\<noteq> {}\"\n  shows \"\\<exists>x\\<in>S. Sup S - e < x\"", "lemma not_singleton_existence[simp]:\n  \\<open>\\<exists> x::('a::not_singleton). x \\<noteq> t\\<close>", "lemma UNIV_not_singleton[simp]: \"(UNIV::_::not_singleton set) \\<noteq> {x}\"", "lemma UNIV_not_singleton_converse: \n  assumes\"\\<And>x::'a. UNIV \\<noteq> {x}\"\n  shows \"\\<exists>x::'a. \\<exists>y. x \\<noteq> y\"", "lemma class_not_singletonI_monoid_add:\n  assumes \"(UNIV::'a set) \\<noteq> {0}\"\n  shows \"class.not_singleton TYPE('a::monoid_add)\"", "lemma not_singleton_vs_CARD_1:\n  assumes \\<open>\\<not> class.not_singleton TYPE('a)\\<close>\n  shows \\<open>class.CARD_1 TYPE('a)\\<close>", "lemma everything_the_same[simp]: \"(x::'a)=y\"", "lemma CARD_1_UNIV: \"UNIV = {x::'a}\"", "lemma CARD_1_ext: \"x (a::'a) = y b \\<Longrightarrow> x = y\"", "lemma enum_CARD_1: \"(Enum.enum :: 'a::{CARD_1,enum} list) = [a]\"", "lemma cauchy_filter_metricI:\n  fixes F :: \"'a::metric_space filter\"\n  assumes \"\\<And>e. e>0 \\<Longrightarrow> \\<exists>P. eventually P F \\<and> (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < e)\"\n  shows \"cauchy_filter F\"", "lemma cauchy_filter_metric_filtermapI:\n  fixes F :: \"'a filter\" and f :: \"'a\\<Rightarrow>'b::metric_space\"\n  assumes \"\\<And>e. e>0 \\<Longrightarrow> \\<exists>P. eventually P F \\<and> (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist (f x) (f y) < e)\"\n  shows \"cauchy_filter (filtermap f F)\"", "lemma tendsto_add_const_iff:\n  \\<comment> \\<open>This is a generalization of \\<open>Limits.tendsto_add_const_iff\\<close>, \n      the only difference is that the sort here is more general.\\<close>\n  \"((\\<lambda>x. c + f x :: 'a::topological_group_add) \\<longlongrightarrow> c + d) F \\<longleftrightarrow> (f \\<longlongrightarrow> d) F\"", "lemma finite_subsets_at_top_minus: \n  assumes \"A\\<subseteq>B\"\n  shows \"finite_subsets_at_top (B - A) \\<le> filtermap (\\<lambda>F. F - A) (finite_subsets_at_top B)\"", "lemma finite_subsets_at_top_inter: \n  assumes \"A\\<subseteq>B\"\n  shows \"filtermap (\\<lambda>F. F \\<inter> A) (finite_subsets_at_top B) \\<le> finite_subsets_at_top A\"", "lemma tendsto_principal_singleton:\n  shows \"(f \\<longlongrightarrow> f x) (principal {x})\"", "lemma complete_singleton: \n  \"complete {s::'a::uniform_space}\"", "lemma cmod_Re:\n  assumes \"x \\<ge> 0\"\n  shows \"cmod x = Re x\"", "lemma abs_complex_real[simp]: \"abs x \\<in> \\<real>\" for x :: complex", "lemma Im_abs[simp]: \"Im (abs x) = 0\"", "lemma cnj_x_x: \"cnj x * x = (abs x)\\<^sup>2\"", "lemma cnj_x_x_geq0[simp]: \"cnj x * x \\<ge> 0\"", "lemma index_of_length: \"index_of x y \\<le> length y\"", "lemma index_of_correct:\n  assumes \"x \\<in> set y\"\n  shows \"y ! index_of x y = x\"", "lemma enum_idx_correct: \n  \"Enum.enum ! enum_idx i = i\"", "lemma index_of_bound: \n  assumes \"y \\<noteq> []\" and \"x \\<in> set y\"\n  shows \"index_of x y < length y\"", "lemma enum_idx_bound: \"enum_idx x < length (Enum.enum :: 'a list)\" for x :: \"'a::enum\"", "lemma index_of_nth:\n  assumes \"distinct xs\"\n  assumes \"i < length xs\"\n  shows \"index_of (xs ! i) xs = i\"", "lemma enum_idx_enum: \n  assumes \\<open>i < CARD('a::enum)\\<close>\n  shows \\<open>enum_idx (enum_class.enum ! i :: 'a) = i\\<close>", "lemma map_filter_map: \"List.map_filter f (map g l) = List.map_filter (f o g) l\"", "lemma map_filter_Some[simp]: \"List.map_filter (\\<lambda>x. Some (f x)) l = map f l\"", "lemma filter_Un: \"Set.filter f (x \\<union> y) = Set.filter f x \\<union> Set.filter f y\"", "lemma Set_filter_unchanged: \"Set.filter P X = X\" if \"\\<And>x. x\\<in>X \\<Longrightarrow> P x\" for P and X :: \"'z set\"", "lemma inj_map_total[simp]: \"inj_map (Some o \\<pi>) = inj \\<pi>\"", "lemma inj_map_Some[simp]: \"inj_map Some\"", "lemma inv_map_total: \n  assumes \"surj \\<pi>\"\n  shows \"inv_map (Some o \\<pi>) = Some o inv \\<pi>\"", "lemma inj_map_map_comp[simp]: \n  assumes a1: \"inj_map f\" and a2: \"inj_map g\" \n  shows \"inj_map (f \\<circ>\\<^sub>m g)\"", "lemma inj_map_inv_map[simp]: \"inj_map (inv_map \\<pi>)\""], "translations": [["", "lemma reals_zero_comparable_iff:\n  \"(x::complex)\\<in>\\<real> \\<longleftrightarrow> x \\<le> 0 \\<or> x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> \\<real>) = (x \\<le> 0 \\<or> 0 \\<le> x)", "unfolding complex_is_Real_iff less_eq_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im x = 0) =\n    (Im x = Im 0 \\<and> Re x \\<le> Re 0 \\<or>\n     Im 0 = Im x \\<and> Re 0 \\<le> Re x)", "by auto"], ["", "lemma reals_zero_comparable:\n  fixes x::complex\n  assumes \"x\\<in>\\<real>\"\n  shows \"x \\<le> 0 \\<or> x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> 0 \\<or> 0 \\<le> x", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. x \\<le> 0 \\<or> 0 \\<le> x", "unfolding reals_zero_comparable_iff"], ["proof (prove)\nusing this:\n  x \\<le> 0 \\<or> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. x \\<le> 0 \\<or> 0 \\<le> x", "by assumption"], ["", "lemma unique_choice: \"\\<forall>x. \\<exists>!y. Q x y \\<Longrightarrow> \\<exists>!f. \\<forall>x. Q x (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<exists>!y. Q x y \\<Longrightarrow>\n    \\<exists>!f. \\<forall>x. Q x (f x)", "apply (auto intro!: choice ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f y x.\n       \\<lbrakk>\\<forall>x. \\<exists>!y. Q x y; \\<forall>x. Q x (f x);\n        \\<forall>x. Q x (y x)\\<rbrakk>\n       \\<Longrightarrow> f x = y x", "by metis"], ["", "lemma sum_single: \n  assumes \"finite A\"\n  assumes \"\\<And>j. j \\<noteq> i \\<Longrightarrow> j\\<in>A \\<Longrightarrow> f j = 0\"\n  shows \"sum f A = (if i\\<in>A then f i else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f A = (if i \\<in> A then f i else (0::'b))", "apply (subst sum.mono_neutral_cong_right[where S=\\<open>A \\<inter> {i}\\<close> and h=f])"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite A\n 2. A \\<inter> {i} \\<subseteq> A\n 3. \\<forall>i\\<in>A - A \\<inter> {i}. f i = (0::'b)\n 4. \\<And>x. x \\<in> A \\<inter> {i} \\<Longrightarrow> f x = f x\n 5. sum f (A \\<inter> {i}) = (if i \\<in> A then f i else (0::'b))", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  \\<lbrakk>?j \\<noteq> i; ?j \\<in> A\\<rbrakk>\n  \\<Longrightarrow> f ?j = (0::'b)\n\ngoal (5 subgoals):\n 1. finite A\n 2. A \\<inter> {i} \\<subseteq> A\n 3. \\<forall>i\\<in>A - A \\<inter> {i}. f i = (0::'b)\n 4. \\<And>x. x \\<in> A \\<inter> {i} \\<Longrightarrow> f x = f x\n 5. sum f (A \\<inter> {i}) = (if i \\<in> A then f i else (0::'b))", "by auto"], ["", "lemma image_set_plus: \n  assumes \\<open>linear U\\<close>\n  shows \\<open>U ` (A + B) = U ` A + U ` B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. U ` (A + B) = U ` A + U ` B", "unfolding image_def set_plus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{c. \\<exists>a\\<in>A. \\<exists>b\\<in>B. c = a + b}.\n           y = U x} =\n    {c. \\<exists>a\\<in>{y. \\<exists>x\\<in>A. y = U x}.\n           \\<exists>b\\<in>{y. \\<exists>x\\<in>B. y = U x}. c = a + b}", "using assms"], ["proof (prove)\nusing this:\n  linear U\n\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{c. \\<exists>a\\<in>A. \\<exists>b\\<in>B. c = a + b}.\n           y = U x} =\n    {c. \\<exists>a\\<in>{y. \\<exists>x\\<in>A. y = U x}.\n           \\<exists>b\\<in>{y. \\<exists>x\\<in>B. y = U x}. c = a + b}", "by (force simp: linear_add)"], ["", "consts heterogenous_identity :: \\<open>'a \\<Rightarrow> 'b\\<close>"], ["", "overloading heterogenous_identity_id \\<equiv> \"heterogenous_identity :: 'a \\<Rightarrow> 'a\" begin"], ["", "definition heterogenous_identity_def[simp]: \\<open>heterogenous_identity_id = id\\<close>"], ["", "end"], ["", "lemma bdd_above_image_mono:\n  assumes \\<open>\\<And>x. x\\<in>S \\<Longrightarrow> f x \\<le> g x\\<close>\n  assumes \\<open>bdd_above (g ` S)\\<close>\n  shows \\<open>bdd_above (f ` S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (f ` S)", "by (smt (verit, ccfv_threshold) assms(1) assms(2) bdd_aboveI2 bdd_above_def order_trans rev_image_eqI)"], ["", "lemma L2_set_mono2:\n  assumes a1: \"finite L\" and a2: \"K \\<le> L\"\n  shows \"L2_set f K \\<le> L2_set f L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set f K \\<le> L2_set f L", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. L2_set f K \\<le> L2_set f L", "have \"(\\<Sum>i\\<in>K. (f i)\\<^sup>2) \\<le> (\\<Sum>i\\<in>L. (f i)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>K. (f i)\\<^sup>2) \\<le> (\\<Sum>i\\<in>L. (f i)\\<^sup>2)", "proof (rule sum_mono2)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite L\n 2. K \\<subseteq> L\n 3. \\<And>b. b \\<in> L - K \\<Longrightarrow> 0 \\<le> (f b)\\<^sup>2", "show \"finite L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite L", "using a1"], ["proof (prove)\nusing this:\n  finite L\n\ngoal (1 subgoal):\n 1. finite L", "."], ["proof (state)\nthis:\n  finite L\n\ngoal (2 subgoals):\n 1. K \\<subseteq> L\n 2. \\<And>b. b \\<in> L - K \\<Longrightarrow> 0 \\<le> (f b)\\<^sup>2", "show \"K \\<subseteq> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<subseteq> L", "using a2"], ["proof (prove)\nusing this:\n  K \\<subseteq> L\n\ngoal (1 subgoal):\n 1. K \\<subseteq> L", "."], ["proof (state)\nthis:\n  K \\<subseteq> L\n\ngoal (1 subgoal):\n 1. \\<And>b. b \\<in> L - K \\<Longrightarrow> 0 \\<le> (f b)\\<^sup>2", "show \"0 \\<le> (f b)\\<^sup>2\"\n      if \"b \\<in> L - K\"\n      for b :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (f b)\\<^sup>2", "using that"], ["proof (prove)\nusing this:\n  b \\<in> L - K\n\ngoal (1 subgoal):\n 1. 0 \\<le> (f b)\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  ?b \\<in> L - K \\<Longrightarrow> 0 \\<le> (f ?b)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>K. (f i)\\<^sup>2) \\<le> (\\<Sum>i\\<in>L. (f i)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. L2_set f K \\<le> L2_set f L", "hence \"sqrt (\\<Sum>i\\<in>K. (f i)\\<^sup>2) \\<le> sqrt (\\<Sum>i\\<in>L. (f i)\\<^sup>2)\""], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>K. (f i)\\<^sup>2) \\<le> (\\<Sum>i\\<in>L. (f i)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. sqrt (\\<Sum>i\\<in>K. (f i)\\<^sup>2)\n    \\<le> sqrt (\\<Sum>i\\<in>L. (f i)\\<^sup>2)", "by (rule real_sqrt_le_mono)"], ["proof (state)\nthis:\n  sqrt (\\<Sum>i\\<in>K. (f i)\\<^sup>2)\n  \\<le> sqrt (\\<Sum>i\\<in>L. (f i)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. L2_set f K \\<le> L2_set f L", "thus ?thesis"], ["proof (prove)\nusing this:\n  sqrt (\\<Sum>i\\<in>K. (f i)\\<^sup>2)\n  \\<le> sqrt (\\<Sum>i\\<in>L. (f i)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. L2_set f K \\<le> L2_set f L", "unfolding L2_set_def"], ["proof (prove)\nusing this:\n  sqrt (\\<Sum>i\\<in>K. (f i)\\<^sup>2)\n  \\<le> sqrt (\\<Sum>i\\<in>L. (f i)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. sqrt (\\<Sum>i\\<in>K. (f i)\\<^sup>2)\n    \\<le> sqrt (\\<Sum>i\\<in>L. (f i)\\<^sup>2)", "."], ["proof (state)\nthis:\n  L2_set f K \\<le> L2_set f L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Sup_real_close:\n  fixes e :: real\n  assumes \"0 < e\"\n    and S: \"bdd_above S\" \"S \\<noteq> {}\"\n  shows \"\\<exists>x\\<in>S. Sup S - e < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Sup S - e < x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Sup S - e < x", "have \\<open>Sup (ereal ` S) \\<noteq> \\<infinity>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (ereal ` S) \\<noteq> \\<infinity>", "by (metis assms(2) bdd_above_def ereal_less_eq(3) less_SUP_iff less_ereal.simps(4) not_le)"], ["proof (state)\nthis:\n  Sup (ereal ` S) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Sup S - e < x", "moreover"], ["proof (state)\nthis:\n  Sup (ereal ` S) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Sup S - e < x", "have \\<open>Sup (ereal ` S) \\<noteq> -\\<infinity>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (ereal ` S) \\<noteq> - \\<infinity>", "by (simp add: SUP_eq_iff assms(3))"], ["proof (state)\nthis:\n  Sup (ereal ` S) \\<noteq> - \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Sup S - e < x", "ultimately"], ["proof (chain)\npicking this:\n  Sup (ereal ` S) \\<noteq> \\<infinity>\n  Sup (ereal ` S) \\<noteq> - \\<infinity>", "have Sup_bdd: \\<open>\\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity>\\<close>"], ["proof (prove)\nusing this:\n  Sup (ereal ` S) \\<noteq> \\<infinity>\n  Sup (ereal ` S) \\<noteq> - \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  \\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Sup S - e < x", "then"], ["proof (chain)\npicking this:\n  \\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity>", "have \\<open>\\<exists>x'\\<in>ereal ` S. Sup (ereal ` S) - ereal e < x'\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>ereal ` S. Sup (ereal ` S) - ereal e < x'", "apply (rule_tac Sup_ereal_close)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity> \\<Longrightarrow>\n    0 < ereal e\n 2. \\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity>\n 3. \\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity> \\<Longrightarrow>\n    ereal ` S \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  0 < e\n  bdd_above S\n  S \\<noteq> {}\n\ngoal (3 subgoals):\n 1. \\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity> \\<Longrightarrow>\n    0 < ereal e\n 2. \\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity>\n 3. \\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity> \\<Longrightarrow>\n    ereal ` S \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>ereal ` S. Sup (ereal ` S) - ereal e < x'\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Sup S - e < x", "then"], ["proof (chain)\npicking this:\n  \\<exists>x'\\<in>ereal ` S. Sup (ereal ` S) - ereal e < x'", "obtain x where \\<open>x \\<in> S\\<close> and Sup_x: \\<open>Sup (ereal ` S) - ereal e < ereal x\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x'\\<in>ereal ` S. Sup (ereal ` S) - ereal e < x'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> S; Sup (ereal ` S) - ereal e < ereal x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> S\n  Sup (ereal ` S) - ereal e < ereal x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Sup S - e < x", "have \\<open>Sup (ereal ` S) = ereal (Sup S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup (ereal ` S) = ereal (Sup S)", "using Sup_bdd"], ["proof (prove)\nusing this:\n  \\<bar>Sup (ereal ` S)\\<bar> \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Sup (ereal ` S) = ereal (Sup S)", "by (rule ereal_Sup[symmetric])"], ["proof (state)\nthis:\n  Sup (ereal ` S) = ereal (Sup S)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Sup S - e < x", "with Sup_x"], ["proof (chain)\npicking this:\n  Sup (ereal ` S) - ereal e < ereal x\n  Sup (ereal ` S) = ereal (Sup S)", "have \\<open>ereal (Sup S - e) < ereal x\\<close>"], ["proof (prove)\nusing this:\n  Sup (ereal ` S) - ereal e < ereal x\n  Sup (ereal ` S) = ereal (Sup S)\n\ngoal (1 subgoal):\n 1. ereal (Sup S - e) < ereal x", "by auto"], ["proof (state)\nthis:\n  ereal (Sup S - e) < ereal x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Sup S - e < x", "then"], ["proof (chain)\npicking this:\n  ereal (Sup S - e) < ereal x", "have \\<open>Sup S - e < x\\<close>"], ["proof (prove)\nusing this:\n  ereal (Sup S - e) < ereal x\n\ngoal (1 subgoal):\n 1. Sup S - e < x", "by auto"], ["proof (state)\nthis:\n  Sup S - e < x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Sup S - e < x", "with \\<open>x \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S\n  Sup S - e < x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> S\n  Sup S - e < x\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S. Sup S - e < x", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>S. Sup S - e < x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Improved version of @{attribute internalize_sort}: It is not necessary to specify the sort of the type variable.\\<close>"], ["", "attribute_setup internalize_sort' = \\<open>let\nfun find_tvar thm v = let\n  val tvars = Term.add_tvars (Thm.prop_of thm) []\n  val tv = case find_first (fn (n,sort) => n=v) tvars of\n              SOME tv => tv | NONE => raise THM (\"Type variable \" ^ string_of_indexname v ^ \" not found\", 0, [thm])\nin \nTVar tv\nend\n\nfun internalize_sort_attr (tvar:indexname) =\n  Thm.rule_attribute [] (fn context => fn thm =>\n    (snd (Internalize_Sort.internalize_sort (Thm.ctyp_of (Context.proof_of context) (find_tvar thm tvar)) thm)));\nin\n  Scan.lift Args.var >> internalize_sort_attr\nend\\<close>\n  \"internalize a sort\""], ["", "subsection \\<open>Not singleton\\<close>"], ["", "class not_singleton =\n  assumes not_singleton_card: \"\\<exists>x y. x \\<noteq> y\""], ["", "lemma not_singleton_existence[simp]:\n  \\<open>\\<exists> x::('a::not_singleton). x \\<noteq> t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<noteq> t", "using not_singleton_card[where ?'a = 'a]"], ["proof (prove)\nusing this:\n  \\<exists>x y. x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<noteq> t", "by (metis (full_types))"], ["", "lemma UNIV_not_singleton[simp]: \"(UNIV::_::not_singleton set) \\<noteq> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<noteq> {x}", "using not_singleton_existence[of x]"], ["proof (prove)\nusing this:\n  \\<exists>xa. xa \\<noteq> x\n\ngoal (1 subgoal):\n 1. UNIV \\<noteq> {x}", "by blast"], ["", "lemma UNIV_not_singleton_converse: \n  assumes\"\\<And>x::'a. UNIV \\<noteq> {x}\"\n  shows \"\\<exists>x::'a. \\<exists>y. x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y", "using assms"], ["proof (prove)\nusing this:\n  UNIV \\<noteq> {?x}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y", "by fastforce"], ["", "subclass (in card2) not_singleton"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.not_singleton TYPE('a)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y", "using two_le_card"], ["proof (prove)\nusing this:\n  2 \\<le> CARD('a)\n\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y", "by (meson card_2_iff' obtain_subset_with_card_n)"], ["", "subclass (in perfect_space) not_singleton"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.not_singleton TYPE('a)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y", "by (metis (mono_tags) Collect_cong Collect_mem_eq UNIV_I local.UNIV_not_singleton local.not_open_singleton local.open_subopen)"], ["", "lemma class_not_singletonI_monoid_add:\n  assumes \"(UNIV::'a set) \\<noteq> {0}\"\n  shows \"class.not_singleton TYPE('a::monoid_add)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.not_singleton TYPE('a)", "proof intro_classes"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y", "let ?univ = \"UNIV :: 'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y", "from assms"], ["proof (chain)\npicking this:\n  UNIV \\<noteq> {0::'a}", "obtain x::'a where \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  UNIV \\<noteq> {0::'a}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<noteq> (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y", "thus \"\\<exists>x y :: 'a. x \\<noteq> y\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  \\<exists>x y. x \\<noteq> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_singleton_vs_CARD_1:\n  assumes \\<open>\\<not> class.not_singleton TYPE('a)\\<close>\n  shows \\<open>class.CARD_1 TYPE('a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.CARD_1 TYPE('a)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> class.not_singleton TYPE('a)\n\ngoal (1 subgoal):\n 1. class.CARD_1 TYPE('a)", "unfolding class.not_singleton_def class.CARD_1_def"], ["proof (prove)\nusing this:\n  \\<nexists>x y. x \\<noteq> y\n\ngoal (1 subgoal):\n 1. CARD('a) = 1", "by (metis (full_types) One_nat_def UNIV_I card.empty card.insert empty_iff equalityI finite.intros(1) insert_iff subsetI)"], ["", "subsection \\<open>\\<^class>\\<open>CARD_1\\<close>\\<close>"], ["", "context CARD_1 begin"], ["", "lemma everything_the_same[simp]: \"(x::'a)=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "by (metis (full_types) UNIV_I card_1_singletonE empty_iff insert_iff local.CARD_1)"], ["", "lemma CARD_1_UNIV: \"UNIV = {x::'a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {x}", "by (metis (full_types) UNIV_I card_1_singletonE local.CARD_1 singletonD)"], ["", "lemma CARD_1_ext: \"x (a::'a) = y b \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x a = y b \\<Longrightarrow> x = y", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. x a = y b \\<Longrightarrow> x xa = y xa", "show \"x t = y t\"\n    if \"x a = y b\"\n    for t :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. x t = y t", "using that"], ["proof (prove)\nusing this:\n  x a = y b\n\ngoal (1 subgoal):\n 1. x t = y t", "apply (subst (asm) everything_the_same[where x=a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ?y1 = y b \\<Longrightarrow> x t = y t", "apply (subst (asm) everything_the_same[where x=b])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ?y1 = y ?y2 \\<Longrightarrow> x t = y t", "by simp"], ["proof (state)\nthis:\n  x a = y b \\<Longrightarrow> x ?t = y ?t\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instance unit :: CARD_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(unit, CARD_1_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD(unit) = 1", "by auto"], ["", "instance prod :: (CARD_1, CARD_1) CARD_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, CARD_1_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a \\<times> 'b) = 1", "by (simp add: CARD_1)"], ["", "instance \"fun\" :: (CARD_1, CARD_1) CARD_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, CARD_1_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a \\<Rightarrow> 'b) = 1", "by (auto simp add: card_fun CARD_1)"], ["", "lemma enum_CARD_1: \"(Enum.enum :: 'a::{CARD_1,enum} list) = [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_class.enum = [a]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. enum_class.enum = [a]", "let ?enum = \"Enum.enum :: 'a::{CARD_1,enum} list\""], ["proof (state)\ngoal (1 subgoal):\n 1. enum_class.enum = [a]", "have \"length ?enum = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length enum_class.enum = 1", "apply (subst card_UNIV_length_enum[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a) = 1", "by (rule CARD_1)"], ["proof (state)\nthis:\n  length enum_class.enum = 1\n\ngoal (1 subgoal):\n 1. enum_class.enum = [a]", "then"], ["proof (chain)\npicking this:\n  length enum_class.enum = 1", "obtain b where \"?enum = [b]\""], ["proof (prove)\nusing this:\n  length enum_class.enum = 1\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        enum_class.enum = [b] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. length enum_class.enum = 1 \\<Longrightarrow>\n    \\<exists>b. enum_class.enum = [b]", "apply (cases ?enum, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>length enum_class.enum = Suc 0;\n        enum_class.enum = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. enum_class.enum = [b]", "by (metis length_0_conv length_Cons nat.inject)"], ["proof (state)\nthis:\n  enum_class.enum = [b]\n\ngoal (1 subgoal):\n 1. enum_class.enum = [a]", "thus \"?enum = [a]\""], ["proof (prove)\nusing this:\n  enum_class.enum = [b]\n\ngoal (1 subgoal):\n 1. enum_class.enum = [a]", "by (subst everything_the_same[of _ b], simp)"], ["proof (state)\nthis:\n  enum_class.enum = [a]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Topology\\<close>"], ["", "lemma cauchy_filter_metricI:\n  fixes F :: \"'a::metric_space filter\"\n  assumes \"\\<And>e. e>0 \\<Longrightarrow> \\<exists>P. eventually P F \\<and> (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < e)\"\n  shows \"cauchy_filter F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cauchy_filter F", "proof (unfold cauchy_filter_def le_filter_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       eventually P uniformity \\<Longrightarrow>\n       eventually P (F \\<times>\\<^sub>F F)", "fix P :: \"'a \\<times> 'a \\<Rightarrow> bool\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       eventually P uniformity \\<Longrightarrow>\n       eventually P (F \\<times>\\<^sub>F F)", "assume \"eventually P uniformity\""], ["proof (state)\nthis:\n  eventually P uniformity\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       eventually P uniformity \\<Longrightarrow>\n       eventually P (F \\<times>\\<^sub>F F)", "then"], ["proof (chain)\npicking this:\n  eventually P uniformity", "obtain e where e: \"e > 0\" and P: \"dist x y < e \\<Longrightarrow> P (x, y)\" for x y"], ["proof (prove)\nusing this:\n  eventually P uniformity\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>0 < e;\n         \\<And>x y. dist x y < e \\<Longrightarrow> P (x, y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_uniformity_metric"], ["proof (prove)\nusing this:\n  \\<exists>e>0. \\<forall>x y. dist x y < e \\<longrightarrow> P (x, y)\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>0 < e;\n         \\<And>x y. dist x y < e \\<Longrightarrow> P (x, y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < e\n  dist ?x ?y < e \\<Longrightarrow> P (?x, ?y)\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       eventually P uniformity \\<Longrightarrow>\n       eventually P (F \\<times>\\<^sub>F F)", "obtain P' where evP': \"eventually P' F\" and P'_dist: \"P' x \\<and> P' y \\<Longrightarrow> dist x y < e\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P'.\n        \\<lbrakk>eventually P' F;\n         \\<And>x y. P' x \\<and> P' y \\<Longrightarrow> dist x y < e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P'.\n       eventually P' F \\<and>\n       (\\<forall>x y. P' x \\<and> P' y \\<longrightarrow> dist x y < e)", "using assms e"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>P.\n     eventually P F \\<and>\n     (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < ?e)\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<exists>P'.\n       eventually P' F \\<and>\n       (\\<forall>x y. P' x \\<and> P' y \\<longrightarrow> dist x y < e)", "by auto"], ["proof (state)\nthis:\n  eventually P' F\n  P' ?x \\<and> P' ?y \\<Longrightarrow> dist ?x ?y < e\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       eventually P uniformity \\<Longrightarrow>\n       eventually P (F \\<times>\\<^sub>F F)", "from evP' P'_dist P"], ["proof (chain)\npicking this:\n  eventually P' F\n  P' ?x \\<and> P' ?y \\<Longrightarrow> dist ?x ?y < e\n  dist ?x ?y < e \\<Longrightarrow> P (?x, ?y)", "show \"eventually P (F \\<times>\\<^sub>F F)\""], ["proof (prove)\nusing this:\n  eventually P' F\n  P' ?x \\<and> P' ?y \\<Longrightarrow> dist ?x ?y < e\n  dist ?x ?y < e \\<Longrightarrow> P (?x, ?y)\n\ngoal (1 subgoal):\n 1. eventually P (F \\<times>\\<^sub>F F)", "unfolding eventually_uniformity_metric eventually_prod_filter eventually_filtermap"], ["proof (prove)\nusing this:\n  eventually P' F\n  P' ?x \\<and> P' ?y \\<Longrightarrow> dist ?x ?y < e\n  dist ?x ?y < e \\<Longrightarrow> P (?x, ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>Pf Pg.\n       eventually Pf F \\<and>\n       eventually Pg F \\<and>\n       (\\<forall>x y.\n           Pf x \\<longrightarrow> Pg y \\<longrightarrow> P (x, y))", "by metis"], ["proof (state)\nthis:\n  eventually P (F \\<times>\\<^sub>F F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cauchy_filter_metric_filtermapI:\n  fixes F :: \"'a filter\" and f :: \"'a\\<Rightarrow>'b::metric_space\"\n  assumes \"\\<And>e. e>0 \\<Longrightarrow> \\<exists>P. eventually P F \\<and> (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist (f x) (f y) < e)\"\n  shows \"cauchy_filter (filtermap f F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cauchy_filter (filtermap f F)", "proof (rule cauchy_filter_metricI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>P.\n          eventually P (filtermap f F) \\<and>\n          (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < e)", "fix e :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>P.\n          eventually P (filtermap f F) \\<and>\n          (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < e)", "assume e: \"e > 0\""], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>P.\n          eventually P (filtermap f F) \\<and>\n          (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < e)", "with assms"], ["proof (chain)\npicking this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>P.\n     eventually P F \\<and>\n     (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist (f x) (f y) < ?e)\n  0 < e", "obtain P where evP: \"eventually P F\" and dist: \"P x \\<and> P y \\<Longrightarrow> dist (f x) (f y) < e\" for x y"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>P.\n     eventually P F \\<and>\n     (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist (f x) (f y) < ?e)\n  0 < e\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>eventually P F;\n         \\<And>x y.\n            P x \\<and> P y \\<Longrightarrow> dist (f x) (f y) < e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim auto"], ["proof (state)\nthis:\n  eventually P F\n  P ?x \\<and> P ?y \\<Longrightarrow> dist (f ?x) (f ?y) < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>P.\n          eventually P (filtermap f F) \\<and>\n          (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < e)", "define P' where \"P' y = (\\<exists>x. P x \\<and> y = f x)\" for y"], ["proof (state)\nthis:\n  P' ?y = (\\<exists>x. P x \\<and> ?y = f x)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>P.\n          eventually P (filtermap f F) \\<and>\n          (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < e)", "have \"eventually P' (filtermap f F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually P' (filtermap f F)", "unfolding eventually_filtermap P'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. \\<exists>xa. P xa \\<and> f x = f xa", "using evP"], ["proof (prove)\nusing this:\n  eventually P F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in F. \\<exists>xa. P xa \\<and> f x = f xa", "by (smt eventually_mono)"], ["proof (state)\nthis:\n  eventually P' (filtermap f F)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>P.\n          eventually P (filtermap f F) \\<and>\n          (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < e)", "moreover"], ["proof (state)\nthis:\n  eventually P' (filtermap f F)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>P.\n          eventually P (filtermap f F) \\<and>\n          (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < e)", "have \"P' x \\<and> P' y \\<longrightarrow> dist x y < e\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. P' x \\<and> P' y \\<longrightarrow> dist x y < e", "unfolding P'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>xa. P xa \\<and> x = f xa) \\<and>\n    (\\<exists>x. P x \\<and> y = f x) \\<longrightarrow>\n    dist x y < e", "using dist"], ["proof (prove)\nusing this:\n  P ?x \\<and> P ?y \\<Longrightarrow> dist (f ?x) (f ?y) < e\n\ngoal (1 subgoal):\n 1. (\\<exists>xa. P xa \\<and> x = f xa) \\<and>\n    (\\<exists>x. P x \\<and> y = f x) \\<longrightarrow>\n    dist x y < e", "by metis"], ["proof (state)\nthis:\n  P' ?x \\<and> P' ?y \\<longrightarrow> dist ?x ?y < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>P.\n          eventually P (filtermap f F) \\<and>\n          (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < e)", "ultimately"], ["proof (chain)\npicking this:\n  eventually P' (filtermap f F)\n  P' ?x \\<and> P' ?y \\<longrightarrow> dist ?x ?y < e", "show \"\\<exists>P. eventually P (filtermap f F) \\<and> (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < e)\""], ["proof (prove)\nusing this:\n  eventually P' (filtermap f F)\n  P' ?x \\<and> P' ?y \\<longrightarrow> dist ?x ?y < e\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       eventually P (filtermap f F) \\<and>\n       (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < e)", "by auto"], ["proof (state)\nthis:\n  \\<exists>P.\n     eventually P (filtermap f F) \\<and>\n     (\\<forall>x y. P x \\<and> P y \\<longrightarrow> dist x y < e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_add_const_iff:\n  \\<comment> \\<open>This is a generalization of \\<open>Limits.tendsto_add_const_iff\\<close>, \n      the only difference is that the sort here is more general.\\<close>\n  \"((\\<lambda>x. c + f x :: 'a::topological_group_add) \\<longlongrightarrow> c + d) F \\<longleftrightarrow> (f \\<longlongrightarrow> d) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. c + f x) \\<longlongrightarrow> c + d) F =\n    (f \\<longlongrightarrow> d) F", "using tendsto_add[OF tendsto_const[of c], of f d]\n    and tendsto_add[OF tendsto_const[of \"-c\"], of \"\\<lambda>x. c + f x\" \"c + d\"]"], ["proof (prove)\nusing this:\n  (f \\<longlongrightarrow> d) ?F \\<Longrightarrow>\n  ((\\<lambda>x. c + f x) \\<longlongrightarrow> c + d) ?F\n  ((\\<lambda>x. c + f x) \\<longlongrightarrow> c + d) ?F \\<Longrightarrow>\n  ((\\<lambda>x. - c + (c + f x)) \\<longlongrightarrow> - c + (c + d)) ?F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. c + f x) \\<longlongrightarrow> c + d) F =\n    (f \\<longlongrightarrow> d) F", "by auto"], ["", "lemma finite_subsets_at_top_minus: \n  assumes \"A\\<subseteq>B\"\n  shows \"finite_subsets_at_top (B - A) \\<le> filtermap (\\<lambda>F. F - A) (finite_subsets_at_top B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_subsets_at_top (B - A)\n    \\<le> filtermap (\\<lambda>F. F - A) (finite_subsets_at_top B)", "proof (rule filter_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       eventually P\n        (filtermap (\\<lambda>F. F - A)\n          (finite_subsets_at_top B)) \\<Longrightarrow>\n       eventually P (finite_subsets_at_top (B - A))", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       eventually P\n        (filtermap (\\<lambda>F. F - A)\n          (finite_subsets_at_top B)) \\<Longrightarrow>\n       eventually P (finite_subsets_at_top (B - A))", "assume \"eventually P (filtermap (\\<lambda>F. F - A) (finite_subsets_at_top B))\""], ["proof (state)\nthis:\n  eventually P (filtermap (\\<lambda>F. F - A) (finite_subsets_at_top B))\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       eventually P\n        (filtermap (\\<lambda>F. F - A)\n          (finite_subsets_at_top B)) \\<Longrightarrow>\n       eventually P (finite_subsets_at_top (B - A))", "then"], ["proof (chain)\npicking this:\n  eventually P (filtermap (\\<lambda>F. F - A) (finite_subsets_at_top B))", "obtain X where \"finite X\" and \"X \\<subseteq> B\" \n    and P: \"finite Y \\<and> X \\<subseteq> Y \\<and> Y \\<subseteq> B \\<longrightarrow> P (Y - A)\" for Y"], ["proof (prove)\nusing this:\n  eventually P (filtermap (\\<lambda>F. F - A) (finite_subsets_at_top B))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>finite X; X \\<subseteq> B;\n         \\<And>Y.\n            finite Y \\<and>\n            X \\<subseteq> Y \\<and> Y \\<subseteq> B \\<longrightarrow>\n            P (Y - A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_filtermap eventually_finite_subsets_at_top"], ["proof (prove)\nusing this:\n  \\<exists>X.\n     finite X \\<and>\n     X \\<subseteq> B \\<and>\n     (\\<forall>Y.\n         finite Y \\<and>\n         X \\<subseteq> Y \\<and> Y \\<subseteq> B \\<longrightarrow>\n         P (Y - A))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>finite X; X \\<subseteq> B;\n         \\<And>Y.\n            finite Y \\<and>\n            X \\<subseteq> Y \\<and> Y \\<subseteq> B \\<longrightarrow>\n            P (Y - A)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite X\n  X \\<subseteq> B\n  finite ?Y \\<and>\n  X \\<subseteq> ?Y \\<and> ?Y \\<subseteq> B \\<longrightarrow>\n  P (?Y - A)\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       eventually P\n        (filtermap (\\<lambda>F. F - A)\n          (finite_subsets_at_top B)) \\<Longrightarrow>\n       eventually P (finite_subsets_at_top (B - A))", "hence \"finite (X-A)\" and \"X-A \\<subseteq> B - A\""], ["proof (prove)\nusing this:\n  finite X\n  X \\<subseteq> B\n  finite ?Y \\<and>\n  X \\<subseteq> ?Y \\<and> ?Y \\<subseteq> B \\<longrightarrow>\n  P (?Y - A)\n\ngoal (1 subgoal):\n 1. finite (X - A) &&& X - A \\<subseteq> B - A", "by auto"], ["proof (state)\nthis:\n  finite (X - A)\n  X - A \\<subseteq> B - A\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       eventually P\n        (filtermap (\\<lambda>F. F - A)\n          (finite_subsets_at_top B)) \\<Longrightarrow>\n       eventually P (finite_subsets_at_top (B - A))", "moreover"], ["proof (state)\nthis:\n  finite (X - A)\n  X - A \\<subseteq> B - A\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       eventually P\n        (filtermap (\\<lambda>F. F - A)\n          (finite_subsets_at_top B)) \\<Longrightarrow>\n       eventually P (finite_subsets_at_top (B - A))", "have \"finite Y \\<and> X-A \\<subseteq> Y \\<and> Y \\<subseteq> B - A \\<longrightarrow> P Y\" for Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Y \\<and>\n    X - A \\<subseteq> Y \\<and> Y \\<subseteq> B - A \\<longrightarrow>\n    P Y", "using P[where Y=\"Y\\<union>X\"] \\<open>finite X\\<close> \\<open>X \\<subseteq> B\\<close>"], ["proof (prove)\nusing this:\n  finite (Y \\<union> X) \\<and>\n  X \\<subseteq> Y \\<union> X \\<and>\n  Y \\<union> X \\<subseteq> B \\<longrightarrow>\n  P (Y \\<union> X - A)\n  finite X\n  X \\<subseteq> B\n\ngoal (1 subgoal):\n 1. finite Y \\<and>\n    X - A \\<subseteq> Y \\<and> Y \\<subseteq> B - A \\<longrightarrow>\n    P Y", "by (metis Diff_subset Int_Diff Un_Diff finite_Un inf.orderE le_sup_iff sup.orderE sup_ge2)"], ["proof (state)\nthis:\n  finite ?Y \\<and>\n  X - A \\<subseteq> ?Y \\<and> ?Y \\<subseteq> B - A \\<longrightarrow>\n  P ?Y\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       eventually P\n        (filtermap (\\<lambda>F. F - A)\n          (finite_subsets_at_top B)) \\<Longrightarrow>\n       eventually P (finite_subsets_at_top (B - A))", "ultimately"], ["proof (chain)\npicking this:\n  finite (X - A)\n  X - A \\<subseteq> B - A\n  finite ?Y \\<and>\n  X - A \\<subseteq> ?Y \\<and> ?Y \\<subseteq> B - A \\<longrightarrow>\n  P ?Y", "show \"eventually P (finite_subsets_at_top (B - A))\""], ["proof (prove)\nusing this:\n  finite (X - A)\n  X - A \\<subseteq> B - A\n  finite ?Y \\<and>\n  X - A \\<subseteq> ?Y \\<and> ?Y \\<subseteq> B - A \\<longrightarrow>\n  P ?Y\n\ngoal (1 subgoal):\n 1. eventually P (finite_subsets_at_top (B - A))", "unfolding eventually_finite_subsets_at_top"], ["proof (prove)\nusing this:\n  finite (X - A)\n  X - A \\<subseteq> B - A\n  finite ?Y \\<and>\n  X - A \\<subseteq> ?Y \\<and> ?Y \\<subseteq> B - A \\<longrightarrow>\n  P ?Y\n\ngoal (1 subgoal):\n 1. \\<exists>X.\n       finite X \\<and>\n       X \\<subseteq> B - A \\<and>\n       (\\<forall>Y.\n           finite Y \\<and>\n           X \\<subseteq> Y \\<and> Y \\<subseteq> B - A \\<longrightarrow>\n           P Y)", "by meson"], ["proof (state)\nthis:\n  eventually P (finite_subsets_at_top (B - A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_subsets_at_top_inter: \n  assumes \"A\\<subseteq>B\"\n  shows \"filtermap (\\<lambda>F. F \\<inter> A) (finite_subsets_at_top B) \\<le> finite_subsets_at_top A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filtermap (\\<lambda>F. F \\<inter> A) (finite_subsets_at_top B)\n    \\<le> finite_subsets_at_top A", "proof (rule filter_leI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       eventually P (finite_subsets_at_top A) \\<Longrightarrow>\n       eventually P\n        (filtermap (\\<lambda>F. F \\<inter> A) (finite_subsets_at_top B))", "show \"eventually P (filtermap (\\<lambda>F. F \\<inter> A) (finite_subsets_at_top B))\"\n    if \"eventually P (finite_subsets_at_top A)\"\n    for P :: \"'a set \\<Rightarrow> bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually P\n     (filtermap (\\<lambda>F. F \\<inter> A) (finite_subsets_at_top B))", "using that"], ["proof (prove)\nusing this:\n  eventually P (finite_subsets_at_top A)\n\ngoal (1 subgoal):\n 1. eventually P\n     (filtermap (\\<lambda>F. F \\<inter> A) (finite_subsets_at_top B))", "unfolding eventually_filtermap"], ["proof (prove)\nusing this:\n  eventually P (finite_subsets_at_top A)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in finite_subsets_at_top B. P (x \\<inter> A)", "unfolding eventually_finite_subsets_at_top"], ["proof (prove)\nusing this:\n  \\<exists>X.\n     finite X \\<and>\n     X \\<subseteq> A \\<and>\n     (\\<forall>Y.\n         finite Y \\<and>\n         X \\<subseteq> Y \\<and> Y \\<subseteq> A \\<longrightarrow>\n         P Y)\n\ngoal (1 subgoal):\n 1. \\<exists>X.\n       finite X \\<and>\n       X \\<subseteq> B \\<and>\n       (\\<forall>Y.\n           finite Y \\<and>\n           X \\<subseteq> Y \\<and> Y \\<subseteq> B \\<longrightarrow>\n           P (Y \\<inter> A))", "by (metis Int_subset_iff assms finite_Int inf_le2 subset_trans)"], ["proof (state)\nthis:\n  eventually ?P (finite_subsets_at_top A) \\<Longrightarrow>\n  eventually ?P\n   (filtermap (\\<lambda>F. F \\<inter> A) (finite_subsets_at_top B))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tendsto_principal_singleton:\n  shows \"(f \\<longlongrightarrow> f x) (principal {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> f x) (principal {x})", "unfolding tendsto_def eventually_principal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S.\n       open S \\<longrightarrow>\n       f x \\<in> S \\<longrightarrow> (\\<forall>x\\<in>{x}. f x \\<in> S)", "by simp"], ["", "lemma complete_singleton: \n  \"complete {s::'a::uniform_space}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete {s}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. complete {s}", "have \"F \\<le> principal {s} \\<Longrightarrow>\n         F \\<noteq> bot \\<Longrightarrow> cauchy_filter F \\<Longrightarrow> F \\<le> nhds s\" for F"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>F \\<le> principal {s}; F \\<noteq> bot; cauchy_filter F\\<rbrakk>\n    \\<Longrightarrow> F \\<le> nhds s", "by (metis eventually_nhds eventually_principal le_filter_def singletonD)"], ["proof (state)\nthis:\n  \\<lbrakk>?F \\<le> principal {s}; ?F \\<noteq> bot;\n   cauchy_filter ?F\\<rbrakk>\n  \\<Longrightarrow> ?F \\<le> nhds s\n\ngoal (1 subgoal):\n 1. complete {s}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?F \\<le> principal {s}; ?F \\<noteq> bot;\n   cauchy_filter ?F\\<rbrakk>\n  \\<Longrightarrow> ?F \\<le> nhds s\n\ngoal (1 subgoal):\n 1. complete {s}", "unfolding complete_uniform"], ["proof (prove)\nusing this:\n  \\<lbrakk>?F \\<le> principal {s}; ?F \\<noteq> bot;\n   cauchy_filter ?F\\<rbrakk>\n  \\<Longrightarrow> ?F \\<le> nhds s\n\ngoal (1 subgoal):\n 1. \\<forall>F\\<le>principal {s}.\n       F \\<noteq> bot \\<longrightarrow>\n       cauchy_filter F \\<longrightarrow>\n       (\\<exists>x\\<in>{s}. F \\<le> nhds x)", "by simp"], ["proof (state)\nthis:\n  complete {s}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Complex numbers\\<close>"], ["", "lemma cmod_Re:\n  assumes \"x \\<ge> 0\"\n  shows \"cmod x = Re x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod x = Re x", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. cmod x = Re x", "unfolding less_eq_complex_def cmod_def"], ["proof (prove)\nusing this:\n  Im 0 = Im x \\<and> Re 0 \\<le> Re x\n\ngoal (1 subgoal):\n 1. sqrt ((Re x)\\<^sup>2 + (Im x)\\<^sup>2) = Re x", "by auto"], ["", "lemma abs_complex_real[simp]: \"abs x \\<in> \\<real>\" for x :: complex"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<in> \\<real>", "by (simp add: abs_complex_def)"], ["", "lemma Im_abs[simp]: \"Im (abs x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im \\<bar>x\\<bar> = 0", "using abs_complex_real complex_is_Real_iff"], ["proof (prove)\nusing this:\n  \\<bar>?x\\<bar> \\<in> \\<real>\n  (?z \\<in> \\<real>) = (Im ?z = 0)\n\ngoal (1 subgoal):\n 1. Im \\<bar>x\\<bar> = 0", "by blast"], ["", "lemma cnj_x_x: \"cnj x * x = (abs x)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj x * x = \\<bar>x\\<bar>\\<^sup>2", "proof (cases x)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       x = Complex x1 x2 \\<Longrightarrow> cnj x * x = \\<bar>x\\<bar>\\<^sup>2", "show \"cnj x * x = \\<bar>x\\<bar>\\<^sup>2\"\n    if \"x = Complex x1 x2\"\n    for x1 :: real\n      and x2 :: real"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj x * x = \\<bar>x\\<bar>\\<^sup>2", "using that"], ["proof (prove)\nusing this:\n  x = Complex x1 x2\n\ngoal (1 subgoal):\n 1. cnj x * x = \\<bar>x\\<bar>\\<^sup>2", "by (auto simp: complex_cnj complex_mult abs_complex_def \n        complex_norm power2_eq_square complex_of_real_def)"], ["proof (state)\nthis:\n  x = Complex ?x1.0 ?x2.0 \\<Longrightarrow>\n  cnj x * x = \\<bar>x\\<bar>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cnj_x_x_geq0[simp]: \"cnj x * x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cnj x * x", "proof (cases x)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2. x = Complex x1 x2 \\<Longrightarrow> 0 \\<le> cnj x * x", "show \"0 \\<le> cnj x * x\"\n    if \"x = Complex x1 x2\"\n    for x1 :: real\n      and x2 :: real"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cnj x * x", "using that"], ["proof (prove)\nusing this:\n  x = Complex x1 x2\n\ngoal (1 subgoal):\n 1. 0 \\<le> cnj x * x", "by (auto simp: complex_cnj complex_mult complex_of_real_def)"], ["proof (state)\nthis:\n  x = Complex ?x1.0 ?x2.0 \\<Longrightarrow> 0 \\<le> cnj x * x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>List indices and enum\\<close>"], ["", "fun index_of where\n  \"index_of x [] = (0::nat)\"\n| \"index_of x (y#ys) = (if x=y then 0 else (index_of x ys + 1))\""], ["", "definition \"enum_idx (x::'a::enum) = index_of x (enum_class.enum :: 'a list)\""], ["", "lemma index_of_length: \"index_of x y \\<le> length y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of x y \\<le> length y", "apply (induction y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. index_of x [] \\<le> length []\n 2. \\<And>a y.\n       index_of x y \\<le> length y \\<Longrightarrow>\n       index_of x (a # y) \\<le> length (a # y)", "by auto"], ["", "lemma index_of_correct:\n  assumes \"x \\<in> set y\"\n  shows \"y ! index_of x y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y ! index_of x y = x", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set y\n\ngoal (1 subgoal):\n 1. y ! index_of x y = x", "apply (induction y arbitrary: x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> set [] \\<Longrightarrow> [] ! index_of x [] = x\n 2. \\<And>a y x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set y \\<Longrightarrow> y ! index_of x y = x;\n        x \\<in> set (a # y)\\<rbrakk>\n       \\<Longrightarrow> (a # y) ! index_of x (a # y) = x", "by auto"], ["", "lemma enum_idx_correct: \n  \"Enum.enum ! enum_idx i = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_class.enum ! enum_idx i = i", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. enum_class.enum ! enum_idx i = i", "have \"i \\<in> set enum_class.enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> set enum_class.enum", "using UNIV_enum"], ["proof (prove)\nusing this:\n  UNIV = set enum_class.enum\n\ngoal (1 subgoal):\n 1. i \\<in> set enum_class.enum", "by blast"], ["proof (state)\nthis:\n  i \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. enum_class.enum ! enum_idx i = i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. enum_class.enum ! enum_idx i = i", "unfolding enum_idx_def"], ["proof (prove)\nusing this:\n  i \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. enum_class.enum ! index_of i enum_class.enum = i", "using index_of_correct"], ["proof (prove)\nusing this:\n  i \\<in> set enum_class.enum\n  ?x \\<in> set ?y \\<Longrightarrow> ?y ! index_of ?x ?y = ?x\n\ngoal (1 subgoal):\n 1. enum_class.enum ! index_of i enum_class.enum = i", "by metis"], ["proof (state)\nthis:\n  enum_class.enum ! enum_idx i = i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_of_bound: \n  assumes \"y \\<noteq> []\" and \"x \\<in> set y\"\n  shows \"index_of x y < length y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of x y < length y", "using assms"], ["proof (prove)\nusing this:\n  y \\<noteq> []\n  x \\<in> set y\n\ngoal (1 subgoal):\n 1. index_of x y < length y", "proof(induction y arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[] \\<noteq> []; x \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> index_of x [] < length []\n 2. \\<And>a y x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>y \\<noteq> []; x \\<in> set y\\<rbrakk>\n                   \\<Longrightarrow> index_of x y < length y;\n        a # y \\<noteq> []; x \\<in> set (a # y)\\<rbrakk>\n       \\<Longrightarrow> index_of x (a # y) < length (a # y)", "case Nil"], ["proof (state)\nthis:\n  [] \\<noteq> []\n  x \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[] \\<noteq> []; x \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> index_of x [] < length []\n 2. \\<And>a y x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>y \\<noteq> []; x \\<in> set y\\<rbrakk>\n                   \\<Longrightarrow> index_of x y < length y;\n        a # y \\<noteq> []; x \\<in> set (a # y)\\<rbrakk>\n       \\<Longrightarrow> index_of x (a # y) < length (a # y)", "thus ?case"], ["proof (prove)\nusing this:\n  [] \\<noteq> []\n  x \\<in> set []\n\ngoal (1 subgoal):\n 1. index_of x [] < length []", "by auto"], ["proof (state)\nthis:\n  index_of x [] < length []\n\ngoal (1 subgoal):\n 1. \\<And>a y x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>y \\<noteq> []; x \\<in> set y\\<rbrakk>\n                   \\<Longrightarrow> index_of x y < length y;\n        a # y \\<noteq> []; x \\<in> set (a # y)\\<rbrakk>\n       \\<Longrightarrow> index_of x (a # y) < length (a # y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a y x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>y \\<noteq> []; x \\<in> set y\\<rbrakk>\n                   \\<Longrightarrow> index_of x y < length y;\n        a # y \\<noteq> []; x \\<in> set (a # y)\\<rbrakk>\n       \\<Longrightarrow> index_of x (a # y) < length (a # y)", "case (Cons a y)"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<noteq> []; ?x \\<in> set y\\<rbrakk>\n  \\<Longrightarrow> index_of ?x y < length y\n  a # y \\<noteq> []\n  x \\<in> set (a # y)\n\ngoal (1 subgoal):\n 1. \\<And>a y x.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>y \\<noteq> []; x \\<in> set y\\<rbrakk>\n                   \\<Longrightarrow> index_of x y < length y;\n        a # y \\<noteq> []; x \\<in> set (a # y)\\<rbrakk>\n       \\<Longrightarrow> index_of x (a # y) < length (a # y)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of x (a # y) < length (a # y)", "proof(cases \"a = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow> index_of x (a # y) < length (a # y)\n 2. a \\<noteq> x \\<Longrightarrow> index_of x (a # y) < length (a # y)", "case True"], ["proof (state)\nthis:\n  a = x\n\ngoal (2 subgoals):\n 1. a = x \\<Longrightarrow> index_of x (a # y) < length (a # y)\n 2. a \\<noteq> x \\<Longrightarrow> index_of x (a # y) < length (a # y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = x\n\ngoal (1 subgoal):\n 1. index_of x (a # y) < length (a # y)", "by auto"], ["proof (state)\nthis:\n  index_of x (a # y) < length (a # y)\n\ngoal (1 subgoal):\n 1. a \\<noteq> x \\<Longrightarrow> index_of x (a # y) < length (a # y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> x \\<Longrightarrow> index_of x (a # y) < length (a # y)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> x\n\ngoal (1 subgoal):\n 1. a \\<noteq> x \\<Longrightarrow> index_of x (a # y) < length (a # y)", "moreover"], ["proof (state)\nthis:\n  a \\<noteq> x\n\ngoal (1 subgoal):\n 1. a \\<noteq> x \\<Longrightarrow> index_of x (a # y) < length (a # y)", "have \"a \\<noteq> x \\<Longrightarrow> index_of x y < length y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> x \\<Longrightarrow> index_of x y < length y", "using Cons.IH Cons.prems(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<noteq> []; ?x \\<in> set y\\<rbrakk>\n  \\<Longrightarrow> index_of ?x y < length y\n  x \\<in> set (a # y)\n\ngoal (1 subgoal):\n 1. a \\<noteq> x \\<Longrightarrow> index_of x y < length y", "by fastforce"], ["proof (state)\nthis:\n  a \\<noteq> x \\<Longrightarrow> index_of x y < length y\n\ngoal (1 subgoal):\n 1. a \\<noteq> x \\<Longrightarrow> index_of x (a # y) < length (a # y)", "ultimately"], ["proof (chain)\npicking this:\n  a \\<noteq> x\n  a \\<noteq> x \\<Longrightarrow> index_of x y < length y", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> x\n  a \\<noteq> x \\<Longrightarrow> index_of x y < length y\n\ngoal (1 subgoal):\n 1. index_of x (a # y) < length (a # y)", "by auto"], ["proof (state)\nthis:\n  index_of x (a # y) < length (a # y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  index_of x (a # y) < length (a # y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enum_idx_bound: \"enum_idx x < length (Enum.enum :: 'a list)\" for x :: \"'a::enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_idx x < length enum_class.enum", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. enum_idx x < length enum_class.enum", "have p1: \"False\"\n    if \"(Enum.enum :: 'a list) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"(UNIV::'a set) = set ([]::'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = set []", "using that UNIV_enum"], ["proof (prove)\nusing this:\n  enum_class.enum = []\n  UNIV = set enum_class.enum\n\ngoal (1 subgoal):\n 1. UNIV = set []", "by metis"], ["proof (state)\nthis:\n  UNIV = set []\n\ngoal (1 subgoal):\n 1. False", "also"], ["proof (state)\nthis:\n  UNIV = set []\n\ngoal (1 subgoal):\n 1. False", "have \"\\<dots> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set [] = {}", "by blast"], ["proof (state)\nthis:\n  set [] = {}\n\ngoal (1 subgoal):\n 1. False", "finally"], ["proof (chain)\npicking this:\n  UNIV = {}", "have \"(UNIV::'a set) = {}\""], ["proof (prove)\nusing this:\n  UNIV = {}\n\ngoal (1 subgoal):\n 1. UNIV = {}", "."], ["proof (state)\nthis:\n  UNIV = {}\n\ngoal (1 subgoal):\n 1. False", "thus ?thesis"], ["proof (prove)\nusing this:\n  UNIV = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  enum_class.enum = [] \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. enum_idx x < length enum_class.enum", "have p2: \"x \\<in> set (Enum.enum :: 'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set enum_class.enum", "using UNIV_enum"], ["proof (prove)\nusing this:\n  UNIV = set enum_class.enum\n\ngoal (1 subgoal):\n 1. x \\<in> set enum_class.enum", "by auto"], ["proof (state)\nthis:\n  x \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. enum_idx x < length enum_class.enum", "moreover"], ["proof (state)\nthis:\n  x \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. enum_idx x < length enum_class.enum", "have \"(enum_class.enum::'a list) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_class.enum \\<noteq> []", "using p2"], ["proof (prove)\nusing this:\n  x \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. enum_class.enum \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  enum_class.enum \\<noteq> []\n\ngoal (1 subgoal):\n 1. enum_idx x < length enum_class.enum", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set enum_class.enum\n  enum_class.enum \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set enum_class.enum\n  enum_class.enum \\<noteq> []\n\ngoal (1 subgoal):\n 1. enum_idx x < length enum_class.enum", "unfolding enum_idx_def"], ["proof (prove)\nusing this:\n  x \\<in> set enum_class.enum\n  enum_class.enum \\<noteq> []\n\ngoal (1 subgoal):\n 1. index_of x enum_class.enum < length enum_class.enum", "using index_of_bound [where x = x and y = \"(Enum.enum :: 'a list)\"]"], ["proof (prove)\nusing this:\n  x \\<in> set enum_class.enum\n  enum_class.enum \\<noteq> []\n  \\<lbrakk>enum_class.enum \\<noteq> []; x \\<in> set enum_class.enum\\<rbrakk>\n  \\<Longrightarrow> index_of x enum_class.enum < length enum_class.enum\n\ngoal (1 subgoal):\n 1. index_of x enum_class.enum < length enum_class.enum", "by auto"], ["proof (state)\nthis:\n  enum_idx x < length enum_class.enum\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_of_nth:\n  assumes \"distinct xs\"\n  assumes \"i < length xs\"\n  shows \"index_of (xs ! i) xs = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of (xs ! i) xs = i", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  i < length xs\n\ngoal (1 subgoal):\n 1. index_of (xs ! i) xs = i", "by (metis gr_implies_not_zero index_of_bound index_of_correct length_0_conv nth_eq_iff_index_eq nth_mem)"], ["", "lemma enum_idx_enum: \n  assumes \\<open>i < CARD('a::enum)\\<close>\n  shows \\<open>enum_idx (enum_class.enum ! i :: 'a) = i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_idx (enum_class.enum ! i) = i", "unfolding enum_idx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. index_of (enum_class.enum ! i) enum_class.enum = i", "apply (rule index_of_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct enum_class.enum\n 2. i < length enum_class.enum", "using assms"], ["proof (prove)\nusing this:\n  i < CARD('a)\n\ngoal (2 subgoals):\n 1. distinct enum_class.enum\n 2. i < length enum_class.enum", "by (simp_all add: card_UNIV_length_enum enum_distinct)"], ["", "subsection \\<open>Filtering lists/sets\\<close>"], ["", "lemma map_filter_map: \"List.map_filter f (map g l) = List.map_filter (f o g) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter f (map g l) = List.map_filter (f \\<circ> g) l", "proof (induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. List.map_filter f (map g []) = List.map_filter (f \\<circ> g) []\n 2. \\<And>a l.\n       List.map_filter f (map g l) =\n       List.map_filter (f \\<circ> g) l \\<Longrightarrow>\n       List.map_filter f (map g (a # l)) =\n       List.map_filter (f \\<circ> g) (a # l)", "show \"List.map_filter f (map g []) = List.map_filter (f \\<circ> g) []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter f (map g []) = List.map_filter (f \\<circ> g) []", "by (simp add: map_filter_simps)"], ["proof (state)\nthis:\n  List.map_filter f (map g []) = List.map_filter (f \\<circ> g) []\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       List.map_filter f (map g l) =\n       List.map_filter (f \\<circ> g) l \\<Longrightarrow>\n       List.map_filter f (map g (a # l)) =\n       List.map_filter (f \\<circ> g) (a # l)", "show \"List.map_filter f (map g (a # l)) = List.map_filter (f \\<circ> g) (a # l)\"\n    if \"List.map_filter f (map g l) = List.map_filter (f \\<circ> g) l\"\n    for a :: 'c\n      and l :: \"'c list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter f (map g (a # l)) =\n    List.map_filter (f \\<circ> g) (a # l)", "using that  map_filter_simps(1)"], ["proof (prove)\nusing this:\n  List.map_filter f (map g l) = List.map_filter (f \\<circ> g) l\n  List.map_filter ?f (?x # ?xs) =\n  (case ?f ?x of None \\<Rightarrow> List.map_filter ?f ?xs\n   | Some y \\<Rightarrow> y # List.map_filter ?f ?xs)\n\ngoal (1 subgoal):\n 1. List.map_filter f (map g (a # l)) =\n    List.map_filter (f \\<circ> g) (a # l)", "by (metis comp_eq_dest_lhs list.simps(9))"], ["proof (state)\nthis:\n  List.map_filter f (map g ?l) =\n  List.map_filter (f \\<circ> g) ?l \\<Longrightarrow>\n  List.map_filter f (map g (?a # ?l)) =\n  List.map_filter (f \\<circ> g) (?a # ?l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_filter_Some[simp]: \"List.map_filter (\\<lambda>x. Some (f x)) l = map f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter (\\<lambda>x. Some (f x)) l = map f l", "proof (induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. List.map_filter (\\<lambda>x. Some (f x)) [] = map f []\n 2. \\<And>a l.\n       List.map_filter (\\<lambda>x. Some (f x)) l =\n       map f l \\<Longrightarrow>\n       List.map_filter (\\<lambda>x. Some (f x)) (a # l) = map f (a # l)", "show \"List.map_filter (\\<lambda>x. Some (f x)) [] = map f []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter (\\<lambda>x. Some (f x)) [] = map f []", "by (simp add: map_filter_simps)"], ["proof (state)\nthis:\n  List.map_filter (\\<lambda>x. Some (f x)) [] = map f []\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       List.map_filter (\\<lambda>x. Some (f x)) l =\n       map f l \\<Longrightarrow>\n       List.map_filter (\\<lambda>x. Some (f x)) (a # l) = map f (a # l)", "show \"List.map_filter (\\<lambda>x. Some (f x)) (a # l) = map f (a # l)\"\n    if \"List.map_filter (\\<lambda>x. Some (f x)) l = map f l\"\n    for a :: 'b\n      and l :: \"'b list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter (\\<lambda>x. Some (f x)) (a # l) = map f (a # l)", "using that"], ["proof (prove)\nusing this:\n  List.map_filter (\\<lambda>x. Some (f x)) l = map f l\n\ngoal (1 subgoal):\n 1. List.map_filter (\\<lambda>x. Some (f x)) (a # l) = map f (a # l)", "by (simp add: map_filter_simps(1))"], ["proof (state)\nthis:\n  List.map_filter (\\<lambda>x. Some (f x)) ?l = map f ?l \\<Longrightarrow>\n  List.map_filter (\\<lambda>x. Some (f x)) (?a # ?l) = map f (?a # ?l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_Un: \"Set.filter f (x \\<union> y) = Set.filter f x \\<union> Set.filter f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter f (x \\<union> y) = Set.filter f x \\<union> Set.filter f y", "unfolding Set.filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a \\<in> x \\<union> y. f a} = {a \\<in> x. f a} \\<union> {a \\<in> y. f a}", "by auto"], ["", "lemma Set_filter_unchanged: \"Set.filter P X = X\" if \"\\<And>x. x\\<in>X \\<Longrightarrow> P x\" for P and X :: \"'z set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter P X = X", "using that"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. Set.filter P X = X", "unfolding Set.filter_def"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. {a \\<in> X. P a} = X", "by auto"], ["", "subsection \\<open>Maps\\<close>"], ["", "definition \"inj_map \\<pi> = (\\<forall>x y. \\<pi> x = \\<pi> y \\<and> \\<pi> x \\<noteq> None \\<longrightarrow> x = y)\""], ["", "definition \"inv_map \\<pi> = (\\<lambda>y. if Some y \\<in> range \\<pi> then Some (inv \\<pi> (Some y)) else None)\""], ["", "lemma inj_map_total[simp]: \"inj_map (Some o \\<pi>) = inj \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_map (Some \\<circ> \\<pi>) = inj \\<pi>", "unfolding inj_map_def inj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y.\n        (Some \\<circ> \\<pi>) x = (Some \\<circ> \\<pi>) y \\<and>\n        (Some \\<circ> \\<pi>) x \\<noteq> None \\<longrightarrow>\n        x = y) =\n    (\\<forall>x y. \\<pi> x = \\<pi> y \\<longrightarrow> x = y)", "by simp"], ["", "lemma inj_map_Some[simp]: \"inj_map Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_map Some", "by (simp add: inj_map_def)"], ["", "lemma inv_map_total: \n  assumes \"surj \\<pi>\"\n  shows \"inv_map (Some o \\<pi>) = Some o inv \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_map (Some \\<circ> \\<pi>) = Some \\<circ> inv \\<pi>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. inv_map (Some \\<circ> \\<pi>) = Some \\<circ> inv \\<pi>", "have \"(if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n          then Some (SOME x. Some (\\<pi> x) = Some y)\n          else None) =\n         Some (SOME b. \\<pi> b = y)\"\n    if \"surj \\<pi>\"\n    for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n     then Some (SOME x. Some (\\<pi> x) = Some y) else None) =\n    Some (SOME b. \\<pi> b = y)", "using that"], ["proof (prove)\nusing this:\n  surj \\<pi>\n\ngoal (1 subgoal):\n 1. (if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n     then Some (SOME x. Some (\\<pi> x) = Some y) else None) =\n    Some (SOME b. \\<pi> b = y)", "by auto"], ["proof (state)\nthis:\n  surj \\<pi> \\<Longrightarrow>\n  (if Some ?y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n   then Some (SOME x. Some (\\<pi> x) = Some ?y) else None) =\n  Some (SOME b. \\<pi> b = ?y)\n\ngoal (1 subgoal):\n 1. inv_map (Some \\<circ> \\<pi>) = Some \\<circ> inv \\<pi>", "hence  \"surj \\<pi> \\<Longrightarrow>\n    (\\<lambda>y. if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n         then Some (SOME x. Some (\\<pi> x) = Some y) else None) =\n    (\\<lambda>x. Some (SOME xa. \\<pi> xa = x))\""], ["proof (prove)\nusing this:\n  surj \\<pi> \\<Longrightarrow>\n  (if Some ?y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n   then Some (SOME x. Some (\\<pi> x) = Some ?y) else None) =\n  Some (SOME b. \\<pi> b = ?y)\n\ngoal (1 subgoal):\n 1. surj \\<pi> \\<Longrightarrow>\n    (\\<lambda>y.\n        if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n        then Some (SOME x. Some (\\<pi> x) = Some y) else None) =\n    (\\<lambda>x. Some (SOME xa. \\<pi> xa = x))", "by (rule ext)"], ["proof (state)\nthis:\n  surj \\<pi> \\<Longrightarrow>\n  (\\<lambda>y.\n      if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n      then Some (SOME x. Some (\\<pi> x) = Some y) else None) =\n  (\\<lambda>x. Some (SOME xa. \\<pi> xa = x))\n\ngoal (1 subgoal):\n 1. inv_map (Some \\<circ> \\<pi>) = Some \\<circ> inv \\<pi>", "thus ?thesis"], ["proof (prove)\nusing this:\n  surj \\<pi> \\<Longrightarrow>\n  (\\<lambda>y.\n      if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n      then Some (SOME x. Some (\\<pi> x) = Some y) else None) =\n  (\\<lambda>x. Some (SOME xa. \\<pi> xa = x))\n\ngoal (1 subgoal):\n 1. inv_map (Some \\<circ> \\<pi>) = Some \\<circ> inv \\<pi>", "unfolding inv_map_def o_def inv_def"], ["proof (prove)\nusing this:\n  surj \\<pi> \\<Longrightarrow>\n  (\\<lambda>y.\n      if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n      then Some (SOME x. Some (\\<pi> x) = Some y) else None) =\n  (\\<lambda>x. Some (SOME xa. \\<pi> xa = x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>y.\n        if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n        then Some (SOME x. Some (\\<pi> x) = Some y) else None) =\n    (\\<lambda>x. Some (SOME xa. \\<pi> xa = x))", "using assms"], ["proof (prove)\nusing this:\n  surj \\<pi> \\<Longrightarrow>\n  (\\<lambda>y.\n      if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n      then Some (SOME x. Some (\\<pi> x) = Some y) else None) =\n  (\\<lambda>x. Some (SOME xa. \\<pi> xa = x))\n  surj \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<lambda>y.\n        if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n        then Some (SOME x. Some (\\<pi> x) = Some y) else None) =\n    (\\<lambda>x. Some (SOME xa. \\<pi> xa = x))", "by linarith"], ["proof (state)\nthis:\n  inv_map (Some \\<circ> \\<pi>) = Some \\<circ> inv \\<pi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_map_map_comp[simp]: \n  assumes a1: \"inj_map f\" and a2: \"inj_map g\" \n  shows \"inj_map (f \\<circ>\\<^sub>m g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_map (f \\<circ>\\<^sub>m g)", "using a1 a2"], ["proof (prove)\nusing this:\n  inj_map f\n  inj_map g\n\ngoal (1 subgoal):\n 1. inj_map (f \\<circ>\\<^sub>m g)", "unfolding inj_map_def"], ["proof (prove)\nusing this:\n  \\<forall>x y. f x = f y \\<and> f x \\<noteq> None \\<longrightarrow> x = y\n  \\<forall>x y. g x = g y \\<and> g x \\<noteq> None \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (f \\<circ>\\<^sub>m g) x = (f \\<circ>\\<^sub>m g) y \\<and>\n       (f \\<circ>\\<^sub>m g) x \\<noteq> None \\<longrightarrow>\n       x = y", "by (metis (mono_tags, lifting) map_comp_def option.case_eq_if option.expand)"], ["", "lemma inj_map_inv_map[simp]: \"inj_map (inv_map \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_map (inv_map \\<pi>)", "proof (unfold inj_map_def, rule allI, rule allI, rule impI, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inv_map \\<pi> x = inv_map \\<pi> y;\n        inv_map \\<pi> x \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inv_map \\<pi> x = inv_map \\<pi> y;\n        inv_map \\<pi> x \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume same: \"inv_map \\<pi> x = inv_map \\<pi> y\"\n    and pix_not_None: \"inv_map \\<pi> x \\<noteq> None\""], ["proof (state)\nthis:\n  inv_map \\<pi> x = inv_map \\<pi> y\n  inv_map \\<pi> x \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inv_map \\<pi> x = inv_map \\<pi> y;\n        inv_map \\<pi> x \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x = y", "have x_pi: \"Some x \\<in> range \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some x \\<in> range \\<pi>", "using pix_not_None"], ["proof (prove)\nusing this:\n  inv_map \\<pi> x \\<noteq> None\n\ngoal (1 subgoal):\n 1. Some x \\<in> range \\<pi>", "unfolding inv_map_def"], ["proof (prove)\nusing this:\n  (if Some x \\<in> range \\<pi> then Some (inv \\<pi> (Some x))\n   else None) \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. Some x \\<in> range \\<pi>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (if Some x \\<in> range \\<pi> then Some (inv \\<pi> (Some x))\n        else None) =\n       Some y \\<Longrightarrow>\n       Some x \\<in> range \\<pi>", "by (meson option.distinct(1))"], ["proof (state)\nthis:\n  Some x \\<in> range \\<pi>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inv_map \\<pi> x = inv_map \\<pi> y;\n        inv_map \\<pi> x \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x = y", "have y_pi: \"Some y \\<in> range \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some y \\<in> range \\<pi>", "using pix_not_None"], ["proof (prove)\nusing this:\n  inv_map \\<pi> x \\<noteq> None\n\ngoal (1 subgoal):\n 1. Some y \\<in> range \\<pi>", "unfolding same"], ["proof (prove)\nusing this:\n  inv_map \\<pi> y \\<noteq> None\n\ngoal (1 subgoal):\n 1. Some y \\<in> range \\<pi>", "unfolding inv_map_def"], ["proof (prove)\nusing this:\n  (if Some y \\<in> range \\<pi> then Some (inv \\<pi> (Some y))\n   else None) \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. Some y \\<in> range \\<pi>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya.\n       (if Some y \\<in> range \\<pi> then Some (inv \\<pi> (Some y))\n        else None) =\n       Some ya \\<Longrightarrow>\n       Some y \\<in> range \\<pi>", "by (meson option.distinct(1))"], ["proof (state)\nthis:\n  Some y \\<in> range \\<pi>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inv_map \\<pi> x = inv_map \\<pi> y;\n        inv_map \\<pi> x \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"inv_map \\<pi> x = Some (Hilbert_Choice.inv \\<pi> (Some x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_map \\<pi> x = Some (inv \\<pi> (Some x))", "unfolding inv_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Some x \\<in> range \\<pi> then Some (inv \\<pi> (Some x)) else None) =\n    Some (inv \\<pi> (Some x))", "using x_pi"], ["proof (prove)\nusing this:\n  Some x \\<in> range \\<pi>\n\ngoal (1 subgoal):\n 1. (if Some x \\<in> range \\<pi> then Some (inv \\<pi> (Some x)) else None) =\n    Some (inv \\<pi> (Some x))", "by simp"], ["proof (state)\nthis:\n  inv_map \\<pi> x = Some (inv \\<pi> (Some x))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inv_map \\<pi> x = inv_map \\<pi> y;\n        inv_map \\<pi> x \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  inv_map \\<pi> x = Some (inv \\<pi> (Some x))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inv_map \\<pi> x = inv_map \\<pi> y;\n        inv_map \\<pi> x \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"inv_map \\<pi> y = Some (Hilbert_Choice.inv \\<pi> (Some y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_map \\<pi> y = Some (inv \\<pi> (Some y))", "unfolding inv_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Some y \\<in> range \\<pi> then Some (inv \\<pi> (Some y)) else None) =\n    Some (inv \\<pi> (Some y))", "using y_pi"], ["proof (prove)\nusing this:\n  Some y \\<in> range \\<pi>\n\ngoal (1 subgoal):\n 1. (if Some y \\<in> range \\<pi> then Some (inv \\<pi> (Some y)) else None) =\n    Some (inv \\<pi> (Some y))", "by simp"], ["proof (state)\nthis:\n  inv_map \\<pi> y = Some (inv \\<pi> (Some y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inv_map \\<pi> x = inv_map \\<pi> y;\n        inv_map \\<pi> x \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  inv_map \\<pi> x = Some (inv \\<pi> (Some x))\n  inv_map \\<pi> y = Some (inv \\<pi> (Some y))", "have \"Hilbert_Choice.inv \\<pi> (Some x) = Hilbert_Choice.inv \\<pi> (Some y)\""], ["proof (prove)\nusing this:\n  inv_map \\<pi> x = Some (inv \\<pi> (Some x))\n  inv_map \\<pi> y = Some (inv \\<pi> (Some y))\n\ngoal (1 subgoal):\n 1. inv \\<pi> (Some x) = inv \\<pi> (Some y)", "using same"], ["proof (prove)\nusing this:\n  inv_map \\<pi> x = Some (inv \\<pi> (Some x))\n  inv_map \\<pi> y = Some (inv \\<pi> (Some y))\n  inv_map \\<pi> x = inv_map \\<pi> y\n\ngoal (1 subgoal):\n 1. inv \\<pi> (Some x) = inv \\<pi> (Some y)", "by simp"], ["proof (state)\nthis:\n  inv \\<pi> (Some x) = inv \\<pi> (Some y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>inv_map \\<pi> x = inv_map \\<pi> y;\n        inv_map \\<pi> x \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  inv \\<pi> (Some x) = inv \\<pi> (Some y)\n\ngoal (1 subgoal):\n 1. x = y", "by (meson inv_into_injective option.inject x_pi y_pi)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}