{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators/One_Dimensional_Spaces.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators", "problem_names": ["lemma one_cinner_one[simp]: \\<open>\\<langle>(1::('a::one_dim)), 1\\<rangle> = 1\\<close>", "lemma one_cinner_a_scaleC_one[simp]: \\<open>\\<langle>1::('a::one_dim), a\\<rangle> *\\<^sub>C 1 = a\\<close>", "lemma one_dim_apply_is_times_def:\n  \"\\<psi> * \\<phi> = (\\<langle>1, \\<psi>\\<rangle> * \\<langle>1, \\<phi>\\<rangle>) *\\<^sub>C 1\" for \\<psi> :: \\<open>'a::one_dim\\<close>", "lemma one_dim_iso_idem[simp]: \"one_dim_iso (one_dim_iso x) = one_dim_iso x\"", "lemma one_dim_iso_id[simp]: \"one_dim_iso = id\"", "lemma one_dim_iso_adjoint[simp]: \\<open>cadjoint one_dim_iso = one_dim_iso\\<close>", "lemma one_dim_iso_is_of_complex[simp]: \"one_dim_iso = of_complex\"", "lemma of_complex_one_dim_iso[simp]: \"of_complex (one_dim_iso \\<psi>) = one_dim_iso \\<psi>\"", "lemma one_dim_iso_of_complex[simp]: \"one_dim_iso (of_complex c) = of_complex c\"", "lemma one_dim_iso_add[simp]:\n  \\<open>one_dim_iso (a + b) = one_dim_iso a + one_dim_iso b\\<close>", "lemma one_dim_iso_minus[simp]:\n  \\<open>one_dim_iso (a - b) = one_dim_iso a - one_dim_iso b\\<close>", "lemma one_dim_iso_scaleC[simp]: \"one_dim_iso (c *\\<^sub>C \\<psi>) = c *\\<^sub>C one_dim_iso \\<psi>\"", "lemma clinear_one_dim_iso[simp]: \"clinear one_dim_iso\"", "lemma bounded_clinear_one_dim_iso[simp]: \"bounded_clinear one_dim_iso\"", "lemma one_dim_iso_of_one[simp]: \"one_dim_iso 1 = 1\"", "lemma onorm_one_dim_iso[simp]: \"onorm one_dim_iso = 1\"", "lemma one_dim_iso_times[simp]: \"one_dim_iso (\\<psi> * \\<phi>) = one_dim_iso \\<psi> * one_dim_iso \\<phi>\"", "lemma one_dim_iso_of_zero[simp]: \"one_dim_iso 0 = 0\"", "lemma one_dim_iso_of_zero': \"one_dim_iso x = 0 \\<Longrightarrow> x = 0\"", "lemma one_dim_scaleC_1[simp]: \"one_dim_iso x *\\<^sub>C 1 = x\"", "lemma one_dim_clinear_eqI: \n  assumes \"(x::'a::one_dim) \\<noteq> 0\" and \"clinear f\" and \"clinear g\" and \"f x = g x\"\n  shows \"f = g\"", "lemma one_dim_norm: \"norm x = cmod (one_dim_iso x)\"", "lemma one_dim_onorm:\n  fixes f :: \"'a::one_dim \\<Rightarrow> 'b::complex_normed_vector\"\n  assumes \"clinear f\"\n  shows \"onorm f = norm (f 1)\"", "lemma one_dim_onorm':\n  fixes f :: \"'a::one_dim \\<Rightarrow> 'b::one_dim\"\n  assumes \"clinear f\"\n  shows \"onorm f = cmod (one_dim_iso (f 1))\"", "lemma one_dim_iso_inj: \"one_dim_iso x = one_dim_iso y \\<Longrightarrow> x = y\""], "translations": [["", "lemma one_cinner_one[simp]: \\<open>\\<langle>(1::('a::one_dim)), 1\\<rangle> = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>1::'a, 1::'a\\<rangle> = 1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>1::'a, 1::'a\\<rangle> = 1", "include notation_norm"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>1::'a, 1::'a\\<rangle> = 1", "have \\<open>(canonical_basis::'a list) = [1::('a::one_dim)]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. canonical_basis = [1::'a]", "by (simp add: one_dim_canonical_basis)"], ["proof (state)\nthis:\n  canonical_basis = [1::'a]\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, 1::'a\\<rangle> = 1", "hence \\<open>\\<parallel>1::'a::one_dim\\<parallel> = 1\\<close>"], ["proof (prove)\nusing this:\n  canonical_basis = [1::'a]\n\ngoal (1 subgoal):\n 1. \\<parallel>1::'a\\<parallel> = 1", "by (metis is_normal list.set_intros(1))"], ["proof (state)\nthis:\n  \\<parallel>1::'a\\<parallel> = 1\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, 1::'a\\<rangle> = 1", "hence \\<open>\\<parallel>1::'a::one_dim\\<parallel>^2 = 1\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>1::'a\\<parallel> = 1\n\ngoal (1 subgoal):\n 1. \\<parallel>1::'a\\<parallel>\\<^sup>2 = 1", "by simp"], ["proof (state)\nthis:\n  \\<parallel>1::'a\\<parallel>\\<^sup>2 = 1\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, 1::'a\\<rangle> = 1", "moreover"], ["proof (state)\nthis:\n  \\<parallel>1::'a\\<parallel>\\<^sup>2 = 1\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, 1::'a\\<rangle> = 1", "have  \\<open>\\<parallel>(1::('a::one_dim))\\<parallel>^2 = \\<langle>(1::('a::one_dim)), 1\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (\\<parallel>1::'a\\<parallel>\\<^sup>2) =\n    \\<langle>1::'a, 1::'a\\<rangle>", "by (metis cnorm_eq_square)"], ["proof (state)\nthis:\n  complex_of_real (\\<parallel>1::'a\\<parallel>\\<^sup>2) =\n  \\<langle>1::'a, 1::'a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, 1::'a\\<rangle> = 1", "ultimately"], ["proof (chain)\npicking this:\n  \\<parallel>1::'a\\<parallel>\\<^sup>2 = 1\n  complex_of_real (\\<parallel>1::'a\\<parallel>\\<^sup>2) =\n  \\<langle>1::'a, 1::'a\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>1::'a\\<parallel>\\<^sup>2 = 1\n  complex_of_real (\\<parallel>1::'a\\<parallel>\\<^sup>2) =\n  \\<langle>1::'a, 1::'a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, 1::'a\\<rangle> = 1", "by simp"], ["proof (state)\nthis:\n  \\<langle>1::'a, 1::'a\\<rangle> = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_cinner_a_scaleC_one[simp]: \\<open>\\<langle>1::('a::one_dim), a\\<rangle> *\\<^sub>C 1 = a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a", "have \\<open>(canonical_basis::'a list) = [1]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. canonical_basis = [1::'a]", "by (simp add: one_dim_canonical_basis)"], ["proof (state)\nthis:\n  canonical_basis = [1::'a]\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a", "hence r2: \\<open>a \\<in> complex_vector.span ({1::'a})\\<close>"], ["proof (prove)\nusing this:\n  canonical_basis = [1::'a]\n\ngoal (1 subgoal):\n 1. a \\<in> cspan {1::'a}", "using  iso_tuple_UNIV_I empty_set is_generator_set list.simps(15)"], ["proof (prove)\nusing this:\n  canonical_basis = [1::'a]\n  ?x \\<in> UNIV \\<equiv> True\n  {} = set []\n  cspan (set canonical_basis) = UNIV\n  set (?x21.0 # ?x22.0) = insert ?x21.0 (set ?x22.0)\n\ngoal (1 subgoal):\n 1. a \\<in> cspan {1::'a}", "by metis"], ["proof (state)\nthis:\n  a \\<in> cspan {1::'a}\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a", "have \"(1::'a) \\<notin> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<notin> {}", "by (metis equals0D)"], ["proof (state)\nthis:\n  (1::'a) \\<notin> {}\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a", "hence r1: \\<open>\\<exists> s. a = s *\\<^sub>C 1\\<close>"], ["proof (prove)\nusing this:\n  (1::'a) \\<notin> {}\n\ngoal (1 subgoal):\n 1. \\<exists>s. a = s *\\<^sub>C (1::'a)", "by (metis Diff_insert_absorb r2 complex_vector.span_breakdown \n        complex_vector.span_empty eq_iff_diff_eq_0 singleton_iff)"], ["proof (state)\nthis:\n  \\<exists>s. a = s *\\<^sub>C (1::'a)\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a", "then"], ["proof (chain)\npicking this:\n  \\<exists>s. a = s *\\<^sub>C (1::'a)", "obtain s where s_def: \\<open>a = s *\\<^sub>C 1\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>s. a = s *\\<^sub>C (1::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        a = s *\\<^sub>C (1::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a = s *\\<^sub>C (1::'a)\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a", "have  \\<open>\\<langle>(1::'a), a\\<rangle> = \\<langle>(1::'a), s *\\<^sub>C 1\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> =\n    \\<langle>1::'a, s *\\<^sub>C (1::'a)\\<rangle>", "using \\<open>a = s *\\<^sub>C 1\\<close>"], ["proof (prove)\nusing this:\n  a = s *\\<^sub>C (1::'a)\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> =\n    \\<langle>1::'a, s *\\<^sub>C (1::'a)\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<langle>1::'a, a\\<rangle> = \\<langle>1::'a, s *\\<^sub>C (1::'a)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a", "also"], ["proof (state)\nthis:\n  \\<langle>1::'a, a\\<rangle> = \\<langle>1::'a, s *\\<^sub>C (1::'a)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a", "have \\<open>\\<dots> = s * \\<langle>(1::'a), 1\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>1::'a, s *\\<^sub>C (1::'a)\\<rangle> =\n    s * \\<langle>1::'a, 1::'a\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<langle>1::'a, s *\\<^sub>C (1::'a)\\<rangle> =\n  s * \\<langle>1::'a, 1::'a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a", "also"], ["proof (state)\nthis:\n  \\<langle>1::'a, s *\\<^sub>C (1::'a)\\<rangle> =\n  s * \\<langle>1::'a, 1::'a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a", "have \\<open>\\<dots> = s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. s * \\<langle>1::'a, 1::'a\\<rangle> = s", "using one_cinner_one"], ["proof (prove)\nusing this:\n  \\<langle>1::?'a, 1::?'a\\<rangle> = 1\n\ngoal (1 subgoal):\n 1. s * \\<langle>1::'a, 1::'a\\<rangle> = s", "by auto"], ["proof (state)\nthis:\n  s * \\<langle>1::'a, 1::'a\\<rangle> = s\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a", "finally"], ["proof (chain)\npicking this:\n  \\<langle>1::'a, a\\<rangle> = s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>1::'a, a\\<rangle> = s\n\ngoal (1 subgoal):\n 1. \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a", "by (simp add: s_def)"], ["proof (state)\nthis:\n  \\<langle>1::'a, a\\<rangle> *\\<^sub>C (1::'a) = a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_dim_apply_is_times_def:\n  \"\\<psi> * \\<phi> = (\\<langle>1, \\<psi>\\<rangle> * \\<langle>1, \\<phi>\\<rangle>) *\\<^sub>C 1\" for \\<psi> :: \\<open>'a::one_dim\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> * \\<phi> =\n    (\\<langle>1::'a, \\<psi>\\<rangle> *\n     \\<langle>1::'a, \\<phi>\\<rangle>) *\\<^sub>C\n    (1::'a)", "by (metis one_cinner_a_scaleC_one one_dim_prod_scale1)"], ["", "instance one_dim \\<subseteq> complex_algebra_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, complex_algebra_1_class)", "proof"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b c. (a + b) * c = a * c + b * c\n 3. \\<And>a b c. a * (b + c) = a * b + a * c\n 4. \\<And>a x y. a *\\<^sub>C x * y = a *\\<^sub>C (x * y)\n 5. \\<And>x a y. x * a *\\<^sub>C y = a *\\<^sub>C (x * y)\n 6. \\<And>a. (1::'a) * a = a\n 7. \\<And>a. a * (1::'a) = a\n 8. (0::'a) \\<noteq> (1::'a)", "fix x y z :: \\<open>'a::one_dim\\<close> and c :: complex"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b c. (a + b) * c = a * c + b * c\n 3. \\<And>a b c. a * (b + c) = a * b + a * c\n 4. \\<And>a x y. a *\\<^sub>C x * y = a *\\<^sub>C (x * y)\n 5. \\<And>x a y. x * a *\\<^sub>C y = a *\\<^sub>C (x * y)\n 6. \\<And>a. (1::'a) * a = a\n 7. \\<And>a. a * (1::'a) = a\n 8. (0::'a) \\<noteq> (1::'a)", "show \"(x * y) * z = x * (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y * z = x * (y * z)", "by (simp add: one_dim_apply_is_times_def[where ?'a='a])"], ["proof (state)\nthis:\n  x * y * z = x * (y * z)\n\ngoal (7 subgoals):\n 1. \\<And>a b c. (a + b) * c = a * c + b * c\n 2. \\<And>a b c. a * (b + c) = a * b + a * c\n 3. \\<And>a x y. a *\\<^sub>C x * y = a *\\<^sub>C (x * y)\n 4. \\<And>x a y. x * a *\\<^sub>C y = a *\\<^sub>C (x * y)\n 5. \\<And>a. (1::'a) * a = a\n 6. \\<And>a. a * (1::'a) = a\n 7. (0::'a) \\<noteq> (1::'a)", "show \"(x + y) * z = x * z + y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) * z = x * z + y * z", "by (metis (no_types, lifting) cinner_simps(2) complex_vector.vector_space_assms(2) complex_vector.vector_space_assms(3) one_dim_apply_is_times_def)"], ["proof (state)\nthis:\n  (x + y) * z = x * z + y * z\n\ngoal (6 subgoals):\n 1. \\<And>a b c. a * (b + c) = a * b + a * c\n 2. \\<And>a x y. a *\\<^sub>C x * y = a *\\<^sub>C (x * y)\n 3. \\<And>x a y. x * a *\\<^sub>C y = a *\\<^sub>C (x * y)\n 4. \\<And>a. (1::'a) * a = a\n 5. \\<And>a. a * (1::'a) = a\n 6. (0::'a) \\<noteq> (1::'a)", "show \"x * (y + z) = x * y + x * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y + z) = x * y + x * z", "by (metis (mono_tags, lifting) cinner_simps(2) complex_vector.vector_space_assms(2) distrib_left one_dim_apply_is_times_def)"], ["proof (state)\nthis:\n  x * (y + z) = x * y + x * z\n\ngoal (5 subgoals):\n 1. \\<And>a x y. a *\\<^sub>C x * y = a *\\<^sub>C (x * y)\n 2. \\<And>x a y. x * a *\\<^sub>C y = a *\\<^sub>C (x * y)\n 3. \\<And>a. (1::'a) * a = a\n 4. \\<And>a. a * (1::'a) = a\n 5. (0::'a) \\<noteq> (1::'a)", "show \"(c *\\<^sub>C x) * y = c *\\<^sub>C (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C x * y = c *\\<^sub>C (x * y)", "by (simp add: one_dim_apply_is_times_def[where ?'a='a])"], ["proof (state)\nthis:\n  c *\\<^sub>C x * y = c *\\<^sub>C (x * y)\n\ngoal (4 subgoals):\n 1. \\<And>x a y. x * a *\\<^sub>C y = a *\\<^sub>C (x * y)\n 2. \\<And>a. (1::'a) * a = a\n 3. \\<And>a. a * (1::'a) = a\n 4. (0::'a) \\<noteq> (1::'a)", "show \"x * (c *\\<^sub>C y) = c *\\<^sub>C (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * c *\\<^sub>C y = c *\\<^sub>C (x * y)", "by (simp add: one_dim_apply_is_times_def[where ?'a='a])"], ["proof (state)\nthis:\n  x * c *\\<^sub>C y = c *\\<^sub>C (x * y)\n\ngoal (3 subgoals):\n 1. \\<And>a. (1::'a) * a = a\n 2. \\<And>a. a * (1::'a) = a\n 3. (0::'a) \\<noteq> (1::'a)", "show \"1 * x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) * x = x", "by (metis mult.left_neutral one_cinner_a_scaleC_one one_cinner_one one_dim_apply_is_times_def)"], ["proof (state)\nthis:\n  (1::'a) * x = x\n\ngoal (2 subgoals):\n 1. \\<And>a. a * (1::'a) = a\n 2. (0::'a) \\<noteq> (1::'a)", "show \"x * 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1::'a) = x", "by (simp add: one_dim_apply_is_times_def [where ?'a = 'a])"], ["proof (state)\nthis:\n  x * (1::'a) = x\n\ngoal (1 subgoal):\n 1. (0::'a) \\<noteq> (1::'a)", "show \"(0::'a) \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<noteq> (1::'a)", "by (metis cinner_eq_zero_iff one_cinner_one zero_neq_one)"], ["proof (state)\nthis:\n  (0::'a) \\<noteq> (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance one_dim \\<subseteq> complex_normed_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, complex_normed_algebra_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. norm (x * y) \\<le> norm x * norm y", "fix x y :: \\<open>'a::one_dim\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. norm (x * y) \\<le> norm x * norm y", "show \"norm (x * y) \\<le> norm x * norm y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "have r1:  \"cmod (\\<langle>1::'a, x\\<rangle>) \\<le> norm (1::'a) * norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<langle>1::'a, x\\<rangle> \\<le> norm (1::'a) * norm x", "by (simp add: complex_inner_class.Cauchy_Schwarz_ineq2)"], ["proof (state)\nthis:\n  cmod \\<langle>1::'a, x\\<rangle> \\<le> norm (1::'a) * norm x\n\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "have r2: \"cmod (\\<langle>1::'a, y\\<rangle>) \\<le> norm (1::'a) * norm y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<langle>1::'a, y\\<rangle> \\<le> norm (1::'a) * norm y", "by (simp add: complex_inner_class.Cauchy_Schwarz_ineq2)"], ["proof (state)\nthis:\n  cmod \\<langle>1::'a, y\\<rangle> \\<le> norm (1::'a) * norm y\n\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "have q1: \"\\<langle>(1::'a), 1\\<rangle> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>1::'a, 1::'a\\<rangle> = 1", "by (simp add: )"], ["proof (state)\nthis:\n  \\<langle>1::'a, 1::'a\\<rangle> = 1\n\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "hence \"(norm (1::'a))^2 = 1\""], ["proof (prove)\nusing this:\n  \\<langle>1::'a, 1::'a\\<rangle> = 1\n\ngoal (1 subgoal):\n 1. (norm (1::'a))\\<^sup>2 = 1", "by (simp add: cnorm_eq_1 power2_eq_1_iff)"], ["proof (state)\nthis:\n  (norm (1::'a))\\<^sup>2 = 1\n\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "hence \"norm (1::'a) = 1\""], ["proof (prove)\nusing this:\n  (norm (1::'a))\\<^sup>2 = 1\n\ngoal (1 subgoal):\n 1. norm (1::'a) = 1", "by (smt abs_norm_cancel power2_eq_1_iff)"], ["proof (state)\nthis:\n  norm (1::'a) = 1\n\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "hence \"cmod (\\<langle>1::'a, x\\<rangle> * \\<langle>1::'a, y\\<rangle>) * norm (1::'a) = cmod (\\<langle>1::'a, x\\<rangle> * \\<langle>1::'a, y\\<rangle>)\""], ["proof (prove)\nusing this:\n  norm (1::'a) = 1\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>1::'a, x\\<rangle> * \\<langle>1::'a, y\\<rangle>) *\n    norm (1::'a) =\n    cmod (\\<langle>1::'a, x\\<rangle> * \\<langle>1::'a, y\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  cmod (\\<langle>1::'a, x\\<rangle> * \\<langle>1::'a, y\\<rangle>) *\n  norm (1::'a) =\n  cmod (\\<langle>1::'a, x\\<rangle> * \\<langle>1::'a, y\\<rangle>)\n\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "also"], ["proof (state)\nthis:\n  cmod (\\<langle>1::'a, x\\<rangle> * \\<langle>1::'a, y\\<rangle>) *\n  norm (1::'a) =\n  cmod (\\<langle>1::'a, x\\<rangle> * \\<langle>1::'a, y\\<rangle>)\n\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "have \"\\<dots> = cmod (\\<langle>1::'a, x\\<rangle>) * cmod (\\<langle>1::'a, y\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<langle>1::'a, x\\<rangle> * \\<langle>1::'a, y\\<rangle>) =\n    cmod \\<langle>1::'a, x\\<rangle> * cmod \\<langle>1::'a, y\\<rangle>", "by (simp add: norm_mult)"], ["proof (state)\nthis:\n  cmod (\\<langle>1::'a, x\\<rangle> * \\<langle>1::'a, y\\<rangle>) =\n  cmod \\<langle>1::'a, x\\<rangle> * cmod \\<langle>1::'a, y\\<rangle>\n\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "also"], ["proof (state)\nthis:\n  cmod (\\<langle>1::'a, x\\<rangle> * \\<langle>1::'a, y\\<rangle>) =\n  cmod \\<langle>1::'a, x\\<rangle> * cmod \\<langle>1::'a, y\\<rangle>\n\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "have \"\\<dots> \\<le> norm (1::'a) * norm x * norm (1::'a) * norm y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<langle>1::'a, x\\<rangle> * cmod \\<langle>1::'a, y\\<rangle>\n    \\<le> norm (1::'a) * norm x * norm (1::'a) * norm y", "by (smt \\<open>norm 1 = 1\\<close> mult.commute mult_cancel_right1 norm_scaleC one_cinner_a_scaleC_one)"], ["proof (state)\nthis:\n  cmod \\<langle>1::'a, x\\<rangle> * cmod \\<langle>1::'a, y\\<rangle>\n  \\<le> norm (1::'a) * norm x * norm (1::'a) * norm y\n\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "also"], ["proof (state)\nthis:\n  cmod \\<langle>1::'a, x\\<rangle> * cmod \\<langle>1::'a, y\\<rangle>\n  \\<le> norm (1::'a) * norm x * norm (1::'a) * norm y\n\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "have \"\\<dots> = norm x * norm y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (1::'a) * norm x * norm (1::'a) * norm y = norm x * norm y", "by (simp add: \\<open>norm 1 = 1\\<close>)"], ["proof (state)\nthis:\n  norm (1::'a) * norm x * norm (1::'a) * norm y = norm x * norm y\n\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "finally"], ["proof (chain)\npicking this:\n  cmod (\\<langle>1::'a, x\\<rangle> * \\<langle>1::'a, y\\<rangle>) *\n  norm (1::'a)\n  \\<le> norm x * norm y", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (\\<langle>1::'a, x\\<rangle> * \\<langle>1::'a, y\\<rangle>) *\n  norm (1::'a)\n  \\<le> norm x * norm y\n\ngoal (1 subgoal):\n 1. norm (x * y) \\<le> norm x * norm y", "by (simp add: one_dim_apply_is_times_def[where ?'a='a])"], ["proof (state)\nthis:\n  norm (x * y) \\<le> norm x * norm y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (x * y) \\<le> norm x * norm y\n\ngoal:\nNo subgoals!", "qed"], ["", "instance one_dim \\<subseteq> complex_normed_algebra_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, complex_normed_algebra_1_class)", "proof intro_classes"], ["proof (state)\ngoal (1 subgoal):\n 1. norm (1::'a) = 1", "show \"norm (1::'a) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (1::'a) = 1", "by (metis complex_inner_1_left norm_eq_sqrt_cinner norm_one one_cinner_one)"], ["proof (state)\nthis:\n  norm (1::'a) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This is the canonical isomorphism between any two one dimensional spaces. Specifically,\n  if 1 denotes the element of the canonical basis (which is specified by type class \\<^class>\\<open>basis_enum\\<close>,\n  then \\<^term>\\<open>one_dim_iso\\<close> is the unique isomorphism that maps 1 to 1.\\<close>"], ["", "definition one_dim_iso :: \"'a::one_dim \\<Rightarrow> 'b::one_dim\"\n  where \"one_dim_iso a = of_complex (\\<langle>1, a\\<rangle>)\""], ["", "lemma one_dim_iso_idem[simp]: \"one_dim_iso (one_dim_iso x) = one_dim_iso x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso (one_dim_iso x) = one_dim_iso x", "by (simp add: one_dim_iso_def)"], ["", "lemma one_dim_iso_id[simp]: \"one_dim_iso = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso = id", "unfolding one_dim_iso_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. of_complex \\<langle>1::'a, a\\<rangle>) = id", "by (auto simp add: of_complex_def)"], ["", "lemma one_dim_iso_adjoint[simp]: \\<open>cadjoint one_dim_iso = one_dim_iso\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso\\<^sup>\\<dagger> = one_dim_iso", "apply (rule cadjoint_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<langle>one_dim_iso x, y\\<rangle> =\n       \\<langle>x, one_dim_iso y\\<rangle>", "by (simp add: one_dim_iso_def of_complex_def)"], ["", "lemma one_dim_iso_is_of_complex[simp]: \"one_dim_iso = of_complex\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso = of_complex", "unfolding one_dim_iso_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. of_complex \\<langle>1, a\\<rangle>) = of_complex", "by auto"], ["", "lemma of_complex_one_dim_iso[simp]: \"of_complex (one_dim_iso \\<psi>) = one_dim_iso \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (one_dim_iso \\<psi>) = one_dim_iso \\<psi>", "by (metis one_dim_iso_is_of_complex one_dim_iso_idem)"], ["", "lemma one_dim_iso_of_complex[simp]: \"one_dim_iso (of_complex c) = of_complex c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso (of_complex c) = of_complex c", "by (metis one_dim_iso_is_of_complex one_dim_iso_idem)"], ["", "lemma one_dim_iso_add[simp]:\n  \\<open>one_dim_iso (a + b) = one_dim_iso a + one_dim_iso b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso (a + b) = one_dim_iso a + one_dim_iso b", "by (simp add: cinner_simps(2) one_dim_iso_def)"], ["", "lemma one_dim_iso_minus[simp]:\n  \\<open>one_dim_iso (a - b) = one_dim_iso a - one_dim_iso b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso (a - b) = one_dim_iso a - one_dim_iso b", "by (simp add: cinner_simps(3) one_dim_iso_def)"], ["", "lemma one_dim_iso_scaleC[simp]: \"one_dim_iso (c *\\<^sub>C \\<psi>) = c *\\<^sub>C one_dim_iso \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso (c *\\<^sub>C \\<psi>) = c *\\<^sub>C one_dim_iso \\<psi>", "by (metis cinner_scaleC_right of_complex_mult one_dim_iso_def scaleC_conv_of_complex)"], ["", "lemma clinear_one_dim_iso[simp]: \"clinear one_dim_iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear one_dim_iso", "by (rule clinearI, auto)"], ["", "lemma bounded_clinear_one_dim_iso[simp]: \"bounded_clinear one_dim_iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear one_dim_iso", "proof (rule bounded_clinear_intro [where K = 1] , auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. norm (one_dim_iso x) \\<le> norm x", "fix x :: \\<open>'a::one_dim\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. norm (one_dim_iso x) \\<le> norm x", "show \"norm (one_dim_iso x) \\<le> norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (one_dim_iso x) \\<le> norm x", "by (metis (full_types) norm_of_complex of_complex_def one_cinner_a_scaleC_one one_dim_iso_def \n        order_refl)"], ["proof (state)\nthis:\n  norm (one_dim_iso x) \\<le> norm x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_dim_iso_of_one[simp]: \"one_dim_iso 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso (1::'b) = (1::'a)", "by (simp add: one_dim_iso_def)"], ["", "lemma onorm_one_dim_iso[simp]: \"onorm one_dim_iso = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm one_dim_iso = 1", "proof (rule onormI [where b = 1 and x = 1])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. norm (one_dim_iso x) \\<le> 1 * norm x\n 2. (1::'a) \\<noteq> (0::'a)\n 3. norm (one_dim_iso (1::'a)) = 1 * norm (1::'a)", "fix x :: \\<open>'a::one_dim\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. norm (one_dim_iso x) \\<le> 1 * norm x\n 2. (1::'a) \\<noteq> (0::'a)\n 3. norm (one_dim_iso (1::'a)) = 1 * norm (1::'a)", "have \"norm (one_dim_iso x ::'b) \\<le> norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (one_dim_iso x) \\<le> norm x", "by (metis eq_iff norm_of_complex of_complex_def one_cinner_a_scaleC_one one_dim_iso_def)"], ["proof (state)\nthis:\n  norm (one_dim_iso x) \\<le> norm x\n\ngoal (3 subgoals):\n 1. \\<And>x. norm (one_dim_iso x) \\<le> 1 * norm x\n 2. (1::'a) \\<noteq> (0::'a)\n 3. norm (one_dim_iso (1::'a)) = 1 * norm (1::'a)", "thus \"norm (one_dim_iso (x::'a)::'b) \\<le> 1 * norm x\""], ["proof (prove)\nusing this:\n  norm (one_dim_iso x) \\<le> norm x\n\ngoal (1 subgoal):\n 1. norm (one_dim_iso x) \\<le> 1 * norm x", "by auto"], ["proof (state)\nthis:\n  norm (one_dim_iso x) \\<le> 1 * norm x\n\ngoal (2 subgoals):\n 1. (1::'a) \\<noteq> (0::'a)\n 2. norm (one_dim_iso (1::'a)) = 1 * norm (1::'a)", "show \"(1::'a) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<noteq> (0::'a)", "by simp"], ["proof (state)\nthis:\n  (1::'a) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. norm (one_dim_iso (1::'a)) = 1 * norm (1::'a)", "show \"norm (one_dim_iso (1::'a)::'b) = 1 * norm (1::'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (one_dim_iso (1::'a)) = 1 * norm (1::'a)", "by auto"], ["proof (state)\nthis:\n  norm (one_dim_iso (1::'a)) = 1 * norm (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_dim_iso_times[simp]: \"one_dim_iso (\\<psi> * \\<phi>) = one_dim_iso \\<psi> * one_dim_iso \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso (\\<psi> * \\<phi>) = one_dim_iso \\<psi> * one_dim_iso \\<phi>", "by (metis mult.left_neutral mult_scaleC_left of_complex_def one_cinner_a_scaleC_one one_dim_iso_def one_dim_iso_scaleC)"], ["", "lemma one_dim_iso_of_zero[simp]: \"one_dim_iso 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso (0::'b) = (0::'a)", "by (simp add: complex_vector.linear_0)"], ["", "lemma one_dim_iso_of_zero': \"one_dim_iso x = 0 \\<Longrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso x = (0::'a) \\<Longrightarrow> x = (0::'b)", "by (metis of_complex_def of_complex_eq_0_iff one_cinner_a_scaleC_one one_dim_iso_def)"], ["", "lemma one_dim_scaleC_1[simp]: \"one_dim_iso x *\\<^sub>C 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso x *\\<^sub>C (1::'a) = x", "by (simp add: one_dim_iso_def)"], ["", "lemma one_dim_clinear_eqI: \n  assumes \"(x::'a::one_dim) \\<noteq> 0\" and \"clinear f\" and \"clinear g\" and \"f x = g x\"\n  shows \"f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "fix y :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "from \\<open>f x = g x\\<close>"], ["proof (chain)\npicking this:\n  f x = g x", "have \\<open>one_dim_iso x *\\<^sub>C f 1 = one_dim_iso x *\\<^sub>C g 1\\<close>"], ["proof (prove)\nusing this:\n  f x = g x\n\ngoal (1 subgoal):\n 1. one_dim_iso x *\\<^sub>C f (1::'a) = one_dim_iso x *\\<^sub>C g (1::'a)", "by (metis assms(2) assms(3) complex_vector.linear_scale one_dim_scaleC_1)"], ["proof (state)\nthis:\n  one_dim_iso x *\\<^sub>C f (1::'a) = one_dim_iso x *\\<^sub>C g (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "hence \"f 1 = g 1\""], ["proof (prove)\nusing this:\n  one_dim_iso x *\\<^sub>C f (1::'a) = one_dim_iso x *\\<^sub>C g (1::'a)\n\ngoal (1 subgoal):\n 1. f (1::'a) = g (1::'a)", "using assms(1) one_dim_iso_of_zero'"], ["proof (prove)\nusing this:\n  one_dim_iso x *\\<^sub>C f (1::'a) = one_dim_iso x *\\<^sub>C g (1::'a)\n  x \\<noteq> (0::'a)\n  one_dim_iso ?x = (0::?'a) \\<Longrightarrow> ?x = (0::?'b)\n\ngoal (1 subgoal):\n 1. f (1::'a) = g (1::'a)", "by auto"], ["proof (state)\nthis:\n  f (1::'a) = g (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "then"], ["proof (chain)\npicking this:\n  f (1::'a) = g (1::'a)", "show \"f y = g y\""], ["proof (prove)\nusing this:\n  f (1::'a) = g (1::'a)\n\ngoal (1 subgoal):\n 1. f y = g y", "by (metis assms(2) assms(3) complex_vector.linear_scale one_dim_scaleC_1)"], ["proof (state)\nthis:\n  f y = g y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_dim_norm: \"norm x = cmod (one_dim_iso x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x = cmod (one_dim_iso x)", "proof (subst one_dim_scaleC_1 [symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. norm (one_dim_iso x *\\<^sub>C (1::'a)) = cmod (one_dim_iso x)", "show \"norm (one_dim_iso x *\\<^sub>C (1::'a)) = cmod (one_dim_iso x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (one_dim_iso x *\\<^sub>C (1::'a)) = cmod (one_dim_iso x)", "by (metis norm_of_complex of_complex_def)"], ["proof (state)\nthis:\n  norm (one_dim_iso x *\\<^sub>C (1::'a)) = cmod (one_dim_iso x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_dim_onorm:\n  fixes f :: \"'a::one_dim \\<Rightarrow> 'b::complex_normed_vector\"\n  assumes \"clinear f\"\n  shows \"onorm f = norm (f 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm f = norm (f (1::'a))", "proof (rule onormI[where x=1])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. norm (f x) \\<le> norm (f (1::'a)) * norm x\n 2. (1::'a) \\<noteq> (0::'a)\n 3. norm (f (1::'a)) = norm (f (1::'a)) * norm (1::'a)", "fix x :: 'a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. norm (f x) \\<le> norm (f (1::'a)) * norm x\n 2. (1::'a) \\<noteq> (0::'a)\n 3. norm (f (1::'a)) = norm (f (1::'a)) * norm (1::'a)", "have \"norm x * norm (f 1) \\<le> norm (f 1) * norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x * norm (f (1::'a)) \\<le> norm (f (1::'a)) * norm x", "by simp"], ["proof (state)\nthis:\n  norm x * norm (f (1::'a)) \\<le> norm (f (1::'a)) * norm x\n\ngoal (3 subgoals):\n 1. \\<And>x. norm (f x) \\<le> norm (f (1::'a)) * norm x\n 2. (1::'a) \\<noteq> (0::'a)\n 3. norm (f (1::'a)) = norm (f (1::'a)) * norm (1::'a)", "hence \"norm (f (one_dim_iso x *\\<^sub>C 1)) \\<le> norm (f 1) * norm x\""], ["proof (prove)\nusing this:\n  norm x * norm (f (1::'a)) \\<le> norm (f (1::'a)) * norm x\n\ngoal (1 subgoal):\n 1. norm (f (one_dim_iso x *\\<^sub>C (1::'a)))\n    \\<le> norm (f (1::'a)) * norm x", "by (metis (mono_tags, lifting) assms complex_vector.linear_scale norm_scaleC one_dim_norm)"], ["proof (state)\nthis:\n  norm (f (one_dim_iso x *\\<^sub>C (1::'a))) \\<le> norm (f (1::'a)) * norm x\n\ngoal (3 subgoals):\n 1. \\<And>x. norm (f x) \\<le> norm (f (1::'a)) * norm x\n 2. (1::'a) \\<noteq> (0::'a)\n 3. norm (f (1::'a)) = norm (f (1::'a)) * norm (1::'a)", "thus \"norm (f x) \\<le> norm (f 1) * norm x\""], ["proof (prove)\nusing this:\n  norm (f (one_dim_iso x *\\<^sub>C (1::'a))) \\<le> norm (f (1::'a)) * norm x\n\ngoal (1 subgoal):\n 1. norm (f x) \\<le> norm (f (1::'a)) * norm x", "by (subst one_dim_scaleC_1 [symmetric])"], ["proof (state)\nthis:\n  norm (f x) \\<le> norm (f (1::'a)) * norm x\n\ngoal (2 subgoals):\n 1. (1::'a) \\<noteq> (0::'a)\n 2. norm (f (1::'a)) = norm (f (1::'a)) * norm (1::'a)", "qed auto"], ["", "lemma one_dim_onorm':\n  fixes f :: \"'a::one_dim \\<Rightarrow> 'b::one_dim\"\n  assumes \"clinear f\"\n  shows \"onorm f = cmod (one_dim_iso (f 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm f = cmod (one_dim_iso (f (1::'a)))", "using assms one_dim_norm one_dim_onorm"], ["proof (prove)\nusing this:\n  clinear f\n  norm ?x = cmod (one_dim_iso ?x)\n  clinear ?f \\<Longrightarrow> onorm ?f = norm (?f (1::?'a))\n\ngoal (1 subgoal):\n 1. onorm f = cmod (one_dim_iso (f (1::'a)))", "by fastforce"], ["", "instance one_dim \\<subseteq> zero_neq_one"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, zero_neq_one_class)", ".."], ["", "lemma one_dim_iso_inj: \"one_dim_iso x = one_dim_iso y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso x = one_dim_iso y \\<Longrightarrow> x = y", "by (metis one_dim_iso_idem one_dim_scaleC_1)"], ["", "instance one_dim \\<subseteq> comm_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, comm_ring_class)", "proof intro_classes"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b. a * b = b * a\n 2. \\<And>a b c. (a + b) * c = a * c + b * c", "fix x y z :: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b. a * b = b * a\n 2. \\<And>a b c. (a + b) * c = a * c + b * c", "show \"x * y = y * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = y * x", "by (metis one_dim_apply_is_times_def ordered_field_class.sign_simps(5))"], ["proof (state)\nthis:\n  x * y = y * x\n\ngoal (1 subgoal):\n 1. \\<And>a b c. (a + b) * c = a * c + b * c", "show \"(x + y) * z = x * z + y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) * z = x * z + y * z", "by (simp add: ring_class.ring_distribs(2))"], ["proof (state)\nthis:\n  (x + y) * z = x * z + y * z\n\ngoal:\nNo subgoals!", "qed"], ["", "instance one_dim \\<subseteq> field"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, field_class)", "proof intro_classes"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a. (1::'a) * a = a\n 2. \\<And>a. a \\<noteq> (0::'a) \\<Longrightarrow> inverse a * a = (1::'a)\n 3. \\<And>a b. a / b = a * inverse b\n 4. inverse (0::'a) = (0::'a)", "fix x y z :: \\<open>'a::one_dim\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a. (1::'a) * a = a\n 2. \\<And>a. a \\<noteq> (0::'a) \\<Longrightarrow> inverse a * a = (1::'a)\n 3. \\<And>a b. a / b = a * inverse b\n 4. inverse (0::'a) = (0::'a)", "show \"1 * x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) * x = x", "by simp"], ["proof (state)\nthis:\n  (1::'a) * x = x\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<noteq> (0::'a) \\<Longrightarrow> inverse a * a = (1::'a)\n 2. \\<And>a b. a / b = a * inverse b\n 3. inverse (0::'a) = (0::'a)", "have \"(inverse \\<langle>1, x\\<rangle> * \\<langle>1, x\\<rangle>) *\\<^sub>C (1::'a) = 1\" if \"x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inverse \\<langle>1::'a, x\\<rangle> *\n     \\<langle>1::'a, x\\<rangle>) *\\<^sub>C\n    (1::'a) =\n    (1::'a)", "by (metis left_inverse of_complex_def one_cinner_a_scaleC_one one_dim_iso_of_zero \n        one_dim_iso_is_of_complex one_dim_iso_of_one that)"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a) \\<Longrightarrow>\n  (inverse \\<langle>1::'a, x\\<rangle> *\n   \\<langle>1::'a, x\\<rangle>) *\\<^sub>C\n  (1::'a) =\n  (1::'a)\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<noteq> (0::'a) \\<Longrightarrow> inverse a * a = (1::'a)\n 2. \\<And>a b. a / b = a * inverse b\n 3. inverse (0::'a) = (0::'a)", "hence \"inverse (\\<langle>1, x\\<rangle> *\\<^sub>C 1) * \\<langle>1, x\\<rangle> *\\<^sub>C 1 = (1::'a)\" if \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a) \\<Longrightarrow>\n  (inverse \\<langle>1::'a, x\\<rangle> *\n   \\<langle>1::'a, x\\<rangle>) *\\<^sub>C\n  (1::'a) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. inverse (\\<langle>1::'a, x\\<rangle> *\\<^sub>C (1::'a)) *\n    \\<langle>1::'a, x\\<rangle> *\\<^sub>C (1::'a) =\n    (1::'a)", "by (metis one_dim_inverse one_dim_prod_scale1 that)"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a) \\<Longrightarrow>\n  inverse (\\<langle>1::'a, x\\<rangle> *\\<^sub>C (1::'a)) *\n  \\<langle>1::'a, x\\<rangle> *\\<^sub>C (1::'a) =\n  (1::'a)\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<noteq> (0::'a) \\<Longrightarrow> inverse a * a = (1::'a)\n 2. \\<And>a b. a / b = a * inverse b\n 3. inverse (0::'a) = (0::'a)", "hence \"inverse (\\<langle>1, x\\<rangle> *\\<^sub>C 1) * x = 1\" if \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a) \\<Longrightarrow>\n  inverse (\\<langle>1::'a, x\\<rangle> *\\<^sub>C (1::'a)) *\n  \\<langle>1::'a, x\\<rangle> *\\<^sub>C (1::'a) =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. inverse (\\<langle>1::'a, x\\<rangle> *\\<^sub>C (1::'a)) * x = (1::'a)", "using one_cinner_a_scaleC_one[of x, symmetric] that"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a) \\<Longrightarrow>\n  inverse (\\<langle>1::'a, x\\<rangle> *\\<^sub>C (1::'a)) *\n  \\<langle>1::'a, x\\<rangle> *\\<^sub>C (1::'a) =\n  (1::'a)\n  x = \\<langle>1::'a, x\\<rangle> *\\<^sub>C (1::'a)\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. inverse (\\<langle>1::'a, x\\<rangle> *\\<^sub>C (1::'a)) * x = (1::'a)", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a) \\<Longrightarrow>\n  inverse (\\<langle>1::'a, x\\<rangle> *\\<^sub>C (1::'a)) * x = (1::'a)\n\ngoal (3 subgoals):\n 1. \\<And>a. a \\<noteq> (0::'a) \\<Longrightarrow> inverse a * a = (1::'a)\n 2. \\<And>a b. a / b = a * inverse b\n 3. inverse (0::'a) = (0::'a)", "thus \"inverse x * x = 1\" if \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a) \\<Longrightarrow>\n  inverse (\\<langle>1::'a, x\\<rangle> *\\<^sub>C (1::'a)) * x = (1::'a)\n\ngoal (1 subgoal):\n 1. inverse x * x = (1::'a)", "by (simp add: that)"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a) \\<Longrightarrow> inverse x * x = (1::'a)\n\ngoal (2 subgoals):\n 1. \\<And>a b. a / b = a * inverse b\n 2. inverse (0::'a) = (0::'a)", "show \"x / y = x * inverse y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x / y = x * inverse y", "by (simp add: one_dim_class.divide_inverse)"], ["proof (state)\nthis:\n  x / y = x * inverse y\n\ngoal (1 subgoal):\n 1. inverse (0::'a) = (0::'a)", "show \"inverse (0::'a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (0::'a) = (0::'a)", "by (subst complex_vector.scale_zero_left[symmetric], subst one_dim_inverse, simp)"], ["proof (state)\nthis:\n  inverse (0::'a) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance one_dim \\<subseteq> complex_normed_field"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, complex_normed_field_class)", "proof intro_classes"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. norm (x * y) = norm x * norm y", "fix x y :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. norm (x * y) = norm x * norm y", "show \"norm (x * y) = norm x * norm y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (x * y) = norm x * norm y", "by (metis norm_mult one_dim_iso_times one_dim_norm)"], ["proof (state)\nthis:\n  norm (x * y) = norm x * norm y\n\ngoal:\nNo subgoals!", "qed"], ["", "instance one_dim \\<subseteq> chilbert_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, chilbert_space_class)", ".."], ["", "end"]]}