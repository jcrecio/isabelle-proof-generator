{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators/Complex_Inner_Product.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators", "problem_names": ["lemma cinner_real: \"cinner x x \\<in> \\<real>\"", "lemmas cinner_commute' [simp] = cinner_commute[symmetric]", "lemma (in complex_inner) cinner_eq_flip: \\<open>(cinner x y = cinner z w) \\<longleftrightarrow> (cinner y x = cinner w z)\\<close>", "lemma Im_cinner_x_x[simp]: \"Im \\<langle>x , x\\<rangle> = 0\"", "lemma of_complex_inner_1' [simp]:\n  \"cinner (1 :: 'a :: {complex_inner, complex_normed_algebra_1}) (of_complex x) = x\"", "lemma cinner_extensionality:\n  assumes \\<open>\\<And>\\<gamma>. \\<langle>\\<gamma>, \\<psi>\\<rangle> = \\<langle>\\<gamma>, \\<phi>\\<rangle>\\<close>\n  shows \\<open>\\<psi> = \\<phi>\\<close>", "lemma polar_identity:\n  includes notation_norm\n  shows \\<open>\\<parallel>x + y\\<parallel>^2 = \\<parallel>x\\<parallel>^2 + \\<parallel>y\\<parallel>^2 + 2*Re \\<langle>x, y\\<rangle>\\<close>\n    \\<comment> \\<open>Shown in the proof of Corollary 1.5 in @{cite conway2013course}\\<close>", "lemma polar_identity_minus:\n  includes notation_norm \n  shows \\<open>\\<parallel>x - y\\<parallel>^2 = \\<parallel>x\\<parallel>^2 + \\<parallel>y\\<parallel>^2 - 2 * Re \\<langle>x, y\\<rangle>\\<close>", "theorem pythagorean_theorem:\n  includes notation_norm\n  shows \\<open>\\<langle>x , y\\<rangle> = 0 \\<Longrightarrow> \\<parallel> x + y \\<parallel>^2 = \\<parallel> x \\<parallel>^2 + \\<parallel> y \\<parallel>^2\\<close> \n    \\<comment> \\<open>Shown in the proof of Theorem 2.2 in @{cite conway2013course}\\<close>", "lemma pythagorean_theorem_sum:\n  assumes q1: \"\\<And>a a'. a \\<in> t \\<Longrightarrow> a' \\<in> t \\<Longrightarrow> a \\<noteq> a' \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\"\n    and q2: \"finite t\"\n  shows \"(norm  (\\<Sum>a\\<in>t. f a))^2 = (\\<Sum>a\\<in>t.(norm (f a))^2)\"", "lemma Cauchy_cinner_Cauchy:\n  fixes x y :: \\<open>nat \\<Rightarrow> 'a::complex_inner\\<close>\n  assumes a1: \\<open>Cauchy x\\<close> and a2: \\<open>Cauchy y\\<close>\n  shows \\<open>Cauchy (\\<lambda> n. \\<langle> x n, y n \\<rangle>)\\<close>", "lemma cinner_sup_norm: \\<open>norm \\<psi> = (SUP \\<phi>. cmod (cinner \\<phi> \\<psi>) / norm \\<phi>)\\<close>", "lemma cinner_sup_onorm: \n  fixes A :: \\<open>'a::{real_normed_vector,not_singleton} \\<Rightarrow> 'b::complex_inner\\<close>\n  assumes \\<open>bounded_linear A\\<close>\n  shows \\<open>onorm A = (SUP (\\<psi>,\\<phi>). cmod (cinner \\<psi> (A \\<phi>)) / (norm \\<psi> * norm \\<phi>))\\<close>", "lemma orthogonal_complement_orthoI:\n  \\<open>x \\<in> orthogonal_complement M \\<Longrightarrow> y \\<in> M \\<Longrightarrow> \\<langle> x, y \\<rangle> = 0\\<close>", "lemma orthogonal_complement_orthoI':\n  \\<open>x \\<in> M \\<Longrightarrow> y \\<in> orthogonal_complement M \\<Longrightarrow> \\<langle> x, y \\<rangle> = 0\\<close>", "lemma orthogonal_complementI:\n  \\<open>(\\<And>x. x \\<in> M \\<Longrightarrow> \\<langle> y, x \\<rangle> = 0) \\<Longrightarrow> y \\<in> orthogonal_complement M\\<close>", "lemma is_orthogonal_sym: \"is_orthogonal \\<psi> \\<phi> = is_orthogonal \\<phi> \\<psi>\"", "lemma orthogonal_complement_closed_subspace[simp]: \n  \"closed_csubspace (orthogonal_complement A)\"\n  for A :: \\<open>('a::complex_inner) set\\<close>", "lemma orthogonal_complement_zero_intersection:\n  assumes \"0\\<in>M\"\n  shows \\<open>M \\<inter> (orthogonal_complement M) = {0}\\<close>", "lemma is_orthogonal_closure_cspan:\n  assumes \"\\<And>x y. x \\<in> X \\<Longrightarrow> y \\<in> Y \\<Longrightarrow> is_orthogonal x y\"\n  assumes \\<open>x \\<in> closure (cspan X)\\<close> \\<open>y \\<in> closure (cspan Y)\\<close>\n  shows \"is_orthogonal x y\"", "lemma is_ortho_set_empty[simp]: \"is_ortho_set {}\"", "lemma is_ortho_set_antimono: \\<open>A \\<subseteq> B \\<Longrightarrow> is_ortho_set B \\<Longrightarrow> is_ortho_set A\\<close>", "lemma orthogonal_complement_of_closure:\n  fixes A ::\"('a::complex_inner) set\"\n  shows \"orthogonal_complement A = orthogonal_complement (closure A)\"", "lemma is_orthogonal_closure: \n  assumes \\<open>\\<And>s. s \\<in> S \\<Longrightarrow> is_orthogonal a  s\\<close>\n  assumes \\<open>x \\<in> closure S\\<close> \n  shows \\<open>is_orthogonal a x\\<close>", "lemma is_orthogonal_cspan:\n  assumes a1: \"\\<And>s. s \\<in> S \\<Longrightarrow> is_orthogonal a s\" and a3: \"x \\<in> cspan S\"\n  shows \"\\<langle>a, x\\<rangle> = 0\"", "lemma ccspan_leq_ortho_ccspan:\n  assumes \"\\<And>s t. s\\<in>S \\<Longrightarrow> t\\<in>T \\<Longrightarrow> is_orthogonal s t\"\n  shows \"ccspan S \\<le> - (ccspan T)\"", "lemma double_orthogonal_complement_increasing[simp]:\n  shows \"M \\<subseteq> orthogonal_complement (orthogonal_complement M)\"", "lemma orthonormal_basis_of_cspan:\n  fixes S::\"'a::complex_inner set\"\n  assumes \"finite S\"\n  shows \"\\<exists>A. is_ortho_set A \\<and> (\\<forall>x\\<in>A. norm x = 1) \\<and> cspan A = cspan S \\<and> finite A\"", "lemma is_ortho_set_cindependent:\n  assumes \"is_ortho_set A\" \n  shows \"cindependent A\"", "lemma onb_expansion_finite:\n  includes notation_norm\n  fixes T::\\<open>'a::{complex_inner,cfinite_dim} set\\<close>\n  assumes a1: \\<open>cspan T = UNIV\\<close> and a3: \\<open>is_ortho_set T\\<close>\n    and a4: \\<open>\\<And>t. t\\<in>T \\<Longrightarrow> \\<parallel>t\\<parallel> = 1\\<close>\n  shows \\<open>x = (\\<Sum>t\\<in>T. \\<langle> t, x \\<rangle> *\\<^sub>C t)\\<close>", "lemma smallest_norm_exists:\n  \\<comment> \\<open>Theorem 2.5 in @{cite conway2013course} (inside the proof)\\<close>\n  includes notation_norm\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes q1: \\<open>convex M\\<close> and q2: \\<open>closed M\\<close> and q3: \\<open>M \\<noteq> {}\\<close>\n  shows  \\<open>\\<exists>k. is_arg_min (\\<lambda> x. \\<parallel>x\\<parallel>) (\\<lambda> t. t \\<in> M) k\\<close>", "lemma smallest_norm_unique:\n  \\<comment> \\<open>Theorem 2.5 in @{cite conway2013course} (inside the proof)\\<close>\n  includes notation_norm\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes q1: \\<open>convex M\\<close>\n  assumes r: \\<open>is_arg_min (\\<lambda> x. \\<parallel>x\\<parallel>) (\\<lambda> t. t \\<in> M) r\\<close>\n  assumes s: \\<open>is_arg_min (\\<lambda> x. \\<parallel>x\\<parallel>) (\\<lambda> t. t \\<in> M) s\\<close>\n  shows \\<open>r = s\\<close>", "theorem smallest_dist_exists:\n  \\<comment> \\<open>Theorem 2.5 in @{cite conway2013course}\\<close> \n  fixes M::\\<open>'a::chilbert_space set\\<close> and h \n  assumes a1: \\<open>convex M\\<close> and a2: \\<open>closed M\\<close> and a3: \\<open>M \\<noteq> {}\\<close>\n  shows  \\<open>\\<exists>k. is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) k\\<close>", "theorem smallest_dist_unique:\n  \\<comment> \\<open>Theorem 2.5 in @{cite conway2013course}\\<close> \n  fixes M::\\<open>'a::complex_inner set\\<close> and h \n  assumes a1: \\<open>convex M\\<close>\n  assumes \\<open>is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) r\\<close>\n  assumes \\<open>is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) s\\<close>\n  shows  \\<open>r = s\\<close>", "theorem smallest_dist_is_ortho:\n  fixes M::\\<open>'a::complex_inner set\\<close> and h k::'a \n  assumes b1: \\<open>closed_csubspace M\\<close>\n  shows  \\<open>(is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) k) \\<longleftrightarrow> \n          h - k \\<in> (orthogonal_complement M) \\<and> k \\<in> M\\<close>", "lemma is_projection_on_iff_orthog:\n  \\<open>closed_csubspace M \\<Longrightarrow> is_projection_on \\<pi> M \\<longleftrightarrow> (\\<forall>h. h - \\<pi> h \\<in> orthogonal_complement M \\<and> \\<pi> h \\<in> M)\\<close>", "lemma is_projection_on_exists:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \\<open>convex M\\<close> and \\<open>closed M\\<close> and \\<open>M \\<noteq> {}\\<close>\n  shows \"\\<exists>\\<pi>. is_projection_on \\<pi> M\"", "lemma is_projection_on_unique:\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes \\<open>convex M\\<close>\n  assumes \"is_projection_on \\<pi>\\<^sub>1 M\"\n  assumes \"is_projection_on \\<pi>\\<^sub>2 M\"\n  shows \"\\<pi>\\<^sub>1 = \\<pi>\\<^sub>2\"", "lemma projection_is_projection_on:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \\<open>convex M\\<close> and \\<open>closed M\\<close> and \\<open>M \\<noteq> {}\\<close>\n  shows \"is_projection_on (projection M) M\"", "lemma projection_is_projection_on'[simp]:\n  \\<comment> \\<open>Common special case of @{thm projection_is_projection_on}\\<close>\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \\<open>closed_csubspace M\\<close>\n  shows \"is_projection_on (projection M) M\"", "lemma projection_orthogonal:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \"closed_csubspace M\" and \\<open>m \\<in> M\\<close>\n  shows \\<open>is_orthogonal (h - projection M h) m\\<close>", "lemma is_projection_on_in_image:\n  assumes \"is_projection_on \\<pi> M\"\n  shows \"\\<pi> h \\<in> M\"", "lemma is_projection_on_image:\n  assumes \"is_projection_on \\<pi> M\"\n  shows \"range \\<pi> = M\"", "lemma projection_in_image[simp]:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \\<open>convex M\\<close> and \\<open>closed M\\<close> and \\<open>M \\<noteq> {}\\<close>\n  shows \\<open>projection M h \\<in> M\\<close>", "lemma projection_image[simp]:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \\<open>convex M\\<close> and \\<open>closed M\\<close> and \\<open>M \\<noteq> {}\\<close>\n  shows \\<open>range (projection M) = M\\<close>", "lemma projection_eqI':\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes \\<open>convex M\\<close>\n  assumes \\<open>is_projection_on f M\\<close>\n  shows \\<open>projection M = f\\<close>", "lemma is_projection_on_eqI:\n  fixes  M :: \\<open>'a::complex_inner set\\<close>\n  assumes a1: \\<open>closed_csubspace M\\<close> and a2: \\<open>h - x \\<in> orthogonal_complement M\\<close> and a3: \\<open>x \\<in> M\\<close> \n    and a4: \\<open>is_projection_on \\<pi> M\\<close>\n  shows \\<open>\\<pi> h = x\\<close>", "lemma projection_eqI:\n  fixes  M :: \\<open>('a::chilbert_space) set\\<close>\n  assumes  \\<open>closed_csubspace M\\<close> and \\<open>h - x \\<in> orthogonal_complement M\\<close> and \\<open>x \\<in> M\\<close>\n  shows \\<open>projection M h = x\\<close>", "lemma is_projection_on_fixes_image:\n  fixes M :: \\<open>'a::metric_space set\\<close>\n  assumes a1: \"is_projection_on \\<pi> M\" and a3: \"x \\<in> M\"\n  shows \"\\<pi> x = x\"", "lemma projection_fixes_image:\n  fixes M :: \\<open>('a::chilbert_space) set\\<close>\n  assumes a1: \"closed_csubspace M\" and a2: \"x \\<in> M\"\n  shows \"(projection M) x = x\"", "theorem is_projection_on_bounded_clinear:\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes a1: \"is_projection_on \\<pi> M\" and a2: \"closed_csubspace M\"\n  shows \"bounded_clinear \\<pi>\"", "theorem projection_bounded_clinear:\n  fixes M :: \\<open>('a::chilbert_space) set\\<close>\n  assumes a1: \"closed_csubspace M\"\n  shows \\<open>bounded_clinear (projection M)\\<close> \n    \\<comment> \\<open>Theorem 2.7 in @{cite conway2013course}\\<close>", "lemma is_projection_on_id_minus:\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes is_proj: \"is_projection_on \\<pi> M\"\n    and cc: \"closed_csubspace M\"\n  shows \"is_projection_on (id - \\<pi>) (orthogonal_complement M)\"", "lemma projection_on_orthogonal_complement[simp]:\n  fixes M :: \"'a::chilbert_space set\"\n  assumes a1: \"closed_csubspace M\"\n  shows \"projection (orthogonal_complement M) = id - projection M\"", "lemma is_projection_on_zero:\n  \"is_projection_on (\\<lambda>_. 0) {0}\"", "lemma projection_zero[simp]:\n  \"projection {0} = (\\<lambda>_. 0)\"", "lemma is_projection_on_rank1:\n  fixes t :: \\<open>'a::complex_inner\\<close>\n  shows \\<open>is_projection_on (\\<lambda>x. (\\<langle>t , x\\<rangle> / \\<langle>t , t\\<rangle>) *\\<^sub>C t) (cspan {t})\\<close>", "lemma projection_rank1:\n  fixes t x :: \\<open>'a::complex_inner\\<close>\n  shows \\<open>projection (cspan {t}) x = (\\<langle>t , x\\<rangle> / \\<langle>t , t\\<rangle>) *\\<^sub>C t\\<close>", "theorem double_orthogonal_complement_id[simp]:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes a1: \"closed_csubspace M\"\n  shows \"orthogonal_complement (orthogonal_complement M) = M\"", "lemma orthogonal_complement_antimono[simp]:\n  fixes  A B :: \\<open>('a::complex_inner) set\\<close>\n  assumes \"A \\<supseteq> B\"\n  shows \\<open>orthogonal_complement A \\<subseteq> orthogonal_complement B\\<close>", "lemma orthogonal_complement_antimono_iff[simp]:\n  fixes  A B :: \\<open>('a::chilbert_space) set\\<close>\n  assumes \\<open>closed_csubspace A\\<close> and  \\<open>closed_csubspace B\\<close>\n  shows \\<open>orthogonal_complement A \\<subseteq> orthogonal_complement B \\<longleftrightarrow> A \\<supseteq> B\\<close>", "lemma orthogonal_complement_UNIV[simp]: \n  \"orthogonal_complement UNIV = {0}\"", "lemma orthogonal_complement_zero[simp]:\n  \"orthogonal_complement {0} = UNIV\"", "lemma de_morgan_orthogonal_complement_plus:        \n  fixes A B::\"('a::complex_inner) set\"\n  assumes \\<open>0 \\<in> A\\<close> and \\<open>0 \\<in> B\\<close>\n  shows \\<open>orthogonal_complement (A +\\<^sub>M B) = (orthogonal_complement A) \\<inter> (orthogonal_complement B)\\<close>", "lemma de_morgan_orthogonal_complement_inter:\n  fixes A B::\"'a::chilbert_space set\"\n  assumes a1: \\<open>closed_csubspace A\\<close> and a2: \\<open>closed_csubspace B\\<close>\n  shows  \\<open>orthogonal_complement (A \\<inter> B) = orthogonal_complement A +\\<^sub>M orthogonal_complement B\\<close>", "lemma orthogonal_complement_kernel_functional:\n  fixes f :: \\<open>'a::complex_inner \\<Rightarrow> complex\\<close>\n  assumes \\<open>bounded_clinear f\\<close>\n  shows \\<open>\\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}\\<close>", "lemma riesz_frechet_representation_existence:\n  \\<comment> \\<open>Theorem 3.4 in @{cite conway2013course}\\<close>\n  fixes f::\\<open>'a::chilbert_space \\<Rightarrow> complex\\<close>\n  assumes a1: \\<open>bounded_clinear f\\<close>\n  shows \\<open>\\<exists>t. \\<forall>x.  f x = \\<langle>t, x\\<rangle>\\<close>", "lemma riesz_frechet_representation_unique:\n  \\<comment> \\<open>Theorem 3.4 in @{cite conway2013course}\\<close>\n  fixes f::\\<open>'a::complex_inner \\<Rightarrow> complex\\<close>\n  assumes \\<open>\\<And>x. f x = \\<langle>t, x\\<rangle>\\<close>\n  assumes \\<open>\\<And>x. f x = \\<langle>u, x\\<rangle>\\<close>\n  shows \\<open>t = u\\<close>", "lemma is_adjoint_sym:\n  \\<open>is_cadjoint F G \\<Longrightarrow> is_cadjoint G F\\<close>", "lemma cadjoint_exists:\n  fixes G :: \"'b::chilbert_space \\<Rightarrow> 'a::complex_inner\"\n  assumes [simp]: \\<open>bounded_clinear G\\<close>\n  shows \\<open>\\<exists>F. is_cadjoint F G\\<close>", "lemma cadjoint_is_cadjoint[simp]:\n  fixes G :: \"'b::chilbert_space \\<Rightarrow> 'a::complex_inner\"\n  assumes [simp]: \\<open>bounded_clinear G\\<close>\n  shows \\<open>is_cadjoint (cadjoint G) G\\<close>", "lemma is_cadjoint_unique:\n  assumes \\<open>is_cadjoint F1 G\\<close>\n  assumes \\<open>is_cadjoint F2 G\\<close>\n  shows \\<open>F1 = F2\\<close>", "lemma cadjoint_univ_prop:\n  fixes G :: \"'b::chilbert_space \\<Rightarrow> 'a::complex_inner\"\n  assumes a1: \\<open>bounded_clinear G\\<close>\n  shows \\<open>\\<forall>x. \\<forall>y. \\<langle>cadjoint G x, y\\<rangle> = \\<langle>x, G y\\<rangle>\\<close>", "lemma cadjoint_univ_prop':\n  fixes G :: \"'b::chilbert_space \\<Rightarrow> 'a::complex_inner\"\n  assumes a1: \\<open>bounded_clinear G\\<close>\n  shows \\<open>\\<forall>x. \\<forall>y. \\<langle>x, cadjoint G y\\<rangle> = \\<langle>G x, y\\<rangle>\\<close>", "lemma cadjoint_eqI:\n  fixes G:: \\<open>'b::complex_inner \\<Rightarrow> 'a::complex_inner\\<close>\n    and F:: \\<open>'a \\<Rightarrow> 'b\\<close>\n  assumes \\<open>\\<And>x y. \\<langle>F x, y\\<rangle> = \\<langle>x, G y\\<rangle>\\<close>\n  shows \\<open>G\\<^sup>\\<dagger> = F\\<close>", "lemma cadjoint_bounded_clinear:\n  fixes A :: \"'a::chilbert_space \\<Rightarrow> 'b::complex_inner\"\n  assumes a1: \"bounded_clinear A\"\n  shows \\<open>bounded_clinear (A\\<^sup>\\<dagger>)\\<close>", "lemma cadjoint_id: \\<open>(id::'a::complex_inner\\<Rightarrow>'a)\\<^sup>\\<dagger> = id\\<close>", "lemma scaleC_cadjoint:\n  fixes A::\"'a::chilbert_space \\<Rightarrow> 'b::complex_inner\"\n  assumes \"bounded_clinear A\"\n  shows \\<open>(\\<lambda>t. a *\\<^sub>C (A t))\\<^sup>\\<dagger> = (\\<lambda>s. (cnj a) *\\<^sub>C ((A\\<^sup>\\<dagger>) s))\\<close>", "lemma is_projection_on_is_cadjoint:\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes a1: \\<open>is_projection_on \\<pi> M\\<close> and a2: \\<open>closed_csubspace M\\<close>\n  shows \\<open>is_cadjoint \\<pi> \\<pi>\\<close>", "lemma is_projection_on_cadjoint:\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes \\<open>is_projection_on \\<pi> M\\<close> and \\<open>closed_csubspace M\\<close>\n  shows \\<open>\\<pi>\\<^sup>\\<dagger> = \\<pi>\\<close>", "lemma projection_cadjoint:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \\<open>closed_csubspace M\\<close>\n  shows \\<open>(projection M)\\<^sup>\\<dagger> = projection M\\<close>", "lemma is_projection_on_plus:\n  assumes \"\\<And>x y. x:A \\<Longrightarrow> y:B \\<Longrightarrow> is_orthogonal x y\"\n  assumes \\<open>closed_csubspace A\\<close>\n  assumes \\<open>closed_csubspace B\\<close>\n  assumes \\<open>is_projection_on \\<pi>A A\\<close>\n  assumes \\<open>is_projection_on \\<pi>B B\\<close>\n  shows \\<open>is_projection_on (\\<lambda>x. \\<pi>A x + \\<pi>B x) (A +\\<^sub>M B)\\<close>", "lemma projection_plus:\n  fixes A B :: \"'a::chilbert_space set\"\n  assumes \"\\<And>x y. x:A \\<Longrightarrow> y:B \\<Longrightarrow> is_orthogonal x y\"\n  assumes \\<open>closed_csubspace A\\<close>\n  assumes \\<open>closed_csubspace B\\<close>\n  shows \\<open>projection (A +\\<^sub>M B) = (\\<lambda>x. projection A x + projection B x)\\<close>", "lemma is_projection_on_insert:\n  assumes ortho: \"\\<And>s. s \\<in> S \\<Longrightarrow> \\<langle>a, s\\<rangle> = 0\"\n  assumes \\<open>is_projection_on \\<pi> (closure (cspan S))\\<close>\n  assumes \\<open>is_projection_on \\<pi>a (cspan {a})\\<close>\n  shows \"is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x) (closure (cspan (insert a S)))\"", "lemma projection_insert:\n  fixes a :: \\<open>'a::chilbert_space\\<close>\n  assumes a1: \"\\<And>s. s \\<in> S \\<Longrightarrow> \\<langle>a, s\\<rangle> = 0\"\n  shows \"projection (closure (cspan (insert a S))) u\n        = projection (cspan {a}) u + projection (closure (cspan S)) u\"", "lemma projection_insert_finite:\n  assumes a1: \"\\<And>s. s \\<in> S \\<Longrightarrow> \\<langle>a, s\\<rangle> = 0\" and a2: \"finite (S::'a::chilbert_space set)\"\n  shows \"projection (cspan (insert a S)) u\n        = projection (cspan {a}) u + projection (cspan S) u\"", "lemma cinner_canonical_basis:\n  assumes \\<open>i < length (canonical_basis :: 'a::onb_enum list)\\<close>\n  assumes \\<open>j < length (canonical_basis :: 'a::onb_enum list)\\<close>\n  shows \\<open>cinner (canonical_basis!i :: 'a) (canonical_basis!j) = (if i=j then 1 else 0)\\<close>"], "translations": [["", "lemma cinner_real: \"cinner x x \\<in> \\<real>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, x\\<rangle> \\<in> \\<real>", "by (meson cinner_ge_zero reals_zero_comparable_iff)"], ["", "lemmas cinner_commute' [simp] = cinner_commute[symmetric]"], ["", "lemma (in complex_inner) cinner_eq_flip: \\<open>(cinner x y = cinner z w) \\<longleftrightarrow> (cinner y x = cinner w z)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>x, y\\<rangle> = \\<langle>z, w\\<rangle>) =\n    (\\<langle>y, x\\<rangle> = \\<langle>w, z\\<rangle>)", "by (metis cinner_commute)"], ["", "lemma Im_cinner_x_x[simp]: \"Im \\<langle>x , x\\<rangle> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im \\<langle>x, x\\<rangle> = 0", "using comp_Im_same[OF cinner_ge_zero]"], ["proof (prove)\nusing this:\n  Im 0 = Im \\<langle>?x1, ?x1\\<rangle>\n\ngoal (1 subgoal):\n 1. Im \\<langle>x, x\\<rangle> = 0", "by simp"], ["", "lemma of_complex_inner_1' [simp]:\n  \"cinner (1 :: 'a :: {complex_inner, complex_normed_algebra_1}) (of_complex x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>1::'a, of_complex x\\<rangle> = x", "by (metis cinner_commute complex_cnj_cnj of_complex_inner_1)"], ["", "class chilbert_space =  complex_inner + complete_space\nbegin"], ["", "subclass cbanach"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.cbanach (*\\<^sub>R) (*\\<^sub>C) (+) (0::'a) (-) uminus dist norm\n     sgn uniformity open", "by standard"], ["", "end"], ["", "instantiation complex :: \"chilbert_space\" begin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(complex, chilbert_space_class)", ".."], ["", "end"], ["", "subsection \\<open>Misc facts\\<close>"], ["", "text \\<open>This is a useful rule for establishing the equality of vectors\\<close>"], ["", "lemma cinner_extensionality:\n  assumes \\<open>\\<And>\\<gamma>. \\<langle>\\<gamma>, \\<psi>\\<rangle> = \\<langle>\\<gamma>, \\<phi>\\<rangle>\\<close>\n  shows \\<open>\\<psi> = \\<phi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> = \\<phi>", "by (metis assms cinner_eq_zero_iff cinner_simps(3) right_minus_eq)"], ["", "lemma polar_identity:\n  includes notation_norm\n  shows \\<open>\\<parallel>x + y\\<parallel>^2 = \\<parallel>x\\<parallel>^2 + \\<parallel>y\\<parallel>^2 + 2*Re \\<langle>x, y\\<rangle>\\<close>\n    \\<comment> \\<open>Shown in the proof of Corollary 1.5 in @{cite conway2013course}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>x + y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 +\n    2 * Re \\<langle>x, y\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>x + y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 +\n    2 * Re \\<langle>x, y\\<rangle>", "have \\<open>\\<langle>x , y\\<rangle> + \\<langle>y , x\\<rangle> = \\<langle>x , y\\<rangle> + cnj \\<langle>x , y\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, y\\<rangle> + \\<langle>y, x\\<rangle> =\n    \\<langle>x, y\\<rangle> + cnj \\<langle>x, y\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<langle>x, y\\<rangle> + \\<langle>y, x\\<rangle> =\n  \\<langle>x, y\\<rangle> + cnj \\<langle>x, y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<parallel>x + y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 +\n    2 * Re \\<langle>x, y\\<rangle>", "hence \\<open>\\<langle>x , y\\<rangle> + \\<langle>y , x\\<rangle> = 2 * Re \\<langle>x , y\\<rangle> \\<close>"], ["proof (prove)\nusing this:\n  \\<langle>x, y\\<rangle> + \\<langle>y, x\\<rangle> =\n  \\<langle>x, y\\<rangle> + cnj \\<langle>x, y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>x, y\\<rangle> + \\<langle>y, x\\<rangle> =\n    complex_of_real (2 * Re \\<langle>x, y\\<rangle>)", "using complex_add_cnj"], ["proof (prove)\nusing this:\n  \\<langle>x, y\\<rangle> + \\<langle>y, x\\<rangle> =\n  \\<langle>x, y\\<rangle> + cnj \\<langle>x, y\\<rangle>\n  ?z + cnj ?z = complex_of_real (2 * Re ?z)\n\ngoal (1 subgoal):\n 1. \\<langle>x, y\\<rangle> + \\<langle>y, x\\<rangle> =\n    complex_of_real (2 * Re \\<langle>x, y\\<rangle>)", "by presburger"], ["proof (state)\nthis:\n  \\<langle>x, y\\<rangle> + \\<langle>y, x\\<rangle> =\n  complex_of_real (2 * Re \\<langle>x, y\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<parallel>x + y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 +\n    2 * Re \\<langle>x, y\\<rangle>", "have \\<open>\\<parallel>x + y\\<parallel>^2 = \\<langle>x+y, x+y\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (\\<parallel>x + y\\<parallel>\\<^sup>2) =\n    \\<langle>x + y, x + y\\<rangle>", "by (simp add: cdot_square_norm)"], ["proof (state)\nthis:\n  complex_of_real (\\<parallel>x + y\\<parallel>\\<^sup>2) =\n  \\<langle>x + y, x + y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<parallel>x + y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 +\n    2 * Re \\<langle>x, y\\<rangle>", "hence \\<open>\\<parallel>x + y\\<parallel>^2 = \\<langle>x , x\\<rangle> + \\<langle>x , y\\<rangle> + \\<langle>y , x\\<rangle> + \\<langle>y , y\\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  complex_of_real (\\<parallel>x + y\\<parallel>\\<^sup>2) =\n  \\<langle>x + y, x + y\\<rangle>\n\ngoal (1 subgoal):\n 1. complex_of_real (\\<parallel>x + y\\<parallel>\\<^sup>2) =\n    \\<langle>x, x\\<rangle> + \\<langle>x, y\\<rangle> +\n    \\<langle>y, x\\<rangle> +\n    \\<langle>y, y\\<rangle>", "by (simp add: cinner_add_left cinner_add_right)"], ["proof (state)\nthis:\n  complex_of_real (\\<parallel>x + y\\<parallel>\\<^sup>2) =\n  \\<langle>x, x\\<rangle> + \\<langle>x, y\\<rangle> + \\<langle>y, x\\<rangle> +\n  \\<langle>y, y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<parallel>x + y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 +\n    2 * Re \\<langle>x, y\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  complex_of_real (\\<parallel>x + y\\<parallel>\\<^sup>2) =\n  \\<langle>x, x\\<rangle> + \\<langle>x, y\\<rangle> + \\<langle>y, x\\<rangle> +\n  \\<langle>y, y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<parallel>x + y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 +\n    2 * Re \\<langle>x, y\\<rangle>", "using  \\<open>\\<langle>x , y\\<rangle> + \\<langle>y , x\\<rangle> = 2 * Re \\<langle>x , y\\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  complex_of_real (\\<parallel>x + y\\<parallel>\\<^sup>2) =\n  \\<langle>x, x\\<rangle> + \\<langle>x, y\\<rangle> + \\<langle>y, x\\<rangle> +\n  \\<langle>y, y\\<rangle>\n  \\<langle>x, y\\<rangle> + \\<langle>y, x\\<rangle> =\n  complex_of_real (2 * Re \\<langle>x, y\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<parallel>x + y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 +\n    2 * Re \\<langle>x, y\\<rangle>", "by (smt (verit, ccfv_SIG) Re_complex_of_real plus_complex.simps(1) power2_norm_eq_cinner')"], ["proof (state)\nthis:\n  \\<parallel>x + y\\<parallel>\\<^sup>2 =\n  \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 +\n  2 * Re \\<langle>x, y\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polar_identity_minus:\n  includes notation_norm \n  shows \\<open>\\<parallel>x - y\\<parallel>^2 = \\<parallel>x\\<parallel>^2 + \\<parallel>y\\<parallel>^2 - 2 * Re \\<langle>x, y\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>x - y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 -\n    2 * Re \\<langle>x, y\\<rangle>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>x - y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 -\n    2 * Re \\<langle>x, y\\<rangle>", "have \\<open>\\<parallel>x + (-y)\\<parallel>^2 = \\<parallel>x\\<parallel>^2 + \\<parallel>-y\\<parallel>^2 + 2 * Re \\<langle>x , (-y)\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>x + - y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>- y\\<parallel>\\<^sup>2 +\n    2 * Re \\<langle>x, - y\\<rangle>", "using polar_identity"], ["proof (prove)\nusing this:\n  \\<parallel>?x + ?y\\<parallel>\\<^sup>2 =\n  \\<parallel>?x\\<parallel>\\<^sup>2 + \\<parallel>?y\\<parallel>\\<^sup>2 +\n  2 * Re \\<langle>?x, ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<parallel>x + - y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>- y\\<parallel>\\<^sup>2 +\n    2 * Re \\<langle>x, - y\\<rangle>", "by blast"], ["proof (state)\nthis:\n  \\<parallel>x + - y\\<parallel>\\<^sup>2 =\n  \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>- y\\<parallel>\\<^sup>2 +\n  2 * Re \\<langle>x, - y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<parallel>x - y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 -\n    2 * Re \\<langle>x, y\\<rangle>", "hence \\<open>\\<parallel>x - y\\<parallel>^2 = \\<parallel>x\\<parallel>^2 + \\<parallel>y\\<parallel>^2 - 2*Re \\<langle>x , y\\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>x + - y\\<parallel>\\<^sup>2 =\n  \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>- y\\<parallel>\\<^sup>2 +\n  2 * Re \\<langle>x, - y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<parallel>x - y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 -\n    2 * Re \\<langle>x, y\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<parallel>x - y\\<parallel>\\<^sup>2 =\n  \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 -\n  2 * Re \\<langle>x, y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<parallel>x - y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 -\n    2 * Re \\<langle>x, y\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>x - y\\<parallel>\\<^sup>2 =\n  \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 -\n  2 * Re \\<langle>x, y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<parallel>x - y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 -\n    2 * Re \\<langle>x, y\\<rangle>", "by blast"], ["proof (state)\nthis:\n  \\<parallel>x - y\\<parallel>\\<^sup>2 =\n  \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2 -\n  2 * Re \\<langle>x, y\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition parallelogram_law:\n  includes notation_norm\n  fixes x y :: \"'a::complex_inner\"\n  shows \\<open>\\<parallel>x+y\\<parallel>^2 + \\<parallel>x-y\\<parallel>^2 = 2*( \\<parallel>x\\<parallel>^2 + \\<parallel>y\\<parallel>^2 )\\<close>\n    \\<comment> \\<open>Shown in the proof of Theorem 2.3 in @{cite conway2013course}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>x + y\\<parallel>\\<^sup>2 +\n    \\<parallel>x - y\\<parallel>\\<^sup>2 =\n    2 * (\\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2)", "by (simp add: polar_identity_minus polar_identity)"], ["", "theorem pythagorean_theorem:\n  includes notation_norm\n  shows \\<open>\\<langle>x , y\\<rangle> = 0 \\<Longrightarrow> \\<parallel> x + y \\<parallel>^2 = \\<parallel> x \\<parallel>^2 + \\<parallel> y \\<parallel>^2\\<close> \n    \\<comment> \\<open>Shown in the proof of Theorem 2.2 in @{cite conway2013course}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, y\\<rangle> = 0 \\<Longrightarrow>\n    \\<parallel>x + y\\<parallel>\\<^sup>2 =\n    \\<parallel>x\\<parallel>\\<^sup>2 + \\<parallel>y\\<parallel>\\<^sup>2", "by (simp add: polar_identity)"], ["", "lemma pythagorean_theorem_sum:\n  assumes q1: \"\\<And>a a'. a \\<in> t \\<Longrightarrow> a' \\<in> t \\<Longrightarrow> a \\<noteq> a' \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\"\n    and q2: \"finite t\"\n  shows \"(norm  (\\<Sum>a\\<in>t. f a))^2 = (\\<Sum>a\\<in>t.(norm (f a))^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (sum f t))\\<^sup>2 = (\\<Sum>a\\<in>t. (norm (f a))\\<^sup>2)", "proof (insert q1, use q2 in induction)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>a a'.\n        \\<lbrakk>a \\<in> {}; a' \\<in> {}; a \\<noteq> a'\\<rbrakk>\n        \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0) \\<Longrightarrow>\n    (norm (sum f {}))\\<^sup>2 = (\\<Sum>a\\<in>{}. (norm (f a))\\<^sup>2)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "case empty"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> {}; ?a' \\<in> {}; ?a \\<noteq> ?a'\\<rbrakk>\n  \\<Longrightarrow> \\<langle>f ?a, f ?a'\\<rangle> = 0\n\ngoal (2 subgoals):\n 1. (\\<And>a a'.\n        \\<lbrakk>a \\<in> {}; a' \\<in> {}; a \\<noteq> a'\\<rbrakk>\n        \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0) \\<Longrightarrow>\n    (norm (sum f {}))\\<^sup>2 = (\\<Sum>a\\<in>{}. (norm (f a))\\<^sup>2)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (sum f {}))\\<^sup>2 = (\\<Sum>a\\<in>{}. (norm (f a))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  (norm (sum f {}))\\<^sup>2 = (\\<Sum>a\\<in>{}. (norm (f a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  (\\<And>a a'.\n      \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n      \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0) \\<Longrightarrow>\n  (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2)\n  \\<lbrakk>?a \\<in> insert x F; ?a' \\<in> insert x F;\n   ?a \\<noteq> ?a'\\<rbrakk>\n  \\<Longrightarrow> \\<langle>f ?a, f ?a'\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "have r1: \"\\<langle>f x, f a\\<rangle> = 0\"\n    if \"a \\<in> F\"\n    for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>f x, f a\\<rangle> = 0", "using that insert.hyps(2) insert.prems"], ["proof (prove)\nusing this:\n  a \\<in> F\n  x \\<notin> F\n  \\<lbrakk>?a \\<in> insert x F; ?a' \\<in> insert x F;\n   ?a \\<noteq> ?a'\\<rbrakk>\n  \\<Longrightarrow> \\<langle>f ?a, f ?a'\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. \\<langle>f x, f a\\<rangle> = 0", "by auto"], ["proof (state)\nthis:\n  ?a \\<in> F \\<Longrightarrow> \\<langle>f x, f ?a\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "have \"sum f F = (\\<Sum>a\\<in>F. f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f F = sum f F", "by simp"], ["proof (state)\nthis:\n  sum f F = sum f F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "hence s4: \"\\<langle>f x, sum f F\\<rangle> = \\<langle>f x, (\\<Sum>a\\<in>F. f a)\\<rangle>\""], ["proof (prove)\nusing this:\n  sum f F = sum f F\n\ngoal (1 subgoal):\n 1. \\<langle>f x, sum f F\\<rangle> = \\<langle>f x, sum f F\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<langle>f x, sum f F\\<rangle> = \\<langle>f x, sum f F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  \\<langle>f x, sum f F\\<rangle> = \\<langle>f x, sum f F\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "have s3: \"\\<dots> = (\\<Sum>a\\<in>F. \\<langle>f x, f a\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>f x, sum f F\\<rangle> =\n    (\\<Sum>a\\<in>F. \\<langle>f x, f a\\<rangle>)", "using cinner_sum_right"], ["proof (prove)\nusing this:\n  \\<langle>?x, sum ?f ?A\\<rangle> =\n  (\\<Sum>y\\<in>?A. \\<langle>?x, ?f y\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<langle>f x, sum f F\\<rangle> =\n    (\\<Sum>a\\<in>F. \\<langle>f x, f a\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  \\<langle>f x, sum f F\\<rangle> =\n  (\\<Sum>a\\<in>F. \\<langle>f x, f a\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  \\<langle>f x, sum f F\\<rangle> =\n  (\\<Sum>a\\<in>F. \\<langle>f x, f a\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "have s2: \"\\<dots> = (\\<Sum>a\\<in>F. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>F. \\<langle>f x, f a\\<rangle>) = (\\<Sum>a\\<in>F. 0)", "using r1"], ["proof (prove)\nusing this:\n  ?a \\<in> F \\<Longrightarrow> \\<langle>f x, f ?a\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>F. \\<langle>f x, f a\\<rangle>) = (\\<Sum>a\\<in>F. 0)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>F. \\<langle>f x, f a\\<rangle>) = (\\<Sum>a\\<in>F. 0)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>F. \\<langle>f x, f a\\<rangle>) = (\\<Sum>a\\<in>F. 0)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "have s1: \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>F. 0) = 0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>F. 0) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "finally"], ["proof (chain)\npicking this:\n  0 = 0", "have xF_ortho: \"\\<langle>f x, sum f F\\<rangle> = 0\""], ["proof (prove)\nusing this:\n  0 = 0\n\ngoal (1 subgoal):\n 1. \\<langle>f x, sum f F\\<rangle> = 0", "using s2 s3"], ["proof (prove)\nusing this:\n  0 = 0\n  (\\<Sum>a\\<in>F. \\<langle>f x, f a\\<rangle>) = (\\<Sum>a\\<in>F. 0)\n  \\<langle>f x, sum f F\\<rangle> =\n  (\\<Sum>a\\<in>F. \\<langle>f x, f a\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<langle>f x, sum f F\\<rangle> = 0", "by auto"], ["proof (state)\nthis:\n  \\<langle>f x, sum f F\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "have \"(norm (sum f (insert x F)))\\<^sup>2 = (norm (f x + sum f F))\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (sum f (insert x F)))\\<^sup>2 = (norm (f x + sum f F))\\<^sup>2", "by (simp add: insert.hyps(1) insert.hyps(2))"], ["proof (state)\nthis:\n  (norm (sum f (insert x F)))\\<^sup>2 = (norm (f x + sum f F))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  (norm (sum f (insert x F)))\\<^sup>2 = (norm (f x + sum f F))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "have \"\\<dots> = (norm (f x))\\<^sup>2 + (norm (sum f F))\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (f x + sum f F))\\<^sup>2 =\n    (norm (f x))\\<^sup>2 + (norm (sum f F))\\<^sup>2", "using xF_ortho"], ["proof (prove)\nusing this:\n  \\<langle>f x, sum f F\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. (norm (f x + sum f F))\\<^sup>2 =\n    (norm (f x))\\<^sup>2 + (norm (sum f F))\\<^sup>2", "by (rule pythagorean_theorem)"], ["proof (state)\nthis:\n  (norm (f x + sum f F))\\<^sup>2 =\n  (norm (f x))\\<^sup>2 + (norm (sum f F))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  (norm (f x + sum f F))\\<^sup>2 =\n  (norm (f x))\\<^sup>2 + (norm (sum f F))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "have \"\\<dots> = (norm (f x))\\<^sup>2 + (\\<Sum>a\\<in>F.(norm (f a))^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (f x))\\<^sup>2 + (norm (sum f F))\\<^sup>2 =\n    (norm (f x))\\<^sup>2 + (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2)", "apply (subst insert.IH)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n       \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\n 2. (norm (f x))\\<^sup>2 + (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2) =\n    (norm (f x))\\<^sup>2 + (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2)", "using insert.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> insert x F; ?a' \\<in> insert x F;\n   ?a \\<noteq> ?a'\\<rbrakk>\n  \\<Longrightarrow> \\<langle>f ?a, f ?a'\\<rangle> = 0\n\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n       \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\n 2. (norm (f x))\\<^sup>2 + (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2) =\n    (norm (f x))\\<^sup>2 + (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  (norm (f x))\\<^sup>2 + (norm (sum f F))\\<^sup>2 =\n  (norm (f x))\\<^sup>2 + (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  (norm (f x))\\<^sup>2 + (norm (sum f F))\\<^sup>2 =\n  (norm (f x))\\<^sup>2 + (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "have \"\\<dots> = (\\<Sum>a\\<in>insert x F.(norm (f a))^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (f x))\\<^sup>2 + (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2) =\n    (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "by (simp add: insert.hyps(1) insert.hyps(2))"], ["proof (state)\nthis:\n  (norm (f x))\\<^sup>2 + (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2) =\n  (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>a a'.\n            \\<lbrakk>a \\<in> F; a' \\<in> F; a \\<noteq> a'\\<rbrakk>\n            \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> =\n                              0) \\<Longrightarrow>\n        (norm (sum f F))\\<^sup>2 = (\\<Sum>a\\<in>F. (norm (f a))\\<^sup>2);\n        \\<And>a a'.\n           \\<lbrakk>a \\<in> insert x F; a' \\<in> insert x F;\n            a \\<noteq> a'\\<rbrakk>\n           \\<Longrightarrow> \\<langle>f a, f a'\\<rangle> = 0\\<rbrakk>\n       \\<Longrightarrow> (norm (sum f (insert x F)))\\<^sup>2 =\n                         (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "finally"], ["proof (chain)\npicking this:\n  (norm (sum f (insert x F)))\\<^sup>2 =\n  (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "show ?case"], ["proof (prove)\nusing this:\n  (norm (sum f (insert x F)))\\<^sup>2 =\n  (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (norm (sum f (insert x F)))\\<^sup>2 =\n    (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  (norm (sum f (insert x F)))\\<^sup>2 =\n  (\\<Sum>a\\<in>insert x F. (norm (f a))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Cauchy_cinner_Cauchy:\n  fixes x y :: \\<open>nat \\<Rightarrow> 'a::complex_inner\\<close>\n  assumes a1: \\<open>Cauchy x\\<close> and a2: \\<open>Cauchy y\\<close>\n  shows \\<open>Cauchy (\\<lambda> n. \\<langle> x n, y n \\<rangle>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. \\<langle>x n, y n\\<rangle>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. \\<langle>x n, y n\\<rangle>)", "have \\<open>bounded (range x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded (range x)", "using a1"], ["proof (prove)\nusing this:\n  Cauchy x\n\ngoal (1 subgoal):\n 1. bounded (range x)", "by (simp add: Elementary_Metric_Spaces.cauchy_imp_bounded)"], ["proof (state)\nthis:\n  bounded (range x)\n\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. \\<langle>x n, y n\\<rangle>)", "hence b1: \\<open>\\<exists>M. \\<forall>n. norm (x n) < M\\<close>"], ["proof (prove)\nusing this:\n  bounded (range x)\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n. norm (x n) < M", "by (meson bounded_pos_less rangeI)"], ["proof (state)\nthis:\n  \\<exists>M. \\<forall>n. norm (x n) < M\n\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. \\<langle>x n, y n\\<rangle>)", "have \\<open>bounded (range y)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded (range y)", "using a2"], ["proof (prove)\nusing this:\n  Cauchy y\n\ngoal (1 subgoal):\n 1. bounded (range y)", "by (simp add: Elementary_Metric_Spaces.cauchy_imp_bounded)"], ["proof (state)\nthis:\n  bounded (range y)\n\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. \\<langle>x n, y n\\<rangle>)", "hence b2: \\<open>\\<exists> M. \\<forall> n. norm (y n) < M\\<close>"], ["proof (prove)\nusing this:\n  bounded (range y)\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n. norm (y n) < M", "by (meson bounded_pos_less rangeI)"], ["proof (state)\nthis:\n  \\<exists>M. \\<forall>n. norm (y n) < M\n\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. \\<langle>x n, y n\\<rangle>)", "have \\<open>\\<exists>M. \\<forall>n. norm (x n) < M \\<and> norm (y n) < M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n. norm (x n) < M \\<and> norm (y n) < M", "using b1 b2"], ["proof (prove)\nusing this:\n  \\<exists>M. \\<forall>n. norm (x n) < M\n  \\<exists>M. \\<forall>n. norm (y n) < M\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n. norm (x n) < M \\<and> norm (y n) < M", "by (metis dual_order.strict_trans linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  \\<exists>M. \\<forall>n. norm (x n) < M \\<and> norm (y n) < M\n\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. \\<langle>x n, y n\\<rangle>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>M. \\<forall>n. norm (x n) < M \\<and> norm (y n) < M", "obtain M where M1: \\<open>\\<And>n. norm (x n) < M\\<close> and M2: \\<open>\\<And>n. norm (y n) < M\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>M. \\<forall>n. norm (x n) < M \\<and> norm (y n) < M\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>\\<And>n. norm (x n) < M; \\<And>n. norm (y n) < M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  norm (x ?n) < M\n  norm (y ?n) < M\n\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. \\<langle>x n, y n\\<rangle>)", "have M3: \\<open>M > 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < M", "by (smt M2 norm_not_less_zero)"], ["proof (state)\nthis:\n  0 < M\n\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. \\<langle>x n, y n\\<rangle>)", "have \\<open>\\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. norm ( (\\<lambda> i. \\<langle> x i, y i \\<rangle>) n -  (\\<lambda> i. \\<langle> x i, y i \\<rangle>) m ) < e\\<close>\n    if \"e > 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n             < e", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n             < e", "have \\<open>e / (2*M) > 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e / (2 * M)", "using M3"], ["proof (prove)\nusing this:\n  0 < M\n\ngoal (1 subgoal):\n 1. 0 < e / (2 * M)", "by (simp add: that)"], ["proof (state)\nthis:\n  0 < e / (2 * M)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n             < e", "hence \\<open>\\<exists>N. \\<forall>n\\<ge>N. \\<forall>m\\<ge>N. norm (x n - x m) < e / (2*M)\\<close>"], ["proof (prove)\nusing this:\n  0 < e / (2 * M)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N. \\<forall>m\\<ge>N. norm (x n - x m) < e / (2 * M)", "using a1"], ["proof (prove)\nusing this:\n  0 < e / (2 * M)\n  Cauchy x\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N. \\<forall>m\\<ge>N. norm (x n - x m) < e / (2 * M)", "by (simp add: Cauchy_iff)"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N. \\<forall>m\\<ge>N. norm (x n - x m) < e / (2 * M)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n             < e", "then"], ["proof (chain)\npicking this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N. \\<forall>m\\<ge>N. norm (x n - x m) < e / (2 * M)", "obtain N1 where N1_def: \\<open>\\<And>n m. n\\<ge>N1 \\<Longrightarrow> m\\<ge>N1 \\<Longrightarrow> norm (x n - x m) < e / (2*M)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N. \\<forall>m\\<ge>N. norm (x n - x m) < e / (2 * M)\n\ngoal (1 subgoal):\n 1. (\\<And>N1.\n        (\\<And>n m.\n            \\<lbrakk>N1 \\<le> n; N1 \\<le> m\\<rbrakk>\n            \\<Longrightarrow> norm (x n - x m)\n                              < e / (2 * M)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>N1 \\<le> ?n; N1 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> norm (x ?n - x ?m) < e / (2 * M)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n             < e", "have x1: \\<open>\\<exists>N. \\<forall> n\\<ge>N. \\<forall> m\\<ge>N. norm (y n - y m) < e / (2*M)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N. \\<forall>m\\<ge>N. norm (y n - y m) < e / (2 * M)", "using a2 \\<open>e / (2*M) > 0\\<close>"], ["proof (prove)\nusing this:\n  Cauchy y\n  0 < e / (2 * M)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N. \\<forall>m\\<ge>N. norm (y n - y m) < e / (2 * M)", "by (simp add: Cauchy_iff)"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N. \\<forall>m\\<ge>N. norm (y n - y m) < e / (2 * M)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n             < e", "obtain N2 where N2_def: \\<open>\\<And>n m.  n\\<ge>N2 \\<Longrightarrow> m\\<ge>N2 \\<Longrightarrow> norm (y n - y m) < e / (2*M)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N2.\n        (\\<And>n m.\n            \\<lbrakk>N2 \\<le> n; N2 \\<le> m\\<rbrakk>\n            \\<Longrightarrow> norm (y n - y m)\n                              < e / (2 * M)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using x1"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N. \\<forall>m\\<ge>N. norm (y n - y m) < e / (2 * M)\n\ngoal (1 subgoal):\n 1. (\\<And>N2.\n        (\\<And>n m.\n            \\<lbrakk>N2 \\<le> n; N2 \\<le> m\\<rbrakk>\n            \\<Longrightarrow> norm (y n - y m)\n                              < e / (2 * M)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>N2 \\<le> ?n; N2 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> norm (y ?n - y ?m) < e / (2 * M)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n             < e", "define N where N_def: \\<open>N = N1 + N2\\<close>"], ["proof (state)\nthis:\n  N = N1 + N2\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n             < e", "hence \\<open>N \\<ge> N1\\<close>"], ["proof (prove)\nusing this:\n  N = N1 + N2\n\ngoal (1 subgoal):\n 1. N1 \\<le> N", "by auto"], ["proof (state)\nthis:\n  N1 \\<le> N\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n             < e", "have \\<open>N \\<ge> N2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. N2 \\<le> N", "using N_def"], ["proof (prove)\nusing this:\n  N = N1 + N2\n\ngoal (1 subgoal):\n 1. N2 \\<le> N", "by auto"], ["proof (state)\nthis:\n  N2 \\<le> N\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n             < e", "have \\<open>norm ( \\<langle> x n, y n \\<rangle> - \\<langle> x m, y m \\<rangle> ) < e\\<close>\n      if \\<open>n \\<ge> N\\<close> and \\<open>m \\<ge> N\\<close>\n      for n m"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "have \\<open>\\<langle> x n, y n \\<rangle> - \\<langle> x m, y m \\<rangle> = (\\<langle> x n, y n \\<rangle> - \\<langle> x m, y n \\<rangle>) + (\\<langle> x m, y n \\<rangle> - \\<langle> x m, y m \\<rangle>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle> =\n    \\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle> +\n    (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  \\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle> =\n  \\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle> +\n  (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "hence y1: \\<open>norm (\\<langle> x n, y n \\<rangle> - \\<langle> x m, y m \\<rangle>) \\<le> norm (\\<langle> x n, y n \\<rangle> - \\<langle> x m, y n \\<rangle>)\n           + norm (\\<langle> x m, y n \\<rangle> - \\<langle> x m, y m \\<rangle>)\\<close>"], ["proof (prove)\nusing this:\n  \\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle> =\n  \\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle> +\n  (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n    \\<le> cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) +\n          cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)", "by (metis norm_triangle_ineq)"], ["proof (state)\nthis:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n  \\<le> cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) +\n        cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "have \\<open>\\<langle> x n, y n \\<rangle> - \\<langle> x m, y n \\<rangle> = \\<langle> x n - x m, y n \\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle> =\n    \\<langle>x n - x m, y n\\<rangle>", "by (simp add: cinner_diff_left)"], ["proof (state)\nthis:\n  \\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle> =\n  \\<langle>x n - x m, y n\\<rangle>\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "hence \\<open>norm (\\<langle> x n, y n \\<rangle> - \\<langle> x m, y n \\<rangle>) = norm \\<langle> x n - x m, y n \\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  \\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle> =\n  \\<langle>x n - x m, y n\\<rangle>\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) =\n    cmod \\<langle>x n - x m, y n\\<rangle>", "by simp"], ["proof (state)\nthis:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) =\n  cmod \\<langle>x n - x m, y n\\<rangle>\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "moreover"], ["proof (state)\nthis:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) =\n  cmod \\<langle>x n - x m, y n\\<rangle>\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "have \\<open>norm \\<langle> x n - x m, y n \\<rangle> \\<le> norm (x n - x m) * norm (y n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<langle>x n - x m, y n\\<rangle>\n    \\<le> norm (x n - x m) * norm (y n)", "using complex_inner_class.Cauchy_Schwarz_ineq2"], ["proof (prove)\nusing this:\n  cmod \\<langle>?x, ?y\\<rangle> \\<le> norm ?x * norm ?y\n\ngoal (1 subgoal):\n 1. cmod \\<langle>x n - x m, y n\\<rangle>\n    \\<le> norm (x n - x m) * norm (y n)", "by blast"], ["proof (state)\nthis:\n  cmod \\<langle>x n - x m, y n\\<rangle> \\<le> norm (x n - x m) * norm (y n)\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "moreover"], ["proof (state)\nthis:\n  cmod \\<langle>x n - x m, y n\\<rangle> \\<le> norm (x n - x m) * norm (y n)\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "have \\<open>norm (y n) < M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (y n) < M", "by (simp add: M2)"], ["proof (state)\nthis:\n  norm (y n) < M\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "moreover"], ["proof (state)\nthis:\n  norm (y n) < M\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "have \\<open>norm (x n - x m) < e/(2*M)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (x n - x m) < e / (2 * M)", "using \\<open>N \\<le> m\\<close> \\<open>N \\<le> n\\<close> \\<open>N1 \\<le> N\\<close> N1_def"], ["proof (prove)\nusing this:\n  N \\<le> m\n  N \\<le> n\n  N1 \\<le> N\n  \\<lbrakk>N1 \\<le> ?n; N1 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> norm (x ?n - x ?m) < e / (2 * M)\n\ngoal (1 subgoal):\n 1. norm (x n - x m) < e / (2 * M)", "by auto"], ["proof (state)\nthis:\n  norm (x n - x m) < e / (2 * M)\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "ultimately"], ["proof (chain)\npicking this:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) =\n  cmod \\<langle>x n - x m, y n\\<rangle>\n  cmod \\<langle>x n - x m, y n\\<rangle> \\<le> norm (x n - x m) * norm (y n)\n  norm (y n) < M\n  norm (x n - x m) < e / (2 * M)", "have \\<open>norm (\\<langle> x n, y n \\<rangle> - \\<langle> x m, y n \\<rangle>) < (e/(2*M)) * M\\<close>"], ["proof (prove)\nusing this:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) =\n  cmod \\<langle>x n - x m, y n\\<rangle>\n  cmod \\<langle>x n - x m, y n\\<rangle> \\<le> norm (x n - x m) * norm (y n)\n  norm (y n) < M\n  norm (x n - x m) < e / (2 * M)\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>)\n    < e / (2 * M) * M", "by (smt linordered_semiring_strict_class.mult_strict_mono norm_ge_zero)"], ["proof (state)\nthis:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>)\n  < e / (2 * M) * M\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "moreover"], ["proof (state)\nthis:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>)\n  < e / (2 * M) * M\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "have \\<open> (e/(2*M)) * M = e/2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. e / (2 * M) * M = e / 2", "using \\<open>M > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < M\n\ngoal (1 subgoal):\n 1. e / (2 * M) * M = e / 2", "by simp"], ["proof (state)\nthis:\n  e / (2 * M) * M = e / 2\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "ultimately"], ["proof (chain)\npicking this:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>)\n  < e / (2 * M) * M\n  e / (2 * M) * M = e / 2", "have  \\<open>norm (\\<langle> x n, y n \\<rangle> - \\<langle> x m, y n \\<rangle>) < e/2\\<close>"], ["proof (prove)\nusing this:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>)\n  < e / (2 * M) * M\n  e / (2 * M) * M = e / 2\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) < e / 2", "by simp"], ["proof (state)\nthis:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) < e / 2\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "hence y2: \\<open>norm (\\<langle> x n, y n \\<rangle> - \\<langle> x m, y n \\<rangle>) < e/2\\<close>"], ["proof (prove)\nusing this:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) < e / 2\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) < e / 2", "by blast"], ["proof (state)\nthis:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) < e / 2\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "have \\<open>\\<langle> x m, y n \\<rangle> - \\<langle> x m, y m \\<rangle> = \\<langle> x m, y n - y m \\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle> =\n    \\<langle>x m, y n - y m\\<rangle>", "by (simp add: cinner_diff_right)"], ["proof (state)\nthis:\n  \\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle> =\n  \\<langle>x m, y n - y m\\<rangle>\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "hence \\<open>norm (\\<langle> x m, y n \\<rangle> - \\<langle> x m, y m \\<rangle>) = norm \\<langle> x m, y n - y m \\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  \\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle> =\n  \\<langle>x m, y n - y m\\<rangle>\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) =\n    cmod \\<langle>x m, y n - y m\\<rangle>", "by simp"], ["proof (state)\nthis:\n  cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) =\n  cmod \\<langle>x m, y n - y m\\<rangle>\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "moreover"], ["proof (state)\nthis:\n  cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) =\n  cmod \\<langle>x m, y n - y m\\<rangle>\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "have \\<open>norm \\<langle> x m, y n - y m \\<rangle> \\<le> norm (x m) * norm (y n - y m)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<langle>x m, y n - y m\\<rangle>\n    \\<le> norm (x m) * norm (y n - y m)", "by (meson complex_inner_class.Cauchy_Schwarz_ineq2)"], ["proof (state)\nthis:\n  cmod \\<langle>x m, y n - y m\\<rangle> \\<le> norm (x m) * norm (y n - y m)\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "moreover"], ["proof (state)\nthis:\n  cmod \\<langle>x m, y n - y m\\<rangle> \\<le> norm (x m) * norm (y n - y m)\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "have \\<open>norm (x m) < M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (x m) < M", "by (simp add: M1)"], ["proof (state)\nthis:\n  norm (x m) < M\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "moreover"], ["proof (state)\nthis:\n  norm (x m) < M\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "have \\<open>norm (y n - y m) < e/(2*M)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (y n - y m) < e / (2 * M)", "using \\<open>N \\<le> m\\<close> \\<open>N \\<le> n\\<close> \\<open>N2 \\<le> N\\<close> N2_def"], ["proof (prove)\nusing this:\n  N \\<le> m\n  N \\<le> n\n  N2 \\<le> N\n  \\<lbrakk>N2 \\<le> ?n; N2 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> norm (y ?n - y ?m) < e / (2 * M)\n\ngoal (1 subgoal):\n 1. norm (y n - y m) < e / (2 * M)", "by auto"], ["proof (state)\nthis:\n  norm (y n - y m) < e / (2 * M)\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "ultimately"], ["proof (chain)\npicking this:\n  cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) =\n  cmod \\<langle>x m, y n - y m\\<rangle>\n  cmod \\<langle>x m, y n - y m\\<rangle> \\<le> norm (x m) * norm (y n - y m)\n  norm (x m) < M\n  norm (y n - y m) < e / (2 * M)", "have \\<open>norm (\\<langle> x m, y n \\<rangle> - \\<langle> x m, y m \\<rangle>) < M * (e/(2*M))\\<close>"], ["proof (prove)\nusing this:\n  cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) =\n  cmod \\<langle>x m, y n - y m\\<rangle>\n  cmod \\<langle>x m, y n - y m\\<rangle> \\<le> norm (x m) * norm (y n - y m)\n  norm (x m) < M\n  norm (y n - y m) < e / (2 * M)\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n    < M * (e / (2 * M))", "by (smt linordered_semiring_strict_class.mult_strict_mono norm_ge_zero)"], ["proof (state)\nthis:\n  cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n  < M * (e / (2 * M))\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "moreover"], ["proof (state)\nthis:\n  cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n  < M * (e / (2 * M))\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "have \\<open>M * (e/(2*M)) = e/2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. M * (e / (2 * M)) = e / 2", "using \\<open>M > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < M\n\ngoal (1 subgoal):\n 1. M * (e / (2 * M)) = e / 2", "by simp"], ["proof (state)\nthis:\n  M * (e / (2 * M)) = e / 2\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "ultimately"], ["proof (chain)\npicking this:\n  cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n  < M * (e / (2 * M))\n  M * (e / (2 * M)) = e / 2", "have  \\<open>norm (\\<langle> x m, y n \\<rangle> - \\<langle> x m, y m \\<rangle>) < e/2\\<close>"], ["proof (prove)\nusing this:\n  cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n  < M * (e / (2 * M))\n  M * (e / (2 * M)) = e / 2\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e / 2", "by simp"], ["proof (state)\nthis:\n  cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e / 2\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "hence y3: \\<open>norm (\\<langle> x m, y n \\<rangle> - \\<langle> x m, y m \\<rangle>) < e/2\\<close>"], ["proof (prove)\nusing this:\n  cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e / 2\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e / 2", "by blast"], ["proof (state)\nthis:\n  cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e / 2\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "show \\<open>norm ( \\<langle> x n, y n \\<rangle> - \\<langle> x m, y m \\<rangle> ) < e\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "using y1 y2 y3"], ["proof (prove)\nusing this:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n  \\<le> cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) +\n        cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y n\\<rangle>) < e / 2\n  cmod (\\<langle>x m, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e / 2\n\ngoal (1 subgoal):\n 1. cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e", "by simp"], ["proof (state)\nthis:\n  cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> cmod\n                     (\\<langle>x ?n, y ?n\\<rangle> -\n                      \\<langle>x ?m, y ?m\\<rangle>)\n                    < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n             < e", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> cmod\n                     (\\<langle>x ?n, y ?n\\<rangle> -\n                      \\<langle>x ?m, y ?m\\<rangle>)\n                    < e\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N.\n             cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n             < e", "by blast"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n           < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n           < ?e\n\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. \\<langle>x n, y n\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           cmod (\\<langle>x n, y n\\<rangle> - \\<langle>x m, y m\\<rangle>)\n           < ?e\n\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. \\<langle>x n, y n\\<rangle>)", "by (simp add: CauchyI)"], ["proof (state)\nthis:\n  Cauchy (\\<lambda>n. \\<langle>x n, y n\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cinner_sup_norm: \\<open>norm \\<psi> = (SUP \\<phi>. cmod (cinner \\<phi> \\<psi>) / norm \\<phi>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm \\<psi> =\n    (SUP \\<phi>. cmod \\<langle>\\<phi>, \\<psi>\\<rangle> / norm \\<phi>)", "proof (rule sym, rule cSup_eq_maximum)"], ["proof (state)\ngoal (2 subgoals):\n 1. norm \\<psi>\n    \\<in> range\n           (\\<lambda>\\<phi>.\n               cmod \\<langle>\\<phi>, \\<psi>\\<rangle> / norm \\<phi>)\n 2. \\<And>x.\n       x \\<in> range\n                (\\<lambda>\\<phi>.\n                    cmod \\<langle>\\<phi>, \\<psi>\\<rangle> /\n                    norm \\<phi>) \\<Longrightarrow>\n       x \\<le> norm \\<psi>", "have \\<open>norm \\<psi> = cmod (cinner \\<psi> \\<psi>) / norm \\<psi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm \\<psi> = cmod \\<langle>\\<psi>, \\<psi>\\<rangle> / norm \\<psi>", "by (metis norm_eq_sqrt_cinner norm_ge_zero real_div_sqrt)"], ["proof (state)\nthis:\n  norm \\<psi> = cmod \\<langle>\\<psi>, \\<psi>\\<rangle> / norm \\<psi>\n\ngoal (2 subgoals):\n 1. norm \\<psi>\n    \\<in> range\n           (\\<lambda>\\<phi>.\n               cmod \\<langle>\\<phi>, \\<psi>\\<rangle> / norm \\<phi>)\n 2. \\<And>x.\n       x \\<in> range\n                (\\<lambda>\\<phi>.\n                    cmod \\<langle>\\<phi>, \\<psi>\\<rangle> /\n                    norm \\<phi>) \\<Longrightarrow>\n       x \\<le> norm \\<psi>", "then"], ["proof (chain)\npicking this:\n  norm \\<psi> = cmod \\<langle>\\<psi>, \\<psi>\\<rangle> / norm \\<psi>", "show \\<open>norm \\<psi> \\<in> range (\\<lambda>\\<phi>. cmod (cinner \\<phi> \\<psi>) / norm \\<phi>)\\<close>"], ["proof (prove)\nusing this:\n  norm \\<psi> = cmod \\<langle>\\<psi>, \\<psi>\\<rangle> / norm \\<psi>\n\ngoal (1 subgoal):\n 1. norm \\<psi>\n    \\<in> range\n           (\\<lambda>\\<phi>.\n               cmod \\<langle>\\<phi>, \\<psi>\\<rangle> / norm \\<phi>)", "by blast"], ["proof (state)\nthis:\n  norm \\<psi>\n  \\<in> range\n         (\\<lambda>\\<phi>.\n             cmod \\<langle>\\<phi>, \\<psi>\\<rangle> / norm \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range\n                (\\<lambda>\\<phi>.\n                    cmod \\<langle>\\<phi>, \\<psi>\\<rangle> /\n                    norm \\<phi>) \\<Longrightarrow>\n       x \\<le> norm \\<psi>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range\n                (\\<lambda>\\<phi>.\n                    cmod \\<langle>\\<phi>, \\<psi>\\<rangle> /\n                    norm \\<phi>) \\<Longrightarrow>\n       x \\<le> norm \\<psi>", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range\n                (\\<lambda>\\<phi>.\n                    cmod \\<langle>\\<phi>, \\<psi>\\<rangle> /\n                    norm \\<phi>) \\<Longrightarrow>\n       x \\<le> norm \\<psi>", "assume \\<open>n \\<in> range (\\<lambda>\\<phi>. cmod (cinner \\<phi> \\<psi>) / norm \\<phi>)\\<close>"], ["proof (state)\nthis:\n  n \\<in> range\n           (\\<lambda>\\<phi>.\n               cmod \\<langle>\\<phi>, \\<psi>\\<rangle> / norm \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range\n                (\\<lambda>\\<phi>.\n                    cmod \\<langle>\\<phi>, \\<psi>\\<rangle> /\n                    norm \\<phi>) \\<Longrightarrow>\n       x \\<le> norm \\<psi>", "then"], ["proof (chain)\npicking this:\n  n \\<in> range\n           (\\<lambda>\\<phi>.\n               cmod \\<langle>\\<phi>, \\<psi>\\<rangle> / norm \\<phi>)", "obtain \\<phi> where n\\<phi>: \\<open>n = cmod (cinner \\<phi> \\<psi>) / norm \\<phi>\\<close>"], ["proof (prove)\nusing this:\n  n \\<in> range\n           (\\<lambda>\\<phi>.\n               cmod \\<langle>\\<phi>, \\<psi>\\<rangle> / norm \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        n =\n        cmod \\<langle>\\<phi>, \\<psi>\\<rangle> /\n        norm \\<phi> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = cmod \\<langle>\\<phi>, \\<psi>\\<rangle> / norm \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range\n                (\\<lambda>\\<phi>.\n                    cmod \\<langle>\\<phi>, \\<psi>\\<rangle> /\n                    norm \\<phi>) \\<Longrightarrow>\n       x \\<le> norm \\<psi>", "show \\<open>n \\<le> norm \\<psi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> norm \\<psi>", "unfolding n\\<phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<langle>\\<phi>, \\<psi>\\<rangle> / norm \\<phi> \\<le> norm \\<psi>", "by (simp add: complex_inner_class.Cauchy_Schwarz_ineq2 divide_le_eq ordered_field_class.sign_simps(33))"], ["proof (state)\nthis:\n  n \\<le> norm \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cinner_sup_onorm: \n  fixes A :: \\<open>'a::{real_normed_vector,not_singleton} \\<Rightarrow> 'b::complex_inner\\<close>\n  assumes \\<open>bounded_linear A\\<close>\n  shows \\<open>onorm A = (SUP (\\<psi>,\\<phi>). cmod (cinner \\<psi> (A \\<phi>)) / (norm \\<psi> * norm \\<phi>))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm A =\n    (SUP (\\<psi>, \\<phi>).\n        cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n        (norm \\<psi> * norm \\<phi>))", "proof (unfold onorm_def, rule cSup_eq_cSup)"], ["proof (state)\ngoal (3 subgoals):\n 1. bdd_above (range (\\<lambda>x. norm (A x) / norm x))\n 2. \\<And>a.\n       a \\<in> range (\\<lambda>x. norm (A x) / norm x) \\<Longrightarrow>\n       \\<exists>b\\<in>range\n                       (\\<lambda>(\\<psi>, \\<phi>).\n                           cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                           (norm \\<psi> * norm \\<phi>)).\n          a \\<le> b\n 3. \\<And>b.\n       b \\<in> range\n                (\\<lambda>(\\<psi>, \\<phi>).\n                    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                    (norm \\<psi> * norm \\<phi>)) \\<Longrightarrow>\n       \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "show \\<open>bdd_above (range (\\<lambda>x. norm (A x) / norm x))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (range (\\<lambda>x. norm (A x) / norm x))", "by (meson assms bdd_aboveI2 le_onorm)"], ["proof (state)\nthis:\n  bdd_above (range (\\<lambda>x. norm (A x) / norm x))\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> range (\\<lambda>x. norm (A x) / norm x) \\<Longrightarrow>\n       \\<exists>b\\<in>range\n                       (\\<lambda>(\\<psi>, \\<phi>).\n                           cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                           (norm \\<psi> * norm \\<phi>)).\n          a \\<le> b\n 2. \\<And>b.\n       b \\<in> range\n                (\\<lambda>(\\<psi>, \\<phi>).\n                    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                    (norm \\<psi> * norm \\<phi>)) \\<Longrightarrow>\n       \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> range (\\<lambda>x. norm (A x) / norm x) \\<Longrightarrow>\n       \\<exists>b\\<in>range\n                       (\\<lambda>(\\<psi>, \\<phi>).\n                           cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                           (norm \\<psi> * norm \\<phi>)).\n          a \\<le> b\n 2. \\<And>b.\n       b \\<in> range\n                (\\<lambda>(\\<psi>, \\<phi>).\n                    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                    (norm \\<psi> * norm \\<phi>)) \\<Longrightarrow>\n       \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> range (\\<lambda>x. norm (A x) / norm x) \\<Longrightarrow>\n       \\<exists>b\\<in>range\n                       (\\<lambda>(\\<psi>, \\<phi>).\n                           cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                           (norm \\<psi> * norm \\<phi>)).\n          a \\<le> b\n 2. \\<And>b.\n       b \\<in> range\n                (\\<lambda>(\\<psi>, \\<phi>).\n                    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                    (norm \\<psi> * norm \\<phi>)) \\<Longrightarrow>\n       \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "assume \\<open>a \\<in> range (\\<lambda>\\<phi>. norm (A \\<phi>) / norm \\<phi>)\\<close>"], ["proof (state)\nthis:\n  a \\<in> range (\\<lambda>\\<phi>. norm (A \\<phi>) / norm \\<phi>)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> range (\\<lambda>x. norm (A x) / norm x) \\<Longrightarrow>\n       \\<exists>b\\<in>range\n                       (\\<lambda>(\\<psi>, \\<phi>).\n                           cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                           (norm \\<psi> * norm \\<phi>)).\n          a \\<le> b\n 2. \\<And>b.\n       b \\<in> range\n                (\\<lambda>(\\<psi>, \\<phi>).\n                    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                    (norm \\<psi> * norm \\<phi>)) \\<Longrightarrow>\n       \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "then"], ["proof (chain)\npicking this:\n  a \\<in> range (\\<lambda>\\<phi>. norm (A \\<phi>) / norm \\<phi>)", "obtain \\<phi> where \\<open>a = norm (A \\<phi>) / norm \\<phi>\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> range (\\<lambda>\\<phi>. norm (A \\<phi>) / norm \\<phi>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        a = norm (A \\<phi>) / norm \\<phi> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a = norm (A \\<phi>) / norm \\<phi>\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> range (\\<lambda>x. norm (A x) / norm x) \\<Longrightarrow>\n       \\<exists>b\\<in>range\n                       (\\<lambda>(\\<psi>, \\<phi>).\n                           cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                           (norm \\<psi> * norm \\<phi>)).\n          a \\<le> b\n 2. \\<And>b.\n       b \\<in> range\n                (\\<lambda>(\\<psi>, \\<phi>).\n                    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                    (norm \\<psi> * norm \\<phi>)) \\<Longrightarrow>\n       \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "then"], ["proof (chain)\npicking this:\n  a = norm (A \\<phi>) / norm \\<phi>", "have \\<open>a \\<le> cmod (cinner (A \\<phi>) (A \\<phi>)) / (norm (A \\<phi>) * norm \\<phi>)\\<close>"], ["proof (prove)\nusing this:\n  a = norm (A \\<phi>) / norm \\<phi>\n\ngoal (1 subgoal):\n 1. a \\<le> cmod \\<langle>A \\<phi>, A \\<phi>\\<rangle> /\n            (norm (A \\<phi>) * norm \\<phi>)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = norm (A \\<phi>) / norm \\<phi> \\<Longrightarrow>\n    norm (A \\<phi>) / norm \\<phi>\n    \\<le> cmod \\<langle>A \\<phi>, A \\<phi>\\<rangle> /\n          (norm (A \\<phi>) * norm \\<phi>)", "by (smt (verit) divide_divide_eq_left norm_eq_sqrt_cinner norm_imp_pos_and_ge real_div_sqrt)"], ["proof (state)\nthis:\n  a \\<le> cmod \\<langle>A \\<phi>, A \\<phi>\\<rangle> /\n          (norm (A \\<phi>) * norm \\<phi>)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> range (\\<lambda>x. norm (A x) / norm x) \\<Longrightarrow>\n       \\<exists>b\\<in>range\n                       (\\<lambda>(\\<psi>, \\<phi>).\n                           cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                           (norm \\<psi> * norm \\<phi>)).\n          a \\<le> b\n 2. \\<And>b.\n       b \\<in> range\n                (\\<lambda>(\\<psi>, \\<phi>).\n                    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                    (norm \\<psi> * norm \\<phi>)) \\<Longrightarrow>\n       \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "then"], ["proof (chain)\npicking this:\n  a \\<le> cmod \\<langle>A \\<phi>, A \\<phi>\\<rangle> /\n          (norm (A \\<phi>) * norm \\<phi>)", "show \\<open>\\<exists>b\\<in>range (\\<lambda>(\\<psi>, \\<phi>). cmod (cinner \\<psi> (A \\<phi>)) / (norm \\<psi> * norm \\<phi>)). a \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  a \\<le> cmod \\<langle>A \\<phi>, A \\<phi>\\<rangle> /\n          (norm (A \\<phi>) * norm \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<exists>b\\<in>range\n                    (\\<lambda>(\\<psi>, \\<phi>).\n                        cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                        (norm \\<psi> * norm \\<phi>)).\n       a \\<le> b", "by force"], ["proof (state)\nthis:\n  \\<exists>b\\<in>range\n                  (\\<lambda>(\\<psi>, \\<phi>).\n                      cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                      (norm \\<psi> * norm \\<phi>)).\n     a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> range\n                (\\<lambda>(\\<psi>, \\<phi>).\n                    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                    (norm \\<psi> * norm \\<phi>)) \\<Longrightarrow>\n       \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> range\n                (\\<lambda>(\\<psi>, \\<phi>).\n                    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                    (norm \\<psi> * norm \\<phi>)) \\<Longrightarrow>\n       \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> range\n                (\\<lambda>(\\<psi>, \\<phi>).\n                    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                    (norm \\<psi> * norm \\<phi>)) \\<Longrightarrow>\n       \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "assume \\<open>b \\<in> range (\\<lambda>(\\<psi>, \\<phi>). cmod (cinner \\<psi> (A \\<phi>)) / (norm \\<psi> * norm \\<phi>))\\<close>"], ["proof (state)\nthis:\n  b \\<in> range\n           (\\<lambda>(\\<psi>, \\<phi>).\n               cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n               (norm \\<psi> * norm \\<phi>))\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> range\n                (\\<lambda>(\\<psi>, \\<phi>).\n                    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                    (norm \\<psi> * norm \\<phi>)) \\<Longrightarrow>\n       \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "then"], ["proof (chain)\npicking this:\n  b \\<in> range\n           (\\<lambda>(\\<psi>, \\<phi>).\n               cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n               (norm \\<psi> * norm \\<phi>))", "obtain \\<psi> \\<phi> where b: \\<open>b = cmod (cinner \\<psi> (A \\<phi>)) / (norm \\<psi> * norm \\<phi>)\\<close>"], ["proof (prove)\nusing this:\n  b \\<in> range\n           (\\<lambda>(\\<psi>, \\<phi>).\n               cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n               (norm \\<psi> * norm \\<phi>))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi> \\<phi>.\n        b =\n        cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n        (norm \\<psi> * norm \\<phi>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b = cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> / (norm \\<psi> * norm \\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> range\n                (\\<lambda>(\\<psi>, \\<phi>).\n                    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                    (norm \\<psi> * norm \\<phi>)) \\<Longrightarrow>\n       \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "then"], ["proof (chain)\npicking this:\n  b = cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> / (norm \\<psi> * norm \\<phi>)", "have \\<open>b \\<le> norm (A \\<phi>) / norm \\<phi>\\<close>"], ["proof (prove)\nusing this:\n  b = cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> / (norm \\<psi> * norm \\<phi>)\n\ngoal (1 subgoal):\n 1. b \\<le> norm (A \\<phi>) / norm \\<phi>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. b =\n    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n    (norm \\<psi> * norm \\<phi>) \\<Longrightarrow>\n    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> / (norm \\<psi> * norm \\<phi>)\n    \\<le> norm (A \\<phi>) / norm \\<phi>", "by (smt (verit, ccfv_threshold) complex_inner_class.Cauchy_Schwarz_ineq2 division_ring_divide_zero linordered_field_class.divide_right_mono mult_cancel_left1 nonzero_mult_divide_mult_cancel_left2 norm_imp_pos_and_ge ordered_field_class.sign_simps(33) zero_le_divide_iff)"], ["proof (state)\nthis:\n  b \\<le> norm (A \\<phi>) / norm \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> range\n                (\\<lambda>(\\<psi>, \\<phi>).\n                    cmod \\<langle>\\<psi>, A \\<phi>\\<rangle> /\n                    (norm \\<psi> * norm \\<phi>)) \\<Longrightarrow>\n       \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "then"], ["proof (chain)\npicking this:\n  b \\<le> norm (A \\<phi>) / norm \\<phi>", "show \\<open>\\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a\\<close>"], ["proof (prove)\nusing this:\n  b \\<le> norm (A \\<phi>) / norm \\<phi>\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a", "by auto"], ["proof (state)\nthis:\n  \\<exists>a\\<in>range (\\<lambda>x. norm (A x) / norm x). b \\<le> a\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Orthogonality\\<close>"], ["", "definition \"orthogonal_complement S = {x| x. \\<forall>y\\<in>S. cinner x y = 0}\""], ["", "lemma orthogonal_complement_orthoI:\n  \\<open>x \\<in> orthogonal_complement M \\<Longrightarrow> y \\<in> M \\<Longrightarrow> \\<langle> x, y \\<rangle> = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> orthogonal_complement M; y \\<in> M\\<rbrakk>\n    \\<Longrightarrow> \\<langle>x, y\\<rangle> = 0", "unfolding orthogonal_complement_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> {x |x. \\<forall>y\\<in>M. \\<langle>x, y\\<rangle> = 0};\n     y \\<in> M\\<rbrakk>\n    \\<Longrightarrow> \\<langle>x, y\\<rangle> = 0", "by auto"], ["", "lemma orthogonal_complement_orthoI':\n  \\<open>x \\<in> M \\<Longrightarrow> y \\<in> orthogonal_complement M \\<Longrightarrow> \\<langle> x, y \\<rangle> = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> M; y \\<in> orthogonal_complement M\\<rbrakk>\n    \\<Longrightarrow> \\<langle>x, y\\<rangle> = 0", "by (metis cinner_commute' complex_cnj_zero orthogonal_complement_orthoI)"], ["", "lemma orthogonal_complementI:\n  \\<open>(\\<And>x. x \\<in> M \\<Longrightarrow> \\<langle> y, x \\<rangle> = 0) \\<Longrightarrow> y \\<in> orthogonal_complement M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> M \\<Longrightarrow>\n        \\<langle>y, x\\<rangle> = 0) \\<Longrightarrow>\n    y \\<in> orthogonal_complement M", "unfolding orthogonal_complement_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> M \\<Longrightarrow>\n        \\<langle>y, x\\<rangle> = 0) \\<Longrightarrow>\n    y \\<in> {x |x. \\<forall>y\\<in>M. \\<langle>x, y\\<rangle> = 0}", "by simp"], ["", "abbreviation is_orthogonal::\\<open>'a::complex_inner \\<Rightarrow> 'a \\<Rightarrow> bool\\<close>  where\n  \\<open>is_orthogonal x y \\<equiv> \\<langle> x, y \\<rangle> = 0\\<close>"], ["", "bundle orthogonal_notation begin"], ["", "notation is_orthogonal (infixl \"\\<bottom>\" 69)"], ["", "end"], ["", "bundle no_orthogonal_notation begin"], ["", "no_notation is_orthogonal (infixl \"\\<bottom>\" 69)"], ["", "end"], ["", "lemma is_orthogonal_sym: \"is_orthogonal \\<psi> \\<phi> = is_orthogonal \\<phi> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal \\<psi> \\<phi> = is_orthogonal \\<phi> \\<psi>", "by (metis cinner_commute' complex_cnj_zero)"], ["", "lemma orthogonal_complement_closed_subspace[simp]: \n  \"closed_csubspace (orthogonal_complement A)\"\n  for A :: \\<open>('a::complex_inner) set\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (orthogonal_complement A)", "proof (intro closed_csubspace.intro complex_vector.subspaceI)"], ["proof (state)\ngoal (4 subgoals):\n 1. (0::'a) \\<in> orthogonal_complement A\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> orthogonal_complement A;\n        y \\<in> orthogonal_complement A\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> orthogonal_complement A\n 3. \\<And>c x.\n       x \\<in> orthogonal_complement A \\<Longrightarrow>\n       c *\\<^sub>C x \\<in> orthogonal_complement A\n 4. closed (orthogonal_complement A)", "fix x y and c"], ["proof (state)\ngoal (4 subgoals):\n 1. (0::'a) \\<in> orthogonal_complement A\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> orthogonal_complement A;\n        y \\<in> orthogonal_complement A\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> orthogonal_complement A\n 3. \\<And>c x.\n       x \\<in> orthogonal_complement A \\<Longrightarrow>\n       c *\\<^sub>C x \\<in> orthogonal_complement A\n 4. closed (orthogonal_complement A)", "show \\<open>0 \\<in> orthogonal_complement A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> orthogonal_complement A", "by (rule orthogonal_complementI, simp)"], ["proof (state)\nthis:\n  (0::'a) \\<in> orthogonal_complement A\n\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> orthogonal_complement A;\n        y \\<in> orthogonal_complement A\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> orthogonal_complement A\n 2. \\<And>c x.\n       x \\<in> orthogonal_complement A \\<Longrightarrow>\n       c *\\<^sub>C x \\<in> orthogonal_complement A\n 3. closed (orthogonal_complement A)", "show \\<open>x + y \\<in> orthogonal_complement A\\<close>\n    if \\<open>x \\<in> orthogonal_complement A\\<close> and \\<open>y \\<in> orthogonal_complement A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<in> orthogonal_complement A", "using that"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement A\n  y \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. x + y \\<in> orthogonal_complement A", "by (auto intro!: orthogonal_complementI dest!: orthogonal_complement_orthoI\n        simp add: cinner_add_left)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> orthogonal_complement A;\n   y \\<in> orthogonal_complement A\\<rbrakk>\n  \\<Longrightarrow> x + y \\<in> orthogonal_complement A\n\ngoal (2 subgoals):\n 1. \\<And>c x.\n       x \\<in> orthogonal_complement A \\<Longrightarrow>\n       c *\\<^sub>C x \\<in> orthogonal_complement A\n 2. closed (orthogonal_complement A)", "show \\<open>c *\\<^sub>C x \\<in> orthogonal_complement A\\<close> if \\<open>x \\<in> orthogonal_complement A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> orthogonal_complement A", "using that"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> orthogonal_complement A", "by (auto intro!: orthogonal_complementI dest!: orthogonal_complement_orthoI)"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement A \\<Longrightarrow>\n  c *\\<^sub>C x \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. closed (orthogonal_complement A)", "show \"closed (orthogonal_complement A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (orthogonal_complement A)", "proof (auto simp add: closed_sequential_limits, rename_tac an a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>an a.\n       \\<lbrakk>\\<forall>n. an n \\<in> orthogonal_complement A;\n        an \\<longlonglongrightarrow> a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> orthogonal_complement A", "fix an a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>an a.\n       \\<lbrakk>\\<forall>n. an n \\<in> orthogonal_complement A;\n        an \\<longlonglongrightarrow> a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> orthogonal_complement A", "assume ortho: \\<open>\\<forall>n::nat. an n \\<in> orthogonal_complement A\\<close>"], ["proof (state)\nthis:\n  \\<forall>n. an n \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. \\<And>an a.\n       \\<lbrakk>\\<forall>n. an n \\<in> orthogonal_complement A;\n        an \\<longlonglongrightarrow> a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> orthogonal_complement A", "assume lim: \\<open>an \\<longlonglongrightarrow> a\\<close>"], ["proof (state)\nthis:\n  an \\<longlonglongrightarrow> a\n\ngoal (1 subgoal):\n 1. \\<And>an a.\n       \\<lbrakk>\\<forall>n. an n \\<in> orthogonal_complement A;\n        an \\<longlonglongrightarrow> a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> orthogonal_complement A", "have \\<open>\\<forall> y \\<in> A. \\<forall> n. \\<langle> y , an n \\<rangle> = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>A. \\<forall>n. is_orthogonal y (an n)", "using orthogonal_complement_orthoI'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> ?M; ?y \\<in> orthogonal_complement ?M\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>A. \\<forall>n. is_orthogonal y (an n)", "by (simp add: orthogonal_complement_orthoI' ortho)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>A. \\<forall>n. is_orthogonal y (an n)\n\ngoal (1 subgoal):\n 1. \\<And>an a.\n       \\<lbrakk>\\<forall>n. an n \\<in> orthogonal_complement A;\n        an \\<longlonglongrightarrow> a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> orthogonal_complement A", "moreover"], ["proof (state)\nthis:\n  \\<forall>y\\<in>A. \\<forall>n. is_orthogonal y (an n)\n\ngoal (1 subgoal):\n 1. \\<And>an a.\n       \\<lbrakk>\\<forall>n. an n \\<in> orthogonal_complement A;\n        an \\<longlonglongrightarrow> a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> orthogonal_complement A", "have \\<open>isCont (\\<lambda> x. \\<langle> y , x \\<rangle>) a\\<close> for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (cinner y) a", "using bounded_clinear_cinner_right clinear_continuous_at"], ["proof (prove)\nusing this:\n  bounded_clinear (cinner ?a)\n  bounded_clinear ?f \\<Longrightarrow> isCont ?f ?x\n\ngoal (1 subgoal):\n 1. isCont (cinner y) a", "by (simp add: clinear_continuous_at bounded_clinear_cinner_right)"], ["proof (state)\nthis:\n  isCont (cinner ?y) a\n\ngoal (1 subgoal):\n 1. \\<And>an a.\n       \\<lbrakk>\\<forall>n. an n \\<in> orthogonal_complement A;\n        an \\<longlonglongrightarrow> a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> orthogonal_complement A", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>A. \\<forall>n. is_orthogonal y (an n)\n  isCont (cinner ?y) a", "have \\<open>(\\<lambda> n. (\\<lambda> v. \\<langle> y , v \\<rangle>) (an n)) \\<longlonglongrightarrow> (\\<lambda> v. \\<langle> y , v \\<rangle>) a\\<close> for y"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>A. \\<forall>n. is_orthogonal y (an n)\n  isCont (cinner ?y) a\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>y, an n\\<rangle>)\n    \\<longlonglongrightarrow> \\<langle>y, a\\<rangle>", "using isCont_tendsto_compose"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>A. \\<forall>n. is_orthogonal y (an n)\n  isCont (cinner ?y) a\n  \\<lbrakk>isCont ?g ?l; (?f \\<longlongrightarrow> ?l) ?F\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. ?g (?f x)) \\<longlongrightarrow> ?g ?l) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>y, an n\\<rangle>)\n    \\<longlonglongrightarrow> \\<langle>y, a\\<rangle>", "by (simp add: isCont_tendsto_compose lim)"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<langle>?y, an n\\<rangle>)\n  \\<longlonglongrightarrow> \\<langle>?y, a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>an a.\n       \\<lbrakk>\\<forall>n. an n \\<in> orthogonal_complement A;\n        an \\<longlonglongrightarrow> a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> orthogonal_complement A", "hence  \\<open>\\<forall> y\\<in>A. (\\<lambda> n. \\<langle> y , an n \\<rangle>  ) \\<longlonglongrightarrow>  \\<langle> y , a \\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<langle>?y, an n\\<rangle>)\n  \\<longlonglongrightarrow> \\<langle>?y, a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>A.\n       (\\<lambda>n. \\<langle>y, an n\\<rangle>)\n       \\<longlonglongrightarrow> \\<langle>y, a\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<forall>y\\<in>A.\n     (\\<lambda>n. \\<langle>y, an n\\<rangle>)\n     \\<longlonglongrightarrow> \\<langle>y, a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>an a.\n       \\<lbrakk>\\<forall>n. an n \\<in> orthogonal_complement A;\n        an \\<longlonglongrightarrow> a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> orthogonal_complement A", "hence  \\<open>\\<forall> y\\<in>A. (\\<lambda> n. 0  ) \\<longlonglongrightarrow>  \\<langle> y , a \\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>A.\n     (\\<lambda>n. \\<langle>y, an n\\<rangle>)\n     \\<longlonglongrightarrow> \\<langle>y, a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>A.\n       (\\<lambda>n. 0) \\<longlonglongrightarrow> \\<langle>y, a\\<rangle>", "using \\<open>\\<forall> y \\<in> A. \\<forall> n. \\<langle> y , an n \\<rangle> = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>A.\n     (\\<lambda>n. \\<langle>y, an n\\<rangle>)\n     \\<longlonglongrightarrow> \\<langle>y, a\\<rangle>\n  \\<forall>y\\<in>A. \\<forall>n. is_orthogonal y (an n)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>A.\n       (\\<lambda>n. 0) \\<longlonglongrightarrow> \\<langle>y, a\\<rangle>", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>y\\<in>A.\n     (\\<lambda>n. 0) \\<longlonglongrightarrow> \\<langle>y, a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>an a.\n       \\<lbrakk>\\<forall>n. an n \\<in> orthogonal_complement A;\n        an \\<longlonglongrightarrow> a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> orthogonal_complement A", "hence  \\<open>\\<forall> y \\<in> A. \\<langle> y , a \\<rangle> = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>A.\n     (\\<lambda>n. 0) \\<longlonglongrightarrow> \\<langle>y, a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>A. is_orthogonal y a", "using limI"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>A.\n     (\\<lambda>n. 0) \\<longlonglongrightarrow> \\<langle>y, a\\<rangle>\n  ?X \\<longlonglongrightarrow> ?L \\<Longrightarrow> lim ?X = ?L\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>A. is_orthogonal y a", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>y\\<in>A. is_orthogonal y a\n\ngoal (1 subgoal):\n 1. \\<And>an a.\n       \\<lbrakk>\\<forall>n. an n \\<in> orthogonal_complement A;\n        an \\<longlonglongrightarrow> a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> orthogonal_complement A", "then"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>A. is_orthogonal y a", "show \\<open>a \\<in> orthogonal_complement A\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>A. is_orthogonal y a\n\ngoal (1 subgoal):\n 1. a \\<in> orthogonal_complement A", "by (simp add: orthogonal_complementI is_orthogonal_sym)"], ["proof (state)\nthis:\n  a \\<in> orthogonal_complement A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed (orthogonal_complement A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthogonal_complement_zero_intersection:\n  assumes \"0\\<in>M\"\n  shows \\<open>M \\<inter> (orthogonal_complement M) = {0}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<inter> orthogonal_complement M = {0::'a}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<inter> orthogonal_complement M = {0::'a}", "have \"x=0\" if \"x\\<in>M\" and \"x\\<in>orthogonal_complement M\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = (0::'a)", "from that"], ["proof (chain)\npicking this:\n  x \\<in> M\n  x \\<in> orthogonal_complement M", "have \"\\<langle> x, x \\<rangle> = 0\""], ["proof (prove)\nusing this:\n  x \\<in> M\n  x \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. is_orthogonal x x", "unfolding orthogonal_complement_def"], ["proof (prove)\nusing this:\n  x \\<in> M\n  x \\<in> {x |x. \\<forall>y\\<in>M. is_orthogonal x y}\n\ngoal (1 subgoal):\n 1. is_orthogonal x x", "by auto"], ["proof (state)\nthis:\n  is_orthogonal x x\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "thus \"x=0\""], ["proof (prove)\nusing this:\n  is_orthogonal x x\n\ngoal (1 subgoal):\n 1. x = (0::'a)", "by auto"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> M; ?x \\<in> orthogonal_complement M\\<rbrakk>\n  \\<Longrightarrow> ?x = (0::'a)\n\ngoal (1 subgoal):\n 1. M \\<inter> orthogonal_complement M = {0::'a}", "with assms"], ["proof (chain)\npicking this:\n  (0::'a) \\<in> M\n  \\<lbrakk>?x \\<in> M; ?x \\<in> orthogonal_complement M\\<rbrakk>\n  \\<Longrightarrow> ?x = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) \\<in> M\n  \\<lbrakk>?x \\<in> M; ?x \\<in> orthogonal_complement M\\<rbrakk>\n  \\<Longrightarrow> ?x = (0::'a)\n\ngoal (1 subgoal):\n 1. M \\<inter> orthogonal_complement M = {0::'a}", "unfolding orthogonal_complement_def"], ["proof (prove)\nusing this:\n  (0::'a) \\<in> M\n  \\<lbrakk>?x \\<in> M;\n   ?x \\<in> {x |x. \\<forall>y\\<in>M. is_orthogonal x y}\\<rbrakk>\n  \\<Longrightarrow> ?x = (0::'a)\n\ngoal (1 subgoal):\n 1. M \\<inter> {x |x. \\<forall>y\\<in>M. is_orthogonal x y} = {0::'a}", "by auto"], ["proof (state)\nthis:\n  M \\<inter> orthogonal_complement M = {0::'a}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_orthogonal_closure_cspan:\n  assumes \"\\<And>x y. x \\<in> X \\<Longrightarrow> y \\<in> Y \\<Longrightarrow> is_orthogonal x y\"\n  assumes \\<open>x \\<in> closure (cspan X)\\<close> \\<open>y \\<in> closure (cspan Y)\\<close>\n  shows \"is_orthogonal x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_orthogonal x y", "have *: \\<open>cinner x y = 0\\<close> if \\<open>y \\<in> Y\\<close> for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal x y", "using bounded_antilinear_cinner_left"], ["proof (prove)\nusing this:\n  bounded_antilinear (\\<lambda>a. \\<langle>a, ?b\\<rangle>)\n\ngoal (1 subgoal):\n 1. is_orthogonal x y", "apply (rule bounded_antilinear_eq_on[where G=X])"], ["proof (prove)\ngoal (3 subgoals):\n 1. bounded_antilinear (\\<lambda>a. 0)\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> is_orthogonal x y\n 3. x \\<in> closure (cspan X)", "using assms that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> X; ?y \\<in> Y\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n  x \\<in> closure (cspan X)\n  y \\<in> closure (cspan Y)\n  y \\<in> Y\n\ngoal (3 subgoals):\n 1. bounded_antilinear (\\<lambda>a. 0)\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> is_orthogonal x y\n 3. x \\<in> closure (cspan X)", "by auto"], ["proof (state)\nthis:\n  ?y \\<in> Y \\<Longrightarrow> is_orthogonal x ?y\n\ngoal (1 subgoal):\n 1. is_orthogonal x y", "show \\<open>cinner x y = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal x y", "using bounded_clinear_cinner_right"], ["proof (prove)\nusing this:\n  bounded_clinear (cinner ?a)\n\ngoal (1 subgoal):\n 1. is_orthogonal x y", "apply (rule bounded_clinear_eq_on[where G=Y])"], ["proof (prove)\ngoal (3 subgoals):\n 1. bounded_clinear (\\<lambda>a. 0)\n 2. \\<And>xa. xa \\<in> Y \\<Longrightarrow> is_orthogonal x xa\n 3. y \\<in> closure (cspan Y)", "using * assms"], ["proof (prove)\nusing this:\n  ?y \\<in> Y \\<Longrightarrow> is_orthogonal x ?y\n  \\<lbrakk>?x \\<in> X; ?y \\<in> Y\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n  x \\<in> closure (cspan X)\n  y \\<in> closure (cspan Y)\n\ngoal (3 subgoals):\n 1. bounded_clinear (\\<lambda>a. 0)\n 2. \\<And>xa. xa \\<in> Y \\<Longrightarrow> is_orthogonal x xa\n 3. y \\<in> closure (cspan Y)", "by auto"], ["proof (state)\nthis:\n  is_orthogonal x y\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation ccsubspace :: (complex_inner) \"uminus\"\nbegin"], ["", "lift_definition uminus_ccsubspace::\\<open>'a ccsubspace  \\<Rightarrow> 'a ccsubspace\\<close>\n  is \\<open>orthogonal_complement\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       closed_csubspace set \\<Longrightarrow>\n       closed_csubspace (orthogonal_complement set)", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, uminus_class)", ".."], ["", "end"], ["", "instantiation ccsubspace :: (complex_inner) minus begin"], ["", "lift_definition minus_ccsubspace :: \"'a ccsubspace \\<Rightarrow> 'a ccsubspace \\<Rightarrow> 'a ccsubspace\"\n  is \"\\<lambda>A B. A \\<inter> (orthogonal_complement B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       \\<lbrakk>closed_csubspace set1; closed_csubspace set2\\<rbrakk>\n       \\<Longrightarrow> closed_csubspace\n                          (set1 \\<inter> orthogonal_complement set2)", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, minus_class)", ".."], ["", "end"], ["", "text \\<open>Orthogonal set\\<close>"], ["", "definition is_ortho_set :: \"'a::complex_inner set \\<Rightarrow> bool\" where\n  \\<open>is_ortho_set S = ((\\<forall>x\\<in>S. \\<forall>y\\<in>S. x \\<noteq> y \\<longrightarrow> \\<langle>x, y\\<rangle> = 0) \\<and> 0 \\<notin> S)\\<close>"], ["", "lemma is_ortho_set_empty[simp]: \"is_ortho_set {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ortho_set {}", "unfolding is_ortho_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{}.\n        \\<forall>y\\<in>{}.\n           x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n    (0::'a) \\<notin> {}", "by auto"], ["", "lemma is_ortho_set_antimono: \\<open>A \\<subseteq> B \\<Longrightarrow> is_ortho_set B \\<Longrightarrow> is_ortho_set A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> B; is_ortho_set B\\<rbrakk>\n    \\<Longrightarrow> is_ortho_set A", "unfolding is_ortho_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> B;\n     (\\<forall>x\\<in>B.\n         \\<forall>y\\<in>B.\n            x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n     (0::'a) \\<notin> B\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x\\<in>A.\n                          \\<forall>y\\<in>A.\n                             x \\<noteq> y \\<longrightarrow>\n                             is_orthogonal x y) \\<and>\n                      (0::'a) \\<notin> A", "by auto"], ["", "lemma orthogonal_complement_of_closure:\n  fixes A ::\"('a::complex_inner) set\"\n  shows \"orthogonal_complement A = orthogonal_complement (closure A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement A = orthogonal_complement (closure A)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. orthogonal_complement A = orthogonal_complement (closure A)", "have s1: \\<open>\\<langle> y, x \\<rangle> = 0\\<close> \n    if a1: \"x \\<in> (orthogonal_complement A)\"\n      and a2: \\<open>y \\<in> closure A\\<close>  \n    for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal y x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_orthogonal y x", "have \\<open>\\<forall> y \\<in> A. \\<langle> y , x \\<rangle> = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>A. is_orthogonal y x", "by (simp add: a1 orthogonal_complement_orthoI')"], ["proof (state)\nthis:\n  \\<forall>y\\<in>A. is_orthogonal y x\n\ngoal (1 subgoal):\n 1. is_orthogonal y x", "then"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>A. is_orthogonal y x", "obtain yy where \\<open>\\<forall> n. yy n \\<in> A\\<close> and \\<open>yy \\<longlonglongrightarrow> y\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>A. is_orthogonal y x\n\ngoal (1 subgoal):\n 1. (\\<And>yy.\n        \\<lbrakk>\\<forall>n. yy n \\<in> A;\n         yy \\<longlonglongrightarrow> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using a2 closure_sequential"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>A. is_orthogonal y x\n  y \\<in> closure A\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n\ngoal (1 subgoal):\n 1. (\\<And>yy.\n        \\<lbrakk>\\<forall>n. yy n \\<in> A;\n         yy \\<longlonglongrightarrow> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>n. yy n \\<in> A\n  yy \\<longlonglongrightarrow> y\n\ngoal (1 subgoal):\n 1. is_orthogonal y x", "have \\<open>isCont (\\<lambda> t. \\<langle> t , x \\<rangle>) y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (\\<lambda>t. \\<langle>t, x\\<rangle>) y", "by simp"], ["proof (state)\nthis:\n  isCont (\\<lambda>t. \\<langle>t, x\\<rangle>) y\n\ngoal (1 subgoal):\n 1. is_orthogonal y x", "hence \\<open>(\\<lambda> n. \\<langle> yy n , x \\<rangle>) \\<longlonglongrightarrow>  \\<langle> y , x \\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  isCont (\\<lambda>t. \\<langle>t, x\\<rangle>) y\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>yy n, x\\<rangle>)\n    \\<longlonglongrightarrow> \\<langle>y, x\\<rangle>", "using \\<open>yy \\<longlonglongrightarrow> y\\<close> isCont_tendsto_compose"], ["proof (prove)\nusing this:\n  isCont (\\<lambda>t. \\<langle>t, x\\<rangle>) y\n  yy \\<longlonglongrightarrow> y\n  \\<lbrakk>isCont ?g ?l; (?f \\<longlongrightarrow> ?l) ?F\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. ?g (?f x)) \\<longlongrightarrow> ?g ?l) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>yy n, x\\<rangle>)\n    \\<longlonglongrightarrow> \\<langle>y, x\\<rangle>", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<langle>yy n, x\\<rangle>)\n  \\<longlonglongrightarrow> \\<langle>y, x\\<rangle>\n\ngoal (1 subgoal):\n 1. is_orthogonal y x", "hence \\<open>(\\<lambda> n. 0) \\<longlonglongrightarrow>  \\<langle> y , x \\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<langle>yy n, x\\<rangle>)\n  \\<longlonglongrightarrow> \\<langle>y, x\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 0) \\<longlonglongrightarrow> \\<langle>y, x\\<rangle>", "using \\<open>\\<forall> y \\<in> A. \\<langle> y , x \\<rangle> = 0\\<close>  \\<open>\\<forall> n. yy n \\<in> A\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<langle>yy n, x\\<rangle>)\n  \\<longlonglongrightarrow> \\<langle>y, x\\<rangle>\n  \\<forall>y\\<in>A. is_orthogonal y x\n  \\<forall>n. yy n \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 0) \\<longlonglongrightarrow> \\<langle>y, x\\<rangle>", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. 0) \\<longlonglongrightarrow> \\<langle>y, x\\<rangle>\n\ngoal (1 subgoal):\n 1. is_orthogonal y x", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. 0) \\<longlonglongrightarrow> \\<langle>y, x\\<rangle>\n\ngoal (1 subgoal):\n 1. is_orthogonal y x", "using limI"], ["proof (prove)\nusing this:\n  (\\<lambda>n. 0) \\<longlonglongrightarrow> \\<langle>y, x\\<rangle>\n  ?X \\<longlonglongrightarrow> ?L \\<Longrightarrow> lim ?X = ?L\n\ngoal (1 subgoal):\n 1. is_orthogonal y x", "by force"], ["proof (state)\nthis:\n  is_orthogonal y x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> orthogonal_complement A; ?y \\<in> closure A\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?y ?x\n\ngoal (1 subgoal):\n 1. orthogonal_complement A = orthogonal_complement (closure A)", "hence \"x \\<in> orthogonal_complement (closure A)\"\n    if a1: \"x \\<in> (orthogonal_complement A)\"\n    for x"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> orthogonal_complement A; ?y \\<in> closure A\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?y ?x\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (closure A)", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> orthogonal_complement A; ?y \\<in> closure A\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?y ?x\n  x \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (closure A)", "by (meson orthogonal_complementI is_orthogonal_sym)"], ["proof (state)\nthis:\n  ?x \\<in> orthogonal_complement A \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement (closure A)\n\ngoal (1 subgoal):\n 1. orthogonal_complement A = orthogonal_complement (closure A)", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> orthogonal_complement A \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement (closure A)\n\ngoal (1 subgoal):\n 1. orthogonal_complement A = orthogonal_complement (closure A)", "have \\<open>x \\<in> (orthogonal_complement A)\\<close> \n    if \"x \\<in> (orthogonal_complement (closure A))\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A", "using that"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement (closure A)\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A", "by (meson closure_subset orthogonal_complement_orthoI orthogonal_complementI subset_eq)"], ["proof (state)\nthis:\n  ?x \\<in> orthogonal_complement (closure A) \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. orthogonal_complement A = orthogonal_complement (closure A)", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> orthogonal_complement A \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement (closure A)\n  ?x \\<in> orthogonal_complement (closure A) \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement A", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> orthogonal_complement A \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement (closure A)\n  ?x \\<in> orthogonal_complement (closure A) \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. orthogonal_complement A = orthogonal_complement (closure A)", "by blast"], ["proof (state)\nthis:\n  orthogonal_complement A = orthogonal_complement (closure A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_orthogonal_closure: \n  assumes \\<open>\\<And>s. s \\<in> S \\<Longrightarrow> is_orthogonal a  s\\<close>\n  assumes \\<open>x \\<in> closure S\\<close> \n  shows \\<open>is_orthogonal a x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal a x", "by (metis assms(1) assms(2) orthogonal_complementI orthogonal_complement_of_closure orthogonal_complement_orthoI)"], ["", "lemma is_orthogonal_cspan:\n  assumes a1: \"\\<And>s. s \\<in> S \\<Longrightarrow> is_orthogonal a s\" and a3: \"x \\<in> cspan S\"\n  shows \"\\<langle>a, x\\<rangle> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal a x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_orthogonal a x", "have \"\\<exists>t r. finite t \\<and> t \\<subseteq> S \\<and> (\\<Sum>a\\<in>t. r a *\\<^sub>C a) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t r.\n       finite t \\<and>\n       t \\<subseteq> S \\<and> (\\<Sum>a\\<in>t. r a *\\<^sub>C a) = x", "using complex_vector.span_explicit"], ["proof (prove)\nusing this:\n  cspan ?b =\n  {\\<Sum>a\\<in>t. r a *\\<^sub>C a |t r. finite t \\<and> t \\<subseteq> ?b}\n\ngoal (1 subgoal):\n 1. \\<exists>t r.\n       finite t \\<and>\n       t \\<subseteq> S \\<and> (\\<Sum>a\\<in>t. r a *\\<^sub>C a) = x", "by (smt a3 mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<exists>t r.\n     finite t \\<and>\n     t \\<subseteq> S \\<and> (\\<Sum>a\\<in>t. r a *\\<^sub>C a) = x\n\ngoal (1 subgoal):\n 1. is_orthogonal a x", "then"], ["proof (chain)\npicking this:\n  \\<exists>t r.\n     finite t \\<and>\n     t \\<subseteq> S \\<and> (\\<Sum>a\\<in>t. r a *\\<^sub>C a) = x", "obtain t r where b1: \"finite t\" and b2: \"t \\<subseteq> S\" and b3: \"(\\<Sum>a\\<in>t. r a *\\<^sub>C a) = x\""], ["proof (prove)\nusing this:\n  \\<exists>t r.\n     finite t \\<and>\n     t \\<subseteq> S \\<and> (\\<Sum>a\\<in>t. r a *\\<^sub>C a) = x\n\ngoal (1 subgoal):\n 1. (\\<And>t r.\n        \\<lbrakk>finite t; t \\<subseteq> S;\n         (\\<Sum>a\\<in>t. r a *\\<^sub>C a) = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite t\n  t \\<subseteq> S\n  (\\<Sum>a\\<in>t. r a *\\<^sub>C a) = x\n\ngoal (1 subgoal):\n 1. is_orthogonal a x", "have x1: \"\\<langle>a, i\\<rangle> = 0\"\n    if \"i\\<in>t\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal a i", "using b2 a1 that"], ["proof (prove)\nusing this:\n  t \\<subseteq> S\n  ?s \\<in> S \\<Longrightarrow> is_orthogonal a ?s\n  i \\<in> t\n\ngoal (1 subgoal):\n 1. is_orthogonal a i", "by blast"], ["proof (state)\nthis:\n  ?i \\<in> t \\<Longrightarrow> is_orthogonal a ?i\n\ngoal (1 subgoal):\n 1. is_orthogonal a x", "have  \"\\<langle>a, x\\<rangle> = \\<langle>a, (\\<Sum>i\\<in>t. r i *\\<^sub>C i)\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>a, x\\<rangle> =\n    \\<langle>a, \\<Sum>i\\<in>t. r i *\\<^sub>C i\\<rangle>", "by (simp add: b3)"], ["proof (state)\nthis:\n  \\<langle>a, x\\<rangle> =\n  \\<langle>a, \\<Sum>i\\<in>t. r i *\\<^sub>C i\\<rangle>\n\ngoal (1 subgoal):\n 1. is_orthogonal a x", "also"], ["proof (state)\nthis:\n  \\<langle>a, x\\<rangle> =\n  \\<langle>a, \\<Sum>i\\<in>t. r i *\\<^sub>C i\\<rangle>\n\ngoal (1 subgoal):\n 1. is_orthogonal a x", "have  \"\\<dots> = (\\<Sum>i\\<in>t. r i *\\<^sub>C \\<langle>a, i\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>a, \\<Sum>i\\<in>t. r i *\\<^sub>C i\\<rangle> =\n    (\\<Sum>i\\<in>t. r i *\\<^sub>C \\<langle>a, i\\<rangle>)", "by (simp add: cinner_sum_right)"], ["proof (state)\nthis:\n  \\<langle>a, \\<Sum>i\\<in>t. r i *\\<^sub>C i\\<rangle> =\n  (\\<Sum>i\\<in>t. r i *\\<^sub>C \\<langle>a, i\\<rangle>)\n\ngoal (1 subgoal):\n 1. is_orthogonal a x", "also"], ["proof (state)\nthis:\n  \\<langle>a, \\<Sum>i\\<in>t. r i *\\<^sub>C i\\<rangle> =\n  (\\<Sum>i\\<in>t. r i *\\<^sub>C \\<langle>a, i\\<rangle>)\n\ngoal (1 subgoal):\n 1. is_orthogonal a x", "have  \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>t. r i *\\<^sub>C \\<langle>a, i\\<rangle>) = 0", "using x1"], ["proof (prove)\nusing this:\n  ?i \\<in> t \\<Longrightarrow> is_orthogonal a ?i\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>t. r i *\\<^sub>C \\<langle>a, i\\<rangle>) = 0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>t. r i *\\<^sub>C \\<langle>a, i\\<rangle>) = 0\n\ngoal (1 subgoal):\n 1. is_orthogonal a x", "finally"], ["proof (chain)\npicking this:\n  is_orthogonal a x", "show ?thesis"], ["proof (prove)\nusing this:\n  is_orthogonal a x\n\ngoal (1 subgoal):\n 1. is_orthogonal a x", "."], ["proof (state)\nthis:\n  is_orthogonal a x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccspan_leq_ortho_ccspan:\n  assumes \"\\<And>s t. s\\<in>S \\<Longrightarrow> t\\<in>T \\<Longrightarrow> is_orthogonal s t\"\n  shows \"ccspan S \\<le> - (ccspan T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan S \\<le> - ccspan T", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s \\<in> S; ?t \\<in> T\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?s ?t\n\ngoal (1 subgoal):\n 1. ccspan S \\<le> - ccspan T", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S T.\n       (\\<And>s t.\n           \\<lbrakk>s \\<in> S; t \\<in> T\\<rbrakk>\n           \\<Longrightarrow> is_orthogonal s t) \\<Longrightarrow>\n       closure (cspan S)\n       \\<subseteq> orthogonal_complement (closure (cspan T))", "by (smt (verit, ccfv_threshold) is_orthogonal_closure is_orthogonal_cspan is_orthogonal_sym orthogonal_complementI subsetI)"], ["", "lemma double_orthogonal_complement_increasing[simp]:\n  shows \"M \\<subseteq> orthogonal_complement (orthogonal_complement M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<subseteq> orthogonal_complement (orthogonal_complement M)", "proof (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> M \\<Longrightarrow>\n       x \\<in> orthogonal_complement (orthogonal_complement M)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> M \\<Longrightarrow>\n       x \\<in> orthogonal_complement (orthogonal_complement M)", "assume s1: \"x \\<in> M\""], ["proof (state)\nthis:\n  x \\<in> M\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> M \\<Longrightarrow>\n       x \\<in> orthogonal_complement (orthogonal_complement M)", "have \\<open>\\<forall> y \\<in> (orthogonal_complement M). \\<langle> x, y \\<rangle> = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>orthogonal_complement M. is_orthogonal x y", "using s1 orthogonal_complement_orthoI'"], ["proof (prove)\nusing this:\n  x \\<in> M\n  \\<lbrakk>?x \\<in> ?M; ?y \\<in> orthogonal_complement ?M\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>orthogonal_complement M. is_orthogonal x y", "by auto"], ["proof (state)\nthis:\n  \\<forall>y\\<in>orthogonal_complement M. is_orthogonal x y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> M \\<Longrightarrow>\n       x \\<in> orthogonal_complement (orthogonal_complement M)", "hence \\<open>x \\<in> orthogonal_complement (orthogonal_complement M)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>orthogonal_complement M. is_orthogonal x y\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (orthogonal_complement M)", "by (simp add: orthogonal_complement_def)"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement (orthogonal_complement M)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> M \\<Longrightarrow>\n       x \\<in> orthogonal_complement (orthogonal_complement M)", "then"], ["proof (chain)\npicking this:\n  x \\<in> orthogonal_complement (orthogonal_complement M)", "show \"x \\<in> orthogonal_complement (orthogonal_complement M)\""], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement (orthogonal_complement M)\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (orthogonal_complement M)", "by blast"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement (orthogonal_complement M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthonormal_basis_of_cspan:\n  fixes S::\"'a::complex_inner set\"\n  assumes \"finite S\"\n  shows \"\\<exists>A. is_ortho_set A \\<and> (\\<forall>x\\<in>A. norm x = 1) \\<and> cspan A = cspan S \\<and> finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan S \\<and> finite A", "proof (use assms in induction)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan {} \\<and> finite A\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>A.\n           is_ortho_set A \\<and>\n           (\\<forall>x\\<in>A. norm x = 1) \\<and>\n           cspan A = cspan F \\<and> finite A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            is_ortho_set A \\<and>\n                            (\\<forall>x\\<in>A. norm x = 1) \\<and>\n                            cspan A = cspan (insert x F) \\<and> finite A", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan {} \\<and> finite A\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>A.\n           is_ortho_set A \\<and>\n           (\\<forall>x\\<in>A. norm x = 1) \\<and>\n           cspan A = cspan F \\<and> finite A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            is_ortho_set A \\<and>\n                            (\\<forall>x\\<in>A. norm x = 1) \\<and>\n                            cspan A = cspan (insert x F) \\<and> finite A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan {} \\<and> finite A", "apply (rule exI[of _ \"{}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ortho_set {} \\<and>\n    (\\<forall>x\\<in>{}. norm x = 1) \\<and>\n    cspan {} = cspan {} \\<and> finite {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>A.\n     is_ortho_set A \\<and>\n     (\\<forall>x\\<in>A. norm x = 1) \\<and>\n     cspan A = cspan {} \\<and> finite A\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>A.\n           is_ortho_set A \\<and>\n           (\\<forall>x\\<in>A. norm x = 1) \\<and>\n           cspan A = cspan F \\<and> finite A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            is_ortho_set A \\<and>\n                            (\\<forall>x\\<in>A. norm x = 1) \\<and>\n                            cspan A = cspan (insert x F) \\<and> finite A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>A.\n           is_ortho_set A \\<and>\n           (\\<forall>x\\<in>A. norm x = 1) \\<and>\n           cspan A = cspan F \\<and> finite A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            is_ortho_set A \\<and>\n                            (\\<forall>x\\<in>A. norm x = 1) \\<and>\n                            cspan A = cspan (insert x F) \\<and> finite A", "case (insert s S)"], ["proof (state)\nthis:\n  finite S\n  s \\<notin> S\n  \\<exists>A.\n     is_ortho_set A \\<and>\n     (\\<forall>x\\<in>A. norm x = 1) \\<and> cspan A = cspan S \\<and> finite A\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>A.\n           is_ortho_set A \\<and>\n           (\\<forall>x\\<in>A. norm x = 1) \\<and>\n           cspan A = cspan F \\<and> finite A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            is_ortho_set A \\<and>\n                            (\\<forall>x\\<in>A. norm x = 1) \\<and>\n                            cspan A = cspan (insert x F) \\<and> finite A", "from insert.IH"], ["proof (chain)\npicking this:\n  \\<exists>A.\n     is_ortho_set A \\<and>\n     (\\<forall>x\\<in>A. norm x = 1) \\<and> cspan A = cspan S \\<and> finite A", "obtain A where orthoA: \"is_ortho_set A\" and normA: \"\\<And>x. x\\<in>A \\<Longrightarrow> norm x = 1\" and spanA: \"cspan A = cspan S\" and finiteA: \"finite A\""], ["proof (prove)\nusing this:\n  \\<exists>A.\n     is_ortho_set A \\<and>\n     (\\<forall>x\\<in>A. norm x = 1) \\<and> cspan A = cspan S \\<and> finite A\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>is_ortho_set A;\n         \\<And>x. x \\<in> A \\<Longrightarrow> norm x = 1; cspan A = cspan S;\n         finite A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_ortho_set A\n  ?x \\<in> A \\<Longrightarrow> norm ?x = 1\n  cspan A = cspan S\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<exists>A.\n           is_ortho_set A \\<and>\n           (\\<forall>x\\<in>A. norm x = 1) \\<and>\n           cspan A = cspan F \\<and> finite A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            is_ortho_set A \\<and>\n                            (\\<forall>x\\<in>A. norm x = 1) \\<and>\n                            cspan A = cspan (insert x F) \\<and> finite A", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "proof (cases \\<open>s \\<in> cspan S\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<in> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A\n 2. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "case True"], ["proof (state)\nthis:\n  s \\<in> cspan S\n\ngoal (2 subgoals):\n 1. s \\<in> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A\n 2. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "then"], ["proof (chain)\npicking this:\n  s \\<in> cspan S", "have \\<open>cspan (insert s S) = cspan S\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> cspan S\n\ngoal (1 subgoal):\n 1. cspan (insert s S) = cspan S", "by (simp add: complex_vector.span_redundant)"], ["proof (state)\nthis:\n  cspan (insert s S) = cspan S\n\ngoal (2 subgoals):\n 1. s \\<in> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A\n 2. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "with orthoA normA spanA finiteA"], ["proof (chain)\npicking this:\n  is_ortho_set A\n  ?x \\<in> A \\<Longrightarrow> norm ?x = 1\n  cspan A = cspan S\n  finite A\n  cspan (insert s S) = cspan S", "show ?thesis"], ["proof (prove)\nusing this:\n  is_ortho_set A\n  ?x \\<in> A \\<Longrightarrow> norm ?x = 1\n  cspan A = cspan S\n  finite A\n  cspan (insert s S) = cspan S\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "by auto"], ["proof (state)\nthis:\n  \\<exists>A.\n     is_ortho_set A \\<and>\n     (\\<forall>x\\<in>A. norm x = 1) \\<and>\n     cspan A = cspan (insert s S) \\<and> finite A\n\ngoal (1 subgoal):\n 1. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "case False"], ["proof (state)\nthis:\n  s \\<notin> cspan S\n\ngoal (1 subgoal):\n 1. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "obtain a where a_ortho: \\<open>\\<And>x. x\\<in>A \\<Longrightarrow> is_orthogonal x a\\<close> and sa_span: \\<open>s - a \\<in> cspan A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> is_orthogonal x a;\n         s - a \\<in> cspan A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (atomize_elim, use \\<open>finite A\\<close> \\<open>is_ortho_set A\\<close> in induction)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_ortho_set {} \\<Longrightarrow>\n    \\<exists>a.\n       (\\<forall>x. x \\<in> {} \\<longrightarrow> is_orthogonal x a) \\<and>\n       s - a \\<in> cspan {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_ortho_set F \\<Longrightarrow>\n        \\<exists>a.\n           (\\<forall>x.\n               x \\<in> F \\<longrightarrow> is_orthogonal x a) \\<and>\n           s - a \\<in> cspan F;\n        is_ortho_set (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<forall>xa.\n                                xa \\<in> insert x F \\<longrightarrow>\n                                is_orthogonal xa a) \\<and>\n                            s - a \\<in> cspan (insert x F)", "case empty"], ["proof (state)\nthis:\n  is_ortho_set {}\n\ngoal (2 subgoals):\n 1. is_ortho_set {} \\<Longrightarrow>\n    \\<exists>a.\n       (\\<forall>x. x \\<in> {} \\<longrightarrow> is_orthogonal x a) \\<and>\n       s - a \\<in> cspan {}\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_ortho_set F \\<Longrightarrow>\n        \\<exists>a.\n           (\\<forall>x.\n               x \\<in> F \\<longrightarrow> is_orthogonal x a) \\<and>\n           s - a \\<in> cspan F;\n        is_ortho_set (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<forall>xa.\n                                xa \\<in> insert x F \\<longrightarrow>\n                                is_orthogonal xa a) \\<and>\n                            s - a \\<in> cspan (insert x F)", "then"], ["proof (chain)\npicking this:\n  is_ortho_set {}", "show ?case"], ["proof (prove)\nusing this:\n  is_ortho_set {}\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       (\\<forall>x. x \\<in> {} \\<longrightarrow> is_orthogonal x a) \\<and>\n       s - a \\<in> cspan {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>a.\n     (\\<forall>x. x \\<in> {} \\<longrightarrow> is_orthogonal x a) \\<and>\n     s - a \\<in> cspan {}\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_ortho_set F \\<Longrightarrow>\n        \\<exists>a.\n           (\\<forall>x.\n               x \\<in> F \\<longrightarrow> is_orthogonal x a) \\<and>\n           s - a \\<in> cspan F;\n        is_ortho_set (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<forall>xa.\n                                xa \\<in> insert x F \\<longrightarrow>\n                                is_orthogonal xa a) \\<and>\n                            s - a \\<in> cspan (insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_ortho_set F \\<Longrightarrow>\n        \\<exists>a.\n           (\\<forall>x.\n               x \\<in> F \\<longrightarrow> is_orthogonal x a) \\<and>\n           s - a \\<in> cspan F;\n        is_ortho_set (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<forall>xa.\n                                xa \\<in> insert x F \\<longrightarrow>\n                                is_orthogonal xa a) \\<and>\n                            s - a \\<in> cspan (insert x F)", "case (insert x A)"], ["proof (state)\nthis:\n  finite A\n  x \\<notin> A\n  is_ortho_set A \\<Longrightarrow>\n  \\<exists>a.\n     (\\<forall>x. x \\<in> A \\<longrightarrow> is_orthogonal x a) \\<and>\n     s - a \\<in> cspan A\n  is_ortho_set (insert x A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_ortho_set F \\<Longrightarrow>\n        \\<exists>a.\n           (\\<forall>x.\n               x \\<in> F \\<longrightarrow> is_orthogonal x a) \\<and>\n           s - a \\<in> cspan F;\n        is_ortho_set (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<forall>xa.\n                                xa \\<in> insert x F \\<longrightarrow>\n                                is_orthogonal xa a) \\<and>\n                            s - a \\<in> cspan (insert x F)", "then"], ["proof (chain)\npicking this:\n  finite A\n  x \\<notin> A\n  is_ortho_set A \\<Longrightarrow>\n  \\<exists>a.\n     (\\<forall>x. x \\<in> A \\<longrightarrow> is_orthogonal x a) \\<and>\n     s - a \\<in> cspan A\n  is_ortho_set (insert x A)", "obtain a where orthoA: \\<open>\\<And>x. x \\<in> A \\<Longrightarrow> is_orthogonal x a\\<close> and sa: \\<open>s - a \\<in> cspan A\\<close>"], ["proof (prove)\nusing this:\n  finite A\n  x \\<notin> A\n  is_ortho_set A \\<Longrightarrow>\n  \\<exists>a.\n     (\\<forall>x. x \\<in> A \\<longrightarrow> is_orthogonal x a) \\<and>\n     s - a \\<in> cspan A\n  is_ortho_set (insert x A)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>\\<And>x. x \\<in> A \\<Longrightarrow> is_orthogonal x a;\n         s - a \\<in> cspan A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson is_ortho_set_antimono subset_insertI)"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> is_orthogonal ?x a\n  s - a \\<in> cspan A\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_ortho_set F \\<Longrightarrow>\n        \\<exists>a.\n           (\\<forall>x.\n               x \\<in> F \\<longrightarrow> is_orthogonal x a) \\<and>\n           s - a \\<in> cspan F;\n        is_ortho_set (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<forall>xa.\n                                xa \\<in> insert x F \\<longrightarrow>\n                                is_orthogonal xa a) \\<and>\n                            s - a \\<in> cspan (insert x F)", "define a' where \\<open>a' = a - cinner x a *\\<^sub>C inverse (cinner x x) *\\<^sub>C x\\<close>"], ["proof (state)\nthis:\n  a' =\n  a - \\<langle>x, a\\<rangle> *\\<^sub>C (x /\\<^sub>C \\<langle>x, x\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_ortho_set F \\<Longrightarrow>\n        \\<exists>a.\n           (\\<forall>x.\n               x \\<in> F \\<longrightarrow> is_orthogonal x a) \\<and>\n           s - a \\<in> cspan F;\n        is_ortho_set (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<forall>xa.\n                                xa \\<in> insert x F \\<longrightarrow>\n                                is_orthogonal xa a) \\<and>\n                            s - a \\<in> cspan (insert x F)", "have \\<open>is_orthogonal x a'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal x a'", "unfolding a'_def cinner_diff_right cinner_scaleC_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, a\\<rangle> -\n    \\<langle>x, a\\<rangle> *\n    (inverse \\<langle>x, x\\<rangle> * \\<langle>x, x\\<rangle>) =\n    0", "apply (cases \\<open>cinner x x = 0\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_orthogonal x x \\<Longrightarrow>\n    \\<langle>x, a\\<rangle> -\n    \\<langle>x, a\\<rangle> *\n    (inverse \\<langle>x, x\\<rangle> * \\<langle>x, x\\<rangle>) =\n    0\n 2. \\<langle>x, x\\<rangle> \\<noteq> 0 \\<Longrightarrow>\n    \\<langle>x, a\\<rangle> -\n    \\<langle>x, a\\<rangle> *\n    (inverse \\<langle>x, x\\<rangle> * \\<langle>x, x\\<rangle>) =\n    0", "by auto"], ["proof (state)\nthis:\n  is_orthogonal x a'\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_ortho_set F \\<Longrightarrow>\n        \\<exists>a.\n           (\\<forall>x.\n               x \\<in> F \\<longrightarrow> is_orthogonal x a) \\<and>\n           s - a \\<in> cspan F;\n        is_ortho_set (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<forall>xa.\n                                xa \\<in> insert x F \\<longrightarrow>\n                                is_orthogonal xa a) \\<and>\n                            s - a \\<in> cspan (insert x F)", "have orthoA: \\<open>is_orthogonal y a'\\<close> if \\<open>y \\<in> A\\<close> for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal y a'", "unfolding a'_def cinner_diff_right cinner_scaleC_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>y, a\\<rangle> -\n    \\<langle>x, a\\<rangle> *\n    (inverse \\<langle>x, x\\<rangle> * \\<langle>y, x\\<rangle>) =\n    0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>y, a\\<rangle> =\n    \\<langle>x, a\\<rangle> *\n    (inverse \\<langle>x, x\\<rangle> * \\<langle>y, x\\<rangle>)", "by (metis insert.prems insertCI is_ortho_set_def mult_not_zero orthoA that)"], ["proof (state)\nthis:\n  ?y \\<in> A \\<Longrightarrow> is_orthogonal ?y a'\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_ortho_set F \\<Longrightarrow>\n        \\<exists>a.\n           (\\<forall>x.\n               x \\<in> F \\<longrightarrow> is_orthogonal x a) \\<and>\n           s - a \\<in> cspan F;\n        is_ortho_set (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<forall>xa.\n                                xa \\<in> insert x F \\<longrightarrow>\n                                is_orthogonal xa a) \\<and>\n                            s - a \\<in> cspan (insert x F)", "have \\<open>s - a' \\<in> cspan (insert x A)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. s - a' \\<in> cspan (insert x A)", "unfolding a'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\n    (a -\n     \\<langle>x, a\\<rangle> *\\<^sub>C (x /\\<^sub>C \\<langle>x, x\\<rangle>))\n    \\<in> cspan (insert x A)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. s -\n    (a -\n     (\\<langle>x, a\\<rangle> * inverse \\<langle>x, x\\<rangle>) *\\<^sub>C x)\n    \\<in> cspan (insert x A)", "by (metis (no_types, lifting) complex_vector.span_breakdown_eq diff_add_cancel diff_diff_add sa)"], ["proof (state)\nthis:\n  s - a' \\<in> cspan (insert x A)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        is_ortho_set F \\<Longrightarrow>\n        \\<exists>a.\n           (\\<forall>x.\n               x \\<in> F \\<longrightarrow> is_orthogonal x a) \\<and>\n           s - a \\<in> cspan F;\n        is_ortho_set (insert x F)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (\\<forall>xa.\n                                xa \\<in> insert x F \\<longrightarrow>\n                                is_orthogonal xa a) \\<and>\n                            s - a \\<in> cspan (insert x F)", "with \\<open>is_orthogonal x a'\\<close> orthoA"], ["proof (chain)\npicking this:\n  is_orthogonal x a'\n  ?y \\<in> A \\<Longrightarrow> is_orthogonal ?y a'\n  s - a' \\<in> cspan (insert x A)", "show ?case"], ["proof (prove)\nusing this:\n  is_orthogonal x a'\n  ?y \\<in> A \\<Longrightarrow> is_orthogonal ?y a'\n  s - a' \\<in> cspan (insert x A)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       (\\<forall>xa.\n           xa \\<in> insert x A \\<longrightarrow> is_orthogonal xa a) \\<and>\n       s - a \\<in> cspan (insert x A)", "apply (rule_tac exI[of _ a'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_orthogonal x a';\n     \\<And>y. y \\<in> A \\<Longrightarrow> is_orthogonal y a';\n     s - a' \\<in> cspan (insert x A)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>xa.\n                          xa \\<in> insert x A \\<longrightarrow>\n                          is_orthogonal xa a') \\<and>\n                      s - a' \\<in> cspan (insert x A)", "by auto"], ["proof (state)\nthis:\n  \\<exists>a.\n     (\\<forall>xa.\n         xa \\<in> insert x A \\<longrightarrow> is_orthogonal xa a) \\<and>\n     s - a \\<in> cspan (insert x A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> is_orthogonal ?x a\n  s - a \\<in> cspan A\n\ngoal (1 subgoal):\n 1. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "from False sa_span"], ["proof (chain)\npicking this:\n  s \\<notin> cspan S\n  s - a \\<in> cspan A", "have \\<open>a \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  s \\<notin> cspan S\n  s - a \\<in> cspan A\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a)", "unfolding spanA"], ["proof (prove)\nusing this:\n  s \\<notin> cspan S\n  s - a \\<in> cspan S\n\ngoal (1 subgoal):\n 1. a \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "define a' where \\<open>a' = inverse (norm a) *\\<^sub>C a\\<close>"], ["proof (state)\nthis:\n  a' = complex_of_real (inverse (norm a)) *\\<^sub>C a\n\ngoal (1 subgoal):\n 1. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "with \\<open>a \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a)\n  a' = complex_of_real (inverse (norm a)) *\\<^sub>C a", "have \\<open>norm a' = 1\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  a' = complex_of_real (inverse (norm a)) *\\<^sub>C a\n\ngoal (1 subgoal):\n 1. norm a' = 1", "by (simp add: norm_inverse)"], ["proof (state)\nthis:\n  norm a' = 1\n\ngoal (1 subgoal):\n 1. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "have a: \\<open>a = norm a *\\<^sub>C a'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = complex_of_real (norm a) *\\<^sub>C a'", "by (simp add: \\<open>a \\<noteq> 0\\<close> a'_def)"], ["proof (state)\nthis:\n  a = complex_of_real (norm a) *\\<^sub>C a'\n\ngoal (1 subgoal):\n 1. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "from sa_span spanA"], ["proof (chain)\npicking this:\n  s - a \\<in> cspan A\n  cspan A = cspan S", "have a'_span: \\<open>a' \\<in> cspan (insert s S)\\<close>"], ["proof (prove)\nusing this:\n  s - a \\<in> cspan A\n  cspan A = cspan S\n\ngoal (1 subgoal):\n 1. a' \\<in> cspan (insert s S)", "unfolding a'_def"], ["proof (prove)\nusing this:\n  s - a \\<in> cspan A\n  cspan A = cspan S\n\ngoal (1 subgoal):\n 1. complex_of_real (inverse (norm a)) *\\<^sub>C a \\<in> cspan (insert s S)", "by (metis complex_vector.eq_span_insert_eq complex_vector.span_scale complex_vector.span_superset in_mono insertI1)"], ["proof (state)\nthis:\n  a' \\<in> cspan (insert s S)\n\ngoal (1 subgoal):\n 1. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "from sa_span"], ["proof (chain)\npicking this:\n  s - a \\<in> cspan A", "have s_span: \\<open>s \\<in> cspan (insert a' A)\\<close>"], ["proof (prove)\nusing this:\n  s - a \\<in> cspan A\n\ngoal (1 subgoal):\n 1. s \\<in> cspan (insert a' A)", "apply (subst (asm) a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s - complex_of_real (norm a) *\\<^sub>C a'\n    \\<in> cspan A \\<Longrightarrow>\n    s \\<in> cspan (insert a' A)", "using complex_vector.span_breakdown_eq"], ["proof (prove)\nusing this:\n  (?x \\<in> cspan (insert ?a ?S)) =\n  (\\<exists>k. ?x - k *\\<^sub>C ?a \\<in> cspan ?S)\n\ngoal (1 subgoal):\n 1. s - complex_of_real (norm a) *\\<^sub>C a'\n    \\<in> cspan A \\<Longrightarrow>\n    s \\<in> cspan (insert a' A)", "by blast"], ["proof (state)\nthis:\n  s \\<in> cspan (insert a' A)\n\ngoal (1 subgoal):\n 1. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "from \\<open>a \\<noteq> 0\\<close> a_ortho orthoA"], ["proof (chain)\npicking this:\n  a \\<noteq> (0::'a)\n  ?x \\<in> A \\<Longrightarrow> is_orthogonal ?x a\n  is_ortho_set A", "have ortho: \"is_ortho_set (insert a' A)\""], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  ?x \\<in> A \\<Longrightarrow> is_orthogonal ?x a\n  is_ortho_set A\n\ngoal (1 subgoal):\n 1. is_ortho_set (insert a' A)", "unfolding is_ortho_set_def a'_def"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  ?x \\<in> A \\<Longrightarrow> is_orthogonal ?x a\n  (\\<forall>x\\<in>A.\n      \\<forall>y\\<in>A.\n         x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n  (0::'a) \\<notin> A\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>insert (complex_of_real (inverse (norm a)) *\\<^sub>C a)\n                     A.\n        \\<forall>y\\<in>insert\n                        (complex_of_real (inverse (norm a)) *\\<^sub>C a) A.\n           x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n    (0::'a)\n    \\<notin> insert (complex_of_real (inverse (norm a)) *\\<^sub>C a) A", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>a \\<noteq> (0::'a);\n        \\<And>x. x \\<in> A \\<Longrightarrow> is_orthogonal x a; y \\<in> A;\n        \\<forall>x\\<in>A.\n           \\<forall>y\\<in>A.\n              x \\<noteq> y \\<longrightarrow> is_orthogonal x y;\n        (0::'a) \\<notin> A;\n        a /\\<^sub>C complex_of_real (norm a) \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal a y", "by (meson is_orthogonal_sym)"], ["proof (state)\nthis:\n  is_ortho_set (insert a' A)\n\ngoal (1 subgoal):\n 1. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "have span: \\<open>cspan (insert a' A) = cspan (insert s S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (insert a' A) = cspan (insert s S)", "using a'_span s_span spanA"], ["proof (prove)\nusing this:\n  a' \\<in> cspan (insert s S)\n  s \\<in> cspan (insert a' A)\n  cspan A = cspan S\n\ngoal (1 subgoal):\n 1. cspan (insert a' A) = cspan (insert s S)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>a' \\<in> cspan (insert s S); s \\<in> cspan (insert a' A);\n        cspan A = cspan S; x \\<in> cspan (insert a' A)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> cspan (insert s S)\n 2. \\<And>x.\n       \\<lbrakk>a' \\<in> cspan (insert s S); s \\<in> cspan (insert a' A);\n        cspan A = cspan S; x \\<in> cspan (insert s S)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> cspan (insert a' A)", "apply (metis (full_types) complex_vector.span_breakdown_eq complex_vector.span_redundant insert_commute s_span)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>a' \\<in> cspan (insert s S); s \\<in> cspan (insert a' A);\n        cspan A = cspan S; x \\<in> cspan (insert s S)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> cspan (insert a' A)", "by (metis (full_types) complex_vector.span_breakdown_eq complex_vector.span_redundant insert_commute s_span)"], ["proof (state)\nthis:\n  cspan (insert a' A) = cspan (insert s S)\n\ngoal (1 subgoal):\n 1. s \\<notin> cspan S \\<Longrightarrow>\n    \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A.\n       is_ortho_set A \\<and>\n       (\\<forall>x\\<in>A. norm x = 1) \\<and>\n       cspan A = cspan (insert s S) \\<and> finite A", "apply (rule exI[of _ \\<open>insert a' A\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ortho_set (insert a' A) \\<and>\n    (\\<forall>x\\<in>insert a' A. norm x = 1) \\<and>\n    cspan (insert a' A) = cspan (insert s S) \\<and> finite (insert a' A)", "by (simp add: ortho \\<open>norm a' = 1\\<close> normA finiteA span)"], ["proof (state)\nthis:\n  \\<exists>A.\n     is_ortho_set A \\<and>\n     (\\<forall>x\\<in>A. norm x = 1) \\<and>\n     cspan A = cspan (insert s S) \\<and> finite A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A.\n     is_ortho_set A \\<and>\n     (\\<forall>x\\<in>A. norm x = 1) \\<and>\n     cspan A = cspan (insert s S) \\<and> finite A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_ortho_set_cindependent:\n  assumes \"is_ortho_set A\" \n  shows \"cindependent A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindependent A", "have \"u v = 0\"\n    if b1: \"finite t\" and b2: \"t \\<subseteq> A\" and b3: \"(\\<Sum>v\\<in>t. u v *\\<^sub>C v) = 0\" and b4: \"v \\<in> t\"\n    for t u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. u v = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u v = 0", "have \"\\<langle>v, v'\\<rangle> = 0\" if c1: \"v'\\<in>t-{v}\" for v'"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal v v'", "by (metis DiffE assms b2 b4 insertI1 is_ortho_set_antimono is_ortho_set_def that)"], ["proof (state)\nthis:\n  ?v' \\<in> t - {v} \\<Longrightarrow> is_orthogonal v ?v'\n\ngoal (1 subgoal):\n 1. u v = 0", "hence sum0: \"(\\<Sum>v'\\<in>t-{v}. u v' * \\<langle>v, v'\\<rangle>) = 0\""], ["proof (prove)\nusing this:\n  ?v' \\<in> t - {v} \\<Longrightarrow> is_orthogonal v ?v'\n\ngoal (1 subgoal):\n 1. (\\<Sum>v'\\<in>t - {v}. u v' * \\<langle>v, v'\\<rangle>) = 0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>v'\\<in>t - {v}. u v' * \\<langle>v, v'\\<rangle>) = 0\n\ngoal (1 subgoal):\n 1. u v = 0", "have \"\\<langle>v, (\\<Sum>v'\\<in>t. u v' *\\<^sub>C v')\\<rangle> = (\\<Sum>v'\\<in>t. u v' * \\<langle>v, v'\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>v, \\<Sum>v'\\<in>t. u v' *\\<^sub>C v'\\<rangle> =\n    (\\<Sum>v'\\<in>t. u v' * \\<langle>v, v'\\<rangle>)", "using b1"], ["proof (prove)\nusing this:\n  finite t\n\ngoal (1 subgoal):\n 1. \\<langle>v, \\<Sum>v'\\<in>t. u v' *\\<^sub>C v'\\<rangle> =\n    (\\<Sum>v'\\<in>t. u v' * \\<langle>v, v'\\<rangle>)", "by (metis (mono_tags, lifting) cinner_scaleC_right cinner_sum_right sum.cong)"], ["proof (state)\nthis:\n  \\<langle>v, \\<Sum>v'\\<in>t. u v' *\\<^sub>C v'\\<rangle> =\n  (\\<Sum>v'\\<in>t. u v' * \\<langle>v, v'\\<rangle>)\n\ngoal (1 subgoal):\n 1. u v = 0", "also"], ["proof (state)\nthis:\n  \\<langle>v, \\<Sum>v'\\<in>t. u v' *\\<^sub>C v'\\<rangle> =\n  (\\<Sum>v'\\<in>t. u v' * \\<langle>v, v'\\<rangle>)\n\ngoal (1 subgoal):\n 1. u v = 0", "have \"\\<dots> = u v * \\<langle>v, v\\<rangle> + (\\<Sum>v'\\<in>t-{v}. u v' * \\<langle>v, v'\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v'\\<in>t. u v' * \\<langle>v, v'\\<rangle>) =\n    u v * \\<langle>v, v\\<rangle> +\n    (\\<Sum>v'\\<in>t - {v}. u v' * \\<langle>v, v'\\<rangle>)", "by (meson b1 b4 sum.remove)"], ["proof (state)\nthis:\n  (\\<Sum>v'\\<in>t. u v' * \\<langle>v, v'\\<rangle>) =\n  u v * \\<langle>v, v\\<rangle> +\n  (\\<Sum>v'\\<in>t - {v}. u v' * \\<langle>v, v'\\<rangle>)\n\ngoal (1 subgoal):\n 1. u v = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>v'\\<in>t. u v' * \\<langle>v, v'\\<rangle>) =\n  u v * \\<langle>v, v\\<rangle> +\n  (\\<Sum>v'\\<in>t - {v}. u v' * \\<langle>v, v'\\<rangle>)\n\ngoal (1 subgoal):\n 1. u v = 0", "have \"\\<dots> = u v * \\<langle>v, v\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u v * \\<langle>v, v\\<rangle> +\n    (\\<Sum>v'\\<in>t - {v}. u v' * \\<langle>v, v'\\<rangle>) =\n    u v * \\<langle>v, v\\<rangle>", "using sum0"], ["proof (prove)\nusing this:\n  (\\<Sum>v'\\<in>t - {v}. u v' * \\<langle>v, v'\\<rangle>) = 0\n\ngoal (1 subgoal):\n 1. u v * \\<langle>v, v\\<rangle> +\n    (\\<Sum>v'\\<in>t - {v}. u v' * \\<langle>v, v'\\<rangle>) =\n    u v * \\<langle>v, v\\<rangle>", "by simp"], ["proof (state)\nthis:\n  u v * \\<langle>v, v\\<rangle> +\n  (\\<Sum>v'\\<in>t - {v}. u v' * \\<langle>v, v'\\<rangle>) =\n  u v * \\<langle>v, v\\<rangle>\n\ngoal (1 subgoal):\n 1. u v = 0", "finally"], ["proof (chain)\npicking this:\n  \\<langle>v, \\<Sum>v'\\<in>t. u v' *\\<^sub>C v'\\<rangle> =\n  u v * \\<langle>v, v\\<rangle>", "have \"\\<langle>v, (\\<Sum>v'\\<in>t. u v' *\\<^sub>C v')\\<rangle> =  u v * \\<langle>v, v\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>v, \\<Sum>v'\\<in>t. u v' *\\<^sub>C v'\\<rangle> =\n  u v * \\<langle>v, v\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>v, \\<Sum>v'\\<in>t. u v' *\\<^sub>C v'\\<rangle> =\n    u v * \\<langle>v, v\\<rangle>", "by blast"], ["proof (state)\nthis:\n  \\<langle>v, \\<Sum>v'\\<in>t. u v' *\\<^sub>C v'\\<rangle> =\n  u v * \\<langle>v, v\\<rangle>\n\ngoal (1 subgoal):\n 1. u v = 0", "hence \"u v * \\<langle>v, v\\<rangle> = 0\""], ["proof (prove)\nusing this:\n  \\<langle>v, \\<Sum>v'\\<in>t. u v' *\\<^sub>C v'\\<rangle> =\n  u v * \\<langle>v, v\\<rangle>\n\ngoal (1 subgoal):\n 1. u v * \\<langle>v, v\\<rangle> = 0", "using b3"], ["proof (prove)\nusing this:\n  \\<langle>v, \\<Sum>v'\\<in>t. u v' *\\<^sub>C v'\\<rangle> =\n  u v * \\<langle>v, v\\<rangle>\n  (\\<Sum>v\\<in>t. u v *\\<^sub>C v) = (0::'a)\n\ngoal (1 subgoal):\n 1. u v * \\<langle>v, v\\<rangle> = 0", "by simp"], ["proof (state)\nthis:\n  u v * \\<langle>v, v\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. u v = 0", "moreover"], ["proof (state)\nthis:\n  u v * \\<langle>v, v\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. u v = 0", "have \"\\<langle>v, v\\<rangle> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>v, v\\<rangle> \\<noteq> 0", "using assms is_ortho_set_def b2 b4"], ["proof (prove)\nusing this:\n  is_ortho_set A\n  is_ortho_set ?S =\n  ((\\<forall>x\\<in>?S.\n       \\<forall>y\\<in>?S.\n          x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n   (0::?'a) \\<notin> ?S)\n  t \\<subseteq> A\n  v \\<in> t\n\ngoal (1 subgoal):\n 1. \\<langle>v, v\\<rangle> \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<langle>v, v\\<rangle> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. u v = 0", "ultimately"], ["proof (chain)\npicking this:\n  u v * \\<langle>v, v\\<rangle> = 0\n  \\<langle>v, v\\<rangle> \\<noteq> 0", "show \"u v = 0\""], ["proof (prove)\nusing this:\n  u v * \\<langle>v, v\\<rangle> = 0\n  \\<langle>v, v\\<rangle> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. u v = 0", "by simp"], ["proof (state)\nthis:\n  u v = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?t; ?t \\<subseteq> A;\n   (\\<Sum>v\\<in>?t. ?u v *\\<^sub>C v) = (0::'a); ?v \\<in> ?t\\<rbrakk>\n  \\<Longrightarrow> ?u ?v = 0\n\ngoal (1 subgoal):\n 1. cindependent A", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?t; ?t \\<subseteq> A;\n   (\\<Sum>v\\<in>?t. ?u v *\\<^sub>C v) = (0::'a); ?v \\<in> ?t\\<rbrakk>\n  \\<Longrightarrow> ?u ?v = 0\n\ngoal (1 subgoal):\n 1. cindependent A", "using complex_vector.independent_explicit_module"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?t; ?t \\<subseteq> A;\n   (\\<Sum>v\\<in>?t. ?u v *\\<^sub>C v) = (0::'a); ?v \\<in> ?t\\<rbrakk>\n  \\<Longrightarrow> ?u ?v = 0\n  cindependent ?s =\n  (\\<forall>t u v.\n      finite t \\<longrightarrow>\n      t \\<subseteq> ?s \\<longrightarrow>\n      (\\<Sum>v\\<in>t. u v *\\<^sub>C v) = (0::?'a) \\<longrightarrow>\n      v \\<in> t \\<longrightarrow> u v = 0)\n\ngoal (1 subgoal):\n 1. cindependent A", "by (smt cdependent_raw_def)"], ["proof (state)\nthis:\n  cindependent A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma onb_expansion_finite:\n  includes notation_norm\n  fixes T::\\<open>'a::{complex_inner,cfinite_dim} set\\<close>\n  assumes a1: \\<open>cspan T = UNIV\\<close> and a3: \\<open>is_ortho_set T\\<close>\n    and a4: \\<open>\\<And>t. t\\<in>T \\<Longrightarrow> \\<parallel>t\\<parallel> = 1\\<close>\n  shows \\<open>x = (\\<Sum>t\\<in>T. \\<langle> t, x \\<rangle> *\\<^sub>C t)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "have \\<open>finite T\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite T", "apply (rule cindependent_cfinite_dim_finite)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent T", "by (simp add: a3 is_ortho_set_cindependent)"], ["proof (state)\nthis:\n  finite T\n\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "have \\<open>closure (complex_vector.span T)  = complex_vector.span T\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (cspan T) = cspan T", "by (simp add: a1)"], ["proof (state)\nthis:\n  closure (cspan T) = cspan T\n\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "have \\<open>{\\<Sum>a\\<in>t. r a *\\<^sub>C a |t r. finite t \\<and> t \\<subseteq> T} = {\\<Sum>a\\<in>T. r a *\\<^sub>C a |r. True}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<Sum>a\\<in>t. r a *\\<^sub>C a |t r. finite t \\<and> t \\<subseteq> T} =\n    {\\<Sum>a\\<in>T. r a *\\<^sub>C a |r. True}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t r.\n       \\<lbrakk>finite t; t \\<subseteq> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ra.\n                            (\\<Sum>a\\<in>t. r a *\\<^sub>C a) =\n                            (\\<Sum>a\\<in>T. ra a *\\<^sub>C a)\n 2. \\<And>r.\n       \\<exists>t.\n          (\\<exists>ra.\n              (\\<Sum>a\\<in>T. r a *\\<^sub>C a) =\n              (\\<Sum>a\\<in>t. ra a *\\<^sub>C a)) \\<and>\n          finite t \\<and> t \\<subseteq> T", "apply (rule_tac x=\\<open>\\<lambda>a. if a \\<in> t then r a else 0\\<close> in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t r.\n       \\<lbrakk>finite t; t \\<subseteq> T\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a\\<in>t. r a *\\<^sub>C a) =\n                         (\\<Sum>a\\<in>T.\n                            (if a \\<in> t then r a else 0) *\\<^sub>C a)\n 2. \\<And>r.\n       \\<exists>t.\n          (\\<exists>ra.\n              (\\<Sum>a\\<in>T. r a *\\<^sub>C a) =\n              (\\<Sum>a\\<in>t. ra a *\\<^sub>C a)) \\<and>\n          finite t \\<and> t \\<subseteq> T", "apply (simp add: \\<open>finite T\\<close> sum.mono_neutral_cong_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<exists>t.\n          (\\<exists>ra.\n              (\\<Sum>a\\<in>T. r a *\\<^sub>C a) =\n              (\\<Sum>a\\<in>t. ra a *\\<^sub>C a)) \\<and>\n          finite t \\<and> t \\<subseteq> T", "using \\<open>finite T\\<close>"], ["proof (prove)\nusing this:\n  finite T\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       \\<exists>t.\n          (\\<exists>ra.\n              (\\<Sum>a\\<in>T. r a *\\<^sub>C a) =\n              (\\<Sum>a\\<in>t. ra a *\\<^sub>C a)) \\<and>\n          finite t \\<and> t \\<subseteq> T", "by blast"], ["proof (state)\nthis:\n  {\\<Sum>a\\<in>t. r a *\\<^sub>C a |t r. finite t \\<and> t \\<subseteq> T} =\n  {\\<Sum>a\\<in>T. r a *\\<^sub>C a |r. True}\n\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "have f1: \"\\<forall>A. {a. \\<exists>Aa f. (a::'a) = (\\<Sum>a\\<in>Aa. f a *\\<^sub>C a) \\<and> finite Aa \\<and> Aa \\<subseteq> A} = cspan A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       {\\<Sum>a\\<in>Aa. f a *\\<^sub>C a |Aa f.\n        finite Aa \\<and> Aa \\<subseteq> A} =\n       cspan A", "by (simp add: complex_vector.span_explicit)"], ["proof (state)\nthis:\n  \\<forall>A.\n     {\\<Sum>a\\<in>Aa. f a *\\<^sub>C a |Aa f.\n      finite Aa \\<and> Aa \\<subseteq> A} =\n     cspan A\n\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "have f2: \"\\<forall>a. (\\<exists>f. a = (\\<Sum>a\\<in>T. f a *\\<^sub>C a)) \\<or> (\\<forall>A. (\\<forall>f. a \\<noteq> (\\<Sum>a\\<in>A. f a *\\<^sub>C a)) \\<or> infinite A \\<or> \\<not> A \\<subseteq> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       (\\<exists>f. a = (\\<Sum>a\\<in>T. f a *\\<^sub>C a)) \\<or>\n       (\\<forall>A.\n           (\\<forall>f. a \\<noteq> (\\<Sum>a\\<in>A. f a *\\<^sub>C a)) \\<or>\n           infinite A \\<or> \\<not> A \\<subseteq> T)", "using \\<open>{\\<Sum>a\\<in>t. r a *\\<^sub>C a |t r. finite t \\<and> t \\<subseteq> T} = {\\<Sum>a\\<in>T. r a *\\<^sub>C a |r. True}\\<close>"], ["proof (prove)\nusing this:\n  {\\<Sum>a\\<in>t. r a *\\<^sub>C a |t r. finite t \\<and> t \\<subseteq> T} =\n  {\\<Sum>a\\<in>T. r a *\\<^sub>C a |r. True}\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       (\\<exists>f. a = (\\<Sum>a\\<in>T. f a *\\<^sub>C a)) \\<or>\n       (\\<forall>A.\n           (\\<forall>f. a \\<noteq> (\\<Sum>a\\<in>A. f a *\\<^sub>C a)) \\<or>\n           infinite A \\<or> \\<not> A \\<subseteq> T)", "by auto"], ["proof (state)\nthis:\n  \\<forall>a.\n     (\\<exists>f. a = (\\<Sum>a\\<in>T. f a *\\<^sub>C a)) \\<or>\n     (\\<forall>A.\n         (\\<forall>f. a \\<noteq> (\\<Sum>a\\<in>A. f a *\\<^sub>C a)) \\<or>\n         infinite A \\<or> \\<not> A \\<subseteq> T)\n\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "have f3: \"\\<forall>A a. (\\<exists>Aa f. (a::'a) = (\\<Sum>a\\<in>Aa. f a *\\<^sub>C a) \\<and> finite Aa \\<and> Aa \\<subseteq> A) \\<or> a \\<notin> cspan A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A a.\n       (\\<exists>Aa f.\n           a = (\\<Sum>a\\<in>Aa. f a *\\<^sub>C a) \\<and>\n           finite Aa \\<and> Aa \\<subseteq> A) \\<or>\n       a \\<notin> cspan A", "using f1"], ["proof (prove)\nusing this:\n  \\<forall>A.\n     {\\<Sum>a\\<in>Aa. f a *\\<^sub>C a |Aa f.\n      finite Aa \\<and> Aa \\<subseteq> A} =\n     cspan A\n\ngoal (1 subgoal):\n 1. \\<forall>A a.\n       (\\<exists>Aa f.\n           a = (\\<Sum>a\\<in>Aa. f a *\\<^sub>C a) \\<and>\n           finite Aa \\<and> Aa \\<subseteq> A) \\<or>\n       a \\<notin> cspan A", "by blast"], ["proof (state)\nthis:\n  \\<forall>A a.\n     (\\<exists>Aa f.\n         a = (\\<Sum>a\\<in>Aa. f a *\\<^sub>C a) \\<and>\n         finite Aa \\<and> Aa \\<subseteq> A) \\<or>\n     a \\<notin> cspan A\n\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "have \"cspan T = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan T = UNIV", "by (metis (full_types, lifting)  \\<open>complex_vector.span T = UNIV\\<close>)"], ["proof (state)\nthis:\n  cspan T = UNIV\n\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "hence \\<open>\\<exists> r. x = (\\<Sum> a\\<in>T. r a *\\<^sub>C a)\\<close>"], ["proof (prove)\nusing this:\n  cspan T = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>r. x = (\\<Sum>a\\<in>T. r a *\\<^sub>C a)", "using f3 f2"], ["proof (prove)\nusing this:\n  cspan T = UNIV\n  \\<forall>A a.\n     (\\<exists>Aa f.\n         a = (\\<Sum>a\\<in>Aa. f a *\\<^sub>C a) \\<and>\n         finite Aa \\<and> Aa \\<subseteq> A) \\<or>\n     a \\<notin> cspan A\n  \\<forall>a.\n     (\\<exists>f. a = (\\<Sum>a\\<in>T. f a *\\<^sub>C a)) \\<or>\n     (\\<forall>A.\n         (\\<forall>f. a \\<noteq> (\\<Sum>a\\<in>A. f a *\\<^sub>C a)) \\<or>\n         infinite A \\<or> \\<not> A \\<subseteq> T)\n\ngoal (1 subgoal):\n 1. \\<exists>r. x = (\\<Sum>a\\<in>T. r a *\\<^sub>C a)", "by blast"], ["proof (state)\nthis:\n  \\<exists>r. x = (\\<Sum>a\\<in>T. r a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "then"], ["proof (chain)\npicking this:\n  \\<exists>r. x = (\\<Sum>a\\<in>T. r a *\\<^sub>C a)", "obtain r where \\<open>x = (\\<Sum> a\\<in>T. r a *\\<^sub>C a)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>r. x = (\\<Sum>a\\<in>T. r a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        x = (\\<Sum>a\\<in>T. r a *\\<^sub>C a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = (\\<Sum>a\\<in>T. r a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "have \\<open>r a = \\<langle>a, x\\<rangle>\\<close> if \\<open>a \\<in> T\\<close> for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "have \\<open>norm a = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>a\\<parallel> = 1", "using a4"], ["proof (prove)\nusing this:\n  ?t \\<in> T \\<Longrightarrow> \\<parallel>?t\\<parallel> = 1\n\ngoal (1 subgoal):\n 1. \\<parallel>a\\<parallel> = 1", "by (simp add: \\<open>a \\<in> T\\<close>)"], ["proof (state)\nthis:\n  \\<parallel>a\\<parallel> = 1\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "moreover"], ["proof (state)\nthis:\n  \\<parallel>a\\<parallel> = 1\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "have \\<open>norm a = sqrt (norm \\<langle>a, a\\<rangle>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>a\\<parallel> = sqrt (cmod \\<langle>a, a\\<rangle>)", "using norm_eq_sqrt_cinner"], ["proof (prove)\nusing this:\n  \\<parallel>?x\\<parallel> = sqrt (cmod \\<langle>?x, ?x\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<parallel>a\\<parallel> = sqrt (cmod \\<langle>a, a\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  \\<parallel>a\\<parallel> = sqrt (cmod \\<langle>a, a\\<rangle>)\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  \\<parallel>a\\<parallel> = 1\n  \\<parallel>a\\<parallel> = sqrt (cmod \\<langle>a, a\\<rangle>)", "have \\<open>sqrt (norm \\<langle>a, a\\<rangle>) = 1\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>a\\<parallel> = 1\n  \\<parallel>a\\<parallel> = sqrt (cmod \\<langle>a, a\\<rangle>)\n\ngoal (1 subgoal):\n 1. sqrt (cmod \\<langle>a, a\\<rangle>) = 1", "by simp"], ["proof (state)\nthis:\n  sqrt (cmod \\<langle>a, a\\<rangle>) = 1\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "hence \\<open>norm \\<langle>a, a\\<rangle> = 1\\<close>"], ["proof (prove)\nusing this:\n  sqrt (cmod \\<langle>a, a\\<rangle>) = 1\n\ngoal (1 subgoal):\n 1. cmod \\<langle>a, a\\<rangle> = 1", "using real_sqrt_eq_1_iff"], ["proof (prove)\nusing this:\n  sqrt (cmod \\<langle>a, a\\<rangle>) = 1\n  (sqrt ?x = 1) = (?x = 1)\n\ngoal (1 subgoal):\n 1. cmod \\<langle>a, a\\<rangle> = 1", "by blast"], ["proof (state)\nthis:\n  cmod \\<langle>a, a\\<rangle> = 1\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "moreover"], ["proof (state)\nthis:\n  cmod \\<langle>a, a\\<rangle> = 1\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "have \\<open>\\<langle>a, a\\<rangle> \\<in> \\<real>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>a, a\\<rangle> \\<in> \\<real>", "by (simp add: cinner_real)"], ["proof (state)\nthis:\n  \\<langle>a, a\\<rangle> \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "moreover"], ["proof (state)\nthis:\n  \\<langle>a, a\\<rangle> \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "have \\<open>\\<langle>a, a\\<rangle> \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<langle>a, a\\<rangle>", "using cinner_ge_zero"], ["proof (prove)\nusing this:\n  0 \\<le> \\<langle>?x, ?x\\<rangle>\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<langle>a, a\\<rangle>", "by blast"], ["proof (state)\nthis:\n  0 \\<le> \\<langle>a, a\\<rangle>\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  cmod \\<langle>a, a\\<rangle> = 1\n  \\<langle>a, a\\<rangle> \\<in> \\<real>\n  0 \\<le> \\<langle>a, a\\<rangle>", "have w1: \\<open>\\<langle>a, a\\<rangle> = 1\\<close>"], ["proof (prove)\nusing this:\n  cmod \\<langle>a, a\\<rangle> = 1\n  \\<langle>a, a\\<rangle> \\<in> \\<real>\n  0 \\<le> \\<langle>a, a\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>a, a\\<rangle> = 1", "by (metis \\<open>0 \\<le> \\<langle>a, a\\<rangle>\\<close> \\<open>cmod \\<langle>a, a\\<rangle> = 1\\<close> complex_of_real_cmod of_real_1)"], ["proof (state)\nthis:\n  \\<langle>a, a\\<rangle> = 1\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "have \\<open>r t * \\<langle>a, t\\<rangle> = 0\\<close> if \\<open>t \\<in> T-{a}\\<close> for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. r t * \\<langle>a, t\\<rangle> = 0", "by (metis DiffD1 DiffD2 \\<open>a \\<in> T\\<close> a3 is_ortho_set_def mult_eq_0_iff singletonI that)"], ["proof (state)\nthis:\n  ?t \\<in> T - {a} \\<Longrightarrow> r ?t * \\<langle>a, ?t\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "hence s1: \\<open>(\\<Sum> t\\<in>T-{a}. r t * \\<langle>a, t\\<rangle>) = 0\\<close>"], ["proof (prove)\nusing this:\n  ?t \\<in> T - {a} \\<Longrightarrow> r ?t * \\<langle>a, ?t\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>T - {a}. r t * \\<langle>a, t\\<rangle>) = 0", "by (simp add: \\<open>\\<And>t. t \\<in> T - {a} \\<Longrightarrow> r t * \\<langle>a, t\\<rangle> = 0\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>T - {a}. r t * \\<langle>a, t\\<rangle>) = 0\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "have \\<open>\\<langle>a, x\\<rangle> = \\<langle>a, (\\<Sum> t\\<in>T. r t *\\<^sub>C t)\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>a, x\\<rangle> =\n    \\<langle>a, \\<Sum>t\\<in>T. r t *\\<^sub>C t\\<rangle>", "using \\<open>x = (\\<Sum> a\\<in>T. r a *\\<^sub>C a)\\<close>"], ["proof (prove)\nusing this:\n  x = (\\<Sum>a\\<in>T. r a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. \\<langle>a, x\\<rangle> =\n    \\<langle>a, \\<Sum>t\\<in>T. r t *\\<^sub>C t\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<langle>a, x\\<rangle> =\n  \\<langle>a, \\<Sum>t\\<in>T. r t *\\<^sub>C t\\<rangle>\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "also"], ["proof (state)\nthis:\n  \\<langle>a, x\\<rangle> =\n  \\<langle>a, \\<Sum>t\\<in>T. r t *\\<^sub>C t\\<rangle>\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "have \\<open>\\<dots> = (\\<Sum> t\\<in>T. \\<langle>a, r t *\\<^sub>C t\\<rangle>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>a, \\<Sum>t\\<in>T. r t *\\<^sub>C t\\<rangle> =\n    (\\<Sum>t\\<in>T. \\<langle>a, r t *\\<^sub>C t\\<rangle>)", "using cinner_sum_right"], ["proof (prove)\nusing this:\n  \\<langle>?x, sum ?f ?A\\<rangle> =\n  (\\<Sum>y\\<in>?A. \\<langle>?x, ?f y\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<langle>a, \\<Sum>t\\<in>T. r t *\\<^sub>C t\\<rangle> =\n    (\\<Sum>t\\<in>T. \\<langle>a, r t *\\<^sub>C t\\<rangle>)", "by blast"], ["proof (state)\nthis:\n  \\<langle>a, \\<Sum>t\\<in>T. r t *\\<^sub>C t\\<rangle> =\n  (\\<Sum>t\\<in>T. \\<langle>a, r t *\\<^sub>C t\\<rangle>)\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "also"], ["proof (state)\nthis:\n  \\<langle>a, \\<Sum>t\\<in>T. r t *\\<^sub>C t\\<rangle> =\n  (\\<Sum>t\\<in>T. \\<langle>a, r t *\\<^sub>C t\\<rangle>)\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "have \\<open>\\<dots> = (\\<Sum> t\\<in>T. r t * \\<langle>a, t\\<rangle>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>T. \\<langle>a, r t *\\<^sub>C t\\<rangle>) =\n    (\\<Sum>t\\<in>T. r t * \\<langle>a, t\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>T. \\<langle>a, r t *\\<^sub>C t\\<rangle>) =\n  (\\<Sum>t\\<in>T. r t * \\<langle>a, t\\<rangle>)\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>T. \\<langle>a, r t *\\<^sub>C t\\<rangle>) =\n  (\\<Sum>t\\<in>T. r t * \\<langle>a, t\\<rangle>)\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "have \\<open>\\<dots> = r a * \\<langle>a, a\\<rangle> + (\\<Sum> t\\<in>T-{a}. r t * \\<langle>a, t\\<rangle>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>T. r t * \\<langle>a, t\\<rangle>) =\n    r a * \\<langle>a, a\\<rangle> +\n    (\\<Sum>t\\<in>T - {a}. r t * \\<langle>a, t\\<rangle>)", "using \\<open>a \\<in> T\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>T. r t * \\<langle>a, t\\<rangle>) =\n    r a * \\<langle>a, a\\<rangle> +\n    (\\<Sum>t\\<in>T - {a}. r t * \\<langle>a, t\\<rangle>)", "by (meson \\<open>finite T\\<close> sum.remove)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>T. r t * \\<langle>a, t\\<rangle>) =\n  r a * \\<langle>a, a\\<rangle> +\n  (\\<Sum>t\\<in>T - {a}. r t * \\<langle>a, t\\<rangle>)\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "also"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>T. r t * \\<langle>a, t\\<rangle>) =\n  r a * \\<langle>a, a\\<rangle> +\n  (\\<Sum>t\\<in>T - {a}. r t * \\<langle>a, t\\<rangle>)\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "have \\<open>\\<dots> = r a * \\<langle>a, a\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r a * \\<langle>a, a\\<rangle> +\n    (\\<Sum>t\\<in>T - {a}. r t * \\<langle>a, t\\<rangle>) =\n    r a * \\<langle>a, a\\<rangle>", "using s1"], ["proof (prove)\nusing this:\n  (\\<Sum>t\\<in>T - {a}. r t * \\<langle>a, t\\<rangle>) = 0\n\ngoal (1 subgoal):\n 1. r a * \\<langle>a, a\\<rangle> +\n    (\\<Sum>t\\<in>T - {a}. r t * \\<langle>a, t\\<rangle>) =\n    r a * \\<langle>a, a\\<rangle>", "by simp"], ["proof (state)\nthis:\n  r a * \\<langle>a, a\\<rangle> +\n  (\\<Sum>t\\<in>T - {a}. r t * \\<langle>a, t\\<rangle>) =\n  r a * \\<langle>a, a\\<rangle>\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "also"], ["proof (state)\nthis:\n  r a * \\<langle>a, a\\<rangle> +\n  (\\<Sum>t\\<in>T - {a}. r t * \\<langle>a, t\\<rangle>) =\n  r a * \\<langle>a, a\\<rangle>\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "have \\<open>\\<dots> = r a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r a * \\<langle>a, a\\<rangle> = r a", "by (simp add: w1)"], ["proof (state)\nthis:\n  r a * \\<langle>a, a\\<rangle> = r a\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "finally"], ["proof (chain)\npicking this:\n  \\<langle>a, x\\<rangle> = r a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>a, x\\<rangle> = r a\n\ngoal (1 subgoal):\n 1. r a = \\<langle>a, x\\<rangle>", "by auto"], ["proof (state)\nthis:\n  r a = \\<langle>a, x\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a \\<in> T \\<Longrightarrow> r ?a = \\<langle>?a, x\\<rangle>\n\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?a \\<in> T \\<Longrightarrow> r ?a = \\<langle>?a, x\\<rangle>\n\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "using \\<open>x = (\\<Sum> a\\<in>T. r a *\\<^sub>C a)\\<close>"], ["proof (prove)\nusing this:\n  ?a \\<in> T \\<Longrightarrow> r ?a = \\<langle>?a, x\\<rangle>\n  x = (\\<Sum>a\\<in>T. r a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)", "by fastforce"], ["proof (state)\nthis:\n  x = (\\<Sum>t\\<in>T. \\<langle>t, x\\<rangle> *\\<^sub>C t)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Projections\\<close>"], ["", "lemma smallest_norm_exists:\n  \\<comment> \\<open>Theorem 2.5 in @{cite conway2013course} (inside the proof)\\<close>\n  includes notation_norm\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes q1: \\<open>convex M\\<close> and q2: \\<open>closed M\\<close> and q3: \\<open>M \\<noteq> {}\\<close>\n  shows  \\<open>\\<exists>k. is_arg_min (\\<lambda> x. \\<parallel>x\\<parallel>) (\\<lambda> t. t \\<in> M) k\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "define d where \\<open>d = Inf { \\<parallel>x\\<parallel>^2 | x. x \\<in> M }\\<close>"], ["proof (state)\nthis:\n  d = \\<Sqinter> {\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "have w4: \\<open>{ \\<parallel>x\\<parallel>^2 | x. x \\<in> M } \\<noteq> {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M} \\<noteq> {}", "by (simp add: assms(3))"], ["proof (state)\nthis:\n  {\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "have \\<open>\\<forall> x. \\<parallel>x\\<parallel>^2 \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. 0 \\<le> \\<parallel>x\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. 0 \\<le> \\<parallel>x\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "hence bdd_below1: \\<open>bdd_below { \\<parallel>x\\<parallel>^2 | x. x \\<in> M }\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x. 0 \\<le> \\<parallel>x\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. bdd_below {\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M}", "by fastforce"], ["proof (state)\nthis:\n  bdd_below {\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "have \\<open>d \\<le> \\<parallel>x\\<parallel>^2\\<close> \n    if a1: \"x \\<in> M\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> \\<parallel>x\\<parallel>\\<^sup>2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<le> \\<parallel>x\\<parallel>\\<^sup>2", "have \"\\<forall>v. (\\<exists>w. Re (\\<langle>v , v\\<rangle> ) = \\<parallel>w\\<parallel>\\<^sup>2 \\<and> w \\<in> M) \\<or> v \\<notin> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       (\\<exists>w.\n           Re \\<langle>v, v\\<rangle> =\n           \\<parallel>w\\<parallel>\\<^sup>2 \\<and>\n           w \\<in> M) \\<or>\n       v \\<notin> M", "by (metis (no_types) power2_norm_eq_cinner')"], ["proof (state)\nthis:\n  \\<forall>v.\n     (\\<exists>w.\n         Re \\<langle>v, v\\<rangle> = \\<parallel>w\\<parallel>\\<^sup>2 \\<and>\n         w \\<in> M) \\<or>\n     v \\<notin> M\n\ngoal (1 subgoal):\n 1. d \\<le> \\<parallel>x\\<parallel>\\<^sup>2", "hence \"Re (\\<langle>x , x\\<rangle> ) \\<in> {\\<parallel>v\\<parallel>\\<^sup>2 |v. v \\<in> M}\""], ["proof (prove)\nusing this:\n  \\<forall>v.\n     (\\<exists>w.\n         Re \\<langle>v, v\\<rangle> = \\<parallel>w\\<parallel>\\<^sup>2 \\<and>\n         w \\<in> M) \\<or>\n     v \\<notin> M\n\ngoal (1 subgoal):\n 1. Re \\<langle>x, x\\<rangle>\n    \\<in> {\\<parallel>v\\<parallel>\\<^sup>2 |v. v \\<in> M}", "using a1"], ["proof (prove)\nusing this:\n  \\<forall>v.\n     (\\<exists>w.\n         Re \\<langle>v, v\\<rangle> = \\<parallel>w\\<parallel>\\<^sup>2 \\<and>\n         w \\<in> M) \\<or>\n     v \\<notin> M\n  x \\<in> M\n\ngoal (1 subgoal):\n 1. Re \\<langle>x, x\\<rangle>\n    \\<in> {\\<parallel>v\\<parallel>\\<^sup>2 |v. v \\<in> M}", "by blast"], ["proof (state)\nthis:\n  Re \\<langle>x, x\\<rangle>\n  \\<in> {\\<parallel>v\\<parallel>\\<^sup>2 |v. v \\<in> M}\n\ngoal (1 subgoal):\n 1. d \\<le> \\<parallel>x\\<parallel>\\<^sup>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  Re \\<langle>x, x\\<rangle>\n  \\<in> {\\<parallel>v\\<parallel>\\<^sup>2 |v. v \\<in> M}\n\ngoal (1 subgoal):\n 1. d \\<le> \\<parallel>x\\<parallel>\\<^sup>2", "unfolding d_def"], ["proof (prove)\nusing this:\n  Re \\<langle>x, x\\<rangle>\n  \\<in> {\\<parallel>v\\<parallel>\\<^sup>2 |v. v \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M}\n    \\<le> \\<parallel>x\\<parallel>\\<^sup>2", "by (metis (lifting) bdd_below1 cInf_lower power2_norm_eq_cinner')"], ["proof (state)\nthis:\n  d \\<le> \\<parallel>x\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x1 \\<in> M \\<Longrightarrow> d \\<le> \\<parallel>?x1\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "have \\<open>\\<forall> \\<epsilon> > 0. \\<exists> t \\<in> { \\<parallel>x\\<parallel>^2 | x. x \\<in> M }.  t < d + \\<epsilon>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>>0.\n       \\<exists>t\\<in>{\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M}.\n          t < d + \\<epsilon>", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>>0.\n       \\<exists>t\\<in>{\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M}.\n          t < \\<Sqinter> {\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M} +\n              \\<epsilon>", "using w4  bdd_below1"], ["proof (prove)\nusing this:\n  {\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M} \\<noteq> {}\n  bdd_below {\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>>0.\n       \\<exists>t\\<in>{\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M}.\n          t < \\<Sqinter> {\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M} +\n              \\<epsilon>", "by (meson cInf_lessD less_add_same_cancel1)"], ["proof (state)\nthis:\n  \\<forall>\\<epsilon>>0.\n     \\<exists>t\\<in>{\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M}.\n        t < d + \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "hence \\<open>\\<forall> \\<epsilon> > 0. \\<exists> x \\<in> M.  \\<parallel>x\\<parallel>^2 < d + \\<epsilon>\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>\\<epsilon>>0.\n     \\<exists>t\\<in>{\\<parallel>x\\<parallel>\\<^sup>2 |x. x \\<in> M}.\n        t < d + \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>>0.\n       \\<exists>x\\<in>M. \\<parallel>x\\<parallel>\\<^sup>2 < d + \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<epsilon>>0.\n     \\<exists>x\\<in>M. \\<parallel>x\\<parallel>\\<^sup>2 < d + \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "hence \\<open>\\<forall> \\<epsilon> > 0. \\<exists> x \\<in> M.  \\<parallel>x\\<parallel>^2 < d + \\<epsilon>\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>\\<epsilon>>0.\n     \\<exists>x\\<in>M. \\<parallel>x\\<parallel>\\<^sup>2 < d + \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>>0.\n       \\<exists>x\\<in>M. \\<parallel>x\\<parallel>\\<^sup>2 < d + \\<epsilon>", "by (simp add: \\<open>\\<And>x. x \\<in> M \\<Longrightarrow> d \\<le> \\<parallel>x\\<parallel>\\<^sup>2\\<close>)"], ["proof (state)\nthis:\n  \\<forall>\\<epsilon>>0.\n     \\<exists>x\\<in>M. \\<parallel>x\\<parallel>\\<^sup>2 < d + \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "hence w1: \\<open>\\<forall> n::nat. \\<exists> x \\<in> M.  \\<parallel>x\\<parallel>^2 < d + 1/(n+1)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>\\<epsilon>>0.\n     \\<exists>x\\<in>M. \\<parallel>x\\<parallel>\\<^sup>2 < d + \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>xa\\<in>M.\n          \\<parallel>xa\\<parallel>\\<^sup>2 < d + 1 / (real x + 1)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     \\<exists>xa\\<in>M.\n        \\<parallel>xa\\<parallel>\\<^sup>2 < d + 1 / (real x + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     \\<exists>xa\\<in>M.\n        \\<parallel>xa\\<parallel>\\<^sup>2 < d + 1 / (real x + 1)", "obtain r::\\<open>nat \\<Rightarrow> 'a\\<close> where w2: \\<open>\\<forall> n. r n \\<in> M \\<and>  \\<parallel> r n \\<parallel>^2 < d + 1/(n+1)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     \\<exists>xa\\<in>M.\n        \\<parallel>xa\\<parallel>\\<^sup>2 < d + 1 / (real x + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<forall>n.\n           r n \\<in> M \\<and>\n           \\<parallel>r n\\<parallel>\\<^sup>2\n           < d + 1 / (real n + 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>n.\n     r n \\<in> M \\<and>\n     \\<parallel>r n\\<parallel>\\<^sup>2 < d + 1 / (real n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "have w3: \\<open>\\<forall> n. r n \\<in> M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. r n \\<in> M", "by (simp add: w2)"], ["proof (state)\nthis:\n  \\<forall>n. r n \\<in> M\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "have \\<open>\\<forall> n. \\<parallel> r n \\<parallel>^2 < d + 1/(n+1)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. \\<parallel>r n\\<parallel>\\<^sup>2 < d + 1 / (real n + 1)", "by (simp add: w2)"], ["proof (state)\nthis:\n  \\<forall>n. \\<parallel>r n\\<parallel>\\<^sup>2 < d + 1 / (real n + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "have w5: \\<open>\\<parallel> (r n) - (r m) \\<parallel>^2 < 2*(1/(n+1) + 1/(m+1))\\<close> \n    for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "have w6: \\<open>\\<parallel> r n \\<parallel>^2 < d + 1/(n+1)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>r n\\<parallel>\\<^sup>2 < d + 1 / real (n + 1)", "by (metis w2  of_nat_1 of_nat_add)"], ["proof (state)\nthis:\n  \\<parallel>r n\\<parallel>\\<^sup>2 < d + 1 / real (n + 1)\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "have \\<open> \\<parallel> r m \\<parallel>^2 < d + 1/(m+1)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>r m\\<parallel>\\<^sup>2 < d + 1 / real (m + 1)", "by (metis w2 of_nat_1 of_nat_add)"], ["proof (state)\nthis:\n  \\<parallel>r m\\<parallel>\\<^sup>2 < d + 1 / real (m + 1)\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "have \\<open>(r n) \\<in> M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r n \\<in> M", "by (simp add: \\<open>\\<forall>n. r n \\<in> M\\<close>)"], ["proof (state)\nthis:\n  r n \\<in> M\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "moreover"], ["proof (state)\nthis:\n  r n \\<in> M\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "have \\<open>(r m) \\<in> M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r m \\<in> M", "by (simp add: \\<open>\\<forall>n. r n \\<in> M\\<close>)"], ["proof (state)\nthis:\n  r m \\<in> M\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "ultimately"], ["proof (chain)\npicking this:\n  r n \\<in> M\n  r m \\<in> M", "have \\<open>(1/2) *\\<^sub>R (r n) + (1/2) *\\<^sub>R (r m) \\<in> M\\<close>"], ["proof (prove)\nusing this:\n  r n \\<in> M\n  r m \\<in> M\n\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>R r n + (1 / 2) *\\<^sub>R r m \\<in> M", "using \\<open>convex M\\<close>"], ["proof (prove)\nusing this:\n  r n \\<in> M\n  r m \\<in> M\n  convex M\n\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>R r n + (1 / 2) *\\<^sub>R r m \\<in> M", "by (simp add: convexD)"], ["proof (state)\nthis:\n  (1 / 2) *\\<^sub>R r n + (1 / 2) *\\<^sub>R r m \\<in> M\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "hence \\<open>\\<parallel> (1/2) *\\<^sub>R (r n) + (1/2) *\\<^sub>R (r m) \\<parallel>^2 \\<ge> d\\<close>"], ["proof (prove)\nusing this:\n  (1 / 2) *\\<^sub>R r n + (1 / 2) *\\<^sub>R r m \\<in> M\n\ngoal (1 subgoal):\n 1. d \\<le> \\<parallel>(1 / 2) *\\<^sub>R r n +\n                       (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2", "by (simp add: \\<open>\\<And>x. x \\<in> M \\<Longrightarrow> d \\<le> \\<parallel>x\\<parallel>\\<^sup>2\\<close>)"], ["proof (state)\nthis:\n  d \\<le> \\<parallel>(1 / 2) *\\<^sub>R r n +\n                     (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "have \\<open>\\<parallel> (1/2) *\\<^sub>R (r n) - (1/2) *\\<^sub>R (r m) \\<parallel>^2\n              = (1/2)*( \\<parallel> r n \\<parallel>^2 + \\<parallel> r m \\<parallel>^2 ) - \\<parallel> (1/2) *\\<^sub>R (r n) + (1/2) *\\<^sub>R (r m) \\<parallel>^2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>(1 / 2) *\\<^sub>R r n -\n               (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2 =\n    1 / 2 *\n    (\\<parallel>r n\\<parallel>\\<^sup>2 +\n     \\<parallel>r m\\<parallel>\\<^sup>2) -\n    \\<parallel>(1 / 2) *\\<^sub>R r n +\n               (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2", "by (smt (z3) div_by_1 field_sum_of_halves nonzero_mult_div_cancel_left parallelogram_law polar_identity power2_norm_eq_cinner' scaleR_collapse times_divide_eq_left)"], ["proof (state)\nthis:\n  \\<parallel>(1 / 2) *\\<^sub>R r n -\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2 =\n  1 / 2 *\n  (\\<parallel>r n\\<parallel>\\<^sup>2 + \\<parallel>r m\\<parallel>\\<^sup>2) -\n  \\<parallel>(1 / 2) *\\<^sub>R r n +\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "also"], ["proof (state)\nthis:\n  \\<parallel>(1 / 2) *\\<^sub>R r n -\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2 =\n  1 / 2 *\n  (\\<parallel>r n\\<parallel>\\<^sup>2 + \\<parallel>r m\\<parallel>\\<^sup>2) -\n  \\<parallel>(1 / 2) *\\<^sub>R r n +\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "have  \\<open>...  \n              < (1/2)*( d + 1/(n+1) + \\<parallel> r m \\<parallel>^2 ) - \\<parallel> (1/2) *\\<^sub>R (r n) + (1/2) *\\<^sub>R (r m) \\<parallel>^2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 *\n    (\\<parallel>r n\\<parallel>\\<^sup>2 +\n     \\<parallel>r m\\<parallel>\\<^sup>2) -\n    \\<parallel>(1 / 2) *\\<^sub>R r n +\n               (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n    < 1 / 2 * (d + 1 / real (n + 1) + \\<parallel>r m\\<parallel>\\<^sup>2) -\n      \\<parallel>(1 / 2) *\\<^sub>R r n +\n                 (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2", "using \\<open>\\<parallel>r n\\<parallel>\\<^sup>2 < d + 1 / real (n + 1)\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>r n\\<parallel>\\<^sup>2 < d + 1 / real (n + 1)\n\ngoal (1 subgoal):\n 1. 1 / 2 *\n    (\\<parallel>r n\\<parallel>\\<^sup>2 +\n     \\<parallel>r m\\<parallel>\\<^sup>2) -\n    \\<parallel>(1 / 2) *\\<^sub>R r n +\n               (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n    < 1 / 2 * (d + 1 / real (n + 1) + \\<parallel>r m\\<parallel>\\<^sup>2) -\n      \\<parallel>(1 / 2) *\\<^sub>R r n +\n                 (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  1 / 2 *\n  (\\<parallel>r n\\<parallel>\\<^sup>2 + \\<parallel>r m\\<parallel>\\<^sup>2) -\n  \\<parallel>(1 / 2) *\\<^sub>R r n +\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n  < 1 / 2 * (d + 1 / real (n + 1) + \\<parallel>r m\\<parallel>\\<^sup>2) -\n    \\<parallel>(1 / 2) *\\<^sub>R r n +\n               (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "also"], ["proof (state)\nthis:\n  1 / 2 *\n  (\\<parallel>r n\\<parallel>\\<^sup>2 + \\<parallel>r m\\<parallel>\\<^sup>2) -\n  \\<parallel>(1 / 2) *\\<^sub>R r n +\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n  < 1 / 2 * (d + 1 / real (n + 1) + \\<parallel>r m\\<parallel>\\<^sup>2) -\n    \\<parallel>(1 / 2) *\\<^sub>R r n +\n               (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "have  \\<open>...  \n              < (1/2)*( d + 1/(n+1) + d + 1/(m+1) ) - \\<parallel> (1/2) *\\<^sub>R (r n) + (1/2) *\\<^sub>R (r m) \\<parallel>^2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * (d + 1 / real (n + 1) + \\<parallel>r m\\<parallel>\\<^sup>2) -\n    \\<parallel>(1 / 2) *\\<^sub>R r n +\n               (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n    < 1 / 2 * (d + 1 / real (n + 1) + d + 1 / real (m + 1)) -\n      \\<parallel>(1 / 2) *\\<^sub>R r n +\n                 (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2", "using \\<open>\\<parallel>r m\\<parallel>\\<^sup>2 < d + 1 / real (m + 1)\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>r m\\<parallel>\\<^sup>2 < d + 1 / real (m + 1)\n\ngoal (1 subgoal):\n 1. 1 / 2 * (d + 1 / real (n + 1) + \\<parallel>r m\\<parallel>\\<^sup>2) -\n    \\<parallel>(1 / 2) *\\<^sub>R r n +\n               (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n    < 1 / 2 * (d + 1 / real (n + 1) + d + 1 / real (m + 1)) -\n      \\<parallel>(1 / 2) *\\<^sub>R r n +\n                 (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  1 / 2 * (d + 1 / real (n + 1) + \\<parallel>r m\\<parallel>\\<^sup>2) -\n  \\<parallel>(1 / 2) *\\<^sub>R r n +\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n  < 1 / 2 * (d + 1 / real (n + 1) + d + 1 / real (m + 1)) -\n    \\<parallel>(1 / 2) *\\<^sub>R r n +\n               (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "also"], ["proof (state)\nthis:\n  1 / 2 * (d + 1 / real (n + 1) + \\<parallel>r m\\<parallel>\\<^sup>2) -\n  \\<parallel>(1 / 2) *\\<^sub>R r n +\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n  < 1 / 2 * (d + 1 / real (n + 1) + d + 1 / real (m + 1)) -\n    \\<parallel>(1 / 2) *\\<^sub>R r n +\n               (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "have  \\<open>...  \n              \\<le> (1/2)*( d + 1/(n+1) + d + 1/(m+1) ) - d\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * (d + 1 / real (n + 1) + d + 1 / real (m + 1)) -\n    \\<parallel>(1 / 2) *\\<^sub>R r n +\n               (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n    \\<le> 1 / 2 * (d + 1 / real (n + 1) + d + 1 / real (m + 1)) - d", "by (simp add: \\<open>d \\<le> \\<parallel>(1 / 2) *\\<^sub>R r n + (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\\<close>)"], ["proof (state)\nthis:\n  1 / 2 * (d + 1 / real (n + 1) + d + 1 / real (m + 1)) -\n  \\<parallel>(1 / 2) *\\<^sub>R r n +\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n  \\<le> 1 / 2 * (d + 1 / real (n + 1) + d + 1 / real (m + 1)) - d\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "also"], ["proof (state)\nthis:\n  1 / 2 * (d + 1 / real (n + 1) + d + 1 / real (m + 1)) -\n  \\<parallel>(1 / 2) *\\<^sub>R r n +\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n  \\<le> 1 / 2 * (d + 1 / real (n + 1) + d + 1 / real (m + 1)) - d\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "have  \\<open>...  \n              \\<le> (1/2)*( 1/(n+1) + 1/(m+1) + 2*d ) - d\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * (d + 1 / real (n + 1) + d + 1 / real (m + 1)) - d\n    \\<le> 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1) + 2 * d) - d", "by simp"], ["proof (state)\nthis:\n  1 / 2 * (d + 1 / real (n + 1) + d + 1 / real (m + 1)) - d\n  \\<le> 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1) + 2 * d) - d\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "also"], ["proof (state)\nthis:\n  1 / 2 * (d + 1 / real (n + 1) + d + 1 / real (m + 1)) - d\n  \\<le> 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1) + 2 * d) - d\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "have  \\<open>...  \n              \\<le> (1/2)*( 1/(n+1) + 1/(m+1) ) + (1/2)*(2*d) - d\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1) + 2 * d) - d\n    \\<le> 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1)) + 1 / 2 * (2 * d) -\n          d", "by (simp add: distrib_left)"], ["proof (state)\nthis:\n  1 / 2 * (1 / real (n + 1) + 1 / real (m + 1) + 2 * d) - d\n  \\<le> 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1)) + 1 / 2 * (2 * d) - d\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "also"], ["proof (state)\nthis:\n  1 / 2 * (1 / real (n + 1) + 1 / real (m + 1) + 2 * d) - d\n  \\<le> 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1)) + 1 / 2 * (2 * d) - d\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "have  \\<open>...  \n              \\<le> (1/2)*( 1/(n+1) + 1/(m+1) ) + d - d\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1)) + 1 / 2 * (2 * d) - d\n    \\<le> 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1)) + d - d", "by simp"], ["proof (state)\nthis:\n  1 / 2 * (1 / real (n + 1) + 1 / real (m + 1)) + 1 / 2 * (2 * d) - d\n  \\<le> 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1)) + d - d\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "also"], ["proof (state)\nthis:\n  1 / 2 * (1 / real (n + 1) + 1 / real (m + 1)) + 1 / 2 * (2 * d) - d\n  \\<le> 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1)) + d - d\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "have  \\<open>...  \n              \\<le> (1/2)*( 1/(n+1) + 1/(m+1) )\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1)) + d - d\n    \\<le> 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))", "by simp"], ["proof (state)\nthis:\n  1 / 2 * (1 / real (n + 1) + 1 / real (m + 1)) + d - d\n  \\<le> 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>(1 / 2) *\\<^sub>R r n -\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n  < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))", "have \\<open> \\<parallel>(1 / 2) *\\<^sub>R r n - (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2 < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1)) \\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>(1 / 2) *\\<^sub>R r n -\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n  < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>(1 / 2) *\\<^sub>R r n -\n               (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n    < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))", "by blast"], ["proof (state)\nthis:\n  \\<parallel>(1 / 2) *\\<^sub>R r n -\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n  < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "hence \\<open> \\<parallel>(1 / 2) *\\<^sub>R (r n - r m) \\<parallel>\\<^sup>2 < (1 / 2) * (1 / real (n + 1) + 1 / real (m + 1)) \\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>(1 / 2) *\\<^sub>R r n -\n             (1 / 2) *\\<^sub>R r m\\<parallel>\\<^sup>2\n  < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>(1 / 2) *\\<^sub>R (r n - r m)\\<parallel>\\<^sup>2\n    < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))", "by (simp add: real_vector.scale_right_diff_distrib)"], ["proof (state)\nthis:\n  \\<parallel>(1 / 2) *\\<^sub>R (r n - r m)\\<parallel>\\<^sup>2\n  < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "hence \\<open> ((1 / 2)*\\<parallel> (r n - r m) \\<parallel>)\\<^sup>2 < (1 / 2) * (1 / real (n + 1) + 1 / real (m + 1)) \\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>(1 / 2) *\\<^sub>R (r n - r m)\\<parallel>\\<^sup>2\n  < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. (1 / 2 * \\<parallel>r n - r m\\<parallel>)\\<^sup>2\n    < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))", "by simp"], ["proof (state)\nthis:\n  (1 / 2 * \\<parallel>r n - r m\\<parallel>)\\<^sup>2\n  < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "hence \\<open> (1 / 2)^2*(\\<parallel> (r n - r m) \\<parallel>)\\<^sup>2 < (1 / 2) * (1 / real (n + 1) + 1 / real (m + 1)) \\<close>"], ["proof (prove)\nusing this:\n  (1 / 2 * \\<parallel>r n - r m\\<parallel>)\\<^sup>2\n  < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. (1 / 2)\\<^sup>2 * \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))", "by (metis power_mult_distrib)"], ["proof (state)\nthis:\n  (1 / 2)\\<^sup>2 * \\<parallel>r n - r m\\<parallel>\\<^sup>2\n  < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "hence \\<open> (1 / 4) *(\\<parallel> (r n - r m) \\<parallel>)\\<^sup>2 < (1 / 2) * (1 / real (n + 1) + 1 / real (m + 1)) \\<close>"], ["proof (prove)\nusing this:\n  (1 / 2)\\<^sup>2 * \\<parallel>r n - r m\\<parallel>\\<^sup>2\n  < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. 1 / 4 * \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))", "by (simp add: power_divide)"], ["proof (state)\nthis:\n  1 / 4 * \\<parallel>r n - r m\\<parallel>\\<^sup>2\n  < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "hence \\<open> \\<parallel> (r n - r m) \\<parallel>\\<^sup>2 < 2 * (1 / real (n + 1) + 1 / real (m + 1)) \\<close>"], ["proof (prove)\nusing this:\n  1 / 4 * \\<parallel>r n - r m\\<parallel>\\<^sup>2\n  < 1 / 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / real (n + 1) + 1 / real (m + 1))", "by simp"], ["proof (state)\nthis:\n  \\<parallel>r n - r m\\<parallel>\\<^sup>2\n  < 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>r n - r m\\<parallel>\\<^sup>2\n  < 2 * (1 / real (n + 1) + 1 / real (m + 1))\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2\n    < 2 * (1 / (real n + 1) + 1 / (real m + 1))", "by (metis of_nat_1 of_nat_add)"], ["proof (state)\nthis:\n  \\<parallel>r n - r m\\<parallel>\\<^sup>2\n  < 2 * (1 / (real n + 1) + 1 / (real m + 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<parallel>r ?n1 - r ?m1\\<parallel>\\<^sup>2\n  < 2 * (1 / (real ?n1 + 1) + 1 / (real ?m1 + 1))\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "hence \"\\<exists> N. \\<forall> n m. n \\<ge> N \\<and> m \\<ge> N \\<longrightarrow> \\<parallel> (r n) - (r m) \\<parallel>^2 < \\<epsilon>^2\"\n    if \"\\<epsilon> > 0\" \n    for \\<epsilon>"], ["proof (prove)\nusing this:\n  \\<parallel>r ?n1 - r ?m1\\<parallel>\\<^sup>2\n  < 2 * (1 / (real ?n1 + 1) + 1 / (real ?m1 + 1))\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n m.\n          N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n          \\<parallel>r n - r m\\<parallel>\\<^sup>2 < \\<epsilon>\\<^sup>2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        \\<parallel>r n - r m\\<parallel>\\<^sup>2\n        < 2 * (1 / (real n + 1) + 1 / (real m + 1))) \\<Longrightarrow>\n    \\<exists>N.\n       \\<forall>n m.\n          N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n          \\<parallel>r n - r m\\<parallel>\\<^sup>2 < \\<epsilon>\\<^sup>2", "obtain N::nat where \\<open>1/(N + 1) < \\<epsilon>^2/4\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N.\n        1 / real (N + 1) < \\<epsilon>\\<^sup>2 / 4 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using LIMSEQ_ignore_initial_segment[OF lim_inverse_n', where k=1]"], ["proof (prove)\nusing this:\n  (\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        1 / real (N + 1) < \\<epsilon>\\<^sup>2 / 4 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_eq_plus1 \\<open>0 < \\<epsilon>\\<close> nat_approx_posE zero_less_divide_iff zero_less_numeral \n          zero_less_power )"], ["proof (state)\nthis:\n  1 / real (N + 1) < \\<epsilon>\\<^sup>2 / 4\n\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        \\<parallel>r n - r m\\<parallel>\\<^sup>2\n        < 2 * (1 / (real n + 1) + 1 / (real m + 1))) \\<Longrightarrow>\n    \\<exists>N.\n       \\<forall>n m.\n          N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n          \\<parallel>r n - r m\\<parallel>\\<^sup>2 < \\<epsilon>\\<^sup>2", "hence \\<open>4/(N + 1) < \\<epsilon>^2\\<close>"], ["proof (prove)\nusing this:\n  1 / real (N + 1) < \\<epsilon>\\<^sup>2 / 4\n\ngoal (1 subgoal):\n 1. 4 / real (N + 1) < \\<epsilon>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  4 / real (N + 1) < \\<epsilon>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        \\<parallel>r n - r m\\<parallel>\\<^sup>2\n        < 2 * (1 / (real n + 1) + 1 / (real m + 1))) \\<Longrightarrow>\n    \\<exists>N.\n       \\<forall>n m.\n          N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n          \\<parallel>r n - r m\\<parallel>\\<^sup>2 < \\<epsilon>\\<^sup>2", "have \"2*(1/(n+1) + 1/(m+1)) < \\<epsilon>^2\"\n      if f1: \"n \\<ge> N\" and f2: \"m \\<ge> N\" \n      for m n::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (1 / real (n + 1) + 1 / real (m + 1)) < \\<epsilon>\\<^sup>2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * (1 / real (n + 1) + 1 / real (m + 1)) < \\<epsilon>\\<^sup>2", "have \\<open>1/(n+1) \\<le> 1/(N+1)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / real (n + 1) \\<le> 1 / real (N + 1)", "by (simp add: f1 linordered_field_class.frac_le)"], ["proof (state)\nthis:\n  1 / real (n + 1) \\<le> 1 / real (N + 1)\n\ngoal (1 subgoal):\n 1. 2 * (1 / real (n + 1) + 1 / real (m + 1)) < \\<epsilon>\\<^sup>2", "moreover"], ["proof (state)\nthis:\n  1 / real (n + 1) \\<le> 1 / real (N + 1)\n\ngoal (1 subgoal):\n 1. 2 * (1 / real (n + 1) + 1 / real (m + 1)) < \\<epsilon>\\<^sup>2", "have \\<open>1/(m+1) \\<le> 1/(N+1)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / real (m + 1) \\<le> 1 / real (N + 1)", "by (simp add: f2 linordered_field_class.frac_le)"], ["proof (state)\nthis:\n  1 / real (m + 1) \\<le> 1 / real (N + 1)\n\ngoal (1 subgoal):\n 1. 2 * (1 / real (n + 1) + 1 / real (m + 1)) < \\<epsilon>\\<^sup>2", "ultimately"], ["proof (chain)\npicking this:\n  1 / real (n + 1) \\<le> 1 / real (N + 1)\n  1 / real (m + 1) \\<le> 1 / real (N + 1)", "have  \\<open>2*(1/(n+1) + 1/(m+1)) \\<le> 4/(N+1)\\<close>"], ["proof (prove)\nusing this:\n  1 / real (n + 1) \\<le> 1 / real (N + 1)\n  1 / real (m + 1) \\<le> 1 / real (N + 1)\n\ngoal (1 subgoal):\n 1. 2 * (1 / real (n + 1) + 1 / real (m + 1)) \\<le> 4 / real (N + 1)", "by simp"], ["proof (state)\nthis:\n  2 * (1 / real (n + 1) + 1 / real (m + 1)) \\<le> 4 / real (N + 1)\n\ngoal (1 subgoal):\n 1. 2 * (1 / real (n + 1) + 1 / real (m + 1)) < \\<epsilon>\\<^sup>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 * (1 / real (n + 1) + 1 / real (m + 1)) \\<le> 4 / real (N + 1)\n\ngoal (1 subgoal):\n 1. 2 * (1 / real (n + 1) + 1 / real (m + 1)) < \\<epsilon>\\<^sup>2", "using \\<open>4/(N + 1) < \\<epsilon>^2\\<close>"], ["proof (prove)\nusing this:\n  2 * (1 / real (n + 1) + 1 / real (m + 1)) \\<le> 4 / real (N + 1)\n  4 / real (N + 1) < \\<epsilon>\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 * (1 / real (n + 1) + 1 / real (m + 1)) < \\<epsilon>\\<^sup>2", "by linarith"], ["proof (state)\nthis:\n  2 * (1 / real (n + 1) + 1 / real (m + 1)) < \\<epsilon>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n1; N \\<le> ?m1\\<rbrakk>\n  \\<Longrightarrow> 2 * (1 / real (?n1 + 1) + 1 / real (?m1 + 1))\n                    < \\<epsilon>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        \\<parallel>r n - r m\\<parallel>\\<^sup>2\n        < 2 * (1 / (real n + 1) + 1 / (real m + 1))) \\<Longrightarrow>\n    \\<exists>N.\n       \\<forall>n m.\n          N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n          \\<parallel>r n - r m\\<parallel>\\<^sup>2 < \\<epsilon>\\<^sup>2", "hence \"\\<parallel> (r n) - (r m) \\<parallel>^2 < \\<epsilon>^2\"\n      if y1: \"n \\<ge> N\" and y2: \"m \\<ge> N\" \n      for m n::nat"], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?n1; N \\<le> ?m1\\<rbrakk>\n  \\<Longrightarrow> 2 * (1 / real (?n1 + 1) + 1 / real (?m1 + 1))\n                    < \\<epsilon>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2 < \\<epsilon>\\<^sup>2", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?n1; N \\<le> ?m1\\<rbrakk>\n  \\<Longrightarrow> 2 * (1 / real (?n1 + 1) + 1 / real (?m1 + 1))\n                    < \\<epsilon>\\<^sup>2\n  N \\<le> n\n  N \\<le> m\n\ngoal (1 subgoal):\n 1. \\<parallel>r n - r m\\<parallel>\\<^sup>2 < \\<epsilon>\\<^sup>2", "by (smt \\<open>\\<And>n m. \\<parallel>r n - r m\\<parallel>\\<^sup>2 < 2 * (1 / (real n + 1) + 1 / (real m + 1))\\<close> of_nat_1 of_nat_add)"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n1; N \\<le> ?m1\\<rbrakk>\n  \\<Longrightarrow> \\<parallel>r ?n1 - r ?m1\\<parallel>\\<^sup>2\n                    < \\<epsilon>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        \\<parallel>r n - r m\\<parallel>\\<^sup>2\n        < 2 * (1 / (real n + 1) + 1 / (real m + 1))) \\<Longrightarrow>\n    \\<exists>N.\n       \\<forall>n m.\n          N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n          \\<parallel>r n - r m\\<parallel>\\<^sup>2 < \\<epsilon>\\<^sup>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?n1; N \\<le> ?m1\\<rbrakk>\n  \\<Longrightarrow> \\<parallel>r ?n1 - r ?m1\\<parallel>\\<^sup>2\n                    < \\<epsilon>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n m.\n          N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n          \\<parallel>r n - r m\\<parallel>\\<^sup>2 < \\<epsilon>\\<^sup>2", "by blast"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n m.\n        N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n        \\<parallel>r n - r m\\<parallel>\\<^sup>2 < \\<epsilon>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?\\<epsilon>1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n m.\n        N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n        \\<parallel>r n - r m\\<parallel>\\<^sup>2 < ?\\<epsilon>1\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "hence  \\<open>\\<forall> \\<epsilon> > 0. \\<exists> N::nat. \\<forall> n m::nat. n \\<ge> N \\<and> m \\<ge> N \\<longrightarrow> \\<parallel> (r n) - (r m) \\<parallel>^2 < \\<epsilon>^2\\<close>"], ["proof (prove)\nusing this:\n  0 < ?\\<epsilon>1 \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>n m.\n        N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n        \\<parallel>r n - r m\\<parallel>\\<^sup>2 < ?\\<epsilon>1\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>>0.\n       \\<exists>N.\n          \\<forall>n m.\n             N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n             \\<parallel>r n - r m\\<parallel>\\<^sup>2 < \\<epsilon>\\<^sup>2", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<epsilon>>0.\n     \\<exists>N.\n        \\<forall>n m.\n           N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n           \\<parallel>r n - r m\\<parallel>\\<^sup>2 < \\<epsilon>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "hence  \\<open>\\<forall> \\<epsilon> > 0. \\<exists> N::nat. \\<forall> n m::nat. n \\<ge> N \\<and> m \\<ge> N \\<longrightarrow> \\<parallel> (r n) - (r m) \\<parallel> < \\<epsilon>\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>\\<epsilon>>0.\n     \\<exists>N.\n        \\<forall>n m.\n           N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n           \\<parallel>r n - r m\\<parallel>\\<^sup>2 < \\<epsilon>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<forall>\\<epsilon>>0.\n       \\<exists>N.\n          \\<forall>n m.\n             N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n             \\<parallel>r n - r m\\<parallel> < \\<epsilon>", "by (meson less_eq_real_def power_less_imp_less_base)"], ["proof (state)\nthis:\n  \\<forall>\\<epsilon>>0.\n     \\<exists>N.\n        \\<forall>n m.\n           N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n           \\<parallel>r n - r m\\<parallel> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "hence \\<open>Cauchy r\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>\\<epsilon>>0.\n     \\<exists>N.\n        \\<forall>n m.\n           N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n           \\<parallel>r n - r m\\<parallel> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. Cauchy r", "using CauchyI"], ["proof (prove)\nusing this:\n  \\<forall>\\<epsilon>>0.\n     \\<exists>N.\n        \\<forall>n m.\n           N \\<le> n \\<and> N \\<le> m \\<longrightarrow>\n           \\<parallel>r n - r m\\<parallel> < \\<epsilon>\n  (\\<And>e.\n      0 < e \\<Longrightarrow>\n      \\<exists>M.\n         \\<forall>m\\<ge>M.\n            \\<forall>n\\<ge>M.\n               \\<parallel>?X m - ?X n\\<parallel> < e) \\<Longrightarrow>\n  Cauchy ?X\n\ngoal (1 subgoal):\n 1. Cauchy r", "by fastforce"], ["proof (state)\nthis:\n  Cauchy r\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "then"], ["proof (chain)\npicking this:\n  Cauchy r", "obtain k where \\<open>r \\<longlonglongrightarrow> k\\<close>"], ["proof (prove)\nusing this:\n  Cauchy r\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        r \\<longlonglongrightarrow> k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using  convergent_eq_Cauchy"], ["proof (prove)\nusing this:\n  Cauchy r\n  (\\<exists>l. ?S \\<longlonglongrightarrow> l) = Cauchy ?S\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        r \\<longlonglongrightarrow> k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r \\<longlonglongrightarrow> k\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "have \\<open>k \\<in> M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> M", "using \\<open>closed M\\<close>"], ["proof (prove)\nusing this:\n  closed M\n\ngoal (1 subgoal):\n 1. k \\<in> M", "using \\<open>\\<forall>n. r n \\<in> M\\<close> \\<open>r \\<longlonglongrightarrow> k\\<close> closed_sequentially"], ["proof (prove)\nusing this:\n  closed M\n  \\<forall>n. r n \\<in> M\n  r \\<longlonglongrightarrow> k\n  \\<lbrakk>closed ?s; \\<forall>n. ?f n \\<in> ?s;\n   ?f \\<longlonglongrightarrow> ?l\\<rbrakk>\n  \\<Longrightarrow> ?l \\<in> ?s\n\ngoal (1 subgoal):\n 1. k \\<in> M", "by auto"], ["proof (state)\nthis:\n  k \\<in> M\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "have  \\<open>(\\<lambda> n.  \\<parallel> r n \\<parallel>^2) \\<longlonglongrightarrow>  \\<parallel> k \\<parallel>^2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n    \\<longlonglongrightarrow> \\<parallel>k\\<parallel>\\<^sup>2", "by (simp add: \\<open>r \\<longlonglongrightarrow> k\\<close> tendsto_norm tendsto_power)"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n  \\<longlonglongrightarrow> \\<parallel>k\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n  \\<longlonglongrightarrow> \\<parallel>k\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "have  \\<open>(\\<lambda> n.  \\<parallel> r n \\<parallel>^2) \\<longlonglongrightarrow>  d\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n    \\<longlonglongrightarrow> d", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n    \\<longlonglongrightarrow> d", "have \\<open>\\<bar>\\<parallel> r n \\<parallel>^2 - d\\<bar> < 1/(n+1)\\<close> for n :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<parallel>r n\\<parallel>\\<^sup>2 - d\\<bar> < 1 / real (n + 1)", "using \\<open>\\<And>x. x \\<in> M \\<Longrightarrow> d \\<le> \\<parallel>x\\<parallel>\\<^sup>2\\<close> \\<open>\\<forall>n. r n \\<in> M \\<and> \\<parallel>r n\\<parallel>\\<^sup>2 < d + 1 / (real n + 1)\\<close> of_nat_1 of_nat_add"], ["proof (prove)\nusing this:\n  ?x \\<in> M \\<Longrightarrow> d \\<le> \\<parallel>?x\\<parallel>\\<^sup>2\n  \\<forall>n.\n     r n \\<in> M \\<and>\n     \\<parallel>r n\\<parallel>\\<^sup>2 < d + 1 / (real n + 1)\n  of_nat 1 = (1::?'a)\n  of_nat (?m + ?n) = of_nat ?m + of_nat ?n\n\ngoal (1 subgoal):\n 1. \\<bar>\\<parallel>r n\\<parallel>\\<^sup>2 - d\\<bar> < 1 / real (n + 1)", "by smt"], ["proof (state)\nthis:\n  \\<bar>\\<parallel>r ?n1\\<parallel>\\<^sup>2 - d\\<bar> < 1 / real (?n1 + 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n    \\<longlonglongrightarrow> d", "moreover"], ["proof (state)\nthis:\n  \\<bar>\\<parallel>r ?n1\\<parallel>\\<^sup>2 - d\\<bar> < 1 / real (?n1 + 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n    \\<longlonglongrightarrow> d", "have \\<open>(\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0", "using  LIMSEQ_ignore_initial_segment[OF lim_inverse_n', where k=1]"], ["proof (prove)\nusing this:\n  (\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n    \\<longlonglongrightarrow> d", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>\\<parallel>r ?n1\\<parallel>\\<^sup>2 - d\\<bar> < 1 / real (?n1 + 1)\n  (\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0", "have \\<open>(\\<lambda> n. \\<bar>\\<parallel> r n \\<parallel>^2 - d\\<bar> ) \\<longlonglongrightarrow> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>\\<parallel>r ?n1\\<parallel>\\<^sup>2 - d\\<bar> < 1 / real (?n1 + 1)\n  (\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<bar>\\<parallel>r n\\<parallel>\\<^sup>2 - d\\<bar>)\n    \\<longlonglongrightarrow> 0", "by (simp add: LIMSEQ_norm_0)"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<bar>\\<parallel>r n\\<parallel>\\<^sup>2 - d\\<bar>)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n    \\<longlonglongrightarrow> d", "hence \\<open>(\\<lambda> n. \\<parallel> r n \\<parallel>^2 - d ) \\<longlonglongrightarrow> 0\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<bar>\\<parallel>r n\\<parallel>\\<^sup>2 - d\\<bar>)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2 - d)\n    \\<longlonglongrightarrow> 0", "by (simp add: tendsto_rabs_zero_iff)"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2 - d)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n    \\<longlonglongrightarrow> d", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2 - d)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n    \\<longlonglongrightarrow> d", "have \\<open>(\\<lambda> n. d ) \\<longlonglongrightarrow> d\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. d) \\<longlonglongrightarrow> d", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. d) \\<longlonglongrightarrow> d\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n    \\<longlonglongrightarrow> d", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2 - d)\n  \\<longlonglongrightarrow> 0\n  (\\<lambda>n. d) \\<longlonglongrightarrow> d", "have \\<open>(\\<lambda> n. (\\<parallel> r n \\<parallel>^2 - d)+d ) \\<longlonglongrightarrow> 0+d\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2 - d)\n  \\<longlonglongrightarrow> 0\n  (\\<lambda>n. d) \\<longlonglongrightarrow> d\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2 - d + d)\n    \\<longlonglongrightarrow> 0 + d", "using tendsto_add"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2 - d)\n  \\<longlonglongrightarrow> 0\n  (\\<lambda>n. d) \\<longlonglongrightarrow> d\n  \\<lbrakk>(?f \\<longlongrightarrow> ?a) ?F;\n   (?g \\<longlongrightarrow> ?b) ?F\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. ?f x + ?g x) \\<longlongrightarrow>\n                     ?a + ?b)\n                     ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2 - d + d)\n    \\<longlonglongrightarrow> 0 + d", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2 - d + d)\n  \\<longlonglongrightarrow> 0 + d\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n    \\<longlonglongrightarrow> d", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2 - d + d)\n  \\<longlonglongrightarrow> 0 + d\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n    \\<longlonglongrightarrow> d", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n  \\<longlonglongrightarrow> d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n  \\<longlonglongrightarrow> d\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n  \\<longlonglongrightarrow> \\<parallel>k\\<parallel>\\<^sup>2\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n  \\<longlonglongrightarrow> d", "have \\<open>d = \\<parallel> k \\<parallel>^2\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n  \\<longlonglongrightarrow> \\<parallel>k\\<parallel>\\<^sup>2\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n  \\<longlonglongrightarrow> d\n\ngoal (1 subgoal):\n 1. d = \\<parallel>k\\<parallel>\\<^sup>2", "using LIMSEQ_unique"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n  \\<longlonglongrightarrow> \\<parallel>k\\<parallel>\\<^sup>2\n  (\\<lambda>n. \\<parallel>r n\\<parallel>\\<^sup>2)\n  \\<longlonglongrightarrow> d\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?a;\n   ?X \\<longlonglongrightarrow> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. d = \\<parallel>k\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  d = \\<parallel>k\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "hence \\<open>t \\<in> M \\<Longrightarrow> \\<parallel> k \\<parallel>^2 \\<le> \\<parallel> t \\<parallel>^2\\<close> for t"], ["proof (prove)\nusing this:\n  d = \\<parallel>k\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. t \\<in> M \\<Longrightarrow>\n    \\<parallel>k\\<parallel>\\<^sup>2 \\<le> \\<parallel>t\\<parallel>\\<^sup>2", "using \\<open>\\<And>x. x \\<in> M \\<Longrightarrow> d \\<le> \\<parallel>x\\<parallel>\\<^sup>2\\<close>"], ["proof (prove)\nusing this:\n  d = \\<parallel>k\\<parallel>\\<^sup>2\n  ?x \\<in> M \\<Longrightarrow> d \\<le> \\<parallel>?x\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. t \\<in> M \\<Longrightarrow>\n    \\<parallel>k\\<parallel>\\<^sup>2 \\<le> \\<parallel>t\\<parallel>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  ?t1 \\<in> M \\<Longrightarrow>\n  \\<parallel>k\\<parallel>\\<^sup>2 \\<le> \\<parallel>?t1\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "hence q1: \\<open>\\<exists> k. is_arg_min (\\<lambda> x. \\<parallel>x\\<parallel>^2) (\\<lambda> t. t \\<in> M) k\\<close>"], ["proof (prove)\nusing this:\n  ?t1 \\<in> M \\<Longrightarrow>\n  \\<parallel>k\\<parallel>\\<^sup>2 \\<le> \\<parallel>?t1\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       is_arg_min (\\<lambda>x. \\<parallel>x\\<parallel>\\<^sup>2)\n        (\\<lambda>t. t \\<in> M) k", "using \\<open>k \\<in> M\\<close>\n      is_arg_min_def \\<open>d = \\<parallel>k\\<parallel>\\<^sup>2\\<close>"], ["proof (prove)\nusing this:\n  ?t1 \\<in> M \\<Longrightarrow>\n  \\<parallel>k\\<parallel>\\<^sup>2 \\<le> \\<parallel>?t1\\<parallel>\\<^sup>2\n  k \\<in> M\n  is_arg_min ?f ?P ?x =\n  (?P ?x \\<and> (\\<nexists>y. ?P y \\<and> ?f y < ?f ?x))\n  d = \\<parallel>k\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       is_arg_min (\\<lambda>x. \\<parallel>x\\<parallel>\\<^sup>2)\n        (\\<lambda>t. t \\<in> M) k", "by smt"], ["proof (state)\nthis:\n  \\<exists>k.\n     is_arg_min (\\<lambda>x. \\<parallel>x\\<parallel>\\<^sup>2)\n      (\\<lambda>t. t \\<in> M) k\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "thus \\<open>\\<exists> k. is_arg_min (\\<lambda> x. \\<parallel>x\\<parallel>) (\\<lambda> t. t \\<in> M) k\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     is_arg_min (\\<lambda>x. \\<parallel>x\\<parallel>\\<^sup>2)\n      (\\<lambda>t. t \\<in> M) k\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k", "by (smt is_arg_min_def norm_ge_zero power2_eq_square power2_le_imp_le)"], ["proof (state)\nthis:\n  \\<exists>k. is_arg_min norm (\\<lambda>t. t \\<in> M) k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smallest_norm_unique:\n  \\<comment> \\<open>Theorem 2.5 in @{cite conway2013course} (inside the proof)\\<close>\n  includes notation_norm\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes q1: \\<open>convex M\\<close>\n  assumes r: \\<open>is_arg_min (\\<lambda> x. \\<parallel>x\\<parallel>) (\\<lambda> t. t \\<in> M) r\\<close>\n  assumes s: \\<open>is_arg_min (\\<lambda> x. \\<parallel>x\\<parallel>) (\\<lambda> t. t \\<in> M) s\\<close>\n  shows \\<open>r = s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. r = s", "have \\<open>r \\<in> M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> M", "using \\<open>is_arg_min (\\<lambda>x. \\<parallel>x\\<parallel>) (\\<lambda> t. t \\<in> M) r\\<close>"], ["proof (prove)\nusing this:\n  is_arg_min norm (\\<lambda>t. t \\<in> M) r\n\ngoal (1 subgoal):\n 1. r \\<in> M", "by (simp add: is_arg_min_def)"], ["proof (state)\nthis:\n  r \\<in> M\n\ngoal (1 subgoal):\n 1. r = s", "moreover"], ["proof (state)\nthis:\n  r \\<in> M\n\ngoal (1 subgoal):\n 1. r = s", "have \\<open>s \\<in> M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> M", "using \\<open>is_arg_min (\\<lambda>x. \\<parallel>x\\<parallel>) (\\<lambda> t. t \\<in> M) s\\<close>"], ["proof (prove)\nusing this:\n  is_arg_min norm (\\<lambda>t. t \\<in> M) s\n\ngoal (1 subgoal):\n 1. s \\<in> M", "by (simp add: is_arg_min_def)"], ["proof (state)\nthis:\n  s \\<in> M\n\ngoal (1 subgoal):\n 1. r = s", "ultimately"], ["proof (chain)\npicking this:\n  r \\<in> M\n  s \\<in> M", "have \\<open>((1/2) *\\<^sub>R r + (1/2) *\\<^sub>R s) \\<in> M\\<close>"], ["proof (prove)\nusing this:\n  r \\<in> M\n  s \\<in> M\n\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>R r + (1 / 2) *\\<^sub>R s \\<in> M", "using \\<open>convex M\\<close>"], ["proof (prove)\nusing this:\n  r \\<in> M\n  s \\<in> M\n  convex M\n\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>R r + (1 / 2) *\\<^sub>R s \\<in> M", "by (simp add: convexD)"], ["proof (state)\nthis:\n  (1 / 2) *\\<^sub>R r + (1 / 2) *\\<^sub>R s \\<in> M\n\ngoal (1 subgoal):\n 1. r = s", "hence \\<open>\\<parallel>r\\<parallel> \\<le> \\<parallel> (1/2) *\\<^sub>R r + (1/2) *\\<^sub>R s \\<parallel>\\<close>"], ["proof (prove)\nusing this:\n  (1 / 2) *\\<^sub>R r + (1 / 2) *\\<^sub>R s \\<in> M\n\ngoal (1 subgoal):\n 1. \\<parallel>r\\<parallel>\n    \\<le> \\<parallel>(1 / 2) *\\<^sub>R r + (1 / 2) *\\<^sub>R s\\<parallel>", "by (metis is_arg_min_linorder r)"], ["proof (state)\nthis:\n  \\<parallel>r\\<parallel>\n  \\<le> \\<parallel>(1 / 2) *\\<^sub>R r + (1 / 2) *\\<^sub>R s\\<parallel>\n\ngoal (1 subgoal):\n 1. r = s", "hence u2: \\<open>\\<parallel>r\\<parallel>^2 \\<le> \\<parallel> (1/2) *\\<^sub>R r + (1/2) *\\<^sub>R s \\<parallel>^2\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>r\\<parallel>\n  \\<le> \\<parallel>(1 / 2) *\\<^sub>R r + (1 / 2) *\\<^sub>R s\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<parallel>r\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>(1 / 2) *\\<^sub>R r +\n                     (1 / 2) *\\<^sub>R s\\<parallel>\\<^sup>2", "using norm_ge_zero power_mono"], ["proof (prove)\nusing this:\n  \\<parallel>r\\<parallel>\n  \\<le> \\<parallel>(1 / 2) *\\<^sub>R r + (1 / 2) *\\<^sub>R s\\<parallel>\n  0 \\<le> \\<parallel>?x\\<parallel>\n  \\<lbrakk>?a \\<le> ?b; (0::?'a) \\<le> ?a\\<rbrakk>\n  \\<Longrightarrow> ?a ^ ?n \\<le> ?b ^ ?n\n\ngoal (1 subgoal):\n 1. \\<parallel>r\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>(1 / 2) *\\<^sub>R r +\n                     (1 / 2) *\\<^sub>R s\\<parallel>\\<^sup>2", "by blast"], ["proof (state)\nthis:\n  \\<parallel>r\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>(1 / 2) *\\<^sub>R r +\n                   (1 / 2) *\\<^sub>R s\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. r = s", "have \\<open>\\<parallel>r\\<parallel> \\<le> \\<parallel>s\\<parallel>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>r\\<parallel> \\<le> \\<parallel>s\\<parallel>", "using r s is_arg_min_def"], ["proof (prove)\nusing this:\n  is_arg_min norm (\\<lambda>t. t \\<in> M) r\n  is_arg_min norm (\\<lambda>t. t \\<in> M) s\n  is_arg_min ?f ?P ?x =\n  (?P ?x \\<and> (\\<nexists>y. ?P y \\<and> ?f y < ?f ?x))\n\ngoal (1 subgoal):\n 1. \\<parallel>r\\<parallel> \\<le> \\<parallel>s\\<parallel>", "by (metis is_arg_min_linorder)"], ["proof (state)\nthis:\n  \\<parallel>r\\<parallel> \\<le> \\<parallel>s\\<parallel>\n\ngoal (1 subgoal):\n 1. r = s", "moreover"], ["proof (state)\nthis:\n  \\<parallel>r\\<parallel> \\<le> \\<parallel>s\\<parallel>\n\ngoal (1 subgoal):\n 1. r = s", "have \\<open>\\<parallel>s\\<parallel> \\<le> \\<parallel>r\\<parallel>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>s\\<parallel> \\<le> \\<parallel>r\\<parallel>", "using r s is_arg_min_def"], ["proof (prove)\nusing this:\n  is_arg_min norm (\\<lambda>t. t \\<in> M) r\n  is_arg_min norm (\\<lambda>t. t \\<in> M) s\n  is_arg_min ?f ?P ?x =\n  (?P ?x \\<and> (\\<nexists>y. ?P y \\<and> ?f y < ?f ?x))\n\ngoal (1 subgoal):\n 1. \\<parallel>s\\<parallel> \\<le> \\<parallel>r\\<parallel>", "by (metis is_arg_min_linorder)"], ["proof (state)\nthis:\n  \\<parallel>s\\<parallel> \\<le> \\<parallel>r\\<parallel>\n\ngoal (1 subgoal):\n 1. r = s", "ultimately"], ["proof (chain)\npicking this:\n  \\<parallel>r\\<parallel> \\<le> \\<parallel>s\\<parallel>\n  \\<parallel>s\\<parallel> \\<le> \\<parallel>r\\<parallel>", "have u3: \\<open>\\<parallel>r\\<parallel> = \\<parallel>s\\<parallel>\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>r\\<parallel> \\<le> \\<parallel>s\\<parallel>\n  \\<parallel>s\\<parallel> \\<le> \\<parallel>r\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<parallel>r\\<parallel> = \\<parallel>s\\<parallel>", "by simp"], ["proof (state)\nthis:\n  \\<parallel>r\\<parallel> = \\<parallel>s\\<parallel>\n\ngoal (1 subgoal):\n 1. r = s", "have \\<open>\\<parallel> (1/2) *\\<^sub>R r - (1/2) *\\<^sub>R s \\<parallel>^2 \\<le> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>(1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s\\<parallel>\\<^sup>2\n    \\<le> 0", "using u2 u3 parallelogram_law"], ["proof (prove)\nusing this:\n  \\<parallel>r\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>(1 / 2) *\\<^sub>R r +\n                   (1 / 2) *\\<^sub>R s\\<parallel>\\<^sup>2\n  \\<parallel>r\\<parallel> = \\<parallel>s\\<parallel>\n  \\<parallel>?x + ?y\\<parallel>\\<^sup>2 +\n  \\<parallel>?x - ?y\\<parallel>\\<^sup>2 =\n  2 * (\\<parallel>?x\\<parallel>\\<^sup>2 + \\<parallel>?y\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<parallel>(1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s\\<parallel>\\<^sup>2\n    \\<le> 0", "by (smt (verit, ccfv_SIG) polar_identity_minus power2_norm_eq_cinner' scaleR_add_right scaleR_half_double)"], ["proof (state)\nthis:\n  \\<parallel>(1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s\\<parallel>\\<^sup>2\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. r = s", "hence \\<open>\\<parallel> (1/2) *\\<^sub>R r - (1/2) *\\<^sub>R s \\<parallel>^2 = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>(1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s\\<parallel>\\<^sup>2\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<parallel>(1 / 2) *\\<^sub>R r -\n               (1 / 2) *\\<^sub>R s\\<parallel>\\<^sup>2 =\n    0", "by simp"], ["proof (state)\nthis:\n  \\<parallel>(1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s\\<parallel>\\<^sup>2 =\n  0\n\ngoal (1 subgoal):\n 1. r = s", "hence \\<open>\\<parallel> (1/2) *\\<^sub>R r - (1/2) *\\<^sub>R s \\<parallel> = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>(1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s\\<parallel>\\<^sup>2 =\n  0\n\ngoal (1 subgoal):\n 1. \\<parallel>(1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s\\<parallel> = 0", "by auto"], ["proof (state)\nthis:\n  \\<parallel>(1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s\\<parallel> = 0\n\ngoal (1 subgoal):\n 1. r = s", "hence \\<open>(1/2) *\\<^sub>R r - (1/2) *\\<^sub>R s = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>(1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s\\<parallel> = 0\n\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s = (0::'a)", "using norm_eq_zero"], ["proof (prove)\nusing this:\n  \\<parallel>(1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s\\<parallel> = 0\n  (\\<parallel>?x\\<parallel> = 0) = (?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s = (0::'a)", "by blast"], ["proof (state)\nthis:\n  (1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s = (0::'a)\n\ngoal (1 subgoal):\n 1. r = s", "thus ?thesis"], ["proof (prove)\nusing this:\n  (1 / 2) *\\<^sub>R r - (1 / 2) *\\<^sub>R s = (0::'a)\n\ngoal (1 subgoal):\n 1. r = s", "by simp"], ["proof (state)\nthis:\n  r = s\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem smallest_dist_exists:\n  \\<comment> \\<open>Theorem 2.5 in @{cite conway2013course}\\<close> \n  fixes M::\\<open>'a::chilbert_space set\\<close> and h \n  assumes a1: \\<open>convex M\\<close> and a2: \\<open>closed M\\<close> and a3: \\<open>M \\<noteq> {}\\<close>\n  shows  \\<open>\\<exists>k. is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) k\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k", "have *: \"is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x\\<in>M) (k+h) \\<longleftrightarrow> is_arg_min (\\<lambda>x. norm x) (\\<lambda>x. x\\<in>(\\<lambda>x. x-h) ` M) k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) (k + h) =\n    is_arg_min norm (\\<lambda>x. x \\<in> (\\<lambda>x. x - h) ` M) k", "unfolding dist_norm is_arg_min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k + h \\<in> M \\<and>\n     (\\<nexists>y. y \\<in> M \\<and> norm (y - h) < norm (k + h - h))) =\n    (k \\<in> (\\<lambda>x. x - h) ` M \\<and>\n     (\\<nexists>y. y \\<in> (\\<lambda>x. x - h) ` M \\<and> norm y < norm k))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k + h \\<in> M;\n     \\<forall>y.\n        y \\<in> M \\<longrightarrow> \\<not> norm (y - h) < norm k\\<rbrakk>\n    \\<Longrightarrow> k \\<in> (\\<lambda>x. x - h) ` M", "using add_implies_diff"], ["proof (prove)\nusing this:\n  ?c + ?b = ?a \\<Longrightarrow> ?c = ?a - ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k + h \\<in> M;\n     \\<forall>y.\n        y \\<in> M \\<longrightarrow> \\<not> norm (y - h) < norm k\\<rbrakk>\n    \\<Longrightarrow> k \\<in> (\\<lambda>x. x - h) ` M", "by blast"], ["proof (state)\nthis:\n  is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) (?k + h) =\n  is_arg_min norm (\\<lambda>x. x \\<in> (\\<lambda>x. x - h) ` M) ?k\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k", "have \\<open>\\<exists>k. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x\\<in>M) (k+h)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) (k + h)", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex (is_arg_min norm (\\<lambda>x. x \\<in> (\\<lambda>x. x - h) ` M))", "apply (rule smallest_norm_exists)"], ["proof (prove)\ngoal (3 subgoals):\n 1. convex ((\\<lambda>x. x - h) ` M)\n 2. closed ((\\<lambda>x. x - h) ` M)\n 3. (\\<lambda>x. x - h) ` M \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  convex M\n  closed M\n  M \\<noteq> {}\n\ngoal (3 subgoals):\n 1. convex ((\\<lambda>x. x - h) ` M)\n 2. closed ((\\<lambda>x. x - h) ` M)\n 3. (\\<lambda>x. x - h) ` M \\<noteq> {}", "by (auto simp: closed_translation_subtract)"], ["proof (state)\nthis:\n  \\<exists>k.\n     is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) (k + h)\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k", "then"], ["proof (chain)\npicking this:\n  \\<exists>k.\n     is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) (k + h)", "show \\<open>\\<exists>k. is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) k\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>k.\n     is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) (k + h)\n\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k", "by metis"], ["proof (state)\nthis:\n  \\<exists>k. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem smallest_dist_unique:\n  \\<comment> \\<open>Theorem 2.5 in @{cite conway2013course}\\<close> \n  fixes M::\\<open>'a::complex_inner set\\<close> and h \n  assumes a1: \\<open>convex M\\<close>\n  assumes \\<open>is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) r\\<close>\n  assumes \\<open>is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) s\\<close>\n  shows  \\<open>r = s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = s", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. r = s", "have *: \"is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x\\<in>M) k \\<longleftrightarrow> is_arg_min (\\<lambda>x. norm x) (\\<lambda>x. x\\<in>(\\<lambda>x. x-h) ` M) (k-h)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n    is_arg_min norm (\\<lambda>x. x \\<in> (\\<lambda>x. x - h) ` M) (k - h)", "unfolding dist_norm is_arg_min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<in> M \\<and>\n     (\\<nexists>y. y \\<in> M \\<and> norm (y - h) < norm (k - h))) =\n    (k - h \\<in> (\\<lambda>x. x - h) ` M \\<and>\n     (\\<nexists>y.\n         y \\<in> (\\<lambda>x. x - h) ` M \\<and> norm y < norm (k - h)))", "by auto"], ["proof (state)\nthis:\n  is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) ?k =\n  is_arg_min norm (\\<lambda>x. x \\<in> (\\<lambda>x. x - h) ` M) (?k - h)\n\ngoal (1 subgoal):\n 1. r = s", "have \\<open>r - h = s - h\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r - h = s - h", "using _ assms(2,3)[unfolded *]"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  is_arg_min norm (\\<lambda>x. x \\<in> (\\<lambda>x. x - h) ` M) (r - h)\n  is_arg_min norm (\\<lambda>x. x \\<in> (\\<lambda>x. x - h) ` M) (s - h)\n\ngoal (1 subgoal):\n 1. r - h = s - h", "apply (rule smallest_norm_unique)"], ["proof (prove)\ngoal (1 subgoal):\n 1. convex ((\\<lambda>x. x - h) ` M)", "by (simp add: a1)"], ["proof (state)\nthis:\n  r - h = s - h\n\ngoal (1 subgoal):\n 1. r = s", "thus \\<open>r = s\\<close>"], ["proof (prove)\nusing this:\n  r - h = s - h\n\ngoal (1 subgoal):\n 1. r = s", "by auto"], ["proof (state)\nthis:\n  r = s\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>Theorem 2.6 in @{cite conway2013course}\\<close>"], ["", "theorem smallest_dist_is_ortho:\n  fixes M::\\<open>'a::complex_inner set\\<close> and h k::'a \n  assumes b1: \\<open>closed_csubspace M\\<close>\n  shows  \\<open>(is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) k) \\<longleftrightarrow> \n          h - k \\<in> (orthogonal_complement M) \\<and> k \\<in> M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n    (h - k \\<in> orthogonal_complement M \\<and> k \\<in> M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n    (h - k \\<in> orthogonal_complement M \\<and> k \\<in> M)", "include notation_norm"], ["proof (state)\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n    (h - k \\<in> orthogonal_complement M \\<and> k \\<in> M)", "have  \\<open>csubspace M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace M", "using \\<open>closed_csubspace M\\<close>"], ["proof (prove)\nusing this:\n  closed_csubspace M\n\ngoal (1 subgoal):\n 1. csubspace M", "unfolding closed_csubspace_def"], ["proof (prove)\nusing this:\n  csubspace M \\<and> closed M\n\ngoal (1 subgoal):\n 1. csubspace M", "by blast"], ["proof (state)\nthis:\n  csubspace M\n\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n    (h - k \\<in> orthogonal_complement M \\<and> k \\<in> M)", "have r1: \\<open>2 * Re (\\<langle> h - k , f \\<rangle>) \\<le> \\<parallel> f \\<parallel>^2\\<close>\n    if \"f \\<in> M\" and \\<open>k \\<in> M\\<close> and \\<open>is_arg_min (\\<lambda>x. dist x h) (\\<lambda> x. x \\<in> M) k\\<close>\n    for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "have \\<open>k + f \\<in>  M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. k + f \\<in> M", "using \\<open>csubspace M\\<close>"], ["proof (prove)\nusing this:\n  csubspace M\n\ngoal (1 subgoal):\n 1. k + f \\<in> M", "by (simp add:complex_vector.subspace_add that)"], ["proof (state)\nthis:\n  k + f \\<in> M\n\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "have \"\\<forall>f A a b. \\<not> is_arg_min f (\\<lambda> x. x \\<in> A) (a::'a) \\<or> (f a::real) \\<le> f b \\<or> b \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f A a b.\n       \\<not> is_arg_min f (\\<lambda>x. x \\<in> A) a \\<or>\n       f a \\<le> f b \\<or> b \\<notin> A", "by (metis (no_types) is_arg_min_linorder)"], ["proof (state)\nthis:\n  \\<forall>f A a b.\n     \\<not> is_arg_min f (\\<lambda>x. x \\<in> A) a \\<or>\n     f a \\<le> f b \\<or> b \\<notin> A\n\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "hence \"dist k h \\<le> dist (f + k) h\""], ["proof (prove)\nusing this:\n  \\<forall>f A a b.\n     \\<not> is_arg_min f (\\<lambda>x. x \\<in> A) a \\<or>\n     f a \\<le> f b \\<or> b \\<notin> A\n\ngoal (1 subgoal):\n 1. dist k h \\<le> dist (f + k) h", "by (metis \\<open>is_arg_min (\\<lambda>x. dist x h) (\\<lambda> x. x \\<in> M) k\\<close> \\<open>k + f \\<in> M\\<close> add.commute)"], ["proof (state)\nthis:\n  dist k h \\<le> dist (f + k) h\n\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "hence \\<open>dist h k \\<le> dist  h (k + f)\\<close>"], ["proof (prove)\nusing this:\n  dist k h \\<le> dist (f + k) h\n\ngoal (1 subgoal):\n 1. dist h k \\<le> dist h (k + f)", "by (simp add: add.commute dist_commute)"], ["proof (state)\nthis:\n  dist h k \\<le> dist h (k + f)\n\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "hence \\<open>\\<parallel> h - k \\<parallel> \\<le> \\<parallel> h - (k + f) \\<parallel>\\<close>"], ["proof (prove)\nusing this:\n  dist h k \\<le> dist h (k + f)\n\ngoal (1 subgoal):\n 1. \\<parallel>h - k\\<parallel> \\<le> \\<parallel>h - (k + f)\\<parallel>", "by (simp add: dist_norm)"], ["proof (state)\nthis:\n  \\<parallel>h - k\\<parallel> \\<le> \\<parallel>h - (k + f)\\<parallel>\n\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "hence \\<open>\\<parallel> h - k \\<parallel>^2 \\<le> \\<parallel> h - (k + f) \\<parallel>^2\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>h - k\\<parallel> \\<le> \\<parallel>h - (k + f)\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<parallel>h - k\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>h - (k + f)\\<parallel>\\<^sup>2", "by (simp add: power_mono)"], ["proof (state)\nthis:\n  \\<parallel>h - k\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - (k + f)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>h - k\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - (k + f)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "have \\<open>... \\<le> \\<parallel> (h - k) - f \\<parallel>^2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>h - (k + f)\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>h - k - f\\<parallel>\\<^sup>2", "by (simp add: diff_diff_add)"], ["proof (state)\nthis:\n  \\<parallel>h - (k + f)\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - k - f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "also"], ["proof (state)\nthis:\n  \\<parallel>h - (k + f)\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - k - f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "have \\<open>... \\<le> \\<parallel> (h - k) \\<parallel>^2 + \\<parallel> f \\<parallel>^2 -  2 * Re (\\<langle> h - k , f \\<rangle>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>h - k - f\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>h - k\\<parallel>\\<^sup>2 +\n          \\<parallel>f\\<parallel>\\<^sup>2 -\n          2 * Re \\<langle>h - k, f\\<rangle>", "by (simp add: polar_identity_minus)"], ["proof (state)\nthis:\n  \\<parallel>h - k - f\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - k\\<parallel>\\<^sup>2 +\n        \\<parallel>f\\<parallel>\\<^sup>2 -\n        2 * Re \\<langle>h - k, f\\<rangle>\n\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>h - k\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - k\\<parallel>\\<^sup>2 +\n        \\<parallel>f\\<parallel>\\<^sup>2 -\n        2 * Re \\<langle>h - k, f\\<rangle>", "have \\<open>\\<parallel> (h - k) \\<parallel>^2 \\<le> \\<parallel> (h - k) \\<parallel>^2 + \\<parallel> f \\<parallel>^2 -  2 * Re (\\<langle> h - k , f \\<rangle>)\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>h - k\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - k\\<parallel>\\<^sup>2 +\n        \\<parallel>f\\<parallel>\\<^sup>2 -\n        2 * Re \\<langle>h - k, f\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<parallel>h - k\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>h - k\\<parallel>\\<^sup>2 +\n          \\<parallel>f\\<parallel>\\<^sup>2 -\n          2 * Re \\<langle>h - k, f\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<parallel>h - k\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - k\\<parallel>\\<^sup>2 +\n        \\<parallel>f\\<parallel>\\<^sup>2 -\n        2 * Re \\<langle>h - k, f\\<rangle>\n\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>h - k\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - k\\<parallel>\\<^sup>2 +\n        \\<parallel>f\\<parallel>\\<^sup>2 -\n        2 * Re \\<langle>h - k, f\\<rangle>\n\ngoal (1 subgoal):\n 1. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> M; k \\<in> M;\n   is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k\\<rbrakk>\n  \\<Longrightarrow> 2 * Re \\<langle>h - k, ?f\\<rangle>\n                    \\<le> \\<parallel>?f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n    (h - k \\<in> orthogonal_complement M \\<and> k \\<in> M)", "have q4: \\<open>\\<forall> c > 0.  2 * Re (\\<langle> h - k , f \\<rangle>) \\<le> c\\<close>\n    if  \\<open>\\<forall>c>0. 2 * Re (\\<langle>h - k , f\\<rangle> ) \\<le> c * \\<parallel>f\\<parallel>\\<^sup>2\\<close>\n    for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c", "proof (cases \\<open>\\<parallel> f \\<parallel>^2 > 0\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < \\<parallel>f\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c\n 2. \\<not> 0 < \\<parallel>f\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c", "case True"], ["proof (state)\nthis:\n  0 < \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. 0 < \\<parallel>f\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c\n 2. \\<not> 0 < \\<parallel>f\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c", "hence \\<open>\\<forall> c > 0.  2 * Re (\\<langle> h - k , f \\<rangle>) \\<le> (c/\\<parallel> f \\<parallel>^2)*\\<parallel> f \\<parallel>^2\\<close>"], ["proof (prove)\nusing this:\n  0 < \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<forall>c>0.\n       2 * Re \\<langle>h - k, f\\<rangle>\n       \\<le> c / \\<parallel>f\\<parallel>\\<^sup>2 *\n             \\<parallel>f\\<parallel>\\<^sup>2", "using that linordered_field_class.divide_pos_pos"], ["proof (prove)\nusing this:\n  0 < \\<parallel>f\\<parallel>\\<^sup>2\n  \\<forall>c>0.\n     2 * Re \\<langle>h - k, f\\<rangle>\n     \\<le> c * \\<parallel>f\\<parallel>\\<^sup>2\n  \\<lbrakk>(0::?'a) < ?x; (0::?'a) < ?y\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) < ?x / ?y\n\ngoal (1 subgoal):\n 1. \\<forall>c>0.\n       2 * Re \\<langle>h - k, f\\<rangle>\n       \\<le> c / \\<parallel>f\\<parallel>\\<^sup>2 *\n             \\<parallel>f\\<parallel>\\<^sup>2", "by blast"], ["proof (state)\nthis:\n  \\<forall>c>0.\n     2 * Re \\<langle>h - k, f\\<rangle>\n     \\<le> c / \\<parallel>f\\<parallel>\\<^sup>2 *\n           \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (2 subgoals):\n 1. 0 < \\<parallel>f\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c\n 2. \\<not> 0 < \\<parallel>f\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>c>0.\n     2 * Re \\<langle>h - k, f\\<rangle>\n     \\<le> c / \\<parallel>f\\<parallel>\\<^sup>2 *\n           \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c", "using True"], ["proof (prove)\nusing this:\n  \\<forall>c>0.\n     2 * Re \\<langle>h - k, f\\<rangle>\n     \\<le> c / \\<parallel>f\\<parallel>\\<^sup>2 *\n           \\<parallel>f\\<parallel>\\<^sup>2\n  0 < \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c", "by auto"], ["proof (state)\nthis:\n  \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c\n\ngoal (1 subgoal):\n 1. \\<not> 0 < \\<parallel>f\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < \\<parallel>f\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> 0 < \\<parallel>f\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c", "hence \\<open>\\<parallel> f \\<parallel>^2 = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> 0 < \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>f\\<parallel>\\<^sup>2 = 0", "by simp"], ["proof (state)\nthis:\n  \\<parallel>f\\<parallel>\\<^sup>2 = 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < \\<parallel>f\\<parallel>\\<^sup>2 \\<Longrightarrow>\n    \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>f\\<parallel>\\<^sup>2 = 0\n\ngoal (1 subgoal):\n 1. \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c", "by auto"], ["proof (state)\nthis:\n  \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>c>0.\n     2 * Re \\<langle>h - k, ?f\\<rangle>\n     \\<le> c * \\<parallel>?f\\<parallel>\\<^sup>2 \\<Longrightarrow>\n  \\<forall>c>0. 2 * Re \\<langle>h - k, ?f\\<rangle> \\<le> c\n\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n    (h - k \\<in> orthogonal_complement M \\<and> k \\<in> M)", "have q3: \\<open>\\<forall> c::real. c > 0 \\<longrightarrow> 2 * Re (\\<langle> h - k , f \\<rangle>) \\<le> 0\\<close> \n    if a3: \\<open>\\<forall>f. f \\<in> M \\<longrightarrow> (\\<forall>c>0. 2 * Re \\<langle>h - k , f\\<rangle> \\<le> c * \\<parallel>f\\<parallel>\\<^sup>2)\\<close>\n      and a2: \"f \\<in>  M\"\n      and a1: \"is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) k\"\n    for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> 0", "have \\<open>\\<forall> c > 0.  2 * Re (\\<langle> h - k , f \\<rangle>) \\<le> c*\\<parallel> f \\<parallel>^2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c>0.\n       2 * Re \\<langle>h - k, f\\<rangle>\n       \\<le> c * \\<parallel>f\\<parallel>\\<^sup>2", "by (simp add: that )"], ["proof (state)\nthis:\n  \\<forall>c>0.\n     2 * Re \\<langle>h - k, f\\<rangle>\n     \\<le> c * \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>c>0.\n     2 * Re \\<langle>h - k, f\\<rangle>\n     \\<le> c * \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> 0", "using q4"], ["proof (prove)\nusing this:\n  \\<forall>c>0.\n     2 * Re \\<langle>h - k, f\\<rangle>\n     \\<le> c * \\<parallel>f\\<parallel>\\<^sup>2\n  \\<forall>c>0.\n     2 * Re \\<langle>h - k, ?f\\<rangle>\n     \\<le> c * \\<parallel>?f\\<parallel>\\<^sup>2 \\<Longrightarrow>\n  \\<forall>c>0. 2 * Re \\<langle>h - k, ?f\\<rangle> \\<le> c\n\ngoal (1 subgoal):\n 1. \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> 0", "by smt"], ["proof (state)\nthis:\n  \\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>f.\n              f \\<in> M \\<longrightarrow>\n              (\\<forall>c>0.\n                  2 * Re \\<langle>h - k, f\\<rangle>\n                  \\<le> c * \\<parallel>f\\<parallel>\\<^sup>2);\n   ?f \\<in> M;\n   is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k\\<rbrakk>\n  \\<Longrightarrow> \\<forall>c>0. 2 * Re \\<langle>h - k, ?f\\<rangle> \\<le> 0\n\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n    (h - k \\<in> orthogonal_complement M \\<and> k \\<in> M)", "have w2: \"h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\"\n    if a1: \"is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "have  \\<open>k \\<in> M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> M", "using is_arg_min_def that"], ["proof (prove)\nusing this:\n  is_arg_min ?f ?P ?x =\n  (?P ?x \\<and> (\\<nexists>y. ?P y \\<and> ?f y < ?f ?x))\n  is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k\n\ngoal (1 subgoal):\n 1. k \\<in> M", "by fastforce"], ["proof (state)\nthis:\n  k \\<in> M\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> 2 * Re (\\<langle> h - k , f \\<rangle>) \\<le> \\<parallel> f \\<parallel>^2\\<close>"], ["proof (prove)\nusing this:\n  k \\<in> M\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       2 * Re \\<langle>h - k, f\\<rangle>\n       \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "using r1"], ["proof (prove)\nusing this:\n  k \\<in> M\n  \\<lbrakk>?f \\<in> M; k \\<in> M;\n   is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k\\<rbrakk>\n  \\<Longrightarrow> 2 * Re \\<langle>h - k, ?f\\<rangle>\n                    \\<le> \\<parallel>?f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       2 * Re \\<langle>h - k, f\\<rangle>\n       \\<le> \\<parallel>f\\<parallel>\\<^sup>2", "by (simp add: that)"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "have \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> \n                (\\<forall> c::real.  2 * Re (\\<langle> h - k , c *\\<^sub>R f \\<rangle>) \\<le> \\<parallel> c *\\<^sub>R f \\<parallel>^2)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c.\n           2 * Re \\<langle>h - k, c *\\<^sub>R f\\<rangle>\n           \\<le> \\<parallel>c *\\<^sub>R f\\<parallel>\\<^sup>2)", "using  assms scaleR_scaleC complex_vector.subspace_def \\<open>csubspace M\\<close>"], ["proof (prove)\nusing this:\n  closed_csubspace M\n  (*\\<^sub>R) ?r = (*\\<^sub>C) (complex_of_real ?r)\n  csubspace ?S =\n  ((0::?'a) \\<in> ?S \\<and>\n   (\\<forall>x\\<in>?S. \\<forall>y\\<in>?S. x + y \\<in> ?S) \\<and>\n   (\\<forall>c. \\<forall>x\\<in>?S. c *\\<^sub>C x \\<in> ?S))\n  csubspace M\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c.\n           2 * Re \\<langle>h - k, c *\\<^sub>R f\\<rangle>\n           \\<le> \\<parallel>c *\\<^sub>R f\\<parallel>\\<^sup>2)", "by (metis \\<open>\\<forall>f. f \\<in> M \\<longrightarrow> 2 * Re \\<langle>h - k, f\\<rangle> \\<le> \\<parallel>f\\<parallel>\\<^sup>2\\<close>)"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c.\n         2 * Re \\<langle>h - k, c *\\<^sub>R f\\<rangle>\n         \\<le> \\<parallel>c *\\<^sub>R f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence  \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow>\n                (\\<forall> c::real. c * (2 * Re (\\<langle> h - k , f \\<rangle>)) \\<le> \\<parallel> c *\\<^sub>R f \\<parallel>^2)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c.\n         2 * Re \\<langle>h - k, c *\\<^sub>R f\\<rangle>\n         \\<le> \\<parallel>c *\\<^sub>R f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c.\n           c * (2 * Re \\<langle>h - k, f\\<rangle>)\n           \\<le> \\<parallel>c *\\<^sub>R f\\<parallel>\\<^sup>2)", "by (metis Re_complex_of_real cinner_scaleC_right complex_add_cnj complex_cnj_complex_of_real\n          complex_cnj_mult of_real_mult scaleR_scaleC semiring_normalization_rules(34))"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c.\n         c * (2 * Re \\<langle>h - k, f\\<rangle>)\n         \\<le> \\<parallel>c *\\<^sub>R f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence  \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow>\n                (\\<forall> c::real. c * (2 * Re (\\<langle> h - k , f \\<rangle>)) \\<le> \\<bar>c\\<bar>^2*\\<parallel> f \\<parallel>^2)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c.\n         c * (2 * Re \\<langle>h - k, f\\<rangle>)\n         \\<le> \\<parallel>c *\\<^sub>R f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c.\n           c * (2 * Re \\<langle>h - k, f\\<rangle>)\n           \\<le> \\<bar>c\\<bar>\\<^sup>2 * \\<parallel>f\\<parallel>\\<^sup>2)", "by (simp add: power_mult_distrib)"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c.\n         c * (2 * Re \\<langle>h - k, f\\<rangle>)\n         \\<le> \\<bar>c\\<bar>\\<^sup>2 * \\<parallel>f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence  \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> \n                (\\<forall> c::real. c * (2 * Re (\\<langle> h - k , f \\<rangle>)) \\<le> c^2*\\<parallel> f \\<parallel>^2)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c.\n         c * (2 * Re \\<langle>h - k, f\\<rangle>)\n         \\<le> \\<bar>c\\<bar>\\<^sup>2 * \\<parallel>f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c.\n           c * (2 * Re \\<langle>h - k, f\\<rangle>)\n           \\<le> c\\<^sup>2 * \\<parallel>f\\<parallel>\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c.\n         c * (2 * Re \\<langle>h - k, f\\<rangle>)\n         \\<le> c\\<^sup>2 * \\<parallel>f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence  \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> \n                (\\<forall> c::real. c > 0 \\<longrightarrow> c * (2 * Re (\\<langle> h - k , f \\<rangle>)) \\<le> c^2*\\<parallel> f \\<parallel>^2)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c.\n         c * (2 * Re \\<langle>h - k, f\\<rangle>)\n         \\<le> c\\<^sup>2 * \\<parallel>f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c>0.\n           c * (2 * Re \\<langle>h - k, f\\<rangle>)\n           \\<le> c\\<^sup>2 * \\<parallel>f\\<parallel>\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0.\n         c * (2 * Re \\<langle>h - k, f\\<rangle>)\n         \\<le> c\\<^sup>2 * \\<parallel>f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence  \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> \n                (\\<forall> c::real. c > 0 \\<longrightarrow> c*(2 * Re (\\<langle> h - k , f \\<rangle>)) \\<le> c*(c*\\<parallel> f \\<parallel>^2))\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0.\n         c * (2 * Re \\<langle>h - k, f\\<rangle>)\n         \\<le> c\\<^sup>2 * \\<parallel>f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c>0.\n           c * (2 * Re \\<langle>h - k, f\\<rangle>)\n           \\<le> c * (c * \\<parallel>f\\<parallel>\\<^sup>2))", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0.\n         c * (2 * Re \\<langle>h - k, f\\<rangle>)\n         \\<le> c * (c * \\<parallel>f\\<parallel>\\<^sup>2))\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence  q4: \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> \n                (\\<forall> c::real. c > 0 \\<longrightarrow> 2 * Re (\\<langle> h - k , f \\<rangle>) \\<le> c*\\<parallel> f \\<parallel>^2)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0.\n         c * (2 * Re \\<langle>h - k, f\\<rangle>)\n         \\<le> c * (c * \\<parallel>f\\<parallel>\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c>0.\n           2 * Re \\<langle>h - k, f\\<rangle>\n           \\<le> c * \\<parallel>f\\<parallel>\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0.\n         2 * Re \\<langle>h - k, f\\<rangle>\n         \\<le> c * \\<parallel>f\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "have  \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow>\n                (\\<forall> c::real. c > 0 \\<longrightarrow> 2 * Re (\\<langle> h - k , f \\<rangle>) \\<le> 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> 0)", "using q3"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>f.\n              f \\<in> M \\<longrightarrow>\n              (\\<forall>c>0.\n                  2 * Re \\<langle>h - k, f\\<rangle>\n                  \\<le> c * \\<parallel>f\\<parallel>\\<^sup>2);\n   ?f \\<in> M;\n   is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k\\<rbrakk>\n  \\<Longrightarrow> \\<forall>c>0. 2 * Re \\<langle>h - k, ?f\\<rangle> \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> 0)", "by (simp add: q4 that)"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> 0)\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence  \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> \n                (\\<forall> c::real. c > 0 \\<longrightarrow> (2 * Re (\\<langle> h - k , (-1) *\\<^sub>R f \\<rangle>)) \\<le> 0)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c>0.\n           2 * Re \\<langle>h - k, - 1 *\\<^sub>R f\\<rangle> \\<le> 0)", "using assms scaleR_scaleC complex_vector.subspace_def"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> 0)\n  closed_csubspace M\n  (*\\<^sub>R) ?r = (*\\<^sub>C) (complex_of_real ?r)\n  csubspace ?S =\n  ((0::?'a) \\<in> ?S \\<and>\n   (\\<forall>x\\<in>?S. \\<forall>y\\<in>?S. x + y \\<in> ?S) \\<and>\n   (\\<forall>c. \\<forall>x\\<in>?S. c *\\<^sub>C x \\<in> ?S))\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c>0.\n           2 * Re \\<langle>h - k, - 1 *\\<^sub>R f\\<rangle> \\<le> 0)", "by (metis \\<open>csubspace M\\<close>)"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0. 2 * Re \\<langle>h - k, - 1 *\\<^sub>R f\\<rangle> \\<le> 0)\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence  \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow>\n                (\\<forall> c::real. c > 0 \\<longrightarrow> -(2 * Re (\\<langle> h - k , f \\<rangle>)) \\<le> 0)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0. 2 * Re \\<langle>h - k, - 1 *\\<^sub>R f\\<rangle> \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c>0. - (2 * Re \\<langle>h - k, f\\<rangle>) \\<le> 0)", "by simp"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0. - (2 * Re \\<langle>h - k, f\\<rangle>) \\<le> 0)\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence  \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> \n                (\\<forall> c::real. c > 0 \\<longrightarrow> 2 * Re (\\<langle> h - k , f \\<rangle>) \\<ge> 0)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0. - (2 * Re \\<langle>h - k, f\\<rangle>) \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c>0. 0 \\<le> 2 * Re \\<langle>h - k, f\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0. 0 \\<le> 2 * Re \\<langle>h - k, f\\<rangle>)\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> \n                (\\<forall> c::real. c > 0 \\<longrightarrow> 2 * Re (\\<langle> h - k , f \\<rangle>) = 0)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0. 0 \\<le> 2 * Re \\<langle>h - k, f\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> = 0)", "using  \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> \n                (\\<forall> c::real. c > 0 \\<longrightarrow> (2 * Re (\\<langle> h - k , f \\<rangle>)) \\<le> 0)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0. 0 \\<le> 2 * Re \\<langle>h - k, f\\<rangle>)\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       (\\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> = 0)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> = 0)\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "have \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> \n                 ((1::real) > 0 \\<longrightarrow> 2 * Re (\\<langle> h - k , f \\<rangle>) = 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       0 < 1 \\<longrightarrow> 2 * Re \\<langle>h - k, f\\<rangle> = 0", "using \\<open>\\<forall>f. f \\<in>  M \\<longrightarrow> (\\<forall>c>0. 2 * Re (\\<langle>h - k , f\\<rangle> ) = 0)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     (\\<forall>c>0. 2 * Re \\<langle>h - k, f\\<rangle> = 0)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       0 < 1 \\<longrightarrow> 2 * Re \\<langle>h - k, f\\<rangle> = 0", "by blast"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     0 < 1 \\<longrightarrow> 2 * Re \\<langle>h - k, f\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> 2 * Re (\\<langle> h - k , f \\<rangle>) = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     0 < 1 \\<longrightarrow> 2 * Re \\<langle>h - k, f\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow> 2 * Re \\<langle>h - k, f\\<rangle> = 0", "by simp"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow> 2 * Re \\<langle>h - k, f\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> Re (\\<langle> h - k , f \\<rangle>) = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow> 2 * Re \\<langle>h - k, f\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow> Re \\<langle>h - k, f\\<rangle> = 0", "by simp"], ["proof (state)\nthis:\n  \\<forall>f. f \\<in> M \\<longrightarrow> Re \\<langle>h - k, f\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "have  \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> Re (\\<langle> h - k , (Complex 0 (-1)) *\\<^sub>C f \\<rangle>) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       Re \\<langle>h - k, Complex 0 (- 1) *\\<^sub>C f\\<rangle> = 0", "using assms  complex_vector.subspace_def \\<open>csubspace M\\<close>"], ["proof (prove)\nusing this:\n  closed_csubspace M\n  csubspace ?S =\n  ((0::?'a) \\<in> ?S \\<and>\n   (\\<forall>x\\<in>?S. \\<forall>y\\<in>?S. x + y \\<in> ?S) \\<and>\n   (\\<forall>c. \\<forall>x\\<in>?S. c *\\<^sub>C x \\<in> ?S))\n  csubspace M\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       Re \\<langle>h - k, Complex 0 (- 1) *\\<^sub>C f\\<rangle> = 0", "by (metis \\<open>\\<forall>f. f \\<in> M \\<longrightarrow> Re \\<langle>h - k, f\\<rangle> = 0\\<close>)"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     Re \\<langle>h - k, Complex 0 (- 1) *\\<^sub>C f\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence  \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> Re ( (Complex 0 (-1))*(\\<langle> h - k , f \\<rangle>) ) = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     Re \\<langle>h - k, Complex 0 (- 1) *\\<^sub>C f\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow>\n       Re (Complex 0 (- 1) * \\<langle>h - k, f\\<rangle>) = 0", "by simp"], ["proof (state)\nthis:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     Re (Complex 0 (- 1) * \\<langle>h - k, f\\<rangle>) = 0\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> Im (\\<langle> h - k , f \\<rangle>) = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     Re (Complex 0 (- 1) * \\<langle>h - k, f\\<rangle>) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow> Im \\<langle>h - k, f\\<rangle> = 0", "using Complex_eq_neg_1 Re_i_times cinner_scaleC_right complex_of_real_def"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     f \\<in> M \\<longrightarrow>\n     Re (Complex 0 (- 1) * \\<langle>h - k, f\\<rangle>) = 0\n  (Complex ?a ?b = - 1) = (?a = - 1 \\<and> ?b = 0)\n  Re (\\<i> * ?z) = - Im ?z\n  \\<langle>?x, ?r *\\<^sub>C ?y\\<rangle> = ?r * \\<langle>?x, ?y\\<rangle>\n  complex_of_real ?r = Complex ?r 0\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       f \\<in> M \\<longrightarrow> Im \\<langle>h - k, f\\<rangle> = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>f. f \\<in> M \\<longrightarrow> Im \\<langle>h - k, f\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "have \\<open>\\<forall> f. f \\<in>  M \\<longrightarrow> (\\<langle> h - k , f \\<rangle>) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f. f \\<in> M \\<longrightarrow> is_orthogonal (h - k) f", "using complex_eq_iff"], ["proof (prove)\nusing this:\n  (?x = ?y) = (Re ?x = Re ?y \\<and> Im ?x = Im ?y)\n\ngoal (1 subgoal):\n 1. \\<forall>f. f \\<in> M \\<longrightarrow> is_orthogonal (h - k) f", "by (simp add: \\<open>\\<forall>f. f \\<in> M \\<longrightarrow> Im \\<langle>h - k, f\\<rangle> = 0\\<close> \\<open>\\<forall>f. f \\<in> M \\<longrightarrow> Re \\<langle>h - k, f\\<rangle> = 0\\<close>)"], ["proof (state)\nthis:\n  \\<forall>f. f \\<in> M \\<longrightarrow> is_orthogonal (h - k) f\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence \\<open>h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>f. f \\<in> M \\<longrightarrow> is_orthogonal (h - k) f\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "by (simp add: \\<open>k \\<in> M\\<close> orthogonal_complementI)"], ["proof (state)\nthis:\n  h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "have  \\<open>\\<forall> c. c *\\<^sub>R f \\<in> M\\<close>\n      if \"f \\<in> M\"\n      for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c. c *\\<^sub>R f \\<in> M", "using that scaleR_scaleC  \\<open>csubspace M\\<close> complex_vector.subspace_def"], ["proof (prove)\nusing this:\n  f \\<in> M\n  (*\\<^sub>R) ?r = (*\\<^sub>C) (complex_of_real ?r)\n  csubspace M\n  csubspace ?S =\n  ((0::?'a) \\<in> ?S \\<and>\n   (\\<forall>x\\<in>?S. \\<forall>y\\<in>?S. x + y \\<in> ?S) \\<and>\n   (\\<forall>c. \\<forall>x\\<in>?S. c *\\<^sub>C x \\<in> ?S))\n\ngoal (1 subgoal):\n 1. \\<forall>c. c *\\<^sub>R f \\<in> M", "by (simp add: complex_vector.subspace_def scaleR_scaleC)"], ["proof (state)\nthis:\n  ?f \\<in> M \\<Longrightarrow> \\<forall>c. c *\\<^sub>R ?f \\<in> M\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "have \\<open>\\<langle> h - k , f \\<rangle> = 0\\<close> \n      if \"f \\<in> M\"\n      for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal (h - k) f", "using \\<open>h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\\<close> orthogonal_complement_orthoI that"], ["proof (prove)\nusing this:\n  h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\n  \\<lbrakk>?x \\<in> orthogonal_complement ?M; ?y \\<in> ?M\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n  f \\<in> M\n\ngoal (1 subgoal):\n 1. is_orthogonal (h - k) f", "by auto"], ["proof (state)\nthis:\n  ?f \\<in> M \\<Longrightarrow> is_orthogonal (h - k) ?f\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "hence \\<open>h - k \\<in> orthogonal_complement M\\<close>"], ["proof (prove)\nusing this:\n  ?f \\<in> M \\<Longrightarrow> is_orthogonal (h - k) ?f\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M", "by (simp add: orthogonal_complement_def)"], ["proof (state)\nthis:\n  h - k \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "thus ?thesis"], ["proof (prove)\nusing this:\n  h - k \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "using \\<open>k \\<in> M\\<close>"], ["proof (prove)\nusing this:\n  h - k \\<in> orthogonal_complement M\n  k \\<in> M\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "by auto"], ["proof (state)\nthis:\n  h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M)\n   k \\<Longrightarrow>\n  h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\n\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n    (h - k \\<in> orthogonal_complement M \\<and> k \\<in> M)", "have q1: \\<open>dist h k \\<le> dist h f \\<close> \n    if \"f \\<in> M\" and  \\<open>h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\\<close>\n    for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist h k \\<le> dist h f", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. dist h k \\<le> dist h f", "have \\<open>\\<langle> h - k,  k - f \\<rangle> = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal (h - k) (k - f)", "by (metis (no_types, lifting) that \n          cinner_diff_right diff_0_right orthogonal_complement_orthoI that)"], ["proof (state)\nthis:\n  is_orthogonal (h - k) (k - f)\n\ngoal (1 subgoal):\n 1. dist h k \\<le> dist h f", "have \\<open>\\<parallel> h - f \\<parallel>^2 = \\<parallel> (h - k) + (k - f) \\<parallel>^2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>h - f\\<parallel>\\<^sup>2 =\n    \\<parallel>h - k + (k - f)\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  \\<parallel>h - f\\<parallel>\\<^sup>2 =\n  \\<parallel>h - k + (k - f)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. dist h k \\<le> dist h f", "also"], ["proof (state)\nthis:\n  \\<parallel>h - f\\<parallel>\\<^sup>2 =\n  \\<parallel>h - k + (k - f)\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. dist h k \\<le> dist h f", "have \\<open>... = \\<parallel> h - k \\<parallel>^2 + \\<parallel> k - f \\<parallel>^2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>h - k + (k - f)\\<parallel>\\<^sup>2 =\n    \\<parallel>h - k\\<parallel>\\<^sup>2 +\n    \\<parallel>k - f\\<parallel>\\<^sup>2", "using  \\<open>\\<langle> h - k, k - f \\<rangle> = 0\\<close> pythagorean_theorem"], ["proof (prove)\nusing this:\n  is_orthogonal (h - k) (k - f)\n  is_orthogonal ?x ?y \\<Longrightarrow>\n  \\<parallel>?x + ?y\\<parallel>\\<^sup>2 =\n  \\<parallel>?x\\<parallel>\\<^sup>2 + \\<parallel>?y\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>h - k + (k - f)\\<parallel>\\<^sup>2 =\n    \\<parallel>h - k\\<parallel>\\<^sup>2 +\n    \\<parallel>k - f\\<parallel>\\<^sup>2", "by blast"], ["proof (state)\nthis:\n  \\<parallel>h - k + (k - f)\\<parallel>\\<^sup>2 =\n  \\<parallel>h - k\\<parallel>\\<^sup>2 + \\<parallel>k - f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. dist h k \\<le> dist h f", "also"], ["proof (state)\nthis:\n  \\<parallel>h - k + (k - f)\\<parallel>\\<^sup>2 =\n  \\<parallel>h - k\\<parallel>\\<^sup>2 + \\<parallel>k - f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. dist h k \\<le> dist h f", "have \\<open>... \\<ge> \\<parallel> h - k \\<parallel>^2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>h - k\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>h - k\\<parallel>\\<^sup>2 +\n          \\<parallel>k - f\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  \\<parallel>h - k\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - k\\<parallel>\\<^sup>2 +\n        \\<parallel>k - f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. dist h k \\<le> dist h f", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>h - k\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - f\\<parallel>\\<^sup>2", "have \\<open>\\<parallel>h - k\\<parallel>\\<^sup>2 \\<le> \\<parallel>h - f\\<parallel>\\<^sup>2 \\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>h - k\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>h - k\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>h - f\\<parallel>\\<^sup>2", "by blast"], ["proof (state)\nthis:\n  \\<parallel>h - k\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. dist h k \\<le> dist h f", "hence \\<open>\\<parallel>h - k\\<parallel> \\<le> \\<parallel>h - f\\<parallel>\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>h - k\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - f\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>h - k\\<parallel> \\<le> \\<parallel>h - f\\<parallel>", "using norm_ge_zero power2_le_imp_le"], ["proof (prove)\nusing this:\n  \\<parallel>h - k\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h - f\\<parallel>\\<^sup>2\n  0 \\<le> \\<parallel>?x\\<parallel>\n  \\<lbrakk>?x\\<^sup>2 \\<le> ?y\\<^sup>2; (0::?'a) \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<parallel>h - k\\<parallel> \\<le> \\<parallel>h - f\\<parallel>", "by blast"], ["proof (state)\nthis:\n  \\<parallel>h - k\\<parallel> \\<le> \\<parallel>h - f\\<parallel>\n\ngoal (1 subgoal):\n 1. dist h k \\<le> dist h f", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>h - k\\<parallel> \\<le> \\<parallel>h - f\\<parallel>\n\ngoal (1 subgoal):\n 1. dist h k \\<le> dist h f", "by (simp add: dist_norm)"], ["proof (state)\nthis:\n  dist h k \\<le> dist h f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> M;\n   h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\\<rbrakk>\n  \\<Longrightarrow> dist h k \\<le> dist h ?f\n\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n    (h - k \\<in> orthogonal_complement M \\<and> k \\<in> M)", "have  w1: \"is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) k\"\n    if \"h - k \\<in> orthogonal_complement M \\<and> k \\<in>  M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k", "have \\<open>h - k \\<in> orthogonal_complement M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M", "using that"], ["proof (prove)\nusing this:\n  h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\n\ngoal (1 subgoal):\n 1. h - k \\<in> orthogonal_complement M", "by blast"], ["proof (state)\nthis:\n  h - k \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k", "have \\<open>k \\<in> M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> M", "using \\<open>h - k \\<in> orthogonal_complement M \\<and> k \\<in>  M\\<close>"], ["proof (prove)\nusing this:\n  h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\n\ngoal (1 subgoal):\n 1. k \\<in> M", "by blast"], ["proof (state)\nthis:\n  k \\<in> M\n\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<in> M\n\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k", "by (metis (no_types, lifting) dist_commute is_arg_min_linorder q1 that)"], ["proof (state)\nthis:\n  is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h - k \\<in> orthogonal_complement M \\<and> k \\<in> M \\<Longrightarrow>\n  is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k\n\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n    (h - k \\<in> orthogonal_complement M \\<and> k \\<in> M)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n    (h - k \\<in> orthogonal_complement M \\<and> k \\<in> M)", "using w1 w2"], ["proof (prove)\nusing this:\n  h - k \\<in> orthogonal_complement M \\<and> k \\<in> M \\<Longrightarrow>\n  is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k\n  is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M)\n   k \\<Longrightarrow>\n  h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\n\ngoal (1 subgoal):\n 1. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n    (h - k \\<in> orthogonal_complement M \\<and> k \\<in> M)", "by blast"], ["proof (state)\nthis:\n  is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k =\n  (h - k \\<in> orthogonal_complement M \\<and> k \\<in> M)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary orthog_proj_exists:\n  fixes M :: \\<open>'a::chilbert_space set\\<close> \n  assumes \\<open>closed_csubspace M\\<close>\n  shows  \\<open>\\<exists>k. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "from  \\<open>closed_csubspace M\\<close>"], ["proof (chain)\npicking this:\n  closed_csubspace M", "have \\<open>M \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  closed_csubspace M\n\ngoal (1 subgoal):\n 1. M \\<noteq> {}", "using closed_csubspace.subspace complex_vector.subspace_0"], ["proof (prove)\nusing this:\n  closed_csubspace M\n  closed_csubspace ?A \\<Longrightarrow> csubspace ?A\n  csubspace ?S \\<Longrightarrow> (0::?'a) \\<in> ?S\n\ngoal (1 subgoal):\n 1. M \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>k. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "have \\<open>closed  M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed M", "using  \\<open>closed_csubspace M\\<close>"], ["proof (prove)\nusing this:\n  closed_csubspace M\n\ngoal (1 subgoal):\n 1. closed M", "by (simp add: closed_csubspace.closed)"], ["proof (state)\nthis:\n  closed M\n\ngoal (1 subgoal):\n 1. \\<exists>k. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "have \\<open>convex  M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. convex M", "using  \\<open>closed_csubspace M\\<close>"], ["proof (prove)\nusing this:\n  closed_csubspace M\n\ngoal (1 subgoal):\n 1. convex M", "by (simp)"], ["proof (state)\nthis:\n  convex M\n\ngoal (1 subgoal):\n 1. \\<exists>k. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "have \\<open>\\<exists>k.  is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) k\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k", "by (simp add: smallest_dist_exists \\<open>closed M\\<close> \\<open>convex M\\<close> \\<open>M \\<noteq> {}\\<close>)"], ["proof (state)\nthis:\n  \\<exists>k. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k\n\ngoal (1 subgoal):\n 1. \\<exists>k. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>k. is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) k\n\ngoal (1 subgoal):\n 1. \\<exists>k. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M", "by (simp add: assms smallest_dist_is_ortho)"], ["proof (state)\nthis:\n  \\<exists>k. h - k \\<in> orthogonal_complement M \\<and> k \\<in> M\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary orthog_proj_unique:\n  fixes M :: \\<open>'a::complex_inner set\\<close> \n  assumes \\<open>closed_csubspace M\\<close>\n  assumes \\<open>h - r \\<in> orthogonal_complement M \\<and> r \\<in> M\\<close>\n  assumes \\<open>h - s \\<in> orthogonal_complement M \\<and> s \\<in> M\\<close>\n  shows  \\<open>r = s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r = s", "using _ assms(2,3)"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  h - r \\<in> orthogonal_complement M \\<and> r \\<in> M\n  h - s \\<in> orthogonal_complement M \\<and> s \\<in> M\n\ngoal (1 subgoal):\n 1. r = s", "unfolding smallest_dist_is_ortho[OF assms(1), symmetric]"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) r\n  is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) s\n\ngoal (1 subgoal):\n 1. r = s", "apply (rule smallest_dist_unique)"], ["proof (prove)\ngoal (1 subgoal):\n 1. convex M", "using assms(1)"], ["proof (prove)\nusing this:\n  closed_csubspace M\n\ngoal (1 subgoal):\n 1. convex M", "by (simp)"], ["", "definition is_projection_on::\\<open>('a \\<Rightarrow> 'a) \\<Rightarrow> ('a::metric_space) set \\<Rightarrow> bool\\<close> where\n  \\<open>is_projection_on \\<pi> M \\<longleftrightarrow> (\\<forall>h. is_arg_min (\\<lambda> x. dist x h) (\\<lambda> x. x \\<in> M) (\\<pi> h))\\<close>"], ["", "lemma is_projection_on_iff_orthog:\n  \\<open>closed_csubspace M \\<Longrightarrow> is_projection_on \\<pi> M \\<longleftrightarrow> (\\<forall>h. h - \\<pi> h \\<in> orthogonal_complement M \\<and> \\<pi> h \\<in> M)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace M \\<Longrightarrow>\n    is_projection_on \\<pi> M =\n    (\\<forall>h.\n        h - \\<pi> h \\<in> orthogonal_complement M \\<and> \\<pi> h \\<in> M)", "by (simp add: is_projection_on_def smallest_dist_is_ortho)"], ["", "lemma is_projection_on_exists:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \\<open>convex M\\<close> and \\<open>closed M\\<close> and \\<open>M \\<noteq> {}\\<close>\n  shows \"\\<exists>\\<pi>. is_projection_on \\<pi> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>. is_projection_on \\<pi> M", "unfolding is_projection_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>.\n       \\<forall>h.\n          is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M)\n           (\\<pi> h)", "apply (rule choice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h.\n       \\<exists>y.\n          is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) y", "using smallest_dist_exists[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>k. is_arg_min (\\<lambda>x. dist x ?h) (\\<lambda>x. x \\<in> M) k\n\ngoal (1 subgoal):\n 1. \\<forall>h.\n       \\<exists>y.\n          is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M) y", "by auto"], ["", "lemma is_projection_on_unique:\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes \\<open>convex M\\<close>\n  assumes \"is_projection_on \\<pi>\\<^sub>1 M\"\n  assumes \"is_projection_on \\<pi>\\<^sub>2 M\"\n  shows \"\\<pi>\\<^sub>1 = \\<pi>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>1 = \\<pi>\\<^sub>2", "using smallest_dist_unique[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_arg_min (\\<lambda>x. dist x ?h) (\\<lambda>x. x \\<in> M) ?r;\n   is_arg_min (\\<lambda>x. dist x ?h) (\\<lambda>x. x \\<in> M) ?s\\<rbrakk>\n  \\<Longrightarrow> ?r = ?s\n\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>1 = \\<pi>\\<^sub>2", "using assms(2,3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_arg_min (\\<lambda>x. dist x ?h) (\\<lambda>x. x \\<in> M) ?r;\n   is_arg_min (\\<lambda>x. dist x ?h) (\\<lambda>x. x \\<in> M) ?s\\<rbrakk>\n  \\<Longrightarrow> ?r = ?s\n  is_projection_on \\<pi>\\<^sub>1 M\n  is_projection_on \\<pi>\\<^sub>2 M\n\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>1 = \\<pi>\\<^sub>2", "unfolding is_projection_on_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_arg_min (\\<lambda>x. dist x ?h) (\\<lambda>x. x \\<in> M) ?r;\n   is_arg_min (\\<lambda>x. dist x ?h) (\\<lambda>x. x \\<in> M) ?s\\<rbrakk>\n  \\<Longrightarrow> ?r = ?s\n  \\<forall>h.\n     is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M)\n      (\\<pi>\\<^sub>1 h)\n  \\<forall>h.\n     is_arg_min (\\<lambda>x. dist x h) (\\<lambda>x. x \\<in> M)\n      (\\<pi>\\<^sub>2 h)\n\ngoal (1 subgoal):\n 1. \\<pi>\\<^sub>1 = \\<pi>\\<^sub>2", "by blast"], ["", "definition projection :: \\<open>'a::metric_space set \\<Rightarrow> ('a \\<Rightarrow> 'a)\\<close> where\n  \\<open>projection M \\<equiv> SOME \\<pi>. is_projection_on \\<pi> M\\<close>"], ["", "lemma projection_is_projection_on:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \\<open>convex M\\<close> and \\<open>closed M\\<close> and \\<open>M \\<noteq> {}\\<close>\n  shows \"is_projection_on (projection M) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_projection_on (projection M) M", "by (metis assms(1) assms(2) assms(3) is_projection_on_exists projection_def someI)"], ["", "lemma projection_is_projection_on'[simp]:\n  \\<comment> \\<open>Common special case of @{thm projection_is_projection_on}\\<close>\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \\<open>closed_csubspace M\\<close>\n  shows \"is_projection_on (projection M) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_projection_on (projection M) M", "apply (rule projection_is_projection_on)"], ["proof (prove)\ngoal (3 subgoals):\n 1. convex M\n 2. closed M\n 3. M \\<noteq> {}", "apply (auto simp add: assms closed_csubspace.closed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. M = {} \\<Longrightarrow> False", "using assms closed_csubspace.subspace complex_vector.subspace_0"], ["proof (prove)\nusing this:\n  closed_csubspace M\n  closed_csubspace ?A \\<Longrightarrow> csubspace ?A\n  csubspace ?S \\<Longrightarrow> (0::?'a) \\<in> ?S\n\ngoal (1 subgoal):\n 1. M = {} \\<Longrightarrow> False", "by blast"], ["", "lemma projection_orthogonal:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \"closed_csubspace M\" and \\<open>m \\<in> M\\<close>\n  shows \\<open>is_orthogonal (h - projection M h) m\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal (h - projection M h) m", "by (metis assms(1) assms(2) closed_csubspace.closed closed_csubspace.subspace csubspace_is_convex empty_iff is_projection_on_iff_orthog orthogonal_complement_orthoI projection_is_projection_on)"], ["", "lemma is_projection_on_in_image:\n  assumes \"is_projection_on \\<pi> M\"\n  shows \"\\<pi> h \\<in> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> h \\<in> M", "using assms"], ["proof (prove)\nusing this:\n  is_projection_on \\<pi> M\n\ngoal (1 subgoal):\n 1. \\<pi> h \\<in> M", "by (simp add: is_arg_min_def is_projection_on_def)"], ["", "lemma is_projection_on_image:\n  assumes \"is_projection_on \\<pi> M\"\n  shows \"range \\<pi> = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range \\<pi> = M", "using assms"], ["proof (prove)\nusing this:\n  is_projection_on \\<pi> M\n\ngoal (1 subgoal):\n 1. range \\<pi> = M", "apply (auto simp: is_projection_on_in_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>is_projection_on \\<pi> M; x \\<in> M\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range \\<pi>", "by (smt (verit, ccfv_threshold) dist_pos_lt dist_self is_arg_min_def is_projection_on_def rangeI)"], ["", "lemma projection_in_image[simp]:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \\<open>convex M\\<close> and \\<open>closed M\\<close> and \\<open>M \\<noteq> {}\\<close>\n  shows \\<open>projection M h \\<in> M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection M h \\<in> M", "by (simp add: assms(1) assms(2) assms(3) is_projection_on_in_image projection_is_projection_on)"], ["", "lemma projection_image[simp]:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \\<open>convex M\\<close> and \\<open>closed M\\<close> and \\<open>M \\<noteq> {}\\<close>\n  shows \\<open>range (projection M) = M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. range (projection M) = M", "by (simp add: assms(1) assms(2) assms(3) is_projection_on_image projection_is_projection_on)"], ["", "lemma projection_eqI':\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes \\<open>convex M\\<close>\n  assumes \\<open>is_projection_on f M\\<close>\n  shows \\<open>projection M = f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection M = f", "by (metis assms(1) assms(2) is_projection_on_unique projection_def someI_ex)"], ["", "lemma is_projection_on_eqI:\n  fixes  M :: \\<open>'a::complex_inner set\\<close>\n  assumes a1: \\<open>closed_csubspace M\\<close> and a2: \\<open>h - x \\<in> orthogonal_complement M\\<close> and a3: \\<open>x \\<in> M\\<close> \n    and a4: \\<open>is_projection_on \\<pi> M\\<close>\n  shows \\<open>\\<pi> h = x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> h = x", "by (meson a1 a2 a3 a4 closed_csubspace.subspace csubspace_is_convex is_projection_on_def smallest_dist_is_ortho smallest_dist_unique)"], ["", "lemma projection_eqI:\n  fixes  M :: \\<open>('a::chilbert_space) set\\<close>\n  assumes  \\<open>closed_csubspace M\\<close> and \\<open>h - x \\<in> orthogonal_complement M\\<close> and \\<open>x \\<in> M\\<close>\n  shows \\<open>projection M h = x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection M h = x", "by (metis assms(1) assms(2) assms(3) is_projection_on_iff_orthog orthog_proj_exists projection_def is_projection_on_eqI tfl_some)"], ["", "lemma is_projection_on_fixes_image:\n  fixes M :: \\<open>'a::metric_space set\\<close>\n  assumes a1: \"is_projection_on \\<pi> M\" and a3: \"x \\<in> M\"\n  shows \"\\<pi> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> x = x", "by (metis a1 a3 dist_pos_lt dist_self is_arg_min_def is_projection_on_def)"], ["", "lemma projection_fixes_image:\n  fixes M :: \\<open>('a::chilbert_space) set\\<close>\n  assumes a1: \"closed_csubspace M\" and a2: \"x \\<in> M\"\n  shows \"(projection M) x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. projection M x = x", "using is_projection_on_fixes_image\n    \\<comment> \\<open>Theorem 2.7 in @{cite conway2013course}\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_projection_on ?\\<pi> ?M; ?x \\<in> ?M\\<rbrakk>\n  \\<Longrightarrow> ?\\<pi> ?x = ?x\n\ngoal (1 subgoal):\n 1. projection M x = x", "by (simp add: a1 a2 complex_vector.subspace_0 projection_eqI)"], ["", "proposition is_projection_on_reduces_norm:\n  includes notation_norm\n  fixes M :: \\<open>('a::complex_inner) set\\<close>\n  assumes \\<open>is_projection_on \\<pi> M\\<close> and \\<open>closed_csubspace M\\<close>\n  shows \\<open>\\<parallel> \\<pi>  h \\<parallel> \\<le> \\<parallel> h \\<parallel>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel> \\<le> \\<parallel>h\\<parallel>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel> \\<le> \\<parallel>h\\<parallel>", "have \\<open>h - \\<pi> h \\<in> orthogonal_complement M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. h - \\<pi> h \\<in> orthogonal_complement M", "using assms is_projection_on_iff_orthog"], ["proof (prove)\nusing this:\n  is_projection_on \\<pi> M\n  closed_csubspace M\n  closed_csubspace ?M \\<Longrightarrow>\n  is_projection_on ?\\<pi> ?M =\n  (\\<forall>h.\n      h - ?\\<pi> h \\<in> orthogonal_complement ?M \\<and> ?\\<pi> h \\<in> ?M)\n\ngoal (1 subgoal):\n 1. h - \\<pi> h \\<in> orthogonal_complement M", "by blast"], ["proof (state)\nthis:\n  h - \\<pi> h \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel> \\<le> \\<parallel>h\\<parallel>", "hence \\<open>\\<forall> k \\<in> M. \\<langle>  h - \\<pi> h , k \\<rangle> = 0\\<close>"], ["proof (prove)\nusing this:\n  h - \\<pi> h \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>M. is_orthogonal (h - \\<pi> h) k", "using orthogonal_complement_orthoI"], ["proof (prove)\nusing this:\n  h - \\<pi> h \\<in> orthogonal_complement M\n  \\<lbrakk>?x \\<in> orthogonal_complement ?M; ?y \\<in> ?M\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>M. is_orthogonal (h - \\<pi> h) k", "by blast"], ["proof (state)\nthis:\n  \\<forall>k\\<in>M. is_orthogonal (h - \\<pi> h) k\n\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel> \\<le> \\<parallel>h\\<parallel>", "also"], ["proof (state)\nthis:\n  \\<forall>k\\<in>M. is_orthogonal (h - \\<pi> h) k\n\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel> \\<le> \\<parallel>h\\<parallel>", "have \\<open>\\<pi> h \\<in>  M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> h \\<in> M", "using \\<open>is_projection_on \\<pi> M\\<close>"], ["proof (prove)\nusing this:\n  is_projection_on \\<pi> M\n\ngoal (1 subgoal):\n 1. \\<pi> h \\<in> M", "by (simp add: is_projection_on_in_image)"], ["proof (state)\nthis:\n  \\<pi> h \\<in> M\n\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel> \\<le> \\<parallel>h\\<parallel>", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>M. is_orthogonal (h - \\<pi> h) k\n  \\<pi> h \\<in> M", "have \\<open>\\<langle>  h - \\<pi> h , \\<pi> h \\<rangle> = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>M. is_orthogonal (h - \\<pi> h) k\n  \\<pi> h \\<in> M\n\ngoal (1 subgoal):\n 1. is_orthogonal (h - \\<pi> h) (\\<pi> h)", "by auto"], ["proof (state)\nthis:\n  is_orthogonal (h - \\<pi> h) (\\<pi> h)\n\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel> \\<le> \\<parallel>h\\<parallel>", "hence \\<open>\\<parallel> \\<pi> h \\<parallel>^2 + \\<parallel> h - \\<pi> h \\<parallel>^2 = \\<parallel> h \\<parallel>^2\\<close>"], ["proof (prove)\nusing this:\n  is_orthogonal (h - \\<pi> h) (\\<pi> h)\n\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel>\\<^sup>2 +\n    \\<parallel>h - \\<pi> h\\<parallel>\\<^sup>2 =\n    \\<parallel>h\\<parallel>\\<^sup>2", "using pythagorean_theorem"], ["proof (prove)\nusing this:\n  is_orthogonal (h - \\<pi> h) (\\<pi> h)\n  is_orthogonal ?x ?y \\<Longrightarrow>\n  \\<parallel>?x + ?y\\<parallel>\\<^sup>2 =\n  \\<parallel>?x\\<parallel>\\<^sup>2 + \\<parallel>?y\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel>\\<^sup>2 +\n    \\<parallel>h - \\<pi> h\\<parallel>\\<^sup>2 =\n    \\<parallel>h\\<parallel>\\<^sup>2", "by fastforce"], ["proof (state)\nthis:\n  \\<parallel>\\<pi> h\\<parallel>\\<^sup>2 +\n  \\<parallel>h - \\<pi> h\\<parallel>\\<^sup>2 =\n  \\<parallel>h\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel> \\<le> \\<parallel>h\\<parallel>", "hence \\<open>\\<parallel>\\<pi> h \\<parallel>^2 \\<le> \\<parallel> h \\<parallel>^2\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>\\<pi> h\\<parallel>\\<^sup>2 +\n  \\<parallel>h - \\<pi> h\\<parallel>\\<^sup>2 =\n  \\<parallel>h\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>h\\<parallel>\\<^sup>2", "by (smt zero_le_power2)"], ["proof (state)\nthis:\n  \\<parallel>\\<pi> h\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel> \\<le> \\<parallel>h\\<parallel>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>\\<pi> h\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel> \\<le> \\<parallel>h\\<parallel>", "using norm_ge_zero power2_le_imp_le"], ["proof (prove)\nusing this:\n  \\<parallel>\\<pi> h\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>h\\<parallel>\\<^sup>2\n  0 \\<le> \\<parallel>?x\\<parallel>\n  \\<lbrakk>?x\\<^sup>2 \\<le> ?y\\<^sup>2; (0::?'a) \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<parallel>\\<pi> h\\<parallel> \\<le> \\<parallel>h\\<parallel>", "by blast"], ["proof (state)\nthis:\n  \\<parallel>\\<pi> h\\<parallel> \\<le> \\<parallel>h\\<parallel>\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition projection_reduces_norm:\n  includes notation_norm\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes a1: \"closed_csubspace M\"\n  shows \\<open>\\<parallel> projection M h \\<parallel> \\<le> \\<parallel> h \\<parallel>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>projection M h\\<parallel> \\<le> \\<parallel>h\\<parallel>", "using assms is_projection_on_iff_orthog orthog_proj_exists is_projection_on_reduces_norm projection_eqI"], ["proof (prove)\nusing this:\n  closed_csubspace M\n  closed_csubspace ?M \\<Longrightarrow>\n  is_projection_on ?\\<pi> ?M =\n  (\\<forall>h.\n      h - ?\\<pi> h \\<in> orthogonal_complement ?M \\<and> ?\\<pi> h \\<in> ?M)\n  closed_csubspace ?M \\<Longrightarrow>\n  \\<exists>k. ?h - k \\<in> orthogonal_complement ?M \\<and> k \\<in> ?M\n  \\<lbrakk>is_projection_on ?\\<pi> ?M; closed_csubspace ?M\\<rbrakk>\n  \\<Longrightarrow> \\<parallel>?\\<pi> ?h\\<parallel>\n                    \\<le> \\<parallel>?h\\<parallel>\n  \\<lbrakk>closed_csubspace ?M; ?h - ?x \\<in> orthogonal_complement ?M;\n   ?x \\<in> ?M\\<rbrakk>\n  \\<Longrightarrow> projection ?M ?h = ?x\n\ngoal (1 subgoal):\n 1. \\<parallel>projection M h\\<parallel> \\<le> \\<parallel>h\\<parallel>", "by blast\n\n\\<comment> \\<open>Theorem 2.7 (version) in @{cite conway2013course}\\<close>"], ["", "theorem is_projection_on_bounded_clinear:\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes a1: \"is_projection_on \\<pi> M\" and a2: \"closed_csubspace M\"\n  shows \"bounded_clinear \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear \\<pi>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2. \\<pi> (b1 + b2) = \\<pi> b1 + \\<pi> b2\n 2. \\<And>r b. \\<pi> (r *\\<^sub>C b) = r *\\<^sub>C \\<pi> b\n 3. \\<exists>K. \\<forall>x. norm (\\<pi> x) \\<le> norm x * K", "have b1:  \\<open>csubspace (orthogonal_complement M)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace (orthogonal_complement M)", "by (simp add: a2)"], ["proof (state)\nthis:\n  csubspace (orthogonal_complement M)\n\ngoal (3 subgoals):\n 1. \\<And>b1 b2. \\<pi> (b1 + b2) = \\<pi> b1 + \\<pi> b2\n 2. \\<And>r b. \\<pi> (r *\\<^sub>C b) = r *\\<^sub>C \\<pi> b\n 3. \\<exists>K. \\<forall>x. norm (\\<pi> x) \\<le> norm x * K", "have f1: \"\\<forall>a. a - \\<pi> a \\<in> orthogonal_complement M \\<and> \\<pi> a \\<in> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       a - \\<pi> a \\<in> orthogonal_complement M \\<and> \\<pi> a \\<in> M", "using a1 a2 is_projection_on_iff_orthog"], ["proof (prove)\nusing this:\n  is_projection_on \\<pi> M\n  closed_csubspace M\n  closed_csubspace ?M \\<Longrightarrow>\n  is_projection_on ?\\<pi> ?M =\n  (\\<forall>h.\n      h - ?\\<pi> h \\<in> orthogonal_complement ?M \\<and> ?\\<pi> h \\<in> ?M)\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       a - \\<pi> a \\<in> orthogonal_complement M \\<and> \\<pi> a \\<in> M", "by blast"], ["proof (state)\nthis:\n  \\<forall>a.\n     a - \\<pi> a \\<in> orthogonal_complement M \\<and> \\<pi> a \\<in> M\n\ngoal (3 subgoals):\n 1. \\<And>b1 b2. \\<pi> (b1 + b2) = \\<pi> b1 + \\<pi> b2\n 2. \\<And>r b. \\<pi> (r *\\<^sub>C b) = r *\\<^sub>C \\<pi> b\n 3. \\<exists>K. \\<forall>x. norm (\\<pi> x) \\<le> norm x * K", "hence \"c *\\<^sub>C x - c *\\<^sub>C \\<pi> x \\<in> orthogonal_complement M\"\n    for c x"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     a - \\<pi> a \\<in> orthogonal_complement M \\<and> \\<pi> a \\<in> M\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x - c *\\<^sub>C \\<pi> x \\<in> orthogonal_complement M", "by (metis (no_types) b1 \n        add_diff_cancel_right' complex_vector.subspace_def diff_add_cancel scaleC_add_right)"], ["proof (state)\nthis:\n  ?c *\\<^sub>C ?x - ?c *\\<^sub>C \\<pi> ?x \\<in> orthogonal_complement M\n\ngoal (3 subgoals):\n 1. \\<And>b1 b2. \\<pi> (b1 + b2) = \\<pi> b1 + \\<pi> b2\n 2. \\<And>r b. \\<pi> (r *\\<^sub>C b) = r *\\<^sub>C \\<pi> b\n 3. \\<exists>K. \\<forall>x. norm (\\<pi> x) \\<le> norm x * K", "thus r1: \\<open>\\<pi> (c *\\<^sub>C x) = c *\\<^sub>C (\\<pi> x)\\<close> for x c"], ["proof (prove)\nusing this:\n  ?c *\\<^sub>C ?x - ?c *\\<^sub>C \\<pi> ?x \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<pi> (c *\\<^sub>C x) = c *\\<^sub>C \\<pi> x", "using f1"], ["proof (prove)\nusing this:\n  ?c *\\<^sub>C ?x - ?c *\\<^sub>C \\<pi> ?x \\<in> orthogonal_complement M\n  \\<forall>a.\n     a - \\<pi> a \\<in> orthogonal_complement M \\<and> \\<pi> a \\<in> M\n\ngoal (1 subgoal):\n 1. \\<pi> (c *\\<^sub>C x) = c *\\<^sub>C \\<pi> x", "by (meson a2 a1 closed_csubspace.subspace \n        complex_vector.subspace_def is_projection_on_eqI)"], ["proof (state)\nthis:\n  \\<pi> (?c *\\<^sub>C ?x) = ?c *\\<^sub>C \\<pi> ?x\n\ngoal (2 subgoals):\n 1. \\<And>b1 b2. \\<pi> (b1 + b2) = \\<pi> b1 + \\<pi> b2\n 2. \\<exists>K. \\<forall>x. norm (\\<pi> x) \\<le> norm x * K", "show r2: \\<open>\\<pi> (x + y) =  (\\<pi> x) + (\\<pi> y)\\<close>\n    for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "have \"\\<forall>A. \\<not> closed_csubspace (A::'a set) \\<or> csubspace A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A. \\<not> closed_csubspace A \\<or> csubspace A", "by (metis closed_csubspace.subspace)"], ["proof (state)\nthis:\n  \\<forall>A. \\<not> closed_csubspace A \\<or> csubspace A\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "hence \"csubspace M\""], ["proof (prove)\nusing this:\n  \\<forall>A. \\<not> closed_csubspace A \\<or> csubspace A\n\ngoal (1 subgoal):\n 1. csubspace M", "using a2"], ["proof (prove)\nusing this:\n  \\<forall>A. \\<not> closed_csubspace A \\<or> csubspace A\n  closed_csubspace M\n\ngoal (1 subgoal):\n 1. csubspace M", "by auto"], ["proof (state)\nthis:\n  csubspace M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "hence \\<open>\\<pi> (x + y) - ( (\\<pi> x) + (\\<pi> y) ) \\<in> M\\<close>"], ["proof (prove)\nusing this:\n  csubspace M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) - (\\<pi> x + \\<pi> y) \\<in> M", "by (simp add: complex_vector.subspace_add complex_vector.subspace_diff f1)"], ["proof (state)\nthis:\n  \\<pi> (x + y) - (\\<pi> x + \\<pi> y) \\<in> M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "have \\<open>closed_csubspace (orthogonal_complement M)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (orthogonal_complement M)", "using a2"], ["proof (prove)\nusing this:\n  closed_csubspace M\n\ngoal (1 subgoal):\n 1. closed_csubspace (orthogonal_complement M)", "by simp"], ["proof (state)\nthis:\n  closed_csubspace (orthogonal_complement M)\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "have f1: \"\\<forall>a b. (b::'a) + (a - b) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. b + (a - b) = a", "by (metis add.commute diff_add_cancel)"], ["proof (state)\nthis:\n  \\<forall>a b. b + (a - b) = a\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "have f2: \"\\<forall>a b. (b::'a) - b = a - a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. b - b = a - a", "by auto"], ["proof (state)\nthis:\n  \\<forall>a b. b - b = a - a\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "hence f3: \"\\<forall>a. a - a \\<in> orthogonal_complement M\""], ["proof (prove)\nusing this:\n  \\<forall>a b. b - b = a - a\n\ngoal (1 subgoal):\n 1. \\<forall>a. a - a \\<in> orthogonal_complement M", "by (simp add: complex_vector.subspace_0)"], ["proof (state)\nthis:\n  \\<forall>a. a - a \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "have \"\\<forall>a b. (a \\<in> orthogonal_complement M \\<or> a + b \\<notin> orthogonal_complement M)\n             \\<or> b \\<notin> orthogonal_complement M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       (a \\<in> orthogonal_complement M \\<or>\n        a + b \\<notin> orthogonal_complement M) \\<or>\n       b \\<notin> orthogonal_complement M", "using add_diff_cancel_right' b1 complex_vector.subspace_diff"], ["proof (prove)\nusing this:\n  ?a + ?b - ?b = ?a\n  csubspace (orthogonal_complement M)\n  \\<lbrakk>csubspace ?S; ?x \\<in> ?S; ?y \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> ?x - ?y \\<in> ?S\n\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       (a \\<in> orthogonal_complement M \\<or>\n        a + b \\<notin> orthogonal_complement M) \\<or>\n       b \\<notin> orthogonal_complement M", "by metis"], ["proof (state)\nthis:\n  \\<forall>a b.\n     (a \\<in> orthogonal_complement M \\<or>\n      a + b \\<notin> orthogonal_complement M) \\<or>\n     b \\<notin> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "hence \"\\<forall>a b c. (a \\<in> orthogonal_complement M \\<or> c - (b + a) \\<notin> orthogonal_complement M) \n              \\<or> c - b \\<notin> orthogonal_complement M\""], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     (a \\<in> orthogonal_complement M \\<or>\n      a + b \\<notin> orthogonal_complement M) \\<or>\n     b \\<notin> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<forall>a b c.\n       (a \\<in> orthogonal_complement M \\<or>\n        c - (b + a) \\<notin> orthogonal_complement M) \\<or>\n       c - b \\<notin> orthogonal_complement M", "using f1"], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     (a \\<in> orthogonal_complement M \\<or>\n      a + b \\<notin> orthogonal_complement M) \\<or>\n     b \\<notin> orthogonal_complement M\n  \\<forall>a b. b + (a - b) = a\n\ngoal (1 subgoal):\n 1. \\<forall>a b c.\n       (a \\<in> orthogonal_complement M \\<or>\n        c - (b + a) \\<notin> orthogonal_complement M) \\<or>\n       c - b \\<notin> orthogonal_complement M", "by (metis diff_diff_add)"], ["proof (state)\nthis:\n  \\<forall>a b c.\n     (a \\<in> orthogonal_complement M \\<or>\n      c - (b + a) \\<notin> orthogonal_complement M) \\<or>\n     c - b \\<notin> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "hence f4: \"\\<forall>a b f. (f a - b \\<in> orthogonal_complement M \\<or> a - b \\<notin> orthogonal_complement M) \n              \\<or> \\<not> is_projection_on f M\""], ["proof (prove)\nusing this:\n  \\<forall>a b c.\n     (a \\<in> orthogonal_complement M \\<or>\n      c - (b + a) \\<notin> orthogonal_complement M) \\<or>\n     c - b \\<notin> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<forall>a b f.\n       (f a - b \\<in> orthogonal_complement M \\<or>\n        a - b \\<notin> orthogonal_complement M) \\<or>\n       \\<not> is_projection_on f M", "using f1"], ["proof (prove)\nusing this:\n  \\<forall>a b c.\n     (a \\<in> orthogonal_complement M \\<or>\n      c - (b + a) \\<notin> orthogonal_complement M) \\<or>\n     c - b \\<notin> orthogonal_complement M\n  \\<forall>a b. b + (a - b) = a\n\ngoal (1 subgoal):\n 1. \\<forall>a b f.\n       (f a - b \\<in> orthogonal_complement M \\<or>\n        a - b \\<notin> orthogonal_complement M) \\<or>\n       \\<not> is_projection_on f M", "by (metis a2 is_projection_on_iff_orthog)"], ["proof (state)\nthis:\n  \\<forall>a b f.\n     (f a - b \\<in> orthogonal_complement M \\<or>\n      a - b \\<notin> orthogonal_complement M) \\<or>\n     \\<not> is_projection_on f M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "have f5: \"\\<forall>a b c d. (d::'a) - (c + (b - a)) = d + (a - (b + c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b c d. d - (c + (b - a)) = d + (a - (b + c))", "by auto"], ["proof (state)\nthis:\n  \\<forall>a b c d. d - (c + (b - a)) = d + (a - (b + c))\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "have \"x - \\<pi> x \\<in> orthogonal_complement M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - \\<pi> x \\<in> orthogonal_complement M", "using a1 a2 is_projection_on_iff_orthog"], ["proof (prove)\nusing this:\n  is_projection_on \\<pi> M\n  closed_csubspace M\n  closed_csubspace ?M \\<Longrightarrow>\n  is_projection_on ?\\<pi> ?M =\n  (\\<forall>h.\n      h - ?\\<pi> h \\<in> orthogonal_complement ?M \\<and> ?\\<pi> h \\<in> ?M)\n\ngoal (1 subgoal):\n 1. x - \\<pi> x \\<in> orthogonal_complement M", "by blast"], ["proof (state)\nthis:\n  x - \\<pi> x \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "hence q1: \\<open>\\<pi> (x + y) - ( (\\<pi> x) + (\\<pi> y) ) \\<in> orthogonal_complement M\\<close>"], ["proof (prove)\nusing this:\n  x - \\<pi> x \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) - (\\<pi> x + \\<pi> y) \\<in> orthogonal_complement M", "using f5 f4 f3"], ["proof (prove)\nusing this:\n  x - \\<pi> x \\<in> orthogonal_complement M\n  \\<forall>a b c d. d - (c + (b - a)) = d + (a - (b + c))\n  \\<forall>a b f.\n     (f a - b \\<in> orthogonal_complement M \\<or>\n      a - b \\<notin> orthogonal_complement M) \\<or>\n     \\<not> is_projection_on f M\n  \\<forall>a. a - a \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) - (\\<pi> x + \\<pi> y) \\<in> orthogonal_complement M", "by (metis \\<open>csubspace (orthogonal_complement M)\\<close> \n          \\<open>is_projection_on \\<pi> M\\<close> add_diff_eq complex_vector.subspace_diff diff_diff_add \n          diff_diff_eq2)"], ["proof (state)\nthis:\n  \\<pi> (x + y) - (\\<pi> x + \\<pi> y) \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "hence \\<open>\\<pi> (x + y) - ( (\\<pi> x) + (\\<pi> y) ) \\<in> M \\<inter> (orthogonal_complement M)\\<close>"], ["proof (prove)\nusing this:\n  \\<pi> (x + y) - (\\<pi> x + \\<pi> y) \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) - (\\<pi> x + \\<pi> y)\n    \\<in> M \\<inter> orthogonal_complement M", "by (simp add: \\<open>\\<pi> (x + y) - (\\<pi> x + \\<pi> y) \\<in> M\\<close>)"], ["proof (state)\nthis:\n  \\<pi> (x + y) - (\\<pi> x + \\<pi> y)\n  \\<in> M \\<inter> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "moreover"], ["proof (state)\nthis:\n  \\<pi> (x + y) - (\\<pi> x + \\<pi> y)\n  \\<in> M \\<inter> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "have \\<open>M \\<inter> (orthogonal_complement M) = {0}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<inter> orthogonal_complement M = {0::'a}", "by (simp add: \\<open>closed_csubspace M\\<close> complex_vector.subspace_0 orthogonal_complement_zero_intersection)"], ["proof (state)\nthis:\n  M \\<inter> orthogonal_complement M = {0::'a}\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "ultimately"], ["proof (chain)\npicking this:\n  \\<pi> (x + y) - (\\<pi> x + \\<pi> y)\n  \\<in> M \\<inter> orthogonal_complement M\n  M \\<inter> orthogonal_complement M = {0::'a}", "have \\<open>\\<pi> (x + y) - ( (\\<pi> x) + (\\<pi> y) ) = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<pi> (x + y) - (\\<pi> x + \\<pi> y)\n  \\<in> M \\<inter> orthogonal_complement M\n  M \\<inter> orthogonal_complement M = {0::'a}\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) - (\\<pi> x + \\<pi> y) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<pi> (x + y) - (\\<pi> x + \\<pi> y) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<pi> (x + y) - (\\<pi> x + \\<pi> y) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<pi> (x + y) = \\<pi> x + \\<pi> y", "by simp"], ["proof (state)\nthis:\n  \\<pi> (x + y) = \\<pi> x + \\<pi> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pi> (?x + ?y) = \\<pi> ?x + \\<pi> ?y\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (\\<pi> x) \\<le> norm x * K", "from is_projection_on_reduces_norm"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_projection_on ?\\<pi> ?M; closed_csubspace ?M\\<rbrakk>\n  \\<Longrightarrow> norm (?\\<pi> ?h) \\<le> norm ?h", "show t1: \\<open>\\<exists> K. \\<forall> x. norm (\\<pi> x) \\<le> norm x * K\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_projection_on ?\\<pi> ?M; closed_csubspace ?M\\<rbrakk>\n  \\<Longrightarrow> norm (?\\<pi> ?h) \\<le> norm ?h\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (\\<pi> x) \\<le> norm x * K", "by (metis a1 a2 mult.left_neutral ordered_field_class.sign_simps(5))"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>x. norm (\\<pi> x) \\<le> norm x * K\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem projection_bounded_clinear:\n  fixes M :: \\<open>('a::chilbert_space) set\\<close>\n  assumes a1: \"closed_csubspace M\"\n  shows \\<open>bounded_clinear (projection M)\\<close> \n    \\<comment> \\<open>Theorem 2.7 in @{cite conway2013course}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (projection M)", "using assms is_projection_on_iff_orthog orthog_proj_exists is_projection_on_bounded_clinear projection_eqI"], ["proof (prove)\nusing this:\n  closed_csubspace M\n  closed_csubspace ?M \\<Longrightarrow>\n  is_projection_on ?\\<pi> ?M =\n  (\\<forall>h.\n      h - ?\\<pi> h \\<in> orthogonal_complement ?M \\<and> ?\\<pi> h \\<in> ?M)\n  closed_csubspace ?M \\<Longrightarrow>\n  \\<exists>k. ?h - k \\<in> orthogonal_complement ?M \\<and> k \\<in> ?M\n  \\<lbrakk>is_projection_on ?\\<pi> ?M; closed_csubspace ?M\\<rbrakk>\n  \\<Longrightarrow> bounded_clinear ?\\<pi>\n  \\<lbrakk>closed_csubspace ?M; ?h - ?x \\<in> orthogonal_complement ?M;\n   ?x \\<in> ?M\\<rbrakk>\n  \\<Longrightarrow> projection ?M ?h = ?x\n\ngoal (1 subgoal):\n 1. bounded_clinear (projection M)", "by blast"], ["", "proposition is_projection_on_idem:\n  fixes M :: \\<open>('a::complex_inner) set\\<close>\n  assumes \"is_projection_on \\<pi> M\"\n  shows \"\\<pi> (\\<pi> x) = \\<pi> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> (\\<pi> x) = \\<pi> x", "using is_projection_on_fixes_image is_projection_on_in_image assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_projection_on ?\\<pi> ?M; ?x \\<in> ?M\\<rbrakk>\n  \\<Longrightarrow> ?\\<pi> ?x = ?x\n  is_projection_on ?\\<pi> ?M \\<Longrightarrow> ?\\<pi> ?h \\<in> ?M\n  is_projection_on \\<pi> M\n\ngoal (1 subgoal):\n 1. \\<pi> (\\<pi> x) = \\<pi> x", "by blast"], ["", "proposition projection_idem:\n  fixes M :: \"'a::chilbert_space set\"\n  assumes a1: \"closed_csubspace M\"\n  shows \"projection M (projection M x) = projection M x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. projection M (projection M x) = projection M x", "by (metis assms closed_csubspace.closed closed_csubspace.subspace complex_vector.subspace_0 csubspace_is_convex equals0D projection_fixes_image projection_in_image)"], ["", "proposition is_projection_on_kernel_is_orthogonal_complement:\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes a1: \"is_projection_on \\<pi> M\" and a2: \"closed_csubspace M\"\n  shows \"\\<pi> -` {0} = orthogonal_complement M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> -` {0::'a} = orthogonal_complement M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pi> -` {0::'a} = orthogonal_complement M", "have \"x \\<in> (\\<pi> -` {0})\" \n    if \"x \\<in> orthogonal_complement M\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<pi> -` {0::'a}", "by (smt (verit, ccfv_SIG) a1 a2 closed_csubspace_def complex_vector.subspace_def complex_vector.subspace_diff is_projection_on_eqI orthogonal_complement_closed_subspace that vimage_singleton_eq)"], ["proof (state)\nthis:\n  ?x \\<in> orthogonal_complement M \\<Longrightarrow>\n  ?x \\<in> \\<pi> -` {0::'a}\n\ngoal (1 subgoal):\n 1. \\<pi> -` {0::'a} = orthogonal_complement M", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> orthogonal_complement M \\<Longrightarrow>\n  ?x \\<in> \\<pi> -` {0::'a}\n\ngoal (1 subgoal):\n 1. \\<pi> -` {0::'a} = orthogonal_complement M", "have \"x \\<in> orthogonal_complement M\"\n    if s1: \"x \\<in> \\<pi> -` {0}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement M", "by (metis a1 a2 diff_zero is_projection_on_iff_orthog that vimage_singleton_eq)"], ["proof (state)\nthis:\n  ?x \\<in> \\<pi> -` {0::'a} \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<pi> -` {0::'a} = orthogonal_complement M", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> orthogonal_complement M \\<Longrightarrow>\n  ?x \\<in> \\<pi> -` {0::'a}\n  ?x \\<in> \\<pi> -` {0::'a} \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement M", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> orthogonal_complement M \\<Longrightarrow>\n  ?x \\<in> \\<pi> -` {0::'a}\n  ?x \\<in> \\<pi> -` {0::'a} \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<pi> -` {0::'a} = orthogonal_complement M", "by blast"], ["proof (state)\nthis:\n  \\<pi> -` {0::'a} = orthogonal_complement M\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>Theorem 2.7 in @{cite conway2013course}\\<close>"], ["", "proposition projection_kernel_is_orthogonal_complement:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \"closed_csubspace M\"\n  shows \"(projection M) -` {0} = (orthogonal_complement M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. projection M -` {0::'a} = orthogonal_complement M", "by (metis assms closed_csubspace_def complex_vector.subspace_def csubspace_is_convex insert_absorb insert_not_empty is_projection_on_kernel_is_orthogonal_complement projection_is_projection_on)"], ["", "lemma is_projection_on_id_minus:\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes is_proj: \"is_projection_on \\<pi> M\"\n    and cc: \"closed_csubspace M\"\n  shows \"is_projection_on (id - \\<pi>) (orthogonal_complement M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_projection_on (id - \\<pi>) (orthogonal_complement M)", "using is_proj"], ["proof (prove)\nusing this:\n  is_projection_on \\<pi> M\n\ngoal (1 subgoal):\n 1. is_projection_on (id - \\<pi>) (orthogonal_complement M)", "apply (simp add: cc is_projection_on_iff_orthog)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h.\n       h - \\<pi> h \\<in> orthogonal_complement M \\<and>\n       \\<pi> h \\<in> M \\<Longrightarrow>\n    \\<forall>h.\n       \\<pi> h \\<in> orthogonal_complement (orthogonal_complement M)", "using double_orthogonal_complement_increasing"], ["proof (prove)\nusing this:\n  ?M \\<subseteq> orthogonal_complement (orthogonal_complement ?M)\n\ngoal (1 subgoal):\n 1. \\<forall>h.\n       h - \\<pi> h \\<in> orthogonal_complement M \\<and>\n       \\<pi> h \\<in> M \\<Longrightarrow>\n    \\<forall>h.\n       \\<pi> h \\<in> orthogonal_complement (orthogonal_complement M)", "by blast"], ["", "text \\<open>Exercise 2 (section 2, chapter I) in  @{cite conway2013course}\\<close>"], ["", "lemma projection_on_orthogonal_complement[simp]:\n  fixes M :: \"'a::chilbert_space set\"\n  assumes a1: \"closed_csubspace M\"\n  shows \"projection (orthogonal_complement M) = id - projection M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. projection (orthogonal_complement M) = id - projection M", "apply (auto intro!: ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. projection (orthogonal_complement M) x = x - projection M x", "by (smt (verit, ccfv_SIG) add_diff_cancel_left' assms closed_csubspace.closed closed_csubspace.subspace complex_vector.subspace_0 csubspace_is_convex diff_add_cancel double_orthogonal_complement_increasing insert_absorb insert_not_empty is_projection_on_iff_orthog orthogonal_complement_closed_subspace projection_eqI projection_is_projection_on subset_eq)"], ["", "lemma is_projection_on_zero:\n  \"is_projection_on (\\<lambda>_. 0) {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_projection_on (\\<lambda>_. 0::'a) {0::'a}", "by (simp add: is_projection_on_def is_arg_min_def)"], ["", "lemma projection_zero[simp]:\n  \"projection {0} = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. projection {0::'a} = (\\<lambda>_. 0::'a)", "using is_projection_on_zero"], ["proof (prove)\nusing this:\n  is_projection_on (\\<lambda>_. 0::?'a) {0::?'a}\n\ngoal (1 subgoal):\n 1. projection {0::'a} = (\\<lambda>_. 0::'a)", "by (metis (full_types) is_projection_on_in_image projection_def singletonD someI_ex)"], ["", "lemma is_projection_on_rank1:\n  fixes t :: \\<open>'a::complex_inner\\<close>\n  shows \\<open>is_projection_on (\\<lambda>x. (\\<langle>t , x\\<rangle> / \\<langle>t , t\\<rangle>) *\\<^sub>C t) (cspan {t})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "proof (cases \\<open>t = 0\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. t = (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})\n 2. t \\<noteq> (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "case True"], ["proof (state)\nthis:\n  t = (0::'a)\n\ngoal (2 subgoals):\n 1. t = (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})\n 2. t \\<noteq> (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "then"], ["proof (chain)\npicking this:\n  t = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  t = (0::'a)\n\ngoal (1 subgoal):\n 1. is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "by (simp add: is_projection_on_zero)"], ["proof (state)\nthis:\n  is_projection_on\n   (\\<lambda>x.\n       (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n   (cspan {t})\n\ngoal (1 subgoal):\n 1. t \\<noteq> (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "case False"], ["proof (state)\nthis:\n  t \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. t \\<noteq> (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "define P where \\<open>P x = (\\<langle>t , x\\<rangle> / \\<langle>t , t\\<rangle>) *\\<^sub>C t\\<close> for x"], ["proof (state)\nthis:\n  P ?x = (\\<langle>t, ?x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t\n\ngoal (1 subgoal):\n 1. t \\<noteq> (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "define t' where \\<open>t' = t /\\<^sub>C norm t\\<close>"], ["proof (state)\nthis:\n  t' = t /\\<^sub>C complex_of_real (norm t)\n\ngoal (1 subgoal):\n 1. t \\<noteq> (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "with False"], ["proof (chain)\npicking this:\n  t \\<noteq> (0::'a)\n  t' = t /\\<^sub>C complex_of_real (norm t)", "have \\<open>norm t' = 1\\<close>"], ["proof (prove)\nusing this:\n  t \\<noteq> (0::'a)\n  t' = t /\\<^sub>C complex_of_real (norm t)\n\ngoal (1 subgoal):\n 1. norm t' = 1", "by (simp add: norm_inverse)"], ["proof (state)\nthis:\n  norm t' = 1\n\ngoal (1 subgoal):\n 1. t \\<noteq> (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "have P_def': \\<open>P x = cinner t' x *\\<^sub>C t'\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. P x = \\<langle>t', x\\<rangle> *\\<^sub>C t'", "unfolding P_def t'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t =\n    \\<langle>t /\\<^sub>C complex_of_real (norm t), x\\<rangle> *\\<^sub>C\n    (t /\\<^sub>C complex_of_real (norm t))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle> =\n    inverse (complex_of_real (norm t)) * \\<langle>t, x\\<rangle> *\n    inverse (complex_of_real (norm t))", "by (metis divide_divide_eq_left divide_inverse mult.commute power2_eq_square power2_norm_eq_cinner)"], ["proof (state)\nthis:\n  P ?x = \\<langle>t', ?x\\<rangle> *\\<^sub>C t'\n\ngoal (1 subgoal):\n 1. t \\<noteq> (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "have spant': \\<open>cspan {t} = cspan {t'}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan {t} = cspan {t'}", "by (simp add: False t'_def)"], ["proof (state)\nthis:\n  cspan {t} = cspan {t'}\n\ngoal (1 subgoal):\n 1. t \\<noteq> (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "have cc: \\<open>closed_csubspace (cspan {t})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (cspan {t})", "by (auto intro!: finite_cspan_closed closed_csubspace.intro)"], ["proof (state)\nthis:\n  closed_csubspace (cspan {t})\n\ngoal (1 subgoal):\n 1. t \\<noteq> (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "have ortho: \\<open>h - P h \\<in> orthogonal_complement (cspan {t})\\<close> for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. h - P h \\<in> orthogonal_complement (cspan {t})", "unfolding orthogonal_complement_def P_def' spant'"], ["proof (prove)\ngoal (1 subgoal):\n 1. h - \\<langle>t', h\\<rangle> *\\<^sub>C t'\n    \\<in> {x |x. \\<forall>y\\<in>cspan {t'}. is_orthogonal x y}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> cspan {t'} \\<Longrightarrow>\n       is_orthogonal (h - \\<langle>t', h\\<rangle> *\\<^sub>C t') y", "by (smt (verit, ccfv_threshold) \\<open>norm t' = 1\\<close> add_cancel_right_left cinner_add_right cinner_commute' cinner_scaleC_right cnorm_eq_1 complex_vector.span_breakdown_eq complex_vector.span_empty diff_add_cancel mult_cancel_left1 singletonD)"], ["proof (state)\nthis:\n  ?h - P ?h \\<in> orthogonal_complement (cspan {t})\n\ngoal (1 subgoal):\n 1. t \\<noteq> (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "have inspan: \\<open>P h \\<in> cspan {t}\\<close> for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. P h \\<in> cspan {t}", "unfolding P_def' spant'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>t', h\\<rangle> *\\<^sub>C t' \\<in> cspan {t'}", "by (simp add: complex_vector.span_base complex_vector.span_scale)"], ["proof (state)\nthis:\n  P ?h \\<in> cspan {t}\n\ngoal (1 subgoal):\n 1. t \\<noteq> (0::'a) \\<Longrightarrow>\n    is_projection_on\n     (\\<lambda>x.\n         (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "show \\<open>is_projection_on P (cspan {t})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_projection_on P (cspan {t})", "apply (subst is_projection_on_iff_orthog)"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed_csubspace (cspan {t})\n 2. \\<forall>h.\n       h - P h \\<in> orthogonal_complement (cspan {t}) \\<and>\n       P h \\<in> cspan {t}", "using cc ortho inspan"], ["proof (prove)\nusing this:\n  closed_csubspace (cspan {t})\n  ?h - P ?h \\<in> orthogonal_complement (cspan {t})\n  P ?h \\<in> cspan {t}\n\ngoal (2 subgoals):\n 1. closed_csubspace (cspan {t})\n 2. \\<forall>h.\n       h - P h \\<in> orthogonal_complement (cspan {t}) \\<and>\n       P h \\<in> cspan {t}", "by auto"], ["proof (state)\nthis:\n  is_projection_on P (cspan {t})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma projection_rank1:\n  fixes t x :: \\<open>'a::complex_inner\\<close>\n  shows \\<open>projection (cspan {t}) x = (\\<langle>t , x\\<rangle> / \\<langle>t , t\\<rangle>) *\\<^sub>C t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection (cspan {t}) x =\n    (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t", "apply (rule fun_cong, rule projection_eqI', simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_projection_on\n     (\\<lambda>a.\n         (\\<langle>t, a\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t)\n     (cspan {t})", "by (rule is_projection_on_rank1)"], ["", "subsection \\<open>More orthogonal complement\\<close>"], ["", "text \\<open>The following lemmas logically fit into the \"orthogonality\" section but depend on projections for their proofs.\\<close>"], ["", "text \\<open>Corollary 2.8 in  @{cite conway2013course}\\<close>"], ["", "theorem double_orthogonal_complement_id[simp]:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes a1: \"closed_csubspace M\"\n  shows \"orthogonal_complement (orthogonal_complement M) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement M) = M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement M) = M", "have b2: \"x \\<in> (id - projection M) -` {0}\"\n    if c1: \"x \\<in> M\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (id - projection M) -` {0::'a}", "by (simp add: assms projection_fixes_image that)"], ["proof (state)\nthis:\n  ?x \\<in> M \\<Longrightarrow> ?x \\<in> (id - projection M) -` {0::'a}\n\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement M) = M", "have b3: \\<open>x \\<in> M\\<close> \n    if c1: \\<open>x \\<in> (id - projection M) -` {0}\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> M", "by (metis assms closed_csubspace.closed closed_csubspace.subspace complex_vector.subspace_0 csubspace_is_convex eq_id_iff equals0D fun_diff_def projection_in_image right_minus_eq that vimage_singleton_eq)"], ["proof (state)\nthis:\n  ?x \\<in> (id - projection M) -` {0::'a} \\<Longrightarrow> ?x \\<in> M\n\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement M) = M", "have \\<open>x \\<in>  M \\<longleftrightarrow> x \\<in> (id - projection M) -` {0}\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> M) = (x \\<in> (id - projection M) -` {0::'a})", "using b2 b3"], ["proof (prove)\nusing this:\n  ?x \\<in> M \\<Longrightarrow> ?x \\<in> (id - projection M) -` {0::'a}\n  ?x \\<in> (id - projection M) -` {0::'a} \\<Longrightarrow> ?x \\<in> M\n\ngoal (1 subgoal):\n 1. (x \\<in> M) = (x \\<in> (id - projection M) -` {0::'a})", "by blast"], ["proof (state)\nthis:\n  (?x \\<in> M) = (?x \\<in> (id - projection M) -` {0::'a})\n\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement M) = M", "hence b4: \\<open>( id - (projection M) ) -` {0} =  M\\<close>"], ["proof (prove)\nusing this:\n  (?x \\<in> M) = (?x \\<in> (id - projection M) -` {0::'a})\n\ngoal (1 subgoal):\n 1. (id - projection M) -` {0::'a} = M", "by blast"], ["proof (state)\nthis:\n  (id - projection M) -` {0::'a} = M\n\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement M) = M", "have b1: \"orthogonal_complement (orthogonal_complement M) \n          = (projection (orthogonal_complement M)) -` {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement M) =\n    projection (orthogonal_complement M) -` {0::'a}", "by (simp add: a1 projection_kernel_is_orthogonal_complement del: projection_on_orthogonal_complement)"], ["proof (state)\nthis:\n  orthogonal_complement (orthogonal_complement M) =\n  projection (orthogonal_complement M) -` {0::'a}\n\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement M) = M", "also"], ["proof (state)\nthis:\n  orthogonal_complement (orthogonal_complement M) =\n  projection (orthogonal_complement M) -` {0::'a}\n\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement M) = M", "have \\<open>... = ( id - (projection M) ) -` {0}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection (orthogonal_complement M) -` {0::'a} =\n    (id - projection M) -` {0::'a}", "by (simp add: a1)"], ["proof (state)\nthis:\n  projection (orthogonal_complement M) -` {0::'a} =\n  (id - projection M) -` {0::'a}\n\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement M) = M", "also"], ["proof (state)\nthis:\n  projection (orthogonal_complement M) -` {0::'a} =\n  (id - projection M) -` {0::'a}\n\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement M) = M", "have \\<open>... = M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id - projection M) -` {0::'a} = M", "by (simp add: b4)"], ["proof (state)\nthis:\n  (id - projection M) -` {0::'a} = M\n\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement M) = M", "finally"], ["proof (chain)\npicking this:\n  orthogonal_complement (orthogonal_complement M) = M", "show ?thesis"], ["proof (prove)\nusing this:\n  orthogonal_complement (orthogonal_complement M) = M\n\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement M) = M", "by blast"], ["proof (state)\nthis:\n  orthogonal_complement (orthogonal_complement M) = M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthogonal_complement_antimono[simp]:\n  fixes  A B :: \\<open>('a::complex_inner) set\\<close>\n  assumes \"A \\<supseteq> B\"\n  shows \\<open>orthogonal_complement A \\<subseteq> orthogonal_complement B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement A \\<subseteq> orthogonal_complement B", "by (meson assms orthogonal_complementI orthogonal_complement_orthoI' subsetD subsetI)"], ["", "lemma orthogonal_complement_antimono_iff[simp]:\n  fixes  A B :: \\<open>('a::chilbert_space) set\\<close>\n  assumes \\<open>closed_csubspace A\\<close> and  \\<open>closed_csubspace B\\<close>\n  shows \\<open>orthogonal_complement A \\<subseteq> orthogonal_complement B \\<longleftrightarrow> A \\<supseteq> B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (orthogonal_complement A \\<subseteq> orthogonal_complement B) =\n    (B \\<subseteq> A)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. orthogonal_complement A\n    \\<subseteq> orthogonal_complement B \\<Longrightarrow>\n    B \\<subseteq> A\n 2. B \\<subseteq> A \\<Longrightarrow>\n    orthogonal_complement A \\<subseteq> orthogonal_complement B", "show \\<open>orthogonal_complement A \\<subseteq> orthogonal_complement B\\<close> if \\<open>A \\<supseteq> B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement A \\<subseteq> orthogonal_complement B", "using that"], ["proof (prove)\nusing this:\n  B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. orthogonal_complement A \\<subseteq> orthogonal_complement B", "by auto"], ["proof (state)\nthis:\n  B \\<subseteq> A \\<Longrightarrow>\n  orthogonal_complement A \\<subseteq> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. orthogonal_complement A\n    \\<subseteq> orthogonal_complement B \\<Longrightarrow>\n    B \\<subseteq> A", "assume \\<open>orthogonal_complement A \\<subseteq> orthogonal_complement B\\<close>"], ["proof (state)\nthis:\n  orthogonal_complement A \\<subseteq> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. orthogonal_complement A\n    \\<subseteq> orthogonal_complement B \\<Longrightarrow>\n    B \\<subseteq> A", "then"], ["proof (chain)\npicking this:\n  orthogonal_complement A \\<subseteq> orthogonal_complement B", "have \\<open>orthogonal_complement (orthogonal_complement A) \\<supseteq> orthogonal_complement (orthogonal_complement B)\\<close>"], ["proof (prove)\nusing this:\n  orthogonal_complement A \\<subseteq> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement B)\n    \\<subseteq> orthogonal_complement (orthogonal_complement A)", "by simp"], ["proof (state)\nthis:\n  orthogonal_complement (orthogonal_complement B)\n  \\<subseteq> orthogonal_complement (orthogonal_complement A)\n\ngoal (1 subgoal):\n 1. orthogonal_complement A\n    \\<subseteq> orthogonal_complement B \\<Longrightarrow>\n    B \\<subseteq> A", "then"], ["proof (chain)\npicking this:\n  orthogonal_complement (orthogonal_complement B)\n  \\<subseteq> orthogonal_complement (orthogonal_complement A)", "show \\<open>A \\<supseteq> B\\<close>"], ["proof (prove)\nusing this:\n  orthogonal_complement (orthogonal_complement B)\n  \\<subseteq> orthogonal_complement (orthogonal_complement A)\n\ngoal (1 subgoal):\n 1. B \\<subseteq> A", "using assms"], ["proof (prove)\nusing this:\n  orthogonal_complement (orthogonal_complement B)\n  \\<subseteq> orthogonal_complement (orthogonal_complement A)\n  closed_csubspace A\n  closed_csubspace B\n\ngoal (1 subgoal):\n 1. B \\<subseteq> A", "by auto"], ["proof (state)\nthis:\n  B \\<subseteq> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthogonal_complement_UNIV[simp]: \n  \"orthogonal_complement UNIV = {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement UNIV = {0::'a}", "by (metis Int_UNIV_left complex_vector.subspace_UNIV complex_vector.subspace_def orthogonal_complement_zero_intersection)"], ["", "lemma orthogonal_complement_zero[simp]:\n  \"orthogonal_complement {0} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement {0::'a} = UNIV", "unfolding orthogonal_complement_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x |x. \\<forall>y\\<in>{0::'a}. is_orthogonal x y} = UNIV", "by auto"], ["", "lemma de_morgan_orthogonal_complement_plus:        \n  fixes A B::\"('a::complex_inner) set\"\n  assumes \\<open>0 \\<in> A\\<close> and \\<open>0 \\<in> B\\<close>\n  shows \\<open>orthogonal_complement (A +\\<^sub>M B) = (orthogonal_complement A) \\<inter> (orthogonal_complement B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement (A +\\<^sub>M B) =\n    orthogonal_complement A \\<inter> orthogonal_complement B", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. orthogonal_complement (A +\\<^sub>M B) =\n    orthogonal_complement A \\<inter> orthogonal_complement B", "have \"x \\<in> (orthogonal_complement A) \\<inter> (orthogonal_complement B)\"\n    if \"x \\<in> orthogonal_complement (A +\\<^sub>M B)\" \n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B", "have \\<open>orthogonal_complement (A +\\<^sub>M B) = orthogonal_complement (A + B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement (A +\\<^sub>M B) = orthogonal_complement (A + B)", "unfolding closed_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement (closure (A + B)) = orthogonal_complement (A + B)", "by (subst orthogonal_complement_of_closure[symmetric], simp)"], ["proof (state)\nthis:\n  orthogonal_complement (A +\\<^sub>M B) = orthogonal_complement (A + B)\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B", "hence \\<open>x \\<in> orthogonal_complement (A + B)\\<close>"], ["proof (prove)\nusing this:\n  orthogonal_complement (A +\\<^sub>M B) = orthogonal_complement (A + B)\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A + B)", "using that"], ["proof (prove)\nusing this:\n  orthogonal_complement (A +\\<^sub>M B) = orthogonal_complement (A + B)\n  x \\<in> orthogonal_complement (A +\\<^sub>M B)\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A + B)", "by blast"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement (A + B)\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B", "hence t1: \\<open>\\<forall>z \\<in> (A + B). \\<langle> z , x \\<rangle> = 0\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement (A + B)\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>A + B. is_orthogonal z x", "by (simp add: orthogonal_complement_orthoI')"], ["proof (state)\nthis:\n  \\<forall>z\\<in>A + B. is_orthogonal z x\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B", "have \\<open>A \\<subseteq> A + B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> A + B", "using subset_iff add.commute set_zero_plus2 \\<open>0 \\<in> B\\<close>"], ["proof (prove)\nusing this:\n  (?A \\<subseteq> ?B) =\n  (\\<forall>t. t \\<in> ?A \\<longrightarrow> t \\<in> ?B)\n  ?a + ?b = ?b + ?a\n  (0::?'a) \\<in> ?A \\<Longrightarrow> ?B \\<subseteq> ?A + ?B\n  (0::'a) \\<in> B\n\ngoal (1 subgoal):\n 1. A \\<subseteq> A + B", "by fastforce"], ["proof (state)\nthis:\n  A \\<subseteq> A + B\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B", "hence \\<open>\\<forall>z \\<in> A. \\<langle> z , x \\<rangle> = 0\\<close>"], ["proof (prove)\nusing this:\n  A \\<subseteq> A + B\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>A. is_orthogonal z x", "using t1"], ["proof (prove)\nusing this:\n  A \\<subseteq> A + B\n  \\<forall>z\\<in>A + B. is_orthogonal z x\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>A. is_orthogonal z x", "by auto"], ["proof (state)\nthis:\n  \\<forall>z\\<in>A. is_orthogonal z x\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B", "hence w1: \\<open>x \\<in> (orthogonal_complement A)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>z\\<in>A. is_orthogonal z x\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A", "by (smt mem_Collect_eq is_orthogonal_sym orthogonal_complement_def)"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B", "have \\<open>B \\<subseteq> A + B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> A + B", "using \\<open>0 \\<in> A\\<close> subset_iff set_zero_plus2"], ["proof (prove)\nusing this:\n  (0::'a) \\<in> A\n  (?A \\<subseteq> ?B) =\n  (\\<forall>t. t \\<in> ?A \\<longrightarrow> t \\<in> ?B)\n  (0::?'a) \\<in> ?A \\<Longrightarrow> ?B \\<subseteq> ?A + ?B\n\ngoal (1 subgoal):\n 1. B \\<subseteq> A + B", "by blast"], ["proof (state)\nthis:\n  B \\<subseteq> A + B\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B", "hence \\<open>\\<forall> z \\<in> B. \\<langle> z , x \\<rangle> = 0\\<close>"], ["proof (prove)\nusing this:\n  B \\<subseteq> A + B\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>B. is_orthogonal z x", "using t1"], ["proof (prove)\nusing this:\n  B \\<subseteq> A + B\n  \\<forall>z\\<in>A + B. is_orthogonal z x\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>B. is_orthogonal z x", "by auto"], ["proof (state)\nthis:\n  \\<forall>z\\<in>B. is_orthogonal z x\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B", "hence \\<open>x \\<in> (orthogonal_complement B)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>z\\<in>B. is_orthogonal z x\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement B", "by (smt mem_Collect_eq is_orthogonal_sym orthogonal_complement_def)"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B", "using w1"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement B\n  x \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B", "by auto"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> orthogonal_complement (A +\\<^sub>M B) \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. orthogonal_complement (A +\\<^sub>M B) =\n    orthogonal_complement A \\<inter> orthogonal_complement B", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> orthogonal_complement (A +\\<^sub>M B) \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. orthogonal_complement (A +\\<^sub>M B) =\n    orthogonal_complement A \\<inter> orthogonal_complement B", "have \"x \\<in> (orthogonal_complement (A +\\<^sub>M B))\"\n    if v1: \"x \\<in> (orthogonal_complement A) \\<inter> (orthogonal_complement B)\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "have \\<open>x \\<in> (orthogonal_complement A)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A", "using v1"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement A", "by blast"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "hence \\<open>\\<forall>y\\<in> A. \\<langle> y , x \\<rangle> = 0\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>A. is_orthogonal y x", "by (simp add: orthogonal_complement_orthoI')"], ["proof (state)\nthis:\n  \\<forall>y\\<in>A. is_orthogonal y x\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "have \\<open>x \\<in> (orthogonal_complement B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement B", "using v1"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement B", "by blast"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "hence \\<open>\\<forall> y\\<in> B. \\<langle> y , x \\<rangle> = 0\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>B. is_orthogonal y x", "by (simp add: orthogonal_complement_orthoI')"], ["proof (state)\nthis:\n  \\<forall>y\\<in>B. is_orthogonal y x\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "have \\<open>\\<forall> a\\<in>A. \\<forall> b\\<in>B. \\<langle> a+b , x \\<rangle> = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>A. \\<forall>b\\<in>B. is_orthogonal (a + b) x", "by (simp add: \\<open>\\<forall>y\\<in>A. \\<langle>y , x\\<rangle> = 0\\<close> \\<open>\\<forall>y\\<in>B. \\<langle>y , x\\<rangle> = 0\\<close> cinner_add_left)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>A. \\<forall>b\\<in>B. is_orthogonal (a + b) x\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "hence \\<open>\\<forall> y \\<in> (A + B). \\<langle> y , x \\<rangle> = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>A. \\<forall>b\\<in>B. is_orthogonal (a + b) x\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>A + B. is_orthogonal y x", "using set_plus_elim"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>A. \\<forall>b\\<in>B. is_orthogonal (a + b) x\n  \\<lbrakk>?x \\<in> ?A + ?B;\n   \\<And>a b.\n      \\<lbrakk>?x = a + b; a \\<in> ?A; b \\<in> ?B\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>A + B. is_orthogonal y x", "by force"], ["proof (state)\nthis:\n  \\<forall>y\\<in>A + B. is_orthogonal y x\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "hence \\<open>x \\<in> (orthogonal_complement (A + B))\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>A + B. is_orthogonal y x\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A + B)", "by (smt mem_Collect_eq is_orthogonal_sym orthogonal_complement_def)"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement (A + B)\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "moreover"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement (A + B)\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "have \\<open>(orthogonal_complement (A + B)) = (orthogonal_complement (A +\\<^sub>M B))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement (A + B) = orthogonal_complement (A +\\<^sub>M B)", "unfolding closed_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement (A + B) = orthogonal_complement (closure (A + B))", "by (subst orthogonal_complement_of_closure[symmetric], simp)"], ["proof (state)\nthis:\n  orthogonal_complement (A + B) = orthogonal_complement (A +\\<^sub>M B)\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> orthogonal_complement (A + B)\n  orthogonal_complement (A + B) = orthogonal_complement (A +\\<^sub>M B)", "have \\<open>x \\<in> (orthogonal_complement (A +\\<^sub>M B))\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement (A + B)\n  orthogonal_complement (A + B) = orthogonal_complement (A +\\<^sub>M B)\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "by blast"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement (A +\\<^sub>M B)\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement (A +\\<^sub>M B)\n\ngoal (1 subgoal):\n 1. x \\<in> orthogonal_complement (A +\\<^sub>M B)", "by blast"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement (A +\\<^sub>M B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> orthogonal_complement A \\<inter>\n           orthogonal_complement B \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement (A +\\<^sub>M B)\n\ngoal (1 subgoal):\n 1. orthogonal_complement (A +\\<^sub>M B) =\n    orthogonal_complement A \\<inter> orthogonal_complement B", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> orthogonal_complement (A +\\<^sub>M B) \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B\n  ?x \\<in> orthogonal_complement A \\<inter>\n           orthogonal_complement B \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement (A +\\<^sub>M B)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> orthogonal_complement (A +\\<^sub>M B) \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement A \\<inter> orthogonal_complement B\n  ?x \\<in> orthogonal_complement A \\<inter>\n           orthogonal_complement B \\<Longrightarrow>\n  ?x \\<in> orthogonal_complement (A +\\<^sub>M B)\n\ngoal (1 subgoal):\n 1. orthogonal_complement (A +\\<^sub>M B) =\n    orthogonal_complement A \\<inter> orthogonal_complement B", "by blast"], ["proof (state)\nthis:\n  orthogonal_complement (A +\\<^sub>M B) =\n  orthogonal_complement A \\<inter> orthogonal_complement B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma de_morgan_orthogonal_complement_inter:\n  fixes A B::\"'a::chilbert_space set\"\n  assumes a1: \\<open>closed_csubspace A\\<close> and a2: \\<open>closed_csubspace B\\<close>\n  shows  \\<open>orthogonal_complement (A \\<inter> B) = orthogonal_complement A +\\<^sub>M orthogonal_complement B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement (A \\<inter> B) =\n    orthogonal_complement A +\\<^sub>M orthogonal_complement B", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. orthogonal_complement (A \\<inter> B) =\n    orthogonal_complement A +\\<^sub>M orthogonal_complement B", "have \\<open>orthogonal_complement A +\\<^sub>M orthogonal_complement B\n    = orthogonal_complement (orthogonal_complement (orthogonal_complement A +\\<^sub>M orthogonal_complement B))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement A +\\<^sub>M orthogonal_complement B =\n    orthogonal_complement\n     (orthogonal_complement\n       (orthogonal_complement A +\\<^sub>M orthogonal_complement B))", "by (simp add: closed_subspace_closed_sum)"], ["proof (state)\nthis:\n  orthogonal_complement A +\\<^sub>M orthogonal_complement B =\n  orthogonal_complement\n   (orthogonal_complement\n     (orthogonal_complement A +\\<^sub>M orthogonal_complement B))\n\ngoal (1 subgoal):\n 1. orthogonal_complement (A \\<inter> B) =\n    orthogonal_complement A +\\<^sub>M orthogonal_complement B", "also"], ["proof (state)\nthis:\n  orthogonal_complement A +\\<^sub>M orthogonal_complement B =\n  orthogonal_complement\n   (orthogonal_complement\n     (orthogonal_complement A +\\<^sub>M orthogonal_complement B))\n\ngoal (1 subgoal):\n 1. orthogonal_complement (A \\<inter> B) =\n    orthogonal_complement A +\\<^sub>M orthogonal_complement B", "have \\<open>\\<dots> = orthogonal_complement (orthogonal_complement (orthogonal_complement A) \\<inter> orthogonal_complement (orthogonal_complement B))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement\n     (orthogonal_complement\n       (orthogonal_complement A +\\<^sub>M orthogonal_complement B)) =\n    orthogonal_complement\n     (orthogonal_complement (orthogonal_complement A) \\<inter>\n      orthogonal_complement (orthogonal_complement B))", "by (simp add: de_morgan_orthogonal_complement_plus orthogonal_complementI)"], ["proof (state)\nthis:\n  orthogonal_complement\n   (orthogonal_complement\n     (orthogonal_complement A +\\<^sub>M orthogonal_complement B)) =\n  orthogonal_complement\n   (orthogonal_complement (orthogonal_complement A) \\<inter>\n    orthogonal_complement (orthogonal_complement B))\n\ngoal (1 subgoal):\n 1. orthogonal_complement (A \\<inter> B) =\n    orthogonal_complement A +\\<^sub>M orthogonal_complement B", "also"], ["proof (state)\nthis:\n  orthogonal_complement\n   (orthogonal_complement\n     (orthogonal_complement A +\\<^sub>M orthogonal_complement B)) =\n  orthogonal_complement\n   (orthogonal_complement (orthogonal_complement A) \\<inter>\n    orthogonal_complement (orthogonal_complement B))\n\ngoal (1 subgoal):\n 1. orthogonal_complement (A \\<inter> B) =\n    orthogonal_complement A +\\<^sub>M orthogonal_complement B", "have \\<open>\\<dots> = orthogonal_complement (A \\<inter> B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement\n     (orthogonal_complement (orthogonal_complement A) \\<inter>\n      orthogonal_complement (orthogonal_complement B)) =\n    orthogonal_complement (A \\<inter> B)", "by (simp add: a1 a2)"], ["proof (state)\nthis:\n  orthogonal_complement\n   (orthogonal_complement (orthogonal_complement A) \\<inter>\n    orthogonal_complement (orthogonal_complement B)) =\n  orthogonal_complement (A \\<inter> B)\n\ngoal (1 subgoal):\n 1. orthogonal_complement (A \\<inter> B) =\n    orthogonal_complement A +\\<^sub>M orthogonal_complement B", "finally"], ["proof (chain)\npicking this:\n  orthogonal_complement A +\\<^sub>M orthogonal_complement B =\n  orthogonal_complement (A \\<inter> B)", "show ?thesis"], ["proof (prove)\nusing this:\n  orthogonal_complement A +\\<^sub>M orthogonal_complement B =\n  orthogonal_complement (A \\<inter> B)\n\ngoal (1 subgoal):\n 1. orthogonal_complement (A \\<inter> B) =\n    orthogonal_complement A +\\<^sub>M orthogonal_complement B", "by simp"], ["proof (state)\nthis:\n  orthogonal_complement (A \\<inter> B) =\n  orthogonal_complement A +\\<^sub>M orthogonal_complement B\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Riesz-representation theorem\\<close>"], ["", "lemma orthogonal_complement_kernel_functional:\n  fixes f :: \\<open>'a::complex_inner \\<Rightarrow> complex\\<close>\n  assumes \\<open>bounded_clinear f\\<close>\n  shows \\<open>\\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "proof (cases \\<open>orthogonal_complement (f -` {0}) = {0}\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. orthogonal_complement (f -` {0}) = {0::'a} \\<Longrightarrow>\n    \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}\n 2. orthogonal_complement (f -` {0}) \\<noteq> {0::'a} \\<Longrightarrow>\n    \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "case True"], ["proof (state)\nthis:\n  orthogonal_complement (f -` {0}) = {0::'a}\n\ngoal (2 subgoals):\n 1. orthogonal_complement (f -` {0}) = {0::'a} \\<Longrightarrow>\n    \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}\n 2. orthogonal_complement (f -` {0}) \\<noteq> {0::'a} \\<Longrightarrow>\n    \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "then"], ["proof (chain)\npicking this:\n  orthogonal_complement (f -` {0}) = {0::'a}", "show ?thesis"], ["proof (prove)\nusing this:\n  orthogonal_complement (f -` {0}) = {0::'a}\n\ngoal (1 subgoal):\n 1. \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "apply (rule_tac x=0 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement (f -` {0}) = {0::'a} \\<Longrightarrow>\n    orthogonal_complement (f -` {0}) = cspan {0::'a}", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}\n\ngoal (1 subgoal):\n 1. orthogonal_complement (f -` {0}) \\<noteq> {0::'a} \\<Longrightarrow>\n    \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. orthogonal_complement (f -` {0}) \\<noteq> {0::'a} \\<Longrightarrow>\n    \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "case False"], ["proof (state)\nthis:\n  orthogonal_complement (f -` {0}) \\<noteq> {0::'a}\n\ngoal (1 subgoal):\n 1. orthogonal_complement (f -` {0}) \\<noteq> {0::'a} \\<Longrightarrow>\n    \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "then"], ["proof (chain)\npicking this:\n  orthogonal_complement (f -` {0}) \\<noteq> {0::'a}", "obtain x where xortho: \\<open>x \\<in> orthogonal_complement (f -` {0})\\<close> and xnon0: \\<open>x \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  orthogonal_complement (f -` {0}) \\<noteq> {0::'a}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> orthogonal_complement (f -` {0});\n         x \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using complex_vector.subspace_def"], ["proof (prove)\nusing this:\n  orthogonal_complement (f -` {0}) \\<noteq> {0::'a}\n  csubspace ?S =\n  ((0::?'a) \\<in> ?S \\<and>\n   (\\<forall>x\\<in>?S. \\<forall>y\\<in>?S. x + y \\<in> ?S) \\<and>\n   (\\<forall>c. \\<forall>x\\<in>?S. c *\\<^sub>C x \\<in> ?S))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> orthogonal_complement (f -` {0});\n         x \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> orthogonal_complement (f -` {0})\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. orthogonal_complement (f -` {0}) \\<noteq> {0::'a} \\<Longrightarrow>\n    \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "from xnon0 xortho"], ["proof (chain)\npicking this:\n  x \\<noteq> (0::'a)\n  x \\<in> orthogonal_complement (f -` {0})", "have r1: \\<open>f x \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n  x \\<in> orthogonal_complement (f -` {0})\n\ngoal (1 subgoal):\n 1. f x \\<noteq> 0", "by (metis cinner_eq_zero_iff orthogonal_complement_orthoI vimage_singleton_eq)"], ["proof (state)\nthis:\n  f x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. orthogonal_complement (f -` {0}) \\<noteq> {0::'a} \\<Longrightarrow>\n    \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "have \\<open>\\<exists> k. y = k *\\<^sub>C x\\<close> if \\<open>y \\<in> orthogonal_complement (f -` {0})\\<close> for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. y = k *\\<^sub>C x", "proof (cases \\<open>y = 0\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "case True"], ["proof (state)\nthis:\n  y = (0::'a)\n\ngoal (2 subgoals):\n 1. y = (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x\n 2. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "then"], ["proof (chain)\npicking this:\n  y = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  y = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>k. y = k *\\<^sub>C x", "by auto"], ["proof (state)\nthis:\n  \\<exists>k. y = k *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "case False"], ["proof (state)\nthis:\n  y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "with that"], ["proof (chain)\npicking this:\n  y \\<in> orthogonal_complement (f -` {0})\n  y \\<noteq> (0::'a)", "have \\<open>f y \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> orthogonal_complement (f -` {0})\n  y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. f y \\<noteq> 0", "by (metis cinner_eq_zero_iff orthogonal_complement_orthoI vimage_singleton_eq)"], ["proof (state)\nthis:\n  f y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "then"], ["proof (chain)\npicking this:\n  f y \\<noteq> 0", "obtain k where k_def: \\<open>f x = k * f y\\<close>"], ["proof (prove)\nusing this:\n  f y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k. f x = k * f y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add.inverse_inverse minus_divide_eq_eq)"], ["proof (state)\nthis:\n  f x = k * f y\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "with assms"], ["proof (chain)\npicking this:\n  bounded_clinear f\n  f x = k * f y", "have \\<open>f x = f (k *\\<^sub>C y)\\<close>"], ["proof (prove)\nusing this:\n  bounded_clinear f\n  f x = k * f y\n\ngoal (1 subgoal):\n 1. f x = f (k *\\<^sub>C y)", "by (simp add: bounded_clinear.axioms(1) clinear.scaleC)"], ["proof (state)\nthis:\n  f x = f (k *\\<^sub>C y)\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "hence \\<open>f x - f (k *\\<^sub>C y) = 0\\<close>"], ["proof (prove)\nusing this:\n  f x = f (k *\\<^sub>C y)\n\ngoal (1 subgoal):\n 1. f x - f (k *\\<^sub>C y) = 0", "by simp"], ["proof (state)\nthis:\n  f x - f (k *\\<^sub>C y) = 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "with assms"], ["proof (chain)\npicking this:\n  bounded_clinear f\n  f x - f (k *\\<^sub>C y) = 0", "have s1: \\<open>f (x - k *\\<^sub>C y) = 0\\<close>"], ["proof (prove)\nusing this:\n  bounded_clinear f\n  f x - f (k *\\<^sub>C y) = 0\n\ngoal (1 subgoal):\n 1. f (x - k *\\<^sub>C y) = 0", "by (simp add: bounded_clinear.axioms(1) complex_vector.linear_diff)"], ["proof (state)\nthis:\n  f (x - k *\\<^sub>C y) = 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "from that"], ["proof (chain)\npicking this:\n  y \\<in> orthogonal_complement (f -` {0})", "have \\<open>k *\\<^sub>C y \\<in> orthogonal_complement (f -` {0})\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> orthogonal_complement (f -` {0})\n\ngoal (1 subgoal):\n 1. k *\\<^sub>C y \\<in> orthogonal_complement (f -` {0})", "by (simp add: complex_vector.subspace_scale)"], ["proof (state)\nthis:\n  k *\\<^sub>C y \\<in> orthogonal_complement (f -` {0})\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "with xortho"], ["proof (chain)\npicking this:\n  x \\<in> orthogonal_complement (f -` {0})\n  k *\\<^sub>C y \\<in> orthogonal_complement (f -` {0})", "have s2: \\<open>x - (k *\\<^sub>C y) \\<in> orthogonal_complement (f -` {0})\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement (f -` {0})\n  k *\\<^sub>C y \\<in> orthogonal_complement (f -` {0})\n\ngoal (1 subgoal):\n 1. x - k *\\<^sub>C y \\<in> orthogonal_complement (f -` {0})", "by (simp add: complex_vector.subspace_diff)"], ["proof (state)\nthis:\n  x - k *\\<^sub>C y \\<in> orthogonal_complement (f -` {0})\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "have s3: \\<open>(x - (k *\\<^sub>C y)) \\<in> f -` {0}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x - k *\\<^sub>C y \\<in> f -` {0}", "using s1"], ["proof (prove)\nusing this:\n  f (x - k *\\<^sub>C y) = 0\n\ngoal (1 subgoal):\n 1. x - k *\\<^sub>C y \\<in> f -` {0}", "by simp"], ["proof (state)\nthis:\n  x - k *\\<^sub>C y \\<in> f -` {0}\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "moreover"], ["proof (state)\nthis:\n  x - k *\\<^sub>C y \\<in> f -` {0}\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "have \\<open>(f -` {0}) \\<inter> (orthogonal_complement (f -` {0})) = {0}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f -` {0} \\<inter> orthogonal_complement (f -` {0}) = {0::'a}", "by (meson assms closed_csubspace_def complex_vector.subspace_def kernel_is_closed_csubspace \n          orthogonal_complement_zero_intersection)"], ["proof (state)\nthis:\n  f -` {0} \\<inter> orthogonal_complement (f -` {0}) = {0::'a}\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "ultimately"], ["proof (chain)\npicking this:\n  x - k *\\<^sub>C y \\<in> f -` {0}\n  f -` {0} \\<inter> orthogonal_complement (f -` {0}) = {0::'a}", "have \\<open>x - (k *\\<^sub>C y) = 0\\<close>"], ["proof (prove)\nusing this:\n  x - k *\\<^sub>C y \\<in> f -` {0}\n  f -` {0} \\<inter> orthogonal_complement (f -` {0}) = {0::'a}\n\ngoal (1 subgoal):\n 1. x - k *\\<^sub>C y = (0::'a)", "using s2"], ["proof (prove)\nusing this:\n  x - k *\\<^sub>C y \\<in> f -` {0}\n  f -` {0} \\<inter> orthogonal_complement (f -` {0}) = {0::'a}\n  x - k *\\<^sub>C y \\<in> orthogonal_complement (f -` {0})\n\ngoal (1 subgoal):\n 1. x - k *\\<^sub>C y = (0::'a)", "by blast"], ["proof (state)\nthis:\n  x - k *\\<^sub>C y = (0::'a)\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> \\<exists>k. y = k *\\<^sub>C x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x - k *\\<^sub>C y = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>k. y = k *\\<^sub>C x", "by (metis ceq_vector_fraction_iff eq_iff_diff_eq_0 k_def r1 scaleC_scaleC)"], ["proof (state)\nthis:\n  \\<exists>k. y = k *\\<^sub>C x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y \\<in> orthogonal_complement (f -` {0}) \\<Longrightarrow>\n  \\<exists>k. ?y = k *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. orthogonal_complement (f -` {0}) \\<noteq> {0::'a} \\<Longrightarrow>\n    \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "then"], ["proof (chain)\npicking this:\n  ?y \\<in> orthogonal_complement (f -` {0}) \\<Longrightarrow>\n  \\<exists>k. ?y = k *\\<^sub>C x", "have \\<open>orthogonal_complement (f -` {0}) \\<subseteq> cspan {x}\\<close>"], ["proof (prove)\nusing this:\n  ?y \\<in> orthogonal_complement (f -` {0}) \\<Longrightarrow>\n  \\<exists>k. ?y = k *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. orthogonal_complement (f -` {0}) \\<subseteq> cspan {x}", "using complex_vector.span_superset complex_vector.subspace_scale"], ["proof (prove)\nusing this:\n  ?y \\<in> orthogonal_complement (f -` {0}) \\<Longrightarrow>\n  \\<exists>k. ?y = k *\\<^sub>C x\n  ?S \\<subseteq> cspan ?S\n  \\<lbrakk>csubspace ?S; ?x \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> ?S\n\ngoal (1 subgoal):\n 1. orthogonal_complement (f -` {0}) \\<subseteq> cspan {x}", "by blast"], ["proof (state)\nthis:\n  orthogonal_complement (f -` {0}) \\<subseteq> cspan {x}\n\ngoal (1 subgoal):\n 1. orthogonal_complement (f -` {0}) \\<noteq> {0::'a} \\<Longrightarrow>\n    \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "moreover"], ["proof (state)\nthis:\n  orthogonal_complement (f -` {0}) \\<subseteq> cspan {x}\n\ngoal (1 subgoal):\n 1. orthogonal_complement (f -` {0}) \\<noteq> {0::'a} \\<Longrightarrow>\n    \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "from xortho"], ["proof (chain)\npicking this:\n  x \\<in> orthogonal_complement (f -` {0})", "have \\<open>orthogonal_complement (f -` {0}) \\<supseteq> cspan {x}\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> orthogonal_complement (f -` {0})\n\ngoal (1 subgoal):\n 1. cspan {x} \\<subseteq> orthogonal_complement (f -` {0})", "by (simp add: complex_vector.span_minimal)"], ["proof (state)\nthis:\n  cspan {x} \\<subseteq> orthogonal_complement (f -` {0})\n\ngoal (1 subgoal):\n 1. orthogonal_complement (f -` {0}) \\<noteq> {0::'a} \\<Longrightarrow>\n    \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "ultimately"], ["proof (chain)\npicking this:\n  orthogonal_complement (f -` {0}) \\<subseteq> cspan {x}\n  cspan {x} \\<subseteq> orthogonal_complement (f -` {0})", "show ?thesis"], ["proof (prove)\nusing this:\n  orthogonal_complement (f -` {0}) \\<subseteq> cspan {x}\n  cspan {x} \\<subseteq> orthogonal_complement (f -` {0})\n\ngoal (1 subgoal):\n 1. \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. orthogonal_complement (f -` {0}) = cspan {x}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma riesz_frechet_representation_existence:\n  \\<comment> \\<open>Theorem 3.4 in @{cite conway2013course}\\<close>\n  fixes f::\\<open>'a::chilbert_space \\<Rightarrow> complex\\<close>\n  assumes a1: \\<open>bounded_clinear f\\<close>\n  shows \\<open>\\<exists>t. \\<forall>x.  f x = \\<langle>t, x\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "proof(cases \\<open>\\<forall> x. f x = 0\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x. f x = 0 \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>\n 2. \\<not> (\\<forall>x. f x = 0) \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "case True"], ["proof (state)\nthis:\n  \\<forall>x. f x = 0\n\ngoal (2 subgoals):\n 1. \\<forall>x. f x = 0 \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>\n 2. \\<not> (\\<forall>x. f x = 0) \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. f x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "by (metis cinner_zero_left)"], ["proof (state)\nthis:\n  \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x = 0) \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x = 0) \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>x. f x = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x = 0) \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "obtain t where spant: \\<open>orthogonal_complement (f -` {0}) = cspan {t}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        orthogonal_complement (f -` {0}) = cspan {t} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using orthogonal_complement_kernel_functional"], ["proof (prove)\nusing this:\n  bounded_clinear ?f \\<Longrightarrow>\n  \\<exists>x. orthogonal_complement (?f -` {0}) = cspan {x}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        orthogonal_complement (f -` {0}) = cspan {t} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  bounded_clinear ?f \\<Longrightarrow>\n  \\<exists>x. orthogonal_complement (?f -` {0}) = cspan {x}\n  bounded_clinear f\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        orthogonal_complement (f -` {0}) = cspan {t} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  orthogonal_complement (f -` {0}) = cspan {t}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x = 0) \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "have \\<open>projection (orthogonal_complement (f -` {0})) x = (\\<langle>t , x\\<rangle>/\\<langle>t , t\\<rangle>) *\\<^sub>C t\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection (orthogonal_complement (f -` {0})) x =\n    (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t", "apply (subst spant)"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection (cspan {t}) x =\n    (\\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t", "by (rule projection_rank1)"], ["proof (state)\nthis:\n  projection (orthogonal_complement (f -` {0})) ?x =\n  (\\<langle>t, ?x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x = 0) \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "hence \\<open>f (projection (orthogonal_complement (f -` {0})) x) = ((\\<langle>t , x\\<rangle>)/(\\<langle>t , t\\<rangle>)) * (f t)\\<close> for x"], ["proof (prove)\nusing this:\n  projection (orthogonal_complement (f -` {0})) ?x =\n  (\\<langle>t, ?x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t\n\ngoal (1 subgoal):\n 1. f (projection (orthogonal_complement (f -` {0})) x) =\n    \\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle> * f t", "using a1"], ["proof (prove)\nusing this:\n  projection (orthogonal_complement (f -` {0})) ?x =\n  (\\<langle>t, ?x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t\n  bounded_clinear f\n\ngoal (1 subgoal):\n 1. f (projection (orthogonal_complement (f -` {0})) x) =\n    \\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle> * f t", "unfolding bounded_clinear_def"], ["proof (prove)\nusing this:\n  projection (orthogonal_complement (f -` {0})) ?x =\n  (\\<langle>t, ?x\\<rangle> / \\<langle>t, t\\<rangle>) *\\<^sub>C t\n  clinear f \\<and> bounded_clinear_axioms f\n\ngoal (1 subgoal):\n 1. f (projection (orthogonal_complement (f -` {0})) x) =\n    \\<langle>t, x\\<rangle> / \\<langle>t, t\\<rangle> * f t", "by (simp add: complex_vector.linear_scale)"], ["proof (state)\nthis:\n  f (projection (orthogonal_complement (f -` {0})) ?x) =\n  \\<langle>t, ?x\\<rangle> / \\<langle>t, t\\<rangle> * f t\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x = 0) \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "hence l2: \\<open>f (projection (orthogonal_complement (f -` {0})) x) = \\<langle>((cnj (f t)/\\<langle>t , t\\<rangle>) *\\<^sub>C t) , x\\<rangle>\\<close> for x"], ["proof (prove)\nusing this:\n  f (projection (orthogonal_complement (f -` {0})) ?x) =\n  \\<langle>t, ?x\\<rangle> / \\<langle>t, t\\<rangle> * f t\n\ngoal (1 subgoal):\n 1. f (projection (orthogonal_complement (f -` {0})) x) =\n    \\<langle>(cnj (f t) / \\<langle>t, t\\<rangle>) *\\<^sub>C t, x\\<rangle>", "using complex_cnj_divide"], ["proof (prove)\nusing this:\n  f (projection (orthogonal_complement (f -` {0})) ?x) =\n  \\<langle>t, ?x\\<rangle> / \\<langle>t, t\\<rangle> * f t\n  cnj (?x / ?y) = cnj ?x / cnj ?y\n\ngoal (1 subgoal):\n 1. f (projection (orthogonal_complement (f -` {0})) x) =\n    \\<langle>(cnj (f t) / \\<langle>t, t\\<rangle>) *\\<^sub>C t, x\\<rangle>", "by force"], ["proof (state)\nthis:\n  f (projection (orthogonal_complement (f -` {0})) ?x) =\n  \\<langle>(cnj (f t) / \\<langle>t, t\\<rangle>) *\\<^sub>C t, ?x\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x = 0) \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "have \\<open>f (projection (f -` {0}) x) = 0\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (projection (f -` {0}) x) = 0", "by (metis (no_types, lifting) assms bounded_clinear_def closed_csubspace.closed\n        complex_vector.linear_subspace_vimage complex_vector.subspace_0 complex_vector.subspace_single_0\n        csubspace_is_convex insert_absorb insert_not_empty kernel_is_closed_csubspace projection_in_image vimage_singleton_eq)"], ["proof (state)\nthis:\n  f (projection (f -` {0}) ?x) = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x = 0) \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "hence \"\\<And>a b. f (projection (f -` {0}) a + b) = 0 + f b\""], ["proof (prove)\nusing this:\n  f (projection (f -` {0}) ?x) = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b. f (projection (f -` {0}) a + b) = 0 + f b", "using additive.add assms"], ["proof (prove)\nusing this:\n  f (projection (f -` {0}) ?x) = 0\n  Modules.additive ?f \\<Longrightarrow> ?f (?x + ?y) = ?f ?x + ?f ?y\n  bounded_clinear f\n\ngoal (1 subgoal):\n 1. \\<And>a b. f (projection (f -` {0}) a + b) = 0 + f b", "by (simp add: bounded_clinear_def complex_vector.linear_add)"], ["proof (state)\nthis:\n  f (projection (f -` {0}) ?a + ?b) = 0 + f ?b\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x = 0) \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "hence \"\\<And>a. 0 + f (projection (orthogonal_complement (f -` {0})) a) = f a\""], ["proof (prove)\nusing this:\n  f (projection (f -` {0}) ?a + ?b) = 0 + f ?b\n\ngoal (1 subgoal):\n 1. \\<And>a. 0 + f (projection (orthogonal_complement (f -` {0})) a) = f a", "apply (simp add: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<And>a b. f (projection (f -` {0}) a + b) = f b) \\<Longrightarrow>\n       f (a - projection (f -` {0}) a) = f a", "by (metis add.commute diff_add_cancel)"], ["proof (state)\nthis:\n  0 + f (projection (orthogonal_complement (f -` {0})) ?a) = f ?a\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x = 0) \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "hence \\<open>f x = \\<langle>(cnj (f t)/\\<langle>t , t\\<rangle>) *\\<^sub>C t, x\\<rangle>\\<close> for x"], ["proof (prove)\nusing this:\n  0 + f (projection (orthogonal_complement (f -` {0})) ?a) = f ?a\n\ngoal (1 subgoal):\n 1. f x =\n    \\<langle>(cnj (f t) / \\<langle>t, t\\<rangle>) *\\<^sub>C t, x\\<rangle>", "by (simp add: l2)"], ["proof (state)\nthis:\n  f ?x =\n  \\<langle>(cnj (f t) / \\<langle>t, t\\<rangle>) *\\<^sub>C t, ?x\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x. f x = 0) \\<Longrightarrow>\n    \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  f ?x =\n  \\<langle>(cnj (f t) / \\<langle>t, t\\<rangle>) *\\<^sub>C t, ?x\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>", "by blast"], ["proof (state)\nthis:\n  \\<exists>t. \\<forall>x. f x = \\<langle>t, x\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma riesz_frechet_representation_unique:\n  \\<comment> \\<open>Theorem 3.4 in @{cite conway2013course}\\<close>\n  fixes f::\\<open>'a::complex_inner \\<Rightarrow> complex\\<close>\n  assumes \\<open>\\<And>x. f x = \\<langle>t, x\\<rangle>\\<close>\n  assumes \\<open>\\<And>x. f x = \\<langle>u, x\\<rangle>\\<close>\n  shows \\<open>t = u\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. t = u", "by (metis add_diff_cancel_left' assms(1) assms(2) cinner_diff_left cinner_gt_zero_iff diff_add_cancel diff_zero)"], ["", "subsection \\<open>Adjoints\\<close>"], ["", "definition \"is_cadjoint F G \\<longleftrightarrow> (\\<forall>x. \\<forall>y. \\<langle>F x, y\\<rangle> = \\<langle>x, G y\\<rangle>)\""], ["", "lemma is_adjoint_sym:\n  \\<open>is_cadjoint F G \\<Longrightarrow> is_cadjoint G F\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cadjoint F G \\<Longrightarrow> is_cadjoint G F", "unfolding is_cadjoint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       \\<langle>F x, y\\<rangle> = \\<langle>x, G y\\<rangle> \\<Longrightarrow>\n    \\<forall>x y. \\<langle>G x, y\\<rangle> = \\<langle>x, F y\\<rangle>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<forall>x y.\n          \\<langle>F x, y\\<rangle> =\n          \\<langle>x, G y\\<rangle> \\<Longrightarrow>\n       \\<langle>G x, y\\<rangle> = \\<langle>x, F y\\<rangle>", "by (metis cinner_commute')"], ["", "definition \\<open>cadjoint G = (SOME F. is_cadjoint F G)\\<close>\n  for G :: \"'b::complex_inner \\<Rightarrow> 'a::complex_inner\""], ["", "lemma cadjoint_exists:\n  fixes G :: \"'b::chilbert_space \\<Rightarrow> 'a::complex_inner\"\n  assumes [simp]: \\<open>bounded_clinear G\\<close>\n  shows \\<open>\\<exists>F. is_cadjoint F G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F. is_cadjoint F G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>F. is_cadjoint F G", "include notation_norm"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>F. is_cadjoint F G", "have [simp]: \\<open>clinear G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear G", "using assms"], ["proof (prove)\nusing this:\n  bounded_clinear G\n\ngoal (1 subgoal):\n 1. clinear G", "unfolding bounded_clinear_def"], ["proof (prove)\nusing this:\n  clinear G \\<and> bounded_clinear_axioms G\n\ngoal (1 subgoal):\n 1. clinear G", "by blast"], ["proof (state)\nthis:\n  clinear G\n\ngoal (1 subgoal):\n 1. \\<exists>F. is_cadjoint F G", "define g :: \\<open>'a \\<Rightarrow> 'b \\<Rightarrow> complex\\<close> \n    where \\<open>g x y = \\<langle>x , G y\\<rangle>\\<close> for x y"], ["proof (state)\nthis:\n  g ?x ?y = \\<langle>?x, G ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>F. is_cadjoint F G", "have \\<open>bounded_clinear (g x)\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (g x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear (g x)", "have \\<open>g x (a + b) = g x a + g x b\\<close> for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. g x (a + b) = g x a + g x b", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, G (a + b)\\<rangle> =\n    \\<langle>x, G a\\<rangle> + \\<langle>x, G b\\<rangle>", "using additive.add cinner_add_right clinear_def"], ["proof (prove)\nusing this:\n  Modules.additive ?f \\<Longrightarrow> ?f (?x + ?y) = ?f ?x + ?f ?y\n  \\<langle>?x, ?y + ?z\\<rangle> =\n  \\<langle>?x, ?y\\<rangle> + \\<langle>?x, ?z\\<rangle>\n  clinear ?f \\<equiv> Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) ?f\n\ngoal (1 subgoal):\n 1. \\<langle>x, G (a + b)\\<rangle> =\n    \\<langle>x, G a\\<rangle> + \\<langle>x, G b\\<rangle>", "by (simp add: cinner_add_right complex_vector.linear_add)"], ["proof (state)\nthis:\n  g x (?a + ?b) = g x ?a + g x ?b\n\ngoal (1 subgoal):\n 1. bounded_clinear (g x)", "moreover"], ["proof (state)\nthis:\n  g x (?a + ?b) = g x ?a + g x ?b\n\ngoal (1 subgoal):\n 1. bounded_clinear (g x)", "have  \\<open>g x (k *\\<^sub>C a) = k *\\<^sub>C (g x a)\\<close>\n      for a k"], ["proof (prove)\ngoal (1 subgoal):\n 1. g x (k *\\<^sub>C a) = k *\\<^sub>C g x a", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, G (k *\\<^sub>C a)\\<rangle> =\n    k *\\<^sub>C \\<langle>x, G a\\<rangle>", "by (simp add: complex_vector.linear_scale)"], ["proof (state)\nthis:\n  g x (?k *\\<^sub>C ?a) = ?k *\\<^sub>C g x ?a\n\ngoal (1 subgoal):\n 1. bounded_clinear (g x)", "ultimately"], ["proof (chain)\npicking this:\n  g x (?a + ?b) = g x ?a + g x ?b\n  g x (?k *\\<^sub>C ?a) = ?k *\\<^sub>C g x ?a", "have \\<open>clinear (g x)\\<close>"], ["proof (prove)\nusing this:\n  g x (?a + ?b) = g x ?a + g x ?b\n  g x (?k *\\<^sub>C ?a) = ?k *\\<^sub>C g x ?a\n\ngoal (1 subgoal):\n 1. clinear (g x)", "by (simp add: clinearI)"], ["proof (state)\nthis:\n  clinear (g x)\n\ngoal (1 subgoal):\n 1. bounded_clinear (g x)", "moreover"], ["proof (state)\nthis:\n  clinear (g x)\n\ngoal (1 subgoal):\n 1. bounded_clinear (g x)", "have \\<open>\\<exists> M. \\<forall> y. \\<parallel> G y \\<parallel> \\<le> \\<parallel> y \\<parallel> * M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>y.\n          \\<parallel>G y\\<parallel> \\<le> \\<parallel>y\\<parallel> * M", "using \\<open>bounded_clinear G\\<close>"], ["proof (prove)\nusing this:\n  bounded_clinear G\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>y.\n          \\<parallel>G y\\<parallel> \\<le> \\<parallel>y\\<parallel> * M", "unfolding bounded_clinear_def bounded_clinear_axioms_def"], ["proof (prove)\nusing this:\n  clinear G \\<and>\n  (\\<exists>K.\n      \\<forall>x.\n         \\<parallel>G x\\<parallel> \\<le> \\<parallel>x\\<parallel> * K)\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>y.\n          \\<parallel>G y\\<parallel> \\<le> \\<parallel>y\\<parallel> * M", "by blast"], ["proof (state)\nthis:\n  \\<exists>M.\n     \\<forall>y. \\<parallel>G y\\<parallel> \\<le> \\<parallel>y\\<parallel> * M\n\ngoal (1 subgoal):\n 1. bounded_clinear (g x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>M.\n     \\<forall>y. \\<parallel>G y\\<parallel> \\<le> \\<parallel>y\\<parallel> * M", "have \\<open>\\<exists>M. \\<forall>y. \\<parallel> g x y \\<parallel> \\<le> \\<parallel> y \\<parallel> * M\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>M.\n     \\<forall>y. \\<parallel>G y\\<parallel> \\<le> \\<parallel>y\\<parallel> * M\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>y. cmod (g x y) \\<le> \\<parallel>y\\<parallel> * M", "using g_def"], ["proof (prove)\nusing this:\n  \\<exists>M.\n     \\<forall>y. \\<parallel>G y\\<parallel> \\<le> \\<parallel>y\\<parallel> * M\n  g ?x ?y = \\<langle>?x, G ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>y. cmod (g x y) \\<le> \\<parallel>y\\<parallel> * M", "by (simp add: bounded_clinear.bounded bounded_clinear_cinner_right_comp)"], ["proof (state)\nthis:\n  \\<exists>M. \\<forall>y. cmod (g x y) \\<le> \\<parallel>y\\<parallel> * M\n\ngoal (1 subgoal):\n 1. bounded_clinear (g x)", "ultimately"], ["proof (chain)\npicking this:\n  clinear (g x)\n  \\<exists>M. \\<forall>y. cmod (g x y) \\<le> \\<parallel>y\\<parallel> * M", "show ?thesis"], ["proof (prove)\nusing this:\n  clinear (g x)\n  \\<exists>M. \\<forall>y. cmod (g x y) \\<le> \\<parallel>y\\<parallel> * M\n\ngoal (1 subgoal):\n 1. bounded_clinear (g x)", "unfolding bounded_linear_def"], ["proof (prove)\nusing this:\n  clinear (g x)\n  \\<exists>M. \\<forall>y. cmod (g x y) \\<le> \\<parallel>y\\<parallel> * M\n\ngoal (1 subgoal):\n 1. bounded_clinear (g x)", "using bounded_clinear.intro"], ["proof (prove)\nusing this:\n  clinear (g x)\n  \\<exists>M. \\<forall>y. cmod (g x y) \\<le> \\<parallel>y\\<parallel> * M\n  \\<lbrakk>clinear ?f; bounded_clinear_axioms ?f\\<rbrakk>\n  \\<Longrightarrow> bounded_clinear ?f\n\ngoal (1 subgoal):\n 1. bounded_clinear (g x)", "using bounded_clinear_axioms_def"], ["proof (prove)\nusing this:\n  clinear (g x)\n  \\<exists>M. \\<forall>y. cmod (g x y) \\<le> \\<parallel>y\\<parallel> * M\n  \\<lbrakk>clinear ?f; bounded_clinear_axioms ?f\\<rbrakk>\n  \\<Longrightarrow> bounded_clinear ?f\n  bounded_clinear_axioms ?f \\<equiv>\n  \\<exists>K.\n     \\<forall>x.\n        \\<parallel>?f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * K\n\ngoal (1 subgoal):\n 1. bounded_clinear (g x)", "by blast"], ["proof (state)\nthis:\n  bounded_clinear (g x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bounded_clinear (g ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>F. is_cadjoint F G", "hence \\<open>\\<forall>x. \\<exists>t. \\<forall>y.  g x y = \\<langle>t, y\\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  bounded_clinear (g ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>x. \\<exists>t. \\<forall>y. g x y = \\<langle>t, y\\<rangle>", "using riesz_frechet_representation_existence"], ["proof (prove)\nusing this:\n  bounded_clinear (g ?x)\n  bounded_clinear ?f \\<Longrightarrow>\n  \\<exists>t. \\<forall>x. ?f x = \\<langle>t, x\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>x. \\<exists>t. \\<forall>y. g x y = \\<langle>t, y\\<rangle>", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. \\<exists>t. \\<forall>y. g x y = \\<langle>t, y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>F. is_cadjoint F G", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. \\<exists>t. \\<forall>y. g x y = \\<langle>t, y\\<rangle>", "obtain F where \\<open>\\<forall>x. \\<forall>y. g x y = \\<langle>F x, y\\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<exists>t. \\<forall>y. g x y = \\<langle>t, y\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>F.\n        \\<forall>x y. g x y = \\<langle>F x, y\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>x y. g x y = \\<langle>F x, y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>F. is_cadjoint F G", "then"], ["proof (chain)\npicking this:\n  \\<forall>x y. g x y = \\<langle>F x, y\\<rangle>", "have \\<open>is_cadjoint F G\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x y. g x y = \\<langle>F x, y\\<rangle>\n\ngoal (1 subgoal):\n 1. is_cadjoint F G", "unfolding is_cadjoint_def g_def"], ["proof (prove)\nusing this:\n  \\<forall>x y. \\<langle>x, G y\\<rangle> = \\<langle>F x, y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>x y. \\<langle>F x, y\\<rangle> = \\<langle>x, G y\\<rangle>", "by simp"], ["proof (state)\nthis:\n  is_cadjoint F G\n\ngoal (1 subgoal):\n 1. \\<exists>F. is_cadjoint F G", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_cadjoint F G\n\ngoal (1 subgoal):\n 1. \\<exists>F. is_cadjoint F G", "by auto"], ["proof (state)\nthis:\n  \\<exists>F. is_cadjoint F G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cadjoint_is_cadjoint[simp]:\n  fixes G :: \"'b::chilbert_space \\<Rightarrow> 'a::complex_inner\"\n  assumes [simp]: \\<open>bounded_clinear G\\<close>\n  shows \\<open>is_cadjoint (cadjoint G) G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cadjoint (cadjoint G) G", "by (metis assms cadjoint_def cadjoint_exists someI_ex)"], ["", "lemma is_cadjoint_unique:\n  assumes \\<open>is_cadjoint F1 G\\<close>\n  assumes \\<open>is_cadjoint F2 G\\<close>\n  shows \\<open>F1 = F2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. F1 = F2", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. F1 x = F2 x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. F1 x = F2 x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. F1 x = F2 x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. F1 x = F2 x", "have \\<open>cinner (F1 x - F2 x) y = cinner (F1 x) y - cinner (F2 x) y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>F1 x - F2 x, y\\<rangle> =\n    \\<langle>F1 x, y\\<rangle> - \\<langle>F2 x, y\\<rangle>", "by (simp add: cinner_diff_left)"], ["proof (state)\nthis:\n  \\<langle>F1 x - F2 x, y\\<rangle> =\n  \\<langle>F1 x, y\\<rangle> - \\<langle>F2 x, y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x. F1 x = F2 x", "also"], ["proof (state)\nthis:\n  \\<langle>F1 x - F2 x, y\\<rangle> =\n  \\<langle>F1 x, y\\<rangle> - \\<langle>F2 x, y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x. F1 x = F2 x", "have \\<open>\\<dots> = cinner x (G y) - cinner x (G y)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>F1 x, y\\<rangle> - \\<langle>F2 x, y\\<rangle> =\n    \\<langle>x, G y\\<rangle> - \\<langle>x, G y\\<rangle>", "by (metis assms(1) assms(2) is_cadjoint_def)"], ["proof (state)\nthis:\n  \\<langle>F1 x, y\\<rangle> - \\<langle>F2 x, y\\<rangle> =\n  \\<langle>x, G y\\<rangle> - \\<langle>x, G y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x. F1 x = F2 x", "also"], ["proof (state)\nthis:\n  \\<langle>F1 x, y\\<rangle> - \\<langle>F2 x, y\\<rangle> =\n  \\<langle>x, G y\\<rangle> - \\<langle>x, G y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x. F1 x = F2 x", "have \\<open>\\<dots> = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, G y\\<rangle> - \\<langle>x, G y\\<rangle> = 0", "by simp"], ["proof (state)\nthis:\n  \\<langle>x, G y\\<rangle> - \\<langle>x, G y\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. F1 x = F2 x", "finally"], ["proof (chain)\npicking this:\n  is_orthogonal (F1 x - F2 x) y", "have \\<open>cinner (F1 x - F2 x) y = 0\\<close>"], ["proof (prove)\nusing this:\n  is_orthogonal (F1 x - F2 x) y\n\ngoal (1 subgoal):\n 1. is_orthogonal (F1 x - F2 x) y", "by -"], ["proof (state)\nthis:\n  is_orthogonal (F1 x - F2 x) y\n\ngoal (1 subgoal):\n 1. \\<And>x. F1 x = F2 x", "}"], ["proof (state)\nthis:\n  is_orthogonal (F1 x - F2 x) ?y2\n\ngoal (1 subgoal):\n 1. \\<And>x. F1 x = F2 x", "then"], ["proof (chain)\npicking this:\n  is_orthogonal (F1 x - F2 x) ?y2", "show \\<open>F1 x = F2 x\\<close>"], ["proof (prove)\nusing this:\n  is_orthogonal (F1 x - F2 x) ?y2\n\ngoal (1 subgoal):\n 1. F1 x = F2 x", "by fastforce"], ["proof (state)\nthis:\n  F1 x = F2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cadjoint_univ_prop:\n  fixes G :: \"'b::chilbert_space \\<Rightarrow> 'a::complex_inner\"\n  assumes a1: \\<open>bounded_clinear G\\<close>\n  shows \\<open>\\<forall>x. \\<forall>y. \\<langle>cadjoint G x, y\\<rangle> = \\<langle>x, G y\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       \\<langle>cadjoint G x, y\\<rangle> = \\<langle>x, G y\\<rangle>", "using assms cadjoint_is_cadjoint is_cadjoint_def"], ["proof (prove)\nusing this:\n  bounded_clinear G\n  bounded_clinear ?G \\<Longrightarrow> is_cadjoint (cadjoint ?G) ?G\n  is_cadjoint ?F ?G =\n  (\\<forall>x y. \\<langle>?F x, y\\<rangle> = \\<langle>x, ?G y\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       \\<langle>cadjoint G x, y\\<rangle> = \\<langle>x, G y\\<rangle>", "by blast"], ["", "lemma cadjoint_univ_prop':\n  fixes G :: \"'b::chilbert_space \\<Rightarrow> 'a::complex_inner\"\n  assumes a1: \\<open>bounded_clinear G\\<close>\n  shows \\<open>\\<forall>x. \\<forall>y. \\<langle>x, cadjoint G y\\<rangle> = \\<langle>G x, y\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       \\<langle>x, cadjoint G y\\<rangle> = \\<langle>G x, y\\<rangle>", "by (metis cadjoint_univ_prop assms cinner_commute')"], ["", "notation cadjoint (\"_\\<^sup>\\<dagger>\" [99] 100)"], ["", "lemma cadjoint_eqI:\n  fixes G:: \\<open>'b::complex_inner \\<Rightarrow> 'a::complex_inner\\<close>\n    and F:: \\<open>'a \\<Rightarrow> 'b\\<close>\n  assumes \\<open>\\<And>x y. \\<langle>F x, y\\<rangle> = \\<langle>x, G y\\<rangle>\\<close>\n  shows \\<open>G\\<^sup>\\<dagger> = F\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. G\\<^sup>\\<dagger> = F", "by (metis assms cadjoint_def is_cadjoint_def is_cadjoint_unique someI_ex)"], ["", "lemma cadjoint_bounded_clinear:\n  fixes A :: \"'a::chilbert_space \\<Rightarrow> 'b::complex_inner\"\n  assumes a1: \"bounded_clinear A\"\n  shows \\<open>bounded_clinear (A\\<^sup>\\<dagger>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (A\\<^sup>\\<dagger>)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2.\n       (A\\<^sup>\\<dagger>) (b1 + b2) =\n       (A\\<^sup>\\<dagger>) b1 + (A\\<^sup>\\<dagger>) b2\n 2. \\<And>r b.\n       (A\\<^sup>\\<dagger>) (r *\\<^sub>C b) =\n       r *\\<^sub>C (A\\<^sup>\\<dagger>) b\n 3. \\<exists>K. \\<forall>x. norm ((A\\<^sup>\\<dagger>) x) \\<le> norm x * K", "include notation_norm"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2.\n       (A\\<^sup>\\<dagger>) (b1 + b2) =\n       (A\\<^sup>\\<dagger>) b1 + (A\\<^sup>\\<dagger>) b2\n 2. \\<And>r b.\n       (A\\<^sup>\\<dagger>) (r *\\<^sub>C b) =\n       r *\\<^sub>C (A\\<^sup>\\<dagger>) b\n 3. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "have b1: \\<open>\\<langle>(A\\<^sup>\\<dagger>) x, y\\<rangle> = \\<langle>x , A y\\<rangle>\\<close> for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>(A\\<^sup>\\<dagger>) x, y\\<rangle> = \\<langle>x, A y\\<rangle>", "using cadjoint_univ_prop a1"], ["proof (prove)\nusing this:\n  bounded_clinear ?G \\<Longrightarrow>\n  \\<forall>x y.\n     \\<langle>(?G\\<^sup>\\<dagger>) x, y\\<rangle> = \\<langle>x, ?G y\\<rangle>\n  bounded_clinear A\n\ngoal (1 subgoal):\n 1. \\<langle>(A\\<^sup>\\<dagger>) x, y\\<rangle> = \\<langle>x, A y\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>(A\\<^sup>\\<dagger>) ?x, ?y\\<rangle> = \\<langle>?x, A ?y\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>b1 b2.\n       (A\\<^sup>\\<dagger>) (b1 + b2) =\n       (A\\<^sup>\\<dagger>) b1 + (A\\<^sup>\\<dagger>) b2\n 2. \\<And>r b.\n       (A\\<^sup>\\<dagger>) (r *\\<^sub>C b) =\n       r *\\<^sub>C (A\\<^sup>\\<dagger>) b\n 3. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "have \\<open>\\<langle>(A\\<^sup>\\<dagger>) (x1 + x2) - ((A\\<^sup>\\<dagger>) x1 + (A\\<^sup>\\<dagger>) x2) , y\\<rangle> = 0\\<close> for x1 x2 y"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal\n     ((A\\<^sup>\\<dagger>) (x1 + x2) -\n      ((A\\<^sup>\\<dagger>) x1 + (A\\<^sup>\\<dagger>) x2))\n     y", "by (simp add: b1 cinner_diff_left cinner_add_left)"], ["proof (state)\nthis:\n  is_orthogonal\n   ((A\\<^sup>\\<dagger>) (?x1.0 + ?x2.0) -\n    ((A\\<^sup>\\<dagger>) ?x1.0 + (A\\<^sup>\\<dagger>) ?x2.0))\n   ?y\n\ngoal (3 subgoals):\n 1. \\<And>b1 b2.\n       (A\\<^sup>\\<dagger>) (b1 + b2) =\n       (A\\<^sup>\\<dagger>) b1 + (A\\<^sup>\\<dagger>) b2\n 2. \\<And>r b.\n       (A\\<^sup>\\<dagger>) (r *\\<^sub>C b) =\n       r *\\<^sub>C (A\\<^sup>\\<dagger>) b\n 3. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "hence b2: \\<open>(A\\<^sup>\\<dagger>) (x1 + x2) - ((A\\<^sup>\\<dagger>) x1 + (A\\<^sup>\\<dagger>) x2) = 0\\<close> for x1 x2"], ["proof (prove)\nusing this:\n  is_orthogonal\n   ((A\\<^sup>\\<dagger>) (?x1.0 + ?x2.0) -\n    ((A\\<^sup>\\<dagger>) ?x1.0 + (A\\<^sup>\\<dagger>) ?x2.0))\n   ?y\n\ngoal (1 subgoal):\n 1. (A\\<^sup>\\<dagger>) (x1 + x2) -\n    ((A\\<^sup>\\<dagger>) x1 + (A\\<^sup>\\<dagger>) x2) =\n    (0::'a)", "using cinner_eq_zero_iff"], ["proof (prove)\nusing this:\n  is_orthogonal\n   ((A\\<^sup>\\<dagger>) (?x1.0 + ?x2.0) -\n    ((A\\<^sup>\\<dagger>) ?x1.0 + (A\\<^sup>\\<dagger>) ?x2.0))\n   ?y\n  is_orthogonal ?x ?x = (?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. (A\\<^sup>\\<dagger>) (x1 + x2) -\n    ((A\\<^sup>\\<dagger>) x1 + (A\\<^sup>\\<dagger>) x2) =\n    (0::'a)", "by blast"], ["proof (state)\nthis:\n  (A\\<^sup>\\<dagger>) (?x1.0 + ?x2.0) -\n  ((A\\<^sup>\\<dagger>) ?x1.0 + (A\\<^sup>\\<dagger>) ?x2.0) =\n  (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>b1 b2.\n       (A\\<^sup>\\<dagger>) (b1 + b2) =\n       (A\\<^sup>\\<dagger>) b1 + (A\\<^sup>\\<dagger>) b2\n 2. \\<And>r b.\n       (A\\<^sup>\\<dagger>) (r *\\<^sub>C b) =\n       r *\\<^sub>C (A\\<^sup>\\<dagger>) b\n 3. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "thus z1: \\<open>(A\\<^sup>\\<dagger>) (x1 + x2) = (A\\<^sup>\\<dagger>) x1 + (A\\<^sup>\\<dagger>) x2\\<close> for x1 x2"], ["proof (prove)\nusing this:\n  (A\\<^sup>\\<dagger>) (?x1.0 + ?x2.0) -\n  ((A\\<^sup>\\<dagger>) ?x1.0 + (A\\<^sup>\\<dagger>) ?x2.0) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (A\\<^sup>\\<dagger>) (x1 + x2) =\n    (A\\<^sup>\\<dagger>) x1 + (A\\<^sup>\\<dagger>) x2", "by (simp add: b2 eq_iff_diff_eq_0)"], ["proof (state)\nthis:\n  (A\\<^sup>\\<dagger>) (?x1.0 + ?x2.0) =\n  (A\\<^sup>\\<dagger>) ?x1.0 + (A\\<^sup>\\<dagger>) ?x2.0\n\ngoal (2 subgoals):\n 1. \\<And>r b.\n       (A\\<^sup>\\<dagger>) (r *\\<^sub>C b) =\n       r *\\<^sub>C (A\\<^sup>\\<dagger>) b\n 2. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "have f1: \\<open>\\<langle>(A\\<^sup>\\<dagger>) (r *\\<^sub>C x) - (r *\\<^sub>C (A\\<^sup>\\<dagger>) x ), y\\<rangle> = 0\\<close> for r x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal\n     ((A\\<^sup>\\<dagger>) (r *\\<^sub>C x) -\n      r *\\<^sub>C (A\\<^sup>\\<dagger>) x)\n     y", "by (simp add: b1 cinner_diff_left)"], ["proof (state)\nthis:\n  is_orthogonal\n   ((A\\<^sup>\\<dagger>) (?r *\\<^sub>C ?x) -\n    ?r *\\<^sub>C (A\\<^sup>\\<dagger>) ?x)\n   ?y\n\ngoal (2 subgoals):\n 1. \\<And>r b.\n       (A\\<^sup>\\<dagger>) (r *\\<^sub>C b) =\n       r *\\<^sub>C (A\\<^sup>\\<dagger>) b\n 2. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "thus z2: \\<open>(A\\<^sup>\\<dagger>) (r *\\<^sub>C x) = r *\\<^sub>C (A\\<^sup>\\<dagger>) x\\<close> for r x"], ["proof (prove)\nusing this:\n  is_orthogonal\n   ((A\\<^sup>\\<dagger>) (?r *\\<^sub>C ?x) -\n    ?r *\\<^sub>C (A\\<^sup>\\<dagger>) ?x)\n   ?y\n\ngoal (1 subgoal):\n 1. (A\\<^sup>\\<dagger>) (r *\\<^sub>C x) = r *\\<^sub>C (A\\<^sup>\\<dagger>) x", "using cinner_eq_zero_iff eq_iff_diff_eq_0"], ["proof (prove)\nusing this:\n  is_orthogonal\n   ((A\\<^sup>\\<dagger>) (?r *\\<^sub>C ?x) -\n    ?r *\\<^sub>C (A\\<^sup>\\<dagger>) ?x)\n   ?y\n  is_orthogonal ?x ?x = (?x = (0::?'a))\n  (?a = ?b) = (?a - ?b = (0::?'a))\n\ngoal (1 subgoal):\n 1. (A\\<^sup>\\<dagger>) (r *\\<^sub>C x) = r *\\<^sub>C (A\\<^sup>\\<dagger>) x", "by blast"], ["proof (state)\nthis:\n  (A\\<^sup>\\<dagger>) (?r *\\<^sub>C ?x) =\n  ?r *\\<^sub>C (A\\<^sup>\\<dagger>) ?x\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "have \\<open>\\<parallel> (A\\<^sup>\\<dagger>) x \\<parallel>^2 = \\<langle>(A\\<^sup>\\<dagger>) x, (A\\<^sup>\\<dagger>) x\\<rangle>\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (\\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\\<^sup>2) =\n    \\<langle>(A\\<^sup>\\<dagger>) x, (A\\<^sup>\\<dagger>) x\\<rangle>", "by (metis cnorm_eq_square)"], ["proof (state)\nthis:\n  complex_of_real (\\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2) =\n  \\<langle>(A\\<^sup>\\<dagger>) ?x, (A\\<^sup>\\<dagger>) ?x\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "moreover"], ["proof (state)\nthis:\n  complex_of_real (\\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2) =\n  \\<langle>(A\\<^sup>\\<dagger>) ?x, (A\\<^sup>\\<dagger>) ?x\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "have \\<open>\\<parallel> (A\\<^sup>\\<dagger>) x \\<parallel>^2 \\<ge> 0\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  0 \\<le> \\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "ultimately"], ["proof (chain)\npicking this:\n  complex_of_real (\\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2) =\n  \\<langle>(A\\<^sup>\\<dagger>) ?x, (A\\<^sup>\\<dagger>) ?x\\<rangle>\n  0 \\<le> \\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2", "have \\<open>\\<parallel> (A\\<^sup>\\<dagger>) x \\<parallel>^2 = \\<bar> \\<langle>(A\\<^sup>\\<dagger>) x, (A\\<^sup>\\<dagger>) x\\<rangle> \\<bar>\\<close> for x"], ["proof (prove)\nusing this:\n  complex_of_real (\\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2) =\n  \\<langle>(A\\<^sup>\\<dagger>) ?x, (A\\<^sup>\\<dagger>) ?x\\<rangle>\n  0 \\<le> \\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2\n\ngoal (1 subgoal):\n 1. complex_of_real (\\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\\<^sup>2) =\n    \\<bar>\\<langle>(A\\<^sup>\\<dagger>)\n                    x, (A\\<^sup>\\<dagger>) x\\<rangle>\\<bar>", "by (metis abs_pos cinner_ge_zero)"], ["proof (state)\nthis:\n  complex_of_real (\\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2) =\n  \\<bar>\\<langle>(A\\<^sup>\\<dagger>)\n                  ?x, (A\\<^sup>\\<dagger>) ?x\\<rangle>\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "hence \\<open>\\<parallel> (A\\<^sup>\\<dagger>) x \\<parallel>^2 = \\<bar> \\<langle>x, A ((A\\<^sup>\\<dagger>) x)\\<rangle> \\<bar>\\<close> for x"], ["proof (prove)\nusing this:\n  complex_of_real (\\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2) =\n  \\<bar>\\<langle>(A\\<^sup>\\<dagger>)\n                  ?x, (A\\<^sup>\\<dagger>) ?x\\<rangle>\\<bar>\n\ngoal (1 subgoal):\n 1. complex_of_real (\\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\\<^sup>2) =\n    \\<bar>\\<langle>x, A ((A\\<^sup>\\<dagger>) x)\\<rangle>\\<bar>", "by (simp add: b1)"], ["proof (state)\nthis:\n  complex_of_real (\\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2) =\n  \\<bar>\\<langle>?x, A ((A\\<^sup>\\<dagger>) ?x)\\<rangle>\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "moreover"], ["proof (state)\nthis:\n  complex_of_real (\\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2) =\n  \\<bar>\\<langle>?x, A ((A\\<^sup>\\<dagger>) ?x)\\<rangle>\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "have  \\<open>\\<bar>\\<langle>x , A ((A\\<^sup>\\<dagger>) x)\\<rangle>\\<bar> \\<le> \\<parallel>x\\<parallel> *  \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<langle>x, A ((A\\<^sup>\\<dagger>) x)\\<rangle>\\<bar>\n    \\<le> complex_of_real\n           (\\<parallel>x\\<parallel> *\n            \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>)", "by (simp add: abs_complex_def complex_inner_class.Cauchy_Schwarz_ineq2)"], ["proof (state)\nthis:\n  \\<bar>\\<langle>?x, A ((A\\<^sup>\\<dagger>) ?x)\\<rangle>\\<bar>\n  \\<le> complex_of_real\n         (\\<parallel>?x\\<parallel> *\n          \\<parallel>A ((A\\<^sup>\\<dagger>) ?x)\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "ultimately"], ["proof (chain)\npicking this:\n  complex_of_real (\\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2) =\n  \\<bar>\\<langle>?x, A ((A\\<^sup>\\<dagger>) ?x)\\<rangle>\\<bar>\n  \\<bar>\\<langle>?x, A ((A\\<^sup>\\<dagger>) ?x)\\<rangle>\\<bar>\n  \\<le> complex_of_real\n         (\\<parallel>?x\\<parallel> *\n          \\<parallel>A ((A\\<^sup>\\<dagger>) ?x)\\<parallel>)", "have b5: \\<open>\\<parallel> (A\\<^sup>\\<dagger>) x \\<parallel>^2  \\<le> \\<parallel>x\\<parallel> * \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>\\<close> for x"], ["proof (prove)\nusing this:\n  complex_of_real (\\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2) =\n  \\<bar>\\<langle>?x, A ((A\\<^sup>\\<dagger>) ?x)\\<rangle>\\<bar>\n  \\<bar>\\<langle>?x, A ((A\\<^sup>\\<dagger>) ?x)\\<rangle>\\<bar>\n  \\<le> complex_of_real\n         (\\<parallel>?x\\<parallel> *\n          \\<parallel>A ((A\\<^sup>\\<dagger>) ?x)\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>x\\<parallel> *\n          \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>", "by (metis complex_of_real_mono_iff)"], ["proof (state)\nthis:\n  \\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>?x\\<parallel> *\n        \\<parallel>A ((A\\<^sup>\\<dagger>) ?x)\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "have \\<open>\\<exists>M. M \\<ge> 0 \\<and> (\\<forall> x. \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel> \\<le> M *  \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>0.\n       \\<forall>x.\n          \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>\n          \\<le> M * \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>", "using a1"], ["proof (prove)\nusing this:\n  bounded_clinear A\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<ge>0.\n       \\<forall>x.\n          \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>\n          \\<le> M * \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>", "by (metis (mono_tags, hide_lams) bounded_clinear.bounded linear mult_nonneg_nonpos\n        mult_zero_right norm_ge_zero order.trans semiring_normalization_rules(7))"], ["proof (state)\nthis:\n  \\<exists>M\\<ge>0.\n     \\<forall>x.\n        \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>\n        \\<le> M * \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "then"], ["proof (chain)\npicking this:\n  \\<exists>M\\<ge>0.\n     \\<forall>x.\n        \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>\n        \\<le> M * \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>", "obtain M where q1: \\<open>M \\<ge> 0\\<close> and q2: \\<open>\\<forall> x. \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel> \\<le> M * \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>M\\<ge>0.\n     \\<forall>x.\n        \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>\n        \\<le> M * \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>0 \\<le> M;\n         \\<forall>x.\n            \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>\n            \\<le> M * \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 \\<le> M\n  \\<forall>x.\n     \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>\n     \\<le> M * \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "have \\<open>\\<forall> x::'b. \\<parallel>x\\<parallel> \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. 0 \\<le> \\<parallel>x\\<parallel>", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. 0 \\<le> \\<parallel>x\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "hence b6: \\<open>\\<parallel>x\\<parallel> * \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel> \\<le>  \\<parallel>x\\<parallel> * M * \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\\<close> for x"], ["proof (prove)\nusing this:\n  \\<forall>x. 0 \\<le> \\<parallel>x\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<parallel>x\\<parallel> *\n    \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>\n    \\<le> \\<parallel>x\\<parallel> * M *\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>", "using q2"], ["proof (prove)\nusing this:\n  \\<forall>x. 0 \\<le> \\<parallel>x\\<parallel>\n  \\<forall>x.\n     \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>\n     \\<le> M * \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<parallel>x\\<parallel> *\n    \\<parallel>A ((A\\<^sup>\\<dagger>) x)\\<parallel>\n    \\<le> \\<parallel>x\\<parallel> * M *\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>", "by (smt ordered_comm_semiring_class.comm_mult_left_mono vector_space_over_itself.scale_scale)"], ["proof (state)\nthis:\n  \\<parallel>?x\\<parallel> *\n  \\<parallel>A ((A\\<^sup>\\<dagger>) ?x)\\<parallel>\n  \\<le> \\<parallel>?x\\<parallel> * M *\n        \\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "have z3: \\<open>\\<parallel> (A\\<^sup>\\<dagger>) x \\<parallel> \\<le> \\<parallel>x\\<parallel> * M\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n    \\<le> \\<parallel>x\\<parallel> * M", "proof(cases \\<open>\\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel> = 0\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel> = 0 \\<Longrightarrow>\n    \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n    \\<le> \\<parallel>x\\<parallel> * M\n 2. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n    \\<le> \\<parallel>x\\<parallel> * M", "case True"], ["proof (state)\nthis:\n  \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel> = 0\n\ngoal (2 subgoals):\n 1. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel> = 0 \\<Longrightarrow>\n    \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n    \\<le> \\<parallel>x\\<parallel> * M\n 2. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n    \\<le> \\<parallel>x\\<parallel> * M", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel> = 0\n\ngoal (1 subgoal):\n 1. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n    \\<le> \\<parallel>x\\<parallel> * M", "by (simp add: \\<open>0 \\<le> M\\<close>)"], ["proof (state)\nthis:\n  \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n  \\<le> \\<parallel>x\\<parallel> * M\n\ngoal (1 subgoal):\n 1. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n    \\<le> \\<parallel>x\\<parallel> * M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n    \\<le> \\<parallel>x\\<parallel> * M", "case False"], ["proof (state)\nthis:\n  \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n    \\<le> \\<parallel>x\\<parallel> * M", "have \\<open>\\<parallel> (A\\<^sup>\\<dagger>) x \\<parallel>^2 \\<le> \\<parallel>x\\<parallel> *  M *  \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\\<^sup>2\n    \\<le> \\<parallel>x\\<parallel> * M *\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>", "by (smt b5 b6)"], ["proof (state)\nthis:\n  \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>x\\<parallel> * M *\n        \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n    \\<le> \\<parallel>x\\<parallel> * M", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\\<^sup>2\n  \\<le> \\<parallel>x\\<parallel> * M *\n        \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n    \\<le> \\<parallel>x\\<parallel> * M", "by (smt False mult_right_cancel mult_right_mono norm_ge_zero semiring_normalization_rules(29))"], ["proof (state)\nthis:\n  \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n  \\<le> \\<parallel>x\\<parallel> * M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\n  \\<le> \\<parallel>?x\\<parallel> * M\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "thus \\<open>\\<exists>K. \\<forall>x. \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel> \\<le> \\<parallel>x\\<parallel> * K\\<close>"], ["proof (prove)\nusing this:\n  \\<parallel>(A\\<^sup>\\<dagger>) ?x\\<parallel>\n  \\<le> \\<parallel>?x\\<parallel> * M\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>x.\n          \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n          \\<le> \\<parallel>x\\<parallel> * K", "by auto"], ["proof (state)\nthis:\n  \\<exists>K.\n     \\<forall>x.\n        \\<parallel>(A\\<^sup>\\<dagger>) x\\<parallel>\n        \\<le> \\<parallel>x\\<parallel> * K\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition double_cadjoint:\n  fixes U :: \\<open>'a::chilbert_space \\<Rightarrow> 'b::complex_inner\\<close>\n  assumes a1: \"bounded_clinear U\"\n  shows \"U\\<^sup>\\<dagger>\\<^sup>\\<dagger> = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U\\<^sup>\\<dagger>\\<^sup>\\<dagger> = U", "by (metis assms cadjoint_def cadjoint_is_cadjoint is_adjoint_sym is_cadjoint_unique someI_ex)"], ["", "lemma cadjoint_id: \\<open>(id::'a::complex_inner\\<Rightarrow>'a)\\<^sup>\\<dagger> = id\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. id\\<^sup>\\<dagger> = id", "by (simp add: cadjoint_eqI id_def)"], ["", "lemma scaleC_cadjoint:\n  fixes A::\"'a::chilbert_space \\<Rightarrow> 'b::complex_inner\"\n  assumes \"bounded_clinear A\"\n  shows \\<open>(\\<lambda>t. a *\\<^sub>C (A t))\\<^sup>\\<dagger> = (\\<lambda>s. (cnj a) *\\<^sub>C ((A\\<^sup>\\<dagger>) s))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger> =\n    (\\<lambda>s. cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) s)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger> =\n    (\\<lambda>s. cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) s)", "have b3: \\<open>\\<langle>(\\<lambda> s. (cnj a) *\\<^sub>C ((A\\<^sup>\\<dagger>) s)) x, y \\<rangle> = \\<langle>x, (\\<lambda> t. a *\\<^sub>C (A t)) y \\<rangle>\\<close>\n    for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) x, y\\<rangle> =\n    \\<langle>x, a *\\<^sub>C A y\\<rangle>", "by (simp add: assms cadjoint_univ_prop)"], ["proof (state)\nthis:\n  \\<langle>cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) ?x, ?y\\<rangle> =\n  \\<langle>?x, a *\\<^sub>C A ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger> =\n    (\\<lambda>s. cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) s)", "have \"((\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger>) b = cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) b\"\n    for b::'b"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger>) b =\n    cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) b", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger>) b =\n    cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) b", "have \"bounded_clinear (\\<lambda>t. a *\\<^sub>C A t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>t. a *\\<^sub>C A t)", "by (simp add: assms bounded_clinear_const_scaleC)"], ["proof (state)\nthis:\n  bounded_clinear (\\<lambda>t. a *\\<^sub>C A t)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger>) b =\n    cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) b", "thus ?thesis"], ["proof (prove)\nusing this:\n  bounded_clinear (\\<lambda>t. a *\\<^sub>C A t)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger>) b =\n    cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) b", "by (metis (no_types) cadjoint_eqI b3)"], ["proof (state)\nthis:\n  ((\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger>) b =\n  cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger>) ?b =\n  cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) ?b\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger> =\n    (\\<lambda>s. cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger>) ?b =\n  cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) ?b\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger> =\n    (\\<lambda>s. cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) s)", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>t. a *\\<^sub>C A t)\\<^sup>\\<dagger> =\n  (\\<lambda>s. cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_projection_on_is_cadjoint:\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes a1: \\<open>is_projection_on \\<pi> M\\<close> and a2: \\<open>closed_csubspace M\\<close>\n  shows \\<open>is_cadjoint \\<pi> \\<pi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cadjoint \\<pi> \\<pi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_cadjoint \\<pi> \\<pi>", "have \\<open>cinner (x - \\<pi> x) y = 0\\<close> if \\<open>y\\<in>M\\<close> for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal (x - \\<pi> x) y", "using a1 a2 is_projection_on_iff_orthog orthogonal_complement_orthoI that"], ["proof (prove)\nusing this:\n  is_projection_on \\<pi> M\n  closed_csubspace M\n  closed_csubspace ?M \\<Longrightarrow>\n  is_projection_on ?\\<pi> ?M =\n  (\\<forall>h.\n      h - ?\\<pi> h \\<in> orthogonal_complement ?M \\<and> ?\\<pi> h \\<in> ?M)\n  \\<lbrakk>?x \\<in> orthogonal_complement ?M; ?y \\<in> ?M\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n  y \\<in> M\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - \\<pi> x) y", "by blast"], ["proof (state)\nthis:\n  ?y \\<in> M \\<Longrightarrow> is_orthogonal (?x - \\<pi> ?x) ?y\n\ngoal (1 subgoal):\n 1. is_cadjoint \\<pi> \\<pi>", "then"], ["proof (chain)\npicking this:\n  ?y \\<in> M \\<Longrightarrow> is_orthogonal (?x - \\<pi> ?x) ?y", "have \\<open>cinner x y = cinner (\\<pi> x) y\\<close> if \\<open>y\\<in>M\\<close> for x y"], ["proof (prove)\nusing this:\n  ?y \\<in> M \\<Longrightarrow> is_orthogonal (?x - \\<pi> ?x) ?y\n\ngoal (1 subgoal):\n 1. \\<langle>x, y\\<rangle> = \\<langle>\\<pi> x, y\\<rangle>", "by (metis cinner_diff_left eq_iff_diff_eq_0 that)"], ["proof (state)\nthis:\n  ?y \\<in> M \\<Longrightarrow>\n  \\<langle>?x, ?y\\<rangle> = \\<langle>\\<pi> ?x, ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. is_cadjoint \\<pi> \\<pi>", "moreover"], ["proof (state)\nthis:\n  ?y \\<in> M \\<Longrightarrow>\n  \\<langle>?x, ?y\\<rangle> = \\<langle>\\<pi> ?x, ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. is_cadjoint \\<pi> \\<pi>", "have \\<open>cinner x y = cinner x (\\<pi> y)\\<close> if \\<open>y\\<in>M\\<close> for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, y\\<rangle> = \\<langle>x, \\<pi> y\\<rangle>", "using a1 is_projection_on_fixes_image that"], ["proof (prove)\nusing this:\n  is_projection_on \\<pi> M\n  \\<lbrakk>is_projection_on ?\\<pi> ?M; ?x \\<in> ?M\\<rbrakk>\n  \\<Longrightarrow> ?\\<pi> ?x = ?x\n  y \\<in> M\n\ngoal (1 subgoal):\n 1. \\<langle>x, y\\<rangle> = \\<langle>x, \\<pi> y\\<rangle>", "by fastforce"], ["proof (state)\nthis:\n  ?y \\<in> M \\<Longrightarrow>\n  \\<langle>?x, ?y\\<rangle> = \\<langle>?x, \\<pi> ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. is_cadjoint \\<pi> \\<pi>", "ultimately"], ["proof (chain)\npicking this:\n  ?y \\<in> M \\<Longrightarrow>\n  \\<langle>?x, ?y\\<rangle> = \\<langle>\\<pi> ?x, ?y\\<rangle>\n  ?y \\<in> M \\<Longrightarrow>\n  \\<langle>?x, ?y\\<rangle> = \\<langle>?x, \\<pi> ?y\\<rangle>", "have 1: \\<open>cinner (\\<pi> x) y = cinner x (\\<pi> y)\\<close> if \\<open>y\\<in>M\\<close> for x y"], ["proof (prove)\nusing this:\n  ?y \\<in> M \\<Longrightarrow>\n  \\<langle>?x, ?y\\<rangle> = \\<langle>\\<pi> ?x, ?y\\<rangle>\n  ?y \\<in> M \\<Longrightarrow>\n  \\<langle>?x, ?y\\<rangle> = \\<langle>?x, \\<pi> ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pi> x, y\\<rangle> = \\<langle>x, \\<pi> y\\<rangle>", "using that"], ["proof (prove)\nusing this:\n  ?y \\<in> M \\<Longrightarrow>\n  \\<langle>?x, ?y\\<rangle> = \\<langle>\\<pi> ?x, ?y\\<rangle>\n  ?y \\<in> M \\<Longrightarrow>\n  \\<langle>?x, ?y\\<rangle> = \\<langle>?x, \\<pi> ?y\\<rangle>\n  y \\<in> M\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pi> x, y\\<rangle> = \\<langle>x, \\<pi> y\\<rangle>", "by metis"], ["proof (state)\nthis:\n  ?y \\<in> M \\<Longrightarrow>\n  \\<langle>\\<pi> ?x, ?y\\<rangle> = \\<langle>?x, \\<pi> ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. is_cadjoint \\<pi> \\<pi>", "have \\<open>cinner (\\<pi> x) y = 0\\<close> if \\<open>y \\<in> orthogonal_complement M\\<close> for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal (\\<pi> x) y", "by (meson a1 is_projection_on_in_image orthogonal_complement_orthoI' that)"], ["proof (state)\nthis:\n  ?y \\<in> orthogonal_complement M \\<Longrightarrow>\n  is_orthogonal (\\<pi> ?x) ?y\n\ngoal (1 subgoal):\n 1. is_cadjoint \\<pi> \\<pi>", "also"], ["proof (state)\nthis:\n  ?y \\<in> orthogonal_complement M \\<Longrightarrow>\n  is_orthogonal (\\<pi> ?x) ?y\n\ngoal (1 subgoal):\n 1. is_cadjoint \\<pi> \\<pi>", "have \\<open>0 = cinner x (\\<pi> y)\\<close> if \\<open>y \\<in> orthogonal_complement M\\<close> for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = \\<langle>x, \\<pi> y\\<rangle>", "by (metis a1 a2 cinner_zero_right closed_csubspace.subspace complex_vector.subspace_0 diff_zero is_projection_on_eqI that)"], ["proof (state)\nthis:\n  ?y \\<in> orthogonal_complement M \\<Longrightarrow>\n  0 = \\<langle>?x, \\<pi> ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. is_cadjoint \\<pi> \\<pi>", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y2 \\<in> orthogonal_complement M;\n   ?y1 \\<in> orthogonal_complement M\\<rbrakk>\n  \\<Longrightarrow> \\<langle>\\<pi> ?x2, ?y2\\<rangle> =\n                    \\<langle>?x1, \\<pi> ?y1\\<rangle>", "have 2: \\<open>cinner (\\<pi> x) y = cinner x (\\<pi> y)\\<close> if \\<open>y \\<in> orthogonal_complement M\\<close> for x y"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y2 \\<in> orthogonal_complement M;\n   ?y1 \\<in> orthogonal_complement M\\<rbrakk>\n  \\<Longrightarrow> \\<langle>\\<pi> ?x2, ?y2\\<rangle> =\n                    \\<langle>?x1, \\<pi> ?y1\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pi> x, y\\<rangle> = \\<langle>x, \\<pi> y\\<rangle>", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y2 \\<in> orthogonal_complement M;\n   ?y1 \\<in> orthogonal_complement M\\<rbrakk>\n  \\<Longrightarrow> \\<langle>\\<pi> ?x2, ?y2\\<rangle> =\n                    \\<langle>?x1, \\<pi> ?y1\\<rangle>\n  y \\<in> orthogonal_complement M\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pi> x, y\\<rangle> = \\<langle>x, \\<pi> y\\<rangle>", "by simp"], ["proof (state)\nthis:\n  ?y \\<in> orthogonal_complement M \\<Longrightarrow>\n  \\<langle>\\<pi> ?x, ?y\\<rangle> = \\<langle>?x, \\<pi> ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. is_cadjoint \\<pi> \\<pi>", "from 1 2"], ["proof (chain)\npicking this:\n  ?y \\<in> M \\<Longrightarrow>\n  \\<langle>\\<pi> ?x, ?y\\<rangle> = \\<langle>?x, \\<pi> ?y\\<rangle>\n  ?y \\<in> orthogonal_complement M \\<Longrightarrow>\n  \\<langle>\\<pi> ?x, ?y\\<rangle> = \\<langle>?x, \\<pi> ?y\\<rangle>", "have \\<open>cinner (\\<pi> x) y = cinner x (\\<pi> y)\\<close> for x y"], ["proof (prove)\nusing this:\n  ?y \\<in> M \\<Longrightarrow>\n  \\<langle>\\<pi> ?x, ?y\\<rangle> = \\<langle>?x, \\<pi> ?y\\<rangle>\n  ?y \\<in> orthogonal_complement M \\<Longrightarrow>\n  \\<langle>\\<pi> ?x, ?y\\<rangle> = \\<langle>?x, \\<pi> ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pi> x, y\\<rangle> = \\<langle>x, \\<pi> y\\<rangle>", "by (smt (verit, ccfv_threshold) a1 a2 cinner_commute cinner_diff_left eq_iff_diff_eq_0 is_projection_on_iff_orthog orthogonal_complement_orthoI)"], ["proof (state)\nthis:\n  \\<langle>\\<pi> ?x, ?y\\<rangle> = \\<langle>?x, \\<pi> ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. is_cadjoint \\<pi> \\<pi>", "then"], ["proof (chain)\npicking this:\n  \\<langle>\\<pi> ?x, ?y\\<rangle> = \\<langle>?x, \\<pi> ?y\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>\\<pi> ?x, ?y\\<rangle> = \\<langle>?x, \\<pi> ?y\\<rangle>\n\ngoal (1 subgoal):\n 1. is_cadjoint \\<pi> \\<pi>", "by (simp add: is_cadjoint_def)"], ["proof (state)\nthis:\n  is_cadjoint \\<pi> \\<pi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_projection_on_cadjoint:\n  fixes M :: \\<open>'a::complex_inner set\\<close>\n  assumes \\<open>is_projection_on \\<pi> M\\<close> and \\<open>closed_csubspace M\\<close>\n  shows \\<open>\\<pi>\\<^sup>\\<dagger> = \\<pi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>\\<^sup>\\<dagger> = \\<pi>", "using assms is_projection_on_is_cadjoint cadjoint_eqI is_cadjoint_def"], ["proof (prove)\nusing this:\n  is_projection_on \\<pi> M\n  closed_csubspace M\n  \\<lbrakk>is_projection_on ?\\<pi> ?M; closed_csubspace ?M\\<rbrakk>\n  \\<Longrightarrow> is_cadjoint ?\\<pi> ?\\<pi>\n  (\\<And>x y.\n      \\<langle>?F x, y\\<rangle> =\n      \\<langle>x, ?G y\\<rangle>) \\<Longrightarrow>\n  ?G\\<^sup>\\<dagger> = ?F\n  is_cadjoint ?F ?G =\n  (\\<forall>x y. \\<langle>?F x, y\\<rangle> = \\<langle>x, ?G y\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<pi>\\<^sup>\\<dagger> = \\<pi>", "by blast"], ["", "lemma projection_cadjoint:\n  fixes M :: \\<open>'a::chilbert_space set\\<close>\n  assumes \\<open>closed_csubspace M\\<close>\n  shows \\<open>(projection M)\\<^sup>\\<dagger> = projection M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection M\\<^sup>\\<dagger> = projection M", "using is_projection_on_cadjoint assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_projection_on ?\\<pi> ?M; closed_csubspace ?M\\<rbrakk>\n  \\<Longrightarrow> ?\\<pi>\\<^sup>\\<dagger> = ?\\<pi>\n  closed_csubspace M\n\ngoal (1 subgoal):\n 1. projection M\\<^sup>\\<dagger> = projection M", "by (metis closed_csubspace.closed closed_csubspace.subspace csubspace_is_convex empty_iff orthog_proj_exists projection_is_projection_on)"], ["", "instance ccsubspace :: (chilbert_space) complete_orthomodular_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, complete_orthomodular_lattice_class)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x. x \\<sqinter> - x = \\<bottom>\n 2. \\<And>x. x \\<squnion> - x = \\<top>\n 3. \\<And>x y. x - y = x \\<sqinter> - y\n 4. \\<And>x. - (- x) = x\n 5. \\<And>x y. x \\<le> y \\<Longrightarrow> - y \\<le> - x\n 6. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<squnion> - x \\<sqinter> y = y", "show \"inf x (- x) = bot\"\n    for x :: \"'a ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - x = \\<bottom>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       closed_csubspace x \\<Longrightarrow>\n       x \\<inter> orthogonal_complement x = {0::'a}", "by (simp add: closed_csubspace_def complex_vector.subspace_0 orthogonal_complement_zero_intersection)"], ["proof (state)\nthis:\n  ?x \\<sqinter> - ?x = \\<bottom>\n\ngoal (5 subgoals):\n 1. \\<And>x. x \\<squnion> - x = \\<top>\n 2. \\<And>x y. x - y = x \\<sqinter> - y\n 3. \\<And>x. - (- x) = x\n 4. \\<And>x y. x \\<le> y \\<Longrightarrow> - y \\<le> - x\n 5. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<squnion> - x \\<sqinter> y = y", "have \\<open>t \\<in> x +\\<^sub>M orthogonal_complement x\\<close>\n    if a1: \\<open>closed_csubspace x\\<close>\n    for t::'a and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> x +\\<^sub>M orthogonal_complement x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> x +\\<^sub>M orthogonal_complement x", "have e1: \\<open>t = (projection x) t + (projection (orthogonal_complement x)) t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. t = projection x t + projection (orthogonal_complement x) t", "by (simp add: that)"], ["proof (state)\nthis:\n  t = projection x t + projection (orthogonal_complement x) t\n\ngoal (1 subgoal):\n 1. t \\<in> x +\\<^sub>M orthogonal_complement x", "have e2: \\<open>(projection x) t \\<in> x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection x t \\<in> x", "by (metis closed_csubspace.closed closed_csubspace.subspace csubspace_is_convex empty_iff orthog_proj_exists projection_in_image that)"], ["proof (state)\nthis:\n  projection x t \\<in> x\n\ngoal (1 subgoal):\n 1. t \\<in> x +\\<^sub>M orthogonal_complement x", "have e3: \\<open>(projection (orthogonal_complement x)) t \\<in> orthogonal_complement x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection (orthogonal_complement x) t \\<in> orthogonal_complement x", "by (metis add_diff_cancel_left' e1 orthogonal_complementI projection_orthogonal that)"], ["proof (state)\nthis:\n  projection (orthogonal_complement x) t \\<in> orthogonal_complement x\n\ngoal (1 subgoal):\n 1. t \\<in> x +\\<^sub>M orthogonal_complement x", "have \"orthogonal_complement x \\<subseteq> x +\\<^sub>M orthogonal_complement x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement x \\<subseteq> x +\\<^sub>M orthogonal_complement x", "by (simp add: closed_sum_right_subset complex_vector.subspace_0 that)"], ["proof (state)\nthis:\n  orthogonal_complement x \\<subseteq> x +\\<^sub>M orthogonal_complement x\n\ngoal (1 subgoal):\n 1. t \\<in> x +\\<^sub>M orthogonal_complement x", "thus ?thesis"], ["proof (prove)\nusing this:\n  orthogonal_complement x \\<subseteq> x +\\<^sub>M orthogonal_complement x\n\ngoal (1 subgoal):\n 1. t \\<in> x +\\<^sub>M orthogonal_complement x", "using \\<open>closed_csubspace x\\<close> \n        \\<open>projection (orthogonal_complement x) t \\<in> orthogonal_complement x\\<close> \\<open>projection x t \\<in> x\\<close>\n        \\<open>t = projection x t + projection (orthogonal_complement x) t\\<close> in_mono \n        closed_sum_left_subset complex_vector.subspace_def"], ["proof (prove)\nusing this:\n  orthogonal_complement x \\<subseteq> x +\\<^sub>M orthogonal_complement x\n  closed_csubspace x\n  projection (orthogonal_complement x) t \\<in> orthogonal_complement x\n  projection x t \\<in> x\n  t = projection x t + projection (orthogonal_complement x) t\n  ?A \\<subseteq> ?B \\<Longrightarrow>\n  ?x \\<in> ?A \\<longrightarrow> ?x \\<in> ?B\n  (0::?'c) \\<in> ?B \\<Longrightarrow> ?A \\<subseteq> ?A +\\<^sub>M ?B\n  csubspace ?S =\n  ((0::?'a) \\<in> ?S \\<and>\n   (\\<forall>x\\<in>?S. \\<forall>y\\<in>?S. x + y \\<in> ?S) \\<and>\n   (\\<forall>c. \\<forall>x\\<in>?S. c *\\<^sub>C x \\<in> ?S))\n\ngoal (1 subgoal):\n 1. t \\<in> x +\\<^sub>M orthogonal_complement x", "by (metis closed_csubspace.subspace closed_subspace_closed_sum orthogonal_complement_closed_subspace)"], ["proof (state)\nthis:\n  t \\<in> x +\\<^sub>M orthogonal_complement x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed_csubspace ?x \\<Longrightarrow>\n  ?t \\<in> ?x +\\<^sub>M orthogonal_complement ?x\n\ngoal (5 subgoals):\n 1. \\<And>x. x \\<squnion> - x = \\<top>\n 2. \\<And>x y. x - y = x \\<sqinter> - y\n 3. \\<And>x. - (- x) = x\n 4. \\<And>x y. x \\<le> y \\<Longrightarrow> - y \\<le> - x\n 5. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<squnion> - x \\<sqinter> y = y", "hence b1: \\<open>x +\\<^sub>M orthogonal_complement x = UNIV\\<close>\n    if a1: \\<open>closed_csubspace x\\<close>\n    for x::\\<open>'a set\\<close>"], ["proof (prove)\nusing this:\n  closed_csubspace ?x \\<Longrightarrow>\n  ?t \\<in> ?x +\\<^sub>M orthogonal_complement ?x\n\ngoal (1 subgoal):\n 1. x +\\<^sub>M orthogonal_complement x = UNIV", "using that"], ["proof (prove)\nusing this:\n  closed_csubspace ?x \\<Longrightarrow>\n  ?t \\<in> ?x +\\<^sub>M orthogonal_complement ?x\n  closed_csubspace x\n\ngoal (1 subgoal):\n 1. x +\\<^sub>M orthogonal_complement x = UNIV", "by blast"], ["proof (state)\nthis:\n  closed_csubspace ?x \\<Longrightarrow>\n  ?x +\\<^sub>M orthogonal_complement ?x = UNIV\n\ngoal (5 subgoals):\n 1. \\<And>x. x \\<squnion> - x = \\<top>\n 2. \\<And>x y. x - y = x \\<sqinter> - y\n 3. \\<And>x. - (- x) = x\n 4. \\<And>x y. x \\<le> y \\<Longrightarrow> - y \\<le> - x\n 5. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<squnion> - x \\<sqinter> y = y", "show \"sup x (- x) = top\"\n    for x :: \"'a ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> - x = \\<top>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       closed_csubspace x \\<Longrightarrow>\n       x +\\<^sub>M orthogonal_complement x = UNIV", "using b1"], ["proof (prove)\nusing this:\n  closed_csubspace ?x \\<Longrightarrow>\n  ?x +\\<^sub>M orthogonal_complement ?x = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       closed_csubspace x \\<Longrightarrow>\n       x +\\<^sub>M orthogonal_complement x = UNIV", "by auto"], ["proof (state)\nthis:\n  ?x \\<squnion> - ?x = \\<top>\n\ngoal (4 subgoals):\n 1. \\<And>x y. x - y = x \\<sqinter> - y\n 2. \\<And>x. - (- x) = x\n 3. \\<And>x y. x \\<le> y \\<Longrightarrow> - y \\<le> - x\n 4. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<squnion> - x \\<sqinter> y = y", "show \"- (- x) = x\"\n    for x :: \"'a ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- x) = x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       closed_csubspace x \\<Longrightarrow>\n       orthogonal_complement (orthogonal_complement x) = x", "by (simp)"], ["proof (state)\nthis:\n  - (- ?x) = ?x\n\ngoal (3 subgoals):\n 1. \\<And>x y. x - y = x \\<sqinter> - y\n 2. \\<And>x y. x \\<le> y \\<Longrightarrow> - y \\<le> - x\n 3. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<squnion> - x \\<sqinter> y = y", "show \"- y \\<le> - x\"\n    if \"x \\<le> y\"\n    for x :: \"'a ccsubspace\"\n      and y :: \"'a ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - y \\<le> - x", "using that"], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. - y \\<le> - x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>closed_csubspace x; closed_csubspace y;\n        x \\<subseteq> y\\<rbrakk>\n       \\<Longrightarrow> orthogonal_complement y\n                         \\<subseteq> orthogonal_complement x", "by simp"], ["proof (state)\nthis:\n  ?x \\<le> ?y \\<Longrightarrow> - ?y \\<le> - ?x\n\ngoal (2 subgoals):\n 1. \\<And>x y. x - y = x \\<sqinter> - y\n 2. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<squnion> - x \\<sqinter> y = y", "have c1: \"x +\\<^sub>M orthogonal_complement x \\<inter> y \\<subseteq> y\"\n    if \"closed_csubspace x\"\n      and \"closed_csubspace y\"\n      and \"x \\<subseteq> y\"\n    for x :: \"'a set\"\n      and y :: \"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x +\\<^sub>M orthogonal_complement x \\<inter> y \\<subseteq> y", "using that"], ["proof (prove)\nusing this:\n  closed_csubspace x\n  closed_csubspace y\n  x \\<subseteq> y\n\ngoal (1 subgoal):\n 1. x +\\<^sub>M orthogonal_complement x \\<inter> y \\<subseteq> y", "by (simp add: closed_sum_is_sup)"], ["proof (state)\nthis:\n  \\<lbrakk>closed_csubspace ?x; closed_csubspace ?y;\n   ?x \\<subseteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x +\\<^sub>M orthogonal_complement ?x \\<inter> ?y\n                    \\<subseteq> ?y\n\ngoal (2 subgoals):\n 1. \\<And>x y. x - y = x \\<sqinter> - y\n 2. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<squnion> - x \\<sqinter> y = y", "have c2: \\<open>u \\<in> x +\\<^sub>M ((orthogonal_complement x) \\<inter> y)\\<close>\n    if a1: \"closed_csubspace x\" and a2: \"closed_csubspace y\" and a3: \"x \\<subseteq> y\" and x1: \\<open>u \\<in> y\\<close>\n    for x :: \"'a set\" and y :: \"'a set\"  and u"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y", "have d4: \\<open>(projection x) u \\<in> x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection x u \\<in> x", "by (metis a1 closed_csubspace_def csubspace_is_convex equals0D orthog_proj_exists projection_in_image)"], ["proof (state)\nthis:\n  projection x u \\<in> x\n\ngoal (1 subgoal):\n 1. u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y", "hence d2: \\<open>(projection x) u \\<in> y\\<close>"], ["proof (prove)\nusing this:\n  projection x u \\<in> x\n\ngoal (1 subgoal):\n 1. projection x u \\<in> y", "using a3"], ["proof (prove)\nusing this:\n  projection x u \\<in> x\n  x \\<subseteq> y\n\ngoal (1 subgoal):\n 1. projection x u \\<in> y", "by auto"], ["proof (state)\nthis:\n  projection x u \\<in> y\n\ngoal (1 subgoal):\n 1. u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y", "have d1: \\<open>csubspace y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace y", "by (simp add: a2)"], ["proof (state)\nthis:\n  csubspace y\n\ngoal (1 subgoal):\n 1. u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y", "have \\<open>u - (projection x) u \\<in> orthogonal_complement x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. u - projection x u \\<in> orthogonal_complement x", "by (simp add: a1 orthogonal_complementI projection_orthogonal)"], ["proof (state)\nthis:\n  u - projection x u \\<in> orthogonal_complement x\n\ngoal (1 subgoal):\n 1. u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y", "moreover"], ["proof (state)\nthis:\n  u - projection x u \\<in> orthogonal_complement x\n\ngoal (1 subgoal):\n 1. u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y", "have  \\<open>u - (projection x) u \\<in> y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. u - projection x u \\<in> y", "by (simp add: d1 d2 complex_vector.subspace_diff x1)"], ["proof (state)\nthis:\n  u - projection x u \\<in> y\n\ngoal (1 subgoal):\n 1. u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y", "ultimately"], ["proof (chain)\npicking this:\n  u - projection x u \\<in> orthogonal_complement x\n  u - projection x u \\<in> y", "have d3: \\<open>u - (projection x) u \\<in> ((orthogonal_complement x) \\<inter> y)\\<close>"], ["proof (prove)\nusing this:\n  u - projection x u \\<in> orthogonal_complement x\n  u - projection x u \\<in> y\n\ngoal (1 subgoal):\n 1. u - projection x u \\<in> orthogonal_complement x \\<inter> y", "by simp"], ["proof (state)\nthis:\n  u - projection x u \\<in> orthogonal_complement x \\<inter> y\n\ngoal (1 subgoal):\n 1. u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y", "hence \\<open>\\<exists> v \\<in> ((orthogonal_complement x) \\<inter> y). u = (projection x) u + v\\<close>"], ["proof (prove)\nusing this:\n  u - projection x u \\<in> orthogonal_complement x \\<inter> y\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>orthogonal_complement x \\<inter> y.\n       u = projection x u + v", "by (metis d3 diff_add_cancel ordered_field_class.sign_simps(2))"], ["proof (state)\nthis:\n  \\<exists>v\\<in>orthogonal_complement x \\<inter> y. u = projection x u + v\n\ngoal (1 subgoal):\n 1. u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>orthogonal_complement x \\<inter> y. u = projection x u + v", "obtain v where \\<open>v \\<in> ((orthogonal_complement x) \\<inter> y)\\<close> and \\<open>u = (projection x) u + v\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>orthogonal_complement x \\<inter> y. u = projection x u + v\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> orthogonal_complement x \\<inter> y;\n         u = projection x u + v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> orthogonal_complement x \\<inter> y\n  u = projection x u + v\n\ngoal (1 subgoal):\n 1. u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y", "hence \\<open>u \\<in> x + ((orthogonal_complement x) \\<inter> y)\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> orthogonal_complement x \\<inter> y\n  u = projection x u + v\n\ngoal (1 subgoal):\n 1. u \\<in> x + orthogonal_complement x \\<inter> y", "by (metis d4 set_plus_intro)"], ["proof (state)\nthis:\n  u \\<in> x + orthogonal_complement x \\<inter> y\n\ngoal (1 subgoal):\n 1. u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> x + orthogonal_complement x \\<inter> y\n\ngoal (1 subgoal):\n 1. u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y", "unfolding closed_sum_def"], ["proof (prove)\nusing this:\n  u \\<in> x + orthogonal_complement x \\<inter> y\n\ngoal (1 subgoal):\n 1. u \\<in> closure (x + orthogonal_complement x \\<inter> y)", "using closure_subset"], ["proof (prove)\nusing this:\n  u \\<in> x + orthogonal_complement x \\<inter> y\n  ?S \\<subseteq> closure ?S\n\ngoal (1 subgoal):\n 1. u \\<in> closure (x + orthogonal_complement x \\<inter> y)", "by blast"], ["proof (state)\nthis:\n  u \\<in> x +\\<^sub>M orthogonal_complement x \\<inter> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>closed_csubspace ?x; closed_csubspace ?y; ?x \\<subseteq> ?y;\n   ?u \\<in> ?y\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> ?x +\\<^sub>M\n                             orthogonal_complement ?x \\<inter> ?y\n\ngoal (2 subgoals):\n 1. \\<And>x y. x - y = x \\<sqinter> - y\n 2. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<squnion> - x \\<sqinter> y = y", "have c3: \"y \\<subseteq> x +\\<^sub>M ((orthogonal_complement x) \\<inter> y)\"\n    if a1: \"closed_csubspace x\" and a2: \"closed_csubspace y\" and a3: \"x \\<subseteq> y\"\n    for x y :: \"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<subseteq> x +\\<^sub>M orthogonal_complement x \\<inter> y", "using c2 a1 a2 a3"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed_csubspace ?x; closed_csubspace ?y; ?x \\<subseteq> ?y;\n   ?u \\<in> ?y\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> ?x +\\<^sub>M\n                             orthogonal_complement ?x \\<inter> ?y\n  closed_csubspace x\n  closed_csubspace y\n  x \\<subseteq> y\n\ngoal (1 subgoal):\n 1. y \\<subseteq> x +\\<^sub>M orthogonal_complement x \\<inter> y", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>closed_csubspace ?x; closed_csubspace ?y;\n   ?x \\<subseteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<subseteq> ?x +\\<^sub>M\n                                   orthogonal_complement ?x \\<inter> ?y\n\ngoal (2 subgoals):\n 1. \\<And>x y. x - y = x \\<sqinter> - y\n 2. \\<And>x y. x \\<le> y \\<Longrightarrow> x \\<squnion> - x \\<sqinter> y = y", "show \"sup x (inf (- x) y) = y\"\n    if \"x \\<le> y\"\n    for x y :: \"'a ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> - x \\<sqinter> y = y", "using that"], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<squnion> - x \\<sqinter> y = y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>closed_csubspace x; closed_csubspace y;\n        x \\<subseteq> y\\<rbrakk>\n       \\<Longrightarrow> x +\\<^sub>M orthogonal_complement x \\<inter> y = y", "using c1 c3"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed_csubspace ?x; closed_csubspace ?y;\n   ?x \\<subseteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x +\\<^sub>M orthogonal_complement ?x \\<inter> ?y\n                    \\<subseteq> ?y\n  \\<lbrakk>closed_csubspace ?x; closed_csubspace ?y;\n   ?x \\<subseteq> ?y\\<rbrakk>\n  \\<Longrightarrow> ?y \\<subseteq> ?x +\\<^sub>M\n                                   orthogonal_complement ?x \\<inter> ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>closed_csubspace x; closed_csubspace y;\n        x \\<subseteq> y\\<rbrakk>\n       \\<Longrightarrow> x +\\<^sub>M orthogonal_complement x \\<inter> y = y", "by (simp add: subset_antisym)"], ["proof (state)\nthis:\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<squnion> - ?x \\<sqinter> ?y = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x - y = x \\<sqinter> - y", "show \"x - y = inf x (- y)\"\n    for x y :: \"'a ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x - y = x \\<sqinter> - y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>closed_csubspace x; closed_csubspace y\\<rbrakk>\n       \\<Longrightarrow> x \\<inter> orthogonal_complement y =\n                         x \\<inter> orthogonal_complement y", "by simp"], ["proof (state)\nthis:\n  ?x - ?y = ?x \\<sqinter> - ?y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>More projections\\<close>"], ["", "text \\<open>These lemmas logically belong in the \"projections\" section above but depend on lemmas developed later.\\<close>"], ["", "lemma is_projection_on_plus:\n  assumes \"\\<And>x y. x:A \\<Longrightarrow> y:B \\<Longrightarrow> is_orthogonal x y\"\n  assumes \\<open>closed_csubspace A\\<close>\n  assumes \\<open>closed_csubspace B\\<close>\n  assumes \\<open>is_projection_on \\<pi>A A\\<close>\n  assumes \\<open>is_projection_on \\<pi>B B\\<close>\n  shows \\<open>is_projection_on (\\<lambda>x. \\<pi>A x + \\<pi>B x) (A +\\<^sub>M B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_projection_on (\\<lambda>x. \\<pi>A x + \\<pi>B x) (A +\\<^sub>M B)", "proof (rule is_projection_on_iff_orthog[THEN iffD2, rule_format])"], ["proof (state)\ngoal (2 subgoals):\n 1. closed_csubspace (A +\\<^sub>M B)\n 2. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "show clAB: \\<open>closed_csubspace (A +\\<^sub>M B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (A +\\<^sub>M B)", "by (simp add: assms(2) assms(3) closed_subspace_closed_sum)"], ["proof (state)\nthis:\n  closed_csubspace (A +\\<^sub>M B)\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "have 1: \\<open>\\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "by (meson clAB assms(2) assms(3) assms(4) assms(5) closed_csubspace_def closed_sum_left_subset closed_sum_right_subset complex_vector.subspace_def in_mono is_projection_on_in_image)"], ["proof (state)\nthis:\n  \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "have \\<open>\\<pi>A (\\<pi>B h) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>A (\\<pi>B h) = (0::'a)", "by (smt (verit, del_insts) assms(1) assms(2) assms(4) assms(5) cinner_eq_zero_iff is_cadjoint_def is_projection_on_in_image is_projection_on_is_cadjoint)"], ["proof (state)\nthis:\n  \\<pi>A (\\<pi>B h) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "then"], ["proof (chain)\npicking this:\n  \\<pi>A (\\<pi>B h) = (0::'a)", "have \\<open>h - (\\<pi>A h + \\<pi>B h) = (h - \\<pi>B h) - \\<pi>A (h - \\<pi>B h)\\<close>"], ["proof (prove)\nusing this:\n  \\<pi>A (\\<pi>B h) = (0::'a)\n\ngoal (1 subgoal):\n 1. h - (\\<pi>A h + \\<pi>B h) = h - \\<pi>B h - \\<pi>A (h - \\<pi>B h)", "by (smt (verit) add.right_neutral add_diff_cancel_left' assms(2) assms(4) closed_csubspace.subspace complex_vector.subspace_diff diff_add_eq_diff_diff_swap diff_diff_add is_projection_on_iff_orthog orthog_proj_unique orthogonal_complement_closed_subspace)"], ["proof (state)\nthis:\n  h - (\\<pi>A h + \\<pi>B h) = h - \\<pi>B h - \\<pi>A (h - \\<pi>B h)\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "also"], ["proof (state)\nthis:\n  h - (\\<pi>A h + \\<pi>B h) = h - \\<pi>B h - \\<pi>A (h - \\<pi>B h)\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "have \\<open>\\<dots> \\<in> orthogonal_complement A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. h - \\<pi>B h - \\<pi>A (h - \\<pi>B h) \\<in> orthogonal_complement A", "using assms(2) assms(4) is_projection_on_iff_orthog"], ["proof (prove)\nusing this:\n  closed_csubspace A\n  is_projection_on \\<pi>A A\n  closed_csubspace ?M \\<Longrightarrow>\n  is_projection_on ?\\<pi> ?M =\n  (\\<forall>h.\n      h - ?\\<pi> h \\<in> orthogonal_complement ?M \\<and> ?\\<pi> h \\<in> ?M)\n\ngoal (1 subgoal):\n 1. h - \\<pi>B h - \\<pi>A (h - \\<pi>B h) \\<in> orthogonal_complement A", "by blast"], ["proof (state)\nthis:\n  h - \\<pi>B h - \\<pi>A (h - \\<pi>B h) \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "finally"], ["proof (chain)\npicking this:\n  h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement A", "have orthoA: \\<open>h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement A\\<close>"], ["proof (prove)\nusing this:\n  h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement A", "by -"], ["proof (state)\nthis:\n  h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement A\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "have \\<open>\\<pi>B (\\<pi>A h) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>B (\\<pi>A h) = (0::'a)", "by (smt (verit, del_insts) assms(1) assms(3) assms(4) assms(5) cinner_eq_zero_iff is_cadjoint_def is_projection_on_in_image is_projection_on_is_cadjoint)"], ["proof (state)\nthis:\n  \\<pi>B (\\<pi>A h) = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "then"], ["proof (chain)\npicking this:\n  \\<pi>B (\\<pi>A h) = (0::'a)", "have \\<open>h - (\\<pi>A h + \\<pi>B h) = (h - \\<pi>A h) - \\<pi>B (h - \\<pi>A h)\\<close>"], ["proof (prove)\nusing this:\n  \\<pi>B (\\<pi>A h) = (0::'a)\n\ngoal (1 subgoal):\n 1. h - (\\<pi>A h + \\<pi>B h) = h - \\<pi>A h - \\<pi>B (h - \\<pi>A h)", "by (smt (verit) add.right_neutral add_diff_cancel assms(3) assms(5) closed_csubspace.subspace complex_vector.subspace_diff diff_add_eq_diff_diff_swap diff_diff_add is_projection_on_iff_orthog orthog_proj_unique orthogonal_complement_closed_subspace)"], ["proof (state)\nthis:\n  h - (\\<pi>A h + \\<pi>B h) = h - \\<pi>A h - \\<pi>B (h - \\<pi>A h)\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "also"], ["proof (state)\nthis:\n  h - (\\<pi>A h + \\<pi>B h) = h - \\<pi>A h - \\<pi>B (h - \\<pi>A h)\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "have \\<open>\\<dots> \\<in> orthogonal_complement B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. h - \\<pi>A h - \\<pi>B (h - \\<pi>A h) \\<in> orthogonal_complement B", "using assms(3) assms(5) is_projection_on_iff_orthog"], ["proof (prove)\nusing this:\n  closed_csubspace B\n  is_projection_on \\<pi>B B\n  closed_csubspace ?M \\<Longrightarrow>\n  is_projection_on ?\\<pi> ?M =\n  (\\<forall>h.\n      h - ?\\<pi> h \\<in> orthogonal_complement ?M \\<and> ?\\<pi> h \\<in> ?M)\n\ngoal (1 subgoal):\n 1. h - \\<pi>A h - \\<pi>B (h - \\<pi>A h) \\<in> orthogonal_complement B", "by blast"], ["proof (state)\nthis:\n  h - \\<pi>A h - \\<pi>B (h - \\<pi>A h) \\<in> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "finally"], ["proof (chain)\npicking this:\n  h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement B", "have orthoB: \\<open>h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement B\\<close>"], ["proof (prove)\nusing this:\n  h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement B", "by -"], ["proof (state)\nthis:\n  h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "from orthoA orthoB"], ["proof (chain)\npicking this:\n  h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement A\n  h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement B", "have 2: \\<open>h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement (A +\\<^sub>M B)\\<close>"], ["proof (prove)\nusing this:\n  h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement A\n  h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement (A +\\<^sub>M B)", "by (metis IntI assms(2) assms(3) closed_csubspace_def complex_vector.subspace_def de_morgan_orthogonal_complement_plus)"], ["proof (state)\nthis:\n  h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement (A +\\<^sub>M B)\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h - (\\<pi>A h + \\<pi>B h)\n       \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n       \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "from 1 2"], ["proof (chain)\npicking this:\n  \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B\n  h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement (A +\\<^sub>M B)", "show \\<open>h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and> \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B\\<close>"], ["proof (prove)\nusing this:\n  \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B\n  h - (\\<pi>A h + \\<pi>B h) \\<in> orthogonal_complement (A +\\<^sub>M B)\n\ngoal (1 subgoal):\n 1. h - (\\<pi>A h + \\<pi>B h)\n    \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n    \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B", "by simp"], ["proof (state)\nthis:\n  h - (\\<pi>A h + \\<pi>B h)\n  \\<in> orthogonal_complement (A +\\<^sub>M B) \\<and>\n  \\<pi>A h + \\<pi>B h \\<in> A +\\<^sub>M B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma projection_plus:\n  fixes A B :: \"'a::chilbert_space set\"\n  assumes \"\\<And>x y. x:A \\<Longrightarrow> y:B \\<Longrightarrow> is_orthogonal x y\"\n  assumes \\<open>closed_csubspace A\\<close>\n  assumes \\<open>closed_csubspace B\\<close>\n  shows \\<open>projection (A +\\<^sub>M B) = (\\<lambda>x. projection A x + projection B x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection (A +\\<^sub>M B) =\n    (\\<lambda>x. projection A x + projection B x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. projection (A +\\<^sub>M B) =\n    (\\<lambda>x. projection A x + projection B x)", "have \\<open>is_projection_on (\\<lambda>x. projection A x + projection B x) (A +\\<^sub>M B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_projection_on (\\<lambda>x. projection A x + projection B x)\n     (A +\\<^sub>M B)", "apply (rule is_projection_on_plus)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal x y\n 2. closed_csubspace A\n 3. closed_csubspace B\n 4. is_projection_on (projection A) A\n 5. is_projection_on (projection B) B", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> A; ?y \\<in> B\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n  closed_csubspace A\n  closed_csubspace B\n\ngoal (5 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal x y\n 2. closed_csubspace A\n 3. closed_csubspace B\n 4. is_projection_on (projection A) A\n 5. is_projection_on (projection B) B", "by auto"], ["proof (state)\nthis:\n  is_projection_on (\\<lambda>x. projection A x + projection B x)\n   (A +\\<^sub>M B)\n\ngoal (1 subgoal):\n 1. projection (A +\\<^sub>M B) =\n    (\\<lambda>x. projection A x + projection B x)", "then"], ["proof (chain)\npicking this:\n  is_projection_on (\\<lambda>x. projection A x + projection B x)\n   (A +\\<^sub>M B)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_projection_on (\\<lambda>x. projection A x + projection B x)\n   (A +\\<^sub>M B)\n\ngoal (1 subgoal):\n 1. projection (A +\\<^sub>M B) =\n    (\\<lambda>x. projection A x + projection B x)", "by (meson assms(2) assms(3) closed_csubspace.subspace closed_subspace_closed_sum csubspace_is_convex projection_eqI')"], ["proof (state)\nthis:\n  projection (A +\\<^sub>M B) = (\\<lambda>x. projection A x + projection B x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_projection_on_insert:\n  assumes ortho: \"\\<And>s. s \\<in> S \\<Longrightarrow> \\<langle>a, s\\<rangle> = 0\"\n  assumes \\<open>is_projection_on \\<pi> (closure (cspan S))\\<close>\n  assumes \\<open>is_projection_on \\<pi>a (cspan {a})\\<close>\n  shows \"is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x) (closure (cspan (insert a S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x)\n     (closure (cspan (insert a S)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x)\n     (closure (cspan (insert a S)))", "from ortho"], ["proof (chain)\npicking this:\n  ?s \\<in> S \\<Longrightarrow> is_orthogonal a ?s", "have \\<open>x \\<in> cspan {a} \\<Longrightarrow> y \\<in> closure (cspan S) \\<Longrightarrow> is_orthogonal x y\\<close> for x y"], ["proof (prove)\nusing this:\n  ?s \\<in> S \\<Longrightarrow> is_orthogonal a ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> cspan {a}; y \\<in> closure (cspan S)\\<rbrakk>\n    \\<Longrightarrow> is_orthogonal x y", "using is_orthogonal_cspan is_orthogonal_closure is_orthogonal_sym"], ["proof (prove)\nusing this:\n  ?s \\<in> S \\<Longrightarrow> is_orthogonal a ?s\n  \\<lbrakk>\\<And>s. s \\<in> ?S \\<Longrightarrow> is_orthogonal ?a s;\n   ?x \\<in> cspan ?S\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?a ?x\n  \\<lbrakk>\\<And>s. s \\<in> ?S \\<Longrightarrow> is_orthogonal ?a s;\n   ?x \\<in> closure ?S\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?a ?x\n  is_orthogonal ?\\<psi> ?\\<phi> = is_orthogonal ?\\<phi> ?\\<psi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> cspan {a}; y \\<in> closure (cspan S)\\<rbrakk>\n    \\<Longrightarrow> is_orthogonal x y", "by (smt (verit, ccfv_threshold) empty_iff insert_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> cspan {a}; ?y \\<in> closure (cspan S)\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n\ngoal (1 subgoal):\n 1. is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x)\n     (closure (cspan (insert a S)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> cspan {a}; ?y \\<in> closure (cspan S)\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y", "have \\<open>is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x) (cspan {a} +\\<^sub>M closure (cspan S))\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> cspan {a}; ?y \\<in> closure (cspan S)\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n\ngoal (1 subgoal):\n 1. is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x)\n     (cspan {a} +\\<^sub>M closure (cspan S))", "apply (rule is_projection_on_plus)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> cspan {a}; y \\<in> closure (cspan S)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> cspan {a}\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> cspan {a}; y \\<in> closure (cspan S)\\<rbrakk>\n       \\<Longrightarrow> y \\<in> closure (cspan S)\n 3. closed_csubspace (cspan {a})\n 4. closed_csubspace (closure (cspan S))\n 5. is_projection_on \\<pi>a (cspan {a})\n 6. is_projection_on \\<pi> (closure (cspan S))", "using assms"], ["proof (prove)\nusing this:\n  ?s \\<in> S \\<Longrightarrow> is_orthogonal a ?s\n  is_projection_on \\<pi> (closure (cspan S))\n  is_projection_on \\<pi>a (cspan {a})\n\ngoal (6 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> cspan {a}; y \\<in> closure (cspan S)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> cspan {a}\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> cspan {a}; y \\<in> closure (cspan S)\\<rbrakk>\n       \\<Longrightarrow> y \\<in> closure (cspan S)\n 3. closed_csubspace (cspan {a})\n 4. closed_csubspace (closure (cspan S))\n 5. is_projection_on \\<pi>a (cspan {a})\n 6. is_projection_on \\<pi> (closure (cspan S))", "by (auto simp add: closed_csubspace.intro)"], ["proof (state)\nthis:\n  is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x)\n   (cspan {a} +\\<^sub>M closure (cspan S))\n\ngoal (1 subgoal):\n 1. is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x)\n     (closure (cspan (insert a S)))", "also"], ["proof (state)\nthis:\n  is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x)\n   (cspan {a} +\\<^sub>M closure (cspan S))\n\ngoal (1 subgoal):\n 1. is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x)\n     (closure (cspan (insert a S)))", "have \\<open>\\<dots> = closure (cspan (insert a S))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan {a} +\\<^sub>M closure (cspan S) = closure (cspan (insert a S))", "using closed_sum_cspan[where X=\\<open>{a}\\<close>]"], ["proof (prove)\nusing this:\n  cspan {a} +\\<^sub>M cspan ?Y = closure (cspan ({a} \\<union> ?Y))\n\ngoal (1 subgoal):\n 1. cspan {a} +\\<^sub>M closure (cspan S) = closure (cspan (insert a S))", "by simp"], ["proof (state)\nthis:\n  cspan {a} +\\<^sub>M closure (cspan S) = closure (cspan (insert a S))\n\ngoal (1 subgoal):\n 1. is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x)\n     (closure (cspan (insert a S)))", "finally"], ["proof (chain)\npicking this:\n  is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x)\n   (closure (cspan (insert a S)))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x)\n   (closure (cspan (insert a S)))\n\ngoal (1 subgoal):\n 1. is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x)\n     (closure (cspan (insert a S)))", "by -"], ["proof (state)\nthis:\n  is_projection_on (\\<lambda>x. \\<pi>a x + \\<pi> x)\n   (closure (cspan (insert a S)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma projection_insert:\n  fixes a :: \\<open>'a::chilbert_space\\<close>\n  assumes a1: \"\\<And>s. s \\<in> S \\<Longrightarrow> \\<langle>a, s\\<rangle> = 0\"\n  shows \"projection (closure (cspan (insert a S))) u\n        = projection (cspan {a}) u + projection (closure (cspan S)) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. projection (closure (cspan (insert a S))) u =\n    projection (cspan {a}) u + projection (closure (cspan S)) u", "using is_projection_on_insert[where S=S, OF a1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>s. s \\<in> S \\<Longrightarrow> s \\<in> S;\n   is_projection_on ?\\<pi> (closure (cspan S));\n   is_projection_on ?\\<pi>a (cspan {a})\\<rbrakk>\n  \\<Longrightarrow> is_projection_on (\\<lambda>x. ?\\<pi>a x + ?\\<pi> x)\n                     (closure (cspan (insert a S)))\n\ngoal (1 subgoal):\n 1. projection (closure (cspan (insert a S))) u =\n    projection (cspan {a}) u + projection (closure (cspan S)) u", "by (metis (no_types, lifting) closed_closure closed_csubspace.intro closure_is_csubspace complex_vector.subspace_span csubspace_is_convex finite.intros(1) finite.intros(2) finite_cspan_closed_csubspace projection_eqI' projection_is_projection_on')"], ["", "lemma projection_insert_finite:\n  assumes a1: \"\\<And>s. s \\<in> S \\<Longrightarrow> \\<langle>a, s\\<rangle> = 0\" and a2: \"finite (S::'a::chilbert_space set)\"\n  shows \"projection (cspan (insert a S)) u\n        = projection (cspan {a}) u + projection (cspan S) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. projection (cspan (insert a S)) u =\n    projection (cspan {a}) u + projection (cspan S) u", "using projection_insert"], ["proof (prove)\nusing this:\n  (\\<And>s.\n      s \\<in> ?S \\<Longrightarrow> is_orthogonal ?a s) \\<Longrightarrow>\n  projection (closure (cspan (insert ?a ?S))) ?u =\n  projection (cspan {?a}) ?u + projection (closure (cspan ?S)) ?u\n\ngoal (1 subgoal):\n 1. projection (cspan (insert a S)) u =\n    projection (cspan {a}) u + projection (cspan S) u", "by (metis a1 a2 closure_finite_cspan finite.insertI)"], ["", "subsection \\<open>Canonical basis (\\<open>onb_enum\\<close>)\\<close>"], ["", "setup \\<open>Sign.add_const_constraint (\\<^const_name>\\<open>is_ortho_set\\<close>, SOME \\<^typ>\\<open>'a set \\<Rightarrow> bool\\<close>)\\<close>"], ["", "class onb_enum = basis_enum + complex_inner +\n  assumes is_orthonormal: \"is_ortho_set (set canonical_basis)\"\n    and is_normal: \"\\<And>x. x \\<in> (set canonical_basis) \\<Longrightarrow> norm x = 1\""], ["", "setup \\<open>Sign.add_const_constraint (\\<^const_name>\\<open>is_ortho_set\\<close>, SOME \\<^typ>\\<open>'a::complex_inner set \\<Rightarrow> bool\\<close>)\\<close>"], ["", "lemma cinner_canonical_basis:\n  assumes \\<open>i < length (canonical_basis :: 'a::onb_enum list)\\<close>\n  assumes \\<open>j < length (canonical_basis :: 'a::onb_enum list)\\<close>\n  shows \\<open>cinner (canonical_basis!i :: 'a) (canonical_basis!j) = (if i=j then 1 else 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>canonical_basis ! i, canonical_basis ! j\\<rangle> =\n    (if i = j then 1 else 0)", "by (metis assms(1) assms(2) distinct_canonical_basis is_normal is_ortho_set_def is_orthonormal nth_eq_iff_index_eq nth_mem of_real_1 power2_norm_eq_cinner power_one)"], ["", "instance onb_enum \\<subseteq> chilbert_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, chilbert_space_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "show \"convergent X\"\n    if \"Cauchy X\"\n    for X :: \"nat \\<Rightarrow> 'a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convergent X", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. convergent X", "have \\<open>finite (set canonical_basis)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set canonical_basis)", "by simp"], ["proof (state)\nthis:\n  finite (set canonical_basis)\n\ngoal (1 subgoal):\n 1. convergent X", "have \\<open>Cauchy (\\<lambda> n. \\<langle> t, X n \\<rangle>)\\<close> for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. \\<langle>t, X n\\<rangle>)", "by (simp add: bounded_clinear.Cauchy bounded_clinear_cinner_right that)"], ["proof (state)\nthis:\n  Cauchy (\\<lambda>n. \\<langle>?t1, X n\\<rangle>)\n\ngoal (1 subgoal):\n 1. convergent X", "hence \\<open>convergent (\\<lambda> n. \\<langle> t, X n \\<rangle>)\\<close>\n      for t"], ["proof (prove)\nusing this:\n  Cauchy (\\<lambda>n. \\<langle>?t1, X n\\<rangle>)\n\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. \\<langle>t, X n\\<rangle>)", "by (simp add: Cauchy_convergent_iff)"], ["proof (state)\nthis:\n  convergent (\\<lambda>n. \\<langle>?t1, X n\\<rangle>)\n\ngoal (1 subgoal):\n 1. convergent X", "hence \\<open>\\<forall> t\\<in>set canonical_basis. \\<exists> L. (\\<lambda> n. \\<langle> t, X n \\<rangle>) \\<longlonglongrightarrow> L\\<close>"], ["proof (prove)\nusing this:\n  convergent (\\<lambda>n. \\<langle>?t1, X n\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set canonical_basis.\n       \\<exists>L.\n          (\\<lambda>n. \\<langle>t, X n\\<rangle>) \\<longlonglongrightarrow> L", "by (simp add: convergentD)"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set canonical_basis.\n     \\<exists>L.\n        (\\<lambda>n. \\<langle>t, X n\\<rangle>) \\<longlonglongrightarrow> L\n\ngoal (1 subgoal):\n 1. convergent X", "hence \\<open>\\<exists> L. \\<forall> t\\<in>set canonical_basis. (\\<lambda> n. \\<langle> t, X n \\<rangle>) \\<longlonglongrightarrow> L t\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set canonical_basis.\n     \\<exists>L.\n        (\\<lambda>n. \\<langle>t, X n\\<rangle>) \\<longlonglongrightarrow> L\n\ngoal (1 subgoal):\n 1. \\<exists>L.\n       \\<forall>t\\<in>set canonical_basis.\n          (\\<lambda>n. \\<langle>t, X n\\<rangle>)\n          \\<longlonglongrightarrow> L t", "by metis"], ["proof (state)\nthis:\n  \\<exists>L.\n     \\<forall>t\\<in>set canonical_basis.\n        (\\<lambda>n. \\<langle>t, X n\\<rangle>) \\<longlonglongrightarrow> L t\n\ngoal (1 subgoal):\n 1. convergent X", "then"], ["proof (chain)\npicking this:\n  \\<exists>L.\n     \\<forall>t\\<in>set canonical_basis.\n        (\\<lambda>n. \\<langle>t, X n\\<rangle>) \\<longlonglongrightarrow> L t", "obtain L where \\<open>\\<And> t. t\\<in>set canonical_basis \\<Longrightarrow> (\\<lambda> n. \\<langle> t, X n \\<rangle>) \\<longlonglongrightarrow> L t\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>L.\n     \\<forall>t\\<in>set canonical_basis.\n        (\\<lambda>n. \\<langle>t, X n\\<rangle>) \\<longlonglongrightarrow> L t\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        (\\<And>t.\n            t \\<in> set canonical_basis \\<Longrightarrow>\n            (\\<lambda>n. \\<langle>t, X n\\<rangle>)\n            \\<longlonglongrightarrow> L t) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ?t1 \\<in> set canonical_basis \\<Longrightarrow>\n  (\\<lambda>n. \\<langle>?t1, X n\\<rangle>) \\<longlonglongrightarrow> L ?t1\n\ngoal (1 subgoal):\n 1. convergent X", "define l where \\<open>l = (\\<Sum>t\\<in>set canonical_basis. L t *\\<^sub>C t)\\<close>"], ["proof (state)\nthis:\n  l = (\\<Sum>t\\<in>set canonical_basis. L t *\\<^sub>C t)\n\ngoal (1 subgoal):\n 1. convergent X", "have x1: \\<open>X n = (\\<Sum>t\\<in>set canonical_basis. \\<langle> t, X n \\<rangle> *\\<^sub>C t)\\<close>\n      for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. X n =\n    (\\<Sum>t\\<in>set canonical_basis. \\<langle>t, X n\\<rangle> *\\<^sub>C t)", "using onb_expansion_finite[where T = \"set canonical_basis\" and x = \"X n\"]\n        \\<open>finite (set canonical_basis)\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>cspan (set canonical_basis) = UNIV;\n   is_ortho_set (set canonical_basis);\n   \\<And>t.\n      t \\<in> set canonical_basis \\<Longrightarrow> norm t = 1\\<rbrakk>\n  \\<Longrightarrow> X n =\n                    (\\<Sum>t\\<in>set canonical_basis.\n                       \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n  finite (set canonical_basis)\n\ngoal (1 subgoal):\n 1. X n =\n    (\\<Sum>t\\<in>set canonical_basis. \\<langle>t, X n\\<rangle> *\\<^sub>C t)", "by (smt is_generator_set is_normal is_orthonormal)"], ["proof (state)\nthis:\n  X ?n1 =\n  (\\<Sum>t\\<in>set canonical_basis. \\<langle>t, X ?n1\\<rangle> *\\<^sub>C t)\n\ngoal (1 subgoal):\n 1. convergent X", "have \\<open>(\\<lambda> n. \\<langle> t, X n \\<rangle> *\\<^sub>C t) \\<longlonglongrightarrow> L t *\\<^sub>C t\\<close> \n      if r1: \\<open>t\\<in>set canonical_basis\\<close>\n      for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> L t *\\<^sub>C t", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> L t *\\<^sub>C t", "have \\<open>(\\<lambda> n. \\<langle> t, X n \\<rangle>) \\<longlonglongrightarrow> L t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>t, X n\\<rangle>) \\<longlonglongrightarrow> L t", "using r1  \\<open>\\<And> t. t\\<in>set canonical_basis \\<Longrightarrow> (\\<lambda> n. \\<langle> t, X n \\<rangle>) \\<longlonglongrightarrow> L t\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> set canonical_basis\n  ?t \\<in> set canonical_basis \\<Longrightarrow>\n  (\\<lambda>n. \\<langle>?t, X n\\<rangle>) \\<longlonglongrightarrow> L ?t\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>t, X n\\<rangle>) \\<longlonglongrightarrow> L t", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<langle>t, X n\\<rangle>) \\<longlonglongrightarrow> L t\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> L t *\\<^sub>C t", "define f where \\<open>f x = x *\\<^sub>C t\\<close> for x"], ["proof (state)\nthis:\n  f ?x = ?x *\\<^sub>C t\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> L t *\\<^sub>C t", "have \\<open>isCont f r\\<close>\n        for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont f r", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. x *\\<^sub>C t) r", "by (simp add: bounded_clinear_scaleC_left clinear_continuous_at)"], ["proof (state)\nthis:\n  isCont f ?r1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> L t *\\<^sub>C t", "hence \\<open>(\\<lambda> n. f \\<langle> t, X n \\<rangle>) \\<longlonglongrightarrow> f (L t)\\<close>"], ["proof (prove)\nusing this:\n  isCont f ?r1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f \\<langle>t, X n\\<rangle>)\n    \\<longlonglongrightarrow> f (L t)", "using \\<open>(\\<lambda>n. \\<langle>t, X n\\<rangle>) \\<longlonglongrightarrow> L t\\<close> isCont_tendsto_compose"], ["proof (prove)\nusing this:\n  isCont f ?r1\n  (\\<lambda>n. \\<langle>t, X n\\<rangle>) \\<longlonglongrightarrow> L t\n  \\<lbrakk>isCont ?g ?l; (?f \\<longlongrightarrow> ?l) ?F\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. ?g (?f x)) \\<longlongrightarrow> ?g ?l) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f \\<langle>t, X n\\<rangle>)\n    \\<longlonglongrightarrow> f (L t)", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>n. f \\<langle>t, X n\\<rangle>) \\<longlonglongrightarrow> f (L t)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> L t *\\<^sub>C t", "hence \\<open>(\\<lambda> n. \\<langle> t, X n \\<rangle> *\\<^sub>C t) \\<longlonglongrightarrow> L t *\\<^sub>C t\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. f \\<langle>t, X n\\<rangle>) \\<longlonglongrightarrow> f (L t)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> L t *\\<^sub>C t", "unfolding f_def"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n  \\<longlonglongrightarrow> L t *\\<^sub>C t\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> L t *\\<^sub>C t", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n  \\<longlonglongrightarrow> L t *\\<^sub>C t\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> L t *\\<^sub>C t", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n  \\<longlonglongrightarrow> L t *\\<^sub>C t\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> L t *\\<^sub>C t", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n  \\<longlonglongrightarrow> L t *\\<^sub>C t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t1 \\<in> set canonical_basis \\<Longrightarrow>\n  (\\<lambda>n. \\<langle>?t1, X n\\<rangle> *\\<^sub>C ?t1)\n  \\<longlonglongrightarrow> L ?t1 *\\<^sub>C ?t1\n\ngoal (1 subgoal):\n 1. convergent X", "hence \\<open>(\\<lambda> n. (\\<Sum>t\\<in>set canonical_basis. \\<langle> t, X n \\<rangle> *\\<^sub>C t))\n    \\<longlonglongrightarrow>  (\\<Sum>t\\<in>set canonical_basis. L t *\\<^sub>C t)\\<close>"], ["proof (prove)\nusing this:\n  ?t1 \\<in> set canonical_basis \\<Longrightarrow>\n  (\\<lambda>n. \\<langle>?t1, X n\\<rangle> *\\<^sub>C ?t1)\n  \\<longlonglongrightarrow> L ?t1 *\\<^sub>C ?t1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        \\<Sum>t\\<in>set canonical_basis.\n          \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> (\\<Sum>t\\<in>set canonical_basis.\n                                 L t *\\<^sub>C t)", "using \\<open>finite (set canonical_basis)\\<close>\n        tendsto_sum[where I = \"set canonical_basis\" and f = \"\\<lambda> t. \\<lambda> n. \\<langle>t, X n\\<rangle> *\\<^sub>C t\"\n          and a = \"\\<lambda> t. L t *\\<^sub>C t\"]"], ["proof (prove)\nusing this:\n  ?t1 \\<in> set canonical_basis \\<Longrightarrow>\n  (\\<lambda>n. \\<langle>?t1, X n\\<rangle> *\\<^sub>C ?t1)\n  \\<longlonglongrightarrow> L ?t1 *\\<^sub>C ?t1\n  finite (set canonical_basis)\n  (\\<And>i.\n      i \\<in> set canonical_basis \\<Longrightarrow>\n      ((\\<lambda>n.\n           \\<langle>i, X n\\<rangle> *\\<^sub>C i) \\<longlongrightarrow>\n       L i *\\<^sub>C i)\n       ?F) \\<Longrightarrow>\n  ((\\<lambda>x.\n       \\<Sum>i\\<in>set canonical_basis.\n         \\<langle>i, X x\\<rangle> *\\<^sub>C i) \\<longlongrightarrow>\n   (\\<Sum>i\\<in>set canonical_basis. L i *\\<^sub>C i))\n   ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        \\<Sum>t\\<in>set canonical_basis.\n          \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> (\\<Sum>t\\<in>set canonical_basis.\n                                 L t *\\<^sub>C t)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      \\<Sum>t\\<in>set canonical_basis. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n  \\<longlonglongrightarrow> (\\<Sum>t\\<in>set canonical_basis.\n                               L t *\\<^sub>C t)\n\ngoal (1 subgoal):\n 1. convergent X", "hence x2: \\<open>(\\<lambda> n. (\\<Sum>t\\<in>set canonical_basis. \\<langle> t, X n \\<rangle> *\\<^sub>C t)) \\<longlonglongrightarrow> l\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      \\<Sum>t\\<in>set canonical_basis. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n  \\<longlonglongrightarrow> (\\<Sum>t\\<in>set canonical_basis.\n                               L t *\\<^sub>C t)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        \\<Sum>t\\<in>set canonical_basis.\n          \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> l", "using l_def"], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      \\<Sum>t\\<in>set canonical_basis. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n  \\<longlonglongrightarrow> (\\<Sum>t\\<in>set canonical_basis.\n                               L t *\\<^sub>C t)\n  l = (\\<Sum>t\\<in>set canonical_basis. L t *\\<^sub>C t)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        \\<Sum>t\\<in>set canonical_basis.\n          \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n    \\<longlonglongrightarrow> l", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      \\<Sum>t\\<in>set canonical_basis. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n  \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. convergent X", "have \\<open>X \\<longlonglongrightarrow> l\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<longlonglongrightarrow> l", "using x1 x2"], ["proof (prove)\nusing this:\n  X ?n1 =\n  (\\<Sum>t\\<in>set canonical_basis. \\<langle>t, X ?n1\\<rangle> *\\<^sub>C t)\n  (\\<lambda>n.\n      \\<Sum>t\\<in>set canonical_basis. \\<langle>t, X n\\<rangle> *\\<^sub>C t)\n  \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. X \\<longlonglongrightarrow> l", "by simp"], ["proof (state)\nthis:\n  X \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. convergent X", "thus ?thesis"], ["proof (prove)\nusing this:\n  X \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. convergent X", "unfolding convergent_def"], ["proof (prove)\nusing this:\n  X \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. \\<exists>L. X \\<longlonglongrightarrow> L", "by blast"], ["proof (state)\nthis:\n  convergent X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cauchy ?X \\<Longrightarrow> convergent ?X\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Conjugate space\\<close>"], ["", "instantiation conjugate_space :: (complex_inner) complex_inner begin"], ["", "lift_definition cinner_conjugate_space :: \"'a conjugate_space \\<Rightarrow> 'a conjugate_space \\<Rightarrow> complex\" is\n  \\<open>\\<lambda>x y. cinner y x\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a conjugate_space, complex_inner_class)", "apply (intro_classes; transfer)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x y. \\<langle>y, x\\<rangle> = cnj \\<langle>x, y\\<rangle>\n 2. \\<And>x y z.\n       \\<langle>z, x + y\\<rangle> =\n       \\<langle>z, x\\<rangle> + \\<langle>z, y\\<rangle>\n 3. \\<And>r x y.\n       \\<langle>y, cnj r *\\<^sub>C x\\<rangle> =\n       cnj r * \\<langle>y, x\\<rangle>\n 4. \\<And>x. 0 \\<le> \\<langle>x, x\\<rangle>\n 5. \\<And>x. is_orthogonal x x = (x = (0::'a))\n 6. \\<And>x. norm x = sqrt (cmod \\<langle>x, x\\<rangle>)", "apply (simp_all add: )"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<langle>z, x + y\\<rangle> =\n       \\<langle>z, x\\<rangle> + \\<langle>z, y\\<rangle>\n 2. \\<And>x. 0 \\<le> Re \\<langle>x, x\\<rangle>\n 3. \\<And>x. norm x = sqrt (cmod \\<langle>x, x\\<rangle>)", "apply (simp add: cinner_add_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<le> Re \\<langle>x, x\\<rangle>\n 2. \\<And>x. norm x = sqrt (cmod \\<langle>x, x\\<rangle>)", "using cinner_ge_zero norm_eq_sqrt_cinner"], ["proof (prove)\nusing this:\n  0 \\<le> \\<langle>?x, ?x\\<rangle>\n  norm ?x = sqrt (cmod \\<langle>?x, ?x\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<le> Re \\<langle>x, x\\<rangle>\n 2. \\<And>x. norm x = sqrt (cmod \\<langle>x, x\\<rangle>)", "by auto"], ["", "end"], ["", "instance conjugate_space :: (chilbert_space) chilbert_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a conjugate_space, chilbert_space_class)", ".."], ["", "end"]]}