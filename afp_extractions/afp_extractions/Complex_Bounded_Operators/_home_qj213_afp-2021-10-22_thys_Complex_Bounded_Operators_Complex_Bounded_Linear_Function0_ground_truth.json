{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators/Complex_Bounded_Linear_Function0.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators", "problem_names": ["lemma conorm_componentwise:\n  assumes \"bounded_clinear f\"\n  shows \"onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))\"", "lemmas conorm_componentwise_le = order_trans[OF conorm_componentwise]", "lemma onorm_cinner_left:\n  assumes \"bounded_linear r\"\n  shows \"onorm (\\<lambda>x. r x \\<bullet>\\<^sub>C f) \\<le> onorm r * norm f\"", "lemma onorm_cinner_right:\n  assumes \"bounded_linear r\"\n  shows \"onorm (\\<lambda>x. f \\<bullet>\\<^sub>C r x) \\<le> norm f * onorm r\"", "lemmas [bounded_linear_intros] =\n  bounded_clinear_zero\n  bounded_clinear_add\n  bounded_clinear_const_mult\n  bounded_clinear_mult_const\n  bounded_clinear_scaleC_const\n  bounded_clinear_const_scaleC\n  bounded_clinear_const_scaleR\n  bounded_clinear_ident\n  bounded_clinear_sum\n  (* bounded_clinear_Pair *) (* The Product_Vector theory does not instantiate Pair for complex vector spaces *)\n  bounded_clinear_sub\n  (* bounded_clinear_fst_comp *) (* The Product_Vector theory does not instantiate Pair for complex vector spaces *)\n  (* bounded_clinear_snd_comp *) (* The Product_Vector theory does not instantiate Pair for complex vector spaces *)\n  bounded_antilinear_cinner_left_comp\n  bounded_clinear_cinner_right_comp", "lemma bounded_clinear_cblinfun_apply[bounded_linear_intros]:\n  \"bounded_clinear g \\<Longrightarrow> bounded_clinear (\\<lambda>x. cblinfun_apply f (g x))\"", "lemma cblinfun_eqI: \"(\\<And>i. cblinfun_apply x i = cblinfun_apply y i) \\<Longrightarrow> x = y\"", "lemma bounded_clinear_CBlinfun_apply: \"bounded_clinear f \\<Longrightarrow> cblinfun_apply (CBlinfun f) = f\"", "lemma norm_cblinfun_eqI:\n  assumes \"n \\<le> norm (cblinfun_apply f x) / norm x\"\n  assumes \"\\<And>x. norm (cblinfun_apply f x) \\<le> n * norm x\"\n  assumes \"0 \\<le> n\"\n  shows \"norm f = n\"", "lemma norm_cblinfun: \"norm (cblinfun_apply f x) \\<le> norm f * norm x\"", "lemma norm_cblinfun_bound: \"0 \\<le> b \\<Longrightarrow> (\\<And>x. norm (cblinfun_apply f x) \\<le> b * norm x) \\<Longrightarrow> norm f \\<le> b\"", "lemma bounded_cbilinear_cblinfun_apply[bounded_cbilinear]: \"bounded_cbilinear cblinfun_apply\"", "lemmas bounded_clinear_apply_cblinfun[intro, simp] = cblinfun.bounded_clinear_left", "lemmas [cbilinear_simps] =\n  add_left\n  add_right\n  diff_left\n  diff_right\n  minus_left\n  minus_right\n  scaleC_left\n  scaleC_right\n  zero_left\n  zero_right\n  sum_left\n  sum_right", "lemma norm_cblinfun_ceuclidean_le:\n  fixes a::\"'a::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\"\n  shows \"norm a \\<le> sum (\\<lambda>x. norm (a x)) CBasis\"", "lemma ctendsto_componentwise1:\n  fixes a::\"'a::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\"\n    and b::\"'c \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  assumes \"(\\<And>j. j \\<in> CBasis \\<Longrightarrow> ((\\<lambda>n. b n j) \\<longlongrightarrow> a j) F)\"\n  shows \"(b \\<longlongrightarrow> a) F\"", "lemma cblinfun_of_matrix_works:\n  fixes f::\"'a::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::ceuclidean_space\"\n  shows \"cblinfun_of_matrix (\\<lambda>i j. i \\<bullet>\\<^sub>C (f j)) = f\"", "lemma cblinfun_of_matrix_apply:\n  \"cblinfun_of_matrix a x = (\\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. ((j \\<bullet>\\<^sub>C x) * a i j) *\\<^sub>C i)\"", "lemma cblinfun_of_matrix_minus: \"cblinfun_of_matrix x - cblinfun_of_matrix y = cblinfun_of_matrix (x - y)\"", "lemma norm_cblinfun_of_matrix:\n  \"norm (cblinfun_of_matrix a) \\<le> (\\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. cmod (a i j))\"", "lemma tendsto_cblinfun_of_matrix:\n  assumes \"\\<And>i j. i \\<in> CBasis \\<Longrightarrow> j \\<in> CBasis \\<Longrightarrow> ((\\<lambda>n. b n i j) \\<longlongrightarrow> a i j) F\"\n  shows \"((\\<lambda>n. cblinfun_of_matrix (b n)) \\<longlongrightarrow> cblinfun_of_matrix a) F\"", "lemma ctendsto_componentwise:\n  fixes a::\"'a::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::ceuclidean_space\"\n    and b::\"'c \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  shows \"(\\<And>i j. i \\<in> CBasis \\<Longrightarrow> j \\<in> CBasis \\<Longrightarrow> ((\\<lambda>n. b n j \\<bullet>\\<^sub>C i) \\<longlongrightarrow> a j \\<bullet>\\<^sub>C i) F) \\<Longrightarrow> (b \\<longlongrightarrow> a) F\"", "lemma\n  continuous_cblinfun_componentwiseI:\n  fixes f:: \"'b::t2_space \\<Rightarrow> 'a::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::ceuclidean_space\"\n  assumes \"\\<And>i j. i \\<in> CBasis \\<Longrightarrow> j \\<in> CBasis \\<Longrightarrow> continuous F (\\<lambda>x. (f x) j \\<bullet>\\<^sub>C i)\"\n  shows \"continuous F f\"", "lemma\n  continuous_cblinfun_componentwiseI1:\n  fixes f:: \"'b::t2_space \\<Rightarrow> 'a::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_normed_vector\"\n  assumes \"\\<And>i. i \\<in> CBasis \\<Longrightarrow> continuous F (\\<lambda>x. f x i)\"\n  shows \"continuous F f\"", "lemma\n  continuous_on_cblinfun_componentwise:\n  fixes f:: \"'d::t2_space \\<Rightarrow> 'e::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'f::complex_normed_vector\"\n  assumes \"\\<And>i. i \\<in> CBasis \\<Longrightarrow> continuous_on s (\\<lambda>x. f x i)\"\n  shows \"continuous_on s f\"", "lemma bounded_antilinear_cblinfun_matrix: \"bounded_antilinear (\\<lambda>x. (x::_\\<Rightarrow>\\<^sub>C\\<^sub>L _) j \\<bullet>\\<^sub>C i)\"", "lemma continuous_cblinfun_matrix:\n  fixes f:: \"'b::t2_space \\<Rightarrow> 'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_inner\"\n  assumes \"continuous F f\"\n  shows \"continuous F (\\<lambda>x. (f x) j \\<bullet>\\<^sub>C i)\"", "lemma continuous_on_cblinfun_matrix:\n  fixes f::\"'a::t2_space \\<Rightarrow> 'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_inner\"\n  assumes \"continuous_on S f\"\n  shows \"continuous_on S (\\<lambda>x. (f x) j \\<bullet>\\<^sub>C i)\"", "lemma continuous_on_cblinfun_of_matrix[continuous_intros]:\n  assumes \"\\<And>i j. i \\<in> CBasis \\<Longrightarrow> j \\<in> CBasis \\<Longrightarrow> continuous_on S (\\<lambda>s. g s i j)\"\n  shows \"continuous_on S (\\<lambda>s. cblinfun_of_matrix (g s))\"", "lemma cblinfun_euclidean_eqI: \"(\\<And>i. i \\<in> CBasis \\<Longrightarrow> cblinfun_apply x i = cblinfun_apply y i) \\<Longrightarrow> x = y\"", "lemma CBlinfun_eq_matrix: \"bounded_clinear f \\<Longrightarrow> CBlinfun f = cblinfun_of_matrix (\\<lambda>i j. i \\<bullet>\\<^sub>C f j)\"", "lemma transfer_bounded_cbilinear_bounded_clinearI:\n  assumes \"g = (\\<lambda>i x. (cblinfun_apply (f i) x))\"\n  shows \"bounded_cbilinear g = bounded_clinear f\"", "lemma transfer_bounded_cbilinear_bounded_clinear[transfer_rule]:\n  \"(rel_fun (rel_fun (=) (pcr_cblinfun (=) (=))) (=)) bounded_cbilinear bounded_clinear\"", "lemma transfer_bounded_sesquilinear_bounded_antilinearI:\n  assumes \"g = (\\<lambda>i x. (cblinfun_apply (f i) x))\"\n  shows \"bounded_sesquilinear g = bounded_antilinear f\"", "lemma transfer_bounded_sesquilinear_bounded_antilinear[transfer_rule]:\n  \"(rel_fun (rel_fun (=) (pcr_cblinfun (=) (=))) (=)) bounded_sesquilinear bounded_antilinear\"", "lemma bounded_clinear_prod_left[bounded_clinear]: \"bounded_clinear prod_left\"", "lemma bounded_clinear_prod_right[bounded_clinear]: \"bounded_clinear prod_right\"", "lemmas cblinfun_id_cblinfun_apply[simp] = id_cblinfun.rep_eq", "lemma norm_cblinfun_id[simp]:\n  \"norm (id_cblinfun::'a::{complex_normed_vector, not_singleton} \\<Rightarrow>\\<^sub>C\\<^sub>L 'a) = 1\"", "lemma norm_blinfun_id_le:\n  \"norm (id_cblinfun::'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'a) \\<le> 1\"", "lemma cblinfun_apply_cblinfun_compose[simp]: \"(a o\\<^sub>C\\<^sub>L b) c = a (b c)\"", "lemma norm_cblinfun_compose:\n  \"norm (f o\\<^sub>C\\<^sub>L g) \\<le> norm f * norm g\"", "lemma bounded_cbilinear_cblinfun_compose[bounded_cbilinear]: \"bounded_cbilinear (o\\<^sub>C\\<^sub>L)\"", "lemma cblinfun_compose_zero[simp]:\n  \"blinfun_compose 0 = (\\<lambda>_. 0)\"\n  \"blinfun_compose x 0 = 0\"", "lemma cblinfun_bij2:\n  fixes f::\"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::ceuclidean_space\"\n  assumes \"f o\\<^sub>C\\<^sub>L g = id_cblinfun\"\n  shows \"bij (cblinfun_apply g)\"", "lemma cblinfun_bij1:\n  fixes f::\"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::ceuclidean_space\"\n  assumes \"f o\\<^sub>C\\<^sub>L g = id_cblinfun\"\n  shows \"bij (cblinfun_apply f)\"", "lemma bounded_antilinear_cblinfun_cinner_right[bounded_antilinear]: \"bounded_antilinear cblinfun_cinner_right\"", "lemma bounded_clinear_cblinfun_scaleC_right[bounded_clinear]: \"bounded_clinear cblinfun_scaleC_right\"", "lemmas [simp] = cblinfun_scaleC_left.rep_eq", "lemma bounded_clinear_cblinfun_scaleC_left[bounded_clinear]: \"bounded_clinear cblinfun_scaleC_left\"", "lemma bounded_clinear_cblinfun_mult_right[bounded_clinear]: \"bounded_clinear cblinfun_mult_right\"", "lemmas [simp] = cblinfun_mult_left.rep_eq", "lemma bounded_clinear_cblinfun_mult_left[bounded_clinear]: \"bounded_clinear cblinfun_mult_left\"", "lemmas bounded_clinear_function_uniform_limit_intros[uniform_limit_intros] =\n  bounded_clinear.uniform_limit[OF bounded_clinear_apply_cblinfun]\n  bounded_clinear.uniform_limit[OF bounded_clinear_cblinfun_apply]\n  bounded_antilinear.uniform_limit[OF bounded_antilinear_cblinfun_matrix]", "lemma cstrong_operator_topology_topspace:\n  \"topspace cstrong_operator_topology = UNIV\"", "lemma cstrong_operator_topology_basis:\n  fixes f::\"('a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L'b::complex_normed_vector)\" and U::\"'i \\<Rightarrow> 'b set\" and x::\"'i \\<Rightarrow> 'a\"\n  assumes \"finite I\" \"\\<And>i. i \\<in> I \\<Longrightarrow> open (U i)\"\n  shows \"openin cstrong_operator_topology {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i}\"", "lemma cstrong_operator_topology_continuous_evaluation:\n  \"continuous_map cstrong_operator_topology euclidean (\\<lambda>f. cblinfun_apply f x)\"", "lemma continuous_on_cstrong_operator_topo_iff_coordinatewise:\n  \"continuous_map T cstrong_operator_topology f\n    \\<longleftrightarrow> (\\<forall>x. continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x))\"", "lemma cstrong_operator_topology_weaker_than_euclidean:\n  \"continuous_map euclidean cstrong_operator_topology (\\<lambda>f. f)\""], "translations": [["", "lemma conorm_componentwise:\n  assumes \"bounded_clinear f\"\n  shows \"onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "fix i::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "assume \"i \\<in> CBasis\""], ["proof (state)\nthis:\n  i \\<in> CBasis\n\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "hence \"onorm (\\<lambda>x. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) \\<le> onorm (\\<lambda>x. (i \\<bullet>\\<^sub>C x)) * norm (f i)\""], ["proof (prove)\nusing this:\n  i \\<in> CBasis\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i)\n    \\<le> onorm ((\\<bullet>\\<^sub>C) i) * norm (f i)", "by (auto intro!: onorm_scaleC_left_lemma bounded_clinear_cinner_right)"], ["proof (state)\nthis:\n  onorm (\\<lambda>x. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i)\n  \\<le> onorm ((\\<bullet>\\<^sub>C) i) * norm (f i)\n\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "also"], ["proof (state)\nthis:\n  onorm (\\<lambda>x. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i)\n  \\<le> onorm ((\\<bullet>\\<^sub>C) i) * norm (f i)\n\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "have \"\\<dots> \\<le>  norm i * norm (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm ((\\<bullet>\\<^sub>C) i) * norm (f i) \\<le> norm i * norm (f i)", "apply (rule mult_right_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. onorm ((\\<bullet>\\<^sub>C) i) \\<le> norm i\n 2. 0 \\<le> norm (f i)", "apply (simp add: complex_inner_class.Cauchy_Schwarz_ineq2 onorm_bound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> norm (f i)", "by simp"], ["proof (state)\nthis:\n  onorm ((\\<bullet>\\<^sub>C) i) * norm (f i) \\<le> norm i * norm (f i)\n\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "finally"], ["proof (chain)\npicking this:\n  onorm (\\<lambda>x. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i)\n  \\<le> norm i * norm (f i)", "have \"onorm (\\<lambda>x. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) \\<le> norm (f i)\""], ["proof (prove)\nusing this:\n  onorm (\\<lambda>x. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i)\n  \\<le> norm i * norm (f i)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i)\n    \\<le> norm (f i)", "using \\<open>i \\<in> CBasis\\<close>"], ["proof (prove)\nusing this:\n  onorm (\\<lambda>x. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i)\n  \\<le> norm i * norm (f i)\n  i \\<in> CBasis\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i)\n    \\<le> norm (f i)", "by simp"], ["proof (state)\nthis:\n  onorm (\\<lambda>x. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) \\<le> norm (f i)\n\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "}"], ["proof (state)\nthis:\n  ?i2 \\<in> CBasis \\<Longrightarrow>\n  onorm (\\<lambda>x. (?i2 \\<bullet>\\<^sub>C x) *\\<^sub>C f ?i2)\n  \\<le> norm (f ?i2)\n\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "hence \"onorm (\\<lambda>x. \\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))\""], ["proof (prove)\nusing this:\n  ?i2 \\<in> CBasis \\<Longrightarrow>\n  onorm (\\<lambda>x. (?i2 \\<bullet>\\<^sub>C x) *\\<^sub>C f ?i2)\n  \\<le> norm (f ?i2)\n\ngoal (1 subgoal):\n 1. onorm\n     (\\<lambda>x. \\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i)\n    \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "by (auto intro!: order_trans[OF onorm_sum_le] bounded_clinear_scaleC_const\n        sum_mono bounded_clinear_cinner_right bounded_clinear.bounded_linear)"], ["proof (state)\nthis:\n  onorm\n   (\\<lambda>x. \\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i)\n  \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))\n\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "also"], ["proof (state)\nthis:\n  onorm\n   (\\<lambda>x. \\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i)\n  \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))\n\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "have \"(\\<lambda>x. \\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) = (\\<lambda>x. f (\\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) =\n    (\\<lambda>x.\n        f (\\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C i))", "by (simp add: clinear.scaleC linear_sum bounded_clinear.clinear clinear.linear assms)"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) =\n  (\\<lambda>x. f (\\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C i))\n\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) =\n  (\\<lambda>x. f (\\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C i))\n\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "have \"\\<dots> = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        f (\\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C i)) =\n    f", "by (simp add: ceuclidean_representation)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      f (\\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C i)) =\n  f\n\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "finally"], ["proof (chain)\npicking this:\n  onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "show ?thesis"], ["proof (prove)\nusing this:\n  onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))\n\ngoal (1 subgoal):\n 1. onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))", "."], ["proof (state)\nthis:\n  onorm f \\<le> (\\<Sum>i\\<in>CBasis. norm (f i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas conorm_componentwise_le = order_trans[OF conorm_componentwise]"], ["", "subsection\\<^marker>\\<open>tag unimportant\\<close> \\<open>Intro rules for \\<^term>\\<open>bounded_linear\\<close>\\<close>"], ["", "(* We share the same attribute [bounded_linear_intros] with Bounded_Linear_Function *)\n(* named_theorems bounded_linear_intros *)"], ["", "lemma onorm_cinner_left:\n  assumes \"bounded_linear r\"\n  shows \"onorm (\\<lambda>x. r x \\<bullet>\\<^sub>C f) \\<le> onorm r * norm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r x \\<bullet>\\<^sub>C f) \\<le> onorm r * norm f", "proof (rule onorm_bound)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> onorm r * norm f\n 2. \\<And>x. cmod (r x \\<bullet>\\<^sub>C f) \\<le> onorm r * norm f * norm x", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> onorm r * norm f\n 2. \\<And>x. cmod (r x \\<bullet>\\<^sub>C f) \\<le> onorm r * norm f * norm x", "have \"norm (r x \\<bullet>\\<^sub>C f) \\<le> norm (r x) * norm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (r x \\<bullet>\\<^sub>C f) \\<le> norm (r x) * norm f", "by (simp add: Cauchy_Schwarz_ineq2)"], ["proof (state)\nthis:\n  cmod (r x \\<bullet>\\<^sub>C f) \\<le> norm (r x) * norm f\n\ngoal (2 subgoals):\n 1. 0 \\<le> onorm r * norm f\n 2. \\<And>x. cmod (r x \\<bullet>\\<^sub>C f) \\<le> onorm r * norm f * norm x", "also"], ["proof (state)\nthis:\n  cmod (r x \\<bullet>\\<^sub>C f) \\<le> norm (r x) * norm f\n\ngoal (2 subgoals):\n 1. 0 \\<le> onorm r * norm f\n 2. \\<And>x. cmod (r x \\<bullet>\\<^sub>C f) \\<le> onorm r * norm f * norm x", "have \"\\<dots> \\<le> onorm r * norm x * norm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (r x) * norm f \\<le> onorm r * norm x * norm f", "by (simp add: assms mult.commute mult_left_mono onorm)"], ["proof (state)\nthis:\n  norm (r x) * norm f \\<le> onorm r * norm x * norm f\n\ngoal (2 subgoals):\n 1. 0 \\<le> onorm r * norm f\n 2. \\<And>x. cmod (r x \\<bullet>\\<^sub>C f) \\<le> onorm r * norm f * norm x", "finally"], ["proof (chain)\npicking this:\n  cmod (r x \\<bullet>\\<^sub>C f) \\<le> onorm r * norm x * norm f", "show \"norm (r x \\<bullet>\\<^sub>C f) \\<le> onorm r * norm f * norm x\""], ["proof (prove)\nusing this:\n  cmod (r x \\<bullet>\\<^sub>C f) \\<le> onorm r * norm x * norm f\n\ngoal (1 subgoal):\n 1. cmod (r x \\<bullet>\\<^sub>C f) \\<le> onorm r * norm f * norm x", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  cmod (r x \\<bullet>\\<^sub>C f) \\<le> onorm r * norm f * norm x\n\ngoal (1 subgoal):\n 1. 0 \\<le> onorm r * norm f", "qed (intro mult_nonneg_nonneg norm_ge_zero onorm_pos_le assms)"], ["", "lemma onorm_cinner_right:\n  assumes \"bounded_linear r\"\n  shows \"onorm (\\<lambda>x. f \\<bullet>\\<^sub>C r x) \\<le> norm f * onorm r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. f \\<bullet>\\<^sub>C r x) \\<le> norm f * onorm r", "proof (rule onorm_bound)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> norm f * onorm r\n 2. \\<And>x. cmod (f \\<bullet>\\<^sub>C r x) \\<le> norm f * onorm r * norm x", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> norm f * onorm r\n 2. \\<And>x. cmod (f \\<bullet>\\<^sub>C r x) \\<le> norm f * onorm r * norm x", "have \"norm (f \\<bullet>\\<^sub>C r x) \\<le> norm f * norm (r x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (f \\<bullet>\\<^sub>C r x) \\<le> norm f * norm (r x)", "by (simp add: Cauchy_Schwarz_ineq2)"], ["proof (state)\nthis:\n  cmod (f \\<bullet>\\<^sub>C r x) \\<le> norm f * norm (r x)\n\ngoal (2 subgoals):\n 1. 0 \\<le> norm f * onorm r\n 2. \\<And>x. cmod (f \\<bullet>\\<^sub>C r x) \\<le> norm f * onorm r * norm x", "also"], ["proof (state)\nthis:\n  cmod (f \\<bullet>\\<^sub>C r x) \\<le> norm f * norm (r x)\n\ngoal (2 subgoals):\n 1. 0 \\<le> norm f * onorm r\n 2. \\<And>x. cmod (f \\<bullet>\\<^sub>C r x) \\<le> norm f * onorm r * norm x", "have \"\\<dots> \\<le> onorm r * norm x * norm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm f * norm (r x) \\<le> onorm r * norm x * norm f", "by (simp add: assms mult.commute mult_left_mono onorm)"], ["proof (state)\nthis:\n  norm f * norm (r x) \\<le> onorm r * norm x * norm f\n\ngoal (2 subgoals):\n 1. 0 \\<le> norm f * onorm r\n 2. \\<And>x. cmod (f \\<bullet>\\<^sub>C r x) \\<le> norm f * onorm r * norm x", "finally"], ["proof (chain)\npicking this:\n  cmod (f \\<bullet>\\<^sub>C r x) \\<le> onorm r * norm x * norm f", "show \"norm (f \\<bullet>\\<^sub>C r x) \\<le> norm f * onorm r * norm x\""], ["proof (prove)\nusing this:\n  cmod (f \\<bullet>\\<^sub>C r x) \\<le> onorm r * norm x * norm f\n\ngoal (1 subgoal):\n 1. cmod (f \\<bullet>\\<^sub>C r x) \\<le> norm f * onorm r * norm x", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  cmod (f \\<bullet>\\<^sub>C r x) \\<le> norm f * onorm r * norm x\n\ngoal (1 subgoal):\n 1. 0 \\<le> norm f * onorm r", "qed (intro mult_nonneg_nonneg norm_ge_zero onorm_pos_le assms)"], ["", "lemmas [bounded_linear_intros] =\n  bounded_clinear_zero\n  bounded_clinear_add\n  bounded_clinear_const_mult\n  bounded_clinear_mult_const\n  bounded_clinear_scaleC_const\n  bounded_clinear_const_scaleC\n  bounded_clinear_const_scaleR\n  bounded_clinear_ident\n  bounded_clinear_sum\n  (* bounded_clinear_Pair *) (* The Product_Vector theory does not instantiate Pair for complex vector spaces *)\n  bounded_clinear_sub\n  (* bounded_clinear_fst_comp *) (* The Product_Vector theory does not instantiate Pair for complex vector spaces *)\n  (* bounded_clinear_snd_comp *) (* The Product_Vector theory does not instantiate Pair for complex vector spaces *)\n  bounded_antilinear_cinner_left_comp\n  bounded_clinear_cinner_right_comp"], ["", "subsection\\<^marker>\\<open>tag unimportant\\<close> \\<open>declaration of derivative/continuous/tendsto introduction rules for bounded linear functions\\<close>"], ["", "attribute_setup bounded_clinear =\n  \\<open>let val bounded_linear = Attrib.attribute \\<^context> (the_single @{attributes [bounded_linear]}) in\n   Scan.succeed (Thm.declaration_attribute (fn thm =>\n    Thm.attribute_declaration bounded_linear (thm RS @{thm bounded_clinear.bounded_linear}) o\n    fold (fn (r, s) => Named_Theorems.add_thm s (thm RS r))\n      [\n        (* Not present in Bounded_Linear_Function *)\n        (@{thm bounded_clinear_compose}, \\<^named_theorems>\\<open>bounded_linear_intros\\<close>),\n        (@{thm bounded_clinear_o_bounded_antilinear[unfolded o_def]}, \\<^named_theorems>\\<open>bounded_linear_intros\\<close>)\n      ]))\n  end\\<close>"], ["", "(* Analogue to [bounded_clinear], not present in Bounded_Linear_Function *)"], ["", "attribute_setup bounded_antilinear =\n  \\<open>let val bounded_linear = Attrib.attribute \\<^context> (the_single @{attributes [bounded_linear]}) in\n   Scan.succeed (Thm.declaration_attribute (fn thm =>\n    Thm.attribute_declaration bounded_linear (thm RS @{thm bounded_antilinear.bounded_linear}) o\n    fold (fn (r, s) => Named_Theorems.add_thm s (thm RS r))\n      [\n        (* Not present in Bounded_Linear_Function *)\n        (@{thm bounded_antilinear_o_bounded_clinear[unfolded o_def]}, \\<^named_theorems>\\<open>bounded_linear_intros\\<close>),\n        (@{thm bounded_antilinear_o_bounded_antilinear[unfolded o_def]}, \\<^named_theorems>\\<open>bounded_linear_intros\\<close>)\n      ]))\n  end\\<close>"], ["", "attribute_setup bounded_cbilinear =\n  \\<open>let val bounded_bilinear = Attrib.attribute \\<^context> (the_single @{attributes [bounded_bilinear]}) in\n   Scan.succeed (Thm.declaration_attribute (fn thm =>\n    Thm.attribute_declaration bounded_bilinear (thm RS @{thm bounded_cbilinear.bounded_bilinear}) o\n    fold (fn (r, s) => Named_Theorems.add_thm s (thm RS r))\n      [\n        (@{thm bounded_clinear_compose[OF bounded_cbilinear.bounded_clinear_left]},\n          \\<^named_theorems>\\<open>bounded_linear_intros\\<close>),\n        (@{thm bounded_clinear_compose[OF bounded_cbilinear.bounded_clinear_right]},\n          \\<^named_theorems>\\<open>bounded_linear_intros\\<close>),\n        (@{thm bounded_clinear_o_bounded_antilinear[unfolded o_def, OF bounded_cbilinear.bounded_clinear_left]},\n          \\<^named_theorems>\\<open>bounded_linear_intros\\<close>),\n        (@{thm bounded_clinear_o_bounded_antilinear[unfolded o_def, OF bounded_cbilinear.bounded_clinear_right]},\n          \\<^named_theorems>\\<open>bounded_linear_intros\\<close>)\n      ]))\n  end\\<close>"], ["", "(* Analogue to [bounded_sesquilinear], not present in Bounded_Linear_Function *)"], ["", "attribute_setup bounded_sesquilinear =\n  \\<open>let val bounded_bilinear = Attrib.attribute \\<^context> (the_single @{attributes [bounded_bilinear]}) in\n   Scan.succeed (Thm.declaration_attribute (fn thm =>\n    Thm.attribute_declaration bounded_bilinear (thm RS @{thm bounded_sesquilinear.bounded_bilinear}) o\n    fold (fn (r, s) => Named_Theorems.add_thm s (thm RS r))\n      [\n        (@{thm bounded_antilinear_o_bounded_clinear[unfolded o_def, OF bounded_sesquilinear.bounded_antilinear_left]},\n          \\<^named_theorems>\\<open>bounded_linear_intros\\<close>),\n        (@{thm bounded_clinear_compose[OF bounded_sesquilinear.bounded_clinear_right]},\n          \\<^named_theorems>\\<open>bounded_linear_intros\\<close>),\n        (@{thm bounded_antilinear_o_bounded_antilinear[unfolded o_def, OF bounded_sesquilinear.bounded_antilinear_left]},\n          \\<^named_theorems>\\<open>bounded_linear_intros\\<close>),\n        (@{thm bounded_clinear_o_bounded_antilinear[unfolded o_def, OF bounded_sesquilinear.bounded_clinear_right]},\n          \\<^named_theorems>\\<open>bounded_linear_intros\\<close>)\n      ]))\n  end\\<close>"], ["", "subsection \\<open>Type of complex bounded linear functions\\<close>"], ["", "typedef\\<^marker>\\<open>tag important\\<close> (overloaded) ('a, 'b) cblinfun (\"(_ \\<Rightarrow>\\<^sub>C\\<^sub>L /_)\" [22, 21] 21) =\n  \"{f::'a::complex_normed_vector\\<Rightarrow>'b::complex_normed_vector. bounded_clinear f}\"\n  morphisms cblinfun_apply CBlinfun"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {f. bounded_clinear f}", "by (blast intro: bounded_linear_intros)"], ["", "declare [[coercion\n      \"cblinfun_apply :: ('a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L'b::complex_normed_vector) \\<Rightarrow> 'a \\<Rightarrow> 'b\"]]"], ["", "lemma bounded_clinear_cblinfun_apply[bounded_linear_intros]:\n  \"bounded_clinear g \\<Longrightarrow> bounded_clinear (\\<lambda>x. cblinfun_apply f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear g \\<Longrightarrow>\n    bounded_clinear (\\<lambda>x. cblinfun_apply f (g x))", "by (metis cblinfun_apply mem_Collect_eq bounded_clinear_compose)"], ["", "setup_lifting type_definition_cblinfun"], ["", "lemma cblinfun_eqI: \"(\\<And>i. cblinfun_apply x i = cblinfun_apply y i) \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. cblinfun_apply x i = cblinfun_apply y i) \\<Longrightarrow>\n    x = y", "by transfer auto"], ["", "lemma bounded_clinear_CBlinfun_apply: \"bounded_clinear f \\<Longrightarrow> cblinfun_apply (CBlinfun f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear f \\<Longrightarrow> cblinfun_apply (CBlinfun f) = f", "by (auto simp: CBlinfun_inverse)"], ["", "subsection \\<open>Type class instantiations\\<close>"], ["", "instantiation cblinfun :: (complex_normed_vector, complex_normed_vector) complex_normed_vector\nbegin"], ["", "lift_definition\\<^marker>\\<open>tag important\\<close> norm_cblinfun :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> real\" is onorm"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition minus_cblinfun :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  is \"\\<lambda>f g x. f x - g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>bounded_clinear fun1; bounded_clinear fun2\\<rbrakk>\n       \\<Longrightarrow> bounded_clinear (\\<lambda>x. fun1 x - fun2 x)", "by (rule bounded_clinear_sub)"], ["", "definition dist_cblinfun :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> real\"\n  where \"dist_cblinfun a b = norm (a - b)\""], ["", "definition [code del]:\n  \"(uniformity :: (('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) \\<times> ('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b)) filter) = (INF e\\<in>{0 <..}. principal {(x, y). dist x y < e})\""], ["", "definition open_cblinfun :: \"('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) set \\<Rightarrow> bool\"\n  where [code del]: \"open_cblinfun S = (\\<forall>x\\<in>S. \\<forall>\\<^sub>F (x', y) in uniformity. x' = x \\<longrightarrow> y \\<in> S)\""], ["", "lift_definition uminus_cblinfun :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\" is \"\\<lambda>f x. - f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun.\n       bounded_clinear fun \\<Longrightarrow>\n       bounded_clinear (\\<lambda>x. - fun x)", "by (rule bounded_clinear_minus)"], ["", "lift_definition\\<^marker>\\<open>tag important\\<close> zero_cblinfun :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\" is \"\\<lambda>x. 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. 0::'b)", "by (rule bounded_clinear_zero)"], ["", "lift_definition\\<^marker>\\<open>tag important\\<close> plus_cblinfun :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  is \"\\<lambda>f g x. f x + g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>bounded_clinear fun1; bounded_clinear fun2\\<rbrakk>\n       \\<Longrightarrow> bounded_clinear (\\<lambda>x. fun1 x + fun2 x)", "by (metis bounded_clinear_add)"], ["", "lift_definition\\<^marker>\\<open>tag important\\<close> scaleC_cblinfun::\"complex \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\" is \"\\<lambda>r f x. r *\\<^sub>C f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>complex fun.\n       bounded_clinear fun \\<Longrightarrow>\n       bounded_clinear (\\<lambda>x. complex *\\<^sub>C fun x)", "by (metis bounded_clinear_compose bounded_clinear_scaleC_right)"], ["", "lift_definition\\<^marker>\\<open>tag important\\<close> scaleR_cblinfun::\"real \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\" is \"\\<lambda>r f x. r *\\<^sub>R f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real fun.\n       bounded_clinear fun \\<Longrightarrow>\n       bounded_clinear (\\<lambda>x. real *\\<^sub>R fun x)", "by (rule bounded_clinear_const_scaleR)"], ["", "definition sgn_cblinfun :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  where \"sgn_cblinfun x = scaleC (inverse (norm x)) x\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS\n     ('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b, complex_normed_vector_class)", "proof"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a b c. a + b + c = a + (b + c)\n 3. \\<And>a b. a + b = b + a\n 4. \\<And>a. 0 + a = a\n 5. \\<And>a. - a + a = 0\n 6. \\<And>a b. a - b = a + - b\n 7. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 8. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 9. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 10. \\<And>x. 1 *\\<^sub>C x = x\nA total of 22 subgoals...", "fix a b c :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L'b\" and r q :: real and s t :: complex"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a b c. a + b + c = a + (b + c)\n 3. \\<And>a b. a + b = b + a\n 4. \\<And>a. 0 + a = a\n 5. \\<And>a. - a + a = 0\n 6. \\<And>a b. a - b = a + - b\n 7. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 8. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 9. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 10. \\<And>x. 1 *\\<^sub>C x = x\nA total of 22 subgoals...", "show \\<open>a + b + c = a + (b + c)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>bounded_clinear a; bounded_clinear b;\n        bounded_clinear c\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x + b x + c x) =\n                         (\\<lambda>x. a x + (b x + c x))", "by auto"], ["proof (state)\nthis:\n  a + b + c = a + (b + c)\n\ngoal (21 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a\n 4. \\<And>a. - a + a = 0\n 5. \\<And>a b. a - b = a + - b\n 6. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 7. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 8. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 9. \\<And>x. 1 *\\<^sub>C x = x\n 10. \\<And>x y. dist x y = norm (x - y)\nA total of 21 subgoals...", "show \\<open>0 + a = a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + a = a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       bounded_clinear a \\<Longrightarrow> (\\<lambda>x. (0::'b) + a x) = a", "by auto"], ["proof (state)\nthis:\n  0 + a = a\n\ngoal (20 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. - a + a = 0\n 4. \\<And>a b. a - b = a + - b\n 5. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 6. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 7. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 8. \\<And>x. 1 *\\<^sub>C x = x\n 9. \\<And>x y. dist x y = norm (x - y)\n 10. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\nA total of 20 subgoals...", "show \\<open>a + b = b + a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = b + a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>bounded_clinear a; bounded_clinear b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x + b x) = (\\<lambda>x. b x + a x)", "by auto"], ["proof (state)\nthis:\n  a + b = b + a\n\ngoal (19 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a. - a + a = 0\n 3. \\<And>a b. a - b = a + - b\n 4. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 5. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 6. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 7. \\<And>x. 1 *\\<^sub>C x = x\n 8. \\<And>x y. dist x y = norm (x - y)\n 9. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 10. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\nA total of 19 subgoals...", "show \\<open>- a + a = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. - a + a = 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       bounded_clinear a \\<Longrightarrow>\n       (\\<lambda>x. - a x + a x) = (\\<lambda>x. 0::'b)", "by auto"], ["proof (state)\nthis:\n  - a + a = 0\n\ngoal (18 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a b. a - b = a + - b\n 3. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 4. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 5. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 6. \\<And>x. 1 *\\<^sub>C x = x\n 7. \\<And>x y. dist x y = norm (x - y)\n 8. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 9. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 10. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\nA total of 18 subgoals...", "show \\<open>a - b = a + - b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a - b = a + - b", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>bounded_clinear a; bounded_clinear b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x - b x) = (\\<lambda>x. a x + - b x)", "by auto"], ["proof (state)\nthis:\n  a - b = a + - b\n\ngoal (17 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 3. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 4. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 5. \\<And>x. 1 *\\<^sub>C x = x\n 6. \\<And>x y. dist x y = norm (x - y)\n 7. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 8. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 9. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 10. \\<And>x. 1 *\\<^sub>R x = x\nA total of 17 subgoals...", "show scaleR_scaleC: \\<open>((*\\<^sub>R) r::('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) \\<Rightarrow> _) = (*\\<^sub>C) (complex_of_real r)\\<close> for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)", "apply (rule ext, transfer fixing: r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       bounded_clinear x \\<Longrightarrow>\n       (\\<lambda>xa. r *\\<^sub>R x xa) =\n       (\\<lambda>xa. complex_of_real r *\\<^sub>C x xa)", "by (simp add: scaleR_scaleC)"], ["proof (state)\nthis:\n  (*\\<^sub>R) ?r = (*\\<^sub>C) (complex_of_real ?r)\n\ngoal (16 subgoals):\n 1. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 2. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 3. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 4. \\<And>x. 1 *\\<^sub>C x = x\n 5. \\<And>x y. dist x y = norm (x - y)\n 6. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 7. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 8. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 9. \\<And>x. 1 *\\<^sub>R x = x\n 10. \\<And>x. sgn x = inverse (norm x) *\\<^sub>R x\nA total of 16 subgoals...", "show \\<open>s *\\<^sub>C (b + c) = s *\\<^sub>C b + s *\\<^sub>C c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. s *\\<^sub>C (b + c) = s *\\<^sub>C b + s *\\<^sub>C c", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s b c.\n       \\<lbrakk>bounded_clinear b; bounded_clinear c\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. s *\\<^sub>C (b x + c x)) =\n                         (\\<lambda>x. s *\\<^sub>C b x + s *\\<^sub>C c x)", "by (simp add: scaleC_add_right)"], ["proof (state)\nthis:\n  s *\\<^sub>C (b + c) = s *\\<^sub>C b + s *\\<^sub>C c\n\ngoal (15 subgoals):\n 1. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 2. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 3. \\<And>x. 1 *\\<^sub>C x = x\n 4. \\<And>x y. dist x y = norm (x - y)\n 5. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 6. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 7. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 8. \\<And>x. 1 *\\<^sub>R x = x\n 9. \\<And>x. sgn x = inverse (norm x) *\\<^sub>R x\n 10. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\nA total of 15 subgoals...", "show \\<open>(s + t) *\\<^sub>C a = s *\\<^sub>C a + t *\\<^sub>C a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s + t) *\\<^sub>C a = s *\\<^sub>C a + t *\\<^sub>C a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t a.\n       bounded_clinear a \\<Longrightarrow>\n       (\\<lambda>x. (s + t) *\\<^sub>C a x) =\n       (\\<lambda>x. s *\\<^sub>C a x + t *\\<^sub>C a x)", "by (simp add: scaleC_left.add)"], ["proof (state)\nthis:\n  (s + t) *\\<^sub>C a = s *\\<^sub>C a + t *\\<^sub>C a\n\ngoal (14 subgoals):\n 1. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 2. \\<And>x. 1 *\\<^sub>C x = x\n 3. \\<And>x y. dist x y = norm (x - y)\n 4. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 5. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 6. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 7. \\<And>x. 1 *\\<^sub>R x = x\n 8. \\<And>x. sgn x = inverse (norm x) *\\<^sub>R x\n 9. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 10. \\<And>U.\n        open U =\n        (\\<forall>x\\<in>U.\n            \\<forall>\\<^sub>F (x', y) in uniformity.\n               x' = x \\<longrightarrow> y \\<in> U)\nA total of 14 subgoals...", "show \\<open>s *\\<^sub>C t *\\<^sub>C a = (s * t) *\\<^sub>C a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. s *\\<^sub>C t *\\<^sub>C a = (s * t) *\\<^sub>C a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t a.\n       bounded_clinear a \\<Longrightarrow>\n       (\\<lambda>x. s *\\<^sub>C t *\\<^sub>C a x) =\n       (\\<lambda>x. (s * t) *\\<^sub>C a x)", "by auto"], ["proof (state)\nthis:\n  s *\\<^sub>C t *\\<^sub>C a = (s * t) *\\<^sub>C a\n\ngoal (13 subgoals):\n 1. \\<And>x. 1 *\\<^sub>C x = x\n 2. \\<And>x y. dist x y = norm (x - y)\n 3. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 4. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 5. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 6. \\<And>x. 1 *\\<^sub>R x = x\n 7. \\<And>x. sgn x = inverse (norm x) *\\<^sub>R x\n 8. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 9. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 10. \\<And>x. (norm x = 0) = (x = 0)\nA total of 13 subgoals...", "show \\<open>1 *\\<^sub>C a = a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 *\\<^sub>C a = a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       bounded_clinear a \\<Longrightarrow> (\\<lambda>x. 1 *\\<^sub>C a x) = a", "by auto"], ["proof (state)\nthis:\n  1 *\\<^sub>C a = a\n\ngoal (12 subgoals):\n 1. \\<And>x y. dist x y = norm (x - y)\n 2. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 3. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 4. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 5. \\<And>x. 1 *\\<^sub>R x = x\n 6. \\<And>x. sgn x = inverse (norm x) *\\<^sub>R x\n 7. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 8. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 9. \\<And>x. (norm x = 0) = (x = 0)\n 10. \\<And>x y. norm (x + y) \\<le> norm x + norm y\nA total of 12 subgoals...", "show \\<open>dist a b = norm (a - b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist a b = norm (a - b)", "unfolding dist_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (a - b) = norm (a - b)", "by simp"], ["proof (state)\nthis:\n  dist a b = norm (a - b)\n\ngoal (11 subgoals):\n 1. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 2. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 3. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 4. \\<And>x. 1 *\\<^sub>R x = x\n 5. \\<And>x. sgn x = inverse (norm x) *\\<^sub>R x\n 6. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 7. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 8. \\<And>x. (norm x = 0) = (x = 0)\n 9. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 10. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\nA total of 11 subgoals...", "show \\<open>sgn a = (inverse (norm a)) *\\<^sub>R a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn a = inverse (norm a) *\\<^sub>R a", "unfolding sgn_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (inverse (norm a)) *\\<^sub>C a =\n    inverse (norm a) *\\<^sub>R a", "unfolding scaleR_scaleC"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (inverse (norm a)) *\\<^sub>C a =\n    complex_of_real (inverse (norm a)) *\\<^sub>C a", "by auto"], ["proof (state)\nthis:\n  sgn a = inverse (norm a) *\\<^sub>R a\n\ngoal (10 subgoals):\n 1. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 2. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 3. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 4. \\<And>x. 1 *\\<^sub>R x = x\n 5. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 6. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 7. \\<And>x. (norm x = 0) = (x = 0)\n 8. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 9. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 10. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \\<open>uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist (x::('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b)) y < e})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})", "by (simp add: uniformity_cblinfun_def)"], ["proof (state)\nthis:\n  uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n\ngoal (9 subgoals):\n 1. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 2. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 3. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 4. \\<And>x. 1 *\\<^sub>R x = x\n 5. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 6. \\<And>x. (norm x = 0) = (x = 0)\n 7. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 8. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 9. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \\<open>open U = (\\<forall>x\\<in>U. \\<forall>\\<^sub>F (x', y) in uniformity. (x'::('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b)) = x \\<longrightarrow> y \\<in> U)\\<close> for U"], ["proof (prove)\ngoal (1 subgoal):\n 1. open U =\n    (\\<forall>x\\<in>U.\n        \\<forall>\\<^sub>F (x', y) in uniformity.\n           x' = x \\<longrightarrow> y \\<in> U)", "by (simp add: open_cblinfun_def)"], ["proof (state)\nthis:\n  open ?U =\n  (\\<forall>x\\<in>?U.\n      \\<forall>\\<^sub>F (x', y) in uniformity.\n         x' = x \\<longrightarrow> y \\<in> ?U)\n\ngoal (8 subgoals):\n 1. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 2. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 3. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 4. \\<And>x. 1 *\\<^sub>R x = x\n 5. \\<And>x. (norm x = 0) = (x = 0)\n 6. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 7. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 8. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \\<open>(norm a = 0) = (a = 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm a = 0) = (a = 0)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       bounded_clinear a \\<Longrightarrow>\n       (onorm a = 0) = (a = (\\<lambda>x. 0::'b))", "using bounded_clinear.bounded_linear onorm_eq_0"], ["proof (prove)\nusing this:\n  bounded_clinear ?f \\<Longrightarrow> bounded_linear ?f\n  bounded_linear ?f \\<Longrightarrow>\n  (onorm ?f = 0) = (\\<forall>x. ?f x = (0::?'b))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       bounded_clinear a \\<Longrightarrow>\n       (onorm a = 0) = (a = (\\<lambda>x. 0::'b))", "by blast"], ["proof (state)\nthis:\n  (norm a = 0) = (a = 0)\n\ngoal (7 subgoals):\n 1. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 2. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 3. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 4. \\<And>x. 1 *\\<^sub>R x = x\n 5. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 6. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 7. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \\<open>norm (a + b) \\<le> norm a + norm b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (a + b) \\<le> norm a + norm b", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>bounded_clinear a; bounded_clinear b\\<rbrakk>\n       \\<Longrightarrow> onorm (\\<lambda>x. a x + b x)\n                         \\<le> onorm a + onorm b", "by (simp add: bounded_clinear.bounded_linear onorm_triangle)"], ["proof (state)\nthis:\n  norm (a + b) \\<le> norm a + norm b\n\ngoal (6 subgoals):\n 1. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 2. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 3. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 4. \\<And>x. 1 *\\<^sub>R x = x\n 5. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 6. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \\<open>norm (s *\\<^sub>C a) = cmod s * norm a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (s *\\<^sub>C a) = cmod s * norm a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a.\n       bounded_clinear a \\<Longrightarrow>\n       onorm (\\<lambda>x. s *\\<^sub>C a x) = cmod s * onorm a", "using onorm_scalarC"], ["proof (prove)\nusing this:\n  bounded_clinear ?f \\<Longrightarrow>\n  onorm (\\<lambda>x. ?r *\\<^sub>C ?f x) = cmod ?r * onorm ?f\n\ngoal (1 subgoal):\n 1. \\<And>s a.\n       bounded_clinear a \\<Longrightarrow>\n       onorm (\\<lambda>x. s *\\<^sub>C a x) = cmod s * onorm a", "by blast"], ["proof (state)\nthis:\n  norm (s *\\<^sub>C a) = cmod s * norm a\n\ngoal (5 subgoals):\n 1. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 2. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 3. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 4. \\<And>x. 1 *\\<^sub>R x = x\n 5. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x", "show \\<open>norm (r *\\<^sub>R a) = \\<bar>r\\<bar> * norm a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (r *\\<^sub>R a) = \\<bar>r\\<bar> * norm a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r a.\n       bounded_clinear a \\<Longrightarrow>\n       onorm (\\<lambda>x. r *\\<^sub>R a x) = \\<bar>r\\<bar> * onorm a", "using bounded_clinear.bounded_linear onorm_scaleR"], ["proof (prove)\nusing this:\n  bounded_clinear ?f \\<Longrightarrow> bounded_linear ?f\n  bounded_linear ?f \\<Longrightarrow>\n  onorm (\\<lambda>x. ?r *\\<^sub>R ?f x) = \\<bar>?r\\<bar> * onorm ?f\n\ngoal (1 subgoal):\n 1. \\<And>r a.\n       bounded_clinear a \\<Longrightarrow>\n       onorm (\\<lambda>x. r *\\<^sub>R a x) = \\<bar>r\\<bar> * onorm a", "by blast"], ["proof (state)\nthis:\n  norm (r *\\<^sub>R a) = \\<bar>r\\<bar> * norm a\n\ngoal (4 subgoals):\n 1. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 2. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 3. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 4. \\<And>x. 1 *\\<^sub>R x = x", "show \\<open>r *\\<^sub>R (a + b) = r *\\<^sub>R a +  r *\\<^sub>R b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>R (a + b) = r *\\<^sub>R a + r *\\<^sub>R b", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r a b.\n       \\<lbrakk>bounded_clinear a; bounded_clinear b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. r *\\<^sub>R (a x + b x)) =\n                         (\\<lambda>x. r *\\<^sub>R a x + r *\\<^sub>R b x)", "by (simp add: scaleR_add_right)"], ["proof (state)\nthis:\n  r *\\<^sub>R (a + b) = r *\\<^sub>R a + r *\\<^sub>R b\n\ngoal (3 subgoals):\n 1. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 2. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 3. \\<And>x. 1 *\\<^sub>R x = x", "show \\<open>(r + q) *\\<^sub>R a = r *\\<^sub>R a +  q *\\<^sub>R a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (r + q) *\\<^sub>R a = r *\\<^sub>R a + q *\\<^sub>R a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r q a.\n       bounded_clinear a \\<Longrightarrow>\n       (\\<lambda>x. (r + q) *\\<^sub>R a x) =\n       (\\<lambda>x. r *\\<^sub>R a x + q *\\<^sub>R a x)", "by (simp add: scaleR_add_left)"], ["proof (state)\nthis:\n  (r + q) *\\<^sub>R a = r *\\<^sub>R a + q *\\<^sub>R a\n\ngoal (2 subgoals):\n 1. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 2. \\<And>x. 1 *\\<^sub>R x = x", "show \\<open>r *\\<^sub>R q *\\<^sub>R a = (r * q) *\\<^sub>R a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>R q *\\<^sub>R a = (r * q) *\\<^sub>R a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r q a.\n       bounded_clinear a \\<Longrightarrow>\n       (\\<lambda>x. r *\\<^sub>R q *\\<^sub>R a x) =\n       (\\<lambda>x. (r * q) *\\<^sub>R a x)", "by auto"], ["proof (state)\nthis:\n  r *\\<^sub>R q *\\<^sub>R a = (r * q) *\\<^sub>R a\n\ngoal (1 subgoal):\n 1. \\<And>x. 1 *\\<^sub>R x = x", "show \\<open>1 *\\<^sub>R a = a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 *\\<^sub>R a = a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       bounded_clinear a \\<Longrightarrow> (\\<lambda>x. 1 *\\<^sub>R a x) = a", "by auto"], ["proof (state)\nthis:\n  1 *\\<^sub>R a = a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "declare uniformity_Abort[where 'a=\"('a :: complex_normed_vector) \\<Rightarrow>\\<^sub>C\\<^sub>L ('b :: complex_normed_vector)\", code]"], ["", "lemma norm_cblinfun_eqI:\n  assumes \"n \\<le> norm (cblinfun_apply f x) / norm x\"\n  assumes \"\\<And>x. norm (cblinfun_apply f x) \\<le> n * norm x\"\n  assumes \"0 \\<le> n\"\n  shows \"norm f = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm f = n", "by (auto simp: norm_cblinfun_def\n      intro!: antisym onorm_bound assms order_trans[OF _ le_onorm] bounded_clinear.bounded_linear\n      bounded_linear_intros)"], ["", "lemma norm_cblinfun: \"norm (cblinfun_apply f x) \\<le> norm f * norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (cblinfun_apply f x) \\<le> norm f * norm x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x.\n       bounded_clinear f \\<Longrightarrow> norm (f x) \\<le> onorm f * norm x", "by (simp add: bounded_clinear.bounded_linear onorm)"], ["", "lemma norm_cblinfun_bound: \"0 \\<le> b \\<Longrightarrow> (\\<And>x. norm (cblinfun_apply f x) \\<le> b * norm x) \\<Longrightarrow> norm f \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> b;\n     \\<And>x. norm (cblinfun_apply f x) \\<le> b * norm x\\<rbrakk>\n    \\<Longrightarrow> norm f \\<le> b", "by transfer (rule onorm_bound)"], ["", "lemma bounded_cbilinear_cblinfun_apply[bounded_cbilinear]: \"bounded_cbilinear cblinfun_apply\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_cbilinear cblinfun_apply", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b.\n       cblinfun_apply (a + a') b = cblinfun_apply a b + cblinfun_apply a' b\n 2. \\<And>a b b'.\n       cblinfun_apply a (b + b') = cblinfun_apply a b + cblinfun_apply a b'\n 3. \\<And>r a b.\n       cblinfun_apply (r *\\<^sub>C a) b = r *\\<^sub>C cblinfun_apply a b\n 4. \\<And>a r b.\n       cblinfun_apply a (r *\\<^sub>C b) = r *\\<^sub>C cblinfun_apply a b\n 5. \\<exists>K.\n       \\<forall>a b. norm (cblinfun_apply a b) \\<le> norm a * norm b * K", "fix f g::\"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\" and a b::'a and r::complex"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b.\n       cblinfun_apply (a + a') b = cblinfun_apply a b + cblinfun_apply a' b\n 2. \\<And>a b b'.\n       cblinfun_apply a (b + b') = cblinfun_apply a b + cblinfun_apply a b'\n 3. \\<And>r a b.\n       cblinfun_apply (r *\\<^sub>C a) b = r *\\<^sub>C cblinfun_apply a b\n 4. \\<And>a r b.\n       cblinfun_apply a (r *\\<^sub>C b) = r *\\<^sub>C cblinfun_apply a b\n 5. \\<exists>K.\n       \\<forall>a b. norm (cblinfun_apply a b) \\<le> norm a * norm b * K", "show \"(f + g) a = f a + g a\" \"(r *\\<^sub>C f) a = r *\\<^sub>C f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_apply (f + g) a = cblinfun_apply f a + cblinfun_apply g a &&&\n    cblinfun_apply (r *\\<^sub>C f) a = r *\\<^sub>C cblinfun_apply f a", "by (transfer, simp)+"], ["proof (state)\nthis:\n  cblinfun_apply (f + g) a = cblinfun_apply f a + cblinfun_apply g a\n  cblinfun_apply (r *\\<^sub>C f) a = r *\\<^sub>C cblinfun_apply f a\n\ngoal (3 subgoals):\n 1. \\<And>a b b'.\n       cblinfun_apply a (b + b') = cblinfun_apply a b + cblinfun_apply a b'\n 2. \\<And>a r b.\n       cblinfun_apply a (r *\\<^sub>C b) = r *\\<^sub>C cblinfun_apply a b\n 3. \\<exists>K.\n       \\<forall>a b. norm (cblinfun_apply a b) \\<le> norm a * norm b * K", "interpret bounded_clinear f for f::\"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (cblinfun_apply f)", "by (auto intro!: bounded_linear_intros)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b b'.\n       cblinfun_apply a (b + b') = cblinfun_apply a b + cblinfun_apply a b'\n 2. \\<And>a r b.\n       cblinfun_apply a (r *\\<^sub>C b) = r *\\<^sub>C cblinfun_apply a b\n 3. \\<exists>K.\n       \\<forall>a b. norm (cblinfun_apply a b) \\<le> norm a * norm b * K", "show \"f (a + b) = f a + f b\" \"f (r *\\<^sub>C a) = r *\\<^sub>C f a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_apply f (a + b) = cblinfun_apply f a + cblinfun_apply f b &&&\n    cblinfun_apply f (r *\\<^sub>C a) = r *\\<^sub>C cblinfun_apply f a", "by (simp_all add: add scaleC)"], ["proof (state)\nthis:\n  cblinfun_apply f (a + b) = cblinfun_apply f a + cblinfun_apply f b\n  cblinfun_apply f (r *\\<^sub>C a) = r *\\<^sub>C cblinfun_apply f a\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>a b. norm (cblinfun_apply a b) \\<le> norm a * norm b * K", "show \"\\<exists>K. \\<forall>a b. norm (cblinfun_apply a b) \\<le> norm a * norm b * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>a b. norm (cblinfun_apply a b) \\<le> norm a * norm b * K", "by (auto intro!: exI[where x=1] norm_cblinfun)"], ["proof (state)\nthis:\n  \\<exists>K.\n     \\<forall>a b. norm (cblinfun_apply a b) \\<le> norm a * norm b * K\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation cblinfun: bounded_cbilinear cblinfun_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_cbilinear cblinfun_apply", "by (rule bounded_cbilinear_cblinfun_apply)"], ["", "lemmas bounded_clinear_apply_cblinfun[intro, simp] = cblinfun.bounded_clinear_left"], ["", "declare cblinfun.zero_left [simp] cblinfun.zero_right [simp]"], ["", "context bounded_cbilinear\nbegin"], ["", "named_theorems cbilinear_simps"], ["", "lemmas [cbilinear_simps] =\n  add_left\n  add_right\n  diff_left\n  diff_right\n  minus_left\n  minus_right\n  scaleC_left\n  scaleC_right\n  zero_left\n  zero_right\n  sum_left\n  sum_right"], ["", "end"], ["", "instance cblinfun :: (complex_normed_vector, cbanach) cbanach"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b, cbanach_class)", "(* The proof is almost the same as for \\<open>instance blinfun :: (real_normed_vector, banach) banach\\<close> *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b, cbanach_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "fix X::\"nat \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "assume \"Cauchy X\""], ["proof (state)\nthis:\n  Cauchy X\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "{"], ["proof (state)\nthis:\n  Cauchy X\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "fix x::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "fix x::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "assume \"norm x \\<le> 1\""], ["proof (state)\nthis:\n  norm x \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \"Cauchy (\\<lambda>n. X n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. cblinfun_apply (X n) x)", "proof (rule CauchyI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                norm (cblinfun_apply (X m) x - cblinfun_apply (X n) x) < e", "fix e::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                norm (cblinfun_apply (X m) x - cblinfun_apply (X n) x) < e", "assume \"0 < e\""], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                norm (cblinfun_apply (X m) x - cblinfun_apply (X n) x) < e", "from CauchyD[OF \\<open>Cauchy X\\<close> \\<open>0 < e\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. norm (X m - X n) < e", "obtain M\n          where M: \"\\<And>m n. m \\<ge> M \\<Longrightarrow> n \\<ge> M \\<Longrightarrow> norm (X m - X n) < e\""], ["proof (prove)\nusing this:\n  \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. norm (X m - X n) < e\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        (\\<And>m n.\n            \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n            \\<Longrightarrow> norm (X m - X n) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<le> ?m; M \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> norm (X ?m - X ?n) < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                norm (cblinfun_apply (X m) x - cblinfun_apply (X n) x) < e", "show \"\\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. norm (X m x - X n x) < e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>m\\<ge>M.\n          \\<forall>n\\<ge>M.\n             norm (cblinfun_apply (X m) x - cblinfun_apply (X n) x) < e", "proof (safe intro!: exI[where x=M])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (cblinfun_apply (X m) x - cblinfun_apply (X n) x)\n                         < e", "fix m n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (cblinfun_apply (X m) x - cblinfun_apply (X n) x)\n                         < e", "assume le: \"M \\<le> m\" \"M \\<le> n\""], ["proof (state)\nthis:\n  M \\<le> m\n  M \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (cblinfun_apply (X m) x - cblinfun_apply (X n) x)\n                         < e", "have \"norm (X m x - X n x) = norm ((X m - X n) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (cblinfun_apply (X m) x - cblinfun_apply (X n) x) =\n    norm (cblinfun_apply (X m - X n) x)", "by (simp add: cblinfun.cbilinear_simps)"], ["proof (state)\nthis:\n  norm (cblinfun_apply (X m) x - cblinfun_apply (X n) x) =\n  norm (cblinfun_apply (X m - X n) x)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (cblinfun_apply (X m) x - cblinfun_apply (X n) x)\n                         < e", "also"], ["proof (state)\nthis:\n  norm (cblinfun_apply (X m) x - cblinfun_apply (X n) x) =\n  norm (cblinfun_apply (X m - X n) x)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (cblinfun_apply (X m) x - cblinfun_apply (X n) x)\n                         < e", "have \"\\<dots> \\<le> norm (X m - X n) * norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (cblinfun_apply (X m - X n) x) \\<le> norm (X m - X n) * norm x", "by (rule norm_cblinfun)"], ["proof (state)\nthis:\n  norm (cblinfun_apply (X m - X n) x) \\<le> norm (X m - X n) * norm x\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (cblinfun_apply (X m) x - cblinfun_apply (X n) x)\n                         < e", "also"], ["proof (state)\nthis:\n  norm (cblinfun_apply (X m - X n) x) \\<le> norm (X m - X n) * norm x\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (cblinfun_apply (X m) x - cblinfun_apply (X n) x)\n                         < e", "have \"\\<dots> \\<le> norm (X m - X n) * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (X m - X n) * norm x \\<le> norm (X m - X n) * 1", "using \\<open>norm x \\<le> 1\\<close> norm_ge_zero"], ["proof (prove)\nusing this:\n  norm x \\<le> 1\n  0 \\<le> norm ?x\n\ngoal (1 subgoal):\n 1. norm (X m - X n) * norm x \\<le> norm (X m - X n) * 1", "by (rule mult_left_mono)"], ["proof (state)\nthis:\n  norm (X m - X n) * norm x \\<le> norm (X m - X n) * 1\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (cblinfun_apply (X m) x - cblinfun_apply (X n) x)\n                         < e", "also"], ["proof (state)\nthis:\n  norm (X m - X n) * norm x \\<le> norm (X m - X n) * 1\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (cblinfun_apply (X m) x - cblinfun_apply (X n) x)\n                         < e", "have \"\\<dots> = norm (X m - X n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (X m - X n) * 1 = norm (X m - X n)", "by simp"], ["proof (state)\nthis:\n  norm (X m - X n) * 1 = norm (X m - X n)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (cblinfun_apply (X m) x - cblinfun_apply (X n) x)\n                         < e", "also"], ["proof (state)\nthis:\n  norm (X m - X n) * 1 = norm (X m - X n)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (cblinfun_apply (X m) x - cblinfun_apply (X n) x)\n                         < e", "have \"\\<dots> < e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (X m - X n) < e", "using le"], ["proof (prove)\nusing this:\n  M \\<le> m\n  M \\<le> n\n\ngoal (1 subgoal):\n 1. norm (X m - X n) < e", "by fact"], ["proof (state)\nthis:\n  norm (X m - X n) < e\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm\n                          (cblinfun_apply (X m) x - cblinfun_apply (X n) x)\n                         < e", "finally"], ["proof (chain)\npicking this:\n  norm (cblinfun_apply (X m) x - cblinfun_apply (X n) x) < e", "show \"norm (X m x - X n x) < e\""], ["proof (prove)\nusing this:\n  norm (cblinfun_apply (X m) x - cblinfun_apply (X n) x) < e\n\ngoal (1 subgoal):\n 1. norm (cblinfun_apply (X m) x - cblinfun_apply (X n) x) < e", "."], ["proof (state)\nthis:\n  norm (cblinfun_apply (X m) x - cblinfun_apply (X n) x) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>M.\n     \\<forall>m\\<ge>M.\n        \\<forall>n\\<ge>M.\n           norm (cblinfun_apply (X m) x - cblinfun_apply (X n) x) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cauchy (\\<lambda>n. cblinfun_apply (X n) x)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "hence \"convergent (\\<lambda>n. X n x)\""], ["proof (prove)\nusing this:\n  Cauchy (\\<lambda>n. cblinfun_apply (X n) x)\n\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. cblinfun_apply (X n) x)", "by (metis Cauchy_convergent_iff)"], ["proof (state)\nthis:\n  convergent (\\<lambda>n. cblinfun_apply (X n) x)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "}"], ["proof (state)\nthis:\n  norm ?xa2 \\<le> 1 \\<Longrightarrow>\n  convergent (\\<lambda>n. cblinfun_apply (X n) ?xa2)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "note convergent_norm1 = this"], ["proof (state)\nthis:\n  norm ?xa2 \\<le> 1 \\<Longrightarrow>\n  convergent (\\<lambda>n. cblinfun_apply (X n) ?xa2)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "define y where \"y = x /\\<^sub>R norm x\""], ["proof (state)\nthis:\n  y = x /\\<^sub>R norm x\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have y: \"norm y \\<le> 1\" and xy: \"x = norm x *\\<^sub>R y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm y \\<le> 1 &&& x = norm x *\\<^sub>R y", "by (simp_all add: y_def inverse_eq_divide)"], ["proof (state)\nthis:\n  norm y \\<le> 1\n  x = norm x *\\<^sub>R y\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \"convergent (\\<lambda>n. norm x *\\<^sub>R X n y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. norm x *\\<^sub>R cblinfun_apply (X n) y)", "by (intro bounded_bilinear.convergent[OF bounded_bilinear_scaleR] convergent_const\n          convergent_norm1 y)"], ["proof (state)\nthis:\n  convergent (\\<lambda>n. norm x *\\<^sub>R cblinfun_apply (X n) y)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "also"], ["proof (state)\nthis:\n  convergent (\\<lambda>n. norm x *\\<^sub>R cblinfun_apply (X n) y)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \"(\\<lambda>n. norm x *\\<^sub>R X n y) = (\\<lambda>n. X n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. norm x *\\<^sub>R cblinfun_apply (X n) y) =\n    (\\<lambda>n. cblinfun_apply (X n) x)", "by (metis cblinfun.scaleC_right scaleR_scaleC xy)"], ["proof (state)\nthis:\n  (\\<lambda>n. norm x *\\<^sub>R cblinfun_apply (X n) y) =\n  (\\<lambda>n. cblinfun_apply (X n) x)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "finally"], ["proof (chain)\npicking this:\n  convergent (\\<lambda>n. cblinfun_apply (X n) x)", "have \"convergent (\\<lambda>n. X n x)\""], ["proof (prove)\nusing this:\n  convergent (\\<lambda>n. cblinfun_apply (X n) x)\n\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. cblinfun_apply (X n) x)", "."], ["proof (state)\nthis:\n  convergent (\\<lambda>n. cblinfun_apply (X n) x)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "}"], ["proof (state)\nthis:\n  convergent (\\<lambda>n. cblinfun_apply (X n) ?x2)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "then"], ["proof (chain)\npicking this:\n  convergent (\\<lambda>n. cblinfun_apply (X n) ?x2)", "obtain v where v: \"\\<And>x. (\\<lambda>n. X n x) \\<longlonglongrightarrow> v x\""], ["proof (prove)\nusing this:\n  convergent (\\<lambda>n. cblinfun_apply (X n) ?x2)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>x.\n            (\\<lambda>n. cblinfun_apply (X n) x)\n            \\<longlonglongrightarrow> v x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding convergent_def"], ["proof (prove)\nusing this:\n  \\<exists>L.\n     (\\<lambda>n. cblinfun_apply (X n) ?x2) \\<longlonglongrightarrow> L\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>x.\n            (\\<lambda>n. cblinfun_apply (X n) x)\n            \\<longlonglongrightarrow> v x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (\\<lambda>n. cblinfun_apply (X n) ?x) \\<longlonglongrightarrow> v ?x\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \"Cauchy (\\<lambda>n. norm (X n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. norm (X n))", "proof (rule CauchyI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M. norm (norm (X m) - norm (X n)) < e", "fix e::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M. norm (norm (X m) - norm (X n)) < e", "assume \"e > 0\""], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M. norm (norm (X m) - norm (X n)) < e", "from CauchyD[OF \\<open>Cauchy X\\<close> \\<open>0 < e\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. norm (X m - X n) < e", "obtain M\n      where M: \"\\<And>m n. m \\<ge> M \\<Longrightarrow> n \\<ge> M \\<Longrightarrow> norm (X m - X n) < e\""], ["proof (prove)\nusing this:\n  \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. norm (X m - X n) < e\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        (\\<And>m n.\n            \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n            \\<Longrightarrow> norm (X m - X n) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<le> ?m; M \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> norm (X ?m - X ?n) < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M. norm (norm (X m) - norm (X n)) < e", "show \"\\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. norm (norm (X m) - norm (X n)) < e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>m\\<ge>M.\n          \\<forall>n\\<ge>M. norm (norm (X m) - norm (X n)) < e", "proof (safe intro!: exI[where x=M])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm (norm (X m) - norm (X n)) < e", "fix m n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm (norm (X m) - norm (X n)) < e", "assume mn: \"m \\<ge> M\" \"n \\<ge> M\""], ["proof (state)\nthis:\n  M \\<le> m\n  M \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm (norm (X m) - norm (X n)) < e", "have \"norm (norm (X m) - norm (X n)) \\<le> norm (X m - X n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (norm (X m) - norm (X n)) \\<le> norm (X m - X n)", "by (metis norm_triangle_ineq3 real_norm_def)"], ["proof (state)\nthis:\n  norm (norm (X m) - norm (X n)) \\<le> norm (X m - X n)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm (norm (X m) - norm (X n)) < e", "also"], ["proof (state)\nthis:\n  norm (norm (X m) - norm (X n)) \\<le> norm (X m - X n)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm (norm (X m) - norm (X n)) < e", "have \"\\<dots> < e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (X m - X n) < e", "using mn"], ["proof (prove)\nusing this:\n  M \\<le> m\n  M \\<le> n\n\ngoal (1 subgoal):\n 1. norm (X m - X n) < e", "by fact"], ["proof (state)\nthis:\n  norm (X m - X n) < e\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n       \\<Longrightarrow> norm (norm (X m) - norm (X n)) < e", "finally"], ["proof (chain)\npicking this:\n  norm (norm (X m) - norm (X n)) < e", "show \"norm (norm (X m) - norm (X n)) < e\""], ["proof (prove)\nusing this:\n  norm (norm (X m) - norm (X n)) < e\n\ngoal (1 subgoal):\n 1. norm (norm (X m) - norm (X n)) < e", "."], ["proof (state)\nthis:\n  norm (norm (X m) - norm (X n)) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>M.\n     \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. norm (norm (X m) - norm (X n)) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cauchy (\\<lambda>n. norm (X n))\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "then"], ["proof (chain)\npicking this:\n  Cauchy (\\<lambda>n. norm (X n))", "obtain K where K: \"(\\<lambda>n. norm (X n)) \\<longlonglongrightarrow> K\""], ["proof (prove)\nusing this:\n  Cauchy (\\<lambda>n. norm (X n))\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        (\\<lambda>n. norm (X n))\n        \\<longlonglongrightarrow> K \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Cauchy_convergent_iff convergent_def"], ["proof (prove)\nusing this:\n  \\<exists>L. (\\<lambda>n. norm (X n)) \\<longlonglongrightarrow> L\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        (\\<lambda>n. norm (X n))\n        \\<longlonglongrightarrow> K \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (\\<lambda>n. norm (X n)) \\<longlonglongrightarrow> K\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \"bounded_clinear v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear v", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2. v (b1 + b2) = v b1 + v b2\n 2. \\<And>r b. v (r *\\<^sub>C b) = r *\\<^sub>C v b\n 3. \\<exists>K. \\<forall>x. norm (v x) \\<le> norm x * K", "fix x y and r::complex"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2. v (b1 + b2) = v b1 + v b2\n 2. \\<And>r b. v (r *\\<^sub>C b) = r *\\<^sub>C v b\n 3. \\<exists>K. \\<forall>x. norm (v x) \\<le> norm x * K", "from tendsto_add[OF v[of x] v [of y]] v[of \"x + y\", unfolded cblinfun.cbilinear_simps]\n      tendsto_scaleC[OF tendsto_const[of r] v[of x]] v[of \"r *\\<^sub>C x\", unfolded cblinfun.cbilinear_simps]"], ["proof (chain)\npicking this:\n  (\\<lambda>xa. cblinfun_apply (X xa) x + cblinfun_apply (X xa) y)\n  \\<longlonglongrightarrow> v x + v y\n  (\\<lambda>n. cblinfun_apply (X n) x + cblinfun_apply (X n) y)\n  \\<longlonglongrightarrow> v (x + y)\n  (\\<lambda>xa. r *\\<^sub>C cblinfun_apply (X xa) x)\n  \\<longlonglongrightarrow> r *\\<^sub>C v x\n  (\\<lambda>n. r *\\<^sub>C cblinfun_apply (X n) x)\n  \\<longlonglongrightarrow> v (r *\\<^sub>C x)", "show \"v (x + y) = v x + v y\" \"v (r *\\<^sub>C x) = r *\\<^sub>C v x\""], ["proof (prove)\nusing this:\n  (\\<lambda>xa. cblinfun_apply (X xa) x + cblinfun_apply (X xa) y)\n  \\<longlonglongrightarrow> v x + v y\n  (\\<lambda>n. cblinfun_apply (X n) x + cblinfun_apply (X n) y)\n  \\<longlonglongrightarrow> v (x + y)\n  (\\<lambda>xa. r *\\<^sub>C cblinfun_apply (X xa) x)\n  \\<longlonglongrightarrow> r *\\<^sub>C v x\n  (\\<lambda>n. r *\\<^sub>C cblinfun_apply (X n) x)\n  \\<longlonglongrightarrow> v (r *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. v (x + y) = v x + v y &&& v (r *\\<^sub>C x) = r *\\<^sub>C v x", "by (metis (poly_guards_query) LIMSEQ_unique)+"], ["proof (state)\nthis:\n  v (x + y) = v x + v y\n  v (r *\\<^sub>C x) = r *\\<^sub>C v x\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (v x) \\<le> norm x * K", "show \"\\<exists>K. \\<forall>x. norm (v x) \\<le> norm x * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (v x) \\<le> norm x * K", "proof (safe intro!: exI[where x=K])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. norm (v x) \\<le> norm x * K", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. norm (v x) \\<le> norm x * K", "have \"norm (v x) \\<le> K * norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (v x) \\<le> K * norm x", "apply (rule tendsto_le[OF _ tendsto_mult[OF K tendsto_const] tendsto_norm[OF v]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. sequentially \\<noteq> \\<bottom>\n 2. \\<forall>\\<^sub>F x in sequentially.\n       norm (cblinfun_apply (X x) x) \\<le> norm (X x) * norm x", "by (auto simp: norm_cblinfun)"], ["proof (state)\nthis:\n  norm (v x) \\<le> K * norm x\n\ngoal (1 subgoal):\n 1. \\<And>x. norm (v x) \\<le> norm x * K", "thus \"norm (v x) \\<le> norm x * K\""], ["proof (prove)\nusing this:\n  norm (v x) \\<le> K * norm x\n\ngoal (1 subgoal):\n 1. norm (v x) \\<le> norm x * K", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  norm (v x) \\<le> norm x * K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>x. norm (v x) \\<le> norm x * K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bounded_clinear v\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "hence Bv: \"\\<And>x. (\\<lambda>n. X n x) \\<longlonglongrightarrow> CBlinfun v x\""], ["proof (prove)\nusing this:\n  bounded_clinear v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<lambda>n. cblinfun_apply (X n) x)\n       \\<longlonglongrightarrow> cblinfun_apply (CBlinfun v) x", "by (auto simp: bounded_clinear_CBlinfun_apply v)"], ["proof (state)\nthis:\n  (\\<lambda>n. cblinfun_apply (X n) ?x)\n  \\<longlonglongrightarrow> cblinfun_apply (CBlinfun v) ?x\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \"X \\<longlonglongrightarrow> CBlinfun v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<longlonglongrightarrow> CBlinfun v", "proof (rule LIMSEQ_I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no. \\<forall>n\\<ge>no. norm (X n - CBlinfun v) < r", "fix r::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no. \\<forall>n\\<ge>no. norm (X n - CBlinfun v) < r", "assume \"r > 0\""], ["proof (state)\nthis:\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no. \\<forall>n\\<ge>no. norm (X n - CBlinfun v) < r", "define r' where \"r' = r / 2\""], ["proof (state)\nthis:\n  r' = r / 2\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no. \\<forall>n\\<ge>no. norm (X n - CBlinfun v) < r", "have \"0 < r'\" \"r' < r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r' &&& r' < r", "using \\<open>r > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < r\n\ngoal (1 subgoal):\n 1. 0 < r' &&& r' < r", "by (simp_all add: r'_def)"], ["proof (state)\nthis:\n  0 < r'\n  r' < r\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no. \\<forall>n\\<ge>no. norm (X n - CBlinfun v) < r", "from CauchyD[OF \\<open>Cauchy X\\<close> \\<open>r' > 0\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. norm (X m - X n) < r'", "obtain M where M: \"\\<And>m n. m \\<ge> M \\<Longrightarrow> n \\<ge> M \\<Longrightarrow> norm (X m - X n) < r'\""], ["proof (prove)\nusing this:\n  \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. norm (X m - X n) < r'\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        (\\<And>m n.\n            \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n            \\<Longrightarrow> norm (X m - X n) < r') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<le> ?m; M \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> norm (X ?m - X ?n) < r'\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no. \\<forall>n\\<ge>no. norm (X n - CBlinfun v) < r", "show \"\\<exists>no. \\<forall>n\\<ge>no. norm (X n - CBlinfun v) < r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>no. \\<forall>n\\<ge>no. norm (X n - CBlinfun v) < r", "proof (safe intro!: exI[where x=M])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. M \\<le> n \\<Longrightarrow> norm (X n - CBlinfun v) < r", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. M \\<le> n \\<Longrightarrow> norm (X n - CBlinfun v) < r", "assume n: \"M \\<le> n\""], ["proof (state)\nthis:\n  M \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>n. M \\<le> n \\<Longrightarrow> norm (X n - CBlinfun v) < r", "have \"norm (X n - CBlinfun v) \\<le> r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (X n - CBlinfun v) \\<le> r'", "proof (rule norm_cblinfun_bound)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> r'\n 2. \\<And>x. norm (cblinfun_apply (X n - CBlinfun v) x) \\<le> r' * norm x", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> r'\n 2. \\<And>x. norm (cblinfun_apply (X n - CBlinfun v) x) \\<le> r' * norm x", "have \"eventually (\\<lambda>m. m \\<ge> M) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually ((\\<le>) M) sequentially", "by (metis eventually_ge_at_top)"], ["proof (state)\nthis:\n  eventually ((\\<le>) M) sequentially\n\ngoal (2 subgoals):\n 1. 0 \\<le> r'\n 2. \\<And>x. norm (cblinfun_apply (X n - CBlinfun v) x) \\<le> r' * norm x", "hence ev_le: \"eventually (\\<lambda>m. norm (X n x - X m x) \\<le> r' * norm x) sequentially\""], ["proof (prove)\nusing this:\n  eventually ((\\<le>) M) sequentially\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially.\n       norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x)\n       \\<le> r' * norm x", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       M \\<le> m \\<Longrightarrow>\n       norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x)\n       \\<le> r' * norm x", "case (elim m)"], ["proof (state)\nthis:\n  M \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       M \\<le> m \\<Longrightarrow>\n       norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x)\n       \\<le> r' * norm x", "have \"norm (X n x - X m x) = norm ((X n - X m) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x) =\n    norm (cblinfun_apply (X n - X m) x)", "by (simp add: cblinfun.cbilinear_simps)"], ["proof (state)\nthis:\n  norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x) =\n  norm (cblinfun_apply (X n - X m) x)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       M \\<le> m \\<Longrightarrow>\n       norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x)\n       \\<le> r' * norm x", "also"], ["proof (state)\nthis:\n  norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x) =\n  norm (cblinfun_apply (X n - X m) x)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       M \\<le> m \\<Longrightarrow>\n       norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x)\n       \\<le> r' * norm x", "have \"\\<dots> \\<le> norm ((X n - X m)) * norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (cblinfun_apply (X n - X m) x) \\<le> norm (X n - X m) * norm x", "by (rule norm_cblinfun)"], ["proof (state)\nthis:\n  norm (cblinfun_apply (X n - X m) x) \\<le> norm (X n - X m) * norm x\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       M \\<le> m \\<Longrightarrow>\n       norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x)\n       \\<le> r' * norm x", "also"], ["proof (state)\nthis:\n  norm (cblinfun_apply (X n - X m) x) \\<le> norm (X n - X m) * norm x\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       M \\<le> m \\<Longrightarrow>\n       norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x)\n       \\<le> r' * norm x", "have \"\\<dots> \\<le> r' * norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (X n - X m) * norm x \\<le> r' * norm x", "using M[OF n elim]"], ["proof (prove)\nusing this:\n  norm (X n - X m) < r'\n\ngoal (1 subgoal):\n 1. norm (X n - X m) * norm x \\<le> r' * norm x", "by (simp add: mult_right_mono)"], ["proof (state)\nthis:\n  norm (X n - X m) * norm x \\<le> r' * norm x\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       M \\<le> m \\<Longrightarrow>\n       norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x)\n       \\<le> r' * norm x", "finally"], ["proof (chain)\npicking this:\n  norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x) \\<le> r' * norm x", "show ?case"], ["proof (prove)\nusing this:\n  norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x) \\<le> r' * norm x\n\ngoal (1 subgoal):\n 1. norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x) \\<le> r' * norm x", "."], ["proof (state)\nthis:\n  norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x) \\<le> r' * norm x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially.\n     norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x)\n     \\<le> r' * norm x\n\ngoal (2 subgoals):\n 1. 0 \\<le> r'\n 2. \\<And>x. norm (cblinfun_apply (X n - CBlinfun v) x) \\<le> r' * norm x", "have tendsto_v: \"(\\<lambda>m. norm (X n x - X m x)) \\<longlonglongrightarrow> norm (X n x - CBlinfun v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m. norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x))\n    \\<longlonglongrightarrow> norm\n                               (cblinfun_apply (X n) x -\n                                cblinfun_apply (CBlinfun v) x)", "by (auto intro!: tendsto_intros Bv)"], ["proof (state)\nthis:\n  (\\<lambda>m. norm (cblinfun_apply (X n) x - cblinfun_apply (X m) x))\n  \\<longlonglongrightarrow> norm\n                             (cblinfun_apply (X n) x -\n                              cblinfun_apply (CBlinfun v) x)\n\ngoal (2 subgoals):\n 1. 0 \\<le> r'\n 2. \\<And>x. norm (cblinfun_apply (X n - CBlinfun v) x) \\<le> r' * norm x", "show \"norm ((X n - CBlinfun v) x) \\<le> r' * norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (cblinfun_apply (X n - CBlinfun v) x) \\<le> r' * norm x", "by (auto intro!: tendsto_upperbound tendsto_v ev_le simp: cblinfun.cbilinear_simps)"], ["proof (state)\nthis:\n  norm (cblinfun_apply (X n - CBlinfun v) x) \\<le> r' * norm x\n\ngoal (1 subgoal):\n 1. 0 \\<le> r'", "qed (simp add: \\<open>0 < r'\\<close> less_imp_le)"], ["proof (state)\nthis:\n  norm (X n - CBlinfun v) \\<le> r'\n\ngoal (1 subgoal):\n 1. \\<And>n. M \\<le> n \\<Longrightarrow> norm (X n - CBlinfun v) < r", "thus \"norm (X n - CBlinfun v) < r\""], ["proof (prove)\nusing this:\n  norm (X n - CBlinfun v) \\<le> r'\n\ngoal (1 subgoal):\n 1. norm (X n - CBlinfun v) < r", "by (metis \\<open>r' < r\\<close> le_less_trans)"], ["proof (state)\nthis:\n  norm (X n - CBlinfun v) < r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>no. \\<forall>n\\<ge>no. norm (X n - CBlinfun v) < r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  X \\<longlonglongrightarrow> CBlinfun v\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "thus \"convergent X\""], ["proof (prove)\nusing this:\n  X \\<longlonglongrightarrow> CBlinfun v\n\ngoal (1 subgoal):\n 1. convergent X", "by (rule convergentI)"], ["proof (state)\nthis:\n  convergent X\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<^marker>\\<open>tag unimportant\\<close> \\<open>On Euclidean Space\\<close>"], ["", "(* No different in complex case *)\n(* lemma Zfun_sum:\n  assumes \"finite s\"\n  assumes f: \"\\<And>i. i \\<in> s \\<Longrightarrow> Zfun (f i) F\"\n  shows \"Zfun (\\<lambda>x. sum (\\<lambda>i. f i x) s) F\" *)"], ["", "lemma norm_cblinfun_ceuclidean_le:\n  fixes a::\"'a::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\"\n  shows \"norm a \\<le> sum (\\<lambda>x. norm (a x)) CBasis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm a \\<le> (\\<Sum>x\\<in>CBasis. norm (cblinfun_apply a x))", "apply (rule norm_cblinfun_bound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> (\\<Sum>x\\<in>CBasis. norm (cblinfun_apply a x))\n 2. \\<And>x.\n       norm (cblinfun_apply a x)\n       \\<le> (\\<Sum>x\\<in>CBasis. norm (cblinfun_apply a x)) * norm x", "apply (simp add: sum_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm (cblinfun_apply a x)\n       \\<le> (\\<Sum>x\\<in>CBasis. norm (cblinfun_apply a x)) * norm x", "apply (subst ceuclidean_representation[symmetric, where 'a='a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm\n        (cblinfun_apply a\n          (\\<Sum>b\\<in>CBasis. (b \\<bullet>\\<^sub>C x) *\\<^sub>C b))\n       \\<le> (\\<Sum>x\\<in>CBasis. norm (cblinfun_apply a x)) * norm x", "apply (simp only: cblinfun.cbilinear_simps sum_distrib_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm\n        (\\<Sum>i\\<in>CBasis.\n           (i \\<bullet>\\<^sub>C x) *\\<^sub>C cblinfun_apply a i)\n       \\<le> (\\<Sum>n\\<in>CBasis. norm (cblinfun_apply a n) * norm x)", "apply (rule order.trans[OF norm_sum sum_mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       n \\<in> CBasis \\<Longrightarrow>\n       norm ((n \\<bullet>\\<^sub>C x) *\\<^sub>C cblinfun_apply a n)\n       \\<le> norm (cblinfun_apply a n) * norm x", "apply (simp add: abs_mult mult_right_mono ac_simps CBasis_le_norm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       n \\<in> CBasis \\<Longrightarrow>\n       norm (cblinfun_apply a n) * cmod (n \\<bullet>\\<^sub>C x)\n       \\<le> norm x * norm (cblinfun_apply a n)", "by (metis complex_inner_class.Cauchy_Schwarz_ineq2 mult.commute mult.left_neutral mult_right_mono norm_CBasis norm_ge_zero)"], ["", "lemma ctendsto_componentwise1:\n  fixes a::\"'a::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\"\n    and b::\"'c \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  assumes \"(\\<And>j. j \\<in> CBasis \\<Longrightarrow> ((\\<lambda>n. b n j) \\<longlongrightarrow> a j) F)\"\n  shows \"(b \\<longlongrightarrow> a) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<longlongrightarrow> a) F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (b \\<longlongrightarrow> a) F", "have \"\\<And>j. j \\<in> CBasis \\<Longrightarrow> Zfun (\\<lambda>x. norm (b x j - a j)) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> CBasis \\<Longrightarrow>\n       Zfun (\\<lambda>x. norm (cblinfun_apply (b x) j - cblinfun_apply a j))\n        F", "using assms"], ["proof (prove)\nusing this:\n  ?j \\<in> CBasis \\<Longrightarrow>\n  ((\\<lambda>n. cblinfun_apply (b n) ?j) \\<longlongrightarrow>\n   cblinfun_apply a ?j)\n   F\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> CBasis \\<Longrightarrow>\n       Zfun (\\<lambda>x. norm (cblinfun_apply (b x) j - cblinfun_apply a j))\n        F", "unfolding tendsto_Zfun_iff Zfun_norm_iff"], ["proof (prove)\nusing this:\n  ?j \\<in> CBasis \\<Longrightarrow>\n  Zfun (\\<lambda>x. cblinfun_apply (b x) ?j - cblinfun_apply a ?j) F\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> CBasis \\<Longrightarrow>\n       Zfun (\\<lambda>x. cblinfun_apply (b x) j - cblinfun_apply a j) F", "."], ["proof (state)\nthis:\n  ?j \\<in> CBasis \\<Longrightarrow>\n  Zfun (\\<lambda>x. norm (cblinfun_apply (b x) ?j - cblinfun_apply a ?j)) F\n\ngoal (1 subgoal):\n 1. (b \\<longlongrightarrow> a) F", "hence \"Zfun (\\<lambda>x. \\<Sum>j\\<in>CBasis. norm (b x j - a j)) F\""], ["proof (prove)\nusing this:\n  ?j \\<in> CBasis \\<Longrightarrow>\n  Zfun (\\<lambda>x. norm (cblinfun_apply (b x) ?j - cblinfun_apply a ?j)) F\n\ngoal (1 subgoal):\n 1. Zfun\n     (\\<lambda>x.\n         \\<Sum>j\\<in>CBasis.\n           norm (cblinfun_apply (b x) j - cblinfun_apply a j))\n     F", "by (auto intro!: Zfun_sum)"], ["proof (state)\nthis:\n  Zfun\n   (\\<lambda>x.\n       \\<Sum>j\\<in>CBasis.\n         norm (cblinfun_apply (b x) j - cblinfun_apply a j))\n   F\n\ngoal (1 subgoal):\n 1. (b \\<longlongrightarrow> a) F", "thus ?thesis"], ["proof (prove)\nusing this:\n  Zfun\n   (\\<lambda>x.\n       \\<Sum>j\\<in>CBasis.\n         norm (cblinfun_apply (b x) j - cblinfun_apply a j))\n   F\n\ngoal (1 subgoal):\n 1. (b \\<longlongrightarrow> a) F", "unfolding tendsto_Zfun_iff"], ["proof (prove)\nusing this:\n  Zfun\n   (\\<lambda>x.\n       \\<Sum>j\\<in>CBasis.\n         norm (cblinfun_apply (b x) j - cblinfun_apply a j))\n   F\n\ngoal (1 subgoal):\n 1. Zfun (\\<lambda>x. b x - a) F", "by (rule Zfun_le)\n      (auto intro!: order_trans[OF norm_cblinfun_ceuclidean_le] simp: cblinfun.cbilinear_simps)"], ["proof (state)\nthis:\n  (b \\<longlongrightarrow> a) F\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition\n  cblinfun_of_matrix::\"('b::ceuclidean_space \\<Rightarrow> 'a::ceuclidean_space \\<Rightarrow> complex) \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  is \"\\<lambda>a x. \\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. ((j \\<bullet>\\<^sub>C x) * a i j) *\\<^sub>C i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun.\n       bounded_clinear\n        (\\<lambda>x.\n            \\<Sum>i\\<in>CBasis.\n              \\<Sum>j\\<in>CBasis.\n                (j \\<bullet>\\<^sub>C x * fun i j) *\\<^sub>C i)", "by (intro bounded_linear_intros)"], ["", "lemma cblinfun_of_matrix_works:\n  fixes f::\"'a::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::ceuclidean_space\"\n  shows \"cblinfun_of_matrix (\\<lambda>i j. i \\<bullet>\\<^sub>C (f j)) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_of_matrix\n     (\\<lambda>i j. i \\<bullet>\\<^sub>C cblinfun_apply f j) =\n    f", "proof (transfer, rule,  rule ceuclidean_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f x b.\n       \\<lbrakk>bounded_clinear f; b \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>CBasis.\n                            \\<Sum>j\\<in>CBasis.\n                              (j \\<bullet>\\<^sub>C x *\n                               (i \\<bullet>\\<^sub>C f j)) *\\<^sub>C\n                              i) \\<bullet>\\<^sub>C\n                         b =\n                         f x \\<bullet>\\<^sub>C b", "fix f::\"'a \\<Rightarrow> 'b\" and x::'a and b::'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f x b.\n       \\<lbrakk>bounded_clinear f; b \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>CBasis.\n                            \\<Sum>j\\<in>CBasis.\n                              (j \\<bullet>\\<^sub>C x *\n                               (i \\<bullet>\\<^sub>C f j)) *\\<^sub>C\n                              i) \\<bullet>\\<^sub>C\n                         b =\n                         f x \\<bullet>\\<^sub>C b", "assume \"bounded_clinear f\" and b: \"b \\<in> CBasis\""], ["proof (state)\nthis:\n  bounded_clinear f\n  b \\<in> CBasis\n\ngoal (1 subgoal):\n 1. \\<And>f x b.\n       \\<lbrakk>bounded_clinear f; b \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>CBasis.\n                            \\<Sum>j\\<in>CBasis.\n                              (j \\<bullet>\\<^sub>C x *\n                               (i \\<bullet>\\<^sub>C f j)) *\\<^sub>C\n                              i) \\<bullet>\\<^sub>C\n                         b =\n                         f x \\<bullet>\\<^sub>C b", "then"], ["proof (chain)\npicking this:\n  bounded_clinear f\n  b \\<in> CBasis", "interpret bounded_clinear f"], ["proof (prove)\nusing this:\n  bounded_clinear f\n  b \\<in> CBasis\n\ngoal (1 subgoal):\n 1. bounded_clinear f", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f x b.\n       \\<lbrakk>bounded_clinear f; b \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>CBasis.\n                            \\<Sum>j\\<in>CBasis.\n                              (j \\<bullet>\\<^sub>C x *\n                               (i \\<bullet>\\<^sub>C f j)) *\\<^sub>C\n                              i) \\<bullet>\\<^sub>C\n                         b =\n                         f x \\<bullet>\\<^sub>C b", "have \"(\\<Sum>j\\<in>CBasis. \\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x * (j \\<bullet>\\<^sub>C f i)) *\\<^sub>C j) \\<bullet>\\<^sub>C b\n    = (\\<Sum>j\\<in>CBasis. if j = b then (\\<Sum>i\\<in>CBasis. (x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C j))) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>CBasis.\n       \\<Sum>i\\<in>CBasis.\n         (i \\<bullet>\\<^sub>C x * (j \\<bullet>\\<^sub>C f i)) *\\<^sub>C\n         j) \\<bullet>\\<^sub>C\n    b =\n    (\\<Sum>j\\<in>CBasis.\n       if j = b\n       then \\<Sum>i\\<in>CBasis.\n              x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C j)\n       else 0)", "using b"], ["proof (prove)\nusing this:\n  b \\<in> CBasis\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>CBasis.\n       \\<Sum>i\\<in>CBasis.\n         (i \\<bullet>\\<^sub>C x * (j \\<bullet>\\<^sub>C f i)) *\\<^sub>C\n         j) \\<bullet>\\<^sub>C\n    b =\n    (\\<Sum>j\\<in>CBasis.\n       if j = b\n       then \\<Sum>i\\<in>CBasis.\n              x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C j)\n       else 0)", "apply (simp add: cinner_sum_left cinner_CBasis if_distrib cong: if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> CBasis \\<Longrightarrow>\n    (\\<Sum>j\\<in>CBasis.\n       \\<Sum>i\\<in>CBasis.\n         if j = b then x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)\n         else 0) =\n    (\\<Sum>i\\<in>CBasis. x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b))", "by (simp add: sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>CBasis.\n     \\<Sum>i\\<in>CBasis.\n       (i \\<bullet>\\<^sub>C x * (j \\<bullet>\\<^sub>C f i)) *\\<^sub>C\n       j) \\<bullet>\\<^sub>C\n  b =\n  (\\<Sum>j\\<in>CBasis.\n     if j = b\n     then \\<Sum>i\\<in>CBasis.\n            x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C j)\n     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>f x b.\n       \\<lbrakk>bounded_clinear f; b \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>CBasis.\n                            \\<Sum>j\\<in>CBasis.\n                              (j \\<bullet>\\<^sub>C x *\n                               (i \\<bullet>\\<^sub>C f j)) *\\<^sub>C\n                              i) \\<bullet>\\<^sub>C\n                         b =\n                         f x \\<bullet>\\<^sub>C b", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>CBasis.\n     \\<Sum>i\\<in>CBasis.\n       (i \\<bullet>\\<^sub>C x * (j \\<bullet>\\<^sub>C f i)) *\\<^sub>C\n       j) \\<bullet>\\<^sub>C\n  b =\n  (\\<Sum>j\\<in>CBasis.\n     if j = b\n     then \\<Sum>i\\<in>CBasis.\n            x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C j)\n     else 0)\n\ngoal (1 subgoal):\n 1. \\<And>f x b.\n       \\<lbrakk>bounded_clinear f; b \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>CBasis.\n                            \\<Sum>j\\<in>CBasis.\n                              (j \\<bullet>\\<^sub>C x *\n                               (i \\<bullet>\\<^sub>C f j)) *\\<^sub>C\n                              i) \\<bullet>\\<^sub>C\n                         b =\n                         f x \\<bullet>\\<^sub>C b", "have \"\\<dots> = (\\<Sum>i\\<in>CBasis. ((x \\<bullet>\\<^sub>C i) * (f i \\<bullet>\\<^sub>C b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>CBasis.\n       if j = b\n       then \\<Sum>i\\<in>CBasis.\n              x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C j)\n       else 0) =\n    (\\<Sum>i\\<in>CBasis. x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b))", "using b"], ["proof (prove)\nusing this:\n  b \\<in> CBasis\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>CBasis.\n       if j = b\n       then \\<Sum>i\\<in>CBasis.\n              x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C j)\n       else 0) =\n    (\\<Sum>i\\<in>CBasis. x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b))", "by (simp)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>CBasis.\n     if j = b\n     then \\<Sum>i\\<in>CBasis.\n            x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C j)\n     else 0) =\n  (\\<Sum>i\\<in>CBasis. x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b))\n\ngoal (1 subgoal):\n 1. \\<And>f x b.\n       \\<lbrakk>bounded_clinear f; b \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>CBasis.\n                            \\<Sum>j\\<in>CBasis.\n                              (j \\<bullet>\\<^sub>C x *\n                               (i \\<bullet>\\<^sub>C f j)) *\\<^sub>C\n                              i) \\<bullet>\\<^sub>C\n                         b =\n                         f x \\<bullet>\\<^sub>C b", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>CBasis.\n     if j = b\n     then \\<Sum>i\\<in>CBasis.\n            x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C j)\n     else 0) =\n  (\\<Sum>i\\<in>CBasis. x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b))\n\ngoal (1 subgoal):\n 1. \\<And>f x b.\n       \\<lbrakk>bounded_clinear f; b \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>CBasis.\n                            \\<Sum>j\\<in>CBasis.\n                              (j \\<bullet>\\<^sub>C x *\n                               (i \\<bullet>\\<^sub>C f j)) *\\<^sub>C\n                              i) \\<bullet>\\<^sub>C\n                         b =\n                         f x \\<bullet>\\<^sub>C b", "have \"\\<dots> = f x \\<bullet>\\<^sub>C b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>CBasis.\n       x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)) =\n    f x \\<bullet>\\<^sub>C b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>CBasis.\n       x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)) =\n    f x \\<bullet>\\<^sub>C b", "have \\<open>(\\<Sum>i\\<in>CBasis. (x \\<bullet>\\<^sub>C i) * (f i \\<bullet>\\<^sub>C b)) = (\\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) \\<bullet>\\<^sub>C b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>CBasis.\n       x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)) =\n    (\\<Sum>i\\<in>CBasis.\n       (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) \\<bullet>\\<^sub>C\n    b", "by (auto simp: cinner_sum_left)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>CBasis. x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)) =\n  (\\<Sum>i\\<in>CBasis.\n     (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) \\<bullet>\\<^sub>C\n  b\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>CBasis.\n       x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)) =\n    f x \\<bullet>\\<^sub>C b", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>CBasis. x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)) =\n  (\\<Sum>i\\<in>CBasis.\n     (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) \\<bullet>\\<^sub>C\n  b\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>CBasis.\n       x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)) =\n    f x \\<bullet>\\<^sub>C b", "have \\<open>\\<dots> = f x \\<bullet>\\<^sub>C b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>CBasis.\n       (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) \\<bullet>\\<^sub>C\n    b =\n    f x \\<bullet>\\<^sub>C b", "by (simp add: ceuclidean_representation sum[symmetric] scale[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>CBasis.\n     (i \\<bullet>\\<^sub>C x) *\\<^sub>C f i) \\<bullet>\\<^sub>C\n  b =\n  f x \\<bullet>\\<^sub>C b\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>CBasis.\n       x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)) =\n    f x \\<bullet>\\<^sub>C b", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>CBasis. x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)) =\n  f x \\<bullet>\\<^sub>C b", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>CBasis. x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)) =\n  f x \\<bullet>\\<^sub>C b\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>CBasis.\n       x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)) =\n    f x \\<bullet>\\<^sub>C b", "by -"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>CBasis. x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)) =\n  f x \\<bullet>\\<^sub>C b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>CBasis. x \\<bullet>\\<^sub>C i * (f i \\<bullet>\\<^sub>C b)) =\n  f x \\<bullet>\\<^sub>C b\n\ngoal (1 subgoal):\n 1. \\<And>f x b.\n       \\<lbrakk>bounded_clinear f; b \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>CBasis.\n                            \\<Sum>j\\<in>CBasis.\n                              (j \\<bullet>\\<^sub>C x *\n                               (i \\<bullet>\\<^sub>C f j)) *\\<^sub>C\n                              i) \\<bullet>\\<^sub>C\n                         b =\n                         f x \\<bullet>\\<^sub>C b", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j\\<in>CBasis.\n     \\<Sum>i\\<in>CBasis.\n       (i \\<bullet>\\<^sub>C x * (j \\<bullet>\\<^sub>C f i)) *\\<^sub>C\n       j) \\<bullet>\\<^sub>C\n  b =\n  f x \\<bullet>\\<^sub>C b", "show \"(\\<Sum>j\\<in>CBasis. \\<Sum>i\\<in>CBasis. (i \\<bullet>\\<^sub>C x * (j \\<bullet>\\<^sub>C f i)) *\\<^sub>C j) \\<bullet>\\<^sub>C b = f x \\<bullet>\\<^sub>C b\""], ["proof (prove)\nusing this:\n  (\\<Sum>j\\<in>CBasis.\n     \\<Sum>i\\<in>CBasis.\n       (i \\<bullet>\\<^sub>C x * (j \\<bullet>\\<^sub>C f i)) *\\<^sub>C\n       j) \\<bullet>\\<^sub>C\n  b =\n  f x \\<bullet>\\<^sub>C b\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>CBasis.\n       \\<Sum>i\\<in>CBasis.\n         (i \\<bullet>\\<^sub>C x * (j \\<bullet>\\<^sub>C f i)) *\\<^sub>C\n         j) \\<bullet>\\<^sub>C\n    b =\n    f x \\<bullet>\\<^sub>C b", "."], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>CBasis.\n     \\<Sum>i\\<in>CBasis.\n       (i \\<bullet>\\<^sub>C x * (j \\<bullet>\\<^sub>C f i)) *\\<^sub>C\n       j) \\<bullet>\\<^sub>C\n  b =\n  f x \\<bullet>\\<^sub>C b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_of_matrix_apply:\n  \"cblinfun_of_matrix a x = (\\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. ((j \\<bullet>\\<^sub>C x) * a i j) *\\<^sub>C i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_apply (cblinfun_of_matrix a) x =\n    (\\<Sum>i\\<in>CBasis.\n       \\<Sum>j\\<in>CBasis. (j \\<bullet>\\<^sub>C x * a i j) *\\<^sub>C i)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       (\\<Sum>i\\<in>CBasis.\n          \\<Sum>j\\<in>CBasis. (j \\<bullet>\\<^sub>C x * a i j) *\\<^sub>C i) =\n       (\\<Sum>i\\<in>CBasis.\n          \\<Sum>j\\<in>CBasis. (j \\<bullet>\\<^sub>C x * a i j) *\\<^sub>C i)", "by simp"], ["", "lemma cblinfun_of_matrix_minus: \"cblinfun_of_matrix x - cblinfun_of_matrix y = cblinfun_of_matrix (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_of_matrix x - cblinfun_of_matrix y = cblinfun_of_matrix (x - y)", "by transfer (auto simp: algebra_simps sum_subtractf)"], ["", "lemma norm_cblinfun_of_matrix:\n  \"norm (cblinfun_of_matrix a) \\<le> (\\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. cmod (a i j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (cblinfun_of_matrix a)\n    \\<le> (\\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. cmod (a i j))", "apply (rule norm_cblinfun_bound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> (\\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. cmod (a i j))\n 2. \\<And>x.\n       norm (cblinfun_apply (cblinfun_of_matrix a) x)\n       \\<le> (\\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. cmod (a i j)) * norm x", "apply (simp add: sum_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm (cblinfun_apply (cblinfun_of_matrix a) x)\n       \\<le> (\\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. cmod (a i j)) * norm x", "apply (simp only: cblinfun_of_matrix_apply sum_distrib_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm\n        (\\<Sum>i\\<in>CBasis.\n           \\<Sum>j\\<in>CBasis. (j \\<bullet>\\<^sub>C x * a i j) *\\<^sub>C i)\n       \\<le> (\\<Sum>n\\<in>CBasis.\n                \\<Sum>na\\<in>CBasis. cmod (a n na) * norm x)", "apply (rule order_trans[OF norm_sum sum_mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       n \\<in> CBasis \\<Longrightarrow>\n       norm\n        (\\<Sum>j\\<in>CBasis. (j \\<bullet>\\<^sub>C x * a n j) *\\<^sub>C n)\n       \\<le> (\\<Sum>na\\<in>CBasis. cmod (a n na) * norm x)", "apply (rule order_trans[OF norm_sum sum_mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n na.\n       \\<lbrakk>n \\<in> CBasis; na \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> norm\n                          ((na \\<bullet>\\<^sub>C x * a n na) *\\<^sub>C n)\n                         \\<le> cmod (a n na) * norm x", "apply (simp add: abs_mult mult_right_mono ac_simps Basis_le_norm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n na.\n       \\<lbrakk>n \\<in> CBasis; na \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> cmod (na \\<bullet>\\<^sub>C x * a n na)\n                         \\<le> norm x * cmod (a n na)", "by (metis complex_inner_class.Cauchy_Schwarz_ineq2 complex_scaleC_def mult.left_neutral mult_right_mono norm_CBasis norm_ge_zero norm_scaleC)"], ["", "lemma tendsto_cblinfun_of_matrix:\n  assumes \"\\<And>i j. i \\<in> CBasis \\<Longrightarrow> j \\<in> CBasis \\<Longrightarrow> ((\\<lambda>n. b n i j) \\<longlongrightarrow> a i j) F\"\n  shows \"((\\<lambda>n. cblinfun_of_matrix (b n)) \\<longlongrightarrow> cblinfun_of_matrix a) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n. cblinfun_of_matrix (b n)) \\<longlongrightarrow>\n     cblinfun_of_matrix a)\n     F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>n. cblinfun_of_matrix (b n)) \\<longlongrightarrow>\n     cblinfun_of_matrix a)\n     F", "have \"\\<And>i j. i \\<in> CBasis \\<Longrightarrow> j \\<in> CBasis \\<Longrightarrow> Zfun (\\<lambda>x. norm (b x i j - a i j)) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<in> CBasis; j \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> Zfun (\\<lambda>x. cmod (b x i j - a i j)) F", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> CBasis; ?j \\<in> CBasis\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>n. b n ?i ?j) \\<longlongrightarrow> a ?i ?j)\n                     F\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<in> CBasis; j \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> Zfun (\\<lambda>x. cmod (b x i j - a i j)) F", "unfolding tendsto_Zfun_iff Zfun_norm_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> CBasis; ?j \\<in> CBasis\\<rbrakk>\n  \\<Longrightarrow> Zfun (\\<lambda>x. b x ?i ?j - a ?i ?j) F\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<in> CBasis; j \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> Zfun (\\<lambda>x. b x i j - a i j) F", "."], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<in> CBasis; ?j \\<in> CBasis\\<rbrakk>\n  \\<Longrightarrow> Zfun (\\<lambda>x. cmod (b x ?i ?j - a ?i ?j)) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n. cblinfun_of_matrix (b n)) \\<longlongrightarrow>\n     cblinfun_of_matrix a)\n     F", "hence \"Zfun (\\<lambda>x. (\\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. cmod (b x i j - a i j))) F\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> CBasis; ?j \\<in> CBasis\\<rbrakk>\n  \\<Longrightarrow> Zfun (\\<lambda>x. cmod (b x ?i ?j - a ?i ?j)) F\n\ngoal (1 subgoal):\n 1. Zfun\n     (\\<lambda>x.\n         \\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. cmod (b x i j - a i j))\n     F", "by (auto intro!: Zfun_sum)"], ["proof (state)\nthis:\n  Zfun\n   (\\<lambda>x.\n       \\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. cmod (b x i j - a i j))\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n. cblinfun_of_matrix (b n)) \\<longlongrightarrow>\n     cblinfun_of_matrix a)\n     F", "thus ?thesis"], ["proof (prove)\nusing this:\n  Zfun\n   (\\<lambda>x.\n       \\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. cmod (b x i j - a i j))\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n. cblinfun_of_matrix (b n)) \\<longlongrightarrow>\n     cblinfun_of_matrix a)\n     F", "unfolding tendsto_Zfun_iff cblinfun_of_matrix_minus"], ["proof (prove)\nusing this:\n  Zfun\n   (\\<lambda>x.\n       \\<Sum>i\\<in>CBasis. \\<Sum>j\\<in>CBasis. cmod (b x i j - a i j))\n   F\n\ngoal (1 subgoal):\n 1. Zfun (\\<lambda>x. cblinfun_of_matrix (b x - a)) F", "by (rule Zfun_le) (auto intro!: order_trans[OF norm_cblinfun_of_matrix])"], ["proof (state)\nthis:\n  ((\\<lambda>n. cblinfun_of_matrix (b n)) \\<longlongrightarrow>\n   cblinfun_of_matrix a)\n   F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ctendsto_componentwise:\n  fixes a::\"'a::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::ceuclidean_space\"\n    and b::\"'c \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  shows \"(\\<And>i j. i \\<in> CBasis \\<Longrightarrow> j \\<in> CBasis \\<Longrightarrow> ((\\<lambda>n. b n j \\<bullet>\\<^sub>C i) \\<longlongrightarrow> a j \\<bullet>\\<^sub>C i) F) \\<Longrightarrow> (b \\<longlongrightarrow> a) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<in> CBasis; j \\<in> CBasis\\<rbrakk>\n        \\<Longrightarrow> ((\\<lambda>n.\n                               cblinfun_apply (b n) j \\<bullet>\\<^sub>C\n                               i) \\<longlongrightarrow>\n                           cblinfun_apply a j \\<bullet>\\<^sub>C i)\n                           F) \\<Longrightarrow>\n    (b \\<longlongrightarrow> a) F", "apply (subst cblinfun_of_matrix_works[of a, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<in> CBasis; j \\<in> CBasis\\<rbrakk>\n        \\<Longrightarrow> ((\\<lambda>n.\n                               cblinfun_apply (b n) j \\<bullet>\\<^sub>C\n                               i) \\<longlongrightarrow>\n                           cblinfun_apply a j \\<bullet>\\<^sub>C i)\n                           F) \\<Longrightarrow>\n    (b \\<longlongrightarrow>\n     cblinfun_of_matrix\n      (\\<lambda>i j. i \\<bullet>\\<^sub>C cblinfun_apply a j))\n     F", "apply (subst cblinfun_of_matrix_works[of \"b x\" for x, symmetric, abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i \\<in> CBasis; j \\<in> CBasis\\<rbrakk>\n        \\<Longrightarrow> ((\\<lambda>n.\n                               cblinfun_apply (b n) j \\<bullet>\\<^sub>C\n                               i) \\<longlongrightarrow>\n                           cblinfun_apply a j \\<bullet>\\<^sub>C i)\n                           F) \\<Longrightarrow>\n    ((\\<lambda>x.\n         cblinfun_of_matrix\n          (\\<lambda>i j.\n              i \\<bullet>\\<^sub>C\n              cblinfun_apply (b x) j)) \\<longlongrightarrow>\n     cblinfun_of_matrix\n      (\\<lambda>i j. i \\<bullet>\\<^sub>C cblinfun_apply a j))\n     F", "apply (rule tendsto_cblinfun_of_matrix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>i \\<in> CBasis; j \\<in> CBasis\\<rbrakk>\n                   \\<Longrightarrow> ((\\<lambda>n.\n    cblinfun_apply (b n) j \\<bullet>\\<^sub>C i) \\<longlongrightarrow>\ncblinfun_apply a j \\<bullet>\\<^sub>C i)\nF;\n        i \\<in> CBasis; j \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              i \\<bullet>\\<^sub>C\n                              cblinfun_apply (b x) j) \\<longlongrightarrow>\n                          i \\<bullet>\\<^sub>C cblinfun_apply a j)\n                          F", "apply (subst (1) cinner_commute, subst (2) cinner_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>i \\<in> CBasis; j \\<in> CBasis\\<rbrakk>\n                   \\<Longrightarrow> ((\\<lambda>n.\n    cblinfun_apply (b n) j \\<bullet>\\<^sub>C i) \\<longlongrightarrow>\ncblinfun_apply a j \\<bullet>\\<^sub>C i)\nF;\n        i \\<in> CBasis; j \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>x.\n                              cnj (cblinfun_apply (b x) j \\<bullet>\\<^sub>C\n                                   i)) \\<longlongrightarrow>\n                          cnj (cblinfun_apply a j \\<bullet>\\<^sub>C i))\n                          F", "by (metis lim_cnj)"], ["", "lemma\n  continuous_cblinfun_componentwiseI:\n  fixes f:: \"'b::t2_space \\<Rightarrow> 'a::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::ceuclidean_space\"\n  assumes \"\\<And>i j. i \\<in> CBasis \\<Longrightarrow> j \\<in> CBasis \\<Longrightarrow> continuous F (\\<lambda>x. (f x) j \\<bullet>\\<^sub>C i)\"\n  shows \"continuous F f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous F f", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> CBasis; ?j \\<in> CBasis\\<rbrakk>\n  \\<Longrightarrow> continuous F\n                     (\\<lambda>x.\n                         cblinfun_apply (f x) ?j \\<bullet>\\<^sub>C ?i)\n\ngoal (1 subgoal):\n 1. continuous F f", "by (auto simp: continuous_def intro!: ctendsto_componentwise)"], ["", "lemma\n  continuous_cblinfun_componentwiseI1:\n  fixes f:: \"'b::t2_space \\<Rightarrow> 'a::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_normed_vector\"\n  assumes \"\\<And>i. i \\<in> CBasis \\<Longrightarrow> continuous F (\\<lambda>x. f x i)\"\n  shows \"continuous F f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous F f", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> CBasis \\<Longrightarrow>\n  continuous F (\\<lambda>x. cblinfun_apply (f x) ?i)\n\ngoal (1 subgoal):\n 1. continuous F f", "by (auto simp: continuous_def intro!: ctendsto_componentwise1)"], ["", "lemma\n  continuous_on_cblinfun_componentwise:\n  fixes f:: \"'d::t2_space \\<Rightarrow> 'e::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'f::complex_normed_vector\"\n  assumes \"\\<And>i. i \\<in> CBasis \\<Longrightarrow> continuous_on s (\\<lambda>x. f x i)\"\n  shows \"continuous_on s f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on s f", "using assms"], ["proof (prove)\nusing this:\n  ?i \\<in> CBasis \\<Longrightarrow>\n  continuous_on s (\\<lambda>x. cblinfun_apply (f x) ?i)\n\ngoal (1 subgoal):\n 1. continuous_on s f", "by (auto intro!: continuous_at_imp_continuous_on intro!: ctendsto_componentwise1\n      simp: continuous_on_eq_continuous_within continuous_def)"], ["", "lemma bounded_antilinear_cblinfun_matrix: \"bounded_antilinear (\\<lambda>x. (x::_\\<Rightarrow>\\<^sub>C\\<^sub>L _) j \\<bullet>\\<^sub>C i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear (\\<lambda>x. cblinfun_apply x j \\<bullet>\\<^sub>C i)", "by (auto intro!: bounded_linear_intros)"], ["", "lemma continuous_cblinfun_matrix:\n  fixes f:: \"'b::t2_space \\<Rightarrow> 'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_inner\"\n  assumes \"continuous F f\"\n  shows \"continuous F (\\<lambda>x. (f x) j \\<bullet>\\<^sub>C i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous F (\\<lambda>x. cblinfun_apply (f x) j \\<bullet>\\<^sub>C i)", "by (rule bounded_antilinear.continuous[OF bounded_antilinear_cblinfun_matrix assms])"], ["", "lemma continuous_on_cblinfun_matrix:\n  fixes f::\"'a::t2_space \\<Rightarrow> 'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_inner\"\n  assumes \"continuous_on S f\"\n  shows \"continuous_on S (\\<lambda>x. (f x) j \\<bullet>\\<^sub>C i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on S (\\<lambda>x. cblinfun_apply (f x) j \\<bullet>\\<^sub>C i)", "using assms"], ["proof (prove)\nusing this:\n  continuous_on S f\n\ngoal (1 subgoal):\n 1. continuous_on S (\\<lambda>x. cblinfun_apply (f x) j \\<bullet>\\<^sub>C i)", "by (auto simp: continuous_on_eq_continuous_within continuous_cblinfun_matrix)"], ["", "lemma continuous_on_cblinfun_of_matrix[continuous_intros]:\n  assumes \"\\<And>i j. i \\<in> CBasis \\<Longrightarrow> j \\<in> CBasis \\<Longrightarrow> continuous_on S (\\<lambda>s. g s i j)\"\n  shows \"continuous_on S (\\<lambda>s. cblinfun_of_matrix (g s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on S (\\<lambda>s. cblinfun_of_matrix (g s))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> CBasis; ?j \\<in> CBasis\\<rbrakk>\n  \\<Longrightarrow> continuous_on S (\\<lambda>s. g s ?i ?j)\n\ngoal (1 subgoal):\n 1. continuous_on S (\\<lambda>s. cblinfun_of_matrix (g s))", "by (auto simp: continuous_on intro!: tendsto_cblinfun_of_matrix)"], ["", "(* Not specific to complex/real *)\n(* lemma mult_if_delta:\n  \"(if P then (1::'a::comm_semiring_1) else 0) * q = (if P then q else 0)\" *)\n\n(* Needs that ceuclidean_space is heine_borel. This is shown for euclidean_space in Toplogy_Euclidean_Space\n   which has not been ported to complex *)\n(* lemma compact_cblinfun_lemma:\n  fixes f :: \"nat \\<Rightarrow> 'a::ceuclidean_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::ceuclidean_space\"\n  assumes \"bounded (range f)\"\n  shows \"\\<forall>d\\<subseteq>CBasis. \\<exists>l::'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b. \\<exists> r::nat\\<Rightarrow>nat.\n    strict_mono r \\<and> (\\<forall>e>0. eventually (\\<lambda>n. \\<forall>i\\<in>d. dist (f (r n) i) (l i) < e) sequentially)\"\n  apply (rule compact_lemma_general[where unproj = \"\\<lambda>e. cblinfun_of_matrix (\\<lambda>i j. e j \\<bullet>\\<^sub>C i)\"])\n  by (auto intro!: euclidean_eqI[where 'a='b] bounded_linear_image assms\n    simp: blinfun_of_matrix_works blinfun_of_matrix_apply inner_Basis mult_if_delta sum.delta'\n      scaleR_sum_left[symmetric]) *)"], ["", "lemma cblinfun_euclidean_eqI: \"(\\<And>i. i \\<in> CBasis \\<Longrightarrow> cblinfun_apply x i = cblinfun_apply y i) \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> CBasis \\<Longrightarrow>\n        cblinfun_apply x i = cblinfun_apply y i) \\<Longrightarrow>\n    x = y", "apply (auto intro!: cblinfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<And>i.\n           i \\<in> CBasis \\<Longrightarrow>\n           cblinfun_apply x i = cblinfun_apply y i) \\<Longrightarrow>\n       cblinfun_apply x i = cblinfun_apply y i", "apply (subst (2) ceuclidean_representation[symmetric, where 'a='a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<And>i.\n           i \\<in> CBasis \\<Longrightarrow>\n           cblinfun_apply x i = cblinfun_apply y i) \\<Longrightarrow>\n       cblinfun_apply x i =\n       cblinfun_apply y\n        (\\<Sum>b\\<in>CBasis. (b \\<bullet>\\<^sub>C i) *\\<^sub>C b)", "apply (subst (1) ceuclidean_representation[symmetric, where 'a='a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (\\<And>i.\n           i \\<in> CBasis \\<Longrightarrow>\n           cblinfun_apply x i = cblinfun_apply y i) \\<Longrightarrow>\n       cblinfun_apply x\n        (\\<Sum>b\\<in>CBasis. (b \\<bullet>\\<^sub>C i) *\\<^sub>C b) =\n       cblinfun_apply y\n        (\\<Sum>b\\<in>CBasis. (b \\<bullet>\\<^sub>C i) *\\<^sub>C b)", "by (simp add: cblinfun.cbilinear_simps)"], ["", "lemma CBlinfun_eq_matrix: \"bounded_clinear f \\<Longrightarrow> CBlinfun f = cblinfun_of_matrix (\\<lambda>i j. i \\<bullet>\\<^sub>C f j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear f \\<Longrightarrow>\n    CBlinfun f = cblinfun_of_matrix (\\<lambda>i j. i \\<bullet>\\<^sub>C f j)", "apply (intro cblinfun_euclidean_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>bounded_clinear f; i \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> cblinfun_apply (CBlinfun f) i =\n                         cblinfun_apply\n                          (cblinfun_of_matrix\n                            (\\<lambda>i j. i \\<bullet>\\<^sub>C f j))\n                          i", "by (auto simp: cblinfun_of_matrix_apply bounded_clinear_CBlinfun_apply cinner_CBasis if_distrib\n      if_distribR sum.delta' ceuclidean_representation\n      cong: if_cong)"], ["", "(* Conflicts with: cblinfun :: (complex_normed_vector, cbanach) complete_space *)\n(* instance cblinfun :: (ceuclidean_space, ceuclidean_space) heine_borel *)"], ["", "subsection\\<^marker>\\<open>tag unimportant\\<close> \\<open>concrete bounded linear functions\\<close>"], ["", "lemma transfer_bounded_cbilinear_bounded_clinearI:\n  assumes \"g = (\\<lambda>i x. (cblinfun_apply (f i) x))\"\n  shows \"bounded_cbilinear g = bounded_clinear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_cbilinear g = bounded_clinear f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. bounded_cbilinear g \\<Longrightarrow> bounded_clinear f\n 2. bounded_clinear f \\<Longrightarrow> bounded_cbilinear g", "assume \"bounded_cbilinear g\""], ["proof (state)\nthis:\n  bounded_cbilinear g\n\ngoal (2 subgoals):\n 1. bounded_cbilinear g \\<Longrightarrow> bounded_clinear f\n 2. bounded_clinear f \\<Longrightarrow> bounded_cbilinear g", "then"], ["proof (chain)\npicking this:\n  bounded_cbilinear g", "interpret bounded_cbilinear f"], ["proof (prove)\nusing this:\n  bounded_cbilinear g\n\ngoal (1 subgoal):\n 1. bounded_cbilinear (\\<lambda>x. cblinfun_apply (f x))", "by (simp add: assms)"], ["proof (state)\ngoal (2 subgoals):\n 1. bounded_cbilinear g \\<Longrightarrow> bounded_clinear f\n 2. bounded_clinear f \\<Longrightarrow> bounded_cbilinear g", "show \"bounded_clinear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear f", "proof (unfold_locales, safe intro!: cblinfun_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2 i.\n       cblinfun_apply (f (b1 + b2)) i = cblinfun_apply (f b1 + f b2) i\n 2. \\<And>r b i.\n       cblinfun_apply (f (r *\\<^sub>C b)) i =\n       cblinfun_apply (r *\\<^sub>C f b) i\n 3. \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2 i.\n       cblinfun_apply (f (b1 + b2)) i = cblinfun_apply (f b1 + f b2) i\n 2. \\<And>r b i.\n       cblinfun_apply (f (r *\\<^sub>C b)) i =\n       cblinfun_apply (r *\\<^sub>C f b) i\n 3. \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "show \"f (x + y) i = (f x + f y) i\" \"f (r *\\<^sub>C x) i = (r *\\<^sub>C f x) i\" for r x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_apply (f (x + y)) i = cblinfun_apply (f x + f y) i &&&\n    cblinfun_apply (f (r *\\<^sub>C x)) i =\n    cblinfun_apply (r *\\<^sub>C f x) i", "by (auto intro!: cblinfun_eqI simp: cblinfun.cbilinear_simps)"], ["proof (state)\nthis:\n  cblinfun_apply (f (?x + ?y)) i = cblinfun_apply (f ?x + f ?y) i\n  cblinfun_apply (f (?r *\\<^sub>C ?x)) i =\n  cblinfun_apply (?r *\\<^sub>C f ?x) i\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "from _ nonneg_bounded"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  \\<exists>K\\<ge>0.\n     \\<forall>a b. norm (cblinfun_apply (f a) b) \\<le> norm a * norm b * K", "show \"\\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  \\<exists>K\\<ge>0.\n     \\<forall>a b. norm (cblinfun_apply (f a) b) \\<le> norm a * norm b * K\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "by (rule ex_reg) (auto intro!: onorm_bound simp: norm_cblinfun.rep_eq ac_simps)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bounded_clinear f\n\ngoal (1 subgoal):\n 1. bounded_clinear f \\<Longrightarrow> bounded_cbilinear g", "qed (auto simp: assms intro!: cblinfun.comp)"], ["", "lemma transfer_bounded_cbilinear_bounded_clinear[transfer_rule]:\n  \"(rel_fun (rel_fun (=) (pcr_cblinfun (=) (=))) (=)) bounded_cbilinear bounded_clinear\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_fun (=) (pcr_cblinfun (=) (=))) (=) bounded_cbilinear\n     bounded_clinear", "by (auto simp: pcr_cblinfun_def cr_cblinfun_def rel_fun_def OO_def\n      intro!: transfer_bounded_cbilinear_bounded_clinearI)"], ["", "(* Not present in Bounded_Linear_Function *)"], ["", "lemma transfer_bounded_sesquilinear_bounded_antilinearI:\n  assumes \"g = (\\<lambda>i x. (cblinfun_apply (f i) x))\"\n  shows \"bounded_sesquilinear g = bounded_antilinear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_sesquilinear g = bounded_antilinear f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. bounded_sesquilinear g \\<Longrightarrow> bounded_antilinear f\n 2. bounded_antilinear f \\<Longrightarrow> bounded_sesquilinear g", "assume \"bounded_sesquilinear g\""], ["proof (state)\nthis:\n  bounded_sesquilinear g\n\ngoal (2 subgoals):\n 1. bounded_sesquilinear g \\<Longrightarrow> bounded_antilinear f\n 2. bounded_antilinear f \\<Longrightarrow> bounded_sesquilinear g", "then"], ["proof (chain)\npicking this:\n  bounded_sesquilinear g", "interpret bounded_sesquilinear f"], ["proof (prove)\nusing this:\n  bounded_sesquilinear g\n\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x. cblinfun_apply (f x))", "by (simp add: assms)"], ["proof (state)\ngoal (2 subgoals):\n 1. bounded_sesquilinear g \\<Longrightarrow> bounded_antilinear f\n 2. bounded_antilinear f \\<Longrightarrow> bounded_sesquilinear g", "show \"bounded_antilinear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear f", "proof (unfold_locales, safe intro!: cblinfun_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y i. cblinfun_apply (f (x + y)) i = cblinfun_apply (f x + f y) i\n 2. \\<And>r x i.\n       cblinfun_apply (f (r *\\<^sub>C x)) i =\n       cblinfun_apply (cnj r *\\<^sub>C f x) i\n 3. \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y i. cblinfun_apply (f (x + y)) i = cblinfun_apply (f x + f y) i\n 2. \\<And>r x i.\n       cblinfun_apply (f (r *\\<^sub>C x)) i =\n       cblinfun_apply (cnj r *\\<^sub>C f x) i\n 3. \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "show \"f (x + y) i = (f x + f y) i\" \"f (r *\\<^sub>C x) i = (cnj r *\\<^sub>C f x) i\" for r x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_apply (f (x + y)) i = cblinfun_apply (f x + f y) i &&&\n    cblinfun_apply (f (r *\\<^sub>C x)) i =\n    cblinfun_apply (cnj r *\\<^sub>C f x) i", "by (auto intro!: cblinfun_eqI simp: cblinfun.scaleC_left scaleC_left add_left cblinfun.add_left)"], ["proof (state)\nthis:\n  cblinfun_apply (f (?x + ?y)) i = cblinfun_apply (f ?x + f ?y) i\n  cblinfun_apply (f (?r *\\<^sub>C ?x)) i =\n  cblinfun_apply (cnj ?r *\\<^sub>C f ?x) i\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "from _ nonneg_bounded"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  \\<exists>K\\<ge>0.\n     \\<forall>a b. norm (cblinfun_apply (f a) b) \\<le> norm a * norm b * K", "show \"\\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  \\<exists>K\\<ge>0.\n     \\<forall>a b. norm (cblinfun_apply (f a) b) \\<le> norm a * norm b * K\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "by (rule ex_reg) (auto intro!: onorm_bound simp: norm_cblinfun.rep_eq ac_simps)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bounded_antilinear f\n\ngoal (1 subgoal):\n 1. bounded_antilinear f \\<Longrightarrow> bounded_sesquilinear g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_antilinear f \\<Longrightarrow> bounded_sesquilinear g", "assume \"bounded_antilinear f\""], ["proof (state)\nthis:\n  bounded_antilinear f\n\ngoal (1 subgoal):\n 1. bounded_antilinear f \\<Longrightarrow> bounded_sesquilinear g", "then"], ["proof (chain)\npicking this:\n  bounded_antilinear f", "obtain K where K: \\<open>norm (f x) \\<le> norm x * K\\<close> for x"], ["proof (prove)\nusing this:\n  bounded_antilinear f\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        (\\<And>x. norm (f x) \\<le> norm x * K) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using bounded_antilinear.bounded"], ["proof (prove)\nusing this:\n  bounded_antilinear f\n  bounded_antilinear ?f \\<Longrightarrow>\n  \\<exists>K. \\<forall>x. norm (?f x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        (\\<And>x. norm (f x) \\<le> norm x * K) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  norm (f ?x) \\<le> norm ?x * K\n\ngoal (1 subgoal):\n 1. bounded_antilinear f \\<Longrightarrow> bounded_sesquilinear g", "have \\<open>norm (cblinfun_apply (f a) b) \\<le> norm (f a) * norm b\\<close> for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (cblinfun_apply (f a) b) \\<le> norm (f a) * norm b", "by (simp add: norm_cblinfun)"], ["proof (state)\nthis:\n  norm (cblinfun_apply (f ?a) ?b) \\<le> norm (f ?a) * norm ?b\n\ngoal (1 subgoal):\n 1. bounded_antilinear f \\<Longrightarrow> bounded_sesquilinear g", "also"], ["proof (state)\nthis:\n  norm (cblinfun_apply (f ?a) ?b) \\<le> norm (f ?a) * norm ?b\n\ngoal (1 subgoal):\n 1. bounded_antilinear f \\<Longrightarrow> bounded_sesquilinear g", "have \\<open>\\<dots> a b \\<le> norm a * norm b * K\\<close> for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (f a) * norm b \\<le> norm a * norm b * K", "by (smt (verit, best) K mult.assoc mult.commute mult_mono' norm_ge_zero)"], ["proof (state)\nthis:\n  norm (f ?a) * norm ?b \\<le> norm ?a * norm ?b * K\n\ngoal (1 subgoal):\n 1. bounded_antilinear f \\<Longrightarrow> bounded_sesquilinear g", "finally"], ["proof (chain)\npicking this:\n  norm (cblinfun_apply (f ?a1) ?b1) \\<le> norm ?a1 * norm ?b1 * K", "have *: \\<open>norm (cblinfun_apply (f a) b) \\<le> norm a * norm b * K\\<close> for a b"], ["proof (prove)\nusing this:\n  norm (cblinfun_apply (f ?a1) ?b1) \\<le> norm ?a1 * norm ?b1 * K\n\ngoal (1 subgoal):\n 1. norm (cblinfun_apply (f a) b) \\<le> norm a * norm b * K", "by simp"], ["proof (state)\nthis:\n  norm (cblinfun_apply (f ?a) ?b) \\<le> norm ?a * norm ?b * K\n\ngoal (1 subgoal):\n 1. bounded_antilinear f \\<Longrightarrow> bounded_sesquilinear g", "show \"bounded_sesquilinear g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_sesquilinear g", "using \\<open>bounded_antilinear f\\<close>"], ["proof (prove)\nusing this:\n  bounded_antilinear f\n\ngoal (1 subgoal):\n 1. bounded_sesquilinear g", "apply (auto intro!: bounded_sesquilinear.intro simp: assms cblinfun.add_left cblinfun.add_right \n        linear_simps bounded_antilinear.bounded_linear antilinear.scaleC bounded_antilinear.antilinear\n        cblinfun.scaleC_left cblinfun.scaleC_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear f \\<Longrightarrow>\n    \\<exists>K.\n       \\<forall>a b. norm (cblinfun_apply (f a) b) \\<le> norm a * norm b * K", "using *"], ["proof (prove)\nusing this:\n  norm (cblinfun_apply (f ?a) ?b) \\<le> norm ?a * norm ?b * K\n\ngoal (1 subgoal):\n 1. bounded_antilinear f \\<Longrightarrow>\n    \\<exists>K.\n       \\<forall>a b. norm (cblinfun_apply (f a) b) \\<le> norm a * norm b * K", "by blast"], ["proof (state)\nthis:\n  bounded_sesquilinear g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transfer_bounded_sesquilinear_bounded_antilinear[transfer_rule]:\n  \"(rel_fun (rel_fun (=) (pcr_cblinfun (=) (=))) (=)) bounded_sesquilinear bounded_antilinear\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_fun (=) (pcr_cblinfun (=) (=))) (=) bounded_sesquilinear\n     bounded_antilinear", "by (auto simp: pcr_cblinfun_def cr_cblinfun_def rel_fun_def OO_def\n      intro!: transfer_bounded_sesquilinear_bounded_antilinearI)"], ["", "context bounded_cbilinear\nbegin"], ["", "lift_definition prod_left::\"'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'c\" is \"(\\<lambda>b a. prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. bounded_clinear (\\<lambda>a. a ** b)", "by (rule bounded_clinear_left)"], ["", "declare prod_left.rep_eq[simp]"], ["", "lemma bounded_clinear_prod_left[bounded_clinear]: \"bounded_clinear prod_left\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear prod_left", "by transfer (rule flip)"], ["", "lift_definition prod_right::\"'a \\<Rightarrow> 'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'c\" is \"(\\<lambda>a b. prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. bounded_clinear ((**) a)", "by (rule bounded_clinear_right)"], ["", "declare prod_right.rep_eq[simp]"], ["", "lemma bounded_clinear_prod_right[bounded_clinear]: \"bounded_clinear prod_right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear prod_right", "by transfer (rule bounded_cbilinear_axioms)"], ["", "end"], ["", "lift_definition id_cblinfun::\"'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\" is \"\\<lambda>x. x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. x)", "by (rule bounded_clinear_ident)"], ["", "lemmas cblinfun_id_cblinfun_apply[simp] = id_cblinfun.rep_eq"], ["", "(* Strong than norm_blinfun_id because we replaced the perfect_space typeclass by not_singleton *)"], ["", "lemma norm_cblinfun_id[simp]:\n  \"norm (id_cblinfun::'a::{complex_normed_vector, not_singleton} \\<Rightarrow>\\<^sub>C\\<^sub>L 'a) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm id_cblinfun = 1", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. x) = 1", "apply (rule onorm_id[internalize_sort' 'a])"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.real_normed_vector (-) dist norm (+) (0::'a) uminus (*\\<^sub>R)\n     sgn uniformity open\n 2. class.perfect_space open", "apply standard[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.perfect_space open", "by simp"], ["", "lemma norm_blinfun_id_le:\n  \"norm (id_cblinfun::'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'a) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm id_cblinfun \\<le> 1", "by transfer (auto simp: onorm_id_le)"], ["", "(* Skipped because we do not have \"prod :: (cbanach, cbanach) cbanach\" (Product_Vector not ported to complex)*)\n(* lift_definition fst_cblinfun::\"('a::complex_normed_vector \\<times> 'b::complex_normed_vector) \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\" is fst *)\n\n(* lemma cblinfun_apply_fst_cblinfun[simp]: \"cblinfun_apply fst_cblinfun = fst\" *)\n\n(* lift_definition snd_cblinfun::\"('a::complex_normed_vector \\<times> 'b::complex_normed_vector) \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\" is snd *)\n\n(* lemma blinfun_apply_snd_blinfun[simp]: \"blinfun_apply snd_blinfun = snd\" *)"], ["", "lift_definition cblinfun_compose::\n  \"'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector \\<Rightarrow>\n    'c::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'a \\<Rightarrow>\n    'c \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\" (infixl \"o\\<^sub>C\\<^sub>L\" 55) is \"(o)\"\n  parametric comp_transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>bounded_clinear fun1; bounded_clinear fun2\\<rbrakk>\n       \\<Longrightarrow> bounded_clinear (fun1 \\<circ> fun2)", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>bounded_clinear fun1; bounded_clinear fun2\\<rbrakk>\n       \\<Longrightarrow> bounded_clinear (\\<lambda>x. fun1 (fun2 x))", "by (rule bounded_clinear_compose)"], ["", "lemma cblinfun_apply_cblinfun_compose[simp]: \"(a o\\<^sub>C\\<^sub>L b) c = a (b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_apply (a o\\<^sub>C\\<^sub>L b) c =\n    cblinfun_apply a (cblinfun_apply b c)", "by (simp add: cblinfun_compose.rep_eq)"], ["", "lemma norm_cblinfun_compose:\n  \"norm (f o\\<^sub>C\\<^sub>L g) \\<le> norm f * norm g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (f o\\<^sub>C\\<^sub>L g) \\<le> norm f * norm g", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>bounded_clinear f; bounded_clinear g\\<rbrakk>\n       \\<Longrightarrow> onorm (f \\<circ> g) \\<le> onorm f * onorm g", "by (auto intro!: onorm_compose simp: bounded_clinear.bounded_linear)"], ["", "lemma bounded_cbilinear_cblinfun_compose[bounded_cbilinear]: \"bounded_cbilinear (o\\<^sub>C\\<^sub>L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_cbilinear (o\\<^sub>C\\<^sub>L)", "by unfold_locales\n    (auto intro!: cblinfun_eqI exI[where x=1] simp: cblinfun.cbilinear_simps norm_cblinfun_compose)"], ["", "lemma cblinfun_compose_zero[simp]:\n  \"blinfun_compose 0 = (\\<lambda>_. 0)\"\n  \"blinfun_compose x 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (o\\<^sub>L) 0 = (\\<lambda>_. 0) &&& x o\\<^sub>L 0 = 0", "by (auto simp: blinfun.bilinear_simps intro!: blinfun_eqI)"], ["", "lemma cblinfun_bij2:\n  fixes f::\"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::ceuclidean_space\"\n  assumes \"f o\\<^sub>C\\<^sub>L g = id_cblinfun\"\n  shows \"bij (cblinfun_apply g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (cblinfun_apply g)", "proof (rule bijI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj (cblinfun_apply g)\n 2. surj (cblinfun_apply g)", "show \"inj g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (cblinfun_apply g)", "using assms"], ["proof (prove)\nusing this:\n  f o\\<^sub>C\\<^sub>L g = id_cblinfun\n\ngoal (1 subgoal):\n 1. inj (cblinfun_apply g)", "by (metis cblinfun_id_cblinfun_apply cblinfun_compose.rep_eq injI inj_on_imageI2)"], ["proof (state)\nthis:\n  inj (cblinfun_apply g)\n\ngoal (1 subgoal):\n 1. surj (cblinfun_apply g)", "then"], ["proof (chain)\npicking this:\n  inj (cblinfun_apply g)", "show \"surj g\""], ["proof (prove)\nusing this:\n  inj (cblinfun_apply g)\n\ngoal (1 subgoal):\n 1. surj (cblinfun_apply g)", "using bounded_clinear_def cblinfun.bounded_clinear_right ceucl.linear_inj_imp_surj"], ["proof (prove)\nusing this:\n  inj (cblinfun_apply g)\n  bounded_clinear ?f \\<equiv> clinear ?f \\<and> bounded_clinear_axioms ?f\n  bounded_clinear (cblinfun_apply ?a)\n  \\<lbrakk>clinear ?f; inj ?f\\<rbrakk> \\<Longrightarrow> surj ?f\n\ngoal (1 subgoal):\n 1. surj (cblinfun_apply g)", "by blast"], ["proof (state)\nthis:\n  surj (cblinfun_apply g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_bij1:\n  fixes f::\"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::ceuclidean_space\"\n  assumes \"f o\\<^sub>C\\<^sub>L g = id_cblinfun\"\n  shows \"bij (cblinfun_apply f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (cblinfun_apply f)", "proof (rule bijI)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj (cblinfun_apply f)\n 2. surj (cblinfun_apply f)", "show \"surj (cblinfun_apply f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj (cblinfun_apply f)", "by (metis assms cblinfun_apply_cblinfun_compose cblinfun_id_cblinfun_apply surjI)"], ["proof (state)\nthis:\n  surj (cblinfun_apply f)\n\ngoal (1 subgoal):\n 1. inj (cblinfun_apply f)", "then"], ["proof (chain)\npicking this:\n  surj (cblinfun_apply f)", "show \"inj (cblinfun_apply f)\""], ["proof (prove)\nusing this:\n  surj (cblinfun_apply f)\n\ngoal (1 subgoal):\n 1. inj (cblinfun_apply f)", "using bounded_clinear_def cblinfun.bounded_clinear_right ceucl.linear_surjective_imp_injective"], ["proof (prove)\nusing this:\n  surj (cblinfun_apply f)\n  bounded_clinear ?f \\<equiv> clinear ?f \\<and> bounded_clinear_axioms ?f\n  bounded_clinear (cblinfun_apply ?a)\n  \\<lbrakk>clinear ?f; surj ?f; cdim UNIV = cdim UNIV\\<rbrakk>\n  \\<Longrightarrow> inj ?f\n\ngoal (1 subgoal):\n 1. inj (cblinfun_apply f)", "by blast"], ["proof (state)\nthis:\n  inj (cblinfun_apply f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition cblinfun_cinner_right::\"'a::complex_inner \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L complex\" is \"(\\<bullet>\\<^sub>C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. bounded_clinear ((\\<bullet>\\<^sub>C) a)", "by (rule bounded_clinear_cinner_right)"], ["", "declare cblinfun_cinner_right.rep_eq[simp]"], ["", "lemma bounded_antilinear_cblinfun_cinner_right[bounded_antilinear]: \"bounded_antilinear cblinfun_cinner_right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear cblinfun_cinner_right", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<bullet>\\<^sub>C)", "by (simp add: bounded_sesquilinear_cinner)"], ["", "(* Cannot be defined. cinner is antilinear in first argument. *)\n(* lift_definition cblinfun_cinner_left::\"'a::complex_inner \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L complex\" is \"\\<lambda>x y. y \\<bullet>\\<^sub>C x\" *)\n(* declare cblinfun_cinner_left.rep_eq[simp] *)\n\n(* lemma bounded_clinear_cblinfun_cinner_left[bounded_clinear]: \"bounded_clinear cblinfun_cinner_left\" *)"], ["", "lift_definition cblinfun_scaleC_right::\"complex \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::complex_normed_vector\" is \"(*\\<^sub>C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>complex. bounded_clinear ((*\\<^sub>C) complex)", "by (rule bounded_clinear_scaleC_right)"], ["", "declare cblinfun_scaleC_right.rep_eq[simp]"], ["", "lemma bounded_clinear_cblinfun_scaleC_right[bounded_clinear]: \"bounded_clinear cblinfun_scaleC_right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear cblinfun_scaleC_right", "by transfer (rule bounded_cbilinear_scaleC)"], ["", "lift_definition cblinfun_scaleC_left::\"'a::complex_normed_vector \\<Rightarrow> complex \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\" is \"\\<lambda>x y. y *\\<^sub>C x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. bounded_clinear (\\<lambda>y. y *\\<^sub>C a)", "by (rule bounded_clinear_scaleC_left)"], ["", "lemmas [simp] = cblinfun_scaleC_left.rep_eq"], ["", "lemma bounded_clinear_cblinfun_scaleC_left[bounded_clinear]: \"bounded_clinear cblinfun_scaleC_left\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear cblinfun_scaleC_left", "by transfer (rule bounded_cbilinear.flip[OF bounded_cbilinear_scaleC])"], ["", "lift_definition cblinfun_mult_right::\"'a \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::complex_normed_algebra\" is \"(*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. bounded_clinear ((*) a)", "by (rule bounded_clinear_mult_right)"], ["", "declare cblinfun_mult_right.rep_eq[simp]"], ["", "lemma bounded_clinear_cblinfun_mult_right[bounded_clinear]: \"bounded_clinear cblinfun_mult_right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear cblinfun_mult_right", "by transfer (rule bounded_cbilinear_mult)"], ["", "lift_definition cblinfun_mult_left::\"'a::complex_normed_algebra \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\" is \"\\<lambda>x y. y * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. bounded_clinear (\\<lambda>y. y * a)", "by (rule bounded_clinear_mult_left)"], ["", "lemmas [simp] = cblinfun_mult_left.rep_eq"], ["", "lemma bounded_clinear_cblinfun_mult_left[bounded_clinear]: \"bounded_clinear cblinfun_mult_left\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear cblinfun_mult_left", "by transfer (rule bounded_cbilinear.flip[OF bounded_cbilinear_mult])"], ["", "lemmas bounded_clinear_function_uniform_limit_intros[uniform_limit_intros] =\n  bounded_clinear.uniform_limit[OF bounded_clinear_apply_cblinfun]\n  bounded_clinear.uniform_limit[OF bounded_clinear_cblinfun_apply]\n  bounded_antilinear.uniform_limit[OF bounded_antilinear_cblinfun_matrix]"], ["", "subsection \\<open>The strong operator topology on continuous linear operators\\<close>"], ["", "text \\<open>Let \\<open>'a\\<close> and \\<open>'b\\<close> be two normed real vector spaces. Then the space of linear continuous\noperators from \\<open>'a\\<close> to \\<open>'b\\<close> has a canonical norm, and therefore a canonical corresponding topology\n(the type classes instantiation are given in \\<^file>\\<open>Complex_Bounded_Linear_Function0.thy\\<close>).\n\nHowever, there is another topology on this space, the strong operator topology, where \\<open>T\\<^sub>n\\<close> tends to\n\\<open>T\\<close> iff, for all \\<open>x\\<close> in \\<open>'a\\<close>, then \\<open>T\\<^sub>n x\\<close> tends to \\<open>T x\\<close>. This is precisely the product topology\nwhere the target space is endowed with the norm topology. It is especially useful when \\<open>'b\\<close> is the set\nof real numbers, since then this topology is compact.\n\nWe can not implement it using type classes as there is already a topology, but at least we\ncan define it as a topology.\n\nNote that there is yet another (common and useful) topology on operator spaces, the weak operator\ntopology, defined analogously using the product topology, but where the target space is given the\nweak-* topology, i.e., the pullback of the weak topology on the bidual of the space under the\ncanonical embedding of a space into its bidual. We do not define it there, although it could also be\ndefined analogously.\n\\<close>"], ["", "definition\\<^marker>\\<open>tag important\\<close> cstrong_operator_topology::\"('a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L'b::complex_normed_vector) topology\"\n  where \"cstrong_operator_topology = pullback_topology UNIV cblinfun_apply euclidean\""], ["", "lemma cstrong_operator_topology_topspace:\n  \"topspace cstrong_operator_topology = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. topspace cstrong_operator_topology = UNIV", "unfolding cstrong_operator_topology_def topspace_pullback_topology topspace_euclidean"], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_apply -` UNIV \\<inter> UNIV = UNIV", "by auto"], ["", "lemma cstrong_operator_topology_basis:\n  fixes f::\"('a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L'b::complex_normed_vector)\" and U::\"'i \\<Rightarrow> 'b set\" and x::\"'i \\<Rightarrow> 'a\"\n  assumes \"finite I\" \"\\<And>i. i \\<in> I \\<Longrightarrow> open (U i)\"\n  shows \"openin cstrong_operator_topology {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. openin cstrong_operator_topology\n     {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. openin cstrong_operator_topology\n     {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i}", "have \"open {g::('a\\<Rightarrow>'b). \\<forall>i\\<in>I. g (x i) \\<in> U i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open {g. \\<forall>i\\<in>I. g (x i) \\<in> U i}", "by (rule product_topology_basis'[OF assms])"], ["proof (state)\nthis:\n  open {g. \\<forall>i\\<in>I. g (x i) \\<in> U i}\n\ngoal (1 subgoal):\n 1. openin cstrong_operator_topology\n     {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i}", "moreover"], ["proof (state)\nthis:\n  open {g. \\<forall>i\\<in>I. g (x i) \\<in> U i}\n\ngoal (1 subgoal):\n 1. openin cstrong_operator_topology\n     {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i}", "have \"{f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i}\n                = cblinfun_apply-`{g::('a\\<Rightarrow>'b). \\<forall>i\\<in>I. g (x i) \\<in> U i} \\<inter> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i} =\n    cblinfun_apply -` {g. \\<forall>i\\<in>I. g (x i) \\<in> U i} \\<inter> UNIV", "by auto"], ["proof (state)\nthis:\n  {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i} =\n  cblinfun_apply -` {g. \\<forall>i\\<in>I. g (x i) \\<in> U i} \\<inter> UNIV\n\ngoal (1 subgoal):\n 1. openin cstrong_operator_topology\n     {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i}", "ultimately"], ["proof (chain)\npicking this:\n  open {g. \\<forall>i\\<in>I. g (x i) \\<in> U i}\n  {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i} =\n  cblinfun_apply -` {g. \\<forall>i\\<in>I. g (x i) \\<in> U i} \\<inter> UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  open {g. \\<forall>i\\<in>I. g (x i) \\<in> U i}\n  {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i} =\n  cblinfun_apply -` {g. \\<forall>i\\<in>I. g (x i) \\<in> U i} \\<inter> UNIV\n\ngoal (1 subgoal):\n 1. openin cstrong_operator_topology\n     {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i}", "unfolding cstrong_operator_topology_def"], ["proof (prove)\nusing this:\n  open {g. \\<forall>i\\<in>I. g (x i) \\<in> U i}\n  {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i} =\n  cblinfun_apply -` {g. \\<forall>i\\<in>I. g (x i) \\<in> U i} \\<inter> UNIV\n\ngoal (1 subgoal):\n 1. openin (pullback_topology UNIV cblinfun_apply euclidean)\n     {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i}", "by (subst openin_pullback_topology) auto"], ["proof (state)\nthis:\n  openin cstrong_operator_topology\n   {f. \\<forall>i\\<in>I. cblinfun_apply f (x i) \\<in> U i}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cstrong_operator_topology_continuous_evaluation:\n  \"continuous_map cstrong_operator_topology euclidean (\\<lambda>f. cblinfun_apply f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map cstrong_operator_topology euclidean\n     (\\<lambda>f. cblinfun_apply f x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_map cstrong_operator_topology euclidean\n     (\\<lambda>f. cblinfun_apply f x)", "have \"continuous_map cstrong_operator_topology euclidean ((\\<lambda>f. f x) o cblinfun_apply)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map cstrong_operator_topology euclidean\n     ((\\<lambda>f. f x) \\<circ> cblinfun_apply)", "unfolding cstrong_operator_topology_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map (pullback_topology UNIV cblinfun_apply euclidean)\n     euclidean ((\\<lambda>f. f x) \\<circ> cblinfun_apply)", "apply (rule continuous_map_pullback)"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map euclidean euclidean (\\<lambda>f. f x)", "using continuous_on_product_coordinates"], ["proof (prove)\nusing this:\n  continuous_on UNIV (\\<lambda>x. x ?i)\n\ngoal (1 subgoal):\n 1. continuous_map euclidean euclidean (\\<lambda>f. f x)", "by fastforce"], ["proof (state)\nthis:\n  continuous_map cstrong_operator_topology euclidean\n   ((\\<lambda>f. f x) \\<circ> cblinfun_apply)\n\ngoal (1 subgoal):\n 1. continuous_map cstrong_operator_topology euclidean\n     (\\<lambda>f. cblinfun_apply f x)", "then"], ["proof (chain)\npicking this:\n  continuous_map cstrong_operator_topology euclidean\n   ((\\<lambda>f. f x) \\<circ> cblinfun_apply)", "show ?thesis"], ["proof (prove)\nusing this:\n  continuous_map cstrong_operator_topology euclidean\n   ((\\<lambda>f. f x) \\<circ> cblinfun_apply)\n\ngoal (1 subgoal):\n 1. continuous_map cstrong_operator_topology euclidean\n     (\\<lambda>f. cblinfun_apply f x)", "unfolding comp_def"], ["proof (prove)\nusing this:\n  continuous_map cstrong_operator_topology euclidean\n   (\\<lambda>xa. cblinfun_apply xa x)\n\ngoal (1 subgoal):\n 1. continuous_map cstrong_operator_topology euclidean\n     (\\<lambda>f. cblinfun_apply f x)", "by simp"], ["proof (state)\nthis:\n  continuous_map cstrong_operator_topology euclidean\n   (\\<lambda>f. cblinfun_apply f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_on_cstrong_operator_topo_iff_coordinatewise:\n  \"continuous_map T cstrong_operator_topology f\n    \\<longleftrightarrow> (\\<forall>x. continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map T cstrong_operator_topology f =\n    (\\<forall>x.\n        continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x))", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       continuous_map T cstrong_operator_topology f \\<Longrightarrow>\n       continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x)\n 2. \\<forall>x.\n       continuous_map T euclidean\n        (\\<lambda>y. cblinfun_apply (f y) x) \\<Longrightarrow>\n    continuous_map T cstrong_operator_topology f", "fix x::\"'b\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       continuous_map T cstrong_operator_topology f \\<Longrightarrow>\n       continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x)\n 2. \\<forall>x.\n       continuous_map T euclidean\n        (\\<lambda>y. cblinfun_apply (f y) x) \\<Longrightarrow>\n    continuous_map T cstrong_operator_topology f", "assume \"continuous_map T cstrong_operator_topology f\""], ["proof (state)\nthis:\n  continuous_map T cstrong_operator_topology f\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       continuous_map T cstrong_operator_topology f \\<Longrightarrow>\n       continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x)\n 2. \\<forall>x.\n       continuous_map T euclidean\n        (\\<lambda>y. cblinfun_apply (f y) x) \\<Longrightarrow>\n    continuous_map T cstrong_operator_topology f", "with continuous_map_compose[OF this cstrong_operator_topology_continuous_evaluation]"], ["proof (chain)\npicking this:\n  continuous_map T euclidean ((\\<lambda>f. cblinfun_apply f ?x1) \\<circ> f)\n  continuous_map T cstrong_operator_topology f", "have \"continuous_map T euclidean ((\\<lambda>z. cblinfun_apply z x) o f)\""], ["proof (prove)\nusing this:\n  continuous_map T euclidean ((\\<lambda>f. cblinfun_apply f ?x1) \\<circ> f)\n  continuous_map T cstrong_operator_topology f\n\ngoal (1 subgoal):\n 1. continuous_map T euclidean ((\\<lambda>z. cblinfun_apply z x) \\<circ> f)", "by simp"], ["proof (state)\nthis:\n  continuous_map T euclidean ((\\<lambda>z. cblinfun_apply z x) \\<circ> f)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       continuous_map T cstrong_operator_topology f \\<Longrightarrow>\n       continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x)\n 2. \\<forall>x.\n       continuous_map T euclidean\n        (\\<lambda>y. cblinfun_apply (f y) x) \\<Longrightarrow>\n    continuous_map T cstrong_operator_topology f", "then"], ["proof (chain)\npicking this:\n  continuous_map T euclidean ((\\<lambda>z. cblinfun_apply z x) \\<circ> f)", "show \"continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x)\""], ["proof (prove)\nusing this:\n  continuous_map T euclidean ((\\<lambda>z. cblinfun_apply z x) \\<circ> f)\n\ngoal (1 subgoal):\n 1. continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x)", "unfolding comp_def"], ["proof (prove)\nusing this:\n  continuous_map T euclidean (\\<lambda>xa. cblinfun_apply (f xa) x)\n\ngoal (1 subgoal):\n 1. continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x)", "by auto"], ["proof (state)\nthis:\n  continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       continuous_map T euclidean\n        (\\<lambda>y. cblinfun_apply (f y) x) \\<Longrightarrow>\n    continuous_map T cstrong_operator_topology f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       continuous_map T euclidean\n        (\\<lambda>y. cblinfun_apply (f y) x) \\<Longrightarrow>\n    continuous_map T cstrong_operator_topology f", "assume *: \"\\<forall>x. continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x)\""], ["proof (state)\nthis:\n  \\<forall>x.\n     continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       continuous_map T euclidean\n        (\\<lambda>y. cblinfun_apply (f y) x) \\<Longrightarrow>\n    continuous_map T cstrong_operator_topology f", "have \"\\<And>i. continuous_map T euclidean (\\<lambda>x. cblinfun_apply (f x) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. continuous_map T euclidean (\\<lambda>x. cblinfun_apply (f x) i)", "using *"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x)\n\ngoal (1 subgoal):\n 1. \\<And>i. continuous_map T euclidean (\\<lambda>x. cblinfun_apply (f x) i)", "unfolding comp_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     continuous_map T euclidean (\\<lambda>y. cblinfun_apply (f y) x)\n\ngoal (1 subgoal):\n 1. \\<And>i. continuous_map T euclidean (\\<lambda>x. cblinfun_apply (f x) i)", "by auto"], ["proof (state)\nthis:\n  continuous_map T euclidean (\\<lambda>x. cblinfun_apply (f x) ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       continuous_map T euclidean\n        (\\<lambda>y. cblinfun_apply (f y) x) \\<Longrightarrow>\n    continuous_map T cstrong_operator_topology f", "then"], ["proof (chain)\npicking this:\n  continuous_map T euclidean (\\<lambda>x. cblinfun_apply (f x) ?i)", "have \"continuous_map T euclidean (cblinfun_apply o f)\""], ["proof (prove)\nusing this:\n  continuous_map T euclidean (\\<lambda>x. cblinfun_apply (f x) ?i)\n\ngoal (1 subgoal):\n 1. continuous_map T euclidean (cblinfun_apply \\<circ> f)", "unfolding o_def"], ["proof (prove)\nusing this:\n  continuous_map T euclidean (\\<lambda>x. cblinfun_apply (f x) ?i)\n\ngoal (1 subgoal):\n 1. continuous_map T euclidean (\\<lambda>x. cblinfun_apply (f x))", "by (metis (no_types) continuous_map_componentwise_UNIV euclidean_product_topology)"], ["proof (state)\nthis:\n  continuous_map T euclidean (cblinfun_apply \\<circ> f)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       continuous_map T euclidean\n        (\\<lambda>y. cblinfun_apply (f y) x) \\<Longrightarrow>\n    continuous_map T cstrong_operator_topology f", "show \"continuous_map T cstrong_operator_topology f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map T cstrong_operator_topology f", "unfolding cstrong_operator_topology_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map T (pullback_topology UNIV cblinfun_apply euclidean) f", "apply (rule continuous_map_pullback')"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_map T euclidean (cblinfun_apply \\<circ> f)\n 2. topspace T \\<subseteq> f -` UNIV", "by (auto simp add: \\<open>continuous_map T euclidean (cblinfun_apply o f)\\<close>)"], ["proof (state)\nthis:\n  continuous_map T cstrong_operator_topology f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cstrong_operator_topology_weaker_than_euclidean:\n  \"continuous_map euclidean cstrong_operator_topology (\\<lambda>f. f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map euclidean cstrong_operator_topology (\\<lambda>f. f)", "apply (subst continuous_on_cstrong_operator_topo_iff_coordinatewise)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       continuous_map euclidean euclidean (\\<lambda>y. cblinfun_apply y x)", "by (auto simp add: linear_continuous_on continuous_at_imp_continuous_on linear_continuous_at \n      bounded_clinear.bounded_linear)"], ["", "end"]]}