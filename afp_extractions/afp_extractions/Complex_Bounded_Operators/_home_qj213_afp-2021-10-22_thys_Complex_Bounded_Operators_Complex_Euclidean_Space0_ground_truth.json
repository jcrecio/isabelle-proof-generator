{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators/Complex_Euclidean_Space0.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators", "problem_names": ["lemma (in ceuclidean_space) norm_CBasis[simp]: \"u \\<in> CBasis \\<Longrightarrow> norm u = 1\"", "lemma (in ceuclidean_space) cinner_same_CBasis[simp]: \"u \\<in> CBasis \\<Longrightarrow> cinner u u = 1\"", "lemma (in ceuclidean_space) cinner_not_same_CBasis: \"u \\<in> CBasis \\<Longrightarrow> v \\<in> CBasis \\<Longrightarrow> u \\<noteq> v \\<Longrightarrow> cinner u v = 0\"", "lemma (in ceuclidean_space) sgn_CBasis: \"u \\<in> CBasis \\<Longrightarrow> sgn u = u\"", "lemma (in ceuclidean_space) CBasis_zero [simp]: \"0 \\<notin> CBasis\"", "lemma (in ceuclidean_space) nonzero_CBasis: \"u \\<in> CBasis \\<Longrightarrow> u \\<noteq> 0\"", "lemma (in ceuclidean_space) SOME_CBasis: \"(SOME i. i \\<in> CBasis) \\<in> CBasis\"", "lemma norm_some_CBasis [simp]: \"norm (SOME i. i \\<in> CBasis) = 1\"", "lemma (in ceuclidean_space) cinner_sum_left_CBasis[simp]:\n  \"b \\<in> CBasis \\<Longrightarrow> cinner (\\<Sum>i\\<in>CBasis. f i *\\<^sub>C i) b = cnj (f b)\"", "lemma (in ceuclidean_space) ceuclidean_eqI:\n  assumes b: \"\\<And>b. b \\<in> CBasis \\<Longrightarrow> cinner x b = cinner y b\" shows \"x = y\"", "lemma (in ceuclidean_space) ceuclidean_eq_iff:\n  \"x = y \\<longleftrightarrow> (\\<forall>b\\<in>CBasis. cinner x b = cinner y b)\"", "lemma (in ceuclidean_space) ceuclidean_representation_sum:\n  \"(\\<Sum>i\\<in>CBasis. f i *\\<^sub>C i) = b \\<longleftrightarrow> (\\<forall>i\\<in>CBasis. f i = cnj (cinner b i))\"", "lemma (in ceuclidean_space) ceuclidean_representation_sum':\n  \"b = (\\<Sum>i\\<in>CBasis. f i *\\<^sub>C i) \\<longleftrightarrow> (\\<forall>i\\<in>CBasis. f i = cinner i b)\"", "lemma (in ceuclidean_space) ceuclidean_representation: \"(\\<Sum>b\\<in>CBasis. cinner b x *\\<^sub>C b) = x\"", "lemma (in ceuclidean_space) ceuclidean_cinner: \"cinner x y = (\\<Sum>b\\<in>CBasis. cinner x b * cnj (cinner y b))\"", "lemma (in ceuclidean_space) choice_CBasis_iff:\n  fixes P :: \"'a \\<Rightarrow> complex \\<Rightarrow> bool\"\n  shows \"(\\<forall>i\\<in>CBasis. \\<exists>x. P i x) \\<longleftrightarrow> (\\<exists>x. \\<forall>i\\<in>CBasis. P i (cinner x i))\"", "lemma (in ceuclidean_space) bchoice_CBasis_iff:\n  fixes P :: \"'a \\<Rightarrow> complex \\<Rightarrow> bool\"\n  shows \"(\\<forall>i\\<in>CBasis. \\<exists>x\\<in>A. P i x) \\<longleftrightarrow> (\\<exists>x. \\<forall>i\\<in>CBasis. cinner x i \\<in> A \\<and> P i (cinner x i))\"", "lemma (in ceuclidean_space) ceuclidean_representation_sum_fun:\n  \"(\\<lambda>x. \\<Sum>b\\<in>CBasis. cinner b (f x) *\\<^sub>C b) = f\"", "lemma euclidean_isCont:\n  assumes \"\\<And>b. b \\<in> CBasis \\<Longrightarrow> isCont (\\<lambda>x. (cinner b (f x)) *\\<^sub>C b) x\"\n  shows \"isCont f x\"", "lemma CDIM_positive [simp]: \"0 < CDIM('a::ceuclidean_space)\"", "lemma CDIM_ge_Suc0 [simp]: \"Suc 0 \\<le> card CBasis\"", "lemma sum_cinner_CBasis_scaleC [simp]:\n  fixes f :: \"'a::ceuclidean_space \\<Rightarrow> 'b::complex_vector\"\n  assumes \"b \\<in> CBasis\" shows \"(\\<Sum>i\\<in>CBasis. (cinner i b) *\\<^sub>C f i) = f b\"", "lemma sum_cinner_CBasis_eq [simp]:\n  assumes \"b \\<in> CBasis\" shows \"(\\<Sum>i\\<in>CBasis. (cinner i b) * f i) = f b\"", "lemma sum_if_cinner [simp]:\n  assumes \"i \\<in> CBasis\" \"j \\<in> CBasis\"\n  shows \"cinner (\\<Sum>k\\<in>CBasis. if k = i then f i *\\<^sub>C i else g k *\\<^sub>C k) j = (if j=i then cnj (f j) else cnj (g j))\"", "lemma norm_le_componentwise:\n  \"(\\<And>b. b \\<in> CBasis \\<Longrightarrow> cmod(cinner x b) \\<le> cmod(cinner y b)) \\<Longrightarrow> norm x \\<le> norm y\"", "lemma CBasis_le_norm: \"b \\<in> CBasis \\<Longrightarrow> cmod (cinner x b) \\<le> norm x\"", "lemma norm_bound_CBasis_le: \"b \\<in> CBasis \\<Longrightarrow> norm x \\<le> e \\<Longrightarrow> cmod (inner x b) \\<le> e\"", "lemma norm_bound_CBasis_lt: \"b \\<in> CBasis \\<Longrightarrow> norm x < e \\<Longrightarrow> cmod (inner x b) < e\"", "lemma cnorm_le_l1: \"norm x \\<le> (\\<Sum>b\\<in>CBasis. cmod (cinner x b))\"", "lemma CDIM_complex[simp]: \"CDIM(complex) = 1\"", "lemma cinner_Pair [simp]: \"cinner (a, b) (c, d) = cinner a c + cinner b d\"", "lemma cinner_Pair_0: \"cinner x (0, b) = cinner (snd x) b\" \"cinner x (a, 0) = cinner (fst x) a\"", "lemma sum_CBasis_prod_eq:\n  fixes f::\"('a*'b)\\<Rightarrow>('a*'b)\"\n  shows \"sum f CBasis = sum (\\<lambda>i. f (i, 0)) CBasis + sum (\\<lambda>i. f (0, i)) CBasis\"", "lemma CDIM_prod[simp]: \"CDIM('a \\<times> 'b) = CDIM('a) + CDIM('b)\"", "lemma finite_dimensional_vector_space_euclidean:\n  \"finite_dimensional_vector_space (*\\<^sub>C) CBasis\""], "translations": [["", "lemma (in ceuclidean_space) norm_CBasis[simp]: \"u \\<in> CBasis \\<Longrightarrow> norm u = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> CBasis \\<Longrightarrow> norm u = 1", "unfolding norm_eq_sqrt_cinner"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> CBasis \\<Longrightarrow> sqrt (cmod \\<langle>u, u\\<rangle>) = 1", "by (simp add: cinner_CBasis)"], ["", "lemma (in ceuclidean_space) cinner_same_CBasis[simp]: \"u \\<in> CBasis \\<Longrightarrow> cinner u u = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> CBasis \\<Longrightarrow> \\<langle>u, u\\<rangle> = 1", "by (simp add: cinner_CBasis)"], ["", "lemma (in ceuclidean_space) cinner_not_same_CBasis: \"u \\<in> CBasis \\<Longrightarrow> v \\<in> CBasis \\<Longrightarrow> u \\<noteq> v \\<Longrightarrow> cinner u v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> CBasis; v \\<in> CBasis; u \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> \\<langle>u, v\\<rangle> = 0", "by (simp add: cinner_CBasis)"], ["", "lemma (in ceuclidean_space) sgn_CBasis: \"u \\<in> CBasis \\<Longrightarrow> sgn u = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> CBasis \\<Longrightarrow> sgn u = u", "unfolding sgn_div_norm"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> CBasis \\<Longrightarrow> u /\\<^sub>R norm u = u", "by (simp add: scaleR_one)"], ["", "lemma (in ceuclidean_space) CBasis_zero [simp]: \"0 \\<notin> CBasis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<notin> CBasis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> CBasis \\<Longrightarrow> False", "assume \"0 \\<in> CBasis\""], ["proof (state)\nthis:\n  (0::'a) \\<in> CBasis\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> CBasis \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  (0::'a) \\<in> CBasis\n\ngoal (1 subgoal):\n 1. False", "using cinner_CBasis [of 0 0]"], ["proof (prove)\nusing this:\n  (0::'a) \\<in> CBasis\n  \\<lbrakk>(0::'a) \\<in> CBasis; (0::'a) \\<in> CBasis\\<rbrakk>\n  \\<Longrightarrow> \\<langle>0::'a, 0::'a\\<rangle> =\n                    (if (0::'a) = (0::'a) then 1 else 0)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in ceuclidean_space) nonzero_CBasis: \"u \\<in> CBasis \\<Longrightarrow> u \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> CBasis \\<Longrightarrow> u \\<noteq> (0::'a)", "by clarsimp"], ["", "lemma (in ceuclidean_space) SOME_CBasis: \"(SOME i. i \\<in> CBasis) \\<in> CBasis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME i. i \\<in> CBasis) \\<in> CBasis", "by (metis ex_in_conv nonempty_CBasis someI_ex)"], ["", "lemma norm_some_CBasis [simp]: \"norm (SOME i. i \\<in> CBasis) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (SOME i. i \\<in> CBasis) = 1", "by (simp add: SOME_CBasis)"], ["", "lemma (in ceuclidean_space) cinner_sum_left_CBasis[simp]:\n  \"b \\<in> CBasis \\<Longrightarrow> cinner (\\<Sum>i\\<in>CBasis. f i *\\<^sub>C i) b = cnj (f b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> CBasis \\<Longrightarrow>\n    \\<langle>\\<Sum>i\\<in>CBasis. f i *\\<^sub>C i, b\\<rangle> = cnj (f b)", "by (simp add: cinner_sum_left cinner_CBasis if_distrib comm_monoid_add_class.sum.If_cases)"], ["", "(* Not present in Euclidean_Space *)\n(* lemma (in ceuclidean_space) cinner_sum_right_CBasis[simp]:\n    \"b \\<in> CBasis \\<Longrightarrow> cinner b (\\<Sum>i\\<in>CBasis. f i *\\<^sub>C i) = f b\"\n  by (metis (mono_tags, lifting) cinner_commute cinner_sum_left_CBasis comm_monoid_add_class.sum.cong complex_cnj_cnj) *)"], ["", "lemma (in ceuclidean_space) ceuclidean_eqI:\n  assumes b: \"\\<And>b. b \\<in> CBasis \\<Longrightarrow> cinner x b = cinner y b\" shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "from b"], ["proof (chain)\npicking this:\n  ?b1 \\<in> CBasis \\<Longrightarrow>\n  \\<langle>x, ?b1\\<rangle> = \\<langle>y, ?b1\\<rangle>", "have \"\\<forall>b\\<in>CBasis. cinner (x - y) b = 0\""], ["proof (prove)\nusing this:\n  ?b1 \\<in> CBasis \\<Longrightarrow>\n  \\<langle>x, ?b1\\<rangle> = \\<langle>y, ?b1\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>CBasis. \\<langle>x - y, b\\<rangle> = 0", "by (simp add: cinner_diff_left)"], ["proof (state)\nthis:\n  \\<forall>b\\<in>CBasis. \\<langle>x - y, b\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. x = y", "then"], ["proof (chain)\npicking this:\n  \\<forall>b\\<in>CBasis. \\<langle>x - y, b\\<rangle> = 0", "show \"x = y\""], ["proof (prove)\nusing this:\n  \\<forall>b\\<in>CBasis. \\<langle>x - y, b\\<rangle> = 0\n\ngoal (1 subgoal):\n 1. x = y", "by (simp add: ceuclidean_all_zero_iff)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in ceuclidean_space) ceuclidean_eq_iff:\n  \"x = y \\<longleftrightarrow> (\\<forall>b\\<in>CBasis. cinner x b = cinner y b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y) =\n    (\\<forall>b\\<in>CBasis. \\<langle>x, b\\<rangle> = \\<langle>y, b\\<rangle>)", "by (auto intro: ceuclidean_eqI)"], ["", "lemma (in ceuclidean_space) ceuclidean_representation_sum:\n  \"(\\<Sum>i\\<in>CBasis. f i *\\<^sub>C i) = b \\<longleftrightarrow> (\\<forall>i\\<in>CBasis. f i = cnj (cinner b i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>i\\<in>CBasis. f i *\\<^sub>C i) = b) =\n    (\\<forall>i\\<in>CBasis. f i = cnj \\<langle>b, i\\<rangle>)", "apply (subst ceuclidean_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ba\\<in>CBasis.\n        \\<langle>\\<Sum>i\\<in>CBasis. f i *\\<^sub>C i, ba\\<rangle> =\n        \\<langle>b, ba\\<rangle>) =\n    (\\<forall>i\\<in>CBasis. f i = cnj \\<langle>b, i\\<rangle>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ba\\<in>CBasis. cnj (f ba) = \\<langle>b, ba\\<rangle>) =\n    (\\<forall>i\\<in>CBasis. f i = cnj \\<langle>b, i\\<rangle>)", "by (metis complex_cnj_cnj cinner_commute)"], ["", "lemma (in ceuclidean_space) ceuclidean_representation_sum':\n  \"b = (\\<Sum>i\\<in>CBasis. f i *\\<^sub>C i) \\<longleftrightarrow> (\\<forall>i\\<in>CBasis. f i = cinner i b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b = (\\<Sum>i\\<in>CBasis. f i *\\<^sub>C i)) =\n    (\\<forall>i\\<in>CBasis. f i = \\<langle>i, b\\<rangle>)", "apply (auto simp add: ceuclidean_representation_sum[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>b = (\\<Sum>i\\<in>CBasis. f i *\\<^sub>C i);\n        i \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> f i =\n                         \\<langle>i, \\<Sum>i\\<in>CBasis.\n f i *\\<^sub>C i\\<rangle>\n 2. \\<forall>i\\<in>CBasis. f i = \\<langle>i, b\\<rangle> \\<Longrightarrow>\n    b = (\\<Sum>i\\<in>CBasis. \\<langle>i, b\\<rangle> *\\<^sub>C i)", "apply (metis ceuclidean_representation_sum cinner_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>CBasis. f i = \\<langle>i, b\\<rangle> \\<Longrightarrow>\n    b = (\\<Sum>i\\<in>CBasis. \\<langle>i, b\\<rangle> *\\<^sub>C i)", "by (metis local.ceuclidean_representation_sum local.cinner_commute)"], ["", "lemma (in ceuclidean_space) ceuclidean_representation: \"(\\<Sum>b\\<in>CBasis. cinner b x *\\<^sub>C b) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>CBasis. \\<langle>b, x\\<rangle> *\\<^sub>C b) = x", "unfolding ceuclidean_representation_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>CBasis.\n       \\<langle>b, x\\<rangle> = cnj \\<langle>x, b\\<rangle>", "using local.cinner_commute"], ["proof (prove)\nusing this:\n  \\<langle>?x, ?y\\<rangle> = cnj \\<langle>?y, ?x\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>CBasis.\n       \\<langle>b, x\\<rangle> = cnj \\<langle>x, b\\<rangle>", "by blast"], ["", "lemma (in ceuclidean_space) ceuclidean_cinner: \"cinner x y = (\\<Sum>b\\<in>CBasis. cinner x b * cnj (cinner y b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, y\\<rangle> =\n    (\\<Sum>b\\<in>CBasis.\n       \\<langle>x, b\\<rangle> * cnj \\<langle>y, b\\<rangle>)", "apply (subst (1 2) ceuclidean_representation [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<Sum>b\\<in>CBasis.\n               \\<langle>b, x\\<rangle> *\\<^sub>C\n               b, \\<Sum>b\\<in>CBasis.\n                    \\<langle>b, y\\<rangle> *\\<^sub>C b\\<rangle> =\n    (\\<Sum>b\\<in>CBasis.\n       \\<langle>x, b\\<rangle> * cnj \\<langle>y, b\\<rangle>)", "apply (simp add: cinner_sum_right cinner_CBasis ac_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>CBasis.\n       \\<langle>b, y\\<rangle> * cnj \\<langle>b, x\\<rangle>) =\n    (\\<Sum>b\\<in>CBasis.\n       \\<langle>x, b\\<rangle> * cnj \\<langle>y, b\\<rangle>)", "by (metis local.cinner_commute mult.commute)"], ["", "lemma (in ceuclidean_space) choice_CBasis_iff:\n  fixes P :: \"'a \\<Rightarrow> complex \\<Rightarrow> bool\"\n  shows \"(\\<forall>i\\<in>CBasis. \\<exists>x. P i x) \\<longleftrightarrow> (\\<exists>x. \\<forall>i\\<in>CBasis. P i (cinner x i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>CBasis. \\<exists>x. P i x) =\n    (\\<exists>x. \\<forall>i\\<in>CBasis. P i \\<langle>x, i\\<rangle>)", "unfolding bchoice_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f. \\<forall>i\\<in>CBasis. P i (f i)) =\n    (\\<exists>x. \\<forall>i\\<in>CBasis. P i \\<langle>x, i\\<rangle>)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<forall>i\\<in>CBasis. P i (f i) \\<Longrightarrow>\n       \\<exists>x. \\<forall>i\\<in>CBasis. P i \\<langle>x, i\\<rangle>\n 2. \\<And>x.\n       \\<forall>i\\<in>CBasis. P i \\<langle>x, i\\<rangle> \\<Longrightarrow>\n       \\<exists>f. \\<forall>i\\<in>CBasis. P i (f i)", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<forall>i\\<in>CBasis. P i (f i) \\<Longrightarrow>\n       \\<exists>x. \\<forall>i\\<in>CBasis. P i \\<langle>x, i\\<rangle>\n 2. \\<And>x.\n       \\<forall>i\\<in>CBasis. P i \\<langle>x, i\\<rangle> \\<Longrightarrow>\n       \\<exists>f. \\<forall>i\\<in>CBasis. P i (f i)", "assume \"\\<forall>i\\<in>CBasis. P i (f i)\""], ["proof (state)\nthis:\n  \\<forall>i\\<in>CBasis. P i (f i)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<forall>i\\<in>CBasis. P i (f i) \\<Longrightarrow>\n       \\<exists>x. \\<forall>i\\<in>CBasis. P i \\<langle>x, i\\<rangle>\n 2. \\<And>x.\n       \\<forall>i\\<in>CBasis. P i \\<langle>x, i\\<rangle> \\<Longrightarrow>\n       \\<exists>f. \\<forall>i\\<in>CBasis. P i (f i)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>CBasis. P i (f i)", "show \"\\<exists>x. \\<forall>i\\<in>CBasis. P i (cinner x i)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>CBasis. P i (f i)\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>i\\<in>CBasis. P i \\<langle>x, i\\<rangle>", "by (auto intro!: exI[of _ \"\\<Sum>i\\<in>CBasis. cnj (f i) *\\<^sub>C i\"])"], ["proof (state)\nthis:\n  \\<exists>x. \\<forall>i\\<in>CBasis. P i \\<langle>x, i\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i\\<in>CBasis. P i \\<langle>x, i\\<rangle> \\<Longrightarrow>\n       \\<exists>f. \\<forall>i\\<in>CBasis. P i (f i)", "qed auto"], ["", "lemma (in ceuclidean_space) bchoice_CBasis_iff:\n  fixes P :: \"'a \\<Rightarrow> complex \\<Rightarrow> bool\"\n  shows \"(\\<forall>i\\<in>CBasis. \\<exists>x\\<in>A. P i x) \\<longleftrightarrow> (\\<exists>x. \\<forall>i\\<in>CBasis. cinner x i \\<in> A \\<and> P i (cinner x i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>CBasis. \\<exists>x\\<in>A. P i x) =\n    (\\<exists>x.\n        \\<forall>i\\<in>CBasis.\n           \\<langle>x, i\\<rangle> \\<in> A \\<and> P i \\<langle>x, i\\<rangle>)", "by (simp add: choice_CBasis_iff Bex_def)"], ["", "lemma (in ceuclidean_space) ceuclidean_representation_sum_fun:\n  \"(\\<lambda>x. \\<Sum>b\\<in>CBasis. cinner b (f x) *\\<^sub>C b) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<Sum>b\\<in>CBasis. \\<langle>b, f x\\<rangle> *\\<^sub>C b) =\n    f", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Sum>b\\<in>CBasis. \\<langle>b, f x\\<rangle> *\\<^sub>C b) = f x", "apply (simp add: ceuclidean_representation_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>b\\<in>CBasis.\n          \\<langle>b, f x\\<rangle> = cnj \\<langle>f x, b\\<rangle>", "by (meson local.cinner_commute)"], ["", "lemma euclidean_isCont:\n  assumes \"\\<And>b. b \\<in> CBasis \\<Longrightarrow> isCont (\\<lambda>x. (cinner b (f x)) *\\<^sub>C b) x\"\n  shows \"isCont f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont f x", "apply (subst ceuclidean_representation_sum_fun [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont\n     (\\<lambda>x. \\<Sum>b\\<in>CBasis. \\<langle>b, f x\\<rangle> *\\<^sub>C b)\n     x", "apply (rule isCont_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>CBasis.\n       isCont (\\<lambda>x. \\<langle>b, f x\\<rangle> *\\<^sub>C b) x", "by (blast intro: assms)"], ["", "lemma CDIM_positive [simp]: \"0 < CDIM('a::ceuclidean_space)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < CDIM('a)", "by (simp add: card_gt_0_iff)"], ["", "lemma CDIM_ge_Suc0 [simp]: \"Suc 0 \\<le> card CBasis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 \\<le> CDIM('a)", "by (meson CDIM_positive Suc_leI)"], ["", "lemma sum_cinner_CBasis_scaleC [simp]:\n  fixes f :: \"'a::ceuclidean_space \\<Rightarrow> 'b::complex_vector\"\n  assumes \"b \\<in> CBasis\" shows \"(\\<Sum>i\\<in>CBasis. (cinner i b) *\\<^sub>C f i) = f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>CBasis. \\<langle>i, b\\<rangle> *\\<^sub>C f i) = f b", "by (simp add: comm_monoid_add_class.sum.remove [OF finite_CBasis assms]\n      assms cinner_not_same_CBasis comm_monoid_add_class.sum.neutral)"], ["", "lemma sum_cinner_CBasis_eq [simp]:\n  assumes \"b \\<in> CBasis\" shows \"(\\<Sum>i\\<in>CBasis. (cinner i b) * f i) = f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>CBasis. \\<langle>i, b\\<rangle> * f i) = f b", "by (simp add: comm_monoid_add_class.sum.remove [OF finite_CBasis assms]\n      assms cinner_not_same_CBasis comm_monoid_add_class.sum.neutral)"], ["", "lemma sum_if_cinner [simp]:\n  assumes \"i \\<in> CBasis\" \"j \\<in> CBasis\"\n  shows \"cinner (\\<Sum>k\\<in>CBasis. if k = i then f i *\\<^sub>C i else g k *\\<^sub>C k) j = (if j=i then cnj (f j) else cnj (g j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))", "proof (cases \"i=j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))\n 2. i \\<noteq> j \\<Longrightarrow>\n    \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))", "case True"], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))\n 2. i \\<noteq> j \\<Longrightarrow>\n    \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))", "with assms"], ["proof (chain)\npicking this:\n  i \\<in> CBasis\n  j \\<in> CBasis\n  i = j", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> CBasis\n  j \\<in> CBasis\n  i = j\n\ngoal (1 subgoal):\n 1. \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))", "by (auto simp: cinner_sum_left if_distrib [of \"\\<lambda>x. cinner x j\"] cinner_CBasis cong: if_cong)"], ["proof (state)\nthis:\n  \\<langle>\\<Sum>k\\<in>CBasis.\n             if k = i then f i *\\<^sub>C i\n             else g k *\\<^sub>C k, j\\<rangle> =\n  (if j = i then cnj (f j) else cnj (g j))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))", "have \"(\\<Sum>k\\<in>CBasis. cinner (if k = i then f i *\\<^sub>C i else g k *\\<^sub>C k) j) =\n        (\\<Sum>k\\<in>CBasis. if k = j then cnj (g k) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>CBasis.\n       \\<langle>if k = i then f i *\\<^sub>C i\n                else g k *\\<^sub>C k, j\\<rangle>) =\n    (\\<Sum>k\\<in>CBasis. if k = j then cnj (g k) else 0)", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. CBasis = CBasis\n 2. \\<And>x.\n       x \\<in> CBasis \\<Longrightarrow>\n       \\<langle>if x = i then f i *\\<^sub>C i\n                else g x *\\<^sub>C x, j\\<rangle> =\n       (if x = j then cnj (g x) else 0)", "using False assms"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  i \\<in> CBasis\n  j \\<in> CBasis\n\ngoal (2 subgoals):\n 1. CBasis = CBasis\n 2. \\<And>x.\n       x \\<in> CBasis \\<Longrightarrow>\n       \\<langle>if x = i then f i *\\<^sub>C i\n                else g x *\\<^sub>C x, j\\<rangle> =\n       (if x = j then cnj (g x) else 0)", "by (auto simp: cinner_CBasis)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>CBasis.\n     \\<langle>if k = i then f i *\\<^sub>C i\n              else g k *\\<^sub>C k, j\\<rangle>) =\n  (\\<Sum>k\\<in>CBasis. if k = j then cnj (g k) else 0)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>CBasis.\n     \\<langle>if k = i then f i *\\<^sub>C i\n              else g k *\\<^sub>C k, j\\<rangle>) =\n  (\\<Sum>k\\<in>CBasis. if k = j then cnj (g k) else 0)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))", "have \"... = cnj (g j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>CBasis. if k = j then cnj (g k) else 0) = cnj (g j)", "using assms"], ["proof (prove)\nusing this:\n  i \\<in> CBasis\n  j \\<in> CBasis\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>CBasis. if k = j then cnj (g k) else 0) = cnj (g j)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>k\\<in>CBasis. if k = j then cnj (g k) else 0) = cnj (g j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>k\\<in>CBasis.\n     \\<langle>if k = i then f i *\\<^sub>C i\n              else g k *\\<^sub>C k, j\\<rangle>) =\n  cnj (g j)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>k\\<in>CBasis.\n     \\<langle>if k = i then f i *\\<^sub>C i\n              else g k *\\<^sub>C k, j\\<rangle>) =\n  cnj (g j)\n\ngoal (1 subgoal):\n 1. \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))", "using False"], ["proof (prove)\nusing this:\n  (\\<Sum>k\\<in>CBasis.\n     \\<langle>if k = i then f i *\\<^sub>C i\n              else g k *\\<^sub>C k, j\\<rangle>) =\n  cnj (g j)\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<langle>\\<Sum>k\\<in>CBasis.\n               if k = i then f i *\\<^sub>C i\n               else g k *\\<^sub>C k, j\\<rangle> =\n    (if j = i then cnj (f j) else cnj (g j))", "by (auto simp: cinner_sum_left)"], ["proof (state)\nthis:\n  \\<langle>\\<Sum>k\\<in>CBasis.\n             if k = i then f i *\\<^sub>C i\n             else g k *\\<^sub>C k, j\\<rangle> =\n  (if j = i then cnj (f j) else cnj (g j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm_le_componentwise:\n  \"(\\<And>b. b \\<in> CBasis \\<Longrightarrow> cmod(cinner x b) \\<le> cmod(cinner y b)) \\<Longrightarrow> norm x \\<le> norm y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        b \\<in> CBasis \\<Longrightarrow>\n        cmod \\<langle>x, b\\<rangle>\n        \\<le> cmod \\<langle>y, b\\<rangle>) \\<Longrightarrow>\n    norm x \\<le> norm y", "apply (auto simp: cnorm_le ceuclidean_cinner [of x x] ceuclidean_cinner [of y y] power2_eq_square intro!: sum_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>b.\n        b \\<in> CBasis \\<Longrightarrow>\n        Re \\<langle>b, x\\<rangle> * Im \\<langle>x, b\\<rangle> +\n        Im \\<langle>b, x\\<rangle> * Re \\<langle>x, b\\<rangle> =\n        Re \\<langle>b, y\\<rangle> * Im \\<langle>y, b\\<rangle> +\n        Im \\<langle>b, y\\<rangle> * Re \\<langle>y, b\\<rangle> \\<and>\n        Re \\<langle>b, x\\<rangle> * Re \\<langle>x, b\\<rangle> -\n        Im \\<langle>b, x\\<rangle> * Im \\<langle>x, b\\<rangle>\n        \\<le> Re \\<langle>b, y\\<rangle> * Re \\<langle>y, b\\<rangle> -\n              Im \\<langle>b, y\\<rangle> *\n              Im \\<langle>y, b\\<rangle>) \\<Longrightarrow>\n    (\\<Sum>xa\\<in>CBasis.\n       Re \\<langle>x, xa\\<rangle> * Im \\<langle>xa, x\\<rangle> +\n       Im \\<langle>x, xa\\<rangle> * Re \\<langle>xa, x\\<rangle>) =\n    (\\<Sum>x\\<in>CBasis.\n       Re \\<langle>y, x\\<rangle> * Im \\<langle>x, y\\<rangle> +\n       Im \\<langle>y, x\\<rangle> * Re \\<langle>x, y\\<rangle>)\n 2. \\<And>xa.\n       \\<lbrakk>\\<And>b.\n                   b \\<in> CBasis \\<Longrightarrow>\n                   Re \\<langle>b, x\\<rangle> * Im \\<langle>x, b\\<rangle> +\n                   Im \\<langle>b, x\\<rangle> * Re \\<langle>x, b\\<rangle> =\n                   Re \\<langle>b, y\\<rangle> * Im \\<langle>y, b\\<rangle> +\n                   Im \\<langle>b, y\\<rangle> *\n                   Re \\<langle>y, b\\<rangle> \\<and>\n                   Re \\<langle>b, x\\<rangle> * Re \\<langle>x, b\\<rangle> -\n                   Im \\<langle>b, x\\<rangle> * Im \\<langle>x, b\\<rangle>\n                   \\<le> Re \\<langle>b, y\\<rangle> *\n                         Re \\<langle>y, b\\<rangle> -\n                         Im \\<langle>b, y\\<rangle> *\n                         Im \\<langle>y, b\\<rangle>;\n        xa \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> Re \\<langle>x, xa\\<rangle> *\n                         Re \\<langle>xa, x\\<rangle> -\n                         Im \\<langle>x, xa\\<rangle> *\n                         Im \\<langle>xa, x\\<rangle>\n                         \\<le> Re \\<langle>y, xa\\<rangle> *\n                               Re \\<langle>xa, y\\<rangle> -\n                               Im \\<langle>y, xa\\<rangle> *\n                               Im \\<langle>xa, y\\<rangle>", "apply (smt (verit, best) mult.commute sum.cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>b.\n                   b \\<in> CBasis \\<Longrightarrow>\n                   Re \\<langle>b, x\\<rangle> * Im \\<langle>x, b\\<rangle> +\n                   Im \\<langle>b, x\\<rangle> * Re \\<langle>x, b\\<rangle> =\n                   Re \\<langle>b, y\\<rangle> * Im \\<langle>y, b\\<rangle> +\n                   Im \\<langle>b, y\\<rangle> *\n                   Re \\<langle>y, b\\<rangle> \\<and>\n                   Re \\<langle>b, x\\<rangle> * Re \\<langle>x, b\\<rangle> -\n                   Im \\<langle>b, x\\<rangle> * Im \\<langle>x, b\\<rangle>\n                   \\<le> Re \\<langle>b, y\\<rangle> *\n                         Re \\<langle>y, b\\<rangle> -\n                         Im \\<langle>b, y\\<rangle> *\n                         Im \\<langle>y, b\\<rangle>;\n        xa \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> Re \\<langle>x, xa\\<rangle> *\n                         Re \\<langle>xa, x\\<rangle> -\n                         Im \\<langle>x, xa\\<rangle> *\n                         Im \\<langle>xa, x\\<rangle>\n                         \\<le> Re \\<langle>y, xa\\<rangle> *\n                               Re \\<langle>xa, y\\<rangle> -\n                               Im \\<langle>y, xa\\<rangle> *\n                               Im \\<langle>xa, y\\<rangle>", "by (simp add: ordered_field_class.sign_simps(33))"], ["", "lemma CBasis_le_norm: \"b \\<in> CBasis \\<Longrightarrow> cmod (cinner x b) \\<le> norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> CBasis \\<Longrightarrow>\n    cmod \\<langle>x, b\\<rangle> \\<le> norm x", "by (rule order_trans [OF Cauchy_Schwarz_ineq2]) simp"], ["", "lemma norm_bound_CBasis_le: \"b \\<in> CBasis \\<Longrightarrow> norm x \\<le> e \\<Longrightarrow> cmod (inner x b) \\<le> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> CBasis; norm x \\<le> e\\<rbrakk>\n    \\<Longrightarrow> cmod (complex_of_real (x \\<bullet> b)) \\<le> e", "by (metis inner_commute mult.left_neutral norm_CBasis norm_of_real order_trans real_inner_class.Cauchy_Schwarz_ineq2)"], ["", "lemma norm_bound_CBasis_lt: \"b \\<in> CBasis \\<Longrightarrow> norm x < e \\<Longrightarrow> cmod (inner x b) < e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> CBasis; norm x < e\\<rbrakk>\n    \\<Longrightarrow> cmod (complex_of_real (x \\<bullet> b)) < e", "by (metis inner_commute le_less_trans mult.left_neutral norm_CBasis norm_of_real real_inner_class.Cauchy_Schwarz_ineq2)"], ["", "lemma cnorm_le_l1: \"norm x \\<le> (\\<Sum>b\\<in>CBasis. cmod (cinner x b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x \\<le> (\\<Sum>b\\<in>CBasis. cmod \\<langle>x, b\\<rangle>)", "apply (subst ceuclidean_representation[of x, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (\\<Sum>b\\<in>CBasis. \\<langle>b, x\\<rangle> *\\<^sub>C b)\n    \\<le> (\\<Sum>b\\<in>CBasis. cmod \\<langle>x, b\\<rangle>)", "apply (rule order_trans[OF norm_sum])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>CBasis. norm (\\<langle>i, x\\<rangle> *\\<^sub>C i))\n    \\<le> (\\<Sum>b\\<in>CBasis. cmod \\<langle>x, b\\<rangle>)", "apply (auto intro!: sum_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> CBasis \\<Longrightarrow>\n       cmod \\<langle>i, x\\<rangle> \\<le> cmod \\<langle>x, i\\<rangle>", "by (metis cinner_commute complex_inner_1_left complex_inner_class.Cauchy_Schwarz_ineq2 mult.commute mult.left_neutral norm_one)"], ["", "(* Maybe it holds in the complex case but the proof does not adapt trivially *)\n(* lemma csum_norm_allsubsets_bound:\n  fixes f :: \"'a \\<Rightarrow> 'n::ceuclidean_space\"\n  assumes fP: \"finite P\"\n    and fPs: \"\\<And>Q. Q \\<subseteq> P \\<Longrightarrow> norm (sum f Q) \\<le> e\"\n  shows \"(\\<Sum>x\\<in>P. norm (f x)) \\<le> 2 * real CDIM('n) * e\" *)\n\n\n(* subsection\\<^marker>\\<open>tag unimportant\\<close> \\<open>Subclass relationships\\<close> *)\n(* Everything is commented out, so we comment out the heading, too. *)\n\n(* If we include this, instantiation prod :: (ceuclidean_space, ceuclidean_space) ceuclidean_space below fails *)\n(* instance ceuclidean_space \\<subseteq> perfect_space\nproof\n  fix x :: 'a show \"\\<not> open {x}\"\n  proof\n    assume \"open {x}\"\n    then obtain e where \"0 < e\" and e: \"\\<forall>y. dist y x < e \\<longrightarrow> y = x\"\n      unfolding open_dist by fast\n    define y where \"y = x + scaleR (e/2) (SOME b. b \\<in> CBasis)\"\n    have [simp]: \"(SOME b. b \\<in> CBasis) \\<in> CBasis\"\n      by (rule someI_ex) (auto simp: ex_in_conv)\n    from \\<open>0 < e\\<close> have \"y \\<noteq> x\"\n      unfolding y_def by (auto intro!: nonzero_CBasis)\n    from \\<open>0 < e\\<close> have \"dist y x < e\"\n      unfolding y_def by (simp add: dist_norm)\n    from \\<open>y \\<noteq> x\\<close> and \\<open>dist y x < e\\<close> show \"False\"\n      using e by simp\n  qed\nqed *)"], ["", "subsection \\<open>Class instances\\<close>"], ["", "subsubsection\\<^marker>\\<open>tag unimportant\\<close> \\<open>Type \\<^typ>\\<open>complex\\<close>\\<close>"], ["", "(* No analogue *)\n(* instantiation real :: ceuclidean_space *)"], ["", "instantiation complex :: ceuclidean_space\nbegin"], ["", "definition\n  [simp]: \"CBasis = {1::complex}\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(complex, ceuclidean_space_class)", "by standard auto"], ["", "end"], ["", "lemma CDIM_complex[simp]: \"CDIM(complex) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CDIM(complex) = 1", "by simp"], ["", "(* lemma CDIM_complex[simp]: \"DIM(complex) = 2\"\nlemma complex_CBasis_1 [iff]: \"(1::complex) \\<in> CBasis\"\nlemma complex_CBasis_i [iff]: \"\\<i> \\<in> CBasis\" *)"], ["", "subsubsection\\<^marker>\\<open>tag unimportant\\<close> \\<open>Type \\<^typ>\\<open>'a \\<times> 'b\\<close>\\<close>"], ["", "instantiation prod :: (complex_inner, complex_inner) complex_inner\nbegin"], ["", "definition cinner_prod_def:\n  \"cinner x y = cinner (fst x) (fst y) + cinner (snd x) (snd y)\""], ["", "lemma cinner_Pair [simp]: \"cinner (a, b) (c, d) = cinner a c + cinner b d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>(a, b), (c, d)\\<rangle> =\n    \\<langle>a, c\\<rangle> + \\<langle>b, d\\<rangle>", "unfolding cinner_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>fst (a, b), fst (c, d)\\<rangle> +\n    \\<langle>snd (a, b), snd (c, d)\\<rangle> =\n    \\<langle>a, c\\<rangle> + \\<langle>b, d\\<rangle>", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, complex_inner_class)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y. \\<langle>x, y\\<rangle> = cnj \\<langle>y, x\\<rangle>\n 2. \\<And>x y z.\n       \\<langle>x + y, z\\<rangle> =\n       \\<langle>x, z\\<rangle> + \\<langle>y, z\\<rangle>\n 3. \\<And>r x y.\n       \\<langle>r *\\<^sub>C x, y\\<rangle> = cnj r * \\<langle>x, y\\<rangle>\n 4. \\<And>x. 0 \\<le> \\<langle>x, x\\<rangle>\n 5. \\<And>x. (\\<langle>x, x\\<rangle> = 0) = (x = 0)\n 6. \\<And>x. norm x = sqrt (cmod \\<langle>x, x\\<rangle>)", "fix r :: complex"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y. \\<langle>x, y\\<rangle> = cnj \\<langle>y, x\\<rangle>\n 2. \\<And>x y z.\n       \\<langle>x + y, z\\<rangle> =\n       \\<langle>x, z\\<rangle> + \\<langle>y, z\\<rangle>\n 3. \\<And>r x y.\n       \\<langle>r *\\<^sub>C x, y\\<rangle> = cnj r * \\<langle>x, y\\<rangle>\n 4. \\<And>x. 0 \\<le> \\<langle>x, x\\<rangle>\n 5. \\<And>x. (\\<langle>x, x\\<rangle> = 0) = (x = 0)\n 6. \\<And>x. norm x = sqrt (cmod \\<langle>x, x\\<rangle>)", "fix x y z :: \"'a::complex_inner \\<times> 'b::complex_inner\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y. \\<langle>x, y\\<rangle> = cnj \\<langle>y, x\\<rangle>\n 2. \\<And>x y z.\n       \\<langle>x + y, z\\<rangle> =\n       \\<langle>x, z\\<rangle> + \\<langle>y, z\\<rangle>\n 3. \\<And>r x y.\n       \\<langle>r *\\<^sub>C x, y\\<rangle> = cnj r * \\<langle>x, y\\<rangle>\n 4. \\<And>x. 0 \\<le> \\<langle>x, x\\<rangle>\n 5. \\<And>x. (\\<langle>x, x\\<rangle> = 0) = (x = 0)\n 6. \\<And>x. norm x = sqrt (cmod \\<langle>x, x\\<rangle>)", "show \"cinner x y = cnj (cinner y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, y\\<rangle> = cnj \\<langle>y, x\\<rangle>", "unfolding cinner_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>fst x, fst y\\<rangle> + \\<langle>snd x, snd y\\<rangle> =\n    cnj (\\<langle>fst y, fst x\\<rangle> + \\<langle>snd y, snd x\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  \\<langle>x, y\\<rangle> = cnj \\<langle>y, x\\<rangle>\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<langle>x + y, z\\<rangle> =\n       \\<langle>x, z\\<rangle> + \\<langle>y, z\\<rangle>\n 2. \\<And>r x y.\n       \\<langle>r *\\<^sub>C x, y\\<rangle> = cnj r * \\<langle>x, y\\<rangle>\n 3. \\<And>x. 0 \\<le> \\<langle>x, x\\<rangle>\n 4. \\<And>x. (\\<langle>x, x\\<rangle> = 0) = (x = 0)\n 5. \\<And>x. norm x = sqrt (cmod \\<langle>x, x\\<rangle>)", "show \"cinner (x + y) z = cinner x z + cinner y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x + y, z\\<rangle> =\n    \\<langle>x, z\\<rangle> + \\<langle>y, z\\<rangle>", "unfolding cinner_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>fst (x + y), fst z\\<rangle> +\n    \\<langle>snd (x + y), snd z\\<rangle> =\n    \\<langle>fst x, fst z\\<rangle> + \\<langle>snd x, snd z\\<rangle> +\n    (\\<langle>fst y, fst z\\<rangle> + \\<langle>snd y, snd z\\<rangle>)", "by (simp add: cinner_add_left)"], ["proof (state)\nthis:\n  \\<langle>x + y, z\\<rangle> =\n  \\<langle>x, z\\<rangle> + \\<langle>y, z\\<rangle>\n\ngoal (4 subgoals):\n 1. \\<And>r x y.\n       \\<langle>r *\\<^sub>C x, y\\<rangle> = cnj r * \\<langle>x, y\\<rangle>\n 2. \\<And>x. 0 \\<le> \\<langle>x, x\\<rangle>\n 3. \\<And>x. (\\<langle>x, x\\<rangle> = 0) = (x = 0)\n 4. \\<And>x. norm x = sqrt (cmod \\<langle>x, x\\<rangle>)", "show \"cinner (scaleC r x) y = cnj r * cinner x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>r *\\<^sub>C x, y\\<rangle> = cnj r * \\<langle>x, y\\<rangle>", "unfolding cinner_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>fst (r *\\<^sub>C x), fst y\\<rangle> +\n    \\<langle>snd (r *\\<^sub>C x), snd y\\<rangle> =\n    cnj r *\n    (\\<langle>fst x, fst y\\<rangle> + \\<langle>snd x, snd y\\<rangle>)", "by (simp add: distrib_left)"], ["proof (state)\nthis:\n  \\<langle>r *\\<^sub>C x, y\\<rangle> = cnj r * \\<langle>x, y\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>x. 0 \\<le> \\<langle>x, x\\<rangle>\n 2. \\<And>x. (\\<langle>x, x\\<rangle> = 0) = (x = 0)\n 3. \\<And>x. norm x = sqrt (cmod \\<langle>x, x\\<rangle>)", "show \"0 \\<le> cinner x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<langle>x, x\\<rangle>", "unfolding cinner_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<langle>fst x, fst x\\<rangle> + \\<langle>snd x, snd x\\<rangle>", "by (intro add_nonneg_nonneg cinner_ge_zero)"], ["proof (state)\nthis:\n  0 \\<le> \\<langle>x, x\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>x. (\\<langle>x, x\\<rangle> = 0) = (x = 0)\n 2. \\<And>x. norm x = sqrt (cmod \\<langle>x, x\\<rangle>)", "show \"cinner x x = 0 \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>x, x\\<rangle> = 0) = (x = 0)", "unfolding cinner_prod_def prod_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>fst x, fst x\\<rangle> + \\<langle>snd x, snd x\\<rangle> = 0) =\n    (fst x = fst 0 \\<and> snd x = snd 0)", "by (metis antisym cinner_eq_zero_iff cinner_ge_zero fst_zero le_add_same_cancel2 snd_zero verit_sum_simplify)"], ["proof (state)\nthis:\n  (\\<langle>x, x\\<rangle> = 0) = (x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>x. norm x = sqrt (cmod \\<langle>x, x\\<rangle>)", "show \"norm x = sqrt (cmod (cinner x x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x = sqrt (cmod \\<langle>x, x\\<rangle>)", "unfolding norm_prod_def cinner_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt ((norm (fst x))\\<^sup>2 + (norm (snd x))\\<^sup>2) =\n    sqrt\n     (cmod\n       (\\<langle>fst x, fst x\\<rangle> + \\<langle>snd x, snd x\\<rangle>))", "by (metis (no_types, lifting) Re_complex_of_real add_nonneg_nonneg cinner_ge_zero complex_of_real_cmod plus_complex.simps(1) power2_norm_eq_cinner')"], ["proof (state)\nthis:\n  norm x = sqrt (cmod \\<langle>x, x\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma cinner_Pair_0: \"cinner x (0, b) = cinner (snd x) b\" \"cinner x (a, 0) = cinner (fst x) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x, (0::'a, b)\\<rangle> = \\<langle>snd x, b\\<rangle> &&&\n    \\<langle>x, (a, 0::'b)\\<rangle> = \\<langle>fst x, a\\<rangle>", "by (cases x, simp)+"], ["", "instantiation prod :: (ceuclidean_space, ceuclidean_space) ceuclidean_space\nbegin"], ["", "definition\n  \"CBasis = (\\<lambda>u. (u, 0)) ` CBasis \\<union> (\\<lambda>v. (0, v)) ` CBasis\""], ["", "lemma sum_CBasis_prod_eq:\n  fixes f::\"('a*'b)\\<Rightarrow>('a*'b)\"\n  shows \"sum f CBasis = sum (\\<lambda>i. f (i, 0)) CBasis + sum (\\<lambda>i. f (0, i)) CBasis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f CBasis =\n    (\\<Sum>i\\<in>CBasis. f (i, 0::'b)) + (\\<Sum>i\\<in>CBasis. f (0::'a, i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f CBasis =\n    (\\<Sum>i\\<in>CBasis. f (i, 0::'b)) + (\\<Sum>i\\<in>CBasis. f (0::'a, i))", "have \"inj_on (\\<lambda>u. (u::'a, 0::'b)) CBasis\" \"inj_on (\\<lambda>u. (0::'a, u::'b)) CBasis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>u. (u, 0::'b)) CBasis &&& inj_on (Pair (0::'a)) CBasis", "by (auto intro!: inj_onI Pair_inject)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>u. (u, 0::'b)) CBasis\n  inj_on (Pair (0::'a)) CBasis\n\ngoal (1 subgoal):\n 1. sum f CBasis =\n    (\\<Sum>i\\<in>CBasis. f (i, 0::'b)) + (\\<Sum>i\\<in>CBasis. f (0::'a, i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>u. (u, 0::'b)) CBasis\n  inj_on (Pair (0::'a)) CBasis\n\ngoal (1 subgoal):\n 1. sum f CBasis =\n    (\\<Sum>i\\<in>CBasis. f (i, 0::'b)) + (\\<Sum>i\\<in>CBasis. f (0::'a, i))", "unfolding CBasis_prod_def"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>u. (u, 0::'b)) CBasis\n  inj_on (Pair (0::'a)) CBasis\n\ngoal (1 subgoal):\n 1. sum f\n     ((\\<lambda>u. (u, 0::'b)) ` CBasis \\<union> Pair (0::'a) ` CBasis) =\n    (\\<Sum>i\\<in>CBasis. f (i, 0::'b)) + (\\<Sum>i\\<in>CBasis. f (0::'a, i))", "by (subst sum.union_disjoint) (auto simp: CBasis_prod_def sum.reindex)"], ["proof (state)\nthis:\n  sum f CBasis =\n  (\\<Sum>i\\<in>CBasis. f (i, 0::'b)) + (\\<Sum>i\\<in>CBasis. f (0::'a, i))\n\ngoal:\nNo subgoals!", "qed"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, ceuclidean_space_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. CBasis \\<noteq> {}\n 2. finite CBasis\n 3. \\<And>u v.\n       \\<lbrakk>u \\<in> CBasis; v \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> \\<langle>u, v\\<rangle> = (if u = v then 1 else 0)\n 4. \\<And>x. (\\<forall>u\\<in>CBasis. is_orthogonal x u) = (x = 0)", "show \"(CBasis :: ('a \\<times> 'b) set) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CBasis \\<noteq> {}", "unfolding CBasis_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>u. (u, 0::'b)) ` CBasis \\<union>\n    Pair (0::'a) ` CBasis \\<noteq>\n    {}", "by simp"], ["proof (state)\nthis:\n  CBasis \\<noteq> {}\n\ngoal (3 subgoals):\n 1. finite CBasis\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> CBasis; v \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> \\<langle>u, v\\<rangle> = (if u = v then 1 else 0)\n 3. \\<And>x. (\\<forall>u\\<in>CBasis. is_orthogonal x u) = (x = 0)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. finite CBasis\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> CBasis; v \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> \\<langle>u, v\\<rangle> = (if u = v then 1 else 0)\n 3. \\<And>x. (\\<forall>u\\<in>CBasis. is_orthogonal x u) = (x = 0)", "show \"finite (CBasis :: ('a \\<times> 'b) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite CBasis", "unfolding CBasis_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>u. (u, 0::'b)) ` CBasis \\<union> Pair (0::'a) ` CBasis)", "by simp"], ["proof (state)\nthis:\n  finite CBasis\n\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> CBasis; v \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> \\<langle>u, v\\<rangle> = (if u = v then 1 else 0)\n 2. \\<And>x. (\\<forall>u\\<in>CBasis. is_orthogonal x u) = (x = 0)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> CBasis; v \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> \\<langle>u, v\\<rangle> = (if u = v then 1 else 0)\n 2. \\<And>x. (\\<forall>u\\<in>CBasis. is_orthogonal x u) = (x = 0)", "fix u v :: \"'a \\<times> 'b\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> CBasis; v \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> \\<langle>u, v\\<rangle> = (if u = v then 1 else 0)\n 2. \\<And>x. (\\<forall>u\\<in>CBasis. is_orthogonal x u) = (x = 0)", "assume \"u \\<in> CBasis\" and \"v \\<in> CBasis\""], ["proof (state)\nthis:\n  u \\<in> CBasis\n  v \\<in> CBasis\n\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> CBasis; v \\<in> CBasis\\<rbrakk>\n       \\<Longrightarrow> \\<langle>u, v\\<rangle> = (if u = v then 1 else 0)\n 2. \\<And>x. (\\<forall>u\\<in>CBasis. is_orthogonal x u) = (x = 0)", "thus \"cinner u v = (if u = v then 1 else 0)\""], ["proof (prove)\nusing this:\n  u \\<in> CBasis\n  v \\<in> CBasis\n\ngoal (1 subgoal):\n 1. \\<langle>u, v\\<rangle> = (if u = v then 1 else 0)", "unfolding CBasis_prod_def cinner_prod_def"], ["proof (prove)\nusing this:\n  u \\<in> (\\<lambda>u. (u, 0::'b)) ` CBasis \\<union> Pair (0::'a) ` CBasis\n  v \\<in> (\\<lambda>u. (u, 0::'b)) ` CBasis \\<union> Pair (0::'a) ` CBasis\n\ngoal (1 subgoal):\n 1. \\<langle>fst u, fst v\\<rangle> + \\<langle>snd u, snd v\\<rangle> =\n    (if u = v then 1 else 0)", "by (auto simp add: cinner_CBasis split: if_split_asm)"], ["proof (state)\nthis:\n  \\<langle>u, v\\<rangle> = (if u = v then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>x. (\\<forall>u\\<in>CBasis. is_orthogonal x u) = (x = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<forall>u\\<in>CBasis. is_orthogonal x u) = (x = 0)", "fix x :: \"'a \\<times> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<forall>u\\<in>CBasis. is_orthogonal x u) = (x = 0)", "show \"(\\<forall>u\\<in>CBasis. cinner x u = 0) \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>CBasis. is_orthogonal x u) = (x = 0)", "unfolding CBasis_prod_def ball_Un ball_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>xa\\<in>CBasis. is_orthogonal x (xa, 0::'b)) \\<and>\n     (\\<forall>xa\\<in>CBasis. is_orthogonal x (0::'a, xa))) =\n    (x = 0)", "by (simp add: cinner_prod_def prod_eq_iff ceuclidean_all_zero_iff)"], ["proof (state)\nthis:\n  (\\<forall>u\\<in>CBasis. is_orthogonal x u) = (x = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CDIM_prod[simp]: \"CDIM('a \\<times> 'b) = CDIM('a) + CDIM('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CDIM('a \\<times> 'b) = CDIM('a) + CDIM('b)", "unfolding CBasis_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((\\<lambda>u. (u, 0::'b)) ` CBasis \\<union> Pair (0::'a) ` CBasis) =\n    CDIM('a) + CDIM('b)", "by (subst card_Un_disjoint) (auto intro!: card_image arg_cong2[where f=\"(+)\"] inj_onI)"], ["", "end"], ["", "subsection \\<open>Locale instances\\<close>"], ["", "lemma finite_dimensional_vector_space_euclidean:\n  \"finite_dimensional_vector_space (*\\<^sub>C) CBasis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space (*\\<^sub>C) CBasis", "proof unfold_locales"], ["proof (state)\ngoal (3 subgoals):\n 1. finite CBasis\n 2. complex_vector.independent CBasis\n 3. module.span (*\\<^sub>C) CBasis = UNIV", "show \"finite (CBasis::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite CBasis", "by (metis finite_CBasis)"], ["proof (state)\nthis:\n  finite CBasis\n\ngoal (2 subgoals):\n 1. complex_vector.independent CBasis\n 2. module.span (*\\<^sub>C) CBasis = UNIV", "show \"complex_vector.independent (CBasis::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_vector.independent CBasis", "unfolding complex_vector.dependent_def cdependent_raw_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>CBasis. a \\<in> cspan (CBasis - {a}))", "apply (subst complex_vector.span_finite)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a. finite (CBasis - {a})\n 2. \\<not> (\\<exists>a\\<in>CBasis.\n               a \\<in> range\n                        (\\<lambda>u.\n                            \\<Sum>v\\<in>CBasis - {a}. u v *\\<^sub>C v))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>CBasis.\n               a \\<in> range\n                        (\\<lambda>u.\n                            \\<Sum>v\\<in>CBasis - {a}. u v *\\<^sub>C v))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a u.\n       \\<lbrakk>a \\<in> CBasis;\n        a = (\\<Sum>v\\<in>CBasis - {a}. u v *\\<^sub>C v);\n        u \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac f=\"cinner a\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a u.\n       \\<lbrakk>a \\<in> CBasis; u \\<in> UNIV;\n        \\<langle>a, a\\<rangle> =\n        \\<langle>a, \\<Sum>v\\<in>CBasis - {a}.\n                      u v *\\<^sub>C v\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> False", "by (simp add: cinner_CBasis cinner_sum_right eq_commute)"], ["proof (state)\nthis:\n  complex_vector.independent CBasis\n\ngoal (1 subgoal):\n 1. module.span (*\\<^sub>C) CBasis = UNIV", "show \"module.span (*\\<^sub>C) CBasis = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module.span (*\\<^sub>C) CBasis = UNIV", "unfolding complex_vector.span_finite [OF finite_CBasis] cspan_raw_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. surj (\\<lambda>u. \\<Sum>v\\<in>CBasis. u v *\\<^sub>C v)", "by (auto intro!: ceuclidean_representation[symmetric])"], ["proof (state)\nthis:\n  module.span (*\\<^sub>C) CBasis = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation ceucl: finite_dimensional_vector_space \"scaleC :: complex => 'a => 'a::ceuclidean_space\" \"CBasis\"\n  rewrites \"module.dependent (*\\<^sub>C) = cdependent\"\n    and \"module.representation (*\\<^sub>C) = crepresentation\"\n    and \"module.subspace (*\\<^sub>C) = csubspace\"\n    and \"module.span (*\\<^sub>C) = cspan\"\n    and \"vector_space.extend_basis (*\\<^sub>C) = cextend_basis\"\n    and \"vector_space.dim (*\\<^sub>C) = cdim\"\n    and \"Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear\"\n    and \"Vector_Spaces.linear (*) (*\\<^sub>C) = clinear\"\n    and \"finite_dimensional_vector_space.dimension CBasis = CDIM('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((finite_dimensional_vector_space (*\\<^sub>C) CBasis &&&\n      module.dependent (*\\<^sub>C) = cdependent) &&&\n     module.representation (*\\<^sub>C) = crepresentation &&&\n     module.subspace (*\\<^sub>C) = csubspace &&&\n     module.span (*\\<^sub>C) = cspan) &&&\n    (vector_space.extend_basis (*\\<^sub>C) = cextend_basis &&&\n     vector_space.dim (*\\<^sub>C) = cdim) &&&\n    Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear &&&\n    Vector_Spaces.linear (*) (*\\<^sub>C) = clinear &&&\n    finite_dimensional_vector_space.dimension CBasis = CDIM(?'a)", "(* and \"dimension = CDIM('a)\" *) (* This line leads to a type error. Not sure why *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((finite_dimensional_vector_space (*\\<^sub>C) CBasis &&&\n      module.dependent (*\\<^sub>C) = cdependent) &&&\n     module.representation (*\\<^sub>C) = crepresentation &&&\n     module.subspace (*\\<^sub>C) = csubspace &&&\n     module.span (*\\<^sub>C) = cspan) &&&\n    (vector_space.extend_basis (*\\<^sub>C) = cextend_basis &&&\n     vector_space.dim (*\\<^sub>C) = cdim) &&&\n    Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear &&&\n    Vector_Spaces.linear (*) (*\\<^sub>C) = clinear &&&\n    finite_dimensional_vector_space.dimension CBasis = CDIM(?'a)", "by (auto simp add: cdependent_raw_def crepresentation_raw_def\n      csubspace_raw_def cspan_raw_def cextend_basis_raw_def cdim_raw_def clinear_def\n      complex_scaleC_def[abs_def]\n      finite_dimensional_vector_space.dimension_def\n      intro!: finite_dimensional_vector_space.dimension_def\n      finite_dimensional_vector_space_euclidean)"], ["", "interpretation ceucl: finite_dimensional_vector_space_pair_1\n  \"scaleC::complex\\<Rightarrow>'a::ceuclidean_space\\<Rightarrow>'a\" CBasis\n  \"scaleC::complex\\<Rightarrow>'b::complex_vector \\<Rightarrow> 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space_pair_1 (*\\<^sub>C) CBasis (*\\<^sub>C)", "by unfold_locales"], ["", "interpretation ceucl?: finite_dimensional_vector_space_prod scaleC scaleC CBasis CBasis\n  rewrites \"Basis_pair = CBasis\"\n    and \"module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = (scaleC::_\\<Rightarrow>_\\<Rightarrow>('a \\<times> 'b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space_prod (*\\<^sub>C) (*\\<^sub>C) CBasis\n     CBasis &&&\n    finite_dimensional_vector_space_prod.Basis_pair CBasis CBasis =\n    CBasis &&&\n    module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = (*\\<^sub>C)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. finite_dimensional_vector_space_prod (*\\<^sub>C) (*\\<^sub>C) CBasis\n     CBasis\n 2. finite_dimensional_vector_space_prod.Basis_pair CBasis CBasis = CBasis\n 3. module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = (*\\<^sub>C)", "show \"finite_dimensional_vector_space_prod (*\\<^sub>C) (*\\<^sub>C) CBasis CBasis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space_prod (*\\<^sub>C) (*\\<^sub>C) CBasis\n     CBasis", "by unfold_locales"], ["proof (state)\nthis:\n  finite_dimensional_vector_space_prod (*\\<^sub>C) (*\\<^sub>C) CBasis CBasis\n\ngoal (2 subgoals):\n 1. finite_dimensional_vector_space_prod.Basis_pair CBasis CBasis = CBasis\n 2. module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = (*\\<^sub>C)", "interpret finite_dimensional_vector_space_prod \"(*\\<^sub>C)\" \"(*\\<^sub>C)\" \"CBasis::'a set\" \"CBasis::'b set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space_prod (*\\<^sub>C) (*\\<^sub>C) CBasis\n     CBasis", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. finite_dimensional_vector_space_prod.Basis_pair CBasis CBasis = CBasis\n 2. module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = (*\\<^sub>C)", "show \"Basis_pair = CBasis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.Basis_pair = CBasis", "unfolding Basis_pair_def CBasis_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CBasis \\<times> {0::'b} \\<union> {0::'a} \\<times> CBasis =\n    (\\<lambda>u. (u, 0::'b)) ` CBasis \\<union> Pair (0::'a) ` CBasis", "by auto"], ["proof (state)\nthis:\n  local.Basis_pair = CBasis\n\ngoal (1 subgoal):\n 1. module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = (*\\<^sub>C)", "show \"module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = scaleC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = (*\\<^sub>C)", "by (fact module_prod_scale_eq_scaleC)"], ["proof (state)\nthis:\n  module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = (*\\<^sub>C)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}