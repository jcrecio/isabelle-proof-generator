{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators/Complex_L2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators", "problem_names": ["lemma has_ell2_norm_infsetsum: \"has_ell2_norm x \\<longleftrightarrow> (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV\"", "lemma has_ell2_norm_L2_set: \"has_ell2_norm x = bdd_above (L2_set (norm o x) ` Collect finite)\"", "lemma ell2_norm_L2_set: \n  assumes \"has_ell2_norm x\"\n  shows \"ell2_norm x = (SUP F\\<in>{F. finite F}. L2_set (norm o x) F)\"", "lemma ell2_norm_infsetsum:\n  assumes \"has_ell2_norm x\"\n  shows \"ell2_norm x = sqrt (infsetsum (\\<lambda>i. (norm(x i))^2) UNIV)\"", "lemma has_ell2_norm_finite[simp]: \"has_ell2_norm (x::'a::finite\\<Rightarrow>_)\"", "lemma ell2_norm_finite: \n  \"ell2_norm (x::'a::finite\\<Rightarrow>complex) = sqrt (sum (\\<lambda>i. (norm(x i))^2) UNIV)\"", "lemma ell2_norm_finite_L2_set: \"ell2_norm (x::'a::finite\\<Rightarrow>complex) = L2_set (norm o x) UNIV\"", "lemma ell2_ket:\n  fixes a\n  defines \\<open>f \\<equiv> (\\<lambda>i. if a = i then 1 else 0)\\<close>\n  shows has_ell2_norm_ket: \\<open>has_ell2_norm f\\<close>\n    and ell2_norm_ket: \\<open>ell2_norm f = 1\\<close>", "lemma ell2_norm_geq0:\n  assumes \\<open>has_ell2_norm x\\<close>\n  shows \\<open>ell2_norm x \\<ge> 0\\<close>", "lemma ell2_norm_point_bound:\n  assumes \\<open>has_ell2_norm x\\<close>\n  shows \\<open>ell2_norm x \\<ge> cmod (x i)\\<close>", "lemma ell2_norm_0:\n  assumes \"has_ell2_norm x\"\n  shows \"(ell2_norm x = 0) = (x = (\\<lambda>_. 0))\"", "lemma ell2_norm_smult:\n  assumes \"has_ell2_norm x\"\n  shows \"has_ell2_norm (\\<lambda>i. c * x i)\" and \"ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x\"", "lemma ell2_norm_triangle:\n  assumes \"has_ell2_norm x\" and \"has_ell2_norm y\"\n  shows \"has_ell2_norm (\\<lambda>i. x i + y i)\" and \"ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y\"", "lemma ell2_norm_uminus:\n  assumes \"has_ell2_norm x\"\n  shows \\<open>has_ell2_norm (\\<lambda>i. - x i)\\<close> and \\<open>ell2_norm (\\<lambda>i. - x i) = ell2_norm x\\<close>", "lemma norm_point_bound_ell2: \"norm (Rep_ell2 x i) \\<le> norm x\"", "lemma ell2_norm_finite_support:\n  assumes \\<open>finite S\\<close> \\<open>\\<And> i. i \\<notin> S \\<Longrightarrow> Rep_ell2 x i = 0\\<close>\n  shows \\<open>norm x = sqrt ((sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) S)\\<close>", "lemma ell2_pointwise_ortho:\n  assumes \\<open>\\<And> i. Rep_ell2 x i = 0 \\<or> Rep_ell2 y i = 0\\<close>\n  shows \\<open>is_orthogonal x y\\<close>", "lemma trunc_ell2_empty[simp]: \\<open>trunc_ell2 {} x = 0\\<close>", "lemma norm_id_minus_trunc_ell2:\n  \\<open>(norm (x - trunc_ell2 S x))^2 = (norm x)^2 - (norm (trunc_ell2 S x))^2\\<close>", "lemma norm_trunc_ell2_finite:\n  \\<open>finite S \\<Longrightarrow> (norm (trunc_ell2 S x)) = sqrt ((sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) S)\\<close>", "lemma trunc_ell2_lim_at_UNIV:\n  \\<open>((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>) (finite_subsets_at_top UNIV)\\<close>", "lemma cinner_ket_left: \\<open>\\<langle>ket i, \\<psi>\\<rangle> = Rep_ell2 \\<psi> i\\<close>", "lemma cinner_ket_right: \\<open>\\<langle>\\<psi>, ket i\\<rangle> = cnj (Rep_ell2 \\<psi> i)\\<close>", "lemma cinner_ket_eqI:\n  assumes \\<open>\\<And>i. cinner (ket i) \\<psi> = cinner (ket i) \\<phi>\\<close>\n  shows \\<open>\\<psi> = \\<phi>\\<close>", "lemma norm_ket[simp]: \"norm (ket i) = 1\"", "lemma cinner_ket_same[simp]:\n  \\<open>\\<langle>ket i, ket i\\<rangle> = 1\\<close>", "lemma orthogonal_ket[simp]:\n  \\<open>is_orthogonal (ket i) (ket j) \\<longleftrightarrow> i \\<noteq> j\\<close>", "lemma cinner_ket: \\<open>\\<langle>ket i, ket j\\<rangle> = (if i=j then 1 else 0)\\<close>", "lemma ket_injective[simp]: \\<open>ket i = ket j \\<longleftrightarrow> i = j\\<close>", "lemma inj_ket[simp]: \\<open>inj ket\\<close>", "lemma trunc_ell2_ket_cspan:\n  \\<open>trunc_ell2 S x \\<in> (cspan (range ket))\\<close> if \\<open>finite S\\<close>", "lemma closed_cspan_range_ket[simp]:\n  \\<open>closure (cspan (range ket)) = UNIV\\<close>", "lemma ccspan_range_ket[simp]: \"ccspan (range ket) = (top::('a ell2 ccsubspace))\"", "lemma cspan_range_ket_finite[simp]: \"cspan (range ket :: 'a::finite ell2 set) = UNIV\"", "lemma canonical_basis_length_ell2[code_unfold, simp]:\n  \"length (canonical_basis ::'a::enum ell2 list) = CARD('a)\"", "lemma ket_canonical_basis: \"ket x = canonical_basis ! enum_idx x\"", "lemma clinear_equal_ket:\n  fixes f g :: \\<open>'a::finite ell2 \\<Rightarrow> _\\<close>\n  assumes \\<open>clinear f\\<close>\n  assumes \\<open>clinear g\\<close>\n  assumes \\<open>\\<And>i. f (ket i) = g (ket i)\\<close>\n  shows \\<open>f = g\\<close>", "lemma equal_ket:\n  fixes A B :: \\<open>('a ell2, 'b::complex_normed_vector) cblinfun\\<close>\n  assumes \\<open>\\<And> x. cblinfun_apply A (ket x) = cblinfun_apply B (ket x)\\<close>\n  shows \\<open>A = B\\<close>", "lemma antilinear_equal_ket:\n  fixes f g :: \\<open>'a::finite ell2 \\<Rightarrow> _\\<close>\n  assumes \\<open>antilinear f\\<close>\n  assumes \\<open>antilinear g\\<close>\n  assumes \\<open>\\<And>i. f (ket i) = g (ket i)\\<close>\n  shows \\<open>f = g\\<close>", "lemma cinner_ket_adjointI:\n  fixes F::\"'a ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L _\" and G::\"'b ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L_\"\n  assumes \"\\<And> i j. \\<langle>F *\\<^sub>V ket i, ket j\\<rangle> = \\<langle>ket i, G *\\<^sub>V ket j\\<rangle>\"\n  shows \"F = G*\"", "lemma ket_nonzero[simp]: \"ket i \\<noteq> 0\"", "lemma cindependent_ket:\n  \"cindependent (range (ket::'a\\<Rightarrow>_))\"", "lemma cdim_UNIV_ell2[simp]: \\<open>cdim (UNIV::'a::finite ell2 set) = CARD('a)\\<close>", "lemma is_ortho_set_ket[simp]: \\<open>is_ortho_set (range ket)\\<close>", "lemma cspan_butterfly_ket: \\<open>cspan {butterfly (ket i) (ket j)| (i::'b::finite) (j::'a::finite). True} = UNIV\\<close>", "lemma cindependent_butterfly_ket: \\<open>cindependent {butterfly (ket i) (ket j)| (i::'b) (j::'a). True}\\<close>", "lemma clinear_eq_butterfly_ketI:\n  fixes F G :: \\<open>('a::finite ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::finite ell2) \\<Rightarrow> 'c::complex_vector\\<close>\n  assumes \"clinear F\" and \"clinear G\"\n  assumes \"\\<And>i j. F (butterfly (ket i) (ket j)) = G (butterfly (ket i) (ket j))\"\n  shows \"F = G\"", "lemma sum_butterfly_ket[simp]: \\<open>(\\<Sum>(i::'a::finite)\\<in>UNIV. butterfly (ket i) (ket i)) = id_cblinfun\\<close>", "lemma classical_operator_existsI:\n  assumes \"\\<And>x. B *\\<^sub>V (ket x) = (case \\<pi> x of Some i \\<Rightarrow> ket i | None \\<Rightarrow> 0)\"\n  shows \"classical_operator_exists \\<pi>\"", "lemma classical_operator_exists_inj:\n  assumes \"inj_map \\<pi>\"\n  shows \"classical_operator_exists \\<pi>\"", "lemma classical_operator_exists_finite[simp]: \"classical_operator_exists (\\<pi> :: _::finite \\<Rightarrow> _)\"", "lemma classical_operator_ket:\n  assumes \"classical_operator_exists \\<pi>\"\n  shows \"(classical_operator \\<pi>) *\\<^sub>V (ket x) = (case \\<pi> x of Some i \\<Rightarrow> ket i | None \\<Rightarrow> 0)\"", "lemma classical_operator_ket_finite:\n  \"(classical_operator \\<pi>) *\\<^sub>V (ket (x::'a::finite)) = (case \\<pi> x of Some i \\<Rightarrow> ket i | None \\<Rightarrow> 0)\"", "lemma classical_operator_adjoint[simp]:\n  fixes \\<pi> :: \"'a \\<Rightarrow> 'b option\"\n  assumes a1: \"inj_map \\<pi>\"\n  shows  \"(classical_operator \\<pi>)* = classical_operator (inv_map \\<pi>)\"", "lemma\n  fixes \\<pi>::\"'b \\<Rightarrow> 'c option\" and \\<rho>::\"'a \\<Rightarrow> 'b option\"\n  assumes \"classical_operator_exists \\<pi>\"\n  assumes \"classical_operator_exists \\<rho>\"\n  shows classical_operator_exists_comp[simp]: \"classical_operator_exists (\\<pi> \\<circ>\\<^sub>m \\<rho>)\"\n    and classical_operator_mult[simp]: \"classical_operator \\<pi> o\\<^sub>C\\<^sub>L classical_operator \\<rho> = classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>)\"", "lemma classical_operator_Some[simp]: \"classical_operator (Some::'a\\<Rightarrow>_) = id_cblinfun\"", "lemma isometry_classical_operator[simp]:\n  fixes \\<pi>::\"'a \\<Rightarrow> 'b\"\n  assumes a1: \"inj \\<pi>\"\n  shows \"isometry (classical_operator (Some o \\<pi>))\"", "lemma unitary_classical_operator[simp]:\n  fixes \\<pi>::\"'a \\<Rightarrow> 'b\"\n  assumes a1: \"bij \\<pi>\"\n  shows \"unitary (classical_operator (Some o \\<pi>))\""], "translations": [["", "lemma has_ell2_norm_infsetsum: \"has_ell2_norm x \\<longleftrightarrow> (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm x =\n    ((\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. has_ell2_norm x \\<Longrightarrow>\n    (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV\n 2. (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on\n    UNIV \\<Longrightarrow>\n    has_ell2_norm x", "define f where \"f i = (cmod (x i))\\<^sup>2\" for i"], ["proof (state)\nthis:\n  f ?i = (cmod (x ?i))\\<^sup>2\n\ngoal (2 subgoals):\n 1. has_ell2_norm x \\<Longrightarrow>\n    (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV\n 2. (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on\n    UNIV \\<Longrightarrow>\n    has_ell2_norm x", "assume fsums: \"f abs_summable_on UNIV\""], ["proof (state)\nthis:\n  f abs_summable_on UNIV\n\ngoal (2 subgoals):\n 1. has_ell2_norm x \\<Longrightarrow>\n    (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV\n 2. (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on\n    UNIV \\<Longrightarrow>\n    has_ell2_norm x", "define bound where \"bound = infsetsum f UNIV\""], ["proof (state)\nthis:\n  bound = infsetsum f UNIV\n\ngoal (2 subgoals):\n 1. has_ell2_norm x \\<Longrightarrow>\n    (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV\n 2. (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on\n    UNIV \\<Longrightarrow>\n    has_ell2_norm x", "have \"sum f F \\<le> bound\" if \"finite F\" for F"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f F \\<le> bound", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f F \\<le> bound", "have \"sum f F = infsetsum f F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f F = infsetsum f F", "using that"], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. sum f F = infsetsum f F", "by (rule infsetsum_finite[symmetric])"], ["proof (state)\nthis:\n  sum f F = infsetsum f F\n\ngoal (1 subgoal):\n 1. sum f F \\<le> bound", "also"], ["proof (state)\nthis:\n  sum f F = infsetsum f F\n\ngoal (1 subgoal):\n 1. sum f F \\<le> bound", "have \"infsetsum f F \\<le> infsetsum f UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infsetsum f F \\<le> infsetsum f UNIV", "proof (rule infsetsum_mono_neutral_left)"], ["proof (state)\ngoal (5 subgoals):\n 1. f abs_summable_on F\n 2. f abs_summable_on UNIV\n 3. \\<And>x. x \\<in> F \\<Longrightarrow> f x \\<le> f x\n 4. F \\<subseteq> UNIV\n 5. \\<And>x. x \\<in> UNIV - F \\<Longrightarrow> 0 \\<le> f x", "show \"f abs_summable_on F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f abs_summable_on F", "by (simp add: that)"], ["proof (state)\nthis:\n  f abs_summable_on F\n\ngoal (4 subgoals):\n 1. f abs_summable_on UNIV\n 2. \\<And>x. x \\<in> F \\<Longrightarrow> f x \\<le> f x\n 3. F \\<subseteq> UNIV\n 4. \\<And>x. x \\<in> UNIV - F \\<Longrightarrow> 0 \\<le> f x", "show \"f abs_summable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f abs_summable_on UNIV", "by (simp add: fsums)"], ["proof (state)\nthis:\n  f abs_summable_on UNIV\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> F \\<Longrightarrow> f x \\<le> f x\n 2. F \\<subseteq> UNIV\n 3. \\<And>x. x \\<in> UNIV - F \\<Longrightarrow> 0 \\<le> f x", "show \"f x \\<le> f x\"\n        if \"x \\<in> F\"\n        for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le> f x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> F\n\ngoal (1 subgoal):\n 1. f x \\<le> f x", "by simp"], ["proof (state)\nthis:\n  ?x \\<in> F \\<Longrightarrow> f ?x \\<le> f ?x\n\ngoal (2 subgoals):\n 1. F \\<subseteq> UNIV\n 2. \\<And>x. x \\<in> UNIV - F \\<Longrightarrow> 0 \\<le> f x", "show \"F \\<subseteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> UNIV", "by simp"], ["proof (state)\nthis:\n  F \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV - F \\<Longrightarrow> 0 \\<le> f x", "show \"0 \\<le> f x\"\n        if \"x \\<in> UNIV - F\"\n        for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> f x", "using that f_def"], ["proof (prove)\nusing this:\n  x \\<in> UNIV - F\n  f ?i = (cmod (x ?i))\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> f x", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> UNIV - F \\<Longrightarrow> 0 \\<le> f ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infsetsum f F \\<le> infsetsum f UNIV\n\ngoal (1 subgoal):\n 1. sum f F \\<le> bound", "finally"], ["proof (chain)\npicking this:\n  sum f F \\<le> infsetsum f UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  sum f F \\<le> infsetsum f UNIV\n\ngoal (1 subgoal):\n 1. sum f F \\<le> bound", "unfolding bound_def"], ["proof (prove)\nusing this:\n  sum f F \\<le> infsetsum f UNIV\n\ngoal (1 subgoal):\n 1. sum f F \\<le> infsetsum f UNIV", "by assumption"], ["proof (state)\nthis:\n  sum f F \\<le> bound\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow> sum f ?F \\<le> bound\n\ngoal (2 subgoals):\n 1. has_ell2_norm x \\<Longrightarrow>\n    (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV\n 2. (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on\n    UNIV \\<Longrightarrow>\n    has_ell2_norm x", "thus \"has_ell2_norm x\""], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow> sum f ?F \\<le> bound\n\ngoal (1 subgoal):\n 1. has_ell2_norm x", "unfolding has_ell2_norm_def f_def"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  (\\<Sum>i\\<in>?F. (cmod (x i))\\<^sup>2) \\<le> bound\n\ngoal (1 subgoal):\n 1. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)", "by (rule bdd_aboveI2[where M=bound], simp)"], ["proof (state)\nthis:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. has_ell2_norm x \\<Longrightarrow>\n    (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. has_ell2_norm x \\<Longrightarrow>\n    (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV", "have x1: \"\\<exists>B. \\<forall>F. finite F \\<longrightarrow> (\\<Sum>s\\<in>F. (cmod (x s))\\<^sup>2) < B\"\n    if \"\\<And>t. finite t \\<Longrightarrow> (\\<Sum>i\\<in>t. (cmod (x i))\\<^sup>2) \\<le> M\"\n    for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B.\n       \\<forall>F.\n          finite F \\<longrightarrow>\n          (\\<Sum>s\\<in>F. (cmod (x s))\\<^sup>2) < B", "using that"], ["proof (prove)\nusing this:\n  finite ?t \\<Longrightarrow> (\\<Sum>i\\<in>?t. (cmod (x i))\\<^sup>2) \\<le> M\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       \\<forall>F.\n          finite F \\<longrightarrow>\n          (\\<Sum>s\\<in>F. (cmod (x s))\\<^sup>2) < B", "by (meson gt_ex le_less_trans)"], ["proof (state)\nthis:\n  (\\<And>t.\n      finite t \\<Longrightarrow>\n      (\\<Sum>i\\<in>t. (cmod (x i))\\<^sup>2) \\<le> ?M) \\<Longrightarrow>\n  \\<exists>B.\n     \\<forall>F.\n        finite F \\<longrightarrow> (\\<Sum>s\\<in>F. (cmod (x s))\\<^sup>2) < B\n\ngoal (1 subgoal):\n 1. has_ell2_norm x \\<Longrightarrow>\n    (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV", "assume \"has_ell2_norm x\""], ["proof (state)\nthis:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. has_ell2_norm x \\<Longrightarrow>\n    (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV", "then"], ["proof (chain)\npicking this:\n  has_ell2_norm x", "obtain B where \"(\\<Sum>xa\\<in>F. norm ((cmod (x xa))\\<^sup>2)) < B\" if \"finite F\" for F"], ["proof (prove)\nusing this:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        (\\<And>F.\n            finite F \\<Longrightarrow>\n            (\\<Sum>xa\\<in>F. norm ((cmod (x xa))\\<^sup>2))\n            < B) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof atomize_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. has_ell2_norm x \\<Longrightarrow>\n    \\<exists>B.\n       \\<forall>F.\n          finite F \\<longrightarrow>\n          (\\<Sum>xa\\<in>F. norm ((cmod (x xa))\\<^sup>2)) < B", "show \"\\<exists>B. \\<forall>F. finite F \\<longrightarrow> (\\<Sum>xa\\<in>F. norm ((cmod (x xa))\\<^sup>2)) < B\"\n      if \"has_ell2_norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B.\n       \\<forall>F.\n          finite F \\<longrightarrow>\n          (\\<Sum>xa\\<in>F. norm ((cmod (x xa))\\<^sup>2)) < B", "using that x1"], ["proof (prove)\nusing this:\n  has_ell2_norm x\n  (\\<And>t.\n      finite t \\<Longrightarrow>\n      (\\<Sum>i\\<in>t. (cmod (x i))\\<^sup>2) \\<le> ?M) \\<Longrightarrow>\n  \\<exists>B.\n     \\<forall>F.\n        finite F \\<longrightarrow> (\\<Sum>s\\<in>F. (cmod (x s))\\<^sup>2) < B\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       \\<forall>F.\n          finite F \\<longrightarrow>\n          (\\<Sum>xa\\<in>F. norm ((cmod (x xa))\\<^sup>2)) < B", "unfolding has_ell2_norm_def"], ["proof (prove)\nusing this:\n  bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)\n  (\\<And>t.\n      finite t \\<Longrightarrow>\n      (\\<Sum>i\\<in>t. (cmod (x i))\\<^sup>2) \\<le> ?M) \\<Longrightarrow>\n  \\<exists>B.\n     \\<forall>F.\n        finite F \\<longrightarrow> (\\<Sum>s\\<in>F. (cmod (x s))\\<^sup>2) < B\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       \\<forall>F.\n          finite F \\<longrightarrow>\n          (\\<Sum>xa\\<in>F. norm ((cmod (x xa))\\<^sup>2)) < B", "unfolding bdd_above_def"], ["proof (prove)\nusing this:\n  \\<exists>M.\n     \\<forall>x\\<in>sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite.\n        x \\<le> M\n  (\\<And>t.\n      finite t \\<Longrightarrow>\n      (\\<Sum>i\\<in>t. (cmod (x i))\\<^sup>2) \\<le> ?M) \\<Longrightarrow>\n  \\<exists>B.\n     \\<forall>F.\n        finite F \\<longrightarrow> (\\<Sum>s\\<in>F. (cmod (x s))\\<^sup>2) < B\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       \\<forall>F.\n          finite F \\<longrightarrow>\n          (\\<Sum>xa\\<in>F. norm ((cmod (x xa))\\<^sup>2)) < B", "by auto"], ["proof (state)\nthis:\n  has_ell2_norm x \\<Longrightarrow>\n  \\<exists>B.\n     \\<forall>F.\n        finite F \\<longrightarrow>\n        (\\<Sum>xa\\<in>F. norm ((cmod (x xa))\\<^sup>2)) < B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow>\n  (\\<Sum>xa\\<in>?F. norm ((cmod (x xa))\\<^sup>2)) < B\n\ngoal (1 subgoal):\n 1. has_ell2_norm x \\<Longrightarrow>\n    (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV", "thus \"(\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  (\\<Sum>xa\\<in>?F. norm ((cmod (x xa))\\<^sup>2)) < B\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV", "proof (rule_tac abs_summable_finiteI [where B = B])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>\\<And>F.\n                   finite F \\<Longrightarrow>\n                   (\\<Sum>xa\\<in>F. norm ((cmod (x xa))\\<^sup>2)) < B;\n        finite F; F \\<subseteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>xa\\<in>F. norm ((cmod (x xa))\\<^sup>2))\n                         \\<le> B", "show \"(\\<Sum>t\\<in>F. norm ((cmod (x t))\\<^sup>2)) \\<le> B\"\n      if \"\\<And>F. finite F \\<Longrightarrow> (\\<Sum>s\\<in>F. norm ((cmod (x s))\\<^sup>2)) < B\"\n        and \"finite F\" and \"F \\<subseteq> UNIV\"\n      for F :: \"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>F. norm ((cmod (x t))\\<^sup>2)) \\<le> B", "using that"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  (\\<Sum>s\\<in>?F. norm ((cmod (x s))\\<^sup>2)) < B\n  finite F\n  F \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>F. norm ((cmod (x t))\\<^sup>2)) \\<le> B", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>F.\n              finite F \\<Longrightarrow>\n              (\\<Sum>s\\<in>F. norm ((cmod (x s))\\<^sup>2)) < B;\n   finite ?F; ?F \\<subseteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>t\\<in>?F. norm ((cmod (x t))\\<^sup>2)) \\<le> B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_ell2_norm_L2_set: \"has_ell2_norm x = bdd_above (L2_set (norm o x) ` Collect finite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm x = bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. has_ell2_norm x = bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)", "have bdd_above_image_mono': \"bdd_above (f`A)\"\n    if \"\\<And>x y. x\\<le>y \\<Longrightarrow> x:A \\<Longrightarrow> y:A \\<Longrightarrow> f x \\<le> f y\"\n      and \"\\<exists>M\\<in>A. \\<forall>x \\<in> A. x \\<le> M\"\n    for f::\"'a set\\<Rightarrow>real\" and A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (f ` A)", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<subseteq> ?y; ?x \\<in> A; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> f ?y\n  \\<exists>M\\<in>A. \\<forall>x\\<in>A. x \\<subseteq> M\n\ngoal (1 subgoal):\n 1. bdd_above (f ` A)", "unfolding bdd_above_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<subseteq> ?y; ?x \\<in> A; ?y \\<in> A\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> f ?y\n  \\<exists>M\\<in>A. \\<forall>x\\<in>A. x \\<subseteq> M\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>x\\<in>f ` A. x \\<le> M", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<subseteq> y; x \\<in> ?A; y \\<in> ?A\\<rbrakk>\n              \\<Longrightarrow> ?f x \\<le> ?f y;\n   \\<exists>M\\<in>?A. \\<forall>x\\<in>?A. x \\<subseteq> M\\<rbrakk>\n  \\<Longrightarrow> bdd_above (?f ` ?A)\n\ngoal (1 subgoal):\n 1. has_ell2_norm x = bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)", "have t3: \"bdd_above X \\<Longrightarrow> bdd_above (sqrt ` X)\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above X \\<Longrightarrow> bdd_above (sqrt ` X)", "by (meson bdd_aboveI2 bdd_above_def real_sqrt_le_iff)"], ["proof (state)\nthis:\n  bdd_above ?X \\<Longrightarrow> bdd_above (sqrt ` ?X)\n\ngoal (1 subgoal):\n 1. has_ell2_norm x = bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)", "moreover"], ["proof (state)\nthis:\n  bdd_above ?X \\<Longrightarrow> bdd_above (sqrt ` ?X)\n\ngoal (1 subgoal):\n 1. has_ell2_norm x = bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)", "have t2: \"bdd_above X\" if bdd_sqrt: \"bdd_above (sqrt ` X)\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above X", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. bdd_above X", "obtain y where y:\"y \\<ge> sqrt x\" if \"x:X\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        (\\<And>x.\n            x \\<in> X \\<Longrightarrow> sqrt x \\<le> y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using bdd_sqrt"], ["proof (prove)\nusing this:\n  bdd_above (sqrt ` X)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        (\\<And>x.\n            x \\<in> X \\<Longrightarrow> sqrt x \\<le> y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding bdd_above_def"], ["proof (prove)\nusing this:\n  \\<exists>M. \\<forall>x\\<in>sqrt ` X. x \\<le> M\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        (\\<And>x.\n            x \\<in> X \\<Longrightarrow> sqrt x \\<le> y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> sqrt ?x \\<le> y\n\ngoal (1 subgoal):\n 1. bdd_above X", "have \"y*y \\<ge> x\" if \"x:X\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y * y", "by (metis power2_eq_square sqrt_le_D that y)"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> ?x \\<le> y * y\n\ngoal (1 subgoal):\n 1. bdd_above X", "thus \"bdd_above X\""], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> ?x \\<le> y * y\n\ngoal (1 subgoal):\n 1. bdd_above X", "unfolding bdd_above_def"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> ?x \\<le> y * y\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>x\\<in>X. x \\<le> M", "by auto"], ["proof (state)\nthis:\n  bdd_above X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bdd_above (sqrt ` ?X) \\<Longrightarrow> bdd_above ?X\n\ngoal (1 subgoal):\n 1. has_ell2_norm x = bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)", "ultimately"], ["proof (chain)\npicking this:\n  bdd_above ?X \\<Longrightarrow> bdd_above (sqrt ` ?X)\n  bdd_above (sqrt ` ?X) \\<Longrightarrow> bdd_above ?X", "have bdd_sqrt: \"bdd_above X \\<longleftrightarrow> bdd_above (sqrt ` X)\" for X"], ["proof (prove)\nusing this:\n  bdd_above ?X \\<Longrightarrow> bdd_above (sqrt ` ?X)\n  bdd_above (sqrt ` ?X) \\<Longrightarrow> bdd_above ?X\n\ngoal (1 subgoal):\n 1. bdd_above X = bdd_above (sqrt ` X)", "by rule"], ["proof (state)\nthis:\n  bdd_above ?X = bdd_above (sqrt ` ?X)\n\ngoal (1 subgoal):\n 1. has_ell2_norm x = bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)", "have t1: \"bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n            bdd_above ((\\<lambda>A. sqrt (\\<Sum>i\\<in>A. ((cmod \\<circ> x) i)\\<^sup>2)) ` Collect finite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n    bdd_above\n     ((\\<lambda>A. sqrt (\\<Sum>i\\<in>A. ((cmod \\<circ> x) i)\\<^sup>2)) `\n      Collect finite)", "proof (rewrite asm_rl [of \"(\\<lambda>A. sqrt (sum (\\<lambda>i. ((cmod \\<circ> x) i)\\<^sup>2) A)) ` Collect finite \n                            = sqrt ` (\\<lambda>A. (\\<Sum>i\\<in>A. (cmod (x i))\\<^sup>2)) ` Collect finite\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>A. sqrt (\\<Sum>i\\<in>A. ((cmod \\<circ> x) i)\\<^sup>2)) `\n    Collect finite =\n    sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite\n 2. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n    bdd_above\n     (sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)", "show \"(\\<lambda>A. sqrt (\\<Sum>i\\<in>A. ((cmod \\<circ> x) i)\\<^sup>2)) ` Collect finite = sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>A. sqrt (\\<Sum>i\\<in>A. ((cmod \\<circ> x) i)\\<^sup>2)) `\n    Collect finite =\n    sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>A. sqrt (\\<Sum>i\\<in>A. ((cmod \\<circ> x) i)\\<^sup>2)) `\n  Collect finite =\n  sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite\n\ngoal (1 subgoal):\n 1. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n    bdd_above\n     (sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)", "show \"bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) = bdd_above (sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n    bdd_above\n     (sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)", "by (meson t2 t3)"], ["proof (state)\nthis:\n  bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n  bdd_above (sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n  bdd_above\n   ((\\<lambda>A. sqrt (\\<Sum>i\\<in>A. ((cmod \\<circ> x) i)\\<^sup>2)) `\n    Collect finite)\n\ngoal (1 subgoal):\n 1. has_ell2_norm x = bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)", "show \"has_ell2_norm x \\<longleftrightarrow> bdd_above (L2_set (norm o x) ` Collect finite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm x = bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)", "unfolding has_ell2_norm_def L2_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n    bdd_above\n     ((\\<lambda>A. sqrt (\\<Sum>i\\<in>A. ((cmod \\<circ> x) i)\\<^sup>2)) `\n      Collect finite)", "using t1"], ["proof (prove)\nusing this:\n  bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n  bdd_above\n   ((\\<lambda>A. sqrt (\\<Sum>i\\<in>A. ((cmod \\<circ> x) i)\\<^sup>2)) `\n    Collect finite)\n\ngoal (1 subgoal):\n 1. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n    bdd_above\n     ((\\<lambda>A. sqrt (\\<Sum>i\\<in>A. ((cmod \\<circ> x) i)\\<^sup>2)) `\n      Collect finite)", "."], ["proof (state)\nthis:\n  has_ell2_norm x = bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"ell2_norm x = sqrt (SUP F\\<in>{F. finite F}. sum (\\<lambda>i. norm (x i)^2) F)\" for x :: \\<open>'a \\<Rightarrow> complex\\<close>"], ["", "lemma ell2_norm_L2_set: \n  assumes \"has_ell2_norm x\"\n  shows \"ell2_norm x = (SUP F\\<in>{F. finite F}. L2_set (norm o x) F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm x = \\<Squnion> (L2_set (cmod \\<circ> x) ` {F. finite F})", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ell2_norm x = \\<Squnion> (L2_set (cmod \\<circ> x) ` {F. finite F})", "have \"sqrt (\\<Squnion> (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)) =\n      (SUP F\\<in>{F. finite F}. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)) =\n    (SUP F\\<in>{F. finite F}. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))", "proof (subst continuous_at_Sup_mono)"], ["proof (state)\ngoal (5 subgoals):\n 1. mono sqrt\n 2. continuous\n     (at_left\n       (\\<Squnion>\n         (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)))\n     sqrt\n 3. sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite \\<noteq> {}\n 4. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)\n 5. \\<Squnion>\n     (sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n    (SUP F\\<in>Collect finite. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))", "show \"mono sqrt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono sqrt", "by (simp add: mono_def)"], ["proof (state)\nthis:\n  mono sqrt\n\ngoal (4 subgoals):\n 1. continuous\n     (at_left\n       (\\<Squnion>\n         (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)))\n     sqrt\n 2. sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite \\<noteq> {}\n 3. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)\n 4. \\<Squnion>\n     (sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n    (SUP F\\<in>Collect finite. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))", "show \"continuous (at_left (\\<Squnion> (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite))) sqrt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous\n     (at_left\n       (\\<Squnion>\n         (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)))\n     sqrt", "using continuous_at_split isCont_real_sqrt"], ["proof (prove)\nusing this:\n  isCont ?f ?x =\n  (continuous (at_left ?x) ?f \\<and> continuous (at_right ?x) ?f)\n  isCont sqrt ?x\n\ngoal (1 subgoal):\n 1. continuous\n     (at_left\n       (\\<Squnion>\n         (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)))\n     sqrt", "by blast"], ["proof (state)\nthis:\n  continuous\n   (at_left\n     (\\<Squnion> (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)))\n   sqrt\n\ngoal (3 subgoals):\n 1. sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite \\<noteq> {}\n 2. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)\n 3. \\<Squnion>\n     (sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n    (SUP F\\<in>Collect finite. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))", "show \"sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite \\<noteq> {}\n\ngoal (2 subgoals):\n 1. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)\n 2. \\<Squnion>\n     (sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n    (SUP F\\<in>Collect finite. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))", "show \"bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)", "by (metis assms has_ell2_norm_def)"], ["proof (state)\nthis:\n  bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)\n\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n    (SUP F\\<in>Collect finite. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))", "show \"\\<Squnion> (sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) = (SUP F\\<in>Collect finite. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n    (SUP F\\<in>Collect finite. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))", "by (metis image_image)"], ["proof (state)\nthis:\n  \\<Squnion>\n   (sqrt ` sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n  (SUP F\\<in>Collect finite. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sqrt\n   (\\<Squnion> (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)) =\n  (SUP F\\<in>{F. finite F}. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))\n\ngoal (1 subgoal):\n 1. ell2_norm x = \\<Squnion> (L2_set (cmod \\<circ> x) ` {F. finite F})", "thus ?thesis"], ["proof (prove)\nusing this:\n  sqrt\n   (\\<Squnion> (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)) =\n  (SUP F\\<in>{F. finite F}. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))\n\ngoal (1 subgoal):\n 1. ell2_norm x = \\<Squnion> (L2_set (cmod \\<circ> x) ` {F. finite F})", "unfolding ell2_norm_def L2_set_def o_def"], ["proof (prove)\nusing this:\n  sqrt\n   (\\<Squnion> (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)) =\n  (SUP F\\<in>{F. finite F}. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)) =\n    (SUP F\\<in>{F. finite F}. sqrt (\\<Sum>i\\<in>F. (cmod (x i))\\<^sup>2))", "."], ["proof (state)\nthis:\n  ell2_norm x = \\<Squnion> (L2_set (cmod \\<circ> x) ` {F. finite F})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ell2_norm_infsetsum:\n  assumes \"has_ell2_norm x\"\n  shows \"ell2_norm x = sqrt (infsetsum (\\<lambda>i. (norm(x i))^2) UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm x = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ell2_norm x = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)", "have \"ell2_norm x = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm x = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)", "proof (subst infsetsum_nonneg_is_SUPREMUM)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV\n 2. \\<And>xa. xa \\<in> UNIV \\<Longrightarrow> 0 \\<le> (cmod (x xa))\\<^sup>2\n 3. ell2_norm x =\n    sqrt\n     (\\<Squnion>\n       (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) `\n        {F. finite F \\<and> F \\<subseteq> UNIV}))", "show \"(\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV", "using assms has_ell2_norm_infsetsum"], ["proof (prove)\nusing this:\n  has_ell2_norm x\n  has_ell2_norm ?x =\n  ((\\<lambda>i. (cmod (?x i))\\<^sup>2) abs_summable_on UNIV)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>i. (cmod (x i))\\<^sup>2) abs_summable_on UNIV\n\ngoal (2 subgoals):\n 1. \\<And>xa. xa \\<in> UNIV \\<Longrightarrow> 0 \\<le> (cmod (x xa))\\<^sup>2\n 2. ell2_norm x =\n    sqrt\n     (\\<Squnion>\n       (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) `\n        {F. finite F \\<and> F \\<subseteq> UNIV}))", "show \"0 \\<le> (cmod (x t))\\<^sup>2\"\n      if \"t \\<in> UNIV\"\n      for t :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (cmod (x t))\\<^sup>2", "using that"], ["proof (prove)\nusing this:\n  t \\<in> UNIV\n\ngoal (1 subgoal):\n 1. 0 \\<le> (cmod (x t))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  ?t \\<in> UNIV \\<Longrightarrow> 0 \\<le> (cmod (x ?t))\\<^sup>2\n\ngoal (1 subgoal):\n 1. ell2_norm x =\n    sqrt\n     (\\<Squnion>\n       (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) `\n        {F. finite F \\<and> F \\<subseteq> UNIV}))", "show \"ell2_norm x = sqrt (\\<Squnion> (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` {F. finite F \\<and> F \\<subseteq> UNIV}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm x =\n    sqrt\n     (\\<Squnion>\n       (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) `\n        {F. finite F \\<and> F \\<subseteq> UNIV}))", "unfolding ell2_norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)) =\n    sqrt\n     (\\<Squnion>\n       (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) `\n        {F. finite F \\<and> F \\<subseteq> UNIV}))", "by auto"], ["proof (state)\nthis:\n  ell2_norm x =\n  sqrt\n   (\\<Squnion>\n     (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) `\n      {F. finite F \\<and> F \\<subseteq> UNIV}))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ell2_norm x = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. ell2_norm x = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ell2_norm x = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. ell2_norm x = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  ell2_norm x = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_ell2_norm_finite[simp]: \"has_ell2_norm (x::'a::finite\\<Rightarrow>_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm x", "unfolding has_ell2_norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)", "by simp"], ["", "lemma ell2_norm_finite: \n  \"ell2_norm (x::'a::finite\\<Rightarrow>complex) = sqrt (sum (\\<lambda>i. (norm(x i))^2) UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm x = sqrt (\\<Sum>i\\<in>UNIV. (cmod (x i))\\<^sup>2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ell2_norm x = sqrt (\\<Sum>i\\<in>UNIV. (cmod (x i))\\<^sup>2)", "have \"(\\<Sum>i\\<in>t. (cmod (x i))\\<^sup>2) \\<le> (\\<Sum>i\\<in>y. (cmod (x i))\\<^sup>2)\"\n    if \"t \\<subseteq> y\"\n    for t y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>t. (cmod (x i))\\<^sup>2)\n    \\<le> (\\<Sum>i\\<in>y. (cmod (x i))\\<^sup>2)", "proof (subst sum_mono2)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite y\n 2. t \\<subseteq> y\n 3. \\<And>b. b \\<in> y - t \\<Longrightarrow> 0 \\<le> (cmod (x b))\\<^sup>2\n 4. True", "show \"finite y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite y", "by simp"], ["proof (state)\nthis:\n  finite y\n\ngoal (3 subgoals):\n 1. t \\<subseteq> y\n 2. \\<And>b. b \\<in> y - t \\<Longrightarrow> 0 \\<le> (cmod (x b))\\<^sup>2\n 3. True", "show \"t \\<subseteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<subseteq> y", "using that"], ["proof (prove)\nusing this:\n  t \\<subseteq> y\n\ngoal (1 subgoal):\n 1. t \\<subseteq> y", "."], ["proof (state)\nthis:\n  t \\<subseteq> y\n\ngoal (2 subgoals):\n 1. \\<And>b. b \\<in> y - t \\<Longrightarrow> 0 \\<le> (cmod (x b))\\<^sup>2\n 2. True", "show \"0 \\<le> (cmod (x b))\\<^sup>2\"\n      if \"b \\<in> y - t\"\n      for b :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (cmod (x b))\\<^sup>2", "using that"], ["proof (prove)\nusing this:\n  b \\<in> y - t\n\ngoal (1 subgoal):\n 1. 0 \\<le> (cmod (x b))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  ?b \\<in> y - t \\<Longrightarrow> 0 \\<le> (cmod (x ?b))\\<^sup>2\n\ngoal (1 subgoal):\n 1. True", "show True"], ["proof (prove)\ngoal (1 subgoal):\n 1. True", "by blast"], ["proof (state)\nthis:\n  True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<subseteq> ?y \\<Longrightarrow>\n  (\\<Sum>i\\<in>?t. (cmod (x i))\\<^sup>2)\n  \\<le> (\\<Sum>i\\<in>?y. (cmod (x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. ell2_norm x = sqrt (\\<Sum>i\\<in>UNIV. (cmod (x i))\\<^sup>2)", "hence mono: \"mono (sum (\\<lambda>i. (cmod (x i))\\<^sup>2))\""], ["proof (prove)\nusing this:\n  ?t \\<subseteq> ?y \\<Longrightarrow>\n  (\\<Sum>i\\<in>?t. (cmod (x i))\\<^sup>2)\n  \\<le> (\\<Sum>i\\<in>?y. (cmod (x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. mono (sum (\\<lambda>i. (cmod (x i))\\<^sup>2))", "unfolding mono_def"], ["proof (prove)\nusing this:\n  ?t \\<subseteq> ?y \\<Longrightarrow>\n  (\\<Sum>i\\<in>?t. (cmod (x i))\\<^sup>2)\n  \\<le> (\\<Sum>i\\<in>?y. (cmod (x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<forall>xa y.\n       xa \\<subseteq> y \\<longrightarrow>\n       (\\<Sum>i\\<in>xa. (cmod (x i))\\<^sup>2)\n       \\<le> (\\<Sum>i\\<in>y. (cmod (x i))\\<^sup>2)", "by blast"], ["proof (state)\nthis:\n  mono (sum (\\<lambda>i. (cmod (x i))\\<^sup>2))\n\ngoal (1 subgoal):\n 1. ell2_norm x = sqrt (\\<Sum>i\\<in>UNIV. (cmod (x i))\\<^sup>2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm x = sqrt (\\<Sum>i\\<in>UNIV. (cmod (x i))\\<^sup>2)", "unfolding ell2_norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)) =\n    sqrt (\\<Sum>i\\<in>UNIV. (cmod (x i))\\<^sup>2)", "apply (subst image_of_maximum[where m=UNIV])"], ["proof (prove)\ngoal (4 subgoals):\n 1. mono (sum (\\<lambda>i. (cmod (x i))\\<^sup>2))\n 2. \\<And>x. x \\<in> Collect finite \\<Longrightarrow> x \\<subseteq> UNIV\n 3. UNIV \\<in> Collect finite\n 4. sqrt (\\<Sum>i\\<in>UNIV. (cmod (x i))\\<^sup>2) =\n    sqrt (\\<Sum>i\\<in>UNIV. (cmod (x i))\\<^sup>2)", "using mono"], ["proof (prove)\nusing this:\n  mono (sum (\\<lambda>i. (cmod (x i))\\<^sup>2))\n\ngoal (4 subgoals):\n 1. mono (sum (\\<lambda>i. (cmod (x i))\\<^sup>2))\n 2. \\<And>x. x \\<in> Collect finite \\<Longrightarrow> x \\<subseteq> UNIV\n 3. UNIV \\<in> Collect finite\n 4. sqrt (\\<Sum>i\\<in>UNIV. (cmod (x i))\\<^sup>2) =\n    sqrt (\\<Sum>i\\<in>UNIV. (cmod (x i))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  ell2_norm x = sqrt (\\<Sum>i\\<in>UNIV. (cmod (x i))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ell2_norm_finite_L2_set: \"ell2_norm (x::'a::finite\\<Rightarrow>complex) = L2_set (norm o x) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm x = L2_set (cmod \\<circ> x) UNIV", "proof (subst ell2_norm_L2_set)"], ["proof (state)\ngoal (2 subgoals):\n 1. has_ell2_norm x\n 2. \\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite) =\n    L2_set (cmod \\<circ> x) UNIV", "show \"has_ell2_norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm x", "by simp"], ["proof (state)\nthis:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. \\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite) =\n    L2_set (cmod \\<circ> x) UNIV", "show \"\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite) = L2_set (cmod \\<circ> x) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite) =\n    L2_set (cmod \\<circ> x) UNIV", "proof (subst image_of_maximum[where m = UNIV])"], ["proof (state)\ngoal (4 subgoals):\n 1. mono (L2_set (cmod \\<circ> x))\n 2. \\<And>x. x \\<in> Collect finite \\<Longrightarrow> x \\<subseteq> UNIV\n 3. UNIV \\<in> Collect finite\n 4. L2_set (cmod \\<circ> x) UNIV = L2_set (cmod \\<circ> x) UNIV", "show \"mono (L2_set (cmod \\<circ> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (L2_set (cmod \\<circ> x))", "by (auto simp: mono_def intro!: L2_set_mono2)"], ["proof (state)\nthis:\n  mono (L2_set (cmod \\<circ> x))\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> Collect finite \\<Longrightarrow> x \\<subseteq> UNIV\n 2. UNIV \\<in> Collect finite\n 3. L2_set (cmod \\<circ> x) UNIV = L2_set (cmod \\<circ> x) UNIV", "show \"(x::'a set) \\<subseteq> UNIV\"\n      if \"(x::'a set) \\<in> Collect finite\"\n      for x :: \"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<subseteq> UNIV", "using that"], ["proof (prove)\nusing this:\n  x \\<in> Collect finite\n\ngoal (1 subgoal):\n 1. x \\<subseteq> UNIV", "by simp"], ["proof (state)\nthis:\n  ?x \\<in> Collect finite \\<Longrightarrow> ?x \\<subseteq> UNIV\n\ngoal (2 subgoals):\n 1. UNIV \\<in> Collect finite\n 2. L2_set (cmod \\<circ> x) UNIV = L2_set (cmod \\<circ> x) UNIV", "show \"(UNIV::'a set) \\<in> Collect finite\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<in> Collect finite", "by simp"], ["proof (state)\nthis:\n  UNIV \\<in> Collect finite\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> x) UNIV = L2_set (cmod \\<circ> x) UNIV", "show \"L2_set (cmod \\<circ> x) UNIV = L2_set (cmod \\<circ> x) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> x) UNIV = L2_set (cmod \\<circ> x) UNIV", "by simp"], ["proof (state)\nthis:\n  L2_set (cmod \\<circ> x) UNIV = L2_set (cmod \\<circ> x) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite) =\n  L2_set (cmod \\<circ> x) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ell2_ket:\n  fixes a\n  defines \\<open>f \\<equiv> (\\<lambda>i. if a = i then 1 else 0)\\<close>\n  shows has_ell2_norm_ket: \\<open>has_ell2_norm f\\<close>\n    and ell2_norm_ket: \\<open>ell2_norm f = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm f &&& ell2_norm f = 1", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. has_ell2_norm f\n 2. ell2_norm f = 1", "have finite_bound: \\<open>(\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) \\<le> 1\\<close> if \\<open>finite F\\<close> for F"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) \\<le> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) \\<le> 1", "have \"(\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 0\" if \"a\\<notin>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 0", "proof (subst sum.cong [where B = F and h = \"\\<lambda>_. 0\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. F = F\n 2. \\<And>x.\n       x \\<in> F \\<Longrightarrow>\n       (cmod (if a = x then 1 else 0))\\<^sup>2 = 0\n 3. (\\<Sum>_\\<in>F. 0) = 0", "show \"F = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = F", "by blast"], ["proof (state)\nthis:\n  F = F\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> F \\<Longrightarrow>\n       (cmod (if a = x then 1 else 0))\\<^sup>2 = 0\n 2. (\\<Sum>_\\<in>F. 0) = 0", "show \"(cmod (if a = x then 1 else 0))\\<^sup>2 = 0\"\n        if \"x \\<in> F\"\n        for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (if a = x then 1 else 0))\\<^sup>2 = 0", "using that \\<open>a \\<notin> F\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> F\n  a \\<notin> F\n\ngoal (1 subgoal):\n 1. (cmod (if a = x then 1 else 0))\\<^sup>2 = 0", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> F \\<Longrightarrow> (cmod (if a = ?x then 1 else 0))\\<^sup>2 = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>_\\<in>F. 0) = 0", "show \"(\\<Sum>_\\<in>F. (0::real)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>_\\<in>F. 0) = 0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>_\\<in>F. 0) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<notin> F \\<Longrightarrow>\n  (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) \\<le> 1", "moreover"], ["proof (state)\nthis:\n  a \\<notin> F \\<Longrightarrow>\n  (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) \\<le> 1", "have \"(\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1\" if \"a\\<in>F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1", "obtain F0 where \"a\\<notin>F0\" and F_F0: \"F=insert a F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>a \\<notin> F0; F = insert a F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson \\<open>a \\<in> F\\<close> mk_disjoint_insert)"], ["proof (state)\nthis:\n  a \\<notin> F0\n  F = insert a F0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1", "have \"(\\<Sum>i\\<in>insert a F0. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>insert a F0. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1", "proof (subst sum.insert_remove)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite F0\n 2. (cmod (if a = a then 1 else 0))\\<^sup>2 +\n    (\\<Sum>i\\<in>F0 - {a}. (cmod (if a = i then 1 else 0))\\<^sup>2) =\n    1", "show \"finite F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite F0", "using F_F0 \\<open>finite F\\<close>"], ["proof (prove)\nusing this:\n  F = insert a F0\n  finite F\n\ngoal (1 subgoal):\n 1. finite F0", "by auto"], ["proof (state)\nthis:\n  finite F0\n\ngoal (1 subgoal):\n 1. (cmod (if a = a then 1 else 0))\\<^sup>2 +\n    (\\<Sum>i\\<in>F0 - {a}. (cmod (if a = i then 1 else 0))\\<^sup>2) =\n    1", "show \"(cmod (if a = a then 1 else 0))\\<^sup>2 + (\\<Sum>i\\<in>F0 - {a}. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (if a = a then 1 else 0))\\<^sup>2 +\n    (\\<Sum>i\\<in>F0 - {a}. (cmod (if a = i then 1 else 0))\\<^sup>2) =\n    1", "using sum.not_neutral_contains_not_neutral"], ["proof (prove)\nusing this:\n  \\<lbrakk>sum ?g ?A \\<noteq> (0::?'a);\n   \\<And>a.\n      \\<lbrakk>a \\<in> ?A; ?g a \\<noteq> (0::?'a)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (cmod (if a = a then 1 else 0))\\<^sup>2 +\n    (\\<Sum>i\\<in>F0 - {a}. (cmod (if a = i then 1 else 0))\\<^sup>2) =\n    1", "by fastforce"], ["proof (state)\nthis:\n  (cmod (if a = a then 1 else 0))\\<^sup>2 +\n  (\\<Sum>i\\<in>F0 - {a}. (cmod (if a = i then 1 else 0))\\<^sup>2) =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert a F0. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1", "thus \"(\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1\""], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>insert a F0. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1", "unfolding F_F0"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>insert a F0. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>insert a F0. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1", "."], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<in> F \\<Longrightarrow>\n  (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) \\<le> 1", "ultimately"], ["proof (chain)\npicking this:\n  a \\<notin> F \\<Longrightarrow>\n  (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 0\n  a \\<in> F \\<Longrightarrow>\n  (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1", "show \"(\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) \\<le> 1\""], ["proof (prove)\nusing this:\n  a \\<notin> F \\<Longrightarrow>\n  (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 0\n  a \\<in> F \\<Longrightarrow>\n  (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) \\<le> 1", "unfolding f_def"], ["proof (prove)\nusing this:\n  a \\<notin> F \\<Longrightarrow>\n  (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 0\n  a \\<in> F \\<Longrightarrow>\n  (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) \\<le> 1", "by linarith"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>F. (cmod (if a = i then 1 else 0))\\<^sup>2) \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow>\n  (\\<Sum>i\\<in>?F. (cmod (if a = i then 1 else 0))\\<^sup>2) \\<le> 1\n\ngoal (2 subgoals):\n 1. has_ell2_norm f\n 2. ell2_norm f = 1", "show \\<open>has_ell2_norm f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm f", "using finite_bound"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  (\\<Sum>i\\<in>?F. (cmod (if a = i then 1 else 0))\\<^sup>2) \\<le> 1\n\ngoal (1 subgoal):\n 1. has_ell2_norm f", "by (auto intro!: bdd_aboveI[where M=1] simp: f_def has_ell2_norm_def)"], ["proof (state)\nthis:\n  has_ell2_norm f\n\ngoal (1 subgoal):\n 1. ell2_norm f = 1", "have \\<open>(SUP F\\<in>{F. finite F}. sum (\\<lambda>i. norm (f i)^2) F) = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (sum (\\<lambda>i. (cmod (f i))\\<^sup>2) ` {F. finite F}) = 1", "using finite_bound"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  (\\<Sum>i\\<in>?F. (cmod (if a = i then 1 else 0))\\<^sup>2) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<Squnion> (sum (\\<lambda>i. (cmod (f i))\\<^sup>2) ` {F. finite F}) = 1", "by (auto intro!: cSup_eq_maximum rev_image_eqI[where x=\\<open>{a}\\<close>]\n        simp: f_def)"], ["proof (state)\nthis:\n  \\<Squnion> (sum (\\<lambda>i. (cmod (f i))\\<^sup>2) ` {F. finite F}) = 1\n\ngoal (1 subgoal):\n 1. ell2_norm f = 1", "then"], ["proof (chain)\npicking this:\n  \\<Squnion> (sum (\\<lambda>i. (cmod (f i))\\<^sup>2) ` {F. finite F}) = 1", "show \\<open>ell2_norm f = 1\\<close>"], ["proof (prove)\nusing this:\n  \\<Squnion> (sum (\\<lambda>i. (cmod (f i))\\<^sup>2) ` {F. finite F}) = 1\n\ngoal (1 subgoal):\n 1. ell2_norm f = 1", "unfolding ell2_norm_def"], ["proof (prove)\nusing this:\n  \\<Squnion> (sum (\\<lambda>i. (cmod (f i))\\<^sup>2) ` {F. finite F}) = 1\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       (sum (\\<lambda>i. (cmod (f i))\\<^sup>2) ` Collect finite)) =\n    1", "by simp"], ["proof (state)\nthis:\n  ell2_norm f = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ell2_norm_geq0:\n  assumes \\<open>has_ell2_norm x\\<close>\n  shows \\<open>ell2_norm x \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> ell2_norm x", "by (smt (verit, ccfv_SIG) assms cSUP_upper2 ell2_norm_def finite.intros(1) has_ell2_norm_def mem_Collect_eq real_sqrt_abs real_sqrt_le_iff sum.empty zero_power2)"], ["", "lemma ell2_norm_point_bound:\n  assumes \\<open>has_ell2_norm x\\<close>\n  shows \\<open>ell2_norm x \\<ge> cmod (x i)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (x i) \\<le> ell2_norm x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (x i) \\<le> ell2_norm x", "have \\<open>(cmod (x i))\\<^sup>2 = sum (\\<lambda>i. (cmod (x i))\\<^sup>2) {i}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (x i))\\<^sup>2 = (\\<Sum>i\\<in>{i}. (cmod (x i))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  (cmod (x i))\\<^sup>2 = (\\<Sum>i\\<in>{i}. (cmod (x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. cmod (x i) \\<le> ell2_norm x", "also"], ["proof (state)\nthis:\n  (cmod (x i))\\<^sup>2 = (\\<Sum>i\\<in>{i}. (cmod (x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. cmod (x i) \\<le> ell2_norm x", "have \"\\<dots> \\<le> (\\<Squnion> (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i}. (cmod (x i))\\<^sup>2)\n    \\<le> \\<Squnion>\n           (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)", "apply (rule cSUP_upper2[where x=\\<open>{i}\\<close>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)\n 2. {i} \\<in> Collect finite\n 3. (\\<Sum>i\\<in>{i}. (cmod (x i))\\<^sup>2)\n    \\<le> (\\<Sum>i\\<in>{i}. (cmod (x i))\\<^sup>2)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)", "by (metis assms has_ell2_norm_def)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i}. (cmod (x i))\\<^sup>2)\n  \\<le> \\<Squnion> (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)\n\ngoal (1 subgoal):\n 1. cmod (x i) \\<le> ell2_norm x", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{i}. (cmod (x i))\\<^sup>2)\n  \\<le> \\<Squnion> (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)\n\ngoal (1 subgoal):\n 1. cmod (x i) \\<le> ell2_norm x", "have \\<open>\\<dots> = (ell2_norm x)^2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n    (ell2_norm x)\\<^sup>2", "by (smt (verit, best) SUP_cong calculation ell2_norm_def norm_ge_zero norm_power_ineq real_sqrt_pow2 sum.cong)"], ["proof (state)\nthis:\n  \\<Squnion> (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite) =\n  (ell2_norm x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (x i) \\<le> ell2_norm x", "finally"], ["proof (chain)\npicking this:\n  (cmod (x i))\\<^sup>2 \\<le> (ell2_norm x)\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  (cmod (x i))\\<^sup>2 \\<le> (ell2_norm x)\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (x i) \\<le> ell2_norm x", "by (simp add: assms ell2_norm_geq0)"], ["proof (state)\nthis:\n  cmod (x i) \\<le> ell2_norm x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ell2_norm_0:\n  assumes \"has_ell2_norm x\"\n  shows \"(ell2_norm x = 0) = (x = (\\<lambda>_. 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ell2_norm x = 0) = (x = (\\<lambda>_. 0))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ell2_norm x = 0 \\<Longrightarrow> x = (\\<lambda>_. 0)\n 2. x = (\\<lambda>_. 0) \\<Longrightarrow> ell2_norm x = 0", "assume u1: \"x = (\\<lambda>_. 0)\""], ["proof (state)\nthis:\n  x = (\\<lambda>_. 0)\n\ngoal (2 subgoals):\n 1. ell2_norm x = 0 \\<Longrightarrow> x = (\\<lambda>_. 0)\n 2. x = (\\<lambda>_. 0) \\<Longrightarrow> ell2_norm x = 0", "have u2: \"(SUP x::'a set\\<in>Collect finite. (0::real)) = 0\"\n    if \"x = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP x\\<in>Collect finite. 0) = 0", "by (metis cSUP_const empty_Collect_eq finite.emptyI)"], ["proof (state)\nthis:\n  x = (\\<lambda>_. 0) \\<Longrightarrow> (SUP x\\<in>Collect finite. 0) = 0\n\ngoal (2 subgoals):\n 1. ell2_norm x = 0 \\<Longrightarrow> x = (\\<lambda>_. 0)\n 2. x = (\\<lambda>_. 0) \\<Longrightarrow> ell2_norm x = 0", "show \"ell2_norm x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm x = 0", "unfolding ell2_norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)) =\n    0", "using u1 u2"], ["proof (prove)\nusing this:\n  x = (\\<lambda>_. 0)\n  x = (\\<lambda>_. 0) \\<Longrightarrow> (SUP x\\<in>Collect finite. 0) = 0\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)) =\n    0", "by auto"], ["proof (state)\nthis:\n  ell2_norm x = 0\n\ngoal (1 subgoal):\n 1. ell2_norm x = 0 \\<Longrightarrow> x = (\\<lambda>_. 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ell2_norm x = 0 \\<Longrightarrow> x = (\\<lambda>_. 0)", "assume norm0: \"ell2_norm x = 0\""], ["proof (state)\nthis:\n  ell2_norm x = 0\n\ngoal (1 subgoal):\n 1. ell2_norm x = 0 \\<Longrightarrow> x = (\\<lambda>_. 0)", "show \"x = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (\\<lambda>_. 0)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>uu_. x uu_ = 0", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>uu_. x uu_ = 0", "have \\<open>cmod (x i) \\<le> ell2_norm x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (x i) \\<le> ell2_norm x", "using assms"], ["proof (prove)\nusing this:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. cmod (x i) \\<le> ell2_norm x", "by (rule ell2_norm_point_bound)"], ["proof (state)\nthis:\n  cmod (x i) \\<le> ell2_norm x\n\ngoal (1 subgoal):\n 1. \\<And>uu_. x uu_ = 0", "also"], ["proof (state)\nthis:\n  cmod (x i) \\<le> ell2_norm x\n\ngoal (1 subgoal):\n 1. \\<And>uu_. x uu_ = 0", "have \\<open>\\<dots> = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm x = 0", "by (fact norm0)"], ["proof (state)\nthis:\n  ell2_norm x = 0\n\ngoal (1 subgoal):\n 1. \\<And>uu_. x uu_ = 0", "finally"], ["proof (chain)\npicking this:\n  cmod (x i) \\<le> 0", "show \"x i = 0\""], ["proof (prove)\nusing this:\n  cmod (x i) \\<le> 0\n\ngoal (1 subgoal):\n 1. x i = 0", "by auto"], ["proof (state)\nthis:\n  x i = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = (\\<lambda>_. 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ell2_norm_smult:\n  assumes \"has_ell2_norm x\"\n  shows \"has_ell2_norm (\\<lambda>i. c * x i)\" and \"ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm (\\<lambda>i. c * x i) &&&\n    ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. has_ell2_norm (\\<lambda>i. c * x i)\n 2. ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x", "have L2_set_mul: \"L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F = cmod c * L2_set (cmod \\<circ> x) F\" for F"], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F =\n    cmod c * L2_set (cmod \\<circ> x) F", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F =\n    cmod c * L2_set (cmod \\<circ> x) F", "have \"L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F = L2_set (\\<lambda>i. (cmod c * (cmod o x) i)) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F =\n    L2_set (\\<lambda>i. cmod c * (cmod \\<circ> x) i) F", "by (metis comp_def norm_mult)"], ["proof (state)\nthis:\n  L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F =\n  L2_set (\\<lambda>i. cmod c * (cmod \\<circ> x) i) F\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F =\n    cmod c * L2_set (cmod \\<circ> x) F", "also"], ["proof (state)\nthis:\n  L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F =\n  L2_set (\\<lambda>i. cmod c * (cmod \\<circ> x) i) F\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F =\n    cmod c * L2_set (cmod \\<circ> x) F", "have \"\\<dots> = cmod c * L2_set (cmod o x) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (\\<lambda>i. cmod c * (cmod \\<circ> x) i) F =\n    cmod c * L2_set (cmod \\<circ> x) F", "by (metis norm_ge_zero L2_set_right_distrib)"], ["proof (state)\nthis:\n  L2_set (\\<lambda>i. cmod c * (cmod \\<circ> x) i) F =\n  cmod c * L2_set (cmod \\<circ> x) F\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F =\n    cmod c * L2_set (cmod \\<circ> x) F", "finally"], ["proof (chain)\npicking this:\n  L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F =\n  cmod c * L2_set (cmod \\<circ> x) F", "show ?thesis"], ["proof (prove)\nusing this:\n  L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F =\n  cmod c * L2_set (cmod \\<circ> x) F\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F =\n    cmod c * L2_set (cmod \\<circ> x) F", "."], ["proof (state)\nthis:\n  L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F =\n  cmod c * L2_set (cmod \\<circ> x) F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ?F =\n  cmod c * L2_set (cmod \\<circ> x) ?F\n\ngoal (2 subgoals):\n 1. has_ell2_norm (\\<lambda>i. c * x i)\n 2. ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x", "from assms"], ["proof (chain)\npicking this:\n  has_ell2_norm x", "obtain M where M: \"M \\<ge> L2_set (cmod o x) F\" if \"finite F\" for F"], ["proof (prove)\nusing this:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        (\\<And>F.\n            finite F \\<Longrightarrow>\n            L2_set (cmod \\<circ> x) F \\<le> M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding has_ell2_norm_L2_set bdd_above_def"], ["proof (prove)\nusing this:\n  \\<exists>M.\n     \\<forall>x\\<in>L2_set (cmod \\<circ> x) ` Collect finite. x \\<le> M\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        (\\<And>F.\n            finite F \\<Longrightarrow>\n            L2_set (cmod \\<circ> x) F \\<le> M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow> L2_set (cmod \\<circ> x) ?F \\<le> M\n\ngoal (2 subgoals):\n 1. has_ell2_norm (\\<lambda>i. c * x i)\n 2. ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x", "hence \"cmod c * M \\<ge> L2_set (cmod o (\\<lambda>i. c * x i)) F\" if \"finite F\" for F"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow> L2_set (cmod \\<circ> x) ?F \\<le> M\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F \\<le> cmod c * M", "unfolding L2_set_mul"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow> L2_set (cmod \\<circ> x) ?F \\<le> M\n\ngoal (1 subgoal):\n 1. cmod c * L2_set (cmod \\<circ> x) F \\<le> cmod c * M", "by (simp add: ordered_comm_semiring_class.comm_mult_left_mono that)"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ?F \\<le> cmod c * M\n\ngoal (2 subgoals):\n 1. has_ell2_norm (\\<lambda>i. c * x i)\n 2. ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x", "thus has: \"has_ell2_norm (\\<lambda>i. c * x i)\""], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ?F \\<le> cmod c * M\n\ngoal (1 subgoal):\n 1. has_ell2_norm (\\<lambda>i. c * x i)", "unfolding has_ell2_norm_L2_set bdd_above_def"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ?F \\<le> cmod c * M\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>x\\<in>L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) `\n                      Collect finite.\n          x \\<le> M", "using L2_set_mul[symmetric]"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ?F \\<le> cmod c * M\n  cmod c * L2_set (cmod \\<circ> x) ?F =\n  L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ?F\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>x\\<in>L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) `\n                      Collect finite.\n          x \\<le> M", "by auto"], ["proof (state)\nthis:\n  has_ell2_norm (\\<lambda>i. c * x i)\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x", "have \"ell2_norm (\\<lambda>i. c * x i) = (SUP F \\<in> Collect finite. (L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. c * x i) =\n    \\<Squnion>\n     (L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ` Collect finite)", "by (simp add: ell2_norm_L2_set has)"], ["proof (state)\nthis:\n  ell2_norm (\\<lambda>i. c * x i) =\n  \\<Squnion> (L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ` Collect finite)\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x", "also"], ["proof (state)\nthis:\n  ell2_norm (\\<lambda>i. c * x i) =\n  \\<Squnion> (L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ` Collect finite)\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x", "have \"\\<dots> = (SUP F \\<in> Collect finite. (cmod c * L2_set (cmod \\<circ> x) F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ` Collect finite) =\n    (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F)", "using L2_set_mul"], ["proof (prove)\nusing this:\n  L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ?F =\n  cmod c * L2_set (cmod \\<circ> x) ?F\n\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ` Collect finite) =\n    (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F)", "by auto"], ["proof (state)\nthis:\n  \\<Squnion>\n   (L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ` Collect finite) =\n  (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F)\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x", "also"], ["proof (state)\nthis:\n  \\<Squnion>\n   (L2_set (cmod \\<circ> (\\<lambda>i. c * x i)) ` Collect finite) =\n  (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F)\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x", "have \"\\<dots> = cmod c * ell2_norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) =\n    cmod c * ell2_norm x", "proof (subst ell2_norm_L2_set)"], ["proof (state)\ngoal (2 subgoals):\n 1. has_ell2_norm x\n 2. (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) =\n    cmod c * \\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)", "show \"has_ell2_norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm x", "by (simp add: assms)"], ["proof (state)\nthis:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) =\n    cmod c * \\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)", "show \"(SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) = cmod c * \\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) =\n    cmod c * \\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)", "proof (subst continuous_at_Sup_mono [where f = \"\\<lambda>x. cmod c * x\"])"], ["proof (state)\ngoal (5 subgoals):\n 1. mono ((*) (cmod c))\n 2. continuous\n     (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)))\n     ((*) (cmod c))\n 3. L2_set (cmod \\<circ> x) ` Collect finite \\<noteq> {}\n 4. bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)\n 5. (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) =\n    \\<Squnion> ((*) (cmod c) ` L2_set (cmod \\<circ> x) ` Collect finite)", "show \"mono ((*) (cmod c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ((*) (cmod c))", "by (simp add: mono_def ordered_comm_semiring_class.comm_mult_left_mono)"], ["proof (state)\nthis:\n  mono ((*) (cmod c))\n\ngoal (4 subgoals):\n 1. continuous\n     (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)))\n     ((*) (cmod c))\n 2. L2_set (cmod \\<circ> x) ` Collect finite \\<noteq> {}\n 3. bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)\n 4. (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) =\n    \\<Squnion> ((*) (cmod c) ` L2_set (cmod \\<circ> x) ` Collect finite)", "show \"continuous (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite))) ((*) (cmod c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous\n     (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)))\n     ((*) (cmod c))", "proof (rule continuous_mult)"], ["proof (state)\ngoal (2 subgoals):\n 1. continuous\n     (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)))\n     (\\<lambda>x. cmod c)\n 2. continuous\n     (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)))\n     (\\<lambda>x. x)", "show \"continuous (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite))) (\\<lambda>x. cmod c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous\n     (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)))\n     (\\<lambda>x. cmod c)", "by simp"], ["proof (state)\nthis:\n  continuous\n   (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)))\n   (\\<lambda>x. cmod c)\n\ngoal (1 subgoal):\n 1. continuous\n     (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)))\n     (\\<lambda>x. x)", "show \"continuous (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite))) (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous\n     (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)))\n     (\\<lambda>x. x)", "by simp"], ["proof (state)\nthis:\n  continuous\n   (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)))\n   (\\<lambda>x. x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  continuous\n   (at_left (\\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)))\n   ((*) (cmod c))\n\ngoal (3 subgoals):\n 1. L2_set (cmod \\<circ> x) ` Collect finite \\<noteq> {}\n 2. bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)\n 3. (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) =\n    \\<Squnion> ((*) (cmod c) ` L2_set (cmod \\<circ> x) ` Collect finite)", "show \"L2_set (cmod \\<circ> x) ` Collect finite \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> x) ` Collect finite \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  L2_set (cmod \\<circ> x) ` Collect finite \\<noteq> {}\n\ngoal (2 subgoals):\n 1. bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)\n 2. (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) =\n    \\<Squnion> ((*) (cmod c) ` L2_set (cmod \\<circ> x) ` Collect finite)", "show \"bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)", "by (meson assms has_ell2_norm_L2_set)"], ["proof (state)\nthis:\n  bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)\n\ngoal (1 subgoal):\n 1. (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) =\n    \\<Squnion> ((*) (cmod c) ` L2_set (cmod \\<circ> x) ` Collect finite)", "show \"(SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) = \\<Squnion> ((*) (cmod c) ` L2_set (cmod \\<circ> x) ` Collect finite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) =\n    \\<Squnion> ((*) (cmod c) ` L2_set (cmod \\<circ> x) ` Collect finite)", "by (metis image_image)"], ["proof (state)\nthis:\n  (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) =\n  \\<Squnion> ((*) (cmod c) ` L2_set (cmod \\<circ> x) ` Collect finite)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) =\n  cmod c * \\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (SUP F\\<in>Collect finite. cmod c * L2_set (cmod \\<circ> x) F) =\n  cmod c * ell2_norm x\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x", "finally"], ["proof (chain)\npicking this:\n  ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x", "show \"ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x\""], ["proof (prove)\nusing this:\n  ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x", "."], ["proof (state)\nthis:\n  ell2_norm (\\<lambda>i. c * x i) = cmod c * ell2_norm x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ell2_norm_triangle:\n  assumes \"has_ell2_norm x\" and \"has_ell2_norm y\"\n  shows \"has_ell2_norm (\\<lambda>i. x i + y i)\" and \"ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm (\\<lambda>i. x i + y i) &&&\n    ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. has_ell2_norm (\\<lambda>i. x i + y i)\n 2. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "have triangle: \"L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F \\<le> L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F\" \n    (is \"?lhs\\<le>?rhs\") \n    if \"finite F\" for F"], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F\n    \\<le> L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F\n    \\<le> L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F", "have \"?lhs \\<le> L2_set (\\<lambda>i. (cmod o x) i + (cmod o y) i) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F\n    \\<le> L2_set (\\<lambda>i. (cmod \\<circ> x) i + (cmod \\<circ> y) i) F", "proof (rule L2_set_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> F \\<Longrightarrow>\n       (cmod \\<circ> (\\<lambda>i. x i + y i)) i\n       \\<le> (cmod \\<circ> x) i + (cmod \\<circ> y) i\n 2. \\<And>i.\n       i \\<in> F \\<Longrightarrow>\n       0 \\<le> (cmod \\<circ> (\\<lambda>i. x i + y i)) i", "show \"(cmod \\<circ> (\\<lambda>i. x i + y i)) i \\<le> (cmod \\<circ> x) i + (cmod \\<circ> y) i\"\n        if \"i \\<in> F\"\n        for i :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod \\<circ> (\\<lambda>i. x i + y i)) i\n    \\<le> (cmod \\<circ> x) i + (cmod \\<circ> y) i", "using that norm_triangle_ineq"], ["proof (prove)\nusing this:\n  i \\<in> F\n  norm (?x + ?y) \\<le> norm ?x + norm ?y\n\ngoal (1 subgoal):\n 1. (cmod \\<circ> (\\<lambda>i. x i + y i)) i\n    \\<le> (cmod \\<circ> x) i + (cmod \\<circ> y) i", "by auto"], ["proof (state)\nthis:\n  ?i \\<in> F \\<Longrightarrow>\n  (cmod \\<circ> (\\<lambda>i. x i + y i)) ?i\n  \\<le> (cmod \\<circ> x) ?i + (cmod \\<circ> y) ?i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> F \\<Longrightarrow>\n       0 \\<le> (cmod \\<circ> (\\<lambda>i. x i + y i)) i", "show \"0 \\<le> (cmod \\<circ> (\\<lambda>i. x i + y i)) i\"\n        if \"i \\<in> F\"\n        for i :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (cmod \\<circ> (\\<lambda>i. x i + y i)) i", "using that"], ["proof (prove)\nusing this:\n  i \\<in> F\n\ngoal (1 subgoal):\n 1. 0 \\<le> (cmod \\<circ> (\\<lambda>i. x i + y i)) i", "by simp"], ["proof (state)\nthis:\n  ?i \\<in> F \\<Longrightarrow>\n  0 \\<le> (cmod \\<circ> (\\<lambda>i. x i + y i)) ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F\n  \\<le> L2_set (\\<lambda>i. (cmod \\<circ> x) i + (cmod \\<circ> y) i) F\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F\n    \\<le> L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F", "also"], ["proof (state)\nthis:\n  L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F\n  \\<le> L2_set (\\<lambda>i. (cmod \\<circ> x) i + (cmod \\<circ> y) i) F\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F\n    \\<le> L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F", "have \"\\<dots> \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (\\<lambda>i. (cmod \\<circ> x) i + (cmod \\<circ> y) i) F\n    \\<le> L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F", "by (rule L2_set_triangle_ineq)"], ["proof (state)\nthis:\n  L2_set (\\<lambda>i. (cmod \\<circ> x) i + (cmod \\<circ> y) i) F\n  \\<le> L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F\n    \\<le> L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F", "finally"], ["proof (chain)\npicking this:\n  L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F\n  \\<le> L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F", "show ?thesis"], ["proof (prove)\nusing this:\n  L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F\n  \\<le> L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F\n    \\<le> L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F", "."], ["proof (state)\nthis:\n  L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F\n  \\<le> L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ?F\n  \\<le> L2_set (cmod \\<circ> x) ?F + L2_set (cmod \\<circ> y) ?F\n\ngoal (2 subgoals):\n 1. has_ell2_norm (\\<lambda>i. x i + y i)\n 2. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "obtain Mx My where Mx: \"Mx \\<ge> L2_set (cmod o x) F\" and My: \"My \\<ge> L2_set (cmod o y) F\" \n    if \"finite F\" for F"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Mx My.\n        \\<lbrakk>\\<And>F.\n                    finite F \\<Longrightarrow>\n                    L2_set (cmod \\<circ> x) F \\<le> Mx;\n         \\<And>F.\n            finite F \\<Longrightarrow>\n            L2_set (cmod \\<circ> y) F \\<le> My\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  has_ell2_norm x\n  has_ell2_norm y\n\ngoal (1 subgoal):\n 1. (\\<And>Mx My.\n        \\<lbrakk>\\<And>F.\n                    finite F \\<Longrightarrow>\n                    L2_set (cmod \\<circ> x) F \\<le> Mx;\n         \\<And>F.\n            finite F \\<Longrightarrow>\n            L2_set (cmod \\<circ> y) F \\<le> My\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding has_ell2_norm_L2_set bdd_above_def"], ["proof (prove)\nusing this:\n  \\<exists>M.\n     \\<forall>x\\<in>L2_set (cmod \\<circ> x) ` Collect finite. x \\<le> M\n  \\<exists>M.\n     \\<forall>x\\<in>L2_set (cmod \\<circ> y) ` Collect finite. x \\<le> M\n\ngoal (1 subgoal):\n 1. (\\<And>Mx My.\n        \\<lbrakk>\\<And>F.\n                    finite F \\<Longrightarrow>\n                    L2_set (cmod \\<circ> x) F \\<le> Mx;\n         \\<And>F.\n            finite F \\<Longrightarrow>\n            L2_set (cmod \\<circ> y) F \\<le> My\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow> L2_set (cmod \\<circ> x) ?F \\<le> Mx\n  finite ?F \\<Longrightarrow> L2_set (cmod \\<circ> y) ?F \\<le> My\n\ngoal (2 subgoals):\n 1. has_ell2_norm (\\<lambda>i. x i + y i)\n 2. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "hence MxMy: \"Mx + My \\<ge> L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F\" if \"finite F\" for F"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow> L2_set (cmod \\<circ> x) ?F \\<le> Mx\n  finite ?F \\<Longrightarrow> L2_set (cmod \\<circ> y) ?F \\<le> My\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F \\<le> Mx + My", "using that"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow> L2_set (cmod \\<circ> x) ?F \\<le> Mx\n  finite ?F \\<Longrightarrow> L2_set (cmod \\<circ> y) ?F \\<le> My\n  finite F\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> x) F + L2_set (cmod \\<circ> y) F \\<le> Mx + My", "by fastforce"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> x) ?F + L2_set (cmod \\<circ> y) ?F \\<le> Mx + My\n\ngoal (2 subgoals):\n 1. has_ell2_norm (\\<lambda>i. x i + y i)\n 2. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "hence bdd_plus: \"bdd_above ((\\<lambda>xa. L2_set (cmod \\<circ> x) xa + L2_set (cmod \\<circ> y) xa) ` Collect finite)\""], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> x) ?F + L2_set (cmod \\<circ> y) ?F \\<le> Mx + My\n\ngoal (1 subgoal):\n 1. bdd_above\n     ((\\<lambda>xa.\n          L2_set (cmod \\<circ> x) xa + L2_set (cmod \\<circ> y) xa) `\n      Collect finite)", "unfolding bdd_above_def"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> x) ?F + L2_set (cmod \\<circ> y) ?F \\<le> Mx + My\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>x\\<in>(\\<lambda>xa.\n                          L2_set (cmod \\<circ> x) xa +\n                          L2_set (cmod \\<circ> y) xa) `\n                      Collect finite.\n          x \\<le> M", "by auto"], ["proof (state)\nthis:\n  bdd_above\n   ((\\<lambda>xa. L2_set (cmod \\<circ> x) xa + L2_set (cmod \\<circ> y) xa) `\n    Collect finite)\n\ngoal (2 subgoals):\n 1. has_ell2_norm (\\<lambda>i. x i + y i)\n 2. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "from MxMy"], ["proof (chain)\npicking this:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> x) ?F + L2_set (cmod \\<circ> y) ?F \\<le> Mx + My", "have MxMy': \"Mx + My \\<ge> L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F\" if \"finite F\" for F"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> x) ?F + L2_set (cmod \\<circ> y) ?F \\<le> Mx + My\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F \\<le> Mx + My", "using triangle that"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> x) ?F + L2_set (cmod \\<circ> y) ?F \\<le> Mx + My\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ?F\n  \\<le> L2_set (cmod \\<circ> x) ?F + L2_set (cmod \\<circ> y) ?F\n  finite F\n\ngoal (1 subgoal):\n 1. L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) F \\<le> Mx + My", "by fastforce"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ?F \\<le> Mx + My\n\ngoal (2 subgoals):\n 1. has_ell2_norm (\\<lambda>i. x i + y i)\n 2. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "thus has: \"has_ell2_norm (\\<lambda>i. x i + y i)\""], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ?F \\<le> Mx + My\n\ngoal (1 subgoal):\n 1. has_ell2_norm (\\<lambda>i. x i + y i)", "unfolding has_ell2_norm_L2_set bdd_above_def"], ["proof (prove)\nusing this:\n  finite ?F \\<Longrightarrow>\n  L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ?F \\<le> Mx + My\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>x\\<in>L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) `\n                      Collect finite.\n          x \\<le> M", "by auto"], ["proof (state)\nthis:\n  has_ell2_norm (\\<lambda>i. x i + y i)\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "have SUP_plus: \"(SUP x\\<in>A. f x + g x) \\<le> (SUP x\\<in>A. f x) + (SUP x\\<in>A. g x)\" \n    if notempty: \"A\\<noteq>{}\" and bddf: \"bdd_above (f`A)\"and bddg: \"bdd_above (g`A)\"\n    for f g :: \"'a set \\<Rightarrow> real\" and A"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP x\\<in>A. f x + g x) \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (SUP x\\<in>A. f x + g x) \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "have xleq: \"x \\<le> (SUP x\\<in>A. f x) + (SUP x\\<in>A. g x)\" if x: \"x \\<in> (\\<lambda>x. f x + g x) ` A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "obtain a where aA: \"a:A\" and ax: \"x = f a + g a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A; x = f a + g a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using x"], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>x. f x + g x) ` A\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> A; x = f a + g a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> A\n  x = f a + g a\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "have fa: \"f a \\<le> (SUP x\\<in>A. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<le> \\<Squnion> (f ` A)", "by (simp add: bddf aA cSUP_upper)"], ["proof (state)\nthis:\n  f a \\<le> \\<Squnion> (f ` A)\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "moreover"], ["proof (state)\nthis:\n  f a \\<le> \\<Squnion> (f ` A)\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "have \"g a \\<le> (SUP x\\<in>A. g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g a \\<le> \\<Squnion> (g ` A)", "by (simp add: bddg aA cSUP_upper)"], ["proof (state)\nthis:\n  g a \\<le> \\<Squnion> (g ` A)\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "ultimately"], ["proof (chain)\npicking this:\n  f a \\<le> \\<Squnion> (f ` A)\n  g a \\<le> \\<Squnion> (g ` A)", "have \"f a + g a \\<le> (SUP x\\<in>A. f x) + (SUP x\\<in>A. g x)\""], ["proof (prove)\nusing this:\n  f a \\<le> \\<Squnion> (f ` A)\n  g a \\<le> \\<Squnion> (g ` A)\n\ngoal (1 subgoal):\n 1. f a + g a \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "by simp"], ["proof (state)\nthis:\n  f a + g a \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "with ax"], ["proof (chain)\npicking this:\n  x = f a + g a\n  f a + g a \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "show ?thesis"], ["proof (prove)\nusing this:\n  x = f a + g a\n  f a + g a \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "by simp"], ["proof (state)\nthis:\n  x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> (\\<lambda>x. f x + g x) ` A \\<Longrightarrow>\n  ?x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)\n\ngoal (1 subgoal):\n 1. (SUP x\\<in>A. f x + g x) \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "have \"(\\<lambda>x. f x + g x) ` A \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x + g x) ` A \\<noteq> {}", "using notempty"], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f x + g x) ` A \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. f x + g x) ` A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (SUP x\\<in>A. f x + g x) \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>x. f x + g x) ` A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (SUP x\\<in>A. f x + g x) \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "have \"x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)\"\n      if \"x \\<in> (\\<lambda>x. f x + g x) ` A\"\n      for x :: real"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>x. f x + g x) ` A\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "by (simp add: xleq)"], ["proof (state)\nthis:\n  ?x \\<in> (\\<lambda>x. f x + g x) ` A \\<Longrightarrow>\n  ?x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)\n\ngoal (1 subgoal):\n 1. (SUP x\\<in>A. f x + g x) \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>x. f x + g x) ` A \\<noteq> {}\n  ?x \\<in> (\\<lambda>x. f x + g x) ` A \\<Longrightarrow>\n  ?x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. f x + g x) ` A \\<noteq> {}\n  ?x \\<in> (\\<lambda>x. f x + g x) ` A \\<Longrightarrow>\n  ?x \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)\n\ngoal (1 subgoal):\n 1. (SUP x\\<in>A. f x + g x) \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)", "by (meson bdd_above_def cSup_le_iff)"], ["proof (state)\nthis:\n  (SUP x\\<in>A. f x + g x) \\<le> \\<Squnion> (f ` A) + \\<Squnion> (g ` A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<noteq> {}; bdd_above (?f ` ?A); bdd_above (?g ` ?A)\\<rbrakk>\n  \\<Longrightarrow> (SUP x\\<in>?A. ?f x + ?g x)\n                    \\<le> \\<Squnion> (?f ` ?A) + \\<Squnion> (?g ` ?A)\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "have a2: \"bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)", "by (meson assms(1) has_ell2_norm_L2_set)"], ["proof (state)\nthis:\n  bdd_above (L2_set (cmod \\<circ> x) ` Collect finite)\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "have a3: \"bdd_above (L2_set (cmod \\<circ> y) ` Collect finite)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (L2_set (cmod \\<circ> y) ` Collect finite)", "by (meson assms(2) has_ell2_norm_L2_set)"], ["proof (state)\nthis:\n  bdd_above (L2_set (cmod \\<circ> y) ` Collect finite)\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "have a1: \"Collect finite \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect finite \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Collect finite \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "have a4: \"\\<Squnion> (L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ` Collect finite)\n    \\<le> (SUP xa\\<in>Collect finite.\n           L2_set (cmod \\<circ> x) xa + L2_set (cmod \\<circ> y) xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ` Collect finite)\n    \\<le> (SUP xa\\<in>Collect finite.\n              L2_set (cmod \\<circ> x) xa + L2_set (cmod \\<circ> y) xa)", "by (metis (mono_tags, lifting) a1 bdd_plus cSUP_mono mem_Collect_eq triangle)"], ["proof (state)\nthis:\n  \\<Squnion>\n   (L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ` Collect finite)\n  \\<le> (SUP xa\\<in>Collect finite.\n            L2_set (cmod \\<circ> x) xa + L2_set (cmod \\<circ> y) xa)\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "have \"\\<forall>r. \\<Squnion> (L2_set (cmod \\<circ> (\\<lambda>a. x a + y a)) ` Collect finite) \\<le> r \\<or> \\<not> (SUP A\\<in>Collect finite. L2_set (cmod \\<circ> x) A + L2_set (cmod \\<circ> y) A) \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r.\n       \\<Squnion>\n        (L2_set (cmod \\<circ> (\\<lambda>a. x a + y a)) ` Collect finite)\n       \\<le> r \\<or>\n       \\<not> (SUP A\\<in>Collect finite.\n                  L2_set (cmod \\<circ> x) A + L2_set (cmod \\<circ> y) A)\n              \\<le> r", "using a4"], ["proof (prove)\nusing this:\n  \\<Squnion>\n   (L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ` Collect finite)\n  \\<le> (SUP xa\\<in>Collect finite.\n            L2_set (cmod \\<circ> x) xa + L2_set (cmod \\<circ> y) xa)\n\ngoal (1 subgoal):\n 1. \\<forall>r.\n       \\<Squnion>\n        (L2_set (cmod \\<circ> (\\<lambda>a. x a + y a)) ` Collect finite)\n       \\<le> r \\<or>\n       \\<not> (SUP A\\<in>Collect finite.\n                  L2_set (cmod \\<circ> x) A + L2_set (cmod \\<circ> y) A)\n              \\<le> r", "by linarith"], ["proof (state)\nthis:\n  \\<forall>r.\n     \\<Squnion>\n      (L2_set (cmod \\<circ> (\\<lambda>a. x a + y a)) ` Collect finite)\n     \\<le> r \\<or>\n     \\<not> (SUP A\\<in>Collect finite.\n                L2_set (cmod \\<circ> x) A + L2_set (cmod \\<circ> y) A)\n            \\<le> r\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "hence \"\\<Squnion> (L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ` Collect finite)\n    \\<le> \\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite) +\n       \\<Squnion> (L2_set (cmod \\<circ> y) ` Collect finite)\""], ["proof (prove)\nusing this:\n  \\<forall>r.\n     \\<Squnion>\n      (L2_set (cmod \\<circ> (\\<lambda>a. x a + y a)) ` Collect finite)\n     \\<le> r \\<or>\n     \\<not> (SUP A\\<in>Collect finite.\n                L2_set (cmod \\<circ> x) A + L2_set (cmod \\<circ> y) A)\n            \\<le> r\n\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ` Collect finite)\n    \\<le> \\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite) +\n          \\<Squnion> (L2_set (cmod \\<circ> y) ` Collect finite)", "by (metis (no_types) SUP_plus a1 a2 a3)"], ["proof (state)\nthis:\n  \\<Squnion>\n   (L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ` Collect finite)\n  \\<le> \\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite) +\n        \\<Squnion> (L2_set (cmod \\<circ> y) ` Collect finite)\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "hence \"\\<Squnion> (L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ` Collect finite) \\<le> ell2_norm x + ell2_norm y\""], ["proof (prove)\nusing this:\n  \\<Squnion>\n   (L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ` Collect finite)\n  \\<le> \\<Squnion> (L2_set (cmod \\<circ> x) ` Collect finite) +\n        \\<Squnion> (L2_set (cmod \\<circ> y) ` Collect finite)\n\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ` Collect finite)\n    \\<le> ell2_norm x + ell2_norm y", "by (simp add: assms(1) assms(2) ell2_norm_L2_set)"], ["proof (state)\nthis:\n  \\<Squnion>\n   (L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ` Collect finite)\n  \\<le> ell2_norm x + ell2_norm y\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "thus \"ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y\""], ["proof (prove)\nusing this:\n  \\<Squnion>\n   (L2_set (cmod \\<circ> (\\<lambda>i. x i + y i)) ` Collect finite)\n  \\<le> ell2_norm x + ell2_norm y\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y", "by (simp add: ell2_norm_L2_set has)"], ["proof (state)\nthis:\n  ell2_norm (\\<lambda>i. x i + y i) \\<le> ell2_norm x + ell2_norm y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ell2_norm_uminus:\n  assumes \"has_ell2_norm x\"\n  shows \\<open>has_ell2_norm (\\<lambda>i. - x i)\\<close> and \\<open>ell2_norm (\\<lambda>i. - x i) = ell2_norm x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm (\\<lambda>i. - x i) &&&\n    ell2_norm (\\<lambda>i. - x i) = ell2_norm x", "using assms"], ["proof (prove)\nusing this:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. has_ell2_norm (\\<lambda>i. - x i) &&&\n    ell2_norm (\\<lambda>i. - x i) = ell2_norm x", "by (auto simp: has_ell2_norm_def ell2_norm_def)"], ["", "subsection \\<open>The type \\<open>ell2\\<close> of square-summable functions\\<close>"], ["", "typedef 'a ell2 = \"{x::'a\\<Rightarrow>complex. has_ell2_norm x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {x. has_ell2_norm x}", "unfolding has_ell2_norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {x. bdd_above\n                    (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) `\n                     Collect finite)}", "by (rule exI[of _ \"\\<lambda>_.0\"], auto)"], ["", "setup_lifting type_definition_ell2"], ["", "instantiation ell2 :: (type)complex_vector begin"], ["", "lift_definition zero_ell2 :: \"'a ell2\" is \"\\<lambda>_. 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm (\\<lambda>_. 0)", "by (auto simp: has_ell2_norm_def)"], ["", "lift_definition uminus_ell2 :: \"'a ell2 \\<Rightarrow> 'a ell2\" is uminus"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. has_ell2_norm fun \\<Longrightarrow> has_ell2_norm (- fun)", "by (simp add: has_ell2_norm_def)"], ["", "lift_definition plus_ell2 :: \"'a ell2 \\<Rightarrow> 'a ell2 \\<Rightarrow> 'a ell2\" is \"\\<lambda>f g x. f x + g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>has_ell2_norm fun1; has_ell2_norm fun2\\<rbrakk>\n       \\<Longrightarrow> has_ell2_norm (\\<lambda>x. fun1 x + fun2 x)", "by (rule ell2_norm_triangle)"], ["", "lift_definition minus_ell2 :: \"'a ell2 \\<Rightarrow> 'a ell2 \\<Rightarrow> 'a ell2\" is \"\\<lambda>f g x. f x - g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>has_ell2_norm fun1; has_ell2_norm fun2\\<rbrakk>\n       \\<Longrightarrow> has_ell2_norm (\\<lambda>x. fun1 x - fun2 x)", "apply (subst add_uminus_conv_diff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>has_ell2_norm fun1; has_ell2_norm fun2\\<rbrakk>\n       \\<Longrightarrow> has_ell2_norm (\\<lambda>x. fun1 x + - fun2 x)", "apply (rule ell2_norm_triangle)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>has_ell2_norm fun1; has_ell2_norm fun2\\<rbrakk>\n       \\<Longrightarrow> has_ell2_norm fun1\n 2. \\<And>fun1 fun2.\n       \\<lbrakk>has_ell2_norm fun1; has_ell2_norm fun2\\<rbrakk>\n       \\<Longrightarrow> has_ell2_norm (\\<lambda>i. - fun2 i)", "by (auto simp add: ell2_norm_uminus)"], ["", "lift_definition scaleR_ell2 :: \"real \\<Rightarrow> 'a ell2 \\<Rightarrow> 'a ell2\" is \"\\<lambda>r f x. complex_of_real r * f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real fun.\n       has_ell2_norm fun \\<Longrightarrow>\n       has_ell2_norm (\\<lambda>x. complex_of_real real * fun x)", "by (rule ell2_norm_smult)"], ["", "lift_definition scaleC_ell2 :: \"complex \\<Rightarrow> 'a ell2 \\<Rightarrow> 'a ell2\" is \"\\<lambda>c f x. c * f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>complex fun.\n       has_ell2_norm fun \\<Longrightarrow>\n       has_ell2_norm (\\<lambda>x. complex * fun x)", "by (rule ell2_norm_smult)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ell2, complex_vector_class)", "proof"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a b c. a + b + c = a + (b + c)\n 3. \\<And>a b. a + b = b + a\n 4. \\<And>a. 0 + a = a\n 5. \\<And>a. - a + a = 0\n 6. \\<And>a b. a - b = a + - b\n 7. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 8. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 9. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 10. \\<And>x. 1 *\\<^sub>C x = x", "fix a b c :: \"'a ell2\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a b c. a + b + c = a + (b + c)\n 3. \\<And>a b. a + b = b + a\n 4. \\<And>a. 0 + a = a\n 5. \\<And>a. - a + a = 0\n 6. \\<And>a b. a - b = a + - b\n 7. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 8. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 9. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 10. \\<And>x. 1 *\\<^sub>C x = x", "show \"((*\\<^sub>R) r::'a ell2 \\<Rightarrow> _) = (*\\<^sub>C) (complex_of_real r)\" for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. r *\\<^sub>R x = complex_of_real r *\\<^sub>C x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x r.\n       has_ell2_norm x \\<Longrightarrow>\n       (\\<lambda>xa. complex_of_real r * x xa) =\n       (\\<lambda>xa. complex_of_real r * x xa)", "by auto"], ["proof (state)\nthis:\n  (*\\<^sub>R) ?r = (*\\<^sub>C) (complex_of_real ?r)\n\ngoal (9 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a\n 4. \\<And>a. - a + a = 0\n 5. \\<And>a b. a - b = a + - b\n 6. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 7. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 8. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 9. \\<And>x. 1 *\\<^sub>C x = x", "show \"a + b + c = a + (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "by (transfer; rule ext; simp)"], ["proof (state)\nthis:\n  a + b + c = a + (b + c)\n\ngoal (8 subgoals):\n 1. \\<And>a b. a + b = b + a\n 2. \\<And>a. 0 + a = a\n 3. \\<And>a. - a + a = 0\n 4. \\<And>a b. a - b = a + - b\n 5. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 6. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 7. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 8. \\<And>x. 1 *\\<^sub>C x = x", "show \"a + b = b + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = b + a", "by (transfer; rule ext; simp)"], ["proof (state)\nthis:\n  a + b = b + a\n\ngoal (7 subgoals):\n 1. \\<And>a. 0 + a = a\n 2. \\<And>a. - a + a = 0\n 3. \\<And>a b. a - b = a + - b\n 4. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 5. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 6. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 7. \\<And>x. 1 *\\<^sub>C x = x", "show \"0 + a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + a = a", "by (transfer; rule ext; simp)"], ["proof (state)\nthis:\n  0 + a = a\n\ngoal (6 subgoals):\n 1. \\<And>a. - a + a = 0\n 2. \\<And>a b. a - b = a + - b\n 3. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 4. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 5. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 6. \\<And>x. 1 *\\<^sub>C x = x", "show \"- a + a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a + a = 0", "by (transfer; rule ext; simp)"], ["proof (state)\nthis:\n  - a + a = 0\n\ngoal (5 subgoals):\n 1. \\<And>a b. a - b = a + - b\n 2. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 3. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 4. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 5. \\<And>x. 1 *\\<^sub>C x = x", "show \"a - b = a + - b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a - b = a + - b", "by (transfer; rule ext; simp)"], ["proof (state)\nthis:\n  a - b = a + - b\n\ngoal (4 subgoals):\n 1. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 2. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 3. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 4. \\<And>x. 1 *\\<^sub>C x = x", "show \"r *\\<^sub>C (a + b) = r *\\<^sub>C a + r *\\<^sub>C b\" for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>C (a + b) = r *\\<^sub>C a + r *\\<^sub>C b", "apply (transfer; rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r a b x.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b\\<rbrakk>\n       \\<Longrightarrow> r * (a x + b x) = r * a x + r * b x", "by (simp add: vector_space_over_itself.scale_right_distrib)"], ["proof (state)\nthis:\n  ?r *\\<^sub>C (a + b) = ?r *\\<^sub>C a + ?r *\\<^sub>C b\n\ngoal (3 subgoals):\n 1. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 2. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 3. \\<And>x. 1 *\\<^sub>C x = x", "show \"(r + r') *\\<^sub>C a = r *\\<^sub>C a + r' *\\<^sub>C a\" for r r'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (r + r') *\\<^sub>C a = r *\\<^sub>C a + r' *\\<^sub>C a", "apply (transfer; rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r r' a x.\n       has_ell2_norm a \\<Longrightarrow> (r + r') * a x = r * a x + r' * a x", "by (simp add: ring_class.ring_distribs(2))"], ["proof (state)\nthis:\n  (?r + ?r') *\\<^sub>C a = ?r *\\<^sub>C a + ?r' *\\<^sub>C a\n\ngoal (2 subgoals):\n 1. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 2. \\<And>x. 1 *\\<^sub>C x = x", "show \"r *\\<^sub>C r' *\\<^sub>C a = (r * r') *\\<^sub>C a\" for r r'"], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>C r' *\\<^sub>C a = (r * r') *\\<^sub>C a", "by (transfer; rule ext; simp)"], ["proof (state)\nthis:\n  ?r *\\<^sub>C ?r' *\\<^sub>C a = (?r * ?r') *\\<^sub>C a\n\ngoal (1 subgoal):\n 1. \\<And>x. 1 *\\<^sub>C x = x", "show \"1 *\\<^sub>C a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 *\\<^sub>C a = a", "by (transfer; rule ext; simp)"], ["proof (state)\nthis:\n  1 *\\<^sub>C a = a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation ell2 :: (type)complex_normed_vector begin"], ["", "lift_definition norm_ell2 :: \"'a ell2 \\<Rightarrow> real\" is ell2_norm"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "declare norm_ell2_def[code del]"], ["", "definition \"dist x y = norm (x - y)\" for x y::\"'a ell2\""], ["", "definition \"sgn x = x /\\<^sub>R norm x\" for x::\"'a ell2\""], ["", "definition [code del]: \"uniformity = (INF e\\<in>{0<..}. principal {(x::'a ell2, y). norm (x - y) < e})\""], ["", "definition [code del]: \"open U = (\\<forall>x\\<in>U. \\<forall>\\<^sub>F (x', y) in INF e\\<in>{0<..}. principal {(x, y). norm (x - y) < e}. x' = x \\<longrightarrow> y \\<in> U)\" for U :: \"'a ell2 set\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ell2, complex_normed_vector_class)", "proof"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x y. dist x y = norm (x - y)\n 2. \\<And>x. sgn x = x /\\<^sub>R norm x\n 3. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 4. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 5. \\<And>x. (norm x = 0) = (x = 0)\n 6. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 7. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 8. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "fix a b :: \"'a ell2\""], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x y. dist x y = norm (x - y)\n 2. \\<And>x. sgn x = x /\\<^sub>R norm x\n 3. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 4. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 5. \\<And>x. (norm x = 0) = (x = 0)\n 6. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 7. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 8. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \"dist a b = norm (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist a b = norm (a - b)", "by (simp add: dist_ell2_def)"], ["proof (state)\nthis:\n  dist a b = norm (a - b)\n\ngoal (7 subgoals):\n 1. \\<And>x. sgn x = x /\\<^sub>R norm x\n 2. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 3. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 4. \\<And>x. (norm x = 0) = (x = 0)\n 5. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 6. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 7. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \"sgn a = a /\\<^sub>R norm a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn a = a /\\<^sub>R norm a", "by (simp add: sgn_ell2_def)"], ["proof (state)\nthis:\n  sgn a = a /\\<^sub>R norm a\n\ngoal (6 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x. (norm x = 0) = (x = 0)\n 4. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 5. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 6. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \"uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist (x::'a ell2) y < e})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})", "unfolding dist_ell2_def  uniformity_ell2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF e\\<in>{0<..}. principal {(x, y). norm (x - y) < e}) =\n    (INF e\\<in>{0<..}. principal {(x, y). norm (x - y) < e})", "by simp"], ["proof (state)\nthis:\n  uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n\ngoal (5 subgoals):\n 1. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 2. \\<And>x. (norm x = 0) = (x = 0)\n 3. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 4. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 5. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \"open U = (\\<forall>x\\<in>U. \\<forall>\\<^sub>F (x', y) in uniformity. (x'::'a ell2) = x \\<longrightarrow> y \\<in> U)\" for U :: \"'a ell2 set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open U =\n    (\\<forall>x\\<in>U.\n        \\<forall>\\<^sub>F (x', y) in uniformity.\n           x' = x \\<longrightarrow> y \\<in> U)", "unfolding uniformity_ell2_def open_ell2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>U.\n        \\<forall>\\<^sub>F (x',\n           y) in INF e\\<in>{0<..}. principal {(x, y). norm (x - y) < e}.\n           x' = x \\<longrightarrow> y \\<in> U) =\n    (\\<forall>x\\<in>U.\n        \\<forall>\\<^sub>F (x',\n           y) in INF e\\<in>{0<..}. principal {(x, y). norm (x - y) < e}.\n           x' = x \\<longrightarrow> y \\<in> U)", "by simp_all"], ["proof (state)\nthis:\n  open ?U =\n  (\\<forall>x\\<in>?U.\n      \\<forall>\\<^sub>F (x', y) in uniformity.\n         x' = x \\<longrightarrow> y \\<in> ?U)\n\ngoal (4 subgoals):\n 1. \\<And>x. (norm x = 0) = (x = 0)\n 2. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 3. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 4. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \"(norm a = 0) = (a = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm a = 0) = (a = 0)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       has_ell2_norm a \\<Longrightarrow>\n       (ell2_norm a = 0) = (a = (\\<lambda>_. 0))", "by (fact ell2_norm_0)"], ["proof (state)\nthis:\n  (norm a = 0) = (a = 0)\n\ngoal (3 subgoals):\n 1. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 2. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 3. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \"norm (a + b) \\<le> norm a + norm b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (a + b) \\<le> norm a + norm b", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b\\<rbrakk>\n       \\<Longrightarrow> ell2_norm (\\<lambda>x. a x + b x)\n                         \\<le> ell2_norm a + ell2_norm b", "by (fact ell2_norm_triangle)"], ["proof (state)\nthis:\n  norm (a + b) \\<le> norm a + norm b\n\ngoal (2 subgoals):\n 1. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 2. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \"norm (r *\\<^sub>R (a::'a ell2)) = \\<bar>r\\<bar> * norm a\" for r\n    and a :: \"'a ell2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (r *\\<^sub>R a) = \\<bar>r\\<bar> * norm a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r a.\n       has_ell2_norm a \\<Longrightarrow>\n       ell2_norm (\\<lambda>x. complex_of_real r * a x) =\n       \\<bar>r\\<bar> * ell2_norm a", "by (simp add: ell2_norm_smult(2))"], ["proof (state)\nthis:\n  norm (?r *\\<^sub>R ?a) = \\<bar>?r\\<bar> * norm ?a\n\ngoal (1 subgoal):\n 1. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \"norm (r *\\<^sub>C a) = cmod r * norm a\" for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (r *\\<^sub>C a) = cmod r * norm a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r a.\n       has_ell2_norm a \\<Longrightarrow>\n       ell2_norm (\\<lambda>x. r * a x) = cmod r * ell2_norm a", "by (simp add: ell2_norm_smult(2))"], ["proof (state)\nthis:\n  norm (?r *\\<^sub>C a) = cmod ?r * norm a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma norm_point_bound_ell2: \"norm (Rep_ell2 x i) \\<le> norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (Rep_ell2 x i) \\<le> norm x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       has_ell2_norm x \\<Longrightarrow> cmod (x i) \\<le> ell2_norm x", "by (simp add: ell2_norm_point_bound)"], ["", "lemma ell2_norm_finite_support:\n  assumes \\<open>finite S\\<close> \\<open>\\<And> i. i \\<notin> S \\<Longrightarrow> Rep_ell2 x i = 0\\<close>\n  shows \\<open>norm x = sqrt ((sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x = sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm x = sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "have \\<open>(sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) S \\<le> (Sup (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<le> \\<Squnion>\n           (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<le> \\<Squnion>\n           (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite)", "have \\<open>(sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) S \\<in>(sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite", "using \\<open>finite S\\<close>"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<le> \\<Squnion>\n           (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite)", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<le> \\<Squnion>\n           (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite)", "have \\<open>bdd_above (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above\n     (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)", "using Rep_ell2"], ["proof (prove)\nusing this:\n  Rep_ell2 ?x \\<in> {x. has_ell2_norm x}\n\ngoal (1 subgoal):\n 1. bdd_above\n     (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)", "unfolding has_ell2_norm_def"], ["proof (prove)\nusing this:\n  Rep_ell2 ?x\n  \\<in> {x. bdd_above\n             (sum (\\<lambda>i. (cmod (x i))\\<^sup>2) ` Collect finite)}\n\ngoal (1 subgoal):\n 1. bdd_above\n     (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)", "by auto"], ["proof (state)\nthis:\n  bdd_above\n   (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<le> \\<Squnion>\n           (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite\n  bdd_above\n   (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite\n  bdd_above\n   (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<le> \\<Squnion>\n           (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite)", "using cSup_upper"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite\n  bdd_above\n   (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n  \\<lbrakk>?x \\<in> ?X; bdd_above ?X\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> \\<Squnion> ?X\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<le> \\<Squnion>\n           (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<le> \\<Squnion>\n         (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<le> \\<Squnion>\n         (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n\ngoal (1 subgoal):\n 1. norm x = sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<le> \\<Squnion>\n         (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n\ngoal (1 subgoal):\n 1. norm x = sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "have \\<open>(Sup (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)) \\<le> (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n    \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n    \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "have \\<open>t \\<in> (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite) \\<Longrightarrow> t \\<le> (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) S\\<close>\n      for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "assume \\<open>t \\<in> (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\\<close>"], ["proof (state)\nthis:\n  t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite\n\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "hence \\<open>\\<exists> R \\<in> (Collect finite). t = (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) R\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite\n\ngoal (1 subgoal):\n 1. \\<exists>R\\<in>Collect finite.\n       t = (\\<Sum>i\\<in>R. (cmod (Rep_ell2 x i))\\<^sup>2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>R\\<in>Collect finite.\n     t = (\\<Sum>i\\<in>R. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>R\\<in>Collect finite.\n     t = (\\<Sum>i\\<in>R. (cmod (Rep_ell2 x i))\\<^sup>2)", "obtain R where \\<open>R \\<in> (Collect finite)\\<close> and \\<open>t = (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) R\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>R\\<in>Collect finite.\n     t = (\\<Sum>i\\<in>R. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>R \\<in> Collect finite;\n         t = (\\<Sum>i\\<in>R. (cmod (Rep_ell2 x i))\\<^sup>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  R \\<in> Collect finite\n  t = (\\<Sum>i\\<in>R. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "from \\<open>R \\<in> (Collect finite)\\<close>"], ["proof (chain)\npicking this:\n  R \\<in> Collect finite", "have \\<open>finite R\\<close>"], ["proof (prove)\nusing this:\n  R \\<in> Collect finite\n\ngoal (1 subgoal):\n 1. finite R", "by blast"], ["proof (state)\nthis:\n  finite R\n\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "have \\<open>R = (R - S) \\<union> (R \\<inter> S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. R = R - S \\<union> R \\<inter> S", "by (simp add: Un_Diff_Int)"], ["proof (state)\nthis:\n  R = R - S \\<union> R \\<inter> S\n\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "moreover"], ["proof (state)\nthis:\n  R = R - S \\<union> R \\<inter> S\n\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "have \\<open>(R - S) \\<inter> (R \\<inter> S) = {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (R - S) \\<inter> (R \\<inter> S) = {}", "by auto"], ["proof (state)\nthis:\n  (R - S) \\<inter> (R \\<inter> S) = {}\n\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "ultimately"], ["proof (chain)\npicking this:\n  R = R - S \\<union> R \\<inter> S\n  (R - S) \\<inter> (R \\<inter> S) = {}", "have  \\<open>t = (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) (R - S)\n         + (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) (R \\<inter> S)\\<close>"], ["proof (prove)\nusing this:\n  R = R - S \\<union> R \\<inter> S\n  (R - S) \\<inter> (R \\<inter> S) = {}\n\ngoal (1 subgoal):\n 1. t =\n    (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) +\n    (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)", "using \\<open>t = (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) R\\<close> and \\<open>finite R\\<close>"], ["proof (prove)\nusing this:\n  R = R - S \\<union> R \\<inter> S\n  (R - S) \\<inter> (R \\<inter> S) = {}\n  t = (\\<Sum>i\\<in>R. (cmod (Rep_ell2 x i))\\<^sup>2)\n  finite R\n\ngoal (1 subgoal):\n 1. t =\n    (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) +\n    (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)", "by (smt sum.Int_Diff)"], ["proof (state)\nthis:\n  t =\n  (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) +\n  (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "moreover"], ["proof (state)\nthis:\n  t =\n  (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) +\n  (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "have \\<open>(sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) (R - S) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) = 0", "have \\<open>r \\<in> R - S \\<Longrightarrow> (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) r = 0\\<close>\n          for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> R - S \\<Longrightarrow> (cmod (Rep_ell2 x r))\\<^sup>2 = 0", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  ?r \\<in> R - S \\<Longrightarrow> (cmod (Rep_ell2 x ?r))\\<^sup>2 = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?r \\<in> R - S \\<Longrightarrow> (cmod (Rep_ell2 x ?r))\\<^sup>2 = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) = 0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) = 0\n\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "ultimately"], ["proof (chain)\npicking this:\n  t =\n  (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) +\n  (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) = 0", "have \\<open>t = (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) (R \\<inter> S)\\<close>"], ["proof (prove)\nusing this:\n  t =\n  (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) +\n  (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  (\\<Sum>i\\<in>R - S. (cmod (Rep_ell2 x i))\\<^sup>2) = 0\n\ngoal (1 subgoal):\n 1. t = (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  t = (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "moreover"], ["proof (state)\nthis:\n  t = (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "have \\<open>(sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) (R \\<inter> S) \\<le> (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "have \\<open>R \\<inter> S \\<subseteq> S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<inter> S \\<subseteq> S", "by simp"], ["proof (state)\nthis:\n  R \\<inter> S \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "moreover"], ["proof (state)\nthis:\n  R \\<inter> S \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "have \\<open>(\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) i \\<ge> 0\\<close>\n          for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (cmod (Rep_ell2 x i))\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (cmod (Rep_ell2 x ?i))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "ultimately"], ["proof (chain)\npicking this:\n  R \\<inter> S \\<subseteq> S\n  0 \\<le> (cmod (Rep_ell2 x ?i))\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  R \\<inter> S \\<subseteq> S\n  0 \\<le> (cmod (Rep_ell2 x ?i))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n    \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "by (simp add: assms(1) sum_mono2)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n            Collect finite \\<Longrightarrow>\n    t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "ultimately"], ["proof (chain)\npicking this:\n  t = (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "show \\<open>t \\<le> (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) S\\<close>"], ["proof (prove)\nusing this:\n  t = (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  (\\<Sum>i\\<in>R \\<inter> S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n           Collect finite \\<Longrightarrow>\n  ?t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n    \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "moreover"], ["proof (state)\nthis:\n  ?t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n           Collect finite \\<Longrightarrow>\n  ?t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n    \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "have \\<open>(sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite) \\<noteq> {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n    Collect finite \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n    \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "ultimately"], ["proof (chain)\npicking this:\n  ?t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n           Collect finite \\<Longrightarrow>\n  ?t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite \\<noteq>\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?t \\<in> sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) `\n           Collect finite \\<Longrightarrow>\n  ?t \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n    \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "by (simp add: cSup_least)"], ["proof (state)\nthis:\n  \\<Squnion>\n   (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n  \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Squnion>\n   (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n  \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. norm x = sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<le> \\<Squnion>\n         (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n  \\<Squnion>\n   (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n  \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "have \\<open>(Sup (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)) = (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) S\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n  \\<le> \\<Squnion>\n         (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n  \\<Squnion>\n   (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite)\n  \\<le> (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<Squnion>\n     (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite) =\n    (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  \\<Squnion>\n   (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite) =\n  (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. norm x = sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Squnion>\n   (sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2) ` Collect finite) =\n  (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. norm x = sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "by (metis ell2_norm_def norm_ell2.rep_eq)"], ["proof (state)\nthis:\n  norm x = sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation ell2 :: (type) complex_inner begin"], ["", "lift_definition cinner_ell2 :: \"'a ell2 \\<Rightarrow> 'a ell2 \\<Rightarrow> complex\" is \n  \"\\<lambda>x y. infsetsum (\\<lambda>i. (cnj (x i) * y i)) UNIV\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "declare cinner_ell2_def[code del]"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ell2, complex_inner_class)", "proof standard"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y. x \\<bullet>\\<^sub>C y = cnj (y \\<bullet>\\<^sub>C x)\n 2. \\<And>x y z.\n       (x + y) \\<bullet>\\<^sub>C z =\n       x \\<bullet>\\<^sub>C z + y \\<bullet>\\<^sub>C z\n 3. \\<And>r x y.\n       r *\\<^sub>C x \\<bullet>\\<^sub>C y = cnj r * (x \\<bullet>\\<^sub>C y)\n 4. \\<And>x. 0 \\<le> x \\<bullet>\\<^sub>C x\n 5. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 6. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "fix x y z :: \"'a ell2\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y. x \\<bullet>\\<^sub>C y = cnj (y \\<bullet>\\<^sub>C x)\n 2. \\<And>x y z.\n       (x + y) \\<bullet>\\<^sub>C z =\n       x \\<bullet>\\<^sub>C z + y \\<bullet>\\<^sub>C z\n 3. \\<And>r x y.\n       r *\\<^sub>C x \\<bullet>\\<^sub>C y = cnj r * (x \\<bullet>\\<^sub>C y)\n 4. \\<And>x. 0 \\<le> x \\<bullet>\\<^sub>C x\n 5. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 6. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "fix c :: complex"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y. x \\<bullet>\\<^sub>C y = cnj (y \\<bullet>\\<^sub>C x)\n 2. \\<And>x y z.\n       (x + y) \\<bullet>\\<^sub>C z =\n       x \\<bullet>\\<^sub>C z + y \\<bullet>\\<^sub>C z\n 3. \\<And>r x y.\n       r *\\<^sub>C x \\<bullet>\\<^sub>C y = cnj r * (x \\<bullet>\\<^sub>C y)\n 4. \\<And>x. 0 \\<le> x \\<bullet>\\<^sub>C x\n 5. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 6. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "show \"cinner x y = cnj (cinner y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bullet>\\<^sub>C y = cnj (y \\<bullet>\\<^sub>C x)", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i) * y i) =\n                         cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)", "fix x y :: \"'a\\<Rightarrow>complex\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i) * y i) =\n                         cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)", "assume \"has_ell2_norm x\" and \"has_ell2_norm y\""], ["proof (state)\nthis:\n  has_ell2_norm x\n  has_ell2_norm y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i) * y i) =\n                         cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)", "have \"(\\<Sum>\\<^sub>ai. cnj (x i) * y i) = (\\<Sum>\\<^sub>ai. cnj (cnj (y i) * x i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ai. cnj (x i) * y i) =\n    (\\<Sum>\\<^sub>ai. cnj (cnj (y i) * x i))", "by (metis complex_cnj_cnj complex_cnj_mult mult.commute)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ai. cnj (x i) * y i) =\n  (\\<Sum>\\<^sub>ai. cnj (cnj (y i) * x i))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i) * y i) =\n                         cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ai. cnj (x i) * y i) =\n  (\\<Sum>\\<^sub>ai. cnj (cnj (y i) * x i))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i) * y i) =\n                         cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)", "have \"\\<dots> = cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ai. cnj (cnj (y i) * x i)) =\n    cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)", "by (metis infsetsum_cnj)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ai. cnj (cnj (y i) * x i)) =\n  cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i) * y i) =\n                         cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<^sub>ai. cnj (x i) * y i) =\n  cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)", "show \"(\\<Sum>\\<^sub>ai. cnj (x i) * y i) = cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)\""], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sub>ai. cnj (x i) * y i) =\n  cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ai. cnj (x i) * y i) =\n    cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)", "."], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ai. cnj (x i) * y i) =\n  cnj (\\<Sum>\\<^sub>ai. cnj (y i) * x i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<bullet>\\<^sub>C y = cnj (y \\<bullet>\\<^sub>C x)\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       (x + y) \\<bullet>\\<^sub>C z =\n       x \\<bullet>\\<^sub>C z + y \\<bullet>\\<^sub>C z\n 2. \\<And>r x y.\n       r *\\<^sub>C x \\<bullet>\\<^sub>C y = cnj r * (x \\<bullet>\\<^sub>C y)\n 3. \\<And>x. 0 \\<le> x \\<bullet>\\<^sub>C x\n 4. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 5. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "show \"cinner (x + y) z = cinner x z + cinner y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y) \\<bullet>\\<^sub>C z =\n    x \\<bullet>\\<^sub>C z + y \\<bullet>\\<^sub>C z", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y; has_ell2_norm z\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n                         (\\<Sum>\\<^sub>ai. cnj (x i) * z i) +\n                         (\\<Sum>\\<^sub>ai. cnj (y i) * z i)", "fix x y z :: \"'a \\<Rightarrow> complex\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y; has_ell2_norm z\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n                         (\\<Sum>\\<^sub>ai. cnj (x i) * z i) +\n                         (\\<Sum>\\<^sub>ai. cnj (y i) * z i)", "assume \"has_ell2_norm x\""], ["proof (state)\nthis:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y; has_ell2_norm z\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n                         (\\<Sum>\\<^sub>ai. cnj (x i) * z i) +\n                         (\\<Sum>\\<^sub>ai. cnj (y i) * z i)", "hence cnj_x: \"(\\<lambda>i. cnj (x i) * cnj (x i)) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * cnj (x i)) abs_summable_on UNIV", "by (simp del: complex_cnj_mult add: norm_mult[symmetric] complex_cnj_mult[symmetric] has_ell2_norm_infsetsum power2_eq_square)"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (x i) * cnj (x i)) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y; has_ell2_norm z\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n                         (\\<Sum>\\<^sub>ai. cnj (x i) * z i) +\n                         (\\<Sum>\\<^sub>ai. cnj (y i) * z i)", "assume \"has_ell2_norm y\""], ["proof (state)\nthis:\n  has_ell2_norm y\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y; has_ell2_norm z\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n                         (\\<Sum>\\<^sub>ai. cnj (x i) * z i) +\n                         (\\<Sum>\\<^sub>ai. cnj (y i) * z i)", "hence cnj_y: \"(\\<lambda>i. cnj (y i) * cnj (y i)) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  has_ell2_norm y\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (y i) * cnj (y i)) abs_summable_on UNIV", "by (simp del: complex_cnj_mult add: norm_mult[symmetric] complex_cnj_mult[symmetric] has_ell2_norm_infsetsum power2_eq_square)"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (y i) * cnj (y i)) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y; has_ell2_norm z\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n                         (\\<Sum>\\<^sub>ai. cnj (x i) * z i) +\n                         (\\<Sum>\\<^sub>ai. cnj (y i) * z i)", "assume \"has_ell2_norm z\""], ["proof (state)\nthis:\n  has_ell2_norm z\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y; has_ell2_norm z\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n                         (\\<Sum>\\<^sub>ai. cnj (x i) * z i) +\n                         (\\<Sum>\\<^sub>ai. cnj (y i) * z i)", "hence z: \"(\\<lambda>i. z i * z i) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  has_ell2_norm z\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. z i * z i) abs_summable_on UNIV", "by (simp add: norm_mult[symmetric] has_ell2_norm_infsetsum power2_eq_square)"], ["proof (state)\nthis:\n  (\\<lambda>i. z i * z i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y; has_ell2_norm z\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n                         (\\<Sum>\\<^sub>ai. cnj (x i) * z i) +\n                         (\\<Sum>\\<^sub>ai. cnj (y i) * z i)", "have cnj_x_z:\"(\\<lambda>i. cnj (x i) * z i) abs_summable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * z i) abs_summable_on UNIV", "using cnj_x z"], ["proof (prove)\nusing this:\n  (\\<lambda>i. cnj (x i) * cnj (x i)) abs_summable_on UNIV\n  (\\<lambda>i. z i * z i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * z i) abs_summable_on UNIV", "by (rule abs_summable_product)"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (x i) * z i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y; has_ell2_norm z\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n                         (\\<Sum>\\<^sub>ai. cnj (x i) * z i) +\n                         (\\<Sum>\\<^sub>ai. cnj (y i) * z i)", "have cnj_y_z:\"(\\<lambda>i. cnj (y i) * z i) abs_summable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (y i) * z i) abs_summable_on UNIV", "using cnj_y z"], ["proof (prove)\nusing this:\n  (\\<lambda>i. cnj (y i) * cnj (y i)) abs_summable_on UNIV\n  (\\<lambda>i. z i * z i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (y i) * z i) abs_summable_on UNIV", "by (rule abs_summable_product)"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (y i) * z i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y; has_ell2_norm z\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n                         (\\<Sum>\\<^sub>ai. cnj (x i) * z i) +\n                         (\\<Sum>\\<^sub>ai. cnj (y i) * z i)", "show \"(\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) = (\\<Sum>\\<^sub>ai. cnj (x i) * z i) + (\\<Sum>\\<^sub>ai. cnj (y i) * z i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n    (\\<Sum>\\<^sub>ai. cnj (x i) * z i) + (\\<Sum>\\<^sub>ai. cnj (y i) * z i)", "proof (subst infsetsum_add [symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>i. cnj (x i) * z i) abs_summable_on UNIV\n 2. (\\<lambda>i. cnj (y i) * z i) abs_summable_on UNIV\n 3. (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n    (\\<Sum>\\<^sub>ax. cnj (x x) * z x + cnj (y x) * z x)", "show \"(\\<lambda>i. cnj (x i) * z i) abs_summable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * z i) abs_summable_on UNIV", "by (simp add: cnj_x_z)"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (x i) * z i) abs_summable_on UNIV\n\ngoal (2 subgoals):\n 1. (\\<lambda>i. cnj (y i) * z i) abs_summable_on UNIV\n 2. (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n    (\\<Sum>\\<^sub>ax. cnj (x x) * z x + cnj (y x) * z x)", "show \"(\\<lambda>i. cnj (y i) * z i) abs_summable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (y i) * z i) abs_summable_on UNIV", "by (simp add: cnj_y_z)"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (y i) * z i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n    (\\<Sum>\\<^sub>ax. cnj (x x) * z x + cnj (y x) * z x)", "show \"(\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) = (\\<Sum>\\<^sub>ai. cnj (x i) * z i + cnj (y i) * z i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n    (\\<Sum>\\<^sub>ai. cnj (x i) * z i + cnj (y i) * z i)", "by (metis complex_cnj_add distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n  (\\<Sum>\\<^sub>ai. cnj (x i) * z i + cnj (y i) * z i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ai. cnj (x i + y i) * z i) =\n  (\\<Sum>\\<^sub>ai. cnj (x i) * z i) + (\\<Sum>\\<^sub>ai. cnj (y i) * z i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x + y) \\<bullet>\\<^sub>C z =\n  x \\<bullet>\\<^sub>C z + y \\<bullet>\\<^sub>C z\n\ngoal (4 subgoals):\n 1. \\<And>r x y.\n       r *\\<^sub>C x \\<bullet>\\<^sub>C y = cnj r * (x \\<bullet>\\<^sub>C y)\n 2. \\<And>x. 0 \\<le> x \\<bullet>\\<^sub>C x\n 3. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 4. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "show \"cinner (c *\\<^sub>C x) y = cnj c * cinner x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<bullet>\\<^sub>C y = cnj c * (x \\<bullet>\\<^sub>C y)", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n                         cnj c * (\\<Sum>\\<^sub>ai. cnj (x i) * y i)", "fix x y :: \"'a \\<Rightarrow> complex\" and c :: complex"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n                         cnj c * (\\<Sum>\\<^sub>ai. cnj (x i) * y i)", "assume \"has_ell2_norm x\""], ["proof (state)\nthis:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n                         cnj c * (\\<Sum>\\<^sub>ai. cnj (x i) * y i)", "hence cnj_x: \"(\\<lambda>i. cnj (x i) * cnj (x i)) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * cnj (x i)) abs_summable_on UNIV", "by (simp del: complex_cnj_mult add: norm_mult[symmetric] complex_cnj_mult[symmetric] has_ell2_norm_infsetsum power2_eq_square)"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (x i) * cnj (x i)) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n                         cnj c * (\\<Sum>\\<^sub>ai. cnj (x i) * y i)", "assume \"has_ell2_norm y\""], ["proof (state)\nthis:\n  has_ell2_norm y\n\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n                         cnj c * (\\<Sum>\\<^sub>ai. cnj (x i) * y i)", "hence y: \"(\\<lambda>i. y i * y i) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  has_ell2_norm y\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. y i * y i) abs_summable_on UNIV", "by (simp add: norm_mult[symmetric] has_ell2_norm_infsetsum power2_eq_square)"], ["proof (state)\nthis:\n  (\\<lambda>i. y i * y i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n                         cnj c * (\\<Sum>\\<^sub>ai. cnj (x i) * y i)", "have cnj_x_y:\"(\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV", "using cnj_x y"], ["proof (prove)\nusing this:\n  (\\<lambda>i. cnj (x i) * cnj (x i)) abs_summable_on UNIV\n  (\\<lambda>i. y i * y i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV", "by (rule abs_summable_product)"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>c x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n                         cnj c * (\\<Sum>\\<^sub>ai. cnj (x i) * y i)", "thus \"(\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) = cnj c * (\\<Sum>\\<^sub>ai. cnj (x i) * y i)\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n    cnj c * (\\<Sum>\\<^sub>ai. cnj (x i) * y i)", "proof (subst infsetsum_cmult_right [symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV;\n     cnj c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV\n 2. (\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV \\<Longrightarrow>\n    (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n    (\\<Sum>\\<^sub>ax. cnj c * (cnj (x x) * y x))", "show \"(\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV\"\n        if \"(\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV\"\n          and \"cnj c \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV", "using that"], ["proof (prove)\nusing this:\n  (\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV\n  cnj c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV;\n   cnj c \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV \\<Longrightarrow>\n    (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n    (\\<Sum>\\<^sub>ax. cnj c * (cnj (x x) * y x))", "show \"(\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) = (\\<Sum>\\<^sub>ai. cnj c * (cnj (x i) * y i))\"\n        if \"(\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n    (\\<Sum>\\<^sub>ai. cnj c * (cnj (x i) * y i))", "using that"], ["proof (prove)\nusing this:\n  (\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n    (\\<Sum>\\<^sub>ai. cnj c * (cnj (x i) * y i))", "by (metis complex_cnj_mult vector_space_over_itself.scale_scale)"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (x i) * y i) abs_summable_on UNIV \\<Longrightarrow>\n  (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n  (\\<Sum>\\<^sub>ai. cnj c * (cnj (x i) * y i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ai. cnj (c * x i) * y i) =\n  cnj c * (\\<Sum>\\<^sub>ai. cnj (x i) * y i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c *\\<^sub>C x \\<bullet>\\<^sub>C y = cnj c * (x \\<bullet>\\<^sub>C y)\n\ngoal (3 subgoals):\n 1. \\<And>x. 0 \\<le> x \\<bullet>\\<^sub>C x\n 2. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 3. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "show \"0 \\<le> cinner x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<bullet>\\<^sub>C x", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)", "fix x :: \"'a \\<Rightarrow> complex\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)", "assume \"has_ell2_norm x\""], ["proof (state)\nthis:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)", "hence \"(\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV", "by (simp del: abs_summable_on_norm_iff add: norm_mult has_ell2_norm_infsetsum power2_eq_square)"], ["proof (state)\nthis:\n  (\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)", "hence \"(\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV", "by (subst abs_summable_on_norm_iff[symmetric])"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)", "hence sum: \"(\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV", "unfolding has_ell2_norm_infsetsum power2_eq_square"], ["proof (prove)\nusing this:\n  (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV", "."], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)", "have \"0 = (\\<Sum>\\<^sub>ai::'a. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) = (\\<Sum>\\<^sub>ai. (0::'b))", "by auto"], ["proof (state)\nthis:\n  (0::?'b1) = (\\<Sum>\\<^sub>ai. (0::?'b1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)", "also"], ["proof (state)\nthis:\n  (0::?'b1) = (\\<Sum>\\<^sub>ai. (0::?'b1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)", "have \"\\<dots> \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ai. 0) \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)", "proof (rule infsetsum_mono_complex)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>i. 0) abs_summable_on UNIV\n 2. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\n 3. \\<And>x. x \\<in> UNIV \\<Longrightarrow> 0 \\<le> cnj (x x) * x x", "show \"(\\<lambda>i. 0::complex) abs_summable_on (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. 0) abs_summable_on UNIV", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i. 0) abs_summable_on UNIV\n\ngoal (2 subgoals):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\n 2. \\<And>x. x \\<in> UNIV \\<Longrightarrow> 0 \\<le> cnj (x x) * x x", "show \"(\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV", "by (simp add: sum)"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> 0 \\<le> cnj (x x) * x x", "show \"0 \\<le> cnj (f x) * f x\"\n        if \"x \\<in> UNIV\"\n        for x :: 'a and f :: \"'a \\<Rightarrow>_\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cnj (f x) * f x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> UNIV\n\ngoal (1 subgoal):\n 1. 0 \\<le> cnj (f x) * f x", "by simp"], ["proof (state)\nthis:\n  ?x1 \\<in> UNIV \\<Longrightarrow> 0 \\<le> cnj (?f1 ?x1) * ?f1 ?x1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ai. 0) \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)", "show \"0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)\""], ["proof (prove)\nusing this:\n  0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)\n\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)", "by assumption"], ["proof (state)\nthis:\n  0 \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> x \\<bullet>\\<^sub>C x\n\ngoal (2 subgoals):\n 1. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 2. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "show \"(cinner x x = 0) = (x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)", "proof (transfer, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>has_ell2_norm x;\n        (\\<Sum>\\<^sub>ai. cnj (x i) * x i) = 0\\<rbrakk>\n       \\<Longrightarrow> x = (\\<lambda>_. 0)", "fix x :: \"'a \\<Rightarrow> complex\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>has_ell2_norm x;\n        (\\<Sum>\\<^sub>ai. cnj (x i) * x i) = 0\\<rbrakk>\n       \\<Longrightarrow> x = (\\<lambda>_. 0)", "assume \"has_ell2_norm x\""], ["proof (state)\nthis:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>has_ell2_norm x;\n        (\\<Sum>\\<^sub>ai. cnj (x i) * x i) = 0\\<rbrakk>\n       \\<Longrightarrow> x = (\\<lambda>_. 0)", "hence \"(\\<lambda>i::'a. cmod (cnj (x i) * x i)) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV", "unfolding has_ell2_norm_infsetsum power2_eq_square"], ["proof (prove)\nusing this:\n  (\\<lambda>i. cmod (x i) * cmod (x i)) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV", "by (metis (no_types, lifting) abs_summable_on_cong complex_mod_cnj norm_mult)"], ["proof (state)\nthis:\n  (\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>has_ell2_norm x;\n        (\\<Sum>\\<^sub>ai. cnj (x i) * x i) = 0\\<rbrakk>\n       \\<Longrightarrow> x = (\\<lambda>_. 0)", "hence cmod_x2: \"(\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV", "unfolding has_ell2_norm_infsetsum power2_eq_square"], ["proof (prove)\nusing this:\n  (\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>has_ell2_norm x;\n        (\\<Sum>\\<^sub>ai. cnj (x i) * x i) = 0\\<rbrakk>\n       \\<Longrightarrow> x = (\\<lambda>_. 0)", "assume eq0: \"(\\<Sum>\\<^sub>ai. cnj (x i) * x i) = 0\""], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ai. cnj (x i) * x i) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>has_ell2_norm x;\n        (\\<Sum>\\<^sub>ai. cnj (x i) * x i) = 0\\<rbrakk>\n       \\<Longrightarrow> x = (\\<lambda>_. 0)", "show \"x = (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = (\\<lambda>_. 0)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> (\\<lambda>_. 0) \\<Longrightarrow> False", "assume \"x \\<noteq> (\\<lambda>_. 0)\""], ["proof (state)\nthis:\n  x \\<noteq> (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (\\<lambda>_. 0) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> (\\<lambda>_. 0)", "obtain i where \"x i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. (\\<And>i. x i \\<noteq> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> (\\<lambda>_. 0) \\<Longrightarrow> False", "hence \"0 < cnj (x i) * x i\""], ["proof (prove)\nusing this:\n  x i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < cnj (x i) * x i", "by (metis le_less cnj_x_x_geq0 complex_cnj_zero_iff vector_space_over_itself.scale_eq_0_iff)"], ["proof (state)\nthis:\n  0 < cnj (x i) * x i\n\ngoal (1 subgoal):\n 1. x \\<noteq> (\\<lambda>_. 0) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  0 < cnj (x i) * x i\n\ngoal (1 subgoal):\n 1. x \\<noteq> (\\<lambda>_. 0) \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>\\<^sub>ai\\<in>{i}. cnj (x i) * x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (x i) * x i = (\\<Sum>\\<^sub>ai\\<in>{i}. cnj (x i) * x i)", "by auto"], ["proof (state)\nthis:\n  cnj (x i) * x i = (\\<Sum>\\<^sub>ai\\<in>{i}. cnj (x i) * x i)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (\\<lambda>_. 0) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  cnj (x i) * x i = (\\<Sum>\\<^sub>ai\\<in>{i}. cnj (x i) * x i)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (\\<lambda>_. 0) \\<Longrightarrow> False", "have \"\\<dots> \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ai\\<in>{i}. cnj (x i) * x i)\n    \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)", "proof (rule infsetsum_subset_complex)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\n 2. {i} \\<subseteq> UNIV\n 3. \\<And>x. x \\<notin> {i} \\<Longrightarrow> 0 \\<le> cnj (x x) * x x", "show \"(\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV", "by (simp add: cmod_x2)"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\n\ngoal (2 subgoals):\n 1. {i} \\<subseteq> UNIV\n 2. \\<And>x. x \\<notin> {i} \\<Longrightarrow> 0 \\<le> cnj (x x) * x x", "show \"{i} \\<subseteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i} \\<subseteq> UNIV", "by simp"], ["proof (state)\nthis:\n  {i} \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<notin> {i} \\<Longrightarrow> 0 \\<le> cnj (x x) * x x", "show \"0 \\<le> cnj (f x) * f x\"\n          if \"x \\<notin> {i}\"\n          for x :: 'a and f::\"'a \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cnj (f x) * f x", "using that"], ["proof (prove)\nusing this:\n  x \\<notin> {i}\n\ngoal (1 subgoal):\n 1. 0 \\<le> cnj (f x) * f x", "by simp"], ["proof (state)\nthis:\n  ?x \\<notin> {i} \\<Longrightarrow> 0 \\<le> cnj (?f ?x) * ?f ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ai\\<in>{i}. cnj (x i) * x i)\n  \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (\\<lambda>_. 0) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ai\\<in>{i}. cnj (x i) * x i)\n  \\<le> (\\<Sum>\\<^sub>ai. cnj (x i) * x i)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (\\<lambda>_. 0) \\<Longrightarrow> False", "from eq0"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<^sub>ai. cnj (x i) * x i) = 0", "have \"\\<dots> = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sub>ai. cnj (x i) * x i) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sub>ai. cnj (x i) * x i) = 0", "by assumption"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sub>ai. cnj (x i) * x i) = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> (\\<lambda>_. 0) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  0 < 0", "show False"], ["proof (prove)\nusing this:\n  0 < 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = (\\<lambda>_. 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "show \"norm x = sqrt (cmod (cinner x x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "fix x :: \"'a \\<Rightarrow> complex\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "assume x: \"has_ell2_norm x\""], ["proof (state)\nthis:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "have \"(\\<lambda>i::'a. cmod (x i) * cmod (x i)) abs_summable_on UNIV \\<Longrightarrow>\n    (\\<lambda>i::'a. cmod (cnj (x i) * x i)) abs_summable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cmod (x i) * cmod (x i)) abs_summable_on\n    UNIV \\<Longrightarrow>\n    (\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV", "by (simp del: abs_summable_on_norm_iff add: norm_mult has_ell2_norm_infsetsum power2_eq_square)"], ["proof (state)\nthis:\n  (\\<lambda>i. cmod (x i) * cmod (x i)) abs_summable_on\n  UNIV \\<Longrightarrow>\n  (\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "hence sum: \"(\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. cmod (x i) * cmod (x i)) abs_summable_on\n  UNIV \\<Longrightarrow>\n  (\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV", "using x"], ["proof (prove)\nusing this:\n  (\\<lambda>i. cmod (x i) * cmod (x i)) abs_summable_on\n  UNIV \\<Longrightarrow>\n  (\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV", "unfolding has_ell2_norm_infsetsum power2_eq_square"], ["proof (prove)\nusing this:\n  (\\<lambda>i. cmod (x i) * cmod (x i)) abs_summable_on\n  UNIV \\<Longrightarrow>\n  (\\<lambda>i. cmod (cnj (x i) * x i)) abs_summable_on UNIV\n  (\\<lambda>i. cmod (x i) * cmod (x i)) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "from x"], ["proof (chain)\npicking this:\n  has_ell2_norm x", "have \"ell2_norm x = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)\""], ["proof (prove)\nusing this:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. ell2_norm x = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)", "proof (subst ell2_norm_infsetsum)"], ["proof (state)\ngoal (2 subgoals):\n 1. has_ell2_norm x \\<Longrightarrow> has_ell2_norm x\n 2. has_ell2_norm x \\<Longrightarrow>\n    sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2) =\n    sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)", "show \"has_ell2_norm x\"\n        if \"has_ell2_norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm x", "using that"], ["proof (prove)\nusing this:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. has_ell2_norm x", "."], ["proof (state)\nthis:\n  has_ell2_norm x \\<Longrightarrow> has_ell2_norm x\n\ngoal (1 subgoal):\n 1. has_ell2_norm x \\<Longrightarrow>\n    sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2) =\n    sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)", "show \"sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2) = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)\"\n        if \"has_ell2_norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2) =\n    sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)", "using that"], ["proof (prove)\nusing this:\n  has_ell2_norm x\n\ngoal (1 subgoal):\n 1. sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2) =\n    sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  has_ell2_norm x \\<Longrightarrow>\n  sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2) =\n  sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ell2_norm x = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "also"], ["proof (state)\nthis:\n  ell2_norm x = sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "have \"\\<dots> = sqrt (\\<Sum>\\<^sub>ai. cmod (cnj (x i) * x i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2) =\n    sqrt (\\<Sum>\\<^sub>ai. cmod (cnj (x i) * x i))", "unfolding norm_complex_def power2_eq_square"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Sum>\\<^sub>ai.\n        sqrt (Re (x i) * Re (x i) + Im (x i) * Im (x i)) *\n        sqrt (Re (x i) * Re (x i) + Im (x i) * Im (x i))) =\n    sqrt\n     (\\<Sum>\\<^sub>ai.\n        sqrt\n         (Re (cnj (x i) * x i) * Re (cnj (x i) * x i) +\n          Im (cnj (x i) * x i) * Im (cnj (x i) * x i)))", "by auto"], ["proof (state)\nthis:\n  sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2) =\n  sqrt (\\<Sum>\\<^sub>ai. cmod (cnj (x i) * x i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "also"], ["proof (state)\nthis:\n  sqrt (\\<Sum>\\<^sub>ai. (cmod (x i))\\<^sup>2) =\n  sqrt (\\<Sum>\\<^sub>ai. cmod (cnj (x i) * x i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "have \"\\<dots> = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (\\<Sum>\\<^sub>ai. cmod (cnj (x i) * x i)) =\n    sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "proof (subst infsetsum_cmod)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\n 2. \\<And>x. x \\<in> UNIV \\<Longrightarrow> 0 \\<le> cnj (x x) * x x\n 3. sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i)) =\n    sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "show \"(\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV", "by (simp add: sum)"], ["proof (state)\nthis:\n  (\\<lambda>i. cnj (x i) * x i) abs_summable_on UNIV\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> 0 \\<le> cnj (x x) * x x\n 2. sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i)) =\n    sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "show \"0 \\<le> cnj (f x) * f x\"\n        if \"(x::'a) \\<in> UNIV\"\n        for x :: 'a and f::\"'a \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cnj (f x) * f x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> UNIV\n\ngoal (1 subgoal):\n 1. 0 \\<le> cnj (f x) * f x", "by simp"], ["proof (state)\nthis:\n  ?x \\<in> UNIV \\<Longrightarrow> 0 \\<le> cnj (?f ?x) * ?f ?x\n\ngoal (1 subgoal):\n 1. sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i)) =\n    sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "show \"sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i)) = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i)) =\n    sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "by simp"], ["proof (state)\nthis:\n  sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i)) =\n  sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sqrt (\\<Sum>\\<^sub>ai. cmod (cnj (x i) * x i)) =\n  sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "finally"], ["proof (chain)\npicking this:\n  ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "show \"ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))\""], ["proof (prove)\nusing this:\n  ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))\n\ngoal (1 subgoal):\n 1. ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))", "by assumption"], ["proof (state)\nthis:\n  ell2_norm x = sqrt (cmod (\\<Sum>\\<^sub>ai. cnj (x i) * x i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instance ell2 :: (type) chilbert_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ell2, chilbert_space_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "fix X :: \\<open>nat \\<Rightarrow> 'a ell2\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "define x where \\<open>x n a = Rep_ell2 (X n) a\\<close> for n a"], ["proof (state)\nthis:\n  x ?n ?a = Rep_ell2 (X ?n) ?a\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have [simp]: \\<open>has_ell2_norm (x n)\\<close> for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm (x n)", "using Rep_ell2 x_def[abs_def]"], ["proof (prove)\nusing this:\n  Rep_ell2 ?x \\<in> {x. has_ell2_norm x}\n  x \\<equiv> \\<lambda>n. Rep_ell2 (X n)\n\ngoal (1 subgoal):\n 1. has_ell2_norm (x n)", "by simp"], ["proof (state)\nthis:\n  has_ell2_norm (x ?n)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "assume \\<open>Cauchy X\\<close>"], ["proof (state)\nthis:\n  Cauchy X\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "moreover"], ["proof (state)\nthis:\n  Cauchy X\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \"dist (x n a) (x m a) \\<le> dist (X n) (X m)\" for n m a"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (x n a) (x m a) \\<le> dist (X n) (X m)", "by (metis Rep_ell2 x_def dist_norm ell2_norm_point_bound mem_Collect_eq minus_ell2.rep_eq norm_ell2.rep_eq)"], ["proof (state)\nthis:\n  dist (x ?n ?a) (x ?m ?a) \\<le> dist (X ?n) (X ?m)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "ultimately"], ["proof (chain)\npicking this:\n  Cauchy X\n  dist (x ?n ?a) (x ?m ?a) \\<le> dist (X ?n) (X ?m)", "have \\<open>Cauchy (\\<lambda>n. x n a)\\<close> for a"], ["proof (prove)\nusing this:\n  Cauchy X\n  dist (x ?n ?a) (x ?m ?a) \\<le> dist (X ?n) (X ?m)\n\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. x n a)", "by (meson Cauchy_def le_less_trans)"], ["proof (state)\nthis:\n  Cauchy (\\<lambda>n. x n ?a)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "then"], ["proof (chain)\npicking this:\n  Cauchy (\\<lambda>n. x n ?a)", "obtain l where x_lim: \\<open>(\\<lambda>n. x n a) \\<longlonglongrightarrow> l a\\<close> for a"], ["proof (prove)\nusing this:\n  Cauchy (\\<lambda>n. x n ?a)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        (\\<And>a.\n            (\\<lambda>n. x n a)\n            \\<longlonglongrightarrow> l a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. Cauchy (\\<lambda>n. x n a)) \\<Longrightarrow>\n    \\<exists>l.\n       \\<forall>a. (\\<lambda>n. x n a) \\<longlonglongrightarrow> l a", "apply (rule choice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. Cauchy (\\<lambda>n. x n a)) \\<Longrightarrow>\n    \\<forall>a. \\<exists>y. (\\<lambda>n. x n a) \\<longlonglongrightarrow> y", "by (simp add: convergent_eq_Cauchy)"], ["proof (state)\nthis:\n  (\\<lambda>n. x n ?a) \\<longlonglongrightarrow> l ?a\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "define L where \\<open>L = Abs_ell2 l\\<close>"], ["proof (state)\nthis:\n  L = Abs_ell2 l\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "define normF where \\<open>normF F x = L2_set (cmod \\<circ> x) F\\<close> for F :: \\<open>'a set\\<close> and x"], ["proof (state)\nthis:\n  normF ?F ?x = L2_set (cmod \\<circ> ?x) ?F\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have normF_triangle: \\<open>normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y\\<close> if \\<open>finite F\\<close> for F x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y", "have \\<open>normF F (\\<lambda>a. x a + y a) = L2_set (\\<lambda>a. cmod (x a + y a)) F\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x a + y a) =\n    L2_set (\\<lambda>a. cmod (x a + y a)) F", "by (metis (mono_tags, lifting) L2_set_cong comp_apply normF_def)"], ["proof (state)\nthis:\n  normF F (\\<lambda>a. x a + y a) = L2_set (\\<lambda>a. cmod (x a + y a)) F\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y", "also"], ["proof (state)\nthis:\n  normF F (\\<lambda>a. x a + y a) = L2_set (\\<lambda>a. cmod (x a + y a)) F\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y", "have \\<open>\\<dots> \\<le> L2_set (\\<lambda>a. cmod (x a) + cmod (y a)) F\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (\\<lambda>a. cmod (x a + y a)) F\n    \\<le> L2_set (\\<lambda>a. cmod (x a) + cmod (y a)) F", "by (meson L2_set_mono norm_ge_zero norm_triangle_ineq)"], ["proof (state)\nthis:\n  L2_set (\\<lambda>a. cmod (x a + y a)) F\n  \\<le> L2_set (\\<lambda>a. cmod (x a) + cmod (y a)) F\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y", "also"], ["proof (state)\nthis:\n  L2_set (\\<lambda>a. cmod (x a + y a)) F\n  \\<le> L2_set (\\<lambda>a. cmod (x a) + cmod (y a)) F\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y", "have \\<open>\\<dots> \\<le> L2_set (\\<lambda>a. cmod (x a)) F + L2_set (\\<lambda>a. cmod (y a)) F\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (\\<lambda>a. cmod (x a) + cmod (y a)) F\n    \\<le> L2_set (\\<lambda>a. cmod (x a)) F +\n          L2_set (\\<lambda>a. cmod (y a)) F", "by (simp add: L2_set_triangle_ineq)"], ["proof (state)\nthis:\n  L2_set (\\<lambda>a. cmod (x a) + cmod (y a)) F\n  \\<le> L2_set (\\<lambda>a. cmod (x a)) F +\n        L2_set (\\<lambda>a. cmod (y a)) F\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y", "also"], ["proof (state)\nthis:\n  L2_set (\\<lambda>a. cmod (x a) + cmod (y a)) F\n  \\<le> L2_set (\\<lambda>a. cmod (x a)) F +\n        L2_set (\\<lambda>a. cmod (y a)) F\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y", "have \\<open>\\<dots> \\<le> normF F x + normF F y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (\\<lambda>a. cmod (x a)) F + L2_set (\\<lambda>a. cmod (y a)) F\n    \\<le> normF F x + normF F y", "by (smt (verit, best) L2_set_cong normF_def comp_apply)"], ["proof (state)\nthis:\n  L2_set (\\<lambda>a. cmod (x a)) F + L2_set (\\<lambda>a. cmod (y a)) F\n  \\<le> normF F x + normF F y\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y", "finally"], ["proof (chain)\npicking this:\n  normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y", "show ?thesis"], ["proof (prove)\nusing this:\n  normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y", "by -"], ["proof (state)\nthis:\n  normF F (\\<lambda>a. x a + y a) \\<le> normF F x + normF F y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow>\n  normF ?F (\\<lambda>a. ?x a + ?y a) \\<le> normF ?F ?x + normF ?F ?y\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have normF_negate: \\<open>normF F (\\<lambda>a. - x a) = normF F x\\<close> if \\<open>finite F\\<close> for F x"], ["proof (prove)\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. - x a) = normF F x", "unfolding normF_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. L2_set (\\<lambda>x. cmod (- x x)) F = L2_set (\\<lambda>x. cmod (x x)) F", "by simp"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow> normF ?F (\\<lambda>a. - ?x a) = normF ?F ?x\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have normF_ell2norm: \\<open>normF F x \\<le> ell2_norm x\\<close> if \\<open>finite F\\<close> and \\<open>has_ell2_norm x\\<close> for F x"], ["proof (prove)\ngoal (1 subgoal):\n 1. normF F x \\<le> ell2_norm x", "apply (auto intro!: cSUP_upper2[where x=F] simp: that normF_def ell2_norm_L2_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above (L2_set (cmod \\<circ> x) ` {F. finite F})", "by (meson has_ell2_norm_L2_set that(2))"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?F; has_ell2_norm ?x\\<rbrakk>\n  \\<Longrightarrow> normF ?F ?x \\<le> ell2_norm ?x\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "note Lim_bounded2[rotated, rule_format, trans]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>n. ?N \\<le> n \\<Longrightarrow> ?C \\<le> ?f n;\n   ?f \\<longlonglongrightarrow> ?l\\<rbrakk>\n  \\<Longrightarrow> ?C \\<le> ?l\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "from \\<open>Cauchy X\\<close>"], ["proof (chain)\npicking this:\n  Cauchy X", "obtain I where cauchyX: \\<open>norm (X n - X m) \\<le> \\<epsilon>\\<close> if \\<open>\\<epsilon>>0\\<close> \\<open>n\\<ge>I \\<epsilon>\\<close> \\<open>m\\<ge>I \\<epsilon>\\<close> for \\<epsilon> n m"], ["proof (prove)\nusing this:\n  Cauchy X\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        (\\<And>\\<epsilon> n m.\n            \\<lbrakk>0 < \\<epsilon>; I \\<epsilon> \\<le> n;\n             I \\<epsilon> \\<le> m\\<rbrakk>\n            \\<Longrightarrow> norm (X n - X m)\n                              \\<le> \\<epsilon>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Cauchy_def dist_norm less_eq_real_def)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?\\<epsilon>; I ?\\<epsilon> \\<le> ?n;\n   I ?\\<epsilon> \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> norm (X ?n - X ?m) \\<le> ?\\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have normF_xx: \\<open>normF F (\\<lambda>a. x n a - x m a) \\<le> \\<epsilon>\\<close> if \\<open>finite F\\<close> \\<open>\\<epsilon>>0\\<close> \\<open>n\\<ge>I \\<epsilon>\\<close> \\<open>m\\<ge>I \\<epsilon>\\<close> for \\<epsilon> n m F"], ["proof (prove)\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x n a - x m a) \\<le> \\<epsilon>", "apply (subst asm_rl[of \\<open>(\\<lambda>a. x n a - x m a) = Rep_ell2 (X n - X m)\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>a. x n a - x m a) = Rep_ell2 (X n - X m)\n 2. normF F (Rep_ell2 (X n - X m)) \\<le> \\<epsilon>", "apply (simp add: x_def minus_ell2.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. normF F (Rep_ell2 (X n - X m)) \\<le> \\<epsilon>", "using that cauchyX"], ["proof (prove)\nusing this:\n  finite F\n  0 < \\<epsilon>\n  I \\<epsilon> \\<le> n\n  I \\<epsilon> \\<le> m\n  \\<lbrakk>0 < ?\\<epsilon>; I ?\\<epsilon> \\<le> ?n;\n   I ?\\<epsilon> \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> norm (X ?n - X ?m) \\<le> ?\\<epsilon>\n\ngoal (1 subgoal):\n 1. normF F (Rep_ell2 (X n - X m)) \\<le> \\<epsilon>", "by (metis Rep_ell2 mem_Collect_eq normF_ell2norm norm_ell2.rep_eq order_trans)"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?F; 0 < ?\\<epsilon>; I ?\\<epsilon> \\<le> ?n;\n   I ?\\<epsilon> \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> normF ?F (\\<lambda>a. x ?n a - x ?m a) \\<le> ?\\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have normF_xl_lim: \\<open>(\\<lambda>m. normF F (\\<lambda>a. x m a - l a)) \\<longlonglongrightarrow> 0\\<close> if \\<open>finite F\\<close> for F"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m. normF F (\\<lambda>a. x m a - l a))\n    \\<longlonglongrightarrow> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>m. normF F (\\<lambda>a. x m a - l a))\n    \\<longlonglongrightarrow> 0", "have \\<open>(\\<lambda>xa. cmod (x xa m - l m)) \\<longlonglongrightarrow> 0\\<close> for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xa. cmod (x xa m - l m)) \\<longlonglongrightarrow> 0", "using x_lim"], ["proof (prove)\nusing this:\n  (\\<lambda>n. x n ?a) \\<longlonglongrightarrow> l ?a\n\ngoal (1 subgoal):\n 1. (\\<lambda>xa. cmod (x xa m - l m)) \\<longlonglongrightarrow> 0", "by (simp add: LIM_zero_iff tendsto_norm_zero)"], ["proof (state)\nthis:\n  (\\<lambda>xa. cmod (x xa ?m - l ?m)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>m. normF F (\\<lambda>a. x m a - l a))\n    \\<longlonglongrightarrow> 0", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>xa. cmod (x xa ?m - l ?m)) \\<longlonglongrightarrow> 0", "have \\<open>(\\<lambda>m. \\<Sum>i\\<in>F. ((cmod \\<circ> (\\<lambda>a. x m a - l a)) i)\\<^sup>2) \\<longlonglongrightarrow> 0\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>xa. cmod (x xa ?m - l ?m)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>m.\n        \\<Sum>i\\<in>F. ((cmod \\<circ> (\\<lambda>a. x m a - l a)) i)\\<^sup>2)\n    \\<longlonglongrightarrow> 0", "by (auto intro: tendsto_null_sum)"], ["proof (state)\nthis:\n  (\\<lambda>m.\n      \\<Sum>i\\<in>F. ((cmod \\<circ> (\\<lambda>a. x m a - l a)) i)\\<^sup>2)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>m. normF F (\\<lambda>a. x m a - l a))\n    \\<longlonglongrightarrow> 0", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>m.\n      \\<Sum>i\\<in>F. ((cmod \\<circ> (\\<lambda>a. x m a - l a)) i)\\<^sup>2)\n  \\<longlonglongrightarrow> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>m.\n      \\<Sum>i\\<in>F. ((cmod \\<circ> (\\<lambda>a. x m a - l a)) i)\\<^sup>2)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>m. normF F (\\<lambda>a. x m a - l a))\n    \\<longlonglongrightarrow> 0", "unfolding normF_def L2_set_def"], ["proof (prove)\nusing this:\n  (\\<lambda>m.\n      \\<Sum>i\\<in>F. ((cmod \\<circ> (\\<lambda>a. x m a - l a)) i)\\<^sup>2)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>m.\n        sqrt\n         (\\<Sum>i\\<in>F.\n            ((cmod \\<circ> (\\<lambda>a. x m a - l a)) i)\\<^sup>2))\n    \\<longlonglongrightarrow> 0", "using tendsto_real_sqrt"], ["proof (prove)\nusing this:\n  (\\<lambda>m.\n      \\<Sum>i\\<in>F. ((cmod \\<circ> (\\<lambda>a. x m a - l a)) i)\\<^sup>2)\n  \\<longlonglongrightarrow> 0\n  (?f \\<longlongrightarrow> ?x) ?F \\<Longrightarrow>\n  ((\\<lambda>x. sqrt (?f x)) \\<longlongrightarrow> sqrt ?x) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>m.\n        sqrt\n         (\\<Sum>i\\<in>F.\n            ((cmod \\<circ> (\\<lambda>a. x m a - l a)) i)\\<^sup>2))\n    \\<longlonglongrightarrow> 0", "by force"], ["proof (state)\nthis:\n  (\\<lambda>m. normF F (\\<lambda>a. x m a - l a))\n  \\<longlonglongrightarrow> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow>\n  (\\<lambda>m. normF ?F (\\<lambda>a. x m a - l a))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have normF_xl: \\<open>normF F (\\<lambda>a. x n a - l a) \\<le> \\<epsilon>\\<close>\n    if \\<open>n \\<ge> I \\<epsilon>\\<close> and \\<open>\\<epsilon> > 0\\<close> and \\<open>finite F\\<close> for n \\<epsilon> F"], ["proof (prove)\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x n a - l a) \\<le> \\<epsilon>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x n a - l a) \\<le> \\<epsilon>", "have \\<open>normF F (\\<lambda>a. x n a - l a) - \\<epsilon> \\<le> normF F (\\<lambda>a. x n a - x m a) + normF F (\\<lambda>a. x m a - l a) - \\<epsilon>\\<close> for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x n a - l a) - \\<epsilon>\n    \\<le> normF F (\\<lambda>a. x n a - x m a) +\n          normF F (\\<lambda>a. x m a - l a) -\n          \\<epsilon>", "using normF_triangle[OF \\<open>finite F\\<close>, where x=\\<open>(\\<lambda>a. x n a - x m a)\\<close> and y=\\<open>(\\<lambda>a. x m a - l a)\\<close>]"], ["proof (prove)\nusing this:\n  normF F (\\<lambda>a. x n a - x m a + (x m a - l a))\n  \\<le> normF F (\\<lambda>a. x n a - x m a) +\n        normF F (\\<lambda>a. x m a - l a)\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x n a - l a) - \\<epsilon>\n    \\<le> normF F (\\<lambda>a. x n a - x m a) +\n          normF F (\\<lambda>a. x m a - l a) -\n          \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  normF F (\\<lambda>a. x n a - l a) - \\<epsilon>\n  \\<le> normF F (\\<lambda>a. x n a - x ?m a) +\n        normF F (\\<lambda>a. x ?m a - l a) -\n        \\<epsilon>\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x n a - l a) \\<le> \\<epsilon>", "also"], ["proof (state)\nthis:\n  normF F (\\<lambda>a. x n a - l a) - \\<epsilon>\n  \\<le> normF F (\\<lambda>a. x n a - x ?m a) +\n        normF F (\\<lambda>a. x ?m a - l a) -\n        \\<epsilon>\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x n a - l a) \\<le> \\<epsilon>", "have \\<open>\\<dots> m \\<le> normF F (\\<lambda>a. x m a - l a)\\<close> if \\<open>m \\<ge> I \\<epsilon>\\<close> for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x n a - x m a) +\n    normF F (\\<lambda>a. x m a - l a) -\n    \\<epsilon>\n    \\<le> normF F (\\<lambda>a. x m a - l a)", "using normF_xx[OF \\<open>finite F\\<close> \\<open>\\<epsilon>>0\\<close> \\<open>n \\<ge> I \\<epsilon>\\<close> \\<open>m \\<ge> I \\<epsilon>\\<close>]"], ["proof (prove)\nusing this:\n  normF F (\\<lambda>a. x n a - x m a) \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x n a - x m a) +\n    normF F (\\<lambda>a. x m a - l a) -\n    \\<epsilon>\n    \\<le> normF F (\\<lambda>a. x m a - l a)", "by auto"], ["proof (state)\nthis:\n  I \\<epsilon> \\<le> ?m \\<Longrightarrow>\n  normF F (\\<lambda>a. x n a - x ?m a) +\n  normF F (\\<lambda>a. x ?m a - l a) -\n  \\<epsilon>\n  \\<le> normF F (\\<lambda>a. x ?m a - l a)\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x n a - l a) \\<le> \\<epsilon>", "also"], ["proof (state)\nthis:\n  I \\<epsilon> \\<le> ?m \\<Longrightarrow>\n  normF F (\\<lambda>a. x n a - x ?m a) +\n  normF F (\\<lambda>a. x ?m a - l a) -\n  \\<epsilon>\n  \\<le> normF F (\\<lambda>a. x ?m a - l a)\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x n a - l a) \\<le> \\<epsilon>", "have \\<open>(\\<lambda>m. \\<dots> m) \\<longlonglongrightarrow> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>m. normF F (\\<lambda>a. x m a - l a))\n    \\<longlonglongrightarrow> 0", "using \\<open>finite F\\<close>"], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. (\\<lambda>m. normF F (\\<lambda>a. x m a - l a))\n    \\<longlonglongrightarrow> 0", "by (rule normF_xl_lim)"], ["proof (state)\nthis:\n  (\\<lambda>m. normF F (\\<lambda>a. x m a - l a))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x n a - l a) \\<le> \\<epsilon>", "finally"], ["proof (chain)\npicking this:\n  (\\<And>n.\n      ?N \\<le> n \\<Longrightarrow> I \\<epsilon> \\<le> n) \\<Longrightarrow>\n  normF F (\\<lambda>a. x n a - l a) - \\<epsilon> \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>n.\n      ?N \\<le> n \\<Longrightarrow> I \\<epsilon> \\<le> n) \\<Longrightarrow>\n  normF F (\\<lambda>a. x n a - l a) - \\<epsilon> \\<le> 0\n\ngoal (1 subgoal):\n 1. normF F (\\<lambda>a. x n a - l a) \\<le> \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  normF F (\\<lambda>a. x n a - l a) \\<le> \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>I ?\\<epsilon> \\<le> ?n; 0 < ?\\<epsilon>; finite ?F\\<rbrakk>\n  \\<Longrightarrow> normF ?F (\\<lambda>a. x ?n a - l a) \\<le> ?\\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \\<open>normF F l \\<le> 1 + normF F (x (I 1))\\<close> if [simp]: \\<open>finite F\\<close> for F"], ["proof (prove)\ngoal (1 subgoal):\n 1. normF F l \\<le> 1 + normF F (x (I 1))", "using normF_xl[where F=F and \\<epsilon>=1 and n=\\<open>I 1\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>I 1 \\<le> I 1; 0 < 1; finite F\\<rbrakk>\n  \\<Longrightarrow> normF F (\\<lambda>a. x (I 1) a - l a) \\<le> 1\n\ngoal (1 subgoal):\n 1. normF F l \\<le> 1 + normF F (x (I 1))", "using normF_triangle[where F=F and x=\\<open>x (I 1)\\<close> and y=\\<open>\\<lambda>a. l a - x (I 1) a\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>I 1 \\<le> I 1; 0 < 1; finite F\\<rbrakk>\n  \\<Longrightarrow> normF F (\\<lambda>a. x (I 1) a - l a) \\<le> 1\n  finite F \\<Longrightarrow>\n  normF F (\\<lambda>a. x (I 1) a + (l a - x (I 1) a))\n  \\<le> normF F (x (I 1)) + normF F (\\<lambda>a. l a - x (I 1) a)\n\ngoal (1 subgoal):\n 1. normF F l \\<le> 1 + normF F (x (I 1))", "using normF_negate[where F=F and x=\\<open>(\\<lambda>a. x (I 1) a - l a)\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>I 1 \\<le> I 1; 0 < 1; finite F\\<rbrakk>\n  \\<Longrightarrow> normF F (\\<lambda>a. x (I 1) a - l a) \\<le> 1\n  finite F \\<Longrightarrow>\n  normF F (\\<lambda>a. x (I 1) a + (l a - x (I 1) a))\n  \\<le> normF F (x (I 1)) + normF F (\\<lambda>a. l a - x (I 1) a)\n  finite F \\<Longrightarrow>\n  normF F (\\<lambda>a. - (x (I 1) a - l a)) =\n  normF F (\\<lambda>a. x (I 1) a - l a)\n\ngoal (1 subgoal):\n 1. normF F l \\<le> 1 + normF F (x (I 1))", "by auto"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow> normF ?F l \\<le> 1 + normF ?F (x (I 1))\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "also"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow> normF ?F l \\<le> 1 + normF ?F (x (I 1))\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \\<open>\\<dots> F \\<le> 1 + ell2_norm (x (I 1))\\<close> if \\<open>finite F\\<close> for F"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + normF F (x (I 1)) \\<le> 1 + ell2_norm (x (I 1))", "using normF_ell2norm that"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?F; has_ell2_norm ?x\\<rbrakk>\n  \\<Longrightarrow> normF ?F ?x \\<le> ell2_norm ?x\n  finite F\n\ngoal (1 subgoal):\n 1. 1 + normF F (x (I 1)) \\<le> 1 + ell2_norm (x (I 1))", "by simp"], ["proof (state)\nthis:\n  finite ?F \\<Longrightarrow>\n  1 + normF ?F (x (I 1)) \\<le> 1 + ell2_norm (x (I 1))\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite ?F1; finite ?F1\\<rbrakk>\n  \\<Longrightarrow> normF ?F1 l \\<le> 1 + ell2_norm (x (I 1))", "have [simp]: \\<open>has_ell2_norm l\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?F1; finite ?F1\\<rbrakk>\n  \\<Longrightarrow> normF ?F1 l \\<le> 1 + ell2_norm (x (I 1))\n\ngoal (1 subgoal):\n 1. has_ell2_norm l", "unfolding has_ell2_norm_L2_set"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?F1; finite ?F1\\<rbrakk>\n  \\<Longrightarrow> normF ?F1 l \\<le> 1 + ell2_norm (x (I 1))\n\ngoal (1 subgoal):\n 1. bdd_above (L2_set (cmod \\<circ> l) ` Collect finite)", "by (auto intro!: bdd_aboveI simp flip: normF_def)"], ["proof (state)\nthis:\n  has_ell2_norm l\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "then"], ["proof (chain)\npicking this:\n  has_ell2_norm l", "have \\<open>l = Rep_ell2 L\\<close>"], ["proof (prove)\nusing this:\n  has_ell2_norm l\n\ngoal (1 subgoal):\n 1. l = Rep_ell2 L", "by (simp add: Abs_ell2_inverse L_def)"], ["proof (state)\nthis:\n  l = Rep_ell2 L\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have [simp]: \\<open>has_ell2_norm (\\<lambda>a. x n a - l a)\\<close> for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm (\\<lambda>a. x n a - l a)", "apply (subst diff_conv_add_uminus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm (\\<lambda>a. x n a + - l a)", "apply (rule ell2_norm_triangle)"], ["proof (prove)\ngoal (2 subgoals):\n 1. has_ell2_norm (x n)\n 2. has_ell2_norm (\\<lambda>i. - l i)", "by (auto intro!: ell2_norm_uminus)"], ["proof (state)\nthis:\n  has_ell2_norm (\\<lambda>a. x ?n a - l a)\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "from normF_xl"], ["proof (chain)\npicking this:\n  \\<lbrakk>I ?\\<epsilon> \\<le> ?n; 0 < ?\\<epsilon>; finite ?F\\<rbrakk>\n  \\<Longrightarrow> normF ?F (\\<lambda>a. x ?n a - l a) \\<le> ?\\<epsilon>", "have ell2norm_xl: \\<open>ell2_norm (\\<lambda>a. x n a - l a) \\<le> \\<epsilon>\\<close>\n    if \\<open>n \\<ge> I \\<epsilon>\\<close> and \\<open>\\<epsilon> > 0\\<close> for n \\<epsilon>"], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?\\<epsilon> \\<le> ?n; 0 < ?\\<epsilon>; finite ?F\\<rbrakk>\n  \\<Longrightarrow> normF ?F (\\<lambda>a. x ?n a - l a) \\<le> ?\\<epsilon>\n\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>a. x n a - l a) \\<le> \\<epsilon>", "apply (subst ell2_norm_L2_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>\\<epsilon> n F.\n        \\<lbrakk>I \\<epsilon> \\<le> n; 0 < \\<epsilon>; finite F\\<rbrakk>\n        \\<Longrightarrow> normF F (\\<lambda>a. x n a - l a)\n                          \\<le> \\<epsilon>) \\<Longrightarrow>\n    has_ell2_norm (\\<lambda>a. x n a - l a)\n 2. (\\<And>\\<epsilon> n F.\n        \\<lbrakk>I \\<epsilon> \\<le> n; 0 < \\<epsilon>; finite F\\<rbrakk>\n        \\<Longrightarrow> normF F (\\<lambda>a. x n a - l a)\n                          \\<le> \\<epsilon>) \\<Longrightarrow>\n    \\<Squnion>\n     (L2_set (cmod \\<circ> (\\<lambda>a. x n a - l a)) ` Collect finite)\n    \\<le> \\<epsilon>", "using that"], ["proof (prove)\nusing this:\n  I \\<epsilon> \\<le> n\n  0 < \\<epsilon>\n\ngoal (2 subgoals):\n 1. (\\<And>\\<epsilon> n F.\n        \\<lbrakk>I \\<epsilon> \\<le> n; 0 < \\<epsilon>; finite F\\<rbrakk>\n        \\<Longrightarrow> normF F (\\<lambda>a. x n a - l a)\n                          \\<le> \\<epsilon>) \\<Longrightarrow>\n    has_ell2_norm (\\<lambda>a. x n a - l a)\n 2. (\\<And>\\<epsilon> n F.\n        \\<lbrakk>I \\<epsilon> \\<le> n; 0 < \\<epsilon>; finite F\\<rbrakk>\n        \\<Longrightarrow> normF F (\\<lambda>a. x n a - l a)\n                          \\<le> \\<epsilon>) \\<Longrightarrow>\n    \\<Squnion>\n     (L2_set (cmod \\<circ> (\\<lambda>a. x n a - l a)) ` Collect finite)\n    \\<le> \\<epsilon>", "by (auto intro!: cSUP_least simp: normF_def)"], ["proof (state)\nthis:\n  \\<lbrakk>I ?\\<epsilon> \\<le> ?n; 0 < ?\\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> ell2_norm (\\<lambda>a. x ?n a - l a) \\<le> ?\\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "have \\<open>norm (X n - L) \\<le> \\<epsilon>\\<close> if \\<open>n \\<ge> I \\<epsilon>\\<close> and \\<open>\\<epsilon> > 0\\<close> for n \\<epsilon>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (X n - L) \\<le> \\<epsilon>", "using ell2norm_xl[OF that]"], ["proof (prove)\nusing this:\n  ell2_norm (\\<lambda>a. x n a - l a) \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. norm (X n - L) \\<le> \\<epsilon>", "apply (simp add: x_def norm_ell2.rep_eq \\<open>l = Rep_ell2 L\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm (\\<lambda>a. Rep_ell2 (X n) a - Rep_ell2 L a)\n    \\<le> \\<epsilon> \\<Longrightarrow>\n    ell2_norm (Rep_ell2 (X n - L)) \\<le> \\<epsilon>", "by (smt (verit, best) SUP_cong ell2_norm_def minus_ell2.rep_eq sum.cong)"], ["proof (state)\nthis:\n  \\<lbrakk>I ?\\<epsilon> \\<le> ?n; 0 < ?\\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> norm (X ?n - L) \\<le> ?\\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>I ?\\<epsilon> \\<le> ?n; 0 < ?\\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> norm (X ?n - L) \\<le> ?\\<epsilon>", "have \\<open>X \\<longlonglongrightarrow> L\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?\\<epsilon> \\<le> ?n; 0 < ?\\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> norm (X ?n - L) \\<le> ?\\<epsilon>\n\ngoal (1 subgoal):\n 1. X \\<longlonglongrightarrow> L", "unfolding tendsto_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?\\<epsilon> \\<le> ?n; 0 < ?\\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> norm (X ?n - L) \\<le> ?\\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<forall>e>0. \\<forall>\\<^sub>F x in sequentially. dist (X x) L < e", "apply (auto simp: dist_norm eventually_sequentially)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>\\<And>\\<epsilon> n.\n                   \\<lbrakk>I \\<epsilon> \\<le> n; 0 < \\<epsilon>\\<rbrakk>\n                   \\<Longrightarrow> norm (X n - L) \\<le> \\<epsilon>;\n        0 < e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N. \\<forall>n\\<ge>N. norm (X n - L) < e", "by (meson field_lbound_gt_zero le_less_trans)"], ["proof (state)\nthis:\n  X \\<longlonglongrightarrow> L\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "then"], ["proof (chain)\npicking this:\n  X \\<longlonglongrightarrow> L", "show \\<open>convergent X\\<close>"], ["proof (prove)\nusing this:\n  X \\<longlonglongrightarrow> L\n\ngoal (1 subgoal):\n 1. convergent X", "by (rule convergentI)"], ["proof (state)\nthis:\n  convergent X\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation ell2 :: (CARD_1) complex_algebra_1 \nbegin"], ["", "lift_definition one_ell2 :: \"'a ell2\" is \"\\<lambda>_. 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm (\\<lambda>_. 1)", "by simp"], ["", "lift_definition times_ell2 :: \"'a ell2 \\<Rightarrow> 'a ell2 \\<Rightarrow> 'a ell2\" is \"\\<lambda>a b x. a x * b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>has_ell2_norm fun1; has_ell2_norm fun2\\<rbrakk>\n       \\<Longrightarrow> has_ell2_norm (\\<lambda>x. fun1 x * fun2 x)", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ell2, complex_algebra_1_class)", "proof"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b c. (a + b) * c = a * c + b * c\n 3. \\<And>a b c. a * (b + c) = a * b + a * c\n 4. \\<And>a x y. a *\\<^sub>C x * y = a *\\<^sub>C (x * y)\n 5. \\<And>x a y. x * a *\\<^sub>C y = a *\\<^sub>C (x * y)\n 6. \\<And>a. 1 * a = a\n 7. \\<And>a. a * 1 = a\n 8. 0 \\<noteq> 1", "fix a b c :: \"'a ell2\" and r :: complex"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b c. (a + b) * c = a * c + b * c\n 3. \\<And>a b c. a * (b + c) = a * b + a * c\n 4. \\<And>a x y. a *\\<^sub>C x * y = a *\\<^sub>C (x * y)\n 5. \\<And>x a y. x * a *\\<^sub>C y = a *\\<^sub>C (x * y)\n 6. \\<And>a. 1 * a = a\n 7. \\<And>a. a * 1 = a\n 8. 0 \\<noteq> 1", "show \"a * b * c = a * (b * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b * c = a * (b * c)", "by (transfer, auto)"], ["proof (state)\nthis:\n  a * b * c = a * (b * c)\n\ngoal (7 subgoals):\n 1. \\<And>a b c. (a + b) * c = a * c + b * c\n 2. \\<And>a b c. a * (b + c) = a * b + a * c\n 3. \\<And>a x y. a *\\<^sub>C x * y = a *\\<^sub>C (x * y)\n 4. \\<And>x a y. x * a *\\<^sub>C y = a *\\<^sub>C (x * y)\n 5. \\<And>a. 1 * a = a\n 6. \\<And>a. a * 1 = a\n 7. 0 \\<noteq> 1", "show \"(a + b) * c = a * c + b * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b) * c = a * c + b * c", "apply (transfer, rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c x.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b; has_ell2_norm c\\<rbrakk>\n       \\<Longrightarrow> (a x + b x) * c x = a x * c x + b x * c x", "by (simp add: distrib_left mult.commute)"], ["proof (state)\nthis:\n  (a + b) * c = a * c + b * c\n\ngoal (6 subgoals):\n 1. \\<And>a b c. a * (b + c) = a * b + a * c\n 2. \\<And>a x y. a *\\<^sub>C x * y = a *\\<^sub>C (x * y)\n 3. \\<And>x a y. x * a *\\<^sub>C y = a *\\<^sub>C (x * y)\n 4. \\<And>a. 1 * a = a\n 5. \\<And>a. a * 1 = a\n 6. 0 \\<noteq> 1", "show \"a * (b + c) = a * b + a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (b + c) = a * b + a * c", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b; has_ell2_norm c\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * (b x + c x)) =\n                         (\\<lambda>x. a x * b x + a x * c x)", "by (simp add: ring_class.ring_distribs(1))"], ["proof (state)\nthis:\n  a * (b + c) = a * b + a * c\n\ngoal (5 subgoals):\n 1. \\<And>a x y. a *\\<^sub>C x * y = a *\\<^sub>C (x * y)\n 2. \\<And>x a y. x * a *\\<^sub>C y = a *\\<^sub>C (x * y)\n 3. \\<And>a. 1 * a = a\n 4. \\<And>a. a * 1 = a\n 5. 0 \\<noteq> 1", "show \"r *\\<^sub>C a * b = r *\\<^sub>C (a * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>C a * b = r *\\<^sub>C (a * b)", "by (transfer, auto)"], ["proof (state)\nthis:\n  r *\\<^sub>C a * b = r *\\<^sub>C (a * b)\n\ngoal (4 subgoals):\n 1. \\<And>x a y. x * a *\\<^sub>C y = a *\\<^sub>C (x * y)\n 2. \\<And>a. 1 * a = a\n 3. \\<And>a. a * 1 = a\n 4. 0 \\<noteq> 1", "show \"(a::'a ell2) * r *\\<^sub>C b = r *\\<^sub>C (a * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * r *\\<^sub>C b = r *\\<^sub>C (a * b)", "by (transfer, auto)"], ["proof (state)\nthis:\n  a * r *\\<^sub>C b = r *\\<^sub>C (a * b)\n\ngoal (3 subgoals):\n 1. \\<And>a. 1 * a = a\n 2. \\<And>a. a * 1 = a\n 3. 0 \\<noteq> 1", "show \"1 * a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * a = a", "by (transfer, rule ext, auto)"], ["proof (state)\nthis:\n  1 * a = a\n\ngoal (2 subgoals):\n 1. \\<And>a. a * 1 = a\n 2. 0 \\<noteq> 1", "show \"a * 1 = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * 1 = a", "by (transfer, rule ext, auto)"], ["proof (state)\nthis:\n  a * 1 = a\n\ngoal (1 subgoal):\n 1. 0 \\<noteq> 1", "show \"(0::'a ell2) \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> 1", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. 0) \\<noteq> (\\<lambda>_. 1)", "by (meson zero_neq_one)"], ["proof (state)\nthis:\n  0 \\<noteq> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation ell2 :: (CARD_1) field begin"], ["", "lift_definition divide_ell2 :: \"'a ell2 \\<Rightarrow> 'a ell2 \\<Rightarrow> 'a ell2\" is \"\\<lambda>a b x. a x / b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>has_ell2_norm fun1; has_ell2_norm fun2\\<rbrakk>\n       \\<Longrightarrow> has_ell2_norm (\\<lambda>x. fun1 x / fun2 x)", "by simp"], ["", "lift_definition inverse_ell2 :: \"'a ell2 \\<Rightarrow> 'a ell2\" is \"\\<lambda>a x. inverse (a x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun.\n       has_ell2_norm fun \\<Longrightarrow>\n       has_ell2_norm (\\<lambda>x. inverse (fun x))", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ell2, field_class)", "proof (intro_classes; transfer)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) = (\\<lambda>x. b x * a x)\n 2. \\<And>a. has_ell2_norm a \\<Longrightarrow> (\\<lambda>x. 1 * a x) = a\n 3. \\<And>a b c.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b; has_ell2_norm c\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a x + b x) * c x) =\n                         (\\<lambda>x. a x * c x + b x * c x)\n 4. \\<And>a.\n       \\<lbrakk>has_ell2_norm a; a \\<noteq> (\\<lambda>_. 0)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse (a x) * a x) = (\\<lambda>_. 1)\n 5. \\<And>a b.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x / b x) =\n                         (\\<lambda>x. a x * inverse (b x))\n 6. (\\<lambda>x. inverse 0) = (\\<lambda>_. 0)", "fix a :: \"'a \\<Rightarrow> complex\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) = (\\<lambda>x. b x * a x)\n 2. \\<And>a. has_ell2_norm a \\<Longrightarrow> (\\<lambda>x. 1 * a x) = a\n 3. \\<And>a b c.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b; has_ell2_norm c\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a x + b x) * c x) =\n                         (\\<lambda>x. a x * c x + b x * c x)\n 4. \\<And>a.\n       \\<lbrakk>has_ell2_norm a; a \\<noteq> (\\<lambda>_. 0)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse (a x) * a x) = (\\<lambda>_. 1)\n 5. \\<And>a b.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x / b x) =\n                         (\\<lambda>x. a x * inverse (b x))\n 6. (\\<lambda>x. inverse 0) = (\\<lambda>_. 0)", "assume \"a \\<noteq> (\\<lambda>_. 0)\""], ["proof (state)\nthis:\n  a \\<noteq> (\\<lambda>_. 0)\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) = (\\<lambda>x. b x * a x)\n 2. \\<And>a. has_ell2_norm a \\<Longrightarrow> (\\<lambda>x. 1 * a x) = a\n 3. \\<And>a b c.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b; has_ell2_norm c\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a x + b x) * c x) =\n                         (\\<lambda>x. a x * c x + b x * c x)\n 4. \\<And>a.\n       \\<lbrakk>has_ell2_norm a; a \\<noteq> (\\<lambda>_. 0)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse (a x) * a x) = (\\<lambda>_. 1)\n 5. \\<And>a b.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x / b x) =\n                         (\\<lambda>x. a x * inverse (b x))\n 6. (\\<lambda>x. inverse 0) = (\\<lambda>_. 0)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> (\\<lambda>_. 0)", "obtain y where ay: \"a y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> (\\<lambda>_. 0)\n\ngoal (1 subgoal):\n 1. (\\<And>y. a y \\<noteq> 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a y \\<noteq> 0\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) = (\\<lambda>x. b x * a x)\n 2. \\<And>a. has_ell2_norm a \\<Longrightarrow> (\\<lambda>x. 1 * a x) = a\n 3. \\<And>a b c.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b; has_ell2_norm c\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a x + b x) * c x) =\n                         (\\<lambda>x. a x * c x + b x * c x)\n 4. \\<And>a.\n       \\<lbrakk>has_ell2_norm a; a \\<noteq> (\\<lambda>_. 0)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. inverse (a x) * a x) = (\\<lambda>_. 1)\n 5. \\<And>a b.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x / b x) =\n                         (\\<lambda>x. a x * inverse (b x))\n 6. (\\<lambda>x. inverse 0) = (\\<lambda>_. 0)", "show \"(\\<lambda>x. inverse (a x) * a x) = (\\<lambda>_. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. inverse (a x) * a x) = (\\<lambda>_. 1)", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. inverse (a x) * a x = 1", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. inverse (a x) * a x = 1", "have \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<And>x. inverse (a x) * a x = 1", "with ay"], ["proof (chain)\npicking this:\n  a y \\<noteq> 0\n  x = y", "have \"a x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a y \\<noteq> 0\n  x = y\n\ngoal (1 subgoal):\n 1. a x \\<noteq> 0", "by metis"], ["proof (state)\nthis:\n  a x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x. inverse (a x) * a x = 1", "then"], ["proof (chain)\npicking this:\n  a x \\<noteq> 0", "show \"inverse (a x) * a x = 1\""], ["proof (prove)\nusing this:\n  a x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inverse (a x) * a x = 1", "by auto"], ["proof (state)\nthis:\n  inverse (a x) * a x = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. inverse (a x) * a x) = (\\<lambda>_. 1)\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x * b x) = (\\<lambda>x. b x * a x)\n 2. \\<And>a. has_ell2_norm a \\<Longrightarrow> (\\<lambda>x. 1 * a x) = a\n 3. \\<And>a b c.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b; has_ell2_norm c\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (a x + b x) * c x) =\n                         (\\<lambda>x. a x * c x + b x * c x)\n 4. \\<And>a b.\n       \\<lbrakk>has_ell2_norm a; has_ell2_norm b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a x / b x) =\n                         (\\<lambda>x. a x * inverse (b x))\n 5. (\\<lambda>x. inverse 0) = (\\<lambda>_. 0)", "qed (auto simp add: divide_complex_def mult.commute ring_class.ring_distribs)"], ["", "end"], ["", "subsection \\<open>Orthogonality\\<close>"], ["", "lemma ell2_pointwise_ortho:\n  assumes \\<open>\\<And> i. Rep_ell2 x i = 0 \\<or> Rep_ell2 y i = 0\\<close>\n  shows \\<open>is_orthogonal x y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal x y", "using assms"], ["proof (prove)\nusing this:\n  Rep_ell2 x ?i = 0 \\<or> Rep_ell2 y ?i = 0\n\ngoal (1 subgoal):\n 1. is_orthogonal x y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y;\n        \\<And>i. x i = 0 \\<or> y i = 0\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>\\<^sub>ai. cnj (x i) * y i) = 0", "by (simp add: infsetsum_all_0)"], ["", "subsection \\<open>Truncated vectors\\<close>"], ["", "lift_definition trunc_ell2:: \\<open>'a set \\<Rightarrow> 'a ell2 \\<Rightarrow> 'a ell2\\<close>\n  is \\<open>\\<lambda> S x. (\\<lambda> i. (if i \\<in> S then x i else 0))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set fun.\n       has_ell2_norm fun \\<Longrightarrow>\n       has_ell2_norm (\\<lambda>i. if i \\<in> set then fun i else 0)", "unfolding has_ell2_norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set fun.\n       bdd_above\n        (sum (\\<lambda>i. (cmod (fun i))\\<^sup>2) `\n         Collect finite) \\<Longrightarrow>\n       bdd_above\n        (sum (\\<lambda>i.\n                 (cmod (if i \\<in> set then fun i else 0))\\<^sup>2) `\n         Collect finite)", "apply (rule bdd_above_image_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>set fun x.\n       \\<lbrakk>bdd_above\n                 (sum (\\<lambda>i. (cmod (fun i))\\<^sup>2) `\n                  Collect finite);\n        x \\<in> Collect finite\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>i\\<in>x.\n                            (cmod\n                              (if i \\<in> set then fun i else 0))\\<^sup>2)\n                         \\<le> ?g set fun x\n 2. \\<And>set fun.\n       bdd_above\n        (sum (\\<lambda>i. (cmod (fun i))\\<^sup>2) `\n         Collect finite) \\<Longrightarrow>\n       bdd_above (?g set fun ` Collect finite)", "by (auto intro!: sum_mono)"], ["", "lemma trunc_ell2_empty[simp]: \\<open>trunc_ell2 {} x = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. trunc_ell2 {} x = 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       has_ell2_norm x \\<Longrightarrow>\n       (\\<lambda>i. if i \\<in> {} then x i else 0) = (\\<lambda>_. 0)", "by simp"], ["", "lemma norm_id_minus_trunc_ell2:\n  \\<open>(norm (x - trunc_ell2 S x))^2 = (norm x)^2 - (norm (trunc_ell2 S x))^2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (x - trunc_ell2 S x))\\<^sup>2 =\n    (norm x)\\<^sup>2 - (norm (trunc_ell2 S x))\\<^sup>2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (norm (x - trunc_ell2 S x))\\<^sup>2 =\n    (norm x)\\<^sup>2 - (norm (trunc_ell2 S x))\\<^sup>2", "have \\<open>Rep_ell2 (trunc_ell2 S x) i = 0 \\<or> Rep_ell2 (x - trunc_ell2 S x) i = 0\\<close> for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_ell2 (trunc_ell2 S x) i = 0 \\<or>\n    Rep_ell2 (x - trunc_ell2 S x) i = 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S x i.\n       has_ell2_norm x \\<Longrightarrow>\n       (if i \\<in> S then x i else 0) = 0 \\<or>\n       x i - (if i \\<in> S then x i else 0) = 0", "by auto"], ["proof (state)\nthis:\n  Rep_ell2 (trunc_ell2 S x) ?i = 0 \\<or>\n  Rep_ell2 (x - trunc_ell2 S x) ?i = 0\n\ngoal (1 subgoal):\n 1. (norm (x - trunc_ell2 S x))\\<^sup>2 =\n    (norm x)\\<^sup>2 - (norm (trunc_ell2 S x))\\<^sup>2", "hence \\<open>\\<langle> (trunc_ell2 S x), (x - trunc_ell2 S x) \\<rangle> = 0\\<close>"], ["proof (prove)\nusing this:\n  Rep_ell2 (trunc_ell2 S x) ?i = 0 \\<or>\n  Rep_ell2 (x - trunc_ell2 S x) ?i = 0\n\ngoal (1 subgoal):\n 1. is_orthogonal (trunc_ell2 S x) (x - trunc_ell2 S x)", "using ell2_pointwise_ortho"], ["proof (prove)\nusing this:\n  Rep_ell2 (trunc_ell2 S x) ?i = 0 \\<or>\n  Rep_ell2 (x - trunc_ell2 S x) ?i = 0\n  (\\<And>i. Rep_ell2 ?x i = 0 \\<or> Rep_ell2 ?y i = 0) \\<Longrightarrow>\n  is_orthogonal ?x ?y\n\ngoal (1 subgoal):\n 1. is_orthogonal (trunc_ell2 S x) (x - trunc_ell2 S x)", "by blast"], ["proof (state)\nthis:\n  is_orthogonal (trunc_ell2 S x) (x - trunc_ell2 S x)\n\ngoal (1 subgoal):\n 1. (norm (x - trunc_ell2 S x))\\<^sup>2 =\n    (norm x)\\<^sup>2 - (norm (trunc_ell2 S x))\\<^sup>2", "hence \\<open>(norm x)^2 = (norm (trunc_ell2 S x))^2 + (norm (x - trunc_ell2 S x))^2\\<close>"], ["proof (prove)\nusing this:\n  is_orthogonal (trunc_ell2 S x) (x - trunc_ell2 S x)\n\ngoal (1 subgoal):\n 1. (norm x)\\<^sup>2 =\n    (norm (trunc_ell2 S x))\\<^sup>2 + (norm (x - trunc_ell2 S x))\\<^sup>2", "using pythagorean_theorem"], ["proof (prove)\nusing this:\n  is_orthogonal (trunc_ell2 S x) (x - trunc_ell2 S x)\n  is_orthogonal ?x ?y \\<Longrightarrow>\n  (norm (?x + ?y))\\<^sup>2 = (norm ?x)\\<^sup>2 + (norm ?y)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (norm x)\\<^sup>2 =\n    (norm (trunc_ell2 S x))\\<^sup>2 + (norm (x - trunc_ell2 S x))\\<^sup>2", "by fastforce"], ["proof (state)\nthis:\n  (norm x)\\<^sup>2 =\n  (norm (trunc_ell2 S x))\\<^sup>2 + (norm (x - trunc_ell2 S x))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (norm (x - trunc_ell2 S x))\\<^sup>2 =\n    (norm x)\\<^sup>2 - (norm (trunc_ell2 S x))\\<^sup>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  (norm x)\\<^sup>2 =\n  (norm (trunc_ell2 S x))\\<^sup>2 + (norm (x - trunc_ell2 S x))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (norm (x - trunc_ell2 S x))\\<^sup>2 =\n    (norm x)\\<^sup>2 - (norm (trunc_ell2 S x))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (norm (x - trunc_ell2 S x))\\<^sup>2 =\n  (norm x)\\<^sup>2 - (norm (trunc_ell2 S x))\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm_trunc_ell2_finite:\n  \\<open>finite S \\<Longrightarrow> (norm (trunc_ell2 S x)) = sqrt ((sum (\\<lambda>i. (cmod (Rep_ell2 x i))\\<^sup>2)) S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    norm (trunc_ell2 S x) =\n    sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    norm (trunc_ell2 S x) =\n    sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "assume \\<open>finite S\\<close>"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    norm (trunc_ell2 S x) =\n    sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "moreover"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    norm (trunc_ell2 S x) =\n    sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "have \\<open>\\<And> i. i \\<notin> S \\<Longrightarrow> Rep_ell2 ((trunc_ell2 S x)) i = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<notin> S \\<Longrightarrow> Rep_ell2 (trunc_ell2 S x) i = 0", "by (simp add: trunc_ell2.rep_eq)"], ["proof (state)\nthis:\n  ?i \\<notin> S \\<Longrightarrow> Rep_ell2 (trunc_ell2 S x) ?i = 0\n\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    norm (trunc_ell2 S x) =\n    sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "ultimately"], ["proof (chain)\npicking this:\n  finite S\n  ?i \\<notin> S \\<Longrightarrow> Rep_ell2 (trunc_ell2 S x) ?i = 0", "have \\<open>(norm (trunc_ell2 S x)) = sqrt ((sum (\\<lambda>i. (cmod (Rep_ell2 ((trunc_ell2 S x)) i))\\<^sup>2)) S)\\<close>"], ["proof (prove)\nusing this:\n  finite S\n  ?i \\<notin> S \\<Longrightarrow> Rep_ell2 (trunc_ell2 S x) ?i = 0\n\ngoal (1 subgoal):\n 1. norm (trunc_ell2 S x) =\n    sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 (trunc_ell2 S x) i))\\<^sup>2)", "using ell2_norm_finite_support"], ["proof (prove)\nusing this:\n  finite S\n  ?i \\<notin> S \\<Longrightarrow> Rep_ell2 (trunc_ell2 S x) ?i = 0\n  \\<lbrakk>finite ?S;\n   \\<And>i. i \\<notin> ?S \\<Longrightarrow> Rep_ell2 ?x i = 0\\<rbrakk>\n  \\<Longrightarrow> norm ?x =\n                    sqrt (\\<Sum>i\\<in>?S. (cmod (Rep_ell2 ?x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. norm (trunc_ell2 S x) =\n    sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 (trunc_ell2 S x) i))\\<^sup>2)", "by blast"], ["proof (state)\nthis:\n  norm (trunc_ell2 S x) =\n  sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 (trunc_ell2 S x) i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    norm (trunc_ell2 S x) =\n    sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "moreover"], ["proof (state)\nthis:\n  norm (trunc_ell2 S x) =\n  sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 (trunc_ell2 S x) i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    norm (trunc_ell2 S x) =\n    sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "have \\<open>\\<And> i. i \\<in> S \\<Longrightarrow> Rep_ell2 ((trunc_ell2 S x)) i = Rep_ell2 x i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       Rep_ell2 (trunc_ell2 S x) i = Rep_ell2 x i", "by (simp add: trunc_ell2.rep_eq)"], ["proof (state)\nthis:\n  ?i \\<in> S \\<Longrightarrow> Rep_ell2 (trunc_ell2 S x) ?i = Rep_ell2 x ?i\n\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    norm (trunc_ell2 S x) =\n    sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "ultimately"], ["proof (chain)\npicking this:\n  norm (trunc_ell2 S x) =\n  sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 (trunc_ell2 S x) i))\\<^sup>2)\n  ?i \\<in> S \\<Longrightarrow> Rep_ell2 (trunc_ell2 S x) ?i = Rep_ell2 x ?i", "show ?thesis"], ["proof (prove)\nusing this:\n  norm (trunc_ell2 S x) =\n  sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 (trunc_ell2 S x) i))\\<^sup>2)\n  ?i \\<in> S \\<Longrightarrow> Rep_ell2 (trunc_ell2 S x) ?i = Rep_ell2 x ?i\n\ngoal (1 subgoal):\n 1. norm (trunc_ell2 S x) =\n    sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  norm (trunc_ell2 S x) =\n  sqrt (\\<Sum>i\\<in>S. (cmod (Rep_ell2 x i))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trunc_ell2_lim_at_UNIV:\n  \\<open>((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>) (finite_subsets_at_top UNIV)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "define f where \\<open>f i = (cmod (Rep_ell2 \\<psi> i))\\<^sup>2\\<close> for i"], ["proof (state)\nthis:\n  f ?i = (cmod (Rep_ell2 \\<psi> ?i))\\<^sup>2\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "have has: \\<open>has_ell2_norm (Rep_ell2 \\<psi>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm (Rep_ell2 \\<psi>)", "using Rep_ell2"], ["proof (prove)\nusing this:\n  Rep_ell2 ?x \\<in> {x. has_ell2_norm x}\n\ngoal (1 subgoal):\n 1. has_ell2_norm (Rep_ell2 \\<psi>)", "by blast"], ["proof (state)\nthis:\n  has_ell2_norm (Rep_ell2 \\<psi>)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "then"], ["proof (chain)\npicking this:\n  has_ell2_norm (Rep_ell2 \\<psi>)", "have summable: \"f abs_summable_on UNIV\""], ["proof (prove)\nusing this:\n  has_ell2_norm (Rep_ell2 \\<psi>)\n\ngoal (1 subgoal):\n 1. f abs_summable_on UNIV", "using f_def has_ell2_norm_infsetsum"], ["proof (prove)\nusing this:\n  has_ell2_norm (Rep_ell2 \\<psi>)\n  f ?i = (cmod (Rep_ell2 \\<psi> ?i))\\<^sup>2\n  has_ell2_norm ?x =\n  ((\\<lambda>i. (cmod (?x i))\\<^sup>2) abs_summable_on UNIV)\n\ngoal (1 subgoal):\n 1. f abs_summable_on UNIV", "by fastforce"], ["proof (state)\nthis:\n  f abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "have \\<open>norm \\<psi> = (ell2_norm (Rep_ell2 \\<psi>))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm \\<psi> = ell2_norm (Rep_ell2 \\<psi>)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       has_ell2_norm \\<psi> \\<Longrightarrow>\n       ell2_norm \\<psi> = ell2_norm \\<psi>", "by simp"], ["proof (state)\nthis:\n  norm \\<psi> = ell2_norm (Rep_ell2 \\<psi>)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "also"], ["proof (state)\nthis:\n  norm \\<psi> = ell2_norm (Rep_ell2 \\<psi>)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "have \\<open>\\<dots> = sqrt (infsetsum' f UNIV)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm (Rep_ell2 \\<psi>) = sqrt (infsetsum' f UNIV)", "unfolding ell2_norm_infsetsum[OF has] f_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (infsetsum f UNIV) = sqrt (infsetsum' f UNIV)", "using summable"], ["proof (prove)\nusing this:\n  f abs_summable_on UNIV\n\ngoal (1 subgoal):\n 1. sqrt (infsetsum f UNIV) = sqrt (infsetsum' f UNIV)", "by (simp add: infsetsum_infsetsum')"], ["proof (state)\nthis:\n  ell2_norm (Rep_ell2 \\<psi>) = sqrt (infsetsum' f UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "finally"], ["proof (chain)\npicking this:\n  norm \\<psi> = sqrt (infsetsum' f UNIV)", "have norm\\<psi>: \\<open>norm \\<psi> = sqrt (infsetsum' f UNIV)\\<close>"], ["proof (prove)\nusing this:\n  norm \\<psi> = sqrt (infsetsum' f UNIV)\n\ngoal (1 subgoal):\n 1. norm \\<psi> = sqrt (infsetsum' f UNIV)", "by -"], ["proof (state)\nthis:\n  norm \\<psi> = sqrt (infsetsum' f UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "have norm_trunc: \\<open>norm (trunc_ell2 S \\<psi>) = sqrt (sum f S)\\<close> if \\<open>finite S\\<close> for S"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (trunc_ell2 S \\<psi>) = sqrt (sum f S)", "using f_def that norm_trunc_ell2_finite"], ["proof (prove)\nusing this:\n  f ?i = (cmod (Rep_ell2 \\<psi> ?i))\\<^sup>2\n  finite S\n  finite ?S \\<Longrightarrow>\n  norm (trunc_ell2 ?S ?x) =\n  sqrt (\\<Sum>i\\<in>?S. (cmod (Rep_ell2 ?x i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. norm (trunc_ell2 S \\<psi>) = sqrt (sum f S)", "by fastforce"], ["proof (state)\nthis:\n  finite ?S \\<Longrightarrow> norm (trunc_ell2 ?S \\<psi>) = sqrt (sum f ?S)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "have \\<open>(sum f \\<longlongrightarrow> infsetsum' f UNIV) (finite_subsets_at_top UNIV)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sum f \\<longlongrightarrow> infsetsum' f UNIV)\n     (finite_subsets_at_top UNIV)", "by (simp add: abs_summable_infsetsum'_converges infsetsum'_tendsto summable)"], ["proof (state)\nthis:\n  (sum f \\<longlongrightarrow> infsetsum' f UNIV)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "then"], ["proof (chain)\npicking this:\n  (sum f \\<longlongrightarrow> infsetsum' f UNIV)\n   (finite_subsets_at_top UNIV)", "have \\<open>((\\<lambda>S. sqrt (sum f S)) \\<longlongrightarrow> sqrt (infsetsum' f UNIV)) (finite_subsets_at_top UNIV)\\<close>"], ["proof (prove)\nusing this:\n  (sum f \\<longlongrightarrow> infsetsum' f UNIV)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. sqrt (sum f S)) \\<longlongrightarrow>\n     sqrt (infsetsum' f UNIV))\n     (finite_subsets_at_top UNIV)", "using tendsto_real_sqrt"], ["proof (prove)\nusing this:\n  (sum f \\<longlongrightarrow> infsetsum' f UNIV)\n   (finite_subsets_at_top UNIV)\n  (?f \\<longlongrightarrow> ?x) ?F \\<Longrightarrow>\n  ((\\<lambda>x. sqrt (?f x)) \\<longlongrightarrow> sqrt ?x) ?F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. sqrt (sum f S)) \\<longlongrightarrow>\n     sqrt (infsetsum' f UNIV))\n     (finite_subsets_at_top UNIV)", "by blast"], ["proof (state)\nthis:\n  ((\\<lambda>S. sqrt (sum f S)) \\<longlongrightarrow>\n   sqrt (infsetsum' f UNIV))\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>S. sqrt (sum f S)) \\<longlongrightarrow>\n   sqrt (infsetsum' f UNIV))\n   (finite_subsets_at_top UNIV)", "have \\<open>((\\<lambda>S. norm (trunc_ell2 S \\<psi>)) \\<longlongrightarrow> norm \\<psi>) (finite_subsets_at_top UNIV)\\<close>"], ["proof (prove)\nusing this:\n  ((\\<lambda>S. sqrt (sum f S)) \\<longlongrightarrow>\n   sqrt (infsetsum' f UNIV))\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. norm (trunc_ell2 S \\<psi>)) \\<longlongrightarrow>\n     norm \\<psi>)\n     (finite_subsets_at_top UNIV)", "apply (subst tendsto_cong[where g=\\<open>\\<lambda>S. sqrt (sum f S)\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((\\<lambda>S. sqrt (sum f S)) \\<longlongrightarrow>\n     sqrt (infsetsum' f UNIV))\n     (finite_subsets_at_top UNIV) \\<Longrightarrow>\n    \\<forall>\\<^sub>F x in finite_subsets_at_top UNIV.\n       norm (trunc_ell2 x \\<psi>) = sqrt (sum f x)\n 2. ((\\<lambda>S. sqrt (sum f S)) \\<longlongrightarrow>\n     sqrt (infsetsum' f UNIV))\n     (finite_subsets_at_top UNIV) \\<Longrightarrow>\n    ((\\<lambda>S. sqrt (sum f S)) \\<longlongrightarrow> norm \\<psi>)\n     (finite_subsets_at_top UNIV)", "by (auto simp add: eventually_finite_subsets_at_top_weakI norm_trunc norm\\<psi>)"], ["proof (state)\nthis:\n  ((\\<lambda>S. norm (trunc_ell2 S \\<psi>)) \\<longlongrightarrow>\n   norm \\<psi>)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>S. norm (trunc_ell2 S \\<psi>)) \\<longlongrightarrow>\n   norm \\<psi>)\n   (finite_subsets_at_top UNIV)", "have \\<open>((\\<lambda>S. (norm (trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow> (norm \\<psi>)\\<^sup>2) (finite_subsets_at_top UNIV)\\<close>"], ["proof (prove)\nusing this:\n  ((\\<lambda>S. norm (trunc_ell2 S \\<psi>)) \\<longlongrightarrow>\n   norm \\<psi>)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S.\n         (norm (trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n     (norm \\<psi>)\\<^sup>2)\n     (finite_subsets_at_top UNIV)", "by (simp add: tendsto_power)"], ["proof (state)\nthis:\n  ((\\<lambda>S. (norm (trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n   (norm \\<psi>)\\<^sup>2)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>S. (norm (trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n   (norm \\<psi>)\\<^sup>2)\n   (finite_subsets_at_top UNIV)", "have \\<open>((\\<lambda>S. (norm \\<psi>)\\<^sup>2 - (norm (trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow> 0) (finite_subsets_at_top UNIV)\\<close>"], ["proof (prove)\nusing this:\n  ((\\<lambda>S. (norm (trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n   (norm \\<psi>)\\<^sup>2)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S.\n         (norm \\<psi>)\\<^sup>2 -\n         (norm (trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n     0)\n     (finite_subsets_at_top UNIV)", "apply (rule tendsto_diff[where a=\\<open>(norm \\<psi>)^2\\<close> and b=\\<open>(norm \\<psi>)^2\\<close>, simplified, rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (norm \\<psi>)\\<^sup>2) \\<longlongrightarrow>\n     (norm \\<psi>)\\<^sup>2)\n     (finite_subsets_at_top UNIV)", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>S.\n       (norm \\<psi>)\\<^sup>2 -\n       (norm (trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n   0)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>S.\n       (norm \\<psi>)\\<^sup>2 -\n       (norm (trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n   0)\n   (finite_subsets_at_top UNIV)", "have \\<open>((\\<lambda>S. (norm (\\<psi> - trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow> 0) (finite_subsets_at_top UNIV)\\<close>"], ["proof (prove)\nusing this:\n  ((\\<lambda>S.\n       (norm \\<psi>)\\<^sup>2 -\n       (norm (trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n   0)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S.\n         (norm\n           (\\<psi> - trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n     0)\n     (finite_subsets_at_top UNIV)", "unfolding norm_id_minus_trunc_ell2"], ["proof (prove)\nusing this:\n  ((\\<lambda>S.\n       (norm \\<psi>)\\<^sup>2 -\n       (norm (trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n   0)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S.\n         (norm \\<psi>)\\<^sup>2 -\n         (norm (trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n     0)\n     (finite_subsets_at_top UNIV)", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>S.\n       (norm (\\<psi> - trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n   0)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>S.\n       (norm (\\<psi> - trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n   0)\n   (finite_subsets_at_top UNIV)", "have \\<open>((\\<lambda>S. norm (\\<psi> - trunc_ell2 S \\<psi>)) \\<longlongrightarrow> 0) (finite_subsets_at_top UNIV)\\<close>"], ["proof (prove)\nusing this:\n  ((\\<lambda>S.\n       (norm (\\<psi> - trunc_ell2 S \\<psi>))\\<^sup>2) \\<longlongrightarrow>\n   0)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. norm (\\<psi> - trunc_ell2 S \\<psi>)) \\<longlongrightarrow>\n     0)\n     (finite_subsets_at_top UNIV)", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>S. norm (\\<psi> - trunc_ell2 S \\<psi>)) \\<longlongrightarrow>\n   0)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>S. norm (\\<psi> - trunc_ell2 S \\<psi>)) \\<longlongrightarrow>\n   0)\n   (finite_subsets_at_top UNIV)", "have \\<open>((\\<lambda>S. \\<psi> - trunc_ell2 S \\<psi>) \\<longlongrightarrow> 0) (finite_subsets_at_top UNIV)\\<close>"], ["proof (prove)\nusing this:\n  ((\\<lambda>S. norm (\\<psi> - trunc_ell2 S \\<psi>)) \\<longlongrightarrow>\n   0)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. \\<psi> - trunc_ell2 S \\<psi>) \\<longlongrightarrow> 0)\n     (finite_subsets_at_top UNIV)", "by (rule tendsto_norm_zero_cancel)"], ["proof (state)\nthis:\n  ((\\<lambda>S. \\<psi> - trunc_ell2 S \\<psi>) \\<longlongrightarrow> 0)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>S. \\<psi> - trunc_ell2 S \\<psi>) \\<longlongrightarrow> 0)\n   (finite_subsets_at_top UNIV)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>S. \\<psi> - trunc_ell2 S \\<psi>) \\<longlongrightarrow> 0)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "apply (rule Lim_transform2[where f=\\<open>\\<lambda>_. \\<psi>\\<close>, rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n   (finite_subsets_at_top UNIV)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Kets and bras\\<close>"], ["", "lift_definition ket :: \"'a \\<Rightarrow> 'a ell2\" is \"\\<lambda>x y. if x=y then 1 else 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. has_ell2_norm (\\<lambda>y. if a = y then 1 else 0)", "by (rule has_ell2_norm_ket)"], ["", "abbreviation bra :: \"'a \\<Rightarrow> (_,complex) cblinfun\" where \"bra i \\<equiv> vector_to_cblinfun (ket i)*\" for i"], ["", "instance ell2 :: (type) not_singleton"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ell2, not_singleton_class)", "proof standard"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y", "have \"ket undefined \\<noteq> (0::'a ell2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket undefined \\<noteq> 0", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>y. if undefined = y then 1 else 0) \\<noteq> (\\<lambda>_. 0)", "show \"(\\<lambda>y. if (undefined::'a) = y then 1::complex else 0) \\<noteq> (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y. if undefined = y then 1 else 0) \\<noteq> (\\<lambda>_. 0)", "by (meson one_neq_zero)"], ["proof (state)\nthis:\n  (\\<lambda>y. if undefined = y then 1 else 0) \\<noteq> (\\<lambda>_. 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ket undefined \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y", "thus \\<open>\\<exists>x y::'a ell2. x \\<noteq> y\\<close>"], ["proof (prove)\nusing this:\n  ket undefined \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<noteq> y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x y. x \\<noteq> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cinner_ket_left: \\<open>\\<langle>ket i, \\<psi>\\<rangle> = Rep_ell2 \\<psi> i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C \\<psi> = Rep_ell2 \\<psi> i", "apply (transfer fixing: i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       has_ell2_norm \\<psi> \\<Longrightarrow>\n       (\\<Sum>\\<^sub>aia. cnj (if i = ia then 1 else 0) * \\<psi> ia) =\n       \\<psi> i", "apply (subst infsetsum_cong_neutral[where B=\\<open>{i}\\<close>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<psi> x.\n       \\<lbrakk>has_ell2_norm \\<psi>; x \\<in> UNIV - {i}\\<rbrakk>\n       \\<Longrightarrow> cnj (if i = x then 1 else 0) * \\<psi> x = 0\n 2. \\<And>\\<psi> x.\n       \\<lbrakk>has_ell2_norm \\<psi>; x \\<in> {i} - UNIV\\<rbrakk>\n       \\<Longrightarrow> ?g36 \\<psi> x = 0\n 3. \\<And>\\<psi> x.\n       \\<lbrakk>has_ell2_norm \\<psi>; x \\<in> UNIV \\<inter> {i}\\<rbrakk>\n       \\<Longrightarrow> cnj (if i = x then 1 else 0) * \\<psi> x =\n                         ?g36 \\<psi> x\n 4. \\<And>\\<psi>.\n       has_ell2_norm \\<psi> \\<Longrightarrow>\n       infsetsum (?g36 \\<psi>) {i} = \\<psi> i", "by auto"], ["", "lemma cinner_ket_right: \\<open>\\<langle>\\<psi>, ket i\\<rangle> = cnj (Rep_ell2 \\<psi> i)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<bullet>\\<^sub>C ket i = cnj (Rep_ell2 \\<psi> i)", "apply (transfer fixing: i)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       has_ell2_norm \\<psi> \\<Longrightarrow>\n       (\\<Sum>\\<^sub>aia. cnj (\\<psi> ia) * (if i = ia then 1 else 0)) =\n       cnj (\\<psi> i)", "apply (subst infsetsum_cong_neutral[where B=\\<open>{i}\\<close>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<psi> x.\n       \\<lbrakk>has_ell2_norm \\<psi>; x \\<in> UNIV - {i}\\<rbrakk>\n       \\<Longrightarrow> cnj (\\<psi> x) * (if i = x then 1 else 0) = 0\n 2. \\<And>\\<psi> x.\n       \\<lbrakk>has_ell2_norm \\<psi>; x \\<in> {i} - UNIV\\<rbrakk>\n       \\<Longrightarrow> ?g45 \\<psi> x = 0\n 3. \\<And>\\<psi> x.\n       \\<lbrakk>has_ell2_norm \\<psi>; x \\<in> UNIV \\<inter> {i}\\<rbrakk>\n       \\<Longrightarrow> cnj (\\<psi> x) * (if i = x then 1 else 0) =\n                         ?g45 \\<psi> x\n 4. \\<And>\\<psi>.\n       has_ell2_norm \\<psi> \\<Longrightarrow>\n       infsetsum (?g45 \\<psi>) {i} = cnj (\\<psi> i)", "by auto"], ["", "lemma cinner_ket_eqI:\n  assumes \\<open>\\<And>i. cinner (ket i) \\<psi> = cinner (ket i) \\<phi>\\<close>\n  shows \\<open>\\<psi> = \\<phi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> = \\<phi>", "by (metis Rep_ell2_inject assms cinner_ket_left ext)"], ["", "lemma norm_ket[simp]: \"norm (ket i) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (ket i) = 1", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. ell2_norm (\\<lambda>y. if i = y then 1 else 0) = 1", "by (rule ell2_norm_ket)"], ["", "lemma cinner_ket_same[simp]:\n  \\<open>\\<langle>ket i, ket i\\<rangle> = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket i = 1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket i = 1", "have \\<open>norm (ket i) = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (ket i) = 1", "by simp"], ["proof (state)\nthis:\n  norm (ket i) = 1\n\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket i = 1", "hence \\<open>sqrt (cmod \\<langle>ket i, ket i\\<rangle>) = 1\\<close>"], ["proof (prove)\nusing this:\n  norm (ket i) = 1\n\ngoal (1 subgoal):\n 1. sqrt (cmod (ket i \\<bullet>\\<^sub>C ket i)) = 1", "by (metis norm_eq_sqrt_cinner)"], ["proof (state)\nthis:\n  sqrt (cmod (ket i \\<bullet>\\<^sub>C ket i)) = 1\n\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket i = 1", "hence \\<open>cmod \\<langle>ket i, ket i\\<rangle> = 1\\<close>"], ["proof (prove)\nusing this:\n  sqrt (cmod (ket i \\<bullet>\\<^sub>C ket i)) = 1\n\ngoal (1 subgoal):\n 1. cmod (ket i \\<bullet>\\<^sub>C ket i) = 1", "using real_sqrt_eq_1_iff"], ["proof (prove)\nusing this:\n  sqrt (cmod (ket i \\<bullet>\\<^sub>C ket i)) = 1\n  (sqrt ?x = 1) = (?x = 1)\n\ngoal (1 subgoal):\n 1. cmod (ket i \\<bullet>\\<^sub>C ket i) = 1", "by blast"], ["proof (state)\nthis:\n  cmod (ket i \\<bullet>\\<^sub>C ket i) = 1\n\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket i = 1", "moreover"], ["proof (state)\nthis:\n  cmod (ket i \\<bullet>\\<^sub>C ket i) = 1\n\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket i = 1", "have \\<open>\\<langle>ket i, ket i\\<rangle> = cmod \\<langle>ket i, ket i\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket i =\n    complex_of_real (cmod (ket i \\<bullet>\\<^sub>C ket i))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket i =\n    complex_of_real (cmod (ket i \\<bullet>\\<^sub>C ket i))", "have \\<open>\\<langle>ket i, ket i\\<rangle> \\<in> \\<real>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket i \\<in> \\<real>", "by (simp add: cinner_real)"], ["proof (state)\nthis:\n  ket i \\<bullet>\\<^sub>C ket i \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket i =\n    complex_of_real (cmod (ket i \\<bullet>\\<^sub>C ket i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ket i \\<bullet>\\<^sub>C ket i \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket i =\n    complex_of_real (cmod (ket i \\<bullet>\\<^sub>C ket i))", "by (metis cinner_ge_zero complex_of_real_cmod)"], ["proof (state)\nthis:\n  ket i \\<bullet>\\<^sub>C ket i =\n  complex_of_real (cmod (ket i \\<bullet>\\<^sub>C ket i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ket i \\<bullet>\\<^sub>C ket i =\n  complex_of_real (cmod (ket i \\<bullet>\\<^sub>C ket i))\n\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket i = 1", "ultimately"], ["proof (chain)\npicking this:\n  cmod (ket i \\<bullet>\\<^sub>C ket i) = 1\n  ket i \\<bullet>\\<^sub>C ket i =\n  complex_of_real (cmod (ket i \\<bullet>\\<^sub>C ket i))", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (ket i \\<bullet>\\<^sub>C ket i) = 1\n  ket i \\<bullet>\\<^sub>C ket i =\n  complex_of_real (cmod (ket i \\<bullet>\\<^sub>C ket i))\n\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket i = 1", "by simp"], ["proof (state)\nthis:\n  ket i \\<bullet>\\<^sub>C ket i = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orthogonal_ket[simp]:\n  \\<open>is_orthogonal (ket i) (ket j) \\<longleftrightarrow> i \\<noteq> j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal (ket i) (ket j) = (i \\<noteq> j)", "by (simp add: cinner_ket_left ket.rep_eq)"], ["", "lemma cinner_ket: \\<open>\\<langle>ket i, ket j\\<rangle> = (if i=j then 1 else 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C ket j = (if i = j then 1 else 0)", "by (simp add: cinner_ket_left ket.rep_eq)"], ["", "lemma ket_injective[simp]: \\<open>ket i = ket j \\<longleftrightarrow> i = j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ket i = ket j) = (i = j)", "by (metis cinner_ket one_neq_zero)"], ["", "lemma inj_ket[simp]: \\<open>inj ket\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ket", "by (simp add: inj_on_def)"], ["", "lemma trunc_ell2_ket_cspan:\n  \\<open>trunc_ell2 S x \\<in> (cspan (range ket))\\<close> if \\<open>finite S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. trunc_ell2 S x \\<in> cspan (range ket)", "proof (use that in induction)"], ["proof (state)\ngoal (2 subgoals):\n 1. trunc_ell2 {} x \\<in> cspan (range ket)\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        trunc_ell2 F x \\<in> cspan (range ket)\\<rbrakk>\n       \\<Longrightarrow> trunc_ell2 (insert xa F) x \\<in> cspan (range ket)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. trunc_ell2 {} x \\<in> cspan (range ket)\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        trunc_ell2 F x \\<in> cspan (range ket)\\<rbrakk>\n       \\<Longrightarrow> trunc_ell2 (insert xa F) x \\<in> cspan (range ket)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. trunc_ell2 {} x \\<in> cspan (range ket)", "by (auto intro: complex_vector.span_zero)"], ["proof (state)\nthis:\n  trunc_ell2 {} x \\<in> cspan (range ket)\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        trunc_ell2 F x \\<in> cspan (range ket)\\<rbrakk>\n       \\<Longrightarrow> trunc_ell2 (insert xa F) x \\<in> cspan (range ket)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        trunc_ell2 F x \\<in> cspan (range ket)\\<rbrakk>\n       \\<Longrightarrow> trunc_ell2 (insert xa F) x \\<in> cspan (range ket)", "case (insert a F)"], ["proof (state)\nthis:\n  finite F\n  a \\<notin> F\n  trunc_ell2 F x \\<in> cspan (range ket)\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        trunc_ell2 F x \\<in> cspan (range ket)\\<rbrakk>\n       \\<Longrightarrow> trunc_ell2 (insert xa F) x \\<in> cspan (range ket)", "from insert.hyps"], ["proof (chain)\npicking this:\n  finite F\n  a \\<notin> F", "have \\<open>trunc_ell2 (insert a F) x = trunc_ell2 F x + Rep_ell2 x a *\\<^sub>C ket a\\<close>"], ["proof (prove)\nusing this:\n  finite F\n  a \\<notin> F\n\ngoal (1 subgoal):\n 1. trunc_ell2 (insert a F) x =\n    trunc_ell2 F x + Rep_ell2 x a *\\<^sub>C ket a", "apply (transfer fixing: F a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>finite F; a \\<notin> F; has_ell2_norm x\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>i.\n                             if i \\<in> insert a F then x i else 0) =\n                         (\\<lambda>xa.\n                             (if xa \\<in> F then x xa else 0) +\n                             x a * (if a = xa then 1 else 0))", "by auto"], ["proof (state)\nthis:\n  trunc_ell2 (insert a F) x = trunc_ell2 F x + Rep_ell2 x a *\\<^sub>C ket a\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        trunc_ell2 F x \\<in> cspan (range ket)\\<rbrakk>\n       \\<Longrightarrow> trunc_ell2 (insert xa F) x \\<in> cspan (range ket)", "with insert.IH"], ["proof (chain)\npicking this:\n  trunc_ell2 F x \\<in> cspan (range ket)\n  trunc_ell2 (insert a F) x = trunc_ell2 F x + Rep_ell2 x a *\\<^sub>C ket a", "show ?case"], ["proof (prove)\nusing this:\n  trunc_ell2 F x \\<in> cspan (range ket)\n  trunc_ell2 (insert a F) x = trunc_ell2 F x + Rep_ell2 x a *\\<^sub>C ket a\n\ngoal (1 subgoal):\n 1. trunc_ell2 (insert a F) x \\<in> cspan (range ket)", "by (simp add: complex_vector.span_add_eq complex_vector.span_base complex_vector.span_scale)"], ["proof (state)\nthis:\n  trunc_ell2 (insert a F) x \\<in> cspan (range ket)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_cspan_range_ket[simp]:\n  \\<open>closure (cspan (range ket)) = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (cspan (range ket)) = UNIV", "proof (intro set_eqI iffI UNIV_I closure_approachable[THEN iffD2] allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x \\<in> UNIV; 0 < e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>cspan (range ket). dist y x < e", "fix \\<psi> :: \\<open>'a ell2\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x \\<in> UNIV; 0 < e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>cspan (range ket). dist y x < e", "fix e :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x \\<in> UNIV; 0 < e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>cspan (range ket). dist y x < e", "assume \\<open>e > 0\\<close>"], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x \\<in> UNIV; 0 < e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>cspan (range ket). dist y x < e", "have \\<open>((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>) (finite_subsets_at_top UNIV)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n     (finite_subsets_at_top UNIV)", "by (rule trunc_ell2_lim_at_UNIV)"], ["proof (state)\nthis:\n  ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x \\<in> UNIV; 0 < e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>cspan (range ket). dist y x < e", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n   (finite_subsets_at_top UNIV)", "obtain F where \\<open>finite F\\<close> and \\<open>dist (trunc_ell2 F \\<psi>) \\<psi> < e\\<close>"], ["proof (prove)\nusing this:\n  ((\\<lambda>S. trunc_ell2 S \\<psi>) \\<longlongrightarrow> \\<psi>)\n   (finite_subsets_at_top UNIV)\n\ngoal (1 subgoal):\n 1. (\\<And>F.\n        \\<lbrakk>finite F; dist (trunc_ell2 F \\<psi>) \\<psi> < e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (drule_tac tendstoD[OF _ \\<open>e > 0\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>F.\n                \\<lbrakk>finite F;\n                 dist (trunc_ell2 F \\<psi>) \\<psi> < e\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>\\<^sub>F x in finite_subsets_at_top UNIV.\n        dist (trunc_ell2 x \\<psi>) \\<psi> < e\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto dest: simp: eventually_finite_subsets_at_top)"], ["proof (state)\nthis:\n  finite F\n  dist (trunc_ell2 F \\<psi>) \\<psi> < e\n\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x \\<in> UNIV; 0 < e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>cspan (range ket). dist y x < e", "moreover"], ["proof (state)\nthis:\n  finite F\n  dist (trunc_ell2 F \\<psi>) \\<psi> < e\n\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x \\<in> UNIV; 0 < e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>cspan (range ket). dist y x < e", "have \\<open>trunc_ell2 F \\<psi> \\<in> cspan (range ket)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. trunc_ell2 F \\<psi> \\<in> cspan (range ket)", "using \\<open>finite F\\<close> trunc_ell2_ket_cspan"], ["proof (prove)\nusing this:\n  finite F\n  finite ?S \\<Longrightarrow> trunc_ell2 ?S ?x \\<in> cspan (range ket)\n\ngoal (1 subgoal):\n 1. trunc_ell2 F \\<psi> \\<in> cspan (range ket)", "by blast"], ["proof (state)\nthis:\n  trunc_ell2 F \\<psi> \\<in> cspan (range ket)\n\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>x \\<in> UNIV; 0 < e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>cspan (range ket). dist y x < e", "ultimately"], ["proof (chain)\npicking this:\n  finite F\n  dist (trunc_ell2 F \\<psi>) \\<psi> < e\n  trunc_ell2 F \\<psi> \\<in> cspan (range ket)", "show \\<open>\\<exists>\\<phi>\\<in>cspan (range ket). dist \\<phi> \\<psi> < e\\<close>"], ["proof (prove)\nusing this:\n  finite F\n  dist (trunc_ell2 F \\<psi>) \\<psi> < e\n  trunc_ell2 F \\<psi> \\<in> cspan (range ket)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>\\<in>cspan (range ket). dist \\<phi> \\<psi> < e", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<phi>\\<in>cspan (range ket). dist \\<phi> \\<psi> < e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccspan_range_ket[simp]: \"ccspan (range ket) = (top::('a ell2 ccsubspace))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan (range ket) = \\<top>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ccspan (range ket) = \\<top>", "have \\<open>closure (complex_vector.span (range ket)) = (UNIV::'a ell2 set)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (cspan (range ket)) = UNIV", "using Complex_L2.closed_cspan_range_ket"], ["proof (prove)\nusing this:\n  closure (cspan (range ket)) = UNIV\n\ngoal (1 subgoal):\n 1. closure (cspan (range ket)) = UNIV", "by blast"], ["proof (state)\nthis:\n  closure (cspan (range ket)) = UNIV\n\ngoal (1 subgoal):\n 1. ccspan (range ket) = \\<top>", "thus ?thesis"], ["proof (prove)\nusing this:\n  closure (cspan (range ket)) = UNIV\n\ngoal (1 subgoal):\n 1. ccspan (range ket) = \\<top>", "by (simp add: ccspan.abs_eq top_ccsubspace.abs_eq)"], ["proof (state)\nthis:\n  ccspan (range ket) = \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cspan_range_ket_finite[simp]: \"cspan (range ket :: 'a::finite ell2 set) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (range ket) = UNIV", "by (metis closed_cspan_range_ket closure_finite_cspan finite_class.finite_UNIV finite_imageI)"], ["", "instance ell2 :: (finite) cfinite_dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ell2, cfinite_dim_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "define basis :: \\<open>'a ell2 set\\<close> where \\<open>basis = range ket\\<close>"], ["proof (state)\nthis:\n  basis = range ket\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "have \\<open>finite basis\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite basis", "unfolding basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (range ket)", "by simp"], ["proof (state)\nthis:\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "moreover"], ["proof (state)\nthis:\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "have \\<open>cspan basis = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "by (simp add: basis_def)"], ["proof (state)\nthis:\n  cspan basis = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "ultimately"], ["proof (chain)\npicking this:\n  finite basis\n  cspan basis = UNIV", "show \\<open>\\<exists>basis::'a ell2 set. finite basis \\<and> cspan basis = UNIV\\<close>"], ["proof (prove)\nusing this:\n  finite basis\n  cspan basis = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>basis. finite basis \\<and> cspan basis = UNIV", "by auto"], ["proof (state)\nthis:\n  \\<exists>basis. finite basis \\<and> cspan basis = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation ell2 :: (enum) onb_enum begin"], ["", "definition \"canonical_basis_ell2 = map ket Enum.enum\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ell2, onb_enum_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. distinct canonical_basis\n 2. cindependent (set canonical_basis)\n 3. cspan (set canonical_basis) = UNIV\n 4. is_ortho_set (set canonical_basis)\n 5. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1", "show \"distinct (canonical_basis::'a ell2 list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct canonical_basis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct canonical_basis", "have \\<open>finite (UNIV::'a set)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "by simp"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. distinct canonical_basis", "have \\<open>distinct (enum_class.enum::'a list)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct enum_class.enum", "using enum_distinct"], ["proof (prove)\nusing this:\n  distinct enum_class.enum\n\ngoal (1 subgoal):\n 1. distinct enum_class.enum", "by blast"], ["proof (state)\nthis:\n  distinct enum_class.enum\n\ngoal (1 subgoal):\n 1. distinct canonical_basis", "moreover"], ["proof (state)\nthis:\n  distinct enum_class.enum\n\ngoal (1 subgoal):\n 1. distinct canonical_basis", "have \\<open>inj_on ket (set enum_class.enum)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ket (set enum_class.enum)", "by (meson inj_onI ket_injective)"], ["proof (state)\nthis:\n  inj_on ket (set enum_class.enum)\n\ngoal (1 subgoal):\n 1. distinct canonical_basis", "ultimately"], ["proof (chain)\npicking this:\n  distinct enum_class.enum\n  inj_on ket (set enum_class.enum)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct enum_class.enum\n  inj_on ket (set enum_class.enum)\n\ngoal (1 subgoal):\n 1. distinct canonical_basis", "unfolding canonical_basis_ell2_def"], ["proof (prove)\nusing this:\n  distinct enum_class.enum\n  inj_on ket (set enum_class.enum)\n\ngoal (1 subgoal):\n 1. distinct (map ket enum_class.enum)", "using distinct_map"], ["proof (prove)\nusing this:\n  distinct enum_class.enum\n  inj_on ket (set enum_class.enum)\n  distinct (map ?f ?xs) = (distinct ?xs \\<and> inj_on ?f (set ?xs))\n\ngoal (1 subgoal):\n 1. distinct (map ket enum_class.enum)", "by blast"], ["proof (state)\nthis:\n  distinct canonical_basis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct canonical_basis\n\ngoal (4 subgoals):\n 1. cindependent (set canonical_basis)\n 2. cspan (set canonical_basis) = UNIV\n 3. is_ortho_set (set canonical_basis)\n 4. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1", "show \"is_ortho_set (set (canonical_basis::'a ell2 list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ortho_set (set canonical_basis)", "apply (auto simp: canonical_basis_ell2_def enum_UNIV)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ortho_set (range ket)", "by (smt (z3) norm_ket f_inv_into_f is_ortho_set_def orthogonal_ket norm_zero)"], ["proof (state)\nthis:\n  is_ortho_set (set canonical_basis)\n\ngoal (3 subgoals):\n 1. cindependent (set canonical_basis)\n 2. cspan (set canonical_basis) = UNIV\n 3. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1", "show \"cindependent (set (canonical_basis::'a ell2 list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent (set canonical_basis)", "apply (auto simp: canonical_basis_ell2_def enum_UNIV)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cdependent (range ket) \\<Longrightarrow> False", "by (smt (verit, best) norm_ket f_inv_into_f is_ortho_set_def is_ortho_set_cindependent orthogonal_ket norm_zero)"], ["proof (state)\nthis:\n  cindependent (set canonical_basis)\n\ngoal (2 subgoals):\n 1. cspan (set canonical_basis) = UNIV\n 2. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1", "show \"cspan (set (canonical_basis::'a ell2 list)) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (set canonical_basis) = UNIV", "by (auto simp: canonical_basis_ell2_def enum_UNIV)"], ["proof (state)\nthis:\n  cspan (set canonical_basis) = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1", "show \"norm (x::'a ell2) = 1\"\n    if \"(x::'a ell2) \\<in> set canonical_basis\"\n    for x :: \"'a ell2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x = 1", "using that"], ["proof (prove)\nusing this:\n  x \\<in> set canonical_basis\n\ngoal (1 subgoal):\n 1. norm x = 1", "unfolding canonical_basis_ell2_def"], ["proof (prove)\nusing this:\n  x \\<in> set (map ket enum_class.enum)\n\ngoal (1 subgoal):\n 1. norm x = 1", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> set canonical_basis \\<Longrightarrow> norm ?x = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma canonical_basis_length_ell2[code_unfold, simp]:\n  \"length (canonical_basis ::'a::enum ell2 list) = CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length canonical_basis = CARD('a)", "unfolding canonical_basis_ell2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map ket enum_class.enum) = CARD('a)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. length enum_class.enum = CARD('a)", "using card_UNIV_length_enum"], ["proof (prove)\nusing this:\n  CARD(?'a) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. length enum_class.enum = CARD('a)", "by metis"], ["", "lemma ket_canonical_basis: \"ket x = canonical_basis ! enum_idx x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket x = canonical_basis ! enum_idx x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ket x = canonical_basis ! enum_idx x", "have \"x = (enum_class.enum::'a list) ! enum_idx x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = enum_class.enum ! enum_idx x", "using enum_idx_correct[where i = x]"], ["proof (prove)\nusing this:\n  enum_class.enum ! enum_idx x = x\n\ngoal (1 subgoal):\n 1. x = enum_class.enum ! enum_idx x", "by simp"], ["proof (state)\nthis:\n  x = enum_class.enum ! enum_idx x\n\ngoal (1 subgoal):\n 1. ket x = canonical_basis ! enum_idx x", "hence p1: \"ket x = ket ((enum_class.enum::'a list) ! enum_idx x)\""], ["proof (prove)\nusing this:\n  x = enum_class.enum ! enum_idx x\n\ngoal (1 subgoal):\n 1. ket x = ket (enum_class.enum ! enum_idx x)", "by simp"], ["proof (state)\nthis:\n  ket x = ket (enum_class.enum ! enum_idx x)\n\ngoal (1 subgoal):\n 1. ket x = canonical_basis ! enum_idx x", "have \"enum_idx x < length (enum_class.enum::'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_idx x < length enum_class.enum", "using enum_idx_bound[where x = x]"], ["proof (prove)\nusing this:\n  enum_idx x < length enum_class.enum\n\ngoal (1 subgoal):\n 1. enum_idx x < length enum_class.enum", "."], ["proof (state)\nthis:\n  enum_idx x < length enum_class.enum\n\ngoal (1 subgoal):\n 1. ket x = canonical_basis ! enum_idx x", "hence \"(map ket (enum_class.enum::'a list)) ! enum_idx x \n        = ket ((enum_class.enum::'a list) ! enum_idx x)\""], ["proof (prove)\nusing this:\n  enum_idx x < length enum_class.enum\n\ngoal (1 subgoal):\n 1. map ket enum_class.enum ! enum_idx x =\n    ket (enum_class.enum ! enum_idx x)", "by auto"], ["proof (state)\nthis:\n  map ket enum_class.enum ! enum_idx x = ket (enum_class.enum ! enum_idx x)\n\ngoal (1 subgoal):\n 1. ket x = canonical_basis ! enum_idx x", "thus ?thesis"], ["proof (prove)\nusing this:\n  map ket enum_class.enum ! enum_idx x = ket (enum_class.enum ! enum_idx x)\n\ngoal (1 subgoal):\n 1. ket x = canonical_basis ! enum_idx x", "unfolding canonical_basis_ell2_def"], ["proof (prove)\nusing this:\n  map ket enum_class.enum ! enum_idx x = ket (enum_class.enum ! enum_idx x)\n\ngoal (1 subgoal):\n 1. ket x = map ket enum_class.enum ! enum_idx x", "using p1"], ["proof (prove)\nusing this:\n  map ket enum_class.enum ! enum_idx x = ket (enum_class.enum ! enum_idx x)\n  ket x = ket (enum_class.enum ! enum_idx x)\n\ngoal (1 subgoal):\n 1. ket x = map ket enum_class.enum ! enum_idx x", "by auto"], ["proof (state)\nthis:\n  ket x = canonical_basis ! enum_idx x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma clinear_equal_ket:\n  fixes f g :: \\<open>'a::finite ell2 \\<Rightarrow> _\\<close>\n  assumes \\<open>clinear f\\<close>\n  assumes \\<open>clinear g\\<close>\n  assumes \\<open>\\<And>i. f (ket i) = g (ket i)\\<close>\n  shows \\<open>f = g\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. f x = g x", "apply (rule complex_vector.linear_eq_on_span[where f=f and g=g and B=\\<open>range ket\\<close>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. clinear f\n 2. \\<And>x. clinear g\n 3. \\<And>x xa. xa \\<in> range ket \\<Longrightarrow> f xa = g xa\n 4. \\<And>x. x \\<in> cspan (range ket)", "using assms"], ["proof (prove)\nusing this:\n  clinear f\n  clinear g\n  f (ket ?i) = g (ket ?i)\n\ngoal (4 subgoals):\n 1. \\<And>x. clinear f\n 2. \\<And>x. clinear g\n 3. \\<And>x xa. xa \\<in> range ket \\<Longrightarrow> f xa = g xa\n 4. \\<And>x. x \\<in> cspan (range ket)", "by auto"], ["", "lemma equal_ket:\n  fixes A B :: \\<open>('a ell2, 'b::complex_normed_vector) cblinfun\\<close>\n  assumes \\<open>\\<And> x. cblinfun_apply A (ket x) = cblinfun_apply B (ket x)\\<close>\n  shows \\<open>A = B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "apply (rule cblinfun_eq_gen_eqI[where G=\\<open>range ket\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> range ket \\<Longrightarrow> A *\\<^sub>V x = B *\\<^sub>V x\n 2. ccspan (range ket) = \\<top>", "using assms"], ["proof (prove)\nusing this:\n  A *\\<^sub>V ket ?x = B *\\<^sub>V ket ?x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> range ket \\<Longrightarrow> A *\\<^sub>V x = B *\\<^sub>V x\n 2. ccspan (range ket) = \\<top>", "by auto"], ["", "lemma antilinear_equal_ket:\n  fixes f g :: \\<open>'a::finite ell2 \\<Rightarrow> _\\<close>\n  assumes \\<open>antilinear f\\<close>\n  assumes \\<open>antilinear g\\<close>\n  assumes \\<open>\\<And>i. f (ket i) = g (ket i)\\<close>\n  shows \\<open>f = g\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f = g", "have [simp]: \\<open>clinear (f \\<circ> from_conjugate_space)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear (f \\<circ> from_conjugate_space)", "apply (rule antilinear_o_antilinear)"], ["proof (prove)\ngoal (2 subgoals):\n 1. antilinear from_conjugate_space\n 2. antilinear f", "using assms"], ["proof (prove)\nusing this:\n  antilinear f\n  antilinear g\n  f (ket ?i) = g (ket ?i)\n\ngoal (2 subgoals):\n 1. antilinear from_conjugate_space\n 2. antilinear f", "by (simp_all add: antilinear_from_conjugate_space)"], ["proof (state)\nthis:\n  clinear (f \\<circ> from_conjugate_space)\n\ngoal (1 subgoal):\n 1. f = g", "have [simp]: \\<open>clinear (g \\<circ> from_conjugate_space)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear (g \\<circ> from_conjugate_space)", "apply (rule antilinear_o_antilinear)"], ["proof (prove)\ngoal (2 subgoals):\n 1. antilinear from_conjugate_space\n 2. antilinear g", "using assms"], ["proof (prove)\nusing this:\n  antilinear f\n  antilinear g\n  f (ket ?i) = g (ket ?i)\n\ngoal (2 subgoals):\n 1. antilinear from_conjugate_space\n 2. antilinear g", "by (simp_all add: antilinear_from_conjugate_space)"], ["proof (state)\nthis:\n  clinear (g \\<circ> from_conjugate_space)\n\ngoal (1 subgoal):\n 1. f = g", "have [simp]: \\<open>cspan (to_conjugate_space ` (range ket :: 'a ell2 set)) = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (to_conjugate_space ` range ket) = UNIV", "by simp"], ["proof (state)\nthis:\n  cspan (to_conjugate_space ` range ket) = UNIV\n\ngoal (1 subgoal):\n 1. f = g", "have \"f o from_conjugate_space = g o from_conjugate_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> from_conjugate_space = g \\<circ> from_conjugate_space", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (f \\<circ> from_conjugate_space) x =\n       (g \\<circ> from_conjugate_space) x", "apply (rule complex_vector.linear_eq_on_span[where f=\"f o from_conjugate_space\" and g=\"g o from_conjugate_space\" and B=\\<open>to_conjugate_space ` range ket\\<close>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. clinear (f \\<circ> from_conjugate_space)\n 2. \\<And>x. clinear (g \\<circ> from_conjugate_space)\n 3. \\<And>x xa.\n       xa \\<in> to_conjugate_space ` range ket \\<Longrightarrow>\n       (f \\<circ> from_conjugate_space) xa =\n       (g \\<circ> from_conjugate_space) xa\n 4. \\<And>x. x \\<in> cspan (to_conjugate_space ` range ket)", "apply (simp, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> to_conjugate_space ` range ket \\<Longrightarrow>\n       (f \\<circ> from_conjugate_space) xa =\n       (g \\<circ> from_conjugate_space) xa\n 2. \\<And>x. x \\<in> cspan (to_conjugate_space ` range ket)", "using assms(3)"], ["proof (prove)\nusing this:\n  f (ket ?i) = g (ket ?i)\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa \\<in> to_conjugate_space ` range ket \\<Longrightarrow>\n       (f \\<circ> from_conjugate_space) xa =\n       (g \\<circ> from_conjugate_space) xa\n 2. \\<And>x. x \\<in> cspan (to_conjugate_space ` range ket)", "by (auto simp: to_conjugate_space_inverse)"], ["proof (state)\nthis:\n  f \\<circ> from_conjugate_space = g \\<circ> from_conjugate_space\n\ngoal (1 subgoal):\n 1. f = g", "then"], ["proof (chain)\npicking this:\n  f \\<circ> from_conjugate_space = g \\<circ> from_conjugate_space", "show \"f = g\""], ["proof (prove)\nusing this:\n  f \\<circ> from_conjugate_space = g \\<circ> from_conjugate_space\n\ngoal (1 subgoal):\n 1. f = g", "by (smt (verit) UNIV_I from_conjugate_space_inverse surj_def surj_fun_eq to_conjugate_space_inject)"], ["proof (state)\nthis:\n  f = g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cinner_ket_adjointI:\n  fixes F::\"'a ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L _\" and G::\"'b ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L_\"\n  assumes \"\\<And> i j. \\<langle>F *\\<^sub>V ket i, ket j\\<rangle> = \\<langle>ket i, G *\\<^sub>V ket j\\<rangle>\"\n  shows \"F = G*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = G*", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. F = G*", "from assms"], ["proof (chain)\npicking this:\n  (F *\\<^sub>V ket ?i) \\<bullet>\\<^sub>C ket ?j =\n  ket ?i \\<bullet>\\<^sub>C (G *\\<^sub>V ket ?j)", "have \\<open>(F *\\<^sub>V x) \\<bullet>\\<^sub>C y = x \\<bullet>\\<^sub>C (G *\\<^sub>V y)\\<close> if \\<open>x \\<in> range ket\\<close> and \\<open>y \\<in> range ket\\<close> for x y"], ["proof (prove)\nusing this:\n  (F *\\<^sub>V ket ?i) \\<bullet>\\<^sub>C ket ?j =\n  ket ?i \\<bullet>\\<^sub>C (G *\\<^sub>V ket ?j)\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (G *\\<^sub>V y)", "using that"], ["proof (prove)\nusing this:\n  (F *\\<^sub>V ket ?i) \\<bullet>\\<^sub>C ket ?j =\n  ket ?i \\<bullet>\\<^sub>C (G *\\<^sub>V ket ?j)\n  x \\<in> range ket\n  y \\<in> range ket\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (G *\\<^sub>V y)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> range ket; ?y \\<in> range ket\\<rbrakk>\n  \\<Longrightarrow> (F *\\<^sub>V ?x) \\<bullet>\\<^sub>C ?y =\n                    ?x \\<bullet>\\<^sub>C (G *\\<^sub>V ?y)\n\ngoal (1 subgoal):\n 1. F = G*", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> range ket; ?y \\<in> range ket\\<rbrakk>\n  \\<Longrightarrow> (F *\\<^sub>V ?x) \\<bullet>\\<^sub>C ?y =\n                    ?x \\<bullet>\\<^sub>C (G *\\<^sub>V ?y)", "have \\<open>(F *\\<^sub>V x) \\<bullet>\\<^sub>C y = x \\<bullet>\\<^sub>C (G *\\<^sub>V y)\\<close> if \\<open>x \\<in> range ket\\<close> for x y"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> range ket; ?y \\<in> range ket\\<rbrakk>\n  \\<Longrightarrow> (F *\\<^sub>V ?x) \\<bullet>\\<^sub>C ?y =\n                    ?x \\<bullet>\\<^sub>C (G *\\<^sub>V ?y)\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (G *\\<^sub>V y)", "apply (rule bounded_clinear_eq_on[where G=\\<open>range ket\\<close> and t=y, rotated 2])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xa. xa \\<in> range ket \\<Longrightarrow> x \\<in> range ket\n 2. \\<And>x. x \\<in> range ket \\<Longrightarrow> x \\<in> range ket\n 3. y \\<in> closure (cspan (range ket))\n 4. bounded_clinear ((\\<bullet>\\<^sub>C) (F *\\<^sub>V x))\n 5. bounded_clinear (\\<lambda>xa. x \\<bullet>\\<^sub>C (G *\\<^sub>V xa))", "using that"], ["proof (prove)\nusing this:\n  x \\<in> range ket\n\ngoal (5 subgoals):\n 1. \\<And>xa. xa \\<in> range ket \\<Longrightarrow> x \\<in> range ket\n 2. \\<And>x. x \\<in> range ket \\<Longrightarrow> x \\<in> range ket\n 3. y \\<in> closure (cspan (range ket))\n 4. bounded_clinear ((\\<bullet>\\<^sub>C) (F *\\<^sub>V x))\n 5. bounded_clinear (\\<lambda>xa. x \\<bullet>\\<^sub>C (G *\\<^sub>V xa))", "by (auto intro!: bounded_linear_intros)"], ["proof (state)\nthis:\n  ?x \\<in> range ket \\<Longrightarrow>\n  (F *\\<^sub>V ?x) \\<bullet>\\<^sub>C ?y =\n  ?x \\<bullet>\\<^sub>C (G *\\<^sub>V ?y)\n\ngoal (1 subgoal):\n 1. F = G*", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> range ket \\<Longrightarrow>\n  (F *\\<^sub>V ?x) \\<bullet>\\<^sub>C ?y =\n  ?x \\<bullet>\\<^sub>C (G *\\<^sub>V ?y)", "have \\<open>(F *\\<^sub>V x) \\<bullet>\\<^sub>C y = x \\<bullet>\\<^sub>C (G *\\<^sub>V y)\\<close> for x y"], ["proof (prove)\nusing this:\n  ?x \\<in> range ket \\<Longrightarrow>\n  (F *\\<^sub>V ?x) \\<bullet>\\<^sub>C ?y =\n  ?x \\<bullet>\\<^sub>C (G *\\<^sub>V ?y)\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (G *\\<^sub>V y)", "apply (rule bounded_antilinear_eq_on[where G=\\<open>range ket\\<close> and t=x, rotated 2])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> range ket \\<Longrightarrow> x \\<in> range ket\n 2. x \\<in> closure (cspan (range ket))\n 3. bounded_antilinear (\\<lambda>x. (F *\\<^sub>V x) \\<bullet>\\<^sub>C y)\n 4. bounded_antilinear (\\<lambda>x. x \\<bullet>\\<^sub>C (G *\\<^sub>V y))", "by (auto intro!: bounded_linear_intros)"], ["proof (state)\nthis:\n  (F *\\<^sub>V ?x) \\<bullet>\\<^sub>C ?y =\n  ?x \\<bullet>\\<^sub>C (G *\\<^sub>V ?y)\n\ngoal (1 subgoal):\n 1. F = G*", "then"], ["proof (chain)\npicking this:\n  (F *\\<^sub>V ?x) \\<bullet>\\<^sub>C ?y =\n  ?x \\<bullet>\\<^sub>C (G *\\<^sub>V ?y)", "show ?thesis"], ["proof (prove)\nusing this:\n  (F *\\<^sub>V ?x) \\<bullet>\\<^sub>C ?y =\n  ?x \\<bullet>\\<^sub>C (G *\\<^sub>V ?y)\n\ngoal (1 subgoal):\n 1. F = G*", "by (rule adjoint_eqI)"], ["proof (state)\nthis:\n  F = G*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ket_nonzero[simp]: \"ket i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket i \\<noteq> 0", "using norm_ket[of i]"], ["proof (prove)\nusing this:\n  norm (ket i) = 1\n\ngoal (1 subgoal):\n 1. ket i \\<noteq> 0", "by force"], ["", "lemma cindependent_ket:\n  \"cindependent (range (ket::'a\\<Rightarrow>_))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent (range ket)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cindependent (range ket)", "define S where \"S = range (ket::'a\\<Rightarrow>_)\""], ["proof (state)\nthis:\n  S = range ket\n\ngoal (1 subgoal):\n 1. cindependent (range ket)", "have \"is_ortho_set S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ortho_set S", "unfolding S_def is_ortho_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>range ket.\n        \\<forall>y\\<in>range ket.\n           x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n    0 \\<notin> range ket", "by auto"], ["proof (state)\nthis:\n  is_ortho_set S\n\ngoal (1 subgoal):\n 1. cindependent (range ket)", "moreover"], ["proof (state)\nthis:\n  is_ortho_set S\n\ngoal (1 subgoal):\n 1. cindependent (range ket)", "have \"0 \\<notin> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> S", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> range ket", "using ket_nonzero"], ["proof (prove)\nusing this:\n  ket ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<notin> range ket", "by (simp add: image_iff)"], ["proof (state)\nthis:\n  0 \\<notin> S\n\ngoal (1 subgoal):\n 1. cindependent (range ket)", "ultimately"], ["proof (chain)\npicking this:\n  is_ortho_set S\n  0 \\<notin> S", "show ?thesis"], ["proof (prove)\nusing this:\n  is_ortho_set S\n  0 \\<notin> S\n\ngoal (1 subgoal):\n 1. cindependent (range ket)", "using is_ortho_set_cindependent[where A = S]"], ["proof (prove)\nusing this:\n  is_ortho_set S\n  0 \\<notin> S\n  is_ortho_set S \\<Longrightarrow> cindependent S\n\ngoal (1 subgoal):\n 1. cindependent (range ket)", "unfolding S_def"], ["proof (prove)\nusing this:\n  is_ortho_set (range ket)\n  0 \\<notin> range ket\n  is_ortho_set (range ket) \\<Longrightarrow> cindependent (range ket)\n\ngoal (1 subgoal):\n 1. cindependent (range ket)", "by blast"], ["proof (state)\nthis:\n  cindependent (range ket)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cdim_UNIV_ell2[simp]: \\<open>cdim (UNIV::'a::finite ell2 set) = CARD('a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cdim UNIV = CARD('a)", "apply (subst cspan_range_ket_finite[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cdim (cspan (range ket)) = CARD('a)", "by (metis card_image cindependent_ket complex_vector.dim_span_eq_card_independent inj_ket)"], ["", "lemma is_ortho_set_ket[simp]: \\<open>is_ortho_set (range ket)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ortho_set (range ket)", "using is_ortho_set_def"], ["proof (prove)\nusing this:\n  is_ortho_set ?S =\n  ((\\<forall>x\\<in>?S.\n       \\<forall>y\\<in>?S.\n          x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n   (0::?'a) \\<notin> ?S)\n\ngoal (1 subgoal):\n 1. is_ortho_set (range ket)", "by fastforce"], ["", "subsection \\<open>Butterflies\\<close>"], ["", "lemma cspan_butterfly_ket: \\<open>cspan {butterfly (ket i) (ket j)| (i::'b::finite) (j::'a::finite). True} = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan {butterfly (ket i) (ket j) |i j. True} = UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cspan {butterfly (ket i) (ket j) |i j. True} = UNIV", "have *: \\<open>{butterfly (ket i) (ket j)| (i::'b::finite) (j::'a::finite). True} = {butterfly a b |a b. a \\<in> range ket \\<and> b \\<in> range ket}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {butterfly (ket i) (ket j) |i j. True} =\n    {butterfly a b |a b. a \\<in> range ket \\<and> b \\<in> range ket}", "by auto"], ["proof (state)\nthis:\n  {butterfly (ket i) (ket j) |i j. True} =\n  {butterfly a b |a b. a \\<in> range ket \\<and> b \\<in> range ket}\n\ngoal (1 subgoal):\n 1. cspan {butterfly (ket i) (ket j) |i j. True} = UNIV", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan {butterfly (ket i) (ket j) |i j. True} = UNIV", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan {butterfly a b |a b. a \\<in> range ket \\<and> b \\<in> range ket} =\n    UNIV", "apply (rule cspan_butterfly_UNIV)"], ["proof (prove)\ngoal (4 subgoals):\n 1. cspan (range ket) = UNIV\n 2. cspan (range ket) = UNIV\n 3. is_ortho_set (range ket)\n 4. \\<And>b. b \\<in> range ket \\<Longrightarrow> norm b = 1", "by auto"], ["proof (state)\nthis:\n  cspan {butterfly (ket i) (ket j) |i j. True} = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindependent_butterfly_ket: \\<open>cindependent {butterfly (ket i) (ket j)| (i::'b) (j::'a). True}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent {butterfly (ket i) (ket j) |i j. True}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cindependent {butterfly (ket i) (ket j) |i j. True}", "have *: \\<open>{butterfly (ket i) (ket j)| (i::'b) (j::'a). True} = {butterfly a b |a b. a \\<in> range ket \\<and> b \\<in> range ket}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {butterfly (ket i) (ket j) |i j. True} =\n    {butterfly a b |a b. a \\<in> range ket \\<and> b \\<in> range ket}", "by auto"], ["proof (state)\nthis:\n  {butterfly (ket i) (ket j) |i j. True} =\n  {butterfly a b |a b. a \\<in> range ket \\<and> b \\<in> range ket}\n\ngoal (1 subgoal):\n 1. cindependent {butterfly (ket i) (ket j) |i j. True}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent {butterfly (ket i) (ket j) |i j. True}", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent\n     {butterfly a b |a b. a \\<in> range ket \\<and> b \\<in> range ket}", "apply (rule cindependent_butterfly)"], ["proof (prove)\ngoal (4 subgoals):\n 1. is_ortho_set (range ket)\n 2. is_ortho_set (range ket)\n 3. \\<And>a. a \\<in> range ket \\<Longrightarrow> norm a = 1\n 4. \\<And>b. b \\<in> range ket \\<Longrightarrow> norm b = 1", "by auto"], ["proof (state)\nthis:\n  cindependent {butterfly (ket i) (ket j) |i j. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma clinear_eq_butterfly_ketI:\n  fixes F G :: \\<open>('a::finite ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::finite ell2) \\<Rightarrow> 'c::complex_vector\\<close>\n  assumes \"clinear F\" and \"clinear G\"\n  assumes \"\\<And>i j. F (butterfly (ket i) (ket j)) = G (butterfly (ket i) (ket j))\"\n  shows \"F = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = G", "apply (rule complex_vector.linear_eq_on_span[where f=F, THEN ext, rotated 3])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> cspan (?B1 x)\n 2. \\<And>x. clinear F\n 3. \\<And>x. clinear G\n 4. \\<And>x xa. xa \\<in> ?B1 x \\<Longrightarrow> F xa = G xa", "apply (subst cspan_butterfly_ket)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> UNIV\n 2. \\<And>x. clinear F\n 3. \\<And>x. clinear G\n 4. \\<And>x xa.\n       xa \\<in> {butterfly (ket i) (ket j) |i j. True} \\<Longrightarrow>\n       F xa = G xa", "using assms"], ["proof (prove)\nusing this:\n  clinear F\n  clinear G\n  F (butterfly (ket ?i) (ket ?j)) = G (butterfly (ket ?i) (ket ?j))\n\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> UNIV\n 2. \\<And>x. clinear F\n 3. \\<And>x. clinear G\n 4. \\<And>x xa.\n       xa \\<in> {butterfly (ket i) (ket j) |i j. True} \\<Longrightarrow>\n       F xa = G xa", "by auto"], ["", "lemma sum_butterfly_ket[simp]: \\<open>(\\<Sum>(i::'a::finite)\\<in>UNIV. butterfly (ket i) (ket i)) = id_cblinfun\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. selfbutter (ket i)) = id_cblinfun", "apply (rule equal_ket)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Sum>i\\<in>UNIV. selfbutter (ket i)) *\\<^sub>V ket x =\n       id_cblinfun *\\<^sub>V ket x", "apply (subst complex_vector.linear_sum[where f=\\<open>\\<lambda>y. y *\\<^sub>V ket _\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. clinear (\\<lambda>y. y *\\<^sub>V ket x)\n 2. \\<And>x.\n       (\\<Sum>a\\<in>UNIV. selfbutter (ket a) *\\<^sub>V ket x) =\n       id_cblinfun *\\<^sub>V ket x", "apply (auto simp add: scaleC_cblinfun.rep_eq cblinfun.add_left clinearI butterfly_def cblinfun_compose_image cinner_ket)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Sum>a\\<in>UNIV. (if a = x then 1 else 0) *\\<^sub>C ket a) = ket x", "apply (subst sum.mono_neutral_cong_right[where S=\\<open>{_}\\<close>])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. finite UNIV\n 2. \\<And>x. {?uu7 x} \\<subseteq> UNIV\n 3. \\<And>x.\n       \\<forall>i\\<in>UNIV - {?uu7 x}.\n          (if i = x then 1 else 0) *\\<^sub>C ket i = 0\n 4. \\<And>x xa.\n       xa \\<in> {?uu7 x} \\<Longrightarrow>\n       (if xa = x then 1 else 0) *\\<^sub>C ket xa = ?h7 x xa\n 5. \\<And>x. sum (?h7 x) {?uu7 x} = ket x", "by auto"], ["", "subsection \\<open>One-dimensional spaces\\<close>"], ["", "instantiation ell2 :: (\"{enum,CARD_1}\") one_dim begin"], ["", "text \\<open>Note: enum is not needed logically, but without it this instantiation\n            clashes with \\<open>instantiation ell2 :: (enum) onb_enum\\<close>\\<close>"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ell2, one_dim_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. canonical_basis = [1]\n 2. \\<And>a b. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1\n 3. \\<And>x y. x / y = x * inverse y\n 4. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "show \"canonical_basis = [1::'a ell2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canonical_basis = [1]", "unfolding canonical_basis_ell2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ket enum_class.enum = [1]", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x y. if x = y then 1 else 0) enum_class.enum =\n    [\\<lambda>_. 1]", "by (simp add: enum_CARD_1[of undefined])"], ["proof (state)\nthis:\n  canonical_basis = [1]\n\ngoal (3 subgoals):\n 1. \\<And>a b. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1\n 2. \\<And>x y. x / y = x * inverse y\n 3. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "show \"a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C (1::'a ell2)\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1", "apply (transfer fixing: a b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. a * 1 * (b * 1)) = (\\<lambda>x. a * b * 1)", "by simp"], ["proof (state)\nthis:\n  ?a *\\<^sub>C 1 * ?b *\\<^sub>C 1 = (?a * ?b) *\\<^sub>C 1\n\ngoal (2 subgoals):\n 1. \\<And>x y. x / y = x * inverse y\n 2. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "show \"x / y = x * inverse y\" for x y :: \"'a ell2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x / y = x * inverse y", "by (simp add: divide_inverse)"], ["proof (state)\nthis:\n  ?x / ?y = ?x * inverse ?y\n\ngoal (1 subgoal):\n 1. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "show \"inverse (c *\\<^sub>C 1) = inverse c *\\<^sub>C (1::'a ell2)\" for c :: complex"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (c *\\<^sub>C 1) = 1 /\\<^sub>C c", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. (\\<lambda>x. inverse (c * 1)) = (\\<lambda>x. inverse c * 1)", "by auto"], ["proof (state)\nthis:\n  inverse (?c *\\<^sub>C 1) = 1 /\\<^sub>C ?c\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Classical operators\\<close>"], ["", "text \\<open>We call an operator mapping \\<^term>\\<open>ket x\\<close> to \\<^term>\\<open>ket (\\<pi> x)\\<close> or \\<^term>\\<open>0\\<close> \"classical\".\n(The meaning is inspired by the fact that in quantum mechanics, such operators usually correspond\nto operations with classical interpretation (such as Pauli-X, CNOT, measurement in the computational\nbasis, etc.))\\<close>"], ["", "definition classical_operator :: \"('a\\<Rightarrow>'b option) \\<Rightarrow> 'a ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L'b ell2\" where\n  \"classical_operator \\<pi> = \n    (let f = (\\<lambda>t. (case \\<pi> (inv (ket::'a\\<Rightarrow>_) t) \n                           of None \\<Rightarrow> (0::'b ell2) \n                          | Some i \\<Rightarrow> ket i))\n     in\n      cblinfun_extension (range (ket::'a\\<Rightarrow>_)) f)\""], ["", "definition \"classical_operator_exists \\<pi> \\<longleftrightarrow>\n  cblinfun_extension_exists (range ket)\n    (\\<lambda>t. case \\<pi> (inv ket t) of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)\""], ["", "lemma classical_operator_existsI:\n  assumes \"\\<And>x. B *\\<^sub>V (ket x) = (case \\<pi> x of Some i \\<Rightarrow> ket i | None \\<Rightarrow> 0)\"\n  shows \"classical_operator_exists \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "unfolding classical_operator_exists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_extension_exists (range ket)\n     (\\<lambda>t.\n         case \\<pi> (inv ket t) of None \\<Rightarrow> 0\n         | Some x \\<Rightarrow> ket x)", "apply (rule cblinfun_extension_existsI[of _ B])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range ket \\<Longrightarrow>\n       B *\\<^sub>V x =\n       (case \\<pi> (inv ket x) of None \\<Rightarrow> 0\n        | Some x \\<Rightarrow> ket x)", "using assms"], ["proof (prove)\nusing this:\n  B *\\<^sub>V ket ?x =\n  (case \\<pi> ?x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range ket \\<Longrightarrow>\n       B *\\<^sub>V x =\n       (case \\<pi> (inv ket x) of None \\<Rightarrow> 0\n        | Some x \\<Rightarrow> ket x)", "by (auto simp: inv_f_f[OF inj_ket])"], ["", "lemma classical_operator_exists_inj:\n  assumes \"inj_map \\<pi>\"\n  shows \"classical_operator_exists \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "(* Probably a shorter proof is possible using cblinfun_extension_exists_bounded_dense *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "define C0 where \"C0 \\<psi> = (\\<lambda>b. case inv_map \\<pi> b of None \\<Rightarrow> 0 | Some x \\<Rightarrow> \\<psi> x)\" for \\<psi> :: \"'a\\<Rightarrow>complex\""], ["proof (state)\nthis:\n  C0 ?\\<psi> =\n  (\\<lambda>b.\n      case inv_map \\<pi> b of None \\<Rightarrow> 0\n      | Some x \\<Rightarrow> ?\\<psi> x)\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "have has_ell2_norm_C0: \\<open>has_ell2_norm \\<psi> \\<Longrightarrow> has_ell2_norm (C0 \\<psi>)\\<close> for \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_ell2_norm \\<psi> \\<Longrightarrow> has_ell2_norm (C0 \\<psi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. has_ell2_norm \\<psi> \\<Longrightarrow> has_ell2_norm (C0 \\<psi>)", "assume \\<open>has_ell2_norm \\<psi>\\<close>"], ["proof (state)\nthis:\n  has_ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. has_ell2_norm \\<psi> \\<Longrightarrow> has_ell2_norm (C0 \\<psi>)", "hence \\<open>bdd_above (sum (\\<lambda>i. (cmod (\\<psi> i))\\<^sup>2) ` Collect finite)\\<close>"], ["proof (prove)\nusing this:\n  has_ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. bdd_above (sum (\\<lambda>i. (cmod (\\<psi> i))\\<^sup>2) ` Collect finite)", "unfolding has_ell2_norm_def"], ["proof (prove)\nusing this:\n  bdd_above (sum (\\<lambda>i. (cmod (\\<psi> i))\\<^sup>2) ` Collect finite)\n\ngoal (1 subgoal):\n 1. bdd_above (sum (\\<lambda>i. (cmod (\\<psi> i))\\<^sup>2) ` Collect finite)", "by blast"], ["proof (state)\nthis:\n  bdd_above (sum (\\<lambda>i. (cmod (\\<psi> i))\\<^sup>2) ` Collect finite)\n\ngoal (1 subgoal):\n 1. has_ell2_norm \\<psi> \\<Longrightarrow> has_ell2_norm (C0 \\<psi>)", "hence \\<open>\\<exists> M. \\<forall> S. finite S \\<longrightarrow> ( sum (\\<lambda>i. (cmod (\\<psi> i))\\<^sup>2) S ) \\<le> M\\<close>"], ["proof (prove)\nusing this:\n  bdd_above (sum (\\<lambda>i. (cmod (\\<psi> i))\\<^sup>2) ` Collect finite)\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>S.\n          finite S \\<longrightarrow>\n          (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2) \\<le> M", "by (simp add: bdd_above_def)"], ["proof (state)\nthis:\n  \\<exists>M.\n     \\<forall>S.\n        finite S \\<longrightarrow>\n        (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2) \\<le> M\n\ngoal (1 subgoal):\n 1. has_ell2_norm \\<psi> \\<Longrightarrow> has_ell2_norm (C0 \\<psi>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>M.\n     \\<forall>S.\n        finite S \\<longrightarrow>\n        (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2) \\<le> M", "obtain M::real where \\<open>\\<And> S::'a set. finite S \\<Longrightarrow> ( sum (\\<lambda>i. (cmod (\\<psi> i))\\<^sup>2) S ) \\<le> M\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>M.\n     \\<forall>S.\n        finite S \\<longrightarrow>\n        (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2) \\<le> M\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        (\\<And>S.\n            finite S \\<Longrightarrow>\n            (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)\n            \\<le> M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite ?S \\<Longrightarrow>\n  (\\<Sum>i\\<in>?S. (cmod (\\<psi> i))\\<^sup>2) \\<le> M\n\ngoal (1 subgoal):\n 1. has_ell2_norm \\<psi> \\<Longrightarrow> has_ell2_norm (C0 \\<psi>)", "define \\<phi>::\\<open>'b \\<Rightarrow> complex\\<close> where\n      \\<open>\\<phi> b = (case inv_map \\<pi> b of None \\<Rightarrow> 0 | Some x \\<Rightarrow> \\<psi> x)\\<close> for b"], ["proof (state)\nthis:\n  \\<phi> ?b =\n  (case inv_map \\<pi> ?b of None \\<Rightarrow> 0\n   | Some x \\<Rightarrow> \\<psi> x)\n\ngoal (1 subgoal):\n 1. has_ell2_norm \\<psi> \\<Longrightarrow> has_ell2_norm (C0 \\<psi>)", "have \\<open>\\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk> \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M\\<close>\n      for R::\\<open>'b set\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "assume \\<open>finite R\\<close> and \\<open>\\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<close>"], ["proof (state)\nthis:\n  finite R\n  \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "from  \\<open>\\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0", "have  \\<open>\\<forall>i\\<in>R. \\<exists> x. Some x = inv_map \\<pi> i\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>R. \\<exists>x. Some x = inv_map \\<pi> i", "unfolding \\<phi>_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R.\n     (case inv_map \\<pi> i of None \\<Rightarrow> 0\n      | Some x \\<Rightarrow> \\<psi> x) \\<noteq>\n     0\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>R. \\<exists>x. Some x = inv_map \\<pi> i", "by (metis option.case_eq_if option.collapse)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>R. \\<exists>x. Some x = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "hence  \\<open>\\<exists> f. \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. \\<exists>x. Some x = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i", "by metis"], ["proof (state)\nthis:\n  \\<exists>f. \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i", "obtain f::\\<open>'b\\<Rightarrow>'a\\<close> where \\<open>\\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>f. \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "define S::\\<open>'a set\\<close> where \\<open>S = f ` R\\<close>"], ["proof (state)\nthis:\n  S = f ` R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "have \\<open>finite S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "using \\<open>finite R\\<close>"], ["proof (prove)\nusing this:\n  finite R\n\ngoal (1 subgoal):\n 1. finite S", "by (simp add: S_def)"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "moreover"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "have \\<open>(\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =  (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "have \\<open>inj_on f R\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f R", "proof(rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \\<open>x \\<in> R\\<close> and \\<open>y \\<in> R\\<close> and \\<open>f x = f y\\<close>"], ["proof (state)\nthis:\n  x \\<in> R\n  y \\<in> R\n  f x = f y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from \\<open>\\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i", "have \\<open>\\<forall>i\\<in>R. Some (f i) = Some (inv \\<pi> (Some i))\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>R. Some (f i) = Some (inv \\<pi> (Some i))", "by (metis inv_map_def option.distinct(1))"], ["proof (state)\nthis:\n  \\<forall>i\\<in>R. Some (f i) = Some (inv \\<pi> (Some i))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \\<open>\\<forall>i\\<in>R. f i = inv \\<pi> (Some i)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. Some (f i) = Some (inv \\<pi> (Some i))\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>R. f i = inv \\<pi> (Some i)", "by blast"], ["proof (state)\nthis:\n  \\<forall>i\\<in>R. f i = inv \\<pi> (Some i)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \\<open>\\<forall>i\\<in>R. \\<pi> (f i) = Some i\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. f i = inv \\<pi> (Some i)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>R. \\<pi> (f i) = Some i", "by (metis \\<open>\\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\\<close> f_inv_into_f inv_map_def option.distinct(1))"], ["proof (state)\nthis:\n  \\<forall>i\\<in>R. \\<pi> (f i) = Some i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \\<open>\\<pi> (f x) = Some x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> (f x) = Some x", "using \\<open>\\<forall>i\\<in>R. \\<pi> (f i) = Some i\\<close> \\<open>x\\<in>R\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. \\<pi> (f i) = Some i\n  x \\<in> R\n\ngoal (1 subgoal):\n 1. \\<pi> (f x) = Some x", "by blast"], ["proof (state)\nthis:\n  \\<pi> (f x) = Some x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  \\<pi> (f x) = Some x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \\<open>\\<pi> (f y) = Some y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> (f y) = Some y", "using \\<open>\\<forall>i\\<in>R. \\<pi> (f i) = Some i\\<close> \\<open>y\\<in>R\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. \\<pi> (f i) = Some i\n  y \\<in> R\n\ngoal (1 subgoal):\n 1. \\<pi> (f y) = Some y", "by blast"], ["proof (state)\nthis:\n  \\<pi> (f y) = Some y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  \\<pi> (f x) = Some x\n  \\<pi> (f y) = Some y", "have \\<open>Some x = Some y\\<close>"], ["proof (prove)\nusing this:\n  \\<pi> (f x) = Some x\n  \\<pi> (f y) = Some y\n\ngoal (1 subgoal):\n 1. Some x = Some y", "using \\<open>f x = f y\\<close>"], ["proof (prove)\nusing this:\n  \\<pi> (f x) = Some x\n  \\<pi> (f y) = Some y\n  f x = f y\n\ngoal (1 subgoal):\n 1. Some x = Some y", "by metis"], ["proof (state)\nthis:\n  Some x = Some y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \\<open>x = y\\<close>"], ["proof (prove)\nusing this:\n  Some x = Some y\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on f R\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "moreover"], ["proof (state)\nthis:\n  inj_on f R\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "have \\<open>i \\<in> R \\<Longrightarrow> (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2\\<close>\n          for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> R \\<Longrightarrow>\n    (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> R \\<Longrightarrow>\n    (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2", "assume \\<open>i \\<in> R\\<close>"], ["proof (state)\nthis:\n  i \\<in> R\n\ngoal (1 subgoal):\n 1. i \\<in> R \\<Longrightarrow>\n    (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2", "hence \\<open>\\<phi> i = \\<psi> (f i)\\<close>"], ["proof (prove)\nusing this:\n  i \\<in> R\n\ngoal (1 subgoal):\n 1. \\<phi> i = \\<psi> (f i)", "unfolding \\<phi>_def"], ["proof (prove)\nusing this:\n  i \\<in> R\n\ngoal (1 subgoal):\n 1. (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some x \\<Rightarrow> \\<psi> x) =\n    \\<psi> (f i)", "by (metis \\<open>\\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\\<close> option.simps(5))"], ["proof (state)\nthis:\n  \\<phi> i = \\<psi> (f i)\n\ngoal (1 subgoal):\n 1. i \\<in> R \\<Longrightarrow>\n    (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> i = \\<psi> (f i)\n\ngoal (1 subgoal):\n 1. (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> R \\<Longrightarrow>\n  (cmod (\\<phi> ?i))\\<^sup>2 = (cmod (\\<psi> (f ?i)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "ultimately"], ["proof (chain)\npicking this:\n  inj_on f R\n  ?i \\<in> R \\<Longrightarrow>\n  (cmod (\\<phi> ?i))\\<^sup>2 = (cmod (\\<psi> (f ?i)))\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on f R\n  ?i \\<in> R \\<Longrightarrow>\n  (cmod (\\<phi> ?i))\\<^sup>2 = (cmod (\\<psi> (f ?i)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "unfolding S_def"], ["proof (prove)\nusing this:\n  inj_on f R\n  ?i \\<in> R \\<Longrightarrow>\n  (cmod (\\<phi> ?i))\\<^sup>2 = (cmod (\\<psi> (f ?i)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>f ` R. (cmod (\\<psi> i))\\<^sup>2)", "by (metis (mono_tags, lifting) sum.reindex_cong)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "ultimately"], ["proof (chain)\npicking this:\n  finite S\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite S\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "by (simp add: \\<open>\\<And>S. finite S \\<Longrightarrow> (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2) \\<le> M\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?R; \\<forall>i\\<in>?R. \\<phi> i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i\\<in>?R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M\n\ngoal (1 subgoal):\n 1. has_ell2_norm \\<psi> \\<Longrightarrow> has_ell2_norm (C0 \\<psi>)", "have \\<open>finite R \\<Longrightarrow> ( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) R ) \\<le> M\\<close>\n      for R::\\<open>'b set\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "assume \\<open>finite R\\<close>"], ["proof (state)\nthis:\n  finite R\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "define U::\\<open>'b set\\<close> where \\<open>U = {i | i::'b. i \\<in> R \\<and>  \\<phi> i \\<noteq> 0 }\\<close>"], ["proof (state)\nthis:\n  U = {i |i. i \\<in> R \\<and> \\<phi> i \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "define V::\\<open>'b set\\<close> where \\<open>V = {i | i::'b. i \\<in> R \\<and>  \\<phi> i = 0 }\\<close>"], ["proof (state)\nthis:\n  V = {i |i. i \\<in> R \\<and> \\<phi> i = 0}\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "have \\<open>U \\<inter> V = {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<inter> V = {}", "unfolding U_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i |i. i \\<in> R \\<and> \\<phi> i \\<noteq> 0} \\<inter>\n    {i |i. i \\<in> R \\<and> \\<phi> i = 0} =\n    {}", "by blast"], ["proof (state)\nthis:\n  U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "moreover"], ["proof (state)\nthis:\n  U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "have \\<open>U \\<union> V = R\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<union> V = R", "unfolding U_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i |i. i \\<in> R \\<and> \\<phi> i \\<noteq> 0} \\<union>\n    {i |i. i \\<in> R \\<and> \\<phi> i = 0} =\n    R", "by blast"], ["proof (state)\nthis:\n  U \\<union> V = R\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "ultimately"], ["proof (chain)\npicking this:\n  U \\<inter> V = {}\n  U \\<union> V = R", "have \\<open>( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) R ) = ( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) U ) + \n            ( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) V )\\<close>"], ["proof (prove)\nusing this:\n  U \\<inter> V = {}\n  U \\<union> V = R\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) +\n    (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2)", "using \\<open>finite R\\<close> sum.union_disjoint"], ["proof (prove)\nusing this:\n  U \\<inter> V = {}\n  U \\<union> V = R\n  finite R\n  \\<lbrakk>finite ?A; finite ?B; ?A \\<inter> ?B = {}\\<rbrakk>\n  \\<Longrightarrow> sum ?g (?A \\<union> ?B) = sum ?g ?A + sum ?g ?B\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) +\n    (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) +\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) +\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "have \\<open>( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) V ) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2) = 0", "unfolding V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i |i. i \\<in> R \\<and> \\<phi> i = 0}.\n       (cmod (\\<phi> i))\\<^sup>2) =\n    0", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2) = 0\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) +\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2)\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2) = 0", "have \\<open>( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) R ) = ( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) U )\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) +\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2)\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "have \\<open>\\<forall> i \\<in> U. \\<phi> i \\<noteq> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>U. \\<phi> i \\<noteq> 0", "by (simp add: U_def)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>U. \\<phi> i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "moreover"], ["proof (state)\nthis:\n  \\<forall>i\\<in>U. \\<phi> i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "have \\<open>finite U\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite U", "unfolding U_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i |i. i \\<in> R \\<and> \\<phi> i \\<noteq> 0}", "using \\<open>finite R\\<close>"], ["proof (prove)\nusing this:\n  finite R\n\ngoal (1 subgoal):\n 1. finite {i |i. i \\<in> R \\<and> \\<phi> i \\<noteq> 0}", "by simp"], ["proof (state)\nthis:\n  finite U\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n  \\<forall>i\\<in>U. \\<phi> i \\<noteq> 0\n  finite U", "have \\<open>( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) U ) \\<le> M\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n  \\<forall>i\\<in>U. \\<phi> i \\<noteq> 0\n  finite U\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "using \\<open>\\<And>R. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk> \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n  \\<forall>i\\<in>U. \\<phi> i \\<noteq> 0\n  finite U\n  \\<lbrakk>finite ?R; \\<forall>i\\<in>?R. \\<phi> i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i\\<in>?R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) \\<le> M\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) \\<le> M\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "using \\<open>( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) R ) = ( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) U )\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) \\<le> M\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ?R \\<Longrightarrow>\n  (\\<Sum>i\\<in>?R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M\n\ngoal (1 subgoal):\n 1. has_ell2_norm \\<psi> \\<Longrightarrow> has_ell2_norm (C0 \\<psi>)", "hence  \\<open>bdd_above (sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) ` Collect finite)\\<close>"], ["proof (prove)\nusing this:\n  finite ?R \\<Longrightarrow>\n  (\\<Sum>i\\<in>?R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M\n\ngoal (1 subgoal):\n 1. bdd_above (sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) ` Collect finite)", "unfolding bdd_above_def"], ["proof (prove)\nusing this:\n  finite ?R \\<Longrightarrow>\n  (\\<Sum>i\\<in>?R. (cmod (\\<phi> i))\\<^sup>2) \\<le> M\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>x\\<in>sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) `\n                      Collect finite.\n          x \\<le> M", "by blast"], ["proof (state)\nthis:\n  bdd_above (sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) ` Collect finite)\n\ngoal (1 subgoal):\n 1. has_ell2_norm \\<psi> \\<Longrightarrow> has_ell2_norm (C0 \\<psi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  bdd_above (sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) ` Collect finite)\n\ngoal (1 subgoal):\n 1. has_ell2_norm (C0 \\<psi>)", "unfolding \\<phi>_def C0_def"], ["proof (prove)\nusing this:\n  bdd_above\n   (sum (\\<lambda>i.\n            (cmod\n              (case inv_map \\<pi> i of None \\<Rightarrow> 0\n               | Some x \\<Rightarrow> \\<psi> x))\\<^sup>2) `\n    Collect finite)\n\ngoal (1 subgoal):\n 1. has_ell2_norm\n     (\\<lambda>b.\n         case inv_map \\<pi> b of None \\<Rightarrow> 0\n         | Some x \\<Rightarrow> \\<psi> x)", "using has_ell2_norm_def"], ["proof (prove)\nusing this:\n  bdd_above\n   (sum (\\<lambda>i.\n            (cmod\n              (case inv_map \\<pi> i of None \\<Rightarrow> 0\n               | Some x \\<Rightarrow> \\<psi> x))\\<^sup>2) `\n    Collect finite)\n  has_ell2_norm ?x =\n  bdd_above (sum (\\<lambda>i. (cmod (?x i))\\<^sup>2) ` Collect finite)\n\ngoal (1 subgoal):\n 1. has_ell2_norm\n     (\\<lambda>b.\n         case inv_map \\<pi> b of None \\<Rightarrow> 0\n         | Some x \\<Rightarrow> \\<psi> x)", "by blast"], ["proof (state)\nthis:\n  has_ell2_norm (C0 \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_ell2_norm ?\\<psi> \\<Longrightarrow> has_ell2_norm (C0 ?\\<psi>)\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "define C1 :: \"('a ell2 \\<Rightarrow> 'b ell2)\"\n    where \"C1 \\<psi> = Abs_ell2 (C0 (Rep_ell2 \\<psi>))\" for \\<psi>"], ["proof (state)\nthis:\n  C1 ?\\<psi> = Abs_ell2 (C0 (Rep_ell2 ?\\<psi>))\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "have [transfer_rule]: \"rel_fun (pcr_ell2 (=)) (pcr_ell2 (=)) C0 C1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (pcr_ell2 (=)) (pcr_ell2 (=)) C0 C1", "apply (rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. pcr_ell2 (=) x y \\<Longrightarrow> pcr_ell2 (=) (C0 x) (C1 y)", "unfolding ell2.pcr_cr_eq cr_ell2_def C1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x = Rep_ell2 y \\<Longrightarrow>\n       C0 x = Rep_ell2 (Abs_ell2 (C0 (Rep_ell2 y)))", "apply (subst Abs_ell2_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x = Rep_ell2 y \\<Longrightarrow>\n       C0 (Rep_ell2 y) \\<in> Collect has_ell2_norm\n 2. \\<And>x y. x = Rep_ell2 y \\<Longrightarrow> C0 x = C0 (Rep_ell2 y)", "using has_ell2_norm_C0 Rep_ell2"], ["proof (prove)\nusing this:\n  has_ell2_norm ?\\<psi> \\<Longrightarrow> has_ell2_norm (C0 ?\\<psi>)\n  Rep_ell2 ?x \\<in> {x. has_ell2_norm x}\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x = Rep_ell2 y \\<Longrightarrow>\n       C0 (Rep_ell2 y) \\<in> Collect has_ell2_norm\n 2. \\<And>x y. x = Rep_ell2 y \\<Longrightarrow> C0 x = C0 (Rep_ell2 y)", "by blast+"], ["proof (state)\nthis:\n  rel_fun (pcr_ell2 (=)) (pcr_ell2 (=)) C0 C1\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "have add: \"C1 (x + y) = C1 x + C1 y\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. C1 (x + y) = C1 x + C1 y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> C0 (\\<lambda>xa. x xa + y xa) =\n                         (\\<lambda>xa. C0 x xa + C0 y xa)", "unfolding C0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>b.\n                             case inv_map \\<pi> b of None \\<Rightarrow> 0\n                             | Some xa \\<Rightarrow> x xa + y xa) =\n                         (\\<lambda>xa.\n                             (case inv_map \\<pi> xa of None \\<Rightarrow> 0\n                              | Some xa \\<Rightarrow> x xa) +\n                             (case inv_map \\<pi> xa of None \\<Rightarrow> 0\n                              | Some x \\<Rightarrow> y x))", "apply (rule ext, rename_tac b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y b.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y\\<rbrakk>\n       \\<Longrightarrow> (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some xa \\<Rightarrow> x xa + y xa) =\n                         (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some xa \\<Rightarrow> x xa) +\n                         (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some x \\<Rightarrow> y x)", "apply (case_tac \"inv_map \\<pi> b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y b.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y;\n        inv_map \\<pi> b = None\\<rbrakk>\n       \\<Longrightarrow> (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some xa \\<Rightarrow> x xa + y xa) =\n                         (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some xa \\<Rightarrow> x xa) +\n                         (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some x \\<Rightarrow> y x)\n 2. \\<And>x y b a.\n       \\<lbrakk>has_ell2_norm x; has_ell2_norm y;\n        inv_map \\<pi> b = Some a\\<rbrakk>\n       \\<Longrightarrow> (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some xa \\<Rightarrow> x xa + y xa) =\n                         (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some xa \\<Rightarrow> x xa) +\n                         (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some x \\<Rightarrow> y x)", "by auto"], ["proof (state)\nthis:\n  C1 (?x + ?y) = C1 ?x + C1 ?y\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "have scaleC: \"C1 (c *\\<^sub>C x) = c *\\<^sub>C C1 x\" for c x"], ["proof (prove)\ngoal (1 subgoal):\n 1. C1 (c *\\<^sub>C x) = c *\\<^sub>C C1 x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c x.\n       has_ell2_norm x \\<Longrightarrow>\n       C0 (\\<lambda>xa. c * x xa) = (\\<lambda>xa. c * C0 x xa)", "unfolding C0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c x.\n       has_ell2_norm x \\<Longrightarrow>\n       (\\<lambda>b.\n           case inv_map \\<pi> b of None \\<Rightarrow> 0\n           | Some xa \\<Rightarrow> c * x xa) =\n       (\\<lambda>xa.\n           c *\n           (case inv_map \\<pi> xa of None \\<Rightarrow> 0\n            | Some xa \\<Rightarrow> x xa))", "apply (rule ext, rename_tac b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c x b.\n       has_ell2_norm x \\<Longrightarrow>\n       (case inv_map \\<pi> b of None \\<Rightarrow> 0\n        | Some xa \\<Rightarrow> c * x xa) =\n       c *\n       (case inv_map \\<pi> b of None \\<Rightarrow> 0\n        | Some xa \\<Rightarrow> x xa)", "apply (case_tac \"inv_map \\<pi> b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c x b.\n       \\<lbrakk>has_ell2_norm x; inv_map \\<pi> b = None\\<rbrakk>\n       \\<Longrightarrow> (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some xa \\<Rightarrow> c * x xa) =\n                         c *\n                         (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some xa \\<Rightarrow> x xa)\n 2. \\<And>c x b a.\n       \\<lbrakk>has_ell2_norm x; inv_map \\<pi> b = Some a\\<rbrakk>\n       \\<Longrightarrow> (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some xa \\<Rightarrow> c * x xa) =\n                         c *\n                         (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some xa \\<Rightarrow> x xa)", "by auto"], ["proof (state)\nthis:\n  C1 (?c *\\<^sub>C ?x) = ?c *\\<^sub>C C1 ?x\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "have \"clinear C1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear C1", "using add scaleC"], ["proof (prove)\nusing this:\n  C1 (?x + ?y) = C1 ?x + C1 ?y\n  C1 (?c *\\<^sub>C ?x) = ?c *\\<^sub>C C1 ?x\n\ngoal (1 subgoal):\n 1. clinear C1", "by (rule clinearI)"], ["proof (state)\nthis:\n  clinear C1\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "have bounded_C0: \\<open>ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>\\<close> if \\<open>has_ell2_norm \\<psi>\\<close> for \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "have \\<open>\\<forall> S. finite S \\<longrightarrow> ( sum (\\<lambda>i. (cmod (\\<psi> i))\\<^sup>2) S ) \\<le> (ell2_norm \\<psi>)^2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S.\n       finite S \\<longrightarrow>\n       (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)\n       \\<le> (ell2_norm \\<psi>)\\<^sup>2", "using \\<open>has_ell2_norm \\<psi>\\<close> ell2_norm_def"], ["proof (prove)\nusing this:\n  has_ell2_norm \\<psi>\n  ell2_norm ?x =\n  sqrt\n   (\\<Squnion> (sum (\\<lambda>i. (cmod (?x i))\\<^sup>2) ` {F. finite F}))\n\ngoal (1 subgoal):\n 1. \\<forall>S.\n       finite S \\<longrightarrow>\n       (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)\n       \\<le> (ell2_norm \\<psi>)\\<^sup>2", "by (smt cSUP_upper has_ell2_norm_def mem_Collect_eq sqrt_le_D sum.cong)"], ["proof (state)\nthis:\n  \\<forall>S.\n     finite S \\<longrightarrow>\n     (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)\n     \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "define \\<phi>::\\<open>'b \\<Rightarrow> complex\\<close> where\n      \\<open>\\<phi> b = (case inv_map \\<pi> b of None \\<Rightarrow> 0 | Some x \\<Rightarrow> \\<psi> x)\\<close> for b"], ["proof (state)\nthis:\n  \\<phi> ?b =\n  (case inv_map \\<pi> ?b of None \\<Rightarrow> 0\n   | Some x \\<Rightarrow> \\<psi> x)\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "have \\<open>\\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk> \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le>  (ell2_norm \\<psi>)^2\\<close>\n      for R::\\<open>'b set\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> (ell2_norm \\<psi>)\\<^sup>2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> (ell2_norm \\<psi>)\\<^sup>2", "assume \\<open>finite R\\<close> and \\<open>\\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<close>"], ["proof (state)\nthis:\n  finite R\n  \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> (ell2_norm \\<psi>)\\<^sup>2", "from  \\<open>\\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0", "have  \\<open>\\<forall>i\\<in>R. \\<exists> x. Some x = inv_map \\<pi> i\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>R. \\<exists>x. Some x = inv_map \\<pi> i", "unfolding \\<phi>_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R.\n     (case inv_map \\<pi> i of None \\<Rightarrow> 0\n      | Some x \\<Rightarrow> \\<psi> x) \\<noteq>\n     0\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>R. \\<exists>x. Some x = inv_map \\<pi> i", "by (metis option.case_eq_if option.collapse)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>R. \\<exists>x. Some x = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> (ell2_norm \\<psi>)\\<^sup>2", "hence  \\<open>\\<exists> f. \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. \\<exists>x. Some x = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i", "by metis"], ["proof (state)\nthis:\n  \\<exists>f. \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> (ell2_norm \\<psi>)\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i", "obtain f::\\<open>'b\\<Rightarrow>'a\\<close> where \\<open>\\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>f. \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> (ell2_norm \\<psi>)\\<^sup>2", "define S::\\<open>'a set\\<close> where \\<open>S = f ` R\\<close>"], ["proof (state)\nthis:\n  S = f ` R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> (ell2_norm \\<psi>)\\<^sup>2", "have \\<open>finite S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "using \\<open>finite R\\<close>"], ["proof (prove)\nusing this:\n  finite R\n\ngoal (1 subgoal):\n 1. finite S", "by (simp add: S_def)"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> (ell2_norm \\<psi>)\\<^sup>2", "moreover"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> (ell2_norm \\<psi>)\\<^sup>2", "have \\<open>(\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =  (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "have \\<open>inj_on f R\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f R", "proof(rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \\<open>x \\<in> R\\<close> and \\<open>y \\<in> R\\<close> and \\<open>f x = f y\\<close>"], ["proof (state)\nthis:\n  x \\<in> R\n  y \\<in> R\n  f x = f y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from \\<open>\\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i", "have \\<open>\\<forall>i\\<in>R. Some (f i) = Some (inv \\<pi> (Some i))\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>R. Some (f i) = Some (inv \\<pi> (Some i))", "by (metis inv_map_def option.distinct(1))"], ["proof (state)\nthis:\n  \\<forall>i\\<in>R. Some (f i) = Some (inv \\<pi> (Some i))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \\<open>\\<forall>i\\<in>R. f i = inv \\<pi> (Some i)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. Some (f i) = Some (inv \\<pi> (Some i))\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>R. f i = inv \\<pi> (Some i)", "by blast"], ["proof (state)\nthis:\n  \\<forall>i\\<in>R. f i = inv \\<pi> (Some i)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \\<open>\\<forall>i\\<in>R. \\<pi> (f i) = Some i\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. f i = inv \\<pi> (Some i)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>R. \\<pi> (f i) = Some i", "by (metis \\<open>\\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\\<close> f_inv_into_f inv_map_def option.distinct(1))"], ["proof (state)\nthis:\n  \\<forall>i\\<in>R. \\<pi> (f i) = Some i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \\<open>\\<pi> (f x) = Some x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> (f x) = Some x", "using \\<open>\\<forall>i\\<in>R. \\<pi> (f i) = Some i\\<close> \\<open>x\\<in>R\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. \\<pi> (f i) = Some i\n  x \\<in> R\n\ngoal (1 subgoal):\n 1. \\<pi> (f x) = Some x", "by blast"], ["proof (state)\nthis:\n  \\<pi> (f x) = Some x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  \\<pi> (f x) = Some x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \\<open>\\<pi> (f y) = Some y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> (f y) = Some y", "using \\<open>\\<forall>i\\<in>R. \\<pi> (f i) = Some i\\<close> \\<open>y\\<in>R\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>R. \\<pi> (f i) = Some i\n  y \\<in> R\n\ngoal (1 subgoal):\n 1. \\<pi> (f y) = Some y", "by blast"], ["proof (state)\nthis:\n  \\<pi> (f y) = Some y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  \\<pi> (f x) = Some x\n  \\<pi> (f y) = Some y", "have \\<open>Some x = Some y\\<close>"], ["proof (prove)\nusing this:\n  \\<pi> (f x) = Some x\n  \\<pi> (f y) = Some y\n\ngoal (1 subgoal):\n 1. Some x = Some y", "using \\<open>f x = f y\\<close>"], ["proof (prove)\nusing this:\n  \\<pi> (f x) = Some x\n  \\<pi> (f y) = Some y\n  f x = f y\n\ngoal (1 subgoal):\n 1. Some x = Some y", "by metis"], ["proof (state)\nthis:\n  Some x = Some y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> R; y \\<in> R; f x = f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \\<open>x = y\\<close>"], ["proof (prove)\nusing this:\n  Some x = Some y\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on f R\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "moreover"], ["proof (state)\nthis:\n  inj_on f R\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "have \\<open>i \\<in> R \\<Longrightarrow> (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2\\<close>\n          for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> R \\<Longrightarrow>\n    (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> R \\<Longrightarrow>\n    (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2", "assume \\<open>i \\<in> R\\<close>"], ["proof (state)\nthis:\n  i \\<in> R\n\ngoal (1 subgoal):\n 1. i \\<in> R \\<Longrightarrow>\n    (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2", "hence \\<open>\\<phi> i = \\<psi> (f i)\\<close>"], ["proof (prove)\nusing this:\n  i \\<in> R\n\ngoal (1 subgoal):\n 1. \\<phi> i = \\<psi> (f i)", "unfolding \\<phi>_def"], ["proof (prove)\nusing this:\n  i \\<in> R\n\ngoal (1 subgoal):\n 1. (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some x \\<Rightarrow> \\<psi> x) =\n    \\<psi> (f i)", "by (metis \\<open>\\<forall>i\\<in>R. Some (f i) = inv_map \\<pi> i\\<close> option.simps(5))"], ["proof (state)\nthis:\n  \\<phi> i = \\<psi> (f i)\n\ngoal (1 subgoal):\n 1. i \\<in> R \\<Longrightarrow>\n    (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> i = \\<psi> (f i)\n\ngoal (1 subgoal):\n 1. (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (cmod (\\<phi> i))\\<^sup>2 = (cmod (\\<psi> (f i)))\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> R \\<Longrightarrow>\n  (cmod (\\<phi> ?i))\\<^sup>2 = (cmod (\\<psi> (f ?i)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "ultimately"], ["proof (chain)\npicking this:\n  inj_on f R\n  ?i \\<in> R \\<Longrightarrow>\n  (cmod (\\<phi> ?i))\\<^sup>2 = (cmod (\\<psi> (f ?i)))\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on f R\n  ?i \\<in> R \\<Longrightarrow>\n  (cmod (\\<phi> ?i))\\<^sup>2 = (cmod (\\<psi> (f ?i)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "unfolding S_def"], ["proof (prove)\nusing this:\n  inj_on f R\n  ?i \\<in> R \\<Longrightarrow>\n  (cmod (\\<phi> ?i))\\<^sup>2 = (cmod (\\<psi> (f ?i)))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>f ` R. (cmod (\\<psi> i))\\<^sup>2)", "by (metis (mono_tags, lifting) sum.reindex_cong)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> (ell2_norm \\<psi>)\\<^sup>2", "ultimately"], ["proof (chain)\npicking this:\n  finite S\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite S\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "by (simp add: \\<open>\\<forall>S. finite S \\<longrightarrow> (\\<Sum>i\\<in>S. (cmod (\\<psi> i))\\<^sup>2) \\<le> (ell2_norm \\<psi>)\\<^sup>2\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?R; \\<forall>i\\<in>?R. \\<phi> i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i\\<in>?R. (cmod (\\<phi> i))\\<^sup>2)\n                    \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "have \\<open>finite R \\<Longrightarrow> ( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) R ) \\<le> (ell2_norm \\<psi>)\\<^sup>2\\<close>\n      for R::\\<open>'b set\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "assume \\<open>finite R\\<close>"], ["proof (state)\nthis:\n  finite R\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "define U::\\<open>'b set\\<close> where \\<open>U = {i | i::'b. i \\<in> R \\<and>  \\<phi> i \\<noteq> 0 }\\<close>"], ["proof (state)\nthis:\n  U = {i |i. i \\<in> R \\<and> \\<phi> i \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "define V::\\<open>'b set\\<close> where \\<open>V = {i | i::'b. i \\<in> R \\<and>  \\<phi> i = 0 }\\<close>"], ["proof (state)\nthis:\n  V = {i |i. i \\<in> R \\<and> \\<phi> i = 0}\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "have \\<open>U \\<inter> V = {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<inter> V = {}", "unfolding U_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i |i. i \\<in> R \\<and> \\<phi> i \\<noteq> 0} \\<inter>\n    {i |i. i \\<in> R \\<and> \\<phi> i = 0} =\n    {}", "by blast"], ["proof (state)\nthis:\n  U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "moreover"], ["proof (state)\nthis:\n  U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "have \\<open>U \\<union> V = R\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<union> V = R", "unfolding U_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {i |i. i \\<in> R \\<and> \\<phi> i \\<noteq> 0} \\<union>\n    {i |i. i \\<in> R \\<and> \\<phi> i = 0} =\n    R", "by blast"], ["proof (state)\nthis:\n  U \\<union> V = R\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "ultimately"], ["proof (chain)\npicking this:\n  U \\<inter> V = {}\n  U \\<union> V = R", "have \\<open>( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) R ) = ( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) U ) + \n            ( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) V )\\<close>"], ["proof (prove)\nusing this:\n  U \\<inter> V = {}\n  U \\<union> V = R\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) +\n    (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2)", "using \\<open>finite R\\<close> sum.union_disjoint"], ["proof (prove)\nusing this:\n  U \\<inter> V = {}\n  U \\<union> V = R\n  finite R\n  \\<lbrakk>finite ?A; finite ?B; ?A \\<inter> ?B = {}\\<rbrakk>\n  \\<Longrightarrow> sum ?g (?A \\<union> ?B) = sum ?g ?A + sum ?g ?B\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) +\n    (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) +\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) +\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "have \\<open>( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) V ) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2) = 0", "unfolding V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{i |i. i \\<in> R \\<and> \\<phi> i = 0}.\n       (cmod (\\<phi> i))\\<^sup>2) =\n    0", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2) = 0\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) +\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2)\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2) = 0", "have \\<open>( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) R ) = ( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) U )\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2) +\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2)\n  (\\<Sum>i\\<in>V. (cmod (\\<phi> i))\\<^sup>2) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n    (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "have \\<open>\\<forall> i \\<in> U. \\<phi> i \\<noteq> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>U. \\<phi> i \\<noteq> 0", "by (simp add: U_def)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>U. \\<phi> i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "moreover"], ["proof (state)\nthis:\n  \\<forall>i\\<in>U. \\<phi> i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "have \\<open>finite U\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite U", "unfolding U_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i |i. i \\<in> R \\<and> \\<phi> i \\<noteq> 0}", "using \\<open>finite R\\<close>"], ["proof (prove)\nusing this:\n  finite R\n\ngoal (1 subgoal):\n 1. finite {i |i. i \\<in> R \\<and> \\<phi> i \\<noteq> 0}", "by simp"], ["proof (state)\nthis:\n  finite U\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n  \\<forall>i\\<in>U. \\<phi> i \\<noteq> 0\n  finite U", "have \\<open>( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) U ) \\<le>  (ell2_norm \\<psi>)\\<^sup>2\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n  \\<forall>i\\<in>U. \\<phi> i \\<noteq> 0\n  finite U\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "using \\<open>\\<And>R. \\<lbrakk>finite R; \\<forall>i\\<in>R. \\<phi> i \\<noteq> 0\\<rbrakk> \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le>  (ell2_norm \\<psi>)\\<^sup>2\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n  \\<forall>i\\<in>U. \\<phi> i \\<noteq> 0\n  finite U\n  \\<lbrakk>finite ?R; \\<forall>i\\<in>?R. \\<phi> i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i\\<in>?R. (cmod (\\<phi> i))\\<^sup>2)\n                    \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "using \\<open>( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) R ) = ( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) U )\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> (ell2_norm \\<psi>)\\<^sup>2\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) =\n  (\\<Sum>i\\<in>U. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ?R \\<Longrightarrow>\n  (\\<Sum>i\\<in>?R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "hence \\<open>finite R \\<Longrightarrow> sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> ell2_norm \\<psi>\\<close>\n      for R"], ["proof (prove)\nusing this:\n  finite ?R \\<Longrightarrow>\n  (\\<Sum>i\\<in>?R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow>\n    sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> ell2_norm \\<psi>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R;\n     \\<And>R.\n        finite R \\<Longrightarrow>\n        (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n        \\<le> (ell2_norm \\<psi>)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> ell2_norm \\<psi>", "assume \\<open>finite R\\<close>"], ["proof (state)\nthis:\n  finite R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R;\n     \\<And>R.\n        finite R \\<Longrightarrow>\n        (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n        \\<le> (ell2_norm \\<psi>)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> ell2_norm \\<psi>", "hence \\<open>(\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> (ell2_norm \\<psi>)^2\\<close>"], ["proof (prove)\nusing this:\n  finite R\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "by (simp add: \\<open>\\<And>R. finite R \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> (ell2_norm \\<psi>)\\<^sup>2\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R;\n     \\<And>R.\n        finite R \\<Longrightarrow>\n        (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n        \\<le> (ell2_norm \\<psi>)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> ell2_norm \\<psi>", "hence \\<open>sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> sqrt ((ell2_norm \\<psi>)^2)\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> sqrt ((ell2_norm \\<psi>)\\<^sup>2)", "using real_sqrt_le_iff"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> (ell2_norm \\<psi>)\\<^sup>2\n  (sqrt ?x \\<le> sqrt ?y) = (?x \\<le> ?y)\n\ngoal (1 subgoal):\n 1. sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> sqrt ((ell2_norm \\<psi>)\\<^sup>2)", "by blast"], ["proof (state)\nthis:\n  sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> sqrt ((ell2_norm \\<psi>)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R;\n     \\<And>R.\n        finite R \\<Longrightarrow>\n        (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n        \\<le> (ell2_norm \\<psi>)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> ell2_norm \\<psi>", "moreover"], ["proof (state)\nthis:\n  sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> sqrt ((ell2_norm \\<psi>)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R;\n     \\<And>R.\n        finite R \\<Longrightarrow>\n        (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n        \\<le> (ell2_norm \\<psi>)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> ell2_norm \\<psi>", "have \\<open>sqrt ((ell2_norm \\<psi>)^2) = ell2_norm \\<psi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt ((ell2_norm \\<psi>)\\<^sup>2) = ell2_norm \\<psi>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sqrt ((ell2_norm \\<psi>)\\<^sup>2) = ell2_norm \\<psi>", "have \\<open>ell2_norm \\<psi> \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> ell2_norm \\<psi>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> ell2_norm \\<psi>", "obtain X where \\<open>Rep_ell2 X = \\<psi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        Rep_ell2 X = \\<psi> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Rep_ell2_cases \\<open>has_ell2_norm \\<psi>\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> {x. has_ell2_norm x};\n   \\<And>x. ?y = Rep_ell2 x \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  has_ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        Rep_ell2 X = \\<psi> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Rep_ell2 X = \\<psi>\n\ngoal (1 subgoal):\n 1. 0 \\<le> ell2_norm \\<psi>", "have \\<open>norm X \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> norm X", "by simp"], ["proof (state)\nthis:\n  0 \\<le> norm X\n\ngoal (1 subgoal):\n 1. 0 \\<le> ell2_norm \\<psi>", "thus \\<open>ell2_norm \\<psi> \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> norm X\n\ngoal (1 subgoal):\n 1. 0 \\<le> ell2_norm \\<psi>", "using \\<open>Rep_ell2 X = \\<psi>\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> norm X\n  Rep_ell2 X = \\<psi>\n\ngoal (1 subgoal):\n 1. 0 \\<le> ell2_norm \\<psi>", "by (simp add: norm_ell2.rep_eq)"], ["proof (state)\nthis:\n  0 \\<le> ell2_norm \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. sqrt ((ell2_norm \\<psi>)\\<^sup>2) = ell2_norm \\<psi>", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. sqrt ((ell2_norm \\<psi>)\\<^sup>2) = ell2_norm \\<psi>", "by simp"], ["proof (state)\nthis:\n  sqrt ((ell2_norm \\<psi>)\\<^sup>2) = ell2_norm \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sqrt ((ell2_norm \\<psi>)\\<^sup>2) = ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite R;\n     \\<And>R.\n        finite R \\<Longrightarrow>\n        (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n        \\<le> (ell2_norm \\<psi>)\\<^sup>2\\<rbrakk>\n    \\<Longrightarrow> sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n                      \\<le> ell2_norm \\<psi>", "ultimately"], ["proof (chain)\npicking this:\n  sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> sqrt ((ell2_norm \\<psi>)\\<^sup>2)\n  sqrt ((ell2_norm \\<psi>)\\<^sup>2) = ell2_norm \\<psi>", "show ?thesis"], ["proof (prove)\nusing this:\n  sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> sqrt ((ell2_norm \\<psi>)\\<^sup>2)\n  sqrt ((ell2_norm \\<psi>)\\<^sup>2) = ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> ell2_norm \\<psi>", "by linarith"], ["proof (state)\nthis:\n  sqrt (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> ell2_norm \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ?R \\<Longrightarrow>\n  sqrt (\\<Sum>i\\<in>?R. (cmod (\\<phi> i))\\<^sup>2) \\<le> ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "hence \\<open>\\<forall> L \\<in> { sqrt (sum (\\<lambda>i. norm (\\<phi> i)^2) F) | F. F\\<in>{F. finite F} }. L \\<le> ell2_norm \\<psi>\\<close>"], ["proof (prove)\nusing this:\n  finite ?R \\<Longrightarrow>\n  sqrt (\\<Sum>i\\<in>?R. (cmod (\\<phi> i))\\<^sup>2) \\<le> ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. \\<forall>L\\<in>{sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n                    F \\<in> {F. finite F}}.\n       L \\<le> ell2_norm \\<psi>", "by blast"], ["proof (state)\nthis:\n  \\<forall>L\\<in>{sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n                  F \\<in> {F. finite F}}.\n     L \\<le> ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "moreover"], ["proof (state)\nthis:\n  \\<forall>L\\<in>{sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n                  F \\<in> {F. finite F}}.\n     L \\<le> ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "have \\<open>{ sqrt (sum (\\<lambda>i. norm (\\<phi> i)^2) F) | F. F\\<in>{F. finite F} } \\<noteq> {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n     F \\<in> {F. finite F}} \\<noteq>\n    {}", "by force"], ["proof (state)\nthis:\n  {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n   F \\<in> {F. finite F}} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>L\\<in>{sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n                  F \\<in> {F. finite F}}.\n     L \\<le> ell2_norm \\<psi>\n  {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n   F \\<in> {F. finite F}} \\<noteq>\n  {}", "have \\<open>Sup { sqrt (sum (\\<lambda>i. norm (\\<phi> i)^2) F) | F. F\\<in>{F. finite F} } \\<le> ell2_norm \\<psi>\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>L\\<in>{sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n                  F \\<in> {F. finite F}}.\n     L \\<le> ell2_norm \\<psi>\n  {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n   F \\<in> {F. finite F}} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}\n    \\<le> ell2_norm \\<psi>", "by (meson cSup_least)"], ["proof (state)\nthis:\n  \\<Squnion>\n   {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n    F \\<in> {F. finite F}}\n  \\<le> ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "moreover"], ["proof (state)\nthis:\n  \\<Squnion>\n   {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n    F \\<in> {F. finite F}}\n  \\<le> ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "have \\<open>sqrt ( Sup { sum (\\<lambda>i. norm (\\<phi> i)^2) F | F. F\\<in>{F. finite F} } )\n          = Sup { sqrt (sum (\\<lambda>i. norm (\\<phi> i)^2) F) | F. F\\<in>{F. finite F}  }\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "define T where \\<open>T = { sum (\\<lambda>i. norm (\\<phi> i)^2) F | F. F\\<in>{F. finite F} }\\<close>"], ["proof (state)\nthis:\n  T = {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}}\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "have \\<open>mono sqrt\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono sqrt", "by (simp add: monoI)"], ["proof (state)\nthis:\n  mono sqrt\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "moreover"], ["proof (state)\nthis:\n  mono sqrt\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "have \\<open>continuous (at_left (Sup T)) sqrt\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at_left (\\<Squnion> T)) sqrt", "by (simp add: continuous_at_imp_continuous_at_within isCont_real_sqrt)"], ["proof (state)\nthis:\n  continuous (at_left (\\<Squnion> T)) sqrt\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "moreover"], ["proof (state)\nthis:\n  continuous (at_left (\\<Squnion> T)) sqrt\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "have \\<open>T \\<noteq> {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<noteq> {}", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n     F \\<in> Collect finite} \\<noteq>\n    {}", "by blast"], ["proof (state)\nthis:\n  T \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "moreover"], ["proof (state)\nthis:\n  T \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "have \\<open>bdd_above T\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above T", "proof(rule bdd_aboveI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> T \\<Longrightarrow> x \\<le> ?M", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> T \\<Longrightarrow> x \\<le> ?M", "assume \\<open>x \\<in> T\\<close>"], ["proof (state)\nthis:\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> T \\<Longrightarrow> x \\<le> ?M", "hence \\<open>\\<exists> R. finite R \\<and> x = ( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) R )\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. \\<exists>R.\n       finite R \\<and> x = (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)", "unfolding T_def"], ["proof (prove)\nusing this:\n  x \\<in> {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n           F \\<in> Collect finite}\n\ngoal (1 subgoal):\n 1. \\<exists>R.\n       finite R \\<and> x = (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>R. finite R \\<and> x = (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> T \\<Longrightarrow> x \\<le> ?M", "then"], ["proof (chain)\npicking this:\n  \\<exists>R. finite R \\<and> x = (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)", "obtain R where \\<open>finite R\\<close> and \\<open>x = ( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) R )\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>R. finite R \\<and> x = (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>finite R;\n         x = (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite R\n  x = (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> T \\<Longrightarrow> x \\<le> ?M", "from  \\<open>finite R\\<close>"], ["proof (chain)\npicking this:\n  finite R", "have \\<open>( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) R ) \\<le>  (ell2_norm \\<psi>)^2\\<close>"], ["proof (prove)\nusing this:\n  finite R\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n    \\<le> (ell2_norm \\<psi>)\\<^sup>2", "by (simp add: \\<open>\\<And>R. finite R \\<Longrightarrow> (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2) \\<le> (ell2_norm \\<psi>)\\<^sup>2\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> T \\<Longrightarrow> x \\<le> ?M", "thus \\<open>x \\<le> (ell2_norm \\<psi>)^2\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. x \\<le> (ell2_norm \\<psi>)\\<^sup>2", "using  \\<open>x = ( sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) R )\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n  \\<le> (ell2_norm \\<psi>)\\<^sup>2\n  x = (\\<Sum>i\\<in>R. (cmod (\\<phi> i))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. x \\<le> (ell2_norm \\<psi>)\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  x \\<le> (ell2_norm \\<psi>)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bdd_above T\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "ultimately"], ["proof (chain)\npicking this:\n  mono sqrt\n  continuous (at_left (\\<Squnion> T)) sqrt\n  T \\<noteq> {}\n  bdd_above T", "have \\<open>sqrt (Sup T) = Sup (sqrt ` T)\\<close>"], ["proof (prove)\nusing this:\n  mono sqrt\n  continuous (at_left (\\<Squnion> T)) sqrt\n  T \\<noteq> {}\n  bdd_above T\n\ngoal (1 subgoal):\n 1. sqrt (\\<Squnion> T) = \\<Squnion> (sqrt ` T)", "by (rule Topological_Spaces.continuous_at_Sup_mono)"], ["proof (state)\nthis:\n  sqrt (\\<Squnion> T) = \\<Squnion> (sqrt ` T)\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "moreover"], ["proof (state)\nthis:\n  sqrt (\\<Squnion> T) = \\<Squnion> (sqrt ` T)\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "have \\<open>sqrt ` {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> Collect finite}\n             =  {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F. F \\<in> Collect finite}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt `\n    {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> Collect finite} =\n    {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n     F \\<in> Collect finite}", "by auto"], ["proof (state)\nthis:\n  sqrt `\n  {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> Collect finite} =\n  {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n   F \\<in> Collect finite}\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "ultimately"], ["proof (chain)\npicking this:\n  sqrt (\\<Squnion> T) = \\<Squnion> (sqrt ` T)\n  sqrt `\n  {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> Collect finite} =\n  {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n   F \\<in> Collect finite}", "show ?thesis"], ["proof (prove)\nusing this:\n  sqrt (\\<Squnion> T) = \\<Squnion> (sqrt ` T)\n  sqrt `\n  {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> Collect finite} =\n  {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n   F \\<in> Collect finite}\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "unfolding T_def"], ["proof (prove)\nusing this:\n  sqrt\n   (\\<Squnion>\n     {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n      F \\<in> Collect finite}) =\n  \\<Squnion>\n   (sqrt `\n    {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> Collect finite})\n  sqrt `\n  {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> Collect finite} =\n  {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n   F \\<in> Collect finite}\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F.\n        F \\<in> {F. finite F}}) =\n    \\<Squnion>\n     {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n      F \\<in> {F. finite F}}", "by simp"], ["proof (state)\nthis:\n  sqrt\n   (\\<Squnion>\n     {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}}) =\n  \\<Squnion>\n   {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n    F \\<in> {F. finite F}}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sqrt\n   (\\<Squnion>\n     {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}}) =\n  \\<Squnion>\n   {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n    F \\<in> {F. finite F}}\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "ultimately"], ["proof (chain)\npicking this:\n  \\<Squnion>\n   {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n    F \\<in> {F. finite F}}\n  \\<le> ell2_norm \\<psi>\n  sqrt\n   (\\<Squnion>\n     {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}}) =\n  \\<Squnion>\n   {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n    F \\<in> {F. finite F}}", "have \\<open>sqrt ( Sup { sum (\\<lambda>i. norm (\\<phi> i)^2) F | F. F\\<in>{F. finite F} } ) \\<le> ell2_norm \\<psi>\\<close>"], ["proof (prove)\nusing this:\n  \\<Squnion>\n   {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n    F \\<in> {F. finite F}}\n  \\<le> ell2_norm \\<psi>\n  sqrt\n   (\\<Squnion>\n     {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}}) =\n  \\<Squnion>\n   {sqrt (\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2) |F.\n    F \\<in> {F. finite F}}\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}})\n    \\<le> ell2_norm \\<psi>", "by simp"], ["proof (state)\nthis:\n  sqrt\n   (\\<Squnion>\n     {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}})\n  \\<le> ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "moreover"], ["proof (state)\nthis:\n  sqrt\n   (\\<Squnion>\n     {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}})\n  \\<le> ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "have \\<open>ell2_norm \\<phi> = sqrt ( Sup { sum (\\<lambda>i. norm (\\<phi> i)^2) F | F. F\\<in>{F. finite F} } )\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_norm \\<phi> =\n    sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}})", "unfolding ell2_norm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Squnion>\n       (sum (\\<lambda>i. (cmod (\\<phi> i))\\<^sup>2) ` Collect finite)) =\n    sqrt\n     (\\<Squnion>\n       {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}})", "by (metis Setcompr_eq_image)"], ["proof (state)\nthis:\n  ell2_norm \\<phi> =\n  sqrt\n   (\\<Squnion>\n     {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}})\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "ultimately"], ["proof (chain)\npicking this:\n  sqrt\n   (\\<Squnion>\n     {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}})\n  \\<le> ell2_norm \\<psi>\n  ell2_norm \\<phi> =\n  sqrt\n   (\\<Squnion>\n     {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}})", "have \\<open>ell2_norm \\<phi> \\<le> ell2_norm \\<psi>\\<close>"], ["proof (prove)\nusing this:\n  sqrt\n   (\\<Squnion>\n     {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}})\n  \\<le> ell2_norm \\<psi>\n  ell2_norm \\<phi> =\n  sqrt\n   (\\<Squnion>\n     {\\<Sum>i\\<in>F. (cmod (\\<phi> i))\\<^sup>2 |F. F \\<in> {F. finite F}})\n\ngoal (1 subgoal):\n 1. ell2_norm \\<phi> \\<le> ell2_norm \\<psi>", "by simp"], ["proof (state)\nthis:\n  ell2_norm \\<phi> \\<le> ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "thus ?thesis"], ["proof (prove)\nusing this:\n  ell2_norm \\<phi> \\<le> ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>", "unfolding C0_def \\<phi>_def"], ["proof (prove)\nusing this:\n  ell2_norm\n   (\\<lambda>b.\n       case inv_map \\<pi> b of None \\<Rightarrow> 0\n       | Some x \\<Rightarrow> \\<psi> x)\n  \\<le> ell2_norm \\<psi>\n\ngoal (1 subgoal):\n 1. ell2_norm\n     (\\<lambda>b.\n         case inv_map \\<pi> b of None \\<Rightarrow> 0\n         | Some x \\<Rightarrow> \\<psi> x)\n    \\<le> ell2_norm \\<psi>", "by simp"], ["proof (state)\nthis:\n  ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_ell2_norm ?\\<psi> \\<Longrightarrow>\n  ell2_norm (C0 ?\\<psi>) \\<le> ell2_norm ?\\<psi>\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "hence bounded_C1: \"\\<exists>K. \\<forall>x. norm (C1 x) \\<le> norm x * K\""], ["proof (prove)\nusing this:\n  has_ell2_norm ?\\<psi> \\<Longrightarrow>\n  ell2_norm (C0 ?\\<psi>) \\<le> ell2_norm ?\\<psi>\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (C1 x) \\<le> norm x * K", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        has_ell2_norm \\<psi> \\<Longrightarrow>\n        ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>) \\<Longrightarrow>\n    \\<exists>K.\n       \\<forall>x\\<in>Collect has_ell2_norm.\n          ell2_norm (C0 x) \\<le> ell2_norm x * K", "apply (rule exI[of _ 1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        has_ell2_norm \\<psi> \\<Longrightarrow>\n        ell2_norm (C0 \\<psi>) \\<le> ell2_norm \\<psi>) \\<Longrightarrow>\n    \\<forall>x\\<in>Collect has_ell2_norm.\n       ell2_norm (C0 x) \\<le> ell2_norm x * 1", "by auto"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>x. norm (C1 x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "have \"bounded_clinear C1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear C1", "using \\<open>clinear C1\\<close> bounded_C1"], ["proof (prove)\nusing this:\n  clinear C1\n  \\<exists>K. \\<forall>x. norm (C1 x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. bounded_clinear C1", "using add bounded_clinear_intro scaleC"], ["proof (prove)\nusing this:\n  clinear C1\n  \\<exists>K. \\<forall>x. norm (C1 x) \\<le> norm x * K\n  C1 (?x + ?y) = C1 ?x + C1 ?y\n  \\<lbrakk>\\<And>x y. ?f (x + y) = ?f x + ?f y;\n   \\<And>r x. ?f (r *\\<^sub>C x) = r *\\<^sub>C ?f x;\n   \\<And>x. norm (?f x) \\<le> norm x * ?K\\<rbrakk>\n  \\<Longrightarrow> bounded_clinear ?f\n  C1 (?c *\\<^sub>C ?x) = ?c *\\<^sub>C C1 ?x\n\ngoal (1 subgoal):\n 1. bounded_clinear C1", "by blast"], ["proof (state)\nthis:\n  bounded_clinear C1\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "define C where \"C = CBlinfun C1\""], ["proof (state)\nthis:\n  C = CBlinfun C1\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "have [transfer_rule]: \"pcr_cblinfun (=) (=) C1 C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pcr_cblinfun (=) (=) C1 C", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pcr_cblinfun (=) (=) C1 (CBlinfun C1)", "unfolding cblinfun.pcr_cr_eq cr_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. C1 = (*\\<^sub>V) (CBlinfun C1)", "apply (subst CBlinfun_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. C1 \\<in> Collect bounded_clinear\n 2. C1 = C1", "using \\<open>bounded_clinear C1\\<close>"], ["proof (prove)\nusing this:\n  bounded_clinear C1\n\ngoal (2 subgoals):\n 1. C1 \\<in> Collect bounded_clinear\n 2. C1 = C1", "by auto"], ["proof (state)\nthis:\n  pcr_cblinfun (=) (=) C1 C\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "have C1_ket: \"C1 (ket x) = (case \\<pi> x of Some i \\<Rightarrow> ket i | None \\<Rightarrow> 0)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. C1 (ket x) =\n    (case \\<pi> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "apply (transfer fixing: \\<pi> x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. C0 (\\<lambda>y. if x = y then 1 else 0) =\n    (case \\<pi> x of None \\<Rightarrow> \\<lambda>_. 0\n     | Some i \\<Rightarrow> \\<lambda>y. if i = y then 1 else 0)", "unfolding C0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b.\n        case inv_map \\<pi> b of None \\<Rightarrow> 0\n        | Some y \\<Rightarrow> if x = y then 1 else 0) =\n    (case \\<pi> x of None \\<Rightarrow> \\<lambda>_. 0\n     | Some i \\<Rightarrow> \\<lambda>y. if i = y then 1 else 0)", "apply (rule ext, rename_tac b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       (case inv_map \\<pi> b of None \\<Rightarrow> 0\n        | Some y \\<Rightarrow> if x = y then 1 else 0) =\n       (case \\<pi> x of None \\<Rightarrow> \\<lambda>_. 0\n        | Some i \\<Rightarrow> \\<lambda>y. if i = y then 1 else 0)\n        b", "apply (case_tac \"inv_map \\<pi> b\"; cases \"\\<pi> x\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>inv_map \\<pi> b = None; \\<pi> x = None\\<rbrakk>\n       \\<Longrightarrow> (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some y \\<Rightarrow> if x = y then 1 else 0) =\n                         (case \\<pi> x of None \\<Rightarrow> \\<lambda>_. 0\n                          | Some i \\<Rightarrow>\n                              \\<lambda>y. if i = y then 1 else 0)\n                          b\n 2. \\<And>b a.\n       \\<lbrakk>inv_map \\<pi> b = None; \\<pi> x = Some a\\<rbrakk>\n       \\<Longrightarrow> (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some y \\<Rightarrow> if x = y then 1 else 0) =\n                         (case \\<pi> x of None \\<Rightarrow> \\<lambda>_. 0\n                          | Some i \\<Rightarrow>\n                              \\<lambda>y. if i = y then 1 else 0)\n                          b\n 3. \\<And>b a.\n       \\<lbrakk>inv_map \\<pi> b = Some a; \\<pi> x = None\\<rbrakk>\n       \\<Longrightarrow> (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some y \\<Rightarrow> if x = y then 1 else 0) =\n                         (case \\<pi> x of None \\<Rightarrow> \\<lambda>_. 0\n                          | Some i \\<Rightarrow>\n                              \\<lambda>y. if i = y then 1 else 0)\n                          b\n 4. \\<And>b a aa.\n       \\<lbrakk>inv_map \\<pi> b = Some a; \\<pi> x = Some aa\\<rbrakk>\n       \\<Longrightarrow> (case inv_map \\<pi> b of None \\<Rightarrow> 0\n                          | Some y \\<Rightarrow> if x = y then 1 else 0) =\n                         (case \\<pi> x of None \\<Rightarrow> \\<lambda>_. 0\n                          | Some i \\<Rightarrow>\n                              \\<lambda>y. if i = y then 1 else 0)\n                          b", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>inv_map \\<pi> b = None; \\<pi> x = Some b\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b.\n       \\<lbrakk>inv_map \\<pi> b = Some x; \\<pi> x = None\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>b aa.\n       \\<lbrakk>inv_map \\<pi> b = Some x; \\<pi> x = Some aa\\<rbrakk>\n       \\<Longrightarrow> aa = b\n 4. \\<And>b a.\n       \\<lbrakk>inv_map \\<pi> b = Some a; \\<pi> x = Some b;\n        x \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis inv_map_def option.simps(3) range_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>inv_map \\<pi> b = Some x; \\<pi> x = None\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b aa.\n       \\<lbrakk>inv_map \\<pi> b = Some x; \\<pi> x = Some aa\\<rbrakk>\n       \\<Longrightarrow> aa = b\n 3. \\<And>b a.\n       \\<lbrakk>inv_map \\<pi> b = Some a; \\<pi> x = Some b;\n        x \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis f_inv_into_f inv_map_def option.distinct(1) option.sel)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b aa.\n       \\<lbrakk>inv_map \\<pi> b = Some x; \\<pi> x = Some aa\\<rbrakk>\n       \\<Longrightarrow> aa = b\n 2. \\<And>b a.\n       \\<lbrakk>inv_map \\<pi> b = Some a; \\<pi> x = Some b;\n        x \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis f_inv_into_f inv_map_def option.sel option.simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a.\n       \\<lbrakk>inv_map \\<pi> b = Some a; \\<pi> x = Some b;\n        x \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis (no_types, lifting) assms f_inv_into_f inj_map_def inv_map_def option.sel option.simps(3))"], ["proof (state)\nthis:\n  C1 (ket ?x) =\n  (case \\<pi> ?x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "have \"C *\\<^sub>V ket x = (case \\<pi> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. C *\\<^sub>V ket x =\n    (case \\<pi> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "using ket.transfer[transfer_rule del] zero_ell2.transfer[transfer_rule del]"], ["proof (prove)\nusing this:\n  rel_fun (=) (pcr_ell2 (=)) (\\<lambda>x y. if x = y then 1 else 0) ket\n  pcr_ell2 (=) (\\<lambda>_. 0) 0\n\ngoal (1 subgoal):\n 1. C *\\<^sub>V ket x =\n    (case \\<pi> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "apply (tactic \\<open>all_tac\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. C *\\<^sub>V ket x =\n    (case \\<pi> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "apply (transfer fixing: \\<pi>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       C1 (ket x) =\n       (case \\<pi> x of None \\<Rightarrow> 0 | Some x \\<Rightarrow> ket x)", "by (fact C1_ket)"], ["proof (state)\nthis:\n  C *\\<^sub>V ket ?x =\n  (case \\<pi> ?x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "thus \"classical_operator_exists \\<pi>\""], ["proof (prove)\nusing this:\n  C *\\<^sub>V ket ?x =\n  (case \\<pi> ?x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)\n\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "by (rule classical_operator_existsI[of C])"], ["proof (state)\nthis:\n  classical_operator_exists \\<pi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma classical_operator_exists_finite[simp]: \"classical_operator_exists (\\<pi> :: _::finite \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator_exists \\<pi>", "unfolding classical_operator_exists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_extension_exists (range ket)\n     (\\<lambda>t.\n         case \\<pi> (inv ket t) of None \\<Rightarrow> 0\n         | Some x \\<Rightarrow> ket x)", "apply (rule cblinfun_extension_exists_finite_dim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. cindependent (range ket)\n 2. cspan (range ket) = UNIV", "using cindependent_ket"], ["proof (prove)\nusing this:\n  cindependent (range ket)\n\ngoal (2 subgoals):\n 1. cindependent (range ket)\n 2. cspan (range ket) = UNIV", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (range ket) = UNIV", "using finite_class.finite_UNIV finite_imageI closed_cspan_range_ket closure_finite_cspan"], ["proof (prove)\nusing this:\n  finite UNIV\n  finite ?F \\<Longrightarrow> finite (?h ` ?F)\n  closure (cspan (range ket)) = UNIV\n  finite ?T \\<Longrightarrow> closure (cspan ?T) = cspan ?T\n\ngoal (1 subgoal):\n 1. cspan (range ket) = UNIV", "by blast"], ["", "lemma classical_operator_ket:\n  assumes \"classical_operator_exists \\<pi>\"\n  shows \"(classical_operator \\<pi>) *\\<^sub>V (ket x) = (case \\<pi> x of Some i \\<Rightarrow> ket i | None \\<Rightarrow> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator \\<pi> *\\<^sub>V ket x =\n    (case \\<pi> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "unfolding classical_operator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Let (\\<lambda>t.\n            case \\<pi> (inv ket t) of None \\<Rightarrow> 0\n            | Some x \\<Rightarrow> ket x)\n     (cblinfun_extension (range ket)) *\\<^sub>V\n    ket x =\n    (case \\<pi> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "using f_inv_into_f ket_injective rangeI"], ["proof (prove)\nusing this:\n  ?y \\<in> ?f ` ?A \\<Longrightarrow> ?f (inv_into ?A ?f ?y) = ?y\n  (ket ?i = ket ?j) = (?i = ?j)\n  ?f ?x \\<in> range ?f\n\ngoal (1 subgoal):\n 1. Let (\\<lambda>t.\n            case \\<pi> (inv ket t) of None \\<Rightarrow> 0\n            | Some x \\<Rightarrow> ket x)\n     (cblinfun_extension (range ket)) *\\<^sub>V\n    ket x =\n    (case \\<pi> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "by (metis assms cblinfun_extension_apply classical_operator_exists_def)"], ["", "lemma classical_operator_ket_finite:\n  \"(classical_operator \\<pi>) *\\<^sub>V (ket (x::'a::finite)) = (case \\<pi> x of Some i \\<Rightarrow> ket i | None \\<Rightarrow> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator \\<pi> *\\<^sub>V ket x =\n    (case \\<pi> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "by (rule classical_operator_ket, simp)"], ["", "lemma classical_operator_adjoint[simp]:\n  fixes \\<pi> :: \"'a \\<Rightarrow> 'b option\"\n  assumes a1: \"inj_map \\<pi>\"\n  shows  \"(classical_operator \\<pi>)* = classical_operator (inv_map \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator \\<pi>* = classical_operator (inv_map \\<pi>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. classical_operator \\<pi>* = classical_operator (inv_map \\<pi>)", "define F where \"F = classical_operator (inv_map \\<pi>)\""], ["proof (state)\nthis:\n  F = classical_operator (inv_map \\<pi>)\n\ngoal (1 subgoal):\n 1. classical_operator \\<pi>* = classical_operator (inv_map \\<pi>)", "define G where \"G = classical_operator \\<pi>\""], ["proof (state)\nthis:\n  G = classical_operator \\<pi>\n\ngoal (1 subgoal):\n 1. classical_operator \\<pi>* = classical_operator (inv_map \\<pi>)", "have \"\\<langle>F *\\<^sub>V ket i, ket j\\<rangle> = \\<langle>ket i, G *\\<^sub>V ket j\\<rangle>\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "have w1: \"(classical_operator (inv_map \\<pi>)) *\\<^sub>V (ket i)\n     = (case inv_map \\<pi> i of Some k \\<Rightarrow> ket k | None \\<Rightarrow> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator (inv_map \\<pi>) *\\<^sub>V ket i =\n    (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some k \\<Rightarrow> ket k)", "by (simp add: classical_operator_ket classical_operator_exists_inj)"], ["proof (state)\nthis:\n  classical_operator (inv_map \\<pi>) *\\<^sub>V ket i =\n  (case inv_map \\<pi> i of None \\<Rightarrow> 0\n   | Some k \\<Rightarrow> ket k)\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "have w2: \"(classical_operator \\<pi>) *\\<^sub>V (ket j)\n     = (case \\<pi> j of Some k \\<Rightarrow> ket k | None \\<Rightarrow> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator \\<pi> *\\<^sub>V ket j =\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some k \\<Rightarrow> ket k)", "by (simp add: assms classical_operator_ket classical_operator_exists_inj)"], ["proof (state)\nthis:\n  classical_operator \\<pi> *\\<^sub>V ket j =\n  (case \\<pi> j of None \\<Rightarrow> 0 | Some k \\<Rightarrow> ket k)\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "have \"\\<langle>F *\\<^sub>V ket i, ket j\\<rangle> = \\<langle>classical_operator (inv_map \\<pi>) *\\<^sub>V ket i, ket j\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    (classical_operator (inv_map \\<pi>) *\\<^sub>V ket i) \\<bullet>\\<^sub>C\n    ket j", "unfolding F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (classical_operator (inv_map \\<pi>) *\\<^sub>V ket i) \\<bullet>\\<^sub>C\n    ket j =\n    (classical_operator (inv_map \\<pi>) *\\<^sub>V ket i) \\<bullet>\\<^sub>C\n    ket j", "by blast"], ["proof (state)\nthis:\n  (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n  (classical_operator (inv_map \\<pi>) *\\<^sub>V ket i) \\<bullet>\\<^sub>C\n  ket j\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "also"], ["proof (state)\nthis:\n  (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n  (classical_operator (inv_map \\<pi>) *\\<^sub>V ket i) \\<bullet>\\<^sub>C\n  ket j\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "have \"\\<dots> = \\<langle>(case inv_map \\<pi> i of Some k \\<Rightarrow> ket k | None \\<Rightarrow> 0), ket j\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (classical_operator (inv_map \\<pi>) *\\<^sub>V ket i) \\<bullet>\\<^sub>C\n    ket j =\n    (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some k \\<Rightarrow> ket k) \\<bullet>\\<^sub>C\n    ket j", "using w1"], ["proof (prove)\nusing this:\n  classical_operator (inv_map \\<pi>) *\\<^sub>V ket i =\n  (case inv_map \\<pi> i of None \\<Rightarrow> 0\n   | Some k \\<Rightarrow> ket k)\n\ngoal (1 subgoal):\n 1. (classical_operator (inv_map \\<pi>) *\\<^sub>V ket i) \\<bullet>\\<^sub>C\n    ket j =\n    (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some k \\<Rightarrow> ket k) \\<bullet>\\<^sub>C\n    ket j", "by simp"], ["proof (state)\nthis:\n  (classical_operator (inv_map \\<pi>) *\\<^sub>V ket i) \\<bullet>\\<^sub>C\n  ket j =\n  (case inv_map \\<pi> i of None \\<Rightarrow> 0\n   | Some k \\<Rightarrow> ket k) \\<bullet>\\<^sub>C\n  ket j\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "also"], ["proof (state)\nthis:\n  (classical_operator (inv_map \\<pi>) *\\<^sub>V ket i) \\<bullet>\\<^sub>C\n  ket j =\n  (case inv_map \\<pi> i of None \\<Rightarrow> 0\n   | Some k \\<Rightarrow> ket k) \\<bullet>\\<^sub>C\n  ket j\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "have \"\\<dots> = \\<langle>ket i, (case \\<pi> j of Some k \\<Rightarrow> ket k | None \\<Rightarrow> 0)\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some k \\<Rightarrow> ket k) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some k \\<Rightarrow> ket k)", "proof(induction \"inv_map \\<pi> i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. None = inv_map \\<pi> i \\<Longrightarrow>\n    (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n 2. \\<And>option.\n       Some option = inv_map \\<pi> i \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "case None"], ["proof (state)\nthis:\n  None = inv_map \\<pi> i\n\ngoal (2 subgoals):\n 1. None = inv_map \\<pi> i \\<Longrightarrow>\n    (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n 2. \\<And>option.\n       Some option = inv_map \\<pi> i \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "hence pi1: \"None = inv_map \\<pi> i\""], ["proof (prove)\nusing this:\n  None = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. None = inv_map \\<pi> i", "."], ["proof (state)\nthis:\n  None = inv_map \\<pi> i\n\ngoal (2 subgoals):\n 1. None = inv_map \\<pi> i \\<Longrightarrow>\n    (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n 2. \\<And>option.\n       Some option = inv_map \\<pi> i \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "proof (induction \"\\<pi> j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. None = \\<pi> j \\<Longrightarrow>\n    (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n 2. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "case None"], ["proof (state)\nthis:\n  None = \\<pi> j\n\ngoal (2 subgoals):\n 1. None = \\<pi> j \\<Longrightarrow>\n    (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n 2. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "thus ?case"], ["proof (prove)\nusing this:\n  None = \\<pi> j\n\ngoal (1 subgoal):\n 1. (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "using pi1"], ["proof (prove)\nusing this:\n  None = \\<pi> j\n  None = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "by auto"], ["proof (state)\nthis:\n  (case inv_map \\<pi> i of None \\<Rightarrow> 0\n   | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n  ket j =\n  ket i \\<bullet>\\<^sub>C\n  (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "case (Some c)"], ["proof (state)\nthis:\n  Some c = \\<pi> j\n\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "have \"c \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> i", "proof(rule classical)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> i \\<Longrightarrow> c \\<noteq> i", "assume \"\\<not>(c \\<noteq> i)\""], ["proof (state)\nthis:\n  \\<not> c \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> i \\<Longrightarrow> c \\<noteq> i", "hence \"c = i\""], ["proof (prove)\nusing this:\n  \\<not> c \\<noteq> i\n\ngoal (1 subgoal):\n 1. c = i", "by blast"], ["proof (state)\nthis:\n  c = i\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> i \\<Longrightarrow> c \\<noteq> i", "hence \"inv_map \\<pi> c = inv_map \\<pi> i\""], ["proof (prove)\nusing this:\n  c = i\n\ngoal (1 subgoal):\n 1. inv_map \\<pi> c = inv_map \\<pi> i", "by simp"], ["proof (state)\nthis:\n  inv_map \\<pi> c = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> i \\<Longrightarrow> c \\<noteq> i", "hence \"inv_map \\<pi> c = None\""], ["proof (prove)\nusing this:\n  inv_map \\<pi> c = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. inv_map \\<pi> c = None", "by (simp add: pi1)"], ["proof (state)\nthis:\n  inv_map \\<pi> c = None\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> i \\<Longrightarrow> c \\<noteq> i", "moreover"], ["proof (state)\nthis:\n  inv_map \\<pi> c = None\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> i \\<Longrightarrow> c \\<noteq> i", "have \"inv_map \\<pi> c = Some j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_map \\<pi> c = Some j", "using Some.hyps"], ["proof (prove)\nusing this:\n  Some c = \\<pi> j\n\ngoal (1 subgoal):\n 1. inv_map \\<pi> c = Some j", "unfolding inv_map_def"], ["proof (prove)\nusing this:\n  Some c = \\<pi> j\n\ngoal (1 subgoal):\n 1. (if Some c \\<in> range \\<pi> then Some (inv \\<pi> (Some c)) else None) =\n    Some j", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some c = \\<pi> j \\<Longrightarrow> inv \\<pi> (\\<pi> j) = j", "by (metis a1 f_inv_into_f inj_map_def option.distinct(1) rangeI)"], ["proof (state)\nthis:\n  inv_map \\<pi> c = Some j\n\ngoal (1 subgoal):\n 1. \\<not> c \\<noteq> i \\<Longrightarrow> c \\<noteq> i", "ultimately"], ["proof (chain)\npicking this:\n  inv_map \\<pi> c = None\n  inv_map \\<pi> c = Some j", "show ?thesis"], ["proof (prove)\nusing this:\n  inv_map \\<pi> c = None\n  inv_map \\<pi> c = Some j\n\ngoal (1 subgoal):\n 1. c \\<noteq> i", "by simp"], ["proof (state)\nthis:\n  c \\<noteq> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  c \\<noteq> i\n\ngoal (1 subgoal):\n 1. (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "by (metis None.hyps Some.hyps cinner_zero_left orthogonal_ket option.simps(4) \n              option.simps(5))"], ["proof (state)\nthis:\n  (case inv_map \\<pi> i of None \\<Rightarrow> 0\n   | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n  ket j =\n  ket i \\<bullet>\\<^sub>C\n  (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case inv_map \\<pi> i of None \\<Rightarrow> 0\n   | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n  ket j =\n  ket i \\<bullet>\\<^sub>C\n  (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = inv_map \\<pi> i \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = inv_map \\<pi> i \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "case (Some d)"], ["proof (state)\nthis:\n  Some d = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = inv_map \\<pi> i \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "hence s1: \"Some d = inv_map \\<pi> i\""], ["proof (prove)\nusing this:\n  Some d = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. Some d = inv_map \\<pi> i", "."], ["proof (state)\nthis:\n  Some d = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = inv_map \\<pi> i \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "show \"\\<langle>case inv_map \\<pi> i of \n            None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a, ket j\\<rangle> =\n       \\<langle>ket i, case \\<pi> j of \n            None \\<Rightarrow> 0 \n        | Some a \\<Rightarrow> ket a\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "proof(induction \"\\<pi> j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. None = \\<pi> j \\<Longrightarrow>\n    (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n 2. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "case None"], ["proof (state)\nthis:\n  None = \\<pi> j\n\ngoal (2 subgoals):\n 1. None = \\<pi> j \\<Longrightarrow>\n    (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n 2. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "have \"d \\<noteq> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<noteq> j", "proof(rule classical)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d \\<noteq> j \\<Longrightarrow> d \\<noteq> j", "assume \"\\<not>(d \\<noteq> j)\""], ["proof (state)\nthis:\n  \\<not> d \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<not> d \\<noteq> j \\<Longrightarrow> d \\<noteq> j", "hence \"d = j\""], ["proof (prove)\nusing this:\n  \\<not> d \\<noteq> j\n\ngoal (1 subgoal):\n 1. d = j", "by blast"], ["proof (state)\nthis:\n  d = j\n\ngoal (1 subgoal):\n 1. \\<not> d \\<noteq> j \\<Longrightarrow> d \\<noteq> j", "hence \"\\<pi> d = \\<pi> j\""], ["proof (prove)\nusing this:\n  d = j\n\ngoal (1 subgoal):\n 1. \\<pi> d = \\<pi> j", "by simp"], ["proof (state)\nthis:\n  \\<pi> d = \\<pi> j\n\ngoal (1 subgoal):\n 1. \\<not> d \\<noteq> j \\<Longrightarrow> d \\<noteq> j", "hence \"\\<pi> d = None\""], ["proof (prove)\nusing this:\n  \\<pi> d = \\<pi> j\n\ngoal (1 subgoal):\n 1. \\<pi> d = None", "by (simp add: None.hyps)"], ["proof (state)\nthis:\n  \\<pi> d = None\n\ngoal (1 subgoal):\n 1. \\<not> d \\<noteq> j \\<Longrightarrow> d \\<noteq> j", "moreover"], ["proof (state)\nthis:\n  \\<pi> d = None\n\ngoal (1 subgoal):\n 1. \\<not> d \\<noteq> j \\<Longrightarrow> d \\<noteq> j", "have \"\\<pi> d = Some i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> d = Some i", "using Some.hyps"], ["proof (prove)\nusing this:\n  Some d = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<pi> d = Some i", "unfolding inv_map_def"], ["proof (prove)\nusing this:\n  Some d =\n  (if Some i \\<in> range \\<pi> then Some (inv \\<pi> (Some i)) else None)\n\ngoal (1 subgoal):\n 1. \\<pi> d = Some i", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some d =\n    (if Some i \\<in> range \\<pi> then Some (inv \\<pi> (Some i))\n     else None) \\<Longrightarrow>\n    \\<pi> d = Some i", "by (metis f_inv_into_f option.distinct(1) option.inject)"], ["proof (state)\nthis:\n  \\<pi> d = Some i\n\ngoal (1 subgoal):\n 1. \\<not> d \\<noteq> j \\<Longrightarrow> d \\<noteq> j", "ultimately"], ["proof (chain)\npicking this:\n  \\<pi> d = None\n  \\<pi> d = Some i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pi> d = None\n  \\<pi> d = Some i\n\ngoal (1 subgoal):\n 1. d \\<noteq> j", "by simp"], ["proof (state)\nthis:\n  d \\<noteq> j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d \\<noteq> j\n\ngoal (2 subgoals):\n 1. None = \\<pi> j \\<Longrightarrow>\n    (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n 2. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "thus ?case"], ["proof (prove)\nusing this:\n  d \\<noteq> j\n\ngoal (1 subgoal):\n 1. (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "by (metis None.hyps Some.hyps cinner_zero_right orthogonal_ket option.case_eq_if \n              option.simps(5))"], ["proof (state)\nthis:\n  (case inv_map \\<pi> i of None \\<Rightarrow> 0\n   | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n  ket j =\n  ket i \\<bullet>\\<^sub>C\n  (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "case (Some c)"], ["proof (state)\nthis:\n  Some c = \\<pi> j\n\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "hence s2: \"\\<pi> j = Some c\""], ["proof (prove)\nusing this:\n  Some c = \\<pi> j\n\ngoal (1 subgoal):\n 1. \\<pi> j = Some c", "by simp"], ["proof (state)\nthis:\n  \\<pi> j = Some c\n\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "have \"\\<langle>ket d, ket j\\<rangle> = \\<langle>ket i, ket c\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "proof(cases \"\\<pi> j = Some i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<pi> j = Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c\n 2. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "case True"], ["proof (state)\nthis:\n  \\<pi> j = Some i\n\ngoal (2 subgoals):\n 1. \\<pi> j = Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c\n 2. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "hence ij: \"Some j = inv_map \\<pi> i\""], ["proof (prove)\nusing this:\n  \\<pi> j = Some i\n\ngoal (1 subgoal):\n 1. Some j = inv_map \\<pi> i", "unfolding inv_map_def"], ["proof (prove)\nusing this:\n  \\<pi> j = Some i\n\ngoal (1 subgoal):\n 1. Some j =\n    (if Some i \\<in> range \\<pi> then Some (inv \\<pi> (Some i)) else None)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<pi> j = \\<pi> x; Some i = \\<pi> x\\<rbrakk>\n       \\<Longrightarrow> j = inv \\<pi> (\\<pi> x)\n 2. \\<pi> j = Some i \\<Longrightarrow> Some i \\<in> range \\<pi>", "apply (metis a1 f_inv_into_f inj_map_def option.discI range_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> j = Some i \\<Longrightarrow> Some i \\<in> range \\<pi>", "by (metis range_eqI)"], ["proof (state)\nthis:\n  Some j = inv_map \\<pi> i\n\ngoal (2 subgoals):\n 1. \\<pi> j = Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c\n 2. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "have \"i = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = c", "using True s2"], ["proof (prove)\nusing this:\n  \\<pi> j = Some i\n  \\<pi> j = Some c\n\ngoal (1 subgoal):\n 1. i = c", "by auto"], ["proof (state)\nthis:\n  i = c\n\ngoal (2 subgoals):\n 1. \\<pi> j = Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c\n 2. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "moreover"], ["proof (state)\nthis:\n  i = c\n\ngoal (2 subgoals):\n 1. \\<pi> j = Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c\n 2. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "have \"j = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j = d", "by (metis option.inject s1 ij)"], ["proof (state)\nthis:\n  j = d\n\ngoal (2 subgoals):\n 1. \\<pi> j = Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c\n 2. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "ultimately"], ["proof (chain)\npicking this:\n  i = c\n  j = d", "show ?thesis"], ["proof (prove)\nusing this:\n  i = c\n  j = d\n\ngoal (1 subgoal):\n 1. ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "by (simp add: cinner_ket_same)"], ["proof (state)\nthis:\n  ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c\n\ngoal (1 subgoal):\n 1. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "case False"], ["proof (state)\nthis:\n  \\<pi> j \\<noteq> Some i\n\ngoal (1 subgoal):\n 1. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "moreover"], ["proof (state)\nthis:\n  \\<pi> j \\<noteq> Some i\n\ngoal (1 subgoal):\n 1. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "have \"\\<pi> d = Some i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> d = Some i", "using s1"], ["proof (prove)\nusing this:\n  Some d = inv_map \\<pi> i\n\ngoal (1 subgoal):\n 1. \\<pi> d = Some i", "unfolding inv_map_def"], ["proof (prove)\nusing this:\n  Some d =\n  (if Some i \\<in> range \\<pi> then Some (inv \\<pi> (Some i)) else None)\n\ngoal (1 subgoal):\n 1. \\<pi> d = Some i", "by (metis f_inv_into_f option.distinct(1) option.inject)"], ["proof (state)\nthis:\n  \\<pi> d = Some i\n\ngoal (1 subgoal):\n 1. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "ultimately"], ["proof (chain)\npicking this:\n  \\<pi> j \\<noteq> Some i\n  \\<pi> d = Some i", "have \"j \\<noteq> d\""], ["proof (prove)\nusing this:\n  \\<pi> j \\<noteq> Some i\n  \\<pi> d = Some i\n\ngoal (1 subgoal):\n 1. j \\<noteq> d", "by auto"], ["proof (state)\nthis:\n  j \\<noteq> d\n\ngoal (1 subgoal):\n 1. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "moreover"], ["proof (state)\nthis:\n  j \\<noteq> d\n\ngoal (1 subgoal):\n 1. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "have \"i \\<noteq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> c", "using False s2"], ["proof (prove)\nusing this:\n  \\<pi> j \\<noteq> Some i\n  \\<pi> j = Some c\n\ngoal (1 subgoal):\n 1. i \\<noteq> c", "by auto"], ["proof (state)\nthis:\n  i \\<noteq> c\n\ngoal (1 subgoal):\n 1. \\<pi> j \\<noteq> Some i \\<Longrightarrow>\n    ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "ultimately"], ["proof (chain)\npicking this:\n  j \\<noteq> d\n  i \\<noteq> c", "show ?thesis"], ["proof (prove)\nusing this:\n  j \\<noteq> d\n  i \\<noteq> c\n\ngoal (1 subgoal):\n 1. ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c", "by (metis orthogonal_ket)"], ["proof (state)\nthis:\n  ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c\n\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "hence \"\\<langle>case Some d of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a, ket j\\<rangle> =\n       \\<langle>ket i, case Some c of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a\\<rangle>\""], ["proof (prove)\nusing this:\n  ket d \\<bullet>\\<^sub>C ket j = ket i \\<bullet>\\<^sub>C ket c\n\ngoal (1 subgoal):\n 1. (case Some d of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case Some c of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "by simp"], ["proof (state)\nthis:\n  (case Some d of None \\<Rightarrow> 0\n   | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n  ket j =\n  ket i \\<bullet>\\<^sub>C\n  (case Some c of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n\ngoal (1 subgoal):\n 1. \\<And>option.\n       Some option = \\<pi> j \\<Longrightarrow>\n       (case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n       ket j =\n       ket i \\<bullet>\\<^sub>C\n       (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "thus \"\\<langle>case inv_map \\<pi> i of None \\<Rightarrow> 0\n        | Some a \\<Rightarrow> ket a, ket j\\<rangle> =\n       \\<langle>ket i, case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a\\<rangle>\""], ["proof (prove)\nusing this:\n  (case Some d of None \\<Rightarrow> 0\n   | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n  ket j =\n  ket i \\<bullet>\\<^sub>C\n  (case Some c of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n\ngoal (1 subgoal):\n 1. (case inv_map \\<pi> i of None \\<Rightarrow> 0\n     | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n    ket j =\n    ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)", "by (simp add: Some.hyps s1)"], ["proof (state)\nthis:\n  (case inv_map \\<pi> i of None \\<Rightarrow> 0\n   | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n  ket j =\n  ket i \\<bullet>\\<^sub>C\n  (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case inv_map \\<pi> i of None \\<Rightarrow> 0\n   | Some a \\<Rightarrow> ket a) \\<bullet>\\<^sub>C\n  ket j =\n  ket i \\<bullet>\\<^sub>C\n  (case \\<pi> j of None \\<Rightarrow> 0 | Some a \\<Rightarrow> ket a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (case inv_map \\<pi> i of None \\<Rightarrow> 0\n   | Some k \\<Rightarrow> ket k) \\<bullet>\\<^sub>C\n  ket j =\n  ket i \\<bullet>\\<^sub>C\n  (case \\<pi> j of None \\<Rightarrow> 0 | Some k \\<Rightarrow> ket k)\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "also"], ["proof (state)\nthis:\n  (case inv_map \\<pi> i of None \\<Rightarrow> 0\n   | Some k \\<Rightarrow> ket k) \\<bullet>\\<^sub>C\n  ket j =\n  ket i \\<bullet>\\<^sub>C\n  (case \\<pi> j of None \\<Rightarrow> 0 | Some k \\<Rightarrow> ket k)\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "have \"\\<dots> = \\<langle>ket i, classical_operator \\<pi> *\\<^sub>V ket j\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C\n    (case \\<pi> j of None \\<Rightarrow> 0 | Some k \\<Rightarrow> ket k) =\n    ket i \\<bullet>\\<^sub>C (classical_operator \\<pi> *\\<^sub>V ket j)", "by (simp add: w2)"], ["proof (state)\nthis:\n  ket i \\<bullet>\\<^sub>C\n  (case \\<pi> j of None \\<Rightarrow> 0 | Some k \\<Rightarrow> ket k) =\n  ket i \\<bullet>\\<^sub>C (classical_operator \\<pi> *\\<^sub>V ket j)\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "also"], ["proof (state)\nthis:\n  ket i \\<bullet>\\<^sub>C\n  (case \\<pi> j of None \\<Rightarrow> 0 | Some k \\<Rightarrow> ket k) =\n  ket i \\<bullet>\\<^sub>C (classical_operator \\<pi> *\\<^sub>V ket j)\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "have \"\\<dots> = \\<langle>ket i, G *\\<^sub>V ket j\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C (classical_operator \\<pi> *\\<^sub>V ket j) =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "unfolding G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket i \\<bullet>\\<^sub>C (classical_operator \\<pi> *\\<^sub>V ket j) =\n    ket i \\<bullet>\\<^sub>C (classical_operator \\<pi> *\\<^sub>V ket j)", "by blast"], ["proof (state)\nthis:\n  ket i \\<bullet>\\<^sub>C (classical_operator \\<pi> *\\<^sub>V ket j) =\n  ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "finally"], ["proof (chain)\npicking this:\n  (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n  ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "show ?thesis"], ["proof (prove)\nusing this:\n  (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n  ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)\n\ngoal (1 subgoal):\n 1. (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n    ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)", "."], ["proof (state)\nthis:\n  (F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n  ket i \\<bullet>\\<^sub>C (G *\\<^sub>V ket j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (F *\\<^sub>V ket ?i) \\<bullet>\\<^sub>C ket ?j =\n  ket ?i \\<bullet>\\<^sub>C (G *\\<^sub>V ket ?j)\n\ngoal (1 subgoal):\n 1. classical_operator \\<pi>* = classical_operator (inv_map \\<pi>)", "hence \"G* = F\""], ["proof (prove)\nusing this:\n  (F *\\<^sub>V ket ?i) \\<bullet>\\<^sub>C ket ?j =\n  ket ?i \\<bullet>\\<^sub>C (G *\\<^sub>V ket ?j)\n\ngoal (1 subgoal):\n 1. G* = F", "using cinner_ket_adjointI"], ["proof (prove)\nusing this:\n  (F *\\<^sub>V ket ?i) \\<bullet>\\<^sub>C ket ?j =\n  ket ?i \\<bullet>\\<^sub>C (G *\\<^sub>V ket ?j)\n  (\\<And>i j.\n      (?F *\\<^sub>V ket i) \\<bullet>\\<^sub>C ket j =\n      ket i \\<bullet>\\<^sub>C (?G *\\<^sub>V ket j)) \\<Longrightarrow>\n  ?F = ?G*\n\ngoal (1 subgoal):\n 1. G* = F", "by auto"], ["proof (state)\nthis:\n  G* = F\n\ngoal (1 subgoal):\n 1. classical_operator \\<pi>* = classical_operator (inv_map \\<pi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  G* = F\n\ngoal (1 subgoal):\n 1. classical_operator \\<pi>* = classical_operator (inv_map \\<pi>)", "unfolding G_def F_def"], ["proof (prove)\nusing this:\n  classical_operator \\<pi>* = classical_operator (inv_map \\<pi>)\n\ngoal (1 subgoal):\n 1. classical_operator \\<pi>* = classical_operator (inv_map \\<pi>)", "."], ["proof (state)\nthis:\n  classical_operator \\<pi>* = classical_operator (inv_map \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  fixes \\<pi>::\"'b \\<Rightarrow> 'c option\" and \\<rho>::\"'a \\<Rightarrow> 'b option\"\n  assumes \"classical_operator_exists \\<pi>\"\n  assumes \"classical_operator_exists \\<rho>\"\n  shows classical_operator_exists_comp[simp]: \"classical_operator_exists (\\<pi> \\<circ>\\<^sub>m \\<rho>)\"\n    and classical_operator_mult[simp]: \"classical_operator \\<pi> o\\<^sub>C\\<^sub>L classical_operator \\<rho> = classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator_exists (\\<pi> \\<circ>\\<^sub>m \\<rho>) &&&\n    classical_operator \\<pi> o\\<^sub>C\\<^sub>L classical_operator \\<rho> =\n    classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. classical_operator_exists (\\<pi> \\<circ>\\<^sub>m \\<rho>)\n 2. classical_operator \\<pi> o\\<^sub>C\\<^sub>L classical_operator \\<rho> =\n    classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>)", "define C\\<pi> C\\<rho> C\\<pi>\\<rho> where \"C\\<pi> = classical_operator \\<pi>\" and \"C\\<rho> = classical_operator \\<rho>\" \n    and \"C\\<pi>\\<rho> = classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>)\""], ["proof (state)\nthis:\n  C\\<pi> = classical_operator \\<pi>\n  C\\<rho> = classical_operator \\<rho>\n  C\\<pi>\\<rho> = classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>)\n\ngoal (2 subgoals):\n 1. classical_operator_exists (\\<pi> \\<circ>\\<^sub>m \\<rho>)\n 2. classical_operator \\<pi> o\\<^sub>C\\<^sub>L classical_operator \\<rho> =\n    classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>)", "have C\\<pi>x: \"C\\<pi> *\\<^sub>V (ket x) = (case \\<pi> x of Some i \\<Rightarrow> ket i | None \\<Rightarrow> 0)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. C\\<pi> *\\<^sub>V ket x =\n    (case \\<pi> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "unfolding C\\<pi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator \\<pi> *\\<^sub>V ket x =\n    (case \\<pi> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "using \\<open>classical_operator_exists \\<pi>\\<close>"], ["proof (prove)\nusing this:\n  classical_operator_exists \\<pi>\n\ngoal (1 subgoal):\n 1. classical_operator \\<pi> *\\<^sub>V ket x =\n    (case \\<pi> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "by (rule classical_operator_ket)"], ["proof (state)\nthis:\n  C\\<pi> *\\<^sub>V ket ?x =\n  (case \\<pi> ?x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)\n\ngoal (2 subgoals):\n 1. classical_operator_exists (\\<pi> \\<circ>\\<^sub>m \\<rho>)\n 2. classical_operator \\<pi> o\\<^sub>C\\<^sub>L classical_operator \\<rho> =\n    classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>)", "have C\\<rho>x: \"C\\<rho> *\\<^sub>V (ket x) = (case \\<rho> x of Some i \\<Rightarrow> ket i | None \\<Rightarrow> 0)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. C\\<rho> *\\<^sub>V ket x =\n    (case \\<rho> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "unfolding C\\<rho>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator \\<rho> *\\<^sub>V ket x =\n    (case \\<rho> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "using \\<open>classical_operator_exists \\<rho>\\<close>"], ["proof (prove)\nusing this:\n  classical_operator_exists \\<rho>\n\ngoal (1 subgoal):\n 1. classical_operator \\<rho> *\\<^sub>V ket x =\n    (case \\<rho> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)", "by (rule classical_operator_ket)"], ["proof (state)\nthis:\n  C\\<rho> *\\<^sub>V ket ?x =\n  (case \\<rho> ?x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)\n\ngoal (2 subgoals):\n 1. classical_operator_exists (\\<pi> \\<circ>\\<^sub>m \\<rho>)\n 2. classical_operator \\<pi> o\\<^sub>C\\<^sub>L classical_operator \\<rho> =\n    classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>)", "have C\\<pi>\\<rho>x': \"(C\\<pi> o\\<^sub>C\\<^sub>L C\\<rho>) *\\<^sub>V (ket x) = (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) x of Some i \\<Rightarrow> ket i | None \\<Rightarrow> 0)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (C\\<pi> o\\<^sub>C\\<^sub>L C\\<rho>) *\\<^sub>V ket x =\n    (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) x of None \\<Rightarrow> 0\n     | Some i \\<Rightarrow> ket i)", "apply (simp add: scaleC_cblinfun.rep_eq C\\<rho>x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. C\\<pi> *\\<^sub>V\n    (case \\<rho> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i) =\n    (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) x of None \\<Rightarrow> 0\n     | Some i \\<Rightarrow> ket i)", "apply (cases \"\\<rho> x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<rho> x = None \\<Longrightarrow>\n    C\\<pi> *\\<^sub>V\n    (case \\<rho> x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i) =\n    (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) x of None \\<Rightarrow> 0\n     | Some i \\<Rightarrow> ket i)\n 2. \\<And>a.\n       \\<rho> x = Some a \\<Longrightarrow>\n       C\\<pi> *\\<^sub>V\n       (case \\<rho> x of None \\<Rightarrow> 0\n        | Some i \\<Rightarrow> ket i) =\n       (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) x of None \\<Rightarrow> 0\n        | Some i \\<Rightarrow> ket i)", "by (auto simp: C\\<pi>x)"], ["proof (state)\nthis:\n  (C\\<pi> o\\<^sub>C\\<^sub>L C\\<rho>) *\\<^sub>V ket ?x =\n  (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) ?x of None \\<Rightarrow> 0\n   | Some i \\<Rightarrow> ket i)\n\ngoal (2 subgoals):\n 1. classical_operator_exists (\\<pi> \\<circ>\\<^sub>m \\<rho>)\n 2. classical_operator \\<pi> o\\<^sub>C\\<^sub>L classical_operator \\<rho> =\n    classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>)", "thus \\<open>classical_operator_exists (\\<pi> \\<circ>\\<^sub>m \\<rho>)\\<close>"], ["proof (prove)\nusing this:\n  (C\\<pi> o\\<^sub>C\\<^sub>L C\\<rho>) *\\<^sub>V ket ?x =\n  (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) ?x of None \\<Rightarrow> 0\n   | Some i \\<Rightarrow> ket i)\n\ngoal (1 subgoal):\n 1. classical_operator_exists (\\<pi> \\<circ>\\<^sub>m \\<rho>)", "by (rule classical_operator_existsI)"], ["proof (state)\nthis:\n  classical_operator_exists (\\<pi> \\<circ>\\<^sub>m \\<rho>)\n\ngoal (1 subgoal):\n 1. classical_operator \\<pi> o\\<^sub>C\\<^sub>L classical_operator \\<rho> =\n    classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>)", "hence \"C\\<pi>\\<rho> *\\<^sub>V (ket x) = (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) x of Some i \\<Rightarrow> ket i | None \\<Rightarrow> 0)\" for x"], ["proof (prove)\nusing this:\n  classical_operator_exists (\\<pi> \\<circ>\\<^sub>m \\<rho>)\n\ngoal (1 subgoal):\n 1. C\\<pi>\\<rho> *\\<^sub>V ket x =\n    (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) x of None \\<Rightarrow> 0\n     | Some i \\<Rightarrow> ket i)", "unfolding C\\<pi>\\<rho>_def"], ["proof (prove)\nusing this:\n  classical_operator_exists (\\<pi> \\<circ>\\<^sub>m \\<rho>)\n\ngoal (1 subgoal):\n 1. classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>) *\\<^sub>V ket x =\n    (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) x of None \\<Rightarrow> 0\n     | Some i \\<Rightarrow> ket i)", "by (rule classical_operator_ket)"], ["proof (state)\nthis:\n  C\\<pi>\\<rho> *\\<^sub>V ket ?x =\n  (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) ?x of None \\<Rightarrow> 0\n   | Some i \\<Rightarrow> ket i)\n\ngoal (1 subgoal):\n 1. classical_operator \\<pi> o\\<^sub>C\\<^sub>L classical_operator \\<rho> =\n    classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>)", "with C\\<pi>\\<rho>x'"], ["proof (chain)\npicking this:\n  (C\\<pi> o\\<^sub>C\\<^sub>L C\\<rho>) *\\<^sub>V ket ?x =\n  (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) ?x of None \\<Rightarrow> 0\n   | Some i \\<Rightarrow> ket i)\n  C\\<pi>\\<rho> *\\<^sub>V ket ?x =\n  (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) ?x of None \\<Rightarrow> 0\n   | Some i \\<Rightarrow> ket i)", "have \"(C\\<pi> o\\<^sub>C\\<^sub>L C\\<rho>) *\\<^sub>V (ket x) = C\\<pi>\\<rho> *\\<^sub>V (ket x)\" for x"], ["proof (prove)\nusing this:\n  (C\\<pi> o\\<^sub>C\\<^sub>L C\\<rho>) *\\<^sub>V ket ?x =\n  (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) ?x of None \\<Rightarrow> 0\n   | Some i \\<Rightarrow> ket i)\n  C\\<pi>\\<rho> *\\<^sub>V ket ?x =\n  (case (\\<pi> \\<circ>\\<^sub>m \\<rho>) ?x of None \\<Rightarrow> 0\n   | Some i \\<Rightarrow> ket i)\n\ngoal (1 subgoal):\n 1. (C\\<pi> o\\<^sub>C\\<^sub>L C\\<rho>) *\\<^sub>V ket x =\n    C\\<pi>\\<rho> *\\<^sub>V ket x", "by simp"], ["proof (state)\nthis:\n  (C\\<pi> o\\<^sub>C\\<^sub>L C\\<rho>) *\\<^sub>V ket ?x =\n  C\\<pi>\\<rho> *\\<^sub>V ket ?x\n\ngoal (1 subgoal):\n 1. classical_operator \\<pi> o\\<^sub>C\\<^sub>L classical_operator \\<rho> =\n    classical_operator (\\<pi> \\<circ>\\<^sub>m \\<rho>)", "thus \"C\\<pi> o\\<^sub>C\\<^sub>L C\\<rho> = C\\<pi>\\<rho>\""], ["proof (prove)\nusing this:\n  (C\\<pi> o\\<^sub>C\\<^sub>L C\\<rho>) *\\<^sub>V ket ?x =\n  C\\<pi>\\<rho> *\\<^sub>V ket ?x\n\ngoal (1 subgoal):\n 1. C\\<pi> o\\<^sub>C\\<^sub>L C\\<rho> = C\\<pi>\\<rho>", "by (simp add: equal_ket)"], ["proof (state)\nthis:\n  C\\<pi> o\\<^sub>C\\<^sub>L C\\<rho> = C\\<pi>\\<rho>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma classical_operator_Some[simp]: \"classical_operator (Some::'a\\<Rightarrow>_) = id_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator Some = id_cblinfun", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. classical_operator Some = id_cblinfun", "have \"(classical_operator Some) *\\<^sub>V (ket i)  = id_cblinfun *\\<^sub>V (ket i)\"\n    for i::'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator Some *\\<^sub>V ket i = id_cblinfun *\\<^sub>V ket i", "apply (subst classical_operator_ket)"], ["proof (prove)\ngoal (2 subgoals):\n 1. classical_operator_exists Some\n 2. (case Some i of None \\<Rightarrow> 0 | Some x \\<Rightarrow> ket x) =\n    id_cblinfun *\\<^sub>V ket i", "apply (rule classical_operator_exists_inj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_map Some\n 2. (case Some i of None \\<Rightarrow> 0 | Some x \\<Rightarrow> ket x) =\n    id_cblinfun *\\<^sub>V ket i", "by auto"], ["proof (state)\nthis:\n  classical_operator Some *\\<^sub>V ket ?i = id_cblinfun *\\<^sub>V ket ?i\n\ngoal (1 subgoal):\n 1. classical_operator Some = id_cblinfun", "thus ?thesis"], ["proof (prove)\nusing this:\n  classical_operator Some *\\<^sub>V ket ?i = id_cblinfun *\\<^sub>V ket ?i\n\ngoal (1 subgoal):\n 1. classical_operator Some = id_cblinfun", "using equal_ket[where A = \"classical_operator (Some::'a \\<Rightarrow> _ option)\"\n        and B = \"id_cblinfun::'a ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L _\"]"], ["proof (prove)\nusing this:\n  classical_operator Some *\\<^sub>V ket ?i = id_cblinfun *\\<^sub>V ket ?i\n  (\\<And>x.\n      classical_operator Some *\\<^sub>V ket x =\n      id_cblinfun *\\<^sub>V ket x) \\<Longrightarrow>\n  classical_operator Some = id_cblinfun\n\ngoal (1 subgoal):\n 1. classical_operator Some = id_cblinfun", "by blast"], ["proof (state)\nthis:\n  classical_operator Some = id_cblinfun\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isometry_classical_operator[simp]:\n  fixes \\<pi>::\"'a \\<Rightarrow> 'b\"\n  assumes a1: \"inj \\<pi>\"\n  shows \"isometry (classical_operator (Some o \\<pi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isometry (classical_operator (Some \\<circ> \\<pi>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isometry (classical_operator (Some \\<circ> \\<pi>))", "have b0: \"inj_map (Some \\<circ> \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_map (Some \\<circ> \\<pi>)", "by (simp add: a1)"], ["proof (state)\nthis:\n  inj_map (Some \\<circ> \\<pi>)\n\ngoal (1 subgoal):\n 1. isometry (classical_operator (Some \\<circ> \\<pi>))", "have b0': \"inj_map (inv_map (Some \\<circ> \\<pi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_map (inv_map (Some \\<circ> \\<pi>))", "by simp"], ["proof (state)\nthis:\n  inj_map (inv_map (Some \\<circ> \\<pi>))\n\ngoal (1 subgoal):\n 1. isometry (classical_operator (Some \\<circ> \\<pi>))", "have b1: \"inv_map (Some \\<circ> \\<pi>) \\<circ>\\<^sub>m (Some \\<circ> \\<pi>) = Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_map (Some \\<circ> \\<pi>) \\<circ>\\<^sub>m (Some \\<circ> \\<pi>) = Some", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (inv_map (Some \\<circ> \\<pi>) \\<circ>\\<^sub>m (Some \\<circ> \\<pi>))\n        x =\n       Some x", "unfolding inv_map_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>y.\n            if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n            then Some (inv (\\<lambda>x. Some (\\<pi> x)) (Some y))\n            else None) \\<circ>\\<^sub>m\n        (\\<lambda>x. Some (\\<pi> x)))\n        x =\n       Some x", "using assms"], ["proof (prove)\nusing this:\n  inj \\<pi>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>y.\n            if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n            then Some (inv (\\<lambda>x. Some (\\<pi> x)) (Some y))\n            else None) \\<circ>\\<^sub>m\n        (\\<lambda>x. Some (\\<pi> x)))\n        x =\n       Some x", "unfolding inj_def inv_def"], ["proof (prove)\nusing this:\n  \\<forall>x y. \\<pi> x = \\<pi> y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>y.\n            if Some y \\<in> range (\\<lambda>x. Some (\\<pi> x))\n            then Some (SOME x. Some (\\<pi> x) = Some y)\n            else None) \\<circ>\\<^sub>m\n        (\\<lambda>x. Some (\\<pi> x)))\n        x =\n       Some x", "by auto"], ["proof (state)\nthis:\n  inv_map (Some \\<circ> \\<pi>) \\<circ>\\<^sub>m (Some \\<circ> \\<pi>) = Some\n\ngoal (1 subgoal):\n 1. isometry (classical_operator (Some \\<circ> \\<pi>))", "have b3: \"classical_operator (inv_map (Some \\<circ> \\<pi>)) o\\<^sub>C\\<^sub>L\n            classical_operator (Some \\<circ> \\<pi>) = classical_operator (inv_map (Some \\<circ> \\<pi>) \\<circ>\\<^sub>m (Some \\<circ> \\<pi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator (inv_map (Some \\<circ> \\<pi>)) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>) =\n    classical_operator\n     (inv_map (Some \\<circ> \\<pi>) \\<circ>\\<^sub>m (Some \\<circ> \\<pi>))", "by (metis b0 b0' b1 classical_operator_Some classical_operator_exists_inj \n        classical_operator_mult)"], ["proof (state)\nthis:\n  classical_operator (inv_map (Some \\<circ> \\<pi>)) o\\<^sub>C\\<^sub>L\n  classical_operator (Some \\<circ> \\<pi>) =\n  classical_operator\n   (inv_map (Some \\<circ> \\<pi>) \\<circ>\\<^sub>m (Some \\<circ> \\<pi>))\n\ngoal (1 subgoal):\n 1. isometry (classical_operator (Some \\<circ> \\<pi>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. isometry (classical_operator (Some \\<circ> \\<pi>))", "unfolding isometry_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>) =\n    id_cblinfun", "apply (subst classical_operator_adjoint)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_map (Some \\<circ> \\<pi>)\n 2. classical_operator (inv_map (Some \\<circ> \\<pi>)) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>) =\n    id_cblinfun", "using b0"], ["proof (prove)\nusing this:\n  inj_map (Some \\<circ> \\<pi>)\n\ngoal (2 subgoals):\n 1. inj_map (Some \\<circ> \\<pi>)\n 2. classical_operator (inv_map (Some \\<circ> \\<pi>)) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>) =\n    id_cblinfun", "by (auto simp add: b1 b3)"], ["proof (state)\nthis:\n  isometry (classical_operator (Some \\<circ> \\<pi>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unitary_classical_operator[simp]:\n  fixes \\<pi>::\"'a \\<Rightarrow> 'b\"\n  assumes a1: \"bij \\<pi>\"\n  shows \"unitary (classical_operator (Some o \\<pi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (classical_operator (Some \\<circ> \\<pi>))", "proof (unfold unitary_def, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>) =\n    id_cblinfun\n 2. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "have \"inj \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj \\<pi>", "using a1 bij_betw_imp_inj_on"], ["proof (prove)\nusing this:\n  bij \\<pi>\n  bij_betw ?f ?A ?B \\<Longrightarrow> inj_on ?f ?A\n\ngoal (1 subgoal):\n 1. inj \\<pi>", "by auto"], ["proof (state)\nthis:\n  inj \\<pi>\n\ngoal (2 subgoals):\n 1. classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>) =\n    id_cblinfun\n 2. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "hence \"isometry (classical_operator (Some o \\<pi>))\""], ["proof (prove)\nusing this:\n  inj \\<pi>\n\ngoal (1 subgoal):\n 1. isometry (classical_operator (Some \\<circ> \\<pi>))", "by simp"], ["proof (state)\nthis:\n  isometry (classical_operator (Some \\<circ> \\<pi>))\n\ngoal (2 subgoals):\n 1. classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>) =\n    id_cblinfun\n 2. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "hence \"classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L classical_operator (Some \\<circ> \\<pi>) = id_cblinfun\""], ["proof (prove)\nusing this:\n  isometry (classical_operator (Some \\<circ> \\<pi>))\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>) =\n    id_cblinfun", "unfolding isometry_def"], ["proof (prove)\nusing this:\n  classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L\n  classical_operator (Some \\<circ> \\<pi>) =\n  id_cblinfun\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>) =\n    id_cblinfun", "by simp"], ["proof (state)\nthis:\n  classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L\n  classical_operator (Some \\<circ> \\<pi>) =\n  id_cblinfun\n\ngoal (2 subgoals):\n 1. classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>) =\n    id_cblinfun\n 2. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "thus \\<open>classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L classical_operator (Some \\<circ> \\<pi>) = id_cblinfun\\<close>"], ["proof (prove)\nusing this:\n  classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L\n  classical_operator (Some \\<circ> \\<pi>) =\n  id_cblinfun\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>) =\n    id_cblinfun", "by simp"], ["proof (state)\nthis:\n  classical_operator (Some \\<circ> \\<pi>)* o\\<^sub>C\\<^sub>L\n  classical_operator (Some \\<circ> \\<pi>) =\n  id_cblinfun\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "have \"inj \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj \\<pi>", "by (simp add: assms bij_is_inj)"], ["proof (state)\nthis:\n  inj \\<pi>\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "have comp: \"Some \\<circ> \\<pi> \\<circ>\\<^sub>m inv_map (Some \\<circ> \\<pi>) = Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some \\<circ> \\<pi> \\<circ>\\<^sub>m inv_map (Some \\<circ> \\<pi>) = Some", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (Some \\<circ> \\<pi> \\<circ>\\<^sub>m inv_map (Some \\<circ> \\<pi>)) x =\n       Some x", "unfolding inv_map_def o_def map_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case if Some x \\<in> range (\\<lambda>x. Some (\\<pi> x))\n             then Some (inv (\\<lambda>x. Some (\\<pi> x)) (Some x))\n             else None of\n        None \\<Rightarrow> None | Some x \\<Rightarrow> Some (\\<pi> x)) =\n       Some x", "unfolding inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case if Some x \\<in> range (\\<lambda>x. Some (\\<pi> x))\n             then Some (SOME xa. Some (\\<pi> xa) = Some x) else None of\n        None \\<Rightarrow> None | Some x \\<Rightarrow> Some (\\<pi> x)) =\n       Some x", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa. \\<pi> (SOME x. \\<pi> x = \\<pi> xa) = \\<pi> xa\n 2. \\<And>x. Some x \\<in> range (\\<lambda>x. Some (\\<pi> x))", "apply (metis \\<open>inj \\<pi>\\<close> inv_def inv_f_f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. Some x \\<in> range (\\<lambda>x. Some (\\<pi> x))", "using bij_def image_iff range_eqI"], ["proof (prove)\nusing this:\n  bij ?f = (inj ?f \\<and> surj ?f)\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n  ?b = ?f ?x \\<Longrightarrow> ?b \\<in> range ?f\n\ngoal (1 subgoal):\n 1. \\<And>x. Some x \\<in> range (\\<lambda>x. Some (\\<pi> x))", "by (metis a1)"], ["proof (state)\nthis:\n  Some \\<circ> \\<pi> \\<circ>\\<^sub>m inv_map (Some \\<circ> \\<pi>) = Some\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "have \"classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L classical_operator (Some \\<circ> \\<pi>)*\n      = classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L classical_operator (inv_map (Some \\<circ> \\<pi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (inv_map (Some \\<circ> \\<pi>))", "by (simp add: \\<open>inj \\<pi>\\<close>)"], ["proof (state)\nthis:\n  classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n  classical_operator (Some \\<circ> \\<pi>)* =\n  classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n  classical_operator (inv_map (Some \\<circ> \\<pi>))\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "also"], ["proof (state)\nthis:\n  classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n  classical_operator (Some \\<circ> \\<pi>)* =\n  classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n  classical_operator (inv_map (Some \\<circ> \\<pi>))\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "have \"\\<dots> = classical_operator ((Some \\<circ> \\<pi>) \\<circ>\\<^sub>m (inv_map (Some \\<circ> \\<pi>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (inv_map (Some \\<circ> \\<pi>)) =\n    classical_operator\n     (Some \\<circ> \\<pi> \\<circ>\\<^sub>m inv_map (Some \\<circ> \\<pi>))", "by (simp add: \\<open>inj \\<pi>\\<close> classical_operator_exists_inj)"], ["proof (state)\nthis:\n  classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n  classical_operator (inv_map (Some \\<circ> \\<pi>)) =\n  classical_operator\n   (Some \\<circ> \\<pi> \\<circ>\\<^sub>m inv_map (Some \\<circ> \\<pi>))\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "also"], ["proof (state)\nthis:\n  classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n  classical_operator (inv_map (Some \\<circ> \\<pi>)) =\n  classical_operator\n   (Some \\<circ> \\<pi> \\<circ>\\<^sub>m inv_map (Some \\<circ> \\<pi>))\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "have \"\\<dots> = classical_operator (Some::'b\\<Rightarrow>_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator\n     (Some \\<circ> \\<pi> \\<circ>\\<^sub>m inv_map (Some \\<circ> \\<pi>)) =\n    classical_operator Some", "using comp"], ["proof (prove)\nusing this:\n  Some \\<circ> \\<pi> \\<circ>\\<^sub>m inv_map (Some \\<circ> \\<pi>) = Some\n\ngoal (1 subgoal):\n 1. classical_operator\n     (Some \\<circ> \\<pi> \\<circ>\\<^sub>m inv_map (Some \\<circ> \\<pi>)) =\n    classical_operator Some", "by simp"], ["proof (state)\nthis:\n  classical_operator\n   (Some \\<circ> \\<pi> \\<circ>\\<^sub>m inv_map (Some \\<circ> \\<pi>)) =\n  classical_operator Some\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "also"], ["proof (state)\nthis:\n  classical_operator\n   (Some \\<circ> \\<pi> \\<circ>\\<^sub>m inv_map (Some \\<circ> \\<pi>)) =\n  classical_operator Some\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "have \"\\<dots> = (id_cblinfun:: 'b ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator Some = id_cblinfun", "by simp"], ["proof (state)\nthis:\n  classical_operator Some = id_cblinfun\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "finally"], ["proof (chain)\npicking this:\n  classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n  classical_operator (Some \\<circ> \\<pi>)* =\n  id_cblinfun", "show \"classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L classical_operator (Some \\<circ> \\<pi>)* = id_cblinfun\""], ["proof (prove)\nusing this:\n  classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n  classical_operator (Some \\<circ> \\<pi>)* =\n  id_cblinfun\n\ngoal (1 subgoal):\n 1. classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n    classical_operator (Some \\<circ> \\<pi>)* =\n    id_cblinfun", "."], ["proof (state)\nthis:\n  classical_operator (Some \\<circ> \\<pi>) o\\<^sub>C\\<^sub>L\n  classical_operator (Some \\<circ> \\<pi>)* =\n  id_cblinfun\n\ngoal:\nNo subgoals!", "qed"], ["", "unbundle no_cblinfun_notation"], ["", "end"]]}