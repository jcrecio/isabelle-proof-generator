{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators/Complex_Inner_Product0.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators", "problem_names": ["lemma cinner_zero_left [simp]: \"cinner 0 x = 0\"", "lemma cinner_minus_left [simp]: \"cinner (- x) y = - cinner x y\"", "lemma cinner_diff_left: \"cinner (x - y) z = cinner x z - cinner y z\"", "lemma cinner_sum_left: \"cinner (\\<Sum>x\\<in>A. f x) y = (\\<Sum>x\\<in>A. cinner (f x) y)\"", "lemma call_zero_iff [simp]: \"(\\<forall>u. cinner x u = 0) \\<longleftrightarrow> (x = 0)\"", "lemma cinner_add_right: \"cinner x (y + z) = cinner x y + cinner x z\"", "lemma cinner_scaleC_right [simp]: \"cinner x (scaleC r y) = r * (cinner x y)\"", "lemma cinner_zero_right [simp]: \"cinner x 0 = 0\"", "lemma cinner_minus_right [simp]: \"cinner x (- y) = - cinner x y\"", "lemma cinner_diff_right: \"cinner x (y - z) = cinner x y - cinner x z\"", "lemma cinner_sum_right: \"cinner x (\\<Sum>y\\<in>A. f y) = (\\<Sum>y\\<in>A. cinner x (f y))\"", "lemmas cinner_add [algebra_simps] = cinner_add_left cinner_add_right", "lemmas cinner_diff [algebra_simps]  = cinner_diff_left cinner_diff_right", "lemmas cinner_scaleC = cinner_scaleC_left cinner_scaleC_right", "lemma cinner_gt_zero_iff [simp]: \"0 < cinner x x \\<longleftrightarrow> x \\<noteq> 0\"", "lemma power2_norm_eq_cinner:\n  shows \"(complex_of_real (norm x))\\<^sup>2 = (cinner x x)\"", "lemma power2_norm_eq_cinner':\n  shows \"(norm x)\\<^sup>2 = Re (cinner x x)\"", "lemma cinner_mult_left: \"cinner (of_complex m * a) b = cnj m * (cinner a b)\"", "lemma cinner_mult_right: \"cinner a (of_complex m * b) = m * (cinner a b)\"", "lemma cinner_mult_left': \"cinner (a * of_complex m) b = cnj m * (cinner a b)\"", "lemma cinner_mult_right': \"cinner a (b * of_complex m) = (cinner a b) * m\"", "lemma Cauchy_Schwarz_ineq:\n  \"(cinner x y) * (cinner y x) \\<le> cinner x x * cinner y y\"", "lemma Cauchy_Schwarz_ineq2:\n  shows \"norm (cinner x y) \\<le> norm x * norm y\"", "lemma csquare_continuous:\n  fixes e :: real\n  shows \"e > 0 \\<Longrightarrow> \\<exists>d. 0 < d \\<and> (\\<forall>y. cmod (y - x) < d \\<longrightarrow> cmod (y * y - x * x) < e)\"", "lemma cnorm_le: \"norm x \\<le> norm y \\<longleftrightarrow> cinner x x \\<le> cinner y y\"", "lemma cnorm_lt: \"norm x < norm y \\<longleftrightarrow> cinner x x < cinner y y\"", "lemma cnorm_eq: \"norm x = norm y \\<longleftrightarrow> cinner x x = cinner y y\"", "lemma cnorm_eq_1: \"norm x = 1 \\<longleftrightarrow> cinner x x = 1\"", "lemma cinner_divide_left:\n  fixes a :: \"'a :: {complex_inner,complex_div_algebra}\"\n  shows \"cinner (a / of_complex m) b = (cinner a b) / cnj m\"", "lemma cinner_divide_right:\n  fixes a :: \"'a :: {complex_inner,complex_div_algebra}\"\n  shows \"cinner a (b / of_complex m) = (cinner a b) / m\"", "lemma bounded_sesquilinear_cinner:\n  \"bounded_sesquilinear (cinner::'a::complex_inner \\<Rightarrow> 'a \\<Rightarrow> complex)\"", "lemmas tendsto_cinner [tendsto_intros] =\n  bounded_bilinear.tendsto [OF bounded_sesquilinear_cinner[THEN bounded_sesquilinear.bounded_bilinear]]", "lemmas isCont_cinner [simp] =\n  bounded_bilinear.isCont [OF bounded_sesquilinear_cinner[THEN bounded_sesquilinear.bounded_bilinear]]", "lemmas has_derivative_cinner [derivative_intros] =\n  bounded_bilinear.FDERIV [OF bounded_sesquilinear_cinner[THEN bounded_sesquilinear.bounded_bilinear]]", "lemmas bounded_antilinear_cinner_left =\n  bounded_sesquilinear.bounded_antilinear_left [OF bounded_sesquilinear_cinner]", "lemmas bounded_clinear_cinner_right =\n  bounded_sesquilinear.bounded_clinear_right [OF bounded_sesquilinear_cinner]", "lemmas bounded_antilinear_cinner_left_comp = bounded_antilinear_cinner_left[THEN bounded_antilinear_o_bounded_clinear]", "lemmas bounded_clinear_cinner_right_comp = bounded_clinear_cinner_right[THEN bounded_clinear_compose]", "lemmas has_derivative_cinner_right [derivative_intros] =\n  bounded_linear.has_derivative [OF bounded_clinear_cinner_right[THEN bounded_clinear.bounded_linear]]", "lemmas has_derivative_cinner_left [derivative_intros] =\n  bounded_linear.has_derivative [OF bounded_antilinear_cinner_left[THEN bounded_antilinear.bounded_linear]]", "lemma differentiable_cinner [simp]:\n  \"f differentiable (at x within s) \\<Longrightarrow> g differentiable at x within s \\<Longrightarrow> (\\<lambda>x. cinner (f x) (g x)) differentiable at x within s\"", "lemma\n  shows complex_inner_1_left[simp]: \"cinner 1 x = x\"\n    and complex_inner_1_right[simp]: \"cinner x 1 = cnj x\"", "lemma cdot_square_norm: \"cinner x x = complex_of_real ((norm x)\\<^sup>2)\"", "lemma cnorm_eq_square: \"norm x = a \\<longleftrightarrow> 0 \\<le> a \\<and> cinner x x = complex_of_real (a\\<^sup>2)\"", "lemma cnorm_le_square: \"norm x \\<le> a \\<longleftrightarrow> 0 \\<le> a \\<and> cinner x x \\<le> complex_of_real (a\\<^sup>2)\"", "lemma cnorm_ge_square: \"norm x \\<ge> a \\<longleftrightarrow> a \\<le> 0 \\<or> cinner x x \\<ge> complex_of_real (a\\<^sup>2)\"", "lemma norm_lt_square: \"norm x < a \\<longleftrightarrow> 0 < a \\<and> cinner x x < complex_of_real (a\\<^sup>2)\"", "lemma norm_gt_square: \"norm x > a \\<longleftrightarrow> a < 0 \\<or> cinner x x > complex_of_real (a\\<^sup>2)\"", "lemmas cinner_simps = cinner_add_left cinner_add_right cinner_diff_right cinner_diff_left\n  cinner_scaleC_left cinner_scaleC_right", "lemma cdot_norm: \"cinner x y = ((norm (x+y))\\<^sup>2 - (norm (x-y))\\<^sup>2 - \\<i> * (norm (x + \\<i> *\\<^sub>C y))\\<^sup>2 + \\<i> * (norm (x - \\<i> *\\<^sub>C y))\\<^sup>2) / 4\"", "lemma of_complex_inner_1 [simp]: \n  \"cinner (of_complex x) (1 :: 'a :: {complex_inner, complex_normed_algebra_1}) = cnj x\"", "lemma summable_of_complex_iff: \n  \"summable (\\<lambda>x. of_complex (f x) :: 'a :: {complex_normed_algebra_1,complex_inner}) \\<longleftrightarrow> summable f\"", "lemma cgderiv_deriv [simp]: \"cGDERIV f x :> D \\<longleftrightarrow> DERIV f x :> cnj D\"", "lemma cGDERIV_DERIV_compose:\n  assumes \"cGDERIV f x :> df\" and \"DERIV g (f x) :> cnj dg\"\n  shows \"cGDERIV (\\<lambda>x. g (f x)) x :> scaleC dg df\"", "lemma cGDERIV_subst: \"\\<lbrakk>cGDERIV f x :> df; df = d\\<rbrakk> \\<Longrightarrow> cGDERIV f x :> d\"", "lemma cGDERIV_const: \"cGDERIV (\\<lambda>x. k) x :> 0\"", "lemma cGDERIV_add:\n  \"\\<lbrakk>cGDERIV f x :> df; cGDERIV g x :> dg\\<rbrakk>\n     \\<Longrightarrow> cGDERIV (\\<lambda>x. f x + g x) x :> df + dg\"", "lemma cGDERIV_minus:\n  \"cGDERIV f x :> df \\<Longrightarrow> cGDERIV (\\<lambda>x. - f x) x :> - df\"", "lemma cGDERIV_diff:\n  \"\\<lbrakk>cGDERIV f x :> df; cGDERIV g x :> dg\\<rbrakk>\n     \\<Longrightarrow> cGDERIV (\\<lambda>x. f x - g x) x :> df - dg\"", "lemma cGDERIV_scaleC:\n  \"\\<lbrakk>DERIV f x :> df; cGDERIV g x :> dg\\<rbrakk>\n     \\<Longrightarrow> cGDERIV (\\<lambda>x. scaleC (f x) (g x)) x\n      :> (scaleC (cnj (f x)) dg + scaleC (cnj df) (cnj (g x)))\"", "lemma GDERIV_mult:\n  \"\\<lbrakk>cGDERIV f x :> df; cGDERIV g x :> dg\\<rbrakk>\n     \\<Longrightarrow> cGDERIV (\\<lambda>x. f x * g x) x :> cnj (f x) *\\<^sub>C dg + cnj (g x) *\\<^sub>C df\"", "lemma cGDERIV_inverse:\n  \"\\<lbrakk>cGDERIV f x :> df; f x \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> cGDERIV (\\<lambda>x. inverse (f x)) x :> - cnj ((inverse (f x))\\<^sup>2) *\\<^sub>C df\"", "lemma has_derivative_norm[derivative_intros]:\n  fixes x :: \"'a::complex_inner\"\n  assumes \"x \\<noteq> 0\" \n  shows \"(norm has_derivative (\\<lambda>h. Re (cinner (sgn x) h))) (at x)\""], "translations": [["", "lemma cinner_zero_left [simp]: \"cinner 0 x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (0::'a) x = 0", "using cinner_add_left [of 0 0 x]"], ["proof (prove)\nusing this:\n  cinner ((0::'a) + (0::'a)) x = cinner (0::'a) x + cinner (0::'a) x\n\ngoal (1 subgoal):\n 1. cinner (0::'a) x = 0", "by simp"], ["", "lemma cinner_minus_left [simp]: \"cinner (- x) y = - cinner x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (- x) y = - cinner x y", "using cinner_add_left [of x \"- x\" y]"], ["proof (prove)\nusing this:\n  cinner (x + - x) y = cinner x y + cinner (- x) y\n\ngoal (1 subgoal):\n 1. cinner (- x) y = - cinner x y", "by (simp add: group_add_class.add_eq_0_iff)"], ["", "lemma cinner_diff_left: \"cinner (x - y) z = cinner x z - cinner y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (x - y) z = cinner x z - cinner y z", "using cinner_add_left [of x \"- y\" z]"], ["proof (prove)\nusing this:\n  cinner (x + - y) z = cinner x z + cinner (- y) z\n\ngoal (1 subgoal):\n 1. cinner (x - y) z = cinner x z - cinner y z", "by simp"], ["", "lemma cinner_sum_left: \"cinner (\\<Sum>x\\<in>A. f x) y = (\\<Sum>x\\<in>A. cinner (f x) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (sum f A) y = (\\<Sum>x\\<in>A. cinner (f x) y)", "by (cases \"finite A\", induct set: finite, simp_all add: cinner_add_left)"], ["", "lemma call_zero_iff [simp]: \"(\\<forall>u. cinner x u = 0) \\<longleftrightarrow> (x = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>u. cinner x u = 0) = (x = (0::'a))", "by auto (use cinner_eq_zero_iff in blast)"], ["", "text \\<open>Transfer distributivity rules to right argument.\\<close>"], ["", "lemma cinner_add_right: \"cinner x (y + z) = cinner x y + cinner x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x (y + z) = cinner x y + cinner x z", "using cinner_add_left [of y z x]"], ["proof (prove)\nusing this:\n  cinner (y + z) x = cinner y x + cinner z x\n\ngoal (1 subgoal):\n 1. cinner x (y + z) = cinner x y + cinner x z", "by (metis complex_cnj_add local.cinner_commute)"], ["", "lemma cinner_scaleC_right [simp]: \"cinner x (scaleC r y) = r * (cinner x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x (r *\\<^sub>C y) = r * cinner x y", "using cinner_scaleC_left [of r y x]"], ["proof (prove)\nusing this:\n  cinner (r *\\<^sub>C y) x = cnj r * cinner y x\n\ngoal (1 subgoal):\n 1. cinner x (r *\\<^sub>C y) = r * cinner x y", "by (metis complex_cnj_cnj complex_cnj_mult local.cinner_commute)"], ["", "lemma cinner_zero_right [simp]: \"cinner x 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x (0::'a) = 0", "using cinner_zero_left [of x]"], ["proof (prove)\nusing this:\n  cinner (0::'a) x = 0\n\ngoal (1 subgoal):\n 1. cinner x (0::'a) = 0", "by (metis (mono_tags, hide_lams) complex_cnj_zero local.cinner_commute)"], ["", "lemma cinner_minus_right [simp]: \"cinner x (- y) = - cinner x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x (- y) = - cinner x y", "using cinner_minus_left [of y x]"], ["proof (prove)\nusing this:\n  cinner (- y) x = - cinner y x\n\ngoal (1 subgoal):\n 1. cinner x (- y) = - cinner x y", "by (metis complex_cnj_minus local.cinner_commute)"], ["", "lemma cinner_diff_right: \"cinner x (y - z) = cinner x y - cinner x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x (y - z) = cinner x y - cinner x z", "using cinner_diff_left [of y z x]"], ["proof (prove)\nusing this:\n  cinner (y - z) x = cinner y x - cinner z x\n\ngoal (1 subgoal):\n 1. cinner x (y - z) = cinner x y - cinner x z", "by (metis complex_cnj_diff local.cinner_commute)"], ["", "lemma cinner_sum_right: \"cinner x (\\<Sum>y\\<in>A. f y) = (\\<Sum>y\\<in>A. cinner x (f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x (sum f A) = (\\<Sum>y\\<in>A. cinner x (f y))", "proof (subst cinner_commute)"], ["proof (state)\ngoal (1 subgoal):\n 1. cnj (cinner (sum f A) x) = (\\<Sum>y\\<in>A. cinner x (f y))", "have \"(\\<Sum>y\\<in>A. cinner (f y) x) = (\\<Sum>y\\<in>A. cinner (f y) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A. cinner (f y) x) = (\\<Sum>y\\<in>A. cinner (f y) x)", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A. cinner (f y) x) = (\\<Sum>y\\<in>A. cinner (f y) x)\n\ngoal (1 subgoal):\n 1. cnj (cinner (sum f A) x) = (\\<Sum>y\\<in>A. cinner x (f y))", "hence \"cnj (\\<Sum>y\\<in>A. cinner (f y) x) = cnj (\\<Sum>y\\<in>A. (cinner (f y) x))\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>A. cinner (f y) x) = (\\<Sum>y\\<in>A. cinner (f y) x)\n\ngoal (1 subgoal):\n 1. cnj (\\<Sum>y\\<in>A. cinner (f y) x) =\n    cnj (\\<Sum>y\\<in>A. cinner (f y) x)", "by simp"], ["proof (state)\nthis:\n  cnj (\\<Sum>y\\<in>A. cinner (f y) x) = cnj (\\<Sum>y\\<in>A. cinner (f y) x)\n\ngoal (1 subgoal):\n 1. cnj (cinner (sum f A) x) = (\\<Sum>y\\<in>A. cinner x (f y))", "hence \"cnj (cinner (sum f A) x) = (\\<Sum>y\\<in>A. cnj (cinner (f y) x))\""], ["proof (prove)\nusing this:\n  cnj (\\<Sum>y\\<in>A. cinner (f y) x) = cnj (\\<Sum>y\\<in>A. cinner (f y) x)\n\ngoal (1 subgoal):\n 1. cnj (cinner (sum f A) x) = (\\<Sum>y\\<in>A. cnj (cinner (f y) x))", "by (simp add: cinner_sum_left)"], ["proof (state)\nthis:\n  cnj (cinner (sum f A) x) = (\\<Sum>y\\<in>A. cnj (cinner (f y) x))\n\ngoal (1 subgoal):\n 1. cnj (cinner (sum f A) x) = (\\<Sum>y\\<in>A. cinner x (f y))", "thus \"cnj (cinner (sum f A) x) = (\\<Sum>y\\<in>A. (cinner x (f y)))\""], ["proof (prove)\nusing this:\n  cnj (cinner (sum f A) x) = (\\<Sum>y\\<in>A. cnj (cinner (f y) x))\n\ngoal (1 subgoal):\n 1. cnj (cinner (sum f A) x) = (\\<Sum>y\\<in>A. cinner x (f y))", "by (subst (2) cinner_commute)"], ["proof (state)\nthis:\n  cnj (cinner (sum f A) x) = (\\<Sum>y\\<in>A. cinner x (f y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas cinner_add [algebra_simps] = cinner_add_left cinner_add_right"], ["", "lemmas cinner_diff [algebra_simps]  = cinner_diff_left cinner_diff_right"], ["", "lemmas cinner_scaleC = cinner_scaleC_left cinner_scaleC_right"], ["", "(* text \\<open>Legacy theorem names\\<close>\nlemmas cinner_left_distrib = cinner_add_left\nlemmas cinner_right_distrib = cinner_add_right\nlemmas cinner_distrib = cinner_left_distrib cinner_right_distrib *)"], ["", "lemma cinner_gt_zero_iff [simp]: \"0 < cinner x x \\<longleftrightarrow> x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < cinner x x) = (x \\<noteq> (0::'a))", "by (smt (verit) less_irrefl local.cinner_eq_zero_iff local.cinner_ge_zero order.not_eq_order_implies_strict)"], ["", "(* In Inner_Product, we have\n  lemma power2_norm_eq_cinner: \"(norm x)\\<^sup>2 = cinner x x\"\nThe following are two ways of inserting the conversions between real and complex into this:\n*)"], ["", "lemma power2_norm_eq_cinner:\n  shows \"(complex_of_real (norm x))\\<^sup>2 = (cinner x x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (complex_of_real (norm x))\\<^sup>2 = cinner x x", "by (smt (verit, del_insts) Im_complex_of_real Re_complex_of_real cinner_gt_zero_iff cinner_zero_right cmod_def complex_eq_0 complex_eq_iff less_complex_def local.norm_eq_sqrt_cinner of_real_power real_sqrt_abs real_sqrt_pow2_iff zero_complex.sel(1))"], ["", "lemma power2_norm_eq_cinner':\n  shows \"(norm x)\\<^sup>2 = Re (cinner x x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm x)\\<^sup>2 = Re (cinner x x)", "by (metis Re_complex_of_real of_real_power power2_norm_eq_cinner)"], ["", "text \\<open>Identities involving real multiplication and division.\\<close>"], ["", "lemma cinner_mult_left: \"cinner (of_complex m * a) b = cnj m * (cinner a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (of_complex m * a) b = cnj m * cinner a b", "by (simp add: of_complex_def)"], ["", "lemma cinner_mult_right: \"cinner a (of_complex m * b) = m * (cinner a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner a (of_complex m * b) = m * cinner a b", "by (metis complex_inner_class.cinner_scaleC_right scaleC_conv_of_complex)"], ["", "lemma cinner_mult_left': \"cinner (a * of_complex m) b = cnj m * (cinner a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (a * of_complex m) b = cnj m * cinner a b", "by (metis cinner_mult_left mult.right_neutral mult_scaleC_right scaleC_conv_of_complex)"], ["", "lemma cinner_mult_right': \"cinner a (b * of_complex m) = (cinner a b) * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner a (b * of_complex m) = cinner a b * m", "by (simp add: complex_inner_class.cinner_scaleC_right of_complex_def)"], ["", "(* In Inner_Product, we have\nlemma Cauchy_Schwarz_ineq:\n  \"(cinner x y)\\<^sup>2 \\<le> cinner x x * cinner y y\"\nThe following are two ways of inserting the conversions between real and complex into this:\n*)"], ["", "lemma Cauchy_Schwarz_ineq:\n  \"(cinner x y) * (cinner y x) \\<le> cinner x x * cinner y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x y * cinner y x \\<le> cinner x x * cinner y y", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y\n 2. \\<not> ?P \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "assume \"y = 0\""], ["proof (state)\nthis:\n  y = (0::'a)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y\n 2. \\<not> ?P \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = (0::'a)\n\ngoal (1 subgoal):\n 1. cinner x y * cinner y x \\<le> cinner x x * cinner y y", "by simp"], ["proof (state)\nthis:\n  cinner x y * cinner y x \\<le> cinner x x * cinner y y\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "assume y: \"y \\<noteq> 0\""], ["proof (state)\nthis:\n  y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "have [simp]: \"cnj (cinner y y) = cinner y y\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (cinner y y) = cinner y y", "by (metis cinner_commute)"], ["proof (state)\nthis:\n  cnj (cinner ?y1 ?y1) = cinner ?y1 ?y1\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "define r where \"r = cnj (cinner x y) / cinner y y\""], ["proof (state)\nthis:\n  r = cnj (cinner x y) / cinner y y\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "have \"0 \\<le> cinner (x - scaleC r y) (x - scaleC r y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cinner (x - r *\\<^sub>C y) (x - r *\\<^sub>C y)", "by (rule cinner_ge_zero)"], ["proof (state)\nthis:\n  0 \\<le> cinner (x - r *\\<^sub>C y) (x - r *\\<^sub>C y)\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "also"], ["proof (state)\nthis:\n  0 \\<le> cinner (x - r *\\<^sub>C y) (x - r *\\<^sub>C y)\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "have \"\\<dots> = cinner x x - r * cinner x y - cnj r * cinner y x + r * cnj r * cinner y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (x - r *\\<^sub>C y) (x - r *\\<^sub>C y) =\n    cinner x x - r * cinner x y - cnj r * cinner y x +\n    r * cnj r * cinner y y", "unfolding cinner_diff_left cinner_diff_right cinner_scaleC_left cinner_scaleC_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x x - cnj r * cinner y x -\n    r * (cinner x y - cnj r * cinner y y) =\n    cinner x x - r * cinner x y - cnj r * cinner y x +\n    r * cnj r * cinner y y", "by (smt (z3) cancel_comm_monoid_add_class.diff_cancel cancel_comm_monoid_add_class.diff_zero complex_cnj_divide group_add_class.diff_add_cancel local.cinner_commute local.cinner_eq_zero_iff local.cinner_scaleC_left mult.assoc mult.commute mult_eq_0_iff nonzero_eq_divide_eq r_def y)"], ["proof (state)\nthis:\n  cinner (x - r *\\<^sub>C y) (x - r *\\<^sub>C y) =\n  cinner x x - r * cinner x y - cnj r * cinner y x + r * cnj r * cinner y y\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "also"], ["proof (state)\nthis:\n  cinner (x - r *\\<^sub>C y) (x - r *\\<^sub>C y) =\n  cinner x x - r * cinner x y - cnj r * cinner y x + r * cnj r * cinner y y\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "have \"\\<dots> = cinner x x - cinner y x * cnj r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x x - r * cinner x y - cnj r * cinner y x +\n    r * cnj r * cinner y y =\n    cinner x x - cinner y x * cnj r", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x x - cnj (cinner x y) / cinner y y * cinner x y -\n    cnj (cnj (cinner x y) / cinner y y) * cinner y x +\n    cnj (cinner x y) / cinner y y * cnj (cnj (cinner x y) / cinner y y) *\n    cinner y y =\n    cinner x x - cinner y x * cnj (cnj (cinner x y) / cinner y y)", "by auto"], ["proof (state)\nthis:\n  cinner x x - r * cinner x y - cnj r * cinner y x +\n  r * cnj r * cinner y y =\n  cinner x x - cinner y x * cnj r\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "also"], ["proof (state)\nthis:\n  cinner x x - r * cinner x y - cnj r * cinner y x +\n  r * cnj r * cinner y y =\n  cinner x x - cinner y x * cnj r\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "have \"\\<dots> = cinner x x - cinner x y * cnj (cinner x y) / cinner y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x x - cinner y x * cnj r =\n    cinner x x - cinner x y * cnj (cinner x y) / cinner y y", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x x - cinner y x * cnj (cnj (cinner x y) / cinner y y) =\n    cinner x x - cinner x y * cnj (cinner x y) / cinner y y", "by (metis complex_cnj_divide local.cinner_commute mult.commute times_divide_eq_left)"], ["proof (state)\nthis:\n  cinner x x - cinner y x * cnj r =\n  cinner x x - cinner x y * cnj (cinner x y) / cinner y y\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> cinner x x - cinner x y * cnj (cinner x y) / cinner y y", "have \"0 \\<le> cinner x x - cinner x y * cnj (cinner x y) / cinner y y\""], ["proof (prove)\nusing this:\n  0 \\<le> cinner x x - cinner x y * cnj (cinner x y) / cinner y y\n\ngoal (1 subgoal):\n 1. 0 \\<le> cinner x x - cinner x y * cnj (cinner x y) / cinner y y", "."], ["proof (state)\nthis:\n  0 \\<le> cinner x x - cinner x y * cnj (cinner x y) / cinner y y\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "hence \"cinner x y * cnj (cinner x y) / cinner y y \\<le> cinner x x\""], ["proof (prove)\nusing this:\n  0 \\<le> cinner x x - cinner x y * cnj (cinner x y) / cinner y y\n\ngoal (1 subgoal):\n 1. cinner x y * cnj (cinner x y) / cinner y y \\<le> cinner x x", "by (simp add: le_diff_eq)"], ["proof (state)\nthis:\n  cinner x y * cnj (cinner x y) / cinner y y \\<le> cinner x x\n\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow>\n    cinner x y * cinner y x \\<le> cinner x x * cinner y y", "thus \"cinner x y * cinner y x \\<le> cinner x x * cinner y y\""], ["proof (prove)\nusing this:\n  cinner x y * cnj (cinner x y) / cinner y y \\<le> cinner x x\n\ngoal (1 subgoal):\n 1. cinner x y * cinner y x \\<le> cinner x x * cinner y y", "by (metis cinner_gt_zero_iff local.cinner_commute nice_ordered_field_class.pos_divide_le_eq y)"], ["proof (state)\nthis:\n  cinner x y * cinner y x \\<le> cinner x x * cinner y y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Cauchy_Schwarz_ineq2:\n  shows \"norm (cinner x y) \\<le> norm x * norm y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (cinner x y) \\<le> norm x * norm y", "proof (rule power2_le_imp_le)"], ["proof (state)\ngoal (2 subgoals):\n 1. (cmod (cinner x y))\\<^sup>2 \\<le> (norm x * norm y)\\<^sup>2\n 2. 0 \\<le> norm x * norm y", "have \"(norm (cinner x y))^2 = Re (cinner x y * cinner y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (cinner x y))\\<^sup>2 = Re (cinner x y * cinner y x)", "by (metis (full_types) Re_complex_of_real complex_norm_square local.cinner_commute)"], ["proof (state)\nthis:\n  (cmod (cinner x y))\\<^sup>2 = Re (cinner x y * cinner y x)\n\ngoal (2 subgoals):\n 1. (cmod (cinner x y))\\<^sup>2 \\<le> (norm x * norm y)\\<^sup>2\n 2. 0 \\<le> norm x * norm y", "also"], ["proof (state)\nthis:\n  (cmod (cinner x y))\\<^sup>2 = Re (cinner x y * cinner y x)\n\ngoal (2 subgoals):\n 1. (cmod (cinner x y))\\<^sup>2 \\<le> (norm x * norm y)\\<^sup>2\n 2. 0 \\<le> norm x * norm y", "have \"\\<dots> \\<le> Re (cinner x x * cinner y y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (cinner x y * cinner y x) \\<le> Re (cinner x x * cinner y y)", "using Cauchy_Schwarz_ineq"], ["proof (prove)\nusing this:\n  cinner ?x ?y * cinner ?y ?x \\<le> cinner ?x ?x * cinner ?y ?y\n\ngoal (1 subgoal):\n 1. Re (cinner x y * cinner y x) \\<le> Re (cinner x x * cinner y y)", "by (rule Re_mono)"], ["proof (state)\nthis:\n  Re (cinner x y * cinner y x) \\<le> Re (cinner x x * cinner y y)\n\ngoal (2 subgoals):\n 1. (cmod (cinner x y))\\<^sup>2 \\<le> (norm x * norm y)\\<^sup>2\n 2. 0 \\<le> norm x * norm y", "also"], ["proof (state)\nthis:\n  Re (cinner x y * cinner y x) \\<le> Re (cinner x x * cinner y y)\n\ngoal (2 subgoals):\n 1. (cmod (cinner x y))\\<^sup>2 \\<le> (norm x * norm y)\\<^sup>2\n 2. 0 \\<le> norm x * norm y", "have \"\\<dots> = Re (complex_of_real ((norm x)^2) * complex_of_real ((norm y)^2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (cinner x x * cinner y y) =\n    Re (complex_of_real ((norm x)\\<^sup>2) *\n        complex_of_real ((norm y)\\<^sup>2))", "by (simp add: power2_norm_eq_cinner)"], ["proof (state)\nthis:\n  Re (cinner x x * cinner y y) =\n  Re (complex_of_real ((norm x)\\<^sup>2) *\n      complex_of_real ((norm y)\\<^sup>2))\n\ngoal (2 subgoals):\n 1. (cmod (cinner x y))\\<^sup>2 \\<le> (norm x * norm y)\\<^sup>2\n 2. 0 \\<le> norm x * norm y", "also"], ["proof (state)\nthis:\n  Re (cinner x x * cinner y y) =\n  Re (complex_of_real ((norm x)\\<^sup>2) *\n      complex_of_real ((norm y)\\<^sup>2))\n\ngoal (2 subgoals):\n 1. (cmod (cinner x y))\\<^sup>2 \\<le> (norm x * norm y)\\<^sup>2\n 2. 0 \\<le> norm x * norm y", "have \"\\<dots> = (norm x * norm y)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (complex_of_real ((norm x)\\<^sup>2) *\n        complex_of_real ((norm y)\\<^sup>2)) =\n    (norm x * norm y)\\<^sup>2", "by (simp add: power_mult_distrib)"], ["proof (state)\nthis:\n  Re (complex_of_real ((norm x)\\<^sup>2) *\n      complex_of_real ((norm y)\\<^sup>2)) =\n  (norm x * norm y)\\<^sup>2\n\ngoal (2 subgoals):\n 1. (cmod (cinner x y))\\<^sup>2 \\<le> (norm x * norm y)\\<^sup>2\n 2. 0 \\<le> norm x * norm y", "finally"], ["proof (chain)\npicking this:\n  (cmod (cinner x y))\\<^sup>2 \\<le> (norm x * norm y)\\<^sup>2", "show \"(cmod (cinner x y))^2 \\<le> (norm x * norm y)\\<^sup>2\""], ["proof (prove)\nusing this:\n  (cmod (cinner x y))\\<^sup>2 \\<le> (norm x * norm y)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (cmod (cinner x y))\\<^sup>2 \\<le> (norm x * norm y)\\<^sup>2", "."], ["proof (state)\nthis:\n  (cmod (cinner x y))\\<^sup>2 \\<le> (norm x * norm y)\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> norm x * norm y", "show \"0 \\<le> norm x * norm y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> norm x * norm y", "by (simp add: local.norm_eq_sqrt_cinner)"], ["proof (state)\nthis:\n  0 \\<le> norm x * norm y\n\ngoal:\nNo subgoals!", "qed"], ["", "(* The following variant does not hold in the complex case: *)\n(* lemma norm_cauchy_schwarz: \"cinner x y \\<le> norm x * norm y\"\n  using Cauchy_Schwarz_ineq2 [of x y] by auto *)"], ["", "subclass complex_normed_vector"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.complex_normed_vector (*\\<^sub>R) (*\\<^sub>C) (+) (0::'a) (-)\n     uminus dist norm sgn uniformity open", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. (norm x = 0) = (x = (0::'a))\n 2. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 3. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 4. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "fix a :: complex and r :: real and x y :: 'a"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. (norm x = 0) = (x = (0::'a))\n 2. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 3. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 4. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \"norm x = 0 \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm x = 0) = (x = (0::'a))", "unfolding norm_eq_sqrt_cinner"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sqrt (cmod (cinner x x)) = 0) = (x = (0::'a))", "by simp"], ["proof (state)\nthis:\n  (norm x = 0) = (x = (0::'a))\n\ngoal (3 subgoals):\n 1. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 2. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 3. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \"norm (x + y) \\<le> norm x + norm y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (x + y) \\<le> norm x + norm y", "proof (rule power2_le_imp_le)"], ["proof (state)\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "have \"Re (cinner x y) \\<le> cmod (cinner x y)\"\n      if \"\\<And>x. Re x \\<le> cmod x\" and\n        \"\\<And>x y. x \\<le> y \\<Longrightarrow> complex_of_real x \\<le> complex_of_real y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (cinner x y) \\<le> cmod (cinner x y)", "using that"], ["proof (prove)\nusing this:\n  Re ?x1 \\<le> cmod ?x1\n  ?x1 \\<le> ?y1 \\<Longrightarrow>\n  complex_of_real ?x1 \\<le> complex_of_real ?y1\n\ngoal (1 subgoal):\n 1. Re (cinner x y) \\<le> cmod (cinner x y)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x. Re x \\<le> cmod x;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      complex_of_real x \\<le> complex_of_real y\\<rbrakk>\n  \\<Longrightarrow> Re (cinner x y) \\<le> cmod (cinner x y)\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "hence a1: \"2 * Re (cinner x y) \\<le> 2 * cmod (cinner x y)\"\n      if \"\\<And>x. Re x \\<le> cmod x\" and\n        \"\\<And>x y. x \\<le> y \\<Longrightarrow> complex_of_real x \\<le> complex_of_real y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. Re x \\<le> cmod x;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      complex_of_real x \\<le> complex_of_real y\\<rbrakk>\n  \\<Longrightarrow> Re (cinner x y) \\<le> cmod (cinner x y)\n\ngoal (1 subgoal):\n 1. 2 * Re (cinner x y) \\<le> 2 * cmod (cinner x y)", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. Re x \\<le> cmod x;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      complex_of_real x \\<le> complex_of_real y\\<rbrakk>\n  \\<Longrightarrow> Re (cinner x y) \\<le> cmod (cinner x y)\n  Re ?x1 \\<le> cmod ?x1\n  ?x1 \\<le> ?y1 \\<Longrightarrow>\n  complex_of_real ?x1 \\<le> complex_of_real ?y1\n\ngoal (1 subgoal):\n 1. 2 * Re (cinner x y) \\<le> 2 * cmod (cinner x y)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x. Re x \\<le> cmod x;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      complex_of_real x \\<le> complex_of_real y\\<rbrakk>\n  \\<Longrightarrow> 2 * Re (cinner x y) \\<le> 2 * cmod (cinner x y)\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "have \"cinner x y + cinner y x = complex_of_real (2 * Re (cinner x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x y + cinner y x = complex_of_real (2 * Re (cinner x y))", "by (metis complex_add_cnj local.cinner_commute)"], ["proof (state)\nthis:\n  cinner x y + cinner y x = complex_of_real (2 * Re (cinner x y))\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "also"], ["proof (state)\nthis:\n  cinner x y + cinner y x = complex_of_real (2 * Re (cinner x y))\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "have \"\\<dots> \\<le> complex_of_real (2 * cmod (cinner x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (2 * Re (cinner x y))\n    \\<le> complex_of_real (2 * cmod (cinner x y))", "using complex_Re_le_cmod complex_of_real_mono a1"], ["proof (prove)\nusing this:\n  Re ?x \\<le> cmod ?x\n  ?x \\<le> ?y \\<Longrightarrow> complex_of_real ?x \\<le> complex_of_real ?y\n  \\<lbrakk>\\<And>x. Re x \\<le> cmod x;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      complex_of_real x \\<le> complex_of_real y\\<rbrakk>\n  \\<Longrightarrow> 2 * Re (cinner x y) \\<le> 2 * cmod (cinner x y)\n\ngoal (1 subgoal):\n 1. complex_of_real (2 * Re (cinner x y))\n    \\<le> complex_of_real (2 * cmod (cinner x y))", "by blast"], ["proof (state)\nthis:\n  complex_of_real (2 * Re (cinner x y))\n  \\<le> complex_of_real (2 * cmod (cinner x y))\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "also"], ["proof (state)\nthis:\n  complex_of_real (2 * Re (cinner x y))\n  \\<le> complex_of_real (2 * cmod (cinner x y))\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "have \"\\<dots> = 2 * abs (cinner x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (2 * cmod (cinner x y)) = 2 * \\<bar>cinner x y\\<bar>", "unfolding abs_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (2 * cmod (cinner x y)) =\n    2 * (complex_of_real \\<circ> cmod) (cinner x y)", "by simp"], ["proof (state)\nthis:\n  complex_of_real (2 * cmod (cinner x y)) = 2 * \\<bar>cinner x y\\<bar>\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "also"], ["proof (state)\nthis:\n  complex_of_real (2 * cmod (cinner x y)) = 2 * \\<bar>cinner x y\\<bar>\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "have \"\\<dots> \\<le> 2 * complex_of_real (norm x) * complex_of_real (norm y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * \\<bar>cinner x y\\<bar>\n    \\<le> 2 * complex_of_real (norm x) * complex_of_real (norm y)", "using Cauchy_Schwarz_ineq2"], ["proof (prove)\nusing this:\n  cmod (cinner ?x ?y) \\<le> norm ?x * norm ?y\n\ngoal (1 subgoal):\n 1. 2 * \\<bar>cinner x y\\<bar>\n    \\<le> 2 * complex_of_real (norm x) * complex_of_real (norm y)", "unfolding abs_complex_def"], ["proof (prove)\nusing this:\n  cmod (cinner ?x ?y) \\<le> norm ?x * norm ?y\n\ngoal (1 subgoal):\n 1. 2 * (complex_of_real \\<circ> cmod) (cinner x y)\n    \\<le> 2 * complex_of_real (norm x) * complex_of_real (norm y)", "by auto"], ["proof (state)\nthis:\n  2 * \\<bar>cinner x y\\<bar>\n  \\<le> 2 * complex_of_real (norm x) * complex_of_real (norm y)\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "finally"], ["proof (chain)\npicking this:\n  cinner x y + cinner y x\n  \\<le> 2 * complex_of_real (norm x) * complex_of_real (norm y)", "have xyyx: \"cinner x y + cinner y x \\<le> complex_of_real (2 * norm x * norm y)\""], ["proof (prove)\nusing this:\n  cinner x y + cinner y x\n  \\<le> 2 * complex_of_real (norm x) * complex_of_real (norm y)\n\ngoal (1 subgoal):\n 1. cinner x y + cinner y x \\<le> complex_of_real (2 * norm x * norm y)", "by auto"], ["proof (state)\nthis:\n  cinner x y + cinner y x \\<le> complex_of_real (2 * norm x * norm y)\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "have \"complex_of_real ((norm (x + y))\\<^sup>2) = cinner (x+y) (x+y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real ((norm (x + y))\\<^sup>2) = cinner (x + y) (x + y)", "by (simp add: power2_norm_eq_cinner)"], ["proof (state)\nthis:\n  complex_of_real ((norm (x + y))\\<^sup>2) = cinner (x + y) (x + y)\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "also"], ["proof (state)\nthis:\n  complex_of_real ((norm (x + y))\\<^sup>2) = cinner (x + y) (x + y)\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "have \"\\<dots> = cinner x x + cinner x y + cinner y x + cinner y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (x + y) (x + y) =\n    cinner x x + cinner x y + cinner y x + cinner y y", "by (simp add: cinner_add)"], ["proof (state)\nthis:\n  cinner (x + y) (x + y) = cinner x x + cinner x y + cinner y x + cinner y y\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "also"], ["proof (state)\nthis:\n  cinner (x + y) (x + y) = cinner x x + cinner x y + cinner y x + cinner y y\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "have \"\\<dots> = complex_of_real ((norm x)\\<^sup>2) + complex_of_real ((norm y)\\<^sup>2) + cinner x y + cinner y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x x + cinner x y + cinner y x + cinner y y =\n    complex_of_real ((norm x)\\<^sup>2) +\n    complex_of_real ((norm y)\\<^sup>2) +\n    cinner x y +\n    cinner y x", "by (simp add: power2_norm_eq_cinner)"], ["proof (state)\nthis:\n  cinner x x + cinner x y + cinner y x + cinner y y =\n  complex_of_real ((norm x)\\<^sup>2) + complex_of_real ((norm y)\\<^sup>2) +\n  cinner x y +\n  cinner y x\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "also"], ["proof (state)\nthis:\n  cinner x x + cinner x y + cinner y x + cinner y y =\n  complex_of_real ((norm x)\\<^sup>2) + complex_of_real ((norm y)\\<^sup>2) +\n  cinner x y +\n  cinner y x\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "have \"\\<dots> \\<le> complex_of_real ((norm x)\\<^sup>2) + complex_of_real ((norm y)\\<^sup>2) + complex_of_real (2 * norm x * norm y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real ((norm x)\\<^sup>2) +\n    complex_of_real ((norm y)\\<^sup>2) +\n    cinner x y +\n    cinner y x\n    \\<le> complex_of_real ((norm x)\\<^sup>2) +\n          complex_of_real ((norm y)\\<^sup>2) +\n          complex_of_real (2 * norm x * norm y)", "using xyyx"], ["proof (prove)\nusing this:\n  cinner x y + cinner y x \\<le> complex_of_real (2 * norm x * norm y)\n\ngoal (1 subgoal):\n 1. complex_of_real ((norm x)\\<^sup>2) +\n    complex_of_real ((norm y)\\<^sup>2) +\n    cinner x y +\n    cinner y x\n    \\<le> complex_of_real ((norm x)\\<^sup>2) +\n          complex_of_real ((norm y)\\<^sup>2) +\n          complex_of_real (2 * norm x * norm y)", "by auto"], ["proof (state)\nthis:\n  complex_of_real ((norm x)\\<^sup>2) + complex_of_real ((norm y)\\<^sup>2) +\n  cinner x y +\n  cinner y x\n  \\<le> complex_of_real ((norm x)\\<^sup>2) +\n        complex_of_real ((norm y)\\<^sup>2) +\n        complex_of_real (2 * norm x * norm y)\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "also"], ["proof (state)\nthis:\n  complex_of_real ((norm x)\\<^sup>2) + complex_of_real ((norm y)\\<^sup>2) +\n  cinner x y +\n  cinner y x\n  \\<le> complex_of_real ((norm x)\\<^sup>2) +\n        complex_of_real ((norm y)\\<^sup>2) +\n        complex_of_real (2 * norm x * norm y)\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "have \"\\<dots> = complex_of_real ((norm x + norm y)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real ((norm x)\\<^sup>2) +\n    complex_of_real ((norm y)\\<^sup>2) +\n    complex_of_real (2 * norm x * norm y) =\n    complex_of_real ((norm x + norm y)\\<^sup>2)", "unfolding power2_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real ((norm x)\\<^sup>2) +\n    complex_of_real ((norm y)\\<^sup>2) +\n    complex_of_real (2 * norm x * norm y) =\n    complex_of_real\n     ((norm x)\\<^sup>2 + (norm y)\\<^sup>2 + 2 * norm x * norm y)", "by auto"], ["proof (state)\nthis:\n  complex_of_real ((norm x)\\<^sup>2) + complex_of_real ((norm y)\\<^sup>2) +\n  complex_of_real (2 * norm x * norm y) =\n  complex_of_real ((norm x + norm y)\\<^sup>2)\n\ngoal (2 subgoals):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n 2. 0 \\<le> norm x + norm y", "finally"], ["proof (chain)\npicking this:\n  complex_of_real ((norm (x + y))\\<^sup>2)\n  \\<le> complex_of_real ((norm x + norm y)\\<^sup>2)", "show \"(norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\""], ["proof (prove)\nusing this:\n  complex_of_real ((norm (x + y))\\<^sup>2)\n  \\<le> complex_of_real ((norm x + norm y)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2", "using complex_of_real_mono_iff"], ["proof (prove)\nusing this:\n  complex_of_real ((norm (x + y))\\<^sup>2)\n  \\<le> complex_of_real ((norm x + norm y)\\<^sup>2)\n  (complex_of_real ?x \\<le> complex_of_real ?y) = (?x \\<le> ?y)\n\ngoal (1 subgoal):\n 1. (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2", "by blast"], ["proof (state)\nthis:\n  (norm (x + y))\\<^sup>2 \\<le> (norm x + norm y)\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> norm x + norm y", "show \"0 \\<le> norm x + norm y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> norm x + norm y", "unfolding norm_eq_sqrt_cinner"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> sqrt (cmod (cinner x x)) + sqrt (cmod (cinner y y))", "by simp"], ["proof (state)\nthis:\n  0 \\<le> norm x + norm y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (x + y) \\<le> norm x + norm y\n\ngoal (2 subgoals):\n 1. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 2. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show norm_scaleC: \"norm (a *\\<^sub>C x) = cmod a * norm x\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (a *\\<^sub>C x) = cmod a * norm x", "proof (rule power2_eq_imp_eq)"], ["proof (state)\ngoal (3 subgoals):\n 1. (norm (a *\\<^sub>C x))\\<^sup>2 = (cmod a * norm x)\\<^sup>2\n 2. 0 \\<le> norm (a *\\<^sub>C x)\n 3. 0 \\<le> cmod a * norm x", "show \"(norm (a *\\<^sub>C x))\\<^sup>2 = (cmod a * norm x)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (a *\\<^sub>C x))\\<^sup>2 = (cmod a * norm x)\\<^sup>2", "by (simp_all add: norm_eq_sqrt_cinner norm_mult power2_eq_square)"], ["proof (state)\nthis:\n  (norm (a *\\<^sub>C x))\\<^sup>2 = (cmod a * norm x)\\<^sup>2\n\ngoal (2 subgoals):\n 1. 0 \\<le> norm (a *\\<^sub>C x)\n 2. 0 \\<le> cmod a * norm x", "show \"0 \\<le> norm (a *\\<^sub>C x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> norm (a *\\<^sub>C x)", "by (simp_all add: norm_eq_sqrt_cinner)"], ["proof (state)\nthis:\n  0 \\<le> norm (a *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. 0 \\<le> cmod a * norm x", "show \"0 \\<le> cmod a * norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cmod a * norm x", "by (simp_all add: norm_eq_sqrt_cinner)"], ["proof (state)\nthis:\n  0 \\<le> cmod a * norm x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (?a1 *\\<^sub>C x) = cmod ?a1 * norm x\n\ngoal (1 subgoal):\n 1. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x", "show \"norm (r *\\<^sub>R x) = \\<bar>r\\<bar> * norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (r *\\<^sub>R x) = \\<bar>r\\<bar> * norm x", "unfolding scaleR_scaleC norm_scaleC"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (complex_of_real r) * norm x = \\<bar>r\\<bar> * norm x", "by auto"], ["proof (state)\nthis:\n  norm (r *\\<^sub>R x) = \\<bar>r\\<bar> * norm x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* Does not hold in the complex case *)\n(* lemma csquare_bound_lemma:\n  fixes x :: complex\n  shows \"x < (1 + x) * (1 + x)\" *)"], ["", "lemma csquare_continuous:\n  fixes e :: real\n  shows \"e > 0 \\<Longrightarrow> \\<exists>d. 0 < d \\<and> (\\<forall>y. cmod (y - x) < d \\<longrightarrow> cmod (y * y - x * x) < e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e \\<Longrightarrow>\n    \\<exists>d>0.\n       \\<forall>y.\n          cmod (y - x) < d \\<longrightarrow> cmod (y * y - x * x) < e", "using isCont_power[OF continuous_ident, of x, unfolded isCont_def LIM_eq, rule_format, of e 2]"], ["proof (prove)\nusing this:\n  0 < e \\<Longrightarrow>\n  \\<exists>s>0.\n     \\<forall>xa.\n        xa \\<noteq> x \\<and> cmod (xa - x) < s \\<longrightarrow>\n        cmod (xa\\<^sup>2 - x\\<^sup>2) < e\n\ngoal (1 subgoal):\n 1. 0 < e \\<Longrightarrow>\n    \\<exists>d>0.\n       \\<forall>y.\n          cmod (y - x) < d \\<longrightarrow> cmod (y * y - x * x) < e", "by (force simp add: power2_eq_square)"], ["", "lemma cnorm_le: \"norm x \\<le> norm y \\<longleftrightarrow> cinner x x \\<le> cinner y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm x \\<le> norm y) = (cinner x x \\<le> cinner y y)", "by (smt (verit) complex_of_real_mono_iff norm_eq_sqrt_cinner norm_ge_zero of_real_power power2_norm_eq_cinner real_sqrt_le_mono real_sqrt_pow2)"], ["", "lemma cnorm_lt: \"norm x < norm y \\<longleftrightarrow> cinner x x < cinner y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm x < norm y) = (cinner x x < cinner y y)", "by (meson cnorm_le less_le_not_le)"], ["", "lemma cnorm_eq: \"norm x = norm y \\<longleftrightarrow> cinner x x = cinner y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm x = norm y) = (cinner x x = cinner y y)", "by (metis norm_eq_sqrt_cinner power2_norm_eq_cinner)"], ["", "lemma cnorm_eq_1: \"norm x = 1 \\<longleftrightarrow> cinner x x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm x = 1) = (cinner x x = 1)", "by (metis cinner_ge_zero complex_of_real_cmod norm_eq_sqrt_cinner norm_one of_real_1 real_sqrt_eq_iff real_sqrt_one)"], ["", "lemma cinner_divide_left:\n  fixes a :: \"'a :: {complex_inner,complex_div_algebra}\"\n  shows \"cinner (a / of_complex m) b = (cinner a b) / cnj m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (a / of_complex m) b = cinner a b / cnj m", "by (metis cinner_mult_left' complex_cnj_inverse divide_inverse of_complex_inverse ordered_field_class.sign_simps(33))"], ["", "lemma cinner_divide_right:\n  fixes a :: \"'a :: {complex_inner,complex_div_algebra}\"\n  shows \"cinner a (b / of_complex m) = (cinner a b) / m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner a (b / of_complex m) = cinner a b / m", "by (metis cinner_mult_right' divide_inverse of_complex_inverse)"], ["", "text \\<open>\n  Re-enable constraints for \\<^term>\\<open>open\\<close>, \\<^term>\\<open>uniformity\\<close>,\n  \\<^term>\\<open>dist\\<close>, and \\<^term>\\<open>norm\\<close>.\n\\<close>"], ["", "setup \\<open>Sign.add_const_constraint\n  (\\<^const_name>\\<open>open\\<close>, SOME \\<^typ>\\<open>'a::topological_space set \\<Rightarrow> bool\\<close>)\\<close>"], ["", "setup \\<open>Sign.add_const_constraint\n  (\\<^const_name>\\<open>uniformity\\<close>, SOME \\<^typ>\\<open>('a::uniform_space \\<times> 'a) filter\\<close>)\\<close>"], ["", "setup \\<open>Sign.add_const_constraint\n  (\\<^const_name>\\<open>dist\\<close>, SOME \\<^typ>\\<open>'a::metric_space \\<Rightarrow> 'a \\<Rightarrow> real\\<close>)\\<close>"], ["", "setup \\<open>Sign.add_const_constraint\n  (\\<^const_name>\\<open>norm\\<close>, SOME \\<^typ>\\<open>'a::real_normed_vector \\<Rightarrow> real\\<close>)\\<close>"], ["", "lemma bounded_sesquilinear_cinner:\n  \"bounded_sesquilinear (cinner::'a::complex_inner \\<Rightarrow> 'a \\<Rightarrow> complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_sesquilinear cinner", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. cinner (a + a') b = cinner a b + cinner a' b\n 2. \\<And>a b b'. cinner a (b + b') = cinner a b + cinner a b'\n 3. \\<And>r a b. cinner (r *\\<^sub>C a) b = cnj r *\\<^sub>C cinner a b\n 4. \\<And>a r b. cinner a (r *\\<^sub>C b) = r *\\<^sub>C cinner a b\n 5. \\<exists>K. \\<forall>a b. cmod (cinner a b) \\<le> norm a * norm b * K", "fix x y z :: 'a and r :: complex"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. cinner (a + a') b = cinner a b + cinner a' b\n 2. \\<And>a b b'. cinner a (b + b') = cinner a b + cinner a b'\n 3. \\<And>r a b. cinner (r *\\<^sub>C a) b = cnj r *\\<^sub>C cinner a b\n 4. \\<And>a r b. cinner a (r *\\<^sub>C b) = r *\\<^sub>C cinner a b\n 5. \\<exists>K. \\<forall>a b. cmod (cinner a b) \\<le> norm a * norm b * K", "show \"cinner (x + y) z = cinner x z + cinner y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (x + y) z = cinner x z + cinner y z", "by (rule cinner_add_left)"], ["proof (state)\nthis:\n  cinner (x + y) z = cinner x z + cinner y z\n\ngoal (4 subgoals):\n 1. \\<And>a b b'. cinner a (b + b') = cinner a b + cinner a b'\n 2. \\<And>r a b. cinner (r *\\<^sub>C a) b = cnj r *\\<^sub>C cinner a b\n 3. \\<And>a r b. cinner a (r *\\<^sub>C b) = r *\\<^sub>C cinner a b\n 4. \\<exists>K. \\<forall>a b. cmod (cinner a b) \\<le> norm a * norm b * K", "show \"cinner x (y + z) = cinner x y + cinner x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x (y + z) = cinner x y + cinner x z", "by (rule cinner_add_right)"], ["proof (state)\nthis:\n  cinner x (y + z) = cinner x y + cinner x z\n\ngoal (3 subgoals):\n 1. \\<And>r a b. cinner (r *\\<^sub>C a) b = cnj r *\\<^sub>C cinner a b\n 2. \\<And>a r b. cinner a (r *\\<^sub>C b) = r *\\<^sub>C cinner a b\n 3. \\<exists>K. \\<forall>a b. cmod (cinner a b) \\<le> norm a * norm b * K", "show \"cinner (scaleC r x) y = scaleC (cnj r) (cinner x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (r *\\<^sub>C x) y = cnj r *\\<^sub>C cinner x y", "unfolding complex_scaleC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (r *\\<^sub>C x) y = cnj r * cinner x y", "by (rule cinner_scaleC_left)"], ["proof (state)\nthis:\n  cinner (r *\\<^sub>C x) y = cnj r *\\<^sub>C cinner x y\n\ngoal (2 subgoals):\n 1. \\<And>a r b. cinner a (r *\\<^sub>C b) = r *\\<^sub>C cinner a b\n 2. \\<exists>K. \\<forall>a b. cmod (cinner a b) \\<le> norm a * norm b * K", "show \"cinner x (scaleC r y) = scaleC r (cinner x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x (r *\\<^sub>C y) = r *\\<^sub>C cinner x y", "unfolding complex_scaleC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x (r *\\<^sub>C y) = r * cinner x y", "by (rule cinner_scaleC_right)"], ["proof (state)\nthis:\n  cinner x (r *\\<^sub>C y) = r *\\<^sub>C cinner x y\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. cmod (cinner a b) \\<le> norm a * norm b * K", "have \"\\<forall>x y::'a. norm (cinner x y) \\<le> norm x * norm y * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. cmod (cinner x y) \\<le> norm x * norm y * 1", "by (simp add: complex_inner_class.Cauchy_Schwarz_ineq2)"], ["proof (state)\nthis:\n  \\<forall>x y. cmod (cinner x y) \\<le> norm x * norm y * 1\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. cmod (cinner a b) \\<le> norm a * norm b * K", "thus \"\\<exists>K. \\<forall>x y::'a. norm (cinner x y) \\<le> norm x * norm y * K\""], ["proof (prove)\nusing this:\n  \\<forall>x y. cmod (cinner x y) \\<le> norm x * norm y * 1\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x y. cmod (cinner x y) \\<le> norm x * norm y * K", "by metis"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>x y. cmod (cinner x y) \\<le> norm x * norm y * K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas tendsto_cinner [tendsto_intros] =\n  bounded_bilinear.tendsto [OF bounded_sesquilinear_cinner[THEN bounded_sesquilinear.bounded_bilinear]]"], ["", "lemmas isCont_cinner [simp] =\n  bounded_bilinear.isCont [OF bounded_sesquilinear_cinner[THEN bounded_sesquilinear.bounded_bilinear]]"], ["", "lemmas has_derivative_cinner [derivative_intros] =\n  bounded_bilinear.FDERIV [OF bounded_sesquilinear_cinner[THEN bounded_sesquilinear.bounded_bilinear]]"], ["", "lemmas bounded_antilinear_cinner_left =\n  bounded_sesquilinear.bounded_antilinear_left [OF bounded_sesquilinear_cinner]"], ["", "lemmas bounded_clinear_cinner_right =\n  bounded_sesquilinear.bounded_clinear_right [OF bounded_sesquilinear_cinner]"], ["", "lemmas bounded_antilinear_cinner_left_comp = bounded_antilinear_cinner_left[THEN bounded_antilinear_o_bounded_clinear]"], ["", "lemmas bounded_clinear_cinner_right_comp = bounded_clinear_cinner_right[THEN bounded_clinear_compose]"], ["", "lemmas has_derivative_cinner_right [derivative_intros] =\n  bounded_linear.has_derivative [OF bounded_clinear_cinner_right[THEN bounded_clinear.bounded_linear]]"], ["", "lemmas has_derivative_cinner_left [derivative_intros] =\n  bounded_linear.has_derivative [OF bounded_antilinear_cinner_left[THEN bounded_antilinear.bounded_linear]]"], ["", "lemma differentiable_cinner [simp]:\n  \"f differentiable (at x within s) \\<Longrightarrow> g differentiable at x within s \\<Longrightarrow> (\\<lambda>x. cinner (f x) (g x)) differentiable at x within s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f differentiable at x within s;\n     g differentiable at x within s\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. cinner (f x) (g x)) differentiable at x\n                      within s", "unfolding differentiable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>D. (f has_derivative D) (at x within s);\n     \\<exists>D. (g has_derivative D) (at x within s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>D.\n                         ((\\<lambda>x. cinner (f x) (g x)) has_derivative D)\n                          (at x within s)", "by (blast intro: has_derivative_cinner)"], ["", "subsection \\<open>Class instances\\<close>"], ["", "instantiation complex :: complex_inner\nbegin"], ["", "definition cinner_complex_def [simp]: \"cinner x y = cnj x * y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(complex, complex_inner_class)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y. cinner x y = cnj (cinner y x)\n 2. \\<And>x y z. cinner (x + y) z = cinner x z + cinner y z\n 3. \\<And>r x y. cinner (r *\\<^sub>C x) y = cnj r * cinner x y\n 4. \\<And>x. 0 \\<le> cinner x x\n 5. \\<And>x. (cinner x x = 0) = (x = 0)\n 6. \\<And>x. cmod x = sqrt (cmod (cinner x x))", "fix x y z r :: complex"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y. cinner x y = cnj (cinner y x)\n 2. \\<And>x y z. cinner (x + y) z = cinner x z + cinner y z\n 3. \\<And>r x y. cinner (r *\\<^sub>C x) y = cnj r * cinner x y\n 4. \\<And>x. 0 \\<le> cinner x x\n 5. \\<And>x. (cinner x x = 0) = (x = 0)\n 6. \\<And>x. cmod x = sqrt (cmod (cinner x x))", "show \"cinner x y = cnj (cinner y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x y = cnj (cinner y x)", "unfolding cinner_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj x * y = cnj (cnj y * x)", "by auto"], ["proof (state)\nthis:\n  cinner x y = cnj (cinner y x)\n\ngoal (5 subgoals):\n 1. \\<And>x y z. cinner (x + y) z = cinner x z + cinner y z\n 2. \\<And>r x y. cinner (r *\\<^sub>C x) y = cnj r * cinner x y\n 3. \\<And>x. 0 \\<le> cinner x x\n 4. \\<And>x. (cinner x x = 0) = (x = 0)\n 5. \\<And>x. cmod x = sqrt (cmod (cinner x x))", "show \"cinner (x + y) z = cinner x z + cinner y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (x + y) z = cinner x z + cinner y z", "unfolding cinner_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (x + y) * z = cnj x * z + cnj y * z", "by (simp add: ring_class.ring_distribs(2))"], ["proof (state)\nthis:\n  cinner (x + y) z = cinner x z + cinner y z\n\ngoal (4 subgoals):\n 1. \\<And>r x y. cinner (r *\\<^sub>C x) y = cnj r * cinner x y\n 2. \\<And>x. 0 \\<le> cinner x x\n 3. \\<And>x. (cinner x x = 0) = (x = 0)\n 4. \\<And>x. cmod x = sqrt (cmod (cinner x x))", "show \"cinner (scaleC r x) y = cnj r * cinner x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (r *\\<^sub>C x) y = cnj r * cinner x y", "unfolding cinner_complex_def complex_scaleC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (r * x) * y = cnj r * (cnj x * y)", "by simp"], ["proof (state)\nthis:\n  cinner (r *\\<^sub>C x) y = cnj r * cinner x y\n\ngoal (3 subgoals):\n 1. \\<And>x. 0 \\<le> cinner x x\n 2. \\<And>x. (cinner x x = 0) = (x = 0)\n 3. \\<And>x. cmod x = sqrt (cmod (cinner x x))", "show \"0 \\<le> cinner x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cinner x x", "by simp"], ["proof (state)\nthis:\n  0 \\<le> cinner x x\n\ngoal (2 subgoals):\n 1. \\<And>x. (cinner x x = 0) = (x = 0)\n 2. \\<And>x. cmod x = sqrt (cmod (cinner x x))", "show \"cinner x x = 0 \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cinner x x = 0) = (x = 0)", "unfolding cinner_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cnj x * x = 0) = (x = 0)", "by simp"], ["proof (state)\nthis:\n  (cinner x x = 0) = (x = 0)\n\ngoal (1 subgoal):\n 1. \\<And>x. cmod x = sqrt (cmod (cinner x x))", "have \"cmod (Complex x1 x2) = sqrt (cmod (cinner (Complex x1 x2) (Complex x1 x2)))\"\n    for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (Complex x1 x2) =\n    sqrt (cmod (cinner (Complex x1 x2) (Complex x1 x2)))", "unfolding cinner_complex_def complex_cnj complex_mult complex_norm"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (x1\\<^sup>2 + x2\\<^sup>2) =\n    sqrt\n     (sqrt ((x1 * x1 - - x2 * x2)\\<^sup>2 + (x1 * x2 + - x2 * x1)\\<^sup>2))", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  cmod (Complex ?x1.0 ?x2.0) =\n  sqrt (cmod (cinner (Complex ?x1.0 ?x2.0) (Complex ?x1.0 ?x2.0)))\n\ngoal (1 subgoal):\n 1. \\<And>x. cmod x = sqrt (cmod (cinner x x))", "thus \"norm x = sqrt (cmod (cinner x x))\""], ["proof (prove)\nusing this:\n  cmod (Complex ?x1.0 ?x2.0) =\n  sqrt (cmod (cinner (Complex ?x1.0 ?x2.0) (Complex ?x1.0 ?x2.0)))\n\ngoal (1 subgoal):\n 1. cmod x = sqrt (cmod (cinner x x))", "by (cases x, hypsubst_thin)"], ["proof (state)\nthis:\n  cmod x = sqrt (cmod (cinner x x))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma\n  shows complex_inner_1_left[simp]: \"cinner 1 x = x\"\n    and complex_inner_1_right[simp]: \"cinner x 1 = cnj x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner 1 x = x &&& cinner x 1 = cnj x", "by simp_all"], ["", "(* No analogous to \\<open>instantiation complex :: real_inner\\<close> or to\nlemma complex_inner_1 [simp]: \"inner 1 x = Re x\"\nlemma complex_inner_1_right [simp]: \"inner x 1 = Re x\"\nlemma complex_inner_i_left [simp]: \"inner \\<i> x = Im x\"\nlemma complex_inner_i_right [simp]: \"inner x \\<i> = Im x\"\n *)"], ["", "lemma cdot_square_norm: \"cinner x x = complex_of_real ((norm x)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x x = complex_of_real ((norm x)\\<^sup>2)", "by (metis Im_complex_of_real Re_complex_of_real cinner_ge_zero complex_eq_iff less_eq_complex_def power2_norm_eq_cinner' zero_complex.simps(2))"], ["", "lemma cnorm_eq_square: \"norm x = a \\<longleftrightarrow> 0 \\<le> a \\<and> cinner x x = complex_of_real (a\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm x = a) =\n    (0 \\<le> a \\<and> cinner x x = complex_of_real (a\\<^sup>2))", "by (metis cdot_square_norm norm_ge_zero of_real_eq_iff power2_eq_iff_nonneg)"], ["", "lemma cnorm_le_square: \"norm x \\<le> a \\<longleftrightarrow> 0 \\<le> a \\<and> cinner x x \\<le> complex_of_real (a\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm x \\<le> a) =\n    (0 \\<le> a \\<and> cinner x x \\<le> complex_of_real (a\\<^sup>2))", "by (smt (verit) cdot_square_norm complex_of_real_mono_iff norm_ge_zero power2_le_imp_le)"], ["", "lemma cnorm_ge_square: \"norm x \\<ge> a \\<longleftrightarrow> a \\<le> 0 \\<or> cinner x x \\<ge> complex_of_real (a\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> norm x) =\n    (a \\<le> 0 \\<or> complex_of_real (a\\<^sup>2) \\<le> cinner x x)", "by (smt (verit, best) antisym_conv cnorm_eq_square cnorm_le_square complex_of_real_nn_iff nn_comparable zero_le_power2)"], ["", "lemma norm_lt_square: \"norm x < a \\<longleftrightarrow> 0 < a \\<and> cinner x x < complex_of_real (a\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm x < a) = (0 < a \\<and> cinner x x < complex_of_real (a\\<^sup>2))", "by (meson cnorm_ge_square cnorm_le_square less_le_not_le)"], ["", "lemma norm_gt_square: \"norm x > a \\<longleftrightarrow> a < 0 \\<or> cinner x x > complex_of_real (a\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < norm x) = (a < 0 \\<or> complex_of_real (a\\<^sup>2) < cinner x x)", "by (smt (verit, ccfv_SIG) cdot_square_norm complex_of_real_strict_mono_iff norm_ge_zero power2_eq_imp_eq power_mono)"], ["", "text\\<open>Dot product in terms of the norm rather than conversely.\\<close>"], ["", "lemmas cinner_simps = cinner_add_left cinner_add_right cinner_diff_right cinner_diff_left\n  cinner_scaleC_left cinner_scaleC_right"], ["", "(* Analogue to both dot_norm and dot_norm_neg *)"], ["", "lemma cdot_norm: \"cinner x y = ((norm (x+y))\\<^sup>2 - (norm (x-y))\\<^sup>2 - \\<i> * (norm (x + \\<i> *\\<^sub>C y))\\<^sup>2 + \\<i> * (norm (x - \\<i> *\\<^sub>C y))\\<^sup>2) / 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x y =\n    (complex_of_real ((norm (x + y))\\<^sup>2 - (norm (x - y))\\<^sup>2) -\n     \\<i> * complex_of_real ((norm (x + \\<i> *\\<^sub>C y))\\<^sup>2) +\n     \\<i> * complex_of_real ((norm (x - \\<i> *\\<^sub>C y))\\<^sup>2)) /\n    4", "unfolding power2_norm_eq_cinner"], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner x y =\n    (complex_of_real ((norm (x + y))\\<^sup>2 - (norm (x - y))\\<^sup>2) -\n     \\<i> * complex_of_real ((norm (x + \\<i> *\\<^sub>C y))\\<^sup>2) +\n     \\<i> * complex_of_real ((norm (x - \\<i> *\\<^sub>C y))\\<^sup>2)) /\n    4", "by (simp add: power2_norm_eq_cinner cinner_add_left cinner_add_right \n      cinner_diff_left cinner_diff_right ring_distribs)"], ["", "lemma of_complex_inner_1 [simp]: \n  \"cinner (of_complex x) (1 :: 'a :: {complex_inner, complex_normed_algebra_1}) = cnj x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cinner (of_complex x) (1::'a) = cnj x", "by (metis Complex_Inner_Product0.complex_inner_1_right cinner_complex_def cinner_mult_left complex_cnj_one norm_one of_complex_def power2_norm_eq_cinner scaleC_conv_of_complex)"], ["", "lemma summable_of_complex_iff: \n  \"summable (\\<lambda>x. of_complex (f x) :: 'a :: {complex_normed_algebra_1,complex_inner}) \\<longleftrightarrow> summable f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>x. of_complex (f x)) = summable f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. summable (\\<lambda>x. of_complex (f x)) \\<Longrightarrow> summable f\n 2. summable f \\<Longrightarrow> summable (\\<lambda>x. of_complex (f x))", "assume *: \"summable (\\<lambda>x. of_complex (f x) :: 'a)\""], ["proof (state)\nthis:\n  summable (\\<lambda>x. of_complex (f x))\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>x. of_complex (f x)) \\<Longrightarrow> summable f\n 2. summable f \\<Longrightarrow> summable (\\<lambda>x. of_complex (f x))", "have \"bounded_clinear (cinner (1::'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (cinner (1::'a))", "by (rule bounded_clinear_cinner_right)"], ["proof (state)\nthis:\n  bounded_clinear (cinner (1::'a))\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>x. of_complex (f x)) \\<Longrightarrow> summable f\n 2. summable f \\<Longrightarrow> summable (\\<lambda>x. of_complex (f x))", "then"], ["proof (chain)\npicking this:\n  bounded_clinear (cinner (1::'a))", "interpret bounded_linear \"\\<lambda>x::'a. cinner 1 x\""], ["proof (prove)\nusing this:\n  bounded_clinear (cinner (1::'a))\n\ngoal (1 subgoal):\n 1. bounded_linear (cinner (1::'a))", "by (rule bounded_clinear.bounded_linear)"], ["proof (state)\ngoal (2 subgoals):\n 1. summable (\\<lambda>x. of_complex (f x)) \\<Longrightarrow> summable f\n 2. summable f \\<Longrightarrow> summable (\\<lambda>x. of_complex (f x))", "from summable [OF *]"], ["proof (chain)\npicking this:\n  summable (\\<lambda>n. cinner (1::'a) (of_complex (f n)))", "show \"summable f\""], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. cinner (1::'a) (of_complex (f n)))\n\ngoal (1 subgoal):\n 1. summable f", "apply (subst (asm) cinner_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>n. cnj (cinner (of_complex (f n)) (1::'a))) \\<Longrightarrow>\n    summable f", "by simp"], ["proof (state)\nthis:\n  summable f\n\ngoal (1 subgoal):\n 1. summable f \\<Longrightarrow> summable (\\<lambda>x. of_complex (f x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. summable f \\<Longrightarrow> summable (\\<lambda>x. of_complex (f x))", "assume sum: \"summable f\""], ["proof (state)\nthis:\n  summable f\n\ngoal (1 subgoal):\n 1. summable f \\<Longrightarrow> summable (\\<lambda>x. of_complex (f x))", "thus \"summable (\\<lambda>x. of_complex (f x) :: 'a)\""], ["proof (prove)\nusing this:\n  summable f\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>x. of_complex (f x))", "by (rule summable_of_complex)"], ["proof (state)\nthis:\n  summable (\\<lambda>x. of_complex (f x))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Gradient derivative\\<close>"], ["", "definition\\<^marker>\\<open>tag important\\<close>\n  cgderiv :: \"['a::complex_inner \\<Rightarrow> complex, 'a, 'a] \\<Rightarrow> bool\"\n  (\"(cGDERIV (_)/ (_)/ :> (_))\" [1000, 1000, 60] 60)\n  where\n    (* Must be \"cinner D\" not \"\\<lambda>h. cinner h D\", otherwise not even \"cGDERIV id x :> 1\" holds *)\n    \"cGDERIV f x :> D \\<longleftrightarrow> FDERIV f x :> cinner D\""], ["", "lemma cgderiv_deriv [simp]: \"cGDERIV f x :> D \\<longleftrightarrow> DERIV f x :> cnj D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cGDERIV f x :> D = (f has_field_derivative cnj D) (at x)", "by (simp only: cgderiv_def has_field_derivative_def cinner_complex_def[THEN ext])"], ["", "lemma cGDERIV_DERIV_compose:\n  assumes \"cGDERIV f x :> df\" and \"DERIV g (f x) :> cnj dg\"\n  shows \"cGDERIV (\\<lambda>x. g (f x)) x :> scaleC dg df\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cGDERIV (\\<lambda>x. g (f x)) x :> dg *\\<^sub>C df", "proof (insert assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>cGDERIV f x :> df;\n     (g has_field_derivative cnj dg) (at (f x))\\<rbrakk>\n    \\<Longrightarrow> cGDERIV (\\<lambda>x. g (f x)) x :> dg *\\<^sub>C df", "show \"cGDERIV (\\<lambda>x. g (f x)) x :> dg *\\<^sub>C df\"\n    if \"cGDERIV f x :> df\"\n      and \"(g has_field_derivative cnj dg) (at (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cGDERIV (\\<lambda>x. g (f x)) x :> dg *\\<^sub>C df", "unfolding cgderiv_def has_field_derivative_def cinner_scaleC_left complex_cnj_cnj"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g (f x)) has_derivative\n     (\\<lambda>y. cnj dg * cinner df y))\n     (at x)", "using that"], ["proof (prove)\nusing this:\n  cGDERIV f x :> df\n  (g has_field_derivative cnj dg) (at (f x))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. g (f x)) has_derivative\n     (\\<lambda>y. cnj dg * cinner df y))\n     (at x)", "by (simp add: cgderiv_def has_derivative_compose has_field_derivative_imp_has_derivative)"], ["proof (state)\nthis:\n  \\<lbrakk>cGDERIV f x :> df;\n   (g has_field_derivative cnj dg) (at (f x))\\<rbrakk>\n  \\<Longrightarrow> cGDERIV (\\<lambda>x. g (f x)) x :> dg *\\<^sub>C df\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Not specific to complex/real *)\n(* lemma has_derivative_subst: \"\\<lbrakk>FDERIV f x :> df; df = d\\<rbrakk> \\<Longrightarrow> FDERIV f x :> d\" *)"], ["", "lemma cGDERIV_subst: \"\\<lbrakk>cGDERIV f x :> df; df = d\\<rbrakk> \\<Longrightarrow> cGDERIV f x :> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cGDERIV f x :> df; df = d\\<rbrakk>\n    \\<Longrightarrow> cGDERIV f x :> d", "by simp"], ["", "lemma cGDERIV_const: \"cGDERIV (\\<lambda>x. k) x :> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cGDERIV (\\<lambda>x. k) x :> (0::'a)", "unfolding cgderiv_def cinner_zero_left[THEN ext]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. k) has_derivative (\\<lambda>x. 0)) (at x)", "by (rule has_derivative_const)"], ["", "lemma cGDERIV_add:\n  \"\\<lbrakk>cGDERIV f x :> df; cGDERIV g x :> dg\\<rbrakk>\n     \\<Longrightarrow> cGDERIV (\\<lambda>x. f x + g x) x :> df + dg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cGDERIV f x :> df; cGDERIV g x :> dg\\<rbrakk>\n    \\<Longrightarrow> cGDERIV (\\<lambda>x. f x + g x) x :> df + dg", "unfolding cgderiv_def cinner_add_left[THEN ext]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f has_derivative cinner df) (at x);\n     (g has_derivative cinner dg) (at x)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. f x + g x) has_derivative\n                       (\\<lambda>x. cinner df x + cinner dg x))\n                       (at x)", "by (rule has_derivative_add)"], ["", "lemma cGDERIV_minus:\n  \"cGDERIV f x :> df \\<Longrightarrow> cGDERIV (\\<lambda>x. - f x) x :> - df\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cGDERIV f x :> df \\<Longrightarrow>\n    cGDERIV (\\<lambda>x. - f x) x :> - df", "unfolding cgderiv_def cinner_minus_left[THEN ext]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_derivative cinner df) (at x) \\<Longrightarrow>\n    ((\\<lambda>x. - f x) has_derivative (\\<lambda>x. - cinner df x)) (at x)", "by (rule has_derivative_minus)"], ["", "lemma cGDERIV_diff:\n  \"\\<lbrakk>cGDERIV f x :> df; cGDERIV g x :> dg\\<rbrakk>\n     \\<Longrightarrow> cGDERIV (\\<lambda>x. f x - g x) x :> df - dg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cGDERIV f x :> df; cGDERIV g x :> dg\\<rbrakk>\n    \\<Longrightarrow> cGDERIV (\\<lambda>x. f x - g x) x :> df - dg", "unfolding cgderiv_def cinner_diff_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f has_derivative cinner df) (at x);\n     (g has_derivative cinner dg) (at x)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. f x - g x) has_derivative\n                       (\\<lambda>z. cinner df z - cinner dg z))\n                       (at x)", "by (rule has_derivative_diff)"], ["", "lemma cGDERIV_scaleC:\n  \"\\<lbrakk>DERIV f x :> df; cGDERIV g x :> dg\\<rbrakk>\n     \\<Longrightarrow> cGDERIV (\\<lambda>x. scaleC (f x) (g x)) x\n      :> (scaleC (cnj (f x)) dg + scaleC (cnj df) (cnj (g x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f has_field_derivative df) (at x); cGDERIV g x :> dg\\<rbrakk>\n    \\<Longrightarrow> cGDERIV (\\<lambda>x. f x *\\<^sub>C g x) x\n                      :> cnj (f x) *\\<^sub>C dg + cnj df *\\<^sub>C cnj (g x)", "unfolding cgderiv_def has_field_derivative_def cinner_add_left cinner_scaleC_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f has_derivative (*) df) (at x);\n     (g has_derivative cinner dg) (at x)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. f x *\\<^sub>C g x) has_derivative\n                       (\\<lambda>z.\n                           cnj (cnj (f x)) * cinner dg z +\n                           cnj (cnj df) * cinner (cnj (g x)) z))\n                       (at x)", "apply (rule has_derivative_subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(f has_derivative (*) df) (at x);\n     (g has_derivative cinner dg) (at x)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. f x *\\<^sub>C g x) has_derivative ?df)\n                       (at x)\n 2. \\<lbrakk>(f has_derivative (*) df) (at x);\n     (g has_derivative cinner dg) (at x)\\<rbrakk>\n    \\<Longrightarrow> ?df =\n                      (\\<lambda>z.\n                          cnj (cnj (f x)) * cinner dg z +\n                          cnj (cnj df) * cinner (cnj (g x)) z)", "apply (erule (1) has_derivative_scaleC)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f has_derivative (*) df) (at x);\n     (g has_derivative cinner dg) (at x)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>h.\n                          f x *\\<^sub>C cinner dg h +\n                          (df * h) *\\<^sub>C g x) =\n                      (\\<lambda>z.\n                          cnj (cnj (f x)) * cinner dg z +\n                          cnj (cnj df) * cinner (cnj (g x)) z)", "by (simp add: ac_simps)"], ["", "lemma GDERIV_mult:\n  \"\\<lbrakk>cGDERIV f x :> df; cGDERIV g x :> dg\\<rbrakk>\n     \\<Longrightarrow> cGDERIV (\\<lambda>x. f x * g x) x :> cnj (f x) *\\<^sub>C dg + cnj (g x) *\\<^sub>C df\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cGDERIV f x :> df; cGDERIV g x :> dg\\<rbrakk>\n    \\<Longrightarrow> cGDERIV (\\<lambda>x. f x * g x) x\n                      :> cnj (f x) *\\<^sub>C dg + cnj (g x) *\\<^sub>C df", "unfolding cgderiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f has_derivative cinner df) (at x);\n     (g has_derivative cinner dg) (at x)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. f x * g x) has_derivative\n                       cinner\n                        (cnj (f x) *\\<^sub>C dg + cnj (g x) *\\<^sub>C df))\n                       (at x)", "apply (rule has_derivative_subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(f has_derivative cinner df) (at x);\n     (g has_derivative cinner dg) (at x)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>x. f x * g x) has_derivative ?df) (at x)\n 2. \\<lbrakk>(f has_derivative cinner df) (at x);\n     (g has_derivative cinner dg) (at x)\\<rbrakk>\n    \\<Longrightarrow> ?df =\n                      cinner\n                       (cnj (f x) *\\<^sub>C dg + cnj (g x) *\\<^sub>C df)", "apply (erule (1) has_derivative_mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f has_derivative cinner df) (at x);\n     (g has_derivative cinner dg) (at x)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>h. f x * cinner dg h + cinner df h * g x) =\n                      cinner\n                       (cnj (f x) *\\<^sub>C dg + cnj (g x) *\\<^sub>C df)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<lbrakk>(f has_derivative cinner df) (at x);\n        (g has_derivative cinner dg) (at x)\\<rbrakk>\n       \\<Longrightarrow> f x * cinner dg h + cinner df h * g x =\n                         cinner\n                          (cnj (f x) *\\<^sub>C dg + cnj (g x) *\\<^sub>C df)\n                          h", "by (simp add: cinner_add ac_simps)"], ["", "lemma cGDERIV_inverse:\n  \"\\<lbrakk>cGDERIV f x :> df; f x \\<noteq> 0\\<rbrakk>\n     \\<Longrightarrow> cGDERIV (\\<lambda>x. inverse (f x)) x :> - cnj ((inverse (f x))\\<^sup>2) *\\<^sub>C df\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cGDERIV f x :> df; f x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cGDERIV (\\<lambda>x. inverse (f x)) x\n                      :> - cnj ((inverse (f x))\\<^sup>2) *\\<^sub>C df", "by (metis DERIV_inverse cGDERIV_DERIV_compose complex_cnj_cnj complex_cnj_minus numerals(2))"], ["", "(* Don't know if this holds: *)\n(* lemma cGDERIV_norm:\n  assumes \"x \\<noteq> 0\" shows \"cGDERIV (\\<lambda>x. norm x) x :> sgn x\" \n*)"], ["", "lemma has_derivative_norm[derivative_intros]:\n  fixes x :: \"'a::complex_inner\"\n  assumes \"x \\<noteq> 0\" \n  shows \"(norm has_derivative (\\<lambda>h. Re (cinner (sgn x) h))) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm has_derivative (\\<lambda>h. Re (cinner (sgn x) h))) (at x)", "thm has_derivative_norm"], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm has_derivative (\\<lambda>h. Re (cinner (sgn x) h))) (at x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (norm has_derivative (\\<lambda>h. Re (cinner (sgn x) h))) (at x)", "have Re_pos: \"0 < Re (cinner x x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Re (cinner x x)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < Re (cinner x x)", "by (metis Re_strict_mono cinner_gt_zero_iff zero_complex.simps(1))"], ["proof (state)\nthis:\n  0 < Re (cinner x x)\n\ngoal (1 subgoal):\n 1. (norm has_derivative (\\<lambda>h. Re (cinner (sgn x) h))) (at x)", "have Re_plus_Re: \"Re (cinner x y) + Re (cinner y x) = 2 * Re (cinner x y)\" \n    for x y :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (cinner x y) + Re (cinner y x) = 2 * Re (cinner x y)", "by (metis cinner_commute cnj.simps(1) mult_2_right semiring_normalization_rules(7))"], ["proof (state)\nthis:\n  Re (cinner ?x ?y) + Re (cinner ?y ?x) = 2 * Re (cinner ?x ?y)\n\ngoal (1 subgoal):\n 1. (norm has_derivative (\\<lambda>h. Re (cinner (sgn x) h))) (at x)", "have norm: \"norm x = sqrt (Re (cinner x x))\" for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x = sqrt (Re (cinner x x))", "apply (subst norm_eq_sqrt_cinner, subst cmod_Re)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> cinner x x\n 2. sqrt (Re (cinner x x)) = sqrt (Re (cinner x x))", "using cinner_ge_zero"], ["proof (prove)\nusing this:\n  0 \\<le> cinner ?x ?x\n\ngoal (2 subgoals):\n 1. 0 \\<le> cinner x x\n 2. sqrt (Re (cinner x x)) = sqrt (Re (cinner x x))", "by auto"], ["proof (state)\nthis:\n  norm ?x = sqrt (Re (cinner ?x ?x))\n\ngoal (1 subgoal):\n 1. (norm has_derivative (\\<lambda>h. Re (cinner (sgn x) h))) (at x)", "have v2:\"((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n          (\\<lambda>xa. (Re (cinner x xa) + Re (cinner xa x)) * (inverse (sqrt (Re (cinner x x))) / 2))) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n     (\\<lambda>xa.\n         (Re (cinner x xa) + Re (cinner xa x)) *\n         (inverse (sqrt (Re (cinner x x))) / 2)))\n     (at x)", "by (rule derivative_eq_intros | simp add: Re_pos)+"], ["proof (state)\nthis:\n  ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n   (\\<lambda>xa.\n       (Re (cinner x xa) + Re (cinner xa x)) *\n       (inverse (sqrt (Re (cinner x x))) / 2)))\n   (at x)\n\ngoal (1 subgoal):\n 1. (norm has_derivative (\\<lambda>h. Re (cinner (sgn x) h))) (at x)", "have v1: \"((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative (\\<lambda>y. Re (cinner x y) / sqrt (Re (cinner x x)))) (at x)\"\n    if \"((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative (\\<lambda>xa. Re (cinner x xa) * inverse (sqrt (Re (cinner x x))))) (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n     (\\<lambda>y. Re (cinner x y) / sqrt (Re (cinner x x))))\n     (at x)", "using that"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n   (\\<lambda>xa. Re (cinner x xa) * inverse (sqrt (Re (cinner x x)))))\n   (at x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n     (\\<lambda>y. Re (cinner x y) / sqrt (Re (cinner x x))))\n     (at x)", "apply (subst divide_real_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n     (\\<lambda>xa. Re (cinner x xa) * inverse (sqrt (Re (cinner x x)))))\n     (at x) \\<Longrightarrow>\n    ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n     (\\<lambda>y. Re (cinner x y) * inverse (sqrt (Re (cinner x x)))))\n     (at x)", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n   (\\<lambda>xa. Re (cinner x xa) * inverse (sqrt (Re (cinner x x)))))\n   (at x) \\<Longrightarrow>\n  ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n   (\\<lambda>y. Re (cinner x y) / sqrt (Re (cinner x x))))\n   (at x)\n\ngoal (1 subgoal):\n 1. (norm has_derivative (\\<lambda>h. Re (cinner (sgn x) h))) (at x)", "have \\<open>(norm has_derivative (\\<lambda>y. Re (cinner x y) / norm x)) (at x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm has_derivative (\\<lambda>y. Re (cinner x y) / norm x)) (at x)", "using v2"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n   (\\<lambda>xa.\n       (Re (cinner x xa) + Re (cinner xa x)) *\n       (inverse (sqrt (Re (cinner x x))) / 2)))\n   (at x)\n\ngoal (1 subgoal):\n 1. (norm has_derivative (\\<lambda>y. Re (cinner x y) / norm x)) (at x)", "apply (auto simp: Re_plus_Re norm [abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n     (\\<lambda>xa. Re (cinner x xa) * inverse (sqrt (Re (cinner x x)))))\n     (at x) \\<Longrightarrow>\n    ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n     (\\<lambda>y. Re (cinner x y) / sqrt (Re (cinner x x))))\n     (at x)", "using v1"], ["proof (prove)\nusing this:\n  ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n   (\\<lambda>xa. Re (cinner x xa) * inverse (sqrt (Re (cinner x x)))))\n   (at x) \\<Longrightarrow>\n  ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n   (\\<lambda>y. Re (cinner x y) / sqrt (Re (cinner x x))))\n   (at x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n     (\\<lambda>xa. Re (cinner x xa) * inverse (sqrt (Re (cinner x x)))))\n     (at x) \\<Longrightarrow>\n    ((\\<lambda>x. sqrt (Re (cinner x x))) has_derivative\n     (\\<lambda>y. Re (cinner x y) / sqrt (Re (cinner x x))))\n     (at x)", "by blast"], ["proof (state)\nthis:\n  (norm has_derivative (\\<lambda>y. Re (cinner x y) / norm x)) (at x)\n\ngoal (1 subgoal):\n 1. (norm has_derivative (\\<lambda>h. Re (cinner (sgn x) h))) (at x)", "then"], ["proof (chain)\npicking this:\n  (norm has_derivative (\\<lambda>y. Re (cinner x y) / norm x)) (at x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (norm has_derivative (\\<lambda>y. Re (cinner x y) / norm x)) (at x)\n\ngoal (1 subgoal):\n 1. (norm has_derivative (\\<lambda>h. Re (cinner (sgn x) h))) (at x)", "by (auto simp: power2_eq_square sgn_div_norm scaleR_scaleC)"], ["proof (state)\nthis:\n  (norm has_derivative (\\<lambda>h. Re (cinner (sgn x) h))) (at x)\n\ngoal:\nNo subgoals!", "qed"], ["", "bundle cinner_syntax begin"], ["", "notation cinner (infix \"\\<bullet>\\<^sub>C\" 70)"], ["", "end"], ["", "bundle no_cinner_syntax begin"], ["", "no_notation cinner (infix \"\\<bullet>\\<^sub>C\" 70)"], ["", "end"], ["", "end"]]}