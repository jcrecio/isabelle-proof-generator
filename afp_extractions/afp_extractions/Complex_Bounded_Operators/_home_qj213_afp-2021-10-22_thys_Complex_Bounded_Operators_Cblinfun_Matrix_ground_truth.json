{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators/Cblinfun_Matrix.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators", "problem_names": ["lemma dim_vec_of_basis_enum'[simp]:\n  \\<open>dim_vec (vec_of_basis_enum (v::'a)) = length (canonical_basis::'a::basis_enum list)\\<close>", "lemma vec_of_basis_enum_inverse[simp]:\n  fixes w::\"'a::basis_enum\"\n  shows  \"basis_enum_of_vec (vec_of_basis_enum w) = w\"", "lemma basis_enum_of_vec_inverse[simp]:\n  fixes v::\"complex vec\"\n  defines \"n \\<equiv> length (canonical_basis :: 'a::basis_enum list)\"\n  assumes f1: \"dim_vec v = n\"\n  shows \"vec_of_basis_enum ((basis_enum_of_vec v)::'a) = v\"", "lemma basis_enum_eq_vec_of_basis_enumI:\n  fixes a b :: \"_::basis_enum\"\n  assumes \"vec_of_basis_enum a = vec_of_basis_enum b\"\n  shows \"a = b\"", "lemma basis_enum_of_vec_add:\n  assumes [simp]: \\<open>dim_vec v1 = length (canonical_basis :: 'a::basis_enum list)\\<close> \n    \\<open>dim_vec v2 = length (canonical_basis :: 'a list)\\<close>\n  shows \\<open>((basis_enum_of_vec (v1 + v2)) :: 'a) = basis_enum_of_vec v1 + basis_enum_of_vec v2\\<close>", "lemma basis_enum_of_vec_mult:\n  assumes [simp]: \\<open>dim_vec v = length (canonical_basis :: 'a::basis_enum list)\\<close> \n  shows \\<open>((basis_enum_of_vec (c \\<cdot>\\<^sub>v v)) :: 'a) =  c *\\<^sub>C basis_enum_of_vec v\\<close>", "lemma vec_of_basis_enum_add:\n  \"vec_of_basis_enum (b1 + b2) = vec_of_basis_enum b1 + vec_of_basis_enum b2\"", "lemma vec_of_basis_enum_scaleC:\n  \"vec_of_basis_enum (c *\\<^sub>C b) = c \\<cdot>\\<^sub>v (vec_of_basis_enum b)\"", "lemma vec_of_basis_enum_scaleR:\n  \"vec_of_basis_enum (r *\\<^sub>R b) = complex_of_real r \\<cdot>\\<^sub>v (vec_of_basis_enum b)\"", "lemma vec_of_basis_enum_uminus:\n  \"vec_of_basis_enum (- b2) = - vec_of_basis_enum b2\"", "lemma vec_of_basis_enum_minus:\n  \"vec_of_basis_enum (b1 - b2) = vec_of_basis_enum b1 - vec_of_basis_enum b2\"", "lemma cinner_basis_enum_of_vec:\n  defines \"n \\<equiv> length (canonical_basis :: 'a::onb_enum list)\"\n  assumes [simp]: \"dim_vec x = n\" \"dim_vec y = n\"\n  shows  \"\\<langle>basis_enum_of_vec x :: 'a, basis_enum_of_vec y\\<rangle> = y \\<bullet>c x\"", "lemma cscalar_prod_vec_of_basis_enum: \"cscalar_prod (vec_of_basis_enum \\<phi>) (vec_of_basis_enum \\<psi>) = cinner \\<psi> \\<phi>\"\n  for \\<psi> :: \"'a::onb_enum\"", "lemma norm_ell2_vec_of_basis_enum: \"norm \\<psi> =\n  (let \\<psi>' = vec_of_basis_enum \\<psi> in\n    sqrt (\\<Sum> i \\<in> {0 ..< dim_vec \\<psi>'}. let z = vec_index \\<psi>' i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))\"\n  (is \"_ = ?rhs\") for \\<psi> :: \"'a::onb_enum\"", "lemma basis_enum_of_vec_unit_vec:\n  defines \"basis \\<equiv> (canonical_basis::'a::basis_enum list)\"\n    and \"n \\<equiv> length (canonical_basis :: 'a list)\"\n  assumes a3: \"i < n\"  \n  shows \"basis_enum_of_vec (unit_vec n i) = basis!i\"", "lemma vec_of_basis_enum_ket:\n  \"vec_of_basis_enum (ket i) = unit_vec (CARD('a)) (enum_idx i)\" \n  for i::\"'a::enum\"", "lemma vec_of_basis_enum_zero:\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::basis_enum list)\" \n  shows \"vec_of_basis_enum (0::'a) = 0\\<^sub>v nA\"", "lemma (in complex_vec_space) vec_of_basis_enum_cspan:\n  fixes X :: \"'a::basis_enum set\"\n  assumes \"length (canonical_basis :: 'a list) = n\"\n  shows \"vec_of_basis_enum ` cspan X = span (vec_of_basis_enum ` X)\"", "lemma (in complex_vec_space) basis_enum_of_vec_span:\n  assumes \"length (canonical_basis :: 'a list) = n\"\n  assumes \"Y \\<subseteq> carrier_vec n\"\n  shows \"basis_enum_of_vec ` local.span Y = cspan (basis_enum_of_vec ` Y :: 'a::basis_enum set)\"", "lemma vec_of_basis_enum_canonical_basis:\n  assumes \"i < length (canonical_basis :: 'a list)\"\n  shows \"vec_of_basis_enum (canonical_basis!i :: 'a)\n       = unit_vec (length (canonical_basis :: 'a::basis_enum list)) i\"", "lemma vec_of_basis_enum_times: \n  fixes \\<psi> \\<phi> :: \"'a::one_dim\"\n  shows \"vec_of_basis_enum (\\<psi> * \\<phi>)\n   = vec_of_list [vec_index (vec_of_basis_enum \\<psi>) 0 * vec_index (vec_of_basis_enum \\<phi>) 0]\"", "lemma vec_of_basis_enum_to_inverse: \n  fixes \\<psi> :: \"'a::one_dim\"\n  shows \"vec_of_basis_enum (inverse \\<psi>) = vec_of_list [inverse (vec_index (vec_of_basis_enum \\<psi>) 0)]\"", "lemma vec_of_basis_enum_divide: \n  fixes \\<psi> \\<phi> :: \"'a::one_dim\"\n  shows \"vec_of_basis_enum (\\<psi> / \\<phi>)\n   = vec_of_list [vec_index (vec_of_basis_enum \\<psi>) 0 / vec_index (vec_of_basis_enum \\<phi>) 0]\"", "lemma vec_of_basis_enum_1: \"vec_of_basis_enum (1 :: 'a::one_dim) = vec_of_list [1]\"", "lemma vec_of_basis_enum_ell2_component:\n  fixes \\<psi> :: \\<open>'a::enum ell2\\<close> \n  assumes [simp]: \\<open>i < CARD('a)\\<close>\n  shows \\<open>vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (Enum.enum ! i)\\<close>", "lemma corthogonal_vec_of_basis_enum:\n  fixes S :: \"'a::onb_enum list\"\n  shows \"corthogonal (map vec_of_basis_enum S) \\<longleftrightarrow> is_ortho_set (set S) \\<and> distinct S\"", "lemma mat_of_cblinfun_ell2_carrier[simp]: \\<open>mat_of_cblinfun (a::'a::enum ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::enum ell2) \\<in> carrier_mat CARD('b) CARD('a)\\<close>", "lemma dim_row_mat_of_cblinfun[simp]: \\<open>dim_row (mat_of_cblinfun (a::'a::enum ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::enum ell2)) = CARD('b)\\<close>", "lemma dim_col_mat_of_cblinfun[simp]: \\<open>dim_col (mat_of_cblinfun (a::'a::enum ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::enum ell2)) = CARD('a)\\<close>", "lemma mat_of_cblinfun_cblinfun_apply:\n  \"vec_of_basis_enum (F *\\<^sub>V u) = mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u\"\n  for F::\"'a::{basis_enum,complex_normed_vector}  \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{basis_enum,complex_normed_vector}\" and u::'a", "lemma basis_enum_of_vec_cblinfun_apply:\n  fixes M :: \"complex mat\"\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)\"\n    and \"nB \\<equiv> length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list)\"\n  assumes \"M \\<in> carrier_mat nB nA\" and \"dim_vec x = nA\"\n  shows \"basis_enum_of_vec (M *\\<^sub>v x) = (cblinfun_of_mat M :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) *\\<^sub>V basis_enum_of_vec x\"", "lemma mat_of_cblinfun_inverse:\n  \"cblinfun_of_mat (mat_of_cblinfun B) = B\"\n  for B::\"'a::{basis_enum,complex_normed_vector}  \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{basis_enum,complex_normed_vector}\"", "lemma mat_of_cblinfun_inj: \"inj mat_of_cblinfun\"", "lemma cblinfun_of_mat_inverse:\n  fixes M::\"complex mat\"\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)\"\n    and \"nB \\<equiv> length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list)\"\n  assumes \"M \\<in> carrier_mat nB nA\"\n  shows \"mat_of_cblinfun (cblinfun_of_mat M :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) = M\"", "lemma cblinfun_of_mat_inj: \"inj_on (cblinfun_of_mat::complex mat \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) \n      (carrier_mat (length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list))\n                   (length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)))\"", "lemma cblinfun_eq_mat_of_cblinfunI:\n  assumes \"mat_of_cblinfun a = mat_of_cblinfun b\"\n  shows \"a = b\"", "lemma cblinfun_of_mat_plus:\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)\" \n    and \"nB \\<equiv> length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list)\"\n  assumes [simp,intro]: \"M \\<in> carrier_mat nB nA\" and [simp,intro]: \"N \\<in> carrier_mat nB nA\"\n  shows \"(cblinfun_of_mat (M + N) :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) = ((cblinfun_of_mat M + cblinfun_of_mat N))\"", "lemma mat_of_cblinfun_zero:\n  \"mat_of_cblinfun (0 :: ('a::{basis_enum,complex_normed_vector}  \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{basis_enum,complex_normed_vector})) \n  = 0\\<^sub>m (length (canonical_basis :: 'b list)) (length (canonical_basis :: 'a list))\"", "lemma mat_of_cblinfun_plus:\n  \"mat_of_cblinfun (F + G) = mat_of_cblinfun F + mat_of_cblinfun G\"\n  for F G::\"'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L'b::{basis_enum,complex_normed_vector}\"", "lemma mat_of_cblinfun_id:\n  \"mat_of_cblinfun (id_cblinfun :: ('a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L'a)) = 1\\<^sub>m (length (canonical_basis :: 'a list))\"", "lemma mat_of_cblinfun_1:\n  \"mat_of_cblinfun (1 :: ('a::one_dim \\<Rightarrow>\\<^sub>C\\<^sub>L'b::one_dim)) = 1\\<^sub>m 1\"", "lemma mat_of_cblinfun_uminus:\n  \"mat_of_cblinfun (- M) = - mat_of_cblinfun M\" \n  for M::\"'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L'b::{basis_enum,complex_normed_vector}\"", "lemma mat_of_cblinfun_minus:\n  \"mat_of_cblinfun (M - N) = mat_of_cblinfun M - mat_of_cblinfun N\" \n  for M::\"'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{basis_enum,complex_normed_vector}\" and N::\"'a \\<Rightarrow>\\<^sub>C\\<^sub>L'b\"", "lemma cblinfun_of_mat_uminus:\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)\" \n    and \"nB \\<equiv> length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list)\"\n  assumes \"M \\<in> carrier_mat nB nA\"\n  shows \"(cblinfun_of_mat (-M) :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) = - cblinfun_of_mat M\"", "lemma cblinfun_of_mat_minus:\n  fixes M::\"complex mat\"\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)\" \n    and \"nB \\<equiv> length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list)\"\n  assumes \"M \\<in> carrier_mat nB nA\" and \"N \\<in> carrier_mat nB nA\"\n  shows \"(cblinfun_of_mat (M - N) :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) = cblinfun_of_mat M - cblinfun_of_mat N\"", "lemma cblinfun_of_mat_times:\n  fixes M N ::\"complex mat\"\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)\" \n    and \"nB \\<equiv> length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list)\"\n    and \"nC \\<equiv> length (canonical_basis :: 'c::{basis_enum,complex_normed_vector} list)\"\n  assumes a1: \"M \\<in> carrier_mat nC nB\" and a2: \"N \\<in> carrier_mat nB nA\"\n  shows  \"cblinfun_of_mat (M * N) = ((cblinfun_of_mat M)::'b \\<Rightarrow>\\<^sub>C\\<^sub>L'c) o\\<^sub>C\\<^sub>L ((cblinfun_of_mat N)::'a \\<Rightarrow>\\<^sub>C\\<^sub>L'b)\"", "lemma cblinfun_of_mat_adjoint:\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::onb_enum list)\"\n    and \"nB \\<equiv> length (canonical_basis :: 'b::onb_enum list)\" \n  fixes M:: \"complex mat\"\n  assumes \"M \\<in> carrier_mat nB nA\"\n  shows \"((cblinfun_of_mat (mat_adjoint M)) :: 'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'a) = (cblinfun_of_mat M)*\"", "lemma mat_of_cblinfun_classical_operator:\n  fixes f::\"'a::enum \\<Rightarrow> 'b::enum option\"\n  shows \"mat_of_cblinfun (classical_operator f) = mat (CARD('b)) (CARD('a))\n           (\\<lambda>(r,c). if f (Enum.enum!c) = Some (Enum.enum!r) then 1 else 0)\"", "lemma mat_of_cblinfun_compose:\n  \"mat_of_cblinfun (F o\\<^sub>C\\<^sub>L G) = mat_of_cblinfun F * mat_of_cblinfun G\" \n  for F::\"'b::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::{basis_enum,complex_normed_vector}\"\n    and G::\"'a::{basis_enum,complex_normed_vector}  \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"", "lemma mat_of_cblinfun_scaleC:\n  \"mat_of_cblinfun ((a::complex) *\\<^sub>C F) = a \\<cdot>\\<^sub>m (mat_of_cblinfun F)\"\n  for F :: \"'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{basis_enum,complex_normed_vector}\"", "lemma mat_of_cblinfun_scaleR:\n  \"mat_of_cblinfun ((a::real) *\\<^sub>R F) = (complex_of_real a) \\<cdot>\\<^sub>m (mat_of_cblinfun F)\"", "lemma mat_of_cblinfun_adj:\n  \"mat_of_cblinfun (F*) = mat_adjoint (mat_of_cblinfun F)\"\n  for F :: \"'a::onb_enum \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::onb_enum\"", "lemma mat_of_cblinfun_vector_to_cblinfun:\n  \"mat_of_cblinfun (vector_to_cblinfun \\<psi>)\n       = mat_of_cols (length (canonical_basis :: 'a list)) [vec_of_basis_enum \\<psi>]\"\n  for \\<psi>::\"'a::{basis_enum,complex_normed_vector}\"", "lemma mat_of_cblinfun_proj:\n  fixes a::\"'a::onb_enum\"\n  defines   \"d \\<equiv> length (canonical_basis :: 'a list)\"\n    and \"norm2 \\<equiv> (vec_of_basis_enum a) \\<bullet>c (vec_of_basis_enum a)\"\n  shows  \"mat_of_cblinfun (proj a) = \n      1 / norm2 \\<cdot>\\<^sub>m (mat_of_cols d [vec_of_basis_enum a]\n                 * mat_of_rows d [conjugate (vec_of_basis_enum a)])\" (is \\<open>_ = ?rhs\\<close>)", "lemma mat_of_cblinfun_ell2_component:\n  fixes a :: \\<open>'a::enum ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::enum ell2\\<close> \n  assumes [simp]: \\<open>i < CARD('b)\\<close> \\<open>j < CARD('a)\\<close>\n  shows \\<open>mat_of_cblinfun a $$ (i,j) = Rep_ell2 (a *\\<^sub>V ket (Enum.enum ! j)) (Enum.enum ! i)\\<close>", "lemma mat_of_cblinfun_sandwich:\n  fixes a :: \"(_::onb_enum, _::onb_enum) cblinfun\"\n  shows \\<open>mat_of_cblinfun (sandwich a *\\<^sub>V b) = (let a' = mat_of_cblinfun a in a' * mat_of_cblinfun b * mat_adjoint a')\\<close>", "lemma ccspan_gram_schmidt0_invariant:\n  defines \"basis_enum \\<equiv> (basis_enum_of_vec :: _ \\<Rightarrow> 'a::{basis_enum,complex_normed_vector})\"\n  defines \"n \\<equiv> length (canonical_basis :: 'a list)\"\n  assumes \"set ws \\<subseteq> carrier_vec n\"\n  shows \"ccspan (set (map basis_enum (gram_schmidt0 n ws))) = ccspan (set (map basis_enum ws))\"", "lemma ccspan_leq_using_vec:\n  fixes A B :: \"'a::{basis_enum,complex_normed_vector} list\"\n  shows \"(ccspan (set A) \\<le> ccspan (set B)) \\<longleftrightarrow>\n    is_subspace_of_vec_list (length (canonical_basis :: 'a list)) \n      (map vec_of_basis_enum A) (map vec_of_basis_enum B)\"", "lemma cblinfun_apply_ccspan_using_vec: \n  \"A *\\<^sub>S ccspan (set S) = ccspan (basis_enum_of_vec ` set (map ((*\\<^sub>v) (mat_of_cblinfun A)) (map vec_of_basis_enum S)))\"", "lemma mk_projector_orthog_correct:\n  fixes S :: \"'a::onb_enum list\"\n  defines \"d \\<equiv> length (canonical_basis :: 'a list)\"\n  assumes ortho: \"is_ortho_set (set S)\" and distinct: \"distinct S\"\n  shows \"mk_projector_orthog d (map vec_of_basis_enum S) \n       = mat_of_cblinfun (Proj (ccspan (set S)))\"", "lemma mat_of_cblinfun_Proj_ccspan: \n  fixes S :: \"'a::onb_enum list\"\n  shows \"mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length (canonical_basis :: 'a list) in \n      mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))\""], "translations": [["", "lemma dim_vec_of_basis_enum'[simp]:\n  \\<open>dim_vec (vec_of_basis_enum (v::'a)) = length (canonical_basis::'a::basis_enum list)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_of_basis_enum v) = length canonical_basis", "unfolding vec_of_basis_enum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list\n       (map (crepresentation (set canonical_basis) v) canonical_basis)) =\n    length canonical_basis", "by simp"], ["", "definition basis_enum_of_vec :: \\<open>complex vec \\<Rightarrow> 'a::basis_enum\\<close> where\n  \\<open>basis_enum_of_vec v = \n    (if dim_vec v = length (canonical_basis :: 'a list)\n     then sum_list (map2 (*\\<^sub>C) (list_of_vec v) (canonical_basis::'a list))\n     else 0)\\<close>"], ["", "lemma vec_of_basis_enum_inverse[simp]:\n  fixes w::\"'a::basis_enum\"\n  shows  \"basis_enum_of_vec (vec_of_basis_enum w) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (vec_of_basis_enum w) = w", "unfolding vec_of_basis_enum_def basis_enum_of_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_vec\n         (vec_of_list\n           (map (crepresentation (set canonical_basis) w)\n             canonical_basis)) =\n        length canonical_basis\n     then sum_list\n           (map2 (*\\<^sub>C)\n             (list_of_vec\n               (vec_of_list\n                 (map (crepresentation (set canonical_basis) w)\n                   canonical_basis)))\n             canonical_basis)\n     else (0::'a)) =\n    w", "unfolding list_vec zip_map1 zip_same_conv_map map_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dim_vec\n         (vec_of_list\n           (map (crepresentation (set canonical_basis) w)\n             canonical_basis)) =\n        length canonical_basis\n     then sum_list\n           (map ((\\<lambda>(x, y). x *\\<^sub>C y) \\<circ>\n                 ((\\<lambda>(x, y).\n                      (crepresentation (set canonical_basis) w x,\n                       y)) \\<circ>\n                  (\\<lambda>x. (x, x))))\n             canonical_basis)\n     else (0::'a)) =\n    w", "apply (simp add: o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>canonical_basis. crepresentation\n    (set canonical_basis) w x *\\<^sub>C\n   x) =\n    w", "apply (subst sum.distinct_set_conv_list[symmetric], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set canonical_basis.\n       crepresentation (set canonical_basis) w x *\\<^sub>C x) =\n    w", "apply (rule complex_vector.sum_representation_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. cindependent (set canonical_basis)\n 2. w \\<in> cspan (set canonical_basis)\n 3. finite (set canonical_basis)\n 4. set canonical_basis \\<subseteq> set canonical_basis", "using  is_generator_set"], ["proof (prove)\nusing this:\n  cspan (set canonical_basis) = UNIV\n\ngoal (4 subgoals):\n 1. cindependent (set canonical_basis)\n 2. w \\<in> cspan (set canonical_basis)\n 3. finite (set canonical_basis)\n 4. set canonical_basis \\<subseteq> set canonical_basis", "by auto"], ["", "lemma basis_enum_of_vec_inverse[simp]:\n  fixes v::\"complex vec\"\n  defines \"n \\<equiv> length (canonical_basis :: 'a::basis_enum list)\"\n  assumes f1: \"dim_vec v = n\"\n  shows \"vec_of_basis_enum ((basis_enum_of_vec v)::'a) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (basis_enum_of_vec v) = v", "proof (rule eq_vecI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i\n 2. dim_vec (vec_of_basis_enum (basis_enum_of_vec v)) = dim_vec v", "show \\<open>dim_vec (vec_of_basis_enum (basis_enum_of_vec v :: 'a)) = dim_vec v\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_of_basis_enum (basis_enum_of_vec v)) = dim_vec v", "by (auto simp: vec_of_basis_enum_def f1 n_def)"], ["proof (state)\nthis:\n  dim_vec (vec_of_basis_enum (basis_enum_of_vec v)) = dim_vec v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "assume j_v: \\<open>j < dim_vec v\\<close>"], ["proof (state)\nthis:\n  j < dim_vec v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "define w where \"w = list_of_vec v\""], ["proof (state)\nthis:\n  w = list_of_vec v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "define basis where \"basis = (canonical_basis::'a list)\""], ["proof (state)\nthis:\n  basis = canonical_basis\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "have [simp]: \"length w = n\" \"length basis = n\" \\<open>dim_vec v = n\\<close> \\<open>length (canonical_basis::'a list) = n\\<close>\n    \\<open>j < n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length w = n &&& length basis = n) &&&\n    dim_vec v = n &&& length canonical_basis = n &&& j < n", "using j_v"], ["proof (prove)\nusing this:\n  j < dim_vec v\n\ngoal (1 subgoal):\n 1. (length w = n &&& length basis = n) &&&\n    dim_vec v = n &&& length canonical_basis = n &&& j < n", "by (auto simp: f1 basis_def w_def n_def)"], ["proof (state)\nthis:\n  length w = n\n  length basis = n\n  dim_vec v = n\n  length canonical_basis = n\n  j < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "have [simp]: \\<open>cindependent (set basis)\\<close> \\<open>cspan (set basis) = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent (set basis) &&& cspan (set basis) = UNIV", "by (auto simp: basis_def is_cindependent_set is_generator_set)"], ["proof (state)\nthis:\n  cindependent (set basis)\n  cspan (set basis) = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "have \\<open>vec_of_basis_enum ((basis_enum_of_vec v)::'a) $ j\n       = map (crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis))) basis ! j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (basis_enum_of_vec v) $ j =\n    map (crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis)))\n     basis !\n    j", "by (auto simp: vec_of_list_index vec_of_basis_enum_def basis_enum_of_vec_def simp flip: w_def basis_def)"], ["proof (state)\nthis:\n  vec_of_basis_enum (basis_enum_of_vec v) $ j =\n  map (crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis)))\n   basis !\n  j\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "also"], ["proof (state)\nthis:\n  vec_of_basis_enum (basis_enum_of_vec v) $ j =\n  map (crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis)))\n   basis !\n  j\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "have \\<open>\\<dots> = crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis)) (basis!j)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis)))\n     basis !\n    j =\n    crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis))\n     (basis ! j)", "by simp"], ["proof (state)\nthis:\n  map (crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis)))\n   basis !\n  j =\n  crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis))\n   (basis ! j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "also"], ["proof (state)\nthis:\n  map (crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis)))\n   basis !\n  j =\n  crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis))\n   (basis ! j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "have \\<open>\\<dots> = crepresentation (set basis) (\\<Sum>i<n. (w!i) *\\<^sub>C (basis!i)) (basis!j)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis))\n     (basis ! j) =\n    crepresentation (set basis) (\\<Sum>i<n. w ! i *\\<^sub>C basis ! i)\n     (basis ! j)", "by (auto simp: sum_list_sum_nth atLeast0LessThan)"], ["proof (state)\nthis:\n  crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis))\n   (basis ! j) =\n  crepresentation (set basis) (\\<Sum>i<n. w ! i *\\<^sub>C basis ! i)\n   (basis ! j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "also"], ["proof (state)\nthis:\n  crepresentation (set basis) (sum_list (map2 (*\\<^sub>C) w basis))\n   (basis ! j) =\n  crepresentation (set basis) (\\<Sum>i<n. w ! i *\\<^sub>C basis ! i)\n   (basis ! j)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "have \\<open>\\<dots> = (\\<Sum>i<n. (w!i) *\\<^sub>C crepresentation (set basis) (basis!i) (basis!j))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. crepresentation (set basis) (\\<Sum>i<n. w ! i *\\<^sub>C basis ! i)\n     (basis ! j) =\n    (\\<Sum>i<n.\n        w ! i *\\<^sub>C crepresentation (set basis) (basis ! i) (basis ! j))", "by (auto simp: complex_vector.representation_sum complex_vector.representation_scale)"], ["proof (state)\nthis:\n  crepresentation (set basis) (\\<Sum>i<n. w ! i *\\<^sub>C basis ! i)\n   (basis ! j) =\n  (\\<Sum>i<n.\n      w ! i *\\<^sub>C crepresentation (set basis) (basis ! i) (basis ! j))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "also"], ["proof (state)\nthis:\n  crepresentation (set basis) (\\<Sum>i<n. w ! i *\\<^sub>C basis ! i)\n   (basis ! j) =\n  (\\<Sum>i<n.\n      w ! i *\\<^sub>C crepresentation (set basis) (basis ! i) (basis ! j))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "have \\<open>\\<dots> = w!j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        w ! i *\\<^sub>C\n        crepresentation (set basis) (basis ! i) (basis ! j)) =\n    w ! j", "apply (subst sum_single[where i=j])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {..<n}\n 2. \\<And>ja.\n       \\<lbrakk>ja \\<noteq> j; ja \\<in> {..<n}\\<rbrakk>\n       \\<Longrightarrow> w ! ja *\\<^sub>C\n                         crepresentation (set basis) (basis ! ja)\n                          (basis ! j) =\n                         0\n 3. (if j \\<in> {..<n}\n     then w ! j *\\<^sub>C\n          crepresentation (set basis) (basis ! j) (basis ! j)\n     else 0) =\n    w ! j", "apply (auto simp: complex_vector.representation_basis)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ja.\n       \\<lbrakk>ja \\<noteq> j; ja < n; basis ! j = basis ! ja\\<rbrakk>\n       \\<Longrightarrow> w ! ja = 0", "using \\<open>j < n\\<close> \\<open>length basis = n\\<close> basis_def distinct_canonical_basis nth_eq_iff_index_eq"], ["proof (prove)\nusing this:\n  j < n\n  length basis = n\n  basis = canonical_basis\n  distinct canonical_basis\n  \\<lbrakk>distinct ?xs; ?i < length ?xs; ?j < length ?xs\\<rbrakk>\n  \\<Longrightarrow> (?xs ! ?i = ?xs ! ?j) = (?i = ?j)\n\ngoal (1 subgoal):\n 1. \\<And>ja.\n       \\<lbrakk>ja \\<noteq> j; ja < n; basis ! j = basis ! ja\\<rbrakk>\n       \\<Longrightarrow> w ! ja = 0", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      w ! i *\\<^sub>C crepresentation (set basis) (basis ! i) (basis ! j)) =\n  w ! j\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      w ! i *\\<^sub>C crepresentation (set basis) (basis ! i) (basis ! j)) =\n  w ! j\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "have \\<open>\\<dots> = v $ j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. w ! j = v $ j", "by (simp add: w_def)"], ["proof (state)\nthis:\n  w ! j = v $ j\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec v \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec v) $ i = v $ i", "finally"], ["proof (chain)\npicking this:\n  vec_of_basis_enum (basis_enum_of_vec v) $ j = v $ j", "show \\<open>vec_of_basis_enum (basis_enum_of_vec v :: 'a) $ j = v $ j\\<close>"], ["proof (prove)\nusing this:\n  vec_of_basis_enum (basis_enum_of_vec v) $ j = v $ j\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (basis_enum_of_vec v) $ j = v $ j", "by -"], ["proof (state)\nthis:\n  vec_of_basis_enum (basis_enum_of_vec v) $ j = v $ j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_enum_eq_vec_of_basis_enumI:\n  fixes a b :: \"_::basis_enum\"\n  assumes \"vec_of_basis_enum a = vec_of_basis_enum b\"\n  shows \"a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b", "by (metis assms vec_of_basis_enum_inverse)"], ["", "subsection \\<open>Operations on vectors\\<close>"], ["", "lemma basis_enum_of_vec_add:\n  assumes [simp]: \\<open>dim_vec v1 = length (canonical_basis :: 'a::basis_enum list)\\<close> \n    \\<open>dim_vec v2 = length (canonical_basis :: 'a list)\\<close>\n  shows \\<open>((basis_enum_of_vec (v1 + v2)) :: 'a) = basis_enum_of_vec v1 + basis_enum_of_vec v2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (v1 + v2) =\n    basis_enum_of_vec v1 + basis_enum_of_vec v2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (v1 + v2) =\n    basis_enum_of_vec v1 + basis_enum_of_vec v2", "have \\<open>length (list_of_vec v1) = length (list_of_vec v2)\\<close> and \\<open>length (list_of_vec v2) = length (canonical_basis :: 'a list)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (list_of_vec v1) = length (list_of_vec v2) &&&\n    length (list_of_vec v2) = length canonical_basis", "by simp_all"], ["proof (state)\nthis:\n  length (list_of_vec v1) = length (list_of_vec v2)\n  length (list_of_vec v2) = length canonical_basis\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (v1 + v2) =\n    basis_enum_of_vec v1 + basis_enum_of_vec v2", "then"], ["proof (chain)\npicking this:\n  length (list_of_vec v1) = length (list_of_vec v2)\n  length (list_of_vec v2) = length canonical_basis", "have \\<open>sum_list (map2 (*\\<^sub>C) (map2 (+) (list_of_vec v1) (list_of_vec v2)) (canonical_basis::'a list))\n    = sum_list (map2 (*\\<^sub>C) (list_of_vec v1) canonical_basis) + sum_list (map2 (*\\<^sub>C) (list_of_vec v2) canonical_basis)\\<close>"], ["proof (prove)\nusing this:\n  length (list_of_vec v1) = length (list_of_vec v2)\n  length (list_of_vec v2) = length canonical_basis\n\ngoal (1 subgoal):\n 1. sum_list\n     (map2 (*\\<^sub>C) (map2 (+) (list_of_vec v1) (list_of_vec v2))\n       canonical_basis) =\n    sum_list (map2 (*\\<^sub>C) (list_of_vec v1) canonical_basis) +\n    sum_list (map2 (*\\<^sub>C) (list_of_vec v2) canonical_basis)", "apply (induction rule: list_induct3)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sum_list (map2 (*\\<^sub>C) (map2 (+) [] []) []) =\n    sum_list (map2 (*\\<^sub>C) [] []) + sum_list (map2 (*\\<^sub>C) [] [])\n 2. \\<And>x xs y ys z zs.\n       \\<lbrakk>length xs = length ys; length ys = length zs;\n        sum_list (map2 (*\\<^sub>C) (map2 (+) xs ys) zs) =\n        sum_list (map2 (*\\<^sub>C) xs zs) +\n        sum_list (map2 (*\\<^sub>C) ys zs)\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map2 (*\\<^sub>C) (map2 (+) (x # xs) (y # ys))\n                            (z # zs)) =\n                         sum_list (map2 (*\\<^sub>C) (x # xs) (z # zs)) +\n                         sum_list (map2 (*\\<^sub>C) (y # ys) (z # zs))", "by (auto simp: scaleC_add_left)"], ["proof (state)\nthis:\n  sum_list\n   (map2 (*\\<^sub>C) (map2 (+) (list_of_vec v1) (list_of_vec v2))\n     canonical_basis) =\n  sum_list (map2 (*\\<^sub>C) (list_of_vec v1) canonical_basis) +\n  sum_list (map2 (*\\<^sub>C) (list_of_vec v2) canonical_basis)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (v1 + v2) =\n    basis_enum_of_vec v1 + basis_enum_of_vec v2", "then"], ["proof (chain)\npicking this:\n  sum_list\n   (map2 (*\\<^sub>C) (map2 (+) (list_of_vec v1) (list_of_vec v2))\n     canonical_basis) =\n  sum_list (map2 (*\\<^sub>C) (list_of_vec v1) canonical_basis) +\n  sum_list (map2 (*\\<^sub>C) (list_of_vec v2) canonical_basis)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list\n   (map2 (*\\<^sub>C) (map2 (+) (list_of_vec v1) (list_of_vec v2))\n     canonical_basis) =\n  sum_list (map2 (*\\<^sub>C) (list_of_vec v1) canonical_basis) +\n  sum_list (map2 (*\\<^sub>C) (list_of_vec v2) canonical_basis)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (v1 + v2) =\n    basis_enum_of_vec v1 + basis_enum_of_vec v2", "using assms"], ["proof (prove)\nusing this:\n  sum_list\n   (map2 (*\\<^sub>C) (map2 (+) (list_of_vec v1) (list_of_vec v2))\n     canonical_basis) =\n  sum_list (map2 (*\\<^sub>C) (list_of_vec v1) canonical_basis) +\n  sum_list (map2 (*\\<^sub>C) (list_of_vec v2) canonical_basis)\n  dim_vec v1 = length canonical_basis\n  dim_vec v2 = length canonical_basis\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (v1 + v2) =\n    basis_enum_of_vec v1 + basis_enum_of_vec v2", "by (auto simp: basis_enum_of_vec_def list_of_vec_plus)"], ["proof (state)\nthis:\n  basis_enum_of_vec (v1 + v2) = basis_enum_of_vec v1 + basis_enum_of_vec v2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_enum_of_vec_mult:\n  assumes [simp]: \\<open>dim_vec v = length (canonical_basis :: 'a::basis_enum list)\\<close> \n  shows \\<open>((basis_enum_of_vec (c \\<cdot>\\<^sub>v v)) :: 'a) =  c *\\<^sub>C basis_enum_of_vec v\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (c \\<cdot>\\<^sub>v v) =\n    c *\\<^sub>C basis_enum_of_vec v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (c \\<cdot>\\<^sub>v v) =\n    c *\\<^sub>C basis_enum_of_vec v", "have *: \\<open>monoid_add_hom ((*\\<^sub>C) c :: 'a \\<Rightarrow> _)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. monoid_add_hom ((*\\<^sub>C) c)", "by (simp add: monoid_add_hom_def plus_hom.intro scaleC_add_right semigroup_add_hom.intro zero_hom.intro)"], ["proof (state)\nthis:\n  monoid_add_hom ((*\\<^sub>C) c)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (c \\<cdot>\\<^sub>v v) =\n    c *\\<^sub>C basis_enum_of_vec v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (c \\<cdot>\\<^sub>v v) =\n    c *\\<^sub>C basis_enum_of_vec v", "apply (auto simp: basis_enum_of_vec_def list_of_vec_mult map_zip_map\n        monoid_add_hom.hom_sum_list[OF *])"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map2 (\\<lambda>x. (*\\<^sub>C) (c * x)) (list_of_vec v)\n       canonical_basis) =\n    sum_list\n     (map ((*\\<^sub>C) c \\<circ> (\\<lambda>(x, y). x *\\<^sub>C y))\n       (zip (list_of_vec v) canonical_basis))", "by (metis case_prod_unfold comp_apply scaleC_scaleC)"], ["proof (state)\nthis:\n  basis_enum_of_vec (c \\<cdot>\\<^sub>v v) = c *\\<^sub>C basis_enum_of_vec v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_of_basis_enum_add:\n  \"vec_of_basis_enum (b1 + b2) = vec_of_basis_enum b1 + vec_of_basis_enum b2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (b1 + b2) =\n    vec_of_basis_enum b1 + vec_of_basis_enum b2", "by (auto simp: vec_of_basis_enum_def complex_vector.representation_add)"], ["", "lemma vec_of_basis_enum_scaleC:\n  \"vec_of_basis_enum (c *\\<^sub>C b) = c \\<cdot>\\<^sub>v (vec_of_basis_enum b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (c *\\<^sub>C b) =\n    c \\<cdot>\\<^sub>v vec_of_basis_enum b", "by (auto simp: vec_of_basis_enum_def complex_vector.representation_scale)"], ["", "lemma vec_of_basis_enum_scaleR:\n  \"vec_of_basis_enum (r *\\<^sub>R b) = complex_of_real r \\<cdot>\\<^sub>v (vec_of_basis_enum b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (r *\\<^sub>R b) =\n    complex_of_real r \\<cdot>\\<^sub>v vec_of_basis_enum b", "by (simp add: scaleR_scaleC vec_of_basis_enum_scaleC)"], ["", "lemma vec_of_basis_enum_uminus:\n  \"vec_of_basis_enum (- b2) = - vec_of_basis_enum b2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (- b2) = - vec_of_basis_enum b2", "unfolding scaleC_minus1_left[symmetric, of b2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (- 1 *\\<^sub>C b2) = - vec_of_basis_enum b2", "unfolding scaleC_minus1_left_vec[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (- 1 *\\<^sub>C b2) =\n    - 1 \\<cdot>\\<^sub>v vec_of_basis_enum b2", "by (rule vec_of_basis_enum_scaleC)"], ["", "lemma vec_of_basis_enum_minus:\n  \"vec_of_basis_enum (b1 - b2) = vec_of_basis_enum b1 - vec_of_basis_enum b2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (b1 - b2) =\n    vec_of_basis_enum b1 - vec_of_basis_enum b2", "by (metis (mono_tags, hide_lams) carrier_vec_dim_vec diff_conv_add_uminus diff_zero index_add_vec(2) minus_add_uminus_vec vec_of_basis_enum_add vec_of_basis_enum_uminus)"], ["", "lemma cinner_basis_enum_of_vec:\n  defines \"n \\<equiv> length (canonical_basis :: 'a::onb_enum list)\"\n  assumes [simp]: \"dim_vec x = n\" \"dim_vec y = n\"\n  shows  \"\\<langle>basis_enum_of_vec x :: 'a, basis_enum_of_vec y\\<rangle> = y \\<bullet>c x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n    y \\<bullet>c x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n    y \\<bullet>c x", "have \\<open>\\<langle>basis_enum_of_vec x :: 'a, basis_enum_of_vec y\\<rangle>\n    = (\\<Sum>i<n. x$i *\\<^sub>C canonical_basis ! i :: 'a) \\<bullet>\\<^sub>C (\\<Sum>i<n. y$i *\\<^sub>C canonical_basis ! i)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n    (\\<Sum>i<n. x $ i *\\<^sub>C canonical_basis ! i) \\<bullet>\\<^sub>C\n    (\\<Sum>i<n. y $ i *\\<^sub>C canonical_basis ! i)", "by (auto simp: basis_enum_of_vec_def sum_list_sum_nth atLeast0LessThan simp flip: n_def)"], ["proof (state)\nthis:\n  basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n  (\\<Sum>i<n. x $ i *\\<^sub>C canonical_basis ! i) \\<bullet>\\<^sub>C\n  (\\<Sum>i<n. y $ i *\\<^sub>C canonical_basis ! i)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n    y \\<bullet>c x", "also"], ["proof (state)\nthis:\n  basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n  (\\<Sum>i<n. x $ i *\\<^sub>C canonical_basis ! i) \\<bullet>\\<^sub>C\n  (\\<Sum>i<n. y $ i *\\<^sub>C canonical_basis ! i)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n    y \\<bullet>c x", "have \\<open>\\<dots> = (\\<Sum>i<n. \\<Sum>j<n. cnj (x$i) *\\<^sub>C y$j *\\<^sub>C ((canonical_basis ! i :: 'a) \\<bullet>\\<^sub>C (canonical_basis ! j)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. x $ i *\\<^sub>C canonical_basis ! i) \\<bullet>\\<^sub>C\n    (\\<Sum>i<n. y $ i *\\<^sub>C canonical_basis ! i) =\n    (\\<Sum>i<n.\n        \\<Sum>j<n.\n           cnj (x $ i) *\\<^sub>C\n           y $ j *\\<^sub>C\n           (canonical_basis ! i \\<bullet>\\<^sub>C canonical_basis ! j))", "apply (subst cinner_sum_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa<n.\n        x $ xa *\\<^sub>C canonical_basis ! xa \\<bullet>\\<^sub>C\n        (\\<Sum>i<n. y $ i *\\<^sub>C canonical_basis ! i)) =\n    (\\<Sum>i<n.\n        \\<Sum>j<n.\n           cnj (x $ i) *\\<^sub>C\n           y $ j *\\<^sub>C\n           (canonical_basis ! i \\<bullet>\\<^sub>C canonical_basis ! j))", "apply (subst cinner_sum_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa<n.\n        \\<Sum>ya<n.\n           x $ xa *\\<^sub>C canonical_basis ! xa \\<bullet>\\<^sub>C\n           y $ ya *\\<^sub>C canonical_basis ! ya) =\n    (\\<Sum>i<n.\n        \\<Sum>j<n.\n           cnj (x $ i) *\\<^sub>C\n           y $ j *\\<^sub>C\n           (canonical_basis ! i \\<bullet>\\<^sub>C canonical_basis ! j))", "by (auto simp: mult_ac)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. x $ i *\\<^sub>C canonical_basis ! i) \\<bullet>\\<^sub>C\n  (\\<Sum>i<n. y $ i *\\<^sub>C canonical_basis ! i) =\n  (\\<Sum>i<n.\n      \\<Sum>j<n.\n         cnj (x $ i) *\\<^sub>C\n         y $ j *\\<^sub>C\n         (canonical_basis ! i \\<bullet>\\<^sub>C canonical_basis ! j))\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n    y \\<bullet>c x", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n. x $ i *\\<^sub>C canonical_basis ! i) \\<bullet>\\<^sub>C\n  (\\<Sum>i<n. y $ i *\\<^sub>C canonical_basis ! i) =\n  (\\<Sum>i<n.\n      \\<Sum>j<n.\n         cnj (x $ i) *\\<^sub>C\n         y $ j *\\<^sub>C\n         (canonical_basis ! i \\<bullet>\\<^sub>C canonical_basis ! j))\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n    y \\<bullet>c x", "have \\<open>\\<dots> = (\\<Sum>i<n. \\<Sum>j<n. cnj (x$i) *\\<^sub>C y$j *\\<^sub>C (if i=j then 1 else 0))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        \\<Sum>j<n.\n           cnj (x $ i) *\\<^sub>C\n           y $ j *\\<^sub>C\n           (canonical_basis ! i \\<bullet>\\<^sub>C canonical_basis ! j)) =\n    (\\<Sum>i<n.\n        \\<Sum>j<n.\n           cnj (x $ i) *\\<^sub>C y $ j *\\<^sub>C (if i = j then 1 else 0))", "apply (rule sum.cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       (\\<Sum>j<n.\n           cnj (x $ xa) *\\<^sub>C\n           y $ j *\\<^sub>C\n           (canonical_basis ! xa \\<bullet>\\<^sub>C canonical_basis ! j)) =\n       (\\<Sum>j<n.\n           cnj (x $ xa) *\\<^sub>C y $ j *\\<^sub>C (if xa = j then 1 else 0))", "apply (rule sum.cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>xa \\<in> {..<n}; xaa \\<in> {..<n}\\<rbrakk>\n       \\<Longrightarrow> cnj (x $ xa) *\\<^sub>C\n                         y $ xaa *\\<^sub>C\n                         (canonical_basis ! xa \\<bullet>\\<^sub>C\n                          canonical_basis ! xaa) =\n                         cnj (x $ xa) *\\<^sub>C\n                         y $ xaa *\\<^sub>C (if xa = xaa then 1 else 0)", "by (auto simp: cinner_canonical_basis n_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      \\<Sum>j<n.\n         cnj (x $ i) *\\<^sub>C\n         y $ j *\\<^sub>C\n         (canonical_basis ! i \\<bullet>\\<^sub>C canonical_basis ! j)) =\n  (\\<Sum>i<n.\n      \\<Sum>j<n.\n         cnj (x $ i) *\\<^sub>C y $ j *\\<^sub>C (if i = j then 1 else 0))\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n    y \\<bullet>c x", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      \\<Sum>j<n.\n         cnj (x $ i) *\\<^sub>C\n         y $ j *\\<^sub>C\n         (canonical_basis ! i \\<bullet>\\<^sub>C canonical_basis ! j)) =\n  (\\<Sum>i<n.\n      \\<Sum>j<n.\n         cnj (x $ i) *\\<^sub>C y $ j *\\<^sub>C (if i = j then 1 else 0))\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n    y \\<bullet>c x", "have \\<open>\\<dots> = (\\<Sum>i<n. cnj (x$i) *\\<^sub>C y$i)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        \\<Sum>j<n.\n           cnj (x $ i) *\\<^sub>C y $ j *\\<^sub>C (if i = j then 1 else 0)) =\n    (\\<Sum>i<n. cnj (x $ i) *\\<^sub>C y $ i)", "apply (rule sum.cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       (\\<Sum>j<n.\n           cnj (x $ xa) *\\<^sub>C\n           y $ j *\\<^sub>C (if xa = j then 1 else 0)) =\n       cnj (x $ xa) *\\<^sub>C y $ xa", "apply (subst sum_single)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> {..<n} \\<Longrightarrow> finite {..<n}\n 2. \\<And>xa j.\n       \\<lbrakk>xa \\<in> {..<n}; j \\<noteq> ?i3 xa; j \\<in> {..<n}\\<rbrakk>\n       \\<Longrightarrow> cnj (x $ xa) *\\<^sub>C\n                         y $ j *\\<^sub>C (if xa = j then 1 else 0) =\n                         0\n 3. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       (if ?i3 xa \\<in> {..<n}\n        then cnj (x $ xa) *\\<^sub>C\n             y $ ?i3 xa *\\<^sub>C (if xa = ?i3 xa then 1 else 0)\n        else 0) =\n       cnj (x $ xa) *\\<^sub>C y $ xa", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      \\<Sum>j<n.\n         cnj (x $ i) *\\<^sub>C y $ j *\\<^sub>C (if i = j then 1 else 0)) =\n  (\\<Sum>i<n. cnj (x $ i) *\\<^sub>C y $ i)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n    y \\<bullet>c x", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      \\<Sum>j<n.\n         cnj (x $ i) *\\<^sub>C y $ j *\\<^sub>C (if i = j then 1 else 0)) =\n  (\\<Sum>i<n. cnj (x $ i) *\\<^sub>C y $ i)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n    y \\<bullet>c x", "have \\<open>\\<dots> = y \\<bullet>c x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. cnj (x $ i) *\\<^sub>C y $ i) = y \\<bullet>c x", "by (smt (z3) assms(2) complex_scaleC_def conjugate_complex_def dim_vec_conjugate lessThan_atLeast0 lessThan_iff mult.commute scalar_prod_def sum.cong vec_index_conjugate)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. cnj (x $ i) *\\<^sub>C y $ i) = y \\<bullet>c x\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n    y \\<bullet>c x", "finally"], ["proof (chain)\npicking this:\n  basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y = y \\<bullet>c x", "show ?thesis"], ["proof (prove)\nusing this:\n  basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y = y \\<bullet>c x\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y =\n    y \\<bullet>c x", "by -"], ["proof (state)\nthis:\n  basis_enum_of_vec x \\<bullet>\\<^sub>C basis_enum_of_vec y = y \\<bullet>c x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cscalar_prod_vec_of_basis_enum: \"cscalar_prod (vec_of_basis_enum \\<phi>) (vec_of_basis_enum \\<psi>) = cinner \\<psi> \\<phi>\"\n  for \\<psi> :: \"'a::onb_enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<phi> \\<bullet>c vec_of_basis_enum \\<psi> =\n    \\<psi> \\<bullet>\\<^sub>C \\<phi>", "apply (subst cinner_basis_enum_of_vec[symmetric, where 'a='a])"], ["proof (prove)\ngoal (3 subgoals):\n 1. dim_vec (vec_of_basis_enum \\<psi>) = length canonical_basis\n 2. dim_vec (vec_of_basis_enum \\<phi>) = length canonical_basis\n 3. basis_enum_of_vec (vec_of_basis_enum \\<psi>) \\<bullet>\\<^sub>C\n    basis_enum_of_vec (vec_of_basis_enum \\<phi>) =\n    \\<psi> \\<bullet>\\<^sub>C \\<phi>", "by simp_all"], ["", "lemma norm_ell2_vec_of_basis_enum: \"norm \\<psi> =\n  (let \\<psi>' = vec_of_basis_enum \\<psi> in\n    sqrt (\\<Sum> i \\<in> {0 ..< dim_vec \\<psi>'}. let z = vec_index \\<psi>' i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))\"\n  (is \"_ = ?rhs\") for \\<psi> :: \"'a::onb_enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm \\<psi> =\n    (let \\<psi>' = vec_of_basis_enum \\<psi>\n     in sqrt\n         (\\<Sum>i = 0..<dim_vec \\<psi>'.\n             let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm \\<psi> =\n    (let \\<psi>' = vec_of_basis_enum \\<psi>\n     in sqrt\n         (\\<Sum>i = 0..<dim_vec \\<psi>'.\n             let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))", "have \"norm \\<psi> = sqrt (cmod (\\<Sum>i = 0..<dim_vec (vec_of_basis_enum \\<psi>). \n            vec_of_basis_enum \\<psi> $ i * conjugate (vec_of_basis_enum \\<psi>) $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm \\<psi> =\n    sqrt\n     (cmod\n       (\\<Sum>i = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n           vec_of_basis_enum \\<psi> $ i *\n           conjugate (vec_of_basis_enum \\<psi>) $ i))", "unfolding norm_eq_sqrt_cinner[where 'a='a] cscalar_prod_vec_of_basis_enum[symmetric] scalar_prod_def dim_vec_conjugate"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (cmod\n       (\\<Sum>i = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n           vec_of_basis_enum \\<psi> $ i *\n           conjugate (vec_of_basis_enum \\<psi>) $ i)) =\n    sqrt\n     (cmod\n       (\\<Sum>i = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n           vec_of_basis_enum \\<psi> $ i *\n           conjugate (vec_of_basis_enum \\<psi>) $ i))", "by rule"], ["proof (state)\nthis:\n  norm \\<psi> =\n  sqrt\n   (cmod\n     (\\<Sum>i = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n         vec_of_basis_enum \\<psi> $ i *\n         conjugate (vec_of_basis_enum \\<psi>) $ i))\n\ngoal (1 subgoal):\n 1. norm \\<psi> =\n    (let \\<psi>' = vec_of_basis_enum \\<psi>\n     in sqrt\n         (\\<Sum>i = 0..<dim_vec \\<psi>'.\n             let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  norm \\<psi> =\n  sqrt\n   (cmod\n     (\\<Sum>i = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n         vec_of_basis_enum \\<psi> $ i *\n         conjugate (vec_of_basis_enum \\<psi>) $ i))\n\ngoal (1 subgoal):\n 1. norm \\<psi> =\n    (let \\<psi>' = vec_of_basis_enum \\<psi>\n     in sqrt\n         (\\<Sum>i = 0..<dim_vec \\<psi>'.\n             let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))", "have \"\\<dots> = sqrt (cmod (\\<Sum>x = 0..<dim_vec (vec_of_basis_enum \\<psi>). \n                    let z = vec_of_basis_enum \\<psi> $ x in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (cmod\n       (\\<Sum>i = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n           vec_of_basis_enum \\<psi> $ i *\n           conjugate (vec_of_basis_enum \\<psi>) $ i)) =\n    sqrt\n     (cmod\n       (complex_of_real\n         (\\<Sum>x = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n             let z = vec_of_basis_enum \\<psi> $ x\n             in (Re z)\\<^sup>2 + (Im z)\\<^sup>2)))", "apply (subst sum.cong, rule refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec (vec_of_basis_enum \\<psi>)} \\<Longrightarrow>\n       vec_of_basis_enum \\<psi> $ x *\n       conjugate (vec_of_basis_enum \\<psi>) $ x =\n       ?h x\n 2. sqrt (cmod (sum ?h {0..<dim_vec (vec_of_basis_enum \\<psi>)})) =\n    sqrt\n     (cmod\n       (complex_of_real\n         (\\<Sum>x = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n             let z = vec_of_basis_enum \\<psi> $ x\n             in (Re z)\\<^sup>2 + (Im z)\\<^sup>2)))", "apply (subst vec_index_conjugate)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec (vec_of_basis_enum \\<psi>)} \\<Longrightarrow>\n       x < dim_vec (vec_of_basis_enum \\<psi>)\n 2. \\<And>x.\n       x \\<in> {0..<dim_vec (vec_of_basis_enum \\<psi>)} \\<Longrightarrow>\n       vec_of_basis_enum \\<psi> $ x *\n       conjugate (vec_of_basis_enum \\<psi> $ x) =\n       ?h3 x x\n 3. sqrt\n     (cmod (\\<Sum>x = 0..<dim_vec (vec_of_basis_enum \\<psi>). ?h3 x x)) =\n    sqrt\n     (cmod\n       (complex_of_real\n         (\\<Sum>x = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n             let z = vec_of_basis_enum \\<psi> $ x\n             in (Re z)\\<^sup>2 + (Im z)\\<^sup>2)))", "by (auto simp: Let_def complex_mult_cnj)"], ["proof (state)\nthis:\n  sqrt\n   (cmod\n     (\\<Sum>i = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n         vec_of_basis_enum \\<psi> $ i *\n         conjugate (vec_of_basis_enum \\<psi>) $ i)) =\n  sqrt\n   (cmod\n     (complex_of_real\n       (\\<Sum>x = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n           let z = vec_of_basis_enum \\<psi> $ x\n           in (Re z)\\<^sup>2 + (Im z)\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. norm \\<psi> =\n    (let \\<psi>' = vec_of_basis_enum \\<psi>\n     in sqrt\n         (\\<Sum>i = 0..<dim_vec \\<psi>'.\n             let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))", "also"], ["proof (state)\nthis:\n  sqrt\n   (cmod\n     (\\<Sum>i = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n         vec_of_basis_enum \\<psi> $ i *\n         conjugate (vec_of_basis_enum \\<psi>) $ i)) =\n  sqrt\n   (cmod\n     (complex_of_real\n       (\\<Sum>x = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n           let z = vec_of_basis_enum \\<psi> $ x\n           in (Re z)\\<^sup>2 + (Im z)\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. norm \\<psi> =\n    (let \\<psi>' = vec_of_basis_enum \\<psi>\n     in sqrt\n         (\\<Sum>i = 0..<dim_vec \\<psi>'.\n             let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     (cmod\n       (complex_of_real\n         (\\<Sum>x = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n             let z = vec_of_basis_enum \\<psi> $ x\n             in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))) =\n    (let \\<psi>' = vec_of_basis_enum \\<psi>\n     in sqrt\n         (\\<Sum>i = 0..<dim_vec \\<psi>'.\n             let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))", "unfolding Let_def norm_of_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt\n     \\<bar>\\<Sum>x = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n              (Re (vec_of_basis_enum \\<psi> $ x))\\<^sup>2 +\n              (Im (vec_of_basis_enum \\<psi> $ x))\\<^sup>2\\<bar> =\n    sqrt\n     (\\<Sum>i = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n         (Re (vec_of_basis_enum \\<psi> $ i))\\<^sup>2 +\n         (Im (vec_of_basis_enum \\<psi> $ i))\\<^sup>2)", "apply (subst abs_of_nonneg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> (\\<Sum>x = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n                (Re (vec_of_basis_enum \\<psi> $ x))\\<^sup>2 +\n                (Im (vec_of_basis_enum \\<psi> $ x))\\<^sup>2)\n 2. sqrt\n     (\\<Sum>x = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n         (Re (vec_of_basis_enum \\<psi> $ x))\\<^sup>2 +\n         (Im (vec_of_basis_enum \\<psi> $ x))\\<^sup>2) =\n    sqrt\n     (\\<Sum>i = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n         (Re (vec_of_basis_enum \\<psi> $ i))\\<^sup>2 +\n         (Im (vec_of_basis_enum \\<psi> $ i))\\<^sup>2)", "apply (rule sum_nonneg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {0..<dim_vec (vec_of_basis_enum \\<psi>)} \\<Longrightarrow>\n       0 \\<le> (Re (vec_of_basis_enum \\<psi> $ x))\\<^sup>2 +\n               (Im (vec_of_basis_enum \\<psi> $ x))\\<^sup>2\n 2. sqrt\n     (\\<Sum>x = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n         (Re (vec_of_basis_enum \\<psi> $ x))\\<^sup>2 +\n         (Im (vec_of_basis_enum \\<psi> $ x))\\<^sup>2) =\n    sqrt\n     (\\<Sum>i = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n         (Re (vec_of_basis_enum \\<psi> $ i))\\<^sup>2 +\n         (Im (vec_of_basis_enum \\<psi> $ i))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  sqrt\n   (cmod\n     (complex_of_real\n       (\\<Sum>x = 0..<dim_vec (vec_of_basis_enum \\<psi>).\n           let z = vec_of_basis_enum \\<psi> $ x\n           in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))) =\n  (let \\<psi>' = vec_of_basis_enum \\<psi>\n   in sqrt\n       (\\<Sum>i = 0..<dim_vec \\<psi>'.\n           let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. norm \\<psi> =\n    (let \\<psi>' = vec_of_basis_enum \\<psi>\n     in sqrt\n         (\\<Sum>i = 0..<dim_vec \\<psi>'.\n             let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))", "finally"], ["proof (chain)\npicking this:\n  norm \\<psi> =\n  (let \\<psi>' = vec_of_basis_enum \\<psi>\n   in sqrt\n       (\\<Sum>i = 0..<dim_vec \\<psi>'.\n           let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))", "show ?thesis"], ["proof (prove)\nusing this:\n  norm \\<psi> =\n  (let \\<psi>' = vec_of_basis_enum \\<psi>\n   in sqrt\n       (\\<Sum>i = 0..<dim_vec \\<psi>'.\n           let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. norm \\<psi> =\n    (let \\<psi>' = vec_of_basis_enum \\<psi>\n     in sqrt\n         (\\<Sum>i = 0..<dim_vec \\<psi>'.\n             let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))", "by -"], ["proof (state)\nthis:\n  norm \\<psi> =\n  (let \\<psi>' = vec_of_basis_enum \\<psi>\n   in sqrt\n       (\\<Sum>i = 0..<dim_vec \\<psi>'.\n           let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_enum_of_vec_unit_vec:\n  defines \"basis \\<equiv> (canonical_basis::'a::basis_enum list)\"\n    and \"n \\<equiv> length (canonical_basis :: 'a list)\"\n  assumes a3: \"i < n\"  \n  shows \"basis_enum_of_vec (unit_vec n i) = basis!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "define L::\"complex list\" where \"L = list_of_vec (unit_vec n i)\""], ["proof (state)\nthis:\n  L = list_of_vec (unit_vec n i)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "define I::\"nat list\" where \"I = [0..<n]\""], ["proof (state)\nthis:\n  I = [0..<n]\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "have \"length L = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length L = n", "by (simp add: L_def)"], ["proof (state)\nthis:\n  length L = n\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "moreover"], ["proof (state)\nthis:\n  length L = n\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "have \"length basis = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length basis = n", "by (simp add: basis_def n_def)"], ["proof (state)\nthis:\n  length basis = n\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "ultimately"], ["proof (chain)\npicking this:\n  length L = n\n  length basis = n", "have \"map2 (*\\<^sub>C) L basis = map (\\<lambda>j. L!j *\\<^sub>C basis!j) I\""], ["proof (prove)\nusing this:\n  length L = n\n  length basis = n\n\ngoal (1 subgoal):\n 1. map2 (*\\<^sub>C) L basis = map (\\<lambda>j. L ! j *\\<^sub>C basis ! j) I", "by (simp add: I_def list_eq_iff_nth_eq)"], ["proof (state)\nthis:\n  map2 (*\\<^sub>C) L basis = map (\\<lambda>j. L ! j *\\<^sub>C basis ! j) I\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "hence \"sum_list (map2 (*\\<^sub>C) L basis) = sum_list (map (\\<lambda>j. L!j *\\<^sub>C basis!j) I)\""], ["proof (prove)\nusing this:\n  map2 (*\\<^sub>C) L basis = map (\\<lambda>j. L ! j *\\<^sub>C basis ! j) I\n\ngoal (1 subgoal):\n 1. sum_list (map2 (*\\<^sub>C) L basis) =\n    (\\<Sum>j\\<leftarrow>I. L ! j *\\<^sub>C basis ! j)", "by simp"], ["proof (state)\nthis:\n  sum_list (map2 (*\\<^sub>C) L basis) =\n  (\\<Sum>j\\<leftarrow>I. L ! j *\\<^sub>C basis ! j)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "also"], ["proof (state)\nthis:\n  sum_list (map2 (*\\<^sub>C) L basis) =\n  (\\<Sum>j\\<leftarrow>I. L ! j *\\<^sub>C basis ! j)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "have \"\\<dots> = sum (\\<lambda>j. L!j *\\<^sub>C basis!j) {0..n-1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>I. L ! j *\\<^sub>C basis ! j) =\n    (\\<Sum>j = 0..n - 1. L ! j *\\<^sub>C basis ! j)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>I. L ! j *\\<^sub>C basis ! j) =\n    (\\<Sum>j = 0..n - 1. L ! j *\\<^sub>C basis ! j)", "have \"set I = {0..n-1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set I = {0..n - 1}", "using I_def a3"], ["proof (prove)\nusing this:\n  I = [0..<n]\n  i < n\n\ngoal (1 subgoal):\n 1. set I = {0..n - 1}", "by auto"], ["proof (state)\nthis:\n  set I = {0..n - 1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>I. L ! j *\\<^sub>C basis ! j) =\n    (\\<Sum>j = 0..n - 1. L ! j *\\<^sub>C basis ! j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  set I = {0..n - 1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>I. L ! j *\\<^sub>C basis ! j) =\n    (\\<Sum>j = 0..n - 1. L ! j *\\<^sub>C basis ! j)", "using Groups_List.sum_code[where xs = I and g = \"(\\<lambda>j. L!j *\\<^sub>C basis!j)\"]"], ["proof (prove)\nusing this:\n  set I = {0..n - 1}\n  (\\<Sum>j\\<in>set I. L ! j *\\<^sub>C basis ! j) =\n  (\\<Sum>j\\<leftarrow>remdups I. L ! j *\\<^sub>C basis ! j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>I. L ! j *\\<^sub>C basis ! j) =\n    (\\<Sum>j = 0..n - 1. L ! j *\\<^sub>C basis ! j)", "by (simp add: I_def)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>I. L ! j *\\<^sub>C basis ! j) =\n  (\\<Sum>j = 0..n - 1. L ! j *\\<^sub>C basis ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>I. L ! j *\\<^sub>C basis ! j) =\n  (\\<Sum>j = 0..n - 1. L ! j *\\<^sub>C basis ! j)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>I. L ! j *\\<^sub>C basis ! j) =\n  (\\<Sum>j = 0..n - 1. L ! j *\\<^sub>C basis ! j)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "have \"\\<dots> = sum (\\<lambda>j. (list_of_vec (unit_vec n i))!j *\\<^sub>C basis!j) {0..n-1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1. L ! j *\\<^sub>C basis ! j) =\n    (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "unfolding L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..n - 1. L ! j *\\<^sub>C basis ! j) =\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "finally"], ["proof (chain)\npicking this:\n  sum_list (map2 (*\\<^sub>C) L basis) =\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "have \"sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) basis)\n       = sum (\\<lambda>j. (list_of_vec (unit_vec n i))!j *\\<^sub>C basis!j) {0..n-1}\""], ["proof (prove)\nusing this:\n  sum_list (map2 (*\\<^sub>C) L basis) =\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\n\ngoal (1 subgoal):\n 1. sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) basis) =\n    (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "using L_def"], ["proof (prove)\nusing this:\n  sum_list (map2 (*\\<^sub>C) L basis) =\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\n  L = list_of_vec (unit_vec n i)\n\ngoal (1 subgoal):\n 1. sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) basis) =\n    (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "by blast"], ["proof (state)\nthis:\n  sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) basis) =\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "also"], ["proof (state)\nthis:\n  sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) basis) =\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "have \"\\<dots> = basis ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    basis ! i", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    basis ! i", "have \"(\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n          (\\<Sum>j \\<in> {0..n - 1}. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    basis ! i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    basis ! i", "have \"\\<dots> = list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i\n               + (\\<Sum>j \\<in> {0..n - 1}-{i}. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "define a where \"a j = list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j\" for j"], ["proof (state)\nthis:\n  a ?j = list_of_vec (unit_vec n i) ! ?j *\\<^sub>C basis ! ?j\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "define S where \"S = {0..n - 1}\""], ["proof (state)\nthis:\n  S = {0..n - 1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "have \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "by (simp add: S_def)"], ["proof (state)\nthis:\n  finite S\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "hence \"(\\<Sum>j \\<in> insert i S. a j) = a i + (\\<Sum>j\\<in>S-{i}. a j)\""], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. sum a (insert i S) = a i + sum a (S - {i})", "using Groups_Big.comm_monoid_add_class.sum.insert_remove"], ["proof (prove)\nusing this:\n  finite S\n  finite ?A \\<Longrightarrow>\n  sum ?g (insert ?x ?A) = ?g ?x + sum ?g (?A - {?x})\n\ngoal (1 subgoal):\n 1. sum a (insert i S) = a i + sum a (S - {i})", "by auto"], ["proof (state)\nthis:\n  sum a (insert i S) = a i + sum a (S - {i})\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "moreover"], ["proof (state)\nthis:\n  sum a (insert i S) = a i + sum a (S - {i})\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "have \"S-{i} = {0..n-1}-{i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S - {i} = {0..n - 1} - {i}", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..n - 1} - {i} = {0..n - 1} - {i}", "by blast"], ["proof (state)\nthis:\n  S - {i} = {0..n - 1} - {i}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "moreover"], ["proof (state)\nthis:\n  S - {i} = {0..n - 1} - {i}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "have \"insert i S = {0..n-1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert i S = {0..n - 1}", "using S_def Suc_diff_1 a3 atLeastAtMost_iff diff_is_0_eq' le_SucE le_numeral_extra(4) \n          less_imp_le not_gr_zero"], ["proof (prove)\nusing this:\n  S = {0..n - 1}\n  0 < ?n \\<Longrightarrow> Suc (?n - 1) = ?n\n  i < n\n  (?i \\<in> {?l..?u}) = (?l \\<le> ?i \\<and> ?i \\<le> ?u)\n  ?m \\<le> ?n \\<Longrightarrow> ?m - ?n = 0\n  \\<lbrakk>?m \\<le> Suc ?n; ?m \\<le> ?n \\<Longrightarrow> ?R;\n   ?m = Suc ?n \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  (1::?'a) \\<le> (1::?'a)\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n  (\\<not> (0::?'a) < ?n) = (?n = (0::?'a))\n\ngoal (1 subgoal):\n 1. insert i S = {0..n - 1}", "by fastforce"], ["proof (state)\nthis:\n  insert i S = {0..n - 1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "ultimately"], ["proof (chain)\npicking this:\n  sum a (insert i S) = a i + sum a (S - {i})\n  S - {i} = {0..n - 1} - {i}\n  insert i S = {0..n - 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  sum a (insert i S) = a i + sum a (S - {i})\n  S - {i} = {0..n - 1} - {i}\n  insert i S = {0..n - 1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "using \\<open>a \\<equiv> \\<lambda>j. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j\\<close>"], ["proof (prove)\nusing this:\n  sum a (insert i S) = a i + sum a (S - {i})\n  S - {i} = {0..n - 1} - {i}\n  insert i S = {0..n - 1}\n  a \\<equiv> \\<lambda>j. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n  (\\<Sum>j\\<in>{0..n - 1} - {i}.\n     list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n  (\\<Sum>j\\<in>{0..n - 1} - {i}.\n     list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    basis ! i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n  (\\<Sum>j\\<in>{0..n - 1} - {i}.\n     list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    basis ! i", "have \"\\<dots> = list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i", "have \"j \\<in> {0..n - 1}-{i} \\<Longrightarrow> list_of_vec (unit_vec n i) ! j = 0\"\n        for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<in> {0..n - 1} - {i} \\<Longrightarrow>\n    list_of_vec (unit_vec n i) ! j = (0::'b)", "using a3 atMost_atLeast0 atMost_iff diff_Suc_less index_unit_vec(1) le_less_trans \n          list_of_vec_index member_remove zero_le"], ["proof (prove)\nusing this:\n  i < n\n  {..?n} = {0..?n}\n  (?i \\<in> {..?k}) = (?i \\<le> ?k)\n  0 < ?n \\<Longrightarrow> ?n - Suc ?i < ?n\n  \\<lbrakk>?i < ?n; ?j < ?n\\<rbrakk>\n  \\<Longrightarrow> unit_vec ?n ?i $ ?j =\n                    (if ?j = ?i then 1::?'a else (0::?'a))\n  \\<lbrakk>?x \\<le> ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  list_of_vec ?v ! ?j = ?v $ ?j\n  (?x \\<in> Set.remove ?y ?A) = (?x \\<in> ?A \\<and> ?x \\<noteq> ?y)\n  (0::?'a) \\<le> ?x\n\ngoal (1 subgoal):\n 1. j \\<in> {0..n - 1} - {i} \\<Longrightarrow>\n    list_of_vec (unit_vec n i) ! j = (0::'b)", "by fastforce"], ["proof (state)\nthis:\n  ?j1 \\<in> {0..n - 1} - {i} \\<Longrightarrow>\n  list_of_vec (unit_vec n i) ! ?j1 = (0::?'b2)\n\ngoal (1 subgoal):\n 1. list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i", "hence \"j \\<in> {0..n - 1}-{i} \\<Longrightarrow> list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j = 0\"\n        for j"], ["proof (prove)\nusing this:\n  ?j1 \\<in> {0..n - 1} - {i} \\<Longrightarrow>\n  list_of_vec (unit_vec n i) ! ?j1 = (0::?'b2)\n\ngoal (1 subgoal):\n 1. j \\<in> {0..n - 1} - {i} \\<Longrightarrow>\n    list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j = (0::'a)", "by auto"], ["proof (state)\nthis:\n  ?j1 \\<in> {0..n - 1} - {i} \\<Longrightarrow>\n  list_of_vec (unit_vec n i) ! ?j1 *\\<^sub>C basis ! ?j1 = (0::'a)\n\ngoal (1 subgoal):\n 1. list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i", "hence \"(\\<Sum>j \\<in> {0..n - 1}-{i}. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) = 0\""], ["proof (prove)\nusing this:\n  ?j1 \\<in> {0..n - 1} - {i} \\<Longrightarrow>\n  list_of_vec (unit_vec n i) ! ?j1 *\\<^sub>C basis ! ?j1 = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    (0::'a)", "by (simp add: \\<open>\\<And>j. j \\<in> {0..n - 1} - {i} \\<Longrightarrow> list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j = 0\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{0..n - 1} - {i}.\n     list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>j\\<in>{0..n - 1} - {i}.\n     list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n    (\\<Sum>j\\<in>{0..n - 1} - {i}.\n       list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i", "by simp"], ["proof (state)\nthis:\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n  (\\<Sum>j\\<in>{0..n - 1} - {i}.\n     list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n  (\\<Sum>j\\<in>{0..n - 1} - {i}.\n     list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    basis ! i", "also"], ["proof (state)\nthis:\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n  (\\<Sum>j\\<in>{0..n - 1} - {i}.\n     list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    basis ! i", "have \"\\<dots> = basis ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i = basis ! i", "by (simp add: a3)"], ["proof (state)\nthis:\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i = basis ! i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    basis ! i", "finally"], ["proof (chain)\npicking this:\n  basis ! i = basis ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  basis ! i = basis ! i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    basis ! i", "using \\<open>(\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\n             = list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i + (\\<Sum>j\\<in>{0..n - 1} - {i}. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\\<close>\n        \\<open>list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i + (\\<Sum>j\\<in>{0..n - 1} - {i}. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\n           = list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i\\<close>\n        \\<open>list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i = basis ! i\\<close>"], ["proof (prove)\nusing this:\n  basis ! i = basis ! i\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n  (\\<Sum>j\\<in>{0..n - 1} - {i}.\n     list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j)\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i +\n  (\\<Sum>j\\<in>{0..n - 1} - {i}.\n     list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i\n  list_of_vec (unit_vec n i) ! i *\\<^sub>C basis ! i = basis ! i\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..n - 1.\n        list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n    basis ! i", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  basis ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..n - 1. list_of_vec (unit_vec n i) ! j *\\<^sub>C basis ! j) =\n  basis ! i\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "finally"], ["proof (chain)\npicking this:\n  sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) basis) = basis ! i", "have \"sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) basis)\n      = basis ! i\""], ["proof (prove)\nusing this:\n  sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) basis) = basis ! i\n\ngoal (1 subgoal):\n 1. sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) basis) =\n    basis ! i", "by (simp add: assms)"], ["proof (state)\nthis:\n  sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) basis) = basis ! i\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "hence \"sum_list (map2 scaleC (list_of_vec (unit_vec n i)) (canonical_basis::'a list))\n      = (canonical_basis::'a list) ! i\""], ["proof (prove)\nusing this:\n  sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) basis) = basis ! i\n\ngoal (1 subgoal):\n 1. sum_list\n     (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) canonical_basis) =\n    canonical_basis ! i", "by (simp add: assms)"], ["proof (state)\nthis:\n  sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) canonical_basis) =\n  canonical_basis ! i\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) canonical_basis) =\n  canonical_basis ! i\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (unit_vec n i) = basis ! i", "unfolding basis_enum_of_vec_def"], ["proof (prove)\nusing this:\n  sum_list (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) canonical_basis) =\n  canonical_basis ! i\n\ngoal (1 subgoal):\n 1. (if dim_vec (unit_vec n i) = length canonical_basis\n     then sum_list\n           (map2 (*\\<^sub>C) (list_of_vec (unit_vec n i)) canonical_basis)\n     else (0::'a)) =\n    basis ! i", "by (simp add: assms)"], ["proof (state)\nthis:\n  basis_enum_of_vec (unit_vec n i) = basis ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_of_basis_enum_ket:\n  \"vec_of_basis_enum (ket i) = unit_vec (CARD('a)) (enum_idx i)\" \n  for i::\"'a::enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) = unit_vec CARD('a) (enum_idx i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) = unit_vec CARD('a) (enum_idx i)", "have \"dim_vec (vec_of_basis_enum (ket i)) \n      = dim_vec (unit_vec (CARD('a)) (enum_idx i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_of_basis_enum (ket i)) =\n    dim_vec (unit_vec CARD('a) (enum_idx i))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. dim_vec (vec_of_basis_enum (ket i)) =\n    dim_vec (unit_vec CARD('a) (enum_idx i))", "have \"dim_vec (unit_vec (CARD('a)) (enum_idx i)) \n      = CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (unit_vec CARD('a) (enum_idx i)) = CARD('a)", "by simp"], ["proof (state)\nthis:\n  dim_vec (unit_vec CARD('a) (enum_idx i)) = CARD('a)\n\ngoal (1 subgoal):\n 1. dim_vec (vec_of_basis_enum (ket i)) =\n    dim_vec (unit_vec CARD('a) (enum_idx i))", "moreover"], ["proof (state)\nthis:\n  dim_vec (unit_vec CARD('a) (enum_idx i)) = CARD('a)\n\ngoal (1 subgoal):\n 1. dim_vec (vec_of_basis_enum (ket i)) =\n    dim_vec (unit_vec CARD('a) (enum_idx i))", "have \"dim_vec (vec_of_basis_enum (ket i)) = CARD('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_of_basis_enum (ket i)) = CARD('a)", "unfolding vec_of_basis_enum_def vec_of_basis_enum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list\n       (map (crepresentation (set canonical_basis) (ket i))\n         canonical_basis)) =\n    CARD('a)", "by auto"], ["proof (state)\nthis:\n  dim_vec (vec_of_basis_enum (ket i)) = CARD('a)\n\ngoal (1 subgoal):\n 1. dim_vec (vec_of_basis_enum (ket i)) =\n    dim_vec (unit_vec CARD('a) (enum_idx i))", "ultimately"], ["proof (chain)\npicking this:\n  dim_vec (unit_vec CARD('a) (enum_idx i)) = CARD('a)\n  dim_vec (vec_of_basis_enum (ket i)) = CARD('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  dim_vec (unit_vec CARD('a) (enum_idx i)) = CARD('a)\n  dim_vec (vec_of_basis_enum (ket i)) = CARD('a)\n\ngoal (1 subgoal):\n 1. dim_vec (vec_of_basis_enum (ket i)) =\n    dim_vec (unit_vec CARD('a) (enum_idx i))", "by simp"], ["proof (state)\nthis:\n  dim_vec (vec_of_basis_enum (ket i)) =\n  dim_vec (unit_vec CARD('a) (enum_idx i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dim_vec (vec_of_basis_enum (ket i)) =\n  dim_vec (unit_vec CARD('a) (enum_idx i))\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) = unit_vec CARD('a) (enum_idx i)", "moreover"], ["proof (state)\nthis:\n  dim_vec (vec_of_basis_enum (ket i)) =\n  dim_vec (unit_vec CARD('a) (enum_idx i))\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) = unit_vec CARD('a) (enum_idx i)", "have \"vec_of_basis_enum (ket i) $ j =\n    (unit_vec (CARD('a)) (enum_idx i)) $ j\"\n    if \"j < dim_vec (vec_of_basis_enum (ket i))\"\n    for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "have j_bound: \"j < length (canonical_basis::'a ell2 list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length canonical_basis", "by (metis dim_vec_of_basis_enum' that)"], ["proof (state)\nthis:\n  j < length canonical_basis\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "have y1: \"cindependent (set (canonical_basis::'a ell2 list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent (set canonical_basis)", "using is_cindependent_set"], ["proof (prove)\nusing this:\n  cindependent (set canonical_basis)\n\ngoal (1 subgoal):\n 1. cindependent (set canonical_basis)", "by blast"], ["proof (state)\nthis:\n  cindependent (set canonical_basis)\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "have y2: \"canonical_basis ! j \\<in> set (canonical_basis::'a ell2 list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canonical_basis ! j \\<in> set canonical_basis", "using j_bound"], ["proof (prove)\nusing this:\n  j < length canonical_basis\n\ngoal (1 subgoal):\n 1. canonical_basis ! j \\<in> set canonical_basis", "by auto"], ["proof (state)\nthis:\n  canonical_basis ! j \\<in> set canonical_basis\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "have p1: \"enum_class.enum ! enum_idx i = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_class.enum ! enum_idx i = i", "using enum_idx_correct"], ["proof (prove)\nusing this:\n  enum_class.enum ! enum_idx ?i = ?i\n\ngoal (1 subgoal):\n 1. enum_class.enum ! enum_idx i = i", "by blast"], ["proof (state)\nthis:\n  enum_class.enum ! enum_idx i = i\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "moreover"], ["proof (state)\nthis:\n  enum_class.enum ! enum_idx i = i\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "have p2: \"(canonical_basis::'a ell2 list) ! t  = ket ((enum_class.enum::'a list) ! t)\"\n      if \"t < length (enum_class.enum::'a list)\"\n      for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. canonical_basis ! t = ket (enum_class.enum ! t)", "unfolding canonical_basis_ell2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ket enum_class.enum ! t = ket (enum_class.enum ! t)", "using that"], ["proof (prove)\nusing this:\n  t < length enum_class.enum\n\ngoal (1 subgoal):\n 1. map ket enum_class.enum ! t = ket (enum_class.enum ! t)", "by auto"], ["proof (state)\nthis:\n  ?t1 < length enum_class.enum \\<Longrightarrow>\n  canonical_basis ! ?t1 = ket (enum_class.enum ! ?t1)\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "moreover"], ["proof (state)\nthis:\n  ?t1 < length enum_class.enum \\<Longrightarrow>\n  canonical_basis ! ?t1 = ket (enum_class.enum ! ?t1)\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "have p3: \"enum_idx i < length (enum_class.enum::'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_idx i < length enum_class.enum", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. enum_idx i < length enum_class.enum", "have \"set (enum_class.enum::'a list) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set enum_class.enum = UNIV", "using UNIV_enum"], ["proof (prove)\nusing this:\n  UNIV = set enum_class.enum\n\ngoal (1 subgoal):\n 1. set enum_class.enum = UNIV", "by blast"], ["proof (state)\nthis:\n  set enum_class.enum = UNIV\n\ngoal (1 subgoal):\n 1. enum_idx i < length enum_class.enum", "hence \"i \\<in> set (enum_class.enum::'a list)\""], ["proof (prove)\nusing this:\n  set enum_class.enum = UNIV\n\ngoal (1 subgoal):\n 1. i \\<in> set enum_class.enum", "by blast"], ["proof (state)\nthis:\n  i \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. enum_idx i < length enum_class.enum", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. enum_idx i < length enum_class.enum", "unfolding enum_idx_def"], ["proof (prove)\nusing this:\n  i \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. index_of i enum_class.enum < length enum_class.enum", "by (metis index_of_bound length_greater_0_conv length_pos_if_in_set)"], ["proof (state)\nthis:\n  enum_idx i < length enum_class.enum\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  enum_idx i < length enum_class.enum\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "ultimately"], ["proof (chain)\npicking this:\n  enum_class.enum ! enum_idx i = i\n  ?t1 < length enum_class.enum \\<Longrightarrow>\n  canonical_basis ! ?t1 = ket (enum_class.enum ! ?t1)\n  enum_idx i < length enum_class.enum", "have p4: \"(canonical_basis::'a ell2 list) ! (enum_idx i)  = ket i\""], ["proof (prove)\nusing this:\n  enum_class.enum ! enum_idx i = i\n  ?t1 < length enum_class.enum \\<Longrightarrow>\n  canonical_basis ! ?t1 = ket (enum_class.enum ! ?t1)\n  enum_idx i < length enum_class.enum\n\ngoal (1 subgoal):\n 1. canonical_basis ! enum_idx i = ket i", "by auto"], ["proof (state)\nthis:\n  canonical_basis ! enum_idx i = ket i\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "have \"enum_idx i < length (enum_class.enum::'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_idx i < length enum_class.enum", "using p3"], ["proof (prove)\nusing this:\n  enum_idx i < length enum_class.enum\n\ngoal (1 subgoal):\n 1. enum_idx i < length enum_class.enum", "by auto"], ["proof (state)\nthis:\n  enum_idx i < length enum_class.enum\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "moreover"], ["proof (state)\nthis:\n  enum_idx i < length enum_class.enum\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "have \"length (enum_class.enum::'a list) = dim_vec (vec_of_basis_enum (ket i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length enum_class.enum = dim_vec (vec_of_basis_enum (ket i))", "unfolding vec_of_basis_enum_def canonical_basis_ell2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length enum_class.enum =\n    dim_vec\n     (vec_of_list\n       (map (crepresentation (set (map ket enum_class.enum)) (ket i))\n         (map ket enum_class.enum)))", "using dim_vec_of_basis_enum'[where v = \"ket i\"]"], ["proof (prove)\nusing this:\n  dim_vec (vec_of_basis_enum (ket i)) = length canonical_basis\n\ngoal (1 subgoal):\n 1. length enum_class.enum =\n    dim_vec\n     (vec_of_list\n       (map (crepresentation (set (map ket enum_class.enum)) (ket i))\n         (map ket enum_class.enum)))", "unfolding canonical_basis_ell2_def"], ["proof (prove)\nusing this:\n  dim_vec (vec_of_basis_enum (ket i)) = length (map ket enum_class.enum)\n\ngoal (1 subgoal):\n 1. length enum_class.enum =\n    dim_vec\n     (vec_of_list\n       (map (crepresentation (set (map ket enum_class.enum)) (ket i))\n         (map ket enum_class.enum)))", "by simp"], ["proof (state)\nthis:\n  length enum_class.enum = dim_vec (vec_of_basis_enum (ket i))\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "ultimately"], ["proof (chain)\npicking this:\n  enum_idx i < length enum_class.enum\n  length enum_class.enum = dim_vec (vec_of_basis_enum (ket i))", "have enum_i_dim_vec: \"enum_idx i < dim_vec (unit_vec (CARD('a)) (enum_idx i))\""], ["proof (prove)\nusing this:\n  enum_idx i < length enum_class.enum\n  length enum_class.enum = dim_vec (vec_of_basis_enum (ket i))\n\ngoal (1 subgoal):\n 1. enum_idx i < dim_vec (unit_vec CARD('a) (enum_idx i))", "using \\<open>dim_vec (vec_of_basis_enum (ket i)) = dim_vec (unit_vec (CARD('a)) (enum_idx i))\\<close>"], ["proof (prove)\nusing this:\n  enum_idx i < length enum_class.enum\n  length enum_class.enum = dim_vec (vec_of_basis_enum (ket i))\n  dim_vec (vec_of_basis_enum (ket i)) =\n  dim_vec (unit_vec CARD('a) (enum_idx i))\n\ngoal (1 subgoal):\n 1. enum_idx i < dim_vec (unit_vec CARD('a) (enum_idx i))", "by auto"], ["proof (state)\nthis:\n  enum_idx i < dim_vec (unit_vec CARD('a) (enum_idx i))\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "hence r1: \"(unit_vec (CARD('a)) (enum_idx i)) $ j\n        = (if enum_idx i = j then 1 else 0)\""], ["proof (prove)\nusing this:\n  enum_idx i < dim_vec (unit_vec CARD('a) (enum_idx i))\n\ngoal (1 subgoal):\n 1. unit_vec CARD('a) (enum_idx i) $ j =\n    (if enum_idx i = j then 1::'b else (0::'b))", "using \\<open>dim_vec (vec_of_basis_enum (ket i)) = dim_vec (unit_vec (CARD('a)) (enum_idx i))\\<close> that"], ["proof (prove)\nusing this:\n  enum_idx i < dim_vec (unit_vec CARD('a) (enum_idx i))\n  dim_vec (vec_of_basis_enum (ket i)) =\n  dim_vec (unit_vec CARD('a) (enum_idx i))\n  j < dim_vec (vec_of_basis_enum (ket i))\n\ngoal (1 subgoal):\n 1. unit_vec CARD('a) (enum_idx i) $ j =\n    (if enum_idx i = j then 1::'b else (0::'b))", "by auto"], ["proof (state)\nthis:\n  unit_vec CARD('a) (enum_idx i) $ j =\n  (if enum_idx i = j then 1::?'b3 else (0::?'b3))\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "moreover"], ["proof (state)\nthis:\n  unit_vec CARD('a) (enum_idx i) $ j =\n  (if enum_idx i = j then 1::?'b3 else (0::?'b3))\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "have \"vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "proof(cases \"enum_idx i = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. enum_idx i = j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)\n 2. enum_idx i \\<noteq> j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "case True"], ["proof (state)\nthis:\n  enum_idx i = j\n\ngoal (2 subgoals):\n 1. enum_idx i = j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)\n 2. enum_idx i \\<noteq> j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "have \"crepresentation (set (canonical_basis::'a ell2 list)) \n          ((canonical_basis::'a ell2 list) ! j) ((canonical_basis::'a ell2 list) ! j) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crepresentation (set canonical_basis) (canonical_basis ! j)\n     (canonical_basis ! j) =\n    1", "using y1 y2 complex_vector.representation_basis[where \n            basis = \"set (canonical_basis::'a ell2 list)\" \n            and b = \"(canonical_basis::'a ell2 list) ! j\"]"], ["proof (prove)\nusing this:\n  cindependent (set canonical_basis)\n  canonical_basis ! j \\<in> set canonical_basis\n  \\<lbrakk>cindependent (set canonical_basis);\n   canonical_basis ! j \\<in> set canonical_basis\\<rbrakk>\n  \\<Longrightarrow> crepresentation (set canonical_basis)\n                     (canonical_basis ! j) =\n                    (\\<lambda>v. if v = canonical_basis ! j then 1 else 0)\n\ngoal (1 subgoal):\n 1. crepresentation (set canonical_basis) (canonical_basis ! j)\n     (canonical_basis ! j) =\n    1", "by smt"], ["proof (state)\nthis:\n  crepresentation (set canonical_basis) (canonical_basis ! j)\n   (canonical_basis ! j) =\n  1\n\ngoal (2 subgoals):\n 1. enum_idx i = j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)\n 2. enum_idx i \\<noteq> j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "hence \"vec_of_basis_enum ((canonical_basis::'a ell2 list) ! j) $ j = 1\""], ["proof (prove)\nusing this:\n  crepresentation (set canonical_basis) (canonical_basis ! j)\n   (canonical_basis ! j) =\n  1\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (canonical_basis ! j) $ j = 1", "unfolding vec_of_basis_enum_def"], ["proof (prove)\nusing this:\n  crepresentation (set canonical_basis) (canonical_basis ! j)\n   (canonical_basis ! j) =\n  1\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (map (crepresentation (set canonical_basis) (canonical_basis ! j))\n       canonical_basis) $\n    j =\n    1", "by (metis j_bound nth_map vec_of_list_index)"], ["proof (state)\nthis:\n  vec_of_basis_enum (canonical_basis ! j) $ j = 1\n\ngoal (2 subgoals):\n 1. enum_idx i = j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)\n 2. enum_idx i \\<noteq> j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "hence \"vec_of_basis_enum ((canonical_basis::'a ell2 list) ! (enum_idx i)) \n            $ enum_idx i = 1\""], ["proof (prove)\nusing this:\n  vec_of_basis_enum (canonical_basis ! j) $ j = 1\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (canonical_basis ! enum_idx i) $ enum_idx i = 1", "using True"], ["proof (prove)\nusing this:\n  vec_of_basis_enum (canonical_basis ! j) $ j = 1\n  enum_idx i = j\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (canonical_basis ! enum_idx i) $ enum_idx i = 1", "by simp"], ["proof (state)\nthis:\n  vec_of_basis_enum (canonical_basis ! enum_idx i) $ enum_idx i = 1\n\ngoal (2 subgoals):\n 1. enum_idx i = j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)\n 2. enum_idx i \\<noteq> j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "hence \"vec_of_basis_enum (ket i) $ enum_idx i = 1\""], ["proof (prove)\nusing this:\n  vec_of_basis_enum (canonical_basis ! enum_idx i) $ enum_idx i = 1\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ enum_idx i = 1", "using p4"], ["proof (prove)\nusing this:\n  vec_of_basis_enum (canonical_basis ! enum_idx i) $ enum_idx i = 1\n  canonical_basis ! enum_idx i = ket i\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ enum_idx i = 1", "by simp"], ["proof (state)\nthis:\n  vec_of_basis_enum (ket i) $ enum_idx i = 1\n\ngoal (2 subgoals):\n 1. enum_idx i = j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)\n 2. enum_idx i \\<noteq> j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  vec_of_basis_enum (ket i) $ enum_idx i = 1\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "using True"], ["proof (prove)\nusing this:\n  vec_of_basis_enum (ket i) $ enum_idx i = 1\n  enum_idx i = j\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "unfolding vec_of_basis_enum_def"], ["proof (prove)\nusing this:\n  vec_of_list\n   (map (crepresentation (set canonical_basis) (ket i)) canonical_basis) $\n  enum_idx i =\n  1\n  enum_idx i = j\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (map (crepresentation (set canonical_basis) (ket i)) canonical_basis) $\n    j =\n    (if enum_idx i = j then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)\n\ngoal (1 subgoal):\n 1. enum_idx i \\<noteq> j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. enum_idx i \\<noteq> j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "case False"], ["proof (state)\nthis:\n  enum_idx i \\<noteq> j\n\ngoal (1 subgoal):\n 1. enum_idx i \\<noteq> j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "have \"crepresentation (set (canonical_basis::'a ell2 list)) \n          ((canonical_basis::'a ell2 list) ! (enum_idx i)) ((canonical_basis::'a ell2 list) ! j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crepresentation (set canonical_basis) (canonical_basis ! enum_idx i)\n     (canonical_basis ! j) =\n    0", "using y1 y2 complex_vector.representation_basis[where \n            basis = \"set (canonical_basis::'a ell2 list)\" \n            and b = \"(canonical_basis::'a ell2 list) ! j\"]"], ["proof (prove)\nusing this:\n  cindependent (set canonical_basis)\n  canonical_basis ! j \\<in> set canonical_basis\n  \\<lbrakk>cindependent (set canonical_basis);\n   canonical_basis ! j \\<in> set canonical_basis\\<rbrakk>\n  \\<Longrightarrow> crepresentation (set canonical_basis)\n                     (canonical_basis ! j) =\n                    (\\<lambda>v. if v = canonical_basis ! j then 1 else 0)\n\ngoal (1 subgoal):\n 1. crepresentation (set canonical_basis) (canonical_basis ! enum_idx i)\n     (canonical_basis ! j) =\n    0", "by (metis (mono_tags, hide_lams) False enum_i_dim_vec basis_enum_of_vec_inverse basis_enum_of_vec_unit_vec canonical_basis_length_ell2 index_unit_vec(3) j_bound list_of_vec_index list_vec nth_map r1 vec_of_basis_enum_def)"], ["proof (state)\nthis:\n  crepresentation (set canonical_basis) (canonical_basis ! enum_idx i)\n   (canonical_basis ! j) =\n  0\n\ngoal (1 subgoal):\n 1. enum_idx i \\<noteq> j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "hence \"vec_of_basis_enum ((canonical_basis::'a ell2 list) ! (enum_idx i)) $ j = 0\""], ["proof (prove)\nusing this:\n  crepresentation (set canonical_basis) (canonical_basis ! enum_idx i)\n   (canonical_basis ! j) =\n  0\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (canonical_basis ! enum_idx i) $ j = 0", "unfolding vec_of_basis_enum_def"], ["proof (prove)\nusing this:\n  crepresentation (set canonical_basis) (canonical_basis ! enum_idx i)\n   (canonical_basis ! j) =\n  0\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (map (crepresentation (set canonical_basis)\n            (canonical_basis ! enum_idx i))\n       canonical_basis) $\n    j =\n    0", "by (smt j_bound nth_map vec_of_list_index)"], ["proof (state)\nthis:\n  vec_of_basis_enum (canonical_basis ! enum_idx i) $ j = 0\n\ngoal (1 subgoal):\n 1. enum_idx i \\<noteq> j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "hence \"vec_of_basis_enum ((canonical_basis::'a ell2 list) ! (enum_idx i)) $ j = 0\""], ["proof (prove)\nusing this:\n  vec_of_basis_enum (canonical_basis ! enum_idx i) $ j = 0\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (canonical_basis ! enum_idx i) $ j = 0", "by auto"], ["proof (state)\nthis:\n  vec_of_basis_enum (canonical_basis ! enum_idx i) $ j = 0\n\ngoal (1 subgoal):\n 1. enum_idx i \\<noteq> j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "hence \"vec_of_basis_enum (ket i) $ j = 0\""], ["proof (prove)\nusing this:\n  vec_of_basis_enum (canonical_basis ! enum_idx i) $ j = 0\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = 0", "using p4"], ["proof (prove)\nusing this:\n  vec_of_basis_enum (canonical_basis ! enum_idx i) $ j = 0\n  canonical_basis ! enum_idx i = ket i\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = 0", "by simp"], ["proof (state)\nthis:\n  vec_of_basis_enum (ket i) $ j = 0\n\ngoal (1 subgoal):\n 1. enum_idx i \\<noteq> j \\<Longrightarrow>\n    vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  vec_of_basis_enum (ket i) $ j = 0\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "using False"], ["proof (prove)\nusing this:\n  vec_of_basis_enum (ket i) $ j = 0\n  enum_idx i \\<noteq> j\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "unfolding vec_of_basis_enum_def"], ["proof (prove)\nusing this:\n  vec_of_list\n   (map (crepresentation (set canonical_basis) (ket i)) canonical_basis) $\n  j =\n  0\n  enum_idx i \\<noteq> j\n\ngoal (1 subgoal):\n 1. vec_of_list\n     (map (crepresentation (set canonical_basis) (ket i)) canonical_basis) $\n    j =\n    (if enum_idx i = j then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "ultimately"], ["proof (chain)\npicking this:\n  unit_vec CARD('a) (enum_idx i) $ j =\n  (if enum_idx i = j then 1::?'b3 else (0::?'b3))\n  vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  unit_vec CARD('a) (enum_idx i) $ j =\n  (if enum_idx i = j then 1::?'b3 else (0::?'b3))\n  vec_of_basis_enum (ket i) $ j = (if enum_idx i = j then 1 else 0)\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j", "by auto"], ["proof (state)\nthis:\n  vec_of_basis_enum (ket i) $ j = unit_vec CARD('a) (enum_idx i) $ j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?j1 < dim_vec (vec_of_basis_enum (ket i)) \\<Longrightarrow>\n  vec_of_basis_enum (ket i) $ ?j1 = unit_vec CARD('a) (enum_idx i) $ ?j1\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) = unit_vec CARD('a) (enum_idx i)", "ultimately"], ["proof (chain)\npicking this:\n  dim_vec (vec_of_basis_enum (ket i)) =\n  dim_vec (unit_vec CARD('a) (enum_idx i))\n  ?j1 < dim_vec (vec_of_basis_enum (ket i)) \\<Longrightarrow>\n  vec_of_basis_enum (ket i) $ ?j1 = unit_vec CARD('a) (enum_idx i) $ ?j1", "show ?thesis"], ["proof (prove)\nusing this:\n  dim_vec (vec_of_basis_enum (ket i)) =\n  dim_vec (unit_vec CARD('a) (enum_idx i))\n  ?j1 < dim_vec (vec_of_basis_enum (ket i)) \\<Longrightarrow>\n  vec_of_basis_enum (ket i) $ ?j1 = unit_vec CARD('a) (enum_idx i) $ ?j1\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) = unit_vec CARD('a) (enum_idx i)", "using Matrix.eq_vecI"], ["proof (prove)\nusing this:\n  dim_vec (vec_of_basis_enum (ket i)) =\n  dim_vec (unit_vec CARD('a) (enum_idx i))\n  ?j1 < dim_vec (vec_of_basis_enum (ket i)) \\<Longrightarrow>\n  vec_of_basis_enum (ket i) $ ?j1 = unit_vec CARD('a) (enum_idx i) $ ?j1\n  \\<lbrakk>\\<And>i. i < dim_vec ?w \\<Longrightarrow> ?v $ i = ?w $ i;\n   dim_vec ?v = dim_vec ?w\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (ket i) = unit_vec CARD('a) (enum_idx i)", "by auto"], ["proof (state)\nthis:\n  vec_of_basis_enum (ket i) = unit_vec CARD('a) (enum_idx i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_of_basis_enum_zero:\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::basis_enum list)\" \n  shows \"vec_of_basis_enum (0::'a) = 0\\<^sub>v nA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (0::'a) = 0\\<^sub>v nA", "by (metis assms carrier_vecI dim_vec_of_basis_enum' minus_cancel_vec right_minus_eq vec_of_basis_enum_minus)"], ["", "lemma (in complex_vec_space) vec_of_basis_enum_cspan:\n  fixes X :: \"'a::basis_enum set\"\n  assumes \"length (canonical_basis :: 'a list) = n\"\n  shows \"vec_of_basis_enum ` cspan X = span (vec_of_basis_enum ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum ` cspan X = local.span (vec_of_basis_enum ` X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_basis_enum ` cspan X = local.span (vec_of_basis_enum ` X)", "have carrier: \"vec_of_basis_enum ` X \\<subseteq> carrier_vec n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum ` X \\<subseteq> carrier_vec n", "by (metis assms carrier_vecI dim_vec_of_basis_enum' image_subsetI)"], ["proof (state)\nthis:\n  vec_of_basis_enum ` X \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum ` cspan X = local.span (vec_of_basis_enum ` X)", "have lincomb_sum: \"lincomb c A = vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\" \n    if B_def: \"B = basis_enum_of_vec ` A\" and \\<open>finite A\\<close>\n      and AX: \"A \\<subseteq> vec_of_basis_enum ` X\" and c'_def: \"\\<And>b. c' b = c (vec_of_basis_enum b)\"\n    for c c' A and B::\"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb c A = vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)", "unfolding B_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb c A =\n    vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` A. c' b *\\<^sub>C b)", "using \\<open>finite A\\<close> AX"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> vec_of_basis_enum ` X\n\ngoal (1 subgoal):\n 1. lincomb c A =\n    vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` A. c' b *\\<^sub>C b)", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n    lincomb c {} =\n    vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` {}. c' b *\\<^sub>C b)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> vec_of_basis_enum ` X\n\ngoal (2 subgoals):\n 1. {} \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n    lincomb c {} =\n    vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` {}. c' b *\\<^sub>C b)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "then"], ["proof (chain)\npicking this:\n  {} \\<subseteq> vec_of_basis_enum ` X", "show ?case"], ["proof (prove)\nusing this:\n  {} \\<subseteq> vec_of_basis_enum ` X\n\ngoal (1 subgoal):\n 1. lincomb c {} =\n    vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` {}. c' b *\\<^sub>C b)", "by (simp add: assms vec_of_basis_enum_zero)"], ["proof (state)\nthis:\n  lincomb c {} =\n  vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` {}. c' b *\\<^sub>C b)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n  lincomb c F =\n  vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b)\n  insert x F \\<subseteq> vec_of_basis_enum ` X\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "then"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n  lincomb c F =\n  vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b)\n  insert x F \\<subseteq> vec_of_basis_enum ` X", "have IH: \"lincomb c F = vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b)\"\n      (is \"_ = ?sum\")"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n  lincomb c F =\n  vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b)\n  insert x F \\<subseteq> vec_of_basis_enum ` X\n\ngoal (1 subgoal):\n 1. lincomb c F =\n    vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b)", "by simp"], ["proof (state)\nthis:\n  lincomb c F =\n  vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "have xx: \"vec_of_basis_enum (basis_enum_of_vec x :: 'a) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (basis_enum_of_vec x) = x", "apply (rule basis_enum_of_vec_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec x = length canonical_basis", "using assms carrier carrier_vecD insert.prems"], ["proof (prove)\nusing this:\n  length canonical_basis = n\n  vec_of_basis_enum ` X \\<subseteq> carrier_vec n\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> dim_vec ?v = ?n\n  insert x F \\<subseteq> vec_of_basis_enum ` X\n\ngoal (1 subgoal):\n 1. dim_vec x = length canonical_basis", "by auto"], ["proof (state)\nthis:\n  vec_of_basis_enum (basis_enum_of_vec x) = x\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "have \"lincomb c (insert x F) = c x \\<cdot>\\<^sub>v x + lincomb c F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb c (insert x F) = c x \\<cdot>\\<^sub>v x + lincomb c F", "apply (rule lincomb_insert2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite F\n 2. F \\<subseteq> carrier_vec n\n 3. c \\<in> insert x F \\<rightarrow> UNIV\n 4. x \\<notin> F\n 5. x \\<in> carrier_vec n", "using insert.hyps insert.prems carrier"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  insert x F \\<subseteq> vec_of_basis_enum ` X\n  vec_of_basis_enum ` X \\<subseteq> carrier_vec n\n\ngoal (5 subgoals):\n 1. finite F\n 2. F \\<subseteq> carrier_vec n\n 3. c \\<in> insert x F \\<rightarrow> UNIV\n 4. x \\<notin> F\n 5. x \\<in> carrier_vec n", "by auto"], ["proof (state)\nthis:\n  lincomb c (insert x F) = c x \\<cdot>\\<^sub>v x + lincomb c F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "also"], ["proof (state)\nthis:\n  lincomb c (insert x F) = c x \\<cdot>\\<^sub>v x + lincomb c F\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "have \"c x \\<cdot>\\<^sub>v x = vec_of_basis_enum (c' (basis_enum_of_vec x) *\\<^sub>C (basis_enum_of_vec x :: 'a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c x \\<cdot>\\<^sub>v x =\n    vec_of_basis_enum\n     (c' (basis_enum_of_vec x) *\\<^sub>C basis_enum_of_vec x)", "by (simp add: xx vec_of_basis_enum_scaleC c'_def)"], ["proof (state)\nthis:\n  c x \\<cdot>\\<^sub>v x =\n  vec_of_basis_enum (c' (basis_enum_of_vec x) *\\<^sub>C basis_enum_of_vec x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "also"], ["proof (state)\nthis:\n  c x \\<cdot>\\<^sub>v x =\n  vec_of_basis_enum (c' (basis_enum_of_vec x) *\\<^sub>C basis_enum_of_vec x)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "note IH"], ["proof (state)\nthis:\n  lincomb c F =\n  vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "also"], ["proof (state)\nthis:\n  lincomb c F =\n  vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "have\n      \"vec_of_basis_enum (c' (basis_enum_of_vec x) *\\<^sub>C (basis_enum_of_vec x :: 'a)) + ?sum\n          = vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F. c' b *\\<^sub>C b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum\n     (c' (basis_enum_of_vec x) *\\<^sub>C basis_enum_of_vec x) +\n    vec_of_basis_enum\n     (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b) =\n    vec_of_basis_enum\n     (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F. c' b *\\<^sub>C b)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum\n     (c' (basis_enum_of_vec x) *\\<^sub>C basis_enum_of_vec x) +\n    vec_of_basis_enum\n     (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b) =\n    vec_of_basis_enum\n     (\\<Sum>b\\<in>insert (basis_enum_of_vec x) (basis_enum_of_vec ` F).\n        c' b *\\<^sub>C b)", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum\n     (\\<Sum>b\\<in>insert (basis_enum_of_vec x) (basis_enum_of_vec ` F).\n        c' b *\\<^sub>C b) =\n    vec_of_basis_enum\n     (c' (basis_enum_of_vec x) *\\<^sub>C basis_enum_of_vec x) +\n    vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b)", "apply (subst sum.insert)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (basis_enum_of_vec ` F)\n 2. basis_enum_of_vec x \\<notin> basis_enum_of_vec ` F\n 3. vec_of_basis_enum\n     (c' (basis_enum_of_vec x) *\\<^sub>C basis_enum_of_vec x +\n      (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b)) =\n    vec_of_basis_enum\n     (c' (basis_enum_of_vec x) *\\<^sub>C basis_enum_of_vec x) +\n    vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b)", "using \\<open>finite F\\<close> \\<open>x \\<notin> F\\<close> dim_vec_of_basis_enum' insert.prems \n        vec_of_basis_enum_add c'_def"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  dim_vec (vec_of_basis_enum ?v) = length canonical_basis\n  insert x F \\<subseteq> vec_of_basis_enum ` X\n  vec_of_basis_enum (?b1.0 + ?b2.0) =\n  vec_of_basis_enum ?b1.0 + vec_of_basis_enum ?b2.0\n  c' ?b1 = c (vec_of_basis_enum ?b1)\n\ngoal (3 subgoals):\n 1. finite (basis_enum_of_vec ` F)\n 2. basis_enum_of_vec x \\<notin> basis_enum_of_vec ` F\n 3. vec_of_basis_enum\n     (c' (basis_enum_of_vec x) *\\<^sub>C basis_enum_of_vec x +\n      (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b)) =\n    vec_of_basis_enum\n     (c' (basis_enum_of_vec x) *\\<^sub>C basis_enum_of_vec x) +\n    vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b)", "by auto"], ["proof (state)\nthis:\n  vec_of_basis_enum\n   (c' (basis_enum_of_vec x) *\\<^sub>C basis_enum_of_vec x) +\n  vec_of_basis_enum (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b) =\n  vec_of_basis_enum\n   (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F. c' b *\\<^sub>C b)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> vec_of_basis_enum ` X \\<Longrightarrow>\n        lincomb c F =\n        vec_of_basis_enum\n         (\\<Sum>b\\<in>basis_enum_of_vec ` F. c' b *\\<^sub>C b);\n        insert x F \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n       \\<Longrightarrow> lincomb c (insert x F) =\n                         vec_of_basis_enum\n                          (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F.\n                             c' b *\\<^sub>C b)", "finally"], ["proof (chain)\npicking this:\n  lincomb c (insert x F) =\n  vec_of_basis_enum\n   (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F. c' b *\\<^sub>C b)", "show ?case"], ["proof (prove)\nusing this:\n  lincomb c (insert x F) =\n  vec_of_basis_enum\n   (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F. c' b *\\<^sub>C b)\n\ngoal (1 subgoal):\n 1. lincomb c (insert x F) =\n    vec_of_basis_enum\n     (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F. c' b *\\<^sub>C b)", "by -"], ["proof (state)\nthis:\n  lincomb c (insert x F) =\n  vec_of_basis_enum\n   (\\<Sum>b\\<in>basis_enum_of_vec ` insert x F. c' b *\\<^sub>C b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?B1 = basis_enum_of_vec ` ?A1; finite ?A1;\n   ?A1 \\<subseteq> vec_of_basis_enum ` X;\n   \\<And>b. ?c'1 b = ?c1 (vec_of_basis_enum b)\\<rbrakk>\n  \\<Longrightarrow> lincomb ?c1 ?A1 =\n                    vec_of_basis_enum (\\<Sum>b\\<in>?B1. ?c'1 b *\\<^sub>C b)\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum ` cspan X = local.span (vec_of_basis_enum ` X)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum ` cspan X = local.span (vec_of_basis_enum ` X)", "proof auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)\n 2. \\<And>x.\n       x \\<in> local.span (vec_of_basis_enum ` X) \\<Longrightarrow>\n       x \\<in> vec_of_basis_enum ` cspan X", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)\n 2. \\<And>x.\n       x \\<in> local.span (vec_of_basis_enum ` X) \\<Longrightarrow>\n       x \\<in> vec_of_basis_enum ` cspan X", "assume \"x \\<in> local.span (vec_of_basis_enum ` X)\""], ["proof (state)\nthis:\n  x \\<in> local.span (vec_of_basis_enum ` X)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)\n 2. \\<And>x.\n       x \\<in> local.span (vec_of_basis_enum ` X) \\<Longrightarrow>\n       x \\<in> vec_of_basis_enum ` cspan X", "then"], ["proof (chain)\npicking this:\n  x \\<in> local.span (vec_of_basis_enum ` X)", "obtain c A where xA: \"x = lincomb c A\" and \"finite A\" and AX: \"A \\<subseteq> vec_of_basis_enum ` X\""], ["proof (prove)\nusing this:\n  x \\<in> local.span (vec_of_basis_enum ` X)\n\ngoal (1 subgoal):\n 1. (\\<And>c A.\n        \\<lbrakk>x = lincomb c A; finite A;\n         A \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding span_def"], ["proof (prove)\nusing this:\n  x \\<in> {lincomb a A |a A.\n           finite A \\<and> A \\<subseteq> vec_of_basis_enum ` X}\n\ngoal (1 subgoal):\n 1. (\\<And>c A.\n        \\<lbrakk>x = lincomb c A; finite A;\n         A \\<subseteq> vec_of_basis_enum ` X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = lincomb c A\n  finite A\n  A \\<subseteq> vec_of_basis_enum ` X\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)\n 2. \\<And>x.\n       x \\<in> local.span (vec_of_basis_enum ` X) \\<Longrightarrow>\n       x \\<in> vec_of_basis_enum ` cspan X", "define B::\"'a set\" and c' where \"B = basis_enum_of_vec ` A\"\n      and \"c' b = c (vec_of_basis_enum b)\" for b::'a"], ["proof (state)\nthis:\n  B = basis_enum_of_vec ` A\n  c' ?b = c (vec_of_basis_enum ?b)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)\n 2. \\<And>x.\n       x \\<in> local.span (vec_of_basis_enum ` X) \\<Longrightarrow>\n       x \\<in> vec_of_basis_enum ` cspan X", "note xA"], ["proof (state)\nthis:\n  x = lincomb c A\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)\n 2. \\<And>x.\n       x \\<in> local.span (vec_of_basis_enum ` X) \\<Longrightarrow>\n       x \\<in> vec_of_basis_enum ` cspan X", "also"], ["proof (state)\nthis:\n  x = lincomb c A\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)\n 2. \\<And>x.\n       x \\<in> local.span (vec_of_basis_enum ` X) \\<Longrightarrow>\n       x \\<in> vec_of_basis_enum ` cspan X", "have \"lincomb c A = vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb c A = vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)", "using B_def \\<open>finite A\\<close> AX c'_def"], ["proof (prove)\nusing this:\n  B = basis_enum_of_vec ` A\n  finite A\n  A \\<subseteq> vec_of_basis_enum ` X\n  c' ?b = c (vec_of_basis_enum ?b)\n\ngoal (1 subgoal):\n 1. lincomb c A = vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)", "by (rule lincomb_sum)"], ["proof (state)\nthis:\n  lincomb c A = vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)\n 2. \\<And>x.\n       x \\<in> local.span (vec_of_basis_enum ` X) \\<Longrightarrow>\n       x \\<in> vec_of_basis_enum ` cspan X", "also"], ["proof (state)\nthis:\n  lincomb c A = vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)\n 2. \\<And>x.\n       x \\<in> local.span (vec_of_basis_enum ` X) \\<Longrightarrow>\n       x \\<in> vec_of_basis_enum ` cspan X", "have \"\\<dots> \\<in> vec_of_basis_enum ` cspan X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\n    \\<in> vec_of_basis_enum ` cspan X", "unfolding complex_vector.span_explicit"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\n    \\<in> vec_of_basis_enum `\n          {\\<Sum>a\\<in>t. r a *\\<^sub>C a |t r.\n           finite t \\<and> t \\<subseteq> X}", "apply (rule imageI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\n    \\<in> {\\<Sum>a\\<in>t. r a *\\<^sub>C a |t r.\n           finite t \\<and> t \\<subseteq> X}", "apply (rule CollectI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t r.\n       (\\<Sum>b\\<in>B. c' b *\\<^sub>C b) =\n       (\\<Sum>a\\<in>t. r a *\\<^sub>C a) \\<and>\n       finite t \\<and> t \\<subseteq> X", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       (\\<Sum>b\\<in>B. c' b *\\<^sub>C b) =\n       (\\<Sum>a\\<in>?t4. r a *\\<^sub>C a) \\<and>\n       finite ?t4 \\<and> ?t4 \\<subseteq> X", "apply (rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>B. c' b *\\<^sub>C b) =\n    (\\<Sum>a\\<in>?t4. ?r6 a *\\<^sub>C a) \\<and>\n    finite ?t4 \\<and> ?t4 \\<subseteq> X", "using \\<open>finite A\\<close> AX"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> vec_of_basis_enum ` X\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>B. c' b *\\<^sub>C b) =\n    (\\<Sum>a\\<in>?t4. ?r6 a *\\<^sub>C a) \\<and>\n    finite ?t4 \\<and> ?t4 \\<subseteq> X", "by (auto simp: B_def)"], ["proof (state)\nthis:\n  vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\n  \\<in> vec_of_basis_enum ` cspan X\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)\n 2. \\<And>x.\n       x \\<in> local.span (vec_of_basis_enum ` X) \\<Longrightarrow>\n       x \\<in> vec_of_basis_enum ` cspan X", "finally"], ["proof (chain)\npicking this:\n  x \\<in> vec_of_basis_enum ` cspan X", "show \"x \\<in> vec_of_basis_enum ` cspan X\""], ["proof (prove)\nusing this:\n  x \\<in> vec_of_basis_enum ` cspan X\n\ngoal (1 subgoal):\n 1. x \\<in> vec_of_basis_enum ` cspan X", "by -"], ["proof (state)\nthis:\n  x \\<in> vec_of_basis_enum ` cspan X\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)", "assume \"x \\<in> cspan X\""], ["proof (state)\nthis:\n  x \\<in> cspan X\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)", "then"], ["proof (chain)\npicking this:\n  x \\<in> cspan X", "obtain c' B where x: \"x = (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\" and \"finite B\" and BX: \"B \\<subseteq> X\""], ["proof (prove)\nusing this:\n  x \\<in> cspan X\n\ngoal (1 subgoal):\n 1. (\\<And>c' B.\n        \\<lbrakk>x = (\\<Sum>b\\<in>B. c' b *\\<^sub>C b); finite B;\n         B \\<subseteq> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding complex_vector.span_explicit"], ["proof (prove)\nusing this:\n  x \\<in> {\\<Sum>a\\<in>t. r a *\\<^sub>C a |t r.\n           finite t \\<and> t \\<subseteq> X}\n\ngoal (1 subgoal):\n 1. (\\<And>c' B.\n        \\<lbrakk>x = (\\<Sum>b\\<in>B. c' b *\\<^sub>C b); finite B;\n         B \\<subseteq> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\n  finite B\n  B \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)", "define A and c where \"A = vec_of_basis_enum ` B\"\n      and \"c b = c' (basis_enum_of_vec b)\" for b"], ["proof (state)\nthis:\n  A = vec_of_basis_enum ` B\n  c ?b = c' (basis_enum_of_vec ?b)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)", "have \"vec_of_basis_enum x = vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum x =\n    vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)", "using x"], ["proof (prove)\nusing this:\n  x = (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum x =\n    vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)", "by simp"], ["proof (state)\nthis:\n  vec_of_basis_enum x = vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)", "also"], ["proof (state)\nthis:\n  vec_of_basis_enum x = vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)", "have \"\\<dots> = lincomb c A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b) = lincomb c A", "apply (rule lincomb_sum[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. B = basis_enum_of_vec ` A\n 2. finite A\n 3. A \\<subseteq> vec_of_basis_enum ` X\n 4. \\<And>b. c' b = c (vec_of_basis_enum b)", "unfolding A_def c_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. B = basis_enum_of_vec ` vec_of_basis_enum ` B\n 2. finite (vec_of_basis_enum ` B)\n 3. vec_of_basis_enum ` B \\<subseteq> vec_of_basis_enum ` X\n 4. \\<And>b. c' b = c' (basis_enum_of_vec (vec_of_basis_enum b))", "using BX \\<open>finite B\\<close>"], ["proof (prove)\nusing this:\n  B \\<subseteq> X\n  finite B\n\ngoal (4 subgoals):\n 1. B = basis_enum_of_vec ` vec_of_basis_enum ` B\n 2. finite (vec_of_basis_enum ` B)\n 3. vec_of_basis_enum ` B \\<subseteq> vec_of_basis_enum ` X\n 4. \\<And>b. c' b = c' (basis_enum_of_vec (vec_of_basis_enum b))", "by (auto simp: image_image)"], ["proof (state)\nthis:\n  vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b) = lincomb c A\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)", "also"], ["proof (state)\nthis:\n  vec_of_basis_enum (\\<Sum>b\\<in>B. c' b *\\<^sub>C b) = lincomb c A\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)", "have \"\\<dots> \\<in> span (vec_of_basis_enum ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb c A \\<in> local.span (vec_of_basis_enum ` X)", "unfolding span_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb c A\n    \\<in> {lincomb a A |a A.\n           finite A \\<and> A \\<subseteq> vec_of_basis_enum ` X}", "apply (rule CollectI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a Aa.\n       lincomb c A = lincomb a Aa \\<and>\n       finite Aa \\<and> Aa \\<subseteq> vec_of_basis_enum ` X", "apply (rule exI, rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb c A = lincomb ?a2 ?A4 \\<and>\n    finite ?A4 \\<and> ?A4 \\<subseteq> vec_of_basis_enum ` X", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lincomb c (vec_of_basis_enum ` B) = lincomb ?a2 ?A4 \\<and>\n    finite ?A4 \\<and> ?A4 \\<subseteq> vec_of_basis_enum ` X", "using \\<open>finite B\\<close> BX"], ["proof (prove)\nusing this:\n  finite B\n  B \\<subseteq> X\n\ngoal (1 subgoal):\n 1. lincomb c (vec_of_basis_enum ` B) = lincomb ?a2 ?A4 \\<and>\n    finite ?A4 \\<and> ?A4 \\<subseteq> vec_of_basis_enum ` X", "by auto"], ["proof (state)\nthis:\n  lincomb c A \\<in> local.span (vec_of_basis_enum ` X)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> cspan X \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> local.span (vec_of_basis_enum ` X)", "finally"], ["proof (chain)\npicking this:\n  vec_of_basis_enum x \\<in> local.span (vec_of_basis_enum ` X)", "show \"vec_of_basis_enum x \\<in> local.span (vec_of_basis_enum ` X)\""], ["proof (prove)\nusing this:\n  vec_of_basis_enum x \\<in> local.span (vec_of_basis_enum ` X)\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum x \\<in> local.span (vec_of_basis_enum ` X)", "by -"], ["proof (state)\nthis:\n  vec_of_basis_enum x \\<in> local.span (vec_of_basis_enum ` X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_of_basis_enum ` cspan X = local.span (vec_of_basis_enum ` X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in complex_vec_space) basis_enum_of_vec_span:\n  assumes \"length (canonical_basis :: 'a list) = n\"\n  assumes \"Y \\<subseteq> carrier_vec n\"\n  shows \"basis_enum_of_vec ` local.span Y = cspan (basis_enum_of_vec ` Y :: 'a::basis_enum set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` local.span Y = cspan (basis_enum_of_vec ` Y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` local.span Y = cspan (basis_enum_of_vec ` Y)", "define X::\"'a set\" where \"X = basis_enum_of_vec ` Y\""], ["proof (state)\nthis:\n  X = basis_enum_of_vec ` Y\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` local.span Y = cspan (basis_enum_of_vec ` Y)", "then"], ["proof (chain)\npicking this:\n  X = basis_enum_of_vec ` Y", "have \"cspan (basis_enum_of_vec ` Y :: 'a set) = basis_enum_of_vec ` vec_of_basis_enum ` cspan X\""], ["proof (prove)\nusing this:\n  X = basis_enum_of_vec ` Y\n\ngoal (1 subgoal):\n 1. cspan (basis_enum_of_vec ` Y) =\n    basis_enum_of_vec ` vec_of_basis_enum ` cspan X", "by (simp add: image_image)"], ["proof (state)\nthis:\n  cspan (basis_enum_of_vec ` Y) =\n  basis_enum_of_vec ` vec_of_basis_enum ` cspan X\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` local.span Y = cspan (basis_enum_of_vec ` Y)", "also"], ["proof (state)\nthis:\n  cspan (basis_enum_of_vec ` Y) =\n  basis_enum_of_vec ` vec_of_basis_enum ` cspan X\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` local.span Y = cspan (basis_enum_of_vec ` Y)", "have \"\\<dots> = basis_enum_of_vec ` local.span (vec_of_basis_enum ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` vec_of_basis_enum ` cspan X =\n    basis_enum_of_vec ` local.span (vec_of_basis_enum ` X)", "apply (subst vec_of_basis_enum_cspan)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length canonical_basis = n\n 2. basis_enum_of_vec ` local.span (vec_of_basis_enum ` X) =\n    basis_enum_of_vec ` local.span (vec_of_basis_enum ` X)", "using assms"], ["proof (prove)\nusing this:\n  length canonical_basis = n\n  Y \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. length canonical_basis = n\n 2. basis_enum_of_vec ` local.span (vec_of_basis_enum ` X) =\n    basis_enum_of_vec ` local.span (vec_of_basis_enum ` X)", "by simp_all"], ["proof (state)\nthis:\n  basis_enum_of_vec ` vec_of_basis_enum ` cspan X =\n  basis_enum_of_vec ` local.span (vec_of_basis_enum ` X)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` local.span Y = cspan (basis_enum_of_vec ` Y)", "also"], ["proof (state)\nthis:\n  basis_enum_of_vec ` vec_of_basis_enum ` cspan X =\n  basis_enum_of_vec ` local.span (vec_of_basis_enum ` X)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` local.span Y = cspan (basis_enum_of_vec ` Y)", "have \"vec_of_basis_enum ` X = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum ` X = Y", "unfolding X_def image_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. vec_of_basis_enum (basis_enum_of_vec x)) ` Y = Y", "apply (rule image_cong[where g=id and M=Y and N=Y, simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Y \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec x) = x", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  length canonical_basis = n\n  Y \\<subseteq> carrier_vec n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Y \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec x) = x", "by auto"], ["proof (state)\nthis:\n  vec_of_basis_enum ` X = Y\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` local.span Y = cspan (basis_enum_of_vec ` Y)", "finally"], ["proof (chain)\npicking this:\n  cspan (basis_enum_of_vec ` Y) = basis_enum_of_vec ` local.span Y", "show ?thesis"], ["proof (prove)\nusing this:\n  cspan (basis_enum_of_vec ` Y) = basis_enum_of_vec ` local.span Y\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` local.span Y = cspan (basis_enum_of_vec ` Y)", "by simp"], ["proof (state)\nthis:\n  basis_enum_of_vec ` local.span Y = cspan (basis_enum_of_vec ` Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_of_basis_enum_canonical_basis:\n  assumes \"i < length (canonical_basis :: 'a list)\"\n  shows \"vec_of_basis_enum (canonical_basis!i :: 'a)\n       = unit_vec (length (canonical_basis :: 'a::basis_enum list)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (canonical_basis ! i) =\n    unit_vec (length canonical_basis) i", "by (metis assms basis_enum_of_vec_inverse basis_enum_of_vec_unit_vec index_unit_vec(3))"], ["", "lemma vec_of_basis_enum_times: \n  fixes \\<psi> \\<phi> :: \"'a::one_dim\"\n  shows \"vec_of_basis_enum (\\<psi> * \\<phi>)\n   = vec_of_list [vec_index (vec_of_basis_enum \\<psi>) 0 * vec_index (vec_of_basis_enum \\<phi>) 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (\\<psi> * \\<phi>) =\n    vec_of_list\n     [vec_of_basis_enum \\<psi> $ 0 * vec_of_basis_enum \\<phi> $ 0]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (\\<psi> * \\<phi>) =\n    vec_of_list\n     [vec_of_basis_enum \\<psi> $ 0 * vec_of_basis_enum \\<phi> $ 0]", "have [simp]: \\<open>crepresentation {1} x 1 = one_dim_iso x\\<close> for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. crepresentation {1::'a} x (1::'a) = one_dim_iso x", "apply (subst one_dim_scaleC_1[where x=x, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. crepresentation {1::'a} (one_dim_iso x *\\<^sub>C (1::'a)) (1::'a) =\n    one_dim_iso x", "apply (subst complex_vector.representation_scale)"], ["proof (prove)\ngoal (3 subgoals):\n 1. cindependent {1::'a}\n 2. (1::'a) \\<in> cspan {1::'a}\n 3. one_dim_iso x * crepresentation {1::'a} (1::'a) (1::'a) = one_dim_iso x", "by (auto simp add: complex_vector.span_base complex_vector.representation_basis)"], ["proof (state)\nthis:\n  crepresentation {1::'a} ?x (1::'a) = one_dim_iso ?x\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (\\<psi> * \\<phi>) =\n    vec_of_list\n     [vec_of_basis_enum \\<psi> $ 0 * vec_of_basis_enum \\<phi> $ 0]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (\\<psi> * \\<phi>) =\n    vec_of_list\n     [vec_of_basis_enum \\<psi> $ 0 * vec_of_basis_enum \\<phi> $ 0]", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (vec_of_list\n              [vec_of_basis_enum \\<psi> $ 0 *\n               vec_of_basis_enum \\<phi> $ 0]) \\<Longrightarrow>\n       vec_of_basis_enum (\\<psi> * \\<phi>) $ i =\n       vec_of_list\n        [vec_of_basis_enum \\<psi> $ 0 * vec_of_basis_enum \\<phi> $ 0] $\n       i\n 2. dim_vec (vec_of_basis_enum (\\<psi> * \\<phi>)) =\n    dim_vec\n     (vec_of_list\n       [vec_of_basis_enum \\<psi> $ 0 * vec_of_basis_enum \\<phi> $ 0])", "by (auto simp: vec_of_basis_enum_def)"], ["proof (state)\nthis:\n  vec_of_basis_enum (\\<psi> * \\<phi>) =\n  vec_of_list [vec_of_basis_enum \\<psi> $ 0 * vec_of_basis_enum \\<phi> $ 0]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_of_basis_enum_to_inverse: \n  fixes \\<psi> :: \"'a::one_dim\"\n  shows \"vec_of_basis_enum (inverse \\<psi>) = vec_of_list [inverse (vec_index (vec_of_basis_enum \\<psi>) 0)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (inverse \\<psi>) =\n    vec_of_list [inverse (vec_of_basis_enum \\<psi> $ 0)]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (inverse \\<psi>) =\n    vec_of_list [inverse (vec_of_basis_enum \\<psi> $ 0)]", "have [simp]: \\<open>crepresentation {1} x 1 = one_dim_iso x\\<close> for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. crepresentation {1::'a} x (1::'a) = one_dim_iso x", "apply (subst one_dim_scaleC_1[where x=x, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. crepresentation {1::'a} (one_dim_iso x *\\<^sub>C (1::'a)) (1::'a) =\n    one_dim_iso x", "apply (subst complex_vector.representation_scale)"], ["proof (prove)\ngoal (3 subgoals):\n 1. cindependent {1::'a}\n 2. (1::'a) \\<in> cspan {1::'a}\n 3. one_dim_iso x * crepresentation {1::'a} (1::'a) (1::'a) = one_dim_iso x", "by (auto simp add: complex_vector.span_base complex_vector.representation_basis)"], ["proof (state)\nthis:\n  crepresentation {1::'a} ?x (1::'a) = one_dim_iso ?x\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (inverse \\<psi>) =\n    vec_of_list [inverse (vec_of_basis_enum \\<psi> $ 0)]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (inverse \\<psi>) =\n    vec_of_list [inverse (vec_of_basis_enum \\<psi> $ 0)]", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (vec_of_list\n              [inverse (vec_of_basis_enum \\<psi> $ 0)]) \\<Longrightarrow>\n       vec_of_basis_enum (inverse \\<psi>) $ i =\n       vec_of_list [inverse (vec_of_basis_enum \\<psi> $ 0)] $ i\n 2. dim_vec (vec_of_basis_enum (inverse \\<psi>)) =\n    dim_vec (vec_of_list [inverse (vec_of_basis_enum \\<psi> $ 0)])", "apply (auto simp: vec_of_basis_enum_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso (inverse \\<psi>) = inverse (one_dim_iso \\<psi>)", "by (metis complex_vector.scale_cancel_right one_dim_inverse one_dim_scaleC_1 zero_neq_one)"], ["proof (state)\nthis:\n  vec_of_basis_enum (inverse \\<psi>) =\n  vec_of_list [inverse (vec_of_basis_enum \\<psi> $ 0)]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_of_basis_enum_divide: \n  fixes \\<psi> \\<phi> :: \"'a::one_dim\"\n  shows \"vec_of_basis_enum (\\<psi> / \\<phi>)\n   = vec_of_list [vec_index (vec_of_basis_enum \\<psi>) 0 / vec_index (vec_of_basis_enum \\<phi>) 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (\\<psi> / \\<phi>) =\n    vec_of_list\n     [vec_of_basis_enum \\<psi> $ 0 / vec_of_basis_enum \\<phi> $ 0]", "by (simp add: divide_inverse vec_of_basis_enum_to_inverse vec_of_basis_enum_times)"], ["", "lemma vec_of_basis_enum_1: \"vec_of_basis_enum (1 :: 'a::one_dim) = vec_of_list [1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (1::'a) = vec_of_list [1]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (1::'a) = vec_of_list [1]", "have [simp]: \\<open>crepresentation {1} x 1 = one_dim_iso x\\<close> for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. crepresentation {1::'a} x (1::'a) = one_dim_iso x", "apply (subst one_dim_scaleC_1[where x=x, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. crepresentation {1::'a} (one_dim_iso x *\\<^sub>C (1::'a)) (1::'a) =\n    one_dim_iso x", "apply (subst complex_vector.representation_scale)"], ["proof (prove)\ngoal (3 subgoals):\n 1. cindependent {1::'a}\n 2. (1::'a) \\<in> cspan {1::'a}\n 3. one_dim_iso x * crepresentation {1::'a} (1::'a) (1::'a) = one_dim_iso x", "by (auto simp add: complex_vector.span_base complex_vector.representation_basis)"], ["proof (state)\nthis:\n  crepresentation {1::'a} ?x (1::'a) = one_dim_iso ?x\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (1::'a) = vec_of_list [1]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (1::'a) = vec_of_list [1]", "apply (rule eq_vecI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (vec_of_list [1]) \\<Longrightarrow>\n       vec_of_basis_enum (1::'a) $ i = vec_of_list [1] $ i\n 2. dim_vec (vec_of_basis_enum (1::'a)) = dim_vec (vec_of_list [1])", "by (auto simp: vec_of_basis_enum_def)"], ["proof (state)\nthis:\n  vec_of_basis_enum (1::'a) = vec_of_list [1]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_of_basis_enum_ell2_component:\n  fixes \\<psi> :: \\<open>'a::enum ell2\\<close> \n  assumes [simp]: \\<open>i < CARD('a)\\<close>\n  shows \\<open>vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (Enum.enum ! i)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)", "let ?i = \\<open>Enum.enum ! i\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)", "have \\<open>Rep_ell2 \\<psi> (Enum.enum ! i) = \\<langle>ket ?i, \\<psi>\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_ell2 \\<psi> (enum_class.enum ! i) =\n    ket (enum_class.enum ! i) \\<bullet>\\<^sub>C \\<psi>", "by (simp add: cinner_ket_left)"], ["proof (state)\nthis:\n  Rep_ell2 \\<psi> (enum_class.enum ! i) =\n  ket (enum_class.enum ! i) \\<bullet>\\<^sub>C \\<psi>\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)", "also"], ["proof (state)\nthis:\n  Rep_ell2 \\<psi> (enum_class.enum ! i) =\n  ket (enum_class.enum ! i) \\<bullet>\\<^sub>C \\<psi>\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)", "have \\<open>\\<dots> = vec_of_basis_enum \\<psi> \\<bullet>c vec_of_basis_enum (ket ?i :: 'a ell2)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ket (enum_class.enum ! i) \\<bullet>\\<^sub>C \\<psi> =\n    vec_of_basis_enum \\<psi> \\<bullet>c\n    vec_of_basis_enum (ket (enum_class.enum ! i))", "by (rule cscalar_prod_vec_of_basis_enum[symmetric])"], ["proof (state)\nthis:\n  ket (enum_class.enum ! i) \\<bullet>\\<^sub>C \\<psi> =\n  vec_of_basis_enum \\<psi> \\<bullet>c\n  vec_of_basis_enum (ket (enum_class.enum ! i))\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)", "also"], ["proof (state)\nthis:\n  ket (enum_class.enum ! i) \\<bullet>\\<^sub>C \\<psi> =\n  vec_of_basis_enum \\<psi> \\<bullet>c\n  vec_of_basis_enum (ket (enum_class.enum ! i))\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)", "have \\<open>\\<dots> = vec_of_basis_enum \\<psi> \\<bullet>c unit_vec (CARD('a)) i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> \\<bullet>c\n    vec_of_basis_enum (ket (enum_class.enum ! i)) =\n    vec_of_basis_enum \\<psi> \\<bullet>c unit_vec CARD('a) i", "by (simp add: vec_of_basis_enum_ket enum_idx_enum)"], ["proof (state)\nthis:\n  vec_of_basis_enum \\<psi> \\<bullet>c\n  vec_of_basis_enum (ket (enum_class.enum ! i)) =\n  vec_of_basis_enum \\<psi> \\<bullet>c unit_vec CARD('a) i\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)", "also"], ["proof (state)\nthis:\n  vec_of_basis_enum \\<psi> \\<bullet>c\n  vec_of_basis_enum (ket (enum_class.enum ! i)) =\n  vec_of_basis_enum \\<psi> \\<bullet>c unit_vec CARD('a) i\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)", "have \\<open>\\<dots> = vec_of_basis_enum \\<psi> \\<bullet> unit_vec (CARD('a)) i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> \\<bullet>c unit_vec CARD('a) i =\n    vec_of_basis_enum \\<psi> \\<bullet> unit_vec CARD('a) i", "by (smt (verit, best) assms carrier_vecI conjugate_conjugate_sprod conjugate_id conjugate_vec_sprod_comm dim_vec_conjugate eq_vecI index_unit_vec(3) scalar_prod_left_unit vec_index_conjugate)"], ["proof (state)\nthis:\n  vec_of_basis_enum \\<psi> \\<bullet>c unit_vec CARD('a) i =\n  vec_of_basis_enum \\<psi> \\<bullet> unit_vec CARD('a) i\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)", "also"], ["proof (state)\nthis:\n  vec_of_basis_enum \\<psi> \\<bullet>c unit_vec CARD('a) i =\n  vec_of_basis_enum \\<psi> \\<bullet> unit_vec CARD('a) i\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)", "have \\<open>\\<dots> = vec_of_basis_enum \\<psi> $ i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> \\<bullet> unit_vec CARD('a) i =\n    vec_of_basis_enum \\<psi> $ i", "by simp"], ["proof (state)\nthis:\n  vec_of_basis_enum \\<psi> \\<bullet> unit_vec CARD('a) i =\n  vec_of_basis_enum \\<psi> $ i\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)", "finally"], ["proof (chain)\npicking this:\n  Rep_ell2 \\<psi> (enum_class.enum ! i) = vec_of_basis_enum \\<psi> $ i", "show ?thesis"], ["proof (prove)\nusing this:\n  Rep_ell2 \\<psi> (enum_class.enum ! i) = vec_of_basis_enum \\<psi> $ i\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)", "by simp"], ["proof (state)\nthis:\n  vec_of_basis_enum \\<psi> $ i = Rep_ell2 \\<psi> (enum_class.enum ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma corthogonal_vec_of_basis_enum:\n  fixes S :: \"'a::onb_enum list\"\n  shows \"corthogonal (map vec_of_basis_enum S) \\<longleftrightarrow> is_ortho_set (set S) \\<and> distinct S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corthogonal (map vec_of_basis_enum S) =\n    (is_ortho_set (set S) \\<and> distinct S)", "proof auto"], ["proof (state)\ngoal (3 subgoals):\n 1. corthogonal (map vec_of_basis_enum S) \\<Longrightarrow>\n    is_ortho_set (set S)\n 2. corthogonal (map vec_of_basis_enum S) \\<Longrightarrow> distinct S\n 3. \\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n    \\<Longrightarrow> corthogonal (map vec_of_basis_enum S)", "assume assm: \\<open>corthogonal (map vec_of_basis_enum S)\\<close>"], ["proof (state)\nthis:\n  corthogonal (map vec_of_basis_enum S)\n\ngoal (3 subgoals):\n 1. corthogonal (map vec_of_basis_enum S) \\<Longrightarrow>\n    is_ortho_set (set S)\n 2. corthogonal (map vec_of_basis_enum S) \\<Longrightarrow> distinct S\n 3. \\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n    \\<Longrightarrow> corthogonal (map vec_of_basis_enum S)", "then"], ["proof (chain)\npicking this:\n  corthogonal (map vec_of_basis_enum S)", "show \\<open>is_ortho_set (set S)\\<close>"], ["proof (prove)\nusing this:\n  corthogonal (map vec_of_basis_enum S)\n\ngoal (1 subgoal):\n 1. is_ortho_set (set S)", "by (smt (verit, ccfv_SIG) cinner_eq_zero_iff corthogonal_def cscalar_prod_vec_of_basis_enum in_set_conv_nth is_ortho_set_def length_map nth_map)"], ["proof (state)\nthis:\n  is_ortho_set (set S)\n\ngoal (2 subgoals):\n 1. corthogonal (map vec_of_basis_enum S) \\<Longrightarrow> distinct S\n 2. \\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n    \\<Longrightarrow> corthogonal (map vec_of_basis_enum S)", "show \\<open>distinct S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct S", "using assm corthogonal_distinct distinct_map"], ["proof (prove)\nusing this:\n  corthogonal (map vec_of_basis_enum S)\n  corthogonal ?us \\<Longrightarrow> distinct ?us\n  distinct (map ?f ?xs) = (distinct ?xs \\<and> inj_on ?f (set ?xs))\n\ngoal (1 subgoal):\n 1. distinct S", "by blast"], ["proof (state)\nthis:\n  distinct S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n    \\<Longrightarrow> corthogonal (map vec_of_basis_enum S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n    \\<Longrightarrow> corthogonal (map vec_of_basis_enum S)", "assume \\<open>is_ortho_set (set S)\\<close> and \\<open>distinct S\\<close>"], ["proof (state)\nthis:\n  is_ortho_set (set S)\n  distinct S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n    \\<Longrightarrow> corthogonal (map vec_of_basis_enum S)", "then"], ["proof (chain)\npicking this:\n  is_ortho_set (set S)\n  distinct S", "show \\<open>corthogonal (map vec_of_basis_enum S)\\<close>"], ["proof (prove)\nusing this:\n  is_ortho_set (set S)\n  distinct S\n\ngoal (1 subgoal):\n 1. corthogonal (map vec_of_basis_enum S)", "by (smt (verit, ccfv_threshold) cinner_eq_zero_iff corthogonalI cscalar_prod_vec_of_basis_enum is_ortho_set_def length_map length_map nth_eq_iff_index_eq nth_map nth_map nth_mem nth_mem)"], ["proof (state)\nthis:\n  corthogonal (map vec_of_basis_enum S)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Isomorphism between bounded linear functions and matrices\\<close>"], ["", "text \\<open>We define the canonical isomorphism between \\<^typ>\\<open>'a::basis_enum \\<Rightarrow>\\<^sub>C\\<^sub>L'b::basis_enum\\<close>\n  and the complex \\<^term>\\<open>n*m\\<close>-matrices (where n,m are the dimensions of \\<^typ>\\<open>'a\\<close>, \\<^typ>\\<open>'b\\<close>, \n  respectively). This is possible if \\<^typ>\\<open>'a\\<close>, \\<^typ>\\<open>'b\\<close> are of class \\<^class>\\<open>basis_enum\\<close>\n  since that class fixes a finite canonical basis. Matrices are represented using\n  the \\<^typ>\\<open>complex mat\\<close> type from \\<^session>\\<open>Jordan_Normal_Form\\<close>.\n  (The isomorphism will be called \\<^term>\\<open>mat_of_cblinfun\\<close> below.)\\<close>"], ["", "definition mat_of_cblinfun :: \\<open>'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L'b::{basis_enum,complex_normed_vector} \\<Rightarrow> complex mat\\<close> where\n  \\<open>mat_of_cblinfun f = \n    mat (length (canonical_basis :: 'b list)) (length (canonical_basis :: 'a list)) (\n    \\<lambda> (i, j). crepresentation (set (canonical_basis::'b list)) (f *\\<^sub>V ((canonical_basis::'a list)!j)) ((canonical_basis::'b list)!i))\\<close>\n  for f"], ["", "lift_definition cblinfun_of_mat :: \\<open>complex mat \\<Rightarrow> 'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L'b::{basis_enum,complex_normed_vector}\\<close> is  \n  \\<open>\\<lambda>M. \\<lambda>v. (if M\\<in>carrier_mat (length (canonical_basis :: 'b list)) (length (canonical_basis :: 'a list))\n           then basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum v)\n           else 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mat.\n       bounded_clinear\n        (\\<lambda>v.\n            if mat\n               \\<in> carrier_mat (length canonical_basis)\n                      (length canonical_basis)\n            then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum v)\n            else (0::'b))", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>mat b1 b2.\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum (b1 + b2))\n        else (0::'b)) =\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b1)\n        else (0::'b)) +\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b2)\n        else (0::'b))\n 2. \\<And>mat r b.\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec\n              (mat *\\<^sub>v vec_of_basis_enum (r *\\<^sub>C b))\n        else (0::'b)) =\n       r *\\<^sub>C\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b)\n        else (0::'b))\n 3. \\<And>mat.\n       \\<exists>K.\n          \\<forall>x.\n             norm\n              (if mat\n                  \\<in> carrier_mat (length canonical_basis)\n                         (length canonical_basis)\n               then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum x)\n               else (0::'b))\n             \\<le> norm x * K", "fix M :: \"complex mat\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>mat b1 b2.\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum (b1 + b2))\n        else (0::'b)) =\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b1)\n        else (0::'b)) +\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b2)\n        else (0::'b))\n 2. \\<And>mat r b.\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec\n              (mat *\\<^sub>v vec_of_basis_enum (r *\\<^sub>C b))\n        else (0::'b)) =\n       r *\\<^sub>C\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b)\n        else (0::'b))\n 3. \\<And>mat.\n       \\<exists>K.\n          \\<forall>x.\n             norm\n              (if mat\n                  \\<in> carrier_mat (length canonical_basis)\n                         (length canonical_basis)\n               then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum x)\n               else (0::'b))\n             \\<le> norm x * K", "define m where \"m = length (canonical_basis :: 'b list)\""], ["proof (state)\nthis:\n  m = length canonical_basis\n\ngoal (3 subgoals):\n 1. \\<And>mat b1 b2.\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum (b1 + b2))\n        else (0::'b)) =\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b1)\n        else (0::'b)) +\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b2)\n        else (0::'b))\n 2. \\<And>mat r b.\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec\n              (mat *\\<^sub>v vec_of_basis_enum (r *\\<^sub>C b))\n        else (0::'b)) =\n       r *\\<^sub>C\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b)\n        else (0::'b))\n 3. \\<And>mat.\n       \\<exists>K.\n          \\<forall>x.\n             norm\n              (if mat\n                  \\<in> carrier_mat (length canonical_basis)\n                         (length canonical_basis)\n               then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum x)\n               else (0::'b))\n             \\<le> norm x * K", "define n where \"n = length (canonical_basis :: 'a list)\""], ["proof (state)\nthis:\n  n = length canonical_basis\n\ngoal (3 subgoals):\n 1. \\<And>mat b1 b2.\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum (b1 + b2))\n        else (0::'b)) =\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b1)\n        else (0::'b)) +\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b2)\n        else (0::'b))\n 2. \\<And>mat r b.\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec\n              (mat *\\<^sub>v vec_of_basis_enum (r *\\<^sub>C b))\n        else (0::'b)) =\n       r *\\<^sub>C\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b)\n        else (0::'b))\n 3. \\<And>mat.\n       \\<exists>K.\n          \\<forall>x.\n             norm\n              (if mat\n                  \\<in> carrier_mat (length canonical_basis)\n                         (length canonical_basis)\n               then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum x)\n               else (0::'b))\n             \\<le> norm x * K", "define f::\"complex mat \\<Rightarrow> 'a \\<Rightarrow> 'b\" \n    where \"f M v = (if M\\<in>carrier_mat m n\n        then basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum (v::'a)) \n        else (0::'b))\" \n    for M::\"complex mat\" and v::'a"], ["proof (state)\nthis:\n  f ?M ?v =\n  (if ?M \\<in> carrier_mat m n\n   then basis_enum_of_vec (?M *\\<^sub>v vec_of_basis_enum ?v) else (0::'b))\n\ngoal (3 subgoals):\n 1. \\<And>mat b1 b2.\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum (b1 + b2))\n        else (0::'b)) =\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b1)\n        else (0::'b)) +\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b2)\n        else (0::'b))\n 2. \\<And>mat r b.\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec\n              (mat *\\<^sub>v vec_of_basis_enum (r *\\<^sub>C b))\n        else (0::'b)) =\n       r *\\<^sub>C\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b)\n        else (0::'b))\n 3. \\<And>mat.\n       \\<exists>K.\n          \\<forall>x.\n             norm\n              (if mat\n                  \\<in> carrier_mat (length canonical_basis)\n                         (length canonical_basis)\n               then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum x)\n               else (0::'b))\n             \\<le> norm x * K", "show add: \\<open>f M (b1 + b2) = f M b1 + f M b2\\<close> for b1 b2"], ["proof (prove)\ngoal (1 subgoal):\n 1. f M (b1 + b2) = f M b1 + f M b2", "apply (auto simp: f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> carrier_mat m n \\<Longrightarrow>\n    basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum (b1 + b2)) =\n    basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum b1) +\n    basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum b2)", "by (metis (mono_tags, lifting) carrier_matD(1) carrier_vec_dim_vec dim_mult_mat_vec dim_vec_of_basis_enum' m_def mult_add_distrib_mat_vec n_def basis_enum_of_vec_add vec_of_basis_enum_add)"], ["proof (state)\nthis:\n  f M (?b1.0 + ?b2.0) = f M ?b1.0 + f M ?b2.0\n\ngoal (2 subgoals):\n 1. \\<And>mat r b.\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec\n              (mat *\\<^sub>v vec_of_basis_enum (r *\\<^sub>C b))\n        else (0::'b)) =\n       r *\\<^sub>C\n       (if mat\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum b)\n        else (0::'b))\n 2. \\<And>mat.\n       \\<exists>K.\n          \\<forall>x.\n             norm\n              (if mat\n                  \\<in> carrier_mat (length canonical_basis)\n                         (length canonical_basis)\n               then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum x)\n               else (0::'b))\n             \\<le> norm x * K", "show scale: \\<open>f M (c *\\<^sub>C b) = c *\\<^sub>C f M b\\<close> for c b"], ["proof (prove)\ngoal (1 subgoal):\n 1. f M (c *\\<^sub>C b) = c *\\<^sub>C f M b", "apply (auto simp: f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> carrier_mat m n \\<Longrightarrow>\n    basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum (c *\\<^sub>C b)) =\n    c *\\<^sub>C basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum b)", "by (metis carrier_matD(1) carrier_vec_dim_vec dim_mult_mat_vec dim_vec_of_basis_enum' m_def mult_mat_vec n_def basis_enum_of_vec_mult vec_of_basis_enum_scaleC)"], ["proof (state)\nthis:\n  f M (?c *\\<^sub>C ?b) = ?c *\\<^sub>C f M ?b\n\ngoal (1 subgoal):\n 1. \\<And>mat.\n       \\<exists>K.\n          \\<forall>x.\n             norm\n              (if mat\n                  \\<in> carrier_mat (length canonical_basis)\n                         (length canonical_basis)\n               then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum x)\n               else (0::'b))\n             \\<le> norm x * K", "from add scale"], ["proof (chain)\npicking this:\n  f M (?b1.0 + ?b2.0) = f M ?b1.0 + f M ?b2.0\n  f M (?c *\\<^sub>C ?b) = ?c *\\<^sub>C f M ?b", "have \\<open>clinear (f M)\\<close>"], ["proof (prove)\nusing this:\n  f M (?b1.0 + ?b2.0) = f M ?b1.0 + f M ?b2.0\n  f M (?c *\\<^sub>C ?b) = ?c *\\<^sub>C f M ?b\n\ngoal (1 subgoal):\n 1. clinear (f M)", "by (simp add: clinear_iff)"], ["proof (state)\nthis:\n  clinear (f M)\n\ngoal (1 subgoal):\n 1. \\<And>mat.\n       \\<exists>K.\n          \\<forall>x.\n             norm\n              (if mat\n                  \\<in> carrier_mat (length canonical_basis)\n                         (length canonical_basis)\n               then basis_enum_of_vec (mat *\\<^sub>v vec_of_basis_enum x)\n               else (0::'b))\n             \\<le> norm x * K", "show \\<open>\\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K", "proof (cases \"M\\<in>carrier_mat m n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. M \\<in> carrier_mat m n \\<Longrightarrow>\n    \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K\n 2. M \\<notin> carrier_mat m n \\<Longrightarrow>\n    \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K", "case True"], ["proof (state)\nthis:\n  M \\<in> carrier_mat m n\n\ngoal (2 subgoals):\n 1. M \\<in> carrier_mat m n \\<Longrightarrow>\n    \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K\n 2. M \\<notin> carrier_mat m n \\<Longrightarrow>\n    \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K", "have f_def': \"f M v = basis_enum_of_vec (M *\\<^sub>v (vec_of_basis_enum v))\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. f M v = basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum v)", "using True f_def \n        m_def n_def"], ["proof (prove)\nusing this:\n  M \\<in> carrier_mat m n\n  f ?M ?v =\n  (if ?M \\<in> carrier_mat m n\n   then basis_enum_of_vec (?M *\\<^sub>v vec_of_basis_enum ?v) else (0::'b))\n  m = length canonical_basis\n  n = length canonical_basis\n\ngoal (1 subgoal):\n 1. f M v = basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum v)", "by auto"], ["proof (state)\nthis:\n  f M ?v = basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum ?v)\n\ngoal (2 subgoals):\n 1. M \\<in> carrier_mat m n \\<Longrightarrow>\n    \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K\n 2. M \\<notin> carrier_mat m n \\<Longrightarrow>\n    \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K", "have M_carrier_mat: \n      \"M \\<in> carrier_mat m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> carrier_mat m n", "by (simp add: True)"], ["proof (state)\nthis:\n  M \\<in> carrier_mat m n\n\ngoal (2 subgoals):\n 1. M \\<in> carrier_mat m n \\<Longrightarrow>\n    \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K\n 2. M \\<notin> carrier_mat m n \\<Longrightarrow>\n    \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K", "have \"bounded_clinear (f M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (f M)", "apply (rule bounded_clinear_finite_dim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear (f M)", "using \\<open>clinear (f M)\\<close>"], ["proof (prove)\nusing this:\n  clinear (f M)\n\ngoal (1 subgoal):\n 1. clinear (f M)", "by auto"], ["proof (state)\nthis:\n  bounded_clinear (f M)\n\ngoal (2 subgoals):\n 1. M \\<in> carrier_mat m n \\<Longrightarrow>\n    \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K\n 2. M \\<notin> carrier_mat m n \\<Longrightarrow>\n    \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K", "thus ?thesis"], ["proof (prove)\nusing this:\n  bounded_clinear (f M)\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K", "by (simp add: bounded_clinear.bounded)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K\n\ngoal (1 subgoal):\n 1. M \\<notin> carrier_mat m n \\<Longrightarrow>\n    \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<notin> carrier_mat m n \\<Longrightarrow>\n    \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K", "case False"], ["proof (state)\nthis:\n  M \\<notin> carrier_mat m n\n\ngoal (1 subgoal):\n 1. M \\<notin> carrier_mat m n \\<Longrightarrow>\n    \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K", "thus ?thesis"], ["proof (prove)\nusing this:\n  M \\<notin> carrier_mat m n\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K", "unfolding f_def m_def n_def"], ["proof (prove)\nusing this:\n  M \\<notin> carrier_mat (length canonical_basis) (length canonical_basis)\n\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>b.\n          norm\n           (if M \\<in> carrier_mat (length canonical_basis)\n                        (length canonical_basis)\n            then basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum b)\n            else (0::'b))\n          \\<le> norm b * K", "by (metis (full_types) order_refl mult_eq_0_iff norm_eq_zero)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>b. norm (f M b) \\<le> norm b * K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_of_cblinfun_ell2_carrier[simp]: \\<open>mat_of_cblinfun (a::'a::enum ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::enum ell2) \\<in> carrier_mat CARD('b) CARD('a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun a \\<in> carrier_mat CARD('b) CARD('a)", "by (simp add: mat_of_cblinfun_def)"], ["", "lemma dim_row_mat_of_cblinfun[simp]: \\<open>dim_row (mat_of_cblinfun (a::'a::enum ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::enum ell2)) = CARD('b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mat_of_cblinfun a) = CARD('b)", "by (simp add: mat_of_cblinfun_def)"], ["", "lemma dim_col_mat_of_cblinfun[simp]: \\<open>dim_col (mat_of_cblinfun (a::'a::enum ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::enum ell2)) = CARD('a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (mat_of_cblinfun a) = CARD('a)", "by (simp add: mat_of_cblinfun_def)"], ["", "lemma mat_of_cblinfun_cblinfun_apply:\n  \"vec_of_basis_enum (F *\\<^sub>V u) = mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u\"\n  for F::\"'a::{basis_enum,complex_normed_vector}  \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{basis_enum,complex_normed_vector}\" and u::'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (F *\\<^sub>V u) =\n    mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u", "proof (rule eq_vecI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i\n 2. dim_vec (vec_of_basis_enum (F *\\<^sub>V u)) =\n    dim_vec (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u)", "show \\<open>dim_vec (vec_of_basis_enum (F *\\<^sub>V u)) = dim_vec (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (vec_of_basis_enum (F *\\<^sub>V u)) =\n    dim_vec (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u)", "by (simp add: dim_vec_of_basis_enum' mat_of_cblinfun_def)"], ["proof (state)\nthis:\n  dim_vec (vec_of_basis_enum (F *\\<^sub>V u)) =\n  dim_vec (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "define BasisA where \"BasisA = (canonical_basis::'a list)\""], ["proof (state)\nthis:\n  BasisA = canonical_basis\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "define BasisB where \"BasisB = (canonical_basis::'b list)\""], ["proof (state)\nthis:\n  BasisB = canonical_basis\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "define nA where \"nA = length (canonical_basis :: 'a list)\""], ["proof (state)\nthis:\n  nA = length canonical_basis\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "define nB where \"nB = length (canonical_basis :: 'b list)\""], ["proof (state)\nthis:\n  nB = length canonical_basis\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "assume \\<open>i < dim_vec (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u)\\<close>"], ["proof (state)\nthis:\n  i < dim_vec (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "then"], ["proof (chain)\npicking this:\n  i < dim_vec (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u)", "have [simp]: \\<open>i < nB\\<close>"], ["proof (prove)\nusing this:\n  i < dim_vec (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u)\n\ngoal (1 subgoal):\n 1. i < nB", "by (simp add: mat_of_cblinfun_def nB_def)"], ["proof (state)\nthis:\n  i < nB\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "define v where \\<open>v = BasisB ! i\\<close>"], ["proof (state)\nthis:\n  v = BasisB ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "have [simp]: \\<open>dim_row (mat_of_cblinfun F) = nB\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mat_of_cblinfun F) = nB", "by (simp add: mat_of_cblinfun_def nB_def)"], ["proof (state)\nthis:\n  dim_row (mat_of_cblinfun F) = nB\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "have [simp]: \\<open>length BasisB = nB\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. length BasisB = nB", "by (simp add: nB_def BasisB_def)"], ["proof (state)\nthis:\n  length BasisB = nB\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "have [simp]: \\<open>length BasisA = nA\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. length BasisA = nA", "using BasisA_def nA_def"], ["proof (prove)\nusing this:\n  BasisA = canonical_basis\n  nA = length canonical_basis\n\ngoal (1 subgoal):\n 1. length BasisA = nA", "by auto"], ["proof (state)\nthis:\n  length BasisA = nA\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "have [simp]: \\<open>cindependent (set BasisA)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent (set BasisA)", "using BasisA_def is_cindependent_set"], ["proof (prove)\nusing this:\n  BasisA = canonical_basis\n  cindependent (set canonical_basis)\n\ngoal (1 subgoal):\n 1. cindependent (set BasisA)", "by auto"], ["proof (state)\nthis:\n  cindependent (set BasisA)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "have [simp]: \\<open>cindependent (set BasisB)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent (set BasisB)", "using BasisB_def is_cindependent_set"], ["proof (prove)\nusing this:\n  BasisB = canonical_basis\n  cindependent (set canonical_basis)\n\ngoal (1 subgoal):\n 1. cindependent (set BasisB)", "by blast"], ["proof (state)\nthis:\n  cindependent (set BasisB)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "have [simp]: \\<open>cspan (set BasisB) = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (set BasisB) = UNIV", "by (simp add: BasisB_def is_generator_set)"], ["proof (state)\nthis:\n  cspan (set BasisB) = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "have [simp]: \\<open>cspan (set BasisA) = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (set BasisA) = UNIV", "by (simp add: BasisA_def is_generator_set)"], ["proof (state)\nthis:\n  cspan (set BasisA) = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "have \\<open>(mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i = \n          (\\<Sum>j = 0..<nA. row (mat_of_cblinfun F) i $ j * crepresentation (set BasisA) u (vec_of_list BasisA $ j))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i =\n    (\\<Sum>j = 0..<nA.\n        row (mat_of_cblinfun F) i $ j *\n        crepresentation (set BasisA) u (vec_of_list BasisA $ j))", "by (auto simp: vec_of_basis_enum_def scalar_prod_def simp flip: BasisA_def)"], ["proof (state)\nthis:\n  (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i =\n  (\\<Sum>j = 0..<nA.\n      row (mat_of_cblinfun F) i $ j *\n      crepresentation (set BasisA) u (vec_of_list BasisA $ j))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "also"], ["proof (state)\nthis:\n  (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i =\n  (\\<Sum>j = 0..<nA.\n      row (mat_of_cblinfun F) i $ j *\n      crepresentation (set BasisA) u (vec_of_list BasisA $ j))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "have \\<open>\\<dots> = (\\<Sum>j = 0..<nA. crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) v\n                                 * crepresentation (set BasisA) u (BasisA ! j))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<nA.\n        row (mat_of_cblinfun F) i $ j *\n        crepresentation (set BasisA) u (vec_of_list BasisA $ j)) =\n    (\\<Sum>j = 0..<nA.\n        crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) v *\n        crepresentation (set BasisA) u (BasisA ! j))", "apply (rule sum.cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..<nA} \\<Longrightarrow>\n       row (mat_of_cblinfun F) i $ x *\n       crepresentation (set BasisA) u (vec_of_list BasisA $ x) =\n       crepresentation (set BasisB) (F *\\<^sub>V BasisA ! x) v *\n       crepresentation (set BasisA) u (BasisA ! x)", "by (auto simp: vec_of_list_index mat_of_cblinfun_def scalar_prod_def v_def simp flip: BasisA_def BasisB_def)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<nA.\n      row (mat_of_cblinfun F) i $ j *\n      crepresentation (set BasisA) u (vec_of_list BasisA $ j)) =\n  (\\<Sum>j = 0..<nA.\n      crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) v *\n      crepresentation (set BasisA) u (BasisA ! j))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<nA.\n      row (mat_of_cblinfun F) i $ j *\n      crepresentation (set BasisA) u (vec_of_list BasisA $ j)) =\n  (\\<Sum>j = 0..<nA.\n      crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) v *\n      crepresentation (set BasisA) u (BasisA ! j))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "have \\<open>\\<dots> = crepresentation (set BasisB) (F *\\<^sub>V u) v\\<close> (is \\<open>(\\<Sum>j=_..<_. ?lhs v j) = _\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<nA.\n        crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) v *\n        crepresentation (set BasisA) u (BasisA ! j)) =\n    crepresentation (set BasisB) (F *\\<^sub>V u) v", "proof (rule complex_vector.representation_eqI[symmetric, THEN fun_cong])"], ["proof (state)\ngoal (5 subgoals):\n 1. cindependent (set BasisB)\n 2. F *\\<^sub>V u \\<in> cspan (set BasisB)\n 3. \\<And>b.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n       0 \\<Longrightarrow>\n       b \\<in> set BasisB\n 4. finite\n     {b. (\\<Sum>j = 0..<nA.\n             crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n             crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n         0}\n 5. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "show \\<open>cindependent (set BasisB)\\<close> \\<open>F *\\<^sub>V u \\<in> cspan (set BasisB)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent (set BasisB) &&& F *\\<^sub>V u \\<in> cspan (set BasisB)", "by simp_all"], ["proof (state)\nthis:\n  cindependent (set BasisB)\n  F *\\<^sub>V u \\<in> cspan (set BasisB)\n\ngoal (3 subgoals):\n 1. \\<And>b.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n       0 \\<Longrightarrow>\n       b \\<in> set BasisB\n 2. finite\n     {b. (\\<Sum>j = 0..<nA.\n             crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n             crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n         0}\n 3. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "show only_basis: \\<open>(\\<Sum>j = 0..<nA. ?lhs b j) \\<noteq> 0 \\<Longrightarrow> b \\<in> set BasisB\\<close> for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<nA.\n        crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n        crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n    0 \\<Longrightarrow>\n    b \\<in> set BasisB", "by (metis (mono_tags, lifting) complex_vector.representation_ne_zero mult_not_zero sum.not_neutral_contains_not_neutral)"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<nA.\n      crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) ?b *\n      crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n  0 \\<Longrightarrow>\n  ?b \\<in> set BasisB\n\ngoal (2 subgoals):\n 1. finite\n     {b. (\\<Sum>j = 0..<nA.\n             crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n             crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n         0}\n 2. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>j = 0..<nA.\n      crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) ?b *\n      crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n  0 \\<Longrightarrow>\n  ?b \\<in> set BasisB", "show \\<open>finite {b. (\\<Sum>j = 0..<nA. ?lhs b j) \\<noteq> 0}\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>j = 0..<nA.\n      crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) ?b *\n      crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n  0 \\<Longrightarrow>\n  ?b \\<in> set BasisB\n\ngoal (1 subgoal):\n 1. finite\n     {b. (\\<Sum>j = 0..<nA.\n             crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n             crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n         0}", "by (smt (z3) List.finite_set finite_subset mem_Collect_eq subsetI)"], ["proof (state)\nthis:\n  finite\n   {b. (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n       0}\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "have \\<open>(\\<Sum>b | (\\<Sum>j = 0..<nA. ?lhs b j) \\<noteq> 0. (\\<Sum>j = 0..<nA. ?lhs b j) *\\<^sub>C b) = \n            (\\<Sum>b\\<in>set BasisB. (\\<Sum>j = 0..<nA. ?lhs b j) *\\<^sub>C b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    (\\<Sum>b\\<in>set BasisB.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b)", "apply (rule sum.mono_neutral_left)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (set BasisB)\n 2. {b. (\\<Sum>j = 0..<nA.\n            crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n            crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n        0}\n    \\<subseteq> set BasisB\n 3. \\<forall>i\\<in>set BasisB -\n                   {b. (\\<Sum>j = 0..<nA.\n                           crepresentation (set BasisB)\n                            (F *\\<^sub>V BasisA ! j) b *\n                           crepresentation (set BasisA) u\n                            (BasisA ! j)) \\<noteq>\n                       0}.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) i *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       i =\n       (0::'b)", "using only_basis"], ["proof (prove)\nusing this:\n  (\\<Sum>j = 0..<nA.\n      crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) ?b *\n      crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n  0 \\<Longrightarrow>\n  ?b \\<in> set BasisB\n\ngoal (3 subgoals):\n 1. finite (set BasisB)\n 2. {b. (\\<Sum>j = 0..<nA.\n            crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n            crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n        0}\n    \\<subseteq> set BasisB\n 3. \\<forall>i\\<in>set BasisB -\n                   {b. (\\<Sum>j = 0..<nA.\n                           crepresentation (set BasisB)\n                            (F *\\<^sub>V BasisA ! j) b *\n                           crepresentation (set BasisA) u\n                            (BasisA ! j)) \\<noteq>\n                       0}.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) i *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       i =\n       (0::'b)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                 crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                 crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n             0.\n     (\\<Sum>j = 0..<nA.\n         crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n         crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n     b) =\n  (\\<Sum>b\\<in>set BasisB.\n     (\\<Sum>j = 0..<nA.\n         crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n         crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n     b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "also"], ["proof (state)\nthis:\n  (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                 crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                 crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n             0.\n     (\\<Sum>j = 0..<nA.\n         crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n         crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n     b) =\n  (\\<Sum>b\\<in>set BasisB.\n     (\\<Sum>j = 0..<nA.\n         crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n         crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n     b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "have \\<open>\\<dots> = (\\<Sum>b\\<in>set BasisB. (\\<Sum>a\\<in>set BasisA. crepresentation (set BasisB) (F *\\<^sub>V a) b * crepresentation (set BasisA) u a) *\\<^sub>C b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>set BasisB.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    (\\<Sum>b\\<in>set BasisB.\n       (\\<Sum>a\\<in>set BasisA.\n          crepresentation (set BasisB) (F *\\<^sub>V a) b *\n          crepresentation (set BasisA) u a) *\\<^sub>C\n       b)", "apply (subst sum.reindex_bij_betw[where h=\\<open>nth BasisA\\<close> and T=\\<open>set BasisA\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. bij_betw ((!) BasisA) {0..<nA} (set BasisA)\n 2. (\\<Sum>b\\<in>set BasisB.\n       (\\<Sum>a\\<in>set BasisA.\n          crepresentation (set BasisB) (F *\\<^sub>V a) b *\n          crepresentation (set BasisA) u a) *\\<^sub>C\n       b) =\n    (\\<Sum>b\\<in>set BasisB.\n       (\\<Sum>a\\<in>set BasisA.\n          crepresentation (set BasisB) (F *\\<^sub>V a) b *\n          crepresentation (set BasisA) u a) *\\<^sub>C\n       b)", "apply (metis BasisA_def \\<open>length BasisA = nA\\<close> atLeast0LessThan bij_betw_nth distinct_canonical_basis)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>set BasisB.\n       (\\<Sum>a\\<in>set BasisA.\n          crepresentation (set BasisB) (F *\\<^sub>V a) b *\n          crepresentation (set BasisA) u a) *\\<^sub>C\n       b) =\n    (\\<Sum>b\\<in>set BasisB.\n       (\\<Sum>a\\<in>set BasisA.\n          crepresentation (set BasisB) (F *\\<^sub>V a) b *\n          crepresentation (set BasisA) u a) *\\<^sub>C\n       b)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>set BasisB.\n     (\\<Sum>j = 0..<nA.\n         crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n         crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n     b) =\n  (\\<Sum>b\\<in>set BasisB.\n     (\\<Sum>a\\<in>set BasisA.\n        crepresentation (set BasisB) (F *\\<^sub>V a) b *\n        crepresentation (set BasisA) u a) *\\<^sub>C\n     b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>set BasisB.\n     (\\<Sum>j = 0..<nA.\n         crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n         crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n     b) =\n  (\\<Sum>b\\<in>set BasisB.\n     (\\<Sum>a\\<in>set BasisA.\n        crepresentation (set BasisB) (F *\\<^sub>V a) b *\n        crepresentation (set BasisA) u a) *\\<^sub>C\n     b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "have \\<open>\\<dots> = (\\<Sum>a\\<in>set BasisA. crepresentation (set BasisA) u a *\\<^sub>C (\\<Sum>b\\<in>set BasisB. crepresentation (set BasisB) (F *\\<^sub>V a) b *\\<^sub>C b))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>set BasisB.\n       (\\<Sum>a\\<in>set BasisA.\n          crepresentation (set BasisB) (F *\\<^sub>V a) b *\n          crepresentation (set BasisA) u a) *\\<^sub>C\n       b) =\n    (\\<Sum>a\\<in>set BasisA.\n       crepresentation (set BasisA) u a *\\<^sub>C\n       (\\<Sum>b\\<in>set BasisB.\n          crepresentation (set BasisB) (F *\\<^sub>V a) b *\\<^sub>C b))", "apply (simp add: scaleC_sum_left scaleC_sum_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>set BasisB.\n       \\<Sum>a\\<in>set BasisA.\n         (crepresentation (set BasisB) (F *\\<^sub>V a) b *\n          crepresentation (set BasisA) u a) *\\<^sub>C\n         b) =\n    (\\<Sum>a\\<in>set BasisA.\n       \\<Sum>x\\<in>set BasisB.\n         (crepresentation (set BasisA) u a *\n          crepresentation (set BasisB) (F *\\<^sub>V a) x) *\\<^sub>C\n         x)", "apply (subst sum.swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>set BasisA.\n       \\<Sum>i\\<in>set BasisB.\n         (crepresentation (set BasisB) (F *\\<^sub>V j) i *\n          crepresentation (set BasisA) u j) *\\<^sub>C\n         i) =\n    (\\<Sum>a\\<in>set BasisA.\n       \\<Sum>x\\<in>set BasisB.\n         (crepresentation (set BasisA) u a *\n          crepresentation (set BasisB) (F *\\<^sub>V a) x) *\\<^sub>C\n         x)", "by (metis (no_types, lifting) mult.commute sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>set BasisB.\n     (\\<Sum>a\\<in>set BasisA.\n        crepresentation (set BasisB) (F *\\<^sub>V a) b *\n        crepresentation (set BasisA) u a) *\\<^sub>C\n     b) =\n  (\\<Sum>a\\<in>set BasisA.\n     crepresentation (set BasisA) u a *\\<^sub>C\n     (\\<Sum>b\\<in>set BasisB.\n        crepresentation (set BasisB) (F *\\<^sub>V a) b *\\<^sub>C b))\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>set BasisB.\n     (\\<Sum>a\\<in>set BasisA.\n        crepresentation (set BasisB) (F *\\<^sub>V a) b *\n        crepresentation (set BasisA) u a) *\\<^sub>C\n     b) =\n  (\\<Sum>a\\<in>set BasisA.\n     crepresentation (set BasisA) u a *\\<^sub>C\n     (\\<Sum>b\\<in>set BasisB.\n        crepresentation (set BasisB) (F *\\<^sub>V a) b *\\<^sub>C b))\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "have \\<open>\\<dots> = (\\<Sum>a\\<in>set BasisA. crepresentation (set BasisA) u a *\\<^sub>C (F *\\<^sub>V a))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>set BasisA.\n       crepresentation (set BasisA) u a *\\<^sub>C\n       (\\<Sum>b\\<in>set BasisB.\n          crepresentation (set BasisB) (F *\\<^sub>V a) b *\\<^sub>C b)) =\n    (\\<Sum>a\\<in>set BasisA.\n       crepresentation (set BasisA) u a *\\<^sub>C (F *\\<^sub>V a))", "apply (subst complex_vector.sum_representation_eq)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a. cindependent (set BasisB)\n 2. \\<And>a. F *\\<^sub>V a \\<in> cspan (set BasisB)\n 3. \\<And>a. finite (set BasisB)\n 4. \\<And>a. set BasisB \\<subseteq> set BasisB\n 5. (\\<Sum>a\\<in>set BasisA.\n       crepresentation (set BasisA) u a *\\<^sub>C (F *\\<^sub>V a)) =\n    (\\<Sum>a\\<in>set BasisA.\n       crepresentation (set BasisA) u a *\\<^sub>C (F *\\<^sub>V a))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>set BasisA.\n     crepresentation (set BasisA) u a *\\<^sub>C\n     (\\<Sum>b\\<in>set BasisB.\n        crepresentation (set BasisB) (F *\\<^sub>V a) b *\\<^sub>C b)) =\n  (\\<Sum>a\\<in>set BasisA.\n     crepresentation (set BasisA) u a *\\<^sub>C (F *\\<^sub>V a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>set BasisA.\n     crepresentation (set BasisA) u a *\\<^sub>C\n     (\\<Sum>b\\<in>set BasisB.\n        crepresentation (set BasisB) (F *\\<^sub>V a) b *\\<^sub>C b)) =\n  (\\<Sum>a\\<in>set BasisA.\n     crepresentation (set BasisA) u a *\\<^sub>C (F *\\<^sub>V a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "have \\<open>\\<dots> = F *\\<^sub>V (\\<Sum>a\\<in>set BasisA. crepresentation (set BasisA) u a *\\<^sub>C a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>set BasisA.\n       crepresentation (set BasisA) u a *\\<^sub>C (F *\\<^sub>V a)) =\n    F *\\<^sub>V\n    (\\<Sum>a\\<in>set BasisA. crepresentation (set BasisA) u a *\\<^sub>C a)", "by (simp flip: cblinfun.scaleC_right cblinfun.sum_right)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>set BasisA.\n     crepresentation (set BasisA) u a *\\<^sub>C (F *\\<^sub>V a)) =\n  F *\\<^sub>V\n  (\\<Sum>a\\<in>set BasisA. crepresentation (set BasisA) u a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>set BasisA.\n     crepresentation (set BasisA) u a *\\<^sub>C (F *\\<^sub>V a)) =\n  F *\\<^sub>V\n  (\\<Sum>a\\<in>set BasisA. crepresentation (set BasisA) u a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "have \\<open>\\<dots> = F *\\<^sub>V u\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. F *\\<^sub>V\n    (\\<Sum>a\\<in>set BasisA. crepresentation (set BasisA) u a *\\<^sub>C a) =\n    F *\\<^sub>V u", "apply (subst complex_vector.sum_representation_eq)"], ["proof (prove)\ngoal (5 subgoals):\n 1. cindependent (set BasisA)\n 2. u \\<in> cspan (set BasisA)\n 3. finite (set BasisA)\n 4. set BasisA \\<subseteq> set BasisA\n 5. F *\\<^sub>V u = F *\\<^sub>V u", "by auto"], ["proof (state)\nthis:\n  F *\\<^sub>V\n  (\\<Sum>a\\<in>set BasisA. crepresentation (set BasisA) u a *\\<^sub>C a) =\n  F *\\<^sub>V u\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                 crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                 crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n             0.\n     (\\<Sum>j = 0..<nA.\n         crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n         crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n     b) =\n  F *\\<^sub>V u", "show \\<open>(\\<Sum>b | (\\<Sum>j = 0..<nA. ?lhs b j) \\<noteq> 0. (\\<Sum>j = 0..<nA. ?lhs b j) *\\<^sub>C b) = F *\\<^sub>V u\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                 crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                 crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n             0.\n     (\\<Sum>j = 0..<nA.\n         crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n         crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n     b) =\n  F *\\<^sub>V u\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                   crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                   crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n               0.\n       (\\<Sum>j = 0..<nA.\n           crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n           crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n       b) =\n    F *\\<^sub>V u", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>b | (\\<Sum>j = 0..<nA.\n                 crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n                 crepresentation (set BasisA) u (BasisA ! j)) \\<noteq>\n             0.\n     (\\<Sum>j = 0..<nA.\n         crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) b *\n         crepresentation (set BasisA) u (BasisA ! j)) *\\<^sub>C\n     b) =\n  F *\\<^sub>V u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<nA.\n      crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) v *\n      crepresentation (set BasisA) u (BasisA ! j)) =\n  crepresentation (set BasisB) (F *\\<^sub>V u) v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<nA.\n      crepresentation (set BasisB) (F *\\<^sub>V BasisA ! j) v *\n      crepresentation (set BasisA) u (BasisA ! j)) =\n  crepresentation (set BasisB) (F *\\<^sub>V u) v\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "have \\<open>crepresentation (set BasisB) (F *\\<^sub>V u) v = vec_of_basis_enum (F *\\<^sub>V u) $ i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. crepresentation (set BasisB) (F *\\<^sub>V u) v =\n    vec_of_basis_enum (F *\\<^sub>V u) $ i", "by (auto simp: vec_of_list_index vec_of_basis_enum_def v_def simp flip: BasisB_def)"], ["proof (state)\nthis:\n  crepresentation (set BasisB) (F *\\<^sub>V u) v =\n  vec_of_basis_enum (F *\\<^sub>V u) $ i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec\n            (mat_of_cblinfun F *\\<^sub>v\n             vec_of_basis_enum u) \\<Longrightarrow>\n       vec_of_basis_enum (F *\\<^sub>V u) $ i =\n       (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "finally"], ["proof (chain)\npicking this:\n  (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i =\n  vec_of_basis_enum (F *\\<^sub>V u) $ i", "show \\<open>vec_of_basis_enum (F *\\<^sub>V u) $ i = (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i\\<close>"], ["proof (prove)\nusing this:\n  (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i =\n  vec_of_basis_enum (F *\\<^sub>V u) $ i\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (F *\\<^sub>V u) $ i =\n    (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i", "by simp"], ["proof (state)\nthis:\n  vec_of_basis_enum (F *\\<^sub>V u) $ i =\n  (mat_of_cblinfun F *\\<^sub>v vec_of_basis_enum u) $ i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma basis_enum_of_vec_cblinfun_apply:\n  fixes M :: \"complex mat\"\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)\"\n    and \"nB \\<equiv> length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list)\"\n  assumes \"M \\<in> carrier_mat nB nA\" and \"dim_vec x = nA\"\n  shows \"basis_enum_of_vec (M *\\<^sub>v x) = (cblinfun_of_mat M :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) *\\<^sub>V basis_enum_of_vec x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (M *\\<^sub>v x) =\n    cblinfun_of_mat M *\\<^sub>V basis_enum_of_vec x", "by (metis assms basis_enum_of_vec_inverse cblinfun_of_mat.rep_eq)"], ["", "lemma mat_of_cblinfun_inverse:\n  \"cblinfun_of_mat (mat_of_cblinfun B) = B\"\n  for B::\"'a::{basis_enum,complex_normed_vector}  \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{basis_enum,complex_normed_vector}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_of_mat (mat_of_cblinfun B) = B", "proof (rule cblinfun_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V i = B *\\<^sub>V i", "fix x :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V i = B *\\<^sub>V i", "define y where \\<open>y = vec_of_basis_enum x\\<close>"], ["proof (state)\nthis:\n  y = vec_of_basis_enum x\n\ngoal (1 subgoal):\n 1. \\<And>i. cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V i = B *\\<^sub>V i", "then"], ["proof (chain)\npicking this:\n  y = vec_of_basis_enum x", "have \\<open>cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V x = ((cblinfun_of_mat (mat_of_cblinfun B) :: 'a\\<Rightarrow>\\<^sub>C\\<^sub>L'b) *\\<^sub>V basis_enum_of_vec y)\\<close>"], ["proof (prove)\nusing this:\n  y = vec_of_basis_enum x\n\ngoal (1 subgoal):\n 1. cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V x =\n    cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V basis_enum_of_vec y", "by simp"], ["proof (state)\nthis:\n  cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V x =\n  cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V basis_enum_of_vec y\n\ngoal (1 subgoal):\n 1. \\<And>i. cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V i = B *\\<^sub>V i", "also"], ["proof (state)\nthis:\n  cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V x =\n  cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V basis_enum_of_vec y\n\ngoal (1 subgoal):\n 1. \\<And>i. cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V i = B *\\<^sub>V i", "have \\<open>\\<dots> = basis_enum_of_vec (mat_of_cblinfun B *\\<^sub>v vec_of_basis_enum (basis_enum_of_vec y :: 'a))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V basis_enum_of_vec y =\n    basis_enum_of_vec\n     (mat_of_cblinfun B *\\<^sub>v vec_of_basis_enum (basis_enum_of_vec y))", "apply (transfer fixing: B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (if mat_of_cblinfun B\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec\n              (mat_of_cblinfun B *\\<^sub>v\n               vec_of_basis_enum (basis_enum_of_vec y))\n        else (0::'b)) =\n       basis_enum_of_vec\n        (mat_of_cblinfun B *\\<^sub>v\n         vec_of_basis_enum (basis_enum_of_vec y))", "by (simp add: mat_of_cblinfun_def)"], ["proof (state)\nthis:\n  cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V basis_enum_of_vec y =\n  basis_enum_of_vec\n   (mat_of_cblinfun B *\\<^sub>v vec_of_basis_enum (basis_enum_of_vec y))\n\ngoal (1 subgoal):\n 1. \\<And>i. cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V i = B *\\<^sub>V i", "also"], ["proof (state)\nthis:\n  cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V basis_enum_of_vec y =\n  basis_enum_of_vec\n   (mat_of_cblinfun B *\\<^sub>v vec_of_basis_enum (basis_enum_of_vec y))\n\ngoal (1 subgoal):\n 1. \\<And>i. cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V i = B *\\<^sub>V i", "have \\<open>\\<dots> = basis_enum_of_vec (vec_of_basis_enum (B *\\<^sub>V x))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec\n     (mat_of_cblinfun B *\\<^sub>v vec_of_basis_enum (basis_enum_of_vec y)) =\n    basis_enum_of_vec (vec_of_basis_enum (B *\\<^sub>V x))", "by (simp add: mat_of_cblinfun_cblinfun_apply y_def)"], ["proof (state)\nthis:\n  basis_enum_of_vec\n   (mat_of_cblinfun B *\\<^sub>v vec_of_basis_enum (basis_enum_of_vec y)) =\n  basis_enum_of_vec (vec_of_basis_enum (B *\\<^sub>V x))\n\ngoal (1 subgoal):\n 1. \\<And>i. cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V i = B *\\<^sub>V i", "also"], ["proof (state)\nthis:\n  basis_enum_of_vec\n   (mat_of_cblinfun B *\\<^sub>v vec_of_basis_enum (basis_enum_of_vec y)) =\n  basis_enum_of_vec (vec_of_basis_enum (B *\\<^sub>V x))\n\ngoal (1 subgoal):\n 1. \\<And>i. cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V i = B *\\<^sub>V i", "have \\<open>\\<dots> = B *\\<^sub>V x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (vec_of_basis_enum (B *\\<^sub>V x)) = B *\\<^sub>V x", "by simp"], ["proof (state)\nthis:\n  basis_enum_of_vec (vec_of_basis_enum (B *\\<^sub>V x)) = B *\\<^sub>V x\n\ngoal (1 subgoal):\n 1. \\<And>i. cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V i = B *\\<^sub>V i", "finally"], ["proof (chain)\npicking this:\n  cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V x = B *\\<^sub>V x", "show \\<open>cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V x = B *\\<^sub>V x\\<close>"], ["proof (prove)\nusing this:\n  cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V x = B *\\<^sub>V x\n\ngoal (1 subgoal):\n 1. cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V x = B *\\<^sub>V x", "by -"], ["proof (state)\nthis:\n  cblinfun_of_mat (mat_of_cblinfun B) *\\<^sub>V x = B *\\<^sub>V x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_of_cblinfun_inj: \"inj mat_of_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj mat_of_cblinfun", "by (metis inj_on_def mat_of_cblinfun_inverse)"], ["", "lemma cblinfun_of_mat_inverse:\n  fixes M::\"complex mat\"\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)\"\n    and \"nB \\<equiv> length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list)\"\n  assumes \"M \\<in> carrier_mat nB nA\"\n  shows \"mat_of_cblinfun (cblinfun_of_mat M :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (cblinfun_of_mat M) = M", "by (smt (verit) assms(3) basis_enum_of_vec_inverse carrier_matD(1) carrier_vecD cblinfun_of_mat.rep_eq dim_mult_mat_vec eq_mat_on_vecI mat_carrier mat_of_cblinfun_def mat_of_cblinfun_cblinfun_apply nA_def nB_def)"], ["", "lemma cblinfun_of_mat_inj: \"inj_on (cblinfun_of_mat::complex mat \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) \n      (carrier_mat (length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list))\n                   (length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on cblinfun_of_mat\n     (carrier_mat (length canonical_basis) (length canonical_basis))", "using cblinfun_of_mat_inverse"], ["proof (prove)\nusing this:\n  ?M \\<in> carrier_mat (length canonical_basis)\n            (length canonical_basis) \\<Longrightarrow>\n  mat_of_cblinfun (cblinfun_of_mat ?M) = ?M\n\ngoal (1 subgoal):\n 1. inj_on cblinfun_of_mat\n     (carrier_mat (length canonical_basis) (length canonical_basis))", "by (metis inj_onI)"], ["", "lemma cblinfun_eq_mat_of_cblinfunI:\n  assumes \"mat_of_cblinfun a = mat_of_cblinfun b\"\n  shows \"a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b", "by (metis assms mat_of_cblinfun_inverse)"], ["", "subsection \\<open>Matrix operations\\<close>"], ["", "lemma cblinfun_of_mat_plus:\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)\" \n    and \"nB \\<equiv> length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list)\"\n  assumes [simp,intro]: \"M \\<in> carrier_mat nB nA\" and [simp,intro]: \"N \\<in> carrier_mat nB nA\"\n  shows \"(cblinfun_of_mat (M + N) :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) = ((cblinfun_of_mat M + cblinfun_of_mat N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M + N) = cblinfun_of_mat M + cblinfun_of_mat N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M + N) = cblinfun_of_mat M + cblinfun_of_mat N", "have [simp]: \\<open>vec_of_basis_enum (v :: 'a) \\<in> carrier_vec nA\\<close> for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum v \\<in> carrier_vec nA", "by (auto simp add: carrier_dim_vec dim_vec_of_basis_enum' nA_def)"], ["proof (state)\nthis:\n  vec_of_basis_enum ?v \\<in> carrier_vec nA\n\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M + N) = cblinfun_of_mat M + cblinfun_of_mat N", "have [simp]: \\<open>dim_row M = nB\\<close> \\<open>dim_row N = nB\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row M = nB &&& dim_row N = nB", "using carrier_matD(1)"], ["proof (prove)\nusing this:\n  ?A \\<in> carrier_mat ?nr ?nc \\<Longrightarrow> dim_row ?A = ?nr\n\ngoal (1 subgoal):\n 1. dim_row M = nB &&& dim_row N = nB", "by auto"], ["proof (state)\nthis:\n  dim_row M = nB\n  dim_row N = nB\n\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M + N) = cblinfun_of_mat M + cblinfun_of_mat N", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M + N) = cblinfun_of_mat M + cblinfun_of_mat N", "apply (transfer fixing: M N)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>v.\n        if M + N\n           \\<in> carrier_mat (length canonical_basis)\n                  (length canonical_basis)\n        then basis_enum_of_vec ((M + N) *\\<^sub>v vec_of_basis_enum v)\n        else (0::'b)) =\n    (\\<lambda>x.\n        (if M \\<in> carrier_mat (length canonical_basis)\n                     (length canonical_basis)\n         then basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum x)\n         else (0::'b)) +\n        (if N \\<in> carrier_mat (length canonical_basis)\n                     (length canonical_basis)\n         then basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum x)\n         else (0::'b)))", "by (auto intro!: ext simp add: add_mult_distrib_mat_vec nA_def[symmetric] nB_def[symmetric]\n        add_mult_distrib_mat_vec[where nr=nB and nc=nA] basis_enum_of_vec_add)"], ["proof (state)\nthis:\n  cblinfun_of_mat (M + N) = cblinfun_of_mat M + cblinfun_of_mat N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_of_cblinfun_zero:\n  \"mat_of_cblinfun (0 :: ('a::{basis_enum,complex_normed_vector}  \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{basis_enum,complex_normed_vector})) \n  = 0\\<^sub>m (length (canonical_basis :: 'b list)) (length (canonical_basis :: 'a list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun 0 =\n    0\\<^sub>m (length canonical_basis) (length canonical_basis)", "unfolding mat_of_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length canonical_basis) (length canonical_basis)\n     (\\<lambda>(i, j).\n         crepresentation (set canonical_basis)\n          (0 *\\<^sub>V canonical_basis ! j) (canonical_basis ! i)) =\n    0\\<^sub>m (length canonical_basis) (length canonical_basis)", "by (auto simp: complex_vector.representation_zero)"], ["", "lemma mat_of_cblinfun_plus:\n  \"mat_of_cblinfun (F + G) = mat_of_cblinfun F + mat_of_cblinfun G\"\n  for F G::\"'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L'b::{basis_enum,complex_normed_vector}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (F + G) = mat_of_cblinfun F + mat_of_cblinfun G", "by (auto simp add: mat_of_cblinfun_def cblinfun.add_left complex_vector.representation_add)"], ["", "lemma mat_of_cblinfun_id:\n  \"mat_of_cblinfun (id_cblinfun :: ('a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L'a)) = 1\\<^sub>m (length (canonical_basis :: 'a list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun id_cblinfun = 1\\<^sub>m (length canonical_basis)", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m (length canonical_basis));\n        j < dim_col (1\\<^sub>m (length canonical_basis))\\<rbrakk>\n       \\<Longrightarrow> mat_of_cblinfun id_cblinfun $$ (i, j) =\n                         1\\<^sub>m (length canonical_basis) $$ (i, j)\n 2. dim_row (mat_of_cblinfun id_cblinfun) =\n    dim_row (1\\<^sub>m (length canonical_basis))\n 3. dim_col (mat_of_cblinfun id_cblinfun) =\n    dim_col (1\\<^sub>m (length canonical_basis))", "by (auto simp: mat_of_cblinfun_def complex_vector.representation_basis is_cindependent_set nth_eq_iff_index_eq)"], ["", "lemma mat_of_cblinfun_1:\n  \"mat_of_cblinfun (1 :: ('a::one_dim \\<Rightarrow>\\<^sub>C\\<^sub>L'b::one_dim)) = 1\\<^sub>m 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun 1 = 1\\<^sub>m 1", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (1\\<^sub>m 1);\n        j < dim_col (1\\<^sub>m 1)\\<rbrakk>\n       \\<Longrightarrow> mat_of_cblinfun 1 $$ (i, j) = 1\\<^sub>m 1 $$ (i, j)\n 2. dim_row (mat_of_cblinfun 1) = dim_row (1\\<^sub>m 1)\n 3. dim_col (mat_of_cblinfun 1) = dim_col (1\\<^sub>m 1)", "by (auto simp: mat_of_cblinfun_def complex_vector.representation_basis nth_eq_iff_index_eq)"], ["", "lemma mat_of_cblinfun_uminus:\n  \"mat_of_cblinfun (- M) = - mat_of_cblinfun M\" \n  for M::\"'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L'b::{basis_enum,complex_normed_vector}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (- M) = - mat_of_cblinfun M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (- M) = - mat_of_cblinfun M", "define nA where \"nA = length (canonical_basis :: 'a list)\""], ["proof (state)\nthis:\n  nA = length canonical_basis\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (- M) = - mat_of_cblinfun M", "define nB where \"nB = length (canonical_basis :: 'b list)\""], ["proof (state)\nthis:\n  nB = length canonical_basis\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (- M) = - mat_of_cblinfun M", "have M1: \"mat_of_cblinfun M \\<in> carrier_mat nB nA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun M \\<in> carrier_mat nB nA", "unfolding nB_def nA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun M\n    \\<in> carrier_mat (length canonical_basis) (length canonical_basis)", "by (metis add.right_neutral add_carrier_mat mat_of_cblinfun_plus mat_of_cblinfun_zero nA_def\n        nB_def zero_carrier_mat)"], ["proof (state)\nthis:\n  mat_of_cblinfun M \\<in> carrier_mat nB nA\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (- M) = - mat_of_cblinfun M", "have M2: \"mat_of_cblinfun (-M) \\<in> carrier_mat nB nA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (- M) \\<in> carrier_mat nB nA", "by (metis add_carrier_mat mat_of_cblinfun_plus mat_of_cblinfun_zero diff_0 nA_def nB_def \n        uminus_add_conv_diff zero_carrier_mat)"], ["proof (state)\nthis:\n  mat_of_cblinfun (- M) \\<in> carrier_mat nB nA\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (- M) = - mat_of_cblinfun M", "have \"mat_of_cblinfun (M - M) =  0\\<^sub>m nB nA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (M - M) = 0\\<^sub>m nB nA", "unfolding nA_def nB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (M - M) =\n    0\\<^sub>m (length canonical_basis) (length canonical_basis)", "by (simp add: mat_of_cblinfun_zero)"], ["proof (state)\nthis:\n  mat_of_cblinfun (M - M) = 0\\<^sub>m nB nA\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (- M) = - mat_of_cblinfun M", "moreover"], ["proof (state)\nthis:\n  mat_of_cblinfun (M - M) = 0\\<^sub>m nB nA\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (- M) = - mat_of_cblinfun M", "have \"mat_of_cblinfun (M - M) = mat_of_cblinfun M + mat_of_cblinfun (- M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (M - M) = mat_of_cblinfun M + mat_of_cblinfun (- M)", "by (metis mat_of_cblinfun_plus pth_2)"], ["proof (state)\nthis:\n  mat_of_cblinfun (M - M) = mat_of_cblinfun M + mat_of_cblinfun (- M)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (- M) = - mat_of_cblinfun M", "ultimately"], ["proof (chain)\npicking this:\n  mat_of_cblinfun (M - M) = 0\\<^sub>m nB nA\n  mat_of_cblinfun (M - M) = mat_of_cblinfun M + mat_of_cblinfun (- M)", "have \"mat_of_cblinfun M + mat_of_cblinfun (- M) = 0\\<^sub>m nB nA\""], ["proof (prove)\nusing this:\n  mat_of_cblinfun (M - M) = 0\\<^sub>m nB nA\n  mat_of_cblinfun (M - M) = mat_of_cblinfun M + mat_of_cblinfun (- M)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun M + mat_of_cblinfun (- M) = 0\\<^sub>m nB nA", "by simp"], ["proof (state)\nthis:\n  mat_of_cblinfun M + mat_of_cblinfun (- M) = 0\\<^sub>m nB nA\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (- M) = - mat_of_cblinfun M", "thus ?thesis"], ["proof (prove)\nusing this:\n  mat_of_cblinfun M + mat_of_cblinfun (- M) = 0\\<^sub>m nB nA\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (- M) = - mat_of_cblinfun M", "using M1 M2"], ["proof (prove)\nusing this:\n  mat_of_cblinfun M + mat_of_cblinfun (- M) = 0\\<^sub>m nB nA\n  mat_of_cblinfun M \\<in> carrier_mat nB nA\n  mat_of_cblinfun (- M) \\<in> carrier_mat nB nA\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (- M) = - mat_of_cblinfun M", "by (smt add_uminus_minus_mat assoc_add_mat comm_add_mat left_add_zero_mat minus_r_inv_mat \n        uminus_carrier_mat)"], ["proof (state)\nthis:\n  mat_of_cblinfun (- M) = - mat_of_cblinfun M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_of_cblinfun_minus:\n  \"mat_of_cblinfun (M - N) = mat_of_cblinfun M - mat_of_cblinfun N\" \n  for M::\"'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{basis_enum,complex_normed_vector}\" and N::\"'a \\<Rightarrow>\\<^sub>C\\<^sub>L'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (M - N) = mat_of_cblinfun M - mat_of_cblinfun N", "by (smt (z3) add_uminus_minus_mat mat_of_cblinfun_uminus mat_carrier mat_of_cblinfun_def mat_of_cblinfun_plus pth_2)"], ["", "lemma cblinfun_of_mat_uminus:\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)\" \n    and \"nB \\<equiv> length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list)\"\n  assumes \"M \\<in> carrier_mat nB nA\"\n  shows \"(cblinfun_of_mat (-M) :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) = - cblinfun_of_mat M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_of_mat (- M) = - cblinfun_of_mat M", "by (smt assms add.group_axioms add.right_neutral add_minus_cancel add_uminus_minus_mat \n      cblinfun_of_mat_plus group.inverse_inverse mat_of_cblinfun_inverse mat_of_cblinfun_zero \n      minus_r_inv_mat uminus_carrier_mat)"], ["", "lemma cblinfun_of_mat_minus:\n  fixes M::\"complex mat\"\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)\" \n    and \"nB \\<equiv> length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list)\"\n  assumes \"M \\<in> carrier_mat nB nA\" and \"N \\<in> carrier_mat nB nA\"\n  shows \"(cblinfun_of_mat (M - N) :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) = cblinfun_of_mat M - cblinfun_of_mat N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M - N) = cblinfun_of_mat M - cblinfun_of_mat N", "by (metis assms add_uminus_minus_mat cblinfun_of_mat_plus cblinfun_of_mat_uminus pth_2 uminus_carrier_mat)"], ["", "lemma cblinfun_of_mat_times:\n  fixes M N ::\"complex mat\"\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::{basis_enum,complex_normed_vector} list)\" \n    and \"nB \\<equiv> length (canonical_basis :: 'b::{basis_enum,complex_normed_vector} list)\"\n    and \"nC \\<equiv> length (canonical_basis :: 'c::{basis_enum,complex_normed_vector} list)\"\n  assumes a1: \"M \\<in> carrier_mat nC nB\" and a2: \"N \\<in> carrier_mat nB nA\"\n  shows  \"cblinfun_of_mat (M * N) = ((cblinfun_of_mat M)::'b \\<Rightarrow>\\<^sub>C\\<^sub>L'c) o\\<^sub>C\\<^sub>L ((cblinfun_of_mat N)::'a \\<Rightarrow>\\<^sub>C\\<^sub>L'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M * N) =\n    cblinfun_of_mat M o\\<^sub>C\\<^sub>L cblinfun_of_mat N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M * N) =\n    cblinfun_of_mat M o\\<^sub>C\\<^sub>L cblinfun_of_mat N", "have b1: \"((cblinfun_of_mat M)::'b \\<Rightarrow>\\<^sub>C\\<^sub>L'c) v = basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum v)\"\n    for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_of_mat M *\\<^sub>V v =\n    basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum v)", "by (metis assms(4) cblinfun_of_mat.rep_eq nB_def nC_def)"], ["proof (state)\nthis:\n  cblinfun_of_mat M *\\<^sub>V ?v =\n  basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum ?v)\n\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M * N) =\n    cblinfun_of_mat M o\\<^sub>C\\<^sub>L cblinfun_of_mat N", "have b2: \"((cblinfun_of_mat N)::'a \\<Rightarrow>\\<^sub>C\\<^sub>L'b) v = basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)\"\n    for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_of_mat N *\\<^sub>V v =\n    basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)", "by (metis assms(5) cblinfun_of_mat.rep_eq nA_def nB_def)"], ["proof (state)\nthis:\n  cblinfun_of_mat N *\\<^sub>V ?v =\n  basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum ?v)\n\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M * N) =\n    cblinfun_of_mat M o\\<^sub>C\\<^sub>L cblinfun_of_mat N", "have b3: \"((cblinfun_of_mat (M * N))::'a \\<Rightarrow>\\<^sub>C\\<^sub>L'c) v\n       = basis_enum_of_vec ((M * N) *\\<^sub>v vec_of_basis_enum v)\"\n    for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M * N) *\\<^sub>V v =\n    basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v)", "by (metis assms(4) assms(5) cblinfun_of_mat.rep_eq mult_carrier_mat nA_def nC_def)"], ["proof (state)\nthis:\n  cblinfun_of_mat (M * N) *\\<^sub>V ?v =\n  basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum ?v)\n\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M * N) =\n    cblinfun_of_mat M o\\<^sub>C\\<^sub>L cblinfun_of_mat N", "have \"(basis_enum_of_vec ((M * N) *\\<^sub>v vec_of_basis_enum v)::'c)\n      = (basis_enum_of_vec (M *\\<^sub>v ( vec_of_basis_enum ( (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v))::'b ))))\"\n    for v::'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n    basis_enum_of_vec\n     (M *\\<^sub>v\n      vec_of_basis_enum\n       (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n    basis_enum_of_vec\n     (M *\\<^sub>v\n      vec_of_basis_enum\n       (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))", "have c1: \"vec_of_basis_enum (basis_enum_of_vec x :: 'b) = x\"\n      if \"dim_vec x = nB\"\n      for x::\"complex vec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (basis_enum_of_vec x) = x", "using that"], ["proof (prove)\nusing this:\n  dim_vec x = nB\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (basis_enum_of_vec x) = x", "unfolding nB_def"], ["proof (prove)\nusing this:\n  dim_vec x = length canonical_basis\n\ngoal (1 subgoal):\n 1. vec_of_basis_enum (basis_enum_of_vec x) = x", "by simp"], ["proof (state)\nthis:\n  dim_vec ?x = nB \\<Longrightarrow>\n  vec_of_basis_enum (basis_enum_of_vec ?x) = ?x\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n    basis_enum_of_vec\n     (M *\\<^sub>v\n      vec_of_basis_enum\n       (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))", "have c2: \"vec_of_basis_enum v \\<in> carrier_vec nA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum v \\<in> carrier_vec nA", "by (metis (mono_tags, hide_lams) add.commute carrier_vec_dim_vec index_add_vec(2) \n          index_zero_vec(2) nA_def vec_of_basis_enum_add basis_enum_of_vec_inverse)"], ["proof (state)\nthis:\n  vec_of_basis_enum v \\<in> carrier_vec nA\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n    basis_enum_of_vec\n     (M *\\<^sub>v\n      vec_of_basis_enum\n       (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))", "have \"(M * N) *\\<^sub>v vec_of_basis_enum v = M *\\<^sub>v (N *\\<^sub>v vec_of_basis_enum v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M * N *\\<^sub>v vec_of_basis_enum v =\n    M *\\<^sub>v (N *\\<^sub>v vec_of_basis_enum v)", "using Matrix.assoc_mult_mat_vec a1 a2 c2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> carrier_mat ?n\\<^sub>1 ?n\\<^sub>2;\n   ?B \\<in> carrier_mat ?n\\<^sub>2 ?n\\<^sub>3;\n   ?v \\<in> carrier_vec ?n\\<^sub>3\\<rbrakk>\n  \\<Longrightarrow> ?A * ?B *\\<^sub>v ?v = ?A *\\<^sub>v (?B *\\<^sub>v ?v)\n  M \\<in> carrier_mat nC nB\n  N \\<in> carrier_mat nB nA\n  vec_of_basis_enum v \\<in> carrier_vec nA\n\ngoal (1 subgoal):\n 1. M * N *\\<^sub>v vec_of_basis_enum v =\n    M *\\<^sub>v (N *\\<^sub>v vec_of_basis_enum v)", "by blast"], ["proof (state)\nthis:\n  M * N *\\<^sub>v vec_of_basis_enum v =\n  M *\\<^sub>v (N *\\<^sub>v vec_of_basis_enum v)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n    basis_enum_of_vec\n     (M *\\<^sub>v\n      vec_of_basis_enum\n       (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))", "hence \"(basis_enum_of_vec ((M * N) *\\<^sub>v vec_of_basis_enum v)::'c)\n        = (basis_enum_of_vec (M *\\<^sub>v (N *\\<^sub>v vec_of_basis_enum v))::'c)\""], ["proof (prove)\nusing this:\n  M * N *\\<^sub>v vec_of_basis_enum v =\n  M *\\<^sub>v (N *\\<^sub>v vec_of_basis_enum v)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n    basis_enum_of_vec (M *\\<^sub>v (N *\\<^sub>v vec_of_basis_enum v))", "by simp"], ["proof (state)\nthis:\n  basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n  basis_enum_of_vec (M *\\<^sub>v (N *\\<^sub>v vec_of_basis_enum v))\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n    basis_enum_of_vec\n     (M *\\<^sub>v\n      vec_of_basis_enum\n       (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))", "also"], ["proof (state)\nthis:\n  basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n  basis_enum_of_vec (M *\\<^sub>v (N *\\<^sub>v vec_of_basis_enum v))\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n    basis_enum_of_vec\n     (M *\\<^sub>v\n      vec_of_basis_enum\n       (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))", "have \"\\<dots> = \n      (basis_enum_of_vec (M *\\<^sub>v ( vec_of_basis_enum ( (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v))::'b ))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (M *\\<^sub>v (N *\\<^sub>v vec_of_basis_enum v)) =\n    basis_enum_of_vec\n     (M *\\<^sub>v\n      vec_of_basis_enum\n       (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))", "using c1 a2"], ["proof (prove)\nusing this:\n  dim_vec ?x = nB \\<Longrightarrow>\n  vec_of_basis_enum (basis_enum_of_vec ?x) = ?x\n  N \\<in> carrier_mat nB nA\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (M *\\<^sub>v (N *\\<^sub>v vec_of_basis_enum v)) =\n    basis_enum_of_vec\n     (M *\\<^sub>v\n      vec_of_basis_enum\n       (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))", "by auto"], ["proof (state)\nthis:\n  basis_enum_of_vec (M *\\<^sub>v (N *\\<^sub>v vec_of_basis_enum v)) =\n  basis_enum_of_vec\n   (M *\\<^sub>v\n    vec_of_basis_enum (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n    basis_enum_of_vec\n     (M *\\<^sub>v\n      vec_of_basis_enum\n       (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))", "finally"], ["proof (chain)\npicking this:\n  basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n  basis_enum_of_vec\n   (M *\\<^sub>v\n    vec_of_basis_enum (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))", "show ?thesis"], ["proof (prove)\nusing this:\n  basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n  basis_enum_of_vec\n   (M *\\<^sub>v\n    vec_of_basis_enum (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n    basis_enum_of_vec\n     (M *\\<^sub>v\n      vec_of_basis_enum\n       (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))", "by simp"], ["proof (state)\nthis:\n  basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum v) =\n  basis_enum_of_vec\n   (M *\\<^sub>v\n    vec_of_basis_enum (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum v)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum ?v) =\n  basis_enum_of_vec\n   (M *\\<^sub>v\n    vec_of_basis_enum\n     (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum ?v)))\n\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M * N) =\n    cblinfun_of_mat M o\\<^sub>C\\<^sub>L cblinfun_of_mat N", "thus ?thesis"], ["proof (prove)\nusing this:\n  basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum ?v) =\n  basis_enum_of_vec\n   (M *\\<^sub>v\n    vec_of_basis_enum\n     (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum ?v)))\n\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M * N) =\n    cblinfun_of_mat M o\\<^sub>C\\<^sub>L cblinfun_of_mat N", "using b1 b2 b3"], ["proof (prove)\nusing this:\n  basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum ?v) =\n  basis_enum_of_vec\n   (M *\\<^sub>v\n    vec_of_basis_enum\n     (basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum ?v)))\n  cblinfun_of_mat M *\\<^sub>V ?v =\n  basis_enum_of_vec (M *\\<^sub>v vec_of_basis_enum ?v)\n  cblinfun_of_mat N *\\<^sub>V ?v =\n  basis_enum_of_vec (N *\\<^sub>v vec_of_basis_enum ?v)\n  cblinfun_of_mat (M * N) *\\<^sub>V ?v =\n  basis_enum_of_vec (M * N *\\<^sub>v vec_of_basis_enum ?v)\n\ngoal (1 subgoal):\n 1. cblinfun_of_mat (M * N) =\n    cblinfun_of_mat M o\\<^sub>C\\<^sub>L cblinfun_of_mat N", "by (simp add: cblinfun_eqI scaleC_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  cblinfun_of_mat (M * N) =\n  cblinfun_of_mat M o\\<^sub>C\\<^sub>L cblinfun_of_mat N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_of_mat_adjoint:\n  defines \"nA \\<equiv> length (canonical_basis :: 'a::onb_enum list)\"\n    and \"nB \\<equiv> length (canonical_basis :: 'b::onb_enum list)\" \n  fixes M:: \"complex mat\"\n  assumes \"M \\<in> carrier_mat nB nA\"\n  shows \"((cblinfun_of_mat (mat_adjoint M)) :: 'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'a) = (cblinfun_of_mat M)*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_of_mat (mat_adjoint M) = cblinfun_of_mat M*", "proof (rule adjoint_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n       x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)", "show \"\\<langle>cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x, y\\<rangle> =\n           \\<langle>x, cblinfun_of_mat M *\\<^sub>V y\\<rangle>\"\n    for x::'b and y::'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)", "define u where \"u = vec_of_basis_enum x\""], ["proof (state)\nthis:\n  u = vec_of_basis_enum x\n\ngoal (1 subgoal):\n 1. (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)", "define v where \"v = vec_of_basis_enum y\""], ["proof (state)\nthis:\n  v = vec_of_basis_enum y\n\ngoal (1 subgoal):\n 1. (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)", "have c1: \"vec_of_basis_enum ((cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x)::'a) = (mat_adjoint M) *\\<^sub>v u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) =\n    mat_adjoint M *\\<^sub>v u", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) =\n    mat_adjoint M *\\<^sub>v vec_of_basis_enum x", "by (metis (mono_tags, lifting) assms(3) cblinfun_of_mat_inverse map_carrier_mat mat_adjoint_def' mat_of_cblinfun_cblinfun_apply nA_def nB_def transpose_carrier_mat)"], ["proof (state)\nthis:\n  vec_of_basis_enum (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) =\n  mat_adjoint M *\\<^sub>v u\n\ngoal (1 subgoal):\n 1. (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)", "have c2: \"(vec_of_basis_enum ((cblinfun_of_mat M *\\<^sub>V y)::'b))\n        = M *\\<^sub>v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (cblinfun_of_mat M *\\<^sub>V y) = M *\\<^sub>v v", "by (metis assms(3) cblinfun_of_mat_inverse mat_of_cblinfun_cblinfun_apply nA_def nB_def v_def)"], ["proof (state)\nthis:\n  vec_of_basis_enum (cblinfun_of_mat M *\\<^sub>V y) = M *\\<^sub>v v\n\ngoal (1 subgoal):\n 1. (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)", "have c3: \"dim_vec v = nA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec v = nA", "unfolding v_def nA_def vec_of_basis_enum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list\n       (map (crepresentation (set canonical_basis) y) canonical_basis)) =\n    length canonical_basis", "by (simp add:)"], ["proof (state)\nthis:\n  dim_vec v = nA\n\ngoal (1 subgoal):\n 1. (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)", "have c4: \"dim_vec u = nB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec u = nB", "unfolding u_def nB_def vec_of_basis_enum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (vec_of_list\n       (map (crepresentation (set canonical_basis) x) canonical_basis)) =\n    length canonical_basis", "by (simp add:)"], ["proof (state)\nthis:\n  dim_vec u = nB\n\ngoal (1 subgoal):\n 1. (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)", "have \"v \\<bullet>c ((mat_adjoint M) *\\<^sub>v u) = (M *\\<^sub>v v) \\<bullet>c u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<bullet>c (mat_adjoint M *\\<^sub>v u) = (M *\\<^sub>v v) \\<bullet>c u", "using c3 c4 cscalar_prod_adjoint assms(3)"], ["proof (prove)\nusing this:\n  dim_vec v = nA\n  dim_vec u = nB\n  \\<lbrakk>?M \\<in> carrier_mat ?nB ?nA; dim_vec ?v = ?nA;\n   dim_vec ?u = ?nB\\<rbrakk>\n  \\<Longrightarrow> ?v \\<bullet>c (mat_adjoint ?M *\\<^sub>v ?u) =\n                    (?M *\\<^sub>v ?v) \\<bullet>c ?u\n  M \\<in> carrier_mat nB nA\n\ngoal (1 subgoal):\n 1. v \\<bullet>c (mat_adjoint M *\\<^sub>v u) = (M *\\<^sub>v v) \\<bullet>c u", "by blast"], ["proof (state)\nthis:\n  v \\<bullet>c (mat_adjoint M *\\<^sub>v u) = (M *\\<^sub>v v) \\<bullet>c u\n\ngoal (1 subgoal):\n 1. (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)", "hence \"v \\<bullet>c (vec_of_basis_enum ((cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x)::'a))\n        = (vec_of_basis_enum ((cblinfun_of_mat M *\\<^sub>V y)::'b)) \\<bullet>c u\""], ["proof (prove)\nusing this:\n  v \\<bullet>c (mat_adjoint M *\\<^sub>v u) = (M *\\<^sub>v v) \\<bullet>c u\n\ngoal (1 subgoal):\n 1. v \\<bullet>c\n    vec_of_basis_enum (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) =\n    vec_of_basis_enum (cblinfun_of_mat M *\\<^sub>V y) \\<bullet>c u", "using c1 c2"], ["proof (prove)\nusing this:\n  v \\<bullet>c (mat_adjoint M *\\<^sub>v u) = (M *\\<^sub>v v) \\<bullet>c u\n  vec_of_basis_enum (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) =\n  mat_adjoint M *\\<^sub>v u\n  vec_of_basis_enum (cblinfun_of_mat M *\\<^sub>V y) = M *\\<^sub>v v\n\ngoal (1 subgoal):\n 1. v \\<bullet>c\n    vec_of_basis_enum (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) =\n    vec_of_basis_enum (cblinfun_of_mat M *\\<^sub>V y) \\<bullet>c u", "by simp"], ["proof (state)\nthis:\n  v \\<bullet>c\n  vec_of_basis_enum (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) =\n  vec_of_basis_enum (cblinfun_of_mat M *\\<^sub>V y) \\<bullet>c u\n\ngoal (1 subgoal):\n 1. (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)", "thus \"\\<langle>cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x, y\\<rangle> =\n          \\<langle>x, cblinfun_of_mat M *\\<^sub>V y\\<rangle>\""], ["proof (prove)\nusing this:\n  v \\<bullet>c\n  vec_of_basis_enum (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) =\n  vec_of_basis_enum (cblinfun_of_mat M *\\<^sub>V y) \\<bullet>c u\n\ngoal (1 subgoal):\n 1. (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)", "unfolding u_def v_def"], ["proof (prove)\nusing this:\n  vec_of_basis_enum y \\<bullet>c\n  vec_of_basis_enum (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) =\n  vec_of_basis_enum (cblinfun_of_mat M *\\<^sub>V y) \\<bullet>c\n  vec_of_basis_enum x\n\ngoal (1 subgoal):\n 1. (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)", "by (simp add: cscalar_prod_vec_of_basis_enum)"], ["proof (state)\nthis:\n  (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n  x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (cblinfun_of_mat (mat_adjoint M) *\\<^sub>V ?x) \\<bullet>\\<^sub>C ?y =\n  ?x \\<bullet>\\<^sub>C (cblinfun_of_mat M *\\<^sub>V ?y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_of_cblinfun_classical_operator:\n  fixes f::\"'a::enum \\<Rightarrow> 'b::enum option\"\n  shows \"mat_of_cblinfun (classical_operator f) = mat (CARD('b)) (CARD('a))\n           (\\<lambda>(r,c). if f (Enum.enum!c) = Some (Enum.enum!r) then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "define nA where \"nA = CARD('a)\""], ["proof (state)\nthis:\n  nA = CARD('a)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "define nB where \"nB = CARD('b)\""], ["proof (state)\nthis:\n  nB = CARD('b)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "define BasisA where \"BasisA = (canonical_basis::'a ell2 list)\""], ["proof (state)\nthis:\n  BasisA = canonical_basis\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "define BasisB where \"BasisB = (canonical_basis::'b ell2 list)\""], ["proof (state)\nthis:\n  BasisB = canonical_basis\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "have \"mat_of_cblinfun (classical_operator f) \\<in> carrier_mat nB nA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) \\<in> carrier_mat nB nA", "unfolding nA_def nB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f)\n    \\<in> carrier_mat CARD('b) CARD('a)", "by simp"], ["proof (state)\nthis:\n  mat_of_cblinfun (classical_operator f) \\<in> carrier_mat nB nA\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "moreover"], ["proof (state)\nthis:\n  mat_of_cblinfun (classical_operator f) \\<in> carrier_mat nB nA\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "have \"nA = CARD ('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nA = CARD('a)", "unfolding nA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a) = CARD('a)", "by (simp add:)"], ["proof (state)\nthis:\n  nA = CARD('a)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "moreover"], ["proof (state)\nthis:\n  nA = CARD('a)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "have \"nB = CARD ('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nB = CARD('b)", "unfolding nB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('b) = CARD('b)", "by (simp add:)"], ["proof (state)\nthis:\n  nB = CARD('b)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "ultimately"], ["proof (chain)\npicking this:\n  mat_of_cblinfun (classical_operator f) \\<in> carrier_mat nB nA\n  nA = CARD('a)\n  nB = CARD('b)", "have \"mat_of_cblinfun (classical_operator f) \\<in> carrier_mat (CARD('b)) (CARD('a))\""], ["proof (prove)\nusing this:\n  mat_of_cblinfun (classical_operator f) \\<in> carrier_mat nB nA\n  nA = CARD('a)\n  nB = CARD('b)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f)\n    \\<in> carrier_mat CARD('b) CARD('a)", "unfolding nA_def nB_def"], ["proof (prove)\nusing this:\n  mat_of_cblinfun (classical_operator f) \\<in> carrier_mat CARD('b) CARD('a)\n  CARD('a) = CARD('a)\n  CARD('b) = CARD('b)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f)\n    \\<in> carrier_mat CARD('b) CARD('a)", "by simp"], ["proof (state)\nthis:\n  mat_of_cblinfun (classical_operator f) \\<in> carrier_mat CARD('b) CARD('a)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "moreover"], ["proof (state)\nthis:\n  mat_of_cblinfun (classical_operator f) \\<in> carrier_mat CARD('b) CARD('a)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "have \"(mat_of_cblinfun (classical_operator f))$$(r,c) \n  = (mat (CARD('b)) (CARD('a))\n    (\\<lambda>(r,c). if f (Enum.enum!c) = Some (Enum.enum!r) then 1 else 0))$$(r,c)\"\n    if a1: \"r < CARD('b)\" and a2: \"c < CARD('a)\"\n    for r c"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "have \"CARD('a) = length (enum_class.enum::'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a) = length enum_class.enum", "using card_UNIV_length_enum[where 'a = 'a]"], ["proof (prove)\nusing this:\n  CARD('a) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. CARD('a) = length enum_class.enum", "."], ["proof (state)\nthis:\n  CARD('a) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "hence x1: \"BasisA!c = ket ((Enum.enum::'a list)!c)\""], ["proof (prove)\nusing this:\n  CARD('a) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. BasisA ! c = ket (enum_class.enum ! c)", "unfolding BasisA_def"], ["proof (prove)\nusing this:\n  CARD('a) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. canonical_basis ! c = ket (enum_class.enum ! c)", "using a2 canonical_basis_ell2_def \n        nth_map[where n = c and xs = \"Enum.enum::'a list\" and f = ket]"], ["proof (prove)\nusing this:\n  CARD('a) = length enum_class.enum\n  c < CARD('a)\n  canonical_basis = map ket enum_class.enum\n  c < length enum_class.enum \\<Longrightarrow>\n  map ket enum_class.enum ! c = ket (enum_class.enum ! c)\n\ngoal (1 subgoal):\n 1. canonical_basis ! c = ket (enum_class.enum ! c)", "by metis"], ["proof (state)\nthis:\n  BasisA ! c = ket (enum_class.enum ! c)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "have cardb: \"CARD('b) = length (enum_class.enum::'b list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('b) = length enum_class.enum", "using card_UNIV_length_enum[where 'a = 'b]"], ["proof (prove)\nusing this:\n  CARD('b) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. CARD('b) = length enum_class.enum", "."], ["proof (state)\nthis:\n  CARD('b) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "hence x2: \"BasisB!r = ket ((Enum.enum::'b list)!r)\""], ["proof (prove)\nusing this:\n  CARD('b) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. BasisB ! r = ket (enum_class.enum ! r)", "unfolding BasisB_def"], ["proof (prove)\nusing this:\n  CARD('b) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. canonical_basis ! r = ket (enum_class.enum ! r)", "using a1 canonical_basis_ell2_def \n        nth_map[where n = r and xs = \"Enum.enum::'b list\" and f = ket]"], ["proof (prove)\nusing this:\n  CARD('b) = length enum_class.enum\n  r < CARD('b)\n  canonical_basis = map ket enum_class.enum\n  r < length enum_class.enum \\<Longrightarrow>\n  map ket enum_class.enum ! r = ket (enum_class.enum ! r)\n\ngoal (1 subgoal):\n 1. canonical_basis ! r = ket (enum_class.enum ! r)", "by metis"], ["proof (state)\nthis:\n  BasisB ! r = ket (enum_class.enum ! r)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "have \"inj (map (ket::'b \\<Rightarrow>_))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (map ket)", "by (meson injI ket_injective list.inj_map)"], ["proof (state)\nthis:\n  inj (map ket)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "hence \"length (Enum.enum::'b list) = length (map (ket::'b \\<Rightarrow>_) (Enum.enum::'b list))\""], ["proof (prove)\nusing this:\n  inj (map ket)\n\ngoal (1 subgoal):\n 1. length enum_class.enum = length (map ket enum_class.enum)", "by simp"], ["proof (state)\nthis:\n  length enum_class.enum = length (map ket enum_class.enum)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "hence lengthBasisB: \"CARD('b) = length BasisB\""], ["proof (prove)\nusing this:\n  length enum_class.enum = length (map ket enum_class.enum)\n\ngoal (1 subgoal):\n 1. CARD('b) = length BasisB", "unfolding BasisB_def canonical_basis_ell2_def"], ["proof (prove)\nusing this:\n  length enum_class.enum = length (map ket enum_class.enum)\n\ngoal (1 subgoal):\n 1. CARD('b) = length (map ket enum_class.enum)", "using cardb"], ["proof (prove)\nusing this:\n  length enum_class.enum = length (map ket enum_class.enum)\n  CARD('b) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. CARD('b) = length (map ket enum_class.enum)", "by smt"], ["proof (state)\nthis:\n  CARD('b) = length BasisB\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "have v1: \"(mat_of_cblinfun (classical_operator f))$$(r,c) = 0\"\n      if c1: \"f (Enum.enum!c) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "have \"(classical_operator f) *\\<^sub>V ket (Enum.enum!c) \n          = (case f (Enum.enum!c) of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n    (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n     | Some i \\<Rightarrow> ket i)", "using classical_operator_ket_finite"], ["proof (prove)\nusing this:\n  classical_operator ?\\<pi> *\\<^sub>V ket ?x =\n  (case ?\\<pi> ?x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)\n\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n    (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n     | Some i \\<Rightarrow> ket i)", "."], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n  (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n   | Some i \\<Rightarrow> ket i)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "also"], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n  (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n   | Some i \\<Rightarrow> ket i)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n     | Some i \\<Rightarrow> ket i) =\n    0", "using c1"], ["proof (prove)\nusing this:\n  f (enum_class.enum ! c) = None\n\ngoal (1 subgoal):\n 1. (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n     | Some i \\<Rightarrow> ket i) =\n    0", "by simp"], ["proof (state)\nthis:\n  (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n   | Some i \\<Rightarrow> ket i) =\n  0\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "finally"], ["proof (chain)\npicking this:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) = 0", "have \"(classical_operator f) *\\<^sub>V ket (Enum.enum!c) = 0\""], ["proof (prove)\nusing this:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) = 0\n\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V ket (enum_class.enum ! c) = 0", "."], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) = 0\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "hence *: \"(classical_operator f) *\\<^sub>V BasisA!c = 0\""], ["proof (prove)\nusing this:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) = 0\n\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V BasisA ! c = 0", "using x1"], ["proof (prove)\nusing this:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) = 0\n  BasisA ! c = ket (enum_class.enum ! c)\n\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V BasisA ! c = 0", "by simp"], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V BasisA ! c = 0\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "hence \"\\<langle>BasisB!r, (classical_operator f) *\\<^sub>V BasisA!c\\<rangle> = 0\""], ["proof (prove)\nusing this:\n  classical_operator f *\\<^sub>V BasisA ! c = 0\n\ngoal (1 subgoal):\n 1. is_orthogonal (BasisB ! r) (classical_operator f *\\<^sub>V BasisA ! c)", "by simp"], ["proof (state)\nthis:\n  is_orthogonal (BasisB ! r) (classical_operator f *\\<^sub>V BasisA ! c)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_orthogonal (BasisB ! r) (classical_operator f *\\<^sub>V BasisA ! c)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "unfolding mat_of_cblinfun_def BasisA_def BasisB_def"], ["proof (prove)\nusing this:\n  is_orthogonal (canonical_basis ! r)\n   (classical_operator f *\\<^sub>V canonical_basis ! c)\n\ngoal (1 subgoal):\n 1. mat (length canonical_basis) (length canonical_basis)\n     (\\<lambda>(i, j).\n         crepresentation (set canonical_basis)\n          (classical_operator f *\\<^sub>V canonical_basis ! j)\n          (canonical_basis ! i)) $$\n    (r, c) =\n    0", "by (smt (verit, del_insts) BasisA_def * a1 a2 canonical_basis_length_ell2 complex_vector.representation_zero index_mat(1) old.prod.case)"], ["proof (state)\nthis:\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (enum_class.enum ! c) = None \\<Longrightarrow>\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "have v2: \"(mat_of_cblinfun (classical_operator f))$$(r,c) = 0\"\n      if c1: \"f (Enum.enum!c) = Some (Enum.enum!r')\" and c2: \"r\\<noteq>r'\" \n        and c3: \"r' < CARD('b)\"\n      for r'"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "have x3: \"BasisB!r' = ket ((Enum.enum::'b list)!r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BasisB ! r' = ket (enum_class.enum ! r')", "unfolding BasisB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. canonical_basis ! r' = ket (enum_class.enum ! r')", "using cardb c3 canonical_basis_ell2_def \n          nth_map[where n = r' and xs = \"Enum.enum::'b list\" and f = ket]"], ["proof (prove)\nusing this:\n  CARD('b) = length enum_class.enum\n  r' < CARD('b)\n  canonical_basis = map ket enum_class.enum\n  r' < length enum_class.enum \\<Longrightarrow>\n  map ket enum_class.enum ! r' = ket (enum_class.enum ! r')\n\ngoal (1 subgoal):\n 1. canonical_basis ! r' = ket (enum_class.enum ! r')", "by smt"], ["proof (state)\nthis:\n  BasisB ! r' = ket (enum_class.enum ! r')\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "have \"distinct BasisB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct BasisB", "unfolding BasisB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct canonical_basis", "by simp"], ["proof (state)\nthis:\n  distinct BasisB\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "moreover"], ["proof (state)\nthis:\n  distinct BasisB\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "have \"r < length BasisB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < length BasisB", "using a1 lengthBasisB"], ["proof (prove)\nusing this:\n  r < CARD('b)\n  CARD('b) = length BasisB\n\ngoal (1 subgoal):\n 1. r < length BasisB", "by simp"], ["proof (state)\nthis:\n  r < length BasisB\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "moreover"], ["proof (state)\nthis:\n  r < length BasisB\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "have \"r' < length BasisB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r' < length BasisB", "using c3 lengthBasisB"], ["proof (prove)\nusing this:\n  r' < CARD('b)\n  CARD('b) = length BasisB\n\ngoal (1 subgoal):\n 1. r' < length BasisB", "by simp"], ["proof (state)\nthis:\n  r' < length BasisB\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "ultimately"], ["proof (chain)\npicking this:\n  distinct BasisB\n  r < length BasisB\n  r' < length BasisB", "have h1: \"BasisB!r \\<noteq> BasisB!r'\""], ["proof (prove)\nusing this:\n  distinct BasisB\n  r < length BasisB\n  r' < length BasisB\n\ngoal (1 subgoal):\n 1. BasisB ! r \\<noteq> BasisB ! r'", "using nth_eq_iff_index_eq[where xs = BasisB and i = r and j = r'] c2"], ["proof (prove)\nusing this:\n  distinct BasisB\n  r < length BasisB\n  r' < length BasisB\n  \\<lbrakk>distinct BasisB; r < length BasisB; r' < length BasisB\\<rbrakk>\n  \\<Longrightarrow> (BasisB ! r = BasisB ! r') = (r = r')\n  r \\<noteq> r'\n\ngoal (1 subgoal):\n 1. BasisB ! r \\<noteq> BasisB ! r'", "by blast"], ["proof (state)\nthis:\n  BasisB ! r \\<noteq> BasisB ! r'\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "have \"(classical_operator f) *\\<^sub>V ket (Enum.enum!c) \n          = (case f (Enum.enum!c) of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n    (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n     | Some i \\<Rightarrow> ket i)", "using classical_operator_ket_finite"], ["proof (prove)\nusing this:\n  classical_operator ?\\<pi> *\\<^sub>V ket ?x =\n  (case ?\\<pi> ?x of None \\<Rightarrow> 0 | Some i \\<Rightarrow> ket i)\n\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n    (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n     | Some i \\<Rightarrow> ket i)", "."], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n  (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n   | Some i \\<Rightarrow> ket i)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "also"], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n  (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n   | Some i \\<Rightarrow> ket i)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "have \"\\<dots> = ket (Enum.enum!r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n     | Some i \\<Rightarrow> ket i) =\n    ket (enum_class.enum ! r')", "using c1"], ["proof (prove)\nusing this:\n  f (enum_class.enum ! c) = Some (enum_class.enum ! r')\n\ngoal (1 subgoal):\n 1. (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n     | Some i \\<Rightarrow> ket i) =\n    ket (enum_class.enum ! r')", "by simp"], ["proof (state)\nthis:\n  (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n   | Some i \\<Rightarrow> ket i) =\n  ket (enum_class.enum ! r')\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "finally"], ["proof (chain)\npicking this:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n  ket (enum_class.enum ! r')", "have \"(classical_operator f) *\\<^sub>V ket (Enum.enum!c) = ket (Enum.enum!r')\""], ["proof (prove)\nusing this:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n  ket (enum_class.enum ! r')\n\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n    ket (enum_class.enum ! r')", "."], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n  ket (enum_class.enum ! r')\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "hence *: \"(classical_operator f) *\\<^sub>V BasisA!c = BasisB!r'\""], ["proof (prove)\nusing this:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n  ket (enum_class.enum ! r')\n\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V BasisA ! c = BasisB ! r'", "using x1 x3"], ["proof (prove)\nusing this:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n  ket (enum_class.enum ! r')\n  BasisA ! c = ket (enum_class.enum ! c)\n  BasisB ! r' = ket (enum_class.enum ! r')\n\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V BasisA ! c = BasisB ! r'", "by simp"], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V BasisA ! c = BasisB ! r'\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "moreover"], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V BasisA ! c = BasisB ! r'\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "have \"\\<langle>BasisB!r, BasisB!r'\\<rangle> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal (BasisB ! r) (BasisB ! r')", "using h1"], ["proof (prove)\nusing this:\n  BasisB ! r \\<noteq> BasisB ! r'\n\ngoal (1 subgoal):\n 1. is_orthogonal (BasisB ! r) (BasisB ! r')", "using BasisB_def \\<open>r < length BasisB\\<close> \\<open>r' < length BasisB\\<close> is_ortho_set_def is_orthonormal nth_mem"], ["proof (prove)\nusing this:\n  BasisB ! r \\<noteq> BasisB ! r'\n  BasisB = canonical_basis\n  r < length BasisB\n  r' < length BasisB\n  is_ortho_set ?S =\n  ((\\<forall>x\\<in>?S.\n       \\<forall>y\\<in>?S.\n          x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n   (0::?'a) \\<notin> ?S)\n  is_ortho_set (set canonical_basis)\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. is_orthogonal (BasisB ! r) (BasisB ! r')", "by metis"], ["proof (state)\nthis:\n  is_orthogonal (BasisB ! r) (BasisB ! r')\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "ultimately"], ["proof (chain)\npicking this:\n  classical_operator f *\\<^sub>V BasisA ! c = BasisB ! r'\n  is_orthogonal (BasisB ! r) (BasisB ! r')", "have \"\\<langle>BasisB!r, (classical_operator f) *\\<^sub>V BasisA!c\\<rangle> = 0\""], ["proof (prove)\nusing this:\n  classical_operator f *\\<^sub>V BasisA ! c = BasisB ! r'\n  is_orthogonal (BasisB ! r) (BasisB ! r')\n\ngoal (1 subgoal):\n 1. is_orthogonal (BasisB ! r) (classical_operator f *\\<^sub>V BasisA ! c)", "by simp"], ["proof (state)\nthis:\n  is_orthogonal (BasisB ! r) (classical_operator f *\\<^sub>V BasisA ! c)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_orthogonal (BasisB ! r) (classical_operator f *\\<^sub>V BasisA ! c)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "unfolding mat_of_cblinfun_def BasisA_def BasisB_def"], ["proof (prove)\nusing this:\n  is_orthogonal (canonical_basis ! r)\n   (classical_operator f *\\<^sub>V canonical_basis ! c)\n\ngoal (1 subgoal):\n 1. mat (length canonical_basis) (length canonical_basis)\n     (\\<lambda>(i, j).\n         crepresentation (set canonical_basis)\n          (classical_operator f *\\<^sub>V canonical_basis ! j)\n          (canonical_basis ! i)) $$\n    (r, c) =\n    0", "by (smt (z3) BasisA_def BasisB_def * \\<open>r < length BasisB\\<close> \\<open>r' < length BasisB\\<close> a2 canonical_basis_length_ell2 case_prod_conv complex_vector.representation_basis h1 index_mat(1) is_cindependent_set nth_mem)"], ["proof (state)\nthis:\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>f (enum_class.enum ! c) = Some (enum_class.enum ! ?r');\n   r \\<noteq> ?r'; ?r' < CARD('b)\\<rbrakk>\n  \\<Longrightarrow> mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "have \"(mat_of_cblinfun (classical_operator f))$$(r,c) = 0\"\n      if b1: \"f (Enum.enum!c) \\<noteq> Some (Enum.enum!r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "proof (cases \"f (Enum.enum!c) = None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f (enum_class.enum ! c) = None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n 2. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "case True"], ["proof (state)\nthis:\n  f (enum_class.enum ! c) = None\n\ngoal (2 subgoals):\n 1. f (enum_class.enum ! c) = None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n 2. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  f (enum_class.enum ! c) = None\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "using v1"], ["proof (prove)\nusing this:\n  f (enum_class.enum ! c) = None\n  f (enum_class.enum ! c) = None \\<Longrightarrow>\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "by blast"], ["proof (state)\nthis:\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "case False"], ["proof (state)\nthis:\n  f (enum_class.enum ! c) \\<noteq> None\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "hence \"\\<exists>R. f (Enum.enum!c) = Some R\""], ["proof (prove)\nusing this:\n  f (enum_class.enum ! c) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>R. f (enum_class.enum ! c) = Some R", "apply (induction \"f (Enum.enum!c)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>None = f (enum_class.enum ! c);\n     f (enum_class.enum ! c) \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>R. f (enum_class.enum ! c) = Some R\n 2. \\<And>option.\n       \\<lbrakk>Some option = f (enum_class.enum ! c);\n        f (enum_class.enum ! c) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R. f (enum_class.enum ! c) = Some R", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>option.\n       \\<lbrakk>Some option = f (enum_class.enum ! c);\n        f (enum_class.enum ! c) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R. f (enum_class.enum ! c) = Some R", "by simp"], ["proof (state)\nthis:\n  \\<exists>R. f (enum_class.enum ! c) = Some R\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>R. f (enum_class.enum ! c) = Some R", "obtain R where R0: \"f (Enum.enum!c) = Some R\""], ["proof (prove)\nusing this:\n  \\<exists>R. f (enum_class.enum ! c) = Some R\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        f (enum_class.enum ! c) = Some R \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f (enum_class.enum ! c) = Some R\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "have \"R \\<in> set (Enum.enum::'b list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<in> set enum_class.enum", "using UNIV_enum"], ["proof (prove)\nusing this:\n  UNIV = set enum_class.enum\n\ngoal (1 subgoal):\n 1. R \\<in> set enum_class.enum", "by blast"], ["proof (state)\nthis:\n  R \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "hence \"\\<exists>r'. R = (Enum.enum::'b list)!r' \\<and> r' < length (Enum.enum::'b list)\""], ["proof (prove)\nusing this:\n  R \\<in> set enum_class.enum\n\ngoal (1 subgoal):\n 1. \\<exists>r'. R = enum_class.enum ! r' \\<and> r' < length enum_class.enum", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  \\<exists>r'. R = enum_class.enum ! r' \\<and> r' < length enum_class.enum\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>r'. R = enum_class.enum ! r' \\<and> r' < length enum_class.enum", "obtain r' where u1: \"R = (Enum.enum::'b list)!r'\" \n        and u2: \"r' < length (Enum.enum::'b list)\""], ["proof (prove)\nusing this:\n  \\<exists>r'. R = enum_class.enum ! r' \\<and> r' < length enum_class.enum\n\ngoal (1 subgoal):\n 1. (\\<And>r'.\n        \\<lbrakk>R = enum_class.enum ! r';\n         r' < length enum_class.enum\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  R = enum_class.enum ! r'\n  r' < length enum_class.enum\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "have R1: \"f (Enum.enum!c) = Some (Enum.enum!r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) = Some (enum_class.enum ! r')", "using R0 u1"], ["proof (prove)\nusing this:\n  f (enum_class.enum ! c) = Some R\n  R = enum_class.enum ! r'\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) = Some (enum_class.enum ! r')", "by blast"], ["proof (state)\nthis:\n  f (enum_class.enum ! c) = Some (enum_class.enum ! r')\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "have \"Some ((Enum.enum::'b list)!r') \\<noteq> Some ((Enum.enum::'b list)!r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some (enum_class.enum ! r') \\<noteq> Some (enum_class.enum ! r)", "proof(rule classical)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Some (enum_class.enum ! r') \\<noteq>\n           Some (enum_class.enum ! r) \\<Longrightarrow>\n    Some (enum_class.enum ! r') \\<noteq> Some (enum_class.enum ! r)", "assume \"\\<not>(Some ((Enum.enum::'b list)!r') \\<noteq> Some ((Enum.enum::'b list)!r))\""], ["proof (state)\nthis:\n  \\<not> Some (enum_class.enum ! r') \\<noteq> Some (enum_class.enum ! r)\n\ngoal (1 subgoal):\n 1. \\<not> Some (enum_class.enum ! r') \\<noteq>\n           Some (enum_class.enum ! r) \\<Longrightarrow>\n    Some (enum_class.enum ! r') \\<noteq> Some (enum_class.enum ! r)", "hence \"Some ((Enum.enum::'b list)!r') = Some ((Enum.enum::'b list)!r)\""], ["proof (prove)\nusing this:\n  \\<not> Some (enum_class.enum ! r') \\<noteq> Some (enum_class.enum ! r)\n\ngoal (1 subgoal):\n 1. Some (enum_class.enum ! r') = Some (enum_class.enum ! r)", "by blast"], ["proof (state)\nthis:\n  Some (enum_class.enum ! r') = Some (enum_class.enum ! r)\n\ngoal (1 subgoal):\n 1. \\<not> Some (enum_class.enum ! r') \\<noteq>\n           Some (enum_class.enum ! r) \\<Longrightarrow>\n    Some (enum_class.enum ! r') \\<noteq> Some (enum_class.enum ! r)", "hence \"f (Enum.enum!c) = Some ((Enum.enum::'b list)!r)\""], ["proof (prove)\nusing this:\n  Some (enum_class.enum ! r') = Some (enum_class.enum ! r)\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) = Some (enum_class.enum ! r)", "using R1"], ["proof (prove)\nusing this:\n  Some (enum_class.enum ! r') = Some (enum_class.enum ! r)\n  f (enum_class.enum ! c) = Some (enum_class.enum ! r')\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) = Some (enum_class.enum ! r)", "by auto"], ["proof (state)\nthis:\n  f (enum_class.enum ! c) = Some (enum_class.enum ! r)\n\ngoal (1 subgoal):\n 1. \\<not> Some (enum_class.enum ! r') \\<noteq>\n           Some (enum_class.enum ! r) \\<Longrightarrow>\n    Some (enum_class.enum ! r') \\<noteq> Some (enum_class.enum ! r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f (enum_class.enum ! c) = Some (enum_class.enum ! r)\n\ngoal (1 subgoal):\n 1. Some (enum_class.enum ! r') \\<noteq> Some (enum_class.enum ! r)", "using b1"], ["proof (prove)\nusing this:\n  f (enum_class.enum ! c) = Some (enum_class.enum ! r)\n  f (enum_class.enum ! c) \\<noteq> Some (enum_class.enum ! r)\n\ngoal (1 subgoal):\n 1. Some (enum_class.enum ! r') \\<noteq> Some (enum_class.enum ! r)", "by blast"], ["proof (state)\nthis:\n  Some (enum_class.enum ! r') \\<noteq> Some (enum_class.enum ! r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Some (enum_class.enum ! r') \\<noteq> Some (enum_class.enum ! r)\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "hence \"((Enum.enum::'b list)!r') \\<noteq> ((Enum.enum::'b list)!r)\""], ["proof (prove)\nusing this:\n  Some (enum_class.enum ! r') \\<noteq> Some (enum_class.enum ! r)\n\ngoal (1 subgoal):\n 1. enum_class.enum ! r' \\<noteq> enum_class.enum ! r", "by simp"], ["proof (state)\nthis:\n  enum_class.enum ! r' \\<noteq> enum_class.enum ! r\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "hence \"r' \\<noteq> r\""], ["proof (prove)\nusing this:\n  enum_class.enum ! r' \\<noteq> enum_class.enum ! r\n\ngoal (1 subgoal):\n 1. r' \\<noteq> r", "by blast"], ["proof (state)\nthis:\n  r' \\<noteq> r\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "moreover"], ["proof (state)\nthis:\n  r' \\<noteq> r\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "have \"r' < CARD('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r' < CARD('b)", "using u2 cardb"], ["proof (prove)\nusing this:\n  r' < length enum_class.enum\n  CARD('b) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. r' < CARD('b)", "by simp"], ["proof (state)\nthis:\n  r' < CARD('b)\n\ngoal (1 subgoal):\n 1. f (enum_class.enum ! c) \\<noteq> None \\<Longrightarrow>\n    mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "ultimately"], ["proof (chain)\npicking this:\n  r' \\<noteq> r\n  r' < CARD('b)", "show ?thesis"], ["proof (prove)\nusing this:\n  r' \\<noteq> r\n  r' < CARD('b)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "using R1 v2[where r' = r']"], ["proof (prove)\nusing this:\n  r' \\<noteq> r\n  r' < CARD('b)\n  f (enum_class.enum ! c) = Some (enum_class.enum ! r')\n  \\<lbrakk>f (enum_class.enum ! c) = Some (enum_class.enum ! r');\n   r \\<noteq> r'; r' < CARD('b)\\<rbrakk>\n  \\<Longrightarrow> mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 0", "by blast"], ["proof (state)\nthis:\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (enum_class.enum ! c) \\<noteq>\n  Some (enum_class.enum ! r) \\<Longrightarrow>\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "moreover"], ["proof (state)\nthis:\n  f (enum_class.enum ! c) \\<noteq>\n  Some (enum_class.enum ! r) \\<Longrightarrow>\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "have \"(mat_of_cblinfun (classical_operator f))$$(r,c) = 1\"\n      if b1: \"f (Enum.enum!c) = Some (Enum.enum!r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "have \"CARD('b) = length (enum_class.enum::'b list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('b) = length enum_class.enum", "using card_UNIV_length_enum[where 'a = 'b]"], ["proof (prove)\nusing this:\n  CARD('b) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. CARD('b) = length enum_class.enum", "."], ["proof (state)\nthis:\n  CARD('b) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "hence \"length (map (ket::'b\\<Rightarrow>_) enum_class.enum) = CARD('b)\""], ["proof (prove)\nusing this:\n  CARD('b) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. length (map ket enum_class.enum) = CARD('b)", "by simp"], ["proof (state)\nthis:\n  length (map ket enum_class.enum) = CARD('b)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "hence w0: \"map (ket::'b\\<Rightarrow>_) enum_class.enum ! r = ket (enum_class.enum ! r)\""], ["proof (prove)\nusing this:\n  length (map ket enum_class.enum) = CARD('b)\n\ngoal (1 subgoal):\n 1. map ket enum_class.enum ! r = ket (enum_class.enum ! r)", "by (simp add: a1)"], ["proof (state)\nthis:\n  map ket enum_class.enum ! r = ket (enum_class.enum ! r)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "have \"CARD('a) = length (enum_class.enum::'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('a) = length enum_class.enum", "using card_UNIV_length_enum[where 'a = 'a]"], ["proof (prove)\nusing this:\n  CARD('a) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. CARD('a) = length enum_class.enum", "."], ["proof (state)\nthis:\n  CARD('a) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "hence \"length (map (ket::'a\\<Rightarrow>_) enum_class.enum) = CARD('a)\""], ["proof (prove)\nusing this:\n  CARD('a) = length enum_class.enum\n\ngoal (1 subgoal):\n 1. length (map ket enum_class.enum) = CARD('a)", "by simp"], ["proof (state)\nthis:\n  length (map ket enum_class.enum) = CARD('a)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "hence \"map (ket::'a\\<Rightarrow>_) enum_class.enum ! c = ket (enum_class.enum ! c)\""], ["proof (prove)\nusing this:\n  length (map ket enum_class.enum) = CARD('a)\n\ngoal (1 subgoal):\n 1. map ket enum_class.enum ! c = ket (enum_class.enum ! c)", "by (simp add: a2)"], ["proof (state)\nthis:\n  map ket enum_class.enum ! c = ket (enum_class.enum ! c)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "hence \"(classical_operator f) *\\<^sub>V (BasisA!c) = (classical_operator f) *\\<^sub>V (ket (Enum.enum!c))\""], ["proof (prove)\nusing this:\n  map ket enum_class.enum ! c = ket (enum_class.enum ! c)\n\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V BasisA ! c =\n    classical_operator f *\\<^sub>V ket (enum_class.enum ! c)", "unfolding BasisA_def canonical_basis_ell2_def"], ["proof (prove)\nusing this:\n  map ket enum_class.enum ! c = ket (enum_class.enum ! c)\n\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V map ket enum_class.enum ! c =\n    classical_operator f *\\<^sub>V ket (enum_class.enum ! c)", "by simp"], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V BasisA ! c =\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "also"], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V BasisA ! c =\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "have \"... = (case f (enum_class.enum ! c) of None \\<Rightarrow> 0 | Some x \\<Rightarrow> ket x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n    (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n     | Some x \\<Rightarrow> ket x)", "by (rule classical_operator_ket_finite)"], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n  (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n   | Some x \\<Rightarrow> ket x)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "also"], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V ket (enum_class.enum ! c) =\n  (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n   | Some x \\<Rightarrow> ket x)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "have \"\\<dots> = BasisB!r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n     | Some x \\<Rightarrow> ket x) =\n    BasisB ! r", "using w0 b1"], ["proof (prove)\nusing this:\n  map ket enum_class.enum ! r = ket (enum_class.enum ! r)\n  f (enum_class.enum ! c) = Some (enum_class.enum ! r)\n\ngoal (1 subgoal):\n 1. (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n     | Some x \\<Rightarrow> ket x) =\n    BasisB ! r", "by (simp add: BasisB_def canonical_basis_ell2_def)"], ["proof (state)\nthis:\n  (case f (enum_class.enum ! c) of None \\<Rightarrow> 0\n   | Some x \\<Rightarrow> ket x) =\n  BasisB ! r\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "finally"], ["proof (chain)\npicking this:\n  classical_operator f *\\<^sub>V BasisA ! c = BasisB ! r", "have w1: \"(classical_operator f) *\\<^sub>V (BasisA!c) = BasisB!r\""], ["proof (prove)\nusing this:\n  classical_operator f *\\<^sub>V BasisA ! c = BasisB ! r\n\ngoal (1 subgoal):\n 1. classical_operator f *\\<^sub>V BasisA ! c = BasisB ! r", "by simp"], ["proof (state)\nthis:\n  classical_operator f *\\<^sub>V BasisA ! c = BasisB ! r\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "have \"(mat_of_cblinfun (classical_operator f))$$(r,c)\n        = \\<langle>BasisB!r, (classical_operator f) *\\<^sub>V (BasisA!c)\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    BasisB ! r \\<bullet>\\<^sub>C (classical_operator f *\\<^sub>V BasisA ! c)", "unfolding BasisB_def BasisA_def mat_of_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length canonical_basis) (length canonical_basis)\n     (\\<lambda>(i, j).\n         crepresentation (set canonical_basis)\n          (classical_operator f *\\<^sub>V canonical_basis ! j)\n          (canonical_basis ! i)) $$\n    (r, c) =\n    canonical_basis ! r \\<bullet>\\<^sub>C\n    (classical_operator f *\\<^sub>V canonical_basis ! c)", "using \\<open>nA = CARD('a)\\<close> \\<open>nB = CARD('b)\\<close> a1 a2 nA_def nB_def"], ["proof (prove)\nusing this:\n  nA = CARD('a)\n  nB = CARD('b)\n  r < CARD('b)\n  c < CARD('a)\n  nA = CARD('a)\n  nB = CARD('b)\n\ngoal (1 subgoal):\n 1. mat (length canonical_basis) (length canonical_basis)\n     (\\<lambda>(i, j).\n         crepresentation (set canonical_basis)\n          (classical_operator f *\\<^sub>V canonical_basis ! j)\n          (canonical_basis ! i)) $$\n    (r, c) =\n    canonical_basis ! r \\<bullet>\\<^sub>C\n    (classical_operator f *\\<^sub>V canonical_basis ! c)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r < CARD('b); c < CARD('a); nA = CARD('a);\n     nB = CARD('b)\\<rbrakk>\n    \\<Longrightarrow> crepresentation (set canonical_basis)\n                       (classical_operator f *\\<^sub>V canonical_basis ! c)\n                       (canonical_basis ! r) =\n                      canonical_basis ! r \\<bullet>\\<^sub>C\n                      (classical_operator f *\\<^sub>V canonical_basis ! c)", "by (metis BasisA_def BasisB_def canonical_basis_length_ell2 cinner_canonical_basis complex_vector.representation_basis is_cindependent_set nth_mem w1)"], ["proof (state)\nthis:\n  mat_of_cblinfun (classical_operator f) $$ (r, c) =\n  BasisB ! r \\<bullet>\\<^sub>C (classical_operator f *\\<^sub>V BasisA ! c)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "also"], ["proof (state)\nthis:\n  mat_of_cblinfun (classical_operator f) $$ (r, c) =\n  BasisB ! r \\<bullet>\\<^sub>C (classical_operator f *\\<^sub>V BasisA ! c)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "have \"\\<dots> = \\<langle>BasisB!r, BasisB!r\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BasisB ! r \\<bullet>\\<^sub>C\n    (classical_operator f *\\<^sub>V BasisA ! c) =\n    BasisB ! r \\<bullet>\\<^sub>C BasisB ! r", "using w1"], ["proof (prove)\nusing this:\n  classical_operator f *\\<^sub>V BasisA ! c = BasisB ! r\n\ngoal (1 subgoal):\n 1. BasisB ! r \\<bullet>\\<^sub>C\n    (classical_operator f *\\<^sub>V BasisA ! c) =\n    BasisB ! r \\<bullet>\\<^sub>C BasisB ! r", "by simp"], ["proof (state)\nthis:\n  BasisB ! r \\<bullet>\\<^sub>C (classical_operator f *\\<^sub>V BasisA ! c) =\n  BasisB ! r \\<bullet>\\<^sub>C BasisB ! r\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "also"], ["proof (state)\nthis:\n  BasisB ! r \\<bullet>\\<^sub>C (classical_operator f *\\<^sub>V BasisA ! c) =\n  BasisB ! r \\<bullet>\\<^sub>C BasisB ! r\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BasisB ! r \\<bullet>\\<^sub>C BasisB ! r = 1", "unfolding BasisB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. canonical_basis ! r \\<bullet>\\<^sub>C canonical_basis ! r = 1", "using \\<open>nB = CARD('b)\\<close> a1 nB_def"], ["proof (prove)\nusing this:\n  nB = CARD('b)\n  r < CARD('b)\n  nB = CARD('b)\n\ngoal (1 subgoal):\n 1. canonical_basis ! r \\<bullet>\\<^sub>C canonical_basis ! r = 1", "by (simp add: cinner_canonical_basis)"], ["proof (state)\nthis:\n  BasisB ! r \\<bullet>\\<^sub>C BasisB ! r = 1\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "finally"], ["proof (chain)\npicking this:\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 1\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "by blast"], ["proof (state)\nthis:\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (enum_class.enum ! c) = Some (enum_class.enum ! r) \\<Longrightarrow>\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 1\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "ultimately"], ["proof (chain)\npicking this:\n  f (enum_class.enum ! c) \\<noteq>\n  Some (enum_class.enum ! r) \\<Longrightarrow>\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n  f (enum_class.enum ! c) = Some (enum_class.enum ! r) \\<Longrightarrow>\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  f (enum_class.enum ! c) \\<noteq>\n  Some (enum_class.enum ! r) \\<Longrightarrow>\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 0\n  f (enum_class.enum ! c) = Some (enum_class.enum ! r) \\<Longrightarrow>\n  mat_of_cblinfun (classical_operator f) $$ (r, c) = 1\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) $$ (r, c) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0) $$\n    (r, c)", "by (simp add: a1 a2)"], ["proof (state)\nthis:\n  mat_of_cblinfun (classical_operator f) $$ (r, c) =\n  mat CARD('b) CARD('a)\n   (\\<lambda>(r, c).\n       if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n       else 0) $$\n  (r, c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?r < CARD('b); ?c < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> mat_of_cblinfun (classical_operator f) $$ (?r, ?c) =\n                    mat CARD('b) CARD('a)\n                     (\\<lambda>(r, c).\n                         if f (enum_class.enum ! c) =\n                            Some (enum_class.enum ! r)\n                         then 1 else 0) $$\n                    (?r, ?c)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "ultimately"], ["proof (chain)\npicking this:\n  mat_of_cblinfun (classical_operator f) \\<in> carrier_mat CARD('b) CARD('a)\n  \\<lbrakk>?r < CARD('b); ?c < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> mat_of_cblinfun (classical_operator f) $$ (?r, ?c) =\n                    mat CARD('b) CARD('a)\n                     (\\<lambda>(r, c).\n                         if f (enum_class.enum ! c) =\n                            Some (enum_class.enum ! r)\n                         then 1 else 0) $$\n                    (?r, ?c)", "show ?thesis"], ["proof (prove)\nusing this:\n  mat_of_cblinfun (classical_operator f) \\<in> carrier_mat CARD('b) CARD('a)\n  \\<lbrakk>?r < CARD('b); ?c < CARD('a)\\<rbrakk>\n  \\<Longrightarrow> mat_of_cblinfun (classical_operator f) $$ (?r, ?c) =\n                    mat CARD('b) CARD('a)\n                     (\\<lambda>(r, c).\n                         if f (enum_class.enum ! c) =\n                            Some (enum_class.enum ! r)\n                         then 1 else 0) $$\n                    (?r, ?c)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (classical_operator f) =\n    mat CARD('b) CARD('a)\n     (\\<lambda>(r, c).\n         if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n         else 0)", "apply (rule_tac eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>mat_of_cblinfun (classical_operator f)\n                \\<in> carrier_mat CARD('b) CARD('a);\n        \\<And>r c.\n           \\<lbrakk>r < CARD('b); c < CARD('a)\\<rbrakk>\n           \\<Longrightarrow> mat_of_cblinfun (classical_operator f) $$\n                             (r, c) =\n                             mat CARD('b) CARD('a)\n                              (\\<lambda>(r, c).\n                                  if f (enum_class.enum ! c) =\n                                     Some (enum_class.enum ! r)\n                                  then 1 else 0) $$\n                             (r, c);\n        i < dim_row\n             (mat CARD('b) CARD('a)\n               (\\<lambda>(r, c).\n                   if f (enum_class.enum ! c) = Some (enum_class.enum ! r)\n                   then 1 else 0));\n        j < dim_col\n             (mat CARD('b) CARD('a)\n               (\\<lambda>(r, c).\n                   if f (enum_class.enum ! c) = Some (enum_class.enum ! r)\n                   then 1 else 0))\\<rbrakk>\n       \\<Longrightarrow> mat_of_cblinfun (classical_operator f) $$ (i, j) =\n                         mat CARD('b) CARD('a)\n                          (\\<lambda>(r, c).\n                              if f (enum_class.enum ! c) =\n                                 Some (enum_class.enum ! r)\n                              then 1 else 0) $$\n                         (i, j)\n 2. \\<lbrakk>mat_of_cblinfun (classical_operator f)\n             \\<in> carrier_mat CARD('b) CARD('a);\n     \\<And>r c.\n        \\<lbrakk>r < CARD('b); c < CARD('a)\\<rbrakk>\n        \\<Longrightarrow> mat_of_cblinfun (classical_operator f) $$ (r, c) =\n                          mat CARD('b) CARD('a)\n                           (\\<lambda>(r, c).\n                               if f (enum_class.enum ! c) =\n                                  Some (enum_class.enum ! r)\n                               then 1 else 0) $$\n                          (r, c)\\<rbrakk>\n    \\<Longrightarrow> dim_row (mat_of_cblinfun (classical_operator f)) =\n                      dim_row\n                       (mat CARD('b) CARD('a)\n                         (\\<lambda>(r, c).\n                             if f (enum_class.enum ! c) =\n                                Some (enum_class.enum ! r)\n                             then 1 else 0))\n 3. \\<lbrakk>mat_of_cblinfun (classical_operator f)\n             \\<in> carrier_mat CARD('b) CARD('a);\n     \\<And>r c.\n        \\<lbrakk>r < CARD('b); c < CARD('a)\\<rbrakk>\n        \\<Longrightarrow> mat_of_cblinfun (classical_operator f) $$ (r, c) =\n                          mat CARD('b) CARD('a)\n                           (\\<lambda>(r, c).\n                               if f (enum_class.enum ! c) =\n                                  Some (enum_class.enum ! r)\n                               then 1 else 0) $$\n                          (r, c)\\<rbrakk>\n    \\<Longrightarrow> dim_col (mat_of_cblinfun (classical_operator f)) =\n                      dim_col\n                       (mat CARD('b) CARD('a)\n                         (\\<lambda>(r, c).\n                             if f (enum_class.enum ! c) =\n                                Some (enum_class.enum ! r)\n                             then 1 else 0))", "by auto"], ["proof (state)\nthis:\n  mat_of_cblinfun (classical_operator f) =\n  mat CARD('b) CARD('a)\n   (\\<lambda>(r, c).\n       if f (enum_class.enum ! c) = Some (enum_class.enum ! r) then 1\n       else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_of_cblinfun_compose:\n  \"mat_of_cblinfun (F o\\<^sub>C\\<^sub>L G) = mat_of_cblinfun F * mat_of_cblinfun G\" \n  for F::\"'b::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::{basis_enum,complex_normed_vector}\"\n    and G::\"'a::{basis_enum,complex_normed_vector}  \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (F o\\<^sub>C\\<^sub>L G) =\n    mat_of_cblinfun F * mat_of_cblinfun G", "by (smt (verit, del_insts) cblinfun_of_mat_inverse mat_carrier mat_of_cblinfun_def mat_of_cblinfun_inverse cblinfun_of_mat_times mult_carrier_mat)"], ["", "lemma mat_of_cblinfun_scaleC:\n  \"mat_of_cblinfun ((a::complex) *\\<^sub>C F) = a \\<cdot>\\<^sub>m (mat_of_cblinfun F)\"\n  for F :: \"'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{basis_enum,complex_normed_vector}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (a *\\<^sub>C F) = a \\<cdot>\\<^sub>m mat_of_cblinfun F", "by (auto simp add: complex_vector.representation_scale mat_of_cblinfun_def)"], ["", "lemma mat_of_cblinfun_scaleR:\n  \"mat_of_cblinfun ((a::real) *\\<^sub>R F) = (complex_of_real a) \\<cdot>\\<^sub>m (mat_of_cblinfun F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (a *\\<^sub>R F) =\n    complex_of_real a \\<cdot>\\<^sub>m mat_of_cblinfun F", "unfolding scaleR_scaleC"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (complex_of_real a *\\<^sub>C F) =\n    complex_of_real a \\<cdot>\\<^sub>m mat_of_cblinfun F", "by (rule mat_of_cblinfun_scaleC)"], ["", "lemma mat_of_cblinfun_adj:\n  \"mat_of_cblinfun (F*) = mat_adjoint (mat_of_cblinfun F)\"\n  for F :: \"'a::onb_enum \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::onb_enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (F*) = mat_adjoint (mat_of_cblinfun F)", "by (metis (no_types, lifting) cblinfun_of_mat_inverse map_carrier_mat mat_adjoint_def' mat_carrier cblinfun_of_mat_adjoint mat_of_cblinfun_def mat_of_cblinfun_inverse transpose_carrier_mat)"], ["", "lemma mat_of_cblinfun_vector_to_cblinfun:\n  \"mat_of_cblinfun (vector_to_cblinfun \\<psi>)\n       = mat_of_cols (length (canonical_basis :: 'a list)) [vec_of_basis_enum \\<psi>]\"\n  for \\<psi>::\"'a::{basis_enum,complex_normed_vector}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (vector_to_cblinfun \\<psi>) =\n    mat_of_cols (length canonical_basis) [vec_of_basis_enum \\<psi>]", "by (auto simp: mat_of_cols_Cons_index_0 mat_of_cblinfun_def vec_of_basis_enum_def vec_of_list_index)"], ["", "lemma mat_of_cblinfun_proj:\n  fixes a::\"'a::onb_enum\"\n  defines   \"d \\<equiv> length (canonical_basis :: 'a list)\"\n    and \"norm2 \\<equiv> (vec_of_basis_enum a) \\<bullet>c (vec_of_basis_enum a)\"\n  shows  \"mat_of_cblinfun (proj a) = \n      1 / norm2 \\<cdot>\\<^sub>m (mat_of_cols d [vec_of_basis_enum a]\n                 * mat_of_rows d [conjugate (vec_of_basis_enum a)])\" (is \\<open>_ = ?rhs\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "proof (cases \"a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "case False"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "have norm2: \\<open>norm2 = (norm a)\\<^sup>2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm2 = complex_of_real ((norm a)\\<^sup>2)", "by (simp add: cscalar_prod_vec_of_basis_enum norm2_def cdot_square_norm[symmetric, simplified])"], ["proof (state)\nthis:\n  norm2 = complex_of_real ((norm a)\\<^sup>2)\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "have [simp]: \\<open>vec_of_basis_enum a \\<in> carrier_vec d\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum a \\<in> carrier_vec d", "by (simp add: carrier_vecI d_def dim_vec_of_basis_enum')"], ["proof (state)\nthis:\n  vec_of_basis_enum a \\<in> carrier_vec d\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "have \\<open>mat_of_cblinfun (proj a) = mat_of_cblinfun (proj (a /\\<^sub>R norm a))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (proj a) = mat_of_cblinfun (proj (a /\\<^sub>R norm a))", "by (metis (mono_tags, hide_lams) ccspan_singleton_scaleC complex_vector.scale_eq_0_iff nonzero_imp_inverse_nonzero norm_eq_zero scaleR_scaleC scale_left_imp_eq)"], ["proof (state)\nthis:\n  mat_of_cblinfun (proj a) = mat_of_cblinfun (proj (a /\\<^sub>R norm a))\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "also"], ["proof (state)\nthis:\n  mat_of_cblinfun (proj a) = mat_of_cblinfun (proj (a /\\<^sub>R norm a))\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "have \\<open>\\<dots> = mat_of_cblinfun (selfbutter (a /\\<^sub>R norm a))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (proj (a /\\<^sub>R norm a)) =\n    mat_of_cblinfun (selfbutter (a /\\<^sub>R norm a))", "apply (subst butterfly_eq_proj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. norm (a /\\<^sub>R norm a) = 1\n 2. mat_of_cblinfun (proj (a /\\<^sub>R norm a)) =\n    mat_of_cblinfun (proj (a /\\<^sub>R norm a))", "by (auto simp add: False)"], ["proof (state)\nthis:\n  mat_of_cblinfun (proj (a /\\<^sub>R norm a)) =\n  mat_of_cblinfun (selfbutter (a /\\<^sub>R norm a))\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "also"], ["proof (state)\nthis:\n  mat_of_cblinfun (proj (a /\\<^sub>R norm a)) =\n  mat_of_cblinfun (selfbutter (a /\\<^sub>R norm a))\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "have \\<open>\\<dots> = 1/norm2 \\<cdot>\\<^sub>m mat_of_cblinfun (selfbutter a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (selfbutter (a /\\<^sub>R norm a)) =\n    1 / norm2 \\<cdot>\\<^sub>m mat_of_cblinfun (selfbutter a)", "apply (simp add: mat_of_cblinfun_scaleC norm2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (complex_of_real (norm a)) *\n    inverse (complex_of_real (norm a)) \\<cdot>\\<^sub>m\n    mat_of_cblinfun (selfbutter a) =\n    1 / (complex_of_real (norm a))\\<^sup>2 \\<cdot>\\<^sub>m\n    mat_of_cblinfun (selfbutter a)", "by (simp add: inverse_eq_divide power2_eq_square)"], ["proof (state)\nthis:\n  mat_of_cblinfun (selfbutter (a /\\<^sub>R norm a)) =\n  1 / norm2 \\<cdot>\\<^sub>m mat_of_cblinfun (selfbutter a)\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "also"], ["proof (state)\nthis:\n  mat_of_cblinfun (selfbutter (a /\\<^sub>R norm a)) =\n  1 / norm2 \\<cdot>\\<^sub>m mat_of_cblinfun (selfbutter a)\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "have \\<open>\\<dots> = 1 / norm2 \\<cdot>\\<^sub>m (mat_of_cblinfun (vector_to_cblinfun a :: complex \\<Rightarrow>\\<^sub>C\\<^sub>L 'a) * mat_adjoint (mat_of_cblinfun (vector_to_cblinfun a :: complex \\<Rightarrow>\\<^sub>C\\<^sub>L 'a)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / norm2 \\<cdot>\\<^sub>m mat_of_cblinfun (selfbutter a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cblinfun (vector_to_cblinfun a) *\n     mat_adjoint (mat_of_cblinfun (vector_to_cblinfun a)))", "by (simp add: butterfly_def mat_of_cblinfun_compose mat_of_cblinfun_adj)"], ["proof (state)\nthis:\n  1 / norm2 \\<cdot>\\<^sub>m mat_of_cblinfun (selfbutter a) =\n  1 / norm2 \\<cdot>\\<^sub>m\n  (mat_of_cblinfun (vector_to_cblinfun a) *\n   mat_adjoint (mat_of_cblinfun (vector_to_cblinfun a)))\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "also"], ["proof (state)\nthis:\n  1 / norm2 \\<cdot>\\<^sub>m mat_of_cblinfun (selfbutter a) =\n  1 / norm2 \\<cdot>\\<^sub>m\n  (mat_of_cblinfun (vector_to_cblinfun a) *\n   mat_adjoint (mat_of_cblinfun (vector_to_cblinfun a)))\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "have \\<open>\\<dots> = ?rhs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cblinfun (vector_to_cblinfun a) *\n     mat_adjoint (mat_of_cblinfun (vector_to_cblinfun a))) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "by (simp add: mat_of_cblinfun_vector_to_cblinfun mat_adjoint_def flip: d_def)"], ["proof (state)\nthis:\n  1 / norm2 \\<cdot>\\<^sub>m\n  (mat_of_cblinfun (vector_to_cblinfun a) *\n   mat_adjoint (mat_of_cblinfun (vector_to_cblinfun a))) =\n  1 / norm2 \\<cdot>\\<^sub>m\n  (mat_of_cols d [vec_of_basis_enum a] *\n   mat_of_rows d [conjugate (vec_of_basis_enum a)])\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])\n 2. a \\<noteq> (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "finally"], ["proof (chain)\npicking this:\n  mat_of_cblinfun (proj a) =\n  1 / norm2 \\<cdot>\\<^sub>m\n  (mat_of_cols d [vec_of_basis_enum a] *\n   mat_of_rows d [conjugate (vec_of_basis_enum a)])", "show ?thesis"], ["proof (prove)\nusing this:\n  mat_of_cblinfun (proj a) =\n  1 / norm2 \\<cdot>\\<^sub>m\n  (mat_of_cols d [vec_of_basis_enum a] *\n   mat_of_rows d [conjugate (vec_of_basis_enum a)])\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "by -"], ["proof (state)\nthis:\n  mat_of_cblinfun (proj a) =\n  1 / norm2 \\<cdot>\\<^sub>m\n  (mat_of_cols d [vec_of_basis_enum a] *\n   mat_of_rows d [conjugate (vec_of_basis_enum a)])\n\ngoal (1 subgoal):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "case True"], ["proof (state)\nthis:\n  a = (0::'a)\n\ngoal (1 subgoal):\n 1. a = (0::'a) \\<Longrightarrow>\n    mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (proj a) =\n    1 / norm2 \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)])", "apply (rule eq_matI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (1 / norm2 \\<cdot>\\<^sub>m\n                      (mat_of_cols d [vec_of_basis_enum a] *\n                       mat_of_rows d [conjugate (vec_of_basis_enum a)]));\n        j < dim_col\n             (1 / norm2 \\<cdot>\\<^sub>m\n              (mat_of_cols d [vec_of_basis_enum a] *\n               mat_of_rows d [conjugate (vec_of_basis_enum a)]))\\<rbrakk>\n       \\<Longrightarrow> mat_of_cblinfun (proj a) $$ (i, j) =\n                         (1 / norm2 \\<cdot>\\<^sub>m\n                          (mat_of_cols d [vec_of_basis_enum a] *\n                           mat_of_rows d\n                            [conjugate (vec_of_basis_enum a)])) $$\n                         (i, j)\n 2. dim_row (mat_of_cblinfun (proj a)) =\n    dim_row\n     (1 / norm2 \\<cdot>\\<^sub>m\n      (mat_of_cols d [vec_of_basis_enum a] *\n       mat_of_rows d [conjugate (vec_of_basis_enum a)]))\n 3. dim_col (mat_of_cblinfun (proj a)) =\n    dim_col\n     (1 / norm2 \\<cdot>\\<^sub>m\n      (mat_of_cols d [vec_of_basis_enum a] *\n       mat_of_rows d [conjugate (vec_of_basis_enum a)]))", "by (auto simp: True mat_of_cblinfun_zero vec_of_basis_enum_zero scalar_prod_def  mat_of_rows_index\n        simp flip: d_def)"], ["proof (state)\nthis:\n  mat_of_cblinfun (proj a) =\n  1 / norm2 \\<cdot>\\<^sub>m\n  (mat_of_cols d [vec_of_basis_enum a] *\n   mat_of_rows d [conjugate (vec_of_basis_enum a)])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_of_cblinfun_ell2_component:\n  fixes a :: \\<open>'a::enum ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::enum ell2\\<close> \n  assumes [simp]: \\<open>i < CARD('b)\\<close> \\<open>j < CARD('a)\\<close>\n  shows \\<open>mat_of_cblinfun a $$ (i,j) = Rep_ell2 (a *\\<^sub>V ket (Enum.enum ! j)) (Enum.enum ! i)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun a $$ (i, j) =\n    Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_cblinfun a $$ (i, j) =\n    Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i)", "let ?i = \\<open>Enum.enum ! i\\<close> and ?j = \\<open>Enum.enum ! j\\<close> and ?aj = \\<open>a *\\<^sub>V ket (Enum.enum ! j)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_cblinfun a $$ (i, j) =\n    Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i)", "have \\<open>Rep_ell2 ?aj (Enum.enum ! i) = vec_of_basis_enum ?aj $ i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i) =\n    vec_of_basis_enum (a *\\<^sub>V ket (enum_class.enum ! j)) $ i", "by (rule vec_of_basis_enum_ell2_component[symmetric], simp)"], ["proof (state)\nthis:\n  Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i) =\n  vec_of_basis_enum (a *\\<^sub>V ket (enum_class.enum ! j)) $ i\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun a $$ (i, j) =\n    Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i)", "also"], ["proof (state)\nthis:\n  Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i) =\n  vec_of_basis_enum (a *\\<^sub>V ket (enum_class.enum ! j)) $ i\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun a $$ (i, j) =\n    Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i)", "have \\<open>\\<dots> = (mat_of_cblinfun a *\\<^sub>v vec_of_basis_enum (ket (enum_class.enum ! j) :: 'a ell2)) $ i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_basis_enum (a *\\<^sub>V ket (enum_class.enum ! j)) $ i =\n    (mat_of_cblinfun a *\\<^sub>v\n     vec_of_basis_enum (ket (enum_class.enum ! j))) $\n    i", "by (simp add: mat_of_cblinfun_cblinfun_apply)"], ["proof (state)\nthis:\n  vec_of_basis_enum (a *\\<^sub>V ket (enum_class.enum ! j)) $ i =\n  (mat_of_cblinfun a *\\<^sub>v\n   vec_of_basis_enum (ket (enum_class.enum ! j))) $\n  i\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun a $$ (i, j) =\n    Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i)", "also"], ["proof (state)\nthis:\n  vec_of_basis_enum (a *\\<^sub>V ket (enum_class.enum ! j)) $ i =\n  (mat_of_cblinfun a *\\<^sub>v\n   vec_of_basis_enum (ket (enum_class.enum ! j))) $\n  i\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun a $$ (i, j) =\n    Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i)", "have \\<open>\\<dots> = (mat_of_cblinfun a *\\<^sub>v unit_vec CARD('a) j) $ i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_of_cblinfun a *\\<^sub>v\n     vec_of_basis_enum (ket (enum_class.enum ! j))) $\n    i =\n    (mat_of_cblinfun a *\\<^sub>v unit_vec CARD('a) j) $ i", "by (simp add: vec_of_basis_enum_ket enum_idx_enum)"], ["proof (state)\nthis:\n  (mat_of_cblinfun a *\\<^sub>v\n   vec_of_basis_enum (ket (enum_class.enum ! j))) $\n  i =\n  (mat_of_cblinfun a *\\<^sub>v unit_vec CARD('a) j) $ i\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun a $$ (i, j) =\n    Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i)", "also"], ["proof (state)\nthis:\n  (mat_of_cblinfun a *\\<^sub>v\n   vec_of_basis_enum (ket (enum_class.enum ! j))) $\n  i =\n  (mat_of_cblinfun a *\\<^sub>v unit_vec CARD('a) j) $ i\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun a $$ (i, j) =\n    Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i)", "have \\<open>\\<dots> = mat_of_cblinfun a $$ (i, j)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mat_of_cblinfun a *\\<^sub>v unit_vec CARD('a) j) $ i =\n    mat_of_cblinfun a $$ (i, j)", "apply (subst mat_entry_explicit[where m=\\<open>CARD('b)\\<close>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. mat_of_cblinfun a \\<in> carrier_mat CARD('b) CARD('a)\n 2. i < CARD('b)\n 3. j < CARD('a)\n 4. mat_of_cblinfun a $$ (i, j) = mat_of_cblinfun a $$ (i, j)", "by auto"], ["proof (state)\nthis:\n  (mat_of_cblinfun a *\\<^sub>v unit_vec CARD('a) j) $ i =\n  mat_of_cblinfun a $$ (i, j)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun a $$ (i, j) =\n    Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i)", "finally"], ["proof (chain)\npicking this:\n  Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i) =\n  mat_of_cblinfun a $$ (i, j)", "show ?thesis"], ["proof (prove)\nusing this:\n  Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i) =\n  mat_of_cblinfun a $$ (i, j)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun a $$ (i, j) =\n    Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i)", "by auto"], ["proof (state)\nthis:\n  mat_of_cblinfun a $$ (i, j) =\n  Rep_ell2 (a *\\<^sub>V ket (enum_class.enum ! j)) (enum_class.enum ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_of_cblinfun_sandwich:\n  fixes a :: \"(_::onb_enum, _::onb_enum) cblinfun\"\n  shows \\<open>mat_of_cblinfun (sandwich a *\\<^sub>V b) = (let a' = mat_of_cblinfun a in a' * mat_of_cblinfun b * mat_adjoint a')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (sandwich a *\\<^sub>V b) =\n    (let a' = mat_of_cblinfun a in a' * mat_of_cblinfun b * mat_adjoint a')", "by (simp add: mat_of_cblinfun_compose sandwich_apply Let_def mat_of_cblinfun_adj)"], ["", "subsection \\<open>Operations on subspaces\\<close>"], ["", "lemma ccspan_gram_schmidt0_invariant:\n  defines \"basis_enum \\<equiv> (basis_enum_of_vec :: _ \\<Rightarrow> 'a::{basis_enum,complex_normed_vector})\"\n  defines \"n \\<equiv> length (canonical_basis :: 'a list)\"\n  assumes \"set ws \\<subseteq> carrier_vec n\"\n  shows \"ccspan (set (map basis_enum (gram_schmidt0 n ws))) = ccspan (set (map basis_enum ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan (set (map basis_enum (gram_schmidt0 n ws))) =\n    ccspan (set (map basis_enum ws))", "proof (transfer fixing: n ws basis_enum)"], ["proof (state)\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "interpret complex_vec_space"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "define gs where \"gs = gram_schmidt0 n ws\""], ["proof (state)\nthis:\n  gs = gram_schmidt0 n ws\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "have \"closure (cspan (set (map basis_enum gs)))\n     = cspan (set (map basis_enum gs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum gs))) =\n    cspan (set (map basis_enum gs))", "apply (rule closure_finite_cspan)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set (map basis_enum gs))", "by simp"], ["proof (state)\nthis:\n  closure (cspan (set (map basis_enum gs))) =\n  cspan (set (map basis_enum gs))\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "also"], ["proof (state)\nthis:\n  closure (cspan (set (map basis_enum gs))) =\n  cspan (set (map basis_enum gs))\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "have \"\\<dots> = cspan (basis_enum ` set gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (set (map basis_enum gs)) = cspan (basis_enum ` set gs)", "by simp"], ["proof (state)\nthis:\n  cspan (set (map basis_enum gs)) = cspan (basis_enum ` set gs)\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "also"], ["proof (state)\nthis:\n  cspan (set (map basis_enum gs)) = cspan (basis_enum ` set gs)\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "have \"\\<dots> = basis_enum ` span (set gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (basis_enum ` set gs) = basis_enum ` local.span (set gs)", "unfolding basis_enum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (basis_enum_of_vec ` set gs) =\n    basis_enum_of_vec ` local.span (set gs)", "apply (rule basis_enum_of_vec_span[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. length canonical_basis = n\n 2. set gs \\<subseteq> carrier_vec n", "using n_def"], ["proof (prove)\nusing this:\n  n \\<equiv> length canonical_basis\n\ngoal (2 subgoals):\n 1. length canonical_basis = n\n 2. set gs \\<subseteq> carrier_vec n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. set gs \\<subseteq> carrier_vec n", "by (simp add: assms(3) cof_vec_space.gram_schmidt0_result(1) gs_def)"], ["proof (state)\nthis:\n  cspan (basis_enum ` set gs) = basis_enum ` local.span (set gs)\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "also"], ["proof (state)\nthis:\n  cspan (basis_enum ` set gs) = basis_enum ` local.span (set gs)\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "have \"\\<dots> = basis_enum ` span (set ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum ` local.span (set gs) = basis_enum ` local.span (set ws)", "unfolding gs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum ` local.span (set (gram_schmidt0 n ws)) =\n    basis_enum ` local.span (set ws)", "apply (subst gram_schmidt0_result(4)[where ws=ws, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. set ws \\<subseteq> carrier_vec n\n 2. basis_enum ` local.span (set ws) = basis_enum ` local.span (set ws)", "using assms"], ["proof (prove)\nusing this:\n  basis_enum \\<equiv> basis_enum_of_vec\n  n \\<equiv> length canonical_basis\n  set ws \\<subseteq> carrier_vec n\n\ngoal (2 subgoals):\n 1. set ws \\<subseteq> carrier_vec n\n 2. basis_enum ` local.span (set ws) = basis_enum ` local.span (set ws)", "by auto"], ["proof (state)\nthis:\n  basis_enum ` local.span (set gs) = basis_enum ` local.span (set ws)\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "also"], ["proof (state)\nthis:\n  basis_enum ` local.span (set gs) = basis_enum ` local.span (set ws)\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "have \"\\<dots> = cspan (basis_enum ` set ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum ` local.span (set ws) = cspan (basis_enum ` set ws)", "unfolding basis_enum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` local.span (set ws) =\n    cspan (basis_enum_of_vec ` set ws)", "apply (rule basis_enum_of_vec_span)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length canonical_basis = n\n 2. set ws \\<subseteq> carrier_vec n", "using n_def"], ["proof (prove)\nusing this:\n  n \\<equiv> length canonical_basis\n\ngoal (2 subgoals):\n 1. length canonical_basis = n\n 2. set ws \\<subseteq> carrier_vec n", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ws \\<subseteq> carrier_vec n", "by (simp add: assms(3))"], ["proof (state)\nthis:\n  basis_enum ` local.span (set ws) = cspan (basis_enum ` set ws)\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "also"], ["proof (state)\nthis:\n  basis_enum ` local.span (set ws) = cspan (basis_enum ` set ws)\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "have \"\\<dots> = cspan (set (map basis_enum ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (basis_enum ` set ws) = cspan (set (map basis_enum ws))", "by simp"], ["proof (state)\nthis:\n  cspan (basis_enum ` set ws) = cspan (set (map basis_enum ws))\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "also"], ["proof (state)\nthis:\n  cspan (basis_enum ` set ws) = cspan (set (map basis_enum ws))\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "have \"\\<dots> = closure (cspan (set (map basis_enum ws)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (set (map basis_enum ws)) =\n    closure (cspan (set (map basis_enum ws)))", "apply (rule closure_finite_cspan[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set (map basis_enum ws))", "by simp"], ["proof (state)\nthis:\n  cspan (set (map basis_enum ws)) =\n  closure (cspan (set (map basis_enum ws)))\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum (gram_schmidt0 n ws)))) =\n    closure (cspan (set (map basis_enum ws)))", "finally"], ["proof (chain)\npicking this:\n  closure (cspan (set (map basis_enum gs))) =\n  closure (cspan (set (map basis_enum ws)))", "show \"closure (cspan (set (map basis_enum gs)))\n              = closure (cspan (set (map basis_enum ws)))\""], ["proof (prove)\nusing this:\n  closure (cspan (set (map basis_enum gs))) =\n  closure (cspan (set (map basis_enum ws)))\n\ngoal (1 subgoal):\n 1. closure (cspan (set (map basis_enum gs))) =\n    closure (cspan (set (map basis_enum ws)))", "."], ["proof (state)\nthis:\n  closure (cspan (set (map basis_enum gs))) =\n  closure (cspan (set (map basis_enum ws)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"is_subspace_of_vec_list n vs ws = \n  (let ws' = gram_schmidt0 n ws in\n     \\<forall>v\\<in>set vs. adjuster n v ws' = - v)\""], ["", "lemma ccspan_leq_using_vec:\n  fixes A B :: \"'a::{basis_enum,complex_normed_vector} list\"\n  shows \"(ccspan (set A) \\<le> ccspan (set B)) \\<longleftrightarrow>\n    is_subspace_of_vec_list (length (canonical_basis :: 'a list)) \n      (map vec_of_basis_enum A) (map vec_of_basis_enum B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "define d Av Bv Bo\n    where \"d = length (canonical_basis :: 'a list)\"\n      and \"Av = map vec_of_basis_enum A\"\n      and \"Bv = map vec_of_basis_enum B\"\n      and \"Bo = gram_schmidt0 d Bv\""], ["proof (state)\nthis:\n  d = length canonical_basis\n  Av = map vec_of_basis_enum A\n  Bv = map vec_of_basis_enum B\n  Bo = gram_schmidt0 d Bv\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "interpret complex_vec_space d"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "have Av_carrier: \"set Av \\<subseteq> carrier_vec d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set Av \\<subseteq> carrier_vec d", "unfolding Av_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map vec_of_basis_enum A) \\<subseteq> carrier_vec d", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set A \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> carrier_vec d", "by (simp add: carrier_vecI d_def dim_vec_of_basis_enum')"], ["proof (state)\nthis:\n  set Av \\<subseteq> carrier_vec d\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "have Bv_carrier: \"set Bv \\<subseteq> carrier_vec d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set Bv \\<subseteq> carrier_vec d", "unfolding Bv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map vec_of_basis_enum B) \\<subseteq> carrier_vec d", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set B \\<Longrightarrow>\n       vec_of_basis_enum xa \\<in> carrier_vec d", "by (simp add: carrier_vecI d_def dim_vec_of_basis_enum')"], ["proof (state)\nthis:\n  set Bv \\<subseteq> carrier_vec d\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "have Bo_carrier: \"set Bo \\<subseteq> carrier_vec d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set Bo \\<subseteq> carrier_vec d", "apply (simp add: Bo_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (gram_schmidt0 d Bv) \\<subseteq> carrier_vec d", "using Bv_carrier"], ["proof (prove)\nusing this:\n  set Bv \\<subseteq> carrier_vec d\n\ngoal (1 subgoal):\n 1. set (gram_schmidt0 d Bv) \\<subseteq> carrier_vec d", "by (rule gram_schmidt0_result(1))"], ["proof (state)\nthis:\n  set Bo \\<subseteq> carrier_vec d\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "have orth_Bo: \"corthogonal Bo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. corthogonal Bo", "apply (simp add: Bo_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. corthogonal (gram_schmidt0 d Bv)", "using Bv_carrier"], ["proof (prove)\nusing this:\n  set Bv \\<subseteq> carrier_vec d\n\ngoal (1 subgoal):\n 1. corthogonal (gram_schmidt0 d Bv)", "by (rule gram_schmidt0_result(3))"], ["proof (state)\nthis:\n  corthogonal Bo\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "have distinct_Bo: \"distinct Bo\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct Bo", "apply (simp add: Bo_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (gram_schmidt0 d Bv)", "using Bv_carrier"], ["proof (prove)\nusing this:\n  set Bv \\<subseteq> carrier_vec d\n\ngoal (1 subgoal):\n 1. distinct (gram_schmidt0 d Bv)", "by (rule gram_schmidt0_result(2))"], ["proof (state)\nthis:\n  distinct Bo\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "have \"ccspan (set A) \\<le> ccspan (set B) \\<longleftrightarrow> cspan (set A) \\<subseteq> cspan (set B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    (cspan (set A) \\<subseteq> cspan (set B))", "apply (transfer fixing: A B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (closure (cspan (set A)) \\<subseteq> closure (cspan (set B))) =\n    (cspan (set A) \\<subseteq> cspan (set B))", "apply (subst closure_finite_cspan, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cspan (set A) \\<subseteq> closure (cspan (set B))) =\n    (cspan (set A) \\<subseteq> cspan (set B))", "by (subst closure_finite_cspan, simp_all)"], ["proof (state)\nthis:\n  (ccspan (set A) \\<le> ccspan (set B)) =\n  (cspan (set A) \\<subseteq> cspan (set B))\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "also"], ["proof (state)\nthis:\n  (ccspan (set A) \\<le> ccspan (set B)) =\n  (cspan (set A) \\<subseteq> cspan (set B))\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "have \"\\<dots> \\<longleftrightarrow> span (set Av) \\<subseteq> span (set Bv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cspan (set A) \\<subseteq> cspan (set B)) =\n    (local.span (set Av) \\<subseteq> local.span (set Bv))", "apply (simp add: Av_def Bv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cspan (set A) \\<subseteq> cspan (set B)) =\n    (local.span (vec_of_basis_enum ` set A)\n     \\<subseteq> local.span (vec_of_basis_enum ` set B))", "apply (subst vec_of_basis_enum_cspan[symmetric], simp add: d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cspan (set A) \\<subseteq> cspan (set B)) =\n    (vec_of_basis_enum ` cspan (set A)\n     \\<subseteq> local.span (vec_of_basis_enum ` set B))", "apply (subst vec_of_basis_enum_cspan[symmetric], simp add: d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cspan (set A) \\<subseteq> cspan (set B)) =\n    (vec_of_basis_enum ` cspan (set A)\n     \\<subseteq> vec_of_basis_enum ` cspan (set B))", "by (metis inj_image_subset_iff inj_on_def vec_of_basis_enum_inverse)"], ["proof (state)\nthis:\n  (cspan (set A) \\<subseteq> cspan (set B)) =\n  (local.span (set Av) \\<subseteq> local.span (set Bv))\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "also"], ["proof (state)\nthis:\n  (cspan (set A) \\<subseteq> cspan (set B)) =\n  (local.span (set Av) \\<subseteq> local.span (set Bv))\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "have \"\\<dots> \\<longleftrightarrow> span (set Av) \\<subseteq> span (set Bo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.span (set Av) \\<subseteq> local.span (set Bv)) =\n    (local.span (set Av) \\<subseteq> local.span (set Bo))", "unfolding Bo_def Av_def Bv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.span (set (map vec_of_basis_enum A))\n     \\<subseteq> local.span (set (map vec_of_basis_enum B))) =\n    (local.span (set (map vec_of_basis_enum A))\n     \\<subseteq> local.span\n                  (set (gram_schmidt0 d (map vec_of_basis_enum B))))", "apply (subst gram_schmidt0_result(4)[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (map vec_of_basis_enum B) \\<subseteq> carrier_vec d\n 2. (local.span (set (map vec_of_basis_enum A))\n     \\<subseteq> local.span (set (map vec_of_basis_enum B))) =\n    (local.span (set (map vec_of_basis_enum A))\n     \\<subseteq> local.span (set (map vec_of_basis_enum B)))", "by (simp_all add: carrier_dim_vec d_def dim_vec_of_basis_enum' image_subset_iff)"], ["proof (state)\nthis:\n  (local.span (set Av) \\<subseteq> local.span (set Bv)) =\n  (local.span (set Av) \\<subseteq> local.span (set Bo))\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "also"], ["proof (state)\nthis:\n  (local.span (set Av) \\<subseteq> local.span (set Bv)) =\n  (local.span (set Av) \\<subseteq> local.span (set Bo))\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "have \"\\<dots> \\<longleftrightarrow> (\\<forall>v\\<in>set Av. adjuster d v Bo = - v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.span (set Av) \\<subseteq> local.span (set Bo)) =\n    (\\<forall>v\\<in>set Av. adjuster d v Bo = - v)", "proof (intro iffI ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>local.span (set Av) \\<subseteq> local.span (set Bo);\n        v \\<in> set Av\\<rbrakk>\n       \\<Longrightarrow> adjuster d v Bo = - v\n 2. \\<forall>v\\<in>set Av. adjuster d v Bo = - v \\<Longrightarrow>\n    local.span (set Av) \\<subseteq> local.span (set Bo)", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>local.span (set Av) \\<subseteq> local.span (set Bo);\n        v \\<in> set Av\\<rbrakk>\n       \\<Longrightarrow> adjuster d v Bo = - v\n 2. \\<forall>v\\<in>set Av. adjuster d v Bo = - v \\<Longrightarrow>\n    local.span (set Av) \\<subseteq> local.span (set Bo)", "assume \"v \\<in> set Av\" and \"span (set Av) \\<subseteq> span (set Bo)\""], ["proof (state)\nthis:\n  v \\<in> set Av\n  local.span (set Av) \\<subseteq> local.span (set Bo)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>local.span (set Av) \\<subseteq> local.span (set Bo);\n        v \\<in> set Av\\<rbrakk>\n       \\<Longrightarrow> adjuster d v Bo = - v\n 2. \\<forall>v\\<in>set Av. adjuster d v Bo = - v \\<Longrightarrow>\n    local.span (set Av) \\<subseteq> local.span (set Bo)", "then"], ["proof (chain)\npicking this:\n  v \\<in> set Av\n  local.span (set Av) \\<subseteq> local.span (set Bo)", "have \"v \\<in> span (set Bo)\""], ["proof (prove)\nusing this:\n  v \\<in> set Av\n  local.span (set Av) \\<subseteq> local.span (set Bo)\n\ngoal (1 subgoal):\n 1. v \\<in> local.span (set Bo)", "using Av_carrier span_mem"], ["proof (prove)\nusing this:\n  v \\<in> set Av\n  local.span (set Av) \\<subseteq> local.span (set Bo)\n  set Av \\<subseteq> carrier_vec d\n  \\<lbrakk>?E \\<subseteq> carrier_vec d; ?u \\<in> ?E\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> local.span ?E\n\ngoal (1 subgoal):\n 1. v \\<in> local.span (set Bo)", "by auto"], ["proof (state)\nthis:\n  v \\<in> local.span (set Bo)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>local.span (set Av) \\<subseteq> local.span (set Bo);\n        v \\<in> set Av\\<rbrakk>\n       \\<Longrightarrow> adjuster d v Bo = - v\n 2. \\<forall>v\\<in>set Av. adjuster d v Bo = - v \\<Longrightarrow>\n    local.span (set Av) \\<subseteq> local.span (set Bo)", "have \"adjuster d v Bo + v = 0\\<^sub>v d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjuster d v Bo + v = 0\\<^sub>v d", "apply (rule adjuster_already_in_span)"], ["proof (prove)\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec d\n 2. set Bo \\<subseteq> carrier_vec d\n 3. corthogonal Bo\n 4. v \\<in> local.span (set Bo)", "using Av_carrier \\<open>v \\<in> set Av\\<close> Bo_carrier orth_Bo\n        \\<open>v \\<in> span (set Bo)\\<close>"], ["proof (prove)\nusing this:\n  set Av \\<subseteq> carrier_vec d\n  v \\<in> set Av\n  set Bo \\<subseteq> carrier_vec d\n  corthogonal Bo\n  v \\<in> local.span (set Bo)\n\ngoal (4 subgoals):\n 1. v \\<in> carrier_vec d\n 2. set Bo \\<subseteq> carrier_vec d\n 3. corthogonal Bo\n 4. v \\<in> local.span (set Bo)", "by simp_all"], ["proof (state)\nthis:\n  adjuster d v Bo + v = 0\\<^sub>v d\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>local.span (set Av) \\<subseteq> local.span (set Bo);\n        v \\<in> set Av\\<rbrakk>\n       \\<Longrightarrow> adjuster d v Bo = - v\n 2. \\<forall>v\\<in>set Av. adjuster d v Bo = - v \\<Longrightarrow>\n    local.span (set Av) \\<subseteq> local.span (set Bo)", "then"], ["proof (chain)\npicking this:\n  adjuster d v Bo + v = 0\\<^sub>v d", "show \"adjuster d v Bo = - v\""], ["proof (prove)\nusing this:\n  adjuster d v Bo + v = 0\\<^sub>v d\n\ngoal (1 subgoal):\n 1. adjuster d v Bo = - v", "using Av_carrier Bo_carrier \\<open>v \\<in> set Av\\<close>"], ["proof (prove)\nusing this:\n  adjuster d v Bo + v = 0\\<^sub>v d\n  set Av \\<subseteq> carrier_vec d\n  set Bo \\<subseteq> carrier_vec d\n  v \\<in> set Av\n\ngoal (1 subgoal):\n 1. adjuster d v Bo = - v", "by (metis (no_types, lifting) add.inv_equality adjuster_carrier' local.vec_neg subsetD)"], ["proof (state)\nthis:\n  adjuster d v Bo = - v\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set Av. adjuster d v Bo = - v \\<Longrightarrow>\n    local.span (set Av) \\<subseteq> local.span (set Bo)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set Av. adjuster d v Bo = - v \\<Longrightarrow>\n    local.span (set Av) \\<subseteq> local.span (set Bo)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set Av. adjuster d v Bo = - v \\<Longrightarrow>\n    local.span (set Av) \\<subseteq> local.span (set Bo)", "assume adj_minusv: \"\\<forall>v\\<in>set Av. adjuster d v Bo = - v\""], ["proof (state)\nthis:\n  \\<forall>v\\<in>set Av. adjuster d v Bo = - v\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set Av. adjuster d v Bo = - v \\<Longrightarrow>\n    local.span (set Av) \\<subseteq> local.span (set Bo)", "have *: \"adjuster d v Bo \\<in> span (set Bo)\" if \"v \\<in> set Av\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. adjuster d v Bo \\<in> local.span (set Bo)", "apply (rule adjuster_in_span)"], ["proof (prove)\ngoal (3 subgoals):\n 1. v \\<in> carrier_vec d\n 2. set Bo \\<subseteq> carrier_vec d\n 3. distinct Bo", "using Bo_carrier that Av_carrier distinct_Bo"], ["proof (prove)\nusing this:\n  set Bo \\<subseteq> carrier_vec d\n  v \\<in> set Av\n  set Av \\<subseteq> carrier_vec d\n  distinct Bo\n\ngoal (3 subgoals):\n 1. v \\<in> carrier_vec d\n 2. set Bo \\<subseteq> carrier_vec d\n 3. distinct Bo", "by auto"], ["proof (state)\nthis:\n  ?v1 \\<in> set Av \\<Longrightarrow>\n  adjuster d ?v1 Bo \\<in> local.span (set Bo)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set Av. adjuster d v Bo = - v \\<Longrightarrow>\n    local.span (set Av) \\<subseteq> local.span (set Bo)", "have \"v \\<in> span (set Bo)\" if \"v \\<in> set Av\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> local.span (set Bo)", "using *[OF that] adj_minusv[rule_format, OF that]"], ["proof (prove)\nusing this:\n  adjuster d v Bo \\<in> local.span (set Bo)\n  adjuster d v Bo = - v\n\ngoal (1 subgoal):\n 1. v \\<in> local.span (set Bo)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>- v \\<in> local.span (set Bo); adjuster d v Bo = - v\\<rbrakk>\n    \\<Longrightarrow> v \\<in> local.span (set Bo)", "by (metis (no_types, lifting) Av_carrier Bo_carrier adjust_nonzero distinct_Bo subsetD that uminus_l_inv_vec)"], ["proof (state)\nthis:\n  ?v1 \\<in> set Av \\<Longrightarrow> ?v1 \\<in> local.span (set Bo)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set Av. adjuster d v Bo = - v \\<Longrightarrow>\n    local.span (set Av) \\<subseteq> local.span (set Bo)", "then"], ["proof (chain)\npicking this:\n  ?v1 \\<in> set Av \\<Longrightarrow> ?v1 \\<in> local.span (set Bo)", "show \"span (set Av) \\<subseteq> span (set Bo)\""], ["proof (prove)\nusing this:\n  ?v1 \\<in> set Av \\<Longrightarrow> ?v1 \\<in> local.span (set Bo)\n\ngoal (1 subgoal):\n 1. local.span (set Av) \\<subseteq> local.span (set Bo)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>v.\n                   v \\<in> set Av \\<Longrightarrow>\n                   v \\<in> local.span (set Bo);\n        x \\<in> local.span (set Av)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.span (set Bo)", "by (meson Bo_carrier in_mono span_subsetI subsetI)"], ["proof (state)\nthis:\n  local.span (set Av) \\<subseteq> local.span (set Bo)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (local.span (set Av) \\<subseteq> local.span (set Bo)) =\n  (\\<forall>v\\<in>set Av. adjuster d v Bo = - v)\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "also"], ["proof (state)\nthis:\n  (local.span (set Av) \\<subseteq> local.span (set Bo)) =\n  (\\<forall>v\\<in>set Av. adjuster d v Bo = - v)\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "have \"\\<dots> = is_subspace_of_vec_list d Av Bv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>v\\<in>set Av. adjuster d v Bo = - v) =\n    is_subspace_of_vec_list d Av Bv", "by (simp add: is_subspace_of_vec_list_def d_def Bo_def)"], ["proof (state)\nthis:\n  (\\<forall>v\\<in>set Av. adjuster d v Bo = - v) =\n  is_subspace_of_vec_list d Av Bv\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) =\n    is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum A) (map vec_of_basis_enum B)", "finally"], ["proof (chain)\npicking this:\n  (ccspan (set A) \\<le> ccspan (set B)) = is_subspace_of_vec_list d Av Bv", "show \"ccspan (set A) \\<le> ccspan (set B) \\<longleftrightarrow> is_subspace_of_vec_list d Av Bv\""], ["proof (prove)\nusing this:\n  (ccspan (set A) \\<le> ccspan (set B)) = is_subspace_of_vec_list d Av Bv\n\ngoal (1 subgoal):\n 1. (ccspan (set A) \\<le> ccspan (set B)) = is_subspace_of_vec_list d Av Bv", "by simp"], ["proof (state)\nthis:\n  (ccspan (set A) \\<le> ccspan (set B)) = is_subspace_of_vec_list d Av Bv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_apply_ccspan_using_vec: \n  \"A *\\<^sub>S ccspan (set S) = ccspan (basis_enum_of_vec ` set (map ((*\\<^sub>v) (mat_of_cblinfun A)) (map vec_of_basis_enum S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>S ccspan (set S) =\n    ccspan\n     (basis_enum_of_vec `\n      set (map ((*\\<^sub>v) (mat_of_cblinfun A)) (map vec_of_basis_enum S)))", "apply (auto simp: cblinfun_image_ccspan image_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan ((*\\<^sub>V) A ` set S) =\n    ccspan\n     ((\\<lambda>x.\n          basis_enum_of_vec\n           (mat_of_cblinfun A *\\<^sub>v vec_of_basis_enum x)) `\n      set S)", "by (metis mat_of_cblinfun_cblinfun_apply vec_of_basis_enum_inverse)"], ["", "text \\<open>\\<^term>\\<open>mk_projector_orthog d L\\<close> takes a list L of d-dimensional vectors\nand returns the projector onto the span of L. (Assuming that all vectors in L are \northogonal and nonzero.)\\<close>"], ["", "fun mk_projector_orthog :: \"nat \\<Rightarrow> complex vec list \\<Rightarrow> complex mat\" where\n  \"mk_projector_orthog d [] = zero_mat d d\"\n| \"mk_projector_orthog d [v] = (let norm2 = cscalar_prod v v in\n                                smult_mat (1/norm2) (mat_of_cols d [v] * mat_of_rows d [conjugate v]))\"\n| \"mk_projector_orthog d (v#vs) = (let norm2 = cscalar_prod v v in\n                                   smult_mat (1/norm2) (mat_of_cols d [v] * mat_of_rows d [conjugate v]) \n                                        + mk_projector_orthog d vs)\""], ["", "lemma mk_projector_orthog_correct:\n  fixes S :: \"'a::onb_enum list\"\n  defines \"d \\<equiv> length (canonical_basis :: 'a list)\"\n  assumes ortho: \"is_ortho_set (set S)\" and distinct: \"distinct S\"\n  shows \"mk_projector_orthog d (map vec_of_basis_enum S) \n       = mat_of_cblinfun (Proj (ccspan (set S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "define Snorm where \"Snorm = map (\\<lambda>s. s /\\<^sub>R norm s) S\""], ["proof (state)\nthis:\n  Snorm = map (\\<lambda>s. s /\\<^sub>R norm s) S\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "have \"distinct Snorm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct Snorm", "proof (insert ortho distinct, unfold Snorm_def, induction S)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_ortho_set (set []); distinct []\\<rbrakk>\n    \\<Longrightarrow> distinct (map (\\<lambda>s. s /\\<^sub>R norm s) [])\n 2. \\<And>a S.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>s. s /\\<^sub>R norm s) S);\n        is_ortho_set (set (a # S)); distinct (a # S)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))", "case Nil"], ["proof (state)\nthis:\n  is_ortho_set (set [])\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_ortho_set (set []); distinct []\\<rbrakk>\n    \\<Longrightarrow> distinct (map (\\<lambda>s. s /\\<^sub>R norm s) [])\n 2. \\<And>a S.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>s. s /\\<^sub>R norm s) S);\n        is_ortho_set (set (a # S)); distinct (a # S)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>s. s /\\<^sub>R norm s) [])", "by simp"], ["proof (state)\nthis:\n  distinct (map (\\<lambda>s. s /\\<^sub>R norm s) [])\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>s. s /\\<^sub>R norm s) S);\n        is_ortho_set (set (a # S)); distinct (a # S)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a S.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>s. s /\\<^sub>R norm s) S);\n        is_ortho_set (set (a # S)); distinct (a # S)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))", "case (Cons s S)"], ["proof (state)\nthis:\n  \\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n  \\<Longrightarrow> distinct (map (\\<lambda>s. s /\\<^sub>R norm s) S)\n  is_ortho_set (set (s # S))\n  distinct (s # S)\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>s. s /\\<^sub>R norm s) S);\n        is_ortho_set (set (a # S)); distinct (a # S)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n  \\<Longrightarrow> distinct (map (\\<lambda>s. s /\\<^sub>R norm s) S)\n  is_ortho_set (set (s # S))\n  distinct (s # S)", "have \"is_ortho_set (set S)\" and \"distinct S\""], ["proof (prove)\nusing this:\n  \\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n  \\<Longrightarrow> distinct (map (\\<lambda>s. s /\\<^sub>R norm s) S)\n  is_ortho_set (set (s # S))\n  distinct (s # S)\n\ngoal (1 subgoal):\n 1. is_ortho_set (set S) &&& distinct S", "unfolding is_ortho_set_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<forall>x\\<in>set S.\n               \\<forall>y\\<in>set S.\n                  x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n           (0::'a) \\<notin> set S;\n   distinct S\\<rbrakk>\n  \\<Longrightarrow> distinct (map (\\<lambda>s. s /\\<^sub>R norm s) S)\n  (\\<forall>x\\<in>set (s # S).\n      \\<forall>y\\<in>set (s # S).\n         x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n  (0::'a) \\<notin> set (s # S)\n  distinct (s # S)\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set S.\n        \\<forall>y\\<in>set S.\n           x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n    (0::'a) \\<notin> set S &&&\n    distinct S", "by auto"], ["proof (state)\nthis:\n  is_ortho_set (set S)\n  distinct S\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>s. s /\\<^sub>R norm s) S);\n        is_ortho_set (set (a # S)); distinct (a # S)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))", "note IH = Cons.IH[OF this]"], ["proof (state)\nthis:\n  distinct (map (\\<lambda>s. s /\\<^sub>R norm s) S)\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>s. s /\\<^sub>R norm s) S);\n        is_ortho_set (set (a # S)); distinct (a # S)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))", "have \"s /\\<^sub>R norm s \\<notin> (\\<lambda>s. s /\\<^sub>R norm s) ` set S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s /\\<^sub>R norm s \\<notin> (\\<lambda>s. s /\\<^sub>R norm s) ` set S", "proof auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>s /\\<^sub>R norm s = sa /\\<^sub>R norm sa;\n        sa \\<in> set S\\<rbrakk>\n       \\<Longrightarrow> False", "fix s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>s /\\<^sub>R norm s = sa /\\<^sub>R norm sa;\n        sa \\<in> set S\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"s' \\<in> set S\" and same: \"s /\\<^sub>R norm s = s' /\\<^sub>R norm s'\""], ["proof (state)\nthis:\n  s' \\<in> set S\n  s /\\<^sub>R norm s = s' /\\<^sub>R norm s'\n\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>s /\\<^sub>R norm s = sa /\\<^sub>R norm sa;\n        sa \\<in> set S\\<rbrakk>\n       \\<Longrightarrow> False", "with Cons.prems"], ["proof (chain)\npicking this:\n  is_ortho_set (set (s # S))\n  distinct (s # S)\n  s' \\<in> set S\n  s /\\<^sub>R norm s = s' /\\<^sub>R norm s'", "have \"s \\<noteq> s'\""], ["proof (prove)\nusing this:\n  is_ortho_set (set (s # S))\n  distinct (s # S)\n  s' \\<in> set S\n  s /\\<^sub>R norm s = s' /\\<^sub>R norm s'\n\ngoal (1 subgoal):\n 1. s \\<noteq> s'", "by auto"], ["proof (state)\nthis:\n  s \\<noteq> s'\n\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>s /\\<^sub>R norm s = sa /\\<^sub>R norm sa;\n        sa \\<in> set S\\<rbrakk>\n       \\<Longrightarrow> False", "have \"s \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> (0::'a)", "by (metis Cons.prems(1) is_ortho_set_def list.set_intros(1))"], ["proof (state)\nthis:\n  s \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>s /\\<^sub>R norm s = sa /\\<^sub>R norm sa;\n        sa \\<in> set S\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  s \\<noteq> (0::'a)", "have \"0 \\<noteq> \\<langle>s /\\<^sub>R norm s, s /\\<^sub>R norm s\\<rangle>\""], ["proof (prove)\nusing this:\n  s \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 0 \\<noteq> (s /\\<^sub>R norm s) \\<bullet>\\<^sub>C (s /\\<^sub>R norm s)", "by simp"], ["proof (state)\nthis:\n  0 \\<noteq> (s /\\<^sub>R norm s) \\<bullet>\\<^sub>C (s /\\<^sub>R norm s)\n\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>s /\\<^sub>R norm s = sa /\\<^sub>R norm sa;\n        sa \\<in> set S\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  0 \\<noteq> (s /\\<^sub>R norm s) \\<bullet>\\<^sub>C (s /\\<^sub>R norm s)\n\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>s /\\<^sub>R norm s = sa /\\<^sub>R norm sa;\n        sa \\<in> set S\\<rbrakk>\n       \\<Longrightarrow> False", "have \\<open>\\<langle>s /\\<^sub>R norm s, s /\\<^sub>R norm s\\<rangle> = \\<langle>s /\\<^sub>R norm s, s' /\\<^sub>R norm s'\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s /\\<^sub>R norm s) \\<bullet>\\<^sub>C (s /\\<^sub>R norm s) =\n    (s /\\<^sub>R norm s) \\<bullet>\\<^sub>C (s' /\\<^sub>R norm s')", "by (simp add: same)"], ["proof (state)\nthis:\n  (s /\\<^sub>R norm s) \\<bullet>\\<^sub>C (s /\\<^sub>R norm s) =\n  (s /\\<^sub>R norm s) \\<bullet>\\<^sub>C (s' /\\<^sub>R norm s')\n\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>s /\\<^sub>R norm s = sa /\\<^sub>R norm sa;\n        sa \\<in> set S\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (s /\\<^sub>R norm s) \\<bullet>\\<^sub>C (s /\\<^sub>R norm s) =\n  (s /\\<^sub>R norm s) \\<bullet>\\<^sub>C (s' /\\<^sub>R norm s')\n\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>s /\\<^sub>R norm s = sa /\\<^sub>R norm sa;\n        sa \\<in> set S\\<rbrakk>\n       \\<Longrightarrow> False", "have \\<open>\\<langle>s /\\<^sub>R norm s, s' /\\<^sub>R norm s'\\<rangle> = \\<langle>s, s'\\<rangle> / (norm s * norm s')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s /\\<^sub>R norm s) \\<bullet>\\<^sub>C (s' /\\<^sub>R norm s') =\n    s \\<bullet>\\<^sub>C s' / complex_of_real (norm s * norm s')", "by (simp add: scaleR_scaleC divide_inverse_commute)"], ["proof (state)\nthis:\n  (s /\\<^sub>R norm s) \\<bullet>\\<^sub>C (s' /\\<^sub>R norm s') =\n  s \\<bullet>\\<^sub>C s' / complex_of_real (norm s * norm s')\n\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>s /\\<^sub>R norm s = sa /\\<^sub>R norm sa;\n        sa \\<in> set S\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (s /\\<^sub>R norm s) \\<bullet>\\<^sub>C (s' /\\<^sub>R norm s') =\n  s \\<bullet>\\<^sub>C s' / complex_of_real (norm s * norm s')\n\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>s /\\<^sub>R norm s = sa /\\<^sub>R norm sa;\n        sa \\<in> set S\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>s' \\<in> set S\\<close> \\<open>s \\<noteq> s'\\<close>"], ["proof (chain)\npicking this:\n  s' \\<in> set S\n  s \\<noteq> s'", "have \"\\<dots> = 0\""], ["proof (prove)\nusing this:\n  s' \\<in> set S\n  s \\<noteq> s'\n\ngoal (1 subgoal):\n 1. s \\<bullet>\\<^sub>C s' / complex_of_real (norm s * norm s') = 0", "using Cons.prems"], ["proof (prove)\nusing this:\n  s' \\<in> set S\n  s \\<noteq> s'\n  is_ortho_set (set (s # S))\n  distinct (s # S)\n\ngoal (1 subgoal):\n 1. s \\<bullet>\\<^sub>C s' / complex_of_real (norm s * norm s') = 0", "unfolding is_ortho_set_def"], ["proof (prove)\nusing this:\n  s' \\<in> set S\n  s \\<noteq> s'\n  (\\<forall>x\\<in>set (s # S).\n      \\<forall>y\\<in>set (s # S).\n         x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n  (0::'a) \\<notin> set (s # S)\n  distinct (s # S)\n\ngoal (1 subgoal):\n 1. s \\<bullet>\\<^sub>C s' / complex_of_real (norm s * norm s') = 0", "by simp"], ["proof (state)\nthis:\n  s \\<bullet>\\<^sub>C s' / complex_of_real (norm s * norm s') = 0\n\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>s /\\<^sub>R norm s = sa /\\<^sub>R norm sa;\n        sa \\<in> set S\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  0 \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s /\\<^sub>R norm s \\<notin> (\\<lambda>s. s /\\<^sub>R norm s) ` set S\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set S); distinct S\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>s. s /\\<^sub>R norm s) S);\n        is_ortho_set (set (a # S)); distinct (a # S)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))", "then"], ["proof (chain)\npicking this:\n  s /\\<^sub>R norm s \\<notin> (\\<lambda>s. s /\\<^sub>R norm s) ` set S", "show ?case"], ["proof (prove)\nusing this:\n  s /\\<^sub>R norm s \\<notin> (\\<lambda>s. s /\\<^sub>R norm s) ` set S\n\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>s. s /\\<^sub>R norm s) (s # S))", "using IH"], ["proof (prove)\nusing this:\n  s /\\<^sub>R norm s \\<notin> (\\<lambda>s. s /\\<^sub>R norm s) ` set S\n  distinct (map (\\<lambda>s. s /\\<^sub>R norm s) S)\n\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>s. s /\\<^sub>R norm s) (s # S))", "by simp"], ["proof (state)\nthis:\n  distinct (map (\\<lambda>s. s /\\<^sub>R norm s) (s # S))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct Snorm\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "have norm_Snorm: \"norm s = 1\" if \"s \\<in> set Snorm\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm s = 1", "using that ortho"], ["proof (prove)\nusing this:\n  s \\<in> set Snorm\n  is_ortho_set (set S)\n\ngoal (1 subgoal):\n 1. norm s = 1", "unfolding Snorm_def is_ortho_set_def"], ["proof (prove)\nusing this:\n  s \\<in> set (map (\\<lambda>s. s /\\<^sub>R norm s) S)\n  (\\<forall>x\\<in>set S.\n      \\<forall>y\\<in>set S.\n         x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n  (0::'a) \\<notin> set S\n\ngoal (1 subgoal):\n 1. norm s = 1", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa.\n       \\<lbrakk>sa \\<in> set S; s = sa /\\<^sub>R norm sa;\n        \\<forall>x\\<in>set S.\n           \\<forall>y\\<in>set S.\n              x \\<noteq> y \\<longrightarrow> is_orthogonal x y;\n        (0::'a) \\<notin> set S\\<rbrakk>\n       \\<Longrightarrow> inverse (norm sa) * norm sa = 1", "by (metis left_inverse norm_eq_zero)"], ["proof (state)\nthis:\n  ?s \\<in> set Snorm \\<Longrightarrow> norm ?s = 1\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "have ortho_Snorm: \"is_ortho_set (set Snorm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ortho_set (set Snorm)", "unfolding is_ortho_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set Snorm.\n        \\<forall>y\\<in>set Snorm.\n           x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n    (0::'a) \\<notin> set Snorm", "proof (intro conjI ballI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal x y\n 2. (0::'a) \\<notin> set Snorm", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal x y\n 2. (0::'a) \\<notin> set Snorm", "show \"0 \\<notin> set Snorm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<notin> set Snorm", "using norm_Snorm[of 0]"], ["proof (prove)\nusing this:\n  (0::'a) \\<in> set Snorm \\<Longrightarrow> norm (0::'a) = 1\n\ngoal (1 subgoal):\n 1. (0::'a) \\<notin> set Snorm", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<notin> set Snorm\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal x y", "assume \"x \\<in> set Snorm\" and \"y \\<in> set Snorm\" and \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<in> set Snorm\n  y \\<in> set Snorm\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal x y", "from \\<open>x \\<in> set Snorm\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set Snorm", "obtain x' where x: \"x = x' /\\<^sub>R norm x'\" and x': \"x' \\<in> set S\""], ["proof (prove)\nusing this:\n  x \\<in> set Snorm\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x = x' /\\<^sub>R norm x'; x' \\<in> set S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Snorm_def"], ["proof (prove)\nusing this:\n  x \\<in> set (map (\\<lambda>s. s /\\<^sub>R norm s) S)\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x = x' /\\<^sub>R norm x'; x' \\<in> set S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = x' /\\<^sub>R norm x'\n  x' \\<in> set S\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal x y", "from \\<open>y \\<in> set Snorm\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> set Snorm", "obtain y' where y: \"y = y' /\\<^sub>R norm y'\" and y': \"y' \\<in> set S\""], ["proof (prove)\nusing this:\n  y \\<in> set Snorm\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>y = y' /\\<^sub>R norm y'; y' \\<in> set S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Snorm_def"], ["proof (prove)\nusing this:\n  y \\<in> set (map (\\<lambda>s. s /\\<^sub>R norm s) S)\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>y = y' /\\<^sub>R norm y'; y' \\<in> set S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = y' /\\<^sub>R norm y'\n  y' \\<in> set S\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal x y", "from \\<open>x \\<noteq> y\\<close> x y"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  x = x' /\\<^sub>R norm x'\n  y = y' /\\<^sub>R norm y'", "have \\<open>x' \\<noteq> y'\\<close>"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x = x' /\\<^sub>R norm x'\n  y = y' /\\<^sub>R norm y'\n\ngoal (1 subgoal):\n 1. x' \\<noteq> y'", "by auto"], ["proof (state)\nthis:\n  x' \\<noteq> y'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal x y", "with x' y' ortho"], ["proof (chain)\npicking this:\n  x' \\<in> set S\n  y' \\<in> set S\n  is_ortho_set (set S)\n  x' \\<noteq> y'", "have \"cinner x' y' = 0\""], ["proof (prove)\nusing this:\n  x' \\<in> set S\n  y' \\<in> set S\n  is_ortho_set (set S)\n  x' \\<noteq> y'\n\ngoal (1 subgoal):\n 1. is_orthogonal x' y'", "unfolding is_ortho_set_def"], ["proof (prove)\nusing this:\n  x' \\<in> set S\n  y' \\<in> set S\n  (\\<forall>x\\<in>set S.\n      \\<forall>y\\<in>set S.\n         x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n  (0::'a) \\<notin> set S\n  x' \\<noteq> y'\n\ngoal (1 subgoal):\n 1. is_orthogonal x' y'", "by auto"], ["proof (state)\nthis:\n  is_orthogonal x' y'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal x y", "then"], ["proof (chain)\npicking this:\n  is_orthogonal x' y'", "show \"cinner x y = 0\""], ["proof (prove)\nusing this:\n  is_orthogonal x' y'\n\ngoal (1 subgoal):\n 1. is_orthogonal x y", "unfolding x y scaleR_scaleC"], ["proof (prove)\nusing this:\n  is_orthogonal x' y'\n\ngoal (1 subgoal):\n 1. is_orthogonal (complex_of_real (inverse (norm x')) *\\<^sub>C x')\n     (complex_of_real (inverse (norm y')) *\\<^sub>C y')", "by auto"], ["proof (state)\nthis:\n  is_orthogonal x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_ortho_set (set Snorm)\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "have inj_butter: \"inj_on selfbutter (set Snorm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on selfbutter (set Snorm)", "proof (rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm;\n        selfbutter x = selfbutter y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm;\n        selfbutter x = selfbutter y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> set Snorm\" and \"y \\<in> set Snorm\""], ["proof (state)\nthis:\n  x \\<in> set Snorm\n  y \\<in> set Snorm\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm;\n        selfbutter x = selfbutter y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"selfbutter x = selfbutter y\""], ["proof (state)\nthis:\n  selfbutter x = selfbutter y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm;\n        selfbutter x = selfbutter y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  selfbutter x = selfbutter y", "obtain c where xcy: \"x = c *\\<^sub>C y\" and \"cmod c = 1\""], ["proof (prove)\nusing this:\n  selfbutter x = selfbutter y\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>x = c *\\<^sub>C y; cmod c = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inj_selfbutter_upto_phase"], ["proof (prove)\nusing this:\n  selfbutter x = selfbutter y\n  selfbutter ?x = selfbutter ?y \\<Longrightarrow>\n  \\<exists>c. cmod c = 1 \\<and> ?x = c *\\<^sub>C ?y\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>x = c *\\<^sub>C y; cmod c = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = c *\\<^sub>C y\n  cmod c = 1\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm;\n        selfbutter x = selfbutter y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"0 \\<noteq> cmod (cinner x x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> cmod (x \\<bullet>\\<^sub>C x)", "using \\<open>x \\<in> set Snorm\\<close> norm_Snorm"], ["proof (prove)\nusing this:\n  x \\<in> set Snorm\n  ?s \\<in> set Snorm \\<Longrightarrow> norm ?s = 1\n\ngoal (1 subgoal):\n 1. 0 \\<noteq> cmod (x \\<bullet>\\<^sub>C x)", "by force"], ["proof (state)\nthis:\n  0 \\<noteq> cmod (x \\<bullet>\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm;\n        selfbutter x = selfbutter y\\<rbrakk>\n       \\<Longrightarrow> x = y", "also"], ["proof (state)\nthis:\n  0 \\<noteq> cmod (x \\<bullet>\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm;\n        selfbutter x = selfbutter y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"cmod (cinner x x) = cmod (c * \\<langle>x, y\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (x \\<bullet>\\<^sub>C x) = cmod (c * (x \\<bullet>\\<^sub>C y))", "apply (subst (2) xcy)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (x \\<bullet>\\<^sub>C c *\\<^sub>C y) =\n    cmod (c * (x \\<bullet>\\<^sub>C y))", "by simp"], ["proof (state)\nthis:\n  cmod (x \\<bullet>\\<^sub>C x) = cmod (c * (x \\<bullet>\\<^sub>C y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm;\n        selfbutter x = selfbutter y\\<rbrakk>\n       \\<Longrightarrow> x = y", "also"], ["proof (state)\nthis:\n  cmod (x \\<bullet>\\<^sub>C x) = cmod (c * (x \\<bullet>\\<^sub>C y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm;\n        selfbutter x = selfbutter y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"\\<dots> = cmod \\<langle>x, y\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (c * (x \\<bullet>\\<^sub>C y)) = cmod (x \\<bullet>\\<^sub>C y)", "using \\<open>cmod c = 1\\<close>"], ["proof (prove)\nusing this:\n  cmod c = 1\n\ngoal (1 subgoal):\n 1. cmod (c * (x \\<bullet>\\<^sub>C y)) = cmod (x \\<bullet>\\<^sub>C y)", "by (simp add: norm_mult)"], ["proof (state)\nthis:\n  cmod (c * (x \\<bullet>\\<^sub>C y)) = cmod (x \\<bullet>\\<^sub>C y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm;\n        selfbutter x = selfbutter y\\<rbrakk>\n       \\<Longrightarrow> x = y", "finally"], ["proof (chain)\npicking this:\n  0 \\<noteq> cmod (x \\<bullet>\\<^sub>C y)", "have \"\\<langle>x, y\\<rangle> \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 \\<noteq> cmod (x \\<bullet>\\<^sub>C y)\n\ngoal (1 subgoal):\n 1. x \\<bullet>\\<^sub>C y \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  x \\<bullet>\\<^sub>C y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set Snorm; y \\<in> set Snorm;\n        selfbutter x = selfbutter y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x \\<bullet>\\<^sub>C y \\<noteq> 0", "show \"x = y\""], ["proof (prove)\nusing this:\n  x \\<bullet>\\<^sub>C y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x = y", "using ortho_Snorm \\<open>x \\<in> set Snorm\\<close> \\<open>y \\<in> set Snorm\\<close>"], ["proof (prove)\nusing this:\n  x \\<bullet>\\<^sub>C y \\<noteq> 0\n  is_ortho_set (set Snorm)\n  x \\<in> set Snorm\n  y \\<in> set Snorm\n\ngoal (1 subgoal):\n 1. x = y", "unfolding is_ortho_set_def"], ["proof (prove)\nusing this:\n  x \\<bullet>\\<^sub>C y \\<noteq> 0\n  (\\<forall>x\\<in>set Snorm.\n      \\<forall>y\\<in>set Snorm.\n         x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n  (0::'a) \\<notin> set Snorm\n  x \\<in> set Snorm\n  y \\<in> set Snorm\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on selfbutter (set Snorm)\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "from \\<open>distinct Snorm\\<close> inj_butter"], ["proof (chain)\npicking this:\n  distinct Snorm\n  inj_on selfbutter (set Snorm)", "have distinct': \"distinct (map selfbutter Snorm)\""], ["proof (prove)\nusing this:\n  distinct Snorm\n  inj_on selfbutter (set Snorm)\n\ngoal (1 subgoal):\n 1. distinct (map selfbutter Snorm)", "unfolding distinct_map"], ["proof (prove)\nusing this:\n  distinct Snorm\n  inj_on selfbutter (set Snorm)\n\ngoal (1 subgoal):\n 1. distinct Snorm \\<and> inj_on selfbutter (set Snorm)", "by simp"], ["proof (state)\nthis:\n  distinct (map selfbutter Snorm)\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "have Span_Snorm: \"ccspan (set Snorm) = ccspan (set S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan (set Snorm) = ccspan (set S)", "apply (transfer fixing: Snorm S)"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (cspan (set Snorm)) = closure (cspan (set S))", "apply (simp add: scaleR_scaleC Snorm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan ((\\<lambda>s. s /\\<^sub>C complex_of_real (norm s)) ` set S) =\n    cspan (set S)", "apply (subst complex_vector.span_image_scale)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (set S)\n 2. \\<And>x.\n       x \\<in> set S \\<Longrightarrow>\n       inverse (complex_of_real (norm x)) \\<noteq> 0\n 3. cspan (set S) = cspan (set S)", "using is_ortho_set_def ortho"], ["proof (prove)\nusing this:\n  is_ortho_set ?S =\n  ((\\<forall>x\\<in>?S.\n       \\<forall>y\\<in>?S.\n          x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n   (0::?'a) \\<notin> ?S)\n  is_ortho_set (set S)\n\ngoal (3 subgoals):\n 1. finite (set S)\n 2. \\<And>x.\n       x \\<in> set S \\<Longrightarrow>\n       inverse (complex_of_real (norm x)) \\<noteq> 0\n 3. cspan (set S) = cspan (set S)", "by fastforce+"], ["proof (state)\nthis:\n  ccspan (set Snorm) = ccspan (set S)\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "have \"mk_projector_orthog d (map vec_of_basis_enum S)\n      = mat_of_cblinfun (sum_list (map selfbutter Snorm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (sum_list (map selfbutter Snorm))", "unfolding Snorm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun\n     (sum_list (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) S)))", "proof (induction S)"], ["proof (state)\ngoal (2 subgoals):\n 1. mk_projector_orthog d (map vec_of_basis_enum []) =\n    mat_of_cblinfun\n     (sum_list (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) [])))\n 2. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. mk_projector_orthog d (map vec_of_basis_enum []) =\n    mat_of_cblinfun\n     (sum_list (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) [])))\n 2. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum []) =\n    mat_of_cblinfun\n     (sum_list (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) [])))", "by (simp add: d_def mat_of_cblinfun_zero)"], ["proof (state)\nthis:\n  mk_projector_orthog d (map vec_of_basis_enum []) =\n  mat_of_cblinfun\n   (sum_list (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) [])))\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "case (Cons a S)"], ["proof (state)\nthis:\n  mk_projector_orthog d (map vec_of_basis_enum S) =\n  mat_of_cblinfun\n   (sum_list (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) S)))\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "define sumS where \"sumS = sum_list (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) S))\""], ["proof (state)\nthis:\n  sumS = sum_list (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) S))\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "with Cons"], ["proof (chain)\npicking this:\n  mk_projector_orthog d (map vec_of_basis_enum S) =\n  mat_of_cblinfun\n   (sum_list (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) S)))\n  sumS = sum_list (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) S))", "have IH: \"mk_projector_orthog d (map vec_of_basis_enum S)\n                  = mat_of_cblinfun sumS\""], ["proof (prove)\nusing this:\n  mk_projector_orthog d (map vec_of_basis_enum S) =\n  mat_of_cblinfun\n   (sum_list (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) S)))\n  sumS = sum_list (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) S))\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) = mat_of_cblinfun sumS", "by simp"], ["proof (state)\nthis:\n  mk_projector_orthog d (map vec_of_basis_enum S) = mat_of_cblinfun sumS\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "define factor where \"factor = inverse ((complex_of_real (norm a))\\<^sup>2)\""], ["proof (state)\nthis:\n  factor = inverse ((complex_of_real (norm a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "have factor': \"factor = 1 / (vec_of_basis_enum a \\<bullet>c vec_of_basis_enum a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factor = 1 / (vec_of_basis_enum a \\<bullet>c vec_of_basis_enum a)", "unfolding factor_def cscalar_prod_vec_of_basis_enum"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse ((complex_of_real (norm a))\\<^sup>2) =\n    1 / (a \\<bullet>\\<^sub>C a)", "by (simp add: inverse_eq_divide power2_norm_eq_cinner)"], ["proof (state)\nthis:\n  factor = 1 / (vec_of_basis_enum a \\<bullet>c vec_of_basis_enum a)\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "have \"mk_projector_orthog d (map vec_of_basis_enum (a # S))\n          = factor \\<cdot>\\<^sub>m (mat_of_cols d [vec_of_basis_enum a] \n                    * mat_of_rows d [conjugate (vec_of_basis_enum a)])\n            + mat_of_cblinfun sumS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n    factor \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)]) +\n    mat_of_cblinfun sumS", "apply (cases S)"], ["proof (prove)\ngoal (2 subgoals):\n 1. S = [] \\<Longrightarrow>\n    mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n    factor \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)]) +\n    mat_of_cblinfun sumS\n 2. \\<And>aa list.\n       S = aa # list \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       factor \\<cdot>\\<^sub>m\n       (mat_of_cols d [vec_of_basis_enum a] *\n        mat_of_rows d [conjugate (vec_of_basis_enum a)]) +\n       mat_of_cblinfun sumS", "apply (auto simp add: factor' sumS_def d_def mat_of_cblinfun_zero)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       S = aa # list \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       factor \\<cdot>\\<^sub>m\n       (mat_of_cols d [vec_of_basis_enum a] *\n        mat_of_rows d [conjugate (vec_of_basis_enum a)]) +\n       mat_of_cblinfun sumS", "by (auto simp add: IH[symmetric] factor' d_def)"], ["proof (state)\nthis:\n  mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n  factor \\<cdot>\\<^sub>m\n  (mat_of_cols d [vec_of_basis_enum a] *\n   mat_of_rows d [conjugate (vec_of_basis_enum a)]) +\n  mat_of_cblinfun sumS\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "also"], ["proof (state)\nthis:\n  mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n  factor \\<cdot>\\<^sub>m\n  (mat_of_cols d [vec_of_basis_enum a] *\n   mat_of_rows d [conjugate (vec_of_basis_enum a)]) +\n  mat_of_cblinfun sumS\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "have \"\\<dots> = factor \\<cdot>\\<^sub>m (mat_of_cols d [vec_of_basis_enum a] *\n         mat_adjoint (mat_of_cols d [vec_of_basis_enum a])) + mat_of_cblinfun sumS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factor \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_of_rows d [conjugate (vec_of_basis_enum a)]) +\n    mat_of_cblinfun sumS =\n    factor \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_adjoint (mat_of_cols d [vec_of_basis_enum a])) +\n    mat_of_cblinfun sumS", "apply (rule arg_cong[where f=\"\\<lambda>x. _ \\<cdot>\\<^sub>m (_ * x) + _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_rows d [conjugate (vec_of_basis_enum a)] =\n    mat_adjoint (mat_of_cols d [vec_of_basis_enum a])", "apply (rule mat_eq_iff[THEN iffD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (mat_of_rows d [conjugate (vec_of_basis_enum a)]) =\n    dim_row (mat_adjoint (mat_of_cols d [vec_of_basis_enum a])) \\<and>\n    dim_col (mat_of_rows d [conjugate (vec_of_basis_enum a)]) =\n    dim_col (mat_adjoint (mat_of_cols d [vec_of_basis_enum a])) \\<and>\n    (\\<forall>i j.\n        i < dim_row\n             (mat_adjoint\n               (mat_of_cols d [vec_of_basis_enum a])) \\<longrightarrow>\n        j < dim_col\n             (mat_adjoint\n               (mat_of_cols d [vec_of_basis_enum a])) \\<longrightarrow>\n        mat_of_rows d [conjugate (vec_of_basis_enum a)] $$ (i, j) =\n        mat_adjoint (mat_of_cols d [vec_of_basis_enum a]) $$ (i, j))", "apply (auto simp add: mat_adjoint_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < d \\<Longrightarrow>\n       mat_of_rows d [conjugate (vec_of_basis_enum a)] $$ (0, j) =\n       mat_of_rows d\n        (map conjugate (cols (mat_of_cols d [vec_of_basis_enum a]))) $$\n       (0, j)", "apply (subst mat_of_rows_index)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>j.\n       j < d \\<Longrightarrow> 0 < length [conjugate (vec_of_basis_enum a)]\n 2. \\<And>j. j < d \\<Longrightarrow> j < d\n 3. \\<And>j.\n       j < d \\<Longrightarrow>\n       [conjugate (vec_of_basis_enum a)] ! 0 $ j =\n       mat_of_rows d\n        (map conjugate (cols (mat_of_cols d [vec_of_basis_enum a]))) $$\n       (0, j)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < d \\<Longrightarrow>\n       conjugate (vec_of_basis_enum a) $ j =\n       mat_of_rows d\n        (map conjugate (cols (mat_of_cols d [vec_of_basis_enum a]))) $$\n       (0, j)", "apply (subst mat_of_rows_index)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>j.\n       j < d \\<Longrightarrow>\n       0 < length\n            (map conjugate (cols (mat_of_cols d [vec_of_basis_enum a])))\n 2. \\<And>j. j < d \\<Longrightarrow> j < d\n 3. \\<And>j.\n       j < d \\<Longrightarrow>\n       conjugate (vec_of_basis_enum a) $ j =\n       map conjugate (cols (mat_of_cols d [vec_of_basis_enum a])) ! 0 $ j", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < d \\<Longrightarrow>\n       conjugate (vec_of_basis_enum a) $ j =\n       cnj (mat_of_cols d [vec_of_basis_enum a] $$ (j, 0))", "apply (subst mat_of_cols_index)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>j. j < d \\<Longrightarrow> j < d\n 2. \\<And>j. j < d \\<Longrightarrow> 0 < length [vec_of_basis_enum a]\n 3. \\<And>j.\n       j < d \\<Longrightarrow>\n       conjugate (vec_of_basis_enum a) $ j =\n       cnj ([vec_of_basis_enum a] ! 0 $ j)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < d \\<Longrightarrow>\n       conjugate (vec_of_basis_enum a) $ j = cnj (vec_of_basis_enum a $ j)", "by (simp add: assms(1) dim_vec_of_basis_enum')"], ["proof (state)\nthis:\n  factor \\<cdot>\\<^sub>m\n  (mat_of_cols d [vec_of_basis_enum a] *\n   mat_of_rows d [conjugate (vec_of_basis_enum a)]) +\n  mat_of_cblinfun sumS =\n  factor \\<cdot>\\<^sub>m\n  (mat_of_cols d [vec_of_basis_enum a] *\n   mat_adjoint (mat_of_cols d [vec_of_basis_enum a])) +\n  mat_of_cblinfun sumS\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "also"], ["proof (state)\nthis:\n  factor \\<cdot>\\<^sub>m\n  (mat_of_cols d [vec_of_basis_enum a] *\n   mat_of_rows d [conjugate (vec_of_basis_enum a)]) +\n  mat_of_cblinfun sumS =\n  factor \\<cdot>\\<^sub>m\n  (mat_of_cols d [vec_of_basis_enum a] *\n   mat_adjoint (mat_of_cols d [vec_of_basis_enum a])) +\n  mat_of_cblinfun sumS\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "have \"\\<dots> = mat_of_cblinfun (selfbutter (a /\\<^sub>R norm a)) + mat_of_cblinfun sumS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factor \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_adjoint (mat_of_cols d [vec_of_basis_enum a])) +\n    mat_of_cblinfun sumS =\n    mat_of_cblinfun (selfbutter (a /\\<^sub>R norm a)) + mat_of_cblinfun sumS", "apply (simp add: butterfly_scaleR_left butterfly_scaleR_right power_inverse mat_of_cblinfun_scaleR factor_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse ((complex_of_real (norm a))\\<^sup>2) \\<cdot>\\<^sub>m\n    (mat_of_cols d [vec_of_basis_enum a] *\n     mat_adjoint (mat_of_cols d [vec_of_basis_enum a])) +\n    mat_of_cblinfun sumS =\n    mat_of_cblinfun\n     ((inverse (complex_of_real (norm a)) *\n       inverse (complex_of_real (norm a))) *\\<^sub>C\n      selfbutter a) +\n    mat_of_cblinfun sumS", "apply (simp add: butterfly_def mat_of_cblinfun_compose\n          mat_of_cblinfun_adj mat_of_cblinfun_vector_to_cblinfun d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse ((complex_of_real (norm a))\\<^sup>2) \\<cdot>\\<^sub>m\n    (mat_of_cols (length canonical_basis) [vec_of_basis_enum a] *\n     mat_adjoint\n      (mat_of_cols (length canonical_basis) [vec_of_basis_enum a])) +\n    mat_of_cblinfun sumS =\n    mat_of_cblinfun\n     ((inverse (complex_of_real (norm a)) *\n       inverse (complex_of_real (norm a))) *\\<^sub>C\n      (vector_to_cblinfun a o\\<^sub>C\\<^sub>L vector_to_cblinfun a*)) +\n    mat_of_cblinfun sumS", "by (simp add: mat_of_cblinfun_compose mat_of_cblinfun_adj mat_of_cblinfun_vector_to_cblinfun mat_of_cblinfun_scaleC power2_eq_square)"], ["proof (state)\nthis:\n  factor \\<cdot>\\<^sub>m\n  (mat_of_cols d [vec_of_basis_enum a] *\n   mat_adjoint (mat_of_cols d [vec_of_basis_enum a])) +\n  mat_of_cblinfun sumS =\n  mat_of_cblinfun (selfbutter (a /\\<^sub>R norm a)) + mat_of_cblinfun sumS\n\ngoal (1 subgoal):\n 1. \\<And>a S.\n       mk_projector_orthog d (map vec_of_basis_enum S) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter\n            (map (\\<lambda>s. s /\\<^sub>R norm s) S))) \\<Longrightarrow>\n       mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n       mat_of_cblinfun\n        (sum_list\n          (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "finally"], ["proof (chain)\npicking this:\n  mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n  mat_of_cblinfun (selfbutter (a /\\<^sub>R norm a)) + mat_of_cblinfun sumS", "show ?case"], ["proof (prove)\nusing this:\n  mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n  mat_of_cblinfun (selfbutter (a /\\<^sub>R norm a)) + mat_of_cblinfun sumS\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n    mat_of_cblinfun\n     (sum_list\n       (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))", "by (simp add: mat_of_cblinfun_plus sumS_def)"], ["proof (state)\nthis:\n  mk_projector_orthog d (map vec_of_basis_enum (a # S)) =\n  mat_of_cblinfun\n   (sum_list\n     (map selfbutter (map (\\<lambda>s. s /\\<^sub>R norm s) (a # S))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mk_projector_orthog d (map vec_of_basis_enum S) =\n  mat_of_cblinfun (sum_list (map selfbutter Snorm))\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "also"], ["proof (state)\nthis:\n  mk_projector_orthog d (map vec_of_basis_enum S) =\n  mat_of_cblinfun (sum_list (map selfbutter Snorm))\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "have \"\\<dots> = mat_of_cblinfun (\\<Sum>s\\<in>set Snorm. selfbutter s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (sum_list (map selfbutter Snorm)) =\n    mat_of_cblinfun (sum selfbutter (set Snorm))", "by (metis distinct' distinct_map sum.distinct_set_conv_list)"], ["proof (state)\nthis:\n  mat_of_cblinfun (sum_list (map selfbutter Snorm)) =\n  mat_of_cblinfun (sum selfbutter (set Snorm))\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "also"], ["proof (state)\nthis:\n  mat_of_cblinfun (sum_list (map selfbutter Snorm)) =\n  mat_of_cblinfun (sum selfbutter (set Snorm))\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "have \"\\<dots> = mat_of_cblinfun (\\<Sum>s\\<in>set Snorm. proj s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (sum selfbutter (set Snorm)) =\n    mat_of_cblinfun (sum proj (set Snorm))", "apply (rule arg_cong[where f=\"mat_of_cblinfun\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum selfbutter (set Snorm) = sum proj (set Snorm)", "apply (rule sum.cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set Snorm \\<Longrightarrow> selfbutter x = proj x", "apply (rule butterfly_eq_proj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set Snorm \\<Longrightarrow> norm x = 1", "using norm_Snorm"], ["proof (prove)\nusing this:\n  ?s \\<in> set Snorm \\<Longrightarrow> norm ?s = 1\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set Snorm \\<Longrightarrow> norm x = 1", "by simp"], ["proof (state)\nthis:\n  mat_of_cblinfun (sum selfbutter (set Snorm)) =\n  mat_of_cblinfun (sum proj (set Snorm))\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "also"], ["proof (state)\nthis:\n  mat_of_cblinfun (sum selfbutter (set Snorm)) =\n  mat_of_cblinfun (sum proj (set Snorm))\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "have \"\\<dots> = mat_of_cblinfun (Proj (ccspan (set Snorm)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (sum proj (set Snorm)) =\n    mat_of_cblinfun (Proj (ccspan (set Snorm)))", "apply (rule arg_cong[of _ _ mat_of_cblinfun])"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum proj (set Snorm) = Proj (ccspan (set Snorm))", "proof (insert ortho_Snorm, insert \\<open>distinct Snorm\\<close>, induction Snorm)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_ortho_set (set []); distinct []\\<rbrakk>\n    \\<Longrightarrow> sum proj (set []) = Proj (ccspan (set []))\n 2. \\<And>a Snorm.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set Snorm); distinct Snorm\\<rbrakk>\n                \\<Longrightarrow> sum proj (set Snorm) =\n                                  Proj (ccspan (set Snorm));\n        is_ortho_set (set (a # Snorm)); distinct (a # Snorm)\\<rbrakk>\n       \\<Longrightarrow> sum proj (set (a # Snorm)) =\n                         Proj (ccspan (set (a # Snorm)))", "case Nil"], ["proof (state)\nthis:\n  is_ortho_set (set [])\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_ortho_set (set []); distinct []\\<rbrakk>\n    \\<Longrightarrow> sum proj (set []) = Proj (ccspan (set []))\n 2. \\<And>a Snorm.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set Snorm); distinct Snorm\\<rbrakk>\n                \\<Longrightarrow> sum proj (set Snorm) =\n                                  Proj (ccspan (set Snorm));\n        is_ortho_set (set (a # Snorm)); distinct (a # Snorm)\\<rbrakk>\n       \\<Longrightarrow> sum proj (set (a # Snorm)) =\n                         Proj (ccspan (set (a # Snorm)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum proj (set []) = Proj (ccspan (set []))", "by simp"], ["proof (state)\nthis:\n  sum proj (set []) = Proj (ccspan (set []))\n\ngoal (1 subgoal):\n 1. \\<And>a Snorm.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set Snorm); distinct Snorm\\<rbrakk>\n                \\<Longrightarrow> sum proj (set Snorm) =\n                                  Proj (ccspan (set Snorm));\n        is_ortho_set (set (a # Snorm)); distinct (a # Snorm)\\<rbrakk>\n       \\<Longrightarrow> sum proj (set (a # Snorm)) =\n                         Proj (ccspan (set (a # Snorm)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Snorm.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set Snorm); distinct Snorm\\<rbrakk>\n                \\<Longrightarrow> sum proj (set Snorm) =\n                                  Proj (ccspan (set Snorm));\n        is_ortho_set (set (a # Snorm)); distinct (a # Snorm)\\<rbrakk>\n       \\<Longrightarrow> sum proj (set (a # Snorm)) =\n                         Proj (ccspan (set (a # Snorm)))", "case (Cons a Snorm)"], ["proof (state)\nthis:\n  \\<lbrakk>is_ortho_set (set Snorm); distinct Snorm\\<rbrakk>\n  \\<Longrightarrow> sum proj (set Snorm) = Proj (ccspan (set Snorm))\n  is_ortho_set (set (a # Snorm))\n  distinct (a # Snorm)\n\ngoal (1 subgoal):\n 1. \\<And>a Snorm.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set Snorm); distinct Snorm\\<rbrakk>\n                \\<Longrightarrow> sum proj (set Snorm) =\n                                  Proj (ccspan (set Snorm));\n        is_ortho_set (set (a # Snorm)); distinct (a # Snorm)\\<rbrakk>\n       \\<Longrightarrow> sum proj (set (a # Snorm)) =\n                         Proj (ccspan (set (a # Snorm)))", "from Cons.prems"], ["proof (chain)\npicking this:\n  is_ortho_set (set (a # Snorm))\n  distinct (a # Snorm)", "have [simp]: \"a \\<notin> set Snorm\""], ["proof (prove)\nusing this:\n  is_ortho_set (set (a # Snorm))\n  distinct (a # Snorm)\n\ngoal (1 subgoal):\n 1. a \\<notin> set Snorm", "by simp"], ["proof (state)\nthis:\n  a \\<notin> set Snorm\n\ngoal (1 subgoal):\n 1. \\<And>a Snorm.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set Snorm); distinct Snorm\\<rbrakk>\n                \\<Longrightarrow> sum proj (set Snorm) =\n                                  Proj (ccspan (set Snorm));\n        is_ortho_set (set (a # Snorm)); distinct (a # Snorm)\\<rbrakk>\n       \\<Longrightarrow> sum proj (set (a # Snorm)) =\n                         Proj (ccspan (set (a # Snorm)))", "have \"sum proj (set (a # Snorm))\n        = proj a + sum proj (set Snorm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum proj (set (a # Snorm)) = proj a + sum proj (set Snorm)", "by auto"], ["proof (state)\nthis:\n  sum proj (set (a # Snorm)) = proj a + sum proj (set Snorm)\n\ngoal (1 subgoal):\n 1. \\<And>a Snorm.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set Snorm); distinct Snorm\\<rbrakk>\n                \\<Longrightarrow> sum proj (set Snorm) =\n                                  Proj (ccspan (set Snorm));\n        is_ortho_set (set (a # Snorm)); distinct (a # Snorm)\\<rbrakk>\n       \\<Longrightarrow> sum proj (set (a # Snorm)) =\n                         Proj (ccspan (set (a # Snorm)))", "also"], ["proof (state)\nthis:\n  sum proj (set (a # Snorm)) = proj a + sum proj (set Snorm)\n\ngoal (1 subgoal):\n 1. \\<And>a Snorm.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set Snorm); distinct Snorm\\<rbrakk>\n                \\<Longrightarrow> sum proj (set Snorm) =\n                                  Proj (ccspan (set Snorm));\n        is_ortho_set (set (a # Snorm)); distinct (a # Snorm)\\<rbrakk>\n       \\<Longrightarrow> sum proj (set (a # Snorm)) =\n                         Proj (ccspan (set (a # Snorm)))", "have \"\\<dots> = proj a + Proj (ccspan (set Snorm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj a + sum proj (set Snorm) = proj a + Proj (ccspan (set Snorm))", "apply (subst Cons.IH)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_ortho_set (set Snorm)\n 2. distinct Snorm\n 3. proj a + Proj (ccspan (set Snorm)) = proj a + Proj (ccspan (set Snorm))", "using Cons.prems"], ["proof (prove)\nusing this:\n  is_ortho_set (set (a # Snorm))\n  distinct (a # Snorm)\n\ngoal (3 subgoals):\n 1. is_ortho_set (set Snorm)\n 2. distinct Snorm\n 3. proj a + Proj (ccspan (set Snorm)) = proj a + Proj (ccspan (set Snorm))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_ortho_set (insert a (set Snorm)); distinct Snorm\\<rbrakk>\n    \\<Longrightarrow> is_ortho_set (set Snorm)", "by (meson Cons.prems(1) is_ortho_set_antimono set_subset_Cons)"], ["proof (state)\nthis:\n  proj a + sum proj (set Snorm) = proj a + Proj (ccspan (set Snorm))\n\ngoal (1 subgoal):\n 1. \\<And>a Snorm.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set Snorm); distinct Snorm\\<rbrakk>\n                \\<Longrightarrow> sum proj (set Snorm) =\n                                  Proj (ccspan (set Snorm));\n        is_ortho_set (set (a # Snorm)); distinct (a # Snorm)\\<rbrakk>\n       \\<Longrightarrow> sum proj (set (a # Snorm)) =\n                         Proj (ccspan (set (a # Snorm)))", "also"], ["proof (state)\nthis:\n  proj a + sum proj (set Snorm) = proj a + Proj (ccspan (set Snorm))\n\ngoal (1 subgoal):\n 1. \\<And>a Snorm.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set Snorm); distinct Snorm\\<rbrakk>\n                \\<Longrightarrow> sum proj (set Snorm) =\n                                  Proj (ccspan (set Snorm));\n        is_ortho_set (set (a # Snorm)); distinct (a # Snorm)\\<rbrakk>\n       \\<Longrightarrow> sum proj (set (a # Snorm)) =\n                         Proj (ccspan (set (a # Snorm)))", "have \"\\<dots> = Proj (ccspan ({a} \\<union> set Snorm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj a + Proj (ccspan (set Snorm)) =\n    Proj (ccspan ({a} \\<union> set Snorm))", "apply (rule Proj_orthog_ccspan_union[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {a}; y \\<in> set Snorm\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal x y", "by (metis Cons.prems(1) \\<open>a \\<notin> set Snorm\\<close> is_ortho_set_def list.set_intros(1) list.set_intros(2) singleton_iff)"], ["proof (state)\nthis:\n  proj a + Proj (ccspan (set Snorm)) =\n  Proj (ccspan ({a} \\<union> set Snorm))\n\ngoal (1 subgoal):\n 1. \\<And>a Snorm.\n       \\<lbrakk>\\<lbrakk>is_ortho_set (set Snorm); distinct Snorm\\<rbrakk>\n                \\<Longrightarrow> sum proj (set Snorm) =\n                                  Proj (ccspan (set Snorm));\n        is_ortho_set (set (a # Snorm)); distinct (a # Snorm)\\<rbrakk>\n       \\<Longrightarrow> sum proj (set (a # Snorm)) =\n                         Proj (ccspan (set (a # Snorm)))", "finally"], ["proof (chain)\npicking this:\n  sum proj (set (a # Snorm)) = Proj (ccspan ({a} \\<union> set Snorm))", "show ?case"], ["proof (prove)\nusing this:\n  sum proj (set (a # Snorm)) = Proj (ccspan ({a} \\<union> set Snorm))\n\ngoal (1 subgoal):\n 1. sum proj (set (a # Snorm)) = Proj (ccspan (set (a # Snorm)))", "by simp"], ["proof (state)\nthis:\n  sum proj (set (a # Snorm)) = Proj (ccspan (set (a # Snorm)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat_of_cblinfun (sum proj (set Snorm)) =\n  mat_of_cblinfun (Proj (ccspan (set Snorm)))\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "also"], ["proof (state)\nthis:\n  mat_of_cblinfun (sum proj (set Snorm)) =\n  mat_of_cblinfun (Proj (ccspan (set Snorm)))\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "have \"\\<dots> = mat_of_cblinfun (Proj (ccspan (set S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set Snorm))) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "unfolding Span_Snorm"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "by simp"], ["proof (state)\nthis:\n  mat_of_cblinfun (Proj (ccspan (set Snorm))) =\n  mat_of_cblinfun (Proj (ccspan (set S)))\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "finally"], ["proof (chain)\npicking this:\n  mk_projector_orthog d (map vec_of_basis_enum S) =\n  mat_of_cblinfun (Proj (ccspan (set S)))", "show ?thesis"], ["proof (prove)\nusing this:\n  mk_projector_orthog d (map vec_of_basis_enum S) =\n  mat_of_cblinfun (Proj (ccspan (set S)))\n\ngoal (1 subgoal):\n 1. mk_projector_orthog d (map vec_of_basis_enum S) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "by -"], ["proof (state)\nthis:\n  mk_projector_orthog d (map vec_of_basis_enum S) =\n  mat_of_cblinfun (Proj (ccspan (set S)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_of_cblinfun_Proj_ccspan: \n  fixes S :: \"'a::onb_enum list\"\n  shows \"mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length (canonical_basis :: 'a list) in \n      mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "define d gs \n    where \"d = length (canonical_basis :: 'a list)\"\n      and \"gs = gram_schmidt0 d (map vec_of_basis_enum S)\""], ["proof (state)\nthis:\n  d = length canonical_basis\n  gs = gram_schmidt0 d (map vec_of_basis_enum S)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "interpret complex_vec_space d"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "have gs_dim: \"x \\<in> set gs \\<Longrightarrow> dim_vec x = d\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set gs \\<Longrightarrow> dim_vec x = d", "by (smt carrier_vecD carrier_vec_dim_vec d_def dim_vec_of_basis_enum' ex_map_conv gram_schmidt0_result(1) gs_def subset_code(1))"], ["proof (state)\nthis:\n  ?x1 \\<in> set gs \\<Longrightarrow> dim_vec ?x1 = d\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "have ortho_gs: \"is_ortho_set (set (map basis_enum_of_vec gs :: 'a list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ortho_set (set (map basis_enum_of_vec gs))", "apply (subst corthogonal_vec_of_basis_enum[THEN iffD1], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. corthogonal (map (vec_of_basis_enum \\<circ> basis_enum_of_vec) gs)", "by (smt carrier_dim_vec cof_vec_space.gram_schmidt0_result(1) d_def dim_vec_of_basis_enum' gram_schmidt0_result(3) gs_def imageE map_idI map_map o_apply set_map subset_code(1) basis_enum_of_vec_inverse)"], ["proof (state)\nthis:\n  is_ortho_set (set (map basis_enum_of_vec gs))\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "have distinct_gs: \"distinct (map basis_enum_of_vec gs :: 'a list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map basis_enum_of_vec gs)", "by (metis (mono_tags, hide_lams) carrier_vec_dim_vec cof_vec_space.gram_schmidt0_result(2) d_def dim_vec_of_basis_enum' distinct_map gs_def gs_dim image_iff inj_on_inverseI set_map subsetI basis_enum_of_vec_inverse)"], ["proof (state)\nthis:\n  distinct (map basis_enum_of_vec gs)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "have \"mk_projector_orthog d gs \n      = mk_projector_orthog d (map vec_of_basis_enum (map basis_enum_of_vec gs :: 'a list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_projector_orthog d gs =\n    mk_projector_orthog d (map vec_of_basis_enum (map basis_enum_of_vec gs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_projector_orthog d gs =\n    mk_projector_orthog d\n     (map (vec_of_basis_enum \\<circ> basis_enum_of_vec) gs)", "apply (subst map_cong[where ys=gs and g=id], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set gs \\<Longrightarrow>\n       (vec_of_basis_enum \\<circ> basis_enum_of_vec) x = id x\n 2. mk_projector_orthog d gs = mk_projector_orthog d (map id gs)", "using gs_dim"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set gs \\<Longrightarrow> dim_vec ?x1 = d\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set gs \\<Longrightarrow>\n       (vec_of_basis_enum \\<circ> basis_enum_of_vec) x = id x\n 2. mk_projector_orthog d gs = mk_projector_orthog d (map id gs)", "by (auto intro!: vec_of_basis_enum_inverse simp: d_def)"], ["proof (state)\nthis:\n  mk_projector_orthog d gs =\n  mk_projector_orthog d (map vec_of_basis_enum (map basis_enum_of_vec gs))\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "also"], ["proof (state)\nthis:\n  mk_projector_orthog d gs =\n  mk_projector_orthog d (map vec_of_basis_enum (map basis_enum_of_vec gs))\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "have \"\\<dots> = mat_of_cblinfun (Proj (ccspan (set (map basis_enum_of_vec gs :: 'a list))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_projector_orthog d\n     (map vec_of_basis_enum (map basis_enum_of_vec gs)) =\n    mat_of_cblinfun (Proj (ccspan (set (map basis_enum_of_vec gs))))", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_projector_orthog (length canonical_basis)\n     (map vec_of_basis_enum (map basis_enum_of_vec gs)) =\n    mat_of_cblinfun (Proj (ccspan (set (map basis_enum_of_vec gs))))", "apply (subst mk_projector_orthog_correct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_ortho_set (set (map basis_enum_of_vec gs))\n 2. distinct (map basis_enum_of_vec gs)\n 3. mat_of_cblinfun (Proj (ccspan (set (map basis_enum_of_vec gs)))) =\n    mat_of_cblinfun (Proj (ccspan (set (map basis_enum_of_vec gs))))", "using ortho_gs distinct_gs"], ["proof (prove)\nusing this:\n  is_ortho_set (set (map basis_enum_of_vec gs))\n  distinct (map basis_enum_of_vec gs)\n\ngoal (3 subgoals):\n 1. is_ortho_set (set (map basis_enum_of_vec gs))\n 2. distinct (map basis_enum_of_vec gs)\n 3. mat_of_cblinfun (Proj (ccspan (set (map basis_enum_of_vec gs)))) =\n    mat_of_cblinfun (Proj (ccspan (set (map basis_enum_of_vec gs))))", "by auto"], ["proof (state)\nthis:\n  mk_projector_orthog d (map vec_of_basis_enum (map basis_enum_of_vec gs)) =\n  mat_of_cblinfun (Proj (ccspan (set (map basis_enum_of_vec gs))))\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "also"], ["proof (state)\nthis:\n  mk_projector_orthog d (map vec_of_basis_enum (map basis_enum_of_vec gs)) =\n  mat_of_cblinfun (Proj (ccspan (set (map basis_enum_of_vec gs))))\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "have \"\\<dots> = mat_of_cblinfun (Proj (ccspan (set S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set (map basis_enum_of_vec gs)))) =\n    mat_of_cblinfun (Proj (ccspan (set S)))", "apply (rule arg_cong[where f=\"\\<lambda>x. mat_of_cblinfun (Proj x)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan (set (map basis_enum_of_vec gs)) = ccspan (set S)", "unfolding gs_def d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan\n     (set (map basis_enum_of_vec\n            (gram_schmidt0 (length canonical_basis)\n              (map vec_of_basis_enum S)))) =\n    ccspan (set S)", "apply (subst ccspan_gram_schmidt0_invariant)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set (map vec_of_basis_enum S)\n    \\<subseteq> carrier_vec (length canonical_basis)\n 2. ccspan (set (map basis_enum_of_vec (map vec_of_basis_enum S))) =\n    ccspan (set S)", "by (auto simp add: carrier_vecI dim_vec_of_basis_enum')"], ["proof (state)\nthis:\n  mat_of_cblinfun (Proj (ccspan (set (map basis_enum_of_vec gs)))) =\n  mat_of_cblinfun (Proj (ccspan (set S)))\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "finally"], ["proof (chain)\npicking this:\n  mk_projector_orthog d gs = mat_of_cblinfun (Proj (ccspan (set S)))", "show ?thesis"], ["proof (prove)\nusing this:\n  mk_projector_orthog d gs = mat_of_cblinfun (Proj (ccspan (set S)))\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "unfolding d_def gs_def"], ["proof (prove)\nusing this:\n  mk_projector_orthog (length canonical_basis)\n   (gram_schmidt0 (length canonical_basis) (map vec_of_basis_enum S)) =\n  mat_of_cblinfun (Proj (ccspan (set S)))\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun (Proj (ccspan (set S))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))", "by auto"], ["proof (state)\nthis:\n  mat_of_cblinfun (Proj (ccspan (set S))) =\n  (let d = length canonical_basis\n   in mk_projector_orthog d (gram_schmidt0 d (map vec_of_basis_enum S)))\n\ngoal:\nNo subgoals!", "qed"], ["", "unbundle no_jnf_notation"], ["", "unbundle no_cblinfun_notation"], ["", "end"]]}