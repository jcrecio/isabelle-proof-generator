{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators/Complex_Vector_Spaces0.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators", "problem_names": ["lemmas scaleC = scale", "lemma clinear_compose: \"clinear f \\<Longrightarrow> clinear g \\<Longrightarrow> clinear (g \\<circ> f)\"", "lemmas scaleC_left_commute = complex_vector.scale_left_commute", "lemmas scaleC_zero_left = complex_vector.scale_zero_left", "lemmas scaleC_minus_left = complex_vector.scale_minus_left", "lemmas scaleC_diff_left = complex_vector.scale_left_diff_distrib", "lemmas scaleC_sum_left = complex_vector.scale_sum_left", "lemmas scaleC_zero_right = complex_vector.scale_zero_right", "lemmas scaleC_minus_right = complex_vector.scale_minus_right", "lemmas scaleC_diff_right = complex_vector.scale_right_diff_distrib", "lemmas scaleC_sum_right = complex_vector.scale_sum_right", "lemmas scaleC_eq_0_iff = complex_vector.scale_eq_0_iff", "lemmas scaleC_left_imp_eq = complex_vector.scale_left_imp_eq", "lemmas scaleC_right_imp_eq = complex_vector.scale_right_imp_eq", "lemmas scaleC_cancel_left = complex_vector.scale_cancel_left", "lemmas scaleC_cancel_right = complex_vector.scale_cancel_right", "lemma divideC_field_simps[field_simps]: (* In Real_Vector_Spaces, these lemmas are unnamed *)\n  \"c \\<noteq> 0 \\<Longrightarrow> a = b /\\<^sub>C c \\<longleftrightarrow> c *\\<^sub>C a = b\"\n  \"c \\<noteq> 0 \\<Longrightarrow> b /\\<^sub>C c = a \\<longleftrightarrow> b = c *\\<^sub>C a\"\n  \"c \\<noteq> 0 \\<Longrightarrow> a + b /\\<^sub>C c = (c *\\<^sub>C a + b) /\\<^sub>C c\"\n  \"c \\<noteq> 0 \\<Longrightarrow> a /\\<^sub>C c + b = (a + c *\\<^sub>C b) /\\<^sub>C c\"\n  \"c \\<noteq> 0 \\<Longrightarrow> a - b /\\<^sub>C c = (c *\\<^sub>C a - b) /\\<^sub>C c\"\n  \"c \\<noteq> 0 \\<Longrightarrow> a /\\<^sub>C c - b = (a - c *\\<^sub>C b) /\\<^sub>C c\"\n  \"c \\<noteq> 0 \\<Longrightarrow> - (a /\\<^sub>C c) + b = (- a + c *\\<^sub>C b) /\\<^sub>C c\"\n  \"c \\<noteq> 0 \\<Longrightarrow> - (a /\\<^sub>C c) - b = (- a - c *\\<^sub>C b) /\\<^sub>C c\"\n  for a b :: \"'a :: complex_vector\"", "lemmas clinear_injective_0 = linear_inj_iff_eq_0\n  and clinear_injective_on_subspace_0 = linear_inj_on_iff_eq_0\n  and clinear_cmul = linear_scale\n  and clinear_scaleC = linear_scale_self\n  and csubspace_mul = subspace_scale\n  and cspan_linear_image = linear_span_image\n  and cspan_0 = span_zero\n  and cspan_mul = span_scale\n  and injective_scaleC = injective_scale", "lemma scaleC_minus1_left [simp]: \"scaleC (-1) x = - x\"\n  for x :: \"'a::complex_vector\"", "lemma scaleC_2:\n  fixes x :: \"'a::complex_vector\"\n  shows \"scaleC 2 x = x + x\"", "lemma scaleC_half_double [simp]:\n  fixes a :: \"'a::complex_vector\"\n  shows \"(1 / 2) *\\<^sub>C (a + a) = a\"", "lemma clinear_scale_complex:\n  fixes c::complex shows \"clinear f \\<Longrightarrow> f (c * b) = c * f b\"", "lemma nonzero_inverse_scaleC_distrib:\n  \"a \\<noteq> 0 \\<Longrightarrow> x \\<noteq> 0 \\<Longrightarrow> inverse (scaleC a x) = scaleC (inverse a) (inverse x)\"\n  for x :: \"'a::complex_div_algebra\"", "lemma inverse_scaleC_distrib: \"inverse (scaleC a x) = scaleC (inverse a) (inverse x)\"\n  for x :: \"'a::{complex_div_algebra,division_ring}\"", "lemma complex_add_divide_simps[vector_add_divide_simps]:  (* In Real_Vector_Spaces, these lemmas are unnamed *)\n  \"v + (b / z) *\\<^sub>C w = (if z = 0 then v else (z *\\<^sub>C v + b *\\<^sub>C w) /\\<^sub>C z)\"\n  \"a *\\<^sub>C v + (b / z) *\\<^sub>C w = (if z = 0 then a *\\<^sub>C v else ((a * z) *\\<^sub>C v + b *\\<^sub>C w) /\\<^sub>C z)\"\n  \"(a / z) *\\<^sub>C v + w = (if z = 0 then w else (a *\\<^sub>C v + z *\\<^sub>C w) /\\<^sub>C z)\"\n  \"(a / z) *\\<^sub>C v + b *\\<^sub>C w = (if z = 0 then b *\\<^sub>C w else (a *\\<^sub>C v + (b * z) *\\<^sub>C w) /\\<^sub>C z)\"\n  \"v - (b / z) *\\<^sub>C w = (if z = 0 then v else (z *\\<^sub>C v - b *\\<^sub>C w) /\\<^sub>C z)\"\n  \"a *\\<^sub>C v - (b / z) *\\<^sub>C w = (if z = 0 then a *\\<^sub>C v else ((a * z) *\\<^sub>C v - b *\\<^sub>C w) /\\<^sub>C z)\"\n  \"(a / z) *\\<^sub>C v - w = (if z = 0 then -w else (a *\\<^sub>C v - z *\\<^sub>C w) /\\<^sub>C z)\"\n  \"(a / z) *\\<^sub>C v - b *\\<^sub>C w = (if z = 0 then -b *\\<^sub>C w else (a *\\<^sub>C v - (b * z) *\\<^sub>C w) /\\<^sub>C z)\"\n  for v :: \"'a :: complex_vector\"", "lemma ceq_vector_fraction_iff [vector_add_divide_simps]:\n  fixes x :: \"'a :: complex_vector\"\n  shows \"(x = (u / v) *\\<^sub>C a) \\<longleftrightarrow> (if v=0 then x = 0 else v *\\<^sub>C x = u *\\<^sub>C a)\"", "lemma cvector_fraction_eq_iff [vector_add_divide_simps]:\n  fixes x :: \"'a :: complex_vector\"\n  shows \"((u / v) *\\<^sub>C a = x) \\<longleftrightarrow> (if v=0 then x = 0 else u *\\<^sub>C a = v *\\<^sub>C x)\"", "lemma complex_vector_affinity_eq:\n  fixes x :: \"'a :: complex_vector\"\n  assumes m0: \"m \\<noteq> 0\"\n  shows \"m *\\<^sub>C x + c = y \\<longleftrightarrow> x = inverse m *\\<^sub>C y - (inverse m *\\<^sub>C c)\"\n    (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma complex_vector_eq_affinity: \"m \\<noteq> 0 \\<Longrightarrow> y = m *\\<^sub>C x + c \\<longleftrightarrow> inverse m *\\<^sub>C y - (inverse m *\\<^sub>C c) = x\"\n  for x :: \"'a::complex_vector\"", "lemma scaleC_eq_iff [simp]: \"b + u *\\<^sub>C a = a + u *\\<^sub>C b \\<longleftrightarrow> a = b \\<or> u = 1\"\n  for a :: \"'a::complex_vector\"", "lemma scaleC_collapse [simp]: \"(1 - u) *\\<^sub>C a + u *\\<^sub>C a = a\"\n  for a :: \"'a::complex_vector\"", "lemma scaleC_conv_of_complex: \"scaleC r x = of_complex r * x\"", "lemma of_complex_0 [simp]: \"of_complex 0 = 0\"", "lemma of_complex_1 [simp]: \"of_complex 1 = 1\"", "lemma of_complex_add [simp]: \"of_complex (x + y) = of_complex x + of_complex y\"", "lemma of_complex_minus [simp]: \"of_complex (- x) = - of_complex x\"", "lemma of_complex_diff [simp]: \"of_complex (x - y) = of_complex x - of_complex y\"", "lemma of_complex_mult [simp]: \"of_complex (x * y) = of_complex x * of_complex y\"", "lemma of_complex_sum[simp]: \"of_complex (sum f s) = (\\<Sum>x\\<in>s. of_complex (f x))\"", "lemma of_complex_prod[simp]: \"of_complex (prod f s) = (\\<Prod>x\\<in>s. of_complex (f x))\"", "lemma nonzero_of_complex_inverse:\n  \"x \\<noteq> 0 \\<Longrightarrow> of_complex (inverse x) = inverse (of_complex x :: 'a::complex_div_algebra)\"", "lemma of_complex_inverse [simp]:\n  \"of_complex (inverse x) = inverse (of_complex x :: 'a::{complex_div_algebra,division_ring})\"", "lemma nonzero_of_complex_divide:\n  \"y \\<noteq> 0 \\<Longrightarrow> of_complex (x / y) = (of_complex x / of_complex y :: 'a::complex_field)\"", "lemma of_complex_divide [simp]:\n  \"of_complex (x / y) = (of_complex x / of_complex y :: 'a::complex_div_algebra)\"", "lemma of_complex_power [simp]:\n  \"of_complex (x ^ n) = (of_complex x :: 'a::{complex_algebra_1}) ^ n\"", "lemma of_complex_power_int [simp]:\n  \"of_complex (power_int x n) = power_int (of_complex x :: 'a :: {complex_div_algebra,division_ring}) n\"", "lemma of_complex_eq_iff [simp]: \"of_complex x = of_complex y \\<longleftrightarrow> x = y\"", "lemma inj_of_complex: \"inj of_complex\"", "lemmas of_complex_eq_0_iff [simp] = of_complex_eq_iff [of _ 0, simplified]", "lemmas of_complex_eq_1_iff [simp] = of_complex_eq_iff [of _ 1, simplified]", "lemma minus_of_complex_eq_of_complex_iff [simp]: \"-of_complex x = of_complex y \\<longleftrightarrow> -x = y\"", "lemma of_complex_eq_minus_of_complex_iff [simp]: \"of_complex x = -of_complex y \\<longleftrightarrow> x = -y\"", "lemma of_complex_eq_id [simp]: \"of_complex = (id :: complex \\<Rightarrow> complex)\"", "lemma of_complex_of_nat_eq [simp]: \"of_complex (of_nat n) = of_nat n\"", "lemma of_complex_of_int_eq [simp]: \"of_complex (of_int z) = of_int z\"", "lemma of_complex_numeral [simp]: \"of_complex (numeral w) = numeral w\"", "lemma of_complex_neg_numeral [simp]: \"of_complex (- numeral w) = - numeral w\"", "lemma numeral_power_int_eq_of_complex_cancel_iff [simp]:\n  \"power_int (numeral x) n = (of_complex y :: 'a :: {complex_div_algebra, division_ring}) \\<longleftrightarrow>\n     power_int (numeral x) n = y\"", "lemma of_complex_eq_numeral_power_int_cancel_iff [simp]:\n  \"(of_complex y :: 'a :: {complex_div_algebra, division_ring}) = power_int (numeral x) n \\<longleftrightarrow>\n     y = power_int (numeral x) n\"", "lemma of_complex_eq_of_complex_power_int_cancel_iff [simp]:\n  \"power_int (of_complex b :: 'a :: {complex_div_algebra, division_ring}) w = of_complex x \\<longleftrightarrow>\n     power_int b w = x\"", "lemma of_complex_in_Ints_iff [simp]: \"of_complex x \\<in> \\<int> \\<longleftrightarrow> x \\<in> \\<int>\"", "lemma Ints_of_complex [intro]: \"x \\<in> \\<int> \\<Longrightarrow> of_complex x \\<in> \\<int>\"", "lemma fraction_scaleC_times [simp]:\n  fixes a :: \"'a::complex_algebra_1\"\n  shows \"(numeral u / numeral v) *\\<^sub>C (numeral w * a) = (numeral u * numeral w / numeral v) *\\<^sub>C a\"", "lemma inverse_scaleC_times [simp]:\n  fixes a :: \"'a::complex_algebra_1\"\n  shows \"(1 / numeral v) *\\<^sub>C (numeral w * a) = (numeral w / numeral v) *\\<^sub>C a\"", "lemma scaleC_times [simp]:\n  fixes a :: \"'a::complex_algebra_1\"\n  shows \"(numeral u) *\\<^sub>C (numeral w * a) = (numeral u * numeral w) *\\<^sub>C a\"", "lemma Complexs_of_complex [simp]: \"of_complex r \\<in> \\<complex>\"", "lemma Complexs_of_int [simp]: \"of_int z \\<in> \\<complex>\"", "lemma Complexs_of_nat [simp]: \"of_nat n \\<in> \\<complex>\"", "lemma Complexs_numeral [simp]: \"numeral w \\<in> \\<complex>\"", "lemma Complexs_0 [simp]: \"0 \\<in> \\<complex>\" and Complexs_1 [simp]: \"1 \\<in> \\<complex>\"", "lemma Complexs_add [simp]: \"a \\<in> \\<complex> \\<Longrightarrow> b \\<in> \\<complex> \\<Longrightarrow> a + b \\<in> \\<complex>\"", "lemma Complexs_minus [simp]: \"a \\<in> \\<complex> \\<Longrightarrow> - a \\<in> \\<complex>\"", "lemma Complexs_minus_iff [simp]: \"- a \\<in> \\<complex> \\<longleftrightarrow> a \\<in> \\<complex>\"", "lemma Complexs_diff [simp]: \"a \\<in> \\<complex> \\<Longrightarrow> b \\<in> \\<complex> \\<Longrightarrow> a - b \\<in> \\<complex>\"", "lemma Complexs_mult [simp]: \"a \\<in> \\<complex> \\<Longrightarrow> b \\<in> \\<complex> \\<Longrightarrow> a * b \\<in> \\<complex>\"", "lemma nonzero_Complexs_inverse: \"a \\<in> \\<complex> \\<Longrightarrow> a \\<noteq> 0 \\<Longrightarrow> inverse a \\<in> \\<complex>\"\n  for a :: \"'a::complex_div_algebra\"", "lemma Complexs_inverse: \"a \\<in> \\<complex> \\<Longrightarrow> inverse a \\<in> \\<complex>\"\n  for a :: \"'a::{complex_div_algebra,division_ring}\"", "lemma Complexs_inverse_iff [simp]: \"inverse x \\<in> \\<complex> \\<longleftrightarrow> x \\<in> \\<complex>\"\n  for x :: \"'a::{complex_div_algebra,division_ring}\"", "lemma nonzero_Complexs_divide: \"a \\<in> \\<complex> \\<Longrightarrow> b \\<in> \\<complex> \\<Longrightarrow> b \\<noteq> 0 \\<Longrightarrow> a / b \\<in> \\<complex>\"\n  for a b :: \"'a::complex_field\"", "lemma Complexs_divide [simp]: \"a \\<in> \\<complex> \\<Longrightarrow> b \\<in> \\<complex> \\<Longrightarrow> a / b \\<in> \\<complex>\"\n  for a b :: \"'a::{complex_field,field}\"", "lemma Complexs_power [simp]: \"a \\<in> \\<complex> \\<Longrightarrow> a ^ n \\<in> \\<complex>\"\n  for a :: \"'a::complex_algebra_1\"", "lemma Complexs_cases [cases set: Complexs]:\n  assumes \"q \\<in> \\<complex>\"\n  obtains (of_complex) c where \"q = of_complex c\"", "lemma sum_in_Complexs [intro,simp]: \"(\\<And>i. i \\<in> s \\<Longrightarrow> f i \\<in> \\<complex>) \\<Longrightarrow> sum f s \\<in> \\<complex>\"", "lemma prod_in_Complexs [intro,simp]: \"(\\<And>i. i \\<in> s \\<Longrightarrow> f i \\<in> \\<complex>) \\<Longrightarrow> prod f s \\<in> \\<complex>\"", "lemma Complexs_induct [case_names of_complex, induct set: Complexs]:\n  \"q \\<in> \\<complex> \\<Longrightarrow> (\\<And>r. P (of_complex r)) \\<Longrightarrow> P q\"", "lemma scaleC_mono:\n  \"a \\<le> b \\<Longrightarrow> x \\<le> y \\<Longrightarrow> 0 \\<le> b \\<Longrightarrow> 0 \\<le> x \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C y\"", "lemma scaleC_mono':\n  \"a \\<le> b \\<Longrightarrow> c \\<le> d \\<Longrightarrow> 0 \\<le> a \\<Longrightarrow> 0 \\<le> c \\<Longrightarrow> a *\\<^sub>C c \\<le> b *\\<^sub>C d\"", "lemma pos_le_divideC_eq [field_simps]:\n  \"a \\<le> b /\\<^sub>C c \\<longleftrightarrow> c *\\<^sub>C a \\<le> b\" (is \"?P \\<longleftrightarrow> ?Q\") if \"0 < c\"", "lemma pos_less_divideC_eq [field_simps]:\n  \"a < b /\\<^sub>C c \\<longleftrightarrow> c *\\<^sub>C a < b\" if \"c > 0\"", "lemma pos_divideC_le_eq [field_simps]:\n  \"b /\\<^sub>C c \\<le> a \\<longleftrightarrow> b \\<le> c *\\<^sub>C a\" if \"c > 0\"", "lemma pos_divideC_less_eq [field_simps]:\n  \"b /\\<^sub>C c < a \\<longleftrightarrow> b < c *\\<^sub>C a\" if \"c > 0\"", "lemma pos_le_minus_divideC_eq [field_simps]:\n  \"a \\<le> - (b /\\<^sub>C c) \\<longleftrightarrow> c *\\<^sub>C a \\<le> - b\" if \"c > 0\"", "lemma pos_less_minus_divideC_eq [field_simps]:\n  \"a < - (b /\\<^sub>C c) \\<longleftrightarrow> c *\\<^sub>C a < - b\" if \"c > 0\"", "lemma pos_minus_divideC_le_eq [field_simps]:\n  \"- (b /\\<^sub>C c) \\<le> a \\<longleftrightarrow> - b \\<le> c *\\<^sub>C a\" if \"c > 0\"", "lemma pos_minus_divideC_less_eq [field_simps]:\n  \"- (b /\\<^sub>C c) < a \\<longleftrightarrow> - b < c *\\<^sub>C a\" if \"c > 0\"", "lemma scaleC_image_atLeastAtMost: \"c > 0 \\<Longrightarrow> scaleC c ` {x..y} = {c *\\<^sub>C x..c *\\<^sub>C y}\"", "lemma neg_le_divideC_eq [field_simps]:\n  \"a \\<le> b /\\<^sub>C c \\<longleftrightarrow> b \\<le> c *\\<^sub>C a\" (is \"?P \\<longleftrightarrow> ?Q\") if \"c < 0\"\n    for a b :: \"'a :: ordered_complex_vector\"", "lemma neg_less_divideC_eq [field_simps]:\n  \"a < b /\\<^sub>C c \\<longleftrightarrow> b < c *\\<^sub>C a\" if \"c < 0\"\n    for a b :: \"'a :: ordered_complex_vector\"", "lemma neg_divideC_le_eq [field_simps]:\n  \"b /\\<^sub>C c \\<le> a \\<longleftrightarrow> c *\\<^sub>C a \\<le> b\" if \"c < 0\"\n    for a b :: \"'a :: ordered_complex_vector\"", "lemma neg_divideC_less_eq [field_simps]:\n  \"b /\\<^sub>C c < a \\<longleftrightarrow> c *\\<^sub>C a < b\" if \"c < 0\"\n    for a b :: \"'a :: ordered_complex_vector\"", "lemma neg_le_minus_divideC_eq [field_simps]:\n  \"a \\<le> - (b /\\<^sub>C c) \\<longleftrightarrow> - b \\<le> c *\\<^sub>C a\" if \"c < 0\"\n    for a b :: \"'a :: ordered_complex_vector\"", "lemma neg_less_minus_divideC_eq [field_simps]:\n  \"a < - (b /\\<^sub>C c) \\<longleftrightarrow> - b < c *\\<^sub>C a\" if \"c < 0\"\n    for a b :: \"'a :: ordered_complex_vector\"", "lemma neg_minus_divideC_le_eq [field_simps]:\n  \"- (b /\\<^sub>C c) \\<le> a \\<longleftrightarrow> c *\\<^sub>C a \\<le> - b\" if \"c < 0\"\nfor a b :: \"'a :: ordered_complex_vector\"", "lemma neg_minus_divideC_less_eq [field_simps]:\n  \"- (b /\\<^sub>C c) < a \\<longleftrightarrow> c *\\<^sub>C a < - b\" if \"c < 0\"\nfor a b :: \"'a :: ordered_complex_vector\"", "lemma divideC_field_splits_simps_1 [field_split_simps]: (* In Real_Vector_Spaces, these lemmas are unnamed *)\n  \"a = b /\\<^sub>C c \\<longleftrightarrow> (if c = 0 then a = 0 else c *\\<^sub>C a = b)\"\n  \"b /\\<^sub>C c = a \\<longleftrightarrow> (if c = 0 then a = 0 else b = c *\\<^sub>C a)\"\n  \"a + b /\\<^sub>C c = (if c = 0 then a else (c *\\<^sub>C a + b) /\\<^sub>C c)\"\n  \"a /\\<^sub>C c + b = (if c = 0 then b else (a + c *\\<^sub>C b) /\\<^sub>C c)\"\n  \"a - b /\\<^sub>C c = (if c = 0 then a else (c *\\<^sub>C a - b) /\\<^sub>C c)\"\n  \"a /\\<^sub>C c - b = (if c = 0 then - b else (a - c *\\<^sub>C b) /\\<^sub>C c)\"\n  \"- (a /\\<^sub>C c) + b = (if c = 0 then b else (- a + c *\\<^sub>C b) /\\<^sub>C c)\"\n  \"- (a /\\<^sub>C c) - b = (if c = 0 then - b else (- a - c *\\<^sub>C b) /\\<^sub>C c)\"\n  for a b :: \"'a :: complex_vector\"", "lemma divideC_field_splits_simps_2 [field_split_simps]: (* In Real_Vector_Spaces, these lemmas are unnamed *)\n  \"0 < c \\<Longrightarrow> a \\<le> b /\\<^sub>C c \\<longleftrightarrow> (if c > 0 then c *\\<^sub>C a \\<le> b else if c < 0 then b \\<le> c *\\<^sub>C a else a \\<le> 0)\"\n  \"0 < c \\<Longrightarrow> a < b /\\<^sub>C c \\<longleftrightarrow> (if c > 0 then c *\\<^sub>C a < b else if c < 0 then b < c *\\<^sub>C a else a < 0)\"\n  \"0 < c \\<Longrightarrow> b /\\<^sub>C c \\<le> a \\<longleftrightarrow> (if c > 0 then b \\<le> c *\\<^sub>C a else if c < 0 then c *\\<^sub>C a \\<le> b else a \\<ge> 0)\"\n  \"0 < c \\<Longrightarrow> b /\\<^sub>C c < a \\<longleftrightarrow> (if c > 0 then b < c *\\<^sub>C a else if c < 0 then c *\\<^sub>C a < b else a > 0)\"\n  \"0 < c \\<Longrightarrow> a \\<le> - (b /\\<^sub>C c) \\<longleftrightarrow> (if c > 0 then c *\\<^sub>C a \\<le> - b else if c < 0 then - b \\<le> c *\\<^sub>C a else a \\<le> 0)\"\n  \"0 < c \\<Longrightarrow> a < - (b /\\<^sub>C c) \\<longleftrightarrow> (if c > 0 then c *\\<^sub>C a < - b else if c < 0 then - b < c *\\<^sub>C a else a < 0)\"\n  \"0 < c \\<Longrightarrow> - (b /\\<^sub>C c) \\<le> a \\<longleftrightarrow> (if c > 0 then - b \\<le> c *\\<^sub>C a else if c < 0 then c *\\<^sub>C a \\<le> - b else a \\<ge> 0)\"\n  \"0 < c \\<Longrightarrow> - (b /\\<^sub>C c) < a \\<longleftrightarrow> (if c > 0 then - b < c *\\<^sub>C a else if c < 0 then c *\\<^sub>C a < - b else a > 0)\"\n  for a b :: \"'a :: ordered_complex_vector\"", "lemma scaleC_nonneg_nonneg: \"0 \\<le> a \\<Longrightarrow> 0 \\<le> x \\<Longrightarrow> 0 \\<le> a *\\<^sub>C x\"\n  for x :: \"'a::ordered_complex_vector\"", "lemma scaleC_nonneg_nonpos: \"0 \\<le> a \\<Longrightarrow> x \\<le> 0 \\<Longrightarrow> a *\\<^sub>C x \\<le> 0\"\n  for x :: \"'a::ordered_complex_vector\"", "lemma scaleC_nonpos_nonneg: \"a \\<le> 0 \\<Longrightarrow> 0 \\<le> x \\<Longrightarrow> a *\\<^sub>C x \\<le> 0\"\n  for x :: \"'a::ordered_complex_vector\"", "lemma split_scaleC_neg_le: \"(0 \\<le> a \\<and> x \\<le> 0) \\<or> (a \\<le> 0 \\<and> 0 \\<le> x) \\<Longrightarrow> a *\\<^sub>C x \\<le> 0\"\n  for x :: \"'a::ordered_complex_vector\"", "lemma cle_add_iff1: \"a *\\<^sub>C e + c \\<le> b *\\<^sub>C e + d \\<longleftrightarrow> (a - b) *\\<^sub>C e + c \\<le> d\"\n  for c d e :: \"'a::ordered_complex_vector\"", "lemma cle_add_iff2: \"a *\\<^sub>C e + c \\<le> b *\\<^sub>C e + d \\<longleftrightarrow> c \\<le> (b - a) *\\<^sub>C e + d\"\n  for c d e :: \"'a::ordered_complex_vector\"", "lemma scaleC_left_mono_neg: \"b \\<le> a \\<Longrightarrow> c \\<le> 0 \\<Longrightarrow> c *\\<^sub>C a \\<le> c *\\<^sub>C b\"\n  for a b :: \"'a::ordered_complex_vector\"", "lemma scaleC_right_mono_neg: \"b \\<le> a \\<Longrightarrow> c \\<le> 0 \\<Longrightarrow> a *\\<^sub>C c \\<le> b *\\<^sub>C c\"\n  for c :: \"'a::ordered_complex_vector\"", "lemma scaleC_nonpos_nonpos: \"a \\<le> 0 \\<Longrightarrow> b \\<le> 0 \\<Longrightarrow> 0 \\<le> a *\\<^sub>C b\"\n  for b :: \"'a::ordered_complex_vector\"", "lemma split_scaleC_pos_le: \"(0 \\<le> a \\<and> 0 \\<le> b) \\<or> (a \\<le> 0 \\<and> b \\<le> 0) \\<Longrightarrow> 0 \\<le> a *\\<^sub>C b\"\n  for b :: \"'a::ordered_complex_vector\"", "lemma zero_le_scaleC_iff:\n  fixes b :: \"'a::ordered_complex_vector\"\n  assumes \"a \\<in> \\<real>\" (* Not present in Real_Vector_Spaces.thy *)\n  shows \"0 \\<le> a *\\<^sub>C b \\<longleftrightarrow> 0 < a \\<and> 0 \\<le> b \\<or> a < 0 \\<and> b \\<le> 0 \\<or> a = 0\"\n    (is \"?lhs = ?rhs\")", "lemma scaleC_le_0_iff:\n  \"a *\\<^sub>C b \\<le> 0 \\<longleftrightarrow> 0 < a \\<and> b \\<le> 0 \\<or> a < 0 \\<and> 0 \\<le> b \\<or> a = 0\"\n  if \"a \\<in> \\<real>\" (* Not present in Real_Vector_Spaces *)\n  for b::\"'a::ordered_complex_vector\"", "lemma scaleC_le_cancel_left: \"c *\\<^sub>C a \\<le> c *\\<^sub>C b \\<longleftrightarrow> (0 < c \\<longrightarrow> a \\<le> b) \\<and> (c < 0 \\<longrightarrow> b \\<le> a)\"\n  if \"c \\<in> \\<real>\" (* Not present in Real_Vector_Spaces *)\n  for b :: \"'a::ordered_complex_vector\"", "lemma scaleC_le_cancel_left_pos: \"0 < c \\<Longrightarrow> c *\\<^sub>C a \\<le> c *\\<^sub>C b \\<longleftrightarrow> a \\<le> b\"\n  for b :: \"'a::ordered_complex_vector\"", "lemma scaleC_le_cancel_left_neg: \"c < 0 \\<Longrightarrow> c *\\<^sub>C a \\<le> c *\\<^sub>C b \\<longleftrightarrow> b \\<le> a\"\n  for b :: \"'a::ordered_complex_vector\"", "lemma scaleC_left_le_one_le: \"0 \\<le> x \\<Longrightarrow> a \\<le> 1 \\<Longrightarrow> a *\\<^sub>C x \\<le> x\"\n  for x :: \"'a::ordered_complex_vector\" and a :: complex", "lemma (in complex_normed_algebra_1) scaleC_power [simp]: \"(scaleC x y) ^ n = scaleC (x^n) (y^n)\"", "lemma dist_scaleC [simp]: \"dist (x *\\<^sub>C a) (y *\\<^sub>C a) = \\<bar>x - y\\<bar> * norm a\"\n  for a :: \"'a::complex_normed_vector\"", "lemma norm_of_complex [simp]: \"norm (of_complex c :: 'a::complex_normed_algebra_1) = cmod c\"", "lemma norm_of_complex_add1 [simp]: \"norm (of_complex x + 1 :: 'a :: complex_normed_div_algebra) = cmod (x + 1)\"", "lemma norm_of_complex_addn [simp]:\n  \"norm (of_complex x + numeral b :: 'a :: complex_normed_div_algebra) = cmod (x + numeral b)\"", "lemma norm_of_complex_diff [simp]:\n  \"norm (of_complex b - of_complex a :: 'a::complex_normed_algebra_1) \\<le> cmod (b - a)\"", "lemma dist_of_complex [simp]: \"dist (of_complex x :: 'a) (of_complex y) = dist x y\"\n  for a :: \"'a::complex_normed_div_algebra\"", "lemma closed_complex_atMost: \\<open>closed {..a::complex}\\<close>", "lemma closed_complex_atLeast: \\<open>closed {a::complex..}\\<close>", "lemma closed_complex_atLeastAtMost: \\<open>closed {a::complex .. b}\\<close>", "lemma sgn_scaleC: \"sgn (scaleC r x) = scaleC (sgn r) (sgn x)\"\n  for x :: \"'a::complex_normed_vector\"", "lemma sgn_of_complex: \"sgn (of_complex r :: 'a::complex_normed_algebra_1) = of_complex (sgn r)\"", "lemma complex_sgn_eq: \"sgn x = x / \\<bar>x\\<bar>\"\n  for x :: complex", "lemma czero_le_sgn_iff [simp]: \"0 \\<le> sgn x \\<longleftrightarrow> 0 \\<le> x\"\n  for x :: complex", "lemma csgn_le_0_iff [simp]: \"sgn x \\<le> 0 \\<longleftrightarrow> x \\<le> 0\"\n  for x :: complex", "lemma clinearI: \"clinear f\"\n  if \"\\<And>b1 b2. f (b1 + b2) = f b1 + f b2\"\n    \"\\<And>r b. f (r *\\<^sub>C b) = r *\\<^sub>C f b\"", "lemma clinear_iff:\n  \"clinear f \\<longleftrightarrow> (\\<forall>x y. f (x + y) = f x + f y) \\<and> (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x)\"\n  (is \"clinear f \\<longleftrightarrow> ?rhs\")", "lemmas clinear_scaleC_left = complex_vector.linear_scale_left", "lemmas clinear_imp_scaleC = complex_vector.linear_imp_scale", "lemma clinear_times_of_complex: \"clinear (\\<lambda>x. a * of_complex x)\"", "lemma bounded_linear: \"bounded_linear f\"", "lemma pos_bounded: \"\\<exists>K>0. \\<forall>x. norm (f x) \\<le> norm x * K\"", "lemma nonneg_bounded: \"\\<exists>K\\<ge>0. \\<forall>x. norm (f x) \\<le> norm x * K\"", "lemma clinear: \"clinear f\"", "lemma bounded_clinear_intro:\n  assumes \"\\<And>x y. f (x + y) = f x + f y\"\n    and \"\\<And>r x. f (scaleC r x) = scaleC r (f x)\"\n    and \"\\<And>x. norm (f x) \\<le> norm x * K\"\n  shows \"bounded_clinear f\"", "lemma bounded_bilinear[simp]: \"bounded_bilinear prod\"", "lemmas pos_bounded = pos_bounded", "lemmas nonneg_bounded = nonneg_bounded", "lemmas additive_right = additive_right", "lemmas additive_left = additive_left", "lemmas zero_left = zero_left", "lemmas zero_right = zero_right", "lemmas minus_left = minus_left", "lemmas minus_right = minus_right", "lemmas diff_left = diff_left", "lemmas diff_right = diff_right", "lemmas sum_left = sum_left", "lemmas sum_right = sum_right", "lemmas prod_diff_prod = prod_diff_prod", "lemma bounded_clinear_left: \"bounded_clinear (\\<lambda>a. a ** b)\"", "lemma bounded_clinear_right: \"bounded_clinear (\\<lambda>b. a ** b)\"", "lemma flip: \"bounded_cbilinear (\\<lambda>x y. y ** x)\"", "lemma comp1:\n  assumes \"bounded_clinear g\"\n  shows \"bounded_cbilinear (\\<lambda>x. (**) (g x))\"", "lemma comp: \"bounded_clinear f \\<Longrightarrow> bounded_clinear g \\<Longrightarrow> bounded_cbilinear (\\<lambda>x y. f x ** g y)\"", "lemma bounded_clinear_ident[simp]: \"bounded_clinear (\\<lambda>x. x)\"", "lemma bounded_clinear_zero[simp]: \"bounded_clinear (\\<lambda>x. 0)\"", "lemma bounded_clinear_add:\n  assumes \"bounded_clinear f\"\n    and \"bounded_clinear g\"\n  shows \"bounded_clinear (\\<lambda>x. f x + g x)\"", "lemma bounded_clinear_minus:\n  assumes \"bounded_clinear f\"\n  shows \"bounded_clinear (\\<lambda>x. - f x)\"", "lemma bounded_clinear_sub: \"bounded_clinear f \\<Longrightarrow> bounded_clinear g \\<Longrightarrow> bounded_clinear (\\<lambda>x. f x - g x)\"", "lemma bounded_clinear_sum:\n  fixes f :: \"'i \\<Rightarrow> 'a::complex_normed_vector \\<Rightarrow> 'b::complex_normed_vector\"\n  shows \"(\\<And>i. i \\<in> I \\<Longrightarrow> bounded_clinear (f i)) \\<Longrightarrow> bounded_clinear (\\<lambda>x. \\<Sum>i\\<in>I. f i x)\"", "lemma bounded_clinear_compose:\n  assumes \"bounded_clinear f\"\n    and \"bounded_clinear g\"\n  shows \"bounded_clinear (\\<lambda>x. f (g x))\"", "lemma bounded_cbilinear_mult: \"bounded_cbilinear ((*) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a::complex_normed_algebra)\"", "lemma bounded_clinear_mult_left: \"bounded_clinear (\\<lambda>x::'a::complex_normed_algebra. x * y)\"", "lemma bounded_clinear_mult_right: \"bounded_clinear (\\<lambda>y::'a::complex_normed_algebra. x * y)\"", "lemmas bounded_clinear_mult_const =\n  bounded_clinear_mult_left [THEN bounded_clinear_compose]", "lemmas bounded_clinear_const_mult =\n  bounded_clinear_mult_right [THEN bounded_clinear_compose]", "lemma bounded_clinear_divide: \"bounded_clinear (\\<lambda>x. x / y)\"\n  for y :: \"'a::complex_normed_field\"", "lemma bounded_cbilinear_scaleC: \"bounded_cbilinear scaleC\"", "lemma bounded_clinear_scaleC_left: \"bounded_clinear (\\<lambda>c. scaleC c x)\"", "lemma bounded_clinear_scaleC_right: \"bounded_clinear (\\<lambda>x. scaleC c x)\"", "lemmas bounded_clinear_scaleC_const =\n  bounded_clinear_scaleC_left[THEN bounded_clinear_compose]", "lemmas bounded_clinear_const_scaleC =\n  bounded_clinear_scaleC_right[THEN bounded_clinear_compose]", "lemma bounded_clinear_of_complex: \"bounded_clinear (\\<lambda>r. of_complex r)\"", "lemma complex_bounded_clinear: \"bounded_clinear f \\<longleftrightarrow> (\\<exists>c::complex. f = (\\<lambda>x. x * c))\"\n  for f :: \"complex \\<Rightarrow> complex\"", "lemma cCauchy_iff2: \"Cauchy X \\<longleftrightarrow> (\\<forall>j. (\\<exists>M. \\<forall>m \\<ge> M. \\<forall>n \\<ge> M. cmod (X m - X n) < inverse (real (Suc j))))\"", "lemma complex_increasing_LIMSEQ:\n  fixes f :: \"nat \\<Rightarrow> complex\"\n  assumes inc: \"\\<And>n. f n \\<le> f (Suc n)\"\n    and bdd: \"\\<And>n. f n \\<le> l\"\n    and en: \"\\<And>e. 0 < e \\<Longrightarrow> \\<exists>n. l \\<le> f n + e\"\n  shows \"f \\<longlonglongrightarrow> l\"", "lemma complex_Cauchy_convergent:\n  fixes X :: \"nat \\<Rightarrow> complex\"\n  assumes X: \"Cauchy X\"\n  shows \"convergent X\""], "translations": [["", "lemmas scaleC = scale"], ["", "end"], ["", "global_interpretation complex_vector: vector_space \"scaleC :: complex \\<Rightarrow> 'a \\<Rightarrow> 'a :: complex_vector\"\n  rewrites \"Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear\"\n    and \"Vector_Spaces.linear (*) (*\\<^sub>C) = clinear\"\n  defines cdependent_raw_def: cdependent = complex_vector.dependent\n    and crepresentation_raw_def: crepresentation = complex_vector.representation\n    and csubspace_raw_def: csubspace = complex_vector.subspace\n    and cspan_raw_def: cspan = complex_vector.span\n    and cextend_basis_raw_def: cextend_basis = complex_vector.extend_basis\n    and cdim_raw_def: cdim = complex_vector.dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_space (*\\<^sub>C) &&&\n    Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear &&&\n    Vector_Spaces.linear (*) (*\\<^sub>C) = clinear", "proof unfold_locales"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 2. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 3. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 4. \\<And>x. 1 *\\<^sub>C x = x\n 5. Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear\n 6. Vector_Spaces.linear (*) (*\\<^sub>C) = clinear", "show \"Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear\" \"Vector_Spaces.linear (*) (*\\<^sub>C) = clinear\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear &&&\n    Vector_Spaces.linear (*) (*\\<^sub>C) = clinear", "by (force simp: clinear_def complex_scaleC_def[abs_def])+"], ["proof (state)\nthis:\n  Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear\n  Vector_Spaces.linear (*) (*\\<^sub>C) = clinear\n\ngoal (4 subgoals):\n 1. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 2. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 3. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 4. \\<And>x. 1 *\\<^sub>C x = x", "qed (use scaleC_add_right scaleC_add_left in auto)"], ["", "(* Not needed since we did the global_interpretation with mandatory complex_vector-prefix:\nhide_const (open)\\<comment> \\<open>locale constants\\<close>\n  complex_vector.dependent\n  complex_vector.independent\n  complex_vector.representation\n  complex_vector.subspace\n  complex_vector.span\n  complex_vector.extend_basis\n  complex_vector.dim *)"], ["", "abbreviation \"cindependent x \\<equiv> \\<not> cdependent x\""], ["", "global_interpretation complex_vector: vector_space_pair \"scaleC::_\\<Rightarrow>_\\<Rightarrow>'a::complex_vector\" \"scaleC::_\\<Rightarrow>_\\<Rightarrow>'b::complex_vector\"\n  rewrites  \"Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear\"\n    and \"Vector_Spaces.linear (*) (*\\<^sub>C) = clinear\"\n  defines cconstruct_raw_def: cconstruct = complex_vector.construct"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_space_pair (*\\<^sub>C) (*\\<^sub>C) &&&\n    Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear &&&\n    Vector_Spaces.linear (*) (*\\<^sub>C) = clinear", "proof unfold_locales"], ["proof (state)\ngoal (2 subgoals):\n 1. Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear\n 2. Vector_Spaces.linear (*) (*\\<^sub>C) = clinear", "show \"Vector_Spaces.linear (*) (*\\<^sub>C) = clinear\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vector_Spaces.linear (*) (*\\<^sub>C) = clinear", "unfolding clinear_def complex_scaleC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Vector_Spaces.linear (*) (*\\<^sub>C) =\n    Vector_Spaces.linear (*) (*\\<^sub>C)", "by auto"], ["proof (state)\nthis:\n  Vector_Spaces.linear (*) (*\\<^sub>C) = clinear\n\ngoal (1 subgoal):\n 1. Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear", "qed (auto simp: clinear_def)"], ["", "(* Not needed since we did the global_interpretation with mandatory complex_vector-prefix:\nhide_const (open)\\<comment> \\<open>locale constants\\<close>\n  complex_vector.construct *)"], ["", "lemma clinear_compose: \"clinear f \\<Longrightarrow> clinear g \\<Longrightarrow> clinear (g \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>clinear f; clinear g\\<rbrakk>\n    \\<Longrightarrow> clinear (g \\<circ> f)", "unfolding clinear_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) f;\n     Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) g\\<rbrakk>\n    \\<Longrightarrow> Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C)\n                       (g \\<circ> f)", "by (rule Vector_Spaces.linear_compose)"], ["", "text \\<open>Recover original theorem names\\<close>"], ["", "lemmas scaleC_left_commute = complex_vector.scale_left_commute"], ["", "lemmas scaleC_zero_left = complex_vector.scale_zero_left"], ["", "lemmas scaleC_minus_left = complex_vector.scale_minus_left"], ["", "lemmas scaleC_diff_left = complex_vector.scale_left_diff_distrib"], ["", "lemmas scaleC_sum_left = complex_vector.scale_sum_left"], ["", "lemmas scaleC_zero_right = complex_vector.scale_zero_right"], ["", "lemmas scaleC_minus_right = complex_vector.scale_minus_right"], ["", "lemmas scaleC_diff_right = complex_vector.scale_right_diff_distrib"], ["", "lemmas scaleC_sum_right = complex_vector.scale_sum_right"], ["", "lemmas scaleC_eq_0_iff = complex_vector.scale_eq_0_iff"], ["", "lemmas scaleC_left_imp_eq = complex_vector.scale_left_imp_eq"], ["", "lemmas scaleC_right_imp_eq = complex_vector.scale_right_imp_eq"], ["", "lemmas scaleC_cancel_left = complex_vector.scale_cancel_left"], ["", "lemmas scaleC_cancel_right = complex_vector.scale_cancel_right"], ["", "lemma divideC_field_simps[field_simps]: (* In Real_Vector_Spaces, these lemmas are unnamed *)\n  \"c \\<noteq> 0 \\<Longrightarrow> a = b /\\<^sub>C c \\<longleftrightarrow> c *\\<^sub>C a = b\"\n  \"c \\<noteq> 0 \\<Longrightarrow> b /\\<^sub>C c = a \\<longleftrightarrow> b = c *\\<^sub>C a\"\n  \"c \\<noteq> 0 \\<Longrightarrow> a + b /\\<^sub>C c = (c *\\<^sub>C a + b) /\\<^sub>C c\"\n  \"c \\<noteq> 0 \\<Longrightarrow> a /\\<^sub>C c + b = (a + c *\\<^sub>C b) /\\<^sub>C c\"\n  \"c \\<noteq> 0 \\<Longrightarrow> a - b /\\<^sub>C c = (c *\\<^sub>C a - b) /\\<^sub>C c\"\n  \"c \\<noteq> 0 \\<Longrightarrow> a /\\<^sub>C c - b = (a - c *\\<^sub>C b) /\\<^sub>C c\"\n  \"c \\<noteq> 0 \\<Longrightarrow> - (a /\\<^sub>C c) + b = (- a + c *\\<^sub>C b) /\\<^sub>C c\"\n  \"c \\<noteq> 0 \\<Longrightarrow> - (a /\\<^sub>C c) - b = (- a - c *\\<^sub>C b) /\\<^sub>C c\"\n  for a b :: \"'a :: complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((c \\<noteq> 0 \\<Longrightarrow>\n       (a = b /\\<^sub>C c) = (c *\\<^sub>C a = b)) &&&\n      (c \\<noteq> 0 \\<Longrightarrow>\n       (b /\\<^sub>C c = a) = (b = c *\\<^sub>C a))) &&&\n     (c \\<noteq> 0 \\<Longrightarrow>\n      a + b /\\<^sub>C c = (c *\\<^sub>C a + b) /\\<^sub>C c) &&&\n     (c \\<noteq> 0 \\<Longrightarrow>\n      a /\\<^sub>C c + b = (a + c *\\<^sub>C b) /\\<^sub>C c)) &&&\n    ((c \\<noteq> 0 \\<Longrightarrow>\n      a - b /\\<^sub>C c = (c *\\<^sub>C a - b) /\\<^sub>C c) &&&\n     (c \\<noteq> 0 \\<Longrightarrow>\n      a /\\<^sub>C c - b = (a - c *\\<^sub>C b) /\\<^sub>C c)) &&&\n    (c \\<noteq> 0 \\<Longrightarrow>\n     - (a /\\<^sub>C c) + b = (- a + c *\\<^sub>C b) /\\<^sub>C c) &&&\n    (c \\<noteq> 0 \\<Longrightarrow>\n     - (a /\\<^sub>C c) - b = (- a - c *\\<^sub>C b) /\\<^sub>C c)", "by (auto simp add: scaleC_add_right scaleC_add_left scaleC_diff_right scaleC_diff_left)"], ["", "text \\<open>Legacy names -- omitted\\<close>"], ["", "(* lemmas scaleC_left_distrib = scaleC_add_left\nlemmas scaleC_right_distrib = scaleC_add_right\nlemmas scaleC_left_diff_distrib = scaleC_diff_left\nlemmas scaleC_right_diff_distrib = scaleC_diff_right *)"], ["", "lemmas clinear_injective_0 = linear_inj_iff_eq_0\n  and clinear_injective_on_subspace_0 = linear_inj_on_iff_eq_0\n  and clinear_cmul = linear_scale\n  and clinear_scaleC = linear_scale_self\n  and csubspace_mul = subspace_scale\n  and cspan_linear_image = linear_span_image\n  and cspan_0 = span_zero\n  and cspan_mul = span_scale\n  and injective_scaleC = injective_scale"], ["", "lemma scaleC_minus1_left [simp]: \"scaleC (-1) x = - x\"\n  for x :: \"'a::complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 *\\<^sub>C x = - x", "using scaleC_minus_left [of 1 x]"], ["proof (prove)\nusing this:\n  - 1 *\\<^sub>C x = - (1 *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. - 1 *\\<^sub>C x = - x", "by simp"], ["", "lemma scaleC_2:\n  fixes x :: \"'a::complex_vector\"\n  shows \"scaleC 2 x = x + x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\\<^sub>C x = x + x", "unfolding one_add_one [symmetric] scaleC_add_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 *\\<^sub>C x + 1 *\\<^sub>C x = x + x", "by simp"], ["", "lemma scaleC_half_double [simp]:\n  fixes a :: \"'a::complex_vector\"\n  shows \"(1 / 2) *\\<^sub>C (a + a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>C (a + a) = a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>C (a + a) = a", "have \"\\<And>r. r *\\<^sub>C (a + a) = (r * 2) *\\<^sub>C a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r. r *\\<^sub>C (a + a) = (r * 2) *\\<^sub>C a", "by (metis scaleC_2 scaleC_scaleC)"], ["proof (state)\nthis:\n  ?r *\\<^sub>C (a + a) = (?r * 2) *\\<^sub>C a\n\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>C (a + a) = a", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?r *\\<^sub>C (a + a) = (?r * 2) *\\<^sub>C a\n\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>C (a + a) = a", "by simp"], ["proof (state)\nthis:\n  (1 / 2) *\\<^sub>C (a + a) = a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma clinear_scale_complex:\n  fixes c::complex shows \"clinear f \\<Longrightarrow> f (c * b) = c * f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear f \\<Longrightarrow> f (c * b) = c * f b", "using complex_vector.linear_scale"], ["proof (prove)\nusing this:\n  clinear ?f \\<Longrightarrow> ?f (?r *\\<^sub>C ?b) = ?r *\\<^sub>C ?f ?b\n\ngoal (1 subgoal):\n 1. clinear f \\<Longrightarrow> f (c * b) = c * f b", "by fastforce"], ["", "interpretation scaleC_left: additive \"(\\<lambda>a. scaleC a x :: 'a::complex_vector)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. additive (\\<lambda>a. a *\\<^sub>C x)", "by standard (rule scaleC_add_left)"], ["", "interpretation scaleC_right: additive \"(\\<lambda>x. scaleC a x :: 'a::complex_vector)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. additive ((*\\<^sub>C) a)", "by standard (rule scaleC_add_right)"], ["", "lemma nonzero_inverse_scaleC_distrib:\n  \"a \\<noteq> 0 \\<Longrightarrow> x \\<noteq> 0 \\<Longrightarrow> inverse (scaleC a x) = scaleC (inverse a) (inverse x)\"\n  for x :: \"'a::complex_div_algebra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> 0; x \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> inverse (a *\\<^sub>C x) = inverse x /\\<^sub>C a", "by (rule inverse_unique) simp"], ["", "lemma inverse_scaleC_distrib: \"inverse (scaleC a x) = scaleC (inverse a) (inverse x)\"\n  for x :: \"'a::{complex_div_algebra,division_ring}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (a *\\<^sub>C x) = inverse x /\\<^sub>C a", "by (metis inverse_zero nonzero_inverse_scaleC_distrib complex_vector.scale_eq_0_iff)"], ["", "(* lemmas sum_constant_scaleC = real_vector.sum_constant_scale\\<comment> \\<open>legacy name\\<close> *)\n\n(* Defined in Real_Vector_Spaces:\nnamed_theorems vector_add_divide_simps \"to simplify sums of scaled vectors\" *)"], ["", "lemma complex_add_divide_simps[vector_add_divide_simps]:  (* In Real_Vector_Spaces, these lemmas are unnamed *)\n  \"v + (b / z) *\\<^sub>C w = (if z = 0 then v else (z *\\<^sub>C v + b *\\<^sub>C w) /\\<^sub>C z)\"\n  \"a *\\<^sub>C v + (b / z) *\\<^sub>C w = (if z = 0 then a *\\<^sub>C v else ((a * z) *\\<^sub>C v + b *\\<^sub>C w) /\\<^sub>C z)\"\n  \"(a / z) *\\<^sub>C v + w = (if z = 0 then w else (a *\\<^sub>C v + z *\\<^sub>C w) /\\<^sub>C z)\"\n  \"(a / z) *\\<^sub>C v + b *\\<^sub>C w = (if z = 0 then b *\\<^sub>C w else (a *\\<^sub>C v + (b * z) *\\<^sub>C w) /\\<^sub>C z)\"\n  \"v - (b / z) *\\<^sub>C w = (if z = 0 then v else (z *\\<^sub>C v - b *\\<^sub>C w) /\\<^sub>C z)\"\n  \"a *\\<^sub>C v - (b / z) *\\<^sub>C w = (if z = 0 then a *\\<^sub>C v else ((a * z) *\\<^sub>C v - b *\\<^sub>C w) /\\<^sub>C z)\"\n  \"(a / z) *\\<^sub>C v - w = (if z = 0 then -w else (a *\\<^sub>C v - z *\\<^sub>C w) /\\<^sub>C z)\"\n  \"(a / z) *\\<^sub>C v - b *\\<^sub>C w = (if z = 0 then -b *\\<^sub>C w else (a *\\<^sub>C v - (b * z) *\\<^sub>C w) /\\<^sub>C z)\"\n  for v :: \"'a :: complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((v + (b / z) *\\<^sub>C w =\n      (if z = 0 then v else (z *\\<^sub>C v + b *\\<^sub>C w) /\\<^sub>C z) &&&\n      a *\\<^sub>C v + (b / z) *\\<^sub>C w =\n      (if z = 0 then a *\\<^sub>C v\n       else ((a * z) *\\<^sub>C v + b *\\<^sub>C w) /\\<^sub>C z)) &&&\n     (a / z) *\\<^sub>C v + w =\n     (if z = 0 then w else (a *\\<^sub>C v + z *\\<^sub>C w) /\\<^sub>C z) &&&\n     (a / z) *\\<^sub>C v + b *\\<^sub>C w =\n     (if z = 0 then b *\\<^sub>C w\n      else (a *\\<^sub>C v + (b * z) *\\<^sub>C w) /\\<^sub>C z)) &&&\n    (v - (b / z) *\\<^sub>C w =\n     (if z = 0 then v else (z *\\<^sub>C v - b *\\<^sub>C w) /\\<^sub>C z) &&&\n     a *\\<^sub>C v - (b / z) *\\<^sub>C w =\n     (if z = 0 then a *\\<^sub>C v\n      else ((a * z) *\\<^sub>C v - b *\\<^sub>C w) /\\<^sub>C z)) &&&\n    (a / z) *\\<^sub>C v - w =\n    (if z = 0 then - w else (a *\\<^sub>C v - z *\\<^sub>C w) /\\<^sub>C z) &&&\n    (a / z) *\\<^sub>C v - b *\\<^sub>C w =\n    (if z = 0 then - b *\\<^sub>C w\n     else (a *\\<^sub>C v - (b * z) *\\<^sub>C w) /\\<^sub>C z)", "by (simp_all add: divide_inverse_commute scaleC_add_right scaleC_diff_right)"], ["", "lemma ceq_vector_fraction_iff [vector_add_divide_simps]:\n  fixes x :: \"'a :: complex_vector\"\n  shows \"(x = (u / v) *\\<^sub>C a) \\<longleftrightarrow> (if v=0 then x = 0 else v *\\<^sub>C x = u *\\<^sub>C a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = (u / v) *\\<^sub>C a) =\n    (if v = 0 then x = (0::'a) else v *\\<^sub>C x = u *\\<^sub>C a)", "by auto (metis (no_types) divide_eq_1_iff divide_inverse_commute scaleC_one scaleC_scaleC)"], ["", "lemma cvector_fraction_eq_iff [vector_add_divide_simps]:\n  fixes x :: \"'a :: complex_vector\"\n  shows \"((u / v) *\\<^sub>C a = x) \\<longleftrightarrow> (if v=0 then x = 0 else u *\\<^sub>C a = v *\\<^sub>C x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((u / v) *\\<^sub>C a = x) =\n    (if v = 0 then x = (0::'a) else u *\\<^sub>C a = v *\\<^sub>C x)", "by (metis ceq_vector_fraction_iff)"], ["", "lemma complex_vector_affinity_eq:\n  fixes x :: \"'a :: complex_vector\"\n  assumes m0: \"m \\<noteq> 0\"\n  shows \"m *\\<^sub>C x + c = y \\<longleftrightarrow> x = inverse m *\\<^sub>C y - (inverse m *\\<^sub>C c)\"\n    (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m *\\<^sub>C x + c = y) = (x = y /\\<^sub>C m - c /\\<^sub>C m)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. m *\\<^sub>C x + c = y \\<Longrightarrow>\n    x = y /\\<^sub>C m - c /\\<^sub>C m\n 2. x = y /\\<^sub>C m - c /\\<^sub>C m \\<Longrightarrow>\n    m *\\<^sub>C x + c = y", "assume ?lhs"], ["proof (state)\nthis:\n  m *\\<^sub>C x + c = y\n\ngoal (2 subgoals):\n 1. m *\\<^sub>C x + c = y \\<Longrightarrow>\n    x = y /\\<^sub>C m - c /\\<^sub>C m\n 2. x = y /\\<^sub>C m - c /\\<^sub>C m \\<Longrightarrow>\n    m *\\<^sub>C x + c = y", "hence \"m *\\<^sub>C x = y - c\""], ["proof (prove)\nusing this:\n  m *\\<^sub>C x + c = y\n\ngoal (1 subgoal):\n 1. m *\\<^sub>C x = y - c", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  m *\\<^sub>C x = y - c\n\ngoal (2 subgoals):\n 1. m *\\<^sub>C x + c = y \\<Longrightarrow>\n    x = y /\\<^sub>C m - c /\\<^sub>C m\n 2. x = y /\\<^sub>C m - c /\\<^sub>C m \\<Longrightarrow>\n    m *\\<^sub>C x + c = y", "hence \"inverse m *\\<^sub>C (m *\\<^sub>C x) = inverse m *\\<^sub>C (y - c)\""], ["proof (prove)\nusing this:\n  m *\\<^sub>C x = y - c\n\ngoal (1 subgoal):\n 1. m *\\<^sub>C x /\\<^sub>C m = (y - c) /\\<^sub>C m", "by simp"], ["proof (state)\nthis:\n  m *\\<^sub>C x /\\<^sub>C m = (y - c) /\\<^sub>C m\n\ngoal (2 subgoals):\n 1. m *\\<^sub>C x + c = y \\<Longrightarrow>\n    x = y /\\<^sub>C m - c /\\<^sub>C m\n 2. x = y /\\<^sub>C m - c /\\<^sub>C m \\<Longrightarrow>\n    m *\\<^sub>C x + c = y", "thus \"x = inverse m *\\<^sub>C y - (inverse m *\\<^sub>C c)\""], ["proof (prove)\nusing this:\n  m *\\<^sub>C x /\\<^sub>C m = (y - c) /\\<^sub>C m\n\ngoal (1 subgoal):\n 1. x = y /\\<^sub>C m - c /\\<^sub>C m", "using m0"], ["proof (prove)\nusing this:\n  m *\\<^sub>C x /\\<^sub>C m = (y - c) /\\<^sub>C m\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x = y /\\<^sub>C m - c /\\<^sub>C m", "by (simp add: complex_vector.scale_right_diff_distrib)"], ["proof (state)\nthis:\n  x = y /\\<^sub>C m - c /\\<^sub>C m\n\ngoal (1 subgoal):\n 1. x = y /\\<^sub>C m - c /\\<^sub>C m \\<Longrightarrow>\n    m *\\<^sub>C x + c = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y /\\<^sub>C m - c /\\<^sub>C m \\<Longrightarrow>\n    m *\\<^sub>C x + c = y", "assume ?rhs"], ["proof (state)\nthis:\n  x = y /\\<^sub>C m - c /\\<^sub>C m\n\ngoal (1 subgoal):\n 1. x = y /\\<^sub>C m - c /\\<^sub>C m \\<Longrightarrow>\n    m *\\<^sub>C x + c = y", "with m0"], ["proof (chain)\npicking this:\n  m \\<noteq> 0\n  x = y /\\<^sub>C m - c /\\<^sub>C m", "show \"m *\\<^sub>C x + c = y\""], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n  x = y /\\<^sub>C m - c /\\<^sub>C m\n\ngoal (1 subgoal):\n 1. m *\\<^sub>C x + c = y", "by (simp add: complex_vector.scale_right_diff_distrib)"], ["proof (state)\nthis:\n  m *\\<^sub>C x + c = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complex_vector_eq_affinity: \"m \\<noteq> 0 \\<Longrightarrow> y = m *\\<^sub>C x + c \\<longleftrightarrow> inverse m *\\<^sub>C y - (inverse m *\\<^sub>C c) = x\"\n  for x :: \"'a::complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    (y = m *\\<^sub>C x + c) = (y /\\<^sub>C m - c /\\<^sub>C m = x)", "using complex_vector_affinity_eq[where m=m and x=x and y=y and c=c]"], ["proof (prove)\nusing this:\n  m \\<noteq> 0 \\<Longrightarrow>\n  (m *\\<^sub>C x + c = y) = (x = y /\\<^sub>C m - c /\\<^sub>C m)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 \\<Longrightarrow>\n    (y = m *\\<^sub>C x + c) = (y /\\<^sub>C m - c /\\<^sub>C m = x)", "by metis"], ["", "lemma scaleC_eq_iff [simp]: \"b + u *\\<^sub>C a = a + u *\\<^sub>C b \\<longleftrightarrow> a = b \\<or> u = 1\"\n  for a :: \"'a::complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b + u *\\<^sub>C a = a + u *\\<^sub>C b) = (a = b \\<or> u = 1)", "proof (cases \"u = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    (b + u *\\<^sub>C a = a + u *\\<^sub>C b) = (a = b \\<or> u = 1)\n 2. u \\<noteq> 1 \\<Longrightarrow>\n    (b + u *\\<^sub>C a = a + u *\\<^sub>C b) = (a = b \\<or> u = 1)", "case True"], ["proof (state)\nthis:\n  u = 1\n\ngoal (2 subgoals):\n 1. u = 1 \\<Longrightarrow>\n    (b + u *\\<^sub>C a = a + u *\\<^sub>C b) = (a = b \\<or> u = 1)\n 2. u \\<noteq> 1 \\<Longrightarrow>\n    (b + u *\\<^sub>C a = a + u *\\<^sub>C b) = (a = b \\<or> u = 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  u = 1\n\ngoal (1 subgoal):\n 1. (b + u *\\<^sub>C a = a + u *\\<^sub>C b) = (a = b \\<or> u = 1)", "by auto"], ["proof (state)\nthis:\n  (b + u *\\<^sub>C a = a + u *\\<^sub>C b) = (a = b \\<or> u = 1)\n\ngoal (1 subgoal):\n 1. u \\<noteq> 1 \\<Longrightarrow>\n    (b + u *\\<^sub>C a = a + u *\\<^sub>C b) = (a = b \\<or> u = 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> 1 \\<Longrightarrow>\n    (b + u *\\<^sub>C a = a + u *\\<^sub>C b) = (a = b \\<or> u = 1)", "case False"], ["proof (state)\nthis:\n  u \\<noteq> 1\n\ngoal (1 subgoal):\n 1. u \\<noteq> 1 \\<Longrightarrow>\n    (b + u *\\<^sub>C a = a + u *\\<^sub>C b) = (a = b \\<or> u = 1)", "have \"a = b\" if \"b + u *\\<^sub>C a = a + u *\\<^sub>C b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = b", "from that"], ["proof (chain)\npicking this:\n  b + u *\\<^sub>C a = a + u *\\<^sub>C b", "have \"(u - 1) *\\<^sub>C a = (u - 1) *\\<^sub>C b\""], ["proof (prove)\nusing this:\n  b + u *\\<^sub>C a = a + u *\\<^sub>C b\n\ngoal (1 subgoal):\n 1. (u - 1) *\\<^sub>C a = (u - 1) *\\<^sub>C b", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (u - 1) *\\<^sub>C a = (u - 1) *\\<^sub>C b\n\ngoal (1 subgoal):\n 1. a = b", "with False"], ["proof (chain)\npicking this:\n  u \\<noteq> 1\n  (u - 1) *\\<^sub>C a = (u - 1) *\\<^sub>C b", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<noteq> 1\n  (u - 1) *\\<^sub>C a = (u - 1) *\\<^sub>C b\n\ngoal (1 subgoal):\n 1. a = b", "by auto"], ["proof (state)\nthis:\n  a = b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b + u *\\<^sub>C a = a + u *\\<^sub>C b \\<Longrightarrow> a = b\n\ngoal (1 subgoal):\n 1. u \\<noteq> 1 \\<Longrightarrow>\n    (b + u *\\<^sub>C a = a + u *\\<^sub>C b) = (a = b \\<or> u = 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  b + u *\\<^sub>C a = a + u *\\<^sub>C b \\<Longrightarrow> a = b\n\ngoal (1 subgoal):\n 1. (b + u *\\<^sub>C a = a + u *\\<^sub>C b) = (a = b \\<or> u = 1)", "by auto"], ["proof (state)\nthis:\n  (b + u *\\<^sub>C a = a + u *\\<^sub>C b) = (a = b \\<or> u = 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scaleC_collapse [simp]: \"(1 - u) *\\<^sub>C a + u *\\<^sub>C a = a\"\n  for a :: \"'a::complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - u) *\\<^sub>C a + u *\\<^sub>C a = a", "by (simp add: algebra_simps)"], ["", "subsection \\<open>Embedding of the Complex Numbers into any \\<open>complex_algebra_1\\<close>: \\<open>of_complex\\<close>\\<close>"], ["", "definition of_complex :: \"complex \\<Rightarrow> 'a::complex_algebra_1\"\n  where \"of_complex c = scaleC c 1\""], ["", "lemma scaleC_conv_of_complex: \"scaleC r x = of_complex r * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>C x = of_complex r * x", "by (simp add: of_complex_def)"], ["", "lemma of_complex_0 [simp]: \"of_complex 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex 0 = (0::'a)", "by (simp add: of_complex_def)"], ["", "lemma of_complex_1 [simp]: \"of_complex 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex 1 = (1::'a)", "by (simp add: of_complex_def)"], ["", "lemma of_complex_add [simp]: \"of_complex (x + y) = of_complex x + of_complex y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (x + y) = of_complex x + of_complex y", "by (simp add: of_complex_def scaleC_add_left)"], ["", "lemma of_complex_minus [simp]: \"of_complex (- x) = - of_complex x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (- x) = - of_complex x", "by (simp add: of_complex_def)"], ["", "lemma of_complex_diff [simp]: \"of_complex (x - y) = of_complex x - of_complex y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (x - y) = of_complex x - of_complex y", "by (simp add: of_complex_def scaleC_diff_left)"], ["", "lemma of_complex_mult [simp]: \"of_complex (x * y) = of_complex x * of_complex y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (x * y) = of_complex x * of_complex y", "by (simp add: of_complex_def mult.commute)"], ["", "lemma of_complex_sum[simp]: \"of_complex (sum f s) = (\\<Sum>x\\<in>s. of_complex (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (sum f s) = (\\<Sum>x\\<in>s. of_complex (f x))", "by (induct s rule: infinite_finite_induct) auto"], ["", "lemma of_complex_prod[simp]: \"of_complex (prod f s) = (\\<Prod>x\\<in>s. of_complex (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (prod f s) = (\\<Prod>x\\<in>s. of_complex (f x))", "by (induct s rule: infinite_finite_induct) auto"], ["", "lemma nonzero_of_complex_inverse:\n  \"x \\<noteq> 0 \\<Longrightarrow> of_complex (inverse x) = inverse (of_complex x :: 'a::complex_div_algebra)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    of_complex (inverse x) = inverse (of_complex x)", "by (simp add: of_complex_def nonzero_inverse_scaleC_distrib)"], ["", "lemma of_complex_inverse [simp]:\n  \"of_complex (inverse x) = inverse (of_complex x :: 'a::{complex_div_algebra,division_ring})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (inverse x) = inverse (of_complex x)", "by (simp add: of_complex_def inverse_scaleC_distrib)"], ["", "lemma nonzero_of_complex_divide:\n  \"y \\<noteq> 0 \\<Longrightarrow> of_complex (x / y) = (of_complex x / of_complex y :: 'a::complex_field)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> 0 \\<Longrightarrow>\n    of_complex (x / y) = of_complex x / of_complex y", "by (simp add: divide_inverse nonzero_of_complex_inverse)"], ["", "lemma of_complex_divide [simp]:\n  \"of_complex (x / y) = (of_complex x / of_complex y :: 'a::complex_div_algebra)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (x / y) = of_complex x / of_complex y", "by (simp add: divide_inverse)"], ["", "lemma of_complex_power [simp]:\n  \"of_complex (x ^ n) = (of_complex x :: 'a::{complex_algebra_1}) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (x ^ n) = of_complex x ^ n", "by (induct n) simp_all"], ["", "lemma of_complex_power_int [simp]:\n  \"of_complex (power_int x n) = power_int (of_complex x :: 'a :: {complex_div_algebra,division_ring}) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (x powi n) = of_complex x powi n", "by (auto simp: power_int_def)"], ["", "lemma of_complex_eq_iff [simp]: \"of_complex x = of_complex y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_complex x = of_complex y) = (x = y)", "by (simp add: of_complex_def)"], ["", "lemma inj_of_complex: \"inj of_complex\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj of_complex", "by (auto intro: injI)"], ["", "lemmas of_complex_eq_0_iff [simp] = of_complex_eq_iff [of _ 0, simplified]"], ["", "lemmas of_complex_eq_1_iff [simp] = of_complex_eq_iff [of _ 1, simplified]"], ["", "lemma minus_of_complex_eq_of_complex_iff [simp]: \"-of_complex x = of_complex y \\<longleftrightarrow> -x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- of_complex x = of_complex y) = (- x = y)", "using of_complex_eq_iff[of \"-x\" y]"], ["proof (prove)\nusing this:\n  (of_complex (- x) = of_complex y) = (- x = y)\n\ngoal (1 subgoal):\n 1. (- of_complex x = of_complex y) = (- x = y)", "by (simp only: of_complex_minus)"], ["", "lemma of_complex_eq_minus_of_complex_iff [simp]: \"of_complex x = -of_complex y \\<longleftrightarrow> x = -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_complex x = - of_complex y) = (x = - y)", "using of_complex_eq_iff[of x \"-y\"]"], ["proof (prove)\nusing this:\n  (of_complex x = of_complex (- y)) = (x = - y)\n\ngoal (1 subgoal):\n 1. (of_complex x = - of_complex y) = (x = - y)", "by (simp only: of_complex_minus)"], ["", "lemma of_complex_eq_id [simp]: \"of_complex = (id :: complex \\<Rightarrow> complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex = id", "by (rule ext) (simp add: of_complex_def)"], ["", "text \\<open>Collapse nested embeddings.\\<close>"], ["", "lemma of_complex_of_nat_eq [simp]: \"of_complex (of_nat n) = of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (of_nat n) = of_nat n", "by (induct n) auto"], ["", "lemma of_complex_of_int_eq [simp]: \"of_complex (of_int z) = of_int z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (of_int z) = of_int z", "by (cases z rule: int_diff_cases) simp"], ["", "lemma of_complex_numeral [simp]: \"of_complex (numeral w) = numeral w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (numeral w) = numeral w", "using of_complex_of_int_eq [of \"numeral w\"]"], ["proof (prove)\nusing this:\n  of_complex (of_int (numeral w)) = of_int (numeral w)\n\ngoal (1 subgoal):\n 1. of_complex (numeral w) = numeral w", "by simp"], ["", "lemma of_complex_neg_numeral [simp]: \"of_complex (- numeral w) = - numeral w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (- numeral w) = - numeral w", "using of_complex_of_int_eq [of \"- numeral w\"]"], ["proof (prove)\nusing this:\n  of_complex (of_int (- numeral w)) = of_int (- numeral w)\n\ngoal (1 subgoal):\n 1. of_complex (- numeral w) = - numeral w", "by simp"], ["", "lemma numeral_power_int_eq_of_complex_cancel_iff [simp]:\n  \"power_int (numeral x) n = (of_complex y :: 'a :: {complex_div_algebra, division_ring}) \\<longleftrightarrow>\n     power_int (numeral x) n = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (numeral x powi n = of_complex y) = (numeral x powi n = y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (numeral x powi n = of_complex y) = (numeral x powi n = y)", "have \"power_int (numeral x) n = (of_complex (power_int (numeral x) n) :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral x powi n = of_complex (numeral x powi n)", "by simp"], ["proof (state)\nthis:\n  numeral x powi n = of_complex (numeral x powi n)\n\ngoal (1 subgoal):\n 1. (numeral x powi n = of_complex y) = (numeral x powi n = y)", "also"], ["proof (state)\nthis:\n  numeral x powi n = of_complex (numeral x powi n)\n\ngoal (1 subgoal):\n 1. (numeral x powi n = of_complex y) = (numeral x powi n = y)", "have \"\\<dots> = of_complex y \\<longleftrightarrow> power_int (numeral x) n = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_complex (numeral x powi n) = of_complex y) = (numeral x powi n = y)", "by (subst of_complex_eq_iff) auto"], ["proof (state)\nthis:\n  (of_complex (numeral x powi n) = of_complex y) = (numeral x powi n = y)\n\ngoal (1 subgoal):\n 1. (numeral x powi n = of_complex y) = (numeral x powi n = y)", "finally"], ["proof (chain)\npicking this:\n  (numeral x powi n = of_complex y) = (numeral x powi n = y)", "show ?thesis"], ["proof (prove)\nusing this:\n  (numeral x powi n = of_complex y) = (numeral x powi n = y)\n\ngoal (1 subgoal):\n 1. (numeral x powi n = of_complex y) = (numeral x powi n = y)", "."], ["proof (state)\nthis:\n  (numeral x powi n = of_complex y) = (numeral x powi n = y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_complex_eq_numeral_power_int_cancel_iff [simp]:\n  \"(of_complex y :: 'a :: {complex_div_algebra, division_ring}) = power_int (numeral x) n \\<longleftrightarrow>\n     y = power_int (numeral x) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_complex y = numeral x powi n) = (y = numeral x powi n)", "by (subst (1 2) eq_commute) simp"], ["", "lemma of_complex_eq_of_complex_power_int_cancel_iff [simp]:\n  \"power_int (of_complex b :: 'a :: {complex_div_algebra, division_ring}) w = of_complex x \\<longleftrightarrow>\n     power_int b w = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_complex b powi w = of_complex x) = (b powi w = x)", "by (metis of_complex_power_int of_complex_eq_iff)"], ["", "lemma of_complex_in_Ints_iff [simp]: \"of_complex x \\<in> \\<int> \\<longleftrightarrow> x \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_complex x \\<in> \\<int>) = (x \\<in> \\<int>)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. of_complex x \\<in> \\<int> \\<Longrightarrow> x \\<in> \\<int>\n 2. x \\<in> \\<int> \\<Longrightarrow> of_complex x \\<in> \\<int>", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. of_complex x \\<in> \\<int> \\<Longrightarrow> x \\<in> \\<int>\n 2. x \\<in> \\<int> \\<Longrightarrow> of_complex x \\<in> \\<int>", "assume \"(of_complex x :: 'a) \\<in> \\<int>\""], ["proof (state)\nthis:\n  of_complex x \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. of_complex x \\<in> \\<int> \\<Longrightarrow> x \\<in> \\<int>\n 2. x \\<in> \\<int> \\<Longrightarrow> of_complex x \\<in> \\<int>", "then"], ["proof (chain)\npicking this:\n  of_complex x \\<in> \\<int>", "obtain n where \"(of_complex x :: 'a) = of_int n\""], ["proof (prove)\nusing this:\n  of_complex x \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        of_complex x = of_int n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Ints_def)"], ["proof (state)\nthis:\n  of_complex x = of_int n\n\ngoal (2 subgoals):\n 1. of_complex x \\<in> \\<int> \\<Longrightarrow> x \\<in> \\<int>\n 2. x \\<in> \\<int> \\<Longrightarrow> of_complex x \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  of_complex x = of_int n\n\ngoal (2 subgoals):\n 1. of_complex x \\<in> \\<int> \\<Longrightarrow> x \\<in> \\<int>\n 2. x \\<in> \\<int> \\<Longrightarrow> of_complex x \\<in> \\<int>", "have \"of_int n = of_complex (of_int n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int n = of_complex (of_int n)", "by simp"], ["proof (state)\nthis:\n  of_int n = of_complex (of_int n)\n\ngoal (2 subgoals):\n 1. of_complex x \\<in> \\<int> \\<Longrightarrow> x \\<in> \\<int>\n 2. x \\<in> \\<int> \\<Longrightarrow> of_complex x \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  of_complex x = of_complex (of_int n)", "have \"x = of_int n\""], ["proof (prove)\nusing this:\n  of_complex x = of_complex (of_int n)\n\ngoal (1 subgoal):\n 1. x = of_int n", "by (subst (asm) of_complex_eq_iff)"], ["proof (state)\nthis:\n  x = of_int n\n\ngoal (2 subgoals):\n 1. of_complex x \\<in> \\<int> \\<Longrightarrow> x \\<in> \\<int>\n 2. x \\<in> \\<int> \\<Longrightarrow> of_complex x \\<in> \\<int>", "thus \"x \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  x = of_int n\n\ngoal (1 subgoal):\n 1. x \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  x \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<int> \\<Longrightarrow> of_complex x \\<in> \\<int>", "qed (auto simp: Ints_def)"], ["", "lemma Ints_of_complex [intro]: \"x \\<in> \\<int> \\<Longrightarrow> of_complex x \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<int> \\<Longrightarrow> of_complex x \\<in> \\<int>", "by simp"], ["", "text \\<open>Every complex algebra has characteristic zero.\\<close>"], ["", "(* Inherited from real_algebra_1 *)\n(* instance complex_algebra_1 < ring_char_0 .. *)"], ["", "lemma fraction_scaleC_times [simp]:\n  fixes a :: \"'a::complex_algebra_1\"\n  shows \"(numeral u / numeral v) *\\<^sub>C (numeral w * a) = (numeral u * numeral w / numeral v) *\\<^sub>C a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (numeral u / numeral v) *\\<^sub>C (numeral w * a) =\n    (numeral u * numeral w / numeral v) *\\<^sub>C a", "by (metis (no_types, lifting) of_complex_numeral scaleC_conv_of_complex scaleC_scaleC times_divide_eq_left)"], ["", "lemma inverse_scaleC_times [simp]:\n  fixes a :: \"'a::complex_algebra_1\"\n  shows \"(1 / numeral v) *\\<^sub>C (numeral w * a) = (numeral w / numeral v) *\\<^sub>C a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / numeral v) *\\<^sub>C (numeral w * a) =\n    (numeral w / numeral v) *\\<^sub>C a", "by (metis divide_inverse_commute inverse_eq_divide of_complex_numeral scaleC_conv_of_complex scaleC_scaleC)"], ["", "lemma scaleC_times [simp]:\n  fixes a :: \"'a::complex_algebra_1\"\n  shows \"(numeral u) *\\<^sub>C (numeral w * a) = (numeral u * numeral w) *\\<^sub>C a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral u *\\<^sub>C (numeral w * a) =\n    (numeral u * numeral w) *\\<^sub>C a", "by (simp add: scaleC_conv_of_complex)"], ["", "(* Inherited from real_field *)\n(* instance complex_field < field_char_0 .. *)"], ["", "subsection \\<open>The Set of Real Numbers\\<close>"], ["", "definition Complexs :: \"'a::complex_algebra_1 set\"  (\"\\<complex>\")\n  where \"\\<complex> = range of_complex\""], ["", "lemma Complexs_of_complex [simp]: \"of_complex r \\<in> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex r \\<in> \\<complex>", "by (simp add: Complexs_def)"], ["", "lemma Complexs_of_int [simp]: \"of_int z \\<in> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int z \\<in> \\<complex>", "by (subst of_complex_of_int_eq [symmetric], rule Complexs_of_complex)"], ["", "lemma Complexs_of_nat [simp]: \"of_nat n \\<in> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n \\<in> \\<complex>", "by (subst of_complex_of_nat_eq [symmetric], rule Complexs_of_complex)"], ["", "lemma Complexs_numeral [simp]: \"numeral w \\<in> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral w \\<in> \\<complex>", "by (subst of_complex_numeral [symmetric], rule Complexs_of_complex)"], ["", "lemma Complexs_0 [simp]: \"0 \\<in> \\<complex>\" and Complexs_1 [simp]: \"1 \\<in> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> \\<complex> &&& (1::'b) \\<in> \\<complex>", "by (simp_all add: Complexs_def)"], ["", "lemma Complexs_add [simp]: \"a \\<in> \\<complex> \\<Longrightarrow> b \\<in> \\<complex> \\<Longrightarrow> a + b \\<in> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> \\<complex>; b \\<in> \\<complex>\\<rbrakk>\n    \\<Longrightarrow> a + b \\<in> \\<complex>", "apply (auto simp add: Complexs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>a = of_complex x; b = of_complex xa\\<rbrakk>\n       \\<Longrightarrow> of_complex x + of_complex xa \\<in> range of_complex", "by (metis of_complex_add range_eqI)"], ["", "lemma Complexs_minus [simp]: \"a \\<in> \\<complex> \\<Longrightarrow> - a \\<in> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<complex> \\<Longrightarrow> - a \\<in> \\<complex>", "by (auto simp: Complexs_def)"], ["", "lemma Complexs_minus_iff [simp]: \"- a \\<in> \\<complex> \\<longleftrightarrow> a \\<in> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- a \\<in> \\<complex>) = (a \\<in> \\<complex>)", "using Complexs_minus"], ["proof (prove)\nusing this:\n  ?a \\<in> \\<complex> \\<Longrightarrow> - ?a \\<in> \\<complex>\n\ngoal (1 subgoal):\n 1. (- a \\<in> \\<complex>) = (a \\<in> \\<complex>)", "by fastforce"], ["", "lemma Complexs_diff [simp]: \"a \\<in> \\<complex> \\<Longrightarrow> b \\<in> \\<complex> \\<Longrightarrow> a - b \\<in> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> \\<complex>; b \\<in> \\<complex>\\<rbrakk>\n    \\<Longrightarrow> a - b \\<in> \\<complex>", "by (metis Complexs_add Complexs_minus_iff add_uminus_conv_diff)"], ["", "lemma Complexs_mult [simp]: \"a \\<in> \\<complex> \\<Longrightarrow> b \\<in> \\<complex> \\<Longrightarrow> a * b \\<in> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> \\<complex>; b \\<in> \\<complex>\\<rbrakk>\n    \\<Longrightarrow> a * b \\<in> \\<complex>", "apply (auto simp add: Complexs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>a = of_complex x; b = of_complex xa\\<rbrakk>\n       \\<Longrightarrow> of_complex x * of_complex xa \\<in> range of_complex", "by (metis of_complex_mult rangeI)"], ["", "lemma nonzero_Complexs_inverse: \"a \\<in> \\<complex> \\<Longrightarrow> a \\<noteq> 0 \\<Longrightarrow> inverse a \\<in> \\<complex>\"\n  for a :: \"'a::complex_div_algebra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> \\<complex>; a \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> inverse a \\<in> \\<complex>", "apply (auto simp add: Complexs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> 0; a = of_complex x\\<rbrakk>\n       \\<Longrightarrow> inverse (of_complex x) \\<in> range of_complex", "by (metis of_complex_inverse range_eqI)"], ["", "lemma Complexs_inverse: \"a \\<in> \\<complex> \\<Longrightarrow> inverse a \\<in> \\<complex>\"\n  for a :: \"'a::{complex_div_algebra,division_ring}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<complex> \\<Longrightarrow> inverse a \\<in> \\<complex>", "using nonzero_Complexs_inverse"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> \\<complex>; ?a \\<noteq> (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> inverse ?a \\<in> \\<complex>\n\ngoal (1 subgoal):\n 1. a \\<in> \\<complex> \\<Longrightarrow> inverse a \\<in> \\<complex>", "by fastforce"], ["", "lemma Complexs_inverse_iff [simp]: \"inverse x \\<in> \\<complex> \\<longleftrightarrow> x \\<in> \\<complex>\"\n  for x :: \"'a::{complex_div_algebra,division_ring}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inverse x \\<in> \\<complex>) = (x \\<in> \\<complex>)", "by (metis Complexs_inverse inverse_inverse_eq)"], ["", "lemma nonzero_Complexs_divide: \"a \\<in> \\<complex> \\<Longrightarrow> b \\<in> \\<complex> \\<Longrightarrow> b \\<noteq> 0 \\<Longrightarrow> a / b \\<in> \\<complex>\"\n  for a b :: \"'a::complex_field\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> \\<complex>; b \\<in> \\<complex>;\n     b \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> a / b \\<in> \\<complex>", "by (simp add: divide_inverse)"], ["", "lemma Complexs_divide [simp]: \"a \\<in> \\<complex> \\<Longrightarrow> b \\<in> \\<complex> \\<Longrightarrow> a / b \\<in> \\<complex>\"\n  for a b :: \"'a::{complex_field,field}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> \\<complex>; b \\<in> \\<complex>\\<rbrakk>\n    \\<Longrightarrow> a / b \\<in> \\<complex>", "using nonzero_Complexs_divide"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> \\<complex>; ?b \\<in> \\<complex>;\n   ?b \\<noteq> (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?a / ?b \\<in> \\<complex>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> \\<complex>; b \\<in> \\<complex>\\<rbrakk>\n    \\<Longrightarrow> a / b \\<in> \\<complex>", "by fastforce"], ["", "lemma Complexs_power [simp]: \"a \\<in> \\<complex> \\<Longrightarrow> a ^ n \\<in> \\<complex>\"\n  for a :: \"'a::complex_algebra_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<complex> \\<Longrightarrow> a ^ n \\<in> \\<complex>", "apply (auto simp add: Complexs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = of_complex x \\<Longrightarrow>\n       of_complex x ^ n \\<in> range of_complex", "by (metis range_eqI of_complex_power[symmetric])"], ["", "lemma Complexs_cases [cases set: Complexs]:\n  assumes \"q \\<in> \\<complex>\"\n  obtains (of_complex) c where \"q = of_complex c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c. q = of_complex c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Complexs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c. q = of_complex c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c. q = of_complex c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>q \\<in> \\<complex>\\<close>"], ["proof (chain)\npicking this:\n  q \\<in> \\<complex>", "have \"q \\<in> range of_complex\""], ["proof (prove)\nusing this:\n  q \\<in> \\<complex>\n\ngoal (1 subgoal):\n 1. q \\<in> range of_complex", "unfolding Complexs_def"], ["proof (prove)\nusing this:\n  q \\<in> range of_complex\n\ngoal (1 subgoal):\n 1. q \\<in> range of_complex", "."], ["proof (state)\nthis:\n  q \\<in> range of_complex\n\ngoal (1 subgoal):\n 1. (\\<And>c. q = of_complex c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  q \\<in> range of_complex", "obtain c where \"q = of_complex c\""], ["proof (prove)\nusing this:\n  q \\<in> range of_complex\n\ngoal (1 subgoal):\n 1. (\\<And>c. q = of_complex c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  q = of_complex c\n\ngoal (1 subgoal):\n 1. (\\<And>c. q = of_complex c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  q = of_complex c", "show thesis"], ["proof (prove)\nusing this:\n  q = of_complex c\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_in_Complexs [intro,simp]: \"(\\<And>i. i \\<in> s \\<Longrightarrow> f i \\<in> \\<complex>) \\<Longrightarrow> sum f s \\<in> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> s \\<Longrightarrow> f i \\<in> \\<complex>) \\<Longrightarrow>\n    sum f s \\<in> \\<complex>", "proof (induct s rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>i. i \\<in> A \\<Longrightarrow> f i \\<in> \\<complex>\\<rbrakk>\n       \\<Longrightarrow> sum f A \\<in> \\<complex>\n 2. (\\<And>i.\n        i \\<in> {} \\<Longrightarrow> f i \\<in> \\<complex>) \\<Longrightarrow>\n    sum f {} \\<in> \\<complex>\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow>\n            f i \\<in> \\<complex>) \\<Longrightarrow>\n        sum f F \\<in> \\<complex>;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow>\n           f i \\<in> \\<complex>\\<rbrakk>\n       \\<Longrightarrow> sum f (insert x F) \\<in> \\<complex>", "case infinite"], ["proof (state)\nthis:\n  infinite A_\n  ?i \\<in> A_ \\<Longrightarrow> f ?i \\<in> \\<complex>\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>i. i \\<in> A \\<Longrightarrow> f i \\<in> \\<complex>\\<rbrakk>\n       \\<Longrightarrow> sum f A \\<in> \\<complex>\n 2. (\\<And>i.\n        i \\<in> {} \\<Longrightarrow> f i \\<in> \\<complex>) \\<Longrightarrow>\n    sum f {} \\<in> \\<complex>\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow>\n            f i \\<in> \\<complex>) \\<Longrightarrow>\n        sum f F \\<in> \\<complex>;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow>\n           f i \\<in> \\<complex>\\<rbrakk>\n       \\<Longrightarrow> sum f (insert x F) \\<in> \\<complex>", "then"], ["proof (chain)\npicking this:\n  infinite A_\n  ?i \\<in> A_ \\<Longrightarrow> f ?i \\<in> \\<complex>", "show ?case"], ["proof (prove)\nusing this:\n  infinite A_\n  ?i \\<in> A_ \\<Longrightarrow> f ?i \\<in> \\<complex>\n\ngoal (1 subgoal):\n 1. sum f A_ \\<in> \\<complex>", "by (metis Complexs_0 sum.infinite)"], ["proof (state)\nthis:\n  sum f A_ \\<in> \\<complex>\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i \\<in> {} \\<Longrightarrow> f i \\<in> \\<complex>) \\<Longrightarrow>\n    sum f {} \\<in> \\<complex>\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow>\n            f i \\<in> \\<complex>) \\<Longrightarrow>\n        sum f F \\<in> \\<complex>;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow>\n           f i \\<in> \\<complex>\\<rbrakk>\n       \\<Longrightarrow> sum f (insert x F) \\<in> \\<complex>", "qed simp_all"], ["", "lemma prod_in_Complexs [intro,simp]: \"(\\<And>i. i \\<in> s \\<Longrightarrow> f i \\<in> \\<complex>) \\<Longrightarrow> prod f s \\<in> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> s \\<Longrightarrow> f i \\<in> \\<complex>) \\<Longrightarrow>\n    prod f s \\<in> \\<complex>", "proof (induct s rule: infinite_finite_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>i. i \\<in> A \\<Longrightarrow> f i \\<in> \\<complex>\\<rbrakk>\n       \\<Longrightarrow> prod f A \\<in> \\<complex>\n 2. (\\<And>i.\n        i \\<in> {} \\<Longrightarrow> f i \\<in> \\<complex>) \\<Longrightarrow>\n    prod f {} \\<in> \\<complex>\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow>\n            f i \\<in> \\<complex>) \\<Longrightarrow>\n        prod f F \\<in> \\<complex>;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow>\n           f i \\<in> \\<complex>\\<rbrakk>\n       \\<Longrightarrow> prod f (insert x F) \\<in> \\<complex>", "case infinite"], ["proof (state)\nthis:\n  infinite A_\n  ?i \\<in> A_ \\<Longrightarrow> f ?i \\<in> \\<complex>\n\ngoal (3 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>infinite A;\n        \\<And>i. i \\<in> A \\<Longrightarrow> f i \\<in> \\<complex>\\<rbrakk>\n       \\<Longrightarrow> prod f A \\<in> \\<complex>\n 2. (\\<And>i.\n        i \\<in> {} \\<Longrightarrow> f i \\<in> \\<complex>) \\<Longrightarrow>\n    prod f {} \\<in> \\<complex>\n 3. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow>\n            f i \\<in> \\<complex>) \\<Longrightarrow>\n        prod f F \\<in> \\<complex>;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow>\n           f i \\<in> \\<complex>\\<rbrakk>\n       \\<Longrightarrow> prod f (insert x F) \\<in> \\<complex>", "then"], ["proof (chain)\npicking this:\n  infinite A_\n  ?i \\<in> A_ \\<Longrightarrow> f ?i \\<in> \\<complex>", "show ?case"], ["proof (prove)\nusing this:\n  infinite A_\n  ?i \\<in> A_ \\<Longrightarrow> f ?i \\<in> \\<complex>\n\ngoal (1 subgoal):\n 1. prod f A_ \\<in> \\<complex>", "by (metis Complexs_1 prod.infinite)"], ["proof (state)\nthis:\n  prod f A_ \\<in> \\<complex>\n\ngoal (2 subgoals):\n 1. (\\<And>i.\n        i \\<in> {} \\<Longrightarrow> f i \\<in> \\<complex>) \\<Longrightarrow>\n    prod f {} \\<in> \\<complex>\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow>\n            f i \\<in> \\<complex>) \\<Longrightarrow>\n        prod f F \\<in> \\<complex>;\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow>\n           f i \\<in> \\<complex>\\<rbrakk>\n       \\<Longrightarrow> prod f (insert x F) \\<in> \\<complex>", "qed simp_all"], ["", "lemma Complexs_induct [case_names of_complex, induct set: Complexs]:\n  \"q \\<in> \\<complex> \\<Longrightarrow> (\\<And>r. P (of_complex r)) \\<Longrightarrow> P q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> \\<complex>; \\<And>r. P (of_complex r)\\<rbrakk>\n    \\<Longrightarrow> P q", "by (rule Complexs_cases) auto"], ["", "subsection \\<open>Ordered complex vector spaces\\<close>"], ["", "class ordered_complex_vector = complex_vector + ordered_ab_group_add +\n  assumes scaleC_left_mono: \"x \\<le> y \\<Longrightarrow> 0 \\<le> a \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\"\n    and scaleC_right_mono: \"a \\<le> b \\<Longrightarrow> 0 \\<le> x \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x\"\nbegin"], ["", "subclass (in ordered_complex_vector) ordered_real_vector"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ordered_real_vector (+) (0::'a) (-) uminus (\\<le>) (<) (*\\<^sub>R)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>R x \\<le> a *\\<^sub>R y\n 2. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; (0::'a) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>R x \\<le> b *\\<^sub>R x", "by (auto simp add: less_eq_complex_def scaleC_left_mono scaleC_right_mono scaleR_scaleC)"], ["", "lemma scaleC_mono:\n  \"a \\<le> b \\<Longrightarrow> x \\<le> y \\<Longrightarrow> 0 \\<le> b \\<Longrightarrow> 0 \\<le> x \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; x \\<le> y; 0 \\<le> b; (0::'a) \\<le> x\\<rbrakk>\n    \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C y", "by (meson order_trans scaleC_left_mono scaleC_right_mono)"], ["", "lemma scaleC_mono':\n  \"a \\<le> b \\<Longrightarrow> c \\<le> d \\<Longrightarrow> 0 \\<le> a \\<Longrightarrow> 0 \\<le> c \\<Longrightarrow> a *\\<^sub>C c \\<le> b *\\<^sub>C d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; c \\<le> d; 0 \\<le> a; (0::'a) \\<le> c\\<rbrakk>\n    \\<Longrightarrow> a *\\<^sub>C c \\<le> b *\\<^sub>C d", "by (rule scaleC_mono) (auto intro: order.trans)"], ["", "lemma pos_le_divideC_eq [field_simps]:\n  \"a \\<le> b /\\<^sub>C c \\<longleftrightarrow> c *\\<^sub>C a \\<le> b\" (is \"?P \\<longleftrightarrow> ?Q\") if \"0 < c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> b /\\<^sub>C c) = (c *\\<^sub>C a \\<le> b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<le> b /\\<^sub>C c \\<Longrightarrow> c *\\<^sub>C a \\<le> b\n 2. c *\\<^sub>C a \\<le> b \\<Longrightarrow> a \\<le> b /\\<^sub>C c", "assume ?P"], ["proof (state)\nthis:\n  a \\<le> b /\\<^sub>C c\n\ngoal (2 subgoals):\n 1. a \\<le> b /\\<^sub>C c \\<Longrightarrow> c *\\<^sub>C a \\<le> b\n 2. c *\\<^sub>C a \\<le> b \\<Longrightarrow> a \\<le> b /\\<^sub>C c", "with scaleC_left_mono that"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<le> ?y; 0 \\<le> ?a\\<rbrakk>\n  \\<Longrightarrow> ?a *\\<^sub>C ?x \\<le> ?a *\\<^sub>C ?y\n  0 < c\n  a \\<le> b /\\<^sub>C c", "have \"c *\\<^sub>C a \\<le> c *\\<^sub>C (b /\\<^sub>C c)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; 0 \\<le> ?a\\<rbrakk>\n  \\<Longrightarrow> ?a *\\<^sub>C ?x \\<le> ?a *\\<^sub>C ?y\n  0 < c\n  a \\<le> b /\\<^sub>C c\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C a \\<le> c *\\<^sub>C (b /\\<^sub>C c)", "using preorder_class.less_imp_le"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; 0 \\<le> ?a\\<rbrakk>\n  \\<Longrightarrow> ?a *\\<^sub>C ?x \\<le> ?a *\\<^sub>C ?y\n  0 < c\n  a \\<le> b /\\<^sub>C c\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C a \\<le> c *\\<^sub>C (b /\\<^sub>C c)", "by blast"], ["proof (state)\nthis:\n  c *\\<^sub>C a \\<le> c *\\<^sub>C (b /\\<^sub>C c)\n\ngoal (2 subgoals):\n 1. a \\<le> b /\\<^sub>C c \\<Longrightarrow> c *\\<^sub>C a \\<le> b\n 2. c *\\<^sub>C a \\<le> b \\<Longrightarrow> a \\<le> b /\\<^sub>C c", "with that"], ["proof (chain)\npicking this:\n  0 < c\n  c *\\<^sub>C a \\<le> c *\\<^sub>C (b /\\<^sub>C c)", "show ?Q"], ["proof (prove)\nusing this:\n  0 < c\n  c *\\<^sub>C a \\<le> c *\\<^sub>C (b /\\<^sub>C c)\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C a \\<le> b", "by auto"], ["proof (state)\nthis:\n  c *\\<^sub>C a \\<le> b\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C a \\<le> b \\<Longrightarrow> a \\<le> b /\\<^sub>C c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c *\\<^sub>C a \\<le> b \\<Longrightarrow> a \\<le> b /\\<^sub>C c", "assume ?Q"], ["proof (state)\nthis:\n  c *\\<^sub>C a \\<le> b\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C a \\<le> b \\<Longrightarrow> a \\<le> b /\\<^sub>C c", "with scaleC_left_mono that"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<le> ?y; 0 \\<le> ?a\\<rbrakk>\n  \\<Longrightarrow> ?a *\\<^sub>C ?x \\<le> ?a *\\<^sub>C ?y\n  0 < c\n  c *\\<^sub>C a \\<le> b", "have \"c *\\<^sub>C a /\\<^sub>C c \\<le> b /\\<^sub>C c\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; 0 \\<le> ?a\\<rbrakk>\n  \\<Longrightarrow> ?a *\\<^sub>C ?x \\<le> ?a *\\<^sub>C ?y\n  0 < c\n  c *\\<^sub>C a \\<le> b\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C a /\\<^sub>C c \\<le> b /\\<^sub>C c", "using less_complex_def less_eq_complex_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; 0 \\<le> ?a\\<rbrakk>\n  \\<Longrightarrow> ?a *\\<^sub>C ?x \\<le> ?a *\\<^sub>C ?y\n  0 < c\n  c *\\<^sub>C a \\<le> b\n  ?x < ?y \\<equiv> Im ?x = Im ?y \\<and> Re ?x < Re ?y\n  ?x \\<le> ?y \\<equiv> Im ?x = Im ?y \\<and> Re ?x \\<le> Re ?y\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C a /\\<^sub>C c \\<le> b /\\<^sub>C c", "by fastforce"], ["proof (state)\nthis:\n  c *\\<^sub>C a /\\<^sub>C c \\<le> b /\\<^sub>C c\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C a \\<le> b \\<Longrightarrow> a \\<le> b /\\<^sub>C c", "with that"], ["proof (chain)\npicking this:\n  0 < c\n  c *\\<^sub>C a /\\<^sub>C c \\<le> b /\\<^sub>C c", "show ?P"], ["proof (prove)\nusing this:\n  0 < c\n  c *\\<^sub>C a /\\<^sub>C c \\<le> b /\\<^sub>C c\n\ngoal (1 subgoal):\n 1. a \\<le> b /\\<^sub>C c", "by auto"], ["proof (state)\nthis:\n  a \\<le> b /\\<^sub>C c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pos_less_divideC_eq [field_simps]:\n  \"a < b /\\<^sub>C c \\<longleftrightarrow> c *\\<^sub>C a < b\" if \"c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < b /\\<^sub>C c) = (c *\\<^sub>C a < b)", "using that pos_le_divideC_eq [of c a b]"], ["proof (prove)\nusing this:\n  0 < c\n  0 < c \\<Longrightarrow> (a \\<le> b /\\<^sub>C c) = (c *\\<^sub>C a \\<le> b)\n\ngoal (1 subgoal):\n 1. (a < b /\\<^sub>C c) = (c *\\<^sub>C a < b)", "by (auto simp add: le_less)"], ["", "lemma pos_divideC_le_eq [field_simps]:\n  \"b /\\<^sub>C c \\<le> a \\<longleftrightarrow> b \\<le> c *\\<^sub>C a\" if \"c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b /\\<^sub>C c \\<le> a) = (b \\<le> c *\\<^sub>C a)", "using that pos_le_divideC_eq [of \"inverse c\" b a]\n    less_complex_def"], ["proof (prove)\nusing this:\n  0 < c\n  0 < inverse c \\<Longrightarrow>\n  (b \\<le> a /\\<^sub>C inverse c) = (b /\\<^sub>C c \\<le> a)\n  ?x < ?y \\<equiv> Im ?x = Im ?y \\<and> Re ?x < Re ?y\n\ngoal (1 subgoal):\n 1. (b /\\<^sub>C c \\<le> a) = (b \\<le> c *\\<^sub>C a)", "by auto"], ["", "lemma pos_divideC_less_eq [field_simps]:\n  \"b /\\<^sub>C c < a \\<longleftrightarrow> b < c *\\<^sub>C a\" if \"c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b /\\<^sub>C c < a) = (b < c *\\<^sub>C a)", "using that pos_less_divideC_eq [of \"inverse c\" b a]"], ["proof (prove)\nusing this:\n  0 < c\n  0 < inverse c \\<Longrightarrow>\n  (b < a /\\<^sub>C inverse c) = (b /\\<^sub>C c < a)\n\ngoal (1 subgoal):\n 1. (b /\\<^sub>C c < a) = (b < c *\\<^sub>C a)", "by (simp add: local.less_le_not_le local.pos_divideC_le_eq local.pos_le_divideC_eq)"], ["", "lemma pos_le_minus_divideC_eq [field_simps]:\n  \"a \\<le> - (b /\\<^sub>C c) \\<longleftrightarrow> c *\\<^sub>C a \\<le> - b\" if \"c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> - (b /\\<^sub>C c)) = (c *\\<^sub>C a \\<le> - b)", "using that"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. (a \\<le> - (b /\\<^sub>C c)) = (c *\\<^sub>C a \\<le> - b)", "by (metis local.ab_left_minus local.add.inverse_unique local.add.right_inverse local.add_minus_cancel local.le_minus_iff local.pos_divideC_le_eq local.scaleC_add_right local.scaleC_one local.scaleC_scaleC)"], ["", "lemma pos_less_minus_divideC_eq [field_simps]:\n  \"a < - (b /\\<^sub>C c) \\<longleftrightarrow> c *\\<^sub>C a < - b\" if \"c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < - (b /\\<^sub>C c)) = (c *\\<^sub>C a < - b)", "using that"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. (a < - (b /\\<^sub>C c)) = (c *\\<^sub>C a < - b)", "by (metis le_less less_le_not_le pos_divideC_le_eq pos_divideC_less_eq pos_le_minus_divideC_eq)"], ["", "lemma pos_minus_divideC_le_eq [field_simps]:\n  \"- (b /\\<^sub>C c) \\<le> a \\<longleftrightarrow> - b \\<le> c *\\<^sub>C a\" if \"c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (b /\\<^sub>C c) \\<le> a) = (- b \\<le> c *\\<^sub>C a)", "using that"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. (- (b /\\<^sub>C c) \\<le> a) = (- b \\<le> c *\\<^sub>C a)", "by (metis local.add_minus_cancel local.left_minus local.pos_divideC_le_eq local.scaleC_add_right)"], ["", "lemma pos_minus_divideC_less_eq [field_simps]:\n  \"- (b /\\<^sub>C c) < a \\<longleftrightarrow> - b < c *\\<^sub>C a\" if \"c > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (b /\\<^sub>C c) < a) = (- b < c *\\<^sub>C a)", "using that"], ["proof (prove)\nusing this:\n  0 < c\n\ngoal (1 subgoal):\n 1. (- (b /\\<^sub>C c) < a) = (- b < c *\\<^sub>C a)", "by (simp add: less_le_not_le pos_le_minus_divideC_eq pos_minus_divideC_le_eq)"], ["", "lemma scaleC_image_atLeastAtMost: \"c > 0 \\<Longrightarrow> scaleC c ` {x..y} = {c *\\<^sub>C x..c *\\<^sub>C y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    (*\\<^sub>C) c ` {x..y} = {c *\\<^sub>C x..c *\\<^sub>C y}", "apply (auto intro!: scaleC_left_mono simp: image_iff Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>0 < c; c *\\<^sub>C x \\<le> xa;\n        xa \\<le> c *\\<^sub>C y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb\\<ge>x.\n                            xb \\<le> y \\<and> xa = c *\\<^sub>C xb", "by (meson local.eq_iff pos_divideC_le_eq pos_le_divideC_eq)"], ["", "end"], ["", "(* class ordered_complex_vector *)"], ["", "lemma neg_le_divideC_eq [field_simps]:\n  \"a \\<le> b /\\<^sub>C c \\<longleftrightarrow> b \\<le> c *\\<^sub>C a\" (is \"?P \\<longleftrightarrow> ?Q\") if \"c < 0\"\n    for a b :: \"'a :: ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> b /\\<^sub>C c) = (b \\<le> c *\\<^sub>C a)", "using that pos_le_divideC_eq [of \"- c\" a \"- b\"]"], ["proof (prove)\nusing this:\n  c < 0\n  0 < - c \\<Longrightarrow>\n  (a \\<le> - b /\\<^sub>C - c) = (- c *\\<^sub>C a \\<le> - b)\n\ngoal (1 subgoal):\n 1. (a \\<le> b /\\<^sub>C c) = (b \\<le> c *\\<^sub>C a)", "by (simp add: less_complex_def)"], ["", "lemma neg_less_divideC_eq [field_simps]:\n  \"a < b /\\<^sub>C c \\<longleftrightarrow> b < c *\\<^sub>C a\" if \"c < 0\"\n    for a b :: \"'a :: ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < b /\\<^sub>C c) = (b < c *\\<^sub>C a)", "using that neg_le_divideC_eq [of c a b]"], ["proof (prove)\nusing this:\n  c < 0\n  c < 0 \\<Longrightarrow> (a \\<le> b /\\<^sub>C c) = (b \\<le> c *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. (a < b /\\<^sub>C c) = (b < c *\\<^sub>C a)", "by (smt (verit, ccfv_SIG) neg_le_divideC_eq antisym_conv2 complex_vector.scale_minus_right dual_order.strict_implies_order le_less_trans neg_le_iff_le scaleC_scaleC)"], ["", "lemma neg_divideC_le_eq [field_simps]:\n  \"b /\\<^sub>C c \\<le> a \\<longleftrightarrow> c *\\<^sub>C a \\<le> b\" if \"c < 0\"\n    for a b :: \"'a :: ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b /\\<^sub>C c \\<le> a) = (c *\\<^sub>C a \\<le> b)", "using that pos_divideC_le_eq [of \"- c\" \"- b\" a]"], ["proof (prove)\nusing this:\n  c < 0\n  0 < - c \\<Longrightarrow>\n  (- b /\\<^sub>C - c \\<le> a) = (- b \\<le> - c *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. (b /\\<^sub>C c \\<le> a) = (c *\\<^sub>C a \\<le> b)", "by (simp add: less_complex_def)"], ["", "lemma neg_divideC_less_eq [field_simps]:\n  \"b /\\<^sub>C c < a \\<longleftrightarrow> c *\\<^sub>C a < b\" if \"c < 0\"\n    for a b :: \"'a :: ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b /\\<^sub>C c < a) = (c *\\<^sub>C a < b)", "using that neg_divideC_le_eq [of c b a]"], ["proof (prove)\nusing this:\n  c < 0\n  c < 0 \\<Longrightarrow> (b /\\<^sub>C c \\<le> a) = (c *\\<^sub>C a \\<le> b)\n\ngoal (1 subgoal):\n 1. (b /\\<^sub>C c < a) = (c *\\<^sub>C a < b)", "by (meson neg_le_divideC_eq less_le_not_le)"], ["", "lemma neg_le_minus_divideC_eq [field_simps]:\n  \"a \\<le> - (b /\\<^sub>C c) \\<longleftrightarrow> - b \\<le> c *\\<^sub>C a\" if \"c < 0\"\n    for a b :: \"'a :: ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> - (b /\\<^sub>C c)) = (- b \\<le> c *\\<^sub>C a)", "using that pos_le_minus_divideC_eq [of \"- c\" a \"- b\"]"], ["proof (prove)\nusing this:\n  c < 0\n  0 < - c \\<Longrightarrow>\n  (a \\<le> - (- b /\\<^sub>C - c)) = (- c *\\<^sub>C a \\<le> - (- b))\n\ngoal (1 subgoal):\n 1. (a \\<le> - (b /\\<^sub>C c)) = (- b \\<le> c *\\<^sub>C a)", "by (metis neg_le_divideC_eq complex_vector.scale_minus_right)"], ["", "lemma neg_less_minus_divideC_eq [field_simps]:\n  \"a < - (b /\\<^sub>C c) \\<longleftrightarrow> - b < c *\\<^sub>C a\" if \"c < 0\"\n    for a b :: \"'a :: ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < - (b /\\<^sub>C c)) = (- b < c *\\<^sub>C a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (a < - (b /\\<^sub>C c)) = (- b < c *\\<^sub>C a)", "have *: \"- b = c *\\<^sub>C a \\<longleftrightarrow> b = - (c *\\<^sub>C a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- b = c *\\<^sub>C a) = (b = - (c *\\<^sub>C a))", "by (metis add.inverse_inverse)"], ["proof (state)\nthis:\n  (- b = c *\\<^sub>C a) = (b = - (c *\\<^sub>C a))\n\ngoal (1 subgoal):\n 1. (a < - (b /\\<^sub>C c)) = (- b < c *\\<^sub>C a)", "from that neg_le_minus_divideC_eq [of c a b]"], ["proof (chain)\npicking this:\n  c < 0\n  c < 0 \\<Longrightarrow>\n  (a \\<le> - (b /\\<^sub>C c)) = (- b \\<le> c *\\<^sub>C a)", "show ?thesis"], ["proof (prove)\nusing this:\n  c < 0\n  c < 0 \\<Longrightarrow>\n  (a \\<le> - (b /\\<^sub>C c)) = (- b \\<le> c *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. (a < - (b /\\<^sub>C c)) = (- b < c *\\<^sub>C a)", "by (auto simp add: le_less *)"], ["proof (state)\nthis:\n  (a < - (b /\\<^sub>C c)) = (- b < c *\\<^sub>C a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma neg_minus_divideC_le_eq [field_simps]:\n  \"- (b /\\<^sub>C c) \\<le> a \\<longleftrightarrow> c *\\<^sub>C a \\<le> - b\" if \"c < 0\"\nfor a b :: \"'a :: ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (b /\\<^sub>C c) \\<le> a) = (c *\\<^sub>C a \\<le> - b)", "using that pos_minus_divideC_le_eq [of \"- c\" \"- b\" a]"], ["proof (prove)\nusing this:\n  c < 0\n  0 < - c \\<Longrightarrow>\n  (- (- b /\\<^sub>C - c) \\<le> a) = (- (- b) \\<le> - c *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. (- (b /\\<^sub>C c) \\<le> a) = (c *\\<^sub>C a \\<le> - b)", "by (metis Complex_Vector_Spaces0.neg_divideC_le_eq complex_vector.scale_minus_right)"], ["", "lemma neg_minus_divideC_less_eq [field_simps]:\n  \"- (b /\\<^sub>C c) < a \\<longleftrightarrow> c *\\<^sub>C a < - b\" if \"c < 0\"\nfor a b :: \"'a :: ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- (b /\\<^sub>C c) < a) = (c *\\<^sub>C a < - b)", "using that"], ["proof (prove)\nusing this:\n  c < 0\n\ngoal (1 subgoal):\n 1. (- (b /\\<^sub>C c) < a) = (c *\\<^sub>C a < - b)", "by (simp add: less_le_not_le neg_le_minus_divideC_eq neg_minus_divideC_le_eq)"], ["", "lemma divideC_field_splits_simps_1 [field_split_simps]: (* In Real_Vector_Spaces, these lemmas are unnamed *)\n  \"a = b /\\<^sub>C c \\<longleftrightarrow> (if c = 0 then a = 0 else c *\\<^sub>C a = b)\"\n  \"b /\\<^sub>C c = a \\<longleftrightarrow> (if c = 0 then a = 0 else b = c *\\<^sub>C a)\"\n  \"a + b /\\<^sub>C c = (if c = 0 then a else (c *\\<^sub>C a + b) /\\<^sub>C c)\"\n  \"a /\\<^sub>C c + b = (if c = 0 then b else (a + c *\\<^sub>C b) /\\<^sub>C c)\"\n  \"a - b /\\<^sub>C c = (if c = 0 then a else (c *\\<^sub>C a - b) /\\<^sub>C c)\"\n  \"a /\\<^sub>C c - b = (if c = 0 then - b else (a - c *\\<^sub>C b) /\\<^sub>C c)\"\n  \"- (a /\\<^sub>C c) + b = (if c = 0 then b else (- a + c *\\<^sub>C b) /\\<^sub>C c)\"\n  \"- (a /\\<^sub>C c) - b = (if c = 0 then - b else (- a - c *\\<^sub>C b) /\\<^sub>C c)\"\n  for a b :: \"'a :: complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((a = b /\\<^sub>C c) =\n      (if c = 0 then a = (0::'a) else c *\\<^sub>C a = b) &&&\n      (b /\\<^sub>C c = a) =\n      (if c = 0 then a = (0::'a) else b = c *\\<^sub>C a)) &&&\n     a + b /\\<^sub>C c =\n     (if c = 0 then a else (c *\\<^sub>C a + b) /\\<^sub>C c) &&&\n     a /\\<^sub>C c + b =\n     (if c = 0 then b else (a + c *\\<^sub>C b) /\\<^sub>C c)) &&&\n    (a - b /\\<^sub>C c =\n     (if c = 0 then a else (c *\\<^sub>C a - b) /\\<^sub>C c) &&&\n     a /\\<^sub>C c - b =\n     (if c = 0 then - b else (a - c *\\<^sub>C b) /\\<^sub>C c)) &&&\n    - (a /\\<^sub>C c) + b =\n    (if c = 0 then b else (- a + c *\\<^sub>C b) /\\<^sub>C c) &&&\n    - (a /\\<^sub>C c) - b =\n    (if c = 0 then - b else (- a - c *\\<^sub>C b) /\\<^sub>C c)", "by (auto simp add: field_simps)"], ["", "lemma divideC_field_splits_simps_2 [field_split_simps]: (* In Real_Vector_Spaces, these lemmas are unnamed *)\n  \"0 < c \\<Longrightarrow> a \\<le> b /\\<^sub>C c \\<longleftrightarrow> (if c > 0 then c *\\<^sub>C a \\<le> b else if c < 0 then b \\<le> c *\\<^sub>C a else a \\<le> 0)\"\n  \"0 < c \\<Longrightarrow> a < b /\\<^sub>C c \\<longleftrightarrow> (if c > 0 then c *\\<^sub>C a < b else if c < 0 then b < c *\\<^sub>C a else a < 0)\"\n  \"0 < c \\<Longrightarrow> b /\\<^sub>C c \\<le> a \\<longleftrightarrow> (if c > 0 then b \\<le> c *\\<^sub>C a else if c < 0 then c *\\<^sub>C a \\<le> b else a \\<ge> 0)\"\n  \"0 < c \\<Longrightarrow> b /\\<^sub>C c < a \\<longleftrightarrow> (if c > 0 then b < c *\\<^sub>C a else if c < 0 then c *\\<^sub>C a < b else a > 0)\"\n  \"0 < c \\<Longrightarrow> a \\<le> - (b /\\<^sub>C c) \\<longleftrightarrow> (if c > 0 then c *\\<^sub>C a \\<le> - b else if c < 0 then - b \\<le> c *\\<^sub>C a else a \\<le> 0)\"\n  \"0 < c \\<Longrightarrow> a < - (b /\\<^sub>C c) \\<longleftrightarrow> (if c > 0 then c *\\<^sub>C a < - b else if c < 0 then - b < c *\\<^sub>C a else a < 0)\"\n  \"0 < c \\<Longrightarrow> - (b /\\<^sub>C c) \\<le> a \\<longleftrightarrow> (if c > 0 then - b \\<le> c *\\<^sub>C a else if c < 0 then c *\\<^sub>C a \\<le> - b else a \\<ge> 0)\"\n  \"0 < c \\<Longrightarrow> - (b /\\<^sub>C c) < a \\<longleftrightarrow> (if c > 0 then - b < c *\\<^sub>C a else if c < 0 then c *\\<^sub>C a < - b else a > 0)\"\n  for a b :: \"'a :: ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((0 < c \\<Longrightarrow>\n       (a \\<le> b /\\<^sub>C c) =\n       (if 0 < c then c *\\<^sub>C a \\<le> b\n        else if c < 0 then b \\<le> c *\\<^sub>C a else a \\<le> (0::'a))) &&&\n      (0 < c \\<Longrightarrow>\n       (a < b /\\<^sub>C c) =\n       (if 0 < c then c *\\<^sub>C a < b\n        else if c < 0 then b < c *\\<^sub>C a else a < (0::'a)))) &&&\n     (0 < c \\<Longrightarrow>\n      (b /\\<^sub>C c \\<le> a) =\n      (if 0 < c then b \\<le> c *\\<^sub>C a\n       else if c < 0 then c *\\<^sub>C a \\<le> b else (0::'a) \\<le> a)) &&&\n     (0 < c \\<Longrightarrow>\n      (b /\\<^sub>C c < a) =\n      (if 0 < c then b < c *\\<^sub>C a\n       else if c < 0 then c *\\<^sub>C a < b else (0::'a) < a))) &&&\n    ((0 < c \\<Longrightarrow>\n      (a \\<le> - (b /\\<^sub>C c)) =\n      (if 0 < c then c *\\<^sub>C a \\<le> - b\n       else if c < 0 then - b \\<le> c *\\<^sub>C a else a \\<le> (0::'a))) &&&\n     (0 < c \\<Longrightarrow>\n      (a < - (b /\\<^sub>C c)) =\n      (if 0 < c then c *\\<^sub>C a < - b\n       else if c < 0 then - b < c *\\<^sub>C a else a < (0::'a)))) &&&\n    (0 < c \\<Longrightarrow>\n     (- (b /\\<^sub>C c) \\<le> a) =\n     (if 0 < c then - b \\<le> c *\\<^sub>C a\n      else if c < 0 then c *\\<^sub>C a \\<le> - b else (0::'a) \\<le> a)) &&&\n    (0 < c \\<Longrightarrow>\n     (- (b /\\<^sub>C c) < a) =\n     (if 0 < c then - b < c *\\<^sub>C a\n      else if c < 0 then c *\\<^sub>C a < - b else (0::'a) < a))", "by (clarsimp intro!: field_simps)+"], ["", "lemma scaleC_nonneg_nonneg: \"0 \\<le> a \\<Longrightarrow> 0 \\<le> x \\<Longrightarrow> 0 \\<le> a *\\<^sub>C x\"\n  for x :: \"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; (0::'a) \\<le> x\\<rbrakk>\n    \\<Longrightarrow> (0::'a) \\<le> a *\\<^sub>C x", "using scaleC_left_mono [of 0 x a]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(0::'a) \\<le> x; 0 \\<le> a\\<rbrakk>\n  \\<Longrightarrow> a *\\<^sub>C (0::'a) \\<le> a *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; (0::'a) \\<le> x\\<rbrakk>\n    \\<Longrightarrow> (0::'a) \\<le> a *\\<^sub>C x", "by simp"], ["", "lemma scaleC_nonneg_nonpos: \"0 \\<le> a \\<Longrightarrow> x \\<le> 0 \\<Longrightarrow> a *\\<^sub>C x \\<le> 0\"\n  for x :: \"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; x \\<le> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> a *\\<^sub>C x \\<le> (0::'a)", "using scaleC_left_mono [of x 0 a]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<le> (0::'a); 0 \\<le> a\\<rbrakk>\n  \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C (0::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; x \\<le> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> a *\\<^sub>C x \\<le> (0::'a)", "by simp"], ["", "lemma scaleC_nonpos_nonneg: \"a \\<le> 0 \\<Longrightarrow> 0 \\<le> x \\<Longrightarrow> a *\\<^sub>C x \\<le> 0\"\n  for x :: \"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> 0; (0::'a) \\<le> x\\<rbrakk>\n    \\<Longrightarrow> a *\\<^sub>C x \\<le> (0::'a)", "using scaleC_right_mono [of a 0 x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<le> 0; (0::'a) \\<le> x\\<rbrakk>\n  \\<Longrightarrow> a *\\<^sub>C x \\<le> 0 *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> 0; (0::'a) \\<le> x\\<rbrakk>\n    \\<Longrightarrow> a *\\<^sub>C x \\<le> (0::'a)", "by simp"], ["", "lemma split_scaleC_neg_le: \"(0 \\<le> a \\<and> x \\<le> 0) \\<or> (a \\<le> 0 \\<and> 0 \\<le> x) \\<Longrightarrow> a *\\<^sub>C x \\<le> 0\"\n  for x :: \"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> a \\<and> x \\<le> (0::'a) \\<or>\n    a \\<le> 0 \\<and> (0::'a) \\<le> x \\<Longrightarrow>\n    a *\\<^sub>C x \\<le> (0::'a)", "by (auto simp: scaleC_nonneg_nonpos scaleC_nonpos_nonneg)"], ["", "lemma cle_add_iff1: \"a *\\<^sub>C e + c \\<le> b *\\<^sub>C e + d \\<longleftrightarrow> (a - b) *\\<^sub>C e + c \\<le> d\"\n  for c d e :: \"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a *\\<^sub>C e + c \\<le> b *\\<^sub>C e + d) =\n    ((a - b) *\\<^sub>C e + c \\<le> d)", "by (simp add: algebra_simps)"], ["", "lemma cle_add_iff2: \"a *\\<^sub>C e + c \\<le> b *\\<^sub>C e + d \\<longleftrightarrow> c \\<le> (b - a) *\\<^sub>C e + d\"\n  for c d e :: \"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a *\\<^sub>C e + c \\<le> b *\\<^sub>C e + d) =\n    (c \\<le> (b - a) *\\<^sub>C e + d)", "by (simp add: algebra_simps)"], ["", "lemma scaleC_left_mono_neg: \"b \\<le> a \\<Longrightarrow> c \\<le> 0 \\<Longrightarrow> c *\\<^sub>C a \\<le> c *\\<^sub>C b\"\n  for a b :: \"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> a; c \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> c *\\<^sub>C a \\<le> c *\\<^sub>C b", "by (drule scaleC_left_mono [of _ _ \"- c\"], simp_all add: less_eq_complex_def)"], ["", "lemma scaleC_right_mono_neg: \"b \\<le> a \\<Longrightarrow> c \\<le> 0 \\<Longrightarrow> a *\\<^sub>C c \\<le> b *\\<^sub>C c\"\n  for c :: \"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> a; c \\<le> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> a *\\<^sub>C c \\<le> b *\\<^sub>C c", "by (drule scaleC_right_mono [of _ _ \"- c\"], simp_all)"], ["", "lemma scaleC_nonpos_nonpos: \"a \\<le> 0 \\<Longrightarrow> b \\<le> 0 \\<Longrightarrow> 0 \\<le> a *\\<^sub>C b\"\n  for b :: \"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> 0; b \\<le> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> (0::'a) \\<le> a *\\<^sub>C b", "using scaleC_right_mono_neg [of a 0 b]"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<le> 0; b \\<le> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> 0 *\\<^sub>C b \\<le> a *\\<^sub>C b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> 0; b \\<le> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> (0::'a) \\<le> a *\\<^sub>C b", "by simp"], ["", "lemma split_scaleC_pos_le: \"(0 \\<le> a \\<and> 0 \\<le> b) \\<or> (a \\<le> 0 \\<and> b \\<le> 0) \\<Longrightarrow> 0 \\<le> a *\\<^sub>C b\"\n  for b :: \"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> a \\<and> (0::'a) \\<le> b \\<or>\n    a \\<le> 0 \\<and> b \\<le> (0::'a) \\<Longrightarrow>\n    (0::'a) \\<le> a *\\<^sub>C b", "by (auto simp: scaleC_nonneg_nonneg scaleC_nonpos_nonpos)"], ["", "lemma zero_le_scaleC_iff:\n  fixes b :: \"'a::ordered_complex_vector\"\n  assumes \"a \\<in> \\<real>\" (* Not present in Real_Vector_Spaces.thy *)\n  shows \"0 \\<le> a *\\<^sub>C b \\<longleftrightarrow> 0 < a \\<and> 0 \\<le> b \\<or> a < 0 \\<and> b \\<le> 0 \\<or> a = 0\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0::'a) \\<le> a *\\<^sub>C b) =\n    (0 < a \\<and> (0::'a) \\<le> b \\<or>\n     a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0)", "proof (cases \"a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((0::'a) \\<le> a *\\<^sub>C b) =\n    (0 < a \\<and> (0::'a) \\<le> b \\<or>\n     a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0)\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((0::'a) \\<le> a *\\<^sub>C b) =\n    (0 < a \\<and> (0::'a) \\<le> b \\<or>\n     a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0)", "case True"], ["proof (state)\nthis:\n  a = 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow>\n    ((0::'a) \\<le> a *\\<^sub>C b) =\n    (0 < a \\<and> (0::'a) \\<le> b \\<or>\n     a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0)\n 2. a \\<noteq> 0 \\<Longrightarrow>\n    ((0::'a) \\<le> a *\\<^sub>C b) =\n    (0 < a \\<and> (0::'a) \\<le> b \\<or>\n     a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0)", "then"], ["proof (chain)\npicking this:\n  a = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a = 0\n\ngoal (1 subgoal):\n 1. ((0::'a) \\<le> a *\\<^sub>C b) =\n    (0 < a \\<and> (0::'a) \\<le> b \\<or>\n     a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0)", "by simp"], ["proof (state)\nthis:\n  ((0::'a) \\<le> a *\\<^sub>C b) =\n  (0 < a \\<and> (0::'a) \\<le> b \\<or>\n   a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    ((0::'a) \\<le> a *\\<^sub>C b) =\n    (0 < a \\<and> (0::'a) \\<le> b \\<or>\n     a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    ((0::'a) \\<le> a *\\<^sub>C b) =\n    (0 < a \\<and> (0::'a) \\<le> b \\<or>\n     a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    ((0::'a) \\<le> a *\\<^sub>C b) =\n    (0 < a \\<and> (0::'a) \\<le> b \\<or>\n     a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0::'a) \\<le> a *\\<^sub>C b) =\n    (0 < a \\<and> (0::'a) \\<le> b \\<or>\n     a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (0::'a) \\<le> a *\\<^sub>C b \\<Longrightarrow>\n    0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0\n 2. 0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0 \\<Longrightarrow>\n    (0::'a) \\<le> a *\\<^sub>C b", "assume ?lhs"], ["proof (state)\nthis:\n  (0::'a) \\<le> a *\\<^sub>C b\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> a *\\<^sub>C b \\<Longrightarrow>\n    0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0\n 2. 0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0 \\<Longrightarrow>\n    (0::'a) \\<le> a *\\<^sub>C b", "from \\<open>a \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  a \\<noteq> 0", "consider \"a > 0\" | \"a < 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < a \\<Longrightarrow> thesis;\n     a < 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis assms complex_is_Real_iff less_complex_def less_eq_complex_def not_le order.not_eq_order_implies_strict that(1) zero_complex.sel(2))"], ["proof (state)\nthis:\n  \\<lbrakk>0 < a \\<Longrightarrow> ?thesis;\n   a < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. (0::'a) \\<le> a *\\<^sub>C b \\<Longrightarrow>\n    0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0\n 2. 0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0 \\<Longrightarrow>\n    (0::'a) \\<le> a *\\<^sub>C b", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < a \\<Longrightarrow> ?thesis;\n   a < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?rhs"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < a \\<Longrightarrow> ?thesis;\n   a < 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. 0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow>\n    0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0\n 2. a < 0 \\<Longrightarrow>\n    0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0", "case 1"], ["proof (state)\nthis:\n  0 < a\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow>\n    0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0\n 2. a < 0 \\<Longrightarrow>\n    0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0", "with \\<open>?lhs\\<close>"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> a *\\<^sub>C b\n  0 < a", "have \"inverse a *\\<^sub>C 0 \\<le> inverse a *\\<^sub>C (a *\\<^sub>C b)\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> a *\\<^sub>C b\n  0 < a\n\ngoal (1 subgoal):\n 1. (0::'a) /\\<^sub>C a \\<le> a *\\<^sub>C b /\\<^sub>C a", "by (metis complex_vector.scale_zero_right ordered_complex_vector_class.pos_le_divideC_eq)"], ["proof (state)\nthis:\n  (0::'a) /\\<^sub>C a \\<le> a *\\<^sub>C b /\\<^sub>C a\n\ngoal (2 subgoals):\n 1. 0 < a \\<Longrightarrow>\n    0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0\n 2. a < 0 \\<Longrightarrow>\n    0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0", "with 1"], ["proof (chain)\npicking this:\n  0 < a\n  (0::'a) /\\<^sub>C a \\<le> a *\\<^sub>C b /\\<^sub>C a", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < a\n  (0::'a) /\\<^sub>C a \\<le> a *\\<^sub>C b /\\<^sub>C a\n\ngoal (1 subgoal):\n 1. 0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0", "by simp"], ["proof (state)\nthis:\n  0 < a \\<and> (0::'a) \\<le> b \\<or>\n  a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0", "case 2"], ["proof (state)\nthis:\n  a < 0\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0", "with \\<open>?lhs\\<close>"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> a *\\<^sub>C b\n  a < 0", "have \"- inverse a *\\<^sub>C 0 \\<le> - inverse a *\\<^sub>C (a *\\<^sub>C b)\""], ["proof (prove)\nusing this:\n  (0::'a) \\<le> a *\\<^sub>C b\n  a < 0\n\ngoal (1 subgoal):\n 1. - inverse a *\\<^sub>C (0::'a) \\<le> - inverse a *\\<^sub>C a *\\<^sub>C b", "by (metis Complex_Vector_Spaces0.neg_le_minus_divideC_eq complex_vector.scale_zero_right neg_le_0_iff_le scaleC_left.minus)"], ["proof (state)\nthis:\n  - inverse a *\\<^sub>C (0::'a) \\<le> - inverse a *\\<^sub>C a *\\<^sub>C b\n\ngoal (1 subgoal):\n 1. a < 0 \\<Longrightarrow>\n    0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0", "with 2"], ["proof (chain)\npicking this:\n  a < 0\n  - inverse a *\\<^sub>C (0::'a) \\<le> - inverse a *\\<^sub>C a *\\<^sub>C b", "show ?thesis"], ["proof (prove)\nusing this:\n  a < 0\n  - inverse a *\\<^sub>C (0::'a) \\<le> - inverse a *\\<^sub>C a *\\<^sub>C b\n\ngoal (1 subgoal):\n 1. 0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0", "by simp"], ["proof (state)\nthis:\n  0 < a \\<and> (0::'a) \\<le> b \\<or>\n  a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < a \\<and> (0::'a) \\<le> b \\<or>\n  a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0\n\ngoal (1 subgoal):\n 1. 0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0 \\<Longrightarrow>\n    (0::'a) \\<le> a *\\<^sub>C b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0 \\<Longrightarrow>\n    (0::'a) \\<le> a *\\<^sub>C b", "assume ?rhs"], ["proof (state)\nthis:\n  0 < a \\<and> (0::'a) \\<le> b \\<or>\n  a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0\n\ngoal (1 subgoal):\n 1. 0 < a \\<and> (0::'a) \\<le> b \\<or>\n    a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0 \\<Longrightarrow>\n    (0::'a) \\<le> a *\\<^sub>C b", "then"], ["proof (chain)\npicking this:\n  0 < a \\<and> (0::'a) \\<le> b \\<or>\n  a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0", "show ?lhs"], ["proof (prove)\nusing this:\n  0 < a \\<and> (0::'a) \\<le> b \\<or>\n  a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> a *\\<^sub>C b", "using less_imp_le split_scaleC_pos_le"], ["proof (prove)\nusing this:\n  0 < a \\<and> (0::'a) \\<le> b \\<or>\n  a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n  0 \\<le> ?a \\<and> (0::?'a) \\<le> ?b \\<or>\n  ?a \\<le> 0 \\<and> ?b \\<le> (0::?'a) \\<Longrightarrow>\n  (0::?'a) \\<le> ?a *\\<^sub>C ?b\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> a *\\<^sub>C b", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> a *\\<^sub>C b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((0::'a) \\<le> a *\\<^sub>C b) =\n  (0 < a \\<and> (0::'a) \\<le> b \\<or>\n   a < 0 \\<and> b \\<le> (0::'a) \\<or> a = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scaleC_le_0_iff:\n  \"a *\\<^sub>C b \\<le> 0 \\<longleftrightarrow> 0 < a \\<and> b \\<le> 0 \\<or> a < 0 \\<and> 0 \\<le> b \\<or> a = 0\"\n  if \"a \\<in> \\<real>\" (* Not present in Real_Vector_Spaces *)\n  for b::\"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a *\\<^sub>C b \\<le> (0::'a)) =\n    (0 < a \\<and> b \\<le> (0::'a) \\<or>\n     a < 0 \\<and> (0::'a) \\<le> b \\<or> a = 0)", "apply (insert zero_le_scaleC_iff [of \"-a\" b])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- a \\<in> \\<real> \\<Longrightarrow>\n     ((0::'a) \\<le> - a *\\<^sub>C b) =\n     (0 < - a \\<and> (0::'a) \\<le> b \\<or>\n      - a < 0 \\<and> b \\<le> (0::'a) \\<or> - a = 0)) \\<Longrightarrow>\n    (a *\\<^sub>C b \\<le> (0::'a)) =\n    (0 < a \\<and> b \\<le> (0::'a) \\<or>\n     a < 0 \\<and> (0::'a) \\<le> b \\<or> a = 0)", "using less_complex_def that"], ["proof (prove)\nusing this:\n  ?x < ?y \\<equiv> Im ?x = Im ?y \\<and> Re ?x < Re ?y\n  a \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. (- a \\<in> \\<real> \\<Longrightarrow>\n     ((0::'a) \\<le> - a *\\<^sub>C b) =\n     (0 < - a \\<and> (0::'a) \\<le> b \\<or>\n      - a < 0 \\<and> b \\<le> (0::'a) \\<or> - a = 0)) \\<Longrightarrow>\n    (a *\\<^sub>C b \\<le> (0::'a)) =\n    (0 < a \\<and> b \\<le> (0::'a) \\<or>\n     a < 0 \\<and> (0::'a) \\<le> b \\<or> a = 0)", "by force"], ["", "lemma scaleC_le_cancel_left: \"c *\\<^sub>C a \\<le> c *\\<^sub>C b \\<longleftrightarrow> (0 < c \\<longrightarrow> a \\<le> b) \\<and> (c < 0 \\<longrightarrow> b \\<le> a)\"\n  if \"c \\<in> \\<real>\" (* Not present in Real_Vector_Spaces *)\n  for b :: \"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c *\\<^sub>C a \\<le> c *\\<^sub>C b) =\n    ((0 < c \\<longrightarrow> a \\<le> b) \\<and>\n     (c < 0 \\<longrightarrow> b \\<le> a))", "by (smt (verit, ccfv_threshold) Complex_Vector_Spaces0.neg_divideC_le_eq complex_vector.scale_cancel_left complex_vector.scale_zero_right dual_order.eq_iff dual_order.trans ordered_complex_vector_class.pos_le_divideC_eq that zero_le_scaleC_iff)"], ["", "lemma scaleC_le_cancel_left_pos: \"0 < c \\<Longrightarrow> c *\\<^sub>C a \\<le> c *\\<^sub>C b \\<longleftrightarrow> a \\<le> b\"\n  for b :: \"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < c \\<Longrightarrow>\n    (c *\\<^sub>C a \\<le> c *\\<^sub>C b) = (a \\<le> b)", "by (simp add: complex_is_Real_iff less_complex_def scaleC_le_cancel_left)"], ["", "lemma scaleC_le_cancel_left_neg: \"c < 0 \\<Longrightarrow> c *\\<^sub>C a \\<le> c *\\<^sub>C b \\<longleftrightarrow> b \\<le> a\"\n  for b :: \"'a::ordered_complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c < 0 \\<Longrightarrow>\n    (c *\\<^sub>C a \\<le> c *\\<^sub>C b) = (b \\<le> a)", "by (simp add: complex_is_Real_iff less_complex_def scaleC_le_cancel_left)"], ["", "lemma scaleC_left_le_one_le: \"0 \\<le> x \\<Longrightarrow> a \\<le> 1 \\<Longrightarrow> a *\\<^sub>C x \\<le> x\"\n  for x :: \"'a::ordered_complex_vector\" and a :: complex"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'a) \\<le> x; a \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> a *\\<^sub>C x \\<le> x", "using scaleC_right_mono[of a 1 x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<le> 1; (0::'a) \\<le> x\\<rbrakk>\n  \\<Longrightarrow> a *\\<^sub>C x \\<le> 1 *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'a) \\<le> x; a \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> a *\\<^sub>C x \\<le> x", "by simp"], ["", "subsection \\<open>Complex normed vector spaces\\<close>"], ["", "(* Classes dist, norm, sgn_div_norm, dist_norm, uniformity_dist\n   defined in Real_Vector_Spaces are unchanged in the complex setting.\n   No need to define them here. *)"], ["", "class complex_normed_vector = complex_vector + sgn_div_norm + dist_norm + uniformity_dist + open_uniformity +\n  real_normed_vector + (* Not present in Real_Normed_Vector *)\n  assumes norm_scaleC [simp]: \"norm (scaleC a x) = cmod a * norm x\"\nbegin"], ["", "(* lemma norm_ge_zero [simp]: \"0 \\<le> norm x\" *) (* Not needed, included from real_normed_vector *)"], ["", "end"], ["", "class complex_normed_algebra = complex_algebra + complex_normed_vector +\n  real_normed_algebra"], ["", "(* Not present in Real_Normed_Vector *)\n  (* assumes norm_mult_ineq: \"norm (x * y) \\<le> norm x * norm y\" *) (* Not needed, included from real_normed_algebra *)"], ["", "class complex_normed_algebra_1 = complex_algebra_1 + complex_normed_algebra +\n  real_normed_algebra_1"], ["", "(* Not present in Real_Normed_Vector *)\n  (* assumes norm_one [simp]: \"norm 1 = 1\" *) (* Not needed, included from real_normed_algebra_1 *)"], ["", "lemma (in complex_normed_algebra_1) scaleC_power [simp]: \"(scaleC x y) ^ n = scaleC (x^n) (y^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x *\\<^sub>C y) ^ n = x ^ n *\\<^sub>C y ^ n", "by (induct n) (simp_all add: mult_ac)"], ["", "class complex_normed_div_algebra = complex_div_algebra + complex_normed_vector +\n  real_normed_div_algebra"], ["", "(* Not present in Real_Normed_Vector *)\n  (* assumes norm_mult: \"norm (x * y) = norm x * norm y\" *) (* Not needed, included from real_normed_div_algebra *)"], ["", "class complex_normed_field = complex_field + complex_normed_div_algebra"], ["", "subclass (in complex_normed_field) real_normed_field"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.real_normed_field (/) inverse (*) (1::'a) (+) (0::'a) (-) uminus\n     (*\\<^sub>R) dist norm sgn uniformity open", ".."], ["", "instance complex_normed_div_algebra < complex_normed_algebra_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, complex_normed_algebra_1_class)", ".."], ["", "context complex_normed_vector begin"], ["", "(* Inherited from real_normed_vector:\nlemma norm_zero [simp]: \"norm (0::'a) = 0\"\nlemma zero_less_norm_iff [simp]: \"norm x > 0 \\<longleftrightarrow> x \\<noteq> 0\"\nlemma norm_not_less_zero [simp]: \"\\<not> norm x < 0\"\nlemma norm_le_zero_iff [simp]: \"norm x \\<le> 0 \\<longleftrightarrow> x = 0\"\nlemma norm_minus_cancel [simp]: \"norm (- x) = norm x\"\nlemma norm_minus_commute: \"norm (a - b) = norm (b - a)\"\nlemma dist_add_cancel [simp]: \"dist (a + b) (a + c) = dist b c\"\nlemma dist_add_cancel2 [simp]: \"dist (b + a) (c + a) = dist b c\"\nlemma norm_uminus_minus: \"norm (- x - y) = norm (x + y)\"\nlemma norm_triangle_ineq2: \"norm a - norm b \\<le> norm (a - b)\"\nlemma norm_triangle_ineq3: \"\\<bar>norm a - norm b\\<bar> \\<le> norm (a - b)\"\nlemma norm_triangle_ineq4: \"norm (a - b) \\<le> norm a + norm b\"\nlemma norm_triangle_le_diff: \"norm x + norm y \\<le> e \\<Longrightarrow> norm (x - y) \\<le> e\"\nlemma norm_diff_ineq: \"norm a - norm b \\<le> norm (a + b)\"\nlemma norm_triangle_sub: \"norm x \\<le> norm y + norm (x - y)\"\nlemma norm_triangle_le: \"norm x + norm y \\<le> e \\<Longrightarrow> norm (x + y) \\<le> e\"\nlemma norm_triangle_lt: \"norm x + norm y < e \\<Longrightarrow> norm (x + y) < e\"\nlemma norm_add_leD: \"norm (a + b) \\<le> c \\<Longrightarrow> norm b \\<le> norm a + c\"\nlemma norm_diff_triangle_ineq: \"norm ((a + b) - (c + d)) \\<le> norm (a - c) + norm (b - d)\"\nlemma norm_diff_triangle_le: \"norm (x - z) \\<le> e1 + e2\"\n  if \"norm (x - y) \\<le> e1\"  \"norm (y - z) \\<le> e2\"\nlemma norm_diff_triangle_less: \"norm (x - z) < e1 + e2\"\n  if \"norm (x - y) < e1\"  \"norm (y - z) < e2\"\nlemma norm_triangle_mono:\n  \"norm a \\<le> r \\<Longrightarrow> norm b \\<le> s \\<Longrightarrow> norm (a + b) \\<le> r + s\"\nlemma norm_sum: \"norm (sum f A) \\<le> (\\<Sum>i\\<in>A. norm (f i))\"\n  for f::\"'b \\<Rightarrow> 'a\"\nlemma sum_norm_le: \"norm (sum f S) \\<le> sum g S\"\n  if \"\\<And>x. x \\<in> S \\<Longrightarrow> norm (f x) \\<le> g x\"\n  for f::\"'b \\<Rightarrow> 'a\"\nlemma abs_norm_cancel [simp]: \"\\<bar>norm a\\<bar> = norm a\"\nlemma sum_norm_bound:\n  \"norm (sum f S) \\<le> of_nat (card S)*K\"\n  if \"\\<And>x. x \\<in> S \\<Longrightarrow> norm (f x) \\<le> K\"\n  for f :: \"'b \\<Rightarrow> 'a\"\nlemma norm_add_less: \"norm x < r \\<Longrightarrow> norm y < s \\<Longrightarrow> norm (x + y) < r + s\"\n*)"], ["", "end"], ["", "lemma dist_scaleC [simp]: \"dist (x *\\<^sub>C a) (y *\\<^sub>C a) = \\<bar>x - y\\<bar> * norm a\"\n  for a :: \"'a::complex_normed_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (complex_of_real x *\\<^sub>C a) (complex_of_real y *\\<^sub>C a) =\n    \\<bar>x - y\\<bar> * norm a", "by (metis dist_scaleR scaleR_scaleC)"], ["", "(* Inherited from real_normed_vector *)\n(* lemma norm_mult_less: \"norm x < r \\<Longrightarrow> norm y < s \\<Longrightarrow> norm (x * y) < r * s\"\n  for x y :: \"'a::complex_normed_algebra\" *)"], ["", "lemma norm_of_complex [simp]: \"norm (of_complex c :: 'a::complex_normed_algebra_1) = cmod c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (of_complex c) = cmod c", "by (simp add: of_complex_def)"], ["", "(* Inherited from real_normed_vector:\nlemma norm_numeral [simp]: \"norm (numeral w::'a::complex_normed_algebra_1) = numeral w\"\nlemma norm_neg_numeral [simp]: \"norm (- numeral w::'a::complex_normed_algebra_1) = numeral w\"\nlemma norm_of_complex_add1 [simp]: \"norm (of_real x + 1 :: 'a :: complex_normed_div_algebra) = \\<bar>x + 1\\<bar>\"\nlemma norm_of_complex_addn [simp]:\n  \"norm (of_real x + numeral b :: 'a :: complex_normed_div_algebra) = \\<bar>x + numeral b\\<bar>\"\nlemma norm_of_int [simp]: \"norm (of_int z::'a::complex_normed_algebra_1) = \\<bar>of_int z\\<bar>\"\nlemma norm_of_nat [simp]: \"norm (of_nat n::'a::complex_normed_algebra_1) = of_nat n\"\nlemma nonzero_norm_inverse: \"a \\<noteq> 0 \\<Longrightarrow> norm (inverse a) = inverse (norm a)\"\n  for a :: \"'a::complex_normed_div_algebra\"\nlemma norm_inverse: \"norm (inverse a) = inverse (norm a)\"\n  for a :: \"'a::{complex_normed_div_algebra,division_ring}\"\nlemma nonzero_norm_divide: \"b \\<noteq> 0 \\<Longrightarrow> norm (a / b) = norm a / norm b\"\n  for a b :: \"'a::complex_normed_field\"\nlemma norm_divide: \"norm (a / b) = norm a / norm b\"\n  for a b :: \"'a::{complex_normed_field,field}\"\nlemma norm_inverse_le_norm:\n  fixes x :: \"'a::complex_normed_div_algebra\"\n  shows \"r \\<le> norm x \\<Longrightarrow> 0 < r \\<Longrightarrow> norm (inverse x) \\<le> inverse r\"\nlemma norm_power_ineq: \"norm (x ^ n) \\<le> norm x ^ n\"\n  for x :: \"'a::complex_normed_algebra_1\"\nlemma norm_power: \"norm (x ^ n) = norm x ^ n\"\n  for x :: \"'a::complex_normed_div_algebra\"\nlemma norm_power_int: \"norm (power_int x n) = power_int (norm x) n\"\n  for x :: \"'a::complex_normed_div_algebra\"\nlemma power_eq_imp_eq_norm:\n  fixes w :: \"'a::complex_normed_div_algebra\"\n  assumes eq: \"w ^ n = z ^ n\" and \"n > 0\"\n    shows \"norm w = norm z\"\nlemma power_eq_1_iff:\n  fixes w :: \"'a::complex_normed_div_algebra\"\n  shows \"w ^ n = 1 \\<Longrightarrow> norm w = 1 \\<or> n = 0\"\nlemma norm_mult_numeral1 [simp]: \"norm (numeral w * a) = numeral w * norm a\"\n  for a b :: \"'a::{complex_normed_field,field}\"\nlemma norm_mult_numeral2 [simp]: \"norm (a * numeral w) = norm a * numeral w\"\n  for a b :: \"'a::{complex_normed_field,field}\"\nlemma norm_divide_numeral [simp]: \"norm (a / numeral w) = norm a / numeral w\"\n  for a b :: \"'a::{complex_normed_field,field}\"\nlemma square_norm_one:\n  fixes x :: \"'a::complex_normed_div_algebra\"\n  assumes \"x\\<^sup>2 = 1\"\n  shows \"norm x = 1\"\nlemma norm_less_p1: \"norm x < norm (of_real (norm x) + 1 :: 'a)\"\n  for x :: \"'a::complex_normed_algebra_1\"\nlemma prod_norm: \"prod (\\<lambda>x. norm (f x)) A = norm (prod f A)\"\n  for f :: \"'a \\<Rightarrow> 'b::{comm_semiring_1,complex_normed_div_algebra}\"\nlemma norm_prod_le:\n  \"norm (prod f A) \\<le> (\\<Prod>a\\<in>A. norm (f a :: 'a :: {complex_normed_algebra_1,comm_monoid_mult}))\"\nlemma norm_prod_diff:\n  fixes z w :: \"'i \\<Rightarrow> 'a::{complex_normed_algebra_1, comm_monoid_mult}\"\n  shows \"(\\<And>i. i \\<in> I \\<Longrightarrow> norm (z i) \\<le> 1) \\<Longrightarrow> (\\<And>i. i \\<in> I \\<Longrightarrow> norm (w i) \\<le> 1) \\<Longrightarrow>\n    norm ((\\<Prod>i\\<in>I. z i) - (\\<Prod>i\\<in>I. w i)) \\<le> (\\<Sum>i\\<in>I. norm (z i - w i))\"\nlemma norm_power_diff:\n  fixes z w :: \"'a::{complex_normed_algebra_1, comm_monoid_mult}\"\n  assumes \"norm z \\<le> 1\" \"norm w \\<le> 1\"\n  shows \"norm (z^m - w^m) \\<le> m * norm (z - w)\"\n*)"], ["", "lemma norm_of_complex_add1 [simp]: \"norm (of_complex x + 1 :: 'a :: complex_normed_div_algebra) = cmod (x + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (of_complex x + (1::'a)) = cmod (x + 1)", "by (metis norm_of_complex of_complex_1 of_complex_add)"], ["", "lemma norm_of_complex_addn [simp]:\n  \"norm (of_complex x + numeral b :: 'a :: complex_normed_div_algebra) = cmod (x + numeral b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (of_complex x + numeral b) = cmod (x + numeral b)", "by (metis norm_of_complex of_complex_add of_complex_numeral)"], ["", "lemma norm_of_complex_diff [simp]:\n  \"norm (of_complex b - of_complex a :: 'a::complex_normed_algebra_1) \\<le> cmod (b - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (of_complex b - of_complex a) \\<le> cmod (b - a)", "by (metis norm_of_complex of_complex_diff order_refl)"], ["", "subsection \\<open>Metric spaces\\<close>"], ["", "(* Class metric_space is already defined in Real_Vector_Spaces and does not need changing here *)"], ["", "text \\<open>Every normed vector space is a metric space.\\<close>"], ["", "(* Already follows from complex_normed_vector < real_normed_vector < metric_space *)\n(* instance complex_normed_vector < metric_space *)"], ["", "subsection \\<open>Class instances for complex numbers\\<close>"], ["", "instantiation complex :: complex_normed_field\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(complex, complex_normed_field_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x. cmod (a *\\<^sub>C x) = cmod a * cmod x", "by (simp add: norm_mult)"], ["", "end"], ["", "declare uniformity_Abort[where 'a=complex, code]"], ["", "lemma dist_of_complex [simp]: \"dist (of_complex x :: 'a) (of_complex y) = dist x y\"\n  for a :: \"'a::complex_normed_div_algebra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (of_complex x) (of_complex y) = dist x y", "by (metis dist_norm norm_of_complex of_complex_diff)"], ["", "declare [[code abort: \"open :: complex set \\<Rightarrow> bool\"]]"], ["", "(* As far as I can tell, there is no analogue to this for complex:\ninstance real :: order_topology\ninstance real :: linear_continuum_topology ..\n\nlemmas open_complex_greaterThan = open_greaterThan[where 'a=complex]\nlemmas open_complex_lessThan = open_lessThan[where 'a=complex]\nlemmas open_complex_greaterThanLessThan = open_greaterThanLessThan[where 'a=complex]\n*)"], ["", "lemma closed_complex_atMost: \\<open>closed {..a::complex}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {..a}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed {..a}", "have \\<open>{..a} = Im -` {Im a} \\<inter> Re -` {..Re a}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {..a} = Im -` {Im a} \\<inter> Re -` {..Re a}", "by (auto simp: less_eq_complex_def)"], ["proof (state)\nthis:\n  {..a} = Im -` {Im a} \\<inter> Re -` {..Re a}\n\ngoal (1 subgoal):\n 1. closed {..a}", "also"], ["proof (state)\nthis:\n  {..a} = Im -` {Im a} \\<inter> Re -` {..Re a}\n\ngoal (1 subgoal):\n 1. closed {..a}", "have \\<open>closed \\<dots>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (Im -` {Im a} \\<inter> Re -` {..Re a})", "by (auto intro!: closed_Int closed_vimage continuous_on_Im continuous_on_Re)"], ["proof (state)\nthis:\n  closed (Im -` {Im a} \\<inter> Re -` {..Re a})\n\ngoal (1 subgoal):\n 1. closed {..a}", "finally"], ["proof (chain)\npicking this:\n  closed {..a}", "show ?thesis"], ["proof (prove)\nusing this:\n  closed {..a}\n\ngoal (1 subgoal):\n 1. closed {..a}", "by -"], ["proof (state)\nthis:\n  closed {..a}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_complex_atLeast: \\<open>closed {a::complex..}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {a..}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed {a..}", "have \\<open>{a..} = Im -` {Im a} \\<inter> Re -` {Re a..}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a..} = Im -` {Im a} \\<inter> Re -` {Re a..}", "by (auto simp: less_eq_complex_def)"], ["proof (state)\nthis:\n  {a..} = Im -` {Im a} \\<inter> Re -` {Re a..}\n\ngoal (1 subgoal):\n 1. closed {a..}", "also"], ["proof (state)\nthis:\n  {a..} = Im -` {Im a} \\<inter> Re -` {Re a..}\n\ngoal (1 subgoal):\n 1. closed {a..}", "have \\<open>closed \\<dots>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (Im -` {Im a} \\<inter> Re -` {Re a..})", "by (auto intro!: closed_Int closed_vimage continuous_on_Im continuous_on_Re)"], ["proof (state)\nthis:\n  closed (Im -` {Im a} \\<inter> Re -` {Re a..})\n\ngoal (1 subgoal):\n 1. closed {a..}", "finally"], ["proof (chain)\npicking this:\n  closed {a..}", "show ?thesis"], ["proof (prove)\nusing this:\n  closed {a..}\n\ngoal (1 subgoal):\n 1. closed {a..}", "by -"], ["proof (state)\nthis:\n  closed {a..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_complex_atLeastAtMost: \\<open>closed {a::complex .. b}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {a..b}", "proof (cases \\<open>Im a = Im b\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. Im a = Im b \\<Longrightarrow> closed {a..b}\n 2. Im a \\<noteq> Im b \\<Longrightarrow> closed {a..b}", "case True"], ["proof (state)\nthis:\n  Im a = Im b\n\ngoal (2 subgoals):\n 1. Im a = Im b \\<Longrightarrow> closed {a..b}\n 2. Im a \\<noteq> Im b \\<Longrightarrow> closed {a..b}", "have \\<open>{a..b} = Im -` {Im a} \\<inter> Re -` {Re a..Re b}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a..b} = Im -` {Im a} \\<inter> Re -` {Re a..Re b}", "by (auto simp add: less_eq_complex_def intro!: True)"], ["proof (state)\nthis:\n  {a..b} = Im -` {Im a} \\<inter> Re -` {Re a..Re b}\n\ngoal (2 subgoals):\n 1. Im a = Im b \\<Longrightarrow> closed {a..b}\n 2. Im a \\<noteq> Im b \\<Longrightarrow> closed {a..b}", "also"], ["proof (state)\nthis:\n  {a..b} = Im -` {Im a} \\<inter> Re -` {Re a..Re b}\n\ngoal (2 subgoals):\n 1. Im a = Im b \\<Longrightarrow> closed {a..b}\n 2. Im a \\<noteq> Im b \\<Longrightarrow> closed {a..b}", "have \\<open>closed \\<dots>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (Im -` {Im a} \\<inter> Re -` {Re a..Re b})", "by (auto intro!: closed_Int closed_vimage continuous_on_Im continuous_on_Re)"], ["proof (state)\nthis:\n  closed (Im -` {Im a} \\<inter> Re -` {Re a..Re b})\n\ngoal (2 subgoals):\n 1. Im a = Im b \\<Longrightarrow> closed {a..b}\n 2. Im a \\<noteq> Im b \\<Longrightarrow> closed {a..b}", "finally"], ["proof (chain)\npicking this:\n  closed {a..b}", "show ?thesis"], ["proof (prove)\nusing this:\n  closed {a..b}\n\ngoal (1 subgoal):\n 1. closed {a..b}", "by -"], ["proof (state)\nthis:\n  closed {a..b}\n\ngoal (1 subgoal):\n 1. Im a \\<noteq> Im b \\<Longrightarrow> closed {a..b}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Im a \\<noteq> Im b \\<Longrightarrow> closed {a..b}", "case False"], ["proof (state)\nthis:\n  Im a \\<noteq> Im b\n\ngoal (1 subgoal):\n 1. Im a \\<noteq> Im b \\<Longrightarrow> closed {a..b}", "then"], ["proof (chain)\npicking this:\n  Im a \\<noteq> Im b", "have *: \\<open>{a..b} = {}\\<close>"], ["proof (prove)\nusing this:\n  Im a \\<noteq> Im b\n\ngoal (1 subgoal):\n 1. {a..b} = {}", "using less_eq_complex_def"], ["proof (prove)\nusing this:\n  Im a \\<noteq> Im b\n  ?x \\<le> ?y \\<equiv> Im ?x = Im ?y \\<and> Re ?x \\<le> Re ?y\n\ngoal (1 subgoal):\n 1. {a..b} = {}", "by auto"], ["proof (state)\nthis:\n  {a..b} = {}\n\ngoal (1 subgoal):\n 1. Im a \\<noteq> Im b \\<Longrightarrow> closed {a..b}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {a..b}", "by (simp add: *)"], ["proof (state)\nthis:\n  closed {a..b}\n\ngoal:\nNo subgoals!", "qed"], ["", "(* As far as I can tell, there is no analogue to this for complex:\ninstance real :: ordered_real_vector\n  by standard (auto intro: mult_left_mono mult_right_mono)\n*)\n\n(* subsection \\<open>Extra type constraints\\<close> *)\n(* Everything is commented out, so we comment out the heading, too. *)\n\n(* These are already configured in Real_Vector_Spaces:\n\ntext \\<open>Only allow \\<^term>\\<open>open\\<close> in class \\<open>topological_space\\<close>.\\<close>\nsetup \\<open>Sign.add_const_constraint\n  (\\<^const_name>\\<open>open\\<close>, SOME \\<^typ>\\<open>'a::topological_space set \\<Rightarrow> bool\\<close>)\\<close>\n\ntext \\<open>Only allow \\<^term>\\<open>uniformity\\<close> in class \\<open>uniform_space\\<close>.\\<close>\nsetup \\<open>Sign.add_const_constraint\n  (\\<^const_name>\\<open>uniformity\\<close>, SOME \\<^typ>\\<open>('a::uniformity \\<times> 'a) filter\\<close>)\\<close>\n\ntext \\<open>Only allow \\<^term>\\<open>dist\\<close> in class \\<open>metric_space\\<close>.\\<close>\nsetup \\<open>Sign.add_const_constraint\n  (\\<^const_name>\\<open>dist\\<close>, SOME \\<^typ>\\<open>'a::metric_space \\<Rightarrow> 'a \\<Rightarrow> real\\<close>)\\<close>\n\ntext \\<open>Only allow \\<^term>\\<open>norm\\<close> in class \\<open>complex_normed_vector\\<close>.\\<close>\nsetup \\<open>Sign.add_const_constraint\n  (\\<^const_name>\\<open>norm\\<close>, SOME \\<^typ>\\<open>'a::complex_normed_vector \\<Rightarrow> real\\<close>)\\<close>\n*)"], ["", "subsection \\<open>Sign function\\<close>"], ["", "(* Inherited from real_normed_vector: \nlemma norm_sgn: \"norm (sgn x) = (if x = 0 then 0 else 1)\"\n  for x :: \"'a::complex_normed_vector\"\nlemma sgn_zero [simp]: \"sgn (0::'a::complex_normed_vector) = 0\"\nlemma sgn_zero_iff: \"sgn x = 0 \\<longleftrightarrow> x = 0\"\n  for x :: \"'a::complex_normed_vector\"\nlemma sgn_minus: \"sgn (- x) = - sgn x\"\n  for x :: \"'a::complex_normed_vector\"\nlemma sgn_one [simp]: \"sgn (1::'a::complex_normed_algebra_1) = 1\"\nlemma sgn_mult: \"sgn (x * y) = sgn x * sgn y\"\n  for x y :: \"'a::complex_normed_div_algebra\"\nhide_fact (open) sgn_mult\nlemma norm_conv_dist: \"norm x = dist x 0\"\ndeclare norm_conv_dist [symmetric, simp]\nlemma dist_0_norm [simp]: \"dist 0 x = norm x\"\n  for x :: \"'a::complex_normed_vector\"\nlemma dist_diff [simp]: \"dist a (a - b) = norm b\"  \"dist (a - b) a = norm b\"\nlemma dist_of_int: \"dist (of_int m) (of_int n :: 'a :: complex_normed_algebra_1) = of_int \\<bar>m - n\\<bar>\"\nlemma dist_of_nat:\n  \"dist (of_nat m) (of_nat n :: 'a :: complex_normed_algebra_1) = of_int \\<bar>int m - int n\\<bar>\"\n*)"], ["", "lemma sgn_scaleC: \"sgn (scaleC r x) = scaleC (sgn r) (sgn x)\"\n  for x :: \"'a::complex_normed_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (r *\\<^sub>C x) = sgn r *\\<^sub>C sgn x", "by (simp add: scaleR_scaleC sgn_div_norm ac_simps)"], ["", "lemma sgn_of_complex: \"sgn (of_complex r :: 'a::complex_normed_algebra_1) = of_complex (sgn r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (of_complex r) = of_complex (sgn r)", "unfolding of_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (r *\\<^sub>C (1::'a)) = sgn r *\\<^sub>C (1::'a)", "by (simp only: sgn_scaleC sgn_one)"], ["", "lemma complex_sgn_eq: \"sgn x = x / \\<bar>x\\<bar>\"\n  for x :: complex"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn x = x / \\<bar>x\\<bar>", "by (simp add: abs_complex_def scaleR_scaleC sgn_div_norm divide_inverse)"], ["", "lemma czero_le_sgn_iff [simp]: \"0 \\<le> sgn x \\<longleftrightarrow> 0 \\<le> x\"\n  for x :: complex"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> sgn x) = (0 \\<le> x)", "using cmod_eq_Re divide_eq_0_iff less_eq_complex_def"], ["proof (prove)\nusing this:\n  Im ?z = 0 \\<Longrightarrow> cmod ?z = \\<bar>Re ?z\\<bar>\n  (?a / ?b = (0::?'a)) = (?a = (0::?'a) \\<or> ?b = (0::?'a))\n  ?x \\<le> ?y \\<equiv> Im ?x = Im ?y \\<and> Re ?x \\<le> Re ?y\n\ngoal (1 subgoal):\n 1. (0 \\<le> sgn x) = (0 \\<le> x)", "by auto"], ["", "lemma csgn_le_0_iff [simp]: \"sgn x \\<le> 0 \\<longleftrightarrow> x \\<le> 0\"\n  for x :: complex"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sgn x \\<le> 0) = (x \\<le> 0)", "by (smt (verit, best) czero_le_sgn_iff Im_sgn Re_sgn divide_eq_0_iff dual_order.eq_iff less_eq_complex_def sgn_zero_iff zero_complex.sel(1) zero_complex.sel(2))"], ["", "subsection \\<open>Bounded Linear and Bilinear Operators\\<close>"], ["", "lemma clinearI: \"clinear f\"\n  if \"\\<And>b1 b2. f (b1 + b2) = f b1 + f b2\"\n    \"\\<And>r b. f (r *\\<^sub>C b) = r *\\<^sub>C f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear f", "using that"], ["proof (prove)\nusing this:\n  f (?b1.0 + ?b2.0) = f ?b1.0 + f ?b2.0\n  f (?r *\\<^sub>C ?b) = ?r *\\<^sub>C f ?b\n\ngoal (1 subgoal):\n 1. clinear f", "by unfold_locales (auto simp: algebra_simps)"], ["", "lemma clinear_iff:\n  \"clinear f \\<longleftrightarrow> (\\<forall>x y. f (x + y) = f x + f y) \\<and> (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x)\"\n  (is \"clinear f \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear f =\n    ((\\<forall>x y. f (x + y) = f x + f y) \\<and>\n     (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. clinear f \\<Longrightarrow>\n    (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n    (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x)\n 2. (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n    (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x) \\<Longrightarrow>\n    clinear f", "assume \"clinear f\""], ["proof (state)\nthis:\n  clinear f\n\ngoal (2 subgoals):\n 1. clinear f \\<Longrightarrow>\n    (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n    (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x)\n 2. (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n    (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x) \\<Longrightarrow>\n    clinear f", "then"], ["proof (chain)\npicking this:\n  clinear f", "interpret f: clinear f"], ["proof (prove)\nusing this:\n  clinear f\n\ngoal (1 subgoal):\n 1. clinear f", "."], ["proof (state)\ngoal (2 subgoals):\n 1. clinear f \\<Longrightarrow>\n    (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n    (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x)\n 2. (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n    (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x) \\<Longrightarrow>\n    clinear f", "show \"?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n    (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x)", "by (simp add: f.add f.scale complex_vector.linear_scale f.clinear_axioms)"], ["proof (state)\nthis:\n  (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n  (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x)\n\ngoal (1 subgoal):\n 1. (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n    (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x) \\<Longrightarrow>\n    clinear f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n    (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x) \\<Longrightarrow>\n    clinear f", "assume \"?rhs\""], ["proof (state)\nthis:\n  (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n  (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x)\n\ngoal (1 subgoal):\n 1. (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n    (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x) \\<Longrightarrow>\n    clinear f", "then"], ["proof (chain)\npicking this:\n  (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n  (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x)", "show \"clinear f\""], ["proof (prove)\nusing this:\n  (\\<forall>x y. f (x + y) = f x + f y) \\<and>\n  (\\<forall>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x)\n\ngoal (1 subgoal):\n 1. clinear f", "by (intro clinearI) auto"], ["proof (state)\nthis:\n  clinear f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas clinear_scaleC_left = complex_vector.linear_scale_left"], ["", "lemmas clinear_imp_scaleC = complex_vector.linear_imp_scale"], ["", "corollary complex_clinearD:\n  fixes f :: \"complex \\<Rightarrow> complex\"\n  assumes \"clinear f\" obtains c where \"f = (*) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c. f = (*) c \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (rule clinear_imp_scaleC [OF assms]) (force simp: scaleC_conv_of_complex)"], ["", "lemma clinear_times_of_complex: \"clinear (\\<lambda>x. a * of_complex x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear (\\<lambda>x. a * of_complex x)", "by (auto intro!: clinearI simp: distrib_left)\n    (metis mult_scaleC_right scaleC_conv_of_complex)"], ["", "locale bounded_clinear = clinear f for f :: \"'a::complex_normed_vector \\<Rightarrow> 'b::complex_normed_vector\" +\n  assumes bounded: \"\\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K\"\nbegin"], ["", "(* Not present in Real_Vector_Spaces *)"], ["", "lemma bounded_linear: \"bounded_linear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear f", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b1 b2. f (b1 + b2) = f b1 + f b2\n 2. \\<And>r b. f (r *\\<^sub>R b) = r *\\<^sub>R f b\n 3. \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "by (simp_all add: add scaleC scaleR_scaleC bounded)"], ["", "lemma pos_bounded: \"\\<exists>K>0. \\<forall>x. norm (f x) \\<le> norm x * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K>0. \\<forall>x. norm (f x) \\<le> norm x * K", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>K>0. \\<forall>x. norm (f x) \\<le> norm x * K", "obtain K where K: \"\\<And>x. norm (f x) \\<le> norm x * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>K.\n        (\\<And>x. norm (f x) \\<le> norm x * K) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using bounded"], ["proof (prove)\nusing this:\n  \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        (\\<And>x. norm (f x) \\<le> norm x * K) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  norm (f ?x) \\<le> norm ?x * K\n\ngoal (1 subgoal):\n 1. \\<exists>K>0. \\<forall>x. norm (f x) \\<le> norm x * K", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K>0. \\<forall>x. norm (f x) \\<le> norm x * K", "proof (intro exI impI conjI allI)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < ?K\n 2. \\<And>x. norm (f x) \\<le> norm x * ?K", "show \"0 < max 1 K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < max 1 K", "by (rule order_less_le_trans [OF zero_less_one max.cobounded1])"], ["proof (state)\nthis:\n  0 < max 1 K\n\ngoal (1 subgoal):\n 1. \\<And>x. norm (f x) \\<le> norm x * max 1 K", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. norm (f x) \\<le> norm x * max 1 K", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. norm (f x) \\<le> norm x * max 1 K", "have \"norm (f x) \\<le> norm x * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (f x) \\<le> norm x * K", "using K"], ["proof (prove)\nusing this:\n  norm (f ?x) \\<le> norm ?x * K\n\ngoal (1 subgoal):\n 1. norm (f x) \\<le> norm x * K", "."], ["proof (state)\nthis:\n  norm (f x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. \\<And>x. norm (f x) \\<le> norm x * max 1 K", "also"], ["proof (state)\nthis:\n  norm (f x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. \\<And>x. norm (f x) \\<le> norm x * max 1 K", "have \"\\<dots> \\<le> norm x * max 1 K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x * K \\<le> norm x * max 1 K", "by (rule mult_left_mono [OF max.cobounded2 norm_ge_zero])"], ["proof (state)\nthis:\n  norm x * K \\<le> norm x * max 1 K\n\ngoal (1 subgoal):\n 1. \\<And>x. norm (f x) \\<le> norm x * max 1 K", "finally"], ["proof (chain)\npicking this:\n  norm (f x) \\<le> norm x * max 1 K", "show \"norm (f x) \\<le> norm x * max 1 K\""], ["proof (prove)\nusing this:\n  norm (f x) \\<le> norm x * max 1 K\n\ngoal (1 subgoal):\n 1. norm (f x) \\<le> norm x * max 1 K", "."], ["proof (state)\nthis:\n  norm (f x) \\<le> norm x * max 1 K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>K>0. \\<forall>x. norm (f x) \\<le> norm x * K\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Inherited from bounded_linear *)"], ["", "lemma nonneg_bounded: \"\\<exists>K\\<ge>0. \\<forall>x. norm (f x) \\<le> norm x * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K\\<ge>0. \\<forall>x. norm (f x) \\<le> norm x * K", "by (meson less_imp_le pos_bounded)"], ["", "lemma clinear: \"clinear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear f", "by (fact local.clinear_axioms)"], ["", "end"], ["", "lemma bounded_clinear_intro:\n  assumes \"\\<And>x y. f (x + y) = f x + f y\"\n    and \"\\<And>r x. f (scaleC r x) = scaleC r (f x)\"\n    and \"\\<And>x. norm (f x) \\<le> norm x * K\"\n  shows \"bounded_clinear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear f", "by standard (blast intro: assms)+"], ["", "locale bounded_cbilinear =\n  fixes prod :: \"'a::complex_normed_vector \\<Rightarrow> 'b::complex_normed_vector \\<Rightarrow> 'c::complex_normed_vector\"\n    (infixl \"**\" 70)\n  assumes add_left: \"prod (a + a') b = prod a b + prod a' b\"\n    and add_right: \"prod a (b + b') = prod a b + prod a b'\"\n    and scaleC_left: \"prod (scaleC r a) b = scaleC r (prod a b)\"\n    and scaleC_right: \"prod a (scaleC r b) = scaleC r (prod a b)\"\n    and bounded: \"\\<exists>K. \\<forall>a b. norm (prod a b) \\<le> norm a * norm b * K\"\nbegin"], ["", "(* Not present in Real_Vector_Spaces *)"], ["", "lemma bounded_bilinear[simp]: \"bounded_bilinear prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_bilinear (**)", "apply standard"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a a' b. (a + a') ** b = a ** b + a' ** b\n 2. \\<And>a b b'. a ** (b + b') = a ** b + a ** b'\n 3. \\<And>r a b. r *\\<^sub>R a ** b = r *\\<^sub>R (a ** b)\n 4. \\<And>a r b. a ** r *\\<^sub>R b = r *\\<^sub>R (a ** b)\n 5. \\<exists>K. \\<forall>a b. norm (a ** b) \\<le> norm a * norm b * K", "by (auto simp add: add_left add_right scaleR_scaleC scaleC_left scaleC_right bounded)"], ["", "(* Not present in Real_Vector_Spaces. Has only temporary effect (until \"end\") *)"], ["", "interpretation bounded_bilinear prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_bilinear (**)", "by simp"], ["", "lemmas pos_bounded = pos_bounded"], ["", "(* \"\\<exists>K>0. \\<forall>a b. norm (a ** b) \\<le> norm a * norm b * K\" *)"], ["", "lemmas nonneg_bounded = nonneg_bounded"], ["", "(* \"\\<exists>K\\<ge>0. \\<forall>a b. norm (a ** b) \\<le> norm a * norm b * K\" *)"], ["", "lemmas additive_right = additive_right"], ["", "(* \"additive (\\<lambda>b. prod a b)\" *)"], ["", "lemmas additive_left = additive_left"], ["", "(* \"additive (\\<lambda>a. prod a b)\" *)"], ["", "lemmas zero_left = zero_left"], ["", "(* \"prod 0 b = 0\" *)"], ["", "lemmas zero_right = zero_right"], ["", "(* \"prod a 0 = 0\" *)"], ["", "lemmas minus_left = minus_left"], ["", "(* \"prod (- a) b = - prod a b\" *)"], ["", "lemmas minus_right = minus_right"], ["", "(* \"prod a (- b) = - prod a b\" *)"], ["", "lemmas diff_left = diff_left"], ["", "(* \"prod (a - a') b = prod a b - prod a' b\" *)"], ["", "lemmas diff_right = diff_right"], ["", "(* \"prod a (b - b') = prod a b - prod a b'\" *)"], ["", "lemmas sum_left = sum_left"], ["", "(* \"prod (sum g S) x = sum ((\\<lambda>i. prod (g i) x)) S\" *)"], ["", "lemmas sum_right = sum_right"], ["", "(* \"prod x (sum g S) = sum ((\\<lambda>i. (prod x (g i)))) S\" *)"], ["", "lemmas prod_diff_prod = prod_diff_prod"], ["", "(* \"(x ** y - a ** b) = (x - a) ** (y - b) + (x - a) ** b + a ** (y - b)\" *)"], ["", "lemma bounded_clinear_left: \"bounded_clinear (\\<lambda>a. a ** b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>a. a ** b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>a. a ** b)", "obtain K where \"\\<And>a b. norm (a ** b) \\<le> norm a * norm b * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>K.\n        (\\<And>a b.\n            norm (a ** b) \\<le> norm a * norm b * K) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using pos_bounded"], ["proof (prove)\nusing this:\n  \\<exists>K>0. \\<forall>a b. norm (a ** b) \\<le> norm a * norm b * K\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        (\\<And>a b.\n            norm (a ** b) \\<le> norm a * norm b * K) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  norm (?a ** ?b) \\<le> norm ?a * norm ?b * K\n\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>a. a ** b)", "then"], ["proof (chain)\npicking this:\n  norm (?a ** ?b) \\<le> norm ?a * norm ?b * K", "show ?thesis"], ["proof (prove)\nusing this:\n  norm (?a ** ?b) \\<le> norm ?a * norm ?b * K\n\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>a. a ** b)", "by (rule_tac K=\"norm b * K\" in bounded_clinear_intro) (auto simp: algebra_simps scaleC_left add_left)"], ["proof (state)\nthis:\n  bounded_clinear (\\<lambda>a. a ** b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_clinear_right: \"bounded_clinear (\\<lambda>b. a ** b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear ((**) a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear ((**) a)", "obtain K where \"\\<And>a b. norm (a ** b) \\<le> norm a * norm b * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>K.\n        (\\<And>a b.\n            norm (a ** b) \\<le> norm a * norm b * K) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using pos_bounded"], ["proof (prove)\nusing this:\n  \\<exists>K>0. \\<forall>a b. norm (a ** b) \\<le> norm a * norm b * K\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        (\\<And>a b.\n            norm (a ** b) \\<le> norm a * norm b * K) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  norm (?a ** ?b) \\<le> norm ?a * norm ?b * K\n\ngoal (1 subgoal):\n 1. bounded_clinear ((**) a)", "then"], ["proof (chain)\npicking this:\n  norm (?a ** ?b) \\<le> norm ?a * norm ?b * K", "show ?thesis"], ["proof (prove)\nusing this:\n  norm (?a ** ?b) \\<le> norm ?a * norm ?b * K\n\ngoal (1 subgoal):\n 1. bounded_clinear ((**) a)", "by (rule_tac K=\"norm a * K\" in bounded_clinear_intro) (auto simp: algebra_simps scaleC_right add_right)"], ["proof (state)\nthis:\n  bounded_clinear ((**) a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flip: \"bounded_cbilinear (\\<lambda>x y. y ** x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_cbilinear (\\<lambda>x y. y ** x)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. b ** (a + a') = b ** a + b ** a'\n 2. \\<And>a b b'. (b + b') ** a = b ** a + b' ** a\n 3. \\<And>r a b. b ** r *\\<^sub>C a = r *\\<^sub>C (b ** a)\n 4. \\<And>a r b. r *\\<^sub>C b ** a = r *\\<^sub>C (b ** a)\n 5. \\<exists>K. \\<forall>a b. norm (b ** a) \\<le> norm a * norm b * K", "show \"\\<exists>K. \\<forall>a b. norm (b ** a) \\<le> norm a * norm b * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (b ** a) \\<le> norm a * norm b * K", "by (metis bounded mult.commute)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>a b. norm (b ** a) \\<le> norm a * norm b * K\n\ngoal (4 subgoals):\n 1. \\<And>a a' b. b ** (a + a') = b ** a + b ** a'\n 2. \\<And>a b b'. (b + b') ** a = b ** a + b' ** a\n 3. \\<And>r a b. b ** r *\\<^sub>C a = r *\\<^sub>C (b ** a)\n 4. \\<And>a r b. r *\\<^sub>C b ** a = r *\\<^sub>C (b ** a)", "qed (simp_all add: add_right add_left scaleC_right scaleC_left)"], ["", "lemma comp1:\n  assumes \"bounded_clinear g\"\n  shows \"bounded_cbilinear (\\<lambda>x. (**) (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_cbilinear (\\<lambda>x. (**) (g x))", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. g (a + a') ** b = g a ** b + g a' ** b\n 2. \\<And>a b b'. g a ** (b + b') = g a ** b + g a ** b'\n 3. \\<And>r a b. g (r *\\<^sub>C a) ** b = r *\\<^sub>C (g a ** b)\n 4. \\<And>a r b. g a ** r *\\<^sub>C b = r *\\<^sub>C (g a ** b)\n 5. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "interpret g: bounded_clinear g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear g", "by fact"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. g (a + a') ** b = g a ** b + g a' ** b\n 2. \\<And>a b b'. g a ** (b + b') = g a ** b + g a ** b'\n 3. \\<And>r a b. g (r *\\<^sub>C a) ** b = r *\\<^sub>C (g a ** b)\n 4. \\<And>a r b. g a ** r *\\<^sub>C b = r *\\<^sub>C (g a ** b)\n 5. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "show \"\\<And>a a' b. g (a + a') ** b = g a ** b + g a' ** b\"\n    \"\\<And>a b b'. g a ** (b + b') = g a ** b + g a ** b'\"\n    \"\\<And>r a b. g (r *\\<^sub>C a) ** b = r *\\<^sub>C (g a ** b)\"\n    \"\\<And>a r b. g a ** (r *\\<^sub>C b) = r *\\<^sub>C (g a ** b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>a a' b. g (a + a') ** b = g a ** b + g a' ** b) &&&\n     (\\<And>a b b'. g a ** (b + b') = g a ** b + g a ** b')) &&&\n    (\\<And>r a b. g (r *\\<^sub>C a) ** b = r *\\<^sub>C (g a ** b)) &&&\n    (\\<And>a r b. g a ** r *\\<^sub>C b = r *\\<^sub>C (g a ** b))", "by (auto simp: g.add add_left add_right g.scaleC scaleC_left scaleC_right)"], ["proof (state)\nthis:\n  g (?a + ?a') ** ?b = g ?a ** ?b + g ?a' ** ?b\n  g ?a ** (?b + ?b') = g ?a ** ?b + g ?a ** ?b'\n  g (?r *\\<^sub>C ?a) ** ?b = ?r *\\<^sub>C (g ?a ** ?b)\n  g ?a ** ?r *\\<^sub>C ?b = ?r *\\<^sub>C (g ?a ** ?b)\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "have \"bounded_bilinear (\\<lambda>a b. g a ** b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_bilinear (\\<lambda>a. (**) (g a))", "using g.bounded_linear"], ["proof (prove)\nusing this:\n  bounded_linear g\n\ngoal (1 subgoal):\n 1. bounded_bilinear (\\<lambda>a. (**) (g a))", "by (rule comp1)"], ["proof (state)\nthis:\n  bounded_bilinear (\\<lambda>a. (**) (g a))\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "then"], ["proof (chain)\npicking this:\n  bounded_bilinear (\\<lambda>a. (**) (g a))", "show \"\\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K\""], ["proof (prove)\nusing this:\n  bounded_bilinear (\\<lambda>a. (**) (g a))\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "by (rule bounded_bilinear.bounded)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp: \"bounded_clinear f \\<Longrightarrow> bounded_clinear g \\<Longrightarrow> bounded_cbilinear (\\<lambda>x y. f x ** g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded_clinear f; bounded_clinear g\\<rbrakk>\n    \\<Longrightarrow> bounded_cbilinear (\\<lambda>x y. f x ** g y)", "by (rule bounded_cbilinear.flip[OF bounded_cbilinear.comp1[OF bounded_cbilinear.flip[OF comp1]]])"], ["", "end"], ["", "(* locale bounded_cbilinear *)"], ["", "lemma bounded_clinear_ident[simp]: \"bounded_clinear (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. x)", "by standard (auto intro!: exI[of _ 1])"], ["", "lemma bounded_clinear_zero[simp]: \"bounded_clinear (\\<lambda>x. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. 0::'b)", "by standard (auto intro!: exI[of _ 1])"], ["", "lemma bounded_clinear_add:\n  assumes \"bounded_clinear f\"\n    and \"bounded_clinear g\"\n  shows \"bounded_clinear (\\<lambda>x. f x + g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. f x + g x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. f x + g x)", "interpret f: bounded_clinear f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear f", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. f x + g x)", "interpret g: bounded_clinear g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear g", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. f x + g x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. f x + g x)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2. f (b1 + b2) + g (b1 + b2) = f b1 + g b1 + (f b2 + g b2)\n 2. \\<And>r b.\n       f (r *\\<^sub>C b) + g (r *\\<^sub>C b) = r *\\<^sub>C (f b + g b)\n 3. \\<exists>K. \\<forall>x. norm (f x + g x) \\<le> norm x * K", "from f.bounded"], ["proof (chain)\npicking this:\n  \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "obtain Kf where Kf: \"norm (f x) \\<le> norm x * Kf\" for x"], ["proof (prove)\nusing this:\n  \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. (\\<And>Kf.\n        (\\<And>x. norm (f x) \\<le> norm x * Kf) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  norm (f ?x) \\<le> norm ?x * Kf\n\ngoal (3 subgoals):\n 1. \\<And>b1 b2. f (b1 + b2) + g (b1 + b2) = f b1 + g b1 + (f b2 + g b2)\n 2. \\<And>r b.\n       f (r *\\<^sub>C b) + g (r *\\<^sub>C b) = r *\\<^sub>C (f b + g b)\n 3. \\<exists>K. \\<forall>x. norm (f x + g x) \\<le> norm x * K", "from g.bounded"], ["proof (chain)\npicking this:\n  \\<exists>K. \\<forall>x. norm (g x) \\<le> norm x * K", "obtain Kg where Kg: \"norm (g x) \\<le> norm x * Kg\" for x"], ["proof (prove)\nusing this:\n  \\<exists>K. \\<forall>x. norm (g x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. (\\<And>Kg.\n        (\\<And>x. norm (g x) \\<le> norm x * Kg) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  norm (g ?x) \\<le> norm ?x * Kg\n\ngoal (3 subgoals):\n 1. \\<And>b1 b2. f (b1 + b2) + g (b1 + b2) = f b1 + g b1 + (f b2 + g b2)\n 2. \\<And>r b.\n       f (r *\\<^sub>C b) + g (r *\\<^sub>C b) = r *\\<^sub>C (f b + g b)\n 3. \\<exists>K. \\<forall>x. norm (f x + g x) \\<le> norm x * K", "show \"\\<exists>K. \\<forall>x. norm (f x + g x) \\<le> norm x * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f x + g x) \\<le> norm x * K", "using add_mono[OF Kf Kg]"], ["proof (prove)\nusing this:\n  norm (f ?x2) + norm (g ?x1) \\<le> norm ?x2 * Kf + norm ?x1 * Kg\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f x + g x) \\<le> norm x * K", "by (intro exI[of _ \"Kf + Kg\"]) (auto simp: field_simps intro: norm_triangle_ineq order_trans)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>x. norm (f x + g x) \\<le> norm x * K\n\ngoal (2 subgoals):\n 1. \\<And>b1 b2. f (b1 + b2) + g (b1 + b2) = f b1 + g b1 + (f b2 + g b2)\n 2. \\<And>r b.\n       f (r *\\<^sub>C b) + g (r *\\<^sub>C b) = r *\\<^sub>C (f b + g b)", "qed (simp_all add: f.add g.add f.scaleC g.scaleC scaleC_add_right)"], ["proof (state)\nthis:\n  bounded_clinear (\\<lambda>x. f x + g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_clinear_minus:\n  assumes \"bounded_clinear f\"\n  shows \"bounded_clinear (\\<lambda>x. - f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. - f x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. - f x)", "interpret f: bounded_clinear f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear f", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. - f x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. - f x)", "by unfold_locales (simp_all add: f.add f.scaleC f.bounded)"], ["proof (state)\nthis:\n  bounded_clinear (\\<lambda>x. - f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_clinear_sub: \"bounded_clinear f \\<Longrightarrow> bounded_clinear g \\<Longrightarrow> bounded_clinear (\\<lambda>x. f x - g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded_clinear f; bounded_clinear g\\<rbrakk>\n    \\<Longrightarrow> bounded_clinear (\\<lambda>x. f x - g x)", "using bounded_clinear_add[of f \"\\<lambda>x. - g x\"] bounded_clinear_minus[of g]"], ["proof (prove)\nusing this:\n  \\<lbrakk>bounded_clinear f; bounded_clinear (\\<lambda>x. - g x)\\<rbrakk>\n  \\<Longrightarrow> bounded_clinear (\\<lambda>x. f x + - g x)\n  bounded_clinear g \\<Longrightarrow> bounded_clinear (\\<lambda>x. - g x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded_clinear f; bounded_clinear g\\<rbrakk>\n    \\<Longrightarrow> bounded_clinear (\\<lambda>x. f x - g x)", "by (auto simp: algebra_simps)"], ["", "lemma bounded_clinear_sum:\n  fixes f :: \"'i \\<Rightarrow> 'a::complex_normed_vector \\<Rightarrow> 'b::complex_normed_vector\"\n  shows \"(\\<And>i. i \\<in> I \\<Longrightarrow> bounded_clinear (f i)) \\<Longrightarrow> bounded_clinear (\\<lambda>x. \\<Sum>i\\<in>I. f i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> I \\<Longrightarrow> bounded_clinear (f i)) \\<Longrightarrow>\n    bounded_clinear (\\<lambda>x. \\<Sum>i\\<in>I. f i x)", "by (induct I rule: infinite_finite_induct) (auto intro!: bounded_clinear_add)"], ["", "lemma bounded_clinear_compose:\n  assumes \"bounded_clinear f\"\n    and \"bounded_clinear g\"\n  shows \"bounded_clinear (\\<lambda>x. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. f (g x))", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2. f (g (b1 + b2)) = f (g b1) + f (g b2)\n 2. \\<And>r b. f (g (r *\\<^sub>C b)) = r *\\<^sub>C f (g b)\n 3. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "interpret f: bounded_clinear f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear f", "by fact"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2. f (g (b1 + b2)) = f (g b1) + f (g b2)\n 2. \\<And>r b. f (g (r *\\<^sub>C b)) = r *\\<^sub>C f (g b)\n 3. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "interpret g: bounded_clinear g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear g", "by fact"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2. f (g (b1 + b2)) = f (g b1) + f (g b2)\n 2. \\<And>r b. f (g (r *\\<^sub>C b)) = r *\\<^sub>C f (g b)\n 3. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "show \"f (g (x + y)) = f (g x) + f (g y)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (g (x + y)) = f (g x) + f (g y)", "by (simp only: f.add g.add)"], ["proof (state)\nthis:\n  f (g (?x + ?y)) = f (g ?x) + f (g ?y)\n\ngoal (2 subgoals):\n 1. \\<And>r b. f (g (r *\\<^sub>C b)) = r *\\<^sub>C f (g b)\n 2. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "show \"f (g (scaleC r x)) = scaleC r (f (g x))\" for r x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (g (r *\\<^sub>C x)) = r *\\<^sub>C f (g x)", "by (simp only: f.scaleC g.scaleC)"], ["proof (state)\nthis:\n  f (g (?r *\\<^sub>C ?x)) = ?r *\\<^sub>C f (g ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "from f.pos_bounded"], ["proof (chain)\npicking this:\n  \\<exists>K>0. \\<forall>x. norm (f x) \\<le> norm x * K", "obtain Kf where f: \"\\<And>x. norm (f x) \\<le> norm x * Kf\" and Kf: \"0 < Kf\""], ["proof (prove)\nusing this:\n  \\<exists>K>0. \\<forall>x. norm (f x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. (\\<And>Kf.\n        \\<lbrakk>\\<And>x. norm (f x) \\<le> norm x * Kf; 0 < Kf\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  norm (f ?x) \\<le> norm ?x * Kf\n  0 < Kf\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "from g.pos_bounded"], ["proof (chain)\npicking this:\n  \\<exists>K>0. \\<forall>x. norm (g x) \\<le> norm x * K", "obtain Kg where g: \"\\<And>x. norm (g x) \\<le> norm x * Kg\""], ["proof (prove)\nusing this:\n  \\<exists>K>0. \\<forall>x. norm (g x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. (\\<And>Kg.\n        (\\<And>x. norm (g x) \\<le> norm x * Kg) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  norm (g ?x) \\<le> norm ?x * Kg\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "show \"\\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "proof (intro exI allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. norm (f (g x)) \\<le> norm x * ?K", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. norm (f (g x)) \\<le> norm x * ?K", "have \"norm (f (g x)) \\<le> norm (g x) * Kf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (f (g x)) \\<le> norm (g x) * Kf", "using f"], ["proof (prove)\nusing this:\n  norm (f ?x) \\<le> norm ?x * Kf\n\ngoal (1 subgoal):\n 1. norm (f (g x)) \\<le> norm (g x) * Kf", "."], ["proof (state)\nthis:\n  norm (f (g x)) \\<le> norm (g x) * Kf\n\ngoal (1 subgoal):\n 1. \\<And>x. norm (f (g x)) \\<le> norm x * ?K", "also"], ["proof (state)\nthis:\n  norm (f (g x)) \\<le> norm (g x) * Kf\n\ngoal (1 subgoal):\n 1. \\<And>x. norm (f (g x)) \\<le> norm x * ?K", "have \"\\<dots> \\<le> (norm x * Kg) * Kf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (g x) * Kf \\<le> norm x * Kg * Kf", "using g Kf [THEN order_less_imp_le]"], ["proof (prove)\nusing this:\n  norm (g ?x) \\<le> norm ?x * Kg\n  0 \\<le> Kf\n\ngoal (1 subgoal):\n 1. norm (g x) * Kf \\<le> norm x * Kg * Kf", "by (rule mult_right_mono)"], ["proof (state)\nthis:\n  norm (g x) * Kf \\<le> norm x * Kg * Kf\n\ngoal (1 subgoal):\n 1. \\<And>x. norm (f (g x)) \\<le> norm x * ?K", "also"], ["proof (state)\nthis:\n  norm (g x) * Kf \\<le> norm x * Kg * Kf\n\ngoal (1 subgoal):\n 1. \\<And>x. norm (f (g x)) \\<le> norm x * ?K", "have \"(norm x * Kg) * Kf = norm x * (Kg * Kf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x * Kg * Kf = norm x * (Kg * Kf)", "by (rule mult.assoc)"], ["proof (state)\nthis:\n  norm x * Kg * Kf = norm x * (Kg * Kf)\n\ngoal (1 subgoal):\n 1. \\<And>x. norm (f (g x)) \\<le> norm x * ?K", "finally"], ["proof (chain)\npicking this:\n  norm (f (g x)) \\<le> norm x * (Kg * Kf)", "show \"norm (f (g x)) \\<le> norm x * (Kg * Kf)\""], ["proof (prove)\nusing this:\n  norm (f (g x)) \\<le> norm x * (Kg * Kf)\n\ngoal (1 subgoal):\n 1. norm (f (g x)) \\<le> norm x * (Kg * Kf)", "."], ["proof (state)\nthis:\n  norm (f (g x)) \\<le> norm x * (Kg * Kf)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_cbilinear_mult: \"bounded_cbilinear ((*) :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a::complex_normed_algebra)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_cbilinear (*)", "proof (rule bounded_cbilinear.intro)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. (a + a') * b = a * b + a' * b\n 2. \\<And>a b b'. a * (b + b') = a * b + a * b'\n 3. \\<And>r a b. r *\\<^sub>C a * b = r *\\<^sub>C (a * b)\n 4. \\<And>a r b. a * r *\\<^sub>C b = r *\\<^sub>C (a * b)\n 5. \\<exists>K. \\<forall>a b. norm (a * b) \\<le> norm a * norm b * K", "show \"\\<exists>K. \\<forall>a b::'a. norm (a * b) \\<le> norm a * norm b * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (a * b) \\<le> norm a * norm b * K", "by (rule_tac x=1 in exI) (simp add: norm_mult_ineq)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>a b. norm (a * b) \\<le> norm a * norm b * K\n\ngoal (4 subgoals):\n 1. \\<And>a a' b. (a + a') * b = a * b + a' * b\n 2. \\<And>a b b'. a * (b + b') = a * b + a * b'\n 3. \\<And>r a b. r *\\<^sub>C a * b = r *\\<^sub>C (a * b)\n 4. \\<And>a r b. a * r *\\<^sub>C b = r *\\<^sub>C (a * b)", "qed (auto simp: algebra_simps)"], ["", "lemma bounded_clinear_mult_left: \"bounded_clinear (\\<lambda>x::'a::complex_normed_algebra. x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. x * y)", "using bounded_cbilinear_mult"], ["proof (prove)\nusing this:\n  bounded_cbilinear (*)\n\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. x * y)", "by (rule bounded_cbilinear.bounded_clinear_left)"], ["", "lemma bounded_clinear_mult_right: \"bounded_clinear (\\<lambda>y::'a::complex_normed_algebra. x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear ((*) x)", "using bounded_cbilinear_mult"], ["proof (prove)\nusing this:\n  bounded_cbilinear (*)\n\ngoal (1 subgoal):\n 1. bounded_clinear ((*) x)", "by (rule bounded_cbilinear.bounded_clinear_right)"], ["", "lemmas bounded_clinear_mult_const =\n  bounded_clinear_mult_left [THEN bounded_clinear_compose]"], ["", "lemmas bounded_clinear_const_mult =\n  bounded_clinear_mult_right [THEN bounded_clinear_compose]"], ["", "lemma bounded_clinear_divide: \"bounded_clinear (\\<lambda>x. x / y)\"\n  for y :: \"'a::complex_normed_field\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. x / y)", "unfolding divide_inverse"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. x * inverse y)", "by (rule bounded_clinear_mult_left)"], ["", "lemma bounded_cbilinear_scaleC: \"bounded_cbilinear scaleC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_cbilinear (*\\<^sub>C)", "proof (rule bounded_cbilinear.intro)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. (a + a') *\\<^sub>C b = a *\\<^sub>C b + a' *\\<^sub>C b\n 2. \\<And>a b b'. a *\\<^sub>C (b + b') = a *\\<^sub>C b + a *\\<^sub>C b'\n 3. \\<And>r a b. (r *\\<^sub>C a) *\\<^sub>C b = r *\\<^sub>C a *\\<^sub>C b\n 4. \\<And>a r b. a *\\<^sub>C r *\\<^sub>C b = r *\\<^sub>C a *\\<^sub>C b\n 5. \\<exists>K. \\<forall>a b. norm (a *\\<^sub>C b) \\<le> cmod a * norm b * K", "obtain K where K: \\<open>\\<forall>a (b::'a). norm b \\<le> norm b * K\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>K.\n        \\<forall>a b. norm b \\<le> norm b * K \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using less_eq_real_def"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        \\<forall>a b. norm b \\<le> norm b * K \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>a b. norm b \\<le> norm b * K\n\ngoal (5 subgoals):\n 1. \\<And>a a' b. (a + a') *\\<^sub>C b = a *\\<^sub>C b + a' *\\<^sub>C b\n 2. \\<And>a b b'. a *\\<^sub>C (b + b') = a *\\<^sub>C b + a *\\<^sub>C b'\n 3. \\<And>r a b. (r *\\<^sub>C a) *\\<^sub>C b = r *\\<^sub>C a *\\<^sub>C b\n 4. \\<And>a r b. a *\\<^sub>C r *\\<^sub>C b = r *\\<^sub>C a *\\<^sub>C b\n 5. \\<exists>K. \\<forall>a b. norm (a *\\<^sub>C b) \\<le> cmod a * norm b * K", "show \"\\<exists>K. \\<forall>a (b::'a). norm (a *\\<^sub>C b) \\<le> norm a * norm b * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (a *\\<^sub>C b) \\<le> cmod a * norm b * K", "apply (rule exI[where x=K])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. norm (a *\\<^sub>C b) \\<le> cmod a * norm b * K", "using K"], ["proof (prove)\nusing this:\n  \\<forall>a b. norm b \\<le> norm b * K\n\ngoal (1 subgoal):\n 1. \\<forall>a b. norm (a *\\<^sub>C b) \\<le> cmod a * norm b * K", "by (metis norm_scaleC)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>a b. norm (a *\\<^sub>C b) \\<le> cmod a * norm b * K\n\ngoal (4 subgoals):\n 1. \\<And>a a' b. (a + a') *\\<^sub>C b = a *\\<^sub>C b + a' *\\<^sub>C b\n 2. \\<And>a b b'. a *\\<^sub>C (b + b') = a *\\<^sub>C b + a *\\<^sub>C b'\n 3. \\<And>r a b. (r *\\<^sub>C a) *\\<^sub>C b = r *\\<^sub>C a *\\<^sub>C b\n 4. \\<And>a r b. a *\\<^sub>C r *\\<^sub>C b = r *\\<^sub>C a *\\<^sub>C b", "qed (auto simp: algebra_simps)"], ["", "lemma bounded_clinear_scaleC_left: \"bounded_clinear (\\<lambda>c. scaleC c x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>c. c *\\<^sub>C x)", "using bounded_cbilinear_scaleC"], ["proof (prove)\nusing this:\n  bounded_cbilinear (*\\<^sub>C)\n\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>c. c *\\<^sub>C x)", "by (rule bounded_cbilinear.bounded_clinear_left)"], ["", "lemma bounded_clinear_scaleC_right: \"bounded_clinear (\\<lambda>x. scaleC c x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear ((*\\<^sub>C) c)", "using bounded_cbilinear_scaleC"], ["proof (prove)\nusing this:\n  bounded_cbilinear (*\\<^sub>C)\n\ngoal (1 subgoal):\n 1. bounded_clinear ((*\\<^sub>C) c)", "by (rule bounded_cbilinear.bounded_clinear_right)"], ["", "lemmas bounded_clinear_scaleC_const =\n  bounded_clinear_scaleC_left[THEN bounded_clinear_compose]"], ["", "lemmas bounded_clinear_const_scaleC =\n  bounded_clinear_scaleC_right[THEN bounded_clinear_compose]"], ["", "lemma bounded_clinear_of_complex: \"bounded_clinear (\\<lambda>r. of_complex r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear of_complex", "unfolding of_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>r. r *\\<^sub>C (1::'a))", "by (rule bounded_clinear_scaleC_left)"], ["", "lemma complex_bounded_clinear: \"bounded_clinear f \\<longleftrightarrow> (\\<exists>c::complex. f = (\\<lambda>x. x * c))\"\n  for f :: \"complex \\<Rightarrow> complex\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear f = (\\<exists>c. f = (\\<lambda>x. x * c))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear f = (\\<exists>c. f = (\\<lambda>x. x * c))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear f = (\\<exists>c. f = (\\<lambda>x. x * c))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear f = (\\<exists>c. f = (\\<lambda>x. x * c))", "assume \"bounded_clinear f\""], ["proof (state)\nthis:\n  bounded_clinear f\n\ngoal (1 subgoal):\n 1. bounded_clinear f = (\\<exists>c. f = (\\<lambda>x. x * c))", "then"], ["proof (chain)\npicking this:\n  bounded_clinear f", "interpret bounded_clinear f"], ["proof (prove)\nusing this:\n  bounded_clinear f\n\ngoal (1 subgoal):\n 1. bounded_clinear f", "."], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear f = (\\<exists>c. f = (\\<lambda>x. x * c))", "from scaleC[of x 1]"], ["proof (chain)\npicking this:\n  f (x *\\<^sub>C 1) = x *\\<^sub>C f 1", "have \"f x = x * f 1\""], ["proof (prove)\nusing this:\n  f (x *\\<^sub>C 1) = x *\\<^sub>C f 1\n\ngoal (1 subgoal):\n 1. f x = x * f 1", "by simp"], ["proof (state)\nthis:\n  f x = x * f 1\n\ngoal (1 subgoal):\n 1. bounded_clinear f = (\\<exists>c. f = (\\<lambda>x. x * c))", "}"], ["proof (state)\nthis:\n  bounded_clinear f \\<Longrightarrow> f ?x2 = ?x2 * f 1\n\ngoal (1 subgoal):\n 1. bounded_clinear f = (\\<exists>c. f = (\\<lambda>x. x * c))", "then"], ["proof (chain)\npicking this:\n  bounded_clinear f \\<Longrightarrow> f ?x2 = ?x2 * f 1", "show ?thesis"], ["proof (prove)\nusing this:\n  bounded_clinear f \\<Longrightarrow> f ?x2 = ?x2 * f 1\n\ngoal (1 subgoal):\n 1. bounded_clinear f = (\\<exists>c. f = (\\<lambda>x. x * c))", "by (auto intro: exI[of _ \"f 1\"] bounded_clinear_mult_left)"], ["proof (state)\nthis:\n  bounded_clinear f = (\\<exists>c. f = (\\<lambda>x. x * c))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Inherited from real_normed_algebra_1 *)\n(* instance complex_normed_algebra_1 \\<subseteq> perfect_space *)\n\n(* subsection \\<open>Filters and Limits on Metric Space\\<close> *)\n(* Everything is commented out, so we comment out the heading, too. *)\n\n(* Not specific to real/complex *)\n(* lemma (in metric_space) nhds_metric: \"nhds x = (INF e\\<in>{0 <..}. principal {y. dist y x < e})\" *)\n(* lemma (in metric_space) tendsto_iff: \"(f \\<longlongrightarrow> l) F \\<longleftrightarrow> (\\<forall>e>0. eventually (\\<lambda>x. dist (f x) l < e) F)\" *)\n(* lemma tendsto_dist_iff: \"((f \\<longlongrightarrow> l) F) \\<longleftrightarrow> (((\\<lambda>x. dist (f x) l) \\<longlongrightarrow> 0) F)\" *)\n(* lemma (in metric_space) tendstoI [intro?]:\n  \"(\\<And>e. 0 < e \\<Longrightarrow> eventually (\\<lambda>x. dist (f x) l < e) F) \\<Longrightarrow> (f \\<longlongrightarrow> l) F\" *)\n(* lemma (in metric_space) tendstoD: \"(f \\<longlongrightarrow> l) F \\<Longrightarrow> 0 < e \\<Longrightarrow> eventually (\\<lambda>x. dist (f x) l < e) F\" *)\n(* lemma (in metric_space) eventually_nhds_metric:\n  \"eventually P (nhds a) \\<longleftrightarrow> (\\<exists>d>0. \\<forall>x. dist x a < d \\<longrightarrow> P x)\" *)\n(* lemma eventually_at: \"eventually P (at a within S) \\<longleftrightarrow> (\\<exists>d>0. \\<forall>x\\<in>S. x \\<noteq> a \\<and> dist x a < d \\<longrightarrow> P x)\"\n  for a :: \"'a :: metric_space\" *)\n(* lemma frequently_at: \"frequently P (at a within S) \\<longleftrightarrow> (\\<forall>d>0. \\<exists>x\\<in>S. x \\<noteq> a \\<and> dist x a < d \\<and> P x)\"\n  for a :: \"'a :: metric_space\" *)\n(* lemma eventually_at_le: \"eventually P (at a within S) \\<longleftrightarrow> (\\<exists>d>0. \\<forall>x\\<in>S. x \\<noteq> a \\<and> dist x a \\<le> d \\<longrightarrow> P x)\"\n  for a :: \"'a::metric_space\" *)\n\n(* Does not work in complex case because it needs complex :: order_toplogy *)\n(* lemma eventually_at_left_real: \"a > (b :: real) \\<Longrightarrow> eventually (\\<lambda>x. x \\<in> {b<..<a}) (at_left a)\" *)\n(* lemma eventually_at_right_real: \"a < (b :: real) \\<Longrightarrow> eventually (\\<lambda>x. x \\<in> {a<..<b}) (at_right a)\" *)\n\n(* Not specific to real/complex *)\n(* lemma metric_tendsto_imp_tendsto:\n  fixes a :: \"'a :: metric_space\"\n    and b :: \"'b :: metric_space\"\n  assumes f: \"(f \\<longlongrightarrow> a) F\"\n    and le: \"eventually (\\<lambda>x. dist (g x) b \\<le> dist (f x) a) F\"\n  shows \"(g \\<longlongrightarrow> b) F\" *)\n\n(* Not sure if this makes sense in the complex case *)\n(* lemma filterlim_complex_sequentially: \"LIM x sequentially. (of_nat x :: complex) :> at_top\" *)\n\n(* Not specific to real/complex *)\n(* lemma filterlim_nat_sequentially: \"filterlim nat sequentially at_top\" *)\n(* lemma filterlim_floor_sequentially: \"filterlim floor at_top at_top\" *)\n\n(* Not sure if this makes sense in the complex case *)\n(* lemma filterlim_sequentially_iff_filterlim_real:\n  \"filterlim f sequentially F \\<longleftrightarrow> filterlim (\\<lambda>x. real (f x)) at_top F\" (is \"?lhs = ?rhs\") *)"], ["", "subsubsection \\<open>Limits of Sequences\\<close>"], ["", "(* Not specific to real/complex *)\n(* lemma lim_sequentially: \"X \\<longlonglongrightarrow> L \\<longleftrightarrow> (\\<forall>r>0. \\<exists>no. \\<forall>n\\<ge>no. dist (X n) L < r)\"\n  for L :: \"'a::metric_space\" *)\n(* lemmas LIMSEQ_def = lim_sequentially  (*legacy binding*) *)\n(* lemma LIMSEQ_iff_nz: \"X \\<longlonglongrightarrow> L \\<longleftrightarrow> (\\<forall>r>0. \\<exists>no>0. \\<forall>n\\<ge>no. dist (X n) L < r)\"\n  for L :: \"'a::metric_space\" *)\n(* lemma metric_LIMSEQ_I: \"(\\<And>r. 0 < r \\<Longrightarrow> \\<exists>no. \\<forall>n\\<ge>no. dist (X n) L < r) \\<Longrightarrow> X \\<longlonglongrightarrow> L\"\n  for L :: \"'a::metric_space\" *)\n(* lemma metric_LIMSEQ_D: \"X \\<longlonglongrightarrow> L \\<Longrightarrow> 0 < r \\<Longrightarrow> \\<exists>no. \\<forall>n\\<ge>no. dist (X n) L < r\"\n  for L :: \"'a::metric_space\" *)\n(* lemma LIMSEQ_norm_0:\n  assumes  \"\\<And>n::nat. norm (f n) < 1 / real (Suc n)\"\n  shows \"f \\<longlonglongrightarrow> 0\" *)\n\n(* subsubsection \\<open>Limits of Functions\\<close> *)\n(* Everything is commented out, so we comment out the heading, too. *)\n\n(* Not specific to real/complex *)\n(* lemma LIM_def: \"f \\<midarrow>a\\<rightarrow> L \\<longleftrightarrow> (\\<forall>r > 0. \\<exists>s > 0. \\<forall>x. x \\<noteq> a \\<and> dist x a < s \\<longrightarrow> dist (f x) L < r)\"\n  for a :: \"'a::metric_space\" and L :: \"'b::metric_space\" *)\n(* lemma metric_LIM_I:\n  \"(\\<And>r. 0 < r \\<Longrightarrow> \\<exists>s>0. \\<forall>x. x \\<noteq> a \\<and> dist x a < s \\<longrightarrow> dist (f x) L < r) \\<Longrightarrow> f \\<midarrow>a\\<rightarrow> L\"\n  for a :: \"'a::metric_space\" and L :: \"'b::metric_space\" *)\n(* lemma metric_LIM_D: \"f \\<midarrow>a\\<rightarrow> L \\<Longrightarrow> 0 < r \\<Longrightarrow> \\<exists>s>0. \\<forall>x. x \\<noteq> a \\<and> dist x a < s \\<longrightarrow> dist (f x) L < r\"\n  for a :: \"'a::metric_space\" and L :: \"'b::metric_space\" *)\n(* lemma metric_LIM_imp_LIM:\n  fixes l :: \"'a::metric_space\"\n    and m :: \"'b::metric_space\"\n  assumes f: \"f \\<midarrow>a\\<rightarrow> l\"\n    and le: \"\\<And>x. x \\<noteq> a \\<Longrightarrow> dist (g x) m \\<le> dist (f x) l\"\n  shows \"g \\<midarrow>a\\<rightarrow> m\" *)\n(* lemma metric_LIM_equal2:\n  fixes a :: \"'a::metric_space\"\n  assumes \"g \\<midarrow>a\\<rightarrow> l\" \"0 < R\"\n    and \"\\<And>x. x \\<noteq> a \\<Longrightarrow> dist x a < R \\<Longrightarrow> f x = g x\"\n  shows \"f \\<midarrow>a\\<rightarrow> l\" *)\n(* lemma metric_LIM_compose2:\n  fixes a :: \"'a::metric_space\"\n  assumes f: \"f \\<midarrow>a\\<rightarrow> b\"\n    and g: \"g \\<midarrow>b\\<rightarrow> c\"\n    and inj: \"\\<exists>d>0. \\<forall>x. x \\<noteq> a \\<and> dist x a < d \\<longrightarrow> f x \\<noteq> b\"\n  shows \"(\\<lambda>x. g (f x)) \\<midarrow>a\\<rightarrow> c\" *)\n(* lemma metric_isCont_LIM_compose2:\n  fixes f :: \"'a :: metric_space \\<Rightarrow> _\"\n  assumes f [unfolded isCont_def]: \"isCont f a\"\n    and g: \"g \\<midarrow>f a\\<rightarrow> l\"\n    and inj: \"\\<exists>d>0. \\<forall>x. x \\<noteq> a \\<and> dist x a < d \\<longrightarrow> f x \\<noteq> f a\"\n  shows \"(\\<lambda>x. g (f x)) \\<midarrow>a\\<rightarrow> l\" *)\n\n\n(* subsection \\<open>Complete metric spaces\\<close> *)\n(* Everything is commented out, so we comment out the heading, too. *)"], ["", "subsection \\<open>Cauchy sequences\\<close>"], ["", "(* Not specific to real/complex *)\n(* lemma (in metric_space) Cauchy_def: \"Cauchy X = (\\<forall>e>0. \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (X m) (X n) < e)\" *)\n(* lemma (in metric_space) Cauchy_altdef: \"Cauchy f \\<longleftrightarrow> (\\<forall>e>0. \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n>m. dist (f m) (f n) < e)\" *)\n(* lemma (in metric_space) Cauchy_altdef2: \"Cauchy s \\<longleftrightarrow> (\\<forall>e>0. \\<exists>N::nat. \\<forall>n\\<ge>N. dist(s n)(s N) < e)\" (is \"?lhs = ?rhs\") *)\n(* lemma (in metric_space) metric_CauchyI:\n  \"(\\<And>e. 0 < e \\<Longrightarrow> \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (X m) (X n) < e) \\<Longrightarrow> Cauchy X\" *)\n(* lemma (in metric_space) CauchyI':\n  \"(\\<And>e. 0 < e \\<Longrightarrow> \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n>m. dist (X m) (X n) < e) \\<Longrightarrow> Cauchy X\" *)\n(* lemma (in metric_space) metric_CauchyD:\n  \"Cauchy X \\<Longrightarrow> 0 < e \\<Longrightarrow> \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (X m) (X n) < e\" *)\n(* lemma (in metric_space) metric_Cauchy_iff2:\n  \"Cauchy X = (\\<forall>j. (\\<exists>M. \\<forall>m \\<ge> M. \\<forall>n \\<ge> M. dist (X m) (X n) < inverse(real (Suc j))))\" *)"], ["", "lemma cCauchy_iff2: \"Cauchy X \\<longleftrightarrow> (\\<forall>j. (\\<exists>M. \\<forall>m \\<ge> M. \\<forall>n \\<ge> M. cmod (X m - X n) < inverse (real (Suc j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy X =\n    (\\<forall>j.\n        \\<exists>M.\n           \\<forall>m\\<ge>M.\n              \\<forall>n\\<ge>M. cmod (X m - X n) < inverse (real (Suc j)))", "by (simp only: metric_Cauchy_iff2 dist_complex_def)"], ["", "(* Not specific to real/complex *)\n(* lemma lim_1_over_n [tendsto_intros]: \"((\\<lambda>n. 1 / of_nat n) \\<longlongrightarrow> (0::'a::complex_normed_field)) sequentially\" *)\n(* lemma (in metric_space) complete_def:\n  shows \"complete S = (\\<forall>f. (\\<forall>n. f n \\<in> S) \\<and> Cauchy f \\<longrightarrow> (\\<exists>l\\<in>S. f \\<longlonglongrightarrow> l))\" *)\n(* lemma (in metric_space) totally_bounded_metric:\n  \"totally_bounded S \\<longleftrightarrow> (\\<forall>e>0. \\<exists>k. finite k \\<and> S \\<subseteq> (\\<Union>x\\<in>k. {y. dist x y < e}))\" *)\n\n(* subsubsection \\<open>Cauchy Sequences are Convergent\\<close> *)\n(* Everything is commented out, so we comment out the heading, too. *)\n\n(* Not specific to real/complex *)\n(* class complete_space *)\n(* lemma Cauchy_convergent_iff: \"Cauchy X \\<longleftrightarrow> convergent X\"\n  for X :: \"nat \\<Rightarrow> 'a::complete_space\" *)\n\n(* text \\<open>To prove that a Cauchy sequence converges, it suffices to show that a subsequence converges.\\<close> *)\n\n(* Not specific to real/complex *)\n(* lemma Cauchy_converges_subseq:\n  fixes u::\"nat \\<Rightarrow> 'a::metric_space\"\n  assumes \"Cauchy u\"\n    \"strict_mono r\"\n    \"(u \\<circ> r) \\<longlonglongrightarrow> l\"\n  shows \"u \\<longlonglongrightarrow> l\" *)"], ["", "subsection \\<open>The set of real numbers is a complete metric space\\<close>"], ["", "text \\<open>\n  Proof that Cauchy sequences converge based on the one from\n  \\<^url>\\<open>http://pirate.shu.edu/~wachsmut/ira/numseq/proofs/cauconv.html\\<close>\n\\<close>"], ["", "text \\<open>\n  If sequence \\<^term>\\<open>X\\<close> is Cauchy, then its limit is the lub of\n  \\<^term>\\<open>{r::real. \\<exists>N. \\<forall>n\\<ge>N. r < X n}\\<close>\n\\<close>"], ["", "lemma complex_increasing_LIMSEQ:\n  fixes f :: \"nat \\<Rightarrow> complex\"\n  assumes inc: \"\\<And>n. f n \\<le> f (Suc n)\"\n    and bdd: \"\\<And>n. f n \\<le> l\"\n    and en: \"\\<And>e. 0 < e \\<Longrightarrow> \\<exists>n. l \\<le> f n + e\"\n  shows \"f \\<longlonglongrightarrow> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<longlonglongrightarrow> l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<longlonglongrightarrow> l", "have \\<open>(\\<lambda>n. Re (f n)) \\<longlonglongrightarrow> Re l\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. Re (f n)) \\<longlonglongrightarrow> Re l", "apply (rule increasing_LIMSEQ)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n. Re (f n) \\<le> Re (f (Suc n))\n 2. \\<And>n. Re (f n) \\<le> Re l\n 3. \\<And>e. 0 < e \\<Longrightarrow> \\<exists>n. Re l \\<le> Re (f n) + e", "using assms"], ["proof (prove)\nusing this:\n  f ?n \\<le> f (Suc ?n)\n  f ?n \\<le> l\n  0 < ?e \\<Longrightarrow> \\<exists>n. l \\<le> f n + ?e\n\ngoal (3 subgoals):\n 1. \\<And>n. Re (f n) \\<le> Re (f (Suc n))\n 2. \\<And>n. Re (f n) \\<le> Re l\n 3. \\<And>e. 0 < e \\<Longrightarrow> \\<exists>n. Re l \\<le> Re (f n) + e", "apply (auto simp: less_eq_complex_def less_complex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>0 < e; \\<And>n. Re (f n) \\<le> Re (f (Suc n));\n        \\<And>n. Im (f n) = Im l \\<and> Re (f n) \\<le> Re l;\n        \\<And>e.\n           Im e = 0 \\<and> 0 < Re e \\<Longrightarrow>\n           \\<exists>n. Re l \\<le> Re (f n) + Re e\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. Re l \\<le> Re (f n) + e", "by (metis Im_complex_of_real Re_complex_of_real)"], ["proof (state)\nthis:\n  (\\<lambda>n. Re (f n)) \\<longlonglongrightarrow> Re l\n\ngoal (1 subgoal):\n 1. f \\<longlonglongrightarrow> l", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>n. Re (f n)) \\<longlonglongrightarrow> Re l\n\ngoal (1 subgoal):\n 1. f \\<longlonglongrightarrow> l", "have \\<open>Im (f n) = Im l\\<close> for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (f n) = Im l", "using bdd"], ["proof (prove)\nusing this:\n  f ?n \\<le> l\n\ngoal (1 subgoal):\n 1. Im (f n) = Im l", "by (auto simp: less_eq_complex_def)"], ["proof (state)\nthis:\n  Im (f ?n) = Im l\n\ngoal (1 subgoal):\n 1. f \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  Im (f ?n) = Im l", "have \\<open>(\\<lambda>n. Im (f n)) \\<longlonglongrightarrow> Im l\\<close>"], ["proof (prove)\nusing this:\n  Im (f ?n) = Im l\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. Im (f n)) \\<longlonglongrightarrow> Im l", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. Im (f n)) \\<longlonglongrightarrow> Im l\n\ngoal (1 subgoal):\n 1. f \\<longlonglongrightarrow> l", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>n. Re (f n)) \\<longlonglongrightarrow> Re l\n  (\\<lambda>n. Im (f n)) \\<longlonglongrightarrow> Im l", "show \\<open>f \\<longlonglongrightarrow> l\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. Re (f n)) \\<longlonglongrightarrow> Re l\n  (\\<lambda>n. Im (f n)) \\<longlonglongrightarrow> Im l\n\ngoal (1 subgoal):\n 1. f \\<longlonglongrightarrow> l", "by (simp add: tendsto_complex_iff)"], ["proof (state)\nthis:\n  f \\<longlonglongrightarrow> l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complex_Cauchy_convergent:\n  fixes X :: \"nat \\<Rightarrow> complex\"\n  assumes X: \"Cauchy X\"\n  shows \"convergent X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convergent X", "using assms"], ["proof (prove)\nusing this:\n  Cauchy X\n\ngoal (1 subgoal):\n 1. convergent X", "by (rule Cauchy_convergent)"], ["", "instance complex :: complete_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(complex, complete_space_class)", "by intro_classes (rule complex_Cauchy_convergent)"], ["", "class cbanach = complex_normed_vector + complete_space"], ["", "(* Not present in Real_Vector_Spaces *)"], ["", "subclass (in cbanach) banach"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.banach dist uniformity open (-) norm (+) (0::'a) uminus\n     (*\\<^sub>R) sgn", ".."], ["", "instance complex :: banach"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(complex, banach_class)", ".."], ["", "(* Don't know if this holds in the complex case *)\n(* lemma tendsto_at_topI_sequentially:\n  fixes f :: \"complex \\<Rightarrow> 'b::first_countable_topology\"\n  assumes *: \"\\<And>X. filterlim X at_top sequentially \\<Longrightarrow> (\\<lambda>n. f (X n)) \\<longlonglongrightarrow> y\"\n  shows \"(f \\<longlongrightarrow> y) at_top\" *)\n(* lemma tendsto_at_topI_sequentially_real:\n  fixes f :: \"real \\<Rightarrow> real\"\n  assumes mono: \"mono f\"\n    and limseq: \"(\\<lambda>n. f (real n)) \\<longlonglongrightarrow> y\"\n  shows \"(f \\<longlongrightarrow> y) at_top\" *)"], ["", "end"]]}