{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators/Complex_Bounded_Linear_Function.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators", "problem_names": ["lemma id_cblinfun_apply[simp]: \"id_cblinfun *\\<^sub>V \\<psi> = \\<psi>\"", "lemma isCont_cblinfun_apply[simp]: \"isCont ((*\\<^sub>V) A) \\<psi>\"", "lemma cblinfun_apply_clinear[simp]: \\<open>clinear (cblinfun_apply A)\\<close>", "lemma cblinfun_cinner_eqI:\n  fixes A B :: \\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\\<close>\n  assumes \\<open>\\<And>\\<psi>. cinner \\<psi> (A *\\<^sub>V \\<psi>) = cinner \\<psi> (B *\\<^sub>V \\<psi>)\\<close>\n  shows \\<open>A = B\\<close>", "lemma id_cblinfun_not_0[simp]: \\<open>(id_cblinfun :: 'a::{complex_normed_vector, not_singleton} \\<Rightarrow>\\<^sub>C\\<^sub>L _) \\<noteq> 0\\<close>", "lemma cblinfun_norm_geqI:\n  assumes \\<open>norm (f *\\<^sub>V x) / norm x \\<ge> K\\<close>\n  shows \\<open>norm f \\<ge> K\\<close>", "lemma cblinfun_eq_0_on_span:\n  fixes S::\\<open>'a::complex_normed_vector set\\<close>\n  assumes \"x \\<in> cspan S\"\n    and \"\\<And>s. s\\<in>S \\<Longrightarrow> F *\\<^sub>V s = 0\"\n  shows \\<open>F *\\<^sub>V x = 0\\<close>", "lemma cblinfun_eq_on_span:\n  fixes S::\\<open>'a::complex_normed_vector set\\<close>\n  assumes \"x \\<in> cspan S\"\n    and \"\\<And>s. s\\<in>S \\<Longrightarrow> F *\\<^sub>V s = G *\\<^sub>V s\"\n  shows \\<open>F *\\<^sub>V x = G *\\<^sub>V x\\<close>", "lemma cblinfun_eq_0_on_UNIV_span:\n  fixes basis::\\<open>'a::complex_normed_vector set\\<close>\n  assumes \"cspan basis = UNIV\"\n    and \"\\<And>s. s\\<in>basis \\<Longrightarrow> F *\\<^sub>V s = 0\"\n  shows \\<open>F = 0\\<close>", "lemma cblinfun_eq_on_UNIV_span:\n  fixes basis::\"'a::complex_normed_vector set\" and \\<phi>::\"'a \\<Rightarrow> 'b::complex_normed_vector\"\n  assumes \"cspan basis = UNIV\"\n    and \"\\<And>s. s\\<in>basis \\<Longrightarrow> F *\\<^sub>V s = G *\\<^sub>V s\"\n  shows \\<open>F = G\\<close>", "lemma cblinfun_eq_on_canonical_basis:\n  fixes f g::\"'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\"\n  defines \"basis == set (canonical_basis::'a list)\"\n  assumes \"\\<And>u. u \\<in> basis \\<Longrightarrow> f *\\<^sub>V u = g *\\<^sub>V u\"\n  shows  \"f = g\"", "lemma cblinfun_eq_0_on_canonical_basis:\n  fixes f ::\"'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\"\n  defines \"basis == set (canonical_basis::'a list)\"\n  assumes \"\\<And>u. u \\<in> basis \\<Longrightarrow> f *\\<^sub>V u = 0\"\n  shows  \"f = 0\"", "lemma cinner_canonical_basis_eq_0:\n  defines \"basisA == set (canonical_basis::'a::onb_enum list)\"\n    and   \"basisB == set (canonical_basis::'b::onb_enum list)\"\n  assumes \"\\<And>u v. u\\<in>basisA \\<Longrightarrow> v\\<in>basisB \\<Longrightarrow> \\<langle>v, F *\\<^sub>V u\\<rangle> = 0\"\n  shows \"F = 0\"", "lemma cinner_canonical_basis_eq:\n  defines \"basisA == set (canonical_basis::'a::onb_enum list)\"\n    and   \"basisB == set (canonical_basis::'b::onb_enum list)\"\n  assumes \"\\<And>u v. u\\<in>basisA \\<Longrightarrow> v\\<in>basisB \\<Longrightarrow> \\<langle>v, F *\\<^sub>V u\\<rangle> = \\<langle>v, G *\\<^sub>V u\\<rangle>\"\n  shows \"F = G\"", "lemma cinner_canonical_basis_eq':\n  defines \"basisA == set (canonical_basis::'a::onb_enum list)\"\n    and   \"basisB == set (canonical_basis::'b::onb_enum list)\"\n  assumes \"\\<And>u v. u\\<in>basisA \\<Longrightarrow> v\\<in>basisB \\<Longrightarrow> \\<langle>F *\\<^sub>V u, v\\<rangle> = \\<langle>G *\\<^sub>V u, v\\<rangle>\"\n  shows \"F = G\"", "lemma cblinfun_norm_approx_witness:\n  fixes A :: \\<open>'a::{not_singleton,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\\<close>\n  assumes \\<open>\\<epsilon> > 0\\<close>\n  shows \\<open>\\<exists>\\<psi>. norm (A *\\<^sub>V \\<psi>) \\<ge> norm A - \\<epsilon> \\<and> norm \\<psi> = 1\\<close>", "lemma cblinfun_norm_approx_witness_mult:\n  fixes A :: \\<open>'a::{not_singleton,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\\<close>\n  assumes \\<open>\\<epsilon> < 1\\<close>\n  shows \\<open>\\<exists>\\<psi>. norm (A *\\<^sub>V \\<psi>) \\<ge> norm A * \\<epsilon> \\<and> norm \\<psi> = 1\\<close>", "lemma cblinfun_to_CARD_1_0[simp]: \\<open>(A :: _ \\<Rightarrow>\\<^sub>C\\<^sub>L _::CARD_1) = 0\\<close>", "lemma cblinfun_from_CARD_1_0[simp]: \\<open>(A :: _::CARD_1 \\<Rightarrow>\\<^sub>C\\<^sub>L _) = 0\\<close>", "lemma cblinfun_cspan_UNIV:\n  fixes basis :: \\<open>('a::{complex_normed_vector,cfinite_dim} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector) set\\<close>\n    and basisA :: \\<open>'a set\\<close> and basisB :: \\<open>'b set\\<close>\n  assumes \\<open>cspan basisA = UNIV\\<close> and \\<open>cspan basisB = UNIV\\<close>\n  assumes basis: \\<open>\\<And>a b. a\\<in>basisA \\<Longrightarrow> b\\<in>basisB \\<Longrightarrow> \\<exists>F\\<in>basis. \\<forall>a'\\<in>basisA. F *\\<^sub>V a' = (if a'=a then b else 0)\\<close>\n  shows \\<open>cspan basis = UNIV\\<close>", "lemma clinear_blinfun_compose_left: \\<open>clinear (\\<lambda>x. blinfun_compose x y)\\<close>", "lemma blinfun_compose_assoc: \"(A o\\<^sub>L B) o\\<^sub>L C = A o\\<^sub>L (B  o\\<^sub>L C)\"", "lemma blinfun_cblinfun_eq_bi_unique[transfer_rule]: \\<open>bi_unique blinfun_cblinfun_eq\\<close>", "lemma blinfun_cblinfun_eq_right_total[transfer_rule]: \\<open>right_total blinfun_cblinfun_eq\\<close>", "lemma cblinfun_blinfun_transfer_0[cblinfun_blinfun_transfer]:\n  \"blinfun_cblinfun_eq (0::(_,_) blinfun) (0::(_,_) cblinfun)\"", "lemma cblinfun_blinfun_transfer_plus[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) (+) (+)\"", "lemma cblinfun_blinfun_transfer_minus[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) (-) (-)\"", "lemma cblinfun_blinfun_transfer_uminus[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) (uminus) (uminus)\"", "lemma bi_unique_real_complex_eq[transfer_rule]: \\<open>bi_unique real_complex_eq\\<close>", "lemma left_total_real_complex_eq[transfer_rule]: \\<open>left_total real_complex_eq\\<close>", "lemma cblinfun_blinfun_transfer_scaleC[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(real_complex_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) (scaleR) (scaleC)\"", "lemma cblinfun_blinfun_transfer_CBlinfun[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(eq_onp bounded_clinear ===> blinfun_cblinfun_eq) Blinfun CBlinfun\"", "lemma cblinfun_blinfun_transfer_norm[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> (=)) norm norm\"", "lemma cblinfun_blinfun_transfer_dist[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> (=)) dist dist\"", "lemma cblinfun_blinfun_transfer_sgn[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) sgn sgn\"", "lemma cblinfun_blinfun_transfer_Cauchy[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(((=) ===> blinfun_cblinfun_eq) ===> (=)) Cauchy Cauchy\"", "lemma cblinfun_blinfun_transfer_tendsto[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(((=) ===> blinfun_cblinfun_eq) ===> blinfun_cblinfun_eq ===> (=) ===> (=)) tendsto tendsto\"", "lemma cblinfun_blinfun_transfer_compose[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) (o\\<^sub>L) (o\\<^sub>C\\<^sub>L)\"", "lemma cblinfun_blinfun_transfer_apply[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> (=) ===> (=)) blinfun_apply cblinfun_apply\"", "lemma blinfun_of_cblinfun_inj:\n  \\<open>blinfun_of_cblinfun f = blinfun_of_cblinfun g \\<Longrightarrow> f = g\\<close>", "lemma blinfun_of_cblinfun_inv:\n  assumes \"\\<And>c. \\<And>x. f *\\<^sub>v (c *\\<^sub>C x) = c *\\<^sub>C (f *\\<^sub>v x)\"\n  shows \"\\<exists>g. blinfun_of_cblinfun g = f\"", "lemma blinfun_of_cblinfun_zero:\n  \\<open>blinfun_of_cblinfun 0 = 0\\<close>", "lemma blinfun_of_cblinfun_uminus:\n  \\<open>blinfun_of_cblinfun (- f) = - (blinfun_of_cblinfun f)\\<close>", "lemma blinfun_of_cblinfun_minus:\n  \\<open>blinfun_of_cblinfun (f - g) = blinfun_of_cblinfun f - blinfun_of_cblinfun g\\<close>", "lemma blinfun_of_cblinfun_scaleC:\n  \\<open>blinfun_of_cblinfun (c *\\<^sub>C f) = c *\\<^sub>C (blinfun_of_cblinfun f)\\<close>", "lemma blinfun_of_cblinfun_scaleR:\n  \\<open>blinfun_of_cblinfun (c *\\<^sub>R f) = c *\\<^sub>R (blinfun_of_cblinfun f)\\<close>", "lemma blinfun_of_cblinfun_norm:\n  fixes f::\\<open>'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\\<close>\n  shows \\<open>norm f = norm (blinfun_of_cblinfun f)\\<close>", "lemma blinfun_of_cblinfun_cblinfun_compose:\n  fixes f::\\<open>'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_normed_vector\\<close>\n    and g::\\<open>'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\\<close>\n  shows \\<open>blinfun_of_cblinfun (f  o\\<^sub>C\\<^sub>L g) = (blinfun_of_cblinfun f) o\\<^sub>L (blinfun_of_cblinfun g)\\<close>", "lemma cblinfun_compose_assoc: \n  shows \"(A o\\<^sub>C\\<^sub>L B) o\\<^sub>C\\<^sub>L C = A o\\<^sub>C\\<^sub>L (B o\\<^sub>C\\<^sub>L C)\"", "lemma cblinfun_compose_zero_right[simp]: \"U o\\<^sub>C\\<^sub>L 0 = 0\"", "lemma cblinfun_compose_zero_left[simp]: \"0 o\\<^sub>C\\<^sub>L U = 0\"", "lemma cblinfun_compose_scaleC_left[simp]:\n  fixes A::\"'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_normed_vector\"\n    and B::\"'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  shows \\<open>(a *\\<^sub>C A) o\\<^sub>C\\<^sub>L B = a *\\<^sub>C (A o\\<^sub>C\\<^sub>L B)\\<close>", "lemma cblinfun_compose_scaleR_left[simp]:\n  fixes A::\"'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_normed_vector\"\n    and B::\"'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  shows \\<open>(a *\\<^sub>R A) o\\<^sub>C\\<^sub>L B = a *\\<^sub>R (A o\\<^sub>C\\<^sub>L B)\\<close>", "lemma cblinfun_compose_scaleC_right[simp]:\n  fixes A::\"'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_normed_vector\" \n    and B::\"'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  shows \\<open>A o\\<^sub>C\\<^sub>L (a *\\<^sub>C B) = a *\\<^sub>C (A o\\<^sub>C\\<^sub>L B)\\<close>", "lemma cblinfun_compose_scaleR_right[simp]:\n  fixes A::\"'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_normed_vector\" \n    and B::\"'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  shows \\<open>A o\\<^sub>C\\<^sub>L (a *\\<^sub>R B) = a *\\<^sub>R (A o\\<^sub>C\\<^sub>L B)\\<close>", "lemma cblinfun_compose_id_right[simp]: \n  shows \"U o\\<^sub>C\\<^sub>L id_cblinfun = U\"", "lemma cblinfun_compose_id_left[simp]: \n  shows \"id_cblinfun o\\<^sub>C\\<^sub>L U  = U\"", "lemma cblinfun_eq_on:\n  fixes A B :: \"'a::cbanach \\<Rightarrow>\\<^sub>C\\<^sub>L'b::complex_normed_vector\"\n  assumes \"\\<And>x. x \\<in> G \\<Longrightarrow> A *\\<^sub>V x = B *\\<^sub>V x\" and \\<open>t \\<in> closure (cspan G)\\<close>\n  shows \"A *\\<^sub>V t = B *\\<^sub>V t\"", "lemma cblinfun_eq_gen_eqI:\n  fixes A B :: \"'a::cbanach \\<Rightarrow>\\<^sub>C\\<^sub>L'b::complex_normed_vector\"\n  assumes \"\\<And>x. x \\<in> G \\<Longrightarrow> A *\\<^sub>V x = B *\\<^sub>V x\" and \\<open>ccspan G = \\<top>\\<close>\n  shows \"A = B\"", "lemma cblinfun_compose_add_left: \\<open>(a + b) o\\<^sub>C\\<^sub>L c = (a o\\<^sub>C\\<^sub>L c) + (b o\\<^sub>C\\<^sub>L c)\\<close>", "lemma cblinfun_compose_add_right: \\<open>a o\\<^sub>C\\<^sub>L (b + c) = (a o\\<^sub>C\\<^sub>L b) + (a o\\<^sub>C\\<^sub>L c)\\<close>", "lemma cbilinear_cblinfun_compose[simp]: \"cbilinear cblinfun_compose\"", "lemma id_cblinfun_adjoint[simp]: \"id_cblinfun* = id_cblinfun\"", "lemma double_adj[simp]: \"(A*)* = A\"", "lemma adj_cblinfun_compose[simp]:\n  fixes B::\\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::chilbert_space\\<close>\n    and A::\\<open>'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_inner\\<close> \n  shows \"(A o\\<^sub>C\\<^sub>L B)* =  (B*) o\\<^sub>C\\<^sub>L (A*)\"", "lemma scaleC_adj[simp]: \"(a *\\<^sub>C A)* = (cnj a) *\\<^sub>C (A*)\"", "lemma scaleR_adj[simp]: \"(a *\\<^sub>R A)* = a *\\<^sub>R (A*)\"", "lemma adj_plus: \\<open>(A + B)* = (A*) + (B*)\\<close>", "lemma cinner_sup_norm_cblinfun: \n  fixes A :: \\<open>'a::{complex_normed_vector,not_singleton} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_inner\\<close>\n  shows \\<open>norm A = (SUP (\\<psi>,\\<phi>). cmod (cinner \\<psi> (A *\\<^sub>V \\<phi>)) / (norm \\<psi> * norm \\<phi>))\\<close>", "lemma cinner_adj_left:\n  fixes G :: \"'b::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::complex_inner\"\n  shows \\<open>\\<langle>G* *\\<^sub>V x, y\\<rangle> = \\<langle>x, G *\\<^sub>V y\\<rangle>\\<close>", "lemma cinner_adj_right:\n  fixes G :: \"'b::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::complex_inner\"\n  shows \\<open>\\<langle>x, G* *\\<^sub>V y\\<rangle> = \\<langle>G *\\<^sub>V x, y\\<rangle>\\<close>", "lemma adj_0[simp]: \\<open>0* = 0\\<close>", "lemma norm_adj[simp]: \\<open>norm (A*) = norm A\\<close> \n  for A :: \\<open>'b::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_inner\\<close>", "lemma antilinear_adj[simp]: \\<open>antilinear adj\\<close>", "lemma bounded_antilinear_adj[bounded_antilinear, simp]: \\<open>bounded_antilinear adj\\<close>", "lemma adjoint_eqI:\n  fixes G:: \\<open>'b::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::chilbert_space\\<close>\n    and F:: \\<open>'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\\<close>\n  assumes \\<open>\\<And>x y. \\<langle>(cblinfun_apply F) x, y\\<rangle> = \\<langle>x, (cblinfun_apply G) y\\<rangle>\\<close>\n  shows \\<open>F = G*\\<close>", "lemma cinner_real_hermiteanI: \n  \\<comment> \\<open>Prop. II.2.12 in @{cite conway2013course}\\<close>\n  assumes \\<open>\\<And>\\<psi>. cinner \\<psi> (A *\\<^sub>V \\<psi>) \\<in> \\<real>\\<close>\n  shows \\<open>A = A*\\<close>", "lemma norm_AAadj[simp]: \\<open>norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2\\<close> for A :: \\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{complex_inner}\\<close>", "lemma unitary_twosided_isometry: \"unitary U \\<longleftrightarrow> isometry U \\<and> isometry (U*)\"", "lemma isometryD[simp]: \"isometry U \\<Longrightarrow> U* o\\<^sub>C\\<^sub>L U = id_cblinfun\"", "lemma unitaryD1: \"unitary U \\<Longrightarrow> U* o\\<^sub>C\\<^sub>L U = id_cblinfun\"", "lemma unitaryD2[simp]: \"unitary U \\<Longrightarrow> U o\\<^sub>C\\<^sub>L U* = id_cblinfun\"", "lemma unitary_isometry[simp]: \"unitary U \\<Longrightarrow> isometry U\"", "lemma unitary_adj[simp]: \"unitary (U*) = unitary U\"", "lemma isometry_cblinfun_compose[simp]: \n  assumes \"isometry A\" and \"isometry B\"  \n  shows \"isometry (A o\\<^sub>C\\<^sub>L B)\"", "lemma unitary_cblinfun_compose[simp]: \"unitary (A o\\<^sub>C\\<^sub>L B)\"\n  if \"unitary A\" and \"unitary B\"", "lemma unitary_surj: \n  assumes \"unitary U\"\n  shows \"surj (cblinfun_apply U)\"", "lemma unitary_id[simp]: \"unitary id_cblinfun\"", "lemma orthogonal_on_basis_is_isometry:\n  assumes spanB: \\<open>ccspan B = \\<top>\\<close>\n  assumes orthoU: \\<open>\\<And>b c. b\\<in>B \\<Longrightarrow> c\\<in>B \\<Longrightarrow> cinner (U *\\<^sub>V b) (U *\\<^sub>V c) = cinner b c\\<close>\n  shows \\<open>isometry U\\<close>", "lemma cblinfun_image_mono:\n  assumes a1: \"S \\<le> T\"\n  shows \"A *\\<^sub>S S \\<le> A *\\<^sub>S T\"", "lemma cblinfun_image_0[simp]:  \n  shows \"U *\\<^sub>S 0 = 0\"", "lemma cblinfun_image_bot[simp]: \"U *\\<^sub>S bot = bot\"", "lemma cblinfun_image_sup[simp]:   \n  fixes A B :: \\<open>'a::chilbert_space ccsubspace\\<close> and U :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L'b::chilbert_space\"\n  shows \\<open>U *\\<^sub>S (sup A B) = sup (U *\\<^sub>S A) (U *\\<^sub>S B)\\<close>", "lemma scaleC_cblinfun_image[simp]:\n  fixes A :: \\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b :: chilbert_space\\<close>\n    and S :: \\<open>'a ccsubspace\\<close> and \\<alpha> :: complex\n  shows \\<open>(\\<alpha> *\\<^sub>C A) *\\<^sub>S S  = \\<alpha> *\\<^sub>C (A *\\<^sub>S S)\\<close>", "lemma cblinfun_image_id[simp]: \n  \"id_cblinfun *\\<^sub>S \\<psi> = \\<psi>\"", "lemma cblinfun_compose_image: \n  \\<open>(A o\\<^sub>C\\<^sub>L B) *\\<^sub>S S =  A *\\<^sub>S (B *\\<^sub>S S)\\<close>", "lemmas cblinfun_assoc_left = cblinfun_compose_assoc[symmetric] cblinfun_compose_image[symmetric] \n  add.assoc[where ?'a=\"'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::chilbert_space\", symmetric]", "lemmas cblinfun_assoc_right = cblinfun_compose_assoc cblinfun_compose_image\n  add.assoc[where ?'a=\"'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::chilbert_space\"]", "lemma cblinfun_image_INF_leq[simp]:\n  fixes U :: \"'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::cbanach\"\n    and V :: \"'a \\<Rightarrow> 'b ccsubspace\" \n  shows \\<open>U *\\<^sub>S (INF i. V i) \\<le> (INF i. U *\\<^sub>S (V i))\\<close>", "lemma isometry_cblinfun_image_inf_distrib':\n  fixes U::\\<open>'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::cbanach\\<close> and B C::\"'a ccsubspace\"\n  shows \"U *\\<^sub>S (inf B C) \\<le> inf (U *\\<^sub>S B) (U *\\<^sub>S C)\"", "lemma cblinfun_image_eq:\n  fixes S :: \"'a::cbanach ccsubspace\" \n    and A B :: \"'a::cbanach \\<Rightarrow>\\<^sub>C\\<^sub>L'b::cbanach\"\n  assumes \"\\<And>x. x \\<in> G \\<Longrightarrow> A *\\<^sub>V x = B *\\<^sub>V x\" and \"ccspan G \\<ge> S\"\n  shows \"A *\\<^sub>S S = B *\\<^sub>S S\"", "lemma cblinfun_fixes_range:\n  assumes \"A o\\<^sub>C\\<^sub>L B = B\" and \"\\<psi> \\<in> space_as_set (B *\\<^sub>S top)\"\n  shows \"A *\\<^sub>V \\<psi> = \\<psi>\"", "lemma zero_cblinfun_image[simp]: \"0 *\\<^sub>S S = (0::_ ccsubspace)\"", "lemma cblinfun_image_INF_eq_general:\n  fixes V :: \"'a \\<Rightarrow> 'b::chilbert_space ccsubspace\"\n    and U :: \"'b \\<Rightarrow>\\<^sub>C\\<^sub>L'c::chilbert_space\"\n    and Uinv :: \"'c \\<Rightarrow>\\<^sub>C\\<^sub>L'b\" \n  assumes UinvUUinv: \"Uinv o\\<^sub>C\\<^sub>L U o\\<^sub>C\\<^sub>L Uinv = Uinv\" and UUinvU: \"U o\\<^sub>C\\<^sub>L Uinv o\\<^sub>C\\<^sub>L U = U\"\n    \\<comment> \\<open>Meaning: \\<^term>\\<open>Uinv\\<close> is a Pseudoinverse of \\<^term>\\<open>U\\<close>\\<close>\n    and V: \"\\<And>i. V i \\<le> Uinv *\\<^sub>S top\"\n  shows \"U *\\<^sub>S (INF i. V i) = (INF i. U *\\<^sub>S V i)\"", "lemma unitary_range[simp]: \n  assumes \"unitary U\"\n  shows \"U *\\<^sub>S top = top\"", "lemma range_adjoint_isometry:\n  assumes \"isometry U\"\n  shows \"U* *\\<^sub>S top = top\"", "lemma cblinfun_image_INF_eq[simp]: \n  fixes V :: \"'a \\<Rightarrow> 'b::chilbert_space ccsubspace\" \n    and U :: \"'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::chilbert_space\"\n  assumes \\<open>isometry U\\<close>\n  shows \"U *\\<^sub>S (INF i. V i) = (INF i. U *\\<^sub>S V i)\"", "lemma isometry_cblinfun_image_inf_distrib[simp]:\n  fixes U::\\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::chilbert_space\\<close>\n    and X Y::\"'a ccsubspace\"\n  assumes \"isometry U\"\n  shows \"U *\\<^sub>S (inf X Y) = inf (U *\\<^sub>S X) (U *\\<^sub>S Y)\"", "lemma cblinfun_image_ccspan: \n  shows \"A *\\<^sub>S ccspan G = ccspan ((*\\<^sub>V) A ` G)\"", "lemma cblinfun_apply_in_image[simp]: \"A *\\<^sub>V \\<psi> \\<in> space_as_set (A *\\<^sub>S \\<top>)\"", "lemma cblinfun_plus_image_distr:\n  \\<open>(A + B) *\\<^sub>S S \\<le> A *\\<^sub>S S \\<squnion> B *\\<^sub>S S\\<close>", "lemma cblinfun_sum_image_distr:\n  \\<open>(\\<Sum>i\\<in>I. A i) *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)\\<close>", "lemma sandwich_0[simp]: \\<open>sandwich 0 = 0\\<close>", "lemma sandwich_apply: \\<open>sandwich A *\\<^sub>V B = A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*\\<close>", "lemma norm_sandwich: \\<open>norm (sandwich A) = (norm A)\\<^sup>2\\<close> for A :: \\<open>'a::{chilbert_space} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{complex_inner}\\<close>", "lemma sandwich_apply_adj: \\<open>sandwich A (B*) = (sandwich A B)*\\<close>", "lemma sandwich_id[simp]: \"sandwich id_cblinfun = id_cblinfun\"", "lemma Proj_range[simp]: \"Proj S *\\<^sub>S top = S\"", "lemma adj_Proj: \\<open>(Proj M)* = Proj M\\<close>", "lemma Proj_idempotent[simp]: \\<open>Proj M o\\<^sub>C\\<^sub>L Proj M = Proj M\\<close>", "lemma Proj_on_own_range':\n  fixes P :: \\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L'a\\<close>\n  assumes \\<open>P o\\<^sub>C\\<^sub>L P = P\\<close> and \\<open>P = P*\\<close>\n  shows \\<open>Proj (P *\\<^sub>S top) = P\\<close>", "lemma Proj_range_closed:\n  assumes \"is_Proj P\"\n  shows \"closed (range (cblinfun_apply P))\"", "lemma Proj_is_Proj[simp]:\n  fixes M::\\<open>'a::chilbert_space ccsubspace\\<close>\n  shows \\<open>is_Proj (Proj M)\\<close>", "lemma is_Proj_algebraic: \n  fixes P::\\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\\<close>\n  shows \\<open>is_Proj P \\<longleftrightarrow> P o\\<^sub>C\\<^sub>L P = P \\<and> P = P*\\<close>", "lemma Proj_on_own_range:\n  fixes P :: \\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L'a\\<close>\n  assumes \\<open>is_Proj P\\<close>\n  shows \\<open>Proj (P *\\<^sub>S top) = P\\<close>", "lemma Proj_image_leq: \"(Proj S) *\\<^sub>S A \\<le> S\"", "lemma Proj_sandwich:\n  fixes A::\"'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::chilbert_space\"\n  assumes \"isometry A\"\n  shows \"sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)\"", "lemma Proj_orthog_ccspan_union:\n  assumes \"\\<And>x y. x \\<in> X \\<Longrightarrow> y \\<in> Y \\<Longrightarrow> is_orthogonal x y\"\n  shows \\<open>Proj (ccspan (X \\<union> Y)) = Proj (ccspan X) + Proj (ccspan Y)\\<close>", "lemma proj_0[simp]: \\<open>proj 0 = 0\\<close>", "lemma surj_isometry_is_unitary:\n  fixes U :: \\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::chilbert_space\\<close>\n  assumes \\<open>isometry U\\<close>\n  assumes \\<open>U *\\<^sub>S \\<top> = \\<top>\\<close>\n  shows \\<open>unitary U\\<close>", "lemma ccsubspace_supI_via_Proj:\n  fixes A B C::\"'a::chilbert_space ccsubspace\"\n  assumes a1: \\<open>Proj (- C) *\\<^sub>S A \\<le> B\\<close>\n  shows  \"A \\<le> sup B C\"", "lemma is_Proj_idempotent:\n  assumes \"is_Proj P\"\n  shows \"P o\\<^sub>C\\<^sub>L P = P\"", "lemma is_proj_selfadj:\n  assumes \"is_Proj P\"\n  shows \"P* = P\"", "lemma is_Proj_I: \n  assumes \"P o\\<^sub>C\\<^sub>L P = P\" and \"P* = P\"\n  shows \"is_Proj P\"", "lemma is_Proj_0[simp]: \"is_Proj 0\"", "lemma is_Proj_complement[simp]: \n  assumes a1: \"is_Proj P\"\n  shows \"is_Proj (id_cblinfun-P)\"", "lemma Proj_bot[simp]: \"Proj bot = 0\"", "lemma Proj_ortho_compl:\n  \"Proj (- X) = id_cblinfun - Proj X\"", "lemma Proj_inj: \n  assumes \"Proj X = Proj Y\"\n  shows \"X = Y\"", "lemma kernel_scaleC[simp]: \"a\\<noteq>0 \\<Longrightarrow> kernel (a *\\<^sub>C A) = kernel A\"\n  for a :: complex and A :: \"(_,_) cblinfun\"", "lemma kernel_0[simp]: \"kernel 0 = top\"", "lemma kernel_id[simp]: \"kernel id_cblinfun = 0\"", "lemma eigenspace_scaleC[simp]: \n  assumes a1: \"a \\<noteq> 0\"\n  shows \"eigenspace b (a *\\<^sub>C A) = eigenspace (b/a) A\"", "lemma eigenspace_memberD:\n  assumes \"x \\<in> space_as_set (eigenspace e A)\"\n  shows \"A *\\<^sub>V x = e *\\<^sub>C x\"", "lemma kernel_memberD:\n  assumes \"x \\<in> space_as_set (kernel A)\"\n  shows \"A *\\<^sub>V x = 0\"", "lemma eigenspace_memberI:\n  assumes \"A *\\<^sub>V x = e *\\<^sub>C x\"\n  shows \"x \\<in> space_as_set (eigenspace e A)\"", "lemma kernel_memberI:\n  assumes \"A *\\<^sub>V x = 0\"\n  shows \"x \\<in> space_as_set (kernel A)\"", "lemma \n  assumes \\<open>iso_cblinfun A\\<close>\n  shows cblinfun_inv_left: \\<open>cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun\\<close>\n    and cblinfun_inv_right: \\<open>A o\\<^sub>C\\<^sub>L cblinfun_inv A = id_cblinfun\\<close>", "lemma cblinfun_inv_uniq:\n  assumes \"A o\\<^sub>C\\<^sub>L B = id_cblinfun\" and \"B o\\<^sub>C\\<^sub>L A = id_cblinfun\"\n  shows \"cblinfun_inv A = B\"", "lemma id_cblinfun_eq_1[simp]: \\<open>id_cblinfun = 1\\<close>", "lemma one_dim_apply_is_times[simp]: \n  fixes A :: \"'a::one_dim \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\" and B :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\"\n  shows \"A o\\<^sub>C\\<^sub>L B = A * B\"", "lemma one_comp_one_cblinfun[simp]: \"1 o\\<^sub>C\\<^sub>L 1 = 1\"", "lemma one_cblinfun_adj[simp]: \"1* = 1\"", "lemma scaleC_1_right[simp]: \\<open>scaleC x (1::'a::one_dim) = of_complex x\\<close>", "lemma scaleC_of_complex[simp]: \\<open>scaleC x (of_complex y) = of_complex (x * y)\\<close>", "lemma scaleC_1_apply[simp]: \\<open>(x *\\<^sub>C 1) *\\<^sub>V y = x *\\<^sub>C y\\<close>", "lemma cblinfun_apply_1_left[simp]: \\<open>1 *\\<^sub>V y = y\\<close>", "lemma of_complex_cblinfun_apply[simp]: \\<open>of_complex x *\\<^sub>V y = x *\\<^sub>C y\\<close>", "lemma cblinfun_compose_1_left[simp]: \\<open>1 o\\<^sub>C\\<^sub>L x = x\\<close>", "lemma cblinfun_compose_1_right[simp]: \\<open>x o\\<^sub>C\\<^sub>L 1 = x\\<close>", "lemma one_dim_iso_id_cblinfun: \\<open>one_dim_iso id_cblinfun = id_cblinfun\\<close>", "lemma one_dim_iso_id_cblinfun_eq_1: \\<open>one_dim_iso id_cblinfun = 1\\<close>", "lemma one_dim_iso_comp_distr[simp]: \\<open>one_dim_iso (a o\\<^sub>C\\<^sub>L b) = one_dim_iso a o\\<^sub>C\\<^sub>L one_dim_iso b\\<close>", "lemma one_dim_iso_comp_distr_times[simp]: \\<open>one_dim_iso (a o\\<^sub>C\\<^sub>L b) = one_dim_iso a * one_dim_iso b\\<close>", "lemma one_dim_iso_adjoint[simp]: \\<open>one_dim_iso (A*) = (one_dim_iso A)*\\<close>", "lemma one_dim_iso_adjoint_complex[simp]: \\<open>one_dim_iso (A*) = cnj (one_dim_iso A)\\<close>", "lemma one_dim_cblinfun_compose_commute: \\<open>a o\\<^sub>C\\<^sub>L b = b o\\<^sub>C\\<^sub>L a\\<close> for a b :: \\<open>('a::one_dim,'a) cblinfun\\<close>", "lemma one_cblinfun_apply_one[simp]: \\<open>1 *\\<^sub>V 1 = 1\\<close>", "lemma heterogenous_cblinfun_id_def'[simp]: \"heterogenous_cblinfun_id = id_cblinfun\"", "lemma heterogenous_same_type_cblinfun[simp]: \\<open>heterogenous_same_type_cblinfun (x::'a::chilbert_space itself) (y::'a::chilbert_space itself)\\<close>", "lemma less_eq_cblinfun_def: \\<open>A \\<le> B \\<longleftrightarrow>\n    (\\<forall>\\<psi>. cinner \\<psi> (A *\\<^sub>V \\<psi>) \\<le> cinner \\<psi> (B *\\<^sub>V \\<psi>))\\<close>", "lemma positive_id_cblinfun[simp]: \"id_cblinfun \\<ge> 0\"", "lemma positive_hermitianI: \\<open>A = A*\\<close> if \\<open>A \\<ge> 0\\<close>", "lemma positive_cblinfunI: \\<open>A \\<ge> 0\\<close> if \\<open>\\<And>x. cinner x (A *\\<^sub>V x) \\<ge> 0\\<close>", "lemma positive_cblinfun_squareI: \\<open>A = B* o\\<^sub>C\\<^sub>L B \\<Longrightarrow> A \\<ge> 0\\<close>", "lemma one_dim_loewner_order: \\<open>A \\<ge> B \\<longleftrightarrow> one_dim_iso A \\<ge> (one_dim_iso B :: complex)\\<close> for A B :: \\<open>'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::{chilbert_space, one_dim}\\<close>", "lemma one_dim_positive: \\<open>A \\<ge> 0 \\<longleftrightarrow> one_dim_iso A \\<ge> (0::complex)\\<close> for A :: \\<open>'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::{chilbert_space, one_dim}\\<close>", "lemma vector_to_cblinfun_cblinfun_apply: \n  \"vector_to_cblinfun (A *\\<^sub>V \\<psi>) = A  o\\<^sub>C\\<^sub>L (vector_to_cblinfun \\<psi>)\"", "lemma vector_to_cblinfun_add: \\<open>vector_to_cblinfun (x + y) = vector_to_cblinfun x + vector_to_cblinfun y\\<close>", "lemma norm_vector_to_cblinfun[simp]: \"norm (vector_to_cblinfun x) = norm x\"", "lemma bounded_clinear_vector_to_cblinfun[bounded_clinear]: \"bounded_clinear vector_to_cblinfun\"", "lemma vector_to_cblinfun_scaleC[simp]:\n  \"vector_to_cblinfun (a *\\<^sub>C \\<psi>) = a *\\<^sub>C vector_to_cblinfun \\<psi>\" for a::complex", "lemma vector_to_cblinfun_apply_one_dim[simp]:\n  shows \"vector_to_cblinfun \\<phi> *\\<^sub>V \\<gamma> = one_dim_iso \\<gamma> *\\<^sub>C \\<phi>\"", "lemma vector_to_cblinfun_adj_apply[simp]:\n  shows \"vector_to_cblinfun \\<psi>* *\\<^sub>V \\<phi> = of_complex (cinner \\<psi> \\<phi>)\"", "lemma vector_to_cblinfun_comp_one[simp]: \n  \"(vector_to_cblinfun s :: 'a::one_dim \\<Rightarrow>\\<^sub>C\\<^sub>L _) o\\<^sub>C\\<^sub>L 1 \n     = (vector_to_cblinfun s :: 'b::one_dim \\<Rightarrow>\\<^sub>C\\<^sub>L _)\"", "lemma vector_to_cblinfun_0[simp]: \"vector_to_cblinfun 0 = 0\"", "lemma image_vector_to_cblinfun[simp]: \"vector_to_cblinfun x *\\<^sub>S top = ccspan {x}\"", "lemma vector_to_cblinfun_adj_comp_vector_to_cblinfun[simp]:\n  shows \"vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi> = cinner \\<psi> \\<phi> *\\<^sub>C id_cblinfun\"", "lemma isometry_vector_to_cblinfun[simp]:\n  assumes \"norm x = 1\"\n  shows \"isometry (vector_to_cblinfun x)\"", "lemma butterfly_add_left: \\<open>butterfly (a + a') b = butterfly a b + butterfly a' b\\<close>", "lemma butterfly_add_right: \\<open>butterfly a (b + b') = butterfly a b + butterfly a b'\\<close>", "lemma butterfly_def_one_dim: \"butterfly s t = (vector_to_cblinfun s :: 'c::one_dim \\<Rightarrow>\\<^sub>C\\<^sub>L _)\n                                          o\\<^sub>C\\<^sub>L (vector_to_cblinfun t :: 'c \\<Rightarrow>\\<^sub>C\\<^sub>L _)*\"\n  (is \"_ = ?rhs\") for s :: \"'a::complex_normed_vector\" and t :: \"'b::chilbert_space\"", "lemma butterfly_comp_cblinfun: \"butterfly \\<psi> \\<phi> o\\<^sub>C\\<^sub>L a = butterfly \\<psi> (a* *\\<^sub>V \\<phi>)\"", "lemma cblinfun_comp_butterfly: \"a o\\<^sub>C\\<^sub>L butterfly \\<psi> \\<phi> = butterfly (a *\\<^sub>V \\<psi>) \\<phi>\"", "lemma butterfly_apply[simp]: \"butterfly \\<psi> \\<psi>' *\\<^sub>V \\<phi> = \\<langle>\\<psi>', \\<phi>\\<rangle> *\\<^sub>C \\<psi>\"", "lemma butterfly_scaleC_left[simp]: \"butterfly (c *\\<^sub>C \\<psi>) \\<phi> = c *\\<^sub>C butterfly \\<psi> \\<phi>\"", "lemma butterfly_scaleC_right[simp]: \"butterfly \\<psi> (c *\\<^sub>C \\<phi>) = cnj c *\\<^sub>C butterfly \\<psi> \\<phi>\"", "lemma butterfly_scaleR_left[simp]: \"butterfly (r *\\<^sub>R \\<psi>) \\<phi> = r *\\<^sub>C butterfly \\<psi> \\<phi>\"", "lemma butterfly_scaleR_right[simp]: \"butterfly \\<psi> (r *\\<^sub>R \\<phi>) = r *\\<^sub>C butterfly \\<psi> \\<phi>\"", "lemma butterfly_adjoint[simp]: \"(butterfly \\<psi> \\<phi>)* = butterfly \\<phi> \\<psi>\"", "lemma butterfly_comp_butterfly[simp]: \"butterfly \\<psi>1 \\<psi>2 o\\<^sub>C\\<^sub>L butterfly \\<psi>3 \\<psi>4 = \\<langle>\\<psi>2, \\<psi>3\\<rangle> *\\<^sub>C butterfly \\<psi>1 \\<psi>4\"", "lemma butterfly_0_left[simp]: \"butterfly 0 a = 0\"", "lemma butterfly_0_right[simp]: \"butterfly a 0 = 0\"", "lemma norm_butterfly: \"norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>\"", "lemma bounded_sesquilinear_butterfly[bounded_sesquilinear]: \\<open>bounded_sesquilinear (\\<lambda>(b::'b::chilbert_space) (a::'a::chilbert_space). butterfly a b)\\<close>", "lemma inj_selfbutter_upto_phase: \n  assumes \"selfbutter x = selfbutter y\"\n  shows \"\\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y\"", "lemma butterfly_eq_proj:\n  assumes \"norm x = 1\"\n  shows \"selfbutter x = proj x\"", "lemma butterfly_is_Proj:\n  \\<open>norm x = 1 \\<Longrightarrow> is_Proj (selfbutter x)\\<close>", "lemma cspan_butterfly_UNIV:\n  assumes \\<open>cspan basisA = UNIV\\<close>\n  assumes \\<open>cspan basisB = UNIV\\<close>\n  assumes \\<open>is_ortho_set basisB\\<close>\n  assumes \\<open>\\<And>b. b \\<in> basisB \\<Longrightarrow> norm b = 1\\<close>\n  shows \\<open>cspan {butterfly a b| (a::'a::{complex_normed_vector}) (b::'b::{chilbert_space,cfinite_dim}). a \\<in> basisA \\<and> b \\<in> basisB} = UNIV\\<close>", "lemma cindependent_butterfly: \n  fixes basisA :: \\<open>'a::chilbert_space set\\<close> and basisB :: \\<open>'b::chilbert_space set\\<close>\n  assumes \\<open>is_ortho_set basisA\\<close> \\<open>is_ortho_set basisB\\<close>\n  assumes normA: \\<open>\\<And>a. a\\<in>basisA \\<Longrightarrow> norm a = 1\\<close> and normB: \\<open>\\<And>b. b\\<in>basisB \\<Longrightarrow> norm b = 1\\<close>\n  shows \\<open>cindependent {butterfly a b| a b. a\\<in>basisA \\<and> b\\<in>basisB}\\<close>", "lemma clinear_eq_butterflyI:\n  fixes F G :: \\<open>('a::{chilbert_space,cfinite_dim} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_inner) \\<Rightarrow> 'c::complex_vector\\<close>\n  assumes \"clinear F\" and \"clinear G\"\n  assumes \\<open>cspan basisA = UNIV\\<close> \\<open>cspan basisB = UNIV\\<close>\n  assumes \\<open>is_ortho_set basisA\\<close> \\<open>is_ortho_set basisB\\<close>\n  assumes \"\\<And>a b. a\\<in>basisA \\<Longrightarrow> b\\<in>basisB \\<Longrightarrow> F (butterfly a b) = G (butterfly a b)\"\n  assumes \\<open>\\<And>b. b\\<in>basisB \\<Longrightarrow> norm b = 1\\<close>\n  shows \"F = G\"", "lemma bifunctional_apply[simp]: \\<open>(bifunctional *\\<^sub>V x) *\\<^sub>V f = f *\\<^sub>V x\\<close>", "lemma bifunctional_isometric[simp]: \\<open>norm (bifunctional *\\<^sub>V x) = norm x\\<close> for x :: \\<open>'a::complex_inner\\<close>", "lemma norm_bifunctional[simp]: \\<open>norm (bifunctional :: 'a::{complex_inner, not_singleton} \\<Rightarrow>\\<^sub>C\\<^sub>L _) = 1\\<close>", "theorem cbanach_steinhaus:\n  fixes F :: \\<open>'c \\<Rightarrow> 'a::cbanach \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\\<close>\n  assumes \\<open>\\<And>x. \\<exists>M. \\<forall>n.  norm ((F n) *\\<^sub>V x) \\<le> M\\<close>\n  shows  \\<open>\\<exists>M. \\<forall> n. norm (F n) \\<le> M\\<close>", "theorem riesz_frechet_representation_cblinfun_existence:\n  \\<comment> \\<open>Theorem 3.4 in @{cite conway2013course}\\<close>\n  fixes f::\\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L complex\\<close>\n  shows \\<open>\\<exists>t. \\<forall>x.  f *\\<^sub>V x = \\<langle>t, x\\<rangle>\\<close>", "lemma riesz_frechet_representation_cblinfun_unique:\n  \\<comment> \\<open>Theorem 3.4 in @{cite conway2013course}\\<close>\n  fixes f::\\<open>'a::complex_inner \\<Rightarrow>\\<^sub>C\\<^sub>L complex\\<close>\n  assumes \\<open>\\<And>x. f *\\<^sub>V x = \\<langle>t, x\\<rangle>\\<close>\n  assumes \\<open>\\<And>x. f *\\<^sub>V x = \\<langle>u, x\\<rangle>\\<close>\n  shows \\<open>t = u\\<close>", "theorem riesz_frechet_representation_cblinfun_norm:\n  includes notation_norm\n  fixes f::\\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L complex\\<close>\n  assumes \\<open>\\<And>x.  f *\\<^sub>V x = \\<langle>t, x\\<rangle>\\<close>\n  shows \\<open>\\<parallel>f\\<parallel> = \\<parallel>t\\<parallel>\\<close>", "lemma cblinfun_extension_existsI:\n  assumes \"\\<And>x. x\\<in>S \\<Longrightarrow> B *\\<^sub>V x = \\<phi> x\"\n  shows \"cblinfun_extension_exists S \\<phi>\"", "lemma cblinfun_extension_exists_finite_dim:\n  fixes \\<phi>::\"'a::{complex_normed_vector,cfinite_dim} \\<Rightarrow> 'b::complex_normed_vector\" \n  assumes \"cindependent S\"\n    and \"cspan S = UNIV\"\n  shows \"cblinfun_extension_exists S \\<phi>\"", "lemma cblinfun_extension_exists_bounded_dense:\n  fixes f :: \\<open>'a::complex_normed_vector \\<Rightarrow> 'b::cbanach\\<close>\n  assumes \\<open>csubspace S\\<close>\n  assumes \\<open>closure S = UNIV\\<close>\n  assumes f_add: \\<open>\\<And>x y. x \\<in> S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> f (x + y) = f x + f y\\<close>\n  assumes f_scale: \\<open>\\<And>c x y. x \\<in> S \\<Longrightarrow> f (c *\\<^sub>C x) = c *\\<^sub>C f x\\<close>\n  assumes bounded: \\<open>\\<And>x. x \\<in> S \\<Longrightarrow> norm (f x) \\<le> B * norm x\\<close>\n  shows \\<open>cblinfun_extension_exists S f\\<close>", "lemma cblinfun_extension_apply:\n  assumes \"cblinfun_extension_exists S f\"\n    and \"v \\<in> S\"\n  shows \"(cblinfun_extension S f) *\\<^sub>V v = f v\""], "translations": [["", "lemma id_cblinfun_apply[simp]: \"id_cblinfun *\\<^sub>V \\<psi> = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id_cblinfun *\\<^sub>V \\<psi> = \\<psi>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>. \\<psi> = \\<psi>", "by simp"], ["", "lemma isCont_cblinfun_apply[simp]: \"isCont ((*\\<^sub>V) A) \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont ((*\\<^sub>V) A) \\<psi>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<psi> x. bounded_clinear x \\<Longrightarrow> isCont x \\<psi>", "by (simp add: clinear_continuous_at)"], ["", "declare cblinfun.scaleC_left[simp]"], ["", "lemma cblinfun_apply_clinear[simp]: \\<open>clinear (cblinfun_apply A)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear ((*\\<^sub>V) A)", "using bounded_clinear.axioms(1) cblinfun_apply"], ["proof (prove)\nusing this:\n  bounded_clinear ?f \\<Longrightarrow> clinear ?f\n  (*\\<^sub>V) ?x \\<in> {f. bounded_clinear f}\n\ngoal (1 subgoal):\n 1. clinear ((*\\<^sub>V) A)", "by blast"], ["", "lemma cblinfun_cinner_eqI:\n  fixes A B :: \\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\\<close>\n  assumes \\<open>\\<And>\\<psi>. cinner \\<psi> (A *\\<^sub>V \\<psi>) = cinner \\<psi> (B *\\<^sub>V \\<psi>)\\<close>\n  shows \\<open>A = B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A = B", "define C where \\<open>C = A - B\\<close>"], ["proof (state)\nthis:\n  C = A - B\n\ngoal (1 subgoal):\n 1. A = B", "have C0[simp]: \\<open>cinner \\<psi> (C \\<psi>) = 0\\<close> for \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal \\<psi> (C *\\<^sub>V \\<psi>)", "by (simp add: C_def assms cblinfun.diff_left cinner_diff_right)"], ["proof (state)\nthis:\n  is_orthogonal ?\\<psi> (C *\\<^sub>V ?\\<psi>)\n\ngoal (1 subgoal):\n 1. A = B", "{"], ["proof (state)\nthis:\n  is_orthogonal ?\\<psi> (C *\\<^sub>V ?\\<psi>)\n\ngoal (1 subgoal):\n 1. A = B", "fix f g \\<alpha>"], ["proof (state)\ngoal (1 subgoal):\n 1. A = B", "have \\<open>0 = cinner (f + \\<alpha> *\\<^sub>C g) (C *\\<^sub>V (f + \\<alpha> *\\<^sub>C g))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 =\n    (f + \\<alpha> *\\<^sub>C g) \\<bullet>\\<^sub>C\n    (C *\\<^sub>V (f + \\<alpha> *\\<^sub>C g))", "by (simp add: cinner_diff_right minus_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  0 =\n  (f + \\<alpha> *\\<^sub>C g) \\<bullet>\\<^sub>C\n  (C *\\<^sub>V (f + \\<alpha> *\\<^sub>C g))\n\ngoal (1 subgoal):\n 1. A = B", "also"], ["proof (state)\nthis:\n  0 =\n  (f + \\<alpha> *\\<^sub>C g) \\<bullet>\\<^sub>C\n  (C *\\<^sub>V (f + \\<alpha> *\\<^sub>C g))\n\ngoal (1 subgoal):\n 1. A = B", "have \\<open>\\<dots> = \\<alpha> *\\<^sub>C cinner f (C g) + cnj \\<alpha> *\\<^sub>C cinner g (C f)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f + \\<alpha> *\\<^sub>C g) \\<bullet>\\<^sub>C\n    (C *\\<^sub>V (f + \\<alpha> *\\<^sub>C g)) =\n    \\<alpha> *\\<^sub>C (f \\<bullet>\\<^sub>C (C *\\<^sub>V g)) +\n    cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (C *\\<^sub>V f))", "by (smt (z3) C0 add.commute add.right_neutral cblinfun.add_right cblinfun.scaleC_right cblinfun_cinner_right.rep_eq cinner_add_left cinner_scaleC_left complex_scaleC_def)"], ["proof (state)\nthis:\n  (f + \\<alpha> *\\<^sub>C g) \\<bullet>\\<^sub>C\n  (C *\\<^sub>V (f + \\<alpha> *\\<^sub>C g)) =\n  \\<alpha> *\\<^sub>C (f \\<bullet>\\<^sub>C (C *\\<^sub>V g)) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (C *\\<^sub>V f))\n\ngoal (1 subgoal):\n 1. A = B", "finally"], ["proof (chain)\npicking this:\n  0 =\n  \\<alpha> *\\<^sub>C (f \\<bullet>\\<^sub>C (C *\\<^sub>V g)) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (C *\\<^sub>V f))", "have \\<open>\\<alpha> *\\<^sub>C cinner f (C g) = - cnj \\<alpha> *\\<^sub>C cinner g (C f)\\<close>"], ["proof (prove)\nusing this:\n  0 =\n  \\<alpha> *\\<^sub>C (f \\<bullet>\\<^sub>C (C *\\<^sub>V g)) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (C *\\<^sub>V f))\n\ngoal (1 subgoal):\n 1. \\<alpha> *\\<^sub>C (f \\<bullet>\\<^sub>C (C *\\<^sub>V g)) =\n    - cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (C *\\<^sub>V f))", "by (simp add: eq_neg_iff_add_eq_0)"], ["proof (state)\nthis:\n  \\<alpha> *\\<^sub>C (f \\<bullet>\\<^sub>C (C *\\<^sub>V g)) =\n  - cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (C *\\<^sub>V f))\n\ngoal (1 subgoal):\n 1. A = B", "}"], ["proof (state)\nthis:\n  ?\\<alpha>2 *\\<^sub>C (?f2 \\<bullet>\\<^sub>C (C *\\<^sub>V ?g2)) =\n  - cnj ?\\<alpha>2 *\\<^sub>C (?g2 \\<bullet>\\<^sub>C (C *\\<^sub>V ?f2))\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  ?\\<alpha>2 *\\<^sub>C (?f2 \\<bullet>\\<^sub>C (C *\\<^sub>V ?g2)) =\n  - cnj ?\\<alpha>2 *\\<^sub>C (?g2 \\<bullet>\\<^sub>C (C *\\<^sub>V ?f2))", "have \\<open>cinner f (C g) = 0\\<close> for f g"], ["proof (prove)\nusing this:\n  ?\\<alpha>2 *\\<^sub>C (?f2 \\<bullet>\\<^sub>C (C *\\<^sub>V ?g2)) =\n  - cnj ?\\<alpha>2 *\\<^sub>C (?g2 \\<bullet>\\<^sub>C (C *\\<^sub>V ?f2))\n\ngoal (1 subgoal):\n 1. is_orthogonal f (C *\\<^sub>V g)", "by (metis complex_cnj_i complex_cnj_one complex_vector.scale_cancel_right complex_vector.scale_left_imp_eq equation_minus_iff i_squared mult_eq_0_iff one_neq_neg_one)"], ["proof (state)\nthis:\n  is_orthogonal ?f (C *\\<^sub>V ?g)\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  is_orthogonal ?f (C *\\<^sub>V ?g)", "have \\<open>C g = 0\\<close> for g"], ["proof (prove)\nusing this:\n  is_orthogonal ?f (C *\\<^sub>V ?g)\n\ngoal (1 subgoal):\n 1. C *\\<^sub>V g = (0::'a)", "using cinner_eq_zero_iff"], ["proof (prove)\nusing this:\n  is_orthogonal ?f (C *\\<^sub>V ?g)\n  is_orthogonal ?x ?x = (?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. C *\\<^sub>V g = (0::'a)", "by blast"], ["proof (state)\nthis:\n  C *\\<^sub>V ?g = (0::'a)\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  C *\\<^sub>V ?g = (0::'a)", "have \\<open>C = 0\\<close>"], ["proof (prove)\nusing this:\n  C *\\<^sub>V ?g = (0::'a)\n\ngoal (1 subgoal):\n 1. C = 0", "by (simp add: cblinfun_eqI)"], ["proof (state)\nthis:\n  C = 0\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  C = 0", "show \\<open>A = B\\<close>"], ["proof (prove)\nusing this:\n  C = 0\n\ngoal (1 subgoal):\n 1. A = B", "using C_def"], ["proof (prove)\nusing this:\n  C = 0\n  C = A - B\n\ngoal (1 subgoal):\n 1. A = B", "by auto"], ["proof (state)\nthis:\n  A = B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma id_cblinfun_not_0[simp]: \\<open>(id_cblinfun :: 'a::{complex_normed_vector, not_singleton} \\<Rightarrow>\\<^sub>C\\<^sub>L _) \\<noteq> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. id_cblinfun \\<noteq> 0", "by (metis (full_types) Extra_General.UNIV_not_singleton cblinfun.zero_left cblinfun_id_cblinfun_apply ex_norm1 norm_zero one_neq_zero)"], ["", "lemma cblinfun_norm_geqI:\n  assumes \\<open>norm (f *\\<^sub>V x) / norm x \\<ge> K\\<close>\n  shows \\<open>norm f \\<ge> K\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<le> norm f", "using assms"], ["proof (prove)\nusing this:\n  K \\<le> norm (f *\\<^sub>V x) / norm x\n\ngoal (1 subgoal):\n 1. K \\<le> norm f", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>K f x.\n       \\<lbrakk>bounded_clinear f; K \\<le> norm (f x) / norm x\\<rbrakk>\n       \\<Longrightarrow> K \\<le> onorm f", "by (smt (z3) bounded_clinear.bounded_linear le_onorm)"], ["", "(* This lemma is proven in Complex_Bounded_Linear_Function0 but we add the [simp]\n   only here because we try to keep Complex_Bounded_Linear_Function0 as close to\n   Bounded_Linear_Function as possible. *)"], ["", "declare scaleC_conv_of_complex[simp]"], ["", "lemma cblinfun_eq_0_on_span:\n  fixes S::\\<open>'a::complex_normed_vector set\\<close>\n  assumes \"x \\<in> cspan S\"\n    and \"\\<And>s. s\\<in>S \\<Longrightarrow> F *\\<^sub>V s = 0\"\n  shows \\<open>F *\\<^sub>V x = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. F *\\<^sub>V x = (0::'b)", "apply (rule complex_vector.linear_eq_0_on_span[where f=F])"], ["proof (prove)\ngoal (3 subgoals):\n 1. clinear ((*\\<^sub>V) F)\n 2. \\<And>x. x \\<in> ?b \\<Longrightarrow> F *\\<^sub>V x = (0::'b)\n 3. x \\<in> cspan ?b", "using bounded_clinear.axioms(1) cblinfun_apply assms"], ["proof (prove)\nusing this:\n  bounded_clinear ?f \\<Longrightarrow> clinear ?f\n  (*\\<^sub>V) ?x \\<in> {f. bounded_clinear f}\n  x \\<in> cspan S\n  ?s \\<in> S \\<Longrightarrow> F *\\<^sub>V ?s = (0::'b)\n\ngoal (3 subgoals):\n 1. clinear ((*\\<^sub>V) F)\n 2. \\<And>x. x \\<in> ?b \\<Longrightarrow> F *\\<^sub>V x = (0::'b)\n 3. x \\<in> cspan ?b", "by auto"], ["", "lemma cblinfun_eq_on_span:\n  fixes S::\\<open>'a::complex_normed_vector set\\<close>\n  assumes \"x \\<in> cspan S\"\n    and \"\\<And>s. s\\<in>S \\<Longrightarrow> F *\\<^sub>V s = G *\\<^sub>V s\"\n  shows \\<open>F *\\<^sub>V x = G *\\<^sub>V x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. F *\\<^sub>V x = G *\\<^sub>V x", "apply (rule complex_vector.linear_eq_on_span[where f=F])"], ["proof (prove)\ngoal (4 subgoals):\n 1. clinear ((*\\<^sub>V) F)\n 2. clinear ((*\\<^sub>V) G)\n 3. \\<And>x. x \\<in> ?B \\<Longrightarrow> F *\\<^sub>V x = G *\\<^sub>V x\n 4. x \\<in> cspan ?B", "using bounded_clinear.axioms(1) cblinfun_apply assms"], ["proof (prove)\nusing this:\n  bounded_clinear ?f \\<Longrightarrow> clinear ?f\n  (*\\<^sub>V) ?x \\<in> {f. bounded_clinear f}\n  x \\<in> cspan S\n  ?s \\<in> S \\<Longrightarrow> F *\\<^sub>V ?s = G *\\<^sub>V ?s\n\ngoal (4 subgoals):\n 1. clinear ((*\\<^sub>V) F)\n 2. clinear ((*\\<^sub>V) G)\n 3. \\<And>x. x \\<in> ?B \\<Longrightarrow> F *\\<^sub>V x = G *\\<^sub>V x\n 4. x \\<in> cspan ?B", "by auto"], ["", "lemma cblinfun_eq_0_on_UNIV_span:\n  fixes basis::\\<open>'a::complex_normed_vector set\\<close>\n  assumes \"cspan basis = UNIV\"\n    and \"\\<And>s. s\\<in>basis \\<Longrightarrow> F *\\<^sub>V s = 0\"\n  shows \\<open>F = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. F = 0", "by (metis cblinfun_eq_0_on_span UNIV_I assms cblinfun.zero_left cblinfun_eqI)"], ["", "lemma cblinfun_eq_on_UNIV_span:\n  fixes basis::\"'a::complex_normed_vector set\" and \\<phi>::\"'a \\<Rightarrow> 'b::complex_normed_vector\"\n  assumes \"cspan basis = UNIV\"\n    and \"\\<And>s. s\\<in>basis \\<Longrightarrow> F *\\<^sub>V s = G *\\<^sub>V s\"\n  shows \\<open>F = G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. F = G", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. F = G", "have \"F - G = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F - G = 0", "apply (rule cblinfun_eq_0_on_UNIV_span[where basis=basis])"], ["proof (prove)\ngoal (2 subgoals):\n 1. cspan basis = UNIV\n 2. \\<And>s. s \\<in> basis \\<Longrightarrow> (F - G) *\\<^sub>V s = (0::'c)", "using assms"], ["proof (prove)\nusing this:\n  cspan basis = UNIV\n  ?s \\<in> basis \\<Longrightarrow> F *\\<^sub>V ?s = G *\\<^sub>V ?s\n\ngoal (2 subgoals):\n 1. cspan basis = UNIV\n 2. \\<And>s. s \\<in> basis \\<Longrightarrow> (F - G) *\\<^sub>V s = (0::'c)", "by (auto simp add: cblinfun.diff_left)"], ["proof (state)\nthis:\n  F - G = 0\n\ngoal (1 subgoal):\n 1. F = G", "thus ?thesis"], ["proof (prove)\nusing this:\n  F - G = 0\n\ngoal (1 subgoal):\n 1. F = G", "by simp"], ["proof (state)\nthis:\n  F = G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_eq_on_canonical_basis:\n  fixes f g::\"'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\"\n  defines \"basis == set (canonical_basis::'a list)\"\n  assumes \"\\<And>u. u \\<in> basis \\<Longrightarrow> f *\\<^sub>V u = g *\\<^sub>V u\"\n  shows  \"f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "apply (rule cblinfun_eq_on_UNIV_span[where basis=basis])"], ["proof (prove)\ngoal (2 subgoals):\n 1. cspan basis = UNIV\n 2. \\<And>s. s \\<in> basis \\<Longrightarrow> f *\\<^sub>V s = g *\\<^sub>V s", "using assms is_generator_set is_cindependent_set"], ["proof (prove)\nusing this:\n  basis \\<equiv> set canonical_basis\n  ?u \\<in> basis \\<Longrightarrow> f *\\<^sub>V ?u = g *\\<^sub>V ?u\n  cspan (set canonical_basis) = UNIV\n  cindependent (set canonical_basis)\n\ngoal (2 subgoals):\n 1. cspan basis = UNIV\n 2. \\<And>s. s \\<in> basis \\<Longrightarrow> f *\\<^sub>V s = g *\\<^sub>V s", "by auto"], ["", "lemma cblinfun_eq_0_on_canonical_basis:\n  fixes f ::\"'a::{basis_enum,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\"\n  defines \"basis == set (canonical_basis::'a list)\"\n  assumes \"\\<And>u. u \\<in> basis \\<Longrightarrow> f *\\<^sub>V u = 0\"\n  shows  \"f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = 0", "by (simp add: assms cblinfun_eq_on_canonical_basis)"], ["", "lemma cinner_canonical_basis_eq_0:\n  defines \"basisA == set (canonical_basis::'a::onb_enum list)\"\n    and   \"basisB == set (canonical_basis::'b::onb_enum list)\"\n  assumes \"\\<And>u v. u\\<in>basisA \\<Longrightarrow> v\\<in>basisB \\<Longrightarrow> \\<langle>v, F *\\<^sub>V u\\<rangle> = 0\"\n  shows \"F = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. F = 0", "have \"F *\\<^sub>V u = 0\"\n    if \"u\\<in>basisA\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. F *\\<^sub>V u = (0::'b)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. F *\\<^sub>V u = (0::'b)", "have \"\\<And>v. v\\<in>basisB \\<Longrightarrow> \\<langle>v, F *\\<^sub>V u\\<rangle> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       v \\<in> basisB \\<Longrightarrow> is_orthogonal v (F *\\<^sub>V u)", "by (simp add: assms(3) that)"], ["proof (state)\nthis:\n  ?v \\<in> basisB \\<Longrightarrow> is_orthogonal ?v (F *\\<^sub>V u)\n\ngoal (1 subgoal):\n 1. F *\\<^sub>V u = (0::'b)", "moreover"], ["proof (state)\nthis:\n  ?v \\<in> basisB \\<Longrightarrow> is_orthogonal ?v (F *\\<^sub>V u)\n\ngoal (1 subgoal):\n 1. F *\\<^sub>V u = (0::'b)", "have \"(\\<And>v. v\\<in>basisB \\<Longrightarrow> \\<langle>v, x\\<rangle> = 0) \\<Longrightarrow> x = 0\"\n      for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> basisB \\<Longrightarrow>\n        is_orthogonal v x) \\<Longrightarrow>\n    x = (0::'b)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> basisB \\<Longrightarrow>\n        is_orthogonal v x) \\<Longrightarrow>\n    x = (0::'b)", "assume r1: \"\\<And>v. v\\<in>basisB \\<Longrightarrow> \\<langle>v, x\\<rangle> = 0\""], ["proof (state)\nthis:\n  ?v \\<in> basisB \\<Longrightarrow> is_orthogonal ?v x\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> basisB \\<Longrightarrow>\n        is_orthogonal v x) \\<Longrightarrow>\n    x = (0::'b)", "have \"\\<langle>v, x\\<rangle> = 0\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal v x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_orthogonal v x", "have \"cspan basisB = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan basisB = UNIV", "using basisB_def is_generator_set"], ["proof (prove)\nusing this:\n  basisB \\<equiv> set canonical_basis\n  cspan (set canonical_basis) = UNIV\n\ngoal (1 subgoal):\n 1. cspan basisB = UNIV", "by auto"], ["proof (state)\nthis:\n  cspan basisB = UNIV\n\ngoal (1 subgoal):\n 1. is_orthogonal v x", "hence \"v \\<in> cspan basisB\""], ["proof (prove)\nusing this:\n  cspan basisB = UNIV\n\ngoal (1 subgoal):\n 1. v \\<in> cspan basisB", "by (smt iso_tuple_UNIV_I)"], ["proof (state)\nthis:\n  v \\<in> cspan basisB\n\ngoal (1 subgoal):\n 1. is_orthogonal v x", "hence \"\\<exists>t s. v = (\\<Sum>a\\<in>t. s a *\\<^sub>C a) \\<and> finite t \\<and> t \\<subseteq> basisB\""], ["proof (prove)\nusing this:\n  v \\<in> cspan basisB\n\ngoal (1 subgoal):\n 1. \\<exists>t s.\n       v = (\\<Sum>a\\<in>t. s a *\\<^sub>C a) \\<and>\n       finite t \\<and> t \\<subseteq> basisB", "using complex_vector.span_explicit"], ["proof (prove)\nusing this:\n  v \\<in> cspan basisB\n  cspan ?b =\n  {\\<Sum>a\\<in>t. r a *\\<^sub>C a |t r. finite t \\<and> t \\<subseteq> ?b}\n\ngoal (1 subgoal):\n 1. \\<exists>t s.\n       v = (\\<Sum>a\\<in>t. s a *\\<^sub>C a) \\<and>\n       finite t \\<and> t \\<subseteq> basisB", "by (smt mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<exists>t s.\n     v = (\\<Sum>a\\<in>t. s a *\\<^sub>C a) \\<and>\n     finite t \\<and> t \\<subseteq> basisB\n\ngoal (1 subgoal):\n 1. is_orthogonal v x", "then"], ["proof (chain)\npicking this:\n  \\<exists>t s.\n     v = (\\<Sum>a\\<in>t. s a *\\<^sub>C a) \\<and>\n     finite t \\<and> t \\<subseteq> basisB", "obtain t s where b1: \"v = (\\<Sum>a\\<in>t. s a *\\<^sub>C a)\" and b2: \"finite t\" and b3: \"t \\<subseteq> basisB\""], ["proof (prove)\nusing this:\n  \\<exists>t s.\n     v = (\\<Sum>a\\<in>t. s a *\\<^sub>C a) \\<and>\n     finite t \\<and> t \\<subseteq> basisB\n\ngoal (1 subgoal):\n 1. (\\<And>s t.\n        \\<lbrakk>v = (\\<Sum>a\\<in>t. s a *\\<^sub>C a); finite t;\n         t \\<subseteq> basisB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v = (\\<Sum>a\\<in>t. s a *\\<^sub>C a)\n  finite t\n  t \\<subseteq> basisB\n\ngoal (1 subgoal):\n 1. is_orthogonal v x", "have \"\\<langle>v, x\\<rangle> = \\<langle>(\\<Sum>a\\<in>t. s a *\\<^sub>C a), x\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<bullet>\\<^sub>C x =\n    (\\<Sum>a\\<in>t. s a *\\<^sub>C a) \\<bullet>\\<^sub>C x", "by (simp add: b1)"], ["proof (state)\nthis:\n  v \\<bullet>\\<^sub>C x =\n  (\\<Sum>a\\<in>t. s a *\\<^sub>C a) \\<bullet>\\<^sub>C x\n\ngoal (1 subgoal):\n 1. is_orthogonal v x", "also"], ["proof (state)\nthis:\n  v \\<bullet>\\<^sub>C x =\n  (\\<Sum>a\\<in>t. s a *\\<^sub>C a) \\<bullet>\\<^sub>C x\n\ngoal (1 subgoal):\n 1. is_orthogonal v x", "have \"\\<dots> = (\\<Sum>a\\<in>t. \\<langle>s a *\\<^sub>C a, x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>t. s a *\\<^sub>C a) \\<bullet>\\<^sub>C x =\n    (\\<Sum>a\\<in>t. s a *\\<^sub>C a \\<bullet>\\<^sub>C x)", "using cinner_sum_left"], ["proof (prove)\nusing this:\n  sum ?f ?A \\<bullet>\\<^sub>C ?y =\n  (\\<Sum>x\\<in>?A. ?f x \\<bullet>\\<^sub>C ?y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>t. s a *\\<^sub>C a) \\<bullet>\\<^sub>C x =\n    (\\<Sum>a\\<in>t. s a *\\<^sub>C a \\<bullet>\\<^sub>C x)", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>t. s a *\\<^sub>C a) \\<bullet>\\<^sub>C x =\n  (\\<Sum>a\\<in>t. s a *\\<^sub>C a \\<bullet>\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. is_orthogonal v x", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>t. s a *\\<^sub>C a) \\<bullet>\\<^sub>C x =\n  (\\<Sum>a\\<in>t. s a *\\<^sub>C a \\<bullet>\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. is_orthogonal v x", "have \"\\<dots> = (\\<Sum>a\\<in>t. cnj (s a) * \\<langle>a, x\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>t. s a *\\<^sub>C a \\<bullet>\\<^sub>C x) =\n    (\\<Sum>a\\<in>t. cnj (s a) * (a \\<bullet>\\<^sub>C x))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>t. s a *\\<^sub>C a \\<bullet>\\<^sub>C x) =\n  (\\<Sum>a\\<in>t. cnj (s a) * (a \\<bullet>\\<^sub>C x))\n\ngoal (1 subgoal):\n 1. is_orthogonal v x", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>t. s a *\\<^sub>C a \\<bullet>\\<^sub>C x) =\n  (\\<Sum>a\\<in>t. cnj (s a) * (a \\<bullet>\\<^sub>C x))\n\ngoal (1 subgoal):\n 1. is_orthogonal v x", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>t. cnj (s a) * (a \\<bullet>\\<^sub>C x)) = 0", "using b3 r1 subsetD"], ["proof (prove)\nusing this:\n  t \\<subseteq> basisB\n  ?v \\<in> basisB \\<Longrightarrow> is_orthogonal ?v x\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> ?B\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>t. cnj (s a) * (a \\<bullet>\\<^sub>C x)) = 0", "by force"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>t. cnj (s a) * (a \\<bullet>\\<^sub>C x)) = 0\n\ngoal (1 subgoal):\n 1. is_orthogonal v x", "finally"], ["proof (chain)\npicking this:\n  is_orthogonal v x", "show ?thesis"], ["proof (prove)\nusing this:\n  is_orthogonal v x\n\ngoal (1 subgoal):\n 1. is_orthogonal v x", "by simp"], ["proof (state)\nthis:\n  is_orthogonal v x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_orthogonal ?v x\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<in> basisB \\<Longrightarrow>\n        is_orthogonal v x) \\<Longrightarrow>\n    x = (0::'b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_orthogonal ?v x\n\ngoal (1 subgoal):\n 1. x = (0::'b)", "by (simp add: \\<open>\\<And>v. \\<langle>v, x\\<rangle> = 0\\<close> cinner_extensionality)"], ["proof (state)\nthis:\n  x = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<And>v.\n      v \\<in> basisB \\<Longrightarrow> is_orthogonal v ?x) \\<Longrightarrow>\n  ?x = (0::'b)\n\ngoal (1 subgoal):\n 1. F *\\<^sub>V u = (0::'b)", "ultimately"], ["proof (chain)\npicking this:\n  ?v \\<in> basisB \\<Longrightarrow> is_orthogonal ?v (F *\\<^sub>V u)\n  (\\<And>v.\n      v \\<in> basisB \\<Longrightarrow> is_orthogonal v ?x) \\<Longrightarrow>\n  ?x = (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?v \\<in> basisB \\<Longrightarrow> is_orthogonal ?v (F *\\<^sub>V u)\n  (\\<And>v.\n      v \\<in> basisB \\<Longrightarrow> is_orthogonal v ?x) \\<Longrightarrow>\n  ?x = (0::'b)\n\ngoal (1 subgoal):\n 1. F *\\<^sub>V u = (0::'b)", "by simp"], ["proof (state)\nthis:\n  F *\\<^sub>V u = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<in> basisA \\<Longrightarrow> F *\\<^sub>V ?u = (0::'b)\n\ngoal (1 subgoal):\n 1. F = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?u \\<in> basisA \\<Longrightarrow> F *\\<^sub>V ?u = (0::'b)\n\ngoal (1 subgoal):\n 1. F = 0", "using basisA_def cblinfun_eq_0_on_canonical_basis"], ["proof (prove)\nusing this:\n  ?u \\<in> basisA \\<Longrightarrow> F *\\<^sub>V ?u = (0::'b)\n  basisA \\<equiv> set canonical_basis\n  (\\<And>u.\n      u \\<in> set canonical_basis \\<Longrightarrow>\n      ?f *\\<^sub>V u = (0::?'b)) \\<Longrightarrow>\n  ?f = 0\n\ngoal (1 subgoal):\n 1. F = 0", "by auto"], ["proof (state)\nthis:\n  F = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cinner_canonical_basis_eq:\n  defines \"basisA == set (canonical_basis::'a::onb_enum list)\"\n    and   \"basisB == set (canonical_basis::'b::onb_enum list)\"\n  assumes \"\\<And>u v. u\\<in>basisA \\<Longrightarrow> v\\<in>basisB \\<Longrightarrow> \\<langle>v, F *\\<^sub>V u\\<rangle> = \\<langle>v, G *\\<^sub>V u\\<rangle>\"\n  shows \"F = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = G", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. F = G", "define H where \"H = F - G\""], ["proof (state)\nthis:\n  H = F - G\n\ngoal (1 subgoal):\n 1. F = G", "have \"\\<And>u v. u\\<in>basisA \\<Longrightarrow> v\\<in>basisB \\<Longrightarrow> \\<langle>v, H *\\<^sub>V u\\<rangle> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> basisA; v \\<in> basisB\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal v (H *\\<^sub>V u)", "unfolding H_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> basisA; v \\<in> basisB\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal v ((F - G) *\\<^sub>V u)", "by (simp add: assms(3) cinner_diff_right minus_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  \\<lbrakk>?u \\<in> basisA; ?v \\<in> basisB\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?v (H *\\<^sub>V ?u)\n\ngoal (1 subgoal):\n 1. F = G", "hence \"H = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<in> basisA; ?v \\<in> basisB\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?v (H *\\<^sub>V ?u)\n\ngoal (1 subgoal):\n 1. H = 0", "by (simp add: basisA_def basisB_def cinner_canonical_basis_eq_0)"], ["proof (state)\nthis:\n  H = 0\n\ngoal (1 subgoal):\n 1. F = G", "thus ?thesis"], ["proof (prove)\nusing this:\n  H = 0\n\ngoal (1 subgoal):\n 1. F = G", "unfolding H_def"], ["proof (prove)\nusing this:\n  F - G = 0\n\ngoal (1 subgoal):\n 1. F = G", "by simp"], ["proof (state)\nthis:\n  F = G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cinner_canonical_basis_eq':\n  defines \"basisA == set (canonical_basis::'a::onb_enum list)\"\n    and   \"basisB == set (canonical_basis::'b::onb_enum list)\"\n  assumes \"\\<And>u v. u\\<in>basisA \\<Longrightarrow> v\\<in>basisB \\<Longrightarrow> \\<langle>F *\\<^sub>V u, v\\<rangle> = \\<langle>G *\\<^sub>V u, v\\<rangle>\"\n  shows \"F = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = G", "using cinner_canonical_basis_eq assms"], ["proof (prove)\nusing this:\n  (\\<And>u v.\n      \\<lbrakk>u \\<in> set canonical_basis;\n       v \\<in> set canonical_basis\\<rbrakk>\n      \\<Longrightarrow> v \\<bullet>\\<^sub>C (?F *\\<^sub>V u) =\n                        v \\<bullet>\\<^sub>C\n                        (?G *\\<^sub>V u)) \\<Longrightarrow>\n  ?F = ?G\n  basisA \\<equiv> set canonical_basis\n  basisB \\<equiv> set canonical_basis\n  \\<lbrakk>?u \\<in> basisA; ?v \\<in> basisB\\<rbrakk>\n  \\<Longrightarrow> (F *\\<^sub>V ?u) \\<bullet>\\<^sub>C ?v =\n                    (G *\\<^sub>V ?u) \\<bullet>\\<^sub>C ?v\n\ngoal (1 subgoal):\n 1. F = G", "by (metis cinner_commute')"], ["", "lemma cblinfun_norm_approx_witness:\n  fixes A :: \\<open>'a::{not_singleton,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\\<close>\n  assumes \\<open>\\<epsilon> > 0\\<close>\n  shows \\<open>\\<exists>\\<psi>. norm (A *\\<^sub>V \\<psi>) \\<ge> norm A - \\<epsilon> \\<and> norm \\<psi> = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>.\n       norm A - \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "proof (transfer fixing: \\<epsilon>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       bounded_clinear A \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          onorm A - \\<epsilon> \\<le> norm (A \\<psi>) \\<and> norm \\<psi> = 1", "fix A :: \\<open>'a \\<Rightarrow> 'b\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       bounded_clinear A \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          onorm A - \\<epsilon> \\<le> norm (A \\<psi>) \\<and> norm \\<psi> = 1", "assume [simp]: \\<open>bounded_clinear A\\<close>"], ["proof (state)\nthis:\n  bounded_clinear A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       bounded_clinear A \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          onorm A - \\<epsilon> \\<le> norm (A \\<psi>) \\<and> norm \\<psi> = 1", "have \\<open>\\<exists>y\\<in>{norm (A x) |x. norm x = 1}. y > \\<Squnion> {norm (A x) |x. norm x = 1} - \\<epsilon>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>{norm (A x) |x. norm x = 1}.\n       \\<Squnion> {norm (A x) |x. norm x = 1} - \\<epsilon> < y", "apply (rule Sup_real_close)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < \\<epsilon>\n 2. bdd_above {norm (A x) |x. norm x = 1}\n 3. {norm (A x) |x. norm x = 1} \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n\ngoal (3 subgoals):\n 1. 0 < \\<epsilon>\n 2. bdd_above {norm (A x) |x. norm x = 1}\n 3. {norm (A x) |x. norm x = 1} \\<noteq> {}", "by (auto simp: ex_norm1 bounded_clinear.bounded_linear bdd_above_norm_f)"], ["proof (state)\nthis:\n  \\<exists>y\\<in>{norm (A x) |x. norm x = 1}.\n     \\<Squnion> {norm (A x) |x. norm x = 1} - \\<epsilon> < y\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       bounded_clinear A \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          onorm A - \\<epsilon> \\<le> norm (A \\<psi>) \\<and> norm \\<psi> = 1", "also"], ["proof (state)\nthis:\n  \\<exists>y\\<in>{norm (A x) |x. norm x = 1}.\n     \\<Squnion> {norm (A x) |x. norm x = 1} - \\<epsilon> < y\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       bounded_clinear A \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          onorm A - \\<epsilon> \\<le> norm (A \\<psi>) \\<and> norm \\<psi> = 1", "have \\<open>\\<Squnion> {norm (A x) |x. norm x = 1} = onorm A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {norm (A x) |x. norm x = 1} = onorm A", "by (simp add: Complex_Vector_Spaces0.bounded_clinear.bounded_linear onorm_sphere)"], ["proof (state)\nthis:\n  \\<Squnion> {norm (A x) |x. norm x = 1} = onorm A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       bounded_clinear A \\<Longrightarrow>\n       \\<exists>\\<psi>.\n          onorm A - \\<epsilon> \\<le> norm (A \\<psi>) \\<and> norm \\<psi> = 1", "finally"], ["proof (chain)\npicking this:\n  \\<exists>y\\<in>{norm (A x) |x. norm x = 1}. onorm A - \\<epsilon> < y", "show \\<open>\\<exists>\\<psi>. onorm A - \\<epsilon> \\<le> norm (A \\<psi>) \\<and> norm \\<psi> = 1\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>{norm (A x) |x. norm x = 1}. onorm A - \\<epsilon> < y\n\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>.\n       onorm A - \\<epsilon> \\<le> norm (A \\<psi>) \\<and> norm \\<psi> = 1", "by force"], ["proof (state)\nthis:\n  \\<exists>\\<psi>.\n     onorm A - \\<epsilon> \\<le> norm (A \\<psi>) \\<and> norm \\<psi> = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_norm_approx_witness_mult:\n  fixes A :: \\<open>'a::{not_singleton,complex_normed_vector} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\\<close>\n  assumes \\<open>\\<epsilon> < 1\\<close>\n  shows \\<open>\\<exists>\\<psi>. norm (A *\\<^sub>V \\<psi>) \\<ge> norm A * \\<epsilon> \\<and> norm \\<psi> = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "proof (cases \\<open>norm A = 0\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. norm A = 0 \\<Longrightarrow>\n    \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1\n 2. norm A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "case True"], ["proof (state)\nthis:\n  norm A = 0\n\ngoal (2 subgoals):\n 1. norm A = 0 \\<Longrightarrow>\n    \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1\n 2. norm A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "then"], ["proof (chain)\npicking this:\n  norm A = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  norm A = 0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 0 \\<Longrightarrow> \\<exists>\\<psi>. norm \\<psi> = 1", "by (simp add: ex_norm1)"], ["proof (state)\nthis:\n  \\<exists>\\<psi>.\n     norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n     norm \\<psi> = 1\n\ngoal (1 subgoal):\n 1. norm A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. norm A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "case False"], ["proof (state)\nthis:\n  norm A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. norm A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "then"], ["proof (chain)\npicking this:\n  norm A \\<noteq> 0", "have \\<open>(1 - \\<epsilon>) * norm A > 0\\<close>"], ["proof (prove)\nusing this:\n  norm A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < (1 - \\<epsilon>) * norm A", "using assms"], ["proof (prove)\nusing this:\n  norm A \\<noteq> 0\n  \\<epsilon> < 1\n\ngoal (1 subgoal):\n 1. 0 < (1 - \\<epsilon>) * norm A", "by fastforce"], ["proof (state)\nthis:\n  0 < (1 - \\<epsilon>) * norm A\n\ngoal (1 subgoal):\n 1. norm A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "then"], ["proof (chain)\npicking this:\n  0 < (1 - \\<epsilon>) * norm A", "obtain \\<psi> where geq: \\<open>norm (A *\\<^sub>V \\<psi>) \\<ge> norm A - ((1 - \\<epsilon>) * norm A)\\<close> and \\<open>norm \\<psi> = 1\\<close>"], ["proof (prove)\nusing this:\n  0 < (1 - \\<epsilon>) * norm A\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        \\<lbrakk>norm A - (1 - \\<epsilon>) * norm A\n                 \\<le> norm (A *\\<^sub>V \\<psi>);\n         norm \\<psi> = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cblinfun_norm_approx_witness"], ["proof (prove)\nusing this:\n  0 < (1 - \\<epsilon>) * norm A\n  0 < ?\\<epsilon> \\<Longrightarrow>\n  \\<exists>\\<psi>.\n     norm ?A - ?\\<epsilon> \\<le> norm (?A *\\<^sub>V \\<psi>) \\<and>\n     norm \\<psi> = 1\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        \\<lbrakk>norm A - (1 - \\<epsilon>) * norm A\n                 \\<le> norm (A *\\<^sub>V \\<psi>);\n         norm \\<psi> = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  norm A - (1 - \\<epsilon>) * norm A \\<le> norm (A *\\<^sub>V \\<psi>)\n  norm \\<psi> = 1\n\ngoal (1 subgoal):\n 1. norm A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "have \\<open>norm A * \\<epsilon> = norm A - (1 - \\<epsilon>) * norm A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm A * \\<epsilon> = norm A - (1 - \\<epsilon>) * norm A", "by (simp add: mult.commute right_diff_distrib')"], ["proof (state)\nthis:\n  norm A * \\<epsilon> = norm A - (1 - \\<epsilon>) * norm A\n\ngoal (1 subgoal):\n 1. norm A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "also"], ["proof (state)\nthis:\n  norm A * \\<epsilon> = norm A - (1 - \\<epsilon>) * norm A\n\ngoal (1 subgoal):\n 1. norm A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "have \\<open>\\<dots> \\<le> norm (A *\\<^sub>V \\<psi>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm A - (1 - \\<epsilon>) * norm A \\<le> norm (A *\\<^sub>V \\<psi>)", "by (rule geq)"], ["proof (state)\nthis:\n  norm A - (1 - \\<epsilon>) * norm A \\<le> norm (A *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. norm A \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "finally"], ["proof (chain)\npicking this:\n  norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "using \\<open>norm \\<psi> = 1\\<close>"], ["proof (prove)\nusing this:\n  norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>)\n  norm \\<psi> = 1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>.\n       norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<psi>.\n     norm A * \\<epsilon> \\<le> norm (A *\\<^sub>V \\<psi>) \\<and>\n     norm \\<psi> = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_to_CARD_1_0[simp]: \\<open>(A :: _ \\<Rightarrow>\\<^sub>C\\<^sub>L _::CARD_1) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 0", "apply (rule cblinfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. A *\\<^sub>V i = 0 *\\<^sub>V i", "by auto"], ["", "lemma cblinfun_from_CARD_1_0[simp]: \\<open>(A :: _::CARD_1 \\<Rightarrow>\\<^sub>C\\<^sub>L _) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 0", "apply (rule cblinfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. A *\\<^sub>V i = 0 *\\<^sub>V i", "apply (subst CARD_1_vec_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. A *\\<^sub>V (0::'a) = 0 *\\<^sub>V i", "by auto"], ["", "lemma cblinfun_cspan_UNIV:\n  fixes basis :: \\<open>('a::{complex_normed_vector,cfinite_dim} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector) set\\<close>\n    and basisA :: \\<open>'a set\\<close> and basisB :: \\<open>'b set\\<close>\n  assumes \\<open>cspan basisA = UNIV\\<close> and \\<open>cspan basisB = UNIV\\<close>\n  assumes basis: \\<open>\\<And>a b. a\\<in>basisA \\<Longrightarrow> b\\<in>basisB \\<Longrightarrow> \\<exists>F\\<in>basis. \\<forall>a'\\<in>basisA. F *\\<^sub>V a' = (if a'=a then b else 0)\\<close>\n  shows \\<open>cspan basis = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "obtain basisA' where \\<open>basisA' \\<subseteq> basisA\\<close> and \\<open>cindependent basisA'\\<close> and \\<open>cspan basisA' = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>basisA'.\n        \\<lbrakk>basisA' \\<subseteq> basisA; cindependent basisA';\n         cspan basisA' = UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(1) complex_vector.maximal_independent_subset complex_vector.span_eq top_greatest)"], ["proof (state)\nthis:\n  basisA' \\<subseteq> basisA\n  cindependent basisA'\n  cspan basisA' = UNIV\n\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "then"], ["proof (chain)\npicking this:\n  basisA' \\<subseteq> basisA\n  cindependent basisA'\n  cspan basisA' = UNIV", "have [simp]: \\<open>finite basisA'\\<close>"], ["proof (prove)\nusing this:\n  basisA' \\<subseteq> basisA\n  cindependent basisA'\n  cspan basisA' = UNIV\n\ngoal (1 subgoal):\n 1. finite basisA'", "by (simp add: cindependent_cfinite_dim_finite)"], ["proof (state)\nthis:\n  finite basisA'\n\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "have basis': \\<open>\\<And>a b. a\\<in>basisA' \\<Longrightarrow> b\\<in>basisB \\<Longrightarrow> \\<exists>F\\<in>basis. \\<forall>a'\\<in>basisA'. F *\\<^sub>V a' = (if a'=a then b else 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> basisA'; b \\<in> basisB\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<in>basis.\n                            \\<forall>a'\\<in>basisA'.\n                               F *\\<^sub>V a' =\n                               (if a' = a then b else (0::'b))", "using basis \\<open>basisA' \\<subseteq> basisA\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> basisA; ?b \\<in> basisB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>F\\<in>basis.\n                       \\<forall>a'\\<in>basisA.\n                          F *\\<^sub>V a' = (if a' = ?a then ?b else (0::'b))\n  basisA' \\<subseteq> basisA\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> basisA'; b \\<in> basisB\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<in>basis.\n                            \\<forall>a'\\<in>basisA'.\n                               F *\\<^sub>V a' =\n                               (if a' = a then b else (0::'b))", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> basisA'; ?b \\<in> basisB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>F\\<in>basis.\n                       \\<forall>a'\\<in>basisA'.\n                          F *\\<^sub>V a' = (if a' = ?a then ?b else (0::'b))\n\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "obtain F where F: \\<open>F a b \\<in> basis \\<and> F a b *\\<^sub>V a' = (if a'=a then b else 0)\\<close> \n    if \\<open>a\\<in>basisA'\\<close> \\<open>b\\<in>basisB\\<close> \\<open>a'\\<in>basisA'\\<close> for a b a'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>F.\n        (\\<And>a b a'.\n            \\<lbrakk>a \\<in> basisA'; b \\<in> basisB;\n             a' \\<in> basisA'\\<rbrakk>\n            \\<Longrightarrow> F a b \\<in> basis \\<and>\n                              F a b *\\<^sub>V a' =\n                              (if a' = a then b\n                               else (0::'b))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F.\n       \\<forall>a b a'.\n          a \\<in> basisA' \\<longrightarrow>\n          b \\<in> basisB \\<longrightarrow>\n          a' \\<in> basisA' \\<longrightarrow>\n          F a b \\<in> basis \\<and>\n          F a b *\\<^sub>V a' = (if a' = a then b else (0::'b))", "apply (intro choice allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<exists>y.\n          \\<forall>a'.\n             a \\<in> basisA' \\<longrightarrow>\n             b \\<in> basisB \\<longrightarrow>\n             a' \\<in> basisA' \\<longrightarrow>\n             y \\<in> basis \\<and>\n             y *\\<^sub>V a' = (if a' = a then b else (0::'b))", "using basis'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> basisA'; ?b \\<in> basisB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>F\\<in>basis.\n                       \\<forall>a'\\<in>basisA'.\n                          F *\\<^sub>V a' = (if a' = ?a then ?b else (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<exists>y.\n          \\<forall>a'.\n             a \\<in> basisA' \\<longrightarrow>\n             b \\<in> basisB \\<longrightarrow>\n             a' \\<in> basisA' \\<longrightarrow>\n             y \\<in> basis \\<and>\n             y *\\<^sub>V a' = (if a' = a then b else (0::'b))", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> basisA'; ?b \\<in> basisB; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> F ?a ?b \\<in> basis \\<and>\n                    F ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))\n\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<in> basisA'; ?b \\<in> basisB; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> F ?a ?b \\<in> basis \\<and>\n                    F ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))", "have F_apply: \\<open>F a b *\\<^sub>V a' = (if a'=a then b else 0)\\<close>\n    if \\<open>a\\<in>basisA'\\<close> \\<open>b\\<in>basisB\\<close> \\<open>a'\\<in>basisA'\\<close> for a b a'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> basisA'; ?b \\<in> basisB; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> F ?a ?b \\<in> basis \\<and>\n                    F ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))\n\ngoal (1 subgoal):\n 1. F a b *\\<^sub>V a' = (if a' = a then b else (0::'b))", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> basisA'; ?b \\<in> basisB; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> F ?a ?b \\<in> basis \\<and>\n                    F ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))\n  a \\<in> basisA'\n  b \\<in> basisB\n  a' \\<in> basisA'\n\ngoal (1 subgoal):\n 1. F a b *\\<^sub>V a' = (if a' = a then b else (0::'b))", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> basisA'; ?b \\<in> basisB; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> F ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))\n\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "have F_basis: \\<open>F a b \\<in> basis\\<close> \n    if \\<open>a\\<in>basisA'\\<close> \\<open>b\\<in>basisB\\<close> for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. F a b \\<in> basis", "using that F"], ["proof (prove)\nusing this:\n  a \\<in> basisA'\n  b \\<in> basisB\n  \\<lbrakk>?a \\<in> basisA'; ?b \\<in> basisB; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> F ?a ?b \\<in> basis \\<and>\n                    F ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))\n\ngoal (1 subgoal):\n 1. F a b \\<in> basis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> basisA'; ?b \\<in> basisB\\<rbrakk>\n  \\<Longrightarrow> F ?a ?b \\<in> basis\n\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "have b_span: \\<open>\\<exists>G\\<in>cspan {F a b|b. b\\<in>basisB}. \\<forall>a'\\<in>basisA'. G *\\<^sub>V a' = (if a'=a then b else 0)\\<close> if \\<open>a\\<in>basisA'\\<close> for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>G\\<in>cspan {F a b |b. b \\<in> basisB}.\n       \\<forall>a'\\<in>basisA'.\n          G *\\<^sub>V a' = (if a' = a then b else (0::'b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>G\\<in>cspan {F a b |b. b \\<in> basisB}.\n       \\<forall>a'\\<in>basisA'.\n          G *\\<^sub>V a' = (if a' = a then b else (0::'b))", "from \\<open>cspan basisB = UNIV\\<close>"], ["proof (chain)\npicking this:\n  cspan basisB = UNIV", "obtain r t where \\<open>finite t\\<close> and \\<open>t \\<subseteq> basisB\\<close> and b_lincom: \\<open>b = (\\<Sum>a\\<in>t. r a *\\<^sub>C a)\\<close>"], ["proof (prove)\nusing this:\n  cspan basisB = UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>t r.\n        \\<lbrakk>finite t; t \\<subseteq> basisB;\n         b = (\\<Sum>a\\<in>t. r a *\\<^sub>C a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding complex_vector.span_alt"], ["proof (prove)\nusing this:\n  {\\<Sum>x | f x \\<noteq> 0. f x *\\<^sub>C x |f.\n   {x. f x \\<noteq> 0} \\<subseteq> basisB \\<and>\n   finite {x. f x \\<noteq> 0}} =\n  UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>t r.\n        \\<lbrakk>finite t; t \\<subseteq> basisB;\n         b = (\\<Sum>a\\<in>t. r a *\\<^sub>C a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<Sum>x | f x \\<noteq> 0. f x *\\<^sub>C x |f.\n     {x. f x \\<noteq> 0} \\<subseteq> basisB \\<and>\n     finite {x. f x \\<noteq> 0}} =\n    UNIV \\<Longrightarrow>\n    \\<exists>t r.\n       finite t \\<and>\n       t \\<subseteq> basisB \\<and> b = (\\<Sum>a\\<in>t. r a *\\<^sub>C a)", "by blast"], ["proof (state)\nthis:\n  finite t\n  t \\<subseteq> basisB\n  b = (\\<Sum>a\\<in>t. r a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. \\<exists>G\\<in>cspan {F a b |b. b \\<in> basisB}.\n       \\<forall>a'\\<in>basisA'.\n          G *\\<^sub>V a' = (if a' = a then b else (0::'b))", "define G where \\<open>G = (\\<Sum>i\\<in>t. r i *\\<^sub>C F a i)\\<close>"], ["proof (state)\nthis:\n  G = (\\<Sum>i\\<in>t. r i *\\<^sub>C F a i)\n\ngoal (1 subgoal):\n 1. \\<exists>G\\<in>cspan {F a b |b. b \\<in> basisB}.\n       \\<forall>a'\\<in>basisA'.\n          G *\\<^sub>V a' = (if a' = a then b else (0::'b))", "have \\<open>G \\<in> cspan {F a b|b. b\\<in>basisB}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<in> cspan {F a b |b. b \\<in> basisB}", "using \\<open>finite t\\<close> \\<open>t \\<subseteq> basisB\\<close>"], ["proof (prove)\nusing this:\n  finite t\n  t \\<subseteq> basisB\n\ngoal (1 subgoal):\n 1. G \\<in> cspan {F a b |b. b \\<in> basisB}", "unfolding G_def"], ["proof (prove)\nusing this:\n  finite t\n  t \\<subseteq> basisB\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>t. r i *\\<^sub>C F a i)\n    \\<in> cspan {F a b |b. b \\<in> basisB}", "by (smt (verit, ccfv_threshold) complex_vector.span_base complex_vector.span_scale complex_vector.span_sum mem_Collect_eq subset_eq)"], ["proof (state)\nthis:\n  G \\<in> cspan {F a b |b. b \\<in> basisB}\n\ngoal (1 subgoal):\n 1. \\<exists>G\\<in>cspan {F a b |b. b \\<in> basisB}.\n       \\<forall>a'\\<in>basisA'.\n          G *\\<^sub>V a' = (if a' = a then b else (0::'b))", "moreover"], ["proof (state)\nthis:\n  G \\<in> cspan {F a b |b. b \\<in> basisB}\n\ngoal (1 subgoal):\n 1. \\<exists>G\\<in>cspan {F a b |b. b \\<in> basisB}.\n       \\<forall>a'\\<in>basisA'.\n          G *\\<^sub>V a' = (if a' = a then b else (0::'b))", "have \\<open>G *\\<^sub>V a' = (if a'=a then b else 0)\\<close> if \\<open>a'\\<in>basisA'\\<close> for a'"], ["proof (prove)\ngoal (1 subgoal):\n 1. G *\\<^sub>V a' = (if a' = a then b else (0::'b))", "apply (cases \\<open>a'=a\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a' = a \\<Longrightarrow>\n    G *\\<^sub>V a' = (if a' = a then b else (0::'b))\n 2. a' \\<noteq> a \\<Longrightarrow>\n    G *\\<^sub>V a' = (if a' = a then b else (0::'b))", "using \\<open>t \\<subseteq> basisB\\<close> \\<open>a\\<in>basisA'\\<close> \\<open>a'\\<in>basisA'\\<close>"], ["proof (prove)\nusing this:\n  t \\<subseteq> basisB\n  a \\<in> basisA'\n  a' \\<in> basisA'\n\ngoal (2 subgoals):\n 1. a' = a \\<Longrightarrow>\n    G *\\<^sub>V a' = (if a' = a then b else (0::'b))\n 2. a' \\<noteq> a \\<Longrightarrow>\n    G *\\<^sub>V a' = (if a' = a then b else (0::'b))", "by (auto simp: b_lincom G_def cblinfun.sum_left F_apply intro!: sum.neutral sum.cong)"], ["proof (state)\nthis:\n  ?a' \\<in> basisA' \\<Longrightarrow>\n  G *\\<^sub>V ?a' = (if ?a' = a then b else (0::'b))\n\ngoal (1 subgoal):\n 1. \\<exists>G\\<in>cspan {F a b |b. b \\<in> basisB}.\n       \\<forall>a'\\<in>basisA'.\n          G *\\<^sub>V a' = (if a' = a then b else (0::'b))", "ultimately"], ["proof (chain)\npicking this:\n  G \\<in> cspan {F a b |b. b \\<in> basisB}\n  ?a' \\<in> basisA' \\<Longrightarrow>\n  G *\\<^sub>V ?a' = (if ?a' = a then b else (0::'b))", "show ?thesis"], ["proof (prove)\nusing this:\n  G \\<in> cspan {F a b |b. b \\<in> basisB}\n  ?a' \\<in> basisA' \\<Longrightarrow>\n  G *\\<^sub>V ?a' = (if ?a' = a then b else (0::'b))\n\ngoal (1 subgoal):\n 1. \\<exists>G\\<in>cspan {F a b |b. b \\<in> basisB}.\n       \\<forall>a'\\<in>basisA'.\n          G *\\<^sub>V a' = (if a' = a then b else (0::'b))", "by blast"], ["proof (state)\nthis:\n  \\<exists>G\\<in>cspan {F a b |b. b \\<in> basisB}.\n     \\<forall>a'\\<in>basisA'.\n        G *\\<^sub>V a' = (if a' = a then b else (0::'b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a \\<in> basisA' \\<Longrightarrow>\n  \\<exists>G\\<in>cspan {F ?a b |b. b \\<in> basisB}.\n     \\<forall>a'\\<in>basisA'.\n        G *\\<^sub>V a' = (if a' = ?a then ?b else (0::'b))\n\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "have a_span: \\<open>cspan (\\<Union>a\\<in>basisA'. cspan {F a b|b. b\\<in>basisB}) = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB}) = UNIV", "proof (intro equalityI subset_UNIV subsetI, rename_tac H)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> UNIV \\<Longrightarrow>\n       H \\<in> cspan\n                (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})", "fix H"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> UNIV \\<Longrightarrow>\n       H \\<in> cspan\n                (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})", "obtain G where G: \\<open>G a b \\<in> cspan {F a b|b. b\\<in>basisB} \\<and> G a b *\\<^sub>V a' = (if a'=a then b else 0)\\<close> if \\<open>a\\<in>basisA'\\<close> and \\<open>a'\\<in>basisA'\\<close> for a b a'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>G.\n        (\\<And>a b a'.\n            \\<lbrakk>a \\<in> basisA'; a' \\<in> basisA'\\<rbrakk>\n            \\<Longrightarrow> G a b\n                              \\<in> cspan {F a b |b. b \\<in> basisB} \\<and>\n                              G a b *\\<^sub>V a' =\n                              (if a' = a then b\n                               else (0::'b))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>G.\n       \\<forall>a b a'.\n          a \\<in> basisA' \\<longrightarrow>\n          a' \\<in> basisA' \\<longrightarrow>\n          G a b \\<in> cspan {F a b |b. b \\<in> basisB} \\<and>\n          G a b *\\<^sub>V a' = (if a' = a then b else (0::'b))", "apply (intro choice allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<exists>y.\n          \\<forall>a'.\n             a \\<in> basisA' \\<longrightarrow>\n             a' \\<in> basisA' \\<longrightarrow>\n             y \\<in> cspan {F a b |b. b \\<in> basisB} \\<and>\n             y *\\<^sub>V a' = (if a' = a then b else (0::'b))", "using b_span"], ["proof (prove)\nusing this:\n  ?a \\<in> basisA' \\<Longrightarrow>\n  \\<exists>G\\<in>cspan {F ?a b |b. b \\<in> basisB}.\n     \\<forall>a'\\<in>basisA'.\n        G *\\<^sub>V a' = (if a' = ?a then ?b else (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<exists>y.\n          \\<forall>a'.\n             a \\<in> basisA' \\<longrightarrow>\n             a' \\<in> basisA' \\<longrightarrow>\n             y \\<in> cspan {F a b |b. b \\<in> basisB} \\<and>\n             y *\\<^sub>V a' = (if a' = a then b else (0::'b))", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> basisA'; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> G ?a ?b \\<in> cspan {F ?a b |b. b \\<in> basisB} \\<and>\n                    G ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> UNIV \\<Longrightarrow>\n       H \\<in> cspan\n                (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<in> basisA'; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> G ?a ?b \\<in> cspan {F ?a b |b. b \\<in> basisB} \\<and>\n                    G ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))", "have G_cspan: \\<open>G a b \\<in> cspan {F a b|b. b\\<in>basisB}\\<close> if \\<open>a\\<in>basisA'\\<close> for a b"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> basisA'; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> G ?a ?b \\<in> cspan {F ?a b |b. b \\<in> basisB} \\<and>\n                    G ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))\n\ngoal (1 subgoal):\n 1. G a b \\<in> cspan {F a b |b. b \\<in> basisB}", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> basisA'; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> G ?a ?b \\<in> cspan {F ?a b |b. b \\<in> basisB} \\<and>\n                    G ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))\n  a \\<in> basisA'\n\ngoal (1 subgoal):\n 1. G a b \\<in> cspan {F a b |b. b \\<in> basisB}", "by auto"], ["proof (state)\nthis:\n  ?a \\<in> basisA' \\<Longrightarrow>\n  G ?a ?b \\<in> cspan {F ?a b |b. b \\<in> basisB}\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> UNIV \\<Longrightarrow>\n       H \\<in> cspan\n                (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})", "from G"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<in> basisA'; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> G ?a ?b \\<in> cspan {F ?a b |b. b \\<in> basisB} \\<and>\n                    G ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))", "have G: \\<open>G a b *\\<^sub>V a' = (if a'=a then b else 0)\\<close> if \\<open>a\\<in>basisA'\\<close> and \\<open>a'\\<in>basisA'\\<close> for a b a'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> basisA'; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> G ?a ?b \\<in> cspan {F ?a b |b. b \\<in> basisB} \\<and>\n                    G ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))\n\ngoal (1 subgoal):\n 1. G a b *\\<^sub>V a' = (if a' = a then b else (0::'b))", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> basisA'; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> G ?a ?b \\<in> cspan {F ?a b |b. b \\<in> basisB} \\<and>\n                    G ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))\n  a \\<in> basisA'\n  a' \\<in> basisA'\n\ngoal (1 subgoal):\n 1. G a b *\\<^sub>V a' = (if a' = a then b else (0::'b))", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> basisA'; ?a' \\<in> basisA'\\<rbrakk>\n  \\<Longrightarrow> G ?a ?b *\\<^sub>V ?a' =\n                    (if ?a' = ?a then ?b else (0::'b))\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> UNIV \\<Longrightarrow>\n       H \\<in> cspan\n                (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})", "define H' where \\<open>H' = (\\<Sum>a\\<in>basisA'. G a (H *\\<^sub>V a))\\<close>"], ["proof (state)\nthis:\n  H' = (\\<Sum>a\\<in>basisA'. G a (H *\\<^sub>V a))\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> UNIV \\<Longrightarrow>\n       H \\<in> cspan\n                (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})", "have \\<open>H' \\<in> cspan (\\<Union>a\\<in>basisA'. cspan {F a b|b. b\\<in>basisB})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. H' \\<in> cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})", "unfolding H'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>basisA'. G a (H *\\<^sub>V a))\n    \\<in> cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})", "using G_cspan"], ["proof (prove)\nusing this:\n  ?a \\<in> basisA' \\<Longrightarrow>\n  G ?a ?b \\<in> cspan {F ?a b |b. b \\<in> basisB}\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>basisA'. G a (H *\\<^sub>V a))\n    \\<in> cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})", "by (smt (verit, del_insts) UN_iff complex_vector.span_clauses(1) complex_vector.span_sum)"], ["proof (state)\nthis:\n  H' \\<in> cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> UNIV \\<Longrightarrow>\n       H \\<in> cspan\n                (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})", "moreover"], ["proof (state)\nthis:\n  H' \\<in> cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> UNIV \\<Longrightarrow>\n       H \\<in> cspan\n                (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})", "have \\<open>H' = H\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. H' = H", "using \\<open>cspan basisA' = UNIV\\<close>"], ["proof (prove)\nusing this:\n  cspan basisA' = UNIV\n\ngoal (1 subgoal):\n 1. H' = H", "apply (rule cblinfun_eq_on_UNIV_span)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> basisA' \\<Longrightarrow> H' *\\<^sub>V s = H *\\<^sub>V s", "apply (auto simp: H'_def cblinfun.sum_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> basisA' \\<Longrightarrow>\n       (\\<Sum>i\\<in>basisA'. G i (H *\\<^sub>V i) *\\<^sub>V s) =\n       H *\\<^sub>V s", "apply (subst sum_single)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s. s \\<in> basisA' \\<Longrightarrow> finite basisA'\n 2. \\<And>s j.\n       \\<lbrakk>s \\<in> basisA'; j \\<noteq> ?i4 s; j \\<in> basisA'\\<rbrakk>\n       \\<Longrightarrow> G j (H *\\<^sub>V j) *\\<^sub>V s = (0::'b)\n 3. \\<And>s.\n       s \\<in> basisA' \\<Longrightarrow>\n       (if ?i4 s \\<in> basisA'\n        then G (?i4 s) (H *\\<^sub>V ?i4 s) *\\<^sub>V s else (0::'b)) =\n       H *\\<^sub>V s", "by (auto simp: G)"], ["proof (state)\nthis:\n  H' = H\n\ngoal (1 subgoal):\n 1. \\<And>H.\n       H \\<in> UNIV \\<Longrightarrow>\n       H \\<in> cspan\n                (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})", "ultimately"], ["proof (chain)\npicking this:\n  H' \\<in> cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})\n  H' = H", "show \\<open>H \\<in> cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})\\<close>"], ["proof (prove)\nusing this:\n  H' \\<in> cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})\n  H' = H\n\ngoal (1 subgoal):\n 1. H \\<in> cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})", "by simp"], ["proof (state)\nthis:\n  H \\<in> cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB}) = UNIV\n\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "moreover"], ["proof (state)\nthis:\n  cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB}) = UNIV\n\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "have \\<open>cspan basis \\<supseteq> cspan (\\<Union>a\\<in>basisA'. cspan {F a b|b. b\\<in>basisB})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})\n    \\<subseteq> cspan basis", "using F_basis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> basisA'; ?b \\<in> basisB\\<rbrakk>\n  \\<Longrightarrow> F ?a ?b \\<in> basis\n\ngoal (1 subgoal):\n 1. cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})\n    \\<subseteq> cspan basis", "by (smt (z3) UN_subset_iff complex_vector.span_alt complex_vector.span_minimal complex_vector.subspace_span mem_Collect_eq subset_iff)"], ["proof (state)\nthis:\n  cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})\n  \\<subseteq> cspan basis\n\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "ultimately"], ["proof (chain)\npicking this:\n  cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB}) = UNIV\n  cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})\n  \\<subseteq> cspan basis", "show \\<open>cspan basis = UNIV\\<close>"], ["proof (prove)\nusing this:\n  cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB}) = UNIV\n  cspan (\\<Union>a\\<in>basisA'. cspan {F a b |b. b \\<in> basisB})\n  \\<subseteq> cspan basis\n\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "by auto"], ["proof (state)\nthis:\n  cspan basis = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "instance cblinfun :: (\\<open>{cfinite_dim,complex_normed_vector}\\<close>, \\<open>{cfinite_dim,complex_normed_vector}\\<close>) cfinite_dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b, cfinite_dim_class)", "proof intro_classes"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "obtain basisA :: \\<open>'a set\\<close> where [simp]: \\<open>cspan basisA = UNIV\\<close> \\<open>cindependent basisA\\<close> \\<open>finite basisA\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>basisA.\n        \\<lbrakk>cspan basisA = UNIV; cindependent basisA;\n         finite basisA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using finite_basis"], ["proof (prove)\nusing this:\n  \\<exists>basis.\n     finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>basisA.\n        \\<lbrakk>cspan basisA = UNIV; cindependent basisA;\n         finite basisA\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cspan basisA = UNIV\n  cindependent basisA\n  finite basisA\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "obtain basisB :: \\<open>'b set\\<close> where [simp]: \\<open>cspan basisB = UNIV\\<close> \\<open>cindependent basisB\\<close> \\<open>finite basisB\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>basisB.\n        \\<lbrakk>cspan basisB = UNIV; cindependent basisB;\n         finite basisB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using finite_basis"], ["proof (prove)\nusing this:\n  \\<exists>basis.\n     finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>basisB.\n        \\<lbrakk>cspan basisB = UNIV; cindependent basisB;\n         finite basisB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cspan basisB = UNIV\n  cindependent basisB\n  finite basisB\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "define f where \\<open>f a b = cconstruct basisA (\\<lambda>x. if x=a then b else 0)\\<close> for a :: 'a and b :: 'b"], ["proof (state)\nthis:\n  f ?a ?b = cconstruct basisA (\\<lambda>x. if x = ?a then ?b else (0::'b))\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "have f_a: \\<open>f a b a = b\\<close> if \\<open>a : basisA\\<close> for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. f a b a = b", "by (simp add: complex_vector.construct_basis f_def that)"], ["proof (state)\nthis:\n  ?a \\<in> basisA \\<Longrightarrow> f ?a ?b ?a = ?b\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "have f_not_a: \\<open>f a b c = 0\\<close> if \\<open>a : basisA\\<close> and \\<open>c : basisA\\<close> and \\<open>a \\<noteq> c\\<close>for a b c"], ["proof (prove)\ngoal (1 subgoal):\n 1. f a b c = (0::'b)", "using that"], ["proof (prove)\nusing this:\n  a \\<in> basisA\n  c \\<in> basisA\n  a \\<noteq> c\n\ngoal (1 subgoal):\n 1. f a b c = (0::'b)", "by (simp add: complex_vector.construct_basis f_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> basisA; ?c \\<in> basisA; ?a \\<noteq> ?c\\<rbrakk>\n  \\<Longrightarrow> f ?a ?b ?c = (0::'b)\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "define F where \\<open>F a b = CBlinfun (f a b)\\<close> for a b"], ["proof (state)\nthis:\n  F ?a ?b = CBlinfun (f ?a ?b)\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "have \\<open>clinear (f a b)\\<close> for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear (f a b)", "by (auto intro: complex_vector.linear_construct simp: f_def)"], ["proof (state)\nthis:\n  clinear (f ?a ?b)\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "then"], ["proof (chain)\npicking this:\n  clinear (f ?a ?b)", "have \\<open>bounded_clinear (f a b)\\<close> for a b"], ["proof (prove)\nusing this:\n  clinear (f ?a ?b)\n\ngoal (1 subgoal):\n 1. bounded_clinear (f a b)", "by auto"], ["proof (state)\nthis:\n  bounded_clinear (f ?a ?b)\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "then"], ["proof (chain)\npicking this:\n  bounded_clinear (f ?a ?b)", "have F_apply: \\<open>cblinfun_apply (F a b) = f a b\\<close> for a b"], ["proof (prove)\nusing this:\n  bounded_clinear (f ?a ?b)\n\ngoal (1 subgoal):\n 1. (*\\<^sub>V) (F a b) = f a b", "by (simp add: F_def bounded_clinear_CBlinfun_apply)"], ["proof (state)\nthis:\n  (*\\<^sub>V) (F ?a ?b) = f ?a ?b\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "define basis where \\<open>basis = {F a b| a b. a\\<in>basisA \\<and> b\\<in>basisB}\\<close>"], ["proof (state)\nthis:\n  basis = {F a b |a b. a \\<in> basisA \\<and> b \\<in> basisB}\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "have \\<open>cspan basis = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan basis = UNIV", "apply (rule cblinfun_cspan_UNIV[where basisA=basisA and basisB=basisB])"], ["proof (prove)\ngoal (3 subgoals):\n 1. cspan basisA = UNIV\n 2. cspan basisB = UNIV\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> basisA; b \\<in> basisB\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<in>basis.\n                            \\<forall>a'\\<in>basisA.\n                               F *\\<^sub>V a' =\n                               (if a' = a then b else (0::'b))", "apply (auto simp: basis_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> basisA; b \\<in> basisB\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Fa.\n                            (\\<exists>a b.\n                                Fa = F a b \\<and>\n                                a \\<in> basisA \\<and> b \\<in> basisB) \\<and>\n                            (\\<forall>a'\\<in>basisA.\n                                (a' = a \\<longrightarrow>\n                                 Fa *\\<^sub>V a = b) \\<and>\n                                (a' \\<noteq> a \\<longrightarrow>\n                                 Fa *\\<^sub>V a' = (0::'b)))", "by (metis F_apply f_a f_not_a)"], ["proof (state)\nthis:\n  cspan basis = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "moreover"], ["proof (state)\nthis:\n  cspan basis = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "have \\<open>finite basis\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite basis", "unfolding basis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {F a b |a b. a \\<in> basisA \\<and> b \\<in> basisB}", "apply (rule finite_image_set2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite {a. a \\<in> basisA}\n 2. finite {b. b \\<in> basisB}", "by auto"], ["proof (state)\nthis:\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "ultimately"], ["proof (chain)\npicking this:\n  cspan basis = UNIV\n  finite basis", "show \\<open>\\<exists>S :: ('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) set. finite S \\<and> cspan S = UNIV\\<close>"], ["proof (prove)\nusing this:\n  cspan basis = UNIV\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "by auto"], ["proof (state)\nthis:\n  \\<exists>S. finite S \\<and> cspan S = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Relationship to real bounded operators (\\<^typ>\\<open>_ \\<Rightarrow>\\<^sub>L _\\<close>)\\<close>"], ["", "instantiation blinfun :: (real_normed_vector, complex_normed_vector) \"complex_normed_vector\"\nbegin"], ["", "lift_definition scaleC_blinfun :: \\<open>complex \\<Rightarrow>\n ('a::real_normed_vector, 'b::complex_normed_vector) blinfun \\<Rightarrow>\n ('a, 'b) blinfun\\<close>\n  is \\<open>\\<lambda> c::complex. \\<lambda> f::'a\\<Rightarrow>'b. (\\<lambda> x. c *\\<^sub>C (f x) )\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       bounded_linear (\\<lambda>x. complex *\\<^sub>C fun x)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>complex fun b1 b2.\n       bounded_linear fun \\<Longrightarrow>\n       complex *\\<^sub>C fun (b1 + b2) =\n       complex *\\<^sub>C fun b1 + complex *\\<^sub>C fun b2\n 2. \\<And>complex fun r b.\n       bounded_linear fun \\<Longrightarrow>\n       complex *\\<^sub>C fun (r *\\<^sub>R b) =\n       r *\\<^sub>R complex *\\<^sub>C fun b\n 3. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "fix c::complex and f :: \\<open>'a\\<Rightarrow>'b\\<close> and b1::'a and b2::'a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>complex fun b1 b2.\n       bounded_linear fun \\<Longrightarrow>\n       complex *\\<^sub>C fun (b1 + b2) =\n       complex *\\<^sub>C fun b1 + complex *\\<^sub>C fun b2\n 2. \\<And>complex fun r b.\n       bounded_linear fun \\<Longrightarrow>\n       complex *\\<^sub>C fun (r *\\<^sub>R b) =\n       r *\\<^sub>R complex *\\<^sub>C fun b\n 3. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "assume \\<open>bounded_linear f\\<close>"], ["proof (state)\nthis:\n  bounded_linear f\n\ngoal (3 subgoals):\n 1. \\<And>complex fun b1 b2.\n       bounded_linear fun \\<Longrightarrow>\n       complex *\\<^sub>C fun (b1 + b2) =\n       complex *\\<^sub>C fun b1 + complex *\\<^sub>C fun b2\n 2. \\<And>complex fun r b.\n       bounded_linear fun \\<Longrightarrow>\n       complex *\\<^sub>C fun (r *\\<^sub>R b) =\n       r *\\<^sub>R complex *\\<^sub>C fun b\n 3. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "show \\<open>c *\\<^sub>C f (b1 + b2) = c *\\<^sub>C f b1 + c *\\<^sub>C f b2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C f (b1 + b2) = c *\\<^sub>C f b1 + c *\\<^sub>C f b2", "by (simp add: \\<open>bounded_linear f\\<close> linear_simps scaleC_add_right)"], ["proof (state)\nthis:\n  c *\\<^sub>C f (b1 + b2) = c *\\<^sub>C f b1 + c *\\<^sub>C f b2\n\ngoal (2 subgoals):\n 1. \\<And>complex fun r b.\n       bounded_linear fun \\<Longrightarrow>\n       complex *\\<^sub>C fun (r *\\<^sub>R b) =\n       r *\\<^sub>R complex *\\<^sub>C fun b\n 2. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "fix c::complex and f :: \\<open>'a\\<Rightarrow>'b\\<close> and b::'a and r::real"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>complex fun r b.\n       bounded_linear fun \\<Longrightarrow>\n       complex *\\<^sub>C fun (r *\\<^sub>R b) =\n       r *\\<^sub>R complex *\\<^sub>C fun b\n 2. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "assume \\<open>bounded_linear f\\<close>"], ["proof (state)\nthis:\n  bounded_linear f\n\ngoal (2 subgoals):\n 1. \\<And>complex fun r b.\n       bounded_linear fun \\<Longrightarrow>\n       complex *\\<^sub>C fun (r *\\<^sub>R b) =\n       r *\\<^sub>R complex *\\<^sub>C fun b\n 2. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "show \\<open>c *\\<^sub>C f (r *\\<^sub>R b) = r *\\<^sub>R (c *\\<^sub>C f b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C f (r *\\<^sub>R b) = r *\\<^sub>R c *\\<^sub>C f b", "by (simp add: \\<open>bounded_linear f\\<close> linear_simps(5) scaleR_scaleC)"], ["proof (state)\nthis:\n  c *\\<^sub>C f (r *\\<^sub>R b) = r *\\<^sub>R c *\\<^sub>C f b\n\ngoal (1 subgoal):\n 1. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "fix c::complex and f :: \\<open>'a\\<Rightarrow>'b\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "assume \\<open>bounded_linear f\\<close>"], ["proof (state)\nthis:\n  bounded_linear f\n\ngoal (1 subgoal):\n 1. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "have \\<open>\\<exists> K. \\<forall> x. norm (f x) \\<le> norm x * K\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "using \\<open>bounded_linear f\\<close>"], ["proof (prove)\nusing this:\n  bounded_linear f\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "by (simp add: bounded_linear.bounded)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "then"], ["proof (chain)\npicking this:\n  \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "obtain K where \\<open>\\<forall> x. norm (f x) \\<le> norm x * K\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        \\<forall>x. norm (f x) \\<le> norm x * K \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. norm (f x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "have \\<open>cmod c \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cmod c", "by simp"], ["proof (state)\nthis:\n  0 \\<le> cmod c\n\ngoal (1 subgoal):\n 1. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "hence \\<open>\\<forall> x. (cmod c) * norm (f x) \\<le> (cmod c) * norm x * K\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> cmod c\n\ngoal (1 subgoal):\n 1. \\<forall>x. cmod c * norm (f x) \\<le> cmod c * norm x * K", "using  \\<open>\\<forall> x. norm (f x) \\<le> norm x * K\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> cmod c\n  \\<forall>x. norm (f x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. \\<forall>x. cmod c * norm (f x) \\<le> cmod c * norm x * K", "by (metis ordered_comm_semiring_class.comm_mult_left_mono vector_space_over_itself.scale_scale)"], ["proof (state)\nthis:\n  \\<forall>x. cmod c * norm (f x) \\<le> cmod c * norm x * K\n\ngoal (1 subgoal):\n 1. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "moreover"], ["proof (state)\nthis:\n  \\<forall>x. cmod c * norm (f x) \\<le> cmod c * norm x * K\n\ngoal (1 subgoal):\n 1. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "have \\<open>norm (c *\\<^sub>C f x) = (cmod c) * norm (f x)\\<close>\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (c *\\<^sub>C f x) = cmod c * norm (f x)", "by simp"], ["proof (state)\nthis:\n  norm (c *\\<^sub>C f ?x) = cmod c * norm (f ?x)\n\ngoal (1 subgoal):\n 1. \\<And>complex fun.\n       bounded_linear fun \\<Longrightarrow>\n       \\<exists>K.\n          \\<forall>x. norm (complex *\\<^sub>C fun x) \\<le> norm x * K", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x. cmod c * norm (f x) \\<le> cmod c * norm x * K\n  norm (c *\\<^sub>C f ?x) = cmod c * norm (f ?x)", "show \\<open>\\<exists>K. \\<forall>x. norm (c *\\<^sub>C f x) \\<le> norm x * K\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x. cmod c * norm (f x) \\<le> cmod c * norm x * K\n  norm (c *\\<^sub>C f ?x) = cmod c * norm (f ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (c *\\<^sub>C f x) \\<le> norm x * K", "by (metis ab_semigroup_mult_class.mult_ac(1) mult.commute)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>x. norm (c *\\<^sub>C f x) \\<le> norm x * K\n\ngoal:\nNo subgoals!", "qed"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>L 'b, complex_normed_vector_class)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 3. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 4. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 5. \\<And>x. 1 *\\<^sub>C x = x\n 6. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "have \"r *\\<^sub>R x = complex_of_real r *\\<^sub>C x\"\n    for x :: \"('a, 'b) blinfun\" and r"], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>R x = complex_of_real r *\\<^sub>C x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r x.\n       bounded_linear x \\<Longrightarrow>\n       (\\<lambda>xa. r *\\<^sub>R x xa) =\n       (\\<lambda>xa. complex_of_real r *\\<^sub>C x xa)", "by (simp add: scaleR_scaleC)"], ["proof (state)\nthis:\n  ?r *\\<^sub>R ?x = complex_of_real ?r *\\<^sub>C ?x\n\ngoal (6 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 3. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 4. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 5. \\<And>x. 1 *\\<^sub>C x = x\n 6. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "thus \"((*\\<^sub>R) r::'a \\<Rightarrow>\\<^sub>L 'b \\<Rightarrow> _) = (*\\<^sub>C) (complex_of_real r)\" for r"], ["proof (prove)\nusing this:\n  ?r *\\<^sub>R ?x = complex_of_real ?r *\\<^sub>C ?x\n\ngoal (1 subgoal):\n 1. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)", "by auto"], ["proof (state)\nthis:\n  (*\\<^sub>R) ?r = (*\\<^sub>C) (complex_of_real ?r)\n\ngoal (5 subgoals):\n 1. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 2. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 3. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 4. \\<And>x. 1 *\\<^sub>C x = x\n 5. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \"a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\"\n    for a :: complex and x y :: \"'a \\<Rightarrow>\\<^sub>L 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x y.\n       \\<lbrakk>bounded_linear x; bounded_linear y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>xa. a *\\<^sub>C (x xa + y xa)) =\n                         (\\<lambda>xa. a *\\<^sub>C x xa + a *\\<^sub>C y xa)", "by (simp add: scaleC_add_right)"], ["proof (state)\nthis:\n  ?a *\\<^sub>C (?x + ?y) = ?a *\\<^sub>C ?x + ?a *\\<^sub>C ?y\n\ngoal (4 subgoals):\n 1. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 2. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 3. \\<And>x. 1 *\\<^sub>C x = x\n 4. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \"(a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\"\n    for a b :: complex and x :: \"'a \\<Rightarrow>\\<^sub>L 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       bounded_linear x \\<Longrightarrow>\n       (\\<lambda>xa. (a + b) *\\<^sub>C x xa) =\n       (\\<lambda>xa. a *\\<^sub>C x xa + b *\\<^sub>C x xa)", "by (simp add: scaleC_add_left)"], ["proof (state)\nthis:\n  (?a + ?b) *\\<^sub>C ?x = ?a *\\<^sub>C ?x + ?b *\\<^sub>C ?x\n\ngoal (3 subgoals):\n 1. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 2. \\<And>x. 1 *\\<^sub>C x = x\n 3. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "show \"a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\"\n    for a b :: complex and x :: \"'a \\<Rightarrow>\\<^sub>L 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       bounded_linear x \\<Longrightarrow>\n       (\\<lambda>xa. a *\\<^sub>C b *\\<^sub>C x xa) =\n       (\\<lambda>xa. (a * b) *\\<^sub>C x xa)", "by simp"], ["proof (state)\nthis:\n  ?a *\\<^sub>C ?b *\\<^sub>C ?x = (?a * ?b) *\\<^sub>C ?x\n\ngoal (2 subgoals):\n 1. \\<And>x. 1 *\\<^sub>C x = x\n 2. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "have \\<open>1 *\\<^sub>C f x = f x\\<close>\n    for f :: \\<open>'a\\<Rightarrow>'b\\<close> and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 *\\<^sub>C f x = f x", "by auto"], ["proof (state)\nthis:\n  1 *\\<^sub>C ?f ?x = ?f ?x\n\ngoal (2 subgoals):\n 1. \\<And>x. 1 *\\<^sub>C x = x\n 2. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "thus \"1 *\\<^sub>C x = x\"\n    for x :: \"'a \\<Rightarrow>\\<^sub>L 'b\""], ["proof (prove)\nusing this:\n  1 *\\<^sub>C ?f ?x = ?f ?x\n\ngoal (1 subgoal):\n 1. 1 *\\<^sub>C x = x", "by (simp add: scaleC_blinfun.rep_eq blinfun_eqI)"], ["proof (state)\nthis:\n  1 *\\<^sub>C ?x = ?x\n\ngoal (1 subgoal):\n 1. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "have \\<open>onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f\\<close>\n    if \\<open>bounded_linear f\\<close>\n    for f :: \\<open>'a \\<Rightarrow> 'b\\<close> and a :: complex"], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have \\<open>cmod a \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cmod a", "by simp"], ["proof (state)\nthis:\n  0 \\<le> cmod a\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have \\<open>\\<exists> K::real. \\<forall> x. (\\<bar> ereal ((norm (f x)) / (norm x)) \\<bar>) \\<le> K\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>xa. \\<bar>ereal (norm (f xa) / norm xa)\\<bar> \\<le> ereal x", "using \\<open>bounded_linear f\\<close> le_onorm"], ["proof (prove)\nusing this:\n  bounded_linear f\n  bounded_linear ?f \\<Longrightarrow> norm (?f ?x) / norm ?x \\<le> onorm ?f\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>xa. \\<bar>ereal (norm (f xa) / norm xa)\\<bar> \\<le> ereal x", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>x.\n     \\<forall>xa. \\<bar>ereal (norm (f xa) / norm xa)\\<bar> \\<le> ereal x\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     \\<forall>xa. \\<bar>ereal (norm (f xa) / norm xa)\\<bar> \\<le> ereal x", "obtain K::real where \\<open>\\<forall> x. (\\<bar> ereal ((norm (f x)) / (norm x)) \\<bar>) \\<le> K\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     \\<forall>xa. \\<bar>ereal (norm (f xa) / norm xa)\\<bar> \\<le> ereal x\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        \\<forall>x.\n           \\<bar>ereal (norm (f x) / norm x)\\<bar>\n           \\<le> ereal K \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. \\<bar>ereal (norm (f x) / norm x)\\<bar> \\<le> ereal K\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "hence  \\<open>\\<forall> x. (cmod a) *(\\<bar> ereal ((norm (f x)) / (norm x)) \\<bar>) \\<le> (cmod a) * K\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<bar>ereal (norm (f x) / norm x)\\<bar> \\<le> ereal K\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ereal (cmod a) * \\<bar>ereal (norm (f x) / norm x)\\<bar>\n       \\<le> ereal (cmod a * K)", "using \\<open>cmod a \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<bar>ereal (norm (f x) / norm x)\\<bar> \\<le> ereal K\n  0 \\<le> cmod a\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ereal (cmod a) * \\<bar>ereal (norm (f x) / norm x)\\<bar>\n       \\<le> ereal (cmod a * K)", "by (metis abs_ereal.simps(1) abs_ereal_pos   abs_pos ereal_mult_left_mono  times_ereal.simps(1))"], ["proof (state)\nthis:\n  \\<forall>x.\n     ereal (cmod a) * \\<bar>ereal (norm (f x) / norm x)\\<bar>\n     \\<le> ereal (cmod a * K)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "hence  \\<open>\\<forall> x.  (\\<bar> ereal ((cmod a) * (norm (f x)) / (norm x)) \\<bar>) \\<le> (cmod a) * K\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     ereal (cmod a) * \\<bar>ereal (norm (f x) / norm x)\\<bar>\n     \\<le> ereal (cmod a * K)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<bar>ereal (cmod a * norm (f x) / norm x)\\<bar>\n       \\<le> ereal (cmod a * K)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x.\n     \\<bar>ereal (cmod a * norm (f x) / norm x)\\<bar>\n     \\<le> ereal (cmod a * K)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "hence \\<open>bdd_above {ereal (cmod a * (norm (f x)) / (norm x)) | x. True}\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     \\<bar>ereal (cmod a * norm (f x) / norm x)\\<bar>\n     \\<le> ereal (cmod a * K)\n\ngoal (1 subgoal):\n 1. bdd_above {ereal (cmod a * norm (f x) / norm x) |x. True}", "by simp"], ["proof (state)\nthis:\n  bdd_above {ereal (cmod a * norm (f x) / norm x) |x. True}\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "moreover"], ["proof (state)\nthis:\n  bdd_above {ereal (cmod a * norm (f x) / norm x) |x. True}\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have \\<open>{ereal (cmod a * (norm (f x)) / (norm x)) | x. True} \\<noteq> {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ereal (cmod a * norm (f x) / norm x) |x. True} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {ereal (cmod a * norm (f x) / norm x) |x. True} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "ultimately"], ["proof (chain)\npicking this:\n  bdd_above {ereal (cmod a * norm (f x) / norm x) |x. True}\n  {ereal (cmod a * norm (f x) / norm x) |x. True} \\<noteq> {}", "have p1: \\<open>(SUP x. \\<bar>ereal (cmod a * (norm (f x)) / (norm x))\\<bar>) \\<le> cmod a * K\\<close>"], ["proof (prove)\nusing this:\n  bdd_above {ereal (cmod a * norm (f x) / norm x) |x. True}\n  {ereal (cmod a * norm (f x) / norm x) |x. True} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (SUP x. \\<bar>ereal (cmod a * norm (f x) / norm x)\\<bar>)\n    \\<le> ereal (cmod a * K)", "using \\<open>\\<forall> x. \\<bar> ereal (cmod a * (norm (f x)) / (norm x)) \\<bar> \\<le> cmod a * K\\<close>\n        Sup_least mem_Collect_eq"], ["proof (prove)\nusing this:\n  bdd_above {ereal (cmod a * norm (f x) / norm x) |x. True}\n  {ereal (cmod a * norm (f x) / norm x) |x. True} \\<noteq> {}\n  \\<forall>x.\n     \\<bar>ereal (cmod a * norm (f x) / norm x)\\<bar>\n     \\<le> ereal (cmod a * K)\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<le> ?z) \\<Longrightarrow>\n  \\<Squnion> ?A \\<le> ?z\n  (?a \\<in> Collect ?P) = ?P ?a\n\ngoal (1 subgoal):\n 1. (SUP x. \\<bar>ereal (cmod a * norm (f x) / norm x)\\<bar>)\n    \\<le> ereal (cmod a * K)", "by (simp add: SUP_le_iff)"], ["proof (state)\nthis:\n  (SUP x. \\<bar>ereal (cmod a * norm (f x) / norm x)\\<bar>)\n  \\<le> ereal (cmod a * K)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have  p2: \\<open>\\<And>i. i \\<in> UNIV \\<Longrightarrow> 0 \\<le> ereal (cmod a * norm (f i) / norm i)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> UNIV \\<Longrightarrow>\n       0 \\<le> ereal (cmod a * norm (f i) / norm i)", "by simp"], ["proof (state)\nthis:\n  ?i \\<in> UNIV \\<Longrightarrow>\n  0 \\<le> ereal (cmod a * norm (f ?i) / norm ?i)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "hence \\<open>\\<bar>SUP x. ereal (cmod a * (norm (f x)) / (norm x))\\<bar>\n              \\<le> (SUP x. \\<bar>ereal (cmod a * (norm (f x)) / (norm x))\\<bar>)\\<close>"], ["proof (prove)\nusing this:\n  ?i \\<in> UNIV \\<Longrightarrow>\n  0 \\<le> ereal (cmod a * norm (f ?i) / norm ?i)\n\ngoal (1 subgoal):\n 1. \\<bar>SUP x. ereal (cmod a * norm (f x) / norm x)\\<bar>\n    \\<le> (SUP x. \\<bar>ereal (cmod a * norm (f x) / norm x)\\<bar>)", "using  \\<open>bdd_above {ereal (cmod a * (norm (f x)) / (norm x)) | x. True}\\<close>\n        \\<open>{ereal (cmod a * (norm (f x)) / (norm x)) | x. True} \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  ?i \\<in> UNIV \\<Longrightarrow>\n  0 \\<le> ereal (cmod a * norm (f ?i) / norm ?i)\n  bdd_above {ereal (cmod a * norm (f x) / norm x) |x. True}\n  {ereal (cmod a * norm (f x) / norm x) |x. True} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<bar>SUP x. ereal (cmod a * norm (f x) / norm x)\\<bar>\n    \\<le> (SUP x. \\<bar>ereal (cmod a * norm (f x) / norm x)\\<bar>)", "by (metis (mono_tags, lifting) SUP_upper2 Sup.SUP_cong UNIV_I \n          p2 abs_ereal_ge0 ereal_le_real)"], ["proof (state)\nthis:\n  \\<bar>SUP x. ereal (cmod a * norm (f x) / norm x)\\<bar>\n  \\<le> (SUP x. \\<bar>ereal (cmod a * norm (f x) / norm x)\\<bar>)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "hence \\<open>\\<bar>SUP x. ereal (cmod a * (norm (f x)) / (norm x))\\<bar> \\<le> cmod a * K\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>SUP x. ereal (cmod a * norm (f x) / norm x)\\<bar>\n  \\<le> (SUP x. \\<bar>ereal (cmod a * norm (f x) / norm x)\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<bar>SUP x. ereal (cmod a * norm (f x) / norm x)\\<bar>\n    \\<le> ereal (cmod a * K)", "using  \\<open>(SUP x. \\<bar>ereal (cmod a * (norm (f x)) / (norm x))\\<bar>) \\<le> cmod a * K\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>SUP x. ereal (cmod a * norm (f x) / norm x)\\<bar>\n  \\<le> (SUP x. \\<bar>ereal (cmod a * norm (f x) / norm x)\\<bar>)\n  (SUP x. \\<bar>ereal (cmod a * norm (f x) / norm x)\\<bar>)\n  \\<le> ereal (cmod a * K)\n\ngoal (1 subgoal):\n 1. \\<bar>SUP x. ereal (cmod a * norm (f x) / norm x)\\<bar>\n    \\<le> ereal (cmod a * K)", "by simp"], ["proof (state)\nthis:\n  \\<bar>SUP x. ereal (cmod a * norm (f x) / norm x)\\<bar>\n  \\<le> ereal (cmod a * K)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "hence \\<open>\\<bar> ( SUP i\\<in>UNIV::'a set. ereal ((\\<lambda> x. (cmod a) * (norm (f x)) / norm x) i)) \\<bar> \\<noteq> \\<infinity>\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>SUP x. ereal (cmod a * norm (f x) / norm x)\\<bar>\n  \\<le> ereal (cmod a * K)\n\ngoal (1 subgoal):\n 1. \\<bar>SUP i. ereal (cmod a * norm (f i) / norm i)\\<bar> \\<noteq>\n    \\<infinity>", "by auto"], ["proof (state)\nthis:\n  \\<bar>SUP i. ereal (cmod a * norm (f i) / norm i)\\<bar> \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "hence w2: \\<open>( SUP i\\<in>UNIV::'a set. ereal ((\\<lambda> x. cmod a * (norm (f x)) / norm x) i))\n             = ereal ( Sup ((\\<lambda> x. cmod a * (norm (f x)) / norm x) ` (UNIV::'a set) ))\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>SUP i. ereal (cmod a * norm (f i) / norm i)\\<bar> \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. (SUP i. ereal (cmod a * norm (f i) / norm i)) =\n    ereal (SUP x. cmod a * norm (f x) / norm x)", "by (simp add: ereal_SUP)"], ["proof (state)\nthis:\n  (SUP i. ereal (cmod a * norm (f i) / norm i)) =\n  ereal (SUP x. cmod a * norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have \\<open>(UNIV::('a set)) \\<noteq> {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  UNIV \\<noteq> {}\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "moreover"], ["proof (state)\nthis:\n  UNIV \\<noteq> {}\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have \\<open>\\<And> i. i \\<in> (UNIV::('a set)) \\<Longrightarrow> (\\<lambda> x. (norm (f x)) / norm x :: ereal) i \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> UNIV \\<Longrightarrow> 0 \\<le> ereal (norm (f i) / norm i)", "by simp"], ["proof (state)\nthis:\n  ?i \\<in> UNIV \\<Longrightarrow> 0 \\<le> ereal (norm (f ?i) / norm ?i)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "moreover"], ["proof (state)\nthis:\n  ?i \\<in> UNIV \\<Longrightarrow> 0 \\<le> ereal (norm (f ?i) / norm ?i)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have \\<open>cmod a \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cmod a", "by simp"], ["proof (state)\nthis:\n  0 \\<le> cmod a\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "ultimately"], ["proof (chain)\npicking this:\n  UNIV \\<noteq> {}\n  ?i \\<in> UNIV \\<Longrightarrow> 0 \\<le> ereal (norm (f ?i) / norm ?i)\n  0 \\<le> cmod a", "have \\<open>(SUP i\\<in>(UNIV::('a set)). ((cmod a)::ereal) * (\\<lambda> x. (norm (f x)) / norm x :: ereal) i ) \n        = ((cmod a)::ereal) * ( SUP i\\<in>(UNIV::('a set)). (\\<lambda> x. (norm (f x)) / norm x :: ereal) i )\\<close>"], ["proof (prove)\nusing this:\n  UNIV \\<noteq> {}\n  ?i \\<in> UNIV \\<Longrightarrow> 0 \\<le> ereal (norm (f ?i) / norm ?i)\n  0 \\<le> cmod a\n\ngoal (1 subgoal):\n 1. (SUP i. ereal (cmod a) * ereal (norm (f i) / norm i)) =\n    ereal (cmod a) * (SUP i. ereal (norm (f i) / norm i))", "by (simp add: Sup_ereal_mult_left')"], ["proof (state)\nthis:\n  (SUP i. ereal (cmod a) * ereal (norm (f i) / norm i)) =\n  ereal (cmod a) * (SUP i. ereal (norm (f i) / norm i))\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "hence \\<open>(SUP x. ((cmod a)::ereal) * ( (norm (f x)) / norm x :: ereal) ) \n        = ((cmod a)::ereal) * ( SUP x. ( (norm (f x)) / norm x :: ereal) )\\<close>"], ["proof (prove)\nusing this:\n  (SUP i. ereal (cmod a) * ereal (norm (f i) / norm i)) =\n  ereal (cmod a) * (SUP i. ereal (norm (f i) / norm i))\n\ngoal (1 subgoal):\n 1. (SUP x. ereal (cmod a) * ereal (norm (f x) / norm x)) =\n    ereal (cmod a) * (SUP x. ereal (norm (f x) / norm x))", "by simp"], ["proof (state)\nthis:\n  (SUP x. ereal (cmod a) * ereal (norm (f x) / norm x)) =\n  ereal (cmod a) * (SUP x. ereal (norm (f x) / norm x))\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "hence z1: \\<open>real_of_ereal ( (SUP x. ((cmod a)::ereal) * ( (norm (f x)) / norm x :: ereal) ) )\n        = real_of_ereal ( ((cmod a)::ereal) * ( SUP x. ( (norm (f x)) / norm x :: ereal) ) )\\<close>"], ["proof (prove)\nusing this:\n  (SUP x. ereal (cmod a) * ereal (norm (f x) / norm x)) =\n  ereal (cmod a) * (SUP x. ereal (norm (f x) / norm x))\n\ngoal (1 subgoal):\n 1. real_of_ereal (SUP x. ereal (cmod a) * ereal (norm (f x) / norm x)) =\n    real_of_ereal (ereal (cmod a) * (SUP x. ereal (norm (f x) / norm x)))", "by simp"], ["proof (state)\nthis:\n  real_of_ereal (SUP x. ereal (cmod a) * ereal (norm (f x) / norm x)) =\n  real_of_ereal (ereal (cmod a) * (SUP x. ereal (norm (f x) / norm x)))\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have z2: \\<open>real_of_ereal (SUP x. ((cmod a)::ereal) * ( (norm (f x)) / norm x :: ereal) ) \n                  = (SUP x. cmod a * (norm (f x) / norm x))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_ereal (SUP x. ereal (cmod a) * ereal (norm (f x) / norm x)) =\n    (SUP x. cmod a * (norm (f x) / norm x))", "using w2"], ["proof (prove)\nusing this:\n  (SUP i. ereal (cmod a * norm (f i) / norm i)) =\n  ereal (SUP x. cmod a * norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. real_of_ereal (SUP x. ereal (cmod a) * ereal (norm (f x) / norm x)) =\n    (SUP x. cmod a * (norm (f x) / norm x))", "by auto"], ["proof (state)\nthis:\n  real_of_ereal (SUP x. ereal (cmod a) * ereal (norm (f x) / norm x)) =\n  (SUP x. cmod a * (norm (f x) / norm x))\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have \\<open>real_of_ereal ( ((cmod a)::ereal) * ( SUP x. ( (norm (f x)) / norm x :: ereal) ) )\n                =  (cmod a) * real_of_ereal ( SUP x. ( (norm (f x)) / norm x :: ereal) )\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_ereal (ereal (cmod a) * (SUP x. ereal (norm (f x) / norm x))) =\n    cmod a * real_of_ereal (SUP x. ereal (norm (f x) / norm x))", "by simp"], ["proof (state)\nthis:\n  real_of_ereal (ereal (cmod a) * (SUP x. ereal (norm (f x) / norm x))) =\n  cmod a * real_of_ereal (SUP x. ereal (norm (f x) / norm x))\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "moreover"], ["proof (state)\nthis:\n  real_of_ereal (ereal (cmod a) * (SUP x. ereal (norm (f x) / norm x))) =\n  cmod a * real_of_ereal (SUP x. ereal (norm (f x) / norm x))\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have \\<open>real_of_ereal ( SUP x. ( (norm (f x)) / norm x :: ereal) )\n                  = ( SUP x. ((norm (f x)) / norm x) )\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_ereal (SUP x. ereal (norm (f x) / norm x)) =\n    (SUP x. norm (f x) / norm x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_ereal (SUP x. ereal (norm (f x) / norm x)) =\n    (SUP x. norm (f x) / norm x)", "have \\<open>\\<bar> ( SUP i\\<in>UNIV::'a set. ereal ((\\<lambda> x. (norm (f x)) / norm x) i)) \\<bar> \\<noteq> \\<infinity>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>", "have \\<open>\\<exists> K::real. \\<forall> x. (\\<bar> ereal ((norm (f x)) / (norm x)) \\<bar>) \\<le> K\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>xa. \\<bar>ereal (norm (f xa) / norm xa)\\<bar> \\<le> ereal x", "using \\<open>bounded_linear f\\<close> le_onorm"], ["proof (prove)\nusing this:\n  bounded_linear f\n  bounded_linear ?f \\<Longrightarrow> norm (?f ?x) / norm ?x \\<le> onorm ?f\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       \\<forall>xa. \\<bar>ereal (norm (f xa) / norm xa)\\<bar> \\<le> ereal x", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>x.\n     \\<forall>xa. \\<bar>ereal (norm (f xa) / norm xa)\\<bar> \\<le> ereal x\n\ngoal (1 subgoal):\n 1. \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     \\<forall>xa. \\<bar>ereal (norm (f xa) / norm xa)\\<bar> \\<le> ereal x", "obtain K::real where \\<open>\\<forall> x. (\\<bar> ereal ((norm (f x)) / (norm x)) \\<bar>) \\<le> K\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     \\<forall>xa. \\<bar>ereal (norm (f xa) / norm xa)\\<bar> \\<le> ereal x\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        \\<forall>x.\n           \\<bar>ereal (norm (f x) / norm x)\\<bar>\n           \\<le> ereal K \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. \\<bar>ereal (norm (f x) / norm x)\\<bar> \\<le> ereal K\n\ngoal (1 subgoal):\n 1. \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>", "hence \\<open>bdd_above {ereal ((norm (f x)) / (norm x)) | x. True}\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<bar>ereal (norm (f x) / norm x)\\<bar> \\<le> ereal K\n\ngoal (1 subgoal):\n 1. bdd_above {ereal (norm (f x) / norm x) |x. True}", "by simp"], ["proof (state)\nthis:\n  bdd_above {ereal (norm (f x) / norm x) |x. True}\n\ngoal (1 subgoal):\n 1. \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>", "moreover"], ["proof (state)\nthis:\n  bdd_above {ereal (norm (f x) / norm x) |x. True}\n\ngoal (1 subgoal):\n 1. \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>", "have \\<open>{ereal ((norm (f x)) / (norm x)) | x. True} \\<noteq> {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ereal (norm (f x) / norm x) |x. True} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {ereal (norm (f x) / norm x) |x. True} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>", "ultimately"], ["proof (chain)\npicking this:\n  bdd_above {ereal (norm (f x) / norm x) |x. True}\n  {ereal (norm (f x) / norm x) |x. True} \\<noteq> {}", "have \\<open>(SUP x. \\<bar>ereal ((norm (f x)) / (norm x))\\<bar>) \\<le> K\\<close>"], ["proof (prove)\nusing this:\n  bdd_above {ereal (norm (f x) / norm x) |x. True}\n  {ereal (norm (f x) / norm x) |x. True} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (SUP x. \\<bar>ereal (norm (f x) / norm x)\\<bar>) \\<le> ereal K", "using \\<open>\\<forall> x. \\<bar> ereal ((norm (f x)) / (norm x)) \\<bar> \\<le> K\\<close>\n            Sup_least mem_Collect_eq"], ["proof (prove)\nusing this:\n  bdd_above {ereal (norm (f x) / norm x) |x. True}\n  {ereal (norm (f x) / norm x) |x. True} \\<noteq> {}\n  \\<forall>x. \\<bar>ereal (norm (f x) / norm x)\\<bar> \\<le> ereal K\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<le> ?z) \\<Longrightarrow>\n  \\<Squnion> ?A \\<le> ?z\n  (?a \\<in> Collect ?P) = ?P ?a\n\ngoal (1 subgoal):\n 1. (SUP x. \\<bar>ereal (norm (f x) / norm x)\\<bar>) \\<le> ereal K", "by (simp add: SUP_le_iff)"], ["proof (state)\nthis:\n  (SUP x. \\<bar>ereal (norm (f x) / norm x)\\<bar>) \\<le> ereal K\n\ngoal (1 subgoal):\n 1. \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>", "hence \\<open>\\<bar>SUP x. ereal ((norm (f x)) / (norm x))\\<bar>\n              \\<le> (SUP x. \\<bar>ereal ((norm (f x)) / (norm x))\\<bar>)\\<close>"], ["proof (prove)\nusing this:\n  (SUP x. \\<bar>ereal (norm (f x) / norm x)\\<bar>) \\<le> ereal K\n\ngoal (1 subgoal):\n 1. \\<bar>SUP x. ereal (norm (f x) / norm x)\\<bar>\n    \\<le> (SUP x. \\<bar>ereal (norm (f x) / norm x)\\<bar>)", "using  \\<open>bdd_above {ereal ((norm (f x)) / (norm x)) | x. True}\\<close>\n            \\<open>{ereal ((norm (f x)) / (norm x)) | x. True} \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  (SUP x. \\<bar>ereal (norm (f x) / norm x)\\<bar>) \\<le> ereal K\n  bdd_above {ereal (norm (f x) / norm x) |x. True}\n  {ereal (norm (f x) / norm x) |x. True} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<bar>SUP x. ereal (norm (f x) / norm x)\\<bar>\n    \\<le> (SUP x. \\<bar>ereal (norm (f x) / norm x)\\<bar>)", "by (metis (mono_tags, lifting) SUP_upper2 Sup.SUP_cong UNIV_I \\<open>\\<And>i. i \\<in> UNIV \\<Longrightarrow> 0 \\<le> ereal (norm (f i) / norm i)\\<close> abs_ereal_ge0 ereal_le_real)"], ["proof (state)\nthis:\n  \\<bar>SUP x. ereal (norm (f x) / norm x)\\<bar>\n  \\<le> (SUP x. \\<bar>ereal (norm (f x) / norm x)\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>", "hence \\<open>\\<bar>SUP x. ereal ((norm (f x)) / (norm x))\\<bar> \\<le> K\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>SUP x. ereal (norm (f x) / norm x)\\<bar>\n  \\<le> (SUP x. \\<bar>ereal (norm (f x) / norm x)\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<bar>SUP x. ereal (norm (f x) / norm x)\\<bar> \\<le> ereal K", "using  \\<open>(SUP x. \\<bar>ereal ((norm (f x)) / (norm x))\\<bar>) \\<le> K\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>SUP x. ereal (norm (f x) / norm x)\\<bar>\n  \\<le> (SUP x. \\<bar>ereal (norm (f x) / norm x)\\<bar>)\n  (SUP x. \\<bar>ereal (norm (f x) / norm x)\\<bar>) \\<le> ereal K\n\ngoal (1 subgoal):\n 1. \\<bar>SUP x. ereal (norm (f x) / norm x)\\<bar> \\<le> ereal K", "by simp"], ["proof (state)\nthis:\n  \\<bar>SUP x. ereal (norm (f x) / norm x)\\<bar> \\<le> ereal K\n\ngoal (1 subgoal):\n 1. \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>SUP x. ereal (norm (f x) / norm x)\\<bar> \\<le> ereal K\n\ngoal (1 subgoal):\n 1. \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. real_of_ereal (SUP x. ereal (norm (f x) / norm x)) =\n    (SUP x. norm (f x) / norm x)", "hence \\<open> ( SUP i\\<in>UNIV::'a set. ereal ((\\<lambda> x. (norm (f x)) / norm x) i))\n             = ereal ( Sup ((\\<lambda> x. (norm (f x)) / norm x) ` (UNIV::'a set) ))\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>SUP i. ereal (norm (f i) / norm i)\\<bar> \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (SUP i. ereal (norm (f i) / norm i)) =\n    ereal (SUP x. norm (f x) / norm x)", "by (simp add: ereal_SUP)"], ["proof (state)\nthis:\n  (SUP i. ereal (norm (f i) / norm i)) = ereal (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. real_of_ereal (SUP x. ereal (norm (f x) / norm x)) =\n    (SUP x. norm (f x) / norm x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (SUP i. ereal (norm (f i) / norm i)) = ereal (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. real_of_ereal (SUP x. ereal (norm (f x) / norm x)) =\n    (SUP x. norm (f x) / norm x)", "by simp"], ["proof (state)\nthis:\n  real_of_ereal (SUP x. ereal (norm (f x) / norm x)) =\n  (SUP x. norm (f x) / norm x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_ereal (SUP x. ereal (norm (f x) / norm x)) =\n  (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have z3: \\<open>real_of_ereal ( ((cmod a)::ereal) * ( SUP x. ( (norm (f x)) / norm x :: ereal) ) )\n                = cmod a * (SUP x. norm (f x) / norm x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_ereal (ereal (cmod a) * (SUP x. ereal (norm (f x) / norm x))) =\n    cmod a * (SUP x. norm (f x) / norm x)", "by (simp add: \\<open>real_of_ereal (SUP x. ereal (norm (f x) / norm x)) = (SUP x. norm (f x) / norm x)\\<close>)"], ["proof (state)\nthis:\n  real_of_ereal (ereal (cmod a) * (SUP x. ereal (norm (f x) / norm x))) =\n  cmod a * (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "hence w1: \\<open>(SUP x. cmod a * (norm (f x) / norm x)) =\n          cmod a * (SUP x. norm (f x) / norm x)\\<close>"], ["proof (prove)\nusing this:\n  real_of_ereal (ereal (cmod a) * (SUP x. ereal (norm (f x) / norm x))) =\n  cmod a * (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. (SUP x. cmod a * (norm (f x) / norm x)) =\n    cmod a * (SUP x. norm (f x) / norm x)", "using z1 z2"], ["proof (prove)\nusing this:\n  real_of_ereal (ereal (cmod a) * (SUP x. ereal (norm (f x) / norm x))) =\n  cmod a * (SUP x. norm (f x) / norm x)\n  real_of_ereal (SUP x. ereal (cmod a) * ereal (norm (f x) / norm x)) =\n  real_of_ereal (ereal (cmod a) * (SUP x. ereal (norm (f x) / norm x)))\n  real_of_ereal (SUP x. ereal (cmod a) * ereal (norm (f x) / norm x)) =\n  (SUP x. cmod a * (norm (f x) / norm x))\n\ngoal (1 subgoal):\n 1. (SUP x. cmod a * (norm (f x) / norm x)) =\n    cmod a * (SUP x. norm (f x) / norm x)", "by linarith"], ["proof (state)\nthis:\n  (SUP x. cmod a * (norm (f x) / norm x)) =\n  cmod a * (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have v1: \\<open>onorm (\\<lambda>x. a *\\<^sub>C f x) = (SUP x. norm (a *\\<^sub>C f x) / norm x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) =\n    (SUP x. norm (a *\\<^sub>C f x) / norm x)", "by (simp add: onorm_def)"], ["proof (state)\nthis:\n  onorm (\\<lambda>x. a *\\<^sub>C f x) =\n  (SUP x. norm (a *\\<^sub>C f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have v2: \\<open>(SUP x. norm (a *\\<^sub>C f x) / norm x) = (SUP x. ((cmod a) * norm (f x)) / norm x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP x. norm (a *\\<^sub>C f x) / norm x) =\n    (SUP x. cmod a * norm (f x) / norm x)", "by simp"], ["proof (state)\nthis:\n  (SUP x. norm (a *\\<^sub>C f x) / norm x) =\n  (SUP x. cmod a * norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have v3: \\<open>(SUP x. ((cmod a) * norm (f x)) / norm x) =  (SUP x. (cmod a) * ((norm (f x)) / norm x))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP x. cmod a * norm (f x) / norm x) =\n    (SUP x. cmod a * (norm (f x) / norm x))", "by simp"], ["proof (state)\nthis:\n  (SUP x. cmod a * norm (f x) / norm x) =\n  (SUP x. cmod a * (norm (f x) / norm x))\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "have v4: \\<open>(SUP x. (cmod a) * ((norm (f x)) / norm x)) = (cmod a) *  (SUP x. ((norm (f x)) / norm x))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP x. cmod a * (norm (f x) / norm x)) =\n    cmod a * (SUP x. norm (f x) / norm x)", "using w1"], ["proof (prove)\nusing this:\n  (SUP x. cmod a * (norm (f x) / norm x)) =\n  cmod a * (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. (SUP x. cmod a * (norm (f x) / norm x)) =\n    cmod a * (SUP x. norm (f x) / norm x)", "by blast"], ["proof (state)\nthis:\n  (SUP x. cmod a * (norm (f x) / norm x)) =\n  cmod a * (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "show \\<open>onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "using v1 v2 v3 v4"], ["proof (prove)\nusing this:\n  onorm (\\<lambda>x. a *\\<^sub>C f x) =\n  (SUP x. norm (a *\\<^sub>C f x) / norm x)\n  (SUP x. norm (a *\\<^sub>C f x) / norm x) =\n  (SUP x. cmod a * norm (f x) / norm x)\n  (SUP x. cmod a * norm (f x) / norm x) =\n  (SUP x. cmod a * (norm (f x) / norm x))\n  (SUP x. cmod a * (norm (f x) / norm x)) =\n  cmod a * (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f", "by (metis (mono_tags, lifting) onorm_def)"], ["proof (state)\nthis:\n  onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bounded_linear ?f \\<Longrightarrow>\n  onorm (\\<lambda>x. ?a *\\<^sub>C ?f x) = cmod ?a * onorm ?f\n\ngoal (1 subgoal):\n 1. \\<And>a x. norm (a *\\<^sub>C x) = cmod a * norm x", "thus \\<open>norm (a *\\<^sub>C x) = cmod a * norm x\\<close> \n    for a::complex and x::\\<open>('a, 'b) blinfun\\<close>"], ["proof (prove)\nusing this:\n  bounded_linear ?f \\<Longrightarrow>\n  onorm (\\<lambda>x. ?a *\\<^sub>C ?f x) = cmod ?a * onorm ?f\n\ngoal (1 subgoal):\n 1. norm (a *\\<^sub>C x) = cmod a * norm x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       \\<lbrakk>\\<And>f a.\n                   bounded_linear f \\<Longrightarrow>\n                   onorm (\\<lambda>x. a *\\<^sub>C f x) = cmod a * onorm f;\n        bounded_linear x\\<rbrakk>\n       \\<Longrightarrow> onorm (\\<lambda>xa. a *\\<^sub>C x xa) =\n                         cmod a * onorm x", "by blast"], ["proof (state)\nthis:\n  norm (?a *\\<^sub>C ?x) = cmod ?a * norm ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* We do not have clinear_blinfun_compose_right *)"], ["", "lemma clinear_blinfun_compose_left: \\<open>clinear (\\<lambda>x. blinfun_compose x y)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear (\\<lambda>x. x o\\<^sub>L y)", "by (auto intro!: clinearI simp: blinfun_eqI scaleC_blinfun.rep_eq bounded_bilinear.add_left\n                                  bounded_bilinear_blinfun_compose)"], ["", "instantiation blinfun :: (real_normed_vector, cbanach) \"cbanach\"\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>L 'b, cbanach_class)", ".."], ["", "end"], ["", "lemma blinfun_compose_assoc: \"(A o\\<^sub>L B) o\\<^sub>L C = A o\\<^sub>L (B  o\\<^sub>L C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A o\\<^sub>L B o\\<^sub>L C = A o\\<^sub>L (B o\\<^sub>L C)", "by (simp add: blinfun_eqI)"], ["", "lift_definition blinfun_of_cblinfun::\\<open>'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector \n  \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>L 'b\\<close> is \"id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. bounded_clinear fun \\<Longrightarrow> bounded_linear (id fun)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun. bounded_clinear fun \\<Longrightarrow> bounded_linear (id fun)", "by (simp add: bounded_clinear.bounded_linear)"], ["", "lift_definition blinfun_cblinfun_eq :: \n  \\<open>'a \\<Rightarrow>\\<^sub>L 'b \\<Rightarrow> 'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector \\<Rightarrow> bool\\<close> is \"(=)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma blinfun_cblinfun_eq_bi_unique[transfer_rule]: \\<open>bi_unique blinfun_cblinfun_eq\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique blinfun_cblinfun_eq", "unfolding bi_unique_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        blinfun_cblinfun_eq x y \\<longrightarrow>\n        blinfun_cblinfun_eq x z \\<longrightarrow> y = z) \\<and>\n    (\\<forall>x y z.\n        blinfun_cblinfun_eq x z \\<longrightarrow>\n        blinfun_cblinfun_eq y z \\<longrightarrow> x = y)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{f. bounded_linear f}.\n        \\<forall>y\\<in>{f. bounded_clinear f}.\n           \\<forall>z\\<in>{f. bounded_clinear f}.\n              x = y \\<longrightarrow> x = z \\<longrightarrow> y = z) \\<and>\n    (\\<forall>x\\<in>{f. bounded_linear f}.\n        \\<forall>y\\<in>{f. bounded_linear f}.\n           \\<forall>z\\<in>{f. bounded_clinear f}.\n              x = z \\<longrightarrow> y = z \\<longrightarrow> x = y)", "by auto"], ["", "lemma blinfun_cblinfun_eq_right_total[transfer_rule]: \\<open>right_total blinfun_cblinfun_eq\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total blinfun_cblinfun_eq", "unfolding right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. blinfun_cblinfun_eq x y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>{f. bounded_clinear f}.\n       \\<exists>x\\<in>{f. bounded_linear f}. x = y", "by (simp add: bounded_clinear.bounded_linear)"], ["", "named_theorems cblinfun_blinfun_transfer"], ["", "lemma cblinfun_blinfun_transfer_0[cblinfun_blinfun_transfer]:\n  \"blinfun_cblinfun_eq (0::(_,_) blinfun) (0::(_,_) cblinfun)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_cblinfun_eq 0 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. 0::'b) = (\\<lambda>x. 0::'b)", "by simp"], ["", "lemma cblinfun_blinfun_transfer_plus[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) (+) (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq)\n     (+) (+)", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       blinfun_cblinfun_eq x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           blinfun_cblinfun_eq xa ya \\<longrightarrow>\n           blinfun_cblinfun_eq (x + xa) (y + ya))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{f. bounded_linear f}.\n       \\<forall>y\\<in>{f. bounded_clinear f}.\n          x = y \\<longrightarrow>\n          (\\<forall>xa\\<in>{f. bounded_linear f}.\n              \\<forall>ya\\<in>{f. bounded_clinear f}.\n                 xa = ya \\<longrightarrow>\n                 (\\<lambda>xb. x xb + xa xb) = (\\<lambda>x. y x + ya x))", "by auto"], ["", "lemma cblinfun_blinfun_transfer_minus[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) (-) (-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq)\n     (-) (-)", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       blinfun_cblinfun_eq x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           blinfun_cblinfun_eq xa ya \\<longrightarrow>\n           blinfun_cblinfun_eq (x - xa) (y - ya))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{f. bounded_linear f}.\n       \\<forall>y\\<in>{f. bounded_clinear f}.\n          x = y \\<longrightarrow>\n          (\\<forall>xa\\<in>{f. bounded_linear f}.\n              \\<forall>ya\\<in>{f. bounded_clinear f}.\n                 xa = ya \\<longrightarrow>\n                 (\\<lambda>xb. x xb - xa xb) = (\\<lambda>x. y x - ya x))", "by auto"], ["", "lemma cblinfun_blinfun_transfer_uminus[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) (uminus) (uminus)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) uminus uminus", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       blinfun_cblinfun_eq x y \\<longrightarrow>\n       blinfun_cblinfun_eq (- x) (- y)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{f. bounded_linear f}.\n       \\<forall>y\\<in>{f. bounded_clinear f}.\n          x = y \\<longrightarrow>\n          (\\<lambda>xa. - x xa) = (\\<lambda>x. - y x)", "by auto"], ["", "definition \"real_complex_eq r c \\<longleftrightarrow> complex_of_real r = c\""], ["", "lemma bi_unique_real_complex_eq[transfer_rule]: \\<open>bi_unique real_complex_eq\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique real_complex_eq", "unfolding real_complex_eq_def bi_unique_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        complex_of_real x = y \\<longrightarrow>\n        complex_of_real x = z \\<longrightarrow> y = z) \\<and>\n    (\\<forall>x y z.\n        complex_of_real x = z \\<longrightarrow>\n        complex_of_real y = z \\<longrightarrow> x = y)", "by auto"], ["", "lemma left_total_real_complex_eq[transfer_rule]: \\<open>left_total real_complex_eq\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. left_total real_complex_eq", "unfolding real_complex_eq_def left_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Ex ((=) (complex_of_real x))", "by auto"], ["", "lemma cblinfun_blinfun_transfer_scaleC[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(real_complex_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) (scaleR) (scaleC)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real_complex_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq)\n     (*\\<^sub>R) (*\\<^sub>C)", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       real_complex_eq x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           blinfun_cblinfun_eq xa ya \\<longrightarrow>\n           blinfun_cblinfun_eq (x *\\<^sub>R xa) (y *\\<^sub>C ya))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       real_complex_eq x y \\<longrightarrow>\n       (\\<forall>xa\\<in>{f. bounded_linear f}.\n           \\<forall>ya\\<in>{f. bounded_clinear f}.\n              xa = ya \\<longrightarrow>\n              (\\<lambda>xb. x *\\<^sub>R xa xb) =\n              (\\<lambda>x. y *\\<^sub>C ya x))", "by (simp add: real_complex_eq_def scaleR_scaleC)"], ["", "lemma cblinfun_blinfun_transfer_CBlinfun[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(eq_onp bounded_clinear ===> blinfun_cblinfun_eq) Blinfun CBlinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq_onp bounded_clinear ===> blinfun_cblinfun_eq) Blinfun CBlinfun", "unfolding rel_fun_def blinfun_cblinfun_eq.rep_eq eq_onp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       bounded_clinear x \\<and> x = y \\<longrightarrow>\n       (*\\<^sub>v) (Blinfun x) = (*\\<^sub>V) (CBlinfun y)", "by (auto simp: CBlinfun_inverse Blinfun_inverse bounded_clinear.bounded_linear)"], ["", "lemma cblinfun_blinfun_transfer_norm[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> (=)) norm norm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (blinfun_cblinfun_eq ===> (=)) norm norm", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. blinfun_cblinfun_eq x y \\<longrightarrow> norm x = norm y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{f. bounded_linear f}.\n       \\<forall>y\\<in>{f. bounded_clinear f}.\n          x = y \\<longrightarrow> onorm x = onorm y", "by auto"], ["", "lemma cblinfun_blinfun_transfer_dist[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> (=)) dist dist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> (=)) dist dist", "unfolding rel_fun_def dist_norm"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       blinfun_cblinfun_eq x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           blinfun_cblinfun_eq xa ya \\<longrightarrow>\n           norm (x - xa) = norm (y - ya))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{f. bounded_linear f}.\n       \\<forall>y\\<in>{f. bounded_clinear f}.\n          x = y \\<longrightarrow>\n          (\\<forall>xa\\<in>{f. bounded_linear f}.\n              \\<forall>ya\\<in>{f. bounded_clinear f}.\n                 xa = ya \\<longrightarrow>\n                 onorm (\\<lambda>xb. x xb - xa xb) =\n                 onorm (\\<lambda>x. y x - ya x))", "by auto"], ["", "lemma cblinfun_blinfun_transfer_sgn[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) sgn sgn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) sgn sgn", "unfolding rel_fun_def sgn_blinfun_def sgn_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       blinfun_cblinfun_eq x y \\<longrightarrow>\n       blinfun_cblinfun_eq (x /\\<^sub>R norm x)\n        (complex_of_real (inverse (norm y)) *\\<^sub>C y)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{f. bounded_linear f}.\n       \\<forall>y\\<in>{f. bounded_clinear f}.\n          x = y \\<longrightarrow>\n          (\\<lambda>xa. x xa /\\<^sub>R onorm x) =\n          (\\<lambda>x. complex_of_real (inverse (onorm y)) *\\<^sub>C y x)", "by (auto simp: scaleR_scaleC)"], ["", "lemma cblinfun_blinfun_transfer_Cauchy[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(((=) ===> blinfun_cblinfun_eq) ===> (=)) Cauchy Cauchy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> blinfun_cblinfun_eq) ===> (=)) Cauchy Cauchy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (((=) ===> blinfun_cblinfun_eq) ===> (=)) Cauchy Cauchy", "note cblinfun_blinfun_transfer[transfer_rule]"], ["proof (state)\nthis:\n  blinfun_cblinfun_eq 0 0\n  (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq)\n   (+) (+)\n  (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq)\n   (-) (-)\n  (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) uminus uminus\n  (real_complex_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq)\n   (*\\<^sub>R) (*\\<^sub>C)\n  (eq_onp bounded_clinear ===> blinfun_cblinfun_eq) Blinfun CBlinfun\n  (blinfun_cblinfun_eq ===> (=)) norm norm\n  (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> (=)) dist dist\n  (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) sgn sgn\n\ngoal (1 subgoal):\n 1. (((=) ===> blinfun_cblinfun_eq) ===> (=)) Cauchy Cauchy", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> blinfun_cblinfun_eq) ===> (=)) Cauchy Cauchy", "unfolding Cauchy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> blinfun_cblinfun_eq) ===> (=))\n     (\\<lambda>X.\n         \\<forall>e>0.\n            \\<exists>M.\n               \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (X m) (X n) < e)\n     (\\<lambda>X.\n         \\<forall>e>0.\n            \\<exists>M.\n               \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (X m) (X n) < e)", "by transfer_prover"], ["proof (state)\nthis:\n  (((=) ===> blinfun_cblinfun_eq) ===> (=)) Cauchy Cauchy\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_blinfun_transfer_tendsto[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(((=) ===> blinfun_cblinfun_eq) ===> blinfun_cblinfun_eq ===> (=) ===> (=)) tendsto tendsto\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> blinfun_cblinfun_eq) ===>\n     blinfun_cblinfun_eq ===> (=) ===> (=))\n     (\\<longlongrightarrow>) (\\<longlongrightarrow>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (((=) ===> blinfun_cblinfun_eq) ===>\n     blinfun_cblinfun_eq ===> (=) ===> (=))\n     (\\<longlongrightarrow>) (\\<longlongrightarrow>)", "note cblinfun_blinfun_transfer[transfer_rule]"], ["proof (state)\nthis:\n  blinfun_cblinfun_eq 0 0\n  (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq)\n   (+) (+)\n  (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq)\n   (-) (-)\n  (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) uminus uminus\n  (real_complex_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq)\n   (*\\<^sub>R) (*\\<^sub>C)\n  (eq_onp bounded_clinear ===> blinfun_cblinfun_eq) Blinfun CBlinfun\n  (blinfun_cblinfun_eq ===> (=)) norm norm\n  (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> (=)) dist dist\n  (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) sgn sgn\n  (((=) ===> blinfun_cblinfun_eq) ===> (=)) Cauchy Cauchy\n\ngoal (1 subgoal):\n 1. (((=) ===> blinfun_cblinfun_eq) ===>\n     blinfun_cblinfun_eq ===> (=) ===> (=))\n     (\\<longlongrightarrow>) (\\<longlongrightarrow>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> blinfun_cblinfun_eq) ===>\n     blinfun_cblinfun_eq ===> (=) ===> (=))\n     (\\<longlongrightarrow>) (\\<longlongrightarrow>)", "unfolding tendsto_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> blinfun_cblinfun_eq) ===>\n     blinfun_cblinfun_eq ===> (=) ===> (=))\n     (\\<lambda>f l F.\n         \\<forall>e>0. \\<forall>\\<^sub>F x in F. dist (f x) l < e)\n     (\\<lambda>f l F.\n         \\<forall>e>0. \\<forall>\\<^sub>F x in F. dist (f x) l < e)", "by transfer_prover"], ["proof (state)\nthis:\n  (((=) ===> blinfun_cblinfun_eq) ===>\n   blinfun_cblinfun_eq ===> (=) ===> (=))\n   (\\<longlongrightarrow>) (\\<longlongrightarrow>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_blinfun_transfer_compose[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq) (o\\<^sub>L) (o\\<^sub>C\\<^sub>L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (blinfun_cblinfun_eq ===> blinfun_cblinfun_eq ===> blinfun_cblinfun_eq)\n     (o\\<^sub>L) (o\\<^sub>C\\<^sub>L)", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       blinfun_cblinfun_eq x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           blinfun_cblinfun_eq xa ya \\<longrightarrow>\n           blinfun_cblinfun_eq (x o\\<^sub>L xa) (y o\\<^sub>C\\<^sub>L ya))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{f. bounded_linear f}.\n       \\<forall>y\\<in>{f. bounded_clinear f}.\n          x = y \\<longrightarrow>\n          (\\<forall>xa\\<in>{f. bounded_linear f}.\n              \\<forall>ya\\<in>{f. bounded_clinear f}.\n                 xa = ya \\<longrightarrow> x \\<circ> xa = y \\<circ> ya)", "by auto"], ["", "lemma cblinfun_blinfun_transfer_apply[cblinfun_blinfun_transfer]:\n  includes lifting_syntax\n  shows \"(blinfun_cblinfun_eq ===> (=) ===> (=)) blinfun_apply cblinfun_apply\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (blinfun_cblinfun_eq ===> (=) ===> (=)) (*\\<^sub>v) (*\\<^sub>V)", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       blinfun_cblinfun_eq x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = ya \\<longrightarrow> x *\\<^sub>v xa = y *\\<^sub>V ya)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{f. bounded_linear f}.\n       \\<forall>y\\<in>{f. bounded_clinear f}.\n          x = y \\<longrightarrow>\n          (\\<forall>xa ya. xa = ya \\<longrightarrow> x xa = y ya)", "by auto"], ["", "lemma blinfun_of_cblinfun_inj:\n  \\<open>blinfun_of_cblinfun f = blinfun_of_cblinfun g \\<Longrightarrow> f = g\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_of_cblinfun f = blinfun_of_cblinfun g \\<Longrightarrow> f = g", "by (metis cblinfun_apply_inject blinfun_of_cblinfun.rep_eq)"], ["", "lemma blinfun_of_cblinfun_inv:\n  assumes \"\\<And>c. \\<And>x. f *\\<^sub>v (c *\\<^sub>C x) = c *\\<^sub>C (f *\\<^sub>v x)\"\n  shows \"\\<exists>g. blinfun_of_cblinfun g = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g. blinfun_of_cblinfun g = f", "using assms"], ["proof (prove)\nusing this:\n  f *\\<^sub>v ?c *\\<^sub>C ?x = ?c *\\<^sub>C (f *\\<^sub>v ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>g. blinfun_of_cblinfun g = f", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>bounded_linear f;\n        \\<And>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>g\\<in>Collect bounded_clinear. id g = f", "show \"\\<exists>g\\<in>Collect bounded_clinear. id g = f\"\n    if \"bounded_linear f\"\n      and \"\\<And>c x. f (c *\\<^sub>C x) = c *\\<^sub>C f x\"\n    for f :: \"'a \\<Rightarrow> 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>Collect bounded_clinear. id g = f", "using that bounded_linear_bounded_clinear"], ["proof (prove)\nusing this:\n  bounded_linear f\n  f (?c *\\<^sub>C ?x) = ?c *\\<^sub>C f ?x\n  \\<lbrakk>bounded_linear ?A;\n   \\<forall>c x. ?A (c *\\<^sub>C x) = c *\\<^sub>C ?A x\\<rbrakk>\n  \\<Longrightarrow> bounded_clinear ?A\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>Collect bounded_clinear. id g = f", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>bounded_linear ?f;\n   \\<And>c x. ?f (c *\\<^sub>C x) = c *\\<^sub>C ?f x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>g\\<in>Collect bounded_clinear. id g = ?f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma blinfun_of_cblinfun_zero:\n  \\<open>blinfun_of_cblinfun 0 = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_of_cblinfun 0 = 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. id (\\<lambda>x. 0::'b) = (\\<lambda>x. 0::'b)", "by simp"], ["", "lemma blinfun_of_cblinfun_uminus:\n  \\<open>blinfun_of_cblinfun (- f) = - (blinfun_of_cblinfun f)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_of_cblinfun (- f) = - blinfun_of_cblinfun f", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       bounded_clinear f \\<Longrightarrow>\n       id (\\<lambda>x. - f x) = (\\<lambda>x. - id f x)", "by auto"], ["", "lemma blinfun_of_cblinfun_minus:\n  \\<open>blinfun_of_cblinfun (f - g) = blinfun_of_cblinfun f - blinfun_of_cblinfun g\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_of_cblinfun (f - g) =\n    blinfun_of_cblinfun f - blinfun_of_cblinfun g", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>bounded_clinear f; bounded_clinear g\\<rbrakk>\n       \\<Longrightarrow> id (\\<lambda>x. f x - g x) =\n                         (\\<lambda>x. id f x - id g x)", "by auto"], ["", "lemma blinfun_of_cblinfun_scaleC:\n  \\<open>blinfun_of_cblinfun (c *\\<^sub>C f) = c *\\<^sub>C (blinfun_of_cblinfun f)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_of_cblinfun (c *\\<^sub>C f) = c *\\<^sub>C blinfun_of_cblinfun f", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c f.\n       bounded_clinear f \\<Longrightarrow>\n       id (\\<lambda>x. c *\\<^sub>C f x) = (\\<lambda>x. c *\\<^sub>C id f x)", "by auto"], ["", "lemma blinfun_of_cblinfun_scaleR:\n  \\<open>blinfun_of_cblinfun (c *\\<^sub>R f) = c *\\<^sub>R (blinfun_of_cblinfun f)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_of_cblinfun (c *\\<^sub>R f) = c *\\<^sub>R blinfun_of_cblinfun f", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c f.\n       bounded_clinear f \\<Longrightarrow>\n       id (\\<lambda>x. c *\\<^sub>R f x) = (\\<lambda>x. c *\\<^sub>R id f x)", "by auto"], ["", "lemma blinfun_of_cblinfun_norm:\n  fixes f::\\<open>'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\\<close>\n  shows \\<open>norm f = norm (blinfun_of_cblinfun f)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm f = norm (blinfun_of_cblinfun f)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. bounded_clinear f \\<Longrightarrow> onorm f = onorm (id f)", "by auto"], ["", "subsection \\<open>Composition\\<close>"], ["", "lemma blinfun_of_cblinfun_cblinfun_compose:\n  fixes f::\\<open>'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_normed_vector\\<close>\n    and g::\\<open>'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\\<close>\n  shows \\<open>blinfun_of_cblinfun (f  o\\<^sub>C\\<^sub>L g) = (blinfun_of_cblinfun f) o\\<^sub>L (blinfun_of_cblinfun g)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. blinfun_of_cblinfun (f o\\<^sub>C\\<^sub>L g) =\n    blinfun_of_cblinfun f o\\<^sub>L blinfun_of_cblinfun g", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>bounded_clinear f; bounded_clinear g\\<rbrakk>\n       \\<Longrightarrow> id (f \\<circ> g) = id f \\<circ> id g", "by auto"], ["", "lemma cblinfun_compose_assoc: \n  shows \"(A o\\<^sub>C\\<^sub>L B) o\\<^sub>C\\<^sub>L C = A o\\<^sub>C\\<^sub>L (B o\\<^sub>C\\<^sub>L C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L C =\n    A o\\<^sub>C\\<^sub>L (B o\\<^sub>C\\<^sub>L C)", "by (metis (no_types, lifting) cblinfun_apply_inject fun.map_comp cblinfun_compose.rep_eq)"], ["", "lemma cblinfun_compose_zero_right[simp]: \"U o\\<^sub>C\\<^sub>L 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U o\\<^sub>C\\<^sub>L 0 = 0", "using bounded_cbilinear.zero_right bounded_cbilinear_cblinfun_compose"], ["proof (prove)\nusing this:\n  bounded_cbilinear ?prod \\<Longrightarrow> ?prod ?a (0::?'b) = (0::?'c)\n  bounded_cbilinear (o\\<^sub>C\\<^sub>L)\n\ngoal (1 subgoal):\n 1. U o\\<^sub>C\\<^sub>L 0 = 0", "by blast"], ["", "lemma cblinfun_compose_zero_left[simp]: \"0 o\\<^sub>C\\<^sub>L U = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 o\\<^sub>C\\<^sub>L U = 0", "using bounded_cbilinear.zero_left bounded_cbilinear_cblinfun_compose"], ["proof (prove)\nusing this:\n  bounded_cbilinear ?prod \\<Longrightarrow> ?prod (0::?'a) ?b = (0::?'c)\n  bounded_cbilinear (o\\<^sub>C\\<^sub>L)\n\ngoal (1 subgoal):\n 1. 0 o\\<^sub>C\\<^sub>L U = 0", "by blast"], ["", "lemma cblinfun_compose_scaleC_left[simp]:\n  fixes A::\"'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_normed_vector\"\n    and B::\"'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  shows \\<open>(a *\\<^sub>C A) o\\<^sub>C\\<^sub>L B = a *\\<^sub>C (A o\\<^sub>C\\<^sub>L B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>C A o\\<^sub>C\\<^sub>L B = a *\\<^sub>C (A o\\<^sub>C\\<^sub>L B)", "by (simp add: bounded_cbilinear.scaleC_left bounded_cbilinear_cblinfun_compose)"], ["", "lemma cblinfun_compose_scaleR_left[simp]:\n  fixes A::\"'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_normed_vector\"\n    and B::\"'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  shows \\<open>(a *\\<^sub>R A) o\\<^sub>C\\<^sub>L B = a *\\<^sub>R (A o\\<^sub>C\\<^sub>L B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>R A o\\<^sub>C\\<^sub>L B = a *\\<^sub>R (A o\\<^sub>C\\<^sub>L B)", "by (simp add: scaleR_scaleC)"], ["", "lemma cblinfun_compose_scaleC_right[simp]:\n  fixes A::\"'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_normed_vector\" \n    and B::\"'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  shows \\<open>A o\\<^sub>C\\<^sub>L (a *\\<^sub>C B) = a *\\<^sub>C (A o\\<^sub>C\\<^sub>L B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A o\\<^sub>C\\<^sub>L a *\\<^sub>C B = a *\\<^sub>C (A o\\<^sub>C\\<^sub>L B)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A a B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> A \\<circ> (\\<lambda>x. a *\\<^sub>C B x) =\n                         (\\<lambda>x. a *\\<^sub>C (A \\<circ> B) x)", "by (auto intro!: ext bounded_clinear.clinear complex_vector.linear_scale)"], ["", "lemma cblinfun_compose_scaleR_right[simp]:\n  fixes A::\"'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_normed_vector\" \n    and B::\"'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  shows \\<open>A o\\<^sub>C\\<^sub>L (a *\\<^sub>R B) = a *\\<^sub>R (A o\\<^sub>C\\<^sub>L B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A o\\<^sub>C\\<^sub>L a *\\<^sub>R B = a *\\<^sub>R (A o\\<^sub>C\\<^sub>L B)", "by (simp add: scaleR_scaleC)"], ["", "lemma cblinfun_compose_id_right[simp]: \n  shows \"U o\\<^sub>C\\<^sub>L id_cblinfun = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U o\\<^sub>C\\<^sub>L id_cblinfun = U", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>U.\n       bounded_clinear U \\<Longrightarrow> U \\<circ> (\\<lambda>x. x) = U", "by auto"], ["", "lemma cblinfun_compose_id_left[simp]: \n  shows \"id_cblinfun o\\<^sub>C\\<^sub>L U  = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id_cblinfun o\\<^sub>C\\<^sub>L U = U", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>U.\n       bounded_clinear U \\<Longrightarrow> (\\<lambda>x. x) \\<circ> U = U", "by auto"], ["", "lemma cblinfun_eq_on:\n  fixes A B :: \"'a::cbanach \\<Rightarrow>\\<^sub>C\\<^sub>L'b::complex_normed_vector\"\n  assumes \"\\<And>x. x \\<in> G \\<Longrightarrow> A *\\<^sub>V x = B *\\<^sub>V x\" and \\<open>t \\<in> closure (cspan G)\\<close>\n  shows \"A *\\<^sub>V t = B *\\<^sub>V t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V t = B *\\<^sub>V t", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> G \\<Longrightarrow> A *\\<^sub>V ?x = B *\\<^sub>V ?x\n  t \\<in> closure (cspan G)\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V t = B *\\<^sub>V t", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G A B t.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B;\n        \\<And>x. x \\<in> G \\<Longrightarrow> A x = B x;\n        t \\<in> closure (cspan G)\\<rbrakk>\n       \\<Longrightarrow> A t = B t", "using bounded_clinear_eq_on"], ["proof (prove)\nusing this:\n  \\<lbrakk>bounded_clinear ?A; bounded_clinear ?B;\n   \\<And>x. x \\<in> ?G \\<Longrightarrow> ?A x = ?B x;\n   ?t \\<in> closure (cspan ?G)\\<rbrakk>\n  \\<Longrightarrow> ?A ?t = ?B ?t\n\ngoal (1 subgoal):\n 1. \\<And>G A B t.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B;\n        \\<And>x. x \\<in> G \\<Longrightarrow> A x = B x;\n        t \\<in> closure (cspan G)\\<rbrakk>\n       \\<Longrightarrow> A t = B t", "by blast"], ["", "lemma cblinfun_eq_gen_eqI:\n  fixes A B :: \"'a::cbanach \\<Rightarrow>\\<^sub>C\\<^sub>L'b::complex_normed_vector\"\n  assumes \"\\<And>x. x \\<in> G \\<Longrightarrow> A *\\<^sub>V x = B *\\<^sub>V x\" and \\<open>ccspan G = \\<top>\\<close>\n  shows \"A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "apply (rule cblinfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. A *\\<^sub>V i = B *\\<^sub>V i", "apply (rule cblinfun_eq_on[where G=G])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i x. x \\<in> G \\<Longrightarrow> A *\\<^sub>V x = B *\\<^sub>V x\n 2. \\<And>i. i \\<in> closure (cspan G)", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> G \\<Longrightarrow> A *\\<^sub>V ?x = B *\\<^sub>V ?x\n  ccspan G = \\<top>\n\ngoal (2 subgoals):\n 1. \\<And>i x. x \\<in> G \\<Longrightarrow> A *\\<^sub>V x = B *\\<^sub>V x\n 2. \\<And>i. i \\<in> closure (cspan G)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> G \\<Longrightarrow>\n                   A *\\<^sub>V x = B *\\<^sub>V x;\n        ccspan G = \\<top>\\<rbrakk>\n       \\<Longrightarrow> i \\<in> closure (cspan G)", "by (metis ccspan.rep_eq iso_tuple_UNIV_I top_ccsubspace.rep_eq)"], ["", "lemma cblinfun_compose_add_left: \\<open>(a + b) o\\<^sub>C\\<^sub>L c = (a o\\<^sub>C\\<^sub>L c) + (b o\\<^sub>C\\<^sub>L c)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b o\\<^sub>C\\<^sub>L c =\n    (a o\\<^sub>C\\<^sub>L c) + (b o\\<^sub>C\\<^sub>L c)", "by (simp add: bounded_cbilinear.add_left bounded_cbilinear_cblinfun_compose)"], ["", "lemma cblinfun_compose_add_right: \\<open>a o\\<^sub>C\\<^sub>L (b + c) = (a o\\<^sub>C\\<^sub>L b) + (a o\\<^sub>C\\<^sub>L c)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a o\\<^sub>C\\<^sub>L b + c =\n    (a o\\<^sub>C\\<^sub>L b) + (a o\\<^sub>C\\<^sub>L c)", "by (simp add: bounded_cbilinear.add_right bounded_cbilinear_cblinfun_compose)"], ["", "lemma cbilinear_cblinfun_compose[simp]: \"cbilinear cblinfun_compose\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cbilinear (o\\<^sub>C\\<^sub>L)", "by (auto intro!: clinearI simp add: cbilinear_def bounded_cbilinear.add_left bounded_cbilinear.add_right bounded_cbilinear_cblinfun_compose)"], ["", "subsection \\<open>Adjoint\\<close>"], ["", "lift_definition\n  adj :: \"'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_inner \\<Rightarrow> 'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\" (\"_*\" [99] 100)\n  is cadjoint"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun.\n       bounded_clinear fun \\<Longrightarrow>\n       bounded_clinear (fun\\<^sup>\\<dagger>)", "by (fact cadjoint_bounded_clinear)"], ["", "lemma id_cblinfun_adjoint[simp]: \"id_cblinfun* = id_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id_cblinfun* = id_cblinfun", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x)\\<^sup>\\<dagger> = (\\<lambda>x. x)", "using cadjoint_id"], ["proof (prove)\nusing this:\n  id\\<^sup>\\<dagger> = id\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. x)\\<^sup>\\<dagger> = (\\<lambda>x. x)", "by (metis eq_id_iff)"], ["", "lemma double_adj[simp]: \"(A*)* = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A** = A", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       bounded_clinear A \\<Longrightarrow>\n       A\\<^sup>\\<dagger>\\<^sup>\\<dagger> = A", "using double_cadjoint"], ["proof (prove)\nusing this:\n  bounded_clinear ?U \\<Longrightarrow>\n  ?U\\<^sup>\\<dagger>\\<^sup>\\<dagger> = ?U\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       bounded_clinear A \\<Longrightarrow>\n       A\\<^sup>\\<dagger>\\<^sup>\\<dagger> = A", "by blast"], ["", "lemma adj_cblinfun_compose[simp]:\n  fixes B::\\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::chilbert_space\\<close>\n    and A::\\<open>'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_inner\\<close> \n  shows \"(A o\\<^sub>C\\<^sub>L B)* =  (B*) o\\<^sub>C\\<^sub>L (A*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A o\\<^sub>C\\<^sub>L B)* = B* o\\<^sub>C\\<^sub>L A*", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (A \\<circ> B)\\<^sup>\\<dagger> =\n                         B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>", "fix  A :: \\<open>'b \\<Rightarrow> 'c\\<close> and B :: \\<open>'a \\<Rightarrow> 'b\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (A \\<circ> B)\\<^sup>\\<dagger> =\n                         B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>", "assume \\<open>bounded_clinear A\\<close> and \\<open>bounded_clinear B\\<close>"], ["proof (state)\nthis:\n  bounded_clinear A\n  bounded_clinear B\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (A \\<circ> B)\\<^sup>\\<dagger> =\n                         B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>", "hence \\<open>bounded_clinear (A \\<circ> B)\\<close>"], ["proof (prove)\nusing this:\n  bounded_clinear A\n  bounded_clinear B\n\ngoal (1 subgoal):\n 1. bounded_clinear (A \\<circ> B)", "by (simp add: comp_bounded_clinear)"], ["proof (state)\nthis:\n  bounded_clinear (A \\<circ> B)\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (A \\<circ> B)\\<^sup>\\<dagger> =\n                         B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>", "have \\<open>\\<langle> (A \\<circ> B) u, v \\<rangle> = \\<langle> u, (B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>) v \\<rangle>\\<close>\n    for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<circ> B) u \\<bullet>\\<^sub>C v =\n    u \\<bullet>\\<^sub>C (B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>) v", "by (metis (no_types, lifting) cadjoint_univ_prop \\<open>bounded_clinear A\\<close> \\<open>bounded_clinear B\\<close> cinner_commute' comp_def)"], ["proof (state)\nthis:\n  (A \\<circ> B) ?u \\<bullet>\\<^sub>C ?v =\n  ?u \\<bullet>\\<^sub>C (B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>) ?v\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (A \\<circ> B)\\<^sup>\\<dagger> =\n                         B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>", "thus \\<open>(A \\<circ> B)\\<^sup>\\<dagger> = B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>\\<close>"], ["proof (prove)\nusing this:\n  (A \\<circ> B) ?u \\<bullet>\\<^sub>C ?v =\n  ?u \\<bullet>\\<^sub>C (B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>) ?v\n\ngoal (1 subgoal):\n 1. (A \\<circ> B)\\<^sup>\\<dagger> =\n    B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>", "using \\<open>bounded_clinear (A \\<circ> B)\\<close>"], ["proof (prove)\nusing this:\n  (A \\<circ> B) ?u \\<bullet>\\<^sub>C ?v =\n  ?u \\<bullet>\\<^sub>C (B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>) ?v\n  bounded_clinear (A \\<circ> B)\n\ngoal (1 subgoal):\n 1. (A \\<circ> B)\\<^sup>\\<dagger> =\n    B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>", "by (metis cadjoint_eqI cinner_commute')"], ["proof (state)\nthis:\n  (A \\<circ> B)\\<^sup>\\<dagger> =\n  B\\<^sup>\\<dagger> \\<circ> A\\<^sup>\\<dagger>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scaleC_adj[simp]: \"(a *\\<^sub>C A)* = (cnj a) *\\<^sub>C (A*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a *\\<^sub>C A)* = cnj a *\\<^sub>C A*", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a A.\n       bounded_clinear A \\<Longrightarrow>\n       (\\<lambda>x. a *\\<^sub>C A x)\\<^sup>\\<dagger> =\n       (\\<lambda>x. cnj a *\\<^sub>C (A\\<^sup>\\<dagger>) x)", "by (simp add: Complex_Vector_Spaces0.bounded_clinear.bounded_linear bounded_clinear_def complex_vector.linear_scale scaleC_cadjoint)"], ["", "lemma scaleR_adj[simp]: \"(a *\\<^sub>R A)* = a *\\<^sub>R (A*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a *\\<^sub>R A)* = a *\\<^sub>R A*", "by (simp add: scaleR_scaleC)"], ["", "lemma adj_plus: \\<open>(A + B)* = (A*) + (B*)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A + B)* = A* + B*", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. A x + B x)\\<^sup>\\<dagger> =\n                         (\\<lambda>x.\n                             (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)", "fix A B::\\<open>'b \\<Rightarrow> 'a\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. A x + B x)\\<^sup>\\<dagger> =\n                         (\\<lambda>x.\n                             (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)", "assume a1: \\<open>bounded_clinear A\\<close> and a2: \\<open>bounded_clinear B\\<close>"], ["proof (state)\nthis:\n  bounded_clinear A\n  bounded_clinear B\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. A x + B x)\\<^sup>\\<dagger> =\n                         (\\<lambda>x.\n                             (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)", "define F where \\<open>F = (\\<lambda>x. (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)\\<close>"], ["proof (state)\nthis:\n  F = (\\<lambda>x. (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. A x + B x)\\<^sup>\\<dagger> =\n                         (\\<lambda>x.\n                             (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)", "define G where \\<open>G = (\\<lambda>x. A x + B x)\\<close>"], ["proof (state)\nthis:\n  G = (\\<lambda>x. A x + B x)\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. A x + B x)\\<^sup>\\<dagger> =\n                         (\\<lambda>x.\n                             (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)", "have \\<open>bounded_clinear G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear G", "unfolding G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. A x + B x)", "by (simp add: a1 a2 bounded_clinear_add)"], ["proof (state)\nthis:\n  bounded_clinear G\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. A x + B x)\\<^sup>\\<dagger> =\n                         (\\<lambda>x.\n                             (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)", "moreover"], ["proof (state)\nthis:\n  bounded_clinear G\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. A x + B x)\\<^sup>\\<dagger> =\n                         (\\<lambda>x.\n                             (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)", "have \\<open>\\<langle>F u,  v\\<rangle> = \\<langle>u, G v\\<rangle>\\<close> for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. F u \\<bullet>\\<^sub>C v = u \\<bullet>\\<^sub>C G v", "unfolding F_def G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A\\<^sup>\\<dagger>) u + (B\\<^sup>\\<dagger>) u) \\<bullet>\\<^sub>C v =\n    u \\<bullet>\\<^sub>C (A v + B v)", "using cadjoint_univ_prop a1 a2 cinner_add_left"], ["proof (prove)\nusing this:\n  bounded_clinear ?G \\<Longrightarrow>\n  \\<forall>x y.\n     (?G\\<^sup>\\<dagger>) x \\<bullet>\\<^sub>C y = x \\<bullet>\\<^sub>C ?G y\n  bounded_clinear A\n  bounded_clinear B\n  (?x + ?y) \\<bullet>\\<^sub>C ?z =\n  ?x \\<bullet>\\<^sub>C ?z + ?y \\<bullet>\\<^sub>C ?z\n\ngoal (1 subgoal):\n 1. ((A\\<^sup>\\<dagger>) u + (B\\<^sup>\\<dagger>) u) \\<bullet>\\<^sub>C v =\n    u \\<bullet>\\<^sub>C (A v + B v)", "by (simp add: cadjoint_univ_prop cinner_add_left cinner_add_right)"], ["proof (state)\nthis:\n  F ?u \\<bullet>\\<^sub>C ?v = ?u \\<bullet>\\<^sub>C G ?v\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. A x + B x)\\<^sup>\\<dagger> =\n                         (\\<lambda>x.\n                             (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)", "ultimately"], ["proof (chain)\npicking this:\n  bounded_clinear G\n  F ?u \\<bullet>\\<^sub>C ?v = ?u \\<bullet>\\<^sub>C G ?v", "have \\<open>F = G\\<^sup>\\<dagger> \\<close>"], ["proof (prove)\nusing this:\n  bounded_clinear G\n  F ?u \\<bullet>\\<^sub>C ?v = ?u \\<bullet>\\<^sub>C G ?v\n\ngoal (1 subgoal):\n 1. F = G\\<^sup>\\<dagger>", "using cadjoint_eqI"], ["proof (prove)\nusing this:\n  bounded_clinear G\n  F ?u \\<bullet>\\<^sub>C ?v = ?u \\<bullet>\\<^sub>C G ?v\n  (\\<And>x y.\n      ?F x \\<bullet>\\<^sub>C y = x \\<bullet>\\<^sub>C ?G y) \\<Longrightarrow>\n  ?G\\<^sup>\\<dagger> = ?F\n\ngoal (1 subgoal):\n 1. F = G\\<^sup>\\<dagger>", "by blast"], ["proof (state)\nthis:\n  F = G\\<^sup>\\<dagger>\n\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. A x + B x)\\<^sup>\\<dagger> =\n                         (\\<lambda>x.\n                             (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)", "thus \\<open>(\\<lambda>x. A x + B x)\\<^sup>\\<dagger> = (\\<lambda>x. (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)\\<close>"], ["proof (prove)\nusing this:\n  F = G\\<^sup>\\<dagger>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. A x + B x)\\<^sup>\\<dagger> =\n    (\\<lambda>x. (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)", "unfolding F_def G_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x. (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x) =\n  (\\<lambda>x. A x + B x)\\<^sup>\\<dagger>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. A x + B x)\\<^sup>\\<dagger> =\n    (\\<lambda>x. (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. A x + B x)\\<^sup>\\<dagger> =\n  (\\<lambda>x. (A\\<^sup>\\<dagger>) x + (B\\<^sup>\\<dagger>) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cinner_sup_norm_cblinfun: \n  fixes A :: \\<open>'a::{complex_normed_vector,not_singleton} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_inner\\<close>\n  shows \\<open>norm A = (SUP (\\<psi>,\\<phi>). cmod (cinner \\<psi> (A *\\<^sub>V \\<phi>)) / (norm \\<psi> * norm \\<phi>))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm A =\n    (SUP (\\<psi>, \\<phi>).\n        cmod (\\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<phi>)) /\n        (norm \\<psi> * norm \\<phi>))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       bounded_clinear A \\<Longrightarrow>\n       onorm A =\n       (SUP (\\<psi>, \\<phi>).\n           cmod (\\<psi> \\<bullet>\\<^sub>C A \\<phi>) /\n           (norm \\<psi> * norm \\<phi>))", "apply (rule cinner_sup_onorm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A. bounded_clinear A \\<Longrightarrow> bounded_linear A", "by (simp add: bounded_clinear.bounded_linear)"], ["", "lemma cinner_adj_left:\n  fixes G :: \"'b::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::complex_inner\"\n  shows \\<open>\\<langle>G* *\\<^sub>V x, y\\<rangle> = \\<langle>x, G *\\<^sub>V y\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G* *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    x \\<bullet>\\<^sub>C (G *\\<^sub>V y)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>G x y.\n       bounded_clinear G \\<Longrightarrow>\n       (G\\<^sup>\\<dagger>) x \\<bullet>\\<^sub>C y = x \\<bullet>\\<^sub>C G y", "using cadjoint_univ_prop"], ["proof (prove)\nusing this:\n  bounded_clinear ?G \\<Longrightarrow>\n  \\<forall>x y.\n     (?G\\<^sup>\\<dagger>) x \\<bullet>\\<^sub>C y = x \\<bullet>\\<^sub>C ?G y\n\ngoal (1 subgoal):\n 1. \\<And>G x y.\n       bounded_clinear G \\<Longrightarrow>\n       (G\\<^sup>\\<dagger>) x \\<bullet>\\<^sub>C y = x \\<bullet>\\<^sub>C G y", "by blast"], ["", "lemma cinner_adj_right:\n  fixes G :: \"'b::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::complex_inner\"\n  shows \\<open>\\<langle>x, G* *\\<^sub>V y\\<rangle> = \\<langle>G *\\<^sub>V x, y\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bullet>\\<^sub>C (G* *\\<^sub>V y) =\n    (G *\\<^sub>V x) \\<bullet>\\<^sub>C y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x G y.\n       bounded_clinear G \\<Longrightarrow>\n       x \\<bullet>\\<^sub>C (G\\<^sup>\\<dagger>) y = G x \\<bullet>\\<^sub>C y", "using cadjoint_univ_prop'"], ["proof (prove)\nusing this:\n  bounded_clinear ?G \\<Longrightarrow>\n  \\<forall>x y.\n     x \\<bullet>\\<^sub>C (?G\\<^sup>\\<dagger>) y = ?G x \\<bullet>\\<^sub>C y\n\ngoal (1 subgoal):\n 1. \\<And>x G y.\n       bounded_clinear G \\<Longrightarrow>\n       x \\<bullet>\\<^sub>C (G\\<^sup>\\<dagger>) y = G x \\<bullet>\\<^sub>C y", "by blast"], ["", "lemma adj_0[simp]: \\<open>0* = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0* = 0", "by (metis add_cancel_right_left adj_plus)"], ["", "lemma norm_adj[simp]: \\<open>norm (A*) = norm A\\<close> \n  for A :: \\<open>'b::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::complex_inner\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A*) = norm A", "proof (cases \\<open>(\\<exists>x y :: 'b. x \\<noteq> y) \\<and> (\\<exists>x y :: 'c. x \\<noteq> y)\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    norm (A*) = norm A\n 2. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "case True"], ["proof (state)\nthis:\n  (\\<exists>x y. x \\<noteq> y) \\<and> (\\<exists>x y. x \\<noteq> y)\n\ngoal (2 subgoals):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    norm (A*) = norm A\n 2. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "then"], ["proof (chain)\npicking this:\n  (\\<exists>x y. x \\<noteq> y) \\<and> (\\<exists>x y. x \\<noteq> y)", "have c1: \\<open>class.not_singleton TYPE('b)\\<close>"], ["proof (prove)\nusing this:\n  (\\<exists>x y. x \\<noteq> y) \\<and> (\\<exists>x y. x \\<noteq> y)\n\ngoal (1 subgoal):\n 1. class.not_singleton TYPE('b)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    \\<exists>x y. x \\<noteq> y", "by simp"], ["proof (state)\nthis:\n  class.not_singleton TYPE('b)\n\ngoal (2 subgoals):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    norm (A*) = norm A\n 2. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "from True"], ["proof (chain)\npicking this:\n  (\\<exists>x y. x \\<noteq> y) \\<and> (\\<exists>x y. x \\<noteq> y)", "have c2: \\<open>class.not_singleton TYPE('c)\\<close>"], ["proof (prove)\nusing this:\n  (\\<exists>x y. x \\<noteq> y) \\<and> (\\<exists>x y. x \\<noteq> y)\n\ngoal (1 subgoal):\n 1. class.not_singleton TYPE('c)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    \\<exists>x y. x \\<noteq> y", "by simp"], ["proof (state)\nthis:\n  class.not_singleton TYPE('c)\n\ngoal (2 subgoals):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    norm (A*) = norm A\n 2. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "have normA: \\<open>norm A = (SUP (\\<psi>, \\<phi>). cmod (\\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<phi>)) / (norm \\<psi> * norm \\<phi>))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm A =\n    (SUP (\\<psi>, \\<phi>).\n        cmod (\\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<phi>)) /\n        (norm \\<psi> * norm \\<phi>))", "apply (rule cinner_sup_norm_cblinfun[internalize_sort \\<open>'a::{complex_normed_vector,not_singleton}\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.complex_normed_vector (*\\<^sub>R) (*\\<^sub>C) (+) (0::'b) (-)\n     uminus dist norm sgn uniformity open\n 2. class.not_singleton TYPE('b)", "apply (rule complex_normed_vector_axioms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.not_singleton TYPE('b)", "by (rule c1)"], ["proof (state)\nthis:\n  norm A =\n  (SUP (\\<psi>, \\<phi>).\n      cmod (\\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<phi>)) /\n      (norm \\<psi> * norm \\<phi>))\n\ngoal (2 subgoals):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    norm (A*) = norm A\n 2. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "have normAadj: \\<open>norm (A*) = (SUP (\\<psi>, \\<phi>). cmod (\\<psi> \\<bullet>\\<^sub>C (A* *\\<^sub>V \\<phi>)) / (norm \\<psi> * norm \\<phi>))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A*) =\n    (SUP (\\<psi>, \\<phi>).\n        cmod (\\<psi> \\<bullet>\\<^sub>C (A* *\\<^sub>V \\<phi>)) /\n        (norm \\<psi> * norm \\<phi>))", "apply (rule cinner_sup_norm_cblinfun[internalize_sort \\<open>'a::{complex_normed_vector,not_singleton}\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.complex_normed_vector (*\\<^sub>R) (*\\<^sub>C) (+) (0::'c) (-)\n     uminus dist norm sgn uniformity open\n 2. class.not_singleton TYPE('c)", "apply (rule complex_normed_vector_axioms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.not_singleton TYPE('c)", "by (rule c2)"], ["proof (state)\nthis:\n  norm (A*) =\n  (SUP (\\<psi>, \\<phi>).\n      cmod (\\<psi> \\<bullet>\\<^sub>C (A* *\\<^sub>V \\<phi>)) /\n      (norm \\<psi> * norm \\<phi>))\n\ngoal (2 subgoals):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    norm (A*) = norm A\n 2. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "have \\<open>norm (A*) = (SUP (\\<psi>, \\<phi>). cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) / (norm \\<psi> * norm \\<phi>))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A*) =\n    (SUP (\\<psi>, \\<phi>).\n        cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n        (norm \\<psi> * norm \\<phi>))", "unfolding normAadj"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP (\\<psi>, \\<phi>).\n        cmod (\\<psi> \\<bullet>\\<^sub>C (A* *\\<^sub>V \\<phi>)) /\n        (norm \\<psi> * norm \\<phi>)) =\n    (SUP (\\<psi>, \\<phi>).\n        cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n        (norm \\<psi> * norm \\<phi>))", "apply (subst cinner_adj_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP (\\<psi>, \\<phi>).\n        cmod ((A *\\<^sub>V \\<psi>) \\<bullet>\\<^sub>C \\<phi>) /\n        (norm \\<psi> * norm \\<phi>)) =\n    (SUP (\\<psi>, \\<phi>).\n        cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n        (norm \\<psi> * norm \\<phi>))", "apply (subst cinner_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP (\\<psi>, \\<phi>).\n        cmod (cnj (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>))) /\n        (norm \\<psi> * norm \\<phi>)) =\n    (SUP (\\<psi>, \\<phi>).\n        cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n        (norm \\<psi> * norm \\<phi>))", "apply (subst complex_mod_cnj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP (\\<psi>, \\<phi>).\n        cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n        (norm \\<psi> * norm \\<phi>)) =\n    (SUP (\\<psi>, \\<phi>).\n        cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n        (norm \\<psi> * norm \\<phi>))", "by rule"], ["proof (state)\nthis:\n  norm (A*) =\n  (SUP (\\<psi>, \\<phi>).\n      cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n      (norm \\<psi> * norm \\<phi>))\n\ngoal (2 subgoals):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    norm (A*) = norm A\n 2. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "also"], ["proof (state)\nthis:\n  norm (A*) =\n  (SUP (\\<psi>, \\<phi>).\n      cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n      (norm \\<psi> * norm \\<phi>))\n\ngoal (2 subgoals):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    norm (A*) = norm A\n 2. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "have \\<open>\\<dots> = Sup ((\\<lambda>(\\<psi>, \\<phi>). cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) / (norm \\<psi> * norm \\<phi>)) ` prod.swap ` UNIV)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP (\\<psi>, \\<phi>).\n        cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n        (norm \\<psi> * norm \\<phi>)) =\n    (SUP (\\<psi>, \\<phi>)\\<in>range prod.swap.\n        cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n        (norm \\<psi> * norm \\<phi>))", "by auto"], ["proof (state)\nthis:\n  (SUP (\\<psi>, \\<phi>).\n      cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n      (norm \\<psi> * norm \\<phi>)) =\n  (SUP (\\<psi>, \\<phi>)\\<in>range prod.swap.\n      cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n      (norm \\<psi> * norm \\<phi>))\n\ngoal (2 subgoals):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    norm (A*) = norm A\n 2. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "also"], ["proof (state)\nthis:\n  (SUP (\\<psi>, \\<phi>).\n      cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n      (norm \\<psi> * norm \\<phi>)) =\n  (SUP (\\<psi>, \\<phi>)\\<in>range prod.swap.\n      cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n      (norm \\<psi> * norm \\<phi>))\n\ngoal (2 subgoals):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    norm (A*) = norm A\n 2. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "have \\<open>\\<dots> = (SUP (\\<phi>, \\<psi>). cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) / (norm \\<psi> * norm \\<phi>))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP (\\<psi>, \\<phi>)\\<in>range prod.swap.\n        cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n        (norm \\<psi> * norm \\<phi>)) =\n    (SUP (\\<phi>, \\<psi>).\n        cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n        (norm \\<psi> * norm \\<phi>))", "apply (subst image_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP x.\n        case prod.swap x of\n        (\\<psi>, \\<phi>) \\<Rightarrow>\n          cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n          (norm \\<psi> * norm \\<phi>)) =\n    (SUP (\\<phi>, \\<psi>).\n        cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n        (norm \\<psi> * norm \\<phi>))", "by auto"], ["proof (state)\nthis:\n  (SUP (\\<psi>, \\<phi>)\\<in>range prod.swap.\n      cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n      (norm \\<psi> * norm \\<phi>)) =\n  (SUP (\\<phi>, \\<psi>).\n      cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n      (norm \\<psi> * norm \\<phi>))\n\ngoal (2 subgoals):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    norm (A*) = norm A\n 2. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "also"], ["proof (state)\nthis:\n  (SUP (\\<psi>, \\<phi>)\\<in>range prod.swap.\n      cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n      (norm \\<psi> * norm \\<phi>)) =\n  (SUP (\\<phi>, \\<psi>).\n      cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n      (norm \\<psi> * norm \\<phi>))\n\ngoal (2 subgoals):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    norm (A*) = norm A\n 2. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "have \\<open>\\<dots> = norm A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP (\\<phi>, \\<psi>).\n        cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n        (norm \\<psi> * norm \\<phi>)) =\n    norm A", "unfolding normA"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP (\\<phi>, \\<psi>).\n        cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n        (norm \\<psi> * norm \\<phi>)) =\n    (SUP (\\<psi>, \\<phi>).\n        cmod (\\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<phi>)) /\n        (norm \\<psi> * norm \\<phi>))", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  (SUP (\\<phi>, \\<psi>).\n      cmod (\\<phi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) /\n      (norm \\<psi> * norm \\<phi>)) =\n  norm A\n\ngoal (2 subgoals):\n 1. (\\<exists>x y. x \\<noteq> y) \\<and>\n    (\\<exists>x y. x \\<noteq> y) \\<Longrightarrow>\n    norm (A*) = norm A\n 2. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "finally"], ["proof (chain)\npicking this:\n  norm (A*) = norm A", "show ?thesis"], ["proof (prove)\nusing this:\n  norm (A*) = norm A\n\ngoal (1 subgoal):\n 1. norm (A*) = norm A", "by -"], ["proof (state)\nthis:\n  norm (A*) = norm A\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "case False"], ["proof (state)\nthis:\n  \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and> (\\<exists>x y. x \\<noteq> y))\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "then"], ["proof (chain)\npicking this:\n  \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and> (\\<exists>x y. x \\<noteq> y))", "consider (b) \\<open>\\<And>x::'b. x = 0\\<close> | (c) \\<open>\\<And>x::'c. x = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and> (\\<exists>x y. x \\<noteq> y))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<And>x. x = (0::'b)) \\<Longrightarrow> thesis;\n     (\\<And>x. x = (0::'c)) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<And>x. x = (0::'b)) \\<Longrightarrow> ?thesis;\n   (\\<And>x. x = (0::'c)) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(\\<And>x. x = (0::'b)) \\<Longrightarrow> ?thesis;\n   (\\<And>x. x = (0::'c)) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \\<open>A = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<And>x. x = (0::'b)) \\<Longrightarrow> ?thesis;\n   (\\<And>x. x = (0::'c)) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. A = 0", "apply (cases; transfer)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>\\<And>x. x = (0::'b);\n        \\<And>thesis.\n           \\<lbrakk>(\\<And>x. x = (0::'b)) \\<Longrightarrow> thesis;\n            (\\<And>x. x = (0::'c)) \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        bounded_clinear A\\<rbrakk>\n       \\<Longrightarrow> A = (\\<lambda>x. 0::'c)\n 2. \\<And>A.\n       \\<lbrakk>\\<And>x. x = (0::'c);\n        \\<And>thesis.\n           \\<lbrakk>(\\<And>x. x = (0::'b)) \\<Longrightarrow> thesis;\n            (\\<And>x. x = (0::'c)) \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        bounded_clinear A\\<rbrakk>\n       \\<Longrightarrow> A = (\\<lambda>x. 0::'c)", "apply (metis (full_types) bounded_clinear_def complex_vector.linear_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>\\<And>x. x = (0::'c);\n        \\<And>thesis.\n           \\<lbrakk>(\\<And>x. x = (0::'b)) \\<Longrightarrow> thesis;\n            (\\<And>x. x = (0::'c)) \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        bounded_clinear A\\<rbrakk>\n       \\<Longrightarrow> A = (\\<lambda>x. 0::'c)", "by auto"], ["proof (state)\nthis:\n  A = 0\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>x y. x \\<noteq> y) \\<and>\n            (\\<exists>x y. x \\<noteq> y)) \\<Longrightarrow>\n    norm (A*) = norm A", "then"], ["proof (chain)\npicking this:\n  A = 0", "show \\<open>norm (A*) = norm A\\<close>"], ["proof (prove)\nusing this:\n  A = 0\n\ngoal (1 subgoal):\n 1. norm (A*) = norm A", "by simp"], ["proof (state)\nthis:\n  norm (A*) = norm A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma antilinear_adj[simp]: \\<open>antilinear adj\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. antilinear adj", "apply (rule antilinearI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. (x + y)* = x* + y*\n 2. \\<And>c x. (c *\\<^sub>C x)* = cnj c *\\<^sub>C x*", "by (auto simp add: adj_plus)"], ["", "lemma bounded_antilinear_adj[bounded_antilinear, simp]: \\<open>bounded_antilinear adj\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear adj", "by (auto intro!: antilinearI exI[of _ 1] simp: bounded_antilinear_def bounded_antilinear_axioms_def adj_plus)"], ["", "lemma adjoint_eqI:\n  fixes G:: \\<open>'b::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::chilbert_space\\<close>\n    and F:: \\<open>'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\\<close>\n  assumes \\<open>\\<And>x y. \\<langle>(cblinfun_apply F) x, y\\<rangle> = \\<langle>x, (cblinfun_apply G) y\\<rangle>\\<close>\n  shows \\<open>F = G*\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. F = G*", "using assms"], ["proof (prove)\nusing this:\n  (F *\\<^sub>V ?x) \\<bullet>\\<^sub>C ?y =\n  ?x \\<bullet>\\<^sub>C (G *\\<^sub>V ?y)\n\ngoal (1 subgoal):\n 1. F = G*", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F G.\n       \\<lbrakk>bounded_clinear F; bounded_clinear G;\n        \\<And>x y.\n           F x \\<bullet>\\<^sub>C y = x \\<bullet>\\<^sub>C G y\\<rbrakk>\n       \\<Longrightarrow> F = G\\<^sup>\\<dagger>", "using cadjoint_eqI"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      ?F x \\<bullet>\\<^sub>C y = x \\<bullet>\\<^sub>C ?G y) \\<Longrightarrow>\n  ?G\\<^sup>\\<dagger> = ?F\n\ngoal (1 subgoal):\n 1. \\<And>F G.\n       \\<lbrakk>bounded_clinear F; bounded_clinear G;\n        \\<And>x y.\n           F x \\<bullet>\\<^sub>C y = x \\<bullet>\\<^sub>C G y\\<rbrakk>\n       \\<Longrightarrow> F = G\\<^sup>\\<dagger>", "by auto"], ["", "lemma cinner_real_hermiteanI: \n  \\<comment> \\<open>Prop. II.2.12 in @{cite conway2013course}\\<close>\n  assumes \\<open>\\<And>\\<psi>. cinner \\<psi> (A *\\<^sub>V \\<psi>) \\<in> \\<real>\\<close>\n  shows \\<open>A = A*\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A*", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A = A*", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. A = A*", "fix g h :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. A = A*", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. A = A*", "fix \\<alpha> :: complex"], ["proof (state)\ngoal (1 subgoal):\n 1. A = A*", "have \\<open>cinner h (A h) + cnj \\<alpha> *\\<^sub>C cinner g (A h) + \\<alpha> *\\<^sub>C cinner h (A g) + (abs \\<alpha>)\\<^sup>2 * cinner g (A g)\n        = cinner (h + \\<alpha> *\\<^sub>C g) (A *\\<^sub>V (h + \\<alpha> *\\<^sub>C g))\\<close> (is \\<open>?sum4 = _\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n    cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n    \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n    \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n    (h + \\<alpha> *\\<^sub>C g) \\<bullet>\\<^sub>C\n    (A *\\<^sub>V (h + \\<alpha> *\\<^sub>C g))", "apply (auto simp: cinner_add_right cinner_add_left cblinfun.add_right cblinfun.scaleC_right ring_class.ring_distribs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<alpha>\\<bar>\\<^sup>2 \\<noteq>\n    \\<alpha> * cnj \\<alpha> \\<Longrightarrow>\n    is_orthogonal g (A *\\<^sub>V g)", "by (metis cnj_x_x mult.commute)"], ["proof (state)\nthis:\n  h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n  \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  (h + \\<alpha> *\\<^sub>C g) \\<bullet>\\<^sub>C\n  (A *\\<^sub>V (h + \\<alpha> *\\<^sub>C g))\n\ngoal (1 subgoal):\n 1. A = A*", "also"], ["proof (state)\nthis:\n  h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n  \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  (h + \\<alpha> *\\<^sub>C g) \\<bullet>\\<^sub>C\n  (A *\\<^sub>V (h + \\<alpha> *\\<^sub>C g))\n\ngoal (1 subgoal):\n 1. A = A*", "have \\<open>\\<dots> \\<in> \\<real>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (h + \\<alpha> *\\<^sub>C g) \\<bullet>\\<^sub>C\n    (A *\\<^sub>V (h + \\<alpha> *\\<^sub>C g))\n    \\<in> \\<real>", "using assms"], ["proof (prove)\nusing this:\n  ?\\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V ?\\<psi>) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. (h + \\<alpha> *\\<^sub>C g) \\<bullet>\\<^sub>C\n    (A *\\<^sub>V (h + \\<alpha> *\\<^sub>C g))\n    \\<in> \\<real>", "by auto"], ["proof (state)\nthis:\n  (h + \\<alpha> *\\<^sub>C g) \\<bullet>\\<^sub>C\n  (A *\\<^sub>V (h + \\<alpha> *\\<^sub>C g))\n  \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. A = A*", "finally"], ["proof (chain)\npicking this:\n  h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n  \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g))\n  \\<in> \\<real>", "have \\<open>?sum4 = cnj ?sum4\\<close>"], ["proof (prove)\nusing this:\n  h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n  \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g))\n  \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n    cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n    \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n    \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n    cnj (h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n         cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n         \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n         \\<bar>\\<alpha>\\<bar>\\<^sup>2 *\n         (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)))", "using Reals_cnj_iff"], ["proof (prove)\nusing this:\n  h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n  \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g))\n  \\<in> \\<real>\n  (?z \\<in> \\<real>) = (cnj ?z = ?z)\n\ngoal (1 subgoal):\n 1. h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n    cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n    \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n    \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n    cnj (h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n         cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n         \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n         \\<bar>\\<alpha>\\<bar>\\<^sup>2 *\n         (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)))", "by fastforce"], ["proof (state)\nthis:\n  h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n  \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  cnj (h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n       cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n       \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n       \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)))\n\ngoal (1 subgoal):\n 1. A = A*", "then"], ["proof (chain)\npicking this:\n  h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n  \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  cnj (h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n       cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n       \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n       \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)))", "have \\<open>cnj \\<alpha> *\\<^sub>C cinner g (A h) + \\<alpha> *\\<^sub>C cinner h (A g)\n            = \\<alpha> *\\<^sub>C cinner (A h) g + cnj \\<alpha> *\\<^sub>C cinner (A g) h\\<close>"], ["proof (prove)\nusing this:\n  h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n  \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  cnj (h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n       cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n       \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n       \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)))\n\ngoal (1 subgoal):\n 1. cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n    \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n    \\<alpha> *\\<^sub>C ((A *\\<^sub>V h) \\<bullet>\\<^sub>C g) +\n    cnj \\<alpha> *\\<^sub>C ((A *\\<^sub>V g) \\<bullet>\\<^sub>C h)", "using Reals_cnj_iff abs_complex_real assms"], ["proof (prove)\nusing this:\n  h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n  \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  cnj (h \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n       cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n       \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) +\n       \\<bar>\\<alpha>\\<bar>\\<^sup>2 * (g \\<bullet>\\<^sub>C (A *\\<^sub>V g)))\n  (?z \\<in> \\<real>) = (cnj ?z = ?z)\n  \\<bar>?x\\<bar> \\<in> \\<real>\n  ?\\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V ?\\<psi>) \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n    \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n    \\<alpha> *\\<^sub>C ((A *\\<^sub>V h) \\<bullet>\\<^sub>C g) +\n    cnj \\<alpha> *\\<^sub>C ((A *\\<^sub>V g) \\<bullet>\\<^sub>C h)", "by force"], ["proof (state)\nthis:\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  \\<alpha> *\\<^sub>C ((A *\\<^sub>V h) \\<bullet>\\<^sub>C g) +\n  cnj \\<alpha> *\\<^sub>C ((A *\\<^sub>V g) \\<bullet>\\<^sub>C h)\n\ngoal (1 subgoal):\n 1. A = A*", "also"], ["proof (state)\nthis:\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  \\<alpha> *\\<^sub>C ((A *\\<^sub>V h) \\<bullet>\\<^sub>C g) +\n  cnj \\<alpha> *\\<^sub>C ((A *\\<^sub>V g) \\<bullet>\\<^sub>C h)\n\ngoal (1 subgoal):\n 1. A = A*", "have \\<open>\\<dots> = \\<alpha> *\\<^sub>C cinner h (A* *\\<^sub>V g) + cnj \\<alpha> *\\<^sub>C cinner g (A* *\\<^sub>V h)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> *\\<^sub>C ((A *\\<^sub>V h) \\<bullet>\\<^sub>C g) +\n    cnj \\<alpha> *\\<^sub>C ((A *\\<^sub>V g) \\<bullet>\\<^sub>C h) =\n    \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) +\n    cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h))", "by (simp add: cinner_adj_right)"], ["proof (state)\nthis:\n  \\<alpha> *\\<^sub>C ((A *\\<^sub>V h) \\<bullet>\\<^sub>C g) +\n  cnj \\<alpha> *\\<^sub>C ((A *\\<^sub>V g) \\<bullet>\\<^sub>C h) =\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h))\n\ngoal (1 subgoal):\n 1. A = A*", "finally"], ["proof (chain)\npicking this:\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h))", "have \\<open>cnj \\<alpha> *\\<^sub>C cinner g (A h) + \\<alpha> *\\<^sub>C cinner h (A g) = \\<alpha> *\\<^sub>C cinner h (A* *\\<^sub>V g) + cnj \\<alpha> *\\<^sub>C cinner g (A* *\\<^sub>V h)\\<close>"], ["proof (prove)\nusing this:\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h))\n\ngoal (1 subgoal):\n 1. cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n    \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n    \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) +\n    cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h))", "by -"], ["proof (state)\nthis:\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  \\<alpha> *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) +\n  cnj \\<alpha> *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h))\n\ngoal (1 subgoal):\n 1. A = A*", "}"], ["proof (state)\nthis:\n  cnj ?\\<alpha>2 *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  ?\\<alpha>2 *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  ?\\<alpha>2 *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) +\n  cnj ?\\<alpha>2 *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h))\n\ngoal (1 subgoal):\n 1. A = A*", "from this[where \\<alpha>2=1] this[where \\<alpha>2=\\<i>]"], ["proof (chain)\npicking this:\n  cnj 1 *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  1 *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  1 *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) +\n  cnj 1 *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h))\n  cnj \\<i> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<i> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  \\<i> *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) +\n  cnj \\<i> *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h))", "have 1: \\<open>cinner g (A h) + cinner h (A g) = cinner h (A* *\\<^sub>V g) + cinner g (A* *\\<^sub>V h)\\<close>\n      and i: \\<open>- \\<i> * cinner g (A h) + \\<i> *\\<^sub>C cinner h (A g) =  \\<i> *\\<^sub>C cinner h (A* *\\<^sub>V g) - \\<i> *\\<^sub>C cinner g (A* *\\<^sub>V h)\\<close>"], ["proof (prove)\nusing this:\n  cnj 1 *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  1 *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  1 *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) +\n  cnj 1 *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h))\n  cnj \\<i> *\\<^sub>C (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<i> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  \\<i> *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) +\n  cnj \\<i> *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h))\n\ngoal (1 subgoal):\n 1. g \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n    h \\<bullet>\\<^sub>C (A *\\<^sub>V g) =\n    h \\<bullet>\\<^sub>C (A* *\\<^sub>V g) +\n    g \\<bullet>\\<^sub>C (A* *\\<^sub>V h) &&&\n    - \\<i> * (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n    \\<i> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n    \\<i> *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) -\n    \\<i> *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h))", "by auto"], ["proof (state)\nthis:\n  g \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n  h \\<bullet>\\<^sub>C (A *\\<^sub>V g) =\n  h \\<bullet>\\<^sub>C (A* *\\<^sub>V g) +\n  g \\<bullet>\\<^sub>C (A* *\\<^sub>V h)\n  - \\<i> * (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n  \\<i> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g)) =\n  \\<i> *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) -\n  \\<i> *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h))\n\ngoal (1 subgoal):\n 1. A = A*", "from arg_cong2[OF 1 arg_cong[OF i, where f=\\<open>(*) (-\\<i>)\\<close>], where f=plus]"], ["proof (chain)\npicking this:\n  g \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n  h \\<bullet>\\<^sub>C (A *\\<^sub>V g) +\n  - \\<i> *\n  (- \\<i> * (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n   \\<i> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g))) =\n  h \\<bullet>\\<^sub>C (A* *\\<^sub>V g) +\n  g \\<bullet>\\<^sub>C (A* *\\<^sub>V h) +\n  - \\<i> *\n  (\\<i> *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) -\n   \\<i> *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h)))", "have \\<open>cinner h (A g) = cinner h (A* *\\<^sub>V g)\\<close>"], ["proof (prove)\nusing this:\n  g \\<bullet>\\<^sub>C (A *\\<^sub>V h) +\n  h \\<bullet>\\<^sub>C (A *\\<^sub>V g) +\n  - \\<i> *\n  (- \\<i> * (g \\<bullet>\\<^sub>C (A *\\<^sub>V h)) +\n   \\<i> *\\<^sub>C (h \\<bullet>\\<^sub>C (A *\\<^sub>V g))) =\n  h \\<bullet>\\<^sub>C (A* *\\<^sub>V g) +\n  g \\<bullet>\\<^sub>C (A* *\\<^sub>V h) +\n  - \\<i> *\n  (\\<i> *\\<^sub>C (h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)) -\n   \\<i> *\\<^sub>C (g \\<bullet>\\<^sub>C (A* *\\<^sub>V h)))\n\ngoal (1 subgoal):\n 1. h \\<bullet>\\<^sub>C (A *\\<^sub>V g) =\n    h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)", "by (auto simp: ring_class.ring_distribs)"], ["proof (state)\nthis:\n  h \\<bullet>\\<^sub>C (A *\\<^sub>V g) = h \\<bullet>\\<^sub>C (A* *\\<^sub>V g)\n\ngoal (1 subgoal):\n 1. A = A*", "}"], ["proof (state)\nthis:\n  ?h2 \\<bullet>\\<^sub>C (A *\\<^sub>V ?g2) =\n  ?h2 \\<bullet>\\<^sub>C (A* *\\<^sub>V ?g2)\n\ngoal (1 subgoal):\n 1. A = A*", "then"], ["proof (chain)\npicking this:\n  ?h2 \\<bullet>\\<^sub>C (A *\\<^sub>V ?g2) =\n  ?h2 \\<bullet>\\<^sub>C (A* *\\<^sub>V ?g2)", "show \"A = A*\""], ["proof (prove)\nusing this:\n  ?h2 \\<bullet>\\<^sub>C (A *\\<^sub>V ?g2) =\n  ?h2 \\<bullet>\\<^sub>C (A* *\\<^sub>V ?g2)\n\ngoal (1 subgoal):\n 1. A = A*", "by (simp add: adjoint_eqI cinner_adj_right)"], ["proof (state)\nthis:\n  A = A*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm_AAadj[simp]: \\<open>norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2\\<close> for A :: \\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{complex_inner}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "proof (cases \\<open>class.not_singleton TYPE('b)\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2\n 2. \\<not> class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "case True"], ["proof (state)\nthis:\n  class.not_singleton TYPE('b)\n\ngoal (2 subgoals):\n 1. class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2\n 2. \\<not> class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  class.not_singleton TYPE('b)", "have [simp]: \\<open>class.not_singleton TYPE('b)\\<close>"], ["proof (prove)\nusing this:\n  class.not_singleton TYPE('b)\n\ngoal (1 subgoal):\n 1. class.not_singleton TYPE('b)", "by -"], ["proof (state)\nthis:\n  class.not_singleton TYPE('b)\n\ngoal (2 subgoals):\n 1. class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2\n 2. \\<not> class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "have 1: \\<open>(norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)\\<close> if \\<open>\\<epsilon> < 1\\<close> and \\<open>\\<epsilon> \\<ge> 0\\<close> for \\<epsilon>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "obtain \\<psi> where \\<psi>: \\<open>norm ((A*) *\\<^sub>V \\<psi>) \\<ge> norm (A*) * sqrt \\<epsilon>\\<close> and [simp]: \\<open>norm \\<psi> = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        \\<lbrakk>norm (A*) * sqrt \\<epsilon>\n                 \\<le> norm (A* *\\<^sub>V \\<psi>);\n         norm \\<psi> = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>.\n       norm (A*) * sqrt \\<epsilon> \\<le> norm (A* *\\<^sub>V \\<psi>) \\<and>\n       norm \\<psi> = 1", "apply (rule cblinfun_norm_approx_witness_mult[internalize_sort' 'a])"], ["proof (prove)\ngoal (3 subgoals):\n 1. class.complex_normed_vector (*\\<^sub>R) (*\\<^sub>C) (+) (0::'b) (-)\n     uminus dist norm sgn uniformity open\n 2. class.not_singleton TYPE('b)\n 3. sqrt \\<epsilon> < 1", "using \\<open>\\<epsilon> < 1\\<close>"], ["proof (prove)\nusing this:\n  \\<epsilon> < 1\n\ngoal (3 subgoals):\n 1. class.complex_normed_vector (*\\<^sub>R) (*\\<^sub>C) (+) (0::'b) (-)\n     uminus dist norm sgn uniformity open\n 2. class.not_singleton TYPE('b)\n 3. sqrt \\<epsilon> < 1", "by (auto intro: complex_normed_vector_class.complex_normed_vector_axioms)"], ["proof (state)\nthis:\n  norm (A*) * sqrt \\<epsilon> \\<le> norm (A* *\\<^sub>V \\<psi>)\n  norm \\<psi> = 1\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "have \\<open>complex_of_real ((norm A)\\<^sup>2 * \\<epsilon>) = (norm (A*) * sqrt \\<epsilon>)\\<^sup>2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real ((norm A)\\<^sup>2 * \\<epsilon>) =\n    complex_of_real ((norm (A*) * sqrt \\<epsilon>)\\<^sup>2)", "by (simp add: ordered_field_class.sign_simps(23) that(2))"], ["proof (state)\nthis:\n  complex_of_real ((norm A)\\<^sup>2 * \\<epsilon>) =\n  complex_of_real ((norm (A*) * sqrt \\<epsilon>)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "also"], ["proof (state)\nthis:\n  complex_of_real ((norm A)\\<^sup>2 * \\<epsilon>) =\n  complex_of_real ((norm (A*) * sqrt \\<epsilon>)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "have \\<open>\\<dots> \\<le> (norm ((A* *\\<^sub>V \\<psi>)))\\<^sup>2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real ((norm (A*) * sqrt \\<epsilon>)\\<^sup>2)\n    \\<le> complex_of_real ((norm (A* *\\<^sub>V \\<psi>))\\<^sup>2)", "apply (rule complex_of_real_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm (A*) * sqrt \\<epsilon>)\\<^sup>2\n    \\<le> (norm (A* *\\<^sub>V \\<psi>))\\<^sup>2", "using \\<psi>"], ["proof (prove)\nusing this:\n  norm (A*) * sqrt \\<epsilon> \\<le> norm (A* *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. (norm (A*) * sqrt \\<epsilon>)\\<^sup>2\n    \\<le> (norm (A* *\\<^sub>V \\<psi>))\\<^sup>2", "apply (rule power_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> norm (A*) * sqrt \\<epsilon>", "using \\<open>\\<epsilon> \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. 0 \\<le> norm (A*) * sqrt \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  complex_of_real ((norm (A*) * sqrt \\<epsilon>)\\<^sup>2)\n  \\<le> complex_of_real ((norm (A* *\\<^sub>V \\<psi>))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "also"], ["proof (state)\nthis:\n  complex_of_real ((norm (A*) * sqrt \\<epsilon>)\\<^sup>2)\n  \\<le> complex_of_real ((norm (A* *\\<^sub>V \\<psi>))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "have \\<open>\\<dots> \\<le> cinner (A* *\\<^sub>V \\<psi>) (A* *\\<^sub>V \\<psi>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real ((norm (A* *\\<^sub>V \\<psi>))\\<^sup>2)\n    \\<le> (A* *\\<^sub>V \\<psi>) \\<bullet>\\<^sub>C (A* *\\<^sub>V \\<psi>)", "by (auto simp flip: power2_norm_eq_cinner)"], ["proof (state)\nthis:\n  complex_of_real ((norm (A* *\\<^sub>V \\<psi>))\\<^sup>2)\n  \\<le> (A* *\\<^sub>V \\<psi>) \\<bullet>\\<^sub>C (A* *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "also"], ["proof (state)\nthis:\n  complex_of_real ((norm (A* *\\<^sub>V \\<psi>))\\<^sup>2)\n  \\<le> (A* *\\<^sub>V \\<psi>) \\<bullet>\\<^sub>C (A* *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "have \\<open>\\<dots> = cinner \\<psi> (A *\\<^sub>V A* *\\<^sub>V \\<psi>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A* *\\<^sub>V \\<psi>) \\<bullet>\\<^sub>C (A* *\\<^sub>V \\<psi>) =\n    \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V A* *\\<^sub>V \\<psi>)", "by (simp add: cinner_adj_left)"], ["proof (state)\nthis:\n  (A* *\\<^sub>V \\<psi>) \\<bullet>\\<^sub>C (A* *\\<^sub>V \\<psi>) =\n  \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V A* *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "also"], ["proof (state)\nthis:\n  (A* *\\<^sub>V \\<psi>) \\<bullet>\\<^sub>C (A* *\\<^sub>V \\<psi>) =\n  \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V A* *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "have \\<open>\\<dots> = cinner \\<psi> ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V A* *\\<^sub>V \\<psi>) =\n    \\<psi> \\<bullet>\\<^sub>C ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>)", "by auto"], ["proof (state)\nthis:\n  \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V A* *\\<^sub>V \\<psi>) =\n  \\<psi> \\<bullet>\\<^sub>C ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "also"], ["proof (state)\nthis:\n  \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V A* *\\<^sub>V \\<psi>) =\n  \\<psi> \\<bullet>\\<^sub>C ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "have \\<open>\\<dots> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<bullet>\\<^sub>C ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>)\n    \\<le> complex_of_real (norm (A o\\<^sub>C\\<^sub>L A*))", "using \\<open>norm \\<psi> = 1\\<close>"], ["proof (prove)\nusing this:\n  norm \\<psi> = 1\n\ngoal (1 subgoal):\n 1. \\<psi> \\<bullet>\\<^sub>C ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>)\n    \\<le> complex_of_real (norm (A o\\<^sub>C\\<^sub>L A*))", "by (smt (verit, best) Im_complex_of_real Re_complex_of_real \\<open>(A* *\\<^sub>V \\<psi>) \\<bullet>\\<^sub>C (A* *\\<^sub>V \\<psi>) = \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V A* *\\<^sub>V \\<psi>)\\<close> \\<open>\\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V A* *\\<^sub>V \\<psi>) = \\<psi> \\<bullet>\\<^sub>C ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>)\\<close> cdot_square_norm cinner_ge_zero cmod_Re complex_inner_class.Cauchy_Schwarz_ineq2 less_eq_complex_def mult_cancel_left1 mult_cancel_right1 norm_cblinfun)"], ["proof (state)\nthis:\n  \\<psi> \\<bullet>\\<^sub>C ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>)\n  \\<le> complex_of_real (norm (A o\\<^sub>C\\<^sub>L A*))\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "finally"], ["proof (chain)\npicking this:\n  complex_of_real ((norm A)\\<^sup>2 * \\<epsilon>)\n  \\<le> complex_of_real (norm (A o\\<^sub>C\\<^sub>L A*))", "show ?thesis"], ["proof (prove)\nusing this:\n  complex_of_real ((norm A)\\<^sup>2 * \\<epsilon>)\n  \\<le> complex_of_real (norm (A o\\<^sub>C\\<^sub>L A*))\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "by auto"], ["proof (state)\nthis:\n  (norm A)\\<^sup>2 * \\<epsilon> \\<le> norm (A o\\<^sub>C\\<^sub>L A*)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<epsilon> < 1; 0 \\<le> ?\\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> (norm A)\\<^sup>2 * ?\\<epsilon>\n                    \\<le> norm (A o\\<^sub>C\\<^sub>L A*)\n\ngoal (2 subgoals):\n 1. class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2\n 2. \\<not> class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?\\<epsilon> < 1; 0 \\<le> ?\\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> (norm A)\\<^sup>2 * ?\\<epsilon>\n                    \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "have 1: \\<open>(norm A)\\<^sup>2 \\<le> norm (A o\\<^sub>C\\<^sub>L A*)\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<epsilon> < 1; 0 \\<le> ?\\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> (norm A)\\<^sup>2 * ?\\<epsilon>\n                    \\<le> norm (A o\\<^sub>C\\<^sub>L A*)\n\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2 \\<le> norm (A o\\<^sub>C\\<^sub>L A*)", "by (metis field_le_mult_one_interval less_eq_real_def ordered_field_class.sign_simps(5))"], ["proof (state)\nthis:\n  (norm A)\\<^sup>2 \\<le> norm (A o\\<^sub>C\\<^sub>L A*)\n\ngoal (2 subgoals):\n 1. class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2\n 2. \\<not> class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "have 2: \\<open>norm (A o\\<^sub>C\\<^sub>L A*) \\<le> (norm A)\\<^sup>2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A o\\<^sub>C\\<^sub>L A*) \\<le> (norm A)\\<^sup>2", "proof (rule norm_cblinfun_bound)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> (norm A)\\<^sup>2\n 2. \\<And>x.\n       norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V x)\n       \\<le> (norm A)\\<^sup>2 * norm x", "show \\<open>0 \\<le> (norm A)\\<^sup>2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (norm A)\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  0 \\<le> (norm A)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V x)\n       \\<le> (norm A)\\<^sup>2 * norm x", "fix \\<psi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V x)\n       \\<le> (norm A)\\<^sup>2 * norm x", "have \\<open>norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>) = norm (A *\\<^sub>V A* *\\<^sub>V \\<psi>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>) =\n    norm (A *\\<^sub>V A* *\\<^sub>V \\<psi>)", "by auto"], ["proof (state)\nthis:\n  norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>) =\n  norm (A *\\<^sub>V A* *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V x)\n       \\<le> (norm A)\\<^sup>2 * norm x", "also"], ["proof (state)\nthis:\n  norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>) =\n  norm (A *\\<^sub>V A* *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V x)\n       \\<le> (norm A)\\<^sup>2 * norm x", "have \\<open>\\<dots> \\<le> norm A * norm (A* *\\<^sub>V \\<psi>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A *\\<^sub>V A* *\\<^sub>V \\<psi>)\n    \\<le> norm A * norm (A* *\\<^sub>V \\<psi>)", "by (simp add: norm_cblinfun)"], ["proof (state)\nthis:\n  norm (A *\\<^sub>V A* *\\<^sub>V \\<psi>)\n  \\<le> norm A * norm (A* *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V x)\n       \\<le> (norm A)\\<^sup>2 * norm x", "also"], ["proof (state)\nthis:\n  norm (A *\\<^sub>V A* *\\<^sub>V \\<psi>)\n  \\<le> norm A * norm (A* *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V x)\n       \\<le> (norm A)\\<^sup>2 * norm x", "have \\<open>\\<dots> \\<le> norm A * norm (A*) * norm \\<psi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm A * norm (A* *\\<^sub>V \\<psi>)\n    \\<le> norm A * norm (A*) * norm \\<psi>", "by (metis mult.assoc norm_cblinfun norm_imp_pos_and_ge ordered_comm_semiring_class.comm_mult_left_mono)"], ["proof (state)\nthis:\n  norm A * norm (A* *\\<^sub>V \\<psi>) \\<le> norm A * norm (A*) * norm \\<psi>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V x)\n       \\<le> (norm A)\\<^sup>2 * norm x", "also"], ["proof (state)\nthis:\n  norm A * norm (A* *\\<^sub>V \\<psi>) \\<le> norm A * norm (A*) * norm \\<psi>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V x)\n       \\<le> (norm A)\\<^sup>2 * norm x", "have \\<open>\\<dots> = (norm A)\\<^sup>2 * norm \\<psi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm A * norm (A*) * norm \\<psi> = (norm A)\\<^sup>2 * norm \\<psi>", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  norm A * norm (A*) * norm \\<psi> = (norm A)\\<^sup>2 * norm \\<psi>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V x)\n       \\<le> (norm A)\\<^sup>2 * norm x", "finally"], ["proof (chain)\npicking this:\n  norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>)\n  \\<le> (norm A)\\<^sup>2 * norm \\<psi>", "show \\<open>norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>) \\<le> (norm A)\\<^sup>2 * norm \\<psi>\\<close>"], ["proof (prove)\nusing this:\n  norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>)\n  \\<le> (norm A)\\<^sup>2 * norm \\<psi>\n\ngoal (1 subgoal):\n 1. norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>)\n    \\<le> (norm A)\\<^sup>2 * norm \\<psi>", "by -"], ["proof (state)\nthis:\n  norm ((A o\\<^sub>C\\<^sub>L A*) *\\<^sub>V \\<psi>)\n  \\<le> (norm A)\\<^sup>2 * norm \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (A o\\<^sub>C\\<^sub>L A*) \\<le> (norm A)\\<^sup>2\n\ngoal (2 subgoals):\n 1. class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2\n 2. \\<not> class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "from 1 2"], ["proof (chain)\npicking this:\n  (norm A)\\<^sup>2 \\<le> norm (A o\\<^sub>C\\<^sub>L A*)\n  norm (A o\\<^sub>C\\<^sub>L A*) \\<le> (norm A)\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  (norm A)\\<^sup>2 \\<le> norm (A o\\<^sub>C\\<^sub>L A*)\n  norm (A o\\<^sub>C\\<^sub>L A*) \\<le> (norm A)\\<^sup>2\n\ngoal (1 subgoal):\n 1. norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "case False"], ["proof (state)\nthis:\n  \\<not> class.not_singleton TYPE('b)\n\ngoal (1 subgoal):\n 1. \\<not> class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  \\<not> class.not_singleton TYPE('b)", "have [simp]: \\<open>class.CARD_1 TYPE('b)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> class.not_singleton TYPE('b)\n\ngoal (1 subgoal):\n 1. class.CARD_1 TYPE('b)", "by (rule not_singleton_vs_CARD_1)"], ["proof (state)\nthis:\n  class.CARD_1 TYPE('b)\n\ngoal (1 subgoal):\n 1. \\<not> class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "have \\<open>A = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 0", "apply (rule cblinfun_to_CARD_1_0[internalize_sort' 'b])"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.CARD_1 TYPE('b)\n 2. class.complex_normed_vector (*\\<^sub>R) (*\\<^sub>C) (+) (0::'b) (-)\n     uminus dist norm sgn uniformity open", "by (auto intro: complex_normed_vector_class.complex_normed_vector_axioms)"], ["proof (state)\nthis:\n  A = 0\n\ngoal (1 subgoal):\n 1. \\<not> class.not_singleton TYPE('b) \\<Longrightarrow>\n    norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  A = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  A = 0\n\ngoal (1 subgoal):\n 1. norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  norm (A o\\<^sub>C\\<^sub>L A*) = (norm A)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Unitaries / isometries\\<close>"], ["", "definition isometry::\\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_inner \\<Rightarrow> bool\\<close> where\n  \\<open>isometry U \\<longleftrightarrow> U* o\\<^sub>C\\<^sub>L U = id_cblinfun\\<close>"], ["", "definition unitary::\\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_inner \\<Rightarrow> bool\\<close> where\n  \\<open>unitary U \\<longleftrightarrow> (U* o\\<^sub>C\\<^sub>L U  = id_cblinfun) \\<and> (U o\\<^sub>C\\<^sub>L U* = id_cblinfun)\\<close>"], ["", "lemma unitary_twosided_isometry: \"unitary U \\<longleftrightarrow> isometry U \\<and> isometry (U*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary U = (isometry U \\<and> isometry (U*))", "unfolding unitary_def isometry_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (U* o\\<^sub>C\\<^sub>L U = id_cblinfun \\<and>\n     U o\\<^sub>C\\<^sub>L U* = id_cblinfun) =\n    (U* o\\<^sub>C\\<^sub>L U = id_cblinfun \\<and>\n     U** o\\<^sub>C\\<^sub>L U* = id_cblinfun)", "by simp"], ["", "lemma isometryD[simp]: \"isometry U \\<Longrightarrow> U* o\\<^sub>C\\<^sub>L U = id_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isometry U \\<Longrightarrow> U* o\\<^sub>C\\<^sub>L U = id_cblinfun", "unfolding isometry_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. U* o\\<^sub>C\\<^sub>L U = id_cblinfun \\<Longrightarrow>\n    U* o\\<^sub>C\\<^sub>L U = id_cblinfun", "by simp"], ["", "(* Not [simp] because isometryD[simp] + unitary_isometry[simp] already have the same effect *)"], ["", "lemma unitaryD1: \"unitary U \\<Longrightarrow> U* o\\<^sub>C\\<^sub>L U = id_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary U \\<Longrightarrow> U* o\\<^sub>C\\<^sub>L U = id_cblinfun", "unfolding unitary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. U* o\\<^sub>C\\<^sub>L U = id_cblinfun \\<and>\n    U o\\<^sub>C\\<^sub>L U* = id_cblinfun \\<Longrightarrow>\n    U* o\\<^sub>C\\<^sub>L U = id_cblinfun", "by simp"], ["", "lemma unitaryD2[simp]: \"unitary U \\<Longrightarrow> U o\\<^sub>C\\<^sub>L U* = id_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary U \\<Longrightarrow> U o\\<^sub>C\\<^sub>L U* = id_cblinfun", "unfolding unitary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. U* o\\<^sub>C\\<^sub>L U = id_cblinfun \\<and>\n    U o\\<^sub>C\\<^sub>L U* = id_cblinfun \\<Longrightarrow>\n    U o\\<^sub>C\\<^sub>L U* = id_cblinfun", "by simp"], ["", "lemma unitary_isometry[simp]: \"unitary U \\<Longrightarrow> isometry U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary U \\<Longrightarrow> isometry U", "unfolding unitary_def isometry_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. U* o\\<^sub>C\\<^sub>L U = id_cblinfun \\<and>\n    U o\\<^sub>C\\<^sub>L U* = id_cblinfun \\<Longrightarrow>\n    U* o\\<^sub>C\\<^sub>L U = id_cblinfun", "by simp"], ["", "lemma unitary_adj[simp]: \"unitary (U*) = unitary U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (U*) = unitary U", "unfolding unitary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (U** o\\<^sub>C\\<^sub>L U* = id_cblinfun \\<and>\n     U* o\\<^sub>C\\<^sub>L U** = id_cblinfun) =\n    (U* o\\<^sub>C\\<^sub>L U = id_cblinfun \\<and>\n     U o\\<^sub>C\\<^sub>L U* = id_cblinfun)", "by auto"], ["", "lemma isometry_cblinfun_compose[simp]: \n  assumes \"isometry A\" and \"isometry B\"  \n  shows \"isometry (A o\\<^sub>C\\<^sub>L B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isometry (A o\\<^sub>C\\<^sub>L B)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. isometry (A o\\<^sub>C\\<^sub>L B)", "have \"B* o\\<^sub>C\\<^sub>L A* o\\<^sub>C\\<^sub>L (A o\\<^sub>C\\<^sub>L B) = id_cblinfun\" if \"A* o\\<^sub>C\\<^sub>L A = id_cblinfun\" and \"B* o\\<^sub>C\\<^sub>L B = id_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B* o\\<^sub>C\\<^sub>L A* o\\<^sub>C\\<^sub>L (A o\\<^sub>C\\<^sub>L B) =\n    id_cblinfun", "using that"], ["proof (prove)\nusing this:\n  A* o\\<^sub>C\\<^sub>L A = id_cblinfun\n  B* o\\<^sub>C\\<^sub>L B = id_cblinfun\n\ngoal (1 subgoal):\n 1. B* o\\<^sub>C\\<^sub>L A* o\\<^sub>C\\<^sub>L (A o\\<^sub>C\\<^sub>L B) =\n    id_cblinfun", "by (smt (verit, del_insts) adjoint_eqI cblinfun_apply_cblinfun_compose cblinfun_id_cblinfun_apply)"], ["proof (state)\nthis:\n  \\<lbrakk>A* o\\<^sub>C\\<^sub>L A = id_cblinfun;\n   B* o\\<^sub>C\\<^sub>L B = id_cblinfun\\<rbrakk>\n  \\<Longrightarrow> B* o\\<^sub>C\\<^sub>L A* o\\<^sub>C\\<^sub>L\n                    (A o\\<^sub>C\\<^sub>L B) =\n                    id_cblinfun\n\ngoal (1 subgoal):\n 1. isometry (A o\\<^sub>C\\<^sub>L B)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>A* o\\<^sub>C\\<^sub>L A = id_cblinfun;\n   B* o\\<^sub>C\\<^sub>L B = id_cblinfun\\<rbrakk>\n  \\<Longrightarrow> B* o\\<^sub>C\\<^sub>L A* o\\<^sub>C\\<^sub>L\n                    (A o\\<^sub>C\\<^sub>L B) =\n                    id_cblinfun\n\ngoal (1 subgoal):\n 1. isometry (A o\\<^sub>C\\<^sub>L B)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>A* o\\<^sub>C\\<^sub>L A = id_cblinfun;\n   B* o\\<^sub>C\\<^sub>L B = id_cblinfun\\<rbrakk>\n  \\<Longrightarrow> B* o\\<^sub>C\\<^sub>L A* o\\<^sub>C\\<^sub>L\n                    (A o\\<^sub>C\\<^sub>L B) =\n                    id_cblinfun\n  isometry A\n  isometry B\n\ngoal (1 subgoal):\n 1. isometry (A o\\<^sub>C\\<^sub>L B)", "unfolding isometry_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>A* o\\<^sub>C\\<^sub>L A = id_cblinfun;\n   B* o\\<^sub>C\\<^sub>L B = id_cblinfun\\<rbrakk>\n  \\<Longrightarrow> B* o\\<^sub>C\\<^sub>L A* o\\<^sub>C\\<^sub>L\n                    (A o\\<^sub>C\\<^sub>L B) =\n                    id_cblinfun\n  A* o\\<^sub>C\\<^sub>L A = id_cblinfun\n  B* o\\<^sub>C\\<^sub>L B = id_cblinfun\n\ngoal (1 subgoal):\n 1. (A o\\<^sub>C\\<^sub>L B)* o\\<^sub>C\\<^sub>L (A o\\<^sub>C\\<^sub>L B) =\n    id_cblinfun", "by simp"], ["proof (state)\nthis:\n  isometry (A o\\<^sub>C\\<^sub>L B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unitary_cblinfun_compose[simp]: \"unitary (A o\\<^sub>C\\<^sub>L B)\"\n  if \"unitary A\" and \"unitary B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary (A o\\<^sub>C\\<^sub>L B)", "using that"], ["proof (prove)\nusing this:\n  unitary A\n  unitary B\n\ngoal (1 subgoal):\n 1. unitary (A o\\<^sub>C\\<^sub>L B)", "by (smt (z3) adj_cblinfun_compose cblinfun_compose_assoc cblinfun_compose_id_right double_adj isometryD isometry_cblinfun_compose unitary_def unitary_isometry)"], ["", "lemma unitary_surj: \n  assumes \"unitary U\"\n  shows \"surj (cblinfun_apply U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj ((*\\<^sub>V) U)", "apply (rule surjI[where f=\\<open>cblinfun_apply (U*)\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. U *\\<^sub>V U* *\\<^sub>V x = x", "using assms"], ["proof (prove)\nusing this:\n  unitary U\n\ngoal (1 subgoal):\n 1. \\<And>x. U *\\<^sub>V U* *\\<^sub>V x = x", "unfolding unitary_def"], ["proof (prove)\nusing this:\n  U* o\\<^sub>C\\<^sub>L U = id_cblinfun \\<and>\n  U o\\<^sub>C\\<^sub>L U* = id_cblinfun\n\ngoal (1 subgoal):\n 1. \\<And>x. U *\\<^sub>V U* *\\<^sub>V x = x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x U.\n       \\<lbrakk>bounded_clinear U;\n        U\\<^sup>\\<dagger> \\<circ> U = (\\<lambda>x. x) \\<and>\n        U \\<circ> U\\<^sup>\\<dagger> = (\\<lambda>x. x)\\<rbrakk>\n       \\<Longrightarrow> U ((U\\<^sup>\\<dagger>) x) = x", "using comp_eq_dest_lhs"], ["proof (prove)\nusing this:\n  ?a \\<circ> ?b = ?c \\<Longrightarrow> ?a (?b ?v) = ?c ?v\n\ngoal (1 subgoal):\n 1. \\<And>x U.\n       \\<lbrakk>bounded_clinear U;\n        U\\<^sup>\\<dagger> \\<circ> U = (\\<lambda>x. x) \\<and>\n        U \\<circ> U\\<^sup>\\<dagger> = (\\<lambda>x. x)\\<rbrakk>\n       \\<Longrightarrow> U ((U\\<^sup>\\<dagger>) x) = x", "by force"], ["", "lemma unitary_id[simp]: \"unitary id_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary id_cblinfun", "by (simp add: unitary_def)"], ["", "lemma orthogonal_on_basis_is_isometry:\n  assumes spanB: \\<open>ccspan B = \\<top>\\<close>\n  assumes orthoU: \\<open>\\<And>b c. b\\<in>B \\<Longrightarrow> c\\<in>B \\<Longrightarrow> cinner (U *\\<^sub>V b) (U *\\<^sub>V c) = cinner b c\\<close>\n  shows \\<open>isometry U\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. isometry U", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isometry U", "have [simp]: \\<open>b \\<in> closure (cspan B)\\<close> for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> closure (cspan B)", "using spanB"], ["proof (prove)\nusing this:\n  ccspan B = \\<top>\n\ngoal (1 subgoal):\n 1. b \\<in> closure (cspan B)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B b.\n       closure (cspan B) = UNIV \\<Longrightarrow> b \\<in> closure (cspan B)", "by simp"], ["proof (state)\nthis:\n  ?b \\<in> closure (cspan B)\n\ngoal (1 subgoal):\n 1. isometry U", "have *: \\<open>cinner (U* *\\<^sub>V U *\\<^sub>V \\<psi>) \\<phi> = cinner \\<psi> \\<phi>\\<close> if \\<open>\\<psi>\\<in>B\\<close> and \\<open>\\<phi>\\<in>B\\<close> for \\<psi> \\<phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (U* *\\<^sub>V U *\\<^sub>V \\<psi>) \\<bullet>\\<^sub>C \\<phi> =\n    \\<psi> \\<bullet>\\<^sub>C \\<phi>", "by (simp add: cinner_adj_left orthoU that(1) that(2))"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<psi> \\<in> B; ?\\<phi> \\<in> B\\<rbrakk>\n  \\<Longrightarrow> (U* *\\<^sub>V U *\\<^sub>V ?\\<psi>) \\<bullet>\\<^sub>C\n                    ?\\<phi> =\n                    ?\\<psi> \\<bullet>\\<^sub>C ?\\<phi>\n\ngoal (1 subgoal):\n 1. isometry U", "have *: \\<open>cinner (U* *\\<^sub>V U *\\<^sub>V \\<psi>) \\<phi> = cinner \\<psi> \\<phi>\\<close> if \\<open>\\<psi>\\<in>B\\<close> for \\<psi> \\<phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (U* *\\<^sub>V U *\\<^sub>V \\<psi>) \\<bullet>\\<^sub>C \\<phi> =\n    \\<psi> \\<bullet>\\<^sub>C \\<phi>", "apply (rule bounded_clinear_eq_on[where t=\\<phi> and G=B])"], ["proof (prove)\ngoal (4 subgoals):\n 1. bounded_clinear ((\\<bullet>\\<^sub>C) (U* *\\<^sub>V U *\\<^sub>V \\<psi>))\n 2. bounded_clinear ((\\<bullet>\\<^sub>C) \\<psi>)\n 3. \\<And>x.\n       x \\<in> B \\<Longrightarrow>\n       (U* *\\<^sub>V U *\\<^sub>V \\<psi>) \\<bullet>\\<^sub>C x =\n       \\<psi> \\<bullet>\\<^sub>C x\n 4. \\<phi> \\<in> closure (cspan B)", "using bounded_clinear_cinner_right *[OF that]"], ["proof (prove)\nusing this:\n  bounded_clinear ((\\<bullet>\\<^sub>C) ?a)\n  ?\\<phi> \\<in> B \\<Longrightarrow>\n  (U* *\\<^sub>V U *\\<^sub>V \\<psi>) \\<bullet>\\<^sub>C ?\\<phi> =\n  \\<psi> \\<bullet>\\<^sub>C ?\\<phi>\n\ngoal (4 subgoals):\n 1. bounded_clinear ((\\<bullet>\\<^sub>C) (U* *\\<^sub>V U *\\<^sub>V \\<psi>))\n 2. bounded_clinear ((\\<bullet>\\<^sub>C) \\<psi>)\n 3. \\<And>x.\n       x \\<in> B \\<Longrightarrow>\n       (U* *\\<^sub>V U *\\<^sub>V \\<psi>) \\<bullet>\\<^sub>C x =\n       \\<psi> \\<bullet>\\<^sub>C x\n 4. \\<phi> \\<in> closure (cspan B)", "by auto"], ["proof (state)\nthis:\n  ?\\<psi> \\<in> B \\<Longrightarrow>\n  (U* *\\<^sub>V U *\\<^sub>V ?\\<psi>) \\<bullet>\\<^sub>C ?\\<phi> =\n  ?\\<psi> \\<bullet>\\<^sub>C ?\\<phi>\n\ngoal (1 subgoal):\n 1. isometry U", "have \\<open>U* *\\<^sub>V U *\\<^sub>V \\<phi> = \\<phi>\\<close> if \\<open>\\<phi>\\<in>B\\<close> for \\<phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. U* *\\<^sub>V U *\\<^sub>V \\<phi> = \\<phi>", "apply (rule cinner_extensionality)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<gamma>.\n       \\<gamma> \\<bullet>\\<^sub>C (U* *\\<^sub>V U *\\<^sub>V \\<phi>) =\n       \\<gamma> \\<bullet>\\<^sub>C \\<phi>", "apply (subst cinner_eq_flip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<gamma>.\n       (U* *\\<^sub>V U *\\<^sub>V \\<phi>) \\<bullet>\\<^sub>C \\<gamma> =\n       \\<phi> \\<bullet>\\<^sub>C \\<gamma>", "by (simp add: * that)"], ["proof (state)\nthis:\n  ?\\<phi> \\<in> B \\<Longrightarrow>\n  U* *\\<^sub>V U *\\<^sub>V ?\\<phi> = ?\\<phi>\n\ngoal (1 subgoal):\n 1. isometry U", "then"], ["proof (chain)\npicking this:\n  ?\\<phi> \\<in> B \\<Longrightarrow>\n  U* *\\<^sub>V U *\\<^sub>V ?\\<phi> = ?\\<phi>", "have \\<open>U* o\\<^sub>C\\<^sub>L U = id_cblinfun\\<close>"], ["proof (prove)\nusing this:\n  ?\\<phi> \\<in> B \\<Longrightarrow>\n  U* *\\<^sub>V U *\\<^sub>V ?\\<phi> = ?\\<phi>\n\ngoal (1 subgoal):\n 1. U* o\\<^sub>C\\<^sub>L U = id_cblinfun", "by (metis cblinfun_apply_cblinfun_compose cblinfun_eq_gen_eqI cblinfun_id_cblinfun_apply spanB)"], ["proof (state)\nthis:\n  U* o\\<^sub>C\\<^sub>L U = id_cblinfun\n\ngoal (1 subgoal):\n 1. isometry U", "then"], ["proof (chain)\npicking this:\n  U* o\\<^sub>C\\<^sub>L U = id_cblinfun", "show \\<open>isometry U\\<close>"], ["proof (prove)\nusing this:\n  U* o\\<^sub>C\\<^sub>L U = id_cblinfun\n\ngoal (1 subgoal):\n 1. isometry U", "using isometry_def"], ["proof (prove)\nusing this:\n  U* o\\<^sub>C\\<^sub>L U = id_cblinfun\n  isometry ?U = (?U* o\\<^sub>C\\<^sub>L ?U = id_cblinfun)\n\ngoal (1 subgoal):\n 1. isometry U", "by blast"], ["proof (state)\nthis:\n  isometry U\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Images\\<close>"], ["", "(* Closure is necessary. See email 47a3bb3d-3cc3-0934-36eb-3ef0f7b70a85@ut.ee *)"], ["", "lift_definition cblinfun_image :: \\<open>'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\n\\<Rightarrow> 'a ccsubspace \\<Rightarrow> 'b ccsubspace\\<close>  (infixr \"*\\<^sub>S\" 70)\n  is \"\\<lambda>A S. closure (A ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun set.\n       \\<lbrakk>bounded_clinear fun; closed_csubspace set\\<rbrakk>\n       \\<Longrightarrow> closed_csubspace (closure (fun ` set))", "using  bounded_clinear_def closed_closure  closed_csubspace.intro"], ["proof (prove)\nusing this:\n  bounded_clinear ?f \\<equiv> clinear ?f \\<and> bounded_clinear_axioms ?f\n  closed (closure ?S)\n  \\<lbrakk>csubspace ?A; closed ?A\\<rbrakk>\n  \\<Longrightarrow> closed_csubspace ?A\n\ngoal (1 subgoal):\n 1. \\<And>fun set.\n       \\<lbrakk>bounded_clinear fun; closed_csubspace set\\<rbrakk>\n       \\<Longrightarrow> closed_csubspace (closure (fun ` set))", "by (simp add: bounded_clinear_def complex_vector.linear_subspace_image closure_is_closed_csubspace)"], ["", "lemma cblinfun_image_mono:\n  assumes a1: \"S \\<le> T\"\n  shows \"A *\\<^sub>S S \\<le> A *\\<^sub>S T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>S S \\<le> A *\\<^sub>S T", "using a1"], ["proof (prove)\nusing this:\n  S \\<le> T\n\ngoal (1 subgoal):\n 1. A *\\<^sub>S S \\<le> A *\\<^sub>S T", "by (simp add: cblinfun_image.rep_eq closure_mono image_mono less_eq_ccsubspace.rep_eq)"], ["", "lemma cblinfun_image_0[simp]:  \n  shows \"U *\\<^sub>S 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S 0 = 0", "thm zero_ccsubspace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S 0 = 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>U.\n       bounded_clinear U \\<Longrightarrow> closure (U ` {0::'b}) = {0::'a}", "by (simp add: bounded_clinear_def complex_vector.linear_0)"], ["", "lemma cblinfun_image_bot[simp]: \"U *\\<^sub>S bot = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<bottom> = \\<bottom>", "using cblinfun_image_0"], ["proof (prove)\nusing this:\n  ?U *\\<^sub>S 0 = 0\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<bottom> = \\<bottom>", "by auto"], ["", "lemma cblinfun_image_sup[simp]:   \n  fixes A B :: \\<open>'a::chilbert_space ccsubspace\\<close> and U :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L'b::chilbert_space\"\n  shows \\<open>U *\\<^sub>S (sup A B) = sup (U *\\<^sub>S A) (U *\\<^sub>S B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S (A \\<squnion> B) = U *\\<^sub>S A \\<squnion> U *\\<^sub>S B", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>U A B.\n       \\<lbrakk>bounded_clinear U; closed_csubspace A;\n        closed_csubspace B\\<rbrakk>\n       \\<Longrightarrow> closure (U ` (A +\\<^sub>M B)) =\n                         closure (U ` A) +\\<^sub>M closure (U ` B)", "using bounded_clinear.bounded_linear closure_image_closed_sum"], ["proof (prove)\nusing this:\n  bounded_clinear ?f \\<Longrightarrow> bounded_linear ?f\n  bounded_linear ?U \\<Longrightarrow>\n  closure (?U ` (?A +\\<^sub>M ?B)) =\n  closure (?U ` ?A) +\\<^sub>M closure (?U ` ?B)\n\ngoal (1 subgoal):\n 1. \\<And>U A B.\n       \\<lbrakk>bounded_clinear U; closed_csubspace A;\n        closed_csubspace B\\<rbrakk>\n       \\<Longrightarrow> closure (U ` (A +\\<^sub>M B)) =\n                         closure (U ` A) +\\<^sub>M closure (U ` B)", "by blast"], ["", "lemma scaleC_cblinfun_image[simp]:\n  fixes A :: \\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b :: chilbert_space\\<close>\n    and S :: \\<open>'a ccsubspace\\<close> and \\<alpha> :: complex\n  shows \\<open>(\\<alpha> *\\<^sub>C A) *\\<^sub>S S  = \\<alpha> *\\<^sub>C (A *\\<^sub>S S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> *\\<^sub>C A *\\<^sub>S S = \\<alpha> *\\<^sub>C (A *\\<^sub>S S)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> *\\<^sub>C A *\\<^sub>S S = \\<alpha> *\\<^sub>C (A *\\<^sub>S S)", "have \\<open>closure ( ( ((*\\<^sub>C) \\<alpha>) \\<circ> (cblinfun_apply A) ) ` space_as_set S) =\n   ((*\\<^sub>C) \\<alpha>) ` (closure (cblinfun_apply A ` space_as_set S))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure\n     (((*\\<^sub>C) \\<alpha> \\<circ> (*\\<^sub>V) A) ` space_as_set S) =\n    (*\\<^sub>C) \\<alpha> ` closure ((*\\<^sub>V) A ` space_as_set S)", "by (metis closure_scaleC image_comp)"], ["proof (state)\nthis:\n  closure (((*\\<^sub>C) \\<alpha> \\<circ> (*\\<^sub>V) A) ` space_as_set S) =\n  (*\\<^sub>C) \\<alpha> ` closure ((*\\<^sub>V) A ` space_as_set S)\n\ngoal (1 subgoal):\n 1. \\<alpha> *\\<^sub>C A *\\<^sub>S S = \\<alpha> *\\<^sub>C (A *\\<^sub>S S)", "hence \\<open>(closure (cblinfun_apply (\\<alpha> *\\<^sub>C A) ` space_as_set S)) =\n   ((*\\<^sub>C) \\<alpha>) ` (closure (cblinfun_apply A ` space_as_set S))\\<close>"], ["proof (prove)\nusing this:\n  closure (((*\\<^sub>C) \\<alpha> \\<circ> (*\\<^sub>V) A) ` space_as_set S) =\n  (*\\<^sub>C) \\<alpha> ` closure ((*\\<^sub>V) A ` space_as_set S)\n\ngoal (1 subgoal):\n 1. closure ((*\\<^sub>V) (\\<alpha> *\\<^sub>C A) ` space_as_set S) =\n    (*\\<^sub>C) \\<alpha> ` closure ((*\\<^sub>V) A ` space_as_set S)", "by (metis (mono_tags, lifting) comp_apply image_cong scaleC_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  closure ((*\\<^sub>V) (\\<alpha> *\\<^sub>C A) ` space_as_set S) =\n  (*\\<^sub>C) \\<alpha> ` closure ((*\\<^sub>V) A ` space_as_set S)\n\ngoal (1 subgoal):\n 1. \\<alpha> *\\<^sub>C A *\\<^sub>S S = \\<alpha> *\\<^sub>C (A *\\<^sub>S S)", "hence \\<open>Abs_clinear_space (closure (cblinfun_apply (\\<alpha> *\\<^sub>C A) ` space_as_set S)) =\n            \\<alpha> *\\<^sub>C Abs_clinear_space (closure (cblinfun_apply A ` space_as_set S))\\<close>"], ["proof (prove)\nusing this:\n  closure ((*\\<^sub>V) (\\<alpha> *\\<^sub>C A) ` space_as_set S) =\n  (*\\<^sub>C) \\<alpha> ` closure ((*\\<^sub>V) A ` space_as_set S)\n\ngoal (1 subgoal):\n 1. Abs_clinear_space\n     (closure ((*\\<^sub>V) (\\<alpha> *\\<^sub>C A) ` space_as_set S)) =\n    \\<alpha> *\\<^sub>C\n    Abs_clinear_space (closure ((*\\<^sub>V) A ` space_as_set S))", "by (metis space_as_set_inverse cblinfun_image.rep_eq scaleC_ccsubspace.rep_eq)"], ["proof (state)\nthis:\n  Abs_clinear_space\n   (closure ((*\\<^sub>V) (\\<alpha> *\\<^sub>C A) ` space_as_set S)) =\n  \\<alpha> *\\<^sub>C\n  Abs_clinear_space (closure ((*\\<^sub>V) A ` space_as_set S))\n\ngoal (1 subgoal):\n 1. \\<alpha> *\\<^sub>C A *\\<^sub>S S = \\<alpha> *\\<^sub>C (A *\\<^sub>S S)", "have x1: \"Abs_clinear_space (closure ((*\\<^sub>V) (\\<alpha> *\\<^sub>C A) ` space_as_set S)) =\n            \\<alpha> *\\<^sub>C Abs_clinear_space (closure ((*\\<^sub>V) A ` space_as_set S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_clinear_space\n     (closure ((*\\<^sub>V) (\\<alpha> *\\<^sub>C A) ` space_as_set S)) =\n    \\<alpha> *\\<^sub>C\n    Abs_clinear_space (closure ((*\\<^sub>V) A ` space_as_set S))", "using \\<open>Abs_clinear_space (closure (cblinfun_apply (\\<alpha> *\\<^sub>C A) ` space_as_set S)) =\n            \\<alpha> *\\<^sub>C Abs_clinear_space (closure (cblinfun_apply A ` space_as_set S))\\<close>"], ["proof (prove)\nusing this:\n  Abs_clinear_space\n   (closure ((*\\<^sub>V) (\\<alpha> *\\<^sub>C A) ` space_as_set S)) =\n  \\<alpha> *\\<^sub>C\n  Abs_clinear_space (closure ((*\\<^sub>V) A ` space_as_set S))\n\ngoal (1 subgoal):\n 1. Abs_clinear_space\n     (closure ((*\\<^sub>V) (\\<alpha> *\\<^sub>C A) ` space_as_set S)) =\n    \\<alpha> *\\<^sub>C\n    Abs_clinear_space (closure ((*\\<^sub>V) A ` space_as_set S))", "by blast"], ["proof (state)\nthis:\n  Abs_clinear_space\n   (closure ((*\\<^sub>V) (\\<alpha> *\\<^sub>C A) ` space_as_set S)) =\n  \\<alpha> *\\<^sub>C\n  Abs_clinear_space (closure ((*\\<^sub>V) A ` space_as_set S))\n\ngoal (1 subgoal):\n 1. \\<alpha> *\\<^sub>C A *\\<^sub>S S = \\<alpha> *\\<^sub>C (A *\\<^sub>S S)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> *\\<^sub>C A *\\<^sub>S S = \\<alpha> *\\<^sub>C (A *\\<^sub>S S)", "unfolding cblinfun_image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun (*\\<^sub>V) (map_fun space_as_set Abs_clinear_space)\n     (\\<lambda>A S. closure (A ` S)) (\\<alpha> *\\<^sub>C A) S =\n    \\<alpha> *\\<^sub>C\n    map_fun (*\\<^sub>V) (map_fun space_as_set Abs_clinear_space)\n     (\\<lambda>A S. closure (A ` S)) A S", "using x1"], ["proof (prove)\nusing this:\n  Abs_clinear_space\n   (closure ((*\\<^sub>V) (\\<alpha> *\\<^sub>C A) ` space_as_set S)) =\n  \\<alpha> *\\<^sub>C\n  Abs_clinear_space (closure ((*\\<^sub>V) A ` space_as_set S))\n\ngoal (1 subgoal):\n 1. map_fun (*\\<^sub>V) (map_fun space_as_set Abs_clinear_space)\n     (\\<lambda>A S. closure (A ` S)) (\\<alpha> *\\<^sub>C A) S =\n    \\<alpha> *\\<^sub>C\n    map_fun (*\\<^sub>V) (map_fun space_as_set Abs_clinear_space)\n     (\\<lambda>A S. closure (A ` S)) A S", "by force"], ["proof (state)\nthis:\n  \\<alpha> *\\<^sub>C A *\\<^sub>S S = \\<alpha> *\\<^sub>C (A *\\<^sub>S S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_image_id[simp]: \n  \"id_cblinfun *\\<^sub>S \\<psi> = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id_cblinfun *\\<^sub>S \\<psi> = \\<psi>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       closed_csubspace \\<psi> \\<Longrightarrow>\n       closure ((\\<lambda>x. x) ` \\<psi>) = \\<psi>", "by (simp add: closed_csubspace.closed)"], ["", "lemma cblinfun_compose_image: \n  \\<open>(A o\\<^sub>C\\<^sub>L B) *\\<^sub>S S =  A *\\<^sub>S (B *\\<^sub>S S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A o\\<^sub>C\\<^sub>L B) *\\<^sub>S S = A *\\<^sub>S B *\\<^sub>S S", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B S.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B;\n        closed_csubspace S\\<rbrakk>\n       \\<Longrightarrow> closure ((A \\<circ> B) ` S) =\n                         closure (A ` closure (B ` S))", "unfolding image_comp[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B S.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B;\n        closed_csubspace S\\<rbrakk>\n       \\<Longrightarrow> closure (A ` B ` S) = closure (A ` closure (B ` S))", "apply (rule closure_bounded_linear_image_subset_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B S.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B;\n        closed_csubspace S\\<rbrakk>\n       \\<Longrightarrow> bounded_linear A", "by (simp add: bounded_clinear.bounded_linear)"], ["", "lemmas cblinfun_assoc_left = cblinfun_compose_assoc[symmetric] cblinfun_compose_image[symmetric] \n  add.assoc[where ?'a=\"'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::chilbert_space\", symmetric]"], ["", "lemmas cblinfun_assoc_right = cblinfun_compose_assoc cblinfun_compose_image\n  add.assoc[where ?'a=\"'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::chilbert_space\"]"], ["", "lemma cblinfun_image_INF_leq[simp]:\n  fixes U :: \"'b::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::cbanach\"\n    and V :: \"'a \\<Rightarrow> 'b ccsubspace\" \n  shows \\<open>U *\\<^sub>S (INF i. V i) \\<le> (INF i. U *\\<^sub>S (V i))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<Sqinter> (range V) \\<le> (INF i. U *\\<^sub>S V i)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>U V.\n       \\<lbrakk>bounded_clinear U;\n        pred_fun \\<top> closed_csubspace V\\<rbrakk>\n       \\<Longrightarrow> closure (U ` \\<Inter> (range V))\n                         \\<subseteq> (\\<Inter>i. closure (U ` V i))", "by (simp add: INT_greatest Inter_lower closure_mono image_mono)"], ["", "lemma isometry_cblinfun_image_inf_distrib':\n  fixes U::\\<open>'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::cbanach\\<close> and B C::\"'a ccsubspace\"\n  shows \"U *\\<^sub>S (inf B C) \\<le> inf (U *\\<^sub>S B) (U *\\<^sub>S C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S B \\<sqinter> C\n    \\<le> U *\\<^sub>S B \\<sqinter> (U *\\<^sub>S C)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. U *\\<^sub>S B \\<sqinter> C\n    \\<le> U *\\<^sub>S B \\<sqinter> (U *\\<^sub>S C)", "define V where \\<open>V b = (if b then B else C)\\<close> for b"], ["proof (state)\nthis:\n  V ?b = (if ?b then B else C)\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S B \\<sqinter> C\n    \\<le> U *\\<^sub>S B \\<sqinter> (U *\\<^sub>S C)", "have \\<open>U *\\<^sub>S (INF i. V i) \\<le> (INF i. U *\\<^sub>S (V i))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<Sqinter> (range V) \\<le> (INF i. U *\\<^sub>S V i)", "by auto"], ["proof (state)\nthis:\n  U *\\<^sub>S \\<Sqinter> (range V) \\<le> (INF i. U *\\<^sub>S V i)\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S B \\<sqinter> C\n    \\<le> U *\\<^sub>S B \\<sqinter> (U *\\<^sub>S C)", "then"], ["proof (chain)\npicking this:\n  U *\\<^sub>S \\<Sqinter> (range V) \\<le> (INF i. U *\\<^sub>S V i)", "show ?thesis"], ["proof (prove)\nusing this:\n  U *\\<^sub>S \\<Sqinter> (range V) \\<le> (INF i. U *\\<^sub>S V i)\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S B \\<sqinter> C\n    \\<le> U *\\<^sub>S B \\<sqinter> (U *\\<^sub>S C)", "unfolding V_def"], ["proof (prove)\nusing this:\n  U *\\<^sub>S (INF i. if i then B else C)\n  \\<le> (INF i. U *\\<^sub>S (if i then B else C))\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S B \\<sqinter> C\n    \\<le> U *\\<^sub>S B \\<sqinter> (U *\\<^sub>S C)", "by (metis (mono_tags, lifting) INF_UNIV_bool_expand)"], ["proof (state)\nthis:\n  U *\\<^sub>S B \\<sqinter> C \\<le> U *\\<^sub>S B \\<sqinter> (U *\\<^sub>S C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_image_eq:\n  fixes S :: \"'a::cbanach ccsubspace\" \n    and A B :: \"'a::cbanach \\<Rightarrow>\\<^sub>C\\<^sub>L'b::cbanach\"\n  assumes \"\\<And>x. x \\<in> G \\<Longrightarrow> A *\\<^sub>V x = B *\\<^sub>V x\" and \"ccspan G \\<ge> S\"\n  shows \"A *\\<^sub>S S = B *\\<^sub>S S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>S S = B *\\<^sub>S S", "proof (use assms in transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G A B S.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B;\n        \\<And>x. x \\<in> G \\<Longrightarrow> A x = B x; closed_csubspace S;\n        S \\<subseteq> closure (cspan G)\\<rbrakk>\n       \\<Longrightarrow> closure (A ` S) = closure (B ` S)", "fix G :: \"'a set\" and A :: \"'a \\<Rightarrow> 'b\" and B :: \"'a \\<Rightarrow> 'b\" and S :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G A B S.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B;\n        \\<And>x. x \\<in> G \\<Longrightarrow> A x = B x; closed_csubspace S;\n        S \\<subseteq> closure (cspan G)\\<rbrakk>\n       \\<Longrightarrow> closure (A ` S) = closure (B ` S)", "assume a1: \"bounded_clinear A\""], ["proof (state)\nthis:\n  bounded_clinear A\n\ngoal (1 subgoal):\n 1. \\<And>G A B S.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B;\n        \\<And>x. x \\<in> G \\<Longrightarrow> A x = B x; closed_csubspace S;\n        S \\<subseteq> closure (cspan G)\\<rbrakk>\n       \\<Longrightarrow> closure (A ` S) = closure (B ` S)", "assume a2: \"bounded_clinear B\""], ["proof (state)\nthis:\n  bounded_clinear B\n\ngoal (1 subgoal):\n 1. \\<And>G A B S.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B;\n        \\<And>x. x \\<in> G \\<Longrightarrow> A x = B x; closed_csubspace S;\n        S \\<subseteq> closure (cspan G)\\<rbrakk>\n       \\<Longrightarrow> closure (A ` S) = closure (B ` S)", "assume a3: \"\\<And>x. x \\<in> G \\<Longrightarrow> A x = B x\""], ["proof (state)\nthis:\n  ?x \\<in> G \\<Longrightarrow> A ?x = B ?x\n\ngoal (1 subgoal):\n 1. \\<And>G A B S.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B;\n        \\<And>x. x \\<in> G \\<Longrightarrow> A x = B x; closed_csubspace S;\n        S \\<subseteq> closure (cspan G)\\<rbrakk>\n       \\<Longrightarrow> closure (A ` S) = closure (B ` S)", "assume a4: \"S \\<subseteq> closure (cspan G)\""], ["proof (state)\nthis:\n  S \\<subseteq> closure (cspan G)\n\ngoal (1 subgoal):\n 1. \\<And>G A B S.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B;\n        \\<And>x. x \\<in> G \\<Longrightarrow> A x = B x; closed_csubspace S;\n        S \\<subseteq> closure (cspan G)\\<rbrakk>\n       \\<Longrightarrow> closure (A ` S) = closure (B ` S)", "have \"A ` closure S = B ` closure S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ` closure S = B ` closure S", "by (smt (verit, best) UnCI a1 a2 a3 a4 bounded_clinear_eq_on closure_Un closure_closure image_cong sup.absorb_iff1)"], ["proof (state)\nthis:\n  A ` closure S = B ` closure S\n\ngoal (1 subgoal):\n 1. \\<And>G A B S.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B;\n        \\<And>x. x \\<in> G \\<Longrightarrow> A x = B x; closed_csubspace S;\n        S \\<subseteq> closure (cspan G)\\<rbrakk>\n       \\<Longrightarrow> closure (A ` S) = closure (B ` S)", "then"], ["proof (chain)\npicking this:\n  A ` closure S = B ` closure S", "show \"closure (A ` S) = closure (B ` S)\""], ["proof (prove)\nusing this:\n  A ` closure S = B ` closure S\n\ngoal (1 subgoal):\n 1. closure (A ` S) = closure (B ` S)", "by (metis Complex_Vector_Spaces0.bounded_clinear.bounded_linear a1 a2 closure_bounded_linear_image_subset_eq)"], ["proof (state)\nthis:\n  closure (A ` S) = closure (B ` S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_fixes_range:\n  assumes \"A o\\<^sub>C\\<^sub>L B = B\" and \"\\<psi> \\<in> space_as_set (B *\\<^sub>S top)\"\n  shows \"A *\\<^sub>V \\<psi> = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi> = \\<psi>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi> = \\<psi>", "define rangeB rangeB' where \"rangeB = space_as_set (B *\\<^sub>S top)\" \n    and \"rangeB' = range (cblinfun_apply B)\""], ["proof (state)\nthis:\n  rangeB = space_as_set (B *\\<^sub>S \\<top>)\n  rangeB' = range ((*\\<^sub>V) B)\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi> = \\<psi>", "from assms"], ["proof (chain)\npicking this:\n  A o\\<^sub>C\\<^sub>L B = B\n  \\<psi> \\<in> space_as_set (B *\\<^sub>S \\<top>)", "have \"\\<psi> \\<in> closure rangeB'\""], ["proof (prove)\nusing this:\n  A o\\<^sub>C\\<^sub>L B = B\n  \\<psi> \\<in> space_as_set (B *\\<^sub>S \\<top>)\n\ngoal (1 subgoal):\n 1. \\<psi> \\<in> closure rangeB'", "by (simp add: cblinfun_image.rep_eq rangeB'_def top_ccsubspace.rep_eq)"], ["proof (state)\nthis:\n  \\<psi> \\<in> closure rangeB'\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi> = \\<psi>", "then"], ["proof (chain)\npicking this:\n  \\<psi> \\<in> closure rangeB'", "obtain \\<psi>i where \\<psi>i_lim: \"\\<psi>i \\<longlonglongrightarrow> \\<psi>\" and \\<psi>i_B: \"\\<psi>i i \\<in> rangeB'\" for i"], ["proof (prove)\nusing this:\n  \\<psi> \\<in> closure rangeB'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>i.\n        \\<lbrakk>\\<psi>i \\<longlonglongrightarrow> \\<psi>;\n         \\<And>i. \\<psi>i i \\<in> rangeB'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using closure_sequential"], ["proof (prove)\nusing this:\n  \\<psi> \\<in> closure rangeB'\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>i.\n        \\<lbrakk>\\<psi>i \\<longlonglongrightarrow> \\<psi>;\n         \\<And>i. \\<psi>i i \\<in> rangeB'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<psi>i \\<longlonglongrightarrow> \\<psi>\n  \\<psi>i ?i \\<in> rangeB'\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi> = \\<psi>", "have A_invariant: \"A *\\<^sub>V \\<psi>i i = \\<psi>i i\" \n    for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi>i i = \\<psi>i i", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi>i i = \\<psi>i i", "from \\<psi>i_B"], ["proof (chain)\npicking this:\n  \\<psi>i ?i \\<in> rangeB'", "obtain \\<phi> where \\<phi>: \"\\<psi>i i = B *\\<^sub>V \\<phi>\""], ["proof (prove)\nusing this:\n  \\<psi>i ?i \\<in> rangeB'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<psi>i i = B *\\<^sub>V \\<phi> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using rangeB'_def"], ["proof (prove)\nusing this:\n  \\<psi>i ?i \\<in> rangeB'\n  rangeB' = range ((*\\<^sub>V) B)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<psi>i i = B *\\<^sub>V \\<phi> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<psi>i i = B *\\<^sub>V \\<phi>\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi>i i = \\<psi>i i", "hence \"A *\\<^sub>V \\<psi>i i = (A o\\<^sub>C\\<^sub>L B) *\\<^sub>V \\<phi>\""], ["proof (prove)\nusing this:\n  \\<psi>i i = B *\\<^sub>V \\<phi>\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi>i i = (A o\\<^sub>C\\<^sub>L B) *\\<^sub>V \\<phi>", "by (simp add: cblinfun_compose.rep_eq)"], ["proof (state)\nthis:\n  A *\\<^sub>V \\<psi>i i = (A o\\<^sub>C\\<^sub>L B) *\\<^sub>V \\<phi>\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi>i i = \\<psi>i i", "also"], ["proof (state)\nthis:\n  A *\\<^sub>V \\<psi>i i = (A o\\<^sub>C\\<^sub>L B) *\\<^sub>V \\<phi>\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi>i i = \\<psi>i i", "have \"\\<dots> = B *\\<^sub>V \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A o\\<^sub>C\\<^sub>L B) *\\<^sub>V \\<phi> = B *\\<^sub>V \\<phi>", "by (simp add: assms)"], ["proof (state)\nthis:\n  (A o\\<^sub>C\\<^sub>L B) *\\<^sub>V \\<phi> = B *\\<^sub>V \\<phi>\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi>i i = \\<psi>i i", "also"], ["proof (state)\nthis:\n  (A o\\<^sub>C\\<^sub>L B) *\\<^sub>V \\<phi> = B *\\<^sub>V \\<phi>\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi>i i = \\<psi>i i", "have \"\\<dots> = \\<psi>i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B *\\<^sub>V \\<phi> = \\<psi>i i", "by (simp add: \\<phi>)"], ["proof (state)\nthis:\n  B *\\<^sub>V \\<phi> = \\<psi>i i\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi>i i = \\<psi>i i", "finally"], ["proof (chain)\npicking this:\n  A *\\<^sub>V \\<psi>i i = \\<psi>i i", "show ?thesis"], ["proof (prove)\nusing this:\n  A *\\<^sub>V \\<psi>i i = \\<psi>i i\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi>i i = \\<psi>i i", "."], ["proof (state)\nthis:\n  A *\\<^sub>V \\<psi>i i = \\<psi>i i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A *\\<^sub>V \\<psi>i ?i = \\<psi>i ?i\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi> = \\<psi>", "from \\<psi>i_lim"], ["proof (chain)\npicking this:\n  \\<psi>i \\<longlonglongrightarrow> \\<psi>", "have \"(\\<lambda>i. A *\\<^sub>V (\\<psi>i i)) \\<longlonglongrightarrow> A *\\<^sub>V \\<psi>\""], ["proof (prove)\nusing this:\n  \\<psi>i \\<longlonglongrightarrow> \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. A *\\<^sub>V \\<psi>i i)\n    \\<longlonglongrightarrow> A *\\<^sub>V \\<psi>", "by (rule isCont_tendsto_compose[rotated], simp)"], ["proof (state)\nthis:\n  (\\<lambda>i. A *\\<^sub>V \\<psi>i i)\n  \\<longlonglongrightarrow> A *\\<^sub>V \\<psi>\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi> = \\<psi>", "with A_invariant"], ["proof (chain)\npicking this:\n  A *\\<^sub>V \\<psi>i ?i = \\<psi>i ?i\n  (\\<lambda>i. A *\\<^sub>V \\<psi>i i)\n  \\<longlonglongrightarrow> A *\\<^sub>V \\<psi>", "have \"(\\<lambda>i. \\<psi>i i) \\<longlonglongrightarrow> A *\\<^sub>V \\<psi>\""], ["proof (prove)\nusing this:\n  A *\\<^sub>V \\<psi>i ?i = \\<psi>i ?i\n  (\\<lambda>i. A *\\<^sub>V \\<psi>i i)\n  \\<longlonglongrightarrow> A *\\<^sub>V \\<psi>\n\ngoal (1 subgoal):\n 1. \\<psi>i \\<longlonglongrightarrow> A *\\<^sub>V \\<psi>", "by auto"], ["proof (state)\nthis:\n  \\<psi>i \\<longlonglongrightarrow> A *\\<^sub>V \\<psi>\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi> = \\<psi>", "with \\<psi>i_lim"], ["proof (chain)\npicking this:\n  \\<psi>i \\<longlonglongrightarrow> \\<psi>\n  \\<psi>i \\<longlonglongrightarrow> A *\\<^sub>V \\<psi>", "show \"A *\\<^sub>V \\<psi> = \\<psi>\""], ["proof (prove)\nusing this:\n  \\<psi>i \\<longlonglongrightarrow> \\<psi>\n  \\<psi>i \\<longlonglongrightarrow> A *\\<^sub>V \\<psi>\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi> = \\<psi>", "using LIMSEQ_unique"], ["proof (prove)\nusing this:\n  \\<psi>i \\<longlonglongrightarrow> \\<psi>\n  \\<psi>i \\<longlonglongrightarrow> A *\\<^sub>V \\<psi>\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?a;\n   ?X \\<longlonglongrightarrow> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi> = \\<psi>", "by blast"], ["proof (state)\nthis:\n  A *\\<^sub>V \\<psi> = \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_cblinfun_image[simp]: \"0 *\\<^sub>S S = (0::_ ccsubspace)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 *\\<^sub>S S = 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S.\n       closed_csubspace S \\<Longrightarrow>\n       closure ((\\<lambda>x. 0::'a) ` S) = {0::'a}", "by (simp add: complex_vector.subspace_0 image_constant[where x=0])"], ["", "lemma cblinfun_image_INF_eq_general:\n  fixes V :: \"'a \\<Rightarrow> 'b::chilbert_space ccsubspace\"\n    and U :: \"'b \\<Rightarrow>\\<^sub>C\\<^sub>L'c::chilbert_space\"\n    and Uinv :: \"'c \\<Rightarrow>\\<^sub>C\\<^sub>L'b\" \n  assumes UinvUUinv: \"Uinv o\\<^sub>C\\<^sub>L U o\\<^sub>C\\<^sub>L Uinv = Uinv\" and UUinvU: \"U o\\<^sub>C\\<^sub>L Uinv o\\<^sub>C\\<^sub>L U = U\"\n    \\<comment> \\<open>Meaning: \\<^term>\\<open>Uinv\\<close> is a Pseudoinverse of \\<^term>\\<open>U\\<close>\\<close>\n    and V: \"\\<And>i. V i \\<le> Uinv *\\<^sub>S top\"\n  shows \"U *\\<^sub>S (INF i. V i) = (INF i. U *\\<^sub>S V i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<Sqinter> (range V) = (INF i. U *\\<^sub>S V i)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. U *\\<^sub>S \\<Sqinter> (range V) \\<le> (INF i. U *\\<^sub>S V i)\n 2. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "show \"U *\\<^sub>S (INF i. V i) \\<le> (INF i. U *\\<^sub>S V i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<Sqinter> (range V) \\<le> (INF i. U *\\<^sub>S V i)", "by (rule cblinfun_image_INF_leq)"], ["proof (state)\nthis:\n  U *\\<^sub>S \\<Sqinter> (range V) \\<le> (INF i. U *\\<^sub>S V i)\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "define rangeU rangeUinv where \"rangeU = U *\\<^sub>S top\" and \"rangeUinv = Uinv *\\<^sub>S top\""], ["proof (state)\nthis:\n  rangeU = U *\\<^sub>S \\<top>\n  rangeUinv = Uinv *\\<^sub>S \\<top>\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "define INFUV INFV where INFUV_def: \"INFUV = (INF i. U *\\<^sub>S V i)\" and INFV_def: \"INFV = (INF i. V i)\""], ["proof (state)\nthis:\n  INFUV = (INF i. U *\\<^sub>S V i)\n  INFV = \\<Sqinter> (range V)\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "from assms"], ["proof (chain)\npicking this:\n  Uinv o\\<^sub>C\\<^sub>L U o\\<^sub>C\\<^sub>L Uinv = Uinv\n  U o\\<^sub>C\\<^sub>L Uinv o\\<^sub>C\\<^sub>L U = U\n  V ?i \\<le> Uinv *\\<^sub>S \\<top>", "have \"V i \\<le> rangeUinv\" \n    for i"], ["proof (prove)\nusing this:\n  Uinv o\\<^sub>C\\<^sub>L U o\\<^sub>C\\<^sub>L Uinv = Uinv\n  U o\\<^sub>C\\<^sub>L Uinv o\\<^sub>C\\<^sub>L U = U\n  V ?i \\<le> Uinv *\\<^sub>S \\<top>\n\ngoal (1 subgoal):\n 1. V i \\<le> rangeUinv", "unfolding rangeUinv_def"], ["proof (prove)\nusing this:\n  Uinv o\\<^sub>C\\<^sub>L U o\\<^sub>C\\<^sub>L Uinv = Uinv\n  U o\\<^sub>C\\<^sub>L Uinv o\\<^sub>C\\<^sub>L U = U\n  V ?i \\<le> Uinv *\\<^sub>S \\<top>\n\ngoal (1 subgoal):\n 1. V i \\<le> Uinv *\\<^sub>S \\<top>", "by simp"], ["proof (state)\nthis:\n  V ?i \\<le> rangeUinv\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "moreover"], ["proof (state)\nthis:\n  V ?i \\<le> rangeUinv\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "have \"(Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>V \\<psi> = \\<psi>\" if \"\\<psi> \\<in> space_as_set rangeUinv\" \n    for \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>V \\<psi> = \\<psi>", "using UinvUUinv cblinfun_fixes_range rangeUinv_def that"], ["proof (prove)\nusing this:\n  Uinv o\\<^sub>C\\<^sub>L U o\\<^sub>C\\<^sub>L Uinv = Uinv\n  \\<lbrakk>?A o\\<^sub>C\\<^sub>L ?B = ?B;\n   ?\\<psi> \\<in> space_as_set (?B *\\<^sub>S \\<top>)\\<rbrakk>\n  \\<Longrightarrow> ?A *\\<^sub>V ?\\<psi> = ?\\<psi>\n  rangeUinv = Uinv *\\<^sub>S \\<top>\n  \\<psi> \\<in> space_as_set rangeUinv\n\ngoal (1 subgoal):\n 1. (Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>V \\<psi> = \\<psi>", "by fastforce"], ["proof (state)\nthis:\n  ?\\<psi> \\<in> space_as_set rangeUinv \\<Longrightarrow>\n  (Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>V ?\\<psi> = ?\\<psi>\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "ultimately"], ["proof (chain)\npicking this:\n  V ?i \\<le> rangeUinv\n  ?\\<psi> \\<in> space_as_set rangeUinv \\<Longrightarrow>\n  (Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>V ?\\<psi> = ?\\<psi>", "have \"(Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>V \\<psi> = \\<psi>\" if \"\\<psi> \\<in> space_as_set (V i)\" \n    for \\<psi> i"], ["proof (prove)\nusing this:\n  V ?i \\<le> rangeUinv\n  ?\\<psi> \\<in> space_as_set rangeUinv \\<Longrightarrow>\n  (Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>V ?\\<psi> = ?\\<psi>\n\ngoal (1 subgoal):\n 1. (Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>V \\<psi> = \\<psi>", "using less_eq_ccsubspace.rep_eq that"], ["proof (prove)\nusing this:\n  V ?i \\<le> rangeUinv\n  ?\\<psi> \\<in> space_as_set rangeUinv \\<Longrightarrow>\n  (Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>V ?\\<psi> = ?\\<psi>\n  (?x \\<le> ?xa) = (space_as_set ?x \\<subseteq> space_as_set ?xa)\n  \\<psi> \\<in> space_as_set (V i)\n\ngoal (1 subgoal):\n 1. (Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>V \\<psi> = \\<psi>", "by blast"], ["proof (state)\nthis:\n  ?\\<psi> \\<in> space_as_set (V ?i) \\<Longrightarrow>\n  (Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>V ?\\<psi> = ?\\<psi>\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "hence d1: \"(Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>S (V i) = (V i)\" for i"], ["proof (prove)\nusing this:\n  ?\\<psi> \\<in> space_as_set (V ?i) \\<Longrightarrow>\n  (Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>V ?\\<psi> = ?\\<psi>\n\ngoal (1 subgoal):\n 1. (Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>S V i = V i", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V Uinv U i.\n       \\<lbrakk>pred_fun \\<top> closed_csubspace V; bounded_clinear Uinv;\n        bounded_clinear U;\n        \\<And>\\<psi> i.\n           \\<psi> \\<in> V i \\<Longrightarrow>\n           (Uinv \\<circ> U) \\<psi> = \\<psi>\\<rbrakk>\n       \\<Longrightarrow> closure ((Uinv \\<circ> U) ` V i) = V i", "show \"closure ((Uinv \\<circ> U) ` V i) = V i\"\n      if \"pred_fun \\<top> closed_csubspace V\"\n        and \"bounded_clinear Uinv\"\n        and \"bounded_clinear U\"\n        and \"\\<And>\\<psi> i. \\<psi> \\<in> V i \\<Longrightarrow> (Uinv \\<circ> U) \\<psi> = \\<psi>\"\n      for V :: \"'a \\<Rightarrow> 'b set\"\n        and Uinv :: \"'c \\<Rightarrow> 'b\"\n        and U :: \"'b \\<Rightarrow> 'c\"\n        and i :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure ((Uinv \\<circ> U) ` V i) = V i", "using that"], ["proof (prove)\nusing this:\n  pred_fun \\<top> closed_csubspace V\n  bounded_clinear Uinv\n  bounded_clinear U\n  ?\\<psi> \\<in> V ?i \\<Longrightarrow> (Uinv \\<circ> U) ?\\<psi> = ?\\<psi>\n\ngoal (1 subgoal):\n 1. closure ((Uinv \\<circ> U) ` V i) = V i", "proof auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x. closed_csubspace (V x); bounded_clinear Uinv;\n        bounded_clinear U;\n        \\<And>\\<psi> i.\n           \\<psi> \\<in> V i \\<Longrightarrow> Uinv (U \\<psi>) = \\<psi>;\n        x \\<in> closure (V i)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V i\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x. closed_csubspace (V x); bounded_clinear Uinv;\n        bounded_clinear U;\n        \\<And>\\<psi> i.\n           \\<psi> \\<in> V i \\<Longrightarrow> Uinv (U \\<psi>) = \\<psi>;\n        x \\<in> V i\\<rbrakk>\n       \\<Longrightarrow> x \\<in> closure (V i)", "show \"x \\<in> V i\"\n        if \"\\<forall>x. closed_csubspace (V x)\"\n          and \"bounded_clinear Uinv\"\n          and \"bounded_clinear U\"\n          and \"\\<And>\\<psi> i. \\<psi> \\<in> V i \\<Longrightarrow> Uinv (U \\<psi>) = \\<psi>\"\n          and \"x \\<in> closure (V i)\"\n        for x :: 'b"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> V i", "using that"], ["proof (prove)\nusing this:\n  \\<forall>x. closed_csubspace (V x)\n  bounded_clinear Uinv\n  bounded_clinear U\n  ?\\<psi> \\<in> V ?i \\<Longrightarrow> Uinv (U ?\\<psi>) = ?\\<psi>\n  x \\<in> closure (V i)\n\ngoal (1 subgoal):\n 1. x \\<in> V i", "by (metis orthogonal_complement_of_closure closed_csubspace.subspace double_orthogonal_complement_id closure_is_closed_csubspace)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x. closed_csubspace (V x); bounded_clinear Uinv;\n   bounded_clinear U;\n   \\<And>\\<psi> i.\n      \\<psi> \\<in> V i \\<Longrightarrow> Uinv (U \\<psi>) = \\<psi>;\n   ?x \\<in> closure (V i)\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> V i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x. closed_csubspace (V x); bounded_clinear Uinv;\n        bounded_clinear U;\n        \\<And>\\<psi> i.\n           \\<psi> \\<in> V i \\<Longrightarrow> Uinv (U \\<psi>) = \\<psi>;\n        x \\<in> V i\\<rbrakk>\n       \\<Longrightarrow> x \\<in> closure (V i)", "show \"x \\<in> closure (V i)\"\n        if \"\\<forall>x. closed_csubspace (V x)\"\n          and \"bounded_clinear Uinv\"\n          and \"bounded_clinear U\"\n          and \"\\<And>\\<psi> i. \\<psi> \\<in> V i \\<Longrightarrow> Uinv (U \\<psi>) = \\<psi>\"\n          and \"x \\<in> V i\"\n        for x :: 'b"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> closure (V i)", "using that"], ["proof (prove)\nusing this:\n  \\<forall>x. closed_csubspace (V x)\n  bounded_clinear Uinv\n  bounded_clinear U\n  ?\\<psi> \\<in> V ?i \\<Longrightarrow> Uinv (U ?\\<psi>) = ?\\<psi>\n  x \\<in> V i\n\ngoal (1 subgoal):\n 1. x \\<in> closure (V i)", "using setdist_eq_0_sing_1 setdist_sing_in_set"], ["proof (prove)\nusing this:\n  \\<forall>x. closed_csubspace (V x)\n  bounded_clinear Uinv\n  bounded_clinear U\n  ?\\<psi> \\<in> V ?i \\<Longrightarrow> Uinv (U ?\\<psi>) = ?\\<psi>\n  x \\<in> V i\n  (setdist {?x} ?S = 0) = (?S = {} \\<or> ?x \\<in> closure ?S)\n  ?x \\<in> ?S \\<Longrightarrow> setdist {?x} ?S = 0\n\ngoal (1 subgoal):\n 1. x \\<in> closure (V i)", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x. closed_csubspace (V x); bounded_clinear Uinv;\n   bounded_clinear U;\n   \\<And>\\<psi> i.\n      \\<psi> \\<in> V i \\<Longrightarrow> Uinv (U \\<psi>) = \\<psi>;\n   ?x \\<in> V i\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> closure (V i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>pred_fun \\<top> closed_csubspace ?V; bounded_clinear ?Uinv;\n   bounded_clinear ?U;\n   \\<And>\\<psi> i.\n      \\<psi> \\<in> ?V i \\<Longrightarrow>\n      (?Uinv \\<circ> ?U) \\<psi> = \\<psi>\\<rbrakk>\n  \\<Longrightarrow> closure ((?Uinv \\<circ> ?U) ` ?V ?i) = ?V ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>S V ?i = V ?i\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "have \"U *\\<^sub>S V i \\<le> rangeU\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S V i \\<le> rangeU", "by (simp add: cblinfun_image_mono rangeU_def)"], ["proof (state)\nthis:\n  U *\\<^sub>S V ?i \\<le> rangeU\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "hence \"INFUV \\<le> rangeU\""], ["proof (prove)\nusing this:\n  U *\\<^sub>S V ?i \\<le> rangeU\n\ngoal (1 subgoal):\n 1. INFUV \\<le> rangeU", "unfolding INFUV_def"], ["proof (prove)\nusing this:\n  U *\\<^sub>S V ?i \\<le> rangeU\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> rangeU", "by (meson INF_lower UNIV_I order_trans)"], ["proof (state)\nthis:\n  INFUV \\<le> rangeU\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "moreover"], ["proof (state)\nthis:\n  INFUV \\<le> rangeU\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "have \"(U o\\<^sub>C\\<^sub>L Uinv) *\\<^sub>V \\<psi> = \\<psi>\" if \"\\<psi> \\<in> space_as_set rangeU\" for \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (U o\\<^sub>C\\<^sub>L Uinv) *\\<^sub>V \\<psi> = \\<psi>", "using UUinvU cblinfun_fixes_range rangeU_def that"], ["proof (prove)\nusing this:\n  U o\\<^sub>C\\<^sub>L Uinv o\\<^sub>C\\<^sub>L U = U\n  \\<lbrakk>?A o\\<^sub>C\\<^sub>L ?B = ?B;\n   ?\\<psi> \\<in> space_as_set (?B *\\<^sub>S \\<top>)\\<rbrakk>\n  \\<Longrightarrow> ?A *\\<^sub>V ?\\<psi> = ?\\<psi>\n  rangeU = U *\\<^sub>S \\<top>\n  \\<psi> \\<in> space_as_set rangeU\n\ngoal (1 subgoal):\n 1. (U o\\<^sub>C\\<^sub>L Uinv) *\\<^sub>V \\<psi> = \\<psi>", "by fastforce"], ["proof (state)\nthis:\n  ?\\<psi> \\<in> space_as_set rangeU \\<Longrightarrow>\n  (U o\\<^sub>C\\<^sub>L Uinv) *\\<^sub>V ?\\<psi> = ?\\<psi>\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "ultimately"], ["proof (chain)\npicking this:\n  INFUV \\<le> rangeU\n  ?\\<psi> \\<in> space_as_set rangeU \\<Longrightarrow>\n  (U o\\<^sub>C\\<^sub>L Uinv) *\\<^sub>V ?\\<psi> = ?\\<psi>", "have x: \"(U o\\<^sub>C\\<^sub>L Uinv) *\\<^sub>V \\<psi> = \\<psi>\" if \"\\<psi> \\<in> space_as_set INFUV\" for \\<psi>"], ["proof (prove)\nusing this:\n  INFUV \\<le> rangeU\n  ?\\<psi> \\<in> space_as_set rangeU \\<Longrightarrow>\n  (U o\\<^sub>C\\<^sub>L Uinv) *\\<^sub>V ?\\<psi> = ?\\<psi>\n\ngoal (1 subgoal):\n 1. (U o\\<^sub>C\\<^sub>L Uinv) *\\<^sub>V \\<psi> = \\<psi>", "by (simp add: in_mono less_eq_ccsubspace.rep_eq that)"], ["proof (state)\nthis:\n  ?\\<psi> \\<in> space_as_set INFUV \\<Longrightarrow>\n  (U o\\<^sub>C\\<^sub>L Uinv) *\\<^sub>V ?\\<psi> = ?\\<psi>\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "have \"closure ((U \\<circ> Uinv) ` INFUV) = INFUV\"\n    if \"closed_csubspace INFUV\"\n      and \"bounded_clinear U\"\n      and \"bounded_clinear Uinv\"\n      and \"\\<And>\\<psi>. \\<psi> \\<in> INFUV \\<Longrightarrow> (U \\<circ> Uinv) \\<psi> = \\<psi>\"\n    for INFUV :: \"'c set\"\n      and U :: \"'b \\<Rightarrow> 'c\"\n      and Uinv :: \"'c \\<Rightarrow> 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closure ((U \\<circ> Uinv) ` INFUV) = INFUV", "using that"], ["proof (prove)\nusing this:\n  closed_csubspace INFUV\n  bounded_clinear U\n  bounded_clinear Uinv\n  ?\\<psi> \\<in> INFUV \\<Longrightarrow> (U \\<circ> Uinv) ?\\<psi> = ?\\<psi>\n\ngoal (1 subgoal):\n 1. closure ((U \\<circ> Uinv) ` INFUV) = INFUV", "proof auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>closed_csubspace INFUV; bounded_clinear U;\n        bounded_clinear Uinv;\n        \\<And>\\<psi>.\n           \\<psi> \\<in> INFUV \\<Longrightarrow> U (Uinv \\<psi>) = \\<psi>;\n        x \\<in> closure INFUV\\<rbrakk>\n       \\<Longrightarrow> x \\<in> INFUV\n 2. \\<And>x.\n       \\<lbrakk>closed_csubspace INFUV; bounded_clinear U;\n        bounded_clinear Uinv;\n        \\<And>\\<psi>.\n           \\<psi> \\<in> INFUV \\<Longrightarrow> U (Uinv \\<psi>) = \\<psi>;\n        x \\<in> INFUV\\<rbrakk>\n       \\<Longrightarrow> x \\<in> closure INFUV", "show \"x \\<in> INFUV\"\n      if \"closed_csubspace INFUV\"\n        and \"bounded_clinear U\"\n        and \"bounded_clinear Uinv\"\n        and \"\\<And>\\<psi>. \\<psi> \\<in> INFUV \\<Longrightarrow> U (Uinv \\<psi>) = \\<psi>\"\n        and \"x \\<in> closure INFUV\"\n      for x :: 'c"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> INFUV", "using that"], ["proof (prove)\nusing this:\n  closed_csubspace INFUV\n  bounded_clinear U\n  bounded_clinear Uinv\n  ?\\<psi> \\<in> INFUV \\<Longrightarrow> U (Uinv ?\\<psi>) = ?\\<psi>\n  x \\<in> closure INFUV\n\ngoal (1 subgoal):\n 1. x \\<in> INFUV", "by (metis orthogonal_complement_of_closure closed_csubspace.subspace double_orthogonal_complement_id closure_is_closed_csubspace)"], ["proof (state)\nthis:\n  \\<lbrakk>closed_csubspace INFUV; bounded_clinear U; bounded_clinear Uinv;\n   \\<And>\\<psi>.\n      \\<psi> \\<in> INFUV \\<Longrightarrow> U (Uinv \\<psi>) = \\<psi>;\n   ?x \\<in> closure INFUV\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> INFUV\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>closed_csubspace INFUV; bounded_clinear U;\n        bounded_clinear Uinv;\n        \\<And>\\<psi>.\n           \\<psi> \\<in> INFUV \\<Longrightarrow> U (Uinv \\<psi>) = \\<psi>;\n        x \\<in> INFUV\\<rbrakk>\n       \\<Longrightarrow> x \\<in> closure INFUV", "show \"x \\<in> closure INFUV\"\n      if \"closed_csubspace INFUV\"\n        and \"bounded_clinear U\"\n        and \"bounded_clinear Uinv\"\n        and \"\\<And>\\<psi>. \\<psi> \\<in> INFUV \\<Longrightarrow> U (Uinv \\<psi>) = \\<psi>\"\n        and \"x \\<in> INFUV\"\n      for x :: 'c"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> closure INFUV", "using that"], ["proof (prove)\nusing this:\n  closed_csubspace INFUV\n  bounded_clinear U\n  bounded_clinear Uinv\n  ?\\<psi> \\<in> INFUV \\<Longrightarrow> U (Uinv ?\\<psi>) = ?\\<psi>\n  x \\<in> INFUV\n\ngoal (1 subgoal):\n 1. x \\<in> closure INFUV", "using setdist_eq_0_sing_1 setdist_sing_in_set"], ["proof (prove)\nusing this:\n  closed_csubspace INFUV\n  bounded_clinear U\n  bounded_clinear Uinv\n  ?\\<psi> \\<in> INFUV \\<Longrightarrow> U (Uinv ?\\<psi>) = ?\\<psi>\n  x \\<in> INFUV\n  (setdist {?x} ?S = 0) = (?S = {} \\<or> ?x \\<in> closure ?S)\n  ?x \\<in> ?S \\<Longrightarrow> setdist {?x} ?S = 0\n\ngoal (1 subgoal):\n 1. x \\<in> closure INFUV", "by (simp add: closed_csubspace.closed)"], ["proof (state)\nthis:\n  \\<lbrakk>closed_csubspace INFUV; bounded_clinear U; bounded_clinear Uinv;\n   \\<And>\\<psi>.\n      \\<psi> \\<in> INFUV \\<Longrightarrow> U (Uinv \\<psi>) = \\<psi>;\n   ?x \\<in> INFUV\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> closure INFUV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>closed_csubspace ?INFUV; bounded_clinear ?U;\n   bounded_clinear ?Uinv;\n   \\<And>\\<psi>.\n      \\<psi> \\<in> ?INFUV \\<Longrightarrow>\n      (?U \\<circ> ?Uinv) \\<psi> = \\<psi>\\<rbrakk>\n  \\<Longrightarrow> closure ((?U \\<circ> ?Uinv) ` ?INFUV) = ?INFUV\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "hence \"(U o\\<^sub>C\\<^sub>L Uinv) *\\<^sub>S INFUV = INFUV\""], ["proof (prove)\nusing this:\n  \\<lbrakk>closed_csubspace ?INFUV; bounded_clinear ?U;\n   bounded_clinear ?Uinv;\n   \\<And>\\<psi>.\n      \\<psi> \\<in> ?INFUV \\<Longrightarrow>\n      (?U \\<circ> ?Uinv) \\<psi> = \\<psi>\\<rbrakk>\n  \\<Longrightarrow> closure ((?U \\<circ> ?Uinv) ` ?INFUV) = ?INFUV\n\ngoal (1 subgoal):\n 1. (U o\\<^sub>C\\<^sub>L Uinv) *\\<^sub>S INFUV = INFUV", "by (metis (mono_tags, hide_lams) x cblinfun_image.rep_eq cblinfun_image_id id_cblinfun_apply image_cong \n        space_as_set_inject)"], ["proof (state)\nthis:\n  (U o\\<^sub>C\\<^sub>L Uinv) *\\<^sub>S INFUV = INFUV\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "hence \"INFUV = U *\\<^sub>S Uinv *\\<^sub>S INFUV\""], ["proof (prove)\nusing this:\n  (U o\\<^sub>C\\<^sub>L Uinv) *\\<^sub>S INFUV = INFUV\n\ngoal (1 subgoal):\n 1. INFUV = U *\\<^sub>S Uinv *\\<^sub>S INFUV", "by (simp add: cblinfun_compose_image)"], ["proof (state)\nthis:\n  INFUV = U *\\<^sub>S Uinv *\\<^sub>S INFUV\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "also"], ["proof (state)\nthis:\n  INFUV = U *\\<^sub>S Uinv *\\<^sub>S INFUV\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "have \"\\<dots> \\<le> U *\\<^sub>S (INF i. Uinv *\\<^sub>S U *\\<^sub>S V i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S Uinv *\\<^sub>S INFUV\n    \\<le> U *\\<^sub>S (INF i. Uinv *\\<^sub>S U *\\<^sub>S V i)", "unfolding INFUV_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S Uinv *\\<^sub>S (INF i. U *\\<^sub>S V i)\n    \\<le> U *\\<^sub>S (INF i. Uinv *\\<^sub>S U *\\<^sub>S V i)", "by (metis cblinfun_image_mono cblinfun_image_INF_leq)"], ["proof (state)\nthis:\n  U *\\<^sub>S Uinv *\\<^sub>S INFUV\n  \\<le> U *\\<^sub>S (INF i. Uinv *\\<^sub>S U *\\<^sub>S V i)\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "also"], ["proof (state)\nthis:\n  U *\\<^sub>S Uinv *\\<^sub>S INFUV\n  \\<le> U *\\<^sub>S (INF i. Uinv *\\<^sub>S U *\\<^sub>S V i)\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "have \"\\<dots> = U *\\<^sub>S INFV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S (INF i. Uinv *\\<^sub>S U *\\<^sub>S V i) = U *\\<^sub>S INFV", "using d1"], ["proof (prove)\nusing this:\n  (Uinv o\\<^sub>C\\<^sub>L U) *\\<^sub>S V ?i = V ?i\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S (INF i. Uinv *\\<^sub>S U *\\<^sub>S V i) = U *\\<^sub>S INFV", "by (metis (no_types, lifting) INFV_def cblinfun_assoc_left(2) image_cong)"], ["proof (state)\nthis:\n  U *\\<^sub>S (INF i. Uinv *\\<^sub>S U *\\<^sub>S V i) = U *\\<^sub>S INFV\n\ngoal (1 subgoal):\n 1. (INF i. U *\\<^sub>S V i) \\<le> U *\\<^sub>S \\<Sqinter> (range V)", "finally"], ["proof (chain)\npicking this:\n  INFUV \\<le> U *\\<^sub>S INFV", "show \"INFUV \\<le> U *\\<^sub>S INFV\""], ["proof (prove)\nusing this:\n  INFUV \\<le> U *\\<^sub>S INFV\n\ngoal (1 subgoal):\n 1. INFUV \\<le> U *\\<^sub>S INFV", "."], ["proof (state)\nthis:\n  INFUV \\<le> U *\\<^sub>S INFV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unitary_range[simp]: \n  assumes \"unitary U\"\n  shows \"U *\\<^sub>S top = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<top> = \\<top>", "using assms"], ["proof (prove)\nusing this:\n  unitary U\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<top> = \\<top>", "unfolding unitary_def"], ["proof (prove)\nusing this:\n  U* o\\<^sub>C\\<^sub>L U = id_cblinfun \\<and>\n  U o\\<^sub>C\\<^sub>L U* = id_cblinfun\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<top> = \\<top>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>U.\n       \\<lbrakk>bounded_clinear U;\n        U\\<^sup>\\<dagger> \\<circ> U = (\\<lambda>x. x) \\<and>\n        U \\<circ> U\\<^sup>\\<dagger> = (\\<lambda>x. x)\\<rbrakk>\n       \\<Longrightarrow> closure (range U) = UNIV", "by (metis closure_UNIV comp_apply surj_def)"], ["", "lemma range_adjoint_isometry:\n  assumes \"isometry U\"\n  shows \"U* *\\<^sub>S top = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U* *\\<^sub>S \\<top> = \\<top>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. U* *\\<^sub>S \\<top> = \\<top>", "from assms"], ["proof (chain)\npicking this:\n  isometry U", "have \"top = U* *\\<^sub>S U *\\<^sub>S top\""], ["proof (prove)\nusing this:\n  isometry U\n\ngoal (1 subgoal):\n 1. \\<top> = U* *\\<^sub>S U *\\<^sub>S \\<top>", "by (simp add: cblinfun_assoc_left(2))"], ["proof (state)\nthis:\n  \\<top> = U* *\\<^sub>S U *\\<^sub>S \\<top>\n\ngoal (1 subgoal):\n 1. U* *\\<^sub>S \\<top> = \\<top>", "also"], ["proof (state)\nthis:\n  \\<top> = U* *\\<^sub>S U *\\<^sub>S \\<top>\n\ngoal (1 subgoal):\n 1. U* *\\<^sub>S \\<top> = \\<top>", "have \"\\<dots> \\<le> U* *\\<^sub>S top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U* *\\<^sub>S U *\\<^sub>S \\<top> \\<le> U* *\\<^sub>S \\<top>", "by (simp add: cblinfun_image_mono)"], ["proof (state)\nthis:\n  U* *\\<^sub>S U *\\<^sub>S \\<top> \\<le> U* *\\<^sub>S \\<top>\n\ngoal (1 subgoal):\n 1. U* *\\<^sub>S \\<top> = \\<top>", "finally"], ["proof (chain)\npicking this:\n  \\<top> \\<le> U* *\\<^sub>S \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<top> \\<le> U* *\\<^sub>S \\<top>\n\ngoal (1 subgoal):\n 1. U* *\\<^sub>S \\<top> = \\<top>", "using top.extremum_unique"], ["proof (prove)\nusing this:\n  \\<top> \\<le> U* *\\<^sub>S \\<top>\n  (\\<top> \\<le> ?a) = (?a = \\<top>)\n\ngoal (1 subgoal):\n 1. U* *\\<^sub>S \\<top> = \\<top>", "by blast"], ["proof (state)\nthis:\n  U* *\\<^sub>S \\<top> = \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_image_INF_eq[simp]: \n  fixes V :: \"'a \\<Rightarrow> 'b::chilbert_space ccsubspace\" \n    and U :: \"'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'c::chilbert_space\"\n  assumes \\<open>isometry U\\<close>\n  shows \"U *\\<^sub>S (INF i. V i) = (INF i. U *\\<^sub>S V i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<Sqinter> (range V) = (INF i. U *\\<^sub>S V i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<Sqinter> (range V) = (INF i. U *\\<^sub>S V i)", "from \\<open>isometry U\\<close>"], ["proof (chain)\npicking this:\n  isometry U", "have \"U* o\\<^sub>C\\<^sub>L U o\\<^sub>C\\<^sub>L U* = U*\""], ["proof (prove)\nusing this:\n  isometry U\n\ngoal (1 subgoal):\n 1. U* o\\<^sub>C\\<^sub>L U o\\<^sub>C\\<^sub>L U* = U*", "unfolding isometry_def"], ["proof (prove)\nusing this:\n  U* o\\<^sub>C\\<^sub>L U = id_cblinfun\n\ngoal (1 subgoal):\n 1. U* o\\<^sub>C\\<^sub>L U o\\<^sub>C\\<^sub>L U* = U*", "by simp"], ["proof (state)\nthis:\n  U* o\\<^sub>C\\<^sub>L U o\\<^sub>C\\<^sub>L U* = U*\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<Sqinter> (range V) = (INF i. U *\\<^sub>S V i)", "moreover"], ["proof (state)\nthis:\n  U* o\\<^sub>C\\<^sub>L U o\\<^sub>C\\<^sub>L U* = U*\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<Sqinter> (range V) = (INF i. U *\\<^sub>S V i)", "from \\<open>isometry U\\<close>"], ["proof (chain)\npicking this:\n  isometry U", "have \"U o\\<^sub>C\\<^sub>L U* o\\<^sub>C\\<^sub>L U = U\""], ["proof (prove)\nusing this:\n  isometry U\n\ngoal (1 subgoal):\n 1. U o\\<^sub>C\\<^sub>L U* o\\<^sub>C\\<^sub>L U = U", "unfolding isometry_def"], ["proof (prove)\nusing this:\n  U* o\\<^sub>C\\<^sub>L U = id_cblinfun\n\ngoal (1 subgoal):\n 1. U o\\<^sub>C\\<^sub>L U* o\\<^sub>C\\<^sub>L U = U", "by (simp add: cblinfun_compose_assoc)"], ["proof (state)\nthis:\n  U o\\<^sub>C\\<^sub>L U* o\\<^sub>C\\<^sub>L U = U\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<Sqinter> (range V) = (INF i. U *\\<^sub>S V i)", "moreover"], ["proof (state)\nthis:\n  U o\\<^sub>C\\<^sub>L U* o\\<^sub>C\\<^sub>L U = U\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<Sqinter> (range V) = (INF i. U *\\<^sub>S V i)", "have \"V i \\<le> U* *\\<^sub>S top\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. V i \\<le> U* *\\<^sub>S \\<top>", "by (simp add: range_adjoint_isometry assms)"], ["proof (state)\nthis:\n  V ?i \\<le> U* *\\<^sub>S \\<top>\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<Sqinter> (range V) = (INF i. U *\\<^sub>S V i)", "ultimately"], ["proof (chain)\npicking this:\n  U* o\\<^sub>C\\<^sub>L U o\\<^sub>C\\<^sub>L U* = U*\n  U o\\<^sub>C\\<^sub>L U* o\\<^sub>C\\<^sub>L U = U\n  V ?i \\<le> U* *\\<^sub>S \\<top>", "show ?thesis"], ["proof (prove)\nusing this:\n  U* o\\<^sub>C\\<^sub>L U o\\<^sub>C\\<^sub>L U* = U*\n  U o\\<^sub>C\\<^sub>L U* o\\<^sub>C\\<^sub>L U = U\n  V ?i \\<le> U* *\\<^sub>S \\<top>\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S \\<Sqinter> (range V) = (INF i. U *\\<^sub>S V i)", "by (rule cblinfun_image_INF_eq_general)"], ["proof (state)\nthis:\n  U *\\<^sub>S \\<Sqinter> (range V) = (INF i. U *\\<^sub>S V i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isometry_cblinfun_image_inf_distrib[simp]:\n  fixes U::\\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::chilbert_space\\<close>\n    and X Y::\"'a ccsubspace\"\n  assumes \"isometry U\"\n  shows \"U *\\<^sub>S (inf X Y) = inf (U *\\<^sub>S X) (U *\\<^sub>S Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U *\\<^sub>S X \\<sqinter> Y = U *\\<^sub>S X \\<sqinter> (U *\\<^sub>S Y)", "using cblinfun_image_INF_eq[where V=\"\\<lambda>b. if b then X else Y\" and U=U]"], ["proof (prove)\nusing this:\n  isometry U \\<Longrightarrow>\n  U *\\<^sub>S (INF i. if i then X else Y) =\n  (INF i. U *\\<^sub>S (if i then X else Y))\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S X \\<sqinter> Y = U *\\<^sub>S X \\<sqinter> (U *\\<^sub>S Y)", "unfolding INF_UNIV_bool_expand"], ["proof (prove)\nusing this:\n  isometry U \\<Longrightarrow>\n  U *\\<^sub>S (if True then X else Y) \\<sqinter> (if False then X else Y) =\n  U *\\<^sub>S (if True then X else Y) \\<sqinter>\n  (U *\\<^sub>S (if False then X else Y))\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S X \\<sqinter> Y = U *\\<^sub>S X \\<sqinter> (U *\\<^sub>S Y)", "using assms"], ["proof (prove)\nusing this:\n  isometry U \\<Longrightarrow>\n  U *\\<^sub>S (if True then X else Y) \\<sqinter> (if False then X else Y) =\n  U *\\<^sub>S (if True then X else Y) \\<sqinter>\n  (U *\\<^sub>S (if False then X else Y))\n  isometry U\n\ngoal (1 subgoal):\n 1. U *\\<^sub>S X \\<sqinter> Y = U *\\<^sub>S X \\<sqinter> (U *\\<^sub>S Y)", "by auto"], ["", "lemma cblinfun_image_ccspan: \n  shows \"A *\\<^sub>S ccspan G = ccspan ((*\\<^sub>V) A ` G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>S ccspan G = ccspan ((*\\<^sub>V) A ` G)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A G.\n       bounded_clinear A \\<Longrightarrow>\n       closure (A ` closure (cspan G)) = closure (cspan (A ` G))", "by (simp add: bounded_clinear.bounded_linear bounded_clinear_def closure_bounded_linear_image_subset_eq complex_vector.linear_span_image)"], ["", "lemma cblinfun_apply_in_image[simp]: \"A *\\<^sub>V \\<psi> \\<in> space_as_set (A *\\<^sub>S \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<psi> \\<in> space_as_set (A *\\<^sub>S \\<top>)", "by (metis cblinfun_image.rep_eq closure_subset in_mono range_eqI top_ccsubspace.rep_eq)"], ["", "lemma cblinfun_plus_image_distr:\n  \\<open>(A + B) *\\<^sub>S S \\<le> A *\\<^sub>S S \\<squnion> B *\\<^sub>S S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A + B) *\\<^sub>S S \\<le> A *\\<^sub>S S \\<squnion> B *\\<^sub>S S", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B S.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B;\n        closed_csubspace S\\<rbrakk>\n       \\<Longrightarrow> closure ((\\<lambda>x. A x + B x) ` S)\n                         \\<subseteq> closure (A ` S) +\\<^sub>M\n                                     closure (B ` S)", "by (smt (verit, ccfv_threshold) closed_closure closed_sum_def closure_minimal closure_subset image_subset_iff set_plus_intro subset_eq)"], ["", "lemma cblinfun_sum_image_distr:\n  \\<open>(\\<Sum>i\\<in>I. A i) *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum A I *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)", "proof (cases \\<open>finite I\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite I \\<Longrightarrow>\n    sum A I *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)\n 2. infinite I \\<Longrightarrow>\n    sum A I *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)", "case True"], ["proof (state)\nthis:\n  finite I\n\ngoal (2 subgoals):\n 1. finite I \\<Longrightarrow>\n    sum A I *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)\n 2. infinite I \\<Longrightarrow>\n    sum A I *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)", "then"], ["proof (chain)\npicking this:\n  finite I", "show ?thesis"], ["proof (prove)\nusing this:\n  finite I\n\ngoal (1 subgoal):\n 1. sum A I *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. sum A {} *\\<^sub>S S \\<le> (SUP i\\<in>{}. A i *\\<^sub>S S)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        sum A F *\\<^sub>S S \\<le> (SUP i\\<in>F. A i *\\<^sub>S S)\\<rbrakk>\n       \\<Longrightarrow> sum A (insert x F) *\\<^sub>S S\n                         \\<le> (SUP i\\<in>insert x F. A i *\\<^sub>S S)", "case empty"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sum A {} *\\<^sub>S S \\<le> (SUP i\\<in>{}. A i *\\<^sub>S S)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        sum A F *\\<^sub>S S \\<le> (SUP i\\<in>F. A i *\\<^sub>S S)\\<rbrakk>\n       \\<Longrightarrow> sum A (insert x F) *\\<^sub>S S\n                         \\<le> (SUP i\\<in>insert x F. A i *\\<^sub>S S)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum A {} *\\<^sub>S S \\<le> (SUP i\\<in>{}. A i *\\<^sub>S S)", "by auto"], ["proof (state)\nthis:\n  sum A {} *\\<^sub>S S \\<le> (SUP i\\<in>{}. A i *\\<^sub>S S)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        sum A F *\\<^sub>S S \\<le> (SUP i\\<in>F. A i *\\<^sub>S S)\\<rbrakk>\n       \\<Longrightarrow> sum A (insert x F) *\\<^sub>S S\n                         \\<le> (SUP i\\<in>insert x F. A i *\\<^sub>S S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        sum A F *\\<^sub>S S \\<le> (SUP i\\<in>F. A i *\\<^sub>S S)\\<rbrakk>\n       \\<Longrightarrow> sum A (insert x F) *\\<^sub>S S\n                         \\<le> (SUP i\\<in>insert x F. A i *\\<^sub>S S)", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  sum A F *\\<^sub>S S \\<le> (SUP i\\<in>F. A i *\\<^sub>S S)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        sum A F *\\<^sub>S S \\<le> (SUP i\\<in>F. A i *\\<^sub>S S)\\<rbrakk>\n       \\<Longrightarrow> sum A (insert x F) *\\<^sub>S S\n                         \\<le> (SUP i\\<in>insert x F. A i *\\<^sub>S S)", "then"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  sum A F *\\<^sub>S S \\<le> (SUP i\\<in>F. A i *\\<^sub>S S)", "show ?case"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  sum A F *\\<^sub>S S \\<le> (SUP i\\<in>F. A i *\\<^sub>S S)\n\ngoal (1 subgoal):\n 1. sum A (insert x F) *\\<^sub>S S\n    \\<le> (SUP i\\<in>insert x F. A i *\\<^sub>S S)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F; x \\<notin> F;\n     sum A F *\\<^sub>S S \\<le> (SUP i\\<in>F. A i *\\<^sub>S S)\\<rbrakk>\n    \\<Longrightarrow> (A x + sum A F) *\\<^sub>S S\n                      \\<le> A x *\\<^sub>S S \\<squnion>\n                            (SUP i\\<in>F. A i *\\<^sub>S S)", "by (smt (z3) cblinfun_plus_image_distr inf_sup_aci(6) le_iff_sup)"], ["proof (state)\nthis:\n  sum A (insert x F) *\\<^sub>S S\n  \\<le> (SUP i\\<in>insert x F. A i *\\<^sub>S S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum A I *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)\n\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow>\n    sum A I *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow>\n    sum A I *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)", "case False"], ["proof (state)\nthis:\n  infinite I\n\ngoal (1 subgoal):\n 1. infinite I \\<Longrightarrow>\n    sum A I *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)", "then"], ["proof (chain)\npicking this:\n  infinite I", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite I\n\ngoal (1 subgoal):\n 1. sum A I *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)", "by auto"], ["proof (state)\nthis:\n  sum A I *\\<^sub>S S \\<le> (SUP i\\<in>I. A i *\\<^sub>S S)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Sandwiches\\<close>"], ["", "lift_definition sandwich :: \\<open>('a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_inner) \\<Rightarrow> (('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a) \\<Rightarrow>\\<^sub>C\\<^sub>L ('b \\<Rightarrow>\\<^sub>C\\<^sub>L 'b))\\<close> is\n  \\<open>\\<lambda>(A::'a\\<Rightarrow>\\<^sub>C\\<^sub>L'b) B. A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cblinfun.\n       bounded_clinear\n        (\\<lambda>B.\n            cblinfun o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L cblinfun*)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cblinfun b1 b2.\n       cblinfun o\\<^sub>C\\<^sub>L b1 + b2 o\\<^sub>C\\<^sub>L cblinfun* =\n       (cblinfun o\\<^sub>C\\<^sub>L b1 o\\<^sub>C\\<^sub>L cblinfun*) +\n       (cblinfun o\\<^sub>C\\<^sub>L b2 o\\<^sub>C\\<^sub>L cblinfun*)\n 2. \\<And>cblinfun r b.\n       cblinfun o\\<^sub>C\\<^sub>L r *\\<^sub>C b o\\<^sub>C\\<^sub>L\n       cblinfun* =\n       r *\\<^sub>C\n       (cblinfun o\\<^sub>C\\<^sub>L b o\\<^sub>C\\<^sub>L cblinfun*)\n 3. \\<And>cblinfun.\n       \\<exists>K.\n          \\<forall>x.\n             norm (cblinfun o\\<^sub>C\\<^sub>L x o\\<^sub>C\\<^sub>L cblinfun*)\n             \\<le> norm x * K", "fix A :: \\<open>'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\\<close> and B B1 B2 :: \\<open>'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\\<close> and c :: complex"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cblinfun b1 b2.\n       cblinfun o\\<^sub>C\\<^sub>L b1 + b2 o\\<^sub>C\\<^sub>L cblinfun* =\n       (cblinfun o\\<^sub>C\\<^sub>L b1 o\\<^sub>C\\<^sub>L cblinfun*) +\n       (cblinfun o\\<^sub>C\\<^sub>L b2 o\\<^sub>C\\<^sub>L cblinfun*)\n 2. \\<And>cblinfun r b.\n       cblinfun o\\<^sub>C\\<^sub>L r *\\<^sub>C b o\\<^sub>C\\<^sub>L\n       cblinfun* =\n       r *\\<^sub>C\n       (cblinfun o\\<^sub>C\\<^sub>L b o\\<^sub>C\\<^sub>L cblinfun*)\n 3. \\<And>cblinfun.\n       \\<exists>K.\n          \\<forall>x.\n             norm (cblinfun o\\<^sub>C\\<^sub>L x o\\<^sub>C\\<^sub>L cblinfun*)\n             \\<le> norm x * K", "show \\<open>A o\\<^sub>C\\<^sub>L (B1 + B2) o\\<^sub>C\\<^sub>L A* = (A o\\<^sub>C\\<^sub>L B1 o\\<^sub>C\\<^sub>L A*) + (A o\\<^sub>C\\<^sub>L B2 o\\<^sub>C\\<^sub>L A*)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A o\\<^sub>C\\<^sub>L B1 + B2 o\\<^sub>C\\<^sub>L A* =\n    (A o\\<^sub>C\\<^sub>L B1 o\\<^sub>C\\<^sub>L A*) +\n    (A o\\<^sub>C\\<^sub>L B2 o\\<^sub>C\\<^sub>L A*)", "by (simp add: cblinfun_compose_add_left cblinfun_compose_add_right)"], ["proof (state)\nthis:\n  A o\\<^sub>C\\<^sub>L B1 + B2 o\\<^sub>C\\<^sub>L A* =\n  (A o\\<^sub>C\\<^sub>L B1 o\\<^sub>C\\<^sub>L A*) +\n  (A o\\<^sub>C\\<^sub>L B2 o\\<^sub>C\\<^sub>L A*)\n\ngoal (2 subgoals):\n 1. \\<And>cblinfun r b.\n       cblinfun o\\<^sub>C\\<^sub>L r *\\<^sub>C b o\\<^sub>C\\<^sub>L\n       cblinfun* =\n       r *\\<^sub>C\n       (cblinfun o\\<^sub>C\\<^sub>L b o\\<^sub>C\\<^sub>L cblinfun*)\n 2. \\<And>cblinfun.\n       \\<exists>K.\n          \\<forall>x.\n             norm (cblinfun o\\<^sub>C\\<^sub>L x o\\<^sub>C\\<^sub>L cblinfun*)\n             \\<le> norm x * K", "show \\<open>A o\\<^sub>C\\<^sub>L (c *\\<^sub>C B) o\\<^sub>C\\<^sub>L A* = c *\\<^sub>C (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A o\\<^sub>C\\<^sub>L c *\\<^sub>C B o\\<^sub>C\\<^sub>L A* =\n    c *\\<^sub>C (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)", "by auto"], ["proof (state)\nthis:\n  A o\\<^sub>C\\<^sub>L c *\\<^sub>C B o\\<^sub>C\\<^sub>L A* =\n  c *\\<^sub>C (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n\ngoal (1 subgoal):\n 1. \\<And>cblinfun.\n       \\<exists>K.\n          \\<forall>x.\n             norm (cblinfun o\\<^sub>C\\<^sub>L x o\\<^sub>C\\<^sub>L cblinfun*)\n             \\<le> norm x * K", "show \\<open>\\<exists>K. \\<forall>B. norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*) \\<le> norm B * K\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>B.\n          norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*) \\<le> norm B * K", "proof (rule exI[of _ \\<open>norm A * norm (A*)\\<close>], rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n       \\<le> norm B * (norm A * norm (A*))", "fix B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B.\n       norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n       \\<le> norm B * (norm A * norm (A*))", "have \\<open>norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*) \\<le> norm (A o\\<^sub>C\\<^sub>L B) * norm (A*)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n    \\<le> norm (A o\\<^sub>C\\<^sub>L B) * norm (A*)", "using norm_cblinfun_compose"], ["proof (prove)\nusing this:\n  norm (?f o\\<^sub>C\\<^sub>L ?g) \\<le> norm ?f * norm ?g\n\ngoal (1 subgoal):\n 1. norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n    \\<le> norm (A o\\<^sub>C\\<^sub>L B) * norm (A*)", "by blast"], ["proof (state)\nthis:\n  norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n  \\<le> norm (A o\\<^sub>C\\<^sub>L B) * norm (A*)\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n       \\<le> norm B * (norm A * norm (A*))", "also"], ["proof (state)\nthis:\n  norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n  \\<le> norm (A o\\<^sub>C\\<^sub>L B) * norm (A*)\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n       \\<le> norm B * (norm A * norm (A*))", "have \\<open>\\<dots> \\<le> (norm A * norm B) * norm (A*)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A o\\<^sub>C\\<^sub>L B) * norm (A*)\n    \\<le> norm A * norm B * norm (A*)", "by (simp add: mult_right_mono norm_cblinfun_compose)"], ["proof (state)\nthis:\n  norm (A o\\<^sub>C\\<^sub>L B) * norm (A*) \\<le> norm A * norm B * norm (A*)\n\ngoal (1 subgoal):\n 1. \\<And>B.\n       norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n       \\<le> norm B * (norm A * norm (A*))", "finally"], ["proof (chain)\npicking this:\n  norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n  \\<le> norm A * norm B * norm (A*)", "show \\<open>norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*) \\<le> norm B * (norm A * norm (A*))\\<close>"], ["proof (prove)\nusing this:\n  norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n  \\<le> norm A * norm B * norm (A*)\n\ngoal (1 subgoal):\n 1. norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n    \\<le> norm B * (norm A * norm (A*))", "by (simp add: mult.assoc vector_space_over_itself.scale_left_commute)"], ["proof (state)\nthis:\n  norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*)\n  \\<le> norm B * (norm A * norm (A*))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>K.\n     \\<forall>B.\n        norm (A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*) \\<le> norm B * K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sandwich_0[simp]: \\<open>sandwich 0 = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sandwich 0 = 0", "by (simp add: cblinfun_eqI sandwich.rep_eq)"], ["", "lemma sandwich_apply: \\<open>sandwich A *\\<^sub>V B = A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V B = A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*", "apply (transfer fixing: A B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A* =\n    A o\\<^sub>C\\<^sub>L B o\\<^sub>C\\<^sub>L A*", "by auto"], ["", "lemma norm_sandwich: \\<open>norm (sandwich A) = (norm A)\\<^sup>2\\<close> for A :: \\<open>'a::{chilbert_space} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::{complex_inner}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (sandwich A) = (norm A)\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm (sandwich A) = (norm A)\\<^sup>2", "have main: \\<open>norm (sandwich A) = (norm A)\\<^sup>2\\<close> for A :: \\<open>'c::{chilbert_space,not_singleton} \\<Rightarrow>\\<^sub>C\\<^sub>L 'd::{complex_inner}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (sandwich A) = (norm A)\\<^sup>2", "proof (rule norm_cblinfun_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. (norm A)\\<^sup>2 \\<le> norm (sandwich A *\\<^sub>V ?x) / norm ?x\n 2. \\<And>x. norm (sandwich A *\\<^sub>V x) \\<le> (norm A)\\<^sup>2 * norm x\n 3. 0 \\<le> (norm A)\\<^sup>2", "show \\<open>(norm A)\\<^sup>2 \\<le> norm (sandwich A *\\<^sub>V id_cblinfun) / norm (id_cblinfun :: 'c \\<Rightarrow>\\<^sub>C\\<^sub>L _)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm A)\\<^sup>2\n    \\<le> norm (sandwich A *\\<^sub>V id_cblinfun) / norm id_cblinfun", "apply (auto simp: sandwich_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "by -"], ["proof (state)\nthis:\n  (norm A)\\<^sup>2\n  \\<le> norm (sandwich A *\\<^sub>V id_cblinfun) / norm id_cblinfun\n\ngoal (2 subgoals):\n 1. \\<And>x. norm (sandwich A *\\<^sub>V x) \\<le> (norm A)\\<^sup>2 * norm x\n 2. 0 \\<le> (norm A)\\<^sup>2", "fix B"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. norm (sandwich A *\\<^sub>V x) \\<le> (norm A)\\<^sup>2 * norm x\n 2. 0 \\<le> (norm A)\\<^sup>2", "have \\<open>norm (sandwich A *\\<^sub>V B) \\<le> norm (A o\\<^sub>C\\<^sub>L B) * norm (A*)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (sandwich A *\\<^sub>V B)\n    \\<le> norm (A o\\<^sub>C\\<^sub>L B) * norm (A*)", "using norm_cblinfun_compose"], ["proof (prove)\nusing this:\n  norm (?f o\\<^sub>C\\<^sub>L ?g) \\<le> norm ?f * norm ?g\n\ngoal (1 subgoal):\n 1. norm (sandwich A *\\<^sub>V B)\n    \\<le> norm (A o\\<^sub>C\\<^sub>L B) * norm (A*)", "by (auto simp: sandwich_apply simp del: norm_adj)"], ["proof (state)\nthis:\n  norm (sandwich A *\\<^sub>V B)\n  \\<le> norm (A o\\<^sub>C\\<^sub>L B) * norm (A*)\n\ngoal (2 subgoals):\n 1. \\<And>x. norm (sandwich A *\\<^sub>V x) \\<le> (norm A)\\<^sup>2 * norm x\n 2. 0 \\<le> (norm A)\\<^sup>2", "also"], ["proof (state)\nthis:\n  norm (sandwich A *\\<^sub>V B)\n  \\<le> norm (A o\\<^sub>C\\<^sub>L B) * norm (A*)\n\ngoal (2 subgoals):\n 1. \\<And>x. norm (sandwich A *\\<^sub>V x) \\<le> (norm A)\\<^sup>2 * norm x\n 2. 0 \\<le> (norm A)\\<^sup>2", "have \\<open>\\<dots> \\<le> (norm A * norm B) * norm (A*)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A o\\<^sub>C\\<^sub>L B) * norm (A*)\n    \\<le> norm A * norm B * norm (A*)", "by (simp add: mult_right_mono norm_cblinfun_compose)"], ["proof (state)\nthis:\n  norm (A o\\<^sub>C\\<^sub>L B) * norm (A*) \\<le> norm A * norm B * norm (A*)\n\ngoal (2 subgoals):\n 1. \\<And>x. norm (sandwich A *\\<^sub>V x) \\<le> (norm A)\\<^sup>2 * norm x\n 2. 0 \\<le> (norm A)\\<^sup>2", "also"], ["proof (state)\nthis:\n  norm (A o\\<^sub>C\\<^sub>L B) * norm (A*) \\<le> norm A * norm B * norm (A*)\n\ngoal (2 subgoals):\n 1. \\<And>x. norm (sandwich A *\\<^sub>V x) \\<le> (norm A)\\<^sup>2 * norm x\n 2. 0 \\<le> (norm A)\\<^sup>2", "have \\<open>\\<dots> \\<le> (norm A)\\<^sup>2 * norm B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm A * norm B * norm (A*) \\<le> (norm A)\\<^sup>2 * norm B", "by (simp add: power2_eq_square mult.assoc vector_space_over_itself.scale_left_commute)"], ["proof (state)\nthis:\n  norm A * norm B * norm (A*) \\<le> (norm A)\\<^sup>2 * norm B\n\ngoal (2 subgoals):\n 1. \\<And>x. norm (sandwich A *\\<^sub>V x) \\<le> (norm A)\\<^sup>2 * norm x\n 2. 0 \\<le> (norm A)\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  norm (sandwich A *\\<^sub>V B) \\<le> (norm A)\\<^sup>2 * norm B", "show \\<open>norm (sandwich A *\\<^sub>V B) \\<le> (norm A)\\<^sup>2 * norm B\\<close>"], ["proof (prove)\nusing this:\n  norm (sandwich A *\\<^sub>V B) \\<le> (norm A)\\<^sup>2 * norm B\n\ngoal (1 subgoal):\n 1. norm (sandwich A *\\<^sub>V B) \\<le> (norm A)\\<^sup>2 * norm B", "by -"], ["proof (state)\nthis:\n  norm (sandwich A *\\<^sub>V B) \\<le> (norm A)\\<^sup>2 * norm B\n\ngoal (1 subgoal):\n 1. 0 \\<le> (norm A)\\<^sup>2", "show \\<open>0 \\<le> (norm A)\\<^sup>2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (norm A)\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (norm A)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (sandwich ?A1) = (norm ?A1)\\<^sup>2\n\ngoal (1 subgoal):\n 1. norm (sandwich A) = (norm A)\\<^sup>2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (sandwich A) = (norm A)\\<^sup>2", "proof (cases \\<open>class.not_singleton TYPE('a)\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. class.not_singleton TYPE('a) \\<Longrightarrow>\n    norm (sandwich A) = (norm A)\\<^sup>2\n 2. \\<not> class.not_singleton TYPE('a) \\<Longrightarrow>\n    norm (sandwich A) = (norm A)\\<^sup>2", "case True"], ["proof (state)\nthis:\n  class.not_singleton TYPE('a)\n\ngoal (2 subgoals):\n 1. class.not_singleton TYPE('a) \\<Longrightarrow>\n    norm (sandwich A) = (norm A)\\<^sup>2\n 2. \\<not> class.not_singleton TYPE('a) \\<Longrightarrow>\n    norm (sandwich A) = (norm A)\\<^sup>2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (sandwich A) = (norm A)\\<^sup>2", "apply (rule main[internalize_sort' 'c2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.chilbert_space (*\\<^sub>R) (*\\<^sub>C) (+) (0::'a) (-) uminus dist\n     norm sgn uniformity open (\\<bullet>\\<^sub>C)\n 2. class.not_singleton TYPE('a)", "apply standard[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.not_singleton TYPE('a)", "using True"], ["proof (prove)\nusing this:\n  class.not_singleton TYPE('a)\n\ngoal (1 subgoal):\n 1. class.not_singleton TYPE('a)", "by simp"], ["proof (state)\nthis:\n  norm (sandwich A) = (norm A)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> class.not_singleton TYPE('a) \\<Longrightarrow>\n    norm (sandwich A) = (norm A)\\<^sup>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> class.not_singleton TYPE('a) \\<Longrightarrow>\n    norm (sandwich A) = (norm A)\\<^sup>2", "case False"], ["proof (state)\nthis:\n  \\<not> class.not_singleton TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<not> class.not_singleton TYPE('a) \\<Longrightarrow>\n    norm (sandwich A) = (norm A)\\<^sup>2", "have \\<open>A = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 0", "apply (rule cblinfun_from_CARD_1_0[internalize_sort' 'a])"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.CARD_1 TYPE('a)\n 2. class.complex_normed_vector (*\\<^sub>R) (*\\<^sub>C) (+) (0::'a) (-)\n     uminus dist norm sgn uniformity open", "apply (rule not_singleton_vs_CARD_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> class.not_singleton TYPE('a)\n 2. class.complex_normed_vector (*\\<^sub>R) (*\\<^sub>C) (+) (0::'a) (-)\n     uminus dist norm sgn uniformity open", "apply (rule False)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.complex_normed_vector (*\\<^sub>R) (*\\<^sub>C) (+) (0::'a) (-)\n     uminus dist norm sgn uniformity open", "by standard"], ["proof (state)\nthis:\n  A = 0\n\ngoal (1 subgoal):\n 1. \\<not> class.not_singleton TYPE('a) \\<Longrightarrow>\n    norm (sandwich A) = (norm A)\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  A = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  A = 0\n\ngoal (1 subgoal):\n 1. norm (sandwich A) = (norm A)\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  norm (sandwich A) = (norm A)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (sandwich A) = (norm A)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sandwich_apply_adj: \\<open>sandwich A (B*) = (sandwich A B)*\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V B* = (sandwich A *\\<^sub>V B)*", "by (simp add: cblinfun_assoc_left(1) sandwich_apply)"], ["", "lemma sandwich_id[simp]: \"sandwich id_cblinfun = id_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sandwich id_cblinfun = id_cblinfun", "apply (rule cblinfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. sandwich id_cblinfun *\\<^sub>V i = id_cblinfun *\\<^sub>V i", "by (auto simp: sandwich_apply)"], ["", "subsection \\<open>Projectors\\<close>"], ["", "lift_definition Proj :: \"('a::chilbert_space) ccsubspace \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L'a\"\n  is \\<open>projection\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       closed_csubspace set \\<Longrightarrow>\n       bounded_clinear (projection set)", "by (rule projection_bounded_clinear)"], ["", "lemma Proj_range[simp]: \"Proj S *\\<^sub>S top = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj S *\\<^sub>S \\<top> = S", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       closed_csubspace S \\<Longrightarrow>\n       closure (range (projection S)) = S", "fix S :: \\<open>'a set\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       closed_csubspace S \\<Longrightarrow>\n       closure (range (projection S)) = S", "assume \\<open>closed_csubspace S\\<close>"], ["proof (state)\nthis:\n  closed_csubspace S\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       closed_csubspace S \\<Longrightarrow>\n       closure (range (projection S)) = S", "then"], ["proof (chain)\npicking this:\n  closed_csubspace S", "have \"closure (range (projection S)) \\<subseteq> S\""], ["proof (prove)\nusing this:\n  closed_csubspace S\n\ngoal (1 subgoal):\n 1. closure (range (projection S)) \\<subseteq> S", "by (metis closed_csubspace.closed closed_csubspace.subspace closure_closed complex_vector.subspace_0 csubspace_is_convex dual_order.eq_iff insert_absorb insert_not_empty projection_image)"], ["proof (state)\nthis:\n  closure (range (projection S)) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       closed_csubspace S \\<Longrightarrow>\n       closure (range (projection S)) = S", "moreover"], ["proof (state)\nthis:\n  closure (range (projection S)) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       closed_csubspace S \\<Longrightarrow>\n       closure (range (projection S)) = S", "have \"S \\<subseteq> closure (range (projection S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> closure (range (projection S))", "using \\<open>closed_csubspace S\\<close>"], ["proof (prove)\nusing this:\n  closed_csubspace S\n\ngoal (1 subgoal):\n 1. S \\<subseteq> closure (range (projection S))", "by (metis closed_csubspace_def closure_subset csubspace_is_convex equals0D projection_image subset_iff)"], ["proof (state)\nthis:\n  S \\<subseteq> closure (range (projection S))\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       closed_csubspace S \\<Longrightarrow>\n       closure (range (projection S)) = S", "ultimately"], ["proof (chain)\npicking this:\n  closure (range (projection S)) \\<subseteq> S\n  S \\<subseteq> closure (range (projection S))", "show \\<open>closure (range (projection S)) = S\\<close>"], ["proof (prove)\nusing this:\n  closure (range (projection S)) \\<subseteq> S\n  S \\<subseteq> closure (range (projection S))\n\ngoal (1 subgoal):\n 1. closure (range (projection S)) = S", "by auto"], ["proof (state)\nthis:\n  closure (range (projection S)) = S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adj_Proj: \\<open>(Proj M)* = Proj M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj M* = Proj M", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       closed_csubspace M \\<Longrightarrow>\n       projection M\\<^sup>\\<dagger> = projection M", "by (simp add: projection_cadjoint)"], ["", "lemma Proj_idempotent[simp]: \\<open>Proj M o\\<^sub>C\\<^sub>L Proj M = Proj M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj M o\\<^sub>C\\<^sub>L Proj M = Proj M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Proj M o\\<^sub>C\\<^sub>L Proj M = Proj M", "have u1: \\<open>(cblinfun_apply (Proj M)) = projection (space_as_set M)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (*\\<^sub>V) (Proj M) = projection (space_as_set M)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M.\n       closed_csubspace M \\<Longrightarrow> projection M = projection M", "by blast"], ["proof (state)\nthis:\n  (*\\<^sub>V) (Proj M) = projection (space_as_set M)\n\ngoal (1 subgoal):\n 1. Proj M o\\<^sub>C\\<^sub>L Proj M = Proj M", "have \\<open>closed_csubspace (space_as_set M)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (space_as_set M)", "using space_as_set"], ["proof (prove)\nusing this:\n  space_as_set ?x \\<in> {S. closed_csubspace S}\n\ngoal (1 subgoal):\n 1. closed_csubspace (space_as_set M)", "by auto"], ["proof (state)\nthis:\n  closed_csubspace (space_as_set M)\n\ngoal (1 subgoal):\n 1. Proj M o\\<^sub>C\\<^sub>L Proj M = Proj M", "hence u2: \\<open>(projection (space_as_set M))\\<circ>(projection (space_as_set M))\n                = (projection (space_as_set M))\\<close>"], ["proof (prove)\nusing this:\n  closed_csubspace (space_as_set M)\n\ngoal (1 subgoal):\n 1. projection (space_as_set M) \\<circ> projection (space_as_set M) =\n    projection (space_as_set M)", "using projection_idem"], ["proof (prove)\nusing this:\n  closed_csubspace (space_as_set M)\n  closed_csubspace ?M \\<Longrightarrow>\n  projection ?M (projection ?M ?x) = projection ?M ?x\n\ngoal (1 subgoal):\n 1. projection (space_as_set M) \\<circ> projection (space_as_set M) =\n    projection (space_as_set M)", "by fastforce"], ["proof (state)\nthis:\n  projection (space_as_set M) \\<circ> projection (space_as_set M) =\n  projection (space_as_set M)\n\ngoal (1 subgoal):\n 1. Proj M o\\<^sub>C\\<^sub>L Proj M = Proj M", "have \\<open>(cblinfun_apply (Proj M)) \\<circ> (cblinfun_apply (Proj M)) = cblinfun_apply (Proj M)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (*\\<^sub>V) (Proj M) \\<circ> (*\\<^sub>V) (Proj M) = (*\\<^sub>V) (Proj M)", "using u1 u2"], ["proof (prove)\nusing this:\n  (*\\<^sub>V) (Proj M) = projection (space_as_set M)\n  projection (space_as_set M) \\<circ> projection (space_as_set M) =\n  projection (space_as_set M)\n\ngoal (1 subgoal):\n 1. (*\\<^sub>V) (Proj M) \\<circ> (*\\<^sub>V) (Proj M) = (*\\<^sub>V) (Proj M)", "by simp"], ["proof (state)\nthis:\n  (*\\<^sub>V) (Proj M) \\<circ> (*\\<^sub>V) (Proj M) = (*\\<^sub>V) (Proj M)\n\ngoal (1 subgoal):\n 1. Proj M o\\<^sub>C\\<^sub>L Proj M = Proj M", "hence \\<open>cblinfun_apply ((Proj M) o\\<^sub>C\\<^sub>L (Proj M)) = cblinfun_apply (Proj M)\\<close>"], ["proof (prove)\nusing this:\n  (*\\<^sub>V) (Proj M) \\<circ> (*\\<^sub>V) (Proj M) = (*\\<^sub>V) (Proj M)\n\ngoal (1 subgoal):\n 1. (*\\<^sub>V) (Proj M o\\<^sub>C\\<^sub>L Proj M) = (*\\<^sub>V) (Proj M)", "by (simp add: cblinfun_compose.rep_eq)"], ["proof (state)\nthis:\n  (*\\<^sub>V) (Proj M o\\<^sub>C\\<^sub>L Proj M) = (*\\<^sub>V) (Proj M)\n\ngoal (1 subgoal):\n 1. Proj M o\\<^sub>C\\<^sub>L Proj M = Proj M", "thus ?thesis"], ["proof (prove)\nusing this:\n  (*\\<^sub>V) (Proj M o\\<^sub>C\\<^sub>L Proj M) = (*\\<^sub>V) (Proj M)\n\ngoal (1 subgoal):\n 1. Proj M o\\<^sub>C\\<^sub>L Proj M = Proj M", "using cblinfun_apply_inject"], ["proof (prove)\nusing this:\n  (*\\<^sub>V) (Proj M o\\<^sub>C\\<^sub>L Proj M) = (*\\<^sub>V) (Proj M)\n  ((*\\<^sub>V) ?x = (*\\<^sub>V) ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. Proj M o\\<^sub>C\\<^sub>L Proj M = Proj M", "by auto"], ["proof (state)\nthis:\n  Proj M o\\<^sub>C\\<^sub>L Proj M = Proj M\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition is_Proj::\\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'a \\<Rightarrow> bool\\<close> is\n  \\<open>\\<lambda>P. \\<exists>M. closed_csubspace M \\<and> is_projection_on P M\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Proj_on_own_range':\n  fixes P :: \\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L'a\\<close>\n  assumes \\<open>P o\\<^sub>C\\<^sub>L P = P\\<close> and \\<open>P = P*\\<close>\n  shows \\<open>Proj (P *\\<^sub>S top) = P\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "define M where \"M = P *\\<^sub>S top\""], ["proof (state)\nthis:\n  M = P *\\<^sub>S \\<top>\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "have v3: \"x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0}\"\n    if \"x \\<in> range (cblinfun_apply P)\"\n    for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "have v3_1: \\<open>cblinfun_apply P \\<circ> cblinfun_apply P = cblinfun_apply P\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (*\\<^sub>V) P \\<circ> (*\\<^sub>V) P = (*\\<^sub>V) P", "by (metis \\<open>P o\\<^sub>C\\<^sub>L P = P\\<close> cblinfun_compose.rep_eq)"], ["proof (state)\nthis:\n  (*\\<^sub>V) P \\<circ> (*\\<^sub>V) P = (*\\<^sub>V) P\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "have \\<open>\\<exists>t. P *\\<^sub>V t = x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. P *\\<^sub>V t = x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> range ((*\\<^sub>V) P)\n\ngoal (1 subgoal):\n 1. \\<exists>t. P *\\<^sub>V t = x", "by blast"], ["proof (state)\nthis:\n  \\<exists>t. P *\\<^sub>V t = x\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "then"], ["proof (chain)\npicking this:\n  \\<exists>t. P *\\<^sub>V t = x", "obtain t where t_def: \\<open>P *\\<^sub>V t = x\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>t. P *\\<^sub>V t = x\n\ngoal (1 subgoal):\n 1. (\\<And>t. P *\\<^sub>V t = x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P *\\<^sub>V t = x\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "hence \\<open>x - P *\\<^sub>V x = x - P *\\<^sub>V (P *\\<^sub>V t)\\<close>"], ["proof (prove)\nusing this:\n  P *\\<^sub>V t = x\n\ngoal (1 subgoal):\n 1. x - P *\\<^sub>V x = x - P *\\<^sub>V P *\\<^sub>V t", "by simp"], ["proof (state)\nthis:\n  x - P *\\<^sub>V x = x - P *\\<^sub>V P *\\<^sub>V t\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "also"], ["proof (state)\nthis:\n  x - P *\\<^sub>V x = x - P *\\<^sub>V P *\\<^sub>V t\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "have \\<open>\\<dots> = x - (P *\\<^sub>V t)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x - P *\\<^sub>V P *\\<^sub>V t = x - P *\\<^sub>V t", "using v3_1"], ["proof (prove)\nusing this:\n  (*\\<^sub>V) P \\<circ> (*\\<^sub>V) P = (*\\<^sub>V) P\n\ngoal (1 subgoal):\n 1. x - P *\\<^sub>V P *\\<^sub>V t = x - P *\\<^sub>V t", "by (metis comp_apply)"], ["proof (state)\nthis:\n  x - P *\\<^sub>V P *\\<^sub>V t = x - P *\\<^sub>V t\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "also"], ["proof (state)\nthis:\n  x - P *\\<^sub>V P *\\<^sub>V t = x - P *\\<^sub>V t\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "have \\<open>\\<dots> = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x - P *\\<^sub>V t = (0::'a)", "by (simp add: t_def)"], ["proof (state)\nthis:\n  x - P *\\<^sub>V t = (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "finally"], ["proof (chain)\npicking this:\n  x - P *\\<^sub>V x = (0::'a)", "have \\<open>x - P *\\<^sub>V x = 0\\<close>"], ["proof (prove)\nusing this:\n  x - P *\\<^sub>V x = (0::'a)\n\ngoal (1 subgoal):\n 1. x - P *\\<^sub>V x = (0::'a)", "by blast"], ["proof (state)\nthis:\n  x - P *\\<^sub>V x = (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "thus ?thesis"], ["proof (prove)\nusing this:\n  x - P *\\<^sub>V x = (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "by simp"], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> range ((*\\<^sub>V) P) \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "have v1: \"range (cblinfun_apply P) \\<subseteq> (\\<lambda>x. x - cblinfun_apply P x) -` {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range ((*\\<^sub>V) P)\n    \\<subseteq> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "using v3"], ["proof (prove)\nusing this:\n  ?x \\<in> range ((*\\<^sub>V) P) \\<Longrightarrow>\n  ?x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}\n\ngoal (1 subgoal):\n 1. range ((*\\<^sub>V) P)\n    \\<subseteq> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "by blast"], ["proof (state)\nthis:\n  range ((*\\<^sub>V) P)\n  \\<subseteq> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "have \"x \\<in> range (cblinfun_apply P)\"\n    if \"x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0}\"\n    for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> range ((*\\<^sub>V) P)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> range ((*\\<^sub>V) P)", "have x1:\\<open>x - P *\\<^sub>V x = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x - P *\\<^sub>V x = (0::'a)", "using that"], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}\n\ngoal (1 subgoal):\n 1. x - P *\\<^sub>V x = (0::'a)", "by blast"], ["proof (state)\nthis:\n  x - P *\\<^sub>V x = (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<in> range ((*\\<^sub>V) P)", "have \\<open>x = P *\\<^sub>V x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = P *\\<^sub>V x", "by (simp add: x1 eq_iff_diff_eq_0)"], ["proof (state)\nthis:\n  x = P *\\<^sub>V x\n\ngoal (1 subgoal):\n 1. x \\<in> range ((*\\<^sub>V) P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = P *\\<^sub>V x\n\ngoal (1 subgoal):\n 1. x \\<in> range ((*\\<^sub>V) P)", "by blast"], ["proof (state)\nthis:\n  x \\<in> range ((*\\<^sub>V) P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a} \\<Longrightarrow>\n  ?x \\<in> range ((*\\<^sub>V) P)\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "hence v2: \"(\\<lambda>x. x - cblinfun_apply P x) -` {0} \\<subseteq> range (cblinfun_apply P)\""], ["proof (prove)\nusing this:\n  ?x \\<in> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a} \\<Longrightarrow>\n  ?x \\<in> range ((*\\<^sub>V) P)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}\n    \\<subseteq> range ((*\\<^sub>V) P)", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}\n  \\<subseteq> range ((*\\<^sub>V) P)\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "have i1: \\<open>range (cblinfun_apply P) = (\\<lambda> x. x - cblinfun_apply P x) -` {0}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. range ((*\\<^sub>V) P) = (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "using v1 v2"], ["proof (prove)\nusing this:\n  range ((*\\<^sub>V) P)\n  \\<subseteq> (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}\n  (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}\n  \\<subseteq> range ((*\\<^sub>V) P)\n\ngoal (1 subgoal):\n 1. range ((*\\<^sub>V) P) = (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}", "by (simp add: v1 dual_order.antisym)"], ["proof (state)\nthis:\n  range ((*\\<^sub>V) P) = (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "have p1: \\<open>closed {(0::'a)}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {0::'a}", "by simp"], ["proof (state)\nthis:\n  closed {0::'a}\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "have p2: \\<open>continuous (at x) (\\<lambda> x. x - P *\\<^sub>V x)\\<close>\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. x - P *\\<^sub>V x) x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. x - P *\\<^sub>V x) x", "have \\<open>cblinfun_apply (id_cblinfun - P) = (\\<lambda> x. x - P *\\<^sub>V x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (*\\<^sub>V) (id_cblinfun - P) = (\\<lambda>x. x - P *\\<^sub>V x)", "by (simp add: id_cblinfun.rep_eq minus_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  (*\\<^sub>V) (id_cblinfun - P) = (\\<lambda>x. x - P *\\<^sub>V x)\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. x - P *\\<^sub>V x) x", "hence \\<open>bounded_clinear (cblinfun_apply (id_cblinfun - P))\\<close>"], ["proof (prove)\nusing this:\n  (*\\<^sub>V) (id_cblinfun - P) = (\\<lambda>x. x - P *\\<^sub>V x)\n\ngoal (1 subgoal):\n 1. bounded_clinear ((*\\<^sub>V) (id_cblinfun - P))", "using cblinfun_apply"], ["proof (prove)\nusing this:\n  (*\\<^sub>V) (id_cblinfun - P) = (\\<lambda>x. x - P *\\<^sub>V x)\n  (*\\<^sub>V) ?x \\<in> {f. bounded_clinear f}\n\ngoal (1 subgoal):\n 1. bounded_clinear ((*\\<^sub>V) (id_cblinfun - P))", "by blast"], ["proof (state)\nthis:\n  bounded_clinear ((*\\<^sub>V) (id_cblinfun - P))\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. x - P *\\<^sub>V x) x", "hence \\<open>continuous (at x) (cblinfun_apply (id_cblinfun - P))\\<close>"], ["proof (prove)\nusing this:\n  bounded_clinear ((*\\<^sub>V) (id_cblinfun - P))\n\ngoal (1 subgoal):\n 1. isCont ((*\\<^sub>V) (id_cblinfun - P)) x", "by (simp add: clinear_continuous_at)"], ["proof (state)\nthis:\n  isCont ((*\\<^sub>V) (id_cblinfun - P)) x\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. x - P *\\<^sub>V x) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  isCont ((*\\<^sub>V) (id_cblinfun - P)) x\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. x - P *\\<^sub>V x) x", "using \\<open>cblinfun_apply (id_cblinfun - P) = (\\<lambda> x. x - P *\\<^sub>V x)\\<close>"], ["proof (prove)\nusing this:\n  isCont ((*\\<^sub>V) (id_cblinfun - P)) x\n  (*\\<^sub>V) (id_cblinfun - P) = (\\<lambda>x. x - P *\\<^sub>V x)\n\ngoal (1 subgoal):\n 1. isCont (\\<lambda>x. x - P *\\<^sub>V x) x", "by simp"], ["proof (state)\nthis:\n  isCont (\\<lambda>x. x - P *\\<^sub>V x) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  isCont (\\<lambda>x. x - P *\\<^sub>V x) ?x\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "have i2: \\<open>closed ( (\\<lambda> x. x - P *\\<^sub>V x) -` {0} )\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed ((\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a})", "using p1 p2"], ["proof (prove)\nusing this:\n  closed {0::'a}\n  isCont (\\<lambda>x. x - P *\\<^sub>V x) ?x\n\ngoal (1 subgoal):\n 1. closed ((\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a})", "by (rule Abstract_Topology.continuous_closed_vimage)"], ["proof (state)\nthis:\n  closed ((\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a})\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "have \\<open>closed (range (cblinfun_apply P))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (range ((*\\<^sub>V) P))", "using i1 i2"], ["proof (prove)\nusing this:\n  range ((*\\<^sub>V) P) = (\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a}\n  closed ((\\<lambda>x. x - P *\\<^sub>V x) -` {0::'a})\n\ngoal (1 subgoal):\n 1. closed (range ((*\\<^sub>V) P))", "by simp"], ["proof (state)\nthis:\n  closed (range ((*\\<^sub>V) P))\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "have u2: \\<open>cblinfun_apply P x \\<in> space_as_set M\\<close>\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. P *\\<^sub>V x \\<in> space_as_set M", "by (simp add: M_def \\<open>closed (range ((*\\<^sub>V) P))\\<close> cblinfun_image.rep_eq top_ccsubspace.rep_eq)"], ["proof (state)\nthis:\n  P *\\<^sub>V ?x \\<in> space_as_set M\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "have xy: \\<open>\\<langle> x - P *\\<^sub>V x, y \\<rangle> = 0\\<close>\n    if y1: \\<open>y \\<in> space_as_set M\\<close>\n    for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "have \\<open>\\<exists>t. y = P *\\<^sub>V t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. y = P *\\<^sub>V t", "using y1"], ["proof (prove)\nusing this:\n  y \\<in> space_as_set M\n\ngoal (1 subgoal):\n 1. \\<exists>t. y = P *\\<^sub>V t", "by (simp add:  M_def \\<open>closed (range ((*\\<^sub>V) P))\\<close> cblinfun_image.rep_eq image_iff \n          top_ccsubspace.rep_eq)"], ["proof (state)\nthis:\n  \\<exists>t. y = P *\\<^sub>V t\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "then"], ["proof (chain)\npicking this:\n  \\<exists>t. y = P *\\<^sub>V t", "obtain t where t_def: \\<open>y = P *\\<^sub>V t\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>t. y = P *\\<^sub>V t\n\ngoal (1 subgoal):\n 1. (\\<And>t. y = P *\\<^sub>V t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y = P *\\<^sub>V t\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "have \\<open>\\<langle> x - P *\\<^sub>V x, y \\<rangle> = \\<langle> x - P *\\<^sub>V x, P *\\<^sub>V t \\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - P *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n    (x - P *\\<^sub>V x) \\<bullet>\\<^sub>C (P *\\<^sub>V t)", "by (simp add: t_def)"], ["proof (state)\nthis:\n  (x - P *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n  (x - P *\\<^sub>V x) \\<bullet>\\<^sub>C (P *\\<^sub>V t)\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "also"], ["proof (state)\nthis:\n  (x - P *\\<^sub>V x) \\<bullet>\\<^sub>C y =\n  (x - P *\\<^sub>V x) \\<bullet>\\<^sub>C (P *\\<^sub>V t)\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "have \\<open>\\<dots> = \\<langle> P *\\<^sub>V (x - P *\\<^sub>V x), t \\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - P *\\<^sub>V x) \\<bullet>\\<^sub>C (P *\\<^sub>V t) =\n    (P *\\<^sub>V (x - P *\\<^sub>V x)) \\<bullet>\\<^sub>C t", "by (metis \\<open>P = P*\\<close> cinner_adj_left)"], ["proof (state)\nthis:\n  (x - P *\\<^sub>V x) \\<bullet>\\<^sub>C (P *\\<^sub>V t) =\n  (P *\\<^sub>V (x - P *\\<^sub>V x)) \\<bullet>\\<^sub>C t\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "also"], ["proof (state)\nthis:\n  (x - P *\\<^sub>V x) \\<bullet>\\<^sub>C (P *\\<^sub>V t) =\n  (P *\\<^sub>V (x - P *\\<^sub>V x)) \\<bullet>\\<^sub>C t\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "have \\<open>\\<dots> = \\<langle> P *\\<^sub>V x - P *\\<^sub>V (P *\\<^sub>V x), t \\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P *\\<^sub>V (x - P *\\<^sub>V x)) \\<bullet>\\<^sub>C t =\n    (P *\\<^sub>V x - P *\\<^sub>V P *\\<^sub>V x) \\<bullet>\\<^sub>C t", "by (simp add: cblinfun.diff_right)"], ["proof (state)\nthis:\n  (P *\\<^sub>V (x - P *\\<^sub>V x)) \\<bullet>\\<^sub>C t =\n  (P *\\<^sub>V x - P *\\<^sub>V P *\\<^sub>V x) \\<bullet>\\<^sub>C t\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "also"], ["proof (state)\nthis:\n  (P *\\<^sub>V (x - P *\\<^sub>V x)) \\<bullet>\\<^sub>C t =\n  (P *\\<^sub>V x - P *\\<^sub>V P *\\<^sub>V x) \\<bullet>\\<^sub>C t\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "have \\<open>\\<dots> = \\<langle> P *\\<^sub>V x - P *\\<^sub>V x, t \\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P *\\<^sub>V x - P *\\<^sub>V P *\\<^sub>V x) \\<bullet>\\<^sub>C t =\n    (P *\\<^sub>V x - P *\\<^sub>V x) \\<bullet>\\<^sub>C t", "by (metis assms(1) comp_apply cblinfun_compose.rep_eq)"], ["proof (state)\nthis:\n  (P *\\<^sub>V x - P *\\<^sub>V P *\\<^sub>V x) \\<bullet>\\<^sub>C t =\n  (P *\\<^sub>V x - P *\\<^sub>V x) \\<bullet>\\<^sub>C t\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "also"], ["proof (state)\nthis:\n  (P *\\<^sub>V x - P *\\<^sub>V P *\\<^sub>V x) \\<bullet>\\<^sub>C t =\n  (P *\\<^sub>V x - P *\\<^sub>V x) \\<bullet>\\<^sub>C t\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "have \\<open>\\<dots> = \\<langle> 0, t \\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P *\\<^sub>V x - P *\\<^sub>V x) \\<bullet>\\<^sub>C t =\n    (0::'a) \\<bullet>\\<^sub>C t", "by simp"], ["proof (state)\nthis:\n  (P *\\<^sub>V x - P *\\<^sub>V x) \\<bullet>\\<^sub>C t =\n  (0::'a) \\<bullet>\\<^sub>C t\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "also"], ["proof (state)\nthis:\n  (P *\\<^sub>V x - P *\\<^sub>V x) \\<bullet>\\<^sub>C t =\n  (0::'a) \\<bullet>\\<^sub>C t\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "have \\<open>\\<dots> = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_orthogonal (0::'a) t", "by simp"], ["proof (state)\nthis:\n  is_orthogonal (0::'a) t\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "finally"], ["proof (chain)\npicking this:\n  is_orthogonal (x - P *\\<^sub>V x) y", "show ?thesis"], ["proof (prove)\nusing this:\n  is_orthogonal (x - P *\\<^sub>V x) y\n\ngoal (1 subgoal):\n 1. is_orthogonal (x - P *\\<^sub>V x) y", "by blast"], ["proof (state)\nthis:\n  is_orthogonal (x - P *\\<^sub>V x) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y \\<in> space_as_set M \\<Longrightarrow>\n  is_orthogonal (?x - P *\\<^sub>V ?x) ?y\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "hence u1: \\<open>x - P *\\<^sub>V x \\<in> orthogonal_complement (space_as_set M)\\<close> \n    for x"], ["proof (prove)\nusing this:\n  ?y \\<in> space_as_set M \\<Longrightarrow>\n  is_orthogonal (?x - P *\\<^sub>V ?x) ?y\n\ngoal (1 subgoal):\n 1. x - P *\\<^sub>V x \\<in> orthogonal_complement (space_as_set M)", "by (simp add: orthogonal_complementI)"], ["proof (state)\nthis:\n  ?x - P *\\<^sub>V ?x \\<in> orthogonal_complement (space_as_set M)\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "have \"closed_csubspace (space_as_set M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (space_as_set M)", "using space_as_set"], ["proof (prove)\nusing this:\n  space_as_set ?x \\<in> {S. closed_csubspace S}\n\ngoal (1 subgoal):\n 1. closed_csubspace (space_as_set M)", "by auto"], ["proof (state)\nthis:\n  closed_csubspace (space_as_set M)\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "hence f1: \"(Proj M) *\\<^sub>V a = P *\\<^sub>V a\" for a"], ["proof (prove)\nusing this:\n  closed_csubspace (space_as_set M)\n\ngoal (1 subgoal):\n 1. Proj M *\\<^sub>V a = P *\\<^sub>V a", "by (simp add: Proj.rep_eq projection_eqI u1 u2)"], ["proof (state)\nthis:\n  Proj M *\\<^sub>V ?a = P *\\<^sub>V ?a\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "have \"(+) ((P - Proj M) *\\<^sub>V a) = id\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) ((P - Proj M) *\\<^sub>V a) = id", "using f1"], ["proof (prove)\nusing this:\n  Proj M *\\<^sub>V ?a = P *\\<^sub>V ?a\n\ngoal (1 subgoal):\n 1. (+) ((P - Proj M) *\\<^sub>V a) = id", "by (auto intro!: ext simp add: minus_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  (+) ((P - Proj M) *\\<^sub>V ?a) = id\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "hence \"b - b = cblinfun_apply (P - Proj M) a\"\n    for a b"], ["proof (prove)\nusing this:\n  (+) ((P - Proj M) *\\<^sub>V ?a) = id\n\ngoal (1 subgoal):\n 1. b - b = (P - Proj M) *\\<^sub>V a", "by (metis (no_types) add_diff_cancel_right' id_apply)"], ["proof (state)\nthis:\n  ?b - ?b = (P - Proj M) *\\<^sub>V ?a\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "hence \"cblinfun_apply (id_cblinfun - (P - Proj M)) a = a\"\n    for a"], ["proof (prove)\nusing this:\n  ?b - ?b = (P - Proj M) *\\<^sub>V ?a\n\ngoal (1 subgoal):\n 1. (id_cblinfun - (P - Proj M)) *\\<^sub>V a = a", "by (simp add: id_cblinfun.rep_eq minus_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  (id_cblinfun - (P - Proj M)) *\\<^sub>V ?a = ?a\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (id_cblinfun - (P - Proj M)) *\\<^sub>V ?a = ?a\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "using u1 u2 cblinfun_apply_inject diff_diff_eq2 diff_eq_diff_eq eq_id_iff id_cblinfun.rep_eq"], ["proof (prove)\nusing this:\n  (id_cblinfun - (P - Proj M)) *\\<^sub>V ?a = ?a\n  ?x - P *\\<^sub>V ?x \\<in> orthogonal_complement (space_as_set M)\n  P *\\<^sub>V ?x \\<in> space_as_set M\n  ((*\\<^sub>V) ?x = (*\\<^sub>V) ?y) = (?x = ?y)\n  ?a - (?b - ?c) = ?a + ?c - ?b\n  ?a - ?b = ?c - ?d \\<Longrightarrow> (?a = ?b) = (?c = ?d)\n  (\\<forall>x. ?f x = x) = (?f = id)\n  (*\\<^sub>V) id_cblinfun = (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "by (metis (no_types, hide_lams) M_def)"], ["proof (state)\nthis:\n  Proj (P *\\<^sub>S \\<top>) = P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Proj_range_closed:\n  assumes \"is_Proj P\"\n  shows \"closed (range (cblinfun_apply P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (range ((*\\<^sub>V) P))", "using assms"], ["proof (prove)\nusing this:\n  is_Proj P\n\ngoal (1 subgoal):\n 1. closed (range ((*\\<^sub>V) P))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>bounded_clinear P;\n        \\<exists>M. closed_csubspace M \\<and> is_projection_on P M\\<rbrakk>\n       \\<Longrightarrow> closed (range P)", "using closed_csubspace.closed is_projection_on_image"], ["proof (prove)\nusing this:\n  closed_csubspace ?A \\<Longrightarrow> closed ?A\n  is_projection_on ?\\<pi> ?M \\<Longrightarrow> range ?\\<pi> = ?M\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>bounded_clinear P;\n        \\<exists>M. closed_csubspace M \\<and> is_projection_on P M\\<rbrakk>\n       \\<Longrightarrow> closed (range P)", "by blast"], ["", "lemma Proj_is_Proj[simp]:\n  fixes M::\\<open>'a::chilbert_space ccsubspace\\<close>\n  shows \\<open>is_Proj (Proj M)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Proj (Proj M)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. is_Proj (Proj M)", "have u1: \"closed_csubspace (space_as_set M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (space_as_set M)", "using space_as_set"], ["proof (prove)\nusing this:\n  space_as_set ?x \\<in> {S. closed_csubspace S}\n\ngoal (1 subgoal):\n 1. closed_csubspace (space_as_set M)", "by blast"], ["proof (state)\nthis:\n  closed_csubspace (space_as_set M)\n\ngoal (1 subgoal):\n 1. is_Proj (Proj M)", "have v1: \"h - Proj M *\\<^sub>V h\n         \\<in> orthogonal_complement (space_as_set M)\" for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. h - Proj M *\\<^sub>V h \\<in> orthogonal_complement (space_as_set M)", "by (simp add: Proj.rep_eq orthogonal_complementI projection_orthogonal u1)"], ["proof (state)\nthis:\n  ?h - Proj M *\\<^sub>V ?h \\<in> orthogonal_complement (space_as_set M)\n\ngoal (1 subgoal):\n 1. is_Proj (Proj M)", "have v2: \"Proj M *\\<^sub>V h \\<in> space_as_set M\" for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj M *\\<^sub>V h \\<in> space_as_set M", "by (metis Proj.rep_eq mem_Collect_eq orthog_proj_exists projection_eqI space_as_set)"], ["proof (state)\nthis:\n  Proj M *\\<^sub>V ?h \\<in> space_as_set M\n\ngoal (1 subgoal):\n 1. is_Proj (Proj M)", "have u2: \"is_projection_on ((*\\<^sub>V) (Proj M)) (space_as_set M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_projection_on ((*\\<^sub>V) (Proj M)) (space_as_set M)", "unfolding is_projection_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h.\n       is_arg_min (\\<lambda>x. dist x h)\n        (\\<lambda>x. x \\<in> space_as_set M) (Proj M *\\<^sub>V h)", "by (simp add: smallest_dist_is_ortho u1 v1 v2)"], ["proof (state)\nthis:\n  is_projection_on ((*\\<^sub>V) (Proj M)) (space_as_set M)\n\ngoal (1 subgoal):\n 1. is_Proj (Proj M)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Proj (Proj M)", "using u1 u2 is_Proj.rep_eq"], ["proof (prove)\nusing this:\n  closed_csubspace (space_as_set M)\n  is_projection_on ((*\\<^sub>V) (Proj M)) (space_as_set M)\n  is_Proj ?x =\n  (\\<exists>M.\n      closed_csubspace M \\<and> is_projection_on ((*\\<^sub>V) ?x) M)\n\ngoal (1 subgoal):\n 1. is_Proj (Proj M)", "by blast"], ["proof (state)\nthis:\n  is_Proj (Proj M)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_Proj_algebraic: \n  fixes P::\\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\\<close>\n  shows \\<open>is_Proj P \\<longleftrightarrow> P o\\<^sub>C\\<^sub>L P = P \\<and> P = P*\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Proj P = (P o\\<^sub>C\\<^sub>L P = P \\<and> P = P*)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_Proj P \\<Longrightarrow> P o\\<^sub>C\\<^sub>L P = P \\<and> P = P*\n 2. P o\\<^sub>C\\<^sub>L P = P \\<and> P = P* \\<Longrightarrow> is_Proj P", "have \"P o\\<^sub>C\\<^sub>L P = P\"\n    if \"is_Proj P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P o\\<^sub>C\\<^sub>L P = P", "using that"], ["proof (prove)\nusing this:\n  is_Proj P\n\ngoal (1 subgoal):\n 1. P o\\<^sub>C\\<^sub>L P = P", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>bounded_clinear P;\n        \\<exists>M. closed_csubspace M \\<and> is_projection_on P M\\<rbrakk>\n       \\<Longrightarrow> P \\<circ> P = P", "using is_projection_on_idem"], ["proof (prove)\nusing this:\n  is_projection_on ?\\<pi> ?M \\<Longrightarrow>\n  ?\\<pi> (?\\<pi> ?x) = ?\\<pi> ?x\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>bounded_clinear P;\n        \\<exists>M. closed_csubspace M \\<and> is_projection_on P M\\<rbrakk>\n       \\<Longrightarrow> P \\<circ> P = P", "by fastforce"], ["proof (state)\nthis:\n  is_Proj P \\<Longrightarrow> P o\\<^sub>C\\<^sub>L P = P\n\ngoal (2 subgoals):\n 1. is_Proj P \\<Longrightarrow> P o\\<^sub>C\\<^sub>L P = P \\<and> P = P*\n 2. P o\\<^sub>C\\<^sub>L P = P \\<and> P = P* \\<Longrightarrow> is_Proj P", "moreover"], ["proof (state)\nthis:\n  is_Proj P \\<Longrightarrow> P o\\<^sub>C\\<^sub>L P = P\n\ngoal (2 subgoals):\n 1. is_Proj P \\<Longrightarrow> P o\\<^sub>C\\<^sub>L P = P \\<and> P = P*\n 2. P o\\<^sub>C\\<^sub>L P = P \\<and> P = P* \\<Longrightarrow> is_Proj P", "have \"P = P*\"\n    if \"is_Proj P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = P*", "using that"], ["proof (prove)\nusing this:\n  is_Proj P\n\ngoal (1 subgoal):\n 1. P = P*", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>bounded_clinear P;\n        \\<exists>M. closed_csubspace M \\<and> is_projection_on P M\\<rbrakk>\n       \\<Longrightarrow> P = P\\<^sup>\\<dagger>", "by (metis is_projection_on_cadjoint)"], ["proof (state)\nthis:\n  is_Proj P \\<Longrightarrow> P = P*\n\ngoal (2 subgoals):\n 1. is_Proj P \\<Longrightarrow> P o\\<^sub>C\\<^sub>L P = P \\<and> P = P*\n 2. P o\\<^sub>C\\<^sub>L P = P \\<and> P = P* \\<Longrightarrow> is_Proj P", "ultimately"], ["proof (chain)\npicking this:\n  is_Proj P \\<Longrightarrow> P o\\<^sub>C\\<^sub>L P = P\n  is_Proj P \\<Longrightarrow> P = P*", "show \"P o\\<^sub>C\\<^sub>L P = P \\<and> P = P*\"\n    if \"is_Proj P\""], ["proof (prove)\nusing this:\n  is_Proj P \\<Longrightarrow> P o\\<^sub>C\\<^sub>L P = P\n  is_Proj P \\<Longrightarrow> P = P*\n\ngoal (1 subgoal):\n 1. P o\\<^sub>C\\<^sub>L P = P \\<and> P = P*", "using that"], ["proof (prove)\nusing this:\n  is_Proj P \\<Longrightarrow> P o\\<^sub>C\\<^sub>L P = P\n  is_Proj P \\<Longrightarrow> P = P*\n  is_Proj P\n\ngoal (1 subgoal):\n 1. P o\\<^sub>C\\<^sub>L P = P \\<and> P = P*", "by blast"], ["proof (state)\nthis:\n  is_Proj P \\<Longrightarrow> P o\\<^sub>C\\<^sub>L P = P \\<and> P = P*\n\ngoal (1 subgoal):\n 1. P o\\<^sub>C\\<^sub>L P = P \\<and> P = P* \\<Longrightarrow> is_Proj P", "show \"is_Proj P\"\n    if \"P o\\<^sub>C\\<^sub>L P = P \\<and> P = P*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Proj P", "using that Proj_on_own_range' Proj_is_Proj"], ["proof (prove)\nusing this:\n  P o\\<^sub>C\\<^sub>L P = P \\<and> P = P*\n  \\<lbrakk>?P o\\<^sub>C\\<^sub>L ?P = ?P; ?P = ?P*\\<rbrakk>\n  \\<Longrightarrow> Proj (?P *\\<^sub>S \\<top>) = ?P\n  is_Proj (Proj ?M)\n\ngoal (1 subgoal):\n 1. is_Proj P", "by metis"], ["proof (state)\nthis:\n  P o\\<^sub>C\\<^sub>L P = P \\<and> P = P* \\<Longrightarrow> is_Proj P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Proj_on_own_range:\n  fixes P :: \\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L'a\\<close>\n  assumes \\<open>is_Proj P\\<close>\n  shows \\<open>Proj (P *\\<^sub>S top) = P\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "using Proj_on_own_range' assms is_Proj_algebraic"], ["proof (prove)\nusing this:\n  \\<lbrakk>?P o\\<^sub>C\\<^sub>L ?P = ?P; ?P = ?P*\\<rbrakk>\n  \\<Longrightarrow> Proj (?P *\\<^sub>S \\<top>) = ?P\n  is_Proj P\n  is_Proj ?P = (?P o\\<^sub>C\\<^sub>L ?P = ?P \\<and> ?P = ?P*)\n\ngoal (1 subgoal):\n 1. Proj (P *\\<^sub>S \\<top>) = P", "by blast"], ["", "lemma Proj_image_leq: \"(Proj S) *\\<^sub>S A \\<le> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj S *\\<^sub>S A \\<le> S", "by (metis Proj_range inf_top_left le_inf_iff isometry_cblinfun_image_inf_distrib')"], ["", "lemma Proj_sandwich:\n  fixes A::\"'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::chilbert_space\"\n  assumes \"isometry A\"\n  shows \"sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "define P where \\<open>P = A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L (A*)\\<close>"], ["proof (state)\nthis:\n  P = A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A*\n\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "have \\<open>P o\\<^sub>C\\<^sub>L P = P\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. P o\\<^sub>C\\<^sub>L P = P", "using assms"], ["proof (prove)\nusing this:\n  isometry A\n\ngoal (1 subgoal):\n 1. P o\\<^sub>C\\<^sub>L P = P", "unfolding P_def isometry_def"], ["proof (prove)\nusing this:\n  A* o\\<^sub>C\\<^sub>L A = id_cblinfun\n\ngoal (1 subgoal):\n 1. A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A* o\\<^sub>C\\<^sub>L\n    (A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A*) =\n    A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A*", "by (metis (no_types, lifting) Proj_idempotent cblinfun_assoc_left(1) cblinfun_compose_id_left)"], ["proof (state)\nthis:\n  P o\\<^sub>C\\<^sub>L P = P\n\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "moreover"], ["proof (state)\nthis:\n  P o\\<^sub>C\\<^sub>L P = P\n\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "have \\<open>P = P*\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. P = P*", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A* =\n    (A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A*)*", "by (metis adj_Proj adj_cblinfun_compose cblinfun_assoc_left(1) double_adj)"], ["proof (state)\nthis:\n  P = P*\n\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "ultimately"], ["proof (chain)\npicking this:\n  P o\\<^sub>C\\<^sub>L P = P\n  P = P*", "have \n    \\<open>\\<exists>M. P = Proj M \\<and> space_as_set M = range (cblinfun_apply (A o\\<^sub>C\\<^sub>L (Proj S) o\\<^sub>C\\<^sub>L (A*)))\\<close>"], ["proof (prove)\nusing this:\n  P o\\<^sub>C\\<^sub>L P = P\n  P = P*\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       P = Proj M \\<and>\n       space_as_set M =\n       range ((*\\<^sub>V) (A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A*))", "using P_def Proj_on_own_range'"], ["proof (prove)\nusing this:\n  P o\\<^sub>C\\<^sub>L P = P\n  P = P*\n  P = A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A*\n  \\<lbrakk>?P o\\<^sub>C\\<^sub>L ?P = ?P; ?P = ?P*\\<rbrakk>\n  \\<Longrightarrow> Proj (?P *\\<^sub>S \\<top>) = ?P\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       P = Proj M \\<and>\n       space_as_set M =\n       range ((*\\<^sub>V) (A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A*))", "by (metis Proj_is_Proj Proj_range_closed cblinfun_image.rep_eq closure_closed top_ccsubspace.rep_eq)"], ["proof (state)\nthis:\n  \\<exists>M.\n     P = Proj M \\<and>\n     space_as_set M =\n     range ((*\\<^sub>V) (A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A*))\n\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "then"], ["proof (chain)\npicking this:\n  \\<exists>M.\n     P = Proj M \\<and>\n     space_as_set M =\n     range ((*\\<^sub>V) (A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A*))", "obtain M where \\<open>P = Proj M\\<close>\n    and \\<open>space_as_set M = range (cblinfun_apply (A o\\<^sub>C\\<^sub>L (Proj S) o\\<^sub>C\\<^sub>L (A*)))\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>M.\n     P = Proj M \\<and>\n     space_as_set M =\n     range ((*\\<^sub>V) (A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A*))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>P = Proj M;\n         space_as_set M =\n         range\n          ((*\\<^sub>V)\n            (A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A*))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  P = Proj M\n  space_as_set M =\n  range ((*\\<^sub>V) (A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A*))\n\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "have f1: \"A o\\<^sub>C\\<^sub>L Proj S = P o\\<^sub>C\\<^sub>L A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A o\\<^sub>C\\<^sub>L Proj S = P o\\<^sub>C\\<^sub>L A", "by (simp add: P_def assms cblinfun_compose_assoc)"], ["proof (state)\nthis:\n  A o\\<^sub>C\\<^sub>L Proj S = P o\\<^sub>C\\<^sub>L A\n\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "hence \"P o\\<^sub>C\\<^sub>L A o\\<^sub>C\\<^sub>L A* = P\""], ["proof (prove)\nusing this:\n  A o\\<^sub>C\\<^sub>L Proj S = P o\\<^sub>C\\<^sub>L A\n\ngoal (1 subgoal):\n 1. P o\\<^sub>C\\<^sub>L A o\\<^sub>C\\<^sub>L A* = P", "using P_def"], ["proof (prove)\nusing this:\n  A o\\<^sub>C\\<^sub>L Proj S = P o\\<^sub>C\\<^sub>L A\n  P = A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A*\n\ngoal (1 subgoal):\n 1. P o\\<^sub>C\\<^sub>L A o\\<^sub>C\\<^sub>L A* = P", "by presburger"], ["proof (state)\nthis:\n  P o\\<^sub>C\\<^sub>L A o\\<^sub>C\\<^sub>L A* = P\n\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "hence \"(P o\\<^sub>C\\<^sub>L A) *\\<^sub>S (c \\<squnion> A* *\\<^sub>S d) = P *\\<^sub>S (A *\\<^sub>S c \\<squnion> d)\"\n    for c d"], ["proof (prove)\nusing this:\n  P o\\<^sub>C\\<^sub>L A o\\<^sub>C\\<^sub>L A* = P\n\ngoal (1 subgoal):\n 1. (P o\\<^sub>C\\<^sub>L A) *\\<^sub>S (c \\<squnion> A* *\\<^sub>S d) =\n    P *\\<^sub>S (A *\\<^sub>S c \\<squnion> d)", "by (simp add: cblinfun_assoc_left(2))"], ["proof (state)\nthis:\n  (P o\\<^sub>C\\<^sub>L A) *\\<^sub>S (?c \\<squnion> A* *\\<^sub>S ?d) =\n  P *\\<^sub>S (A *\\<^sub>S ?c \\<squnion> ?d)\n\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "hence \"P *\\<^sub>S (A *\\<^sub>S \\<top> \\<squnion> c) = (P o\\<^sub>C\\<^sub>L A) *\\<^sub>S \\<top>\"\n    for c"], ["proof (prove)\nusing this:\n  (P o\\<^sub>C\\<^sub>L A) *\\<^sub>S (?c \\<squnion> A* *\\<^sub>S ?d) =\n  P *\\<^sub>S (A *\\<^sub>S ?c \\<squnion> ?d)\n\ngoal (1 subgoal):\n 1. P *\\<^sub>S (A *\\<^sub>S \\<top> \\<squnion> c) =\n    (P o\\<^sub>C\\<^sub>L A) *\\<^sub>S \\<top>", "by (metis sup_top_left)"], ["proof (state)\nthis:\n  P *\\<^sub>S (A *\\<^sub>S \\<top> \\<squnion> ?c) =\n  (P o\\<^sub>C\\<^sub>L A) *\\<^sub>S \\<top>\n\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "hence \\<open>M = A *\\<^sub>S S\\<close>"], ["proof (prove)\nusing this:\n  P *\\<^sub>S (A *\\<^sub>S \\<top> \\<squnion> ?c) =\n  (P o\\<^sub>C\\<^sub>L A) *\\<^sub>S \\<top>\n\ngoal (1 subgoal):\n 1. M = A *\\<^sub>S S", "using f1"], ["proof (prove)\nusing this:\n  P *\\<^sub>S (A *\\<^sub>S \\<top> \\<squnion> ?c) =\n  (P o\\<^sub>C\\<^sub>L A) *\\<^sub>S \\<top>\n  A o\\<^sub>C\\<^sub>L Proj S = P o\\<^sub>C\\<^sub>L A\n\ngoal (1 subgoal):\n 1. M = A *\\<^sub>S S", "by (metis \\<open>P = Proj M\\<close> cblinfun_assoc_left(2) Proj_range sup_top_right)"], ["proof (state)\nthis:\n  M = A *\\<^sub>S S\n\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "thus ?thesis"], ["proof (prove)\nusing this:\n  M = A *\\<^sub>S S\n\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "using \\<open>P = Proj M\\<close>"], ["proof (prove)\nusing this:\n  M = A *\\<^sub>S S\n  P = Proj M\n\ngoal (1 subgoal):\n 1. sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)", "unfolding P_def sandwich_apply"], ["proof (prove)\nusing this:\n  M = A *\\<^sub>S S\n  A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A* = Proj M\n\ngoal (1 subgoal):\n 1. A o\\<^sub>C\\<^sub>L Proj S o\\<^sub>C\\<^sub>L A* = Proj (A *\\<^sub>S S)", "by blast"], ["proof (state)\nthis:\n  sandwich A *\\<^sub>V Proj S = Proj (A *\\<^sub>S S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Proj_orthog_ccspan_union:\n  assumes \"\\<And>x y. x \\<in> X \\<Longrightarrow> y \\<in> Y \\<Longrightarrow> is_orthogonal x y\"\n  shows \\<open>Proj (ccspan (X \\<union> Y)) = Proj (ccspan X) + Proj (ccspan Y)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj (ccspan (X \\<union> Y)) = Proj (ccspan X) + Proj (ccspan Y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Proj (ccspan (X \\<union> Y)) = Proj (ccspan X) + Proj (ccspan Y)", "have \\<open>x \\<in> cspan X \\<Longrightarrow> y \\<in> cspan Y \\<Longrightarrow> is_orthogonal x y\\<close> for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> cspan X; y \\<in> cspan Y\\<rbrakk>\n    \\<Longrightarrow> is_orthogonal x y", "apply (rule is_orthogonal_closure_cspan[where X=X and Y=Y])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa ya.\n       \\<lbrakk>x \\<in> cspan X; y \\<in> cspan Y; xa \\<in> X;\n        ya \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal xa ya\n 2. \\<lbrakk>x \\<in> cspan X; y \\<in> cspan Y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> closure (cspan X)\n 3. \\<lbrakk>x \\<in> cspan X; y \\<in> cspan Y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> closure (cspan Y)", "using closure_subset assms"], ["proof (prove)\nusing this:\n  ?S \\<subseteq> closure ?S\n  \\<lbrakk>?x \\<in> X; ?y \\<in> Y\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n\ngoal (3 subgoals):\n 1. \\<And>xa ya.\n       \\<lbrakk>x \\<in> cspan X; y \\<in> cspan Y; xa \\<in> X;\n        ya \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal xa ya\n 2. \\<lbrakk>x \\<in> cspan X; y \\<in> cspan Y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> closure (cspan X)\n 3. \\<lbrakk>x \\<in> cspan X; y \\<in> cspan Y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> closure (cspan Y)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> cspan X; ?y \\<in> cspan Y\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n\ngoal (1 subgoal):\n 1. Proj (ccspan (X \\<union> Y)) = Proj (ccspan X) + Proj (ccspan Y)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> cspan X; ?y \\<in> cspan Y\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y", "have \\<open>x \\<in> closure (cspan X) \\<Longrightarrow> y \\<in> closure (cspan Y) \\<Longrightarrow> is_orthogonal x y\\<close> for x y"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> cspan X; ?y \\<in> cspan Y\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> closure (cspan X); y \\<in> closure (cspan Y)\\<rbrakk>\n    \\<Longrightarrow> is_orthogonal x y", "by (metis orthogonal_complementI orthogonal_complement_of_closure orthogonal_complement_orthoI')"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> closure (cspan X); ?y \\<in> closure (cspan Y)\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n\ngoal (1 subgoal):\n 1. Proj (ccspan (X \\<union> Y)) = Proj (ccspan X) + Proj (ccspan Y)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> closure (cspan X); ?y \\<in> closure (cspan Y)\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> closure (cspan X); ?y \\<in> closure (cspan Y)\\<rbrakk>\n  \\<Longrightarrow> is_orthogonal ?x ?y\n\ngoal (1 subgoal):\n 1. Proj (ccspan (X \\<union> Y)) = Proj (ccspan X) + Proj (ccspan Y)", "apply (transfer fixing: X Y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> closure (cspan X);\n         y \\<in> closure (cspan Y)\\<rbrakk>\n        \\<Longrightarrow> is_orthogonal x y) \\<Longrightarrow>\n    projection (closure (cspan (X \\<union> Y))) =\n    (\\<lambda>x.\n        projection (closure (cspan X)) x + projection (closure (cspan Y)) x)", "apply (subst projection_plus[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>x \\<in> closure (cspan X);\n                    y \\<in> closure (cspan Y)\\<rbrakk>\n                   \\<Longrightarrow> is_orthogonal x y;\n        x \\<in> closure (cspan X); y \\<in> closure (cspan Y)\\<rbrakk>\n       \\<Longrightarrow> is_orthogonal x y\n 2. (\\<And>x y.\n        \\<lbrakk>x \\<in> closure (cspan X);\n         y \\<in> closure (cspan Y)\\<rbrakk>\n        \\<Longrightarrow> is_orthogonal x y) \\<Longrightarrow>\n    closed_csubspace (closure (cspan X))\n 3. (\\<And>x y.\n        \\<lbrakk>x \\<in> closure (cspan X);\n         y \\<in> closure (cspan Y)\\<rbrakk>\n        \\<Longrightarrow> is_orthogonal x y) \\<Longrightarrow>\n    closed_csubspace (closure (cspan Y))\n 4. (\\<And>x y.\n        \\<lbrakk>x \\<in> closure (cspan X);\n         y \\<in> closure (cspan Y)\\<rbrakk>\n        \\<Longrightarrow> is_orthogonal x y) \\<Longrightarrow>\n    projection (closure (cspan (X \\<union> Y))) =\n    projection (closure (cspan X) +\\<^sub>M closure (cspan Y))", "by auto"], ["proof (state)\nthis:\n  Proj (ccspan (X \\<union> Y)) = Proj (ccspan X) + Proj (ccspan Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation proj :: \"'a::chilbert_space \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\" where \"proj \\<psi> \\<equiv> Proj (ccspan {\\<psi>})\""], ["", "lemma proj_0[simp]: \\<open>proj 0 = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. proj (0::'a) = 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection (closure (cspan {0::'a})) = (\\<lambda>x. 0::'a)", "by auto"], ["", "lemma surj_isometry_is_unitary:\n  fixes U :: \\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::chilbert_space\\<close>\n  assumes \\<open>isometry U\\<close>\n  assumes \\<open>U *\\<^sub>S \\<top> = \\<top>\\<close>\n  shows \\<open>unitary U\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary U", "by (metis Proj_sandwich sandwich_apply Proj_on_own_range' assms(1) assms(2) cblinfun_compose_id_right isometry_def unitary_def unitary_id unitary_range)"], ["", "lemma ccsubspace_supI_via_Proj:\n  fixes A B C::\"'a::chilbert_space ccsubspace\"\n  assumes a1: \\<open>Proj (- C) *\\<^sub>S A \\<le> B\\<close>\n  shows  \"A \\<le> sup B C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> B \\<squnion> C", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<le> B \\<squnion> C", "have x2: \\<open>x \\<in> space_as_set B\\<close>\n    if \"x \\<in>  closure ( (projection (orthogonal_complement (space_as_set C))) ` space_as_set A)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space_as_set B", "using that"], ["proof (prove)\nusing this:\n  x \\<in> closure\n           (projection (orthogonal_complement (space_as_set C)) `\n            space_as_set A)\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set B", "by (metis Proj.rep_eq cblinfun_image.rep_eq assms less_eq_ccsubspace.rep_eq subsetD \n        uminus_ccsubspace.rep_eq)"], ["proof (state)\nthis:\n  ?x \\<in> closure\n            (projection (orthogonal_complement (space_as_set C)) `\n             space_as_set A) \\<Longrightarrow>\n  ?x \\<in> space_as_set B\n\ngoal (1 subgoal):\n 1. A \\<le> B \\<squnion> C", "have q1: \\<open>x \\<in> closure {\\<psi> + \\<phi> |\\<psi> \\<phi>. \\<psi> \\<in> space_as_set B \\<and> \\<phi> \\<in> space_as_set C}\\<close>\n    if \\<open>x \\<in> space_as_set A\\<close>\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n              \\<psi> \\<in> space_as_set B \\<and>\n              \\<phi> \\<in> space_as_set C}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n              \\<psi> \\<in> space_as_set B \\<and>\n              \\<phi> \\<in> space_as_set C}", "have p1: \\<open>closed_csubspace (space_as_set C)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (space_as_set C)", "using space_as_set"], ["proof (prove)\nusing this:\n  space_as_set ?x \\<in> {S. closed_csubspace S}\n\ngoal (1 subgoal):\n 1. closed_csubspace (space_as_set C)", "by auto"], ["proof (state)\nthis:\n  closed_csubspace (space_as_set C)\n\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n              \\<psi> \\<in> space_as_set B \\<and>\n              \\<phi> \\<in> space_as_set C}", "hence \\<open>x = (projection (space_as_set C)) x\n       + (projection (orthogonal_complement (space_as_set C))) x\\<close>"], ["proof (prove)\nusing this:\n  closed_csubspace (space_as_set C)\n\ngoal (1 subgoal):\n 1. x =\n    projection (space_as_set C) x +\n    projection (orthogonal_complement (space_as_set C)) x", "by simp"], ["proof (state)\nthis:\n  x =\n  projection (space_as_set C) x +\n  projection (orthogonal_complement (space_as_set C)) x\n\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n              \\<psi> \\<in> space_as_set B \\<and>\n              \\<phi> \\<in> space_as_set C}", "hence \\<open>x = (projection (orthogonal_complement (space_as_set C))) x\n              + (projection (space_as_set C)) x\\<close>"], ["proof (prove)\nusing this:\n  x =\n  projection (space_as_set C) x +\n  projection (orthogonal_complement (space_as_set C)) x\n\ngoal (1 subgoal):\n 1. x =\n    projection (orthogonal_complement (space_as_set C)) x +\n    projection (space_as_set C) x", "by (metis ordered_field_class.sign_simps(2))"], ["proof (state)\nthis:\n  x =\n  projection (orthogonal_complement (space_as_set C)) x +\n  projection (space_as_set C) x\n\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n              \\<psi> \\<in> space_as_set B \\<and>\n              \\<phi> \\<in> space_as_set C}", "moreover"], ["proof (state)\nthis:\n  x =\n  projection (orthogonal_complement (space_as_set C)) x +\n  projection (space_as_set C) x\n\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n              \\<psi> \\<in> space_as_set B \\<and>\n              \\<phi> \\<in> space_as_set C}", "have \\<open>(projection (orthogonal_complement (space_as_set C))) x \\<in> space_as_set B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection (orthogonal_complement (space_as_set C)) x\n    \\<in> space_as_set B", "using x2"], ["proof (prove)\nusing this:\n  ?x \\<in> closure\n            (projection (orthogonal_complement (space_as_set C)) `\n             space_as_set A) \\<Longrightarrow>\n  ?x \\<in> space_as_set B\n\ngoal (1 subgoal):\n 1. projection (orthogonal_complement (space_as_set C)) x\n    \\<in> space_as_set B", "by (meson closure_subset image_subset_iff that)"], ["proof (state)\nthis:\n  projection (orthogonal_complement (space_as_set C)) x \\<in> space_as_set B\n\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n              \\<psi> \\<in> space_as_set B \\<and>\n              \\<phi> \\<in> space_as_set C}", "moreover"], ["proof (state)\nthis:\n  projection (orthogonal_complement (space_as_set C)) x \\<in> space_as_set B\n\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n              \\<psi> \\<in> space_as_set B \\<and>\n              \\<phi> \\<in> space_as_set C}", "have \\<open>(projection (space_as_set C)) x \\<in> space_as_set C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. projection (space_as_set C) x \\<in> space_as_set C", "by (metis mem_Collect_eq orthog_proj_exists projection_eqI space_as_set)"], ["proof (state)\nthis:\n  projection (space_as_set C) x \\<in> space_as_set C\n\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n              \\<psi> \\<in> space_as_set B \\<and>\n              \\<phi> \\<in> space_as_set C}", "ultimately"], ["proof (chain)\npicking this:\n  x =\n  projection (orthogonal_complement (space_as_set C)) x +\n  projection (space_as_set C) x\n  projection (orthogonal_complement (space_as_set C)) x \\<in> space_as_set B\n  projection (space_as_set C) x \\<in> space_as_set C", "show ?thesis"], ["proof (prove)\nusing this:\n  x =\n  projection (orthogonal_complement (space_as_set C)) x +\n  projection (space_as_set C) x\n  projection (orthogonal_complement (space_as_set C)) x \\<in> space_as_set B\n  projection (space_as_set C) x \\<in> space_as_set C\n\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n              \\<psi> \\<in> space_as_set B \\<and>\n              \\<phi> \\<in> space_as_set C}", "using closure_subset"], ["proof (prove)\nusing this:\n  x =\n  projection (orthogonal_complement (space_as_set C)) x +\n  projection (space_as_set C) x\n  projection (orthogonal_complement (space_as_set C)) x \\<in> space_as_set B\n  projection (space_as_set C) x \\<in> space_as_set C\n  ?S \\<subseteq> closure ?S\n\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n              \\<psi> \\<in> space_as_set B \\<and>\n              \\<phi> \\<in> space_as_set C}", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> closure\n           {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n            \\<psi> \\<in> space_as_set B \\<and> \\<phi> \\<in> space_as_set C}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> space_as_set A \\<Longrightarrow>\n  ?x \\<in> closure\n            {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n             \\<psi> \\<in> space_as_set B \\<and> \\<phi> \\<in> space_as_set C}\n\ngoal (1 subgoal):\n 1. A \\<le> B \\<squnion> C", "have x1: \\<open>x \\<in> (space_as_set B +\\<^sub>M space_as_set C)\\<close>\n    if \"x \\<in> space_as_set A\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space_as_set B +\\<^sub>M space_as_set C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> space_as_set B +\\<^sub>M space_as_set C", "have f1: \"x \\<in> closure {a + b |a b. a \\<in> space_as_set B \\<and> b \\<in> space_as_set C}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {a + b |a b.\n              a \\<in> space_as_set B \\<and> b \\<in> space_as_set C}", "by (simp add: q1 that)"], ["proof (state)\nthis:\n  x \\<in> closure\n           {a + b |a b.\n            a \\<in> space_as_set B \\<and> b \\<in> space_as_set C}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set B +\\<^sub>M space_as_set C", "have \"{a + b |a b. a \\<in> space_as_set B \\<and> b \\<in> space_as_set C} = {a. \\<exists>p. p \\<in> space_as_set B \n      \\<and> (\\<exists>q. q \\<in> space_as_set C \\<and> a = p + q)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a + b |a b. a \\<in> space_as_set B \\<and> b \\<in> space_as_set C} =\n    {a. \\<exists>p.\n           p \\<in> space_as_set B \\<and>\n           (\\<exists>q. q \\<in> space_as_set C \\<and> a = p + q)}", "by blast"], ["proof (state)\nthis:\n  {a + b |a b. a \\<in> space_as_set B \\<and> b \\<in> space_as_set C} =\n  {a. \\<exists>p.\n         p \\<in> space_as_set B \\<and>\n         (\\<exists>q. q \\<in> space_as_set C \\<and> a = p + q)}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set B +\\<^sub>M space_as_set C", "hence \"x \\<in> closure {a. \\<exists>b\\<in>space_as_set B. \\<exists>c\\<in>space_as_set C. a = b + c}\""], ["proof (prove)\nusing this:\n  {a + b |a b. a \\<in> space_as_set B \\<and> b \\<in> space_as_set C} =\n  {a. \\<exists>p.\n         p \\<in> space_as_set B \\<and>\n         (\\<exists>q. q \\<in> space_as_set C \\<and> a = p + q)}\n\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {a. \\<exists>b\\<in>space_as_set B.\n                    \\<exists>c\\<in>space_as_set C. a = b + c}", "using f1"], ["proof (prove)\nusing this:\n  {a + b |a b. a \\<in> space_as_set B \\<and> b \\<in> space_as_set C} =\n  {a. \\<exists>p.\n         p \\<in> space_as_set B \\<and>\n         (\\<exists>q. q \\<in> space_as_set C \\<and> a = p + q)}\n  x \\<in> closure\n           {a + b |a b.\n            a \\<in> space_as_set B \\<and> b \\<in> space_as_set C}\n\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {a. \\<exists>b\\<in>space_as_set B.\n                    \\<exists>c\\<in>space_as_set C. a = b + c}", "by (simp add: Bex_def_raw)"], ["proof (state)\nthis:\n  x \\<in> closure\n           {a. \\<exists>b\\<in>space_as_set B.\n                  \\<exists>c\\<in>space_as_set C. a = b + c}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set B +\\<^sub>M space_as_set C", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> closure\n           {a. \\<exists>b\\<in>space_as_set B.\n                  \\<exists>c\\<in>space_as_set C. a = b + c}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set B +\\<^sub>M space_as_set C", "using that"], ["proof (prove)\nusing this:\n  x \\<in> closure\n           {a. \\<exists>b\\<in>space_as_set B.\n                  \\<exists>c\\<in>space_as_set C. a = b + c}\n  x \\<in> space_as_set A\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set B +\\<^sub>M space_as_set C", "unfolding closed_sum_def set_plus_def"], ["proof (prove)\nusing this:\n  x \\<in> closure\n           {a. \\<exists>b\\<in>space_as_set B.\n                  \\<exists>c\\<in>space_as_set C. a = b + c}\n  x \\<in> space_as_set A\n\ngoal (1 subgoal):\n 1. x \\<in> closure\n             {c. \\<exists>a\\<in>space_as_set B.\n                    \\<exists>b\\<in>space_as_set C. c = a + b}", "by blast"], ["proof (state)\nthis:\n  x \\<in> space_as_set B +\\<^sub>M space_as_set C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> space_as_set A \\<Longrightarrow>\n  ?x \\<in> space_as_set B +\\<^sub>M space_as_set C\n\ngoal (1 subgoal):\n 1. A \\<le> B \\<squnion> C", "hence \\<open>x \\<in> space_as_set (Abs_clinear_space (space_as_set B +\\<^sub>M space_as_set C))\\<close>\n    if \"x \\<in> space_as_set A\" for x"], ["proof (prove)\nusing this:\n  ?x \\<in> space_as_set A \\<Longrightarrow>\n  ?x \\<in> space_as_set B +\\<^sub>M space_as_set C\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set\n             (Abs_clinear_space (space_as_set B +\\<^sub>M space_as_set C))", "using that"], ["proof (prove)\nusing this:\n  ?x \\<in> space_as_set A \\<Longrightarrow>\n  ?x \\<in> space_as_set B +\\<^sub>M space_as_set C\n  x \\<in> space_as_set A\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set\n             (Abs_clinear_space (space_as_set B +\\<^sub>M space_as_set C))", "by (metis space_as_set_inverse sup_ccsubspace.rep_eq)"], ["proof (state)\nthis:\n  ?x \\<in> space_as_set A \\<Longrightarrow>\n  ?x \\<in> space_as_set\n            (Abs_clinear_space (space_as_set B +\\<^sub>M space_as_set C))\n\ngoal (1 subgoal):\n 1. A \\<le> B \\<squnion> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> space_as_set A \\<Longrightarrow>\n  ?x \\<in> space_as_set\n            (Abs_clinear_space (space_as_set B +\\<^sub>M space_as_set C))\n\ngoal (1 subgoal):\n 1. A \\<le> B \\<squnion> C", "by (simp add: x1 less_eq_ccsubspace.rep_eq subset_eq sup_ccsubspace.rep_eq)"], ["proof (state)\nthis:\n  A \\<le> B \\<squnion> C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_Proj_idempotent:\n  assumes \"is_Proj P\"\n  shows \"P o\\<^sub>C\\<^sub>L P = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P o\\<^sub>C\\<^sub>L P = P", "using assms"], ["proof (prove)\nusing this:\n  is_Proj P\n\ngoal (1 subgoal):\n 1. P o\\<^sub>C\\<^sub>L P = P", "unfolding is_Proj_def"], ["proof (prove)\nusing this:\n  map_fun (*\\<^sub>V) id\n   (\\<lambda>P. \\<exists>M. closed_csubspace M \\<and> is_projection_on P M)\n   P\n\ngoal (1 subgoal):\n 1. P o\\<^sub>C\\<^sub>L P = P", "using assms is_Proj_algebraic"], ["proof (prove)\nusing this:\n  map_fun (*\\<^sub>V) id\n   (\\<lambda>P. \\<exists>M. closed_csubspace M \\<and> is_projection_on P M)\n   P\n  is_Proj P\n  is_Proj ?P = (?P o\\<^sub>C\\<^sub>L ?P = ?P \\<and> ?P = ?P*)\n\ngoal (1 subgoal):\n 1. P o\\<^sub>C\\<^sub>L P = P", "by auto"], ["", "lemma is_proj_selfadj:\n  assumes \"is_Proj P\"\n  shows \"P* = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P* = P", "using assms"], ["proof (prove)\nusing this:\n  is_Proj P\n\ngoal (1 subgoal):\n 1. P* = P", "unfolding is_Proj_def"], ["proof (prove)\nusing this:\n  map_fun (*\\<^sub>V) id\n   (\\<lambda>P. \\<exists>M. closed_csubspace M \\<and> is_projection_on P M)\n   P\n\ngoal (1 subgoal):\n 1. P* = P", "by (metis is_Proj_algebraic is_Proj_def)"], ["", "lemma is_Proj_I: \n  assumes \"P o\\<^sub>C\\<^sub>L P = P\" and \"P* = P\"\n  shows \"is_Proj P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Proj P", "using assms is_Proj_algebraic"], ["proof (prove)\nusing this:\n  P o\\<^sub>C\\<^sub>L P = P\n  P* = P\n  is_Proj ?P = (?P o\\<^sub>C\\<^sub>L ?P = ?P \\<and> ?P = ?P*)\n\ngoal (1 subgoal):\n 1. is_Proj P", "by metis"], ["", "lemma is_Proj_0[simp]: \"is_Proj 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Proj 0", "by (metis add_left_cancel adj_plus bounded_cbilinear.zero_left bounded_cbilinear_cblinfun_compose group_cancel.rule0 is_Proj_I)"], ["", "lemma is_Proj_complement[simp]: \n  assumes a1: \"is_Proj P\"\n  shows \"is_Proj (id_cblinfun-P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Proj (id_cblinfun - P)", "by (smt (z3) add_diff_cancel_left add_diff_cancel_left' adj_cblinfun_compose adj_plus assms bounded_cbilinear.add_left bounded_cbilinear_cblinfun_compose diff_add_cancel id_cblinfun_adjoint is_Proj_algebraic cblinfun_compose_id_left)"], ["", "lemma Proj_bot[simp]: \"Proj bot = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj \\<bottom> = 0", "by (metis zero_cblinfun_image Proj_on_own_range' is_Proj_0 is_Proj_algebraic \n      zero_ccsubspace_def)"], ["", "lemma Proj_ortho_compl:\n  \"Proj (- X) = id_cblinfun - Proj X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj (- X) = id_cblinfun - Proj X", "by (transfer , auto)"], ["", "lemma Proj_inj: \n  assumes \"Proj X = Proj Y\"\n  shows \"X = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = Y", "by (metis assms Proj_range)"], ["", "subsection \\<open>Kernel\\<close>"], ["", "lift_definition kernel :: \"'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L'b::complex_normed_vector\n   \\<Rightarrow> 'a ccsubspace\" \n  is \"\\<lambda> f. f -` {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun.\n       bounded_clinear fun \\<Longrightarrow>\n       closed_csubspace (fun -` {0::'b})", "by (metis kernel_is_closed_csubspace)"], ["", "definition eigenspace :: \"complex \\<Rightarrow> 'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L'a \\<Rightarrow> 'a ccsubspace\" where\n  \"eigenspace a A = kernel (A - a *\\<^sub>C id_cblinfun)\""], ["", "lemma kernel_scaleC[simp]: \"a\\<noteq>0 \\<Longrightarrow> kernel (a *\\<^sub>C A) = kernel A\"\n  for a :: complex and A :: \"(_,_) cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> kernel (a *\\<^sub>C A) = kernel A", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>a \\<noteq> 0; bounded_clinear A\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a *\\<^sub>C A x) -` {0::'d} =\n                         A -` {0::'d}", "using complex_vector.scale_eq_0_iff"], ["proof (prove)\nusing this:\n  (?a *\\<^sub>C ?x = (0::?'a)) = (?a = 0 \\<or> ?x = (0::?'a))\n\ngoal (1 subgoal):\n 1. \\<And>a A.\n       \\<lbrakk>a \\<noteq> 0; bounded_clinear A\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. a *\\<^sub>C A x) -` {0::'d} =\n                         A -` {0::'d}", "by blast"], ["", "lemma kernel_0[simp]: \"kernel 0 = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel 0 = \\<top>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. 0::'b) -` {0::'b} = UNIV", "by auto"], ["", "lemma kernel_id[simp]: \"kernel id_cblinfun = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel id_cblinfun = 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x) -` {0::'a} = {0::'a}", "by simp"], ["", "lemma eigenspace_scaleC[simp]: \n  assumes a1: \"a \\<noteq> 0\"\n  shows \"eigenspace b (a *\\<^sub>C A) = eigenspace (b/a) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenspace b (a *\\<^sub>C A) = eigenspace (b / a) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eigenspace b (a *\\<^sub>C A) = eigenspace (b / a) A", "have \"b *\\<^sub>C (id_cblinfun::('a, _) cblinfun) = a *\\<^sub>C (b / a) *\\<^sub>C id_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b *\\<^sub>C id_cblinfun = a *\\<^sub>C (b / a) *\\<^sub>C id_cblinfun", "using a1"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b *\\<^sub>C id_cblinfun = a *\\<^sub>C (b / a) *\\<^sub>C id_cblinfun", "by (metis ceq_vector_fraction_iff)"], ["proof (state)\nthis:\n  b *\\<^sub>C id_cblinfun = a *\\<^sub>C (b / a) *\\<^sub>C id_cblinfun\n\ngoal (1 subgoal):\n 1. eigenspace b (a *\\<^sub>C A) = eigenspace (b / a) A", "hence \"kernel (a *\\<^sub>C A - b *\\<^sub>C id_cblinfun) = kernel (A - (b / a) *\\<^sub>C id_cblinfun)\""], ["proof (prove)\nusing this:\n  b *\\<^sub>C id_cblinfun = a *\\<^sub>C (b / a) *\\<^sub>C id_cblinfun\n\ngoal (1 subgoal):\n 1. kernel (a *\\<^sub>C A - b *\\<^sub>C id_cblinfun) =\n    kernel (A - (b / a) *\\<^sub>C id_cblinfun)", "using a1"], ["proof (prove)\nusing this:\n  b *\\<^sub>C id_cblinfun = a *\\<^sub>C (b / a) *\\<^sub>C id_cblinfun\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. kernel (a *\\<^sub>C A - b *\\<^sub>C id_cblinfun) =\n    kernel (A - (b / a) *\\<^sub>C id_cblinfun)", "by (metis (no_types) complex_vector.scale_right_diff_distrib kernel_scaleC)"], ["proof (state)\nthis:\n  kernel (a *\\<^sub>C A - b *\\<^sub>C id_cblinfun) =\n  kernel (A - (b / a) *\\<^sub>C id_cblinfun)\n\ngoal (1 subgoal):\n 1. eigenspace b (a *\\<^sub>C A) = eigenspace (b / a) A", "thus ?thesis"], ["proof (prove)\nusing this:\n  kernel (a *\\<^sub>C A - b *\\<^sub>C id_cblinfun) =\n  kernel (A - (b / a) *\\<^sub>C id_cblinfun)\n\ngoal (1 subgoal):\n 1. eigenspace b (a *\\<^sub>C A) = eigenspace (b / a) A", "unfolding eigenspace_def"], ["proof (prove)\nusing this:\n  kernel (a *\\<^sub>C A - b *\\<^sub>C id_cblinfun) =\n  kernel (A - (b / a) *\\<^sub>C id_cblinfun)\n\ngoal (1 subgoal):\n 1. kernel (a *\\<^sub>C A - b *\\<^sub>C id_cblinfun) =\n    kernel (A - (b / a) *\\<^sub>C id_cblinfun)", "by blast"], ["proof (state)\nthis:\n  eigenspace b (a *\\<^sub>C A) = eigenspace (b / a) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eigenspace_memberD:\n  assumes \"x \\<in> space_as_set (eigenspace e A)\"\n  shows \"A *\\<^sub>V x = e *\\<^sub>C x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V x = e *\\<^sub>C x", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> space_as_set (eigenspace e A)\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V x = e *\\<^sub>C x", "unfolding eigenspace_def"], ["proof (prove)\nusing this:\n  x \\<in> space_as_set (kernel (A - e *\\<^sub>C id_cblinfun))\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V x = e *\\<^sub>C x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A e.\n       \\<lbrakk>bounded_clinear A;\n        x \\<in> (\\<lambda>x. A x - e *\\<^sub>C x) -` {0::'a}\\<rbrakk>\n       \\<Longrightarrow> A x = e *\\<^sub>C x", "by auto"], ["", "lemma kernel_memberD:\n  assumes \"x \\<in> space_as_set (kernel A)\"\n  shows \"A *\\<^sub>V x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V x = (0::'b)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> space_as_set (kernel A)\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V x = (0::'b)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>bounded_clinear A; x \\<in> A -` {0::'b}\\<rbrakk>\n       \\<Longrightarrow> A x = (0::'b)", "by auto"], ["", "lemma eigenspace_memberI:\n  assumes \"A *\\<^sub>V x = e *\\<^sub>C x\"\n  shows \"x \\<in> space_as_set (eigenspace e A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (eigenspace e A)", "using assms"], ["proof (prove)\nusing this:\n  A *\\<^sub>V x = e *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (eigenspace e A)", "unfolding eigenspace_def"], ["proof (prove)\nusing this:\n  A *\\<^sub>V x = e *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (kernel (A - e *\\<^sub>C id_cblinfun))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x e.\n       \\<lbrakk>bounded_clinear A; A x = e *\\<^sub>C x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>x. A x - e *\\<^sub>C x) -`\n                                 {0::'a}", "by auto"], ["", "lemma kernel_memberI:\n  assumes \"A *\\<^sub>V x = 0\"\n  shows \"x \\<in> space_as_set (kernel A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (kernel A)", "using assms"], ["proof (prove)\nusing this:\n  A *\\<^sub>V x = (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (kernel A)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x.\n       \\<lbrakk>bounded_clinear A; A x = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> A -` {0::'a}", "by auto"], ["", "subsection \\<open>Isomorphisms and inverses\\<close>"], ["", "definition iso_cblinfun :: \\<open>('a::complex_normed_vector, 'b::complex_normed_vector) cblinfun \\<Rightarrow> bool\\<close> where\n  \\<open>iso_cblinfun A = (\\<exists> B. A o\\<^sub>C\\<^sub>L B = id_cblinfun \\<and> B o\\<^sub>C\\<^sub>L A = id_cblinfun)\\<close>"], ["", "definition cblinfun_inv :: \\<open>('a::complex_normed_vector, 'b::complex_normed_vector) cblinfun \\<Rightarrow> ('b,'a) cblinfun\\<close> where\n  \\<open>cblinfun_inv A = (SOME B. B o\\<^sub>C\\<^sub>L A = id_cblinfun)\\<close>"], ["", "lemma \n  assumes \\<open>iso_cblinfun A\\<close>\n  shows cblinfun_inv_left: \\<open>cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun\\<close>\n    and cblinfun_inv_right: \\<open>A o\\<^sub>C\\<^sub>L cblinfun_inv A = id_cblinfun\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun &&&\n    A o\\<^sub>C\\<^sub>L cblinfun_inv A = id_cblinfun", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun\n 2. A o\\<^sub>C\\<^sub>L cblinfun_inv A = id_cblinfun", "from assms"], ["proof (chain)\npicking this:\n  iso_cblinfun A", "obtain B where AB: \\<open>A o\\<^sub>C\\<^sub>L B = id_cblinfun\\<close> and BA: \\<open>B o\\<^sub>C\\<^sub>L A = id_cblinfun\\<close>"], ["proof (prove)\nusing this:\n  iso_cblinfun A\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>A o\\<^sub>C\\<^sub>L B = id_cblinfun;\n         B o\\<^sub>C\\<^sub>L A = id_cblinfun\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using iso_cblinfun_def"], ["proof (prove)\nusing this:\n  iso_cblinfun A\n  iso_cblinfun ?A =\n  (\\<exists>B.\n      ?A o\\<^sub>C\\<^sub>L B = id_cblinfun \\<and>\n      B o\\<^sub>C\\<^sub>L ?A = id_cblinfun)\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>A o\\<^sub>C\\<^sub>L B = id_cblinfun;\n         B o\\<^sub>C\\<^sub>L A = id_cblinfun\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A o\\<^sub>C\\<^sub>L B = id_cblinfun\n  B o\\<^sub>C\\<^sub>L A = id_cblinfun\n\ngoal (2 subgoals):\n 1. cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun\n 2. A o\\<^sub>C\\<^sub>L cblinfun_inv A = id_cblinfun", "from BA"], ["proof (chain)\npicking this:\n  B o\\<^sub>C\\<^sub>L A = id_cblinfun", "have \\<open>cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun\\<close>"], ["proof (prove)\nusing this:\n  B o\\<^sub>C\\<^sub>L A = id_cblinfun\n\ngoal (1 subgoal):\n 1. cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun", "by (metis (mono_tags, lifting) cblinfun_inv_def someI_ex)"], ["proof (state)\nthis:\n  cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun\n\ngoal (2 subgoals):\n 1. cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun\n 2. A o\\<^sub>C\\<^sub>L cblinfun_inv A = id_cblinfun", "with AB BA"], ["proof (chain)\npicking this:\n  A o\\<^sub>C\\<^sub>L B = id_cblinfun\n  B o\\<^sub>C\\<^sub>L A = id_cblinfun\n  cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun", "have \\<open>cblinfun_inv A = B\\<close>"], ["proof (prove)\nusing this:\n  A o\\<^sub>C\\<^sub>L B = id_cblinfun\n  B o\\<^sub>C\\<^sub>L A = id_cblinfun\n  cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun\n\ngoal (1 subgoal):\n 1. cblinfun_inv A = B", "by (metis cblinfun_assoc_left(1) cblinfun_compose_id_right)"], ["proof (state)\nthis:\n  cblinfun_inv A = B\n\ngoal (2 subgoals):\n 1. cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun\n 2. A o\\<^sub>C\\<^sub>L cblinfun_inv A = id_cblinfun", "with AB BA"], ["proof (chain)\npicking this:\n  A o\\<^sub>C\\<^sub>L B = id_cblinfun\n  B o\\<^sub>C\\<^sub>L A = id_cblinfun\n  cblinfun_inv A = B", "show \\<open>cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun\\<close>\n    and \\<open>A o\\<^sub>C\\<^sub>L cblinfun_inv A = id_cblinfun\\<close>"], ["proof (prove)\nusing this:\n  A o\\<^sub>C\\<^sub>L B = id_cblinfun\n  B o\\<^sub>C\\<^sub>L A = id_cblinfun\n  cblinfun_inv A = B\n\ngoal (1 subgoal):\n 1. cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun &&&\n    A o\\<^sub>C\\<^sub>L cblinfun_inv A = id_cblinfun", "by auto"], ["proof (state)\nthis:\n  cblinfun_inv A o\\<^sub>C\\<^sub>L A = id_cblinfun\n  A o\\<^sub>C\\<^sub>L cblinfun_inv A = id_cblinfun\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_inv_uniq:\n  assumes \"A o\\<^sub>C\\<^sub>L B = id_cblinfun\" and \"B o\\<^sub>C\\<^sub>L A = id_cblinfun\"\n  shows \"cblinfun_inv A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_inv A = B", "using assms"], ["proof (prove)\nusing this:\n  A o\\<^sub>C\\<^sub>L B = id_cblinfun\n  B o\\<^sub>C\\<^sub>L A = id_cblinfun\n\ngoal (1 subgoal):\n 1. cblinfun_inv A = B", "by (metis cblinfun_compose_assoc cblinfun_compose_id_right cblinfun_inv_left iso_cblinfun_def)"], ["", "subsection \\<open>One-dimensional spaces\\<close>"], ["", "instantiation cblinfun :: (one_dim, one_dim) complex_inner begin"], ["", "text \\<open>Once we have a theory for the trace, we could instead define the Hilbert-Schmidt inner product\n  and relax the \\<^class>\\<open>one_dim\\<close>-sort constraint to (\\<^class>\\<open>cfinite_dim\\<close>,\\<^class>\\<open>complex_normed_vector\\<close>) or similar\\<close>"], ["", "definition \"cinner_cblinfun (A::'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) (B::'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b)\n             = cnj (one_dim_iso (A *\\<^sub>V 1)) * one_dim_iso (B *\\<^sub>V 1)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b, complex_inner_class)", "proof intro_classes"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y. x \\<bullet>\\<^sub>C y = cnj (y \\<bullet>\\<^sub>C x)\n 2. \\<And>x y z.\n       (x + y) \\<bullet>\\<^sub>C z =\n       x \\<bullet>\\<^sub>C z + y \\<bullet>\\<^sub>C z\n 3. \\<And>r x y.\n       r *\\<^sub>C x \\<bullet>\\<^sub>C y = cnj r * (x \\<bullet>\\<^sub>C y)\n 4. \\<And>x. 0 \\<le> x \\<bullet>\\<^sub>C x\n 5. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 6. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "fix A B C :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n    and c c' :: complex"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x y. x \\<bullet>\\<^sub>C y = cnj (y \\<bullet>\\<^sub>C x)\n 2. \\<And>x y z.\n       (x + y) \\<bullet>\\<^sub>C z =\n       x \\<bullet>\\<^sub>C z + y \\<bullet>\\<^sub>C z\n 3. \\<And>r x y.\n       r *\\<^sub>C x \\<bullet>\\<^sub>C y = cnj r * (x \\<bullet>\\<^sub>C y)\n 4. \\<And>x. 0 \\<le> x \\<bullet>\\<^sub>C x\n 5. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 6. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "show \"\\<langle>A, B\\<rangle> = cnj \\<langle>B, A\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<bullet>\\<^sub>C B = cnj (B \\<bullet>\\<^sub>C A)", "unfolding cinner_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (one_dim_iso (A *\\<^sub>V (1::'a))) *\n    one_dim_iso (B *\\<^sub>V (1::'a)) =\n    cnj (cnj (one_dim_iso (B *\\<^sub>V (1::'a))) *\n         one_dim_iso (A *\\<^sub>V (1::'a)))", "by auto"], ["proof (state)\nthis:\n  A \\<bullet>\\<^sub>C B = cnj (B \\<bullet>\\<^sub>C A)\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       (x + y) \\<bullet>\\<^sub>C z =\n       x \\<bullet>\\<^sub>C z + y \\<bullet>\\<^sub>C z\n 2. \\<And>r x y.\n       r *\\<^sub>C x \\<bullet>\\<^sub>C y = cnj r * (x \\<bullet>\\<^sub>C y)\n 3. \\<And>x. 0 \\<le> x \\<bullet>\\<^sub>C x\n 4. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 5. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "show \"\\<langle>A + B, C\\<rangle> = \\<langle>A, C\\<rangle> + \\<langle>B, C\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A + B) \\<bullet>\\<^sub>C C =\n    A \\<bullet>\\<^sub>C C + B \\<bullet>\\<^sub>C C", "by (simp add: cinner_cblinfun_def algebra_simps plus_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  (A + B) \\<bullet>\\<^sub>C C =\n  A \\<bullet>\\<^sub>C C + B \\<bullet>\\<^sub>C C\n\ngoal (4 subgoals):\n 1. \\<And>r x y.\n       r *\\<^sub>C x \\<bullet>\\<^sub>C y = cnj r * (x \\<bullet>\\<^sub>C y)\n 2. \\<And>x. 0 \\<le> x \\<bullet>\\<^sub>C x\n 3. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 4. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "show \"\\<langle>c *\\<^sub>C A, B\\<rangle> = cnj c * \\<langle>A, B\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C A \\<bullet>\\<^sub>C B = cnj c * (A \\<bullet>\\<^sub>C B)", "by (simp add: cblinfun.scaleC_left cinner_cblinfun_def)"], ["proof (state)\nthis:\n  c *\\<^sub>C A \\<bullet>\\<^sub>C B = cnj c * (A \\<bullet>\\<^sub>C B)\n\ngoal (3 subgoals):\n 1. \\<And>x. 0 \\<le> x \\<bullet>\\<^sub>C x\n 2. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 3. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "show \"0 \\<le> \\<langle>A, A\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> A \\<bullet>\\<^sub>C A", "unfolding cinner_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cnj (one_dim_iso (A *\\<^sub>V (1::'a))) *\n            one_dim_iso (A *\\<^sub>V (1::'a))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> A \\<bullet>\\<^sub>C A\n\ngoal (2 subgoals):\n 1. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 2. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "have \"bounded_clinear A \\<Longrightarrow> A 1 = 0 \\<Longrightarrow> A = (\\<lambda>_. 0)\"\n    for A::\"'a \\<Rightarrow> 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded_clinear A; A (1::'a) = (0::'b)\\<rbrakk>\n    \\<Longrightarrow> A = (\\<lambda>_. 0::'b)", "proof (rule one_dim_clinear_eqI [where x = 1] , auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>bounded_clinear A; A (1::'a) = (0::'b)\\<rbrakk>\n    \\<Longrightarrow> clinear A\n 2. \\<lbrakk>bounded_clinear A; A (1::'a) = (0::'b)\\<rbrakk>\n    \\<Longrightarrow> clinear (\\<lambda>_. 0::'b)", "show \"clinear A\"\n      if \"bounded_clinear A\"\n        and \"A 1 = 0\"\n      for A :: \"'a \\<Rightarrow> 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear A", "using that"], ["proof (prove)\nusing this:\n  bounded_clinear A\n  A (1::'a) = (0::'b)\n\ngoal (1 subgoal):\n 1. clinear A", "by (simp add: bounded_clinear.clinear)"], ["proof (state)\nthis:\n  \\<lbrakk>bounded_clinear ?A; ?A (1::'a) = (0::'b)\\<rbrakk>\n  \\<Longrightarrow> clinear ?A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded_clinear A; A (1::'a) = (0::'b)\\<rbrakk>\n    \\<Longrightarrow> clinear (\\<lambda>_. 0::'b)", "show \"clinear ((\\<lambda>_. 0)::'a \\<Rightarrow> 'b)\"\n      if \"bounded_clinear A\"\n        and \"A 1 = 0\"\n      for A :: \"'a \\<Rightarrow> 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear (\\<lambda>_. 0::'b)", "using that"], ["proof (prove)\nusing this:\n  bounded_clinear A\n  A (1::'a) = (0::'b)\n\ngoal (1 subgoal):\n 1. clinear (\\<lambda>_. 0::'b)", "by (simp add: complex_vector.module_hom_zero)"], ["proof (state)\nthis:\n  \\<lbrakk>bounded_clinear ?A; ?A (1::'a) = (0::'b)\\<rbrakk>\n  \\<Longrightarrow> clinear (\\<lambda>_. 0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>bounded_clinear ?A; ?A (1::'a) = (0::'b)\\<rbrakk>\n  \\<Longrightarrow> ?A = (\\<lambda>_. 0::'b)\n\ngoal (2 subgoals):\n 1. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 2. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "hence \"A *\\<^sub>V 1 = 0 \\<Longrightarrow> A = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>bounded_clinear ?A; ?A (1::'a) = (0::'b)\\<rbrakk>\n  \\<Longrightarrow> ?A = (\\<lambda>_. 0::'b)\n\ngoal (1 subgoal):\n 1. A *\\<^sub>V (1::'a) = (0::'b) \\<Longrightarrow> A = 0", "by transfer"], ["proof (state)\nthis:\n  A *\\<^sub>V (1::'a) = (0::'b) \\<Longrightarrow> A = 0\n\ngoal (2 subgoals):\n 1. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 2. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "hence \"one_dim_iso (A *\\<^sub>V 1) = 0 \\<Longrightarrow> A = 0\""], ["proof (prove)\nusing this:\n  A *\\<^sub>V (1::'a) = (0::'b) \\<Longrightarrow> A = 0\n\ngoal (1 subgoal):\n 1. one_dim_iso (A *\\<^sub>V (1::'a)) = (0::'c) \\<Longrightarrow> A = 0", "by (metis one_dim_iso_of_zero one_dim_iso_inj)"], ["proof (state)\nthis:\n  one_dim_iso (A *\\<^sub>V (1::'a)) = (0::?'c) \\<Longrightarrow> A = 0\n\ngoal (2 subgoals):\n 1. \\<And>x. (x \\<bullet>\\<^sub>C x = 0) = (x = 0)\n 2. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "thus \"(\\<langle>A, A\\<rangle> = 0) = (A = 0)\""], ["proof (prove)\nusing this:\n  one_dim_iso (A *\\<^sub>V (1::'a)) = (0::?'c) \\<Longrightarrow> A = 0\n\ngoal (1 subgoal):\n 1. (A \\<bullet>\\<^sub>C A = 0) = (A = 0)", "by (auto simp: cinner_cblinfun_def)"], ["proof (state)\nthis:\n  (A \\<bullet>\\<^sub>C A = 0) = (A = 0)\n\ngoal (1 subgoal):\n 1. \\<And>x. norm x = sqrt (cmod (x \\<bullet>\\<^sub>C x))", "show \"norm A = sqrt (cmod \\<langle>A, A\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm A = sqrt (cmod (A \\<bullet>\\<^sub>C A))", "unfolding cinner_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm A =\n    sqrt\n     (cmod\n       (cnj (one_dim_iso (A *\\<^sub>V (1::'a))) *\n        one_dim_iso (A *\\<^sub>V (1::'a))))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       bounded_clinear A \\<Longrightarrow>\n       onorm A =\n       sqrt (cmod (cnj (one_dim_iso (A (1::'a))) * one_dim_iso (A (1::'a))))", "by (simp add: norm_mult abs_complex_def one_dim_onorm' cnj_x_x power2_eq_square bounded_clinear.clinear)"], ["proof (state)\nthis:\n  norm A = sqrt (cmod (A \\<bullet>\\<^sub>C A))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation cblinfun :: (one_dim, one_dim) one_dim begin"], ["", "lift_definition one_cblinfun :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\" is \"one_dim_iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear one_dim_iso", "by (rule bounded_clinear_one_dim_iso)"], ["", "lift_definition times_cblinfun :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n  is \"\\<lambda>f g. f o one_dim_iso o g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>bounded_clinear fun1; bounded_clinear fun2\\<rbrakk>\n       \\<Longrightarrow> bounded_clinear\n                          (fun1 \\<circ> one_dim_iso \\<circ> fun2)", "by (simp add: comp_bounded_clinear)"], ["", "lift_definition inverse_cblinfun :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\" is\n  \"\\<lambda>f. ((*) (one_dim_iso (inverse (f 1)))) o one_dim_iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun.\n       bounded_clinear fun \\<Longrightarrow>\n       bounded_clinear\n        ((*) (one_dim_iso (inverse (fun (1::'a)))) \\<circ> one_dim_iso)", "by (auto intro!: comp_bounded_clinear bounded_clinear_mult_right)"], ["", "definition divide_cblinfun :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\" where\n  \"divide_cblinfun A B = A * inverse B\""], ["", "definition \"canonical_basis_cblinfun = [1 :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b]\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b, one_dim_class)", "proof intro_classes"], ["proof (state)\ngoal (9 subgoals):\n 1. distinct canonical_basis\n 2. cindependent (set canonical_basis)\n 3. cspan (set canonical_basis) = UNIV\n 4. is_ortho_set (set canonical_basis)\n 5. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1\n 6. canonical_basis = [1]\n 7. \\<And>a b. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1\n 8. \\<And>x y. x div y = x * inverse y\n 9. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "let ?basis = \"canonical_basis :: ('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) list\""], ["proof (state)\ngoal (9 subgoals):\n 1. distinct canonical_basis\n 2. cindependent (set canonical_basis)\n 3. cspan (set canonical_basis) = UNIV\n 4. is_ortho_set (set canonical_basis)\n 5. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1\n 6. canonical_basis = [1]\n 7. \\<And>a b. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1\n 8. \\<And>x y. x div y = x * inverse y\n 9. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "fix A B C :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\"\n    and c c' :: complex"], ["proof (state)\ngoal (9 subgoals):\n 1. distinct canonical_basis\n 2. cindependent (set canonical_basis)\n 3. cspan (set canonical_basis) = UNIV\n 4. is_ortho_set (set canonical_basis)\n 5. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1\n 6. canonical_basis = [1]\n 7. \\<And>a b. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1\n 8. \\<And>x y. x div y = x * inverse y\n 9. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "show \"distinct ?basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct canonical_basis", "unfolding canonical_basis_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [1]", "by simp"], ["proof (state)\nthis:\n  distinct canonical_basis\n\ngoal (8 subgoals):\n 1. cindependent (set canonical_basis)\n 2. cspan (set canonical_basis) = UNIV\n 3. is_ortho_set (set canonical_basis)\n 4. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1\n 5. canonical_basis = [1]\n 6. \\<And>a b. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1\n 7. \\<And>x y. x div y = x * inverse y\n 8. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "have \"(1::'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) \\<noteq> (0::'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<noteq> 0", "by (metis cblinfun.zero_left one_cblinfun.rep_eq one_dim_iso_of_one zero_neq_one)"], ["proof (state)\nthis:\n  1 \\<noteq> 0\n\ngoal (8 subgoals):\n 1. cindependent (set canonical_basis)\n 2. cspan (set canonical_basis) = UNIV\n 3. is_ortho_set (set canonical_basis)\n 4. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1\n 5. canonical_basis = [1]\n 6. \\<And>a b. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1\n 7. \\<And>x y. x div y = x * inverse y\n 8. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "thus \"cindependent (set ?basis)\""], ["proof (prove)\nusing this:\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindependent (set canonical_basis)", "unfolding canonical_basis_cblinfun_def"], ["proof (prove)\nusing this:\n  1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cindependent (set [1])", "by simp"], ["proof (state)\nthis:\n  cindependent (set canonical_basis)\n\ngoal (7 subgoals):\n 1. cspan (set canonical_basis) = UNIV\n 2. is_ortho_set (set canonical_basis)\n 3. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1\n 4. canonical_basis = [1]\n 5. \\<And>a b. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1\n 6. \\<And>x y. x div y = x * inverse y\n 7. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "have \"A \\<in> cspan (set ?basis)\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> cspan (set canonical_basis)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<in> cspan (set canonical_basis)", "define c :: complex where \"c = one_dim_iso (A *\\<^sub>V 1)\""], ["proof (state)\nthis:\n  c = one_dim_iso (A *\\<^sub>V (1::'a))\n\ngoal (1 subgoal):\n 1. A \\<in> cspan (set canonical_basis)", "have \"A x = one_dim_iso (A 1) *\\<^sub>C one_dim_iso x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V x =\n    one_dim_iso (A *\\<^sub>V (1::'a)) *\\<^sub>C one_dim_iso x", "by (smt (z3) cblinfun.scaleC_right complex_vector.scale_left_commute one_dim_iso_idem one_dim_scaleC_1)"], ["proof (state)\nthis:\n  A *\\<^sub>V ?x =\n  one_dim_iso (A *\\<^sub>V (1::'a)) *\\<^sub>C one_dim_iso ?x\n\ngoal (1 subgoal):\n 1. A \\<in> cspan (set canonical_basis)", "hence \"A = one_dim_iso (A *\\<^sub>V 1) *\\<^sub>C 1\""], ["proof (prove)\nusing this:\n  A *\\<^sub>V ?x =\n  one_dim_iso (A *\\<^sub>V (1::'a)) *\\<^sub>C one_dim_iso ?x\n\ngoal (1 subgoal):\n 1. A = one_dim_iso (A *\\<^sub>V (1::'a)) *\\<^sub>C 1", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>bounded_clinear A;\n        \\<And>x.\n           A x = one_dim_iso (A (1::'a)) *\\<^sub>C one_dim_iso x\\<rbrakk>\n       \\<Longrightarrow> A =\n                         (\\<lambda>x.\n                             one_dim_iso (A (1::'a)) *\\<^sub>C\n                             one_dim_iso x)", "by metis"], ["proof (state)\nthis:\n  A = one_dim_iso (A *\\<^sub>V (1::'a)) *\\<^sub>C 1\n\ngoal (1 subgoal):\n 1. A \\<in> cspan (set canonical_basis)", "thus \"A \\<in> cspan (set ?basis)\""], ["proof (prove)\nusing this:\n  A = one_dim_iso (A *\\<^sub>V (1::'a)) *\\<^sub>C 1\n\ngoal (1 subgoal):\n 1. A \\<in> cspan (set canonical_basis)", "unfolding canonical_basis_cblinfun_def"], ["proof (prove)\nusing this:\n  A = one_dim_iso (A *\\<^sub>V (1::'a)) *\\<^sub>C 1\n\ngoal (1 subgoal):\n 1. A \\<in> cspan (set [1])", "by (smt complex_vector.span_base complex_vector.span_scale list.set_intros(1))"], ["proof (state)\nthis:\n  A \\<in> cspan (set canonical_basis)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?A \\<in> cspan (set canonical_basis)\n\ngoal (7 subgoals):\n 1. cspan (set canonical_basis) = UNIV\n 2. is_ortho_set (set canonical_basis)\n 3. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1\n 4. canonical_basis = [1]\n 5. \\<And>a b. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1\n 6. \\<And>x y. x div y = x * inverse y\n 7. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "thus \"cspan (set ?basis) = UNIV\""], ["proof (prove)\nusing this:\n  ?A \\<in> cspan (set canonical_basis)\n\ngoal (1 subgoal):\n 1. cspan (set canonical_basis) = UNIV", "by auto"], ["proof (state)\nthis:\n  cspan (set canonical_basis) = UNIV\n\ngoal (6 subgoals):\n 1. is_ortho_set (set canonical_basis)\n 2. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1\n 3. canonical_basis = [1]\n 4. \\<And>a b. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1\n 5. \\<And>x y. x div y = x * inverse y\n 6. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "have \"A = (1::'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) \\<Longrightarrow>\n    norm (1::'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) = (1::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 1 \\<Longrightarrow> norm 1 = 1", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<lbrakk>bounded_clinear A; A = one_dim_iso\\<rbrakk>\n       \\<Longrightarrow> onorm one_dim_iso = 1", "by simp"], ["proof (state)\nthis:\n  A = 1 \\<Longrightarrow> norm 1 = 1\n\ngoal (6 subgoals):\n 1. is_ortho_set (set canonical_basis)\n 2. \\<And>x. x \\<in> set canonical_basis \\<Longrightarrow> norm x = 1\n 3. canonical_basis = [1]\n 4. \\<And>a b. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1\n 5. \\<And>x y. x div y = x * inverse y\n 6. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "thus \"A \\<in> set ?basis \\<Longrightarrow> norm A = 1\""], ["proof (prove)\nusing this:\n  A = 1 \\<Longrightarrow> norm 1 = 1\n\ngoal (1 subgoal):\n 1. A \\<in> set canonical_basis \\<Longrightarrow> norm A = 1", "unfolding canonical_basis_cblinfun_def"], ["proof (prove)\nusing this:\n  A = 1 \\<Longrightarrow> norm 1 = 1\n\ngoal (1 subgoal):\n 1. A \\<in> set [1] \\<Longrightarrow> norm A = 1", "by simp"], ["proof (state)\nthis:\n  A \\<in> set canonical_basis \\<Longrightarrow> norm A = 1\n\ngoal (5 subgoals):\n 1. is_ortho_set (set canonical_basis)\n 2. canonical_basis = [1]\n 3. \\<And>a b. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1\n 4. \\<And>x y. x div y = x * inverse y\n 5. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "show \"?basis = [1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canonical_basis = [1]", "unfolding canonical_basis_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [1] = [1]", "by simp"], ["proof (state)\nthis:\n  canonical_basis = [1]\n\ngoal (4 subgoals):\n 1. is_ortho_set (set canonical_basis)\n 2. \\<And>a b. a *\\<^sub>C 1 * b *\\<^sub>C 1 = (a * b) *\\<^sub>C 1\n 3. \\<And>x y. x div y = x * inverse y\n 4. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "show \"c *\\<^sub>C 1 * c' *\\<^sub>C 1 = (c * c') *\\<^sub>C (1::'a\\<Rightarrow>\\<^sub>C\\<^sub>L'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C 1 * c' *\\<^sub>C 1 = (c * c') *\\<^sub>C 1", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c c'.\n       (\\<lambda>x. c *\\<^sub>C one_dim_iso x) \\<circ> one_dim_iso \\<circ>\n       (\\<lambda>x. c' *\\<^sub>C one_dim_iso x) =\n       (\\<lambda>x. (c * c') *\\<^sub>C one_dim_iso x)", "by auto"], ["proof (state)\nthis:\n  c *\\<^sub>C 1 * c' *\\<^sub>C 1 = (c * c') *\\<^sub>C 1\n\ngoal (3 subgoals):\n 1. is_ortho_set (set canonical_basis)\n 2. \\<And>x y. x div y = x * inverse y\n 3. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "have \"(1::'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) = (0::'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = 0 \\<Longrightarrow> False", "by (metis cblinfun.zero_left one_cblinfun.rep_eq one_dim_iso_of_zero' zero_neq_neg_one)"], ["proof (state)\nthis:\n  1 = 0 \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. is_ortho_set (set canonical_basis)\n 2. \\<And>x y. x div y = x * inverse y\n 3. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "thus \"is_ortho_set (set ?basis)\""], ["proof (prove)\nusing this:\n  1 = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. is_ortho_set (set canonical_basis)", "unfolding is_ortho_set_def canonical_basis_cblinfun_def"], ["proof (prove)\nusing this:\n  1 = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set [1].\n        \\<forall>y\\<in>set [1].\n           x \\<noteq> y \\<longrightarrow> is_orthogonal x y) \\<and>\n    0 \\<notin> set [1]", "by auto"], ["proof (state)\nthis:\n  is_ortho_set (set canonical_basis)\n\ngoal (2 subgoals):\n 1. \\<And>x y. x div y = x * inverse y\n 2. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "show \"A div B = A * inverse B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A div B = A * inverse B", "by (simp add: divide_cblinfun_def)"], ["proof (state)\nthis:\n  A div B = A * inverse B\n\ngoal (1 subgoal):\n 1. \\<And>a. inverse (a *\\<^sub>C 1) = 1 /\\<^sub>C a", "show \"inverse (c *\\<^sub>C 1) = (1::'a\\<Rightarrow>\\<^sub>C\\<^sub>L'b) /\\<^sub>C c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (c *\\<^sub>C 1) = 1 /\\<^sub>C c", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       (*) (one_dim_iso (inverse (c *\\<^sub>C one_dim_iso (1::'a)))) \\<circ>\n       one_dim_iso =\n       (\\<lambda>x. one_dim_iso x /\\<^sub>C c)", "by (simp add: o_def one_dim_inverse)"], ["proof (state)\nthis:\n  inverse (c *\\<^sub>C 1) = 1 /\\<^sub>C c\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma id_cblinfun_eq_1[simp]: \\<open>id_cblinfun = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. id_cblinfun = 1", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x) = one_dim_iso", "by auto"], ["", "lemma one_dim_apply_is_times[simp]: \n  fixes A :: \"'a::one_dim \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\" and B :: \"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\"\n  shows \"A o\\<^sub>C\\<^sub>L B = A * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A o\\<^sub>C\\<^sub>L B = A * B", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>bounded_clinear A; bounded_clinear B\\<rbrakk>\n       \\<Longrightarrow> A \\<circ> B = A \\<circ> one_dim_iso \\<circ> B", "by simp"], ["", "lemma one_comp_one_cblinfun[simp]: \"1 o\\<^sub>C\\<^sub>L 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 o\\<^sub>C\\<^sub>L 1 = 1", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso \\<circ> one_dim_iso = one_dim_iso", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. one_dim_iso (one_dim_iso x)) = one_dim_iso", "by simp"], ["", "lemma one_cblinfun_adj[simp]: \"1* = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1* = 1", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso\\<^sup>\\<dagger> = one_dim_iso", "by simp"], ["", "lemma scaleC_1_right[simp]: \\<open>scaleC x (1::'a::one_dim) = of_complex x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x *\\<^sub>C (1::'a) = of_complex x", "unfolding of_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x *\\<^sub>C (1::'a) = x *\\<^sub>C (1::'a)", "by simp"], ["", "lemma scaleC_of_complex[simp]: \\<open>scaleC x (of_complex y) = of_complex (x * y)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x *\\<^sub>C of_complex y = of_complex (x * y)", "unfolding of_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x *\\<^sub>C y *\\<^sub>C (1::'a) = (x * y) *\\<^sub>C (1::'a)", "using scaleC_scaleC"], ["proof (prove)\nusing this:\n  ?a *\\<^sub>C ?b *\\<^sub>C ?x = (?a * ?b) *\\<^sub>C ?x\n\ngoal (1 subgoal):\n 1. x *\\<^sub>C y *\\<^sub>C (1::'a) = (x * y) *\\<^sub>C (1::'a)", "by blast"], ["", "lemma scaleC_1_apply[simp]: \\<open>(x *\\<^sub>C 1) *\\<^sub>V y = x *\\<^sub>C y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x *\\<^sub>C 1 *\\<^sub>V y = x *\\<^sub>C y", "by (metis cblinfun.scaleC_left cblinfun_id_cblinfun_apply id_cblinfun_eq_1)"], ["", "lemma cblinfun_apply_1_left[simp]: \\<open>1 *\\<^sub>V y = y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 *\\<^sub>V y = y", "by (metis cblinfun_id_cblinfun_apply id_cblinfun_eq_1)"], ["", "lemma of_complex_cblinfun_apply[simp]: \\<open>of_complex x *\\<^sub>V y = x *\\<^sub>C y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex x *\\<^sub>V y = x *\\<^sub>C y", "unfolding of_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x *\\<^sub>C 1 *\\<^sub>V y = x *\\<^sub>C y", "by (metis cblinfun.scaleC_left cblinfun_id_cblinfun_apply id_cblinfun_eq_1)"], ["", "lemma cblinfun_compose_1_left[simp]: \\<open>1 o\\<^sub>C\\<^sub>L x = x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 o\\<^sub>C\\<^sub>L x = x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. bounded_clinear x \\<Longrightarrow> one_dim_iso \\<circ> x = x", "by auto"], ["", "lemma cblinfun_compose_1_right[simp]: \\<open>x o\\<^sub>C\\<^sub>L 1 = x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x o\\<^sub>C\\<^sub>L 1 = x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. bounded_clinear x \\<Longrightarrow> x \\<circ> one_dim_iso = x", "by auto"], ["", "lemma one_dim_iso_id_cblinfun: \\<open>one_dim_iso id_cblinfun = id_cblinfun\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso id_cblinfun = id_cblinfun", "by simp"], ["", "lemma one_dim_iso_id_cblinfun_eq_1: \\<open>one_dim_iso id_cblinfun = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso id_cblinfun = (1::'a)", "by simp"], ["", "lemma one_dim_iso_comp_distr[simp]: \\<open>one_dim_iso (a o\\<^sub>C\\<^sub>L b) = one_dim_iso a o\\<^sub>C\\<^sub>L one_dim_iso b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso (a o\\<^sub>C\\<^sub>L b) =\n    one_dim_iso a o\\<^sub>C\\<^sub>L one_dim_iso b", "by (smt (z3) cblinfun_compose_scaleC_left cblinfun_compose_scaleC_right one_cinner_a_scaleC_one one_comp_one_cblinfun one_dim_iso_of_one one_dim_iso_scaleC)"], ["", "lemma one_dim_iso_comp_distr_times[simp]: \\<open>one_dim_iso (a o\\<^sub>C\\<^sub>L b) = one_dim_iso a * one_dim_iso b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso (a o\\<^sub>C\\<^sub>L b) = one_dim_iso a * one_dim_iso b", "by (smt (verit, del_insts) mult.left_neutral mult_scaleC_left one_cinner_a_scaleC_one one_comp_one_cblinfun one_dim_iso_of_one one_dim_iso_scaleC cblinfun_compose_scaleC_right cblinfun_compose_scaleC_left)"], ["", "lemma one_dim_iso_adjoint[simp]: \\<open>one_dim_iso (A*) = (one_dim_iso A)*\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso (A*) = one_dim_iso A*", "by (smt (z3) one_cblinfun_adj one_cinner_a_scaleC_one one_dim_iso_of_one one_dim_iso_scaleC scaleC_adj)"], ["", "lemma one_dim_iso_adjoint_complex[simp]: \\<open>one_dim_iso (A*) = cnj (one_dim_iso A)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso (A*) = cnj (one_dim_iso A)", "by (metis (mono_tags, lifting) one_cblinfun_adj one_dim_iso_idem one_dim_scaleC_1 scaleC_adj)"], ["", "lemma one_dim_cblinfun_compose_commute: \\<open>a o\\<^sub>C\\<^sub>L b = b o\\<^sub>C\\<^sub>L a\\<close> for a b :: \\<open>('a::one_dim,'a) cblinfun\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a o\\<^sub>C\\<^sub>L b = b o\\<^sub>C\\<^sub>L a", "by (simp add: one_dim_iso_inj)"], ["", "lemma one_cblinfun_apply_one[simp]: \\<open>1 *\\<^sub>V 1 = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 *\\<^sub>V (1::'b) = (1::'a)", "by (simp add: one_cblinfun.rep_eq)"], ["", "subsection \\<open>Loewner order\\<close>"], ["", "lift_definition heterogenous_cblinfun_id :: \\<open>'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\\<close>\n  is \\<open>if bounded_clinear (heterogenous_identity :: 'a::complex_normed_vector \\<Rightarrow> 'b::complex_normed_vector) then heterogenous_identity else (\\<lambda>_. 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear\n     (if bounded_clinear heterogenous_identity then heterogenous_identity\n      else (\\<lambda>_. 0::'b))", "by auto"], ["", "lemma heterogenous_cblinfun_id_def'[simp]: \"heterogenous_cblinfun_id = id_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heterogenous_cblinfun_id = id_cblinfun", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if bounded_clinear heterogenous_identity then heterogenous_identity\n     else (\\<lambda>_. 0::'a)) =\n    (\\<lambda>x. x)", "by auto"], ["", "definition \"heterogenous_same_type_cblinfun (x::'a::chilbert_space itself) (y::'b::chilbert_space itself) \\<longleftrightarrow>\n  unitary (heterogenous_cblinfun_id :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) \\<and> unitary (heterogenous_cblinfun_id :: 'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'a)\""], ["", "lemma heterogenous_same_type_cblinfun[simp]: \\<open>heterogenous_same_type_cblinfun (x::'a::chilbert_space itself) (y::'a::chilbert_space itself)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. heterogenous_same_type_cblinfun x y", "unfolding heterogenous_same_type_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unitary heterogenous_cblinfun_id \\<and> unitary heterogenous_cblinfun_id", "by auto"], ["", "instantiation cblinfun :: (chilbert_space, chilbert_space) ord begin"], ["", "definition less_eq_cblinfun :: \\<open>('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) \\<Rightarrow> bool\\<close>\n  where less_eq_cblinfun_def_heterogenous: \\<open>less_eq_cblinfun A B = \n  (if heterogenous_same_type_cblinfun TYPE('a) TYPE('b) then\n    \\<forall>\\<psi>::'b. cinner \\<psi> ((B-A) *\\<^sub>V heterogenous_cblinfun_id *\\<^sub>V \\<psi>) \\<ge> 0 else (A=B))\\<close>"], ["", "definition \\<open>less_cblinfun (A :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b) B \\<longleftrightarrow> A \\<le> B \\<and> \\<not> B \\<le> A\\<close>"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b, ord_class)", ".."], ["", "end"], ["", "lemma less_eq_cblinfun_def: \\<open>A \\<le> B \\<longleftrightarrow>\n    (\\<forall>\\<psi>. cinner \\<psi> (A *\\<^sub>V \\<psi>) \\<le> cinner \\<psi> (B *\\<^sub>V \\<psi>))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<le> B) =\n    (\\<forall>\\<psi>.\n        \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)\n        \\<le> \\<psi> \\<bullet>\\<^sub>C (B *\\<^sub>V \\<psi>))", "unfolding less_eq_cblinfun_def_heterogenous"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if heterogenous_same_type_cblinfun TYPE('a) TYPE('a)\n     then \\<forall>\\<psi>.\n             0 \\<le> \\<psi> \\<bullet>\\<^sub>C\n                     ((B - A) *\\<^sub>V\n                      heterogenous_cblinfun_id *\\<^sub>V \\<psi>)\n     else A = B) =\n    (\\<forall>\\<psi>.\n        \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)\n        \\<le> \\<psi> \\<bullet>\\<^sub>C (B *\\<^sub>V \\<psi>))", "by (auto simp del: less_eq_complex_def simp: cblinfun.diff_left cinner_diff_right)"], ["", "instantiation cblinfun :: (chilbert_space, chilbert_space) ordered_complex_vector begin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS\n     ('a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b, ordered_complex_vector_class)", "proof intro_classes"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 6. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 7. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "note less_eq_complex_def[simp del]"], ["proof (state)\nthis:\n  ?x \\<le> ?y \\<equiv> Im ?x = Im ?y \\<and> Re ?x \\<le> Re ?y\n\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 6. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 7. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "fix x y z :: \\<open>'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\\<close>"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 6. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 7. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "fix a b :: complex"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 6. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 7. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "define pos where \\<open>pos X \\<longleftrightarrow> (\\<forall>\\<psi>. cinner \\<psi> (X *\\<^sub>V \\<psi>) \\<ge> 0)\\<close> for X :: \\<open>'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\\<close>"], ["proof (state)\nthis:\n  pos ?X =\n  (\\<forall>\\<psi>. 0 \\<le> \\<psi> \\<bullet>\\<^sub>C (?X *\\<^sub>V \\<psi>))\n\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 6. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 7. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "consider (unitary) \\<open>heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\\<close>\n      \\<open>\\<And>A B :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b. A \\<le> B = pos ((B-A) o\\<^sub>C\\<^sub>L (heterogenous_cblinfun_id :: 'b\\<Rightarrow>\\<^sub>C\\<^sub>L'a))\\<close>\n    | (trivial) \\<open>\\<And>A B :: 'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b. A \\<le> B \\<longleftrightarrow> A = B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n              \\<And>A B.\n                 (A \\<le> B) =\n                 pos (B - A o\\<^sub>C\\<^sub>L\n                      heterogenous_cblinfun_id)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. heterogenous_same_type_cblinfun TYPE('a) TYPE('b) \\<and>\n    (\\<forall>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)) \\<or>\n    (\\<forall>A B. (A \\<le> B) = (A = B))", "by (auto simp: pos_def less_eq_cblinfun_def_heterogenous)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n            \\<And>A B.\n               (A \\<le> B) =\n               pos (B - A o\\<^sub>C\\<^sub>L\n                    heterogenous_cblinfun_id)\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 6. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 7. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "note cases = this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n            \\<And>A B.\n               (A \\<le> B) =\n               pos (B - A o\\<^sub>C\\<^sub>L\n                    heterogenous_cblinfun_id)\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 6. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 7. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "have [simp]: \\<open>pos 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pos 0", "unfolding pos_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<psi>. 0 \\<le> \\<psi> \\<bullet>\\<^sub>C (0 *\\<^sub>V \\<psi>)", "by auto"], ["proof (state)\nthis:\n  pos 0\n\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 6. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 7. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "have pos_nondeg: \\<open>X = 0\\<close> if \\<open>pos X\\<close> and \\<open>pos (-X)\\<close> for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. X = 0", "apply (rule cblinfun_cinner_eqI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>. is_orthogonal \\<psi> (X *\\<^sub>V \\<psi>)", "using that"], ["proof (prove)\nusing this:\n  pos X\n  pos (- X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>. is_orthogonal \\<psi> (X *\\<^sub>V \\<psi>)", "by (metis (no_types, lifting) cblinfun.minus_left cinner_minus_right dual_order.antisym equation_minus_iff neg_le_0_iff_le pos_def)"], ["proof (state)\nthis:\n  \\<lbrakk>pos ?X; pos (- ?X)\\<rbrakk> \\<Longrightarrow> ?X = 0\n\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 6. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 7. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "have pos_add: \\<open>pos (X+Y)\\<close> if \\<open>pos X\\<close> and \\<open>pos Y\\<close> for X Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. pos (X + Y)", "by (smt (z3) pos_def cblinfun.diff_left cinner_minus_right cinner_simps(3) diff_ge_0_iff_ge diff_minus_eq_add neg_le_0_iff_le order_trans that(1) that(2) uminus_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  \\<lbrakk>pos ?X; pos ?Y\\<rbrakk> \\<Longrightarrow> pos (?X + ?Y)\n\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 6. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 7. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "have pos_scaleC: \\<open>pos (a *\\<^sub>C X)\\<close> if \\<open>a\\<ge>0\\<close> and \\<open>pos X\\<close> for X a"], ["proof (prove)\ngoal (1 subgoal):\n 1. pos (a *\\<^sub>C X)", "using that"], ["proof (prove)\nusing this:\n  0 \\<le> a\n  pos X\n\ngoal (1 subgoal):\n 1. pos (a *\\<^sub>C X)", "unfolding pos_def"], ["proof (prove)\nusing this:\n  0 \\<le> a\n  \\<forall>\\<psi>. 0 \\<le> \\<psi> \\<bullet>\\<^sub>C (X *\\<^sub>V \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<psi>.\n       0 \\<le> \\<psi> \\<bullet>\\<^sub>C (a *\\<^sub>C X *\\<^sub>V \\<psi>)", "by (auto simp: cblinfun.scaleC_left)"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?a; pos ?X\\<rbrakk>\n  \\<Longrightarrow> pos (?a *\\<^sub>C ?X)\n\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 6. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 7. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "let ?id = \\<open>heterogenous_cblinfun_id :: 'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\\<close>"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 6. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 7. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "show \\<open>x \\<le> x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "apply (cases rule:cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x \\<le> x", "by auto"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (6 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 5. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 6. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "show \\<open>(x < y) \\<longleftrightarrow> (x \\<le> y \\<and> \\<not> y \\<le> x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "unfolding less_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y \\<and> \\<not> y \\<le> x) =\n    (x \\<le> y \\<and> \\<not> y \\<le> x)", "by simp"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 4. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 5. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "show \\<open>x \\<le> z\\<close> if \\<open>x \\<le> y\\<close> and \\<open>y \\<le> z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> z", "proof (cases rule:cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> z\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x \\<le> z", "case unitary"], ["proof (state)\nthis:\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> z\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x \\<le> z", "define a b :: \\<open>'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\\<close> where \\<open>a = (y-x) o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\\<close>\n      and \\<open>b = (z-y) o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\\<close>"], ["proof (state)\nthis:\n  a = y - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\n  b = z - y o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> z\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x \\<le> z", "with unitary that"], ["proof (chain)\npicking this:\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n  x \\<le> y\n  y \\<le> z\n  a = y - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\n  b = z - y o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id", "have \\<open>pos a\\<close> and \\<open>pos b\\<close>"], ["proof (prove)\nusing this:\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n  x \\<le> y\n  y \\<le> z\n  a = y - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\n  b = z - y o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\n\ngoal (1 subgoal):\n 1. pos a &&& pos b", "by auto"], ["proof (state)\nthis:\n  pos a\n  pos b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> z\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x \\<le> z", "then"], ["proof (chain)\npicking this:\n  pos a\n  pos b", "have \\<open>pos (a + b)\\<close>"], ["proof (prove)\nusing this:\n  pos a\n  pos b\n\ngoal (1 subgoal):\n 1. pos (a + b)", "by (rule pos_add)"], ["proof (state)\nthis:\n  pos (a + b)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> z\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x \\<le> z", "moreover"], ["proof (state)\nthis:\n  pos (a + b)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> z\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x \\<le> z", "have \\<open>a + b = (z - x) o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = z - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id", "unfolding a_def b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id) +\n    (z - y o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id) =\n    z - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id", "by (metis (no_types, lifting) bounded_cbilinear.add_left bounded_cbilinear_cblinfun_compose diff_add_cancel ordered_field_class.sign_simps(2) ordered_field_class.sign_simps(8))"], ["proof (state)\nthis:\n  a + b = z - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x \\<le> z\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x \\<le> z", "ultimately"], ["proof (chain)\npicking this:\n  pos (a + b)\n  a + b = z - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id", "show ?thesis"], ["proof (prove)\nusing this:\n  pos (a + b)\n  a + b = z - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\n\ngoal (1 subgoal):\n 1. x \\<le> z", "using unitary"], ["proof (prove)\nusing this:\n  pos (a + b)\n  a + b = z - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n\ngoal (1 subgoal):\n 1. x \\<le> z", "by auto"], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x \\<le> z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x \\<le> z", "case trivial"], ["proof (state)\nthis:\n  (?A \\<le> ?B) = (?A = ?B)\n\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x \\<le> z", "with that"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> z\n  (?A \\<le> ?B) = (?A = ?B)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> z\n  (?A \\<le> ?B) = (?A = ?B)\n\ngoal (1 subgoal):\n 1. x \\<le> z", "by auto"], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 3. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 4. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "show \\<open>x = y\\<close> if \\<open>x \\<le> y\\<close> and \\<open>y \\<le> x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (cases rule:cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x = y", "case unitary"], ["proof (state)\nthis:\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)", "have \\<open>unitary ?id\\<close>"], ["proof (prove)\nusing this:\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n\ngoal (1 subgoal):\n 1. unitary heterogenous_cblinfun_id", "by (auto simp: heterogenous_same_type_cblinfun_def)"], ["proof (state)\nthis:\n  unitary heterogenous_cblinfun_id\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x = y", "define a b :: \\<open>'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\\<close> where \\<open>a = (y-x) o\\<^sub>C\\<^sub>L ?id\\<close>\n      and \\<open>b = (x-y) o\\<^sub>C\\<^sub>L ?id\\<close>"], ["proof (state)\nthis:\n  a = y - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\n  b = x - y o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x = y", "with unitary that"], ["proof (chain)\npicking this:\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n  x \\<le> y\n  y \\<le> x\n  a = y - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\n  b = x - y o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id", "have \\<open>pos a\\<close> and \\<open>pos b\\<close>"], ["proof (prove)\nusing this:\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n  x \\<le> y\n  y \\<le> x\n  a = y - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\n  b = x - y o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id\n\ngoal (1 subgoal):\n 1. pos a &&& pos b", "by auto"], ["proof (state)\nthis:\n  pos a\n  pos b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  pos a\n  pos b", "have \\<open>a = 0\\<close>"], ["proof (prove)\nusing this:\n  pos a\n  pos b\n\ngoal (1 subgoal):\n 1. a = 0", "apply (rule_tac pos_nondeg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pos a; pos b\\<rbrakk> \\<Longrightarrow> pos a\n 2. \\<lbrakk>pos a; pos b\\<rbrakk> \\<Longrightarrow> pos (- a)", "apply (auto simp: a_def b_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pos (y - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id);\n     pos (x - y o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> pos (- (y - x o\\<^sub>C\\<^sub>L\n                              heterogenous_cblinfun_id))", "by (smt (verit, best) add.commute bounded_cbilinear.add_left bounded_cbilinear_cblinfun_compose cblinfun_compose_zero_left diff_0 diff_add_cancel group_cancel.rule0 group_cancel.sub1)"], ["proof (state)\nthis:\n  a = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x = y\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  a = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a = 0\n\ngoal (1 subgoal):\n 1. x = y", "unfolding a_def"], ["proof (prove)\nusing this:\n  y - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id = 0\n\ngoal (1 subgoal):\n 1. x = y", "using \\<open>unitary ?id\\<close>"], ["proof (prove)\nusing this:\n  y - x o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id = 0\n  unitary heterogenous_cblinfun_id\n\ngoal (1 subgoal):\n 1. x = y", "by (metis cblinfun_compose_assoc cblinfun_compose_id_right cblinfun_compose_zero_left eq_iff_diff_eq_0 unitaryD2)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x = y", "case trivial"], ["proof (state)\nthis:\n  (?A \\<le> ?B) = (?A = ?B)\n\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x = y", "with that"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> x\n  (?A \\<le> ?B) = (?A = ?B)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> x\n  (?A \\<le> ?B) = (?A = ?B)\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n\ngoal (3 subgoals):\n 1. \\<And>a b c. a \\<le> b \\<Longrightarrow> c + a \\<le> c + b\n 2. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 3. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "show \\<open>x + y \\<le> x + z\\<close> if \\<open>y \\<le> z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<le> x + z", "proof (cases rule:cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x + y \\<le> x + z\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x + y \\<le> x + z", "case unitary"], ["proof (state)\nthis:\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> x + y \\<le> x + z\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x + y \\<le> x + z", "with that"], ["proof (chain)\npicking this:\n  y \\<le> z\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<le> z\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n\ngoal (1 subgoal):\n 1. x + y \\<le> x + z", "by auto"], ["proof (state)\nthis:\n  x + y \\<le> x + z\n\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x + y \\<le> x + z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x + y \\<le> x + z", "case trivial"], ["proof (state)\nthis:\n  (?A \\<le> ?B) = (?A = ?B)\n\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow> x + y \\<le> x + z", "with that"], ["proof (chain)\npicking this:\n  y \\<le> z\n  (?A \\<le> ?B) = (?A = ?B)", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<le> z\n  (?A \\<le> ?B) = (?A = ?B)\n\ngoal (1 subgoal):\n 1. x + y \\<le> x + z", "by auto"], ["proof (state)\nthis:\n  x + y \\<le> x + z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<le> z \\<Longrightarrow> x + y \\<le> x + z\n\ngoal (2 subgoals):\n 1. \\<And>x y a.\n       \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 2. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "show \\<open>a *\\<^sub>C x \\<le> a *\\<^sub>C y\\<close> if \\<open>x \\<le> y\\<close> and \\<open>0 \\<le> a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>C x \\<le> a *\\<^sub>C y", "proof (cases rule:cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow>\n    a *\\<^sub>C x \\<le> a *\\<^sub>C y", "case unitary"], ["proof (state)\nthis:\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow>\n    a *\\<^sub>C x \\<le> a *\\<^sub>C y", "with that pos_scaleC"], ["proof (chain)\npicking this:\n  x \\<le> y\n  0 \\<le> a\n  \\<lbrakk>0 \\<le> ?a; pos ?X\\<rbrakk>\n  \\<Longrightarrow> pos (?a *\\<^sub>C ?X)\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> y\n  0 \\<le> a\n  \\<lbrakk>0 \\<le> ?a; pos ?X\\<rbrakk>\n  \\<Longrightarrow> pos (?a *\\<^sub>C ?X)\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n\ngoal (1 subgoal):\n 1. a *\\<^sub>C x \\<le> a *\\<^sub>C y", "by (metis cblinfun_compose_scaleC_left complex_vector.scale_right_diff_distrib)"], ["proof (state)\nthis:\n  a *\\<^sub>C x \\<le> a *\\<^sub>C y\n\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow>\n    a *\\<^sub>C x \\<le> a *\\<^sub>C y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow>\n    a *\\<^sub>C x \\<le> a *\\<^sub>C y", "case trivial"], ["proof (state)\nthis:\n  (?A \\<le> ?B) = (?A = ?B)\n\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow>\n    a *\\<^sub>C x \\<le> a *\\<^sub>C y", "with that"], ["proof (chain)\npicking this:\n  x \\<le> y\n  0 \\<le> a\n  (?A \\<le> ?B) = (?A = ?B)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> y\n  0 \\<le> a\n  (?A \\<le> ?B) = (?A = ?B)\n\ngoal (1 subgoal):\n 1. a *\\<^sub>C x \\<le> a *\\<^sub>C y", "by auto"], ["proof (state)\nthis:\n  a *\\<^sub>C x \\<le> a *\\<^sub>C y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; 0 \\<le> a\\<rbrakk>\n  \\<Longrightarrow> a *\\<^sub>C x \\<le> a *\\<^sub>C y\n\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x", "show \\<open>a *\\<^sub>C x \\<le> b *\\<^sub>C x\\<close> if \\<open>a \\<le> b\\<close> and \\<open>0 \\<le> x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>C x \\<le> b *\\<^sub>C x", "proof (cases rule:cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow>\n    a *\\<^sub>C x \\<le> b *\\<^sub>C x", "case unitary"], ["proof (state)\nthis:\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>heterogenous_same_type_cblinfun TYPE('a) TYPE('b);\n     \\<And>A B.\n        (A \\<le> B) =\n        pos (B - A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\\<rbrakk>\n    \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x\n 2. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow>\n    a *\\<^sub>C x \\<le> b *\\<^sub>C x", "with that"], ["proof (chain)\npicking this:\n  a \\<le> b\n  0 \\<le> x\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> b\n  0 \\<le> x\n  heterogenous_same_type_cblinfun TYPE('a) TYPE('b)\n  (?A \\<le> ?B) = pos (?B - ?A o\\<^sub>C\\<^sub>L heterogenous_cblinfun_id)\n\ngoal (1 subgoal):\n 1. a *\\<^sub>C x \\<le> b *\\<^sub>C x", "by (auto intro!: pos_scaleC simp flip: scaleC_diff_left)"], ["proof (state)\nthis:\n  a *\\<^sub>C x \\<le> b *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow>\n    a *\\<^sub>C x \\<le> b *\\<^sub>C x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow>\n    a *\\<^sub>C x \\<le> b *\\<^sub>C x", "case trivial"], ["proof (state)\nthis:\n  (?A \\<le> ?B) = (?A = ?B)\n\ngoal (1 subgoal):\n 1. (\\<And>A B. (A \\<le> B) = (A = B)) \\<Longrightarrow>\n    a *\\<^sub>C x \\<le> b *\\<^sub>C x", "with that"], ["proof (chain)\npicking this:\n  a \\<le> b\n  0 \\<le> x\n  (?A \\<le> ?B) = (?A = ?B)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> b\n  0 \\<le> x\n  (?A \\<le> ?B) = (?A = ?B)\n\ngoal (1 subgoal):\n 1. a *\\<^sub>C x \\<le> b *\\<^sub>C x", "by auto"], ["proof (state)\nthis:\n  a *\\<^sub>C x \\<le> b *\\<^sub>C x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<le> b; 0 \\<le> x\\<rbrakk>\n  \\<Longrightarrow> a *\\<^sub>C x \\<le> b *\\<^sub>C x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma positive_id_cblinfun[simp]: \"id_cblinfun \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> id_cblinfun", "unfolding less_eq_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<psi>.\n       \\<psi> \\<bullet>\\<^sub>C (0 *\\<^sub>V \\<psi>)\n       \\<le> \\<psi> \\<bullet>\\<^sub>C (id_cblinfun *\\<^sub>V \\<psi>)", "using cinner_ge_zero"], ["proof (prove)\nusing this:\n  0 \\<le> ?x \\<bullet>\\<^sub>C ?x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<psi>.\n       \\<psi> \\<bullet>\\<^sub>C (0 *\\<^sub>V \\<psi>)\n       \\<le> \\<psi> \\<bullet>\\<^sub>C (id_cblinfun *\\<^sub>V \\<psi>)", "by auto"], ["", "lemma positive_hermitianI: \\<open>A = A*\\<close> if \\<open>A \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A*", "apply (rule cinner_real_hermiteanI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>) \\<in> \\<real>", "using that"], ["proof (prove)\nusing this:\n  0 \\<le> A\n\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>) \\<in> \\<real>", "by (auto simp del: less_eq_complex_def simp: reals_zero_comparable_iff less_eq_cblinfun_def)"], ["", "lemma positive_cblinfunI: \\<open>A \\<ge> 0\\<close> if \\<open>\\<And>x. cinner x (A *\\<^sub>V x) \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> A", "unfolding less_eq_cblinfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<psi>.\n       \\<psi> \\<bullet>\\<^sub>C (0 *\\<^sub>V \\<psi>)\n       \\<le> \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)", "using that"], ["proof (prove)\nusing this:\n  0 \\<le> ?x \\<bullet>\\<^sub>C (A *\\<^sub>V ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<psi>.\n       \\<psi> \\<bullet>\\<^sub>C (0 *\\<^sub>V \\<psi>)\n       \\<le> \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)", "by auto"], ["", "(* Note: this does not require B to be a square operator *)"], ["", "lemma positive_cblinfun_squareI: \\<open>A = B* o\\<^sub>C\\<^sub>L B \\<Longrightarrow> A \\<ge> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B* o\\<^sub>C\\<^sub>L B \\<Longrightarrow> 0 \\<le> A", "apply (rule positive_cblinfunI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       A = B* o\\<^sub>C\\<^sub>L B \\<Longrightarrow>\n       0 \\<le> x \\<bullet>\\<^sub>C (A *\\<^sub>V x)", "by (metis cblinfun_apply_cblinfun_compose cinner_adj_right cinner_ge_zero)"], ["", "lemma one_dim_loewner_order: \\<open>A \\<ge> B \\<longleftrightarrow> one_dim_iso A \\<ge> (one_dim_iso B :: complex)\\<close> for A B :: \\<open>'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::{chilbert_space, one_dim}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)", "note less_eq_complex_def[simp del]"], ["proof (state)\nthis:\n  ?x \\<le> ?y \\<equiv> Im ?x = Im ?y \\<and> Re ?x \\<le> Re ?y\n\ngoal (1 subgoal):\n 1. (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)", "have A: \\<open>A = one_dim_iso A *\\<^sub>C id_cblinfun\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = one_dim_iso A *\\<^sub>C id_cblinfun", "by simp"], ["proof (state)\nthis:\n  A = one_dim_iso A *\\<^sub>C id_cblinfun\n\ngoal (1 subgoal):\n 1. (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)", "have B: \\<open>B = one_dim_iso B *\\<^sub>C id_cblinfun\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. B = one_dim_iso B *\\<^sub>C id_cblinfun", "by simp"], ["proof (state)\nthis:\n  B = one_dim_iso B *\\<^sub>C id_cblinfun\n\ngoal (1 subgoal):\n 1. (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)", "have \\<open>A \\<ge> B \\<longleftrightarrow> (\\<forall>\\<psi>. cinner \\<psi> (A \\<psi>) \\<ge> cinner \\<psi> (B \\<psi>))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (B \\<le> A) =\n    (\\<forall>\\<psi>.\n        \\<psi> \\<bullet>\\<^sub>C (B *\\<^sub>V \\<psi>)\n        \\<le> \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>))", "by (simp add: less_eq_cblinfun_def)"], ["proof (state)\nthis:\n  (B \\<le> A) =\n  (\\<forall>\\<psi>.\n      \\<psi> \\<bullet>\\<^sub>C (B *\\<^sub>V \\<psi>)\n      \\<le> \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>))\n\ngoal (1 subgoal):\n 1. (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)", "also"], ["proof (state)\nthis:\n  (B \\<le> A) =\n  (\\<forall>\\<psi>.\n      \\<psi> \\<bullet>\\<^sub>C (B *\\<^sub>V \\<psi>)\n      \\<le> \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>))\n\ngoal (1 subgoal):\n 1. (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)", "have \\<open>\\<dots> \\<longleftrightarrow> (\\<forall>\\<psi>::'a. one_dim_iso B * (\\<psi> \\<bullet>\\<^sub>C \\<psi>) \\<le> one_dim_iso A * (\\<psi> \\<bullet>\\<^sub>C \\<psi>))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<psi>.\n        \\<psi> \\<bullet>\\<^sub>C (B *\\<^sub>V \\<psi>)\n        \\<le> \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) =\n    (\\<forall>\\<psi>.\n        one_dim_iso B * (\\<psi> \\<bullet>\\<^sub>C \\<psi>)\n        \\<le> one_dim_iso A * (\\<psi> \\<bullet>\\<^sub>C \\<psi>))", "apply (subst A, subst B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<psi>.\n        \\<psi> \\<bullet>\\<^sub>C\n        (one_dim_iso B *\\<^sub>C id_cblinfun *\\<^sub>V \\<psi>)\n        \\<le> \\<psi> \\<bullet>\\<^sub>C\n              (one_dim_iso A *\\<^sub>C id_cblinfun *\\<^sub>V \\<psi>)) =\n    (\\<forall>\\<psi>.\n        one_dim_iso B * (\\<psi> \\<bullet>\\<^sub>C \\<psi>)\n        \\<le> one_dim_iso A * (\\<psi> \\<bullet>\\<^sub>C \\<psi>))", "by (metis (no_types, hide_lams) cinner_scaleC_right id_cblinfun_apply scaleC_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  (\\<forall>\\<psi>.\n      \\<psi> \\<bullet>\\<^sub>C (B *\\<^sub>V \\<psi>)\n      \\<le> \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) =\n  (\\<forall>\\<psi>.\n      one_dim_iso B * (\\<psi> \\<bullet>\\<^sub>C \\<psi>)\n      \\<le> one_dim_iso A * (\\<psi> \\<bullet>\\<^sub>C \\<psi>))\n\ngoal (1 subgoal):\n 1. (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)", "also"], ["proof (state)\nthis:\n  (\\<forall>\\<psi>.\n      \\<psi> \\<bullet>\\<^sub>C (B *\\<^sub>V \\<psi>)\n      \\<le> \\<psi> \\<bullet>\\<^sub>C (A *\\<^sub>V \\<psi>)) =\n  (\\<forall>\\<psi>.\n      one_dim_iso B * (\\<psi> \\<bullet>\\<^sub>C \\<psi>)\n      \\<le> one_dim_iso A * (\\<psi> \\<bullet>\\<^sub>C \\<psi>))\n\ngoal (1 subgoal):\n 1. (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)", "have \\<open>\\<dots> \\<longleftrightarrow> one_dim_iso A \\<ge> (one_dim_iso B :: complex)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<psi>.\n        one_dim_iso B * (\\<psi> \\<bullet>\\<^sub>C \\<psi>)\n        \\<le> one_dim_iso A * (\\<psi> \\<bullet>\\<^sub>C \\<psi>)) =\n    (one_dim_iso B \\<le> one_dim_iso A)", "by (auto intro!: mult_right_mono elim!: allE[where x=1])"], ["proof (state)\nthis:\n  (\\<forall>\\<psi>.\n      one_dim_iso B * (\\<psi> \\<bullet>\\<^sub>C \\<psi>)\n      \\<le> one_dim_iso A * (\\<psi> \\<bullet>\\<^sub>C \\<psi>)) =\n  (one_dim_iso B \\<le> one_dim_iso A)\n\ngoal (1 subgoal):\n 1. (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)", "finally"], ["proof (chain)\npicking this:\n  (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)", "show ?thesis"], ["proof (prove)\nusing this:\n  (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)\n\ngoal (1 subgoal):\n 1. (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)", "by -"], ["proof (state)\nthis:\n  (B \\<le> A) = (one_dim_iso B \\<le> one_dim_iso A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma one_dim_positive: \\<open>A \\<ge> 0 \\<longleftrightarrow> one_dim_iso A \\<ge> (0::complex)\\<close> for A :: \\<open>'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'a::{chilbert_space, one_dim}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> A) = (0 \\<le> one_dim_iso A)", "using one_dim_loewner_order[where B=0]"], ["proof (prove)\nusing this:\n  (0 \\<le> ?A) = (one_dim_iso 0 \\<le> one_dim_iso ?A)\n\ngoal (1 subgoal):\n 1. (0 \\<le> A) = (0 \\<le> one_dim_iso A)", "by auto"], ["", "subsection \\<open>Embedding vectors to operators\\<close>"], ["", "lift_definition vector_to_cblinfun :: \\<open>'a::complex_normed_vector \\<Rightarrow> 'b::one_dim \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\\<close> is\n  \\<open>\\<lambda>\\<psi> \\<phi>. one_dim_iso \\<phi> *\\<^sub>C \\<psi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       bounded_clinear (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C a)", "by (simp add: bounded_clinear_scaleC_const)"], ["", "lemma vector_to_cblinfun_cblinfun_apply: \n  \"vector_to_cblinfun (A *\\<^sub>V \\<psi>) = A  o\\<^sub>C\\<^sub>L (vector_to_cblinfun \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun (A *\\<^sub>V \\<psi>) =\n    A o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<psi>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A \\<psi>.\n       bounded_clinear A \\<Longrightarrow>\n       (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C A \\<psi>) =\n       A \\<circ> (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C \\<psi>)", "unfolding comp_def bounded_clinear_def clinear_def Vector_Spaces.linear_def\n    module_hom_def module_hom_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A \\<psi>.\n       (vector_space (*\\<^sub>C) \\<and>\n        vector_space (*\\<^sub>C) \\<and>\n        module (*\\<^sub>C) \\<and>\n        module (*\\<^sub>C) \\<and>\n        (\\<forall>b1 b2. A (b1 + b2) = A b1 + A b2) \\<and>\n        (\\<forall>r b. A (r *\\<^sub>C b) = r *\\<^sub>C A b)) \\<and>\n       bounded_clinear_axioms A \\<Longrightarrow>\n       (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C A \\<psi>) =\n       (\\<lambda>x. A (one_dim_iso x *\\<^sub>C \\<psi>))", "by simp"], ["", "lemma vector_to_cblinfun_add: \\<open>vector_to_cblinfun (x + y) = vector_to_cblinfun x + vector_to_cblinfun y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun (x + y) = vector_to_cblinfun x + vector_to_cblinfun y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C (x + y)) =\n       (\\<lambda>xa.\n           one_dim_iso xa *\\<^sub>C x + one_dim_iso xa *\\<^sub>C y)", "by (simp add: scaleC_add_right)"], ["", "lemma norm_vector_to_cblinfun[simp]: \"norm (vector_to_cblinfun x) = norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (vector_to_cblinfun x) = norm x", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       onorm (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x) = norm x", "have \"bounded_clinear (one_dim_iso::'a \\<Rightarrow> complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear one_dim_iso", "by simp"], ["proof (state)\nthis:\n  bounded_clinear one_dim_iso\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       onorm (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x) = norm x", "moreover"], ["proof (state)\nthis:\n  bounded_clinear one_dim_iso\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       onorm (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x) = norm x", "have \"onorm (one_dim_iso::'a \\<Rightarrow> complex) * norm x = norm x\"\n    for x :: 'b"], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm one_dim_iso * norm x = norm x", "by simp"], ["proof (state)\nthis:\n  onorm one_dim_iso * norm ?x = norm ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       onorm (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x) = norm x", "ultimately"], ["proof (chain)\npicking this:\n  bounded_clinear one_dim_iso\n  onorm one_dim_iso * norm ?x = norm ?x", "show \"onorm (\\<lambda>\\<phi>. one_dim_iso (\\<phi>::'a) *\\<^sub>C x) = norm x\"\n    for x :: 'b"], ["proof (prove)\nusing this:\n  bounded_clinear one_dim_iso\n  onorm one_dim_iso * norm ?x = norm ?x\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x) = norm x", "by (subst onorm_scaleC_left)"], ["proof (state)\nthis:\n  onorm (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C ?x) = norm ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_clinear_vector_to_cblinfun[bounded_clinear]: \"bounded_clinear vector_to_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear vector_to_cblinfun", "apply (rule bounded_clinearI[where K=1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b1 b2.\n       vector_to_cblinfun (b1 + b2) =\n       vector_to_cblinfun b1 + vector_to_cblinfun b2\n 2. \\<And>r b.\n       vector_to_cblinfun (r *\\<^sub>C b) = r *\\<^sub>C vector_to_cblinfun b\n 3. \\<forall>x. norm (vector_to_cblinfun x) \\<le> norm x * 1", "apply (transfer, simp add: scaleC_add_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r b.\n       vector_to_cblinfun (r *\\<^sub>C b) = r *\\<^sub>C vector_to_cblinfun b\n 2. \\<forall>x. norm (vector_to_cblinfun x) \\<le> norm x * 1", "apply (transfer, simp add: mult.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. norm (vector_to_cblinfun x) \\<le> norm x * 1", "by simp"], ["", "lemma vector_to_cblinfun_scaleC[simp]:\n  \"vector_to_cblinfun (a *\\<^sub>C \\<psi>) = a *\\<^sub>C vector_to_cblinfun \\<psi>\" for a::complex"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun (a *\\<^sub>C \\<psi>) =\n    a *\\<^sub>C vector_to_cblinfun \\<psi>", "proof (subst asm_rl [of \"a *\\<^sub>C \\<psi> = (a *\\<^sub>C id_cblinfun) *\\<^sub>V \\<psi>\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. a *\\<^sub>C \\<psi> = a *\\<^sub>C id_cblinfun *\\<^sub>V \\<psi>\n 2. vector_to_cblinfun (a *\\<^sub>C id_cblinfun *\\<^sub>V \\<psi>) =\n    a *\\<^sub>C vector_to_cblinfun \\<psi>", "show \"a *\\<^sub>C \\<psi> = a *\\<^sub>C id_cblinfun *\\<^sub>V \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>C \\<psi> = a *\\<^sub>C id_cblinfun *\\<^sub>V \\<psi>", "by (simp add: scaleC_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  a *\\<^sub>C \\<psi> = a *\\<^sub>C id_cblinfun *\\<^sub>V \\<psi>\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun (a *\\<^sub>C id_cblinfun *\\<^sub>V \\<psi>) =\n    a *\\<^sub>C vector_to_cblinfun \\<psi>", "show \"vector_to_cblinfun (a *\\<^sub>C id_cblinfun *\\<^sub>V \\<psi>) = a *\\<^sub>C (vector_to_cblinfun \\<psi>::'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun (a *\\<^sub>C id_cblinfun *\\<^sub>V \\<psi>) =\n    a *\\<^sub>C vector_to_cblinfun \\<psi>", "by (metis cblinfun_id_cblinfun_apply cblinfun_compose_scaleC_left vector_to_cblinfun_cblinfun_apply)"], ["proof (state)\nthis:\n  vector_to_cblinfun (a *\\<^sub>C id_cblinfun *\\<^sub>V \\<psi>) =\n  a *\\<^sub>C vector_to_cblinfun \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vector_to_cblinfun_apply_one_dim[simp]:\n  shows \"vector_to_cblinfun \\<phi> *\\<^sub>V \\<gamma> = one_dim_iso \\<gamma> *\\<^sub>C \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun \\<phi> *\\<^sub>V \\<gamma> =\n    one_dim_iso \\<gamma> *\\<^sub>C \\<phi>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<gamma>.\n       one_dim_iso \\<gamma> *\\<^sub>C \\<phi> =\n       one_dim_iso \\<gamma> *\\<^sub>C \\<phi>", "by (rule refl)"], ["", "lemma vector_to_cblinfun_adj_apply[simp]:\n  shows \"vector_to_cblinfun \\<psi>* *\\<^sub>V \\<phi> = of_complex (cinner \\<psi> \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun \\<psi>* *\\<^sub>V \\<phi> =\n    of_complex (\\<psi> \\<bullet>\\<^sub>C \\<phi>)", "by (simp add: cinner_adj_right one_dim_iso_def one_dim_iso_inj)"], ["", "lemma vector_to_cblinfun_comp_one[simp]: \n  \"(vector_to_cblinfun s :: 'a::one_dim \\<Rightarrow>\\<^sub>C\\<^sub>L _) o\\<^sub>C\\<^sub>L 1 \n     = (vector_to_cblinfun s :: 'b::one_dim \\<Rightarrow>\\<^sub>C\\<^sub>L _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun s o\\<^sub>C\\<^sub>L 1 = vector_to_cblinfun s", "apply (transfer fixing: s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C s) \\<circ> one_dim_iso =\n    (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C s)", "by fastforce"], ["", "lemma vector_to_cblinfun_0[simp]: \"vector_to_cblinfun 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun (0::'b) = 0", "by (metis cblinfun.zero_left cblinfun_compose_zero_left vector_to_cblinfun_cblinfun_apply)"], ["", "lemma image_vector_to_cblinfun[simp]: \"vector_to_cblinfun x *\\<^sub>S top = ccspan {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun x *\\<^sub>S \\<top> = ccspan {x}", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       closure (range (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x)) =\n       closure (cspan {x})", "show \"closure (range (\\<lambda>\\<phi>::'b. one_dim_iso \\<phi> *\\<^sub>C x)) = closure (cspan {x})\"\n    for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (range (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x)) =\n    closure (cspan {x})", "proof (rule arg_cong [where f = closure])"], ["proof (state)\ngoal (1 subgoal):\n 1. range (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x) = cspan {x}", "have \"k *\\<^sub>C x \\<in> range (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k *\\<^sub>C x\n    \\<in> range (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x)", "by (smt (z3) id_apply one_dim_iso_id one_dim_iso_idem range_eqI)"], ["proof (state)\nthis:\n  ?k1 *\\<^sub>C x\n  \\<in> range (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. range (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x) = cspan {x}", "thus \"range (\\<lambda>\\<phi>. one_dim_iso (\\<phi>::'b) *\\<^sub>C x) = cspan {x}\""], ["proof (prove)\nusing this:\n  ?k1 *\\<^sub>C x\n  \\<in> range (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. range (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x) = cspan {x}", "unfolding complex_vector.span_singleton"], ["proof (prove)\nusing this:\n  ?k1 *\\<^sub>C x\n  \\<in> range (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. range (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x) =\n    range (\\<lambda>k. k *\\<^sub>C x)", "by auto"], ["proof (state)\nthis:\n  range (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C x) = cspan {x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closure (range (\\<lambda>\\<phi>. one_dim_iso \\<phi> *\\<^sub>C ?x)) =\n  closure (cspan {?x})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vector_to_cblinfun_adj_comp_vector_to_cblinfun[simp]:\n  shows \"vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi> = cinner \\<psi> \\<phi> *\\<^sub>C id_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi> =\n    (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi> =\n    (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun", "have \"one_dim_iso \\<gamma> *\\<^sub>C one_dim_iso (of_complex \\<langle>\\<psi>, \\<phi>\\<rangle>) =\n    \\<langle>\\<psi>, \\<phi>\\<rangle> *\\<^sub>C one_dim_iso \\<gamma>\"\n    for \\<gamma> :: \"'c::one_dim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. one_dim_iso \\<gamma> *\\<^sub>C\n    one_dim_iso (of_complex (\\<psi> \\<bullet>\\<^sub>C \\<phi>)) =\n    (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C one_dim_iso \\<gamma>", "by (metis complex_vector.scale_left_commute of_complex_def one_dim_iso_of_one one_dim_iso_scaleC one_dim_scaleC_1)"], ["proof (state)\nthis:\n  one_dim_iso ?\\<gamma>1 *\\<^sub>C\n  one_dim_iso (of_complex (\\<psi> \\<bullet>\\<^sub>C \\<phi>)) =\n  (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C one_dim_iso ?\\<gamma>1\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi> =\n    (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun", "hence \"one_dim_iso ((vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi>) *\\<^sub>V \\<gamma>)\n      = one_dim_iso ((cinner \\<psi> \\<phi> *\\<^sub>C id_cblinfun) *\\<^sub>V \\<gamma>)\" \n    for \\<gamma> :: \"'c::one_dim\""], ["proof (prove)\nusing this:\n  one_dim_iso ?\\<gamma>1 *\\<^sub>C\n  one_dim_iso (of_complex (\\<psi> \\<bullet>\\<^sub>C \\<phi>)) =\n  (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C one_dim_iso ?\\<gamma>1\n\ngoal (1 subgoal):\n 1. one_dim_iso\n     ((vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L\n       vector_to_cblinfun \\<phi>) *\\<^sub>V\n      \\<gamma>) =\n    one_dim_iso\n     ((\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun *\\<^sub>V\n      \\<gamma>)", "by simp"], ["proof (state)\nthis:\n  one_dim_iso\n   ((vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L\n     vector_to_cblinfun \\<phi>) *\\<^sub>V\n    ?\\<gamma>2) =\n  one_dim_iso\n   ((\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun *\\<^sub>V\n    ?\\<gamma>2)\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi> =\n    (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun", "hence \"((vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi>) *\\<^sub>V \\<gamma>) = ((cinner \\<psi> \\<phi> *\\<^sub>C id_cblinfun) *\\<^sub>V \\<gamma>)\" \n    for \\<gamma> :: \"'c::one_dim\""], ["proof (prove)\nusing this:\n  one_dim_iso\n   ((vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L\n     vector_to_cblinfun \\<phi>) *\\<^sub>V\n    ?\\<gamma>2) =\n  one_dim_iso\n   ((\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun *\\<^sub>V\n    ?\\<gamma>2)\n\ngoal (1 subgoal):\n 1. (vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L\n     vector_to_cblinfun \\<phi>) *\\<^sub>V\n    \\<gamma> =\n    (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun *\\<^sub>V\n    \\<gamma>", "by (rule one_dim_iso_inj)"], ["proof (state)\nthis:\n  (vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L\n   vector_to_cblinfun \\<phi>) *\\<^sub>V\n  ?\\<gamma>3 =\n  (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun *\\<^sub>V\n  ?\\<gamma>3\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi> =\n    (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun", "thus ?thesis"], ["proof (prove)\nusing this:\n  (vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L\n   vector_to_cblinfun \\<phi>) *\\<^sub>V\n  ?\\<gamma>3 =\n  (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun *\\<^sub>V\n  ?\\<gamma>3\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi> =\n    (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun", "using cblinfun_eqI[where x = \"vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi>\"\n        and y = \"\\<langle>\\<psi>, \\<phi>\\<rangle> *\\<^sub>C id_cblinfun\"]"], ["proof (prove)\nusing this:\n  (vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L\n   vector_to_cblinfun \\<phi>) *\\<^sub>V\n  ?\\<gamma>3 =\n  (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun *\\<^sub>V\n  ?\\<gamma>3\n  (\\<And>i.\n      (vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L\n       vector_to_cblinfun \\<phi>) *\\<^sub>V\n      i =\n      (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun *\\<^sub>V\n      i) \\<Longrightarrow>\n  vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi> =\n  (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi> =\n    (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun", "by auto"], ["proof (state)\nthis:\n  vector_to_cblinfun \\<psi>* o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi> =\n  (\\<psi> \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C id_cblinfun\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isometry_vector_to_cblinfun[simp]:\n  assumes \"norm x = 1\"\n  shows \"isometry (vector_to_cblinfun x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isometry (vector_to_cblinfun x)", "using assms cnorm_eq_1 isometry_def"], ["proof (prove)\nusing this:\n  norm x = 1\n  (norm ?x = 1) = (?x \\<bullet>\\<^sub>C ?x = 1)\n  isometry ?U = (?U* o\\<^sub>C\\<^sub>L ?U = id_cblinfun)\n\ngoal (1 subgoal):\n 1. isometry (vector_to_cblinfun x)", "by force"], ["", "subsection \\<open>Butterflies (rank-1 projectors)\\<close>"], ["", "definition butterfly_def: \"butterfly (s::'a::complex_normed_vector) (t::'b::chilbert_space)\n   = vector_to_cblinfun s o\\<^sub>C\\<^sub>L (vector_to_cblinfun t :: complex \\<Rightarrow>\\<^sub>C\\<^sub>L _)*\""], ["", "abbreviation \"selfbutter s \\<equiv> butterfly s s\""], ["", "lemma butterfly_add_left: \\<open>butterfly (a + a') b = butterfly a b + butterfly a' b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly (a + a') b = butterfly a b + butterfly a' b", "by (simp add: butterfly_def vector_to_cblinfun_add cbilinear_add_left bounded_cbilinear.add_left bounded_cbilinear_cblinfun_compose)"], ["", "lemma butterfly_add_right: \\<open>butterfly a (b + b') = butterfly a b + butterfly a b'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly a (b + b') = butterfly a b + butterfly a b'", "by (simp add: butterfly_def adj_plus vector_to_cblinfun_add cblinfun_compose_add_right)"], ["", "lemma butterfly_def_one_dim: \"butterfly s t = (vector_to_cblinfun s :: 'c::one_dim \\<Rightarrow>\\<^sub>C\\<^sub>L _)\n                                          o\\<^sub>C\\<^sub>L (vector_to_cblinfun t :: 'c \\<Rightarrow>\\<^sub>C\\<^sub>L _)*\"\n  (is \"_ = ?rhs\") for s :: \"'a::complex_normed_vector\" and t :: \"'b::chilbert_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly s t =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. butterfly s t =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "let ?isoAC = \"1 :: 'c \\<Rightarrow>\\<^sub>C\\<^sub>L complex\""], ["proof (state)\ngoal (1 subgoal):\n 1. butterfly s t =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "let ?isoCA = \"1 :: complex \\<Rightarrow>\\<^sub>C\\<^sub>L 'c\""], ["proof (state)\ngoal (1 subgoal):\n 1. butterfly s t =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "let ?vector = \"vector_to_cblinfun :: _ \\<Rightarrow> ('c \\<Rightarrow>\\<^sub>C\\<^sub>L _)\""], ["proof (state)\ngoal (1 subgoal):\n 1. butterfly s t =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "have \"butterfly s t =\n    (?vector s o\\<^sub>C\\<^sub>L ?isoCA) o\\<^sub>C\\<^sub>L (?vector t o\\<^sub>C\\<^sub>L ?isoCA)*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly s t =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L 1 o\\<^sub>C\\<^sub>L\n    (vector_to_cblinfun t o\\<^sub>C\\<^sub>L 1)*", "unfolding butterfly_def vector_to_cblinfun_comp_one"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t* =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "by simp"], ["proof (state)\nthis:\n  butterfly s t =\n  vector_to_cblinfun s o\\<^sub>C\\<^sub>L 1 o\\<^sub>C\\<^sub>L\n  (vector_to_cblinfun t o\\<^sub>C\\<^sub>L 1)*\n\ngoal (1 subgoal):\n 1. butterfly s t =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "also"], ["proof (state)\nthis:\n  butterfly s t =\n  vector_to_cblinfun s o\\<^sub>C\\<^sub>L 1 o\\<^sub>C\\<^sub>L\n  (vector_to_cblinfun t o\\<^sub>C\\<^sub>L 1)*\n\ngoal (1 subgoal):\n 1. butterfly s t =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "have \"\\<dots> = ?vector s o\\<^sub>C\\<^sub>L (?isoCA o\\<^sub>C\\<^sub>L ?isoCA*) o\\<^sub>C\\<^sub>L (?vector t)*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun s o\\<^sub>C\\<^sub>L 1 o\\<^sub>C\\<^sub>L\n    (vector_to_cblinfun t o\\<^sub>C\\<^sub>L 1)* =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L\n    (1 o\\<^sub>C\\<^sub>L 1*) o\\<^sub>C\\<^sub>L\n    vector_to_cblinfun t*", "by (metis (no_types, lifting) cblinfun_compose_assoc adj_cblinfun_compose)"], ["proof (state)\nthis:\n  vector_to_cblinfun s o\\<^sub>C\\<^sub>L 1 o\\<^sub>C\\<^sub>L\n  (vector_to_cblinfun t o\\<^sub>C\\<^sub>L 1)* =\n  vector_to_cblinfun s o\\<^sub>C\\<^sub>L\n  (1 o\\<^sub>C\\<^sub>L 1*) o\\<^sub>C\\<^sub>L\n  vector_to_cblinfun t*\n\ngoal (1 subgoal):\n 1. butterfly s t =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "also"], ["proof (state)\nthis:\n  vector_to_cblinfun s o\\<^sub>C\\<^sub>L 1 o\\<^sub>C\\<^sub>L\n  (vector_to_cblinfun t o\\<^sub>C\\<^sub>L 1)* =\n  vector_to_cblinfun s o\\<^sub>C\\<^sub>L\n  (1 o\\<^sub>C\\<^sub>L 1*) o\\<^sub>C\\<^sub>L\n  vector_to_cblinfun t*\n\ngoal (1 subgoal):\n 1. butterfly s t =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun s o\\<^sub>C\\<^sub>L\n    (1 o\\<^sub>C\\<^sub>L 1*) o\\<^sub>C\\<^sub>L\n    vector_to_cblinfun t* =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "by simp"], ["proof (state)\nthis:\n  vector_to_cblinfun s o\\<^sub>C\\<^sub>L\n  (1 o\\<^sub>C\\<^sub>L 1*) o\\<^sub>C\\<^sub>L\n  vector_to_cblinfun t* =\n  vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*\n\ngoal (1 subgoal):\n 1. butterfly s t =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "finally"], ["proof (chain)\npicking this:\n  butterfly s t =\n  vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "show ?thesis"], ["proof (prove)\nusing this:\n  butterfly s t =\n  vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*\n\ngoal (1 subgoal):\n 1. butterfly s t =\n    vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*", "by simp"], ["proof (state)\nthis:\n  butterfly s t =\n  vector_to_cblinfun s o\\<^sub>C\\<^sub>L vector_to_cblinfun t*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma butterfly_comp_cblinfun: \"butterfly \\<psi> \\<phi> o\\<^sub>C\\<^sub>L a = butterfly \\<psi> (a* *\\<^sub>V \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly \\<psi> \\<phi> o\\<^sub>C\\<^sub>L a =\n    butterfly \\<psi> (a* *\\<^sub>V \\<phi>)", "unfolding butterfly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun \\<psi> o\\<^sub>C\\<^sub>L\n    vector_to_cblinfun \\<phi>* o\\<^sub>C\\<^sub>L\n    a =\n    vector_to_cblinfun \\<psi> o\\<^sub>C\\<^sub>L\n    vector_to_cblinfun (a* *\\<^sub>V \\<phi>)*", "by (simp add: cblinfun_compose_assoc vector_to_cblinfun_cblinfun_apply)"], ["", "lemma cblinfun_comp_butterfly: \"a o\\<^sub>C\\<^sub>L butterfly \\<psi> \\<phi> = butterfly (a *\\<^sub>V \\<psi>) \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a o\\<^sub>C\\<^sub>L butterfly \\<psi> \\<phi> =\n    butterfly (a *\\<^sub>V \\<psi>) \\<phi>", "unfolding butterfly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a o\\<^sub>C\\<^sub>L\n    (vector_to_cblinfun \\<psi> o\\<^sub>C\\<^sub>L\n     vector_to_cblinfun \\<phi>*) =\n    vector_to_cblinfun (a *\\<^sub>V \\<psi>) o\\<^sub>C\\<^sub>L\n    vector_to_cblinfun \\<phi>*", "by (simp add: cblinfun_compose_assoc vector_to_cblinfun_cblinfun_apply)"], ["", "lemma butterfly_apply[simp]: \"butterfly \\<psi> \\<psi>' *\\<^sub>V \\<phi> = \\<langle>\\<psi>', \\<phi>\\<rangle> *\\<^sub>C \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly \\<psi> \\<psi>' *\\<^sub>V \\<phi> =\n    (\\<psi>' \\<bullet>\\<^sub>C \\<phi>) *\\<^sub>C \\<psi>", "by (simp add: butterfly_def scaleC_cblinfun.rep_eq)"], ["", "lemma butterfly_scaleC_left[simp]: \"butterfly (c *\\<^sub>C \\<psi>) \\<phi> = c *\\<^sub>C butterfly \\<psi> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly (c *\\<^sub>C \\<psi>) \\<phi> =\n    c *\\<^sub>C butterfly \\<psi> \\<phi>", "unfolding butterfly_def vector_to_cblinfun_scaleC scaleC_adj"], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C vector_to_cblinfun \\<psi> o\\<^sub>C\\<^sub>L\n    vector_to_cblinfun \\<phi>* =\n    c *\\<^sub>C\n    (vector_to_cblinfun \\<psi> o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi>*)", "by (simp add: cnj_x_x)"], ["", "lemma butterfly_scaleC_right[simp]: \"butterfly \\<psi> (c *\\<^sub>C \\<phi>) = cnj c *\\<^sub>C butterfly \\<psi> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly \\<psi> (c *\\<^sub>C \\<phi>) =\n    cnj c *\\<^sub>C butterfly \\<psi> \\<phi>", "unfolding butterfly_def vector_to_cblinfun_scaleC scaleC_adj"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun \\<psi> o\\<^sub>C\\<^sub>L\n    cnj c *\\<^sub>C vector_to_cblinfun \\<phi>* =\n    cnj c *\\<^sub>C\n    (vector_to_cblinfun \\<psi> o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<phi>*)", "by (simp add: cnj_x_x)"], ["", "lemma butterfly_scaleR_left[simp]: \"butterfly (r *\\<^sub>R \\<psi>) \\<phi> = r *\\<^sub>C butterfly \\<psi> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly (r *\\<^sub>R \\<psi>) \\<phi> =\n    complex_of_real r *\\<^sub>C butterfly \\<psi> \\<phi>", "by (simp add: scaleR_scaleC)"], ["", "lemma butterfly_scaleR_right[simp]: \"butterfly \\<psi> (r *\\<^sub>R \\<phi>) = r *\\<^sub>C butterfly \\<psi> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly \\<psi> (r *\\<^sub>R \\<phi>) =\n    complex_of_real r *\\<^sub>C butterfly \\<psi> \\<phi>", "by (simp add: butterfly_scaleC_right scaleR_scaleC)"], ["", "lemma butterfly_adjoint[simp]: \"(butterfly \\<psi> \\<phi>)* = butterfly \\<phi> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly \\<psi> \\<phi>* = butterfly \\<phi> \\<psi>", "unfolding butterfly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (vector_to_cblinfun \\<psi> o\\<^sub>C\\<^sub>L\n     vector_to_cblinfun \\<phi>*)* =\n    vector_to_cblinfun \\<phi> o\\<^sub>C\\<^sub>L vector_to_cblinfun \\<psi>*", "by auto"], ["", "lemma butterfly_comp_butterfly[simp]: \"butterfly \\<psi>1 \\<psi>2 o\\<^sub>C\\<^sub>L butterfly \\<psi>3 \\<psi>4 = \\<langle>\\<psi>2, \\<psi>3\\<rangle> *\\<^sub>C butterfly \\<psi>1 \\<psi>4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly \\<psi>1 \\<psi>2 o\\<^sub>C\\<^sub>L butterfly \\<psi>3 \\<psi>4 =\n    (\\<psi>2 \\<bullet>\\<^sub>C \\<psi>3) *\\<^sub>C butterfly \\<psi>1 \\<psi>4", "by (simp add: butterfly_comp_cblinfun)"], ["", "lemma butterfly_0_left[simp]: \"butterfly 0 a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly (0::'b) a = 0", "by (simp add: butterfly_def)"], ["", "lemma butterfly_0_right[simp]: \"butterfly a 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly a (0::'a) = 0", "by (simp add: butterfly_def)"], ["", "lemma norm_butterfly: \"norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>", "proof (cases \"\\<phi>=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<phi> = (0::'a) \\<Longrightarrow>\n    norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>\n 2. \\<phi> \\<noteq> (0::'a) \\<Longrightarrow>\n    norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>", "case True"], ["proof (state)\nthis:\n  \\<phi> = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<phi> = (0::'a) \\<Longrightarrow>\n    norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>\n 2. \\<phi> \\<noteq> (0::'a) \\<Longrightarrow>\n    norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>", "then"], ["proof (chain)\npicking this:\n  \\<phi> = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> = (0::'a)\n\ngoal (1 subgoal):\n 1. norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>", "by simp"], ["proof (state)\nthis:\n  norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>\n\ngoal (1 subgoal):\n 1. \\<phi> \\<noteq> (0::'a) \\<Longrightarrow>\n    norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> \\<noteq> (0::'a) \\<Longrightarrow>\n    norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>", "case False"], ["proof (state)\nthis:\n  \\<phi> \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<phi> \\<noteq> (0::'a) \\<Longrightarrow>\n    norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>", "unfolding norm_cblinfun.rep_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm ((*\\<^sub>V) (butterfly \\<psi> \\<phi>)) =\n    norm \\<psi> * norm \\<phi>", "thm onormI[OF _ False]"], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm ((*\\<^sub>V) (butterfly \\<psi> \\<phi>)) =\n    norm \\<psi> * norm \\<phi>", "proof (rule onormI[OF _ False])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       norm (butterfly \\<psi> \\<phi> *\\<^sub>V x)\n       \\<le> norm \\<psi> * norm \\<phi> * norm x\n 2. norm (butterfly \\<psi> \\<phi> *\\<^sub>V \\<phi>) =\n    norm \\<psi> * norm \\<phi> * norm \\<phi>", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       norm (butterfly \\<psi> \\<phi> *\\<^sub>V x)\n       \\<le> norm \\<psi> * norm \\<phi> * norm x\n 2. norm (butterfly \\<psi> \\<phi> *\\<^sub>V \\<phi>) =\n    norm \\<psi> * norm \\<phi> * norm \\<phi>", "have \"cmod \\<langle>\\<phi>, x\\<rangle> * norm \\<psi> \\<le> norm \\<psi> * norm \\<phi> * norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<phi> \\<bullet>\\<^sub>C x) * norm \\<psi>\n    \\<le> norm \\<psi> * norm \\<phi> * norm x", "by (metis ab_semigroup_mult_class.mult_ac(1) complex_inner_class.Cauchy_Schwarz_ineq2 mult.commute mult_left_mono norm_ge_zero)"], ["proof (state)\nthis:\n  cmod (\\<phi> \\<bullet>\\<^sub>C x) * norm \\<psi>\n  \\<le> norm \\<psi> * norm \\<phi> * norm x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       norm (butterfly \\<psi> \\<phi> *\\<^sub>V x)\n       \\<le> norm \\<psi> * norm \\<phi> * norm x\n 2. norm (butterfly \\<psi> \\<phi> *\\<^sub>V \\<phi>) =\n    norm \\<psi> * norm \\<phi> * norm \\<phi>", "thus \"norm (butterfly \\<psi> \\<phi> *\\<^sub>V x) \\<le> norm \\<psi> * norm \\<phi> * norm x\""], ["proof (prove)\nusing this:\n  cmod (\\<phi> \\<bullet>\\<^sub>C x) * norm \\<psi>\n  \\<le> norm \\<psi> * norm \\<phi> * norm x\n\ngoal (1 subgoal):\n 1. norm (butterfly \\<psi> \\<phi> *\\<^sub>V x)\n    \\<le> norm \\<psi> * norm \\<phi> * norm x", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  norm (butterfly \\<psi> \\<phi> *\\<^sub>V x)\n  \\<le> norm \\<psi> * norm \\<phi> * norm x\n\ngoal (1 subgoal):\n 1. norm (butterfly \\<psi> \\<phi> *\\<^sub>V \\<phi>) =\n    norm \\<psi> * norm \\<phi> * norm \\<phi>", "show \"norm (butterfly \\<psi> \\<phi> *\\<^sub>V \\<phi>) = norm \\<psi> * norm \\<phi> * norm \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (butterfly \\<psi> \\<phi> *\\<^sub>V \\<phi>) =\n    norm \\<psi> * norm \\<phi> * norm \\<phi>", "by (smt (z3) ab_semigroup_mult_class.mult_ac(1) butterfly_apply mult.commute norm_eq_sqrt_cinner norm_ge_zero norm_scaleC power2_eq_square real_sqrt_abs real_sqrt_eq_iff)"], ["proof (state)\nthis:\n  norm (butterfly \\<psi> \\<phi> *\\<^sub>V \\<phi>) =\n  norm \\<psi> * norm \\<phi> * norm \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (butterfly \\<psi> \\<phi>) = norm \\<psi> * norm \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_sesquilinear_butterfly[bounded_sesquilinear]: \\<open>bounded_sesquilinear (\\<lambda>(b::'b::chilbert_space) (a::'a::chilbert_space). butterfly a b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>b a. butterfly a b)", "proof standard"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. butterfly b (a + a') = butterfly b a + butterfly b a'\n 2. \\<And>a b b'. butterfly (b + b') a = butterfly b a + butterfly b' a\n 3. \\<And>r a b. butterfly b (r *\\<^sub>C a) = cnj r *\\<^sub>C butterfly b a\n 4. \\<And>a r b. butterfly (r *\\<^sub>C b) a = r *\\<^sub>C butterfly b a\n 5. \\<exists>K. \\<forall>a b. norm (butterfly b a) \\<le> norm a * norm b * K", "fix a a' :: 'a and b b' :: 'b and r :: complex"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. butterfly b (a + a') = butterfly b a + butterfly b a'\n 2. \\<And>a b b'. butterfly (b + b') a = butterfly b a + butterfly b' a\n 3. \\<And>r a b. butterfly b (r *\\<^sub>C a) = cnj r *\\<^sub>C butterfly b a\n 4. \\<And>a r b. butterfly (r *\\<^sub>C b) a = r *\\<^sub>C butterfly b a\n 5. \\<exists>K. \\<forall>a b. norm (butterfly b a) \\<le> norm a * norm b * K", "show \\<open>butterfly (a + a') b = butterfly a b + butterfly a' b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly (a + a') b = butterfly a b + butterfly a' b", "by (rule butterfly_add_left)"], ["proof (state)\nthis:\n  butterfly (a + a') b = butterfly a b + butterfly a' b\n\ngoal (4 subgoals):\n 1. \\<And>a a' b. butterfly b (a + a') = butterfly b a + butterfly b a'\n 2. \\<And>r a b. butterfly b (r *\\<^sub>C a) = cnj r *\\<^sub>C butterfly b a\n 3. \\<And>a r b. butterfly (r *\\<^sub>C b) a = r *\\<^sub>C butterfly b a\n 4. \\<exists>K. \\<forall>a b. norm (butterfly b a) \\<le> norm a * norm b * K", "show \\<open>butterfly a (b + b') = butterfly a b + butterfly a b'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly a (b + b') = butterfly a b + butterfly a b'", "by (rule butterfly_add_right)"], ["proof (state)\nthis:\n  butterfly a (b + b') = butterfly a b + butterfly a b'\n\ngoal (3 subgoals):\n 1. \\<And>r a b. butterfly b (r *\\<^sub>C a) = cnj r *\\<^sub>C butterfly b a\n 2. \\<And>a r b. butterfly (r *\\<^sub>C b) a = r *\\<^sub>C butterfly b a\n 3. \\<exists>K. \\<forall>a b. norm (butterfly b a) \\<le> norm a * norm b * K", "show \\<open>butterfly (r *\\<^sub>C a) b = r *\\<^sub>C butterfly a b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly (r *\\<^sub>C a) b = r *\\<^sub>C butterfly a b", "by simp"], ["proof (state)\nthis:\n  butterfly (r *\\<^sub>C a) b = r *\\<^sub>C butterfly a b\n\ngoal (2 subgoals):\n 1. \\<And>r a b. butterfly b (r *\\<^sub>C a) = cnj r *\\<^sub>C butterfly b a\n 2. \\<exists>K. \\<forall>a b. norm (butterfly b a) \\<le> norm a * norm b * K", "show \\<open>butterfly a (r *\\<^sub>C b) = cnj r *\\<^sub>C butterfly a b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. butterfly a (r *\\<^sub>C b) = cnj r *\\<^sub>C butterfly a b", "by simp"], ["proof (state)\nthis:\n  butterfly a (r *\\<^sub>C b) = cnj r *\\<^sub>C butterfly a b\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (butterfly b a) \\<le> norm a * norm b * K", "show \\<open>\\<exists>K. \\<forall>b a. norm (butterfly a b) \\<le> norm b * norm a * K \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>b a. norm (butterfly a b) \\<le> norm b * norm a * K", "apply (rule exI[of _ 1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b a. norm (butterfly a b) \\<le> norm b * norm a * 1", "by (simp add: norm_butterfly)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>b a. norm (butterfly a b) \\<le> norm b * norm a * K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_selfbutter_upto_phase: \n  assumes \"selfbutter x = selfbutter y\"\n  shows \"\\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y\n 2. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "case True"], ["proof (state)\nthis:\n  x = (0::'a)\n\ngoal (2 subgoals):\n 1. x = (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y\n 2. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "from assms"], ["proof (chain)\npicking this:\n  selfbutter x = selfbutter y", "have \"y = 0\""], ["proof (prove)\nusing this:\n  selfbutter x = selfbutter y\n\ngoal (1 subgoal):\n 1. y = (0::'a)", "using norm_butterfly"], ["proof (prove)\nusing this:\n  selfbutter x = selfbutter y\n  norm (butterfly ?\\<psi> ?\\<phi>) = norm ?\\<psi> * norm ?\\<phi>\n\ngoal (1 subgoal):\n 1. y = (0::'a)", "by (metis True butterfly_0_left divisors_zero norm_eq_zero)"], ["proof (state)\nthis:\n  y = (0::'a)\n\ngoal (2 subgoals):\n 1. x = (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y\n 2. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "with True"], ["proof (chain)\npicking this:\n  x = (0::'a)\n  y = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  x = (0::'a)\n  y = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "using norm_one"], ["proof (prove)\nusing this:\n  x = (0::'a)\n  y = (0::'a)\n  norm (1::?'a) = 1\n\ngoal (1 subgoal):\n 1. \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "case False"], ["proof (state)\nthis:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "define c where \"c = \\<langle>y, x\\<rangle> / \\<langle>x, x\\<rangle>\""], ["proof (state)\nthis:\n  c = y \\<bullet>\\<^sub>C x / (x \\<bullet>\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "have \"\\<langle>x, x\\<rangle> *\\<^sub>C x = selfbutter x *\\<^sub>V x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<bullet>\\<^sub>C x) *\\<^sub>C x = selfbutter x *\\<^sub>V x", "by (simp add: butterfly_apply)"], ["proof (state)\nthis:\n  (x \\<bullet>\\<^sub>C x) *\\<^sub>C x = selfbutter x *\\<^sub>V x\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "also"], ["proof (state)\nthis:\n  (x \\<bullet>\\<^sub>C x) *\\<^sub>C x = selfbutter x *\\<^sub>V x\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "have \"\\<dots> = selfbutter y *\\<^sub>V x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. selfbutter x *\\<^sub>V x = selfbutter y *\\<^sub>V x", "using assms"], ["proof (prove)\nusing this:\n  selfbutter x = selfbutter y\n\ngoal (1 subgoal):\n 1. selfbutter x *\\<^sub>V x = selfbutter y *\\<^sub>V x", "by simp"], ["proof (state)\nthis:\n  selfbutter x *\\<^sub>V x = selfbutter y *\\<^sub>V x\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "also"], ["proof (state)\nthis:\n  selfbutter x *\\<^sub>V x = selfbutter y *\\<^sub>V x\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "have \"\\<dots> = \\<langle>y, x\\<rangle> *\\<^sub>C y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. selfbutter y *\\<^sub>V x = (y \\<bullet>\\<^sub>C x) *\\<^sub>C y", "by (simp add: butterfly_apply)"], ["proof (state)\nthis:\n  selfbutter y *\\<^sub>V x = (y \\<bullet>\\<^sub>C x) *\\<^sub>C y\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "finally"], ["proof (chain)\npicking this:\n  (x \\<bullet>\\<^sub>C x) *\\<^sub>C x = (y \\<bullet>\\<^sub>C x) *\\<^sub>C y", "have xcy: \"x = c *\\<^sub>C y\""], ["proof (prove)\nusing this:\n  (x \\<bullet>\\<^sub>C x) *\\<^sub>C x = (y \\<bullet>\\<^sub>C x) *\\<^sub>C y\n\ngoal (1 subgoal):\n 1. x = c *\\<^sub>C y", "by (simp add: c_def ceq_vector_fraction_iff)"], ["proof (state)\nthis:\n  x = c *\\<^sub>C y\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "have \"cmod c * norm x = cmod c * norm y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod c * norm x = cmod c * norm y", "using assms norm_butterfly"], ["proof (prove)\nusing this:\n  selfbutter x = selfbutter y\n  norm (butterfly ?\\<psi> ?\\<phi>) = norm ?\\<psi> * norm ?\\<phi>\n\ngoal (1 subgoal):\n 1. cmod c * norm x = cmod c * norm y", "by (smt (verit, ccfv_SIG) \\<open>\\<langle>x, x\\<rangle> *\\<^sub>C x = selfbutter x *\\<^sub>V x\\<close> \\<open>selfbutter y *\\<^sub>V x = \\<langle>y, x\\<rangle> *\\<^sub>C y\\<close> cinner_scaleC_right complex_vector.scale_left_commute complex_vector.scale_right_imp_eq mult_cancel_left norm_eq_sqrt_cinner norm_eq_zero scaleC_scaleC xcy)"], ["proof (state)\nthis:\n  cmod c * norm x = cmod c * norm y\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "also"], ["proof (state)\nthis:\n  cmod c * norm x = cmod c * norm y\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "have \"cmod c * norm y = norm (c *\\<^sub>C y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod c * norm y = norm (c *\\<^sub>C y)", "by simp"], ["proof (state)\nthis:\n  cmod c * norm y = norm (c *\\<^sub>C y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "also"], ["proof (state)\nthis:\n  cmod c * norm y = norm (c *\\<^sub>C y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "have \"\\<dots> = norm x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (c *\\<^sub>C y) = norm x", "unfolding xcy[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x = norm x", "by simp"], ["proof (state)\nthis:\n  norm (c *\\<^sub>C y) = norm x\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "finally"], ["proof (chain)\npicking this:\n  cmod c * norm x = norm x", "have c: \"cmod c = 1\""], ["proof (prove)\nusing this:\n  cmod c * norm x = norm x\n\ngoal (1 subgoal):\n 1. cmod c = 1", "by (simp add: False)"], ["proof (state)\nthis:\n  cmod c = 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "from c xcy"], ["proof (chain)\npicking this:\n  cmod c = 1\n  x = c *\\<^sub>C y", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod c = 1\n  x = c *\\<^sub>C y\n\ngoal (1 subgoal):\n 1. \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y", "by auto"], ["proof (state)\nthis:\n  \\<exists>c. cmod c = 1 \\<and> x = c *\\<^sub>C y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma butterfly_eq_proj:\n  assumes \"norm x = 1\"\n  shows \"selfbutter x = proj x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. selfbutter x = proj x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. selfbutter x = proj x", "define B and \\<phi> :: \"complex \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\"\n    where \"B = selfbutter x\" and \"\\<phi> = vector_to_cblinfun x\""], ["proof (state)\nthis:\n  B = selfbutter x\n  \\<phi> = vector_to_cblinfun x\n\ngoal (1 subgoal):\n 1. selfbutter x = proj x", "then"], ["proof (chain)\npicking this:\n  B = selfbutter x\n  \\<phi> = vector_to_cblinfun x", "have B: \"B = \\<phi> o\\<^sub>C\\<^sub>L \\<phi>*\""], ["proof (prove)\nusing this:\n  B = selfbutter x\n  \\<phi> = vector_to_cblinfun x\n\ngoal (1 subgoal):\n 1. B = \\<phi> o\\<^sub>C\\<^sub>L \\<phi>*", "unfolding butterfly_def"], ["proof (prove)\nusing this:\n  B = vector_to_cblinfun x o\\<^sub>C\\<^sub>L vector_to_cblinfun x*\n  \\<phi> = vector_to_cblinfun x\n\ngoal (1 subgoal):\n 1. B = \\<phi> o\\<^sub>C\\<^sub>L \\<phi>*", "by simp"], ["proof (state)\nthis:\n  B = \\<phi> o\\<^sub>C\\<^sub>L \\<phi>*\n\ngoal (1 subgoal):\n 1. selfbutter x = proj x", "have \\<phi>adj\\<phi>: \"\\<phi>* o\\<^sub>C\\<^sub>L \\<phi> = id_cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>* o\\<^sub>C\\<^sub>L \\<phi> = id_cblinfun", "using \\<phi>_def assms isometry_def isometry_vector_to_cblinfun"], ["proof (prove)\nusing this:\n  \\<phi> = vector_to_cblinfun x\n  norm x = 1\n  isometry ?U = (?U* o\\<^sub>C\\<^sub>L ?U = id_cblinfun)\n  norm ?x = 1 \\<Longrightarrow> isometry (vector_to_cblinfun ?x)\n\ngoal (1 subgoal):\n 1. \\<phi>* o\\<^sub>C\\<^sub>L \\<phi> = id_cblinfun", "by blast"], ["proof (state)\nthis:\n  \\<phi>* o\\<^sub>C\\<^sub>L \\<phi> = id_cblinfun\n\ngoal (1 subgoal):\n 1. selfbutter x = proj x", "have \"B o\\<^sub>C\\<^sub>L B = \\<phi> o\\<^sub>C\\<^sub>L (\\<phi>* o\\<^sub>C\\<^sub>L \\<phi>) o\\<^sub>C\\<^sub>L \\<phi>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B o\\<^sub>C\\<^sub>L B =\n    \\<phi> o\\<^sub>C\\<^sub>L\n    (\\<phi>* o\\<^sub>C\\<^sub>L \\<phi>) o\\<^sub>C\\<^sub>L\n    \\<phi>*", "by (simp add: B cblinfun_assoc_left(1))"], ["proof (state)\nthis:\n  B o\\<^sub>C\\<^sub>L B =\n  \\<phi> o\\<^sub>C\\<^sub>L\n  (\\<phi>* o\\<^sub>C\\<^sub>L \\<phi>) o\\<^sub>C\\<^sub>L\n  \\<phi>*\n\ngoal (1 subgoal):\n 1. selfbutter x = proj x", "also"], ["proof (state)\nthis:\n  B o\\<^sub>C\\<^sub>L B =\n  \\<phi> o\\<^sub>C\\<^sub>L\n  (\\<phi>* o\\<^sub>C\\<^sub>L \\<phi>) o\\<^sub>C\\<^sub>L\n  \\<phi>*\n\ngoal (1 subgoal):\n 1. selfbutter x = proj x", "have \"\\<dots> = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> o\\<^sub>C\\<^sub>L\n    (\\<phi>* o\\<^sub>C\\<^sub>L \\<phi>) o\\<^sub>C\\<^sub>L\n    \\<phi>* =\n    B", "unfolding \\<phi>adj\\<phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> o\\<^sub>C\\<^sub>L id_cblinfun o\\<^sub>C\\<^sub>L \\<phi>* = B", "by (simp add: B)"], ["proof (state)\nthis:\n  \\<phi> o\\<^sub>C\\<^sub>L\n  (\\<phi>* o\\<^sub>C\\<^sub>L \\<phi>) o\\<^sub>C\\<^sub>L\n  \\<phi>* =\n  B\n\ngoal (1 subgoal):\n 1. selfbutter x = proj x", "finally"], ["proof (chain)\npicking this:\n  B o\\<^sub>C\\<^sub>L B = B", "have idem: \"B o\\<^sub>C\\<^sub>L B = B\""], ["proof (prove)\nusing this:\n  B o\\<^sub>C\\<^sub>L B = B\n\ngoal (1 subgoal):\n 1. B o\\<^sub>C\\<^sub>L B = B", "."], ["proof (state)\nthis:\n  B o\\<^sub>C\\<^sub>L B = B\n\ngoal (1 subgoal):\n 1. selfbutter x = proj x", "have herm: \"B = B*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B = B*", "unfolding B"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> o\\<^sub>C\\<^sub>L \\<phi>* = (\\<phi> o\\<^sub>C\\<^sub>L \\<phi>*)*", "by simp"], ["proof (state)\nthis:\n  B = B*\n\ngoal (1 subgoal):\n 1. selfbutter x = proj x", "from idem herm"], ["proof (chain)\npicking this:\n  B o\\<^sub>C\\<^sub>L B = B\n  B = B*", "have BProj: \"B = Proj (B *\\<^sub>S top)\""], ["proof (prove)\nusing this:\n  B o\\<^sub>C\\<^sub>L B = B\n  B = B*\n\ngoal (1 subgoal):\n 1. B = Proj (B *\\<^sub>S \\<top>)", "by (rule Proj_on_own_range'[symmetric])"], ["proof (state)\nthis:\n  B = Proj (B *\\<^sub>S \\<top>)\n\ngoal (1 subgoal):\n 1. selfbutter x = proj x", "have \"B *\\<^sub>S top = ccspan {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B *\\<^sub>S \\<top> = ccspan {x}", "by (simp add: B \\<phi>_def assms cblinfun_compose_image range_adjoint_isometry)"], ["proof (state)\nthis:\n  B *\\<^sub>S \\<top> = ccspan {x}\n\ngoal (1 subgoal):\n 1. selfbutter x = proj x", "with BProj"], ["proof (chain)\npicking this:\n  B = Proj (B *\\<^sub>S \\<top>)\n  B *\\<^sub>S \\<top> = ccspan {x}", "show \"B = proj x\""], ["proof (prove)\nusing this:\n  B = Proj (B *\\<^sub>S \\<top>)\n  B *\\<^sub>S \\<top> = ccspan {x}\n\ngoal (1 subgoal):\n 1. B = proj x", "by simp"], ["proof (state)\nthis:\n  B = proj x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma butterfly_is_Proj:\n  \\<open>norm x = 1 \\<Longrightarrow> is_Proj (selfbutter x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm x = 1 \\<Longrightarrow> is_Proj (selfbutter x)", "by (subst butterfly_eq_proj, simp_all)"], ["", "lemma cspan_butterfly_UNIV:\n  assumes \\<open>cspan basisA = UNIV\\<close>\n  assumes \\<open>cspan basisB = UNIV\\<close>\n  assumes \\<open>is_ortho_set basisB\\<close>\n  assumes \\<open>\\<And>b. b \\<in> basisB \\<Longrightarrow> norm b = 1\\<close>\n  shows \\<open>cspan {butterfly a b| (a::'a::{complex_normed_vector}) (b::'b::{chilbert_space,cfinite_dim}). a \\<in> basisA \\<and> b \\<in> basisB} = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan {butterfly a b |a b. a \\<in> basisA \\<and> b \\<in> basisB} = UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cspan {butterfly a b |a b. a \\<in> basisA \\<and> b \\<in> basisB} = UNIV", "have F: \\<open>\\<exists>F\\<in>{butterfly a b |a b. a \\<in> basisA \\<and> b \\<in> basisB}. \\<forall>b'\\<in>basisB. F *\\<^sub>V b' = (if b' = b then a else 0)\\<close>\n    if \\<open>a \\<in> basisA\\<close> and \\<open>b \\<in> basisB\\<close> for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F\\<in>{butterfly a b |a b.\n                    a \\<in> basisA \\<and> b \\<in> basisB}.\n       \\<forall>b'\\<in>basisB.\n          F *\\<^sub>V b' = (if b' = b then a else (0::'a))", "apply (rule bexI[where x=\\<open>butterfly a b\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>b'\\<in>basisB.\n       butterfly a b *\\<^sub>V b' = (if b' = b then a else (0::'a))\n 2. butterfly a b\n    \\<in> {butterfly a b |a b. a \\<in> basisA \\<and> b \\<in> basisB}", "using assms that"], ["proof (prove)\nusing this:\n  cspan basisA = UNIV\n  cspan basisB = UNIV\n  is_ortho_set basisB\n  ?b \\<in> basisB \\<Longrightarrow> norm ?b = 1\n  a \\<in> basisA\n  b \\<in> basisB\n\ngoal (2 subgoals):\n 1. \\<forall>b'\\<in>basisB.\n       butterfly a b *\\<^sub>V b' = (if b' = b then a else (0::'a))\n 2. butterfly a b\n    \\<in> {butterfly a b |a b. a \\<in> basisA \\<and> b \\<in> basisB}", "by (auto simp: is_ortho_set_def cnorm_eq_1)"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> basisA; ?b \\<in> basisB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>F\\<in>{butterfly a b |a b.\n                                    a \\<in> basisA \\<and> b \\<in> basisB}.\n                       \\<forall>b'\\<in>basisB.\n                          F *\\<^sub>V b' = (if b' = ?b then ?a else (0::'a))\n\ngoal (1 subgoal):\n 1. cspan {butterfly a b |a b. a \\<in> basisA \\<and> b \\<in> basisB} = UNIV", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan {butterfly a b |a b. a \\<in> basisA \\<and> b \\<in> basisB} = UNIV", "apply (rule cblinfun_cspan_UNIV[where basisA=basisB and basisB=basisA])"], ["proof (prove)\ngoal (3 subgoals):\n 1. cspan basisB = UNIV\n 2. cspan basisA = UNIV\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> basisB; b \\<in> basisA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<in>{butterfly a b |a b.\n   a \\<in> basisA \\<and> b \\<in> basisB}.\n                            \\<forall>a'\\<in>basisB.\n                               F *\\<^sub>V a' =\n                               (if a' = a then b else (0::'a))", "using assms"], ["proof (prove)\nusing this:\n  cspan basisA = UNIV\n  cspan basisB = UNIV\n  is_ortho_set basisB\n  ?b \\<in> basisB \\<Longrightarrow> norm ?b = 1\n\ngoal (3 subgoals):\n 1. cspan basisB = UNIV\n 2. cspan basisA = UNIV\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> basisB; b \\<in> basisA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<in>{butterfly a b |a b.\n   a \\<in> basisA \\<and> b \\<in> basisB}.\n                            \\<forall>a'\\<in>basisB.\n                               F *\\<^sub>V a' =\n                               (if a' = a then b else (0::'a))", "apply auto[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> basisB; b \\<in> basisA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<in>{butterfly a b |a b.\n   a \\<in> basisA \\<and> b \\<in> basisB}.\n                            \\<forall>a'\\<in>basisB.\n                               F *\\<^sub>V a' =\n                               (if a' = a then b else (0::'a))", "using F"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> basisA; ?b \\<in> basisB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>F\\<in>{butterfly a b |a b.\n                                    a \\<in> basisA \\<and> b \\<in> basisB}.\n                       \\<forall>b'\\<in>basisB.\n                          F *\\<^sub>V b' = (if b' = ?b then ?a else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> basisB; b \\<in> basisA\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F\\<in>{butterfly a b |a b.\n   a \\<in> basisA \\<and> b \\<in> basisB}.\n                            \\<forall>a'\\<in>basisB.\n                               F *\\<^sub>V a' =\n                               (if a' = a then b else (0::'a))", "by (smt (verit, ccfv_SIG) image_iff)"], ["proof (state)\nthis:\n  cspan {butterfly a b |a b. a \\<in> basisA \\<and> b \\<in> basisB} = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindependent_butterfly: \n  fixes basisA :: \\<open>'a::chilbert_space set\\<close> and basisB :: \\<open>'b::chilbert_space set\\<close>\n  assumes \\<open>is_ortho_set basisA\\<close> \\<open>is_ortho_set basisB\\<close>\n  assumes normA: \\<open>\\<And>a. a\\<in>basisA \\<Longrightarrow> norm a = 1\\<close> and normB: \\<open>\\<And>b. b\\<in>basisB \\<Longrightarrow> norm b = 1\\<close>\n  shows \\<open>cindependent {butterfly a b| a b. a\\<in>basisA \\<and> b\\<in>basisB}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent {butterfly a b |a b. a \\<in> basisA \\<and> b \\<in> basisB}", "proof (unfold complex_vector.independent_explicit_module, intro allI impI, rename_tac T f g)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "fix T :: \\<open>('b \\<Rightarrow>\\<^sub>C\\<^sub>L 'a) set\\<close> and f :: \\<open>'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'a \\<Rightarrow> complex\\<close> and g :: \\<open>'b \\<Rightarrow>\\<^sub>C\\<^sub>L 'a\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "assume \\<open>finite T\\<close>"], ["proof (state)\nthis:\n  finite T\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "assume T_subset: \\<open>T \\<subseteq> {butterfly a b |a b. a \\<in> basisA \\<and> b \\<in> basisB}\\<close>"], ["proof (state)\nthis:\n  T \\<subseteq> {butterfly a b |a b. a \\<in> basisA \\<and> b \\<in> basisB}\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "define lin where \\<open>lin = (\\<Sum>g\\<in>T. f g *\\<^sub>C g)\\<close>"], ["proof (state)\nthis:\n  lin = (\\<Sum>g\\<in>T. f g *\\<^sub>C g)\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "assume \\<open>lin = 0\\<close>"], ["proof (state)\nthis:\n  lin = 0\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "assume \\<open>g \\<in> T\\<close>"], ["proof (state)\nthis:\n  g \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "(* To show: f g = 0 *)"], ["proof (state)\nthis:\n  g \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "then"], ["proof (chain)\npicking this:\n  g \\<in> T", "obtain a b where g: \\<open>g = butterfly a b\\<close> and [simp]: \\<open>a \\<in> basisA\\<close> \\<open>b \\<in> basisB\\<close>"], ["proof (prove)\nusing this:\n  g \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>g = butterfly a b; a \\<in> basisA; b \\<in> basisB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using T_subset"], ["proof (prove)\nusing this:\n  g \\<in> T\n  T \\<subseteq> {butterfly a b |a b. a \\<in> basisA \\<and> b \\<in> basisB}\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>g = butterfly a b; a \\<in> basisA; b \\<in> basisB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g = butterfly a b\n  a \\<in> basisA\n  b \\<in> basisB\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "have *: \"(vector_to_cblinfun a)* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = 0\"\n    if \\<open>g \\<in> T - {butterfly a b}\\<close> for g"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'c)", "from that"], ["proof (chain)\npicking this:\n  g \\<in> T - {butterfly a b}", "obtain a' b' where g: \\<open>g = butterfly a' b'\\<close> and [simp]: \\<open>a' \\<in> basisA\\<close> \\<open>b' \\<in> basisB\\<close>"], ["proof (prove)\nusing this:\n  g \\<in> T - {butterfly a b}\n\ngoal (1 subgoal):\n 1. (\\<And>a' b'.\n        \\<lbrakk>g = butterfly a' b'; a' \\<in> basisA;\n         b' \\<in> basisB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using T_subset"], ["proof (prove)\nusing this:\n  g \\<in> T - {butterfly a b}\n  T \\<subseteq> {butterfly a b |a b. a \\<in> basisA \\<and> b \\<in> basisB}\n\ngoal (1 subgoal):\n 1. (\\<And>a' b'.\n        \\<lbrakk>g = butterfly a' b'; a' \\<in> basisA;\n         b' \\<in> basisB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g = butterfly a' b'\n  a' \\<in> basisA\n  b' \\<in> basisB\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'c)", "from that"], ["proof (chain)\npicking this:\n  g \\<in> T - {butterfly a b}", "have \\<open>g \\<noteq> butterfly a b\\<close>"], ["proof (prove)\nusing this:\n  g \\<in> T - {butterfly a b}\n\ngoal (1 subgoal):\n 1. g \\<noteq> butterfly a b", "by auto"], ["proof (state)\nthis:\n  g \\<noteq> butterfly a b\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'c)", "with g"], ["proof (chain)\npicking this:\n  g = butterfly a' b'\n  g \\<noteq> butterfly a b", "consider (a) \\<open>a\\<noteq>a'\\<close> | (b) \\<open>b\\<noteq>b'\\<close>"], ["proof (prove)\nusing this:\n  g = butterfly a' b'\n  g \\<noteq> butterfly a b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> a' \\<Longrightarrow> thesis;\n     b \\<noteq> b' \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<noteq> a' \\<Longrightarrow> ?thesis;\n   b \\<noteq> b' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'c)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a \\<noteq> a' \\<Longrightarrow> ?thesis;\n   b \\<noteq> b' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \\<open>(vector_to_cblinfun a)* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = 0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<noteq> a' \\<Longrightarrow> ?thesis;\n   b \\<noteq> b' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<noteq> a' \\<Longrightarrow>\n    vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)\n 2. b \\<noteq> b' \\<Longrightarrow>\n    vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)", "case a"], ["proof (state)\nthis:\n  a \\<noteq> a'\n\ngoal (2 subgoals):\n 1. a \\<noteq> a' \\<Longrightarrow>\n    vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)\n 2. b \\<noteq> b' \\<Longrightarrow>\n    vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> a'", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> a'\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)", "using  \\<open>is_ortho_set basisA\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> a'\n  is_ortho_set basisA\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)", "unfolding g"], ["proof (prove)\nusing this:\n  a \\<noteq> a'\n  is_ortho_set basisA\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V\n    f (butterfly a' b') *\\<^sub>C butterfly a' b' *\\<^sub>V b =\n    (0::'d)", "by (auto simp: is_ortho_set_def butterfly_def scaleC_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)\n\ngoal (1 subgoal):\n 1. b \\<noteq> b' \\<Longrightarrow>\n    vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> b' \\<Longrightarrow>\n    vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)", "case b"], ["proof (state)\nthis:\n  b \\<noteq> b'\n\ngoal (1 subgoal):\n 1. b \\<noteq> b' \\<Longrightarrow>\n    vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)", "then"], ["proof (chain)\npicking this:\n  b \\<noteq> b'", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<noteq> b'\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)", "using  \\<open>is_ortho_set basisB\\<close>"], ["proof (prove)\nusing this:\n  b \\<noteq> b'\n  is_ortho_set basisB\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)", "unfolding g"], ["proof (prove)\nusing this:\n  b \\<noteq> b'\n  is_ortho_set basisB\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V\n    f (butterfly a' b') *\\<^sub>C butterfly a' b' *\\<^sub>V b =\n    (0::'d)", "by (auto simp: is_ortho_set_def butterfly_def scaleC_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::'d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = (0::?'d1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?g1 \\<in> T - {butterfly a b} \\<Longrightarrow>\n  vector_to_cblinfun a* *\\<^sub>V f ?g1 *\\<^sub>C ?g1 *\\<^sub>V b =\n  (0::?'c2)\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "have \\<open>0 = (vector_to_cblinfun a)* *\\<^sub>V lin *\\<^sub>V b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'c) = vector_to_cblinfun a* *\\<^sub>V lin *\\<^sub>V b", "using \\<open>lin = 0\\<close>"], ["proof (prove)\nusing this:\n  lin = 0\n\ngoal (1 subgoal):\n 1. (0::'c) = vector_to_cblinfun a* *\\<^sub>V lin *\\<^sub>V b", "by auto"], ["proof (state)\nthis:\n  (0::?'c2) = vector_to_cblinfun a* *\\<^sub>V lin *\\<^sub>V b\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "also"], ["proof (state)\nthis:\n  (0::?'c2) = vector_to_cblinfun a* *\\<^sub>V lin *\\<^sub>V b\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "have \\<open>\\<dots> = (\\<Sum>g\\<in>T. (vector_to_cblinfun a)* *\\<^sub>V (f g *\\<^sub>C g) *\\<^sub>V b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V lin *\\<^sub>V b =\n    (\\<Sum>g\\<in>T.\n       vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b)", "unfolding lin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V\n    (\\<Sum>g\\<in>T. f g *\\<^sub>C g) *\\<^sub>V b =\n    (\\<Sum>g\\<in>T.\n       vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b)", "apply (rule complex_vector.linear_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear (\\<lambda>c. vector_to_cblinfun a* *\\<^sub>V c *\\<^sub>V b)", "by (smt (z3) cblinfun.scaleC_left cblinfun.scaleC_right cblinfun.add_right clinearI plus_cblinfun.rep_eq)"], ["proof (state)\nthis:\n  vector_to_cblinfun a* *\\<^sub>V lin *\\<^sub>V b =\n  (\\<Sum>g\\<in>T.\n     vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b)\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "also"], ["proof (state)\nthis:\n  vector_to_cblinfun a* *\\<^sub>V lin *\\<^sub>V b =\n  (\\<Sum>g\\<in>T.\n     vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b)\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "have \\<open>\\<dots> = (\\<Sum>g\\<in>{butterfly a b}. (vector_to_cblinfun a)* *\\<^sub>V (f g *\\<^sub>C g) *\\<^sub>V b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>g\\<in>T.\n       vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b) =\n    (\\<Sum>g\\<in>{butterfly a b}.\n       vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b)", "apply (rule sum.mono_neutral_right)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite T\n 2. {butterfly a b} \\<subseteq> T\n 3. \\<forall>i\\<in>T - {butterfly a b}.\n       vector_to_cblinfun a* *\\<^sub>V f i *\\<^sub>C i *\\<^sub>V b = (0::'c)", "using \\<open>finite T\\<close> * \\<open>g \\<in> T\\<close> g"], ["proof (prove)\nusing this:\n  finite T\n  ?g1 \\<in> T - {butterfly a b} \\<Longrightarrow>\n  vector_to_cblinfun a* *\\<^sub>V f ?g1 *\\<^sub>C ?g1 *\\<^sub>V b =\n  (0::?'c2)\n  g \\<in> T\n  g = butterfly a b\n\ngoal (3 subgoals):\n 1. finite T\n 2. {butterfly a b} \\<subseteq> T\n 3. \\<forall>i\\<in>T - {butterfly a b}.\n       vector_to_cblinfun a* *\\<^sub>V f i *\\<^sub>C i *\\<^sub>V b = (0::'c)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>g\\<in>T.\n     vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b) =\n  (\\<Sum>g\\<in>{butterfly a b}.\n     vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b)\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>g\\<in>T.\n     vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b) =\n  (\\<Sum>g\\<in>{butterfly a b}.\n     vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b)\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "have \\<open>\\<dots> = (vector_to_cblinfun a)* *\\<^sub>V (f g *\\<^sub>C g) *\\<^sub>V b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>g\\<in>{butterfly a b}.\n       vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b) =\n    vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b", "by (simp add: g)"], ["proof (state)\nthis:\n  (\\<Sum>g\\<in>{butterfly a b}.\n     vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b) =\n  vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>g\\<in>{butterfly a b}.\n     vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b) =\n  vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "have \\<open>\\<dots> = f g\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = f g", "unfolding g"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V\n    f (butterfly a b) *\\<^sub>C butterfly a b *\\<^sub>V b =\n    f (butterfly a b)", "using normA normB"], ["proof (prove)\nusing this:\n  ?a \\<in> basisA \\<Longrightarrow> norm ?a = 1\n  ?b \\<in> basisB \\<Longrightarrow> norm ?b = 1\n\ngoal (1 subgoal):\n 1. vector_to_cblinfun a* *\\<^sub>V\n    f (butterfly a b) *\\<^sub>C butterfly a b *\\<^sub>V b =\n    f (butterfly a b)", "by (auto simp: butterfly_def scaleC_cblinfun.rep_eq cnorm_eq_1)"], ["proof (state)\nthis:\n  vector_to_cblinfun a* *\\<^sub>V f g *\\<^sub>C g *\\<^sub>V b = f g\n\ngoal (1 subgoal):\n 1. \\<And>T f g.\n       \\<lbrakk>finite T;\n        T \\<subseteq> {butterfly a b |a b.\n                       a \\<in> basisA \\<and> b \\<in> basisB};\n        (\\<Sum>v\\<in>T. f v *\\<^sub>C v) = 0; g \\<in> T\\<rbrakk>\n       \\<Longrightarrow> f g = 0", "finally"], ["proof (chain)\npicking this:\n  0 = f g", "show \\<open>f g = 0\\<close>"], ["proof (prove)\nusing this:\n  0 = f g\n\ngoal (1 subgoal):\n 1. f g = 0", "by simp"], ["proof (state)\nthis:\n  f g = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma clinear_eq_butterflyI:\n  fixes F G :: \\<open>('a::{chilbert_space,cfinite_dim} \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_inner) \\<Rightarrow> 'c::complex_vector\\<close>\n  assumes \"clinear F\" and \"clinear G\"\n  assumes \\<open>cspan basisA = UNIV\\<close> \\<open>cspan basisB = UNIV\\<close>\n  assumes \\<open>is_ortho_set basisA\\<close> \\<open>is_ortho_set basisB\\<close>\n  assumes \"\\<And>a b. a\\<in>basisA \\<Longrightarrow> b\\<in>basisB \\<Longrightarrow> F (butterfly a b) = G (butterfly a b)\"\n  assumes \\<open>\\<And>b. b\\<in>basisB \\<Longrightarrow> norm b = 1\\<close>\n  shows \"F = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = G", "apply (rule complex_vector.linear_eq_on_span[where f=F, THEN ext, rotated 3])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> cspan (?B1 x)\n 2. \\<And>x. clinear F\n 3. \\<And>x. clinear G\n 4. \\<And>x xa. xa \\<in> ?B1 x \\<Longrightarrow> F xa = G xa", "apply (subst cspan_butterfly_UNIV)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x. cspan (?basisA7 x x) = UNIV\n 2. \\<And>x. cspan (?basisB7 x x) = UNIV\n 3. \\<And>x. is_ortho_set (?basisB7 x x)\n 4. \\<And>x b. b \\<in> ?basisB7 x x \\<Longrightarrow> norm b = 1\n 5. \\<And>x. x \\<in> UNIV\n 6. \\<And>x. clinear F\n 7. \\<And>x. clinear G\n 8. \\<And>x xa.\n       xa \\<in> {butterfly a b |a b.\n                 a \\<in> ?basisA7 x x \\<and>\n                 b \\<in> ?basisB7 x x} \\<Longrightarrow>\n       F xa = G xa", "using assms"], ["proof (prove)\nusing this:\n  clinear F\n  clinear G\n  cspan basisA = UNIV\n  cspan basisB = UNIV\n  is_ortho_set basisA\n  is_ortho_set basisB\n  \\<lbrakk>?a \\<in> basisA; ?b \\<in> basisB\\<rbrakk>\n  \\<Longrightarrow> F (butterfly ?a ?b) = G (butterfly ?a ?b)\n  ?b \\<in> basisB \\<Longrightarrow> norm ?b = 1\n\ngoal (8 subgoals):\n 1. \\<And>x. cspan (?basisA7 x x) = UNIV\n 2. \\<And>x. cspan (?basisB7 x x) = UNIV\n 3. \\<And>x. is_ortho_set (?basisB7 x x)\n 4. \\<And>x b. b \\<in> ?basisB7 x x \\<Longrightarrow> norm b = 1\n 5. \\<And>x. x \\<in> UNIV\n 6. \\<And>x. clinear F\n 7. \\<And>x. clinear G\n 8. \\<And>x xa.\n       xa \\<in> {butterfly a b |a b.\n                 a \\<in> ?basisA7 x x \\<and>\n                 b \\<in> ?basisB7 x x} \\<Longrightarrow>\n       F xa = G xa", "by auto"], ["", "subsection \\<open>Bifunctionals\\<close>"], ["", "lift_definition bifunctional :: \\<open>'a::complex_normed_vector \\<Rightarrow>\\<^sub>C\\<^sub>L (('a \\<Rightarrow>\\<^sub>C\\<^sub>L complex) \\<Rightarrow>\\<^sub>C\\<^sub>L complex)\\<close>\n  is \\<open>\\<lambda>x f. f *\\<^sub>V x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pred_fun \\<top> bounded_clinear \\<sqinter> bounded_cbilinear)\n     (\\<lambda>x f. f *\\<^sub>V x)", "by (simp add: cblinfun.flip)"], ["", "lemma bifunctional_apply[simp]: \\<open>(bifunctional *\\<^sub>V x) *\\<^sub>V f = f *\\<^sub>V x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (bifunctional *\\<^sub>V x) *\\<^sub>V f = f *\\<^sub>V x", "by (transfer fixing: x f, simp)"], ["", "lemma bifunctional_isometric[simp]: \\<open>norm (bifunctional *\\<^sub>V x) = norm x\\<close> for x :: \\<open>'a::complex_inner\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (bifunctional *\\<^sub>V x) = norm x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm (bifunctional *\\<^sub>V x) = norm x", "define f :: \\<open>'a \\<Rightarrow>\\<^sub>C\\<^sub>L complex\\<close> where \\<open>f = CBlinfun (\\<lambda>y. cinner x y)\\<close>"], ["proof (state)\nthis:\n  f = CBlinfun ((\\<bullet>\\<^sub>C) x)\n\ngoal (1 subgoal):\n 1. norm (bifunctional *\\<^sub>V x) = norm x", "then"], ["proof (chain)\npicking this:\n  f = CBlinfun ((\\<bullet>\\<^sub>C) x)", "have [simp]: \\<open>f *\\<^sub>V y = cinner x y\\<close> for y"], ["proof (prove)\nusing this:\n  f = CBlinfun ((\\<bullet>\\<^sub>C) x)\n\ngoal (1 subgoal):\n 1. f *\\<^sub>V y = x \\<bullet>\\<^sub>C y", "by (simp add: bounded_clinear_CBlinfun_apply bounded_clinear_cinner_right)"], ["proof (state)\nthis:\n  f *\\<^sub>V ?y = x \\<bullet>\\<^sub>C ?y\n\ngoal (1 subgoal):\n 1. norm (bifunctional *\\<^sub>V x) = norm x", "then"], ["proof (chain)\npicking this:\n  f *\\<^sub>V ?y = x \\<bullet>\\<^sub>C ?y", "have [simp]: \\<open>norm f = norm x\\<close>"], ["proof (prove)\nusing this:\n  f *\\<^sub>V ?y = x \\<bullet>\\<^sub>C ?y\n\ngoal (1 subgoal):\n 1. norm f = norm x", "apply (auto intro!: norm_cblinfun_eqI[where x=x] simp: power2_norm_eq_cinner[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. norm x \\<le> cmod ((complex_of_real (norm x))\\<^sup>2) / norm x\n 2. \\<And>xa. cmod (x \\<bullet>\\<^sub>C xa) \\<le> norm x * norm xa", "apply (smt (verit, best) norm_eq_sqrt_cinner norm_ge_zero power2_norm_eq_cinner real_div_sqrt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. cmod (x \\<bullet>\\<^sub>C xa) \\<le> norm x * norm xa", "using Cauchy_Schwarz_ineq2"], ["proof (prove)\nusing this:\n  cmod (?x \\<bullet>\\<^sub>C ?y) \\<le> norm ?x * norm ?y\n\ngoal (1 subgoal):\n 1. \\<And>xa. cmod (x \\<bullet>\\<^sub>C xa) \\<le> norm x * norm xa", "by blast"], ["proof (state)\nthis:\n  norm f = norm x\n\ngoal (1 subgoal):\n 1. norm (bifunctional *\\<^sub>V x) = norm x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (bifunctional *\\<^sub>V x) = norm x", "apply (auto intro!: norm_cblinfun_eqI[where x=f])"], ["proof (prove)\ngoal (2 subgoals):\n 1. norm x \\<le> cmod (x \\<bullet>\\<^sub>C x) / norm x\n 2. \\<And>xa. cmod (xa *\\<^sub>V x) \\<le> norm x * norm xa", "apply (metis norm_eq_sqrt_cinner norm_imp_pos_and_ge real_div_sqrt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. cmod (xa *\\<^sub>V x) \\<le> norm x * norm xa", "by (metis norm_cblinfun ordered_field_class.sign_simps(33))"], ["proof (state)\nthis:\n  norm (bifunctional *\\<^sub>V x) = norm x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm_bifunctional[simp]: \\<open>norm (bifunctional :: 'a::{complex_inner, not_singleton} \\<Rightarrow>\\<^sub>C\\<^sub>L _) = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm bifunctional = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm bifunctional = 1", "obtain x :: 'a where [simp]: \\<open>norm x = 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. norm x = 1 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (meson UNIV_not_singleton ex_norm1)"], ["proof (state)\nthis:\n  norm x = 1\n\ngoal (1 subgoal):\n 1. norm bifunctional = 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm bifunctional = 1", "by (auto intro!: norm_cblinfun_eqI[where x=x])"], ["proof (state)\nthis:\n  norm bifunctional = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Banach-Steinhaus\\<close>"], ["", "theorem cbanach_steinhaus:\n  fixes F :: \\<open>'c \\<Rightarrow> 'a::cbanach \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::complex_normed_vector\\<close>\n  assumes \\<open>\\<And>x. \\<exists>M. \\<forall>n.  norm ((F n) *\\<^sub>V x) \\<le> M\\<close>\n  shows  \\<open>\\<exists>M. \\<forall> n. norm (F n) \\<le> M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n. norm (F n) \\<le> M", "using cblinfun_blinfun_transfer[transfer_rule]"], ["proof (prove)\nusing this:\n  blinfun_cblinfun_eq 0 0\n  rel_fun blinfun_cblinfun_eq\n   (rel_fun blinfun_cblinfun_eq blinfun_cblinfun_eq) (+) (+)\n  rel_fun blinfun_cblinfun_eq\n   (rel_fun blinfun_cblinfun_eq blinfun_cblinfun_eq) (-) (-)\n  rel_fun blinfun_cblinfun_eq blinfun_cblinfun_eq uminus uminus\n  rel_fun real_complex_eq (rel_fun blinfun_cblinfun_eq blinfun_cblinfun_eq)\n   (*\\<^sub>R) (*\\<^sub>C)\n  rel_fun (eq_onp bounded_clinear) blinfun_cblinfun_eq Blinfun CBlinfun\n  rel_fun blinfun_cblinfun_eq (=) norm norm\n  rel_fun blinfun_cblinfun_eq (rel_fun blinfun_cblinfun_eq (=)) dist dist\n  rel_fun blinfun_cblinfun_eq blinfun_cblinfun_eq sgn sgn\n  rel_fun (rel_fun (=) blinfun_cblinfun_eq) (=) Cauchy Cauchy\n  rel_fun (rel_fun (=) blinfun_cblinfun_eq)\n   (rel_fun blinfun_cblinfun_eq (rel_fun (=) (=))) (\\<longlongrightarrow>)\n   (\\<longlongrightarrow>)\n  rel_fun blinfun_cblinfun_eq\n   (rel_fun blinfun_cblinfun_eq blinfun_cblinfun_eq) (o\\<^sub>L)\n   (o\\<^sub>C\\<^sub>L)\n  rel_fun blinfun_cblinfun_eq (rel_fun (=) (=)) (*\\<^sub>v) (*\\<^sub>V)\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n. norm (F n) \\<le> M", "apply (rule TrueI)?"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n. norm (F n) \\<le> M", "(* Deletes current facts *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n. norm (F n) \\<le> M", "proof (use assms in transfer)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>pred_fun \\<top> (Domainp blinfun_cblinfun_eq) F;\n        \\<And>x.\n           \\<exists>M. \\<forall>n. norm (F n *\\<^sub>v x) \\<le> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M. \\<forall>n. norm (F n) \\<le> M", "fix F :: \\<open>'c \\<Rightarrow> 'a \\<Rightarrow>\\<^sub>L 'b\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>pred_fun \\<top> (Domainp blinfun_cblinfun_eq) F;\n        \\<And>x.\n           \\<exists>M. \\<forall>n. norm (F n *\\<^sub>v x) \\<le> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M. \\<forall>n. norm (F n) \\<le> M", "assume \\<open>(\\<And>x. \\<exists>M. \\<forall>n. norm (F n *\\<^sub>v x) \\<le> M)\\<close>"], ["proof (state)\nthis:\n  \\<exists>M. \\<forall>n. norm (F n *\\<^sub>v ?x) \\<le> M\n\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>pred_fun \\<top> (Domainp blinfun_cblinfun_eq) F;\n        \\<And>x.\n           \\<exists>M. \\<forall>n. norm (F n *\\<^sub>v x) \\<le> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M. \\<forall>n. norm (F n) \\<le> M", "hence \\<open>\\<And>x. bounded (range (\\<lambda>n. blinfun_apply (F n) x))\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>M. \\<forall>n. norm (F n *\\<^sub>v ?x) \\<le> M\n\ngoal (1 subgoal):\n 1. \\<And>x. bounded (range (\\<lambda>n. F n *\\<^sub>v x))", "by (metis (no_types, lifting) boundedI rangeE)"], ["proof (state)\nthis:\n  bounded (range (\\<lambda>n. F n *\\<^sub>v ?x))\n\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>pred_fun \\<top> (Domainp blinfun_cblinfun_eq) F;\n        \\<And>x.\n           \\<exists>M. \\<forall>n. norm (F n *\\<^sub>v x) \\<le> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M. \\<forall>n. norm (F n) \\<le> M", "hence \\<open>bounded (range F)\\<close>"], ["proof (prove)\nusing this:\n  bounded (range (\\<lambda>n. F n *\\<^sub>v ?x))\n\ngoal (1 subgoal):\n 1. bounded (range F)", "by (simp add: banach_steinhaus)"], ["proof (state)\nthis:\n  bounded (range F)\n\ngoal (1 subgoal):\n 1. \\<And>F.\n       \\<lbrakk>pred_fun \\<top> (Domainp blinfun_cblinfun_eq) F;\n        \\<And>x.\n           \\<exists>M. \\<forall>n. norm (F n *\\<^sub>v x) \\<le> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M. \\<forall>n. norm (F n) \\<le> M", "thus  \\<open>\\<exists>M. \\<forall>n. norm (F n) \\<le> M\\<close>"], ["proof (prove)\nusing this:\n  bounded (range F)\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>n. norm (F n) \\<le> M", "by (simp add: bounded_iff)"], ["proof (state)\nthis:\n  \\<exists>M. \\<forall>n. norm (F n) \\<le> M\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Riesz-representation theorem\\<close>"], ["", "theorem riesz_frechet_representation_cblinfun_existence:\n  \\<comment> \\<open>Theorem 3.4 in @{cite conway2013course}\\<close>\n  fixes f::\\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L complex\\<close>\n  shows \\<open>\\<exists>t. \\<forall>x.  f *\\<^sub>V x = \\<langle>t, x\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. \\<forall>x. f *\\<^sub>V x = t \\<bullet>\\<^sub>C x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       bounded_clinear f \\<Longrightarrow>\n       \\<exists>t. \\<forall>x. f x = t \\<bullet>\\<^sub>C x", "by (rule riesz_frechet_representation_existence)"], ["", "lemma riesz_frechet_representation_cblinfun_unique:\n  \\<comment> \\<open>Theorem 3.4 in @{cite conway2013course}\\<close>\n  fixes f::\\<open>'a::complex_inner \\<Rightarrow>\\<^sub>C\\<^sub>L complex\\<close>\n  assumes \\<open>\\<And>x. f *\\<^sub>V x = \\<langle>t, x\\<rangle>\\<close>\n  assumes \\<open>\\<And>x. f *\\<^sub>V x = \\<langle>u, x\\<rangle>\\<close>\n  shows \\<open>t = u\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. t = u", "using assms"], ["proof (prove)\nusing this:\n  f *\\<^sub>V ?x = t \\<bullet>\\<^sub>C ?x\n  f *\\<^sub>V ?x = u \\<bullet>\\<^sub>C ?x\n\ngoal (1 subgoal):\n 1. t = u", "by (rule riesz_frechet_representation_unique)"], ["", "theorem riesz_frechet_representation_cblinfun_norm:\n  includes notation_norm\n  fixes f::\\<open>'a::chilbert_space \\<Rightarrow>\\<^sub>C\\<^sub>L complex\\<close>\n  assumes \\<open>\\<And>x.  f *\\<^sub>V x = \\<langle>t, x\\<rangle>\\<close>\n  shows \\<open>\\<parallel>f\\<parallel> = \\<parallel>t\\<parallel>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>f\\<parallel> = \\<parallel>t\\<parallel>", "using assms"], ["proof (prove)\nusing this:\n  f *\\<^sub>V ?x = t \\<bullet>\\<^sub>C ?x\n\ngoal (1 subgoal):\n 1. \\<parallel>f\\<parallel> = \\<parallel>t\\<parallel>", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f t.\n       \\<lbrakk>bounded_clinear f;\n        \\<And>x. f x = t \\<bullet>\\<^sub>C x\\<rbrakk>\n       \\<Longrightarrow> onorm f = \\<parallel>t\\<parallel>", "fix f::\\<open>'a \\<Rightarrow> complex\\<close> and t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f t.\n       \\<lbrakk>bounded_clinear f;\n        \\<And>x. f x = t \\<bullet>\\<^sub>C x\\<rbrakk>\n       \\<Longrightarrow> onorm f = \\<parallel>t\\<parallel>", "assume \\<open>bounded_clinear f\\<close> and \\<open>\\<And>x. f x = \\<langle>t, x\\<rangle>\\<close>"], ["proof (state)\nthis:\n  bounded_clinear f\n  f ?x = t \\<bullet>\\<^sub>C ?x\n\ngoal (1 subgoal):\n 1. \\<And>f t.\n       \\<lbrakk>bounded_clinear f;\n        \\<And>x. f x = t \\<bullet>\\<^sub>C x\\<rbrakk>\n       \\<Longrightarrow> onorm f = \\<parallel>t\\<parallel>", "from  \\<open>\\<And>x. f x = \\<langle>t, x\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  f ?x = t \\<bullet>\\<^sub>C ?x", "have \\<open>(norm (f x)) / (norm x) \\<le> norm t\\<close>\n    for x"], ["proof (prove)\nusing this:\n  f ?x = t \\<bullet>\\<^sub>C ?x\n\ngoal (1 subgoal):\n 1. cmod (f x) / \\<parallel>x\\<parallel> \\<le> \\<parallel>t\\<parallel>", "proof(cases \\<open>norm x = 0\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. f x = t \\<bullet>\\<^sub>C x;\n     \\<parallel>x\\<parallel> = 0\\<rbrakk>\n    \\<Longrightarrow> cmod (f x) / \\<parallel>x\\<parallel>\n                      \\<le> \\<parallel>t\\<parallel>\n 2. \\<lbrakk>\\<And>x. f x = t \\<bullet>\\<^sub>C x;\n     \\<parallel>x\\<parallel> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cmod (f x) / \\<parallel>x\\<parallel>\n                      \\<le> \\<parallel>t\\<parallel>", "case True"], ["proof (state)\nthis:\n  \\<parallel>x\\<parallel> = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. f x = t \\<bullet>\\<^sub>C x;\n     \\<parallel>x\\<parallel> = 0\\<rbrakk>\n    \\<Longrightarrow> cmod (f x) / \\<parallel>x\\<parallel>\n                      \\<le> \\<parallel>t\\<parallel>\n 2. \\<lbrakk>\\<And>x. f x = t \\<bullet>\\<^sub>C x;\n     \\<parallel>x\\<parallel> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cmod (f x) / \\<parallel>x\\<parallel>\n                      \\<le> \\<parallel>t\\<parallel>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>x\\<parallel> = 0\n\ngoal (1 subgoal):\n 1. cmod (f x) / \\<parallel>x\\<parallel> \\<le> \\<parallel>t\\<parallel>", "by simp"], ["proof (state)\nthis:\n  cmod (f x) / \\<parallel>x\\<parallel> \\<le> \\<parallel>t\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. f x = t \\<bullet>\\<^sub>C x;\n     \\<parallel>x\\<parallel> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cmod (f x) / \\<parallel>x\\<parallel>\n                      \\<le> \\<parallel>t\\<parallel>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. f x = t \\<bullet>\\<^sub>C x;\n     \\<parallel>x\\<parallel> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cmod (f x) / \\<parallel>x\\<parallel>\n                      \\<le> \\<parallel>t\\<parallel>", "case False"], ["proof (state)\nthis:\n  \\<parallel>x\\<parallel> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. f x = t \\<bullet>\\<^sub>C x;\n     \\<parallel>x\\<parallel> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cmod (f x) / \\<parallel>x\\<parallel>\n                      \\<le> \\<parallel>t\\<parallel>", "have \\<open>norm (f x) = norm (\\<langle>t, x\\<rangle>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (f x) = cmod (t \\<bullet>\\<^sub>C x)", "using \\<open>\\<And>x. f x = \\<langle>t, x\\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  f ?x = t \\<bullet>\\<^sub>C ?x\n\ngoal (1 subgoal):\n 1. cmod (f x) = cmod (t \\<bullet>\\<^sub>C x)", "by simp"], ["proof (state)\nthis:\n  cmod (f x) = cmod (t \\<bullet>\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. f x = t \\<bullet>\\<^sub>C x;\n     \\<parallel>x\\<parallel> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cmod (f x) / \\<parallel>x\\<parallel>\n                      \\<le> \\<parallel>t\\<parallel>", "also"], ["proof (state)\nthis:\n  cmod (f x) = cmod (t \\<bullet>\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. f x = t \\<bullet>\\<^sub>C x;\n     \\<parallel>x\\<parallel> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cmod (f x) / \\<parallel>x\\<parallel>\n                      \\<le> \\<parallel>t\\<parallel>", "have \\<open>norm \\<langle>t, x\\<rangle> \\<le> norm t * norm x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (t \\<bullet>\\<^sub>C x)\n    \\<le> \\<parallel>t\\<parallel> * \\<parallel>x\\<parallel>", "by (simp add: complex_inner_class.Cauchy_Schwarz_ineq2)"], ["proof (state)\nthis:\n  cmod (t \\<bullet>\\<^sub>C x)\n  \\<le> \\<parallel>t\\<parallel> * \\<parallel>x\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. f x = t \\<bullet>\\<^sub>C x;\n     \\<parallel>x\\<parallel> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cmod (f x) / \\<parallel>x\\<parallel>\n                      \\<le> \\<parallel>t\\<parallel>", "finally"], ["proof (chain)\npicking this:\n  cmod (f x) \\<le> \\<parallel>t\\<parallel> * \\<parallel>x\\<parallel>", "have \\<open>norm (f x) \\<le> norm t * norm x\\<close>"], ["proof (prove)\nusing this:\n  cmod (f x) \\<le> \\<parallel>t\\<parallel> * \\<parallel>x\\<parallel>\n\ngoal (1 subgoal):\n 1. cmod (f x) \\<le> \\<parallel>t\\<parallel> * \\<parallel>x\\<parallel>", "by blast"], ["proof (state)\nthis:\n  cmod (f x) \\<le> \\<parallel>t\\<parallel> * \\<parallel>x\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. f x = t \\<bullet>\\<^sub>C x;\n     \\<parallel>x\\<parallel> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> cmod (f x) / \\<parallel>x\\<parallel>\n                      \\<le> \\<parallel>t\\<parallel>", "thus ?thesis"], ["proof (prove)\nusing this:\n  cmod (f x) \\<le> \\<parallel>t\\<parallel> * \\<parallel>x\\<parallel>\n\ngoal (1 subgoal):\n 1. cmod (f x) / \\<parallel>x\\<parallel> \\<le> \\<parallel>t\\<parallel>", "by (metis False linordered_field_class.divide_right_mono nonzero_mult_div_cancel_right norm_ge_zero)"], ["proof (state)\nthis:\n  cmod (f x) / \\<parallel>x\\<parallel> \\<le> \\<parallel>t\\<parallel>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cmod (f ?x) / \\<parallel>?x\\<parallel> \\<le> \\<parallel>t\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<And>f t.\n       \\<lbrakk>bounded_clinear f;\n        \\<And>x. f x = t \\<bullet>\\<^sub>C x\\<rbrakk>\n       \\<Longrightarrow> onorm f = \\<parallel>t\\<parallel>", "moreover"], ["proof (state)\nthis:\n  cmod (f ?x) / \\<parallel>?x\\<parallel> \\<le> \\<parallel>t\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<And>f t.\n       \\<lbrakk>bounded_clinear f;\n        \\<And>x. f x = t \\<bullet>\\<^sub>C x\\<rbrakk>\n       \\<Longrightarrow> onorm f = \\<parallel>t\\<parallel>", "have \\<open>(norm (f t)) / (norm t) = norm t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "proof(cases \\<open>norm t = 0\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<parallel>t\\<parallel> = 0 \\<Longrightarrow>\n    cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>\n 2. \\<parallel>t\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "case True"], ["proof (state)\nthis:\n  \\<parallel>t\\<parallel> = 0\n\ngoal (2 subgoals):\n 1. \\<parallel>t\\<parallel> = 0 \\<Longrightarrow>\n    cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>\n 2. \\<parallel>t\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>t\\<parallel> = 0\n\ngoal (1 subgoal):\n 1. cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "by simp"], ["proof (state)\nthis:\n  cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<parallel>t\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>t\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "case False"], ["proof (state)\nthis:\n  \\<parallel>t\\<parallel> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<parallel>t\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "have \\<open>f t = \\<langle>t, t\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f t = t \\<bullet>\\<^sub>C t", "using \\<open>\\<And>x. f x = \\<langle>t, x\\<rangle>\\<close>"], ["proof (prove)\nusing this:\n  f ?x = t \\<bullet>\\<^sub>C ?x\n\ngoal (1 subgoal):\n 1. f t = t \\<bullet>\\<^sub>C t", "by blast"], ["proof (state)\nthis:\n  f t = t \\<bullet>\\<^sub>C t\n\ngoal (1 subgoal):\n 1. \\<parallel>t\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "also"], ["proof (state)\nthis:\n  f t = t \\<bullet>\\<^sub>C t\n\ngoal (1 subgoal):\n 1. \\<parallel>t\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "have \\<open>\\<dots> = (norm t)^2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<bullet>\\<^sub>C t =\n    complex_of_real (\\<parallel>t\\<parallel>\\<^sup>2)", "by (meson cnorm_eq_square)"], ["proof (state)\nthis:\n  t \\<bullet>\\<^sub>C t = complex_of_real (\\<parallel>t\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<parallel>t\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "also"], ["proof (state)\nthis:\n  t \\<bullet>\\<^sub>C t = complex_of_real (\\<parallel>t\\<parallel>\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<parallel>t\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "have \\<open>\\<dots> = (norm t)*(norm t)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (\\<parallel>t\\<parallel>\\<^sup>2) =\n    complex_of_real (\\<parallel>t\\<parallel> * \\<parallel>t\\<parallel>)", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  complex_of_real (\\<parallel>t\\<parallel>\\<^sup>2) =\n  complex_of_real (\\<parallel>t\\<parallel> * \\<parallel>t\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>t\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "finally"], ["proof (chain)\npicking this:\n  f t = complex_of_real (\\<parallel>t\\<parallel> * \\<parallel>t\\<parallel>)", "have \\<open>f t = (norm t)*(norm t)\\<close>"], ["proof (prove)\nusing this:\n  f t = complex_of_real (\\<parallel>t\\<parallel> * \\<parallel>t\\<parallel>)\n\ngoal (1 subgoal):\n 1. f t =\n    complex_of_real (\\<parallel>t\\<parallel> * \\<parallel>t\\<parallel>)", "by blast"], ["proof (state)\nthis:\n  f t = complex_of_real (\\<parallel>t\\<parallel> * \\<parallel>t\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>t\\<parallel> \\<noteq> 0 \\<Longrightarrow>\n    cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "thus ?thesis"], ["proof (prove)\nusing this:\n  f t = complex_of_real (\\<parallel>t\\<parallel> * \\<parallel>t\\<parallel>)\n\ngoal (1 subgoal):\n 1. cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "by (metis False Re_complex_of_real \\<open>\\<And>x. f x = cinner t x\\<close> cinner_ge_zero complex_of_real_cmod nonzero_divide_eq_eq)"], ["proof (state)\nthis:\n  cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<And>f t.\n       \\<lbrakk>bounded_clinear f;\n        \\<And>x. f x = t \\<bullet>\\<^sub>C x\\<rbrakk>\n       \\<Longrightarrow> onorm f = \\<parallel>t\\<parallel>", "ultimately"], ["proof (chain)\npicking this:\n  cmod (f ?x) / \\<parallel>?x\\<parallel> \\<le> \\<parallel>t\\<parallel>\n  cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>", "have \\<open>Sup {(norm (f x)) / (norm x)| x. True} = norm t\\<close>"], ["proof (prove)\nusing this:\n  cmod (f ?x) / \\<parallel>?x\\<parallel> \\<le> \\<parallel>t\\<parallel>\n  cmod (f t) / \\<parallel>t\\<parallel> = \\<parallel>t\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<Squnion> {cmod (f x) / \\<parallel>x\\<parallel> |x. True} =\n    \\<parallel>t\\<parallel>", "by (smt cSup_eq_maximum mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<Squnion> {cmod (f x) / \\<parallel>x\\<parallel> |x. True} =\n  \\<parallel>t\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<And>f t.\n       \\<lbrakk>bounded_clinear f;\n        \\<And>x. f x = t \\<bullet>\\<^sub>C x\\<rbrakk>\n       \\<Longrightarrow> onorm f = \\<parallel>t\\<parallel>", "moreover"], ["proof (state)\nthis:\n  \\<Squnion> {cmod (f x) / \\<parallel>x\\<parallel> |x. True} =\n  \\<parallel>t\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<And>f t.\n       \\<lbrakk>bounded_clinear f;\n        \\<And>x. f x = t \\<bullet>\\<^sub>C x\\<rbrakk>\n       \\<Longrightarrow> onorm f = \\<parallel>t\\<parallel>", "have \\<open>Sup {(norm (f x)) / (norm x)| x. True} = (SUP x. (norm (f x)) / (norm x))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {cmod (f x) / \\<parallel>x\\<parallel> |x. True} =\n    (SUP x. cmod (f x) / \\<parallel>x\\<parallel>)", "by (simp add: full_SetCompr_eq)"], ["proof (state)\nthis:\n  \\<Squnion> {cmod (f x) / \\<parallel>x\\<parallel> |x. True} =\n  (SUP x. cmod (f x) / \\<parallel>x\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<And>f t.\n       \\<lbrakk>bounded_clinear f;\n        \\<And>x. f x = t \\<bullet>\\<^sub>C x\\<rbrakk>\n       \\<Longrightarrow> onorm f = \\<parallel>t\\<parallel>", "ultimately"], ["proof (chain)\npicking this:\n  \\<Squnion> {cmod (f x) / \\<parallel>x\\<parallel> |x. True} =\n  \\<parallel>t\\<parallel>\n  \\<Squnion> {cmod (f x) / \\<parallel>x\\<parallel> |x. True} =\n  (SUP x. cmod (f x) / \\<parallel>x\\<parallel>)", "show \\<open>onorm f = norm t\\<close>"], ["proof (prove)\nusing this:\n  \\<Squnion> {cmod (f x) / \\<parallel>x\\<parallel> |x. True} =\n  \\<parallel>t\\<parallel>\n  \\<Squnion> {cmod (f x) / \\<parallel>x\\<parallel> |x. True} =\n  (SUP x. cmod (f x) / \\<parallel>x\\<parallel>)\n\ngoal (1 subgoal):\n 1. onorm f = \\<parallel>t\\<parallel>", "by (simp add: onorm_def)"], ["proof (state)\nthis:\n  onorm f = \\<parallel>t\\<parallel>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Extension of complex bounded operators\\<close>"], ["", "definition cblinfun_extension where \n  \"cblinfun_extension S \\<phi> = (SOME B. \\<forall>x\\<in>S. B *\\<^sub>V x = \\<phi> x)\""], ["", "definition cblinfun_extension_exists where \n  \"cblinfun_extension_exists S \\<phi> = (\\<exists>B. \\<forall>x\\<in>S. B *\\<^sub>V x = \\<phi> x)\""], ["", "lemma cblinfun_extension_existsI:\n  assumes \"\\<And>x. x\\<in>S \\<Longrightarrow> B *\\<^sub>V x = \\<phi> x\"\n  shows \"cblinfun_extension_exists S \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S \\<phi>", "using assms cblinfun_extension_exists_def"], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> B *\\<^sub>V ?x = \\<phi> ?x\n  cblinfun_extension_exists ?S ?\\<phi> =\n  (\\<exists>B. \\<forall>x\\<in>?S. B *\\<^sub>V x = ?\\<phi> x)\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S \\<phi>", "by blast"], ["", "lemma cblinfun_extension_exists_finite_dim:\n  fixes \\<phi>::\"'a::{complex_normed_vector,cfinite_dim} \\<Rightarrow> 'b::complex_normed_vector\" \n  assumes \"cindependent S\"\n    and \"cspan S = UNIV\"\n  shows \"cblinfun_extension_exists S \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S \\<phi>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S \\<phi>", "define f::\"'a \\<Rightarrow> 'b\"\n    where \"f = complex_vector.construct S \\<phi>\""], ["proof (state)\nthis:\n  f = cconstruct S \\<phi>\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S \\<phi>", "have \"clinear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear f", "by (simp add: complex_vector.linear_construct assms linear_construct f_def)"], ["proof (state)\nthis:\n  clinear f\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S \\<phi>", "have \"bounded_clinear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear f", "using \\<open>clinear f\\<close> assms"], ["proof (prove)\nusing this:\n  clinear f\n  cindependent S\n  cspan S = UNIV\n\ngoal (1 subgoal):\n 1. bounded_clinear f", "by auto"], ["proof (state)\nthis:\n  bounded_clinear f\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S \\<phi>", "then"], ["proof (chain)\npicking this:\n  bounded_clinear f", "obtain B::\"'a \\<Rightarrow>\\<^sub>C\\<^sub>L 'b\" \n    where \"B *\\<^sub>V x = f x\" for x"], ["proof (prove)\nusing this:\n  bounded_clinear f\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        (\\<And>x. B *\\<^sub>V x = f x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cblinfun_apply_cases"], ["proof (prove)\nusing this:\n  bounded_clinear f\n  \\<lbrakk>?y \\<in> {f. bounded_clinear f};\n   \\<And>x. ?y = (*\\<^sub>V) x \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        (\\<And>x. B *\\<^sub>V x = f x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  B *\\<^sub>V ?x = f ?x\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S \\<phi>", "have \"B *\\<^sub>V x = \\<phi> x\"\n    if c1: \"x\\<in>S\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. B *\\<^sub>V x = \\<phi> x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. B *\\<^sub>V x = \\<phi> x", "have \"B *\\<^sub>V x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B *\\<^sub>V x = f x", "by (simp add: \\<open>\\<And>x. B *\\<^sub>V x = f x\\<close>)"], ["proof (state)\nthis:\n  B *\\<^sub>V x = f x\n\ngoal (1 subgoal):\n 1. B *\\<^sub>V x = \\<phi> x", "also"], ["proof (state)\nthis:\n  B *\\<^sub>V x = f x\n\ngoal (1 subgoal):\n 1. B *\\<^sub>V x = \\<phi> x", "have \"\\<dots> = \\<phi> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = \\<phi> x", "using assms complex_vector.construct_basis f_def that"], ["proof (prove)\nusing this:\n  cindependent S\n  cspan S = UNIV\n  \\<lbrakk>cindependent ?B; ?b \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> cconstruct ?B ?f ?b = ?f ?b\n  f = cconstruct S \\<phi>\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. f x = \\<phi> x", "by (simp add: complex_vector.construct_basis)"], ["proof (state)\nthis:\n  f x = \\<phi> x\n\ngoal (1 subgoal):\n 1. B *\\<^sub>V x = \\<phi> x", "finally"], ["proof (chain)\npicking this:\n  B *\\<^sub>V x = \\<phi> x", "show?thesis"], ["proof (prove)\nusing this:\n  B *\\<^sub>V x = \\<phi> x\n\ngoal (1 subgoal):\n 1. B *\\<^sub>V x = \\<phi> x", "by blast"], ["proof (state)\nthis:\n  B *\\<^sub>V x = \\<phi> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> S \\<Longrightarrow> B *\\<^sub>V ?x = \\<phi> ?x\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S \\<phi>", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> B *\\<^sub>V ?x = \\<phi> ?x\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S \\<phi>", "unfolding cblinfun_extension_exists_def"], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> B *\\<^sub>V ?x = \\<phi> ?x\n\ngoal (1 subgoal):\n 1. \\<exists>B. \\<forall>x\\<in>S. B *\\<^sub>V x = \\<phi> x", "by blast"], ["proof (state)\nthis:\n  cblinfun_extension_exists S \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_extension_exists_bounded_dense:\n  fixes f :: \\<open>'a::complex_normed_vector \\<Rightarrow> 'b::cbanach\\<close>\n  assumes \\<open>csubspace S\\<close>\n  assumes \\<open>closure S = UNIV\\<close>\n  assumes f_add: \\<open>\\<And>x y. x \\<in> S \\<Longrightarrow> y \\<in> S \\<Longrightarrow> f (x + y) = f x + f y\\<close>\n  assumes f_scale: \\<open>\\<And>c x y. x \\<in> S \\<Longrightarrow> f (c *\\<^sub>C x) = c *\\<^sub>C f x\\<close>\n  assumes bounded: \\<open>\\<And>x. x \\<in> S \\<Longrightarrow> norm (f x) \\<le> B * norm x\\<close>\n  shows \\<open>cblinfun_extension_exists S f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "obtain B where bounded: \\<open>\\<And>x. x \\<in> S \\<Longrightarrow> norm (f x) \\<le> B * norm x\\<close> and \\<open>B > 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>\\<And>x.\n                    x \\<in> S \\<Longrightarrow> norm (f x) \\<le> B * norm x;\n         0 < B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using bounded"], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> norm (f ?x) \\<le> B * norm ?x\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>\\<And>x.\n                    x \\<in> S \\<Longrightarrow> norm (f x) \\<le> B * norm x;\n         0 < B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (smt (z3) mult_mono norm_ge_zero)"], ["proof (state)\nthis:\n  ?x \\<in> S \\<Longrightarrow> norm (f ?x) \\<le> B * norm ?x\n  0 < B\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "have \\<open>\\<exists>xi. (xi \\<longlonglongrightarrow> x) \\<and> (\\<forall>i. xi i \\<in> S)\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xi.\n       xi \\<longlonglongrightarrow> x \\<and> (\\<forall>i. xi i \\<in> S)", "using assms(2) closure_sequential"], ["proof (prove)\nusing this:\n  closure S = UNIV\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n\ngoal (1 subgoal):\n 1. \\<exists>xi.\n       xi \\<longlonglongrightarrow> x \\<and> (\\<forall>i. xi i \\<in> S)", "by blast"], ["proof (state)\nthis:\n  \\<exists>xi.\n     xi \\<longlonglongrightarrow> ?x \\<and> (\\<forall>i. xi i \\<in> S)\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "then"], ["proof (chain)\npicking this:\n  \\<exists>xi.\n     xi \\<longlonglongrightarrow> ?x \\<and> (\\<forall>i. xi i \\<in> S)", "obtain seq :: \\<open>'a \\<Rightarrow> nat \\<Rightarrow> 'a\\<close> where seq_lim: \\<open>seq x \\<longlonglongrightarrow> x\\<close> and seq_S: \\<open>seq x i \\<in> S\\<close> for x i"], ["proof (prove)\nusing this:\n  \\<exists>xi.\n     xi \\<longlonglongrightarrow> ?x \\<and> (\\<forall>i. xi i \\<in> S)\n\ngoal (1 subgoal):\n 1. (\\<And>seq.\n        \\<lbrakk>\\<And>x. seq x \\<longlonglongrightarrow> x;\n         \\<And>x i. seq x i \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (atomize_elim, subst all_conj_distrib[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<exists>xi.\n                   xi \\<longlonglongrightarrow> x \\<and>\n                   (\\<forall>i. xi i \\<in> S);\n     \\<And>x.\n        \\<exists>xi.\n           xi \\<longlonglongrightarrow> x \\<and>\n           (\\<forall>i. xi i \\<in> S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>seq.\n                         \\<forall>x.\n                            seq x \\<longlonglongrightarrow> x \\<and>\n                            (\\<forall>i. seq x i \\<in> S)", "apply (rule choice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<exists>xi.\n                   xi \\<longlonglongrightarrow> x \\<and>\n                   (\\<forall>i. xi i \\<in> S);\n     \\<And>x.\n        \\<exists>xi.\n           xi \\<longlonglongrightarrow> x \\<and>\n           (\\<forall>i. xi i \\<in> S)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         \\<exists>y.\n                            y \\<longlonglongrightarrow> x \\<and>\n                            (\\<forall>i. y i \\<in> S)", "by auto"], ["proof (state)\nthis:\n  seq ?x \\<longlonglongrightarrow> ?x\n  seq ?x ?i \\<in> S\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "define g where \\<open>g x = lim (\\<lambda>i. f (seq x i))\\<close> for x"], ["proof (state)\nthis:\n  g ?x = lim (\\<lambda>i. f (seq ?x i))\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "have \\<open>Cauchy (\\<lambda>i. f (seq x i))\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>i. f (seq x i))", "proof (rule CauchyI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M. norm (f (seq x m) - f (seq x n)) < e", "fix e :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M. norm (f (seq x m) - f (seq x n)) < e", "assume \\<open>e > 0\\<close>"], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M. norm (f (seq x m) - f (seq x n)) < e", "have \\<open>Cauchy (seq x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy (seq x)", "using LIMSEQ_imp_Cauchy seq_lim"], ["proof (prove)\nusing this:\n  ?X \\<longlonglongrightarrow> ?x \\<Longrightarrow> Cauchy ?X\n  seq ?x \\<longlonglongrightarrow> ?x\n\ngoal (1 subgoal):\n 1. Cauchy (seq x)", "by blast"], ["proof (state)\nthis:\n  Cauchy (seq x)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M. norm (f (seq x m) - f (seq x n)) < e", "then"], ["proof (chain)\npicking this:\n  Cauchy (seq x)", "obtain M where less_eB: \\<open>norm (seq x m - seq x n) < e/B\\<close> if \\<open>n \\<ge> M\\<close> and \\<open>m \\<ge> M\\<close> for n m"], ["proof (prove)\nusing this:\n  Cauchy (seq x)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        (\\<And>n m.\n            \\<lbrakk>M \\<le> n; M \\<le> m\\<rbrakk>\n            \\<Longrightarrow> norm (seq x m - seq x n)\n                              < e / B) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy (seq x) \\<Longrightarrow>\n    \\<exists>M.\n       \\<forall>n m.\n          M \\<le> n \\<longrightarrow>\n          M \\<le> m \\<longrightarrow> norm (seq x m - seq x n) < e / B", "by (meson CauchyD \\<open>0 < B\\<close> \\<open>0 < e\\<close> linordered_field_class.divide_pos_pos)"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<le> ?n; M \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> norm (seq x ?m - seq x ?n) < e / B\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M. norm (f (seq x m) - f (seq x n)) < e", "have \\<open>norm (f (seq x m) - f (seq x n)) < e\\<close> if \\<open>n \\<ge> M\\<close> and \\<open>m \\<ge> M\\<close> for n m"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (f (seq x m) - f (seq x n)) < e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm (f (seq x m) - f (seq x n)) < e", "have \\<open>norm (f (seq x m) - f (seq x n)) = norm (f (seq x m - seq x n))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (f (seq x m) - f (seq x n)) = norm (f (seq x m - seq x n))", "using f_add f_scale seq_S"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> S; ?y \\<in> S\\<rbrakk>\n  \\<Longrightarrow> f (?x + ?y) = f ?x + f ?y\n  ?x \\<in> S \\<Longrightarrow> f (?c *\\<^sub>C ?x) = ?c *\\<^sub>C f ?x\n  seq ?x ?i \\<in> S\n\ngoal (1 subgoal):\n 1. norm (f (seq x m) - f (seq x n)) = norm (f (seq x m - seq x n))", "by (metis add_diff_cancel assms(1) complex_vector.subspace_diff diff_add_cancel)"], ["proof (state)\nthis:\n  norm (f (seq x m) - f (seq x n)) = norm (f (seq x m - seq x n))\n\ngoal (1 subgoal):\n 1. norm (f (seq x m) - f (seq x n)) < e", "also"], ["proof (state)\nthis:\n  norm (f (seq x m) - f (seq x n)) = norm (f (seq x m - seq x n))\n\ngoal (1 subgoal):\n 1. norm (f (seq x m) - f (seq x n)) < e", "have \\<open>\\<dots> \\<le> B * norm (seq x m - seq x n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (f (seq x m - seq x n)) \\<le> B * norm (seq x m - seq x n)", "apply (rule bounded)"], ["proof (prove)\ngoal (1 subgoal):\n 1. seq x m - seq x n \\<in> S", "by (simp add: assms(1) complex_vector.subspace_diff seq_S)"], ["proof (state)\nthis:\n  norm (f (seq x m - seq x n)) \\<le> B * norm (seq x m - seq x n)\n\ngoal (1 subgoal):\n 1. norm (f (seq x m) - f (seq x n)) < e", "also"], ["proof (state)\nthis:\n  norm (f (seq x m - seq x n)) \\<le> B * norm (seq x m - seq x n)\n\ngoal (1 subgoal):\n 1. norm (f (seq x m) - f (seq x n)) < e", "from less_eB"], ["proof (chain)\npicking this:\n  \\<lbrakk>M \\<le> ?n; M \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> norm (seq x ?m - seq x ?n) < e / B", "have \\<open>\\<dots> < B * (e/B)\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>M \\<le> ?n; M \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> norm (seq x ?m - seq x ?n) < e / B\n\ngoal (1 subgoal):\n 1. B * norm (seq x m - seq x n) < B * (e / B)", "by (meson \\<open>0 < B\\<close> linordered_semiring_strict_class.mult_strict_left_mono that)"], ["proof (state)\nthis:\n  B * norm (seq x m - seq x n) < B * (e / B)\n\ngoal (1 subgoal):\n 1. norm (f (seq x m) - f (seq x n)) < e", "also"], ["proof (state)\nthis:\n  B * norm (seq x m - seq x n) < B * (e / B)\n\ngoal (1 subgoal):\n 1. norm (f (seq x m) - f (seq x n)) < e", "have \\<open>\\<dots> \\<le> e\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. B * (e / B) \\<le> e", "using \\<open>0 < B\\<close>"], ["proof (prove)\nusing this:\n  0 < B\n\ngoal (1 subgoal):\n 1. B * (e / B) \\<le> e", "by auto"], ["proof (state)\nthis:\n  B * (e / B) \\<le> e\n\ngoal (1 subgoal):\n 1. norm (f (seq x m) - f (seq x n)) < e", "finally"], ["proof (chain)\npicking this:\n  norm (f (seq x m) - f (seq x n)) < e", "show ?thesis"], ["proof (prove)\nusing this:\n  norm (f (seq x m) - f (seq x n)) < e\n\ngoal (1 subgoal):\n 1. norm (f (seq x m) - f (seq x n)) < e", "by -"], ["proof (state)\nthis:\n  norm (f (seq x m) - f (seq x n)) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<le> ?n; M \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> norm (f (seq x ?m) - f (seq x ?n)) < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M. norm (f (seq x m) - f (seq x n)) < e", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>M \\<le> ?n; M \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> norm (f (seq x ?m) - f (seq x ?n)) < e", "show \\<open>\\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. norm (f (seq x m) - f (seq x n)) < e\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>M \\<le> ?n; M \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> norm (f (seq x ?m) - f (seq x ?n)) < e\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>m\\<ge>M.\n          \\<forall>n\\<ge>M. norm (f (seq x m) - f (seq x n)) < e", "by auto"], ["proof (state)\nthis:\n  \\<exists>M.\n     \\<forall>m\\<ge>M.\n        \\<forall>n\\<ge>M. norm (f (seq x m) - f (seq x n)) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cauchy (\\<lambda>i. f (seq ?x i))\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "then"], ["proof (chain)\npicking this:\n  Cauchy (\\<lambda>i. f (seq ?x i))", "have f_seq_lim: \\<open>(\\<lambda>i. f (seq x i)) \\<longlonglongrightarrow> g x\\<close> for x"], ["proof (prove)\nusing this:\n  Cauchy (\\<lambda>i. f (seq ?x i))\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (seq x i)) \\<longlonglongrightarrow> g x", "by (simp add: Cauchy_convergent_iff convergent_LIMSEQ_iff g_def)"], ["proof (state)\nthis:\n  (\\<lambda>i. f (seq ?x i)) \\<longlonglongrightarrow> g ?x\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "have f_xi_lim: \\<open>(\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x\\<close> if \\<open>xi \\<longlonglongrightarrow> x\\<close> and \\<open>\\<And>i. xi i \\<in> S\\<close> for xi x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x", "from seq_lim that"], ["proof (chain)\npicking this:\n  seq ?x \\<longlonglongrightarrow> ?x\n  xi \\<longlonglongrightarrow> x\n  xi ?i \\<in> S", "have \\<open>(\\<lambda>i. B * norm (xi i - seq x i)) \\<longlonglongrightarrow> 0\\<close>"], ["proof (prove)\nusing this:\n  seq ?x \\<longlonglongrightarrow> ?x\n  xi \\<longlonglongrightarrow> x\n  xi ?i \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. B * norm (xi i - seq x i)) \\<longlonglongrightarrow> 0", "by (metis (no_types) \\<open>0 < B\\<close> cancel_comm_monoid_add_class.diff_cancel norm_not_less_zero norm_zero tendsto_diff tendsto_norm_zero_iff tendsto_zero_mult_left_iff)"], ["proof (state)\nthis:\n  (\\<lambda>i. B * norm (xi i - seq x i)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>i. B * norm (xi i - seq x i)) \\<longlonglongrightarrow> 0", "have \\<open>(\\<lambda>i. f (xi i + (-1) *\\<^sub>C seq x i)) \\<longlonglongrightarrow> 0\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>i. B * norm (xi i - seq x i)) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i + - 1 *\\<^sub>C seq x i))\n    \\<longlonglongrightarrow> (0::'b)", "apply (rule Lim_null_comparison[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F xa in sequentially.\n       norm (f (xi xa + - 1 *\\<^sub>C seq x xa))\n       \\<le> B * norm (xi xa - seq x xa)", "using bounded"], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> norm (f ?x) \\<le> B * norm ?x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F xa in sequentially.\n       norm (f (xi xa + - 1 *\\<^sub>C seq x xa))\n       \\<le> B * norm (xi xa - seq x xa)", "by (simp add: assms(1) complex_vector.subspace_diff seq_S that(2))"], ["proof (state)\nthis:\n  (\\<lambda>i. f (xi i + - 1 *\\<^sub>C seq x i))\n  \\<longlonglongrightarrow> (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>i. f (xi i + - 1 *\\<^sub>C seq x i))\n  \\<longlonglongrightarrow> (0::'b)", "have \\<open>(\\<lambda>i. f (xi i) - f (seq x i)) \\<longlonglongrightarrow> 0\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>i. f (xi i + - 1 *\\<^sub>C seq x i))\n  \\<longlonglongrightarrow> (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i) - f (seq x i)) \\<longlonglongrightarrow> (0::'b)", "apply (subst (asm) f_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i. xi i \\<in> S\n 2. \\<And>i. - 1 *\\<^sub>C seq x i \\<in> S\n 3. (\\<lambda>i. f (xi i) + f (- 1 *\\<^sub>C seq x i))\n    \\<longlonglongrightarrow> (0::'b) \\<Longrightarrow>\n    (\\<lambda>i. f (xi i) - f (seq x i)) \\<longlonglongrightarrow> (0::'b)", "apply (auto simp: that \\<open>csubspace S\\<close> complex_vector.subspace_neg seq_S)[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i) + f (- 1 *\\<^sub>C seq x i))\n    \\<longlonglongrightarrow> (0::'b) \\<Longrightarrow>\n    (\\<lambda>i. f (xi i) - f (seq x i)) \\<longlonglongrightarrow> (0::'b)", "apply (subst (asm) f_scale)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i. seq x i \\<in> S\n 2. (\\<lambda>i. f (xi i) + - 1 *\\<^sub>C f (seq x i))\n    \\<longlonglongrightarrow> (0::'b) \\<Longrightarrow>\n    (\\<lambda>i. f (xi i) - f (seq x i)) \\<longlonglongrightarrow> (0::'b)", "by (auto simp: that \\<open>csubspace S\\<close> complex_vector.subspace_neg seq_S)"], ["proof (state)\nthis:\n  (\\<lambda>i. f (xi i) - f (seq x i)) \\<longlonglongrightarrow> (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>i. f (xi i) - f (seq x i)) \\<longlonglongrightarrow> (0::'b)", "show \\<open>(\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>i. f (xi i) - f (seq x i)) \\<longlonglongrightarrow> (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x", "using Lim_transform f_seq_lim"], ["proof (prove)\nusing this:\n  (\\<lambda>i. f (xi i) - f (seq x i)) \\<longlonglongrightarrow> (0::'b)\n  \\<lbrakk>(?g \\<longlongrightarrow> ?a) ?F;\n   ((\\<lambda>x. ?f x - ?g x) \\<longlongrightarrow> (0::?'a)) ?F\\<rbrakk>\n  \\<Longrightarrow> (?f \\<longlongrightarrow> ?a) ?F\n  (\\<lambda>i. f (seq ?x i)) \\<longlonglongrightarrow> g ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?xi \\<longlonglongrightarrow> ?x; \\<And>i. ?xi i \\<in> S\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>i. f (?xi i)) \\<longlonglongrightarrow> g ?x\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "have g_add: \\<open>g (x + y) = g x + g y\\<close> for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (x + y) = g x + g y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g (x + y) = g x + g y", "obtain xi :: \\<open>nat \\<Rightarrow> 'a\\<close> where \\<open>xi \\<longlonglongrightarrow> x\\<close> and \\<open>xi i \\<in> S\\<close> for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xi.\n        \\<lbrakk>xi \\<longlonglongrightarrow> x;\n         \\<And>i. xi i \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using seq_S seq_lim"], ["proof (prove)\nusing this:\n  seq ?x ?i \\<in> S\n  seq ?x \\<longlonglongrightarrow> ?x\n\ngoal (1 subgoal):\n 1. (\\<And>xi.\n        \\<lbrakk>xi \\<longlonglongrightarrow> x;\n         \\<And>i. xi i \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xi \\<longlonglongrightarrow> x\n  xi ?i \\<in> S\n\ngoal (1 subgoal):\n 1. g (x + y) = g x + g y", "obtain yi :: \\<open>nat \\<Rightarrow> 'a\\<close> where \\<open>yi \\<longlonglongrightarrow> y\\<close> and \\<open>yi i \\<in> S\\<close> for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>yi.\n        \\<lbrakk>yi \\<longlonglongrightarrow> y;\n         \\<And>i. yi i \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using seq_S seq_lim"], ["proof (prove)\nusing this:\n  seq ?x ?i \\<in> S\n  seq ?x \\<longlonglongrightarrow> ?x\n\ngoal (1 subgoal):\n 1. (\\<And>yi.\n        \\<lbrakk>yi \\<longlonglongrightarrow> y;\n         \\<And>i. yi i \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  yi \\<longlonglongrightarrow> y\n  yi ?i \\<in> S\n\ngoal (1 subgoal):\n 1. g (x + y) = g x + g y", "have \\<open>(\\<lambda>i. xi i + yi i) \\<longlonglongrightarrow> x + y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. xi i + yi i) \\<longlonglongrightarrow> x + y", "using \\<open>xi \\<longlonglongrightarrow> x\\<close> \\<open>yi \\<longlonglongrightarrow> y\\<close> tendsto_add"], ["proof (prove)\nusing this:\n  xi \\<longlonglongrightarrow> x\n  yi \\<longlonglongrightarrow> y\n  \\<lbrakk>(?f \\<longlongrightarrow> ?a) ?F;\n   (?g \\<longlongrightarrow> ?b) ?F\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. ?f x + ?g x) \\<longlongrightarrow>\n                     ?a + ?b)\n                     ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. xi i + yi i) \\<longlonglongrightarrow> x + y", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>i. xi i + yi i) \\<longlonglongrightarrow> x + y\n\ngoal (1 subgoal):\n 1. g (x + y) = g x + g y", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>i. xi i + yi i) \\<longlonglongrightarrow> x + y", "have lim1: \\<open>(\\<lambda>i. f (xi i + yi i)) \\<longlonglongrightarrow> g (x + y)\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>i. xi i + yi i) \\<longlonglongrightarrow> x + y\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i + yi i)) \\<longlonglongrightarrow> g (x + y)", "by (simp add: \\<open>\\<And>i. xi i \\<in> S\\<close> \\<open>\\<And>i. yi i \\<in> S\\<close> assms(1) complex_vector.subspace_add f_xi_lim)"], ["proof (state)\nthis:\n  (\\<lambda>i. f (xi i + yi i)) \\<longlonglongrightarrow> g (x + y)\n\ngoal (1 subgoal):\n 1. g (x + y) = g x + g y", "have \\<open>(\\<lambda>i. f (xi i + yi i)) = (\\<lambda>i. f (xi i) + f (yi i))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i + yi i)) = (\\<lambda>i. f (xi i) + f (yi i))", "by (simp add: \\<open>\\<And>i. xi i \\<in> S\\<close> \\<open>\\<And>i. yi i \\<in> S\\<close> f_add)"], ["proof (state)\nthis:\n  (\\<lambda>i. f (xi i + yi i)) = (\\<lambda>i. f (xi i) + f (yi i))\n\ngoal (1 subgoal):\n 1. g (x + y) = g x + g y", "also"], ["proof (state)\nthis:\n  (\\<lambda>i. f (xi i + yi i)) = (\\<lambda>i. f (xi i) + f (yi i))\n\ngoal (1 subgoal):\n 1. g (x + y) = g x + g y", "have \\<open>\\<dots> \\<longlonglongrightarrow> g x + g y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i) + f (yi i)) \\<longlonglongrightarrow> g x + g y", "by (simp add: \\<open>\\<And>i. xi i \\<in> S\\<close> \\<open>\\<And>i. yi i \\<in> S\\<close> \\<open>xi \\<longlonglongrightarrow> x\\<close> \\<open>yi \\<longlonglongrightarrow> y\\<close> f_xi_lim tendsto_add)"], ["proof (state)\nthis:\n  (\\<lambda>i. f (xi i) + f (yi i)) \\<longlonglongrightarrow> g x + g y\n\ngoal (1 subgoal):\n 1. g (x + y) = g x + g y", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>i. f (xi i + yi i)) \\<longlonglongrightarrow> g x + g y", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>i. f (xi i + yi i)) \\<longlonglongrightarrow> g x + g y\n\ngoal (1 subgoal):\n 1. g (x + y) = g x + g y", "using lim1 LIMSEQ_unique"], ["proof (prove)\nusing this:\n  (\\<lambda>i. f (xi i + yi i)) \\<longlonglongrightarrow> g x + g y\n  (\\<lambda>i. f (xi i + yi i)) \\<longlonglongrightarrow> g (x + y)\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?a;\n   ?X \\<longlonglongrightarrow> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. g (x + y) = g x + g y", "by blast"], ["proof (state)\nthis:\n  g (x + y) = g x + g y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g (?x + ?y) = g ?x + g ?y\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "have g_scale: \\<open>g (c *\\<^sub>C x) = c *\\<^sub>C g x\\<close> for c x"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (c *\\<^sub>C x) = c *\\<^sub>C g x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g (c *\\<^sub>C x) = c *\\<^sub>C g x", "obtain xi :: \\<open>nat \\<Rightarrow> 'a\\<close> where \\<open>xi \\<longlonglongrightarrow> x\\<close> and \\<open>xi i \\<in> S\\<close> for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xi.\n        \\<lbrakk>xi \\<longlonglongrightarrow> x;\n         \\<And>i. xi i \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using seq_S seq_lim"], ["proof (prove)\nusing this:\n  seq ?x ?i \\<in> S\n  seq ?x \\<longlonglongrightarrow> ?x\n\ngoal (1 subgoal):\n 1. (\\<And>xi.\n        \\<lbrakk>xi \\<longlonglongrightarrow> x;\n         \\<And>i. xi i \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xi \\<longlonglongrightarrow> x\n  xi ?i \\<in> S\n\ngoal (1 subgoal):\n 1. g (c *\\<^sub>C x) = c *\\<^sub>C g x", "have \\<open>(\\<lambda>i. c *\\<^sub>C xi i) \\<longlonglongrightarrow> c *\\<^sub>C x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. c *\\<^sub>C xi i) \\<longlonglongrightarrow> c *\\<^sub>C x", "using \\<open>xi \\<longlonglongrightarrow> x\\<close> bounded_clinear_scaleC_right clinear_continuous_at isCont_tendsto_compose"], ["proof (prove)\nusing this:\n  xi \\<longlonglongrightarrow> x\n  bounded_clinear ((*\\<^sub>C) ?c)\n  bounded_clinear ?f \\<Longrightarrow> isCont ?f ?x\n  \\<lbrakk>isCont ?g ?l; (?f \\<longlongrightarrow> ?l) ?F\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. ?g (?f x)) \\<longlongrightarrow> ?g ?l) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. c *\\<^sub>C xi i) \\<longlonglongrightarrow> c *\\<^sub>C x", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>i. c *\\<^sub>C xi i) \\<longlonglongrightarrow> c *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. g (c *\\<^sub>C x) = c *\\<^sub>C g x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>i. c *\\<^sub>C xi i) \\<longlonglongrightarrow> c *\\<^sub>C x", "have lim1: \\<open>(\\<lambda>i. f (c *\\<^sub>C xi i)) \\<longlonglongrightarrow> g (c *\\<^sub>C x)\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>i. c *\\<^sub>C xi i) \\<longlonglongrightarrow> c *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (c *\\<^sub>C xi i))\n    \\<longlonglongrightarrow> g (c *\\<^sub>C x)", "by (simp add: \\<open>\\<And>i. xi i \\<in> S\\<close> assms(1) complex_vector.subspace_scale f_xi_lim)"], ["proof (state)\nthis:\n  (\\<lambda>i. f (c *\\<^sub>C xi i))\n  \\<longlonglongrightarrow> g (c *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. g (c *\\<^sub>C x) = c *\\<^sub>C g x", "have \\<open>(\\<lambda>i. f (c *\\<^sub>C xi i)) = (\\<lambda>i. c *\\<^sub>C f (xi i))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (c *\\<^sub>C xi i)) = (\\<lambda>i. c *\\<^sub>C f (xi i))", "by (simp add: \\<open>\\<And>i. xi i \\<in> S\\<close> f_scale)"], ["proof (state)\nthis:\n  (\\<lambda>i. f (c *\\<^sub>C xi i)) = (\\<lambda>i. c *\\<^sub>C f (xi i))\n\ngoal (1 subgoal):\n 1. g (c *\\<^sub>C x) = c *\\<^sub>C g x", "also"], ["proof (state)\nthis:\n  (\\<lambda>i. f (c *\\<^sub>C xi i)) = (\\<lambda>i. c *\\<^sub>C f (xi i))\n\ngoal (1 subgoal):\n 1. g (c *\\<^sub>C x) = c *\\<^sub>C g x", "have \\<open>\\<dots> \\<longlonglongrightarrow> c *\\<^sub>C g x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. c *\\<^sub>C f (xi i))\n    \\<longlonglongrightarrow> c *\\<^sub>C g x", "using \\<open>\\<And>i. xi i \\<in> S\\<close> \\<open>xi \\<longlonglongrightarrow> x\\<close> bounded_clinear_scaleC_right clinear_continuous_at f_xi_lim isCont_tendsto_compose"], ["proof (prove)\nusing this:\n  xi ?i \\<in> S\n  xi \\<longlonglongrightarrow> x\n  bounded_clinear ((*\\<^sub>C) ?c)\n  bounded_clinear ?f \\<Longrightarrow> isCont ?f ?x\n  \\<lbrakk>?xi \\<longlonglongrightarrow> ?x; \\<And>i. ?xi i \\<in> S\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>i. f (?xi i)) \\<longlonglongrightarrow> g ?x\n  \\<lbrakk>isCont ?g ?l; (?f \\<longlongrightarrow> ?l) ?F\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. ?g (?f x)) \\<longlongrightarrow> ?g ?l) ?F\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. c *\\<^sub>C f (xi i))\n    \\<longlonglongrightarrow> c *\\<^sub>C g x", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>i. c *\\<^sub>C f (xi i))\n  \\<longlonglongrightarrow> c *\\<^sub>C g x\n\ngoal (1 subgoal):\n 1. g (c *\\<^sub>C x) = c *\\<^sub>C g x", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>i. f (c *\\<^sub>C xi i))\n  \\<longlonglongrightarrow> c *\\<^sub>C g x", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>i. f (c *\\<^sub>C xi i))\n  \\<longlonglongrightarrow> c *\\<^sub>C g x\n\ngoal (1 subgoal):\n 1. g (c *\\<^sub>C x) = c *\\<^sub>C g x", "using lim1 LIMSEQ_unique"], ["proof (prove)\nusing this:\n  (\\<lambda>i. f (c *\\<^sub>C xi i))\n  \\<longlonglongrightarrow> c *\\<^sub>C g x\n  (\\<lambda>i. f (c *\\<^sub>C xi i))\n  \\<longlonglongrightarrow> g (c *\\<^sub>C x)\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?a;\n   ?X \\<longlonglongrightarrow> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. g (c *\\<^sub>C x) = c *\\<^sub>C g x", "by blast"], ["proof (state)\nthis:\n  g (c *\\<^sub>C x) = c *\\<^sub>C g x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g (?c *\\<^sub>C ?x) = ?c *\\<^sub>C g ?x\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "have [simp]: \\<open>f x = g x\\<close> if \\<open>x \\<in> S\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = g x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f x = g x", "have \\<open>(\\<lambda>_. x) \\<longlonglongrightarrow> x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. x) \\<longlonglongrightarrow> x", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>_. x) \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. f x = g x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>_. x) \\<longlonglongrightarrow> x", "have \\<open>(\\<lambda>_. f x) \\<longlonglongrightarrow> g x\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>_. x) \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. (\\<lambda>_. f x) \\<longlonglongrightarrow> g x", "using that"], ["proof (prove)\nusing this:\n  (\\<lambda>_. x) \\<longlonglongrightarrow> x\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<lambda>_. f x) \\<longlonglongrightarrow> g x", "by (rule f_xi_lim)"], ["proof (state)\nthis:\n  (\\<lambda>_. f x) \\<longlonglongrightarrow> g x\n\ngoal (1 subgoal):\n 1. f x = g x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>_. f x) \\<longlonglongrightarrow> g x", "show \\<open>f x = g x\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>_. f x) \\<longlonglongrightarrow> g x\n\ngoal (1 subgoal):\n 1. f x = g x", "by (simp add: LIMSEQ_const_iff)"], ["proof (state)\nthis:\n  f x = g x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> S \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "have g_bounded: \\<open>norm (g x) \\<le> B * norm x\\<close> for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (g x) \\<le> B * norm x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm (g x) \\<le> B * norm x", "obtain xi :: \\<open>nat \\<Rightarrow> 'a\\<close> where \\<open>xi \\<longlonglongrightarrow> x\\<close> and \\<open>xi i \\<in> S\\<close> for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xi.\n        \\<lbrakk>xi \\<longlonglongrightarrow> x;\n         \\<And>i. xi i \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using seq_S seq_lim"], ["proof (prove)\nusing this:\n  seq ?x ?i \\<in> S\n  seq ?x \\<longlonglongrightarrow> ?x\n\ngoal (1 subgoal):\n 1. (\\<And>xi.\n        \\<lbrakk>xi \\<longlonglongrightarrow> x;\n         \\<And>i. xi i \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xi \\<longlonglongrightarrow> x\n  xi ?i \\<in> S\n\ngoal (1 subgoal):\n 1. norm (g x) \\<le> B * norm x", "then"], ["proof (chain)\npicking this:\n  xi \\<longlonglongrightarrow> x\n  xi ?i \\<in> S", "have \\<open>(\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x\\<close>"], ["proof (prove)\nusing this:\n  xi \\<longlonglongrightarrow> x\n  xi ?i \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x", "using f_xi_lim"], ["proof (prove)\nusing this:\n  xi \\<longlonglongrightarrow> x\n  xi ?i \\<in> S\n  \\<lbrakk>?xi \\<longlonglongrightarrow> ?x; \\<And>i. ?xi i \\<in> S\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>i. f (?xi i)) \\<longlonglongrightarrow> g ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x", "by presburger"], ["proof (state)\nthis:\n  (\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x\n\ngoal (1 subgoal):\n 1. norm (g x) \\<le> B * norm x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x", "have \\<open>(\\<lambda>i. norm (f (xi i))) \\<longlonglongrightarrow> norm (g x)\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>i. f (xi i)) \\<longlonglongrightarrow> g x\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. norm (f (xi i))) \\<longlonglongrightarrow> norm (g x)", "by (metis tendsto_norm)"], ["proof (state)\nthis:\n  (\\<lambda>i. norm (f (xi i))) \\<longlonglongrightarrow> norm (g x)\n\ngoal (1 subgoal):\n 1. norm (g x) \\<le> B * norm x", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>i. norm (f (xi i))) \\<longlonglongrightarrow> norm (g x)\n\ngoal (1 subgoal):\n 1. norm (g x) \\<le> B * norm x", "have \\<open>(\\<lambda>i. B * norm (xi i)) \\<longlonglongrightarrow> B * norm x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. B * norm (xi i)) \\<longlonglongrightarrow> B * norm x", "by (simp add: \\<open>xi \\<longlonglongrightarrow> x\\<close> tendsto_mult_left tendsto_norm)"], ["proof (state)\nthis:\n  (\\<lambda>i. B * norm (xi i)) \\<longlonglongrightarrow> B * norm x\n\ngoal (1 subgoal):\n 1. norm (g x) \\<le> B * norm x", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>i. norm (f (xi i))) \\<longlonglongrightarrow> norm (g x)\n  (\\<lambda>i. B * norm (xi i)) \\<longlonglongrightarrow> B * norm x", "show \\<open>norm (g x) \\<le> B * norm x\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>i. norm (f (xi i))) \\<longlonglongrightarrow> norm (g x)\n  (\\<lambda>i. B * norm (xi i)) \\<longlonglongrightarrow> B * norm x\n\ngoal (1 subgoal):\n 1. norm (g x) \\<le> B * norm x", "apply (rule lim_mono[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       ?N \\<le> n \\<Longrightarrow> norm (f (xi n)) \\<le> B * norm (xi n)", "using bounded"], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> norm (f ?x) \\<le> B * norm ?x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       ?N \\<le> n \\<Longrightarrow> norm (f (xi n)) \\<le> B * norm (xi n)", "using \\<open>xi _ \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> norm (f ?x) \\<le> B * norm ?x\n  xi ?_dummy_ \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       ?N \\<le> n \\<Longrightarrow> norm (f (xi n)) \\<le> B * norm (xi n)", "by blast"], ["proof (state)\nthis:\n  norm (g x) \\<le> B * norm x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (g ?x) \\<le> B * norm ?x\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "have \\<open>bounded_clinear g\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear g", "using g_add g_scale"], ["proof (prove)\nusing this:\n  g (?x + ?y) = g ?x + g ?y\n  g (?c *\\<^sub>C ?x) = ?c *\\<^sub>C g ?x\n\ngoal (1 subgoal):\n 1. bounded_clinear g", "apply (rule bounded_clinearI[where K=B])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. norm (g x) \\<le> norm x * B", "using g_bounded"], ["proof (prove)\nusing this:\n  norm (g ?x) \\<le> B * norm ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x. norm (g x) \\<le> norm x * B", "by (simp add: ordered_field_class.sign_simps(5))"], ["proof (state)\nthis:\n  bounded_clinear g\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "then"], ["proof (chain)\npicking this:\n  bounded_clinear g", "have [simp]: \\<open>CBlinfun g *\\<^sub>V x = g x\\<close> for x"], ["proof (prove)\nusing this:\n  bounded_clinear g\n\ngoal (1 subgoal):\n 1. CBlinfun g *\\<^sub>V x = g x", "by (subst CBlinfun_inverse, auto)"], ["proof (state)\nthis:\n  CBlinfun g *\\<^sub>V ?x = g ?x\n\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "show \\<open>cblinfun_extension_exists S f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_extension_exists S f", "apply (rule cblinfun_extension_existsI[where B=\\<open>CBlinfun g\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> CBlinfun g *\\<^sub>V x = f x", "by auto"], ["proof (state)\nthis:\n  cblinfun_extension_exists S f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cblinfun_extension_apply:\n  assumes \"cblinfun_extension_exists S f\"\n    and \"v \\<in> S\"\n  shows \"(cblinfun_extension S f) *\\<^sub>V v = f v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cblinfun_extension S f *\\<^sub>V v = f v", "by (smt assms cblinfun_extension_def cblinfun_extension_exists_def tfl_some)"], ["", "subsection \\<open>Notation\\<close>"], ["", "bundle cblinfun_notation begin"], ["", "notation cblinfun_compose (infixl \"o\\<^sub>C\\<^sub>L\" 55)"], ["", "notation cblinfun_apply (infixr \"*\\<^sub>V\" 70)"], ["", "notation cblinfun_image (infixr \"*\\<^sub>S\" 70)"], ["", "notation adj (\"_*\" [99] 100)"], ["", "end"], ["", "bundle no_cblinfun_notation begin"], ["", "no_notation cblinfun_compose (infixl \"o\\<^sub>C\\<^sub>L\" 55)"], ["", "no_notation cblinfun_apply (infixr \"*\\<^sub>V\" 70)"], ["", "no_notation cblinfun_image (infixr \"*\\<^sub>S\" 70)"], ["", "no_notation adj (\"_*\" [99] 100)"], ["", "end"], ["", "bundle blinfun_notation begin"], ["", "notation blinfun_apply (infixr \"*\\<^sub>V\" 70)"], ["", "end"], ["", "bundle no_blinfun_notation begin"], ["", "no_notation blinfun_apply (infixr \"*\\<^sub>V\" 70)"], ["", "end"], ["", "unbundle no_cblinfun_notation"], ["", "end"]]}