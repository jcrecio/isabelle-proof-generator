{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators/Cblinfun_Code.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators", "problem_names": ["lemma vec_of_ell2_inverse [code abstype]:\n  \"ell2_of_vec (vec_of_ell2 B) = B\"", "lemma vec_of_ell2_zero[code]:\n  \\<comment> \\<open>Code equation for computing the zero vector\\<close>\n  \"vec_of_ell2 (0::'a::enum ell2) = zero_vec (CARD('a))\"", "lemma vec_of_ell2_ket[code]:\n  \\<comment> \\<open>Code equation for computing a standard basis vector\\<close>\n  \"vec_of_ell2 (ket i) = unit_vec (CARD('a)) (enum_idx i)\" \n  for i::\"'a::enum\"", "lemma vec_of_ell2_timesScalarVec[code]: \n  \\<comment> \\<open>Code equation for multiplying a vector with a complex scalar\\<close>\n  \"vec_of_ell2 (scaleC a \\<psi>) = smult_vec a (vec_of_ell2 \\<psi>)\"\n  for \\<psi> :: \"'a::enum ell2\"", "lemma vec_of_ell2_scaleR[code]: \n  \\<comment> \\<open>Code equation for multiplying a vector with a real scalar\\<close>\n  \"vec_of_ell2 (scaleR a \\<psi>) = smult_vec (complex_of_real a) (vec_of_ell2 \\<psi>)\"\n  for \\<psi> :: \"'a::enum ell2\"", "lemma ell2_of_vec_plus[code]:\n  \\<comment> \\<open>Code equation for adding vectors\\<close>\n  \"vec_of_ell2 (x + y) =  (vec_of_ell2 x) + (vec_of_ell2 y)\" for x y :: \"'a::enum ell2\"", "lemma ell2_of_vec_minus[code]:\n  \\<comment> \\<open>Code equation for subtracting vectors\\<close>\n  \"vec_of_ell2 (x - y) =  (vec_of_ell2 x) - (vec_of_ell2 y)\" for x y :: \"'a::enum ell2\"", "lemma ell2_of_vec_uminus[code]:\n  \\<comment> \\<open>Code equation for negating a vector\\<close>\n  \"vec_of_ell2 (- y) =  - (vec_of_ell2 y)\" for y :: \"'a::enum ell2\"", "lemma cinner_ell2_code' [code]: \"cinner \\<psi> \\<phi> = cscalar_prod (vec_of_ell2 \\<phi>) (vec_of_ell2 \\<psi>)\"\n  \\<comment> \\<open>Code equation for the inner product of vectors\\<close>", "lemma norm_ell2_code [code]: \n  \\<comment> \\<open>Code equation for the norm of a vector\\<close>\n  \"norm \\<psi> = (let \\<psi>' = vec_of_ell2 \\<psi> in\n    sqrt (\\<Sum> i \\<in> {0 ..< dim_vec \\<psi>'}. let z = vec_index \\<psi>' i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))\"", "lemma times_ell2_code'[code]: \n  \\<comment> \\<open>Code equation for the product in the algebra of one-dimensional vectors\\<close>\n  fixes \\<psi> \\<phi> :: \"'a::{CARD_1,enum} ell2\"\n  shows \"vec_of_ell2 (\\<psi> * \\<phi>)\n   = vec_of_list [vec_index (vec_of_ell2 \\<psi>) 0 * vec_index (vec_of_ell2 \\<phi>) 0]\"", "lemma divide_ell2_code'[code]: \n  \\<comment> \\<open>Code equation for the product in the algebra of one-dimensional vectors\\<close>\n  fixes \\<psi> \\<phi> :: \"'a::{CARD_1,enum} ell2\"\n  shows \"vec_of_ell2 (\\<psi> / \\<phi>)\n   = vec_of_list [vec_index (vec_of_ell2 \\<psi>) 0 / vec_index (vec_of_ell2 \\<phi>) 0]\"", "lemma inverse_ell2_code'[code]: \n  \\<comment> \\<open>Code equation for the product in the algebra of one-dimensional vectors\\<close>\n  fixes \\<psi> :: \"'a::{CARD_1,enum} ell2\"\n  shows \"vec_of_ell2 (inverse \\<psi>)\n   = vec_of_list [inverse (vec_index (vec_of_ell2 \\<psi>) 0)]\"", "lemma one_ell2_code'[code]: \n  \\<comment> \\<open>Code equation for the unit in the algebra of one-dimensional vectors\\<close>\n  \"vec_of_ell2 (1 :: 'a::{CARD_1,enum} ell2) = vec_of_list [1]\"", "lemma cblinfun_apply_code[code]:\n  \\<comment> \\<open>Code equation for \\<^term>\\<open>cblinfun_apply_code\\<close>, i.e., for applying an operator\n     to an \\<^type>\\<open>ell2\\<close> vector\\<close>\n  \"vec_of_ell2 (cblinfun_apply_code M x) = (mult_mat_vec (mat_of_cblinfun M) (vec_of_ell2 x))\"", "lemma vector_to_cblinfun_code[code]: \n  \\<comment> \\<open>Code equation for translating a vector into an operation (single-column matrix)\\<close>\n  \"mat_of_cblinfun (vector_to_cblinfun_code \\<psi>) = mat_of_cols (CARD('a)) [vec_of_ell2 \\<psi>]\"\n  for \\<psi>::\"'a::enum ell2\"", "lemma mat_of_cblinfun_Proj_code_code[code]: \n  \\<comment> \\<open>Code equation for computing a projector onto a set S of vectors.\n     We first make the vectors S into an orthonormal basis using\n     the Gram-Schmidt procedure and then compute the projector\n     as the sum of the \"butterflies\" \\<open>x * x*\\<close> of the vectors \\<open>x\\<in>S\\<close>\n     (done by \\<^term>\\<open>mk_projector_orthog\\<close>).\\<close>\n  \"mat_of_cblinfun_Proj_code (SPAN S :: 'a::onb_enum ccsubspace) = \n    (let d = length (canonical_basis :: 'a list) in mk_projector_orthog d \n              (gram_schmidt0 d (filter (\\<lambda>v. dim_vec v = d) S)))\"", "lemma top_ccsubspace_code[code]: \n  \\<comment> \\<open>Code equation for \\<^term>\\<open>top\\<close>, the subspace containing everything.\n      Top is represented as the span of the standard basis vectors.\\<close>\n  \"(top::'a ccsubspace) =\n      (let n = length (canonical_basis :: 'a::onb_enum list) in SPAN (unit_vecs n))\"", "lemma bot_as_span[code]: \n  \\<comment> \\<open>Code equation for \\<^term>\\<open>bot\\<close>, the subspace containing everything.\n      Top is represented as the span of the standard basis vectors.\\<close>\n  \"(bot::'a::onb_enum ccsubspace) = SPAN []\"", "lemma sup_spans[code]:\n  \\<comment> \\<open>Code equation for the join (lub) of two subspaces (union of the generating lists)\\<close>\n  \"SPAN A \\<squnion> SPAN B = SPAN (A @ B)\"", "lemma span_Set_Monad[code]: \"Span_code (Set_Monad l) = (SPAN (map vec_of_ell2 l))\"\n  \\<comment> \\<open>Code equation for the span of a finite set. (\\<^term>\\<open>Set_Monad\\<close> is a datatype\n     constructor that represents sets as lists in the computation.)\\<close>", "lemma leq_ccsubspace_code[code]:\n  \\<comment> \\<open>Code equation for deciding inclusion of one space in another.\n     Uses the constant \\<^term>\\<open>is_subspace_of_vec_list\\<close> which implements the actual\n     computation by checking for each generator of A whether it is in the\n     span of B (by orthogonal projection onto an orthonormal basis of B\n     which is computed using Gram-Schmidt).\\<close>\n  \"SPAN A \\<le> (SPAN B :: 'a::onb_enum ccsubspace)\n      \\<longleftrightarrow> (let d = length (canonical_basis :: 'a list) in\n          is_subspace_of_vec_list d\n          (filter (\\<lambda>v. dim_vec v = d) A)\n          (filter (\\<lambda>v. dim_vec v = d) B))\"", "lemma equal_ccsubspace_code[code]:\n  \\<comment> \\<open>Code equation for equality test. By checking mutual inclusion\n      (for which we have code by the preceding code equation).\\<close>\n  \"HOL.equal (A::_ ccsubspace) B = (A\\<le>B \\<and> B\\<le>A)\"", "lemma apply_cblinfun_code[code]:\n  \\<comment> \\<open>Code equation for applying an operator \\<^term>\\<open>A\\<close> to a subspace. \n      Simply by multiplying each generator with \\<^term>\\<open>A\\<close>\\<close>\n  \"A *\\<^sub>S SPAN S = (let d = length (canonical_basis :: 'a list) in\n         SPAN (map (mult_mat_vec (mat_of_cblinfun A))\n               (filter (\\<lambda>v. dim_vec v = d) S)))\"\n  for A::\"'a::onb_enum \\<Rightarrow>\\<^sub>C\\<^sub>L'b::onb_enum\"", "lemma range_cblinfun_code[code]: \n  \\<comment> \\<open>Code equation for computing the range of an operator \\<^term>\\<open>A\\<close>.\n      Returns the columns of the matrix representation of \\<^term>\\<open>A\\<close>.\\<close>\n  fixes A :: \"'a::onb_enum \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::onb_enum\"\n  shows \"range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))\"", "lemma uminus_Span_code[code]: \"- X = range_cblinfun_code (id_cblinfun - Proj X)\"\n  \\<comment> \\<open>Code equation for the orthogonal complement of a subspace \\<^term>\\<open>X\\<close>. \n      Computed as the range of one minus the projector on \\<^term>\\<open>X\\<close>\\<close>", "lemma kernel_code[code]: \n  \\<comment> \\<open>Computes the kernel of an operator \\<^term>\\<open>A\\<close>.\n      This is implemented using the existing functions \n      for transforming a matrix into row echelon form (\\<^term>\\<open>gauss_jordan_single\\<close>)\n      and for computing a basis of the kernel of such a matrix\n      (\\<^term>\\<open>find_base_vectors\\<close>)\\<close>\n  \"kernel A = SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))\" \n  for A::\"('a::onb_enum,'b::onb_enum) cblinfun\"", "lemma inf_ccsubspace_code[code]: \n  \\<comment> \\<open>Code equation for intersection of subspaces.\n     Reduced to orthogonal complement and sum of subspaces\n     for which we already have code equations.\\<close>\n  \"(A::'a::onb_enum ccsubspace) \\<sqinter> B = - (- A \\<squnion> - B)\"", "lemma Sup_ccsubspace_code[code]:\n  \\<comment> \\<open>Supremum (sum) of a set of subspaces. Implemented\n     by repeated pairwise sum.\\<close>\n  \"Sup (Set_Monad l :: 'a::onb_enum ccsubspace set) = fold sup l bot\"", "lemma Inf_ccsubspace_code[code]: \n  \\<comment> \\<open>Infimum (intersection) of a set of subspaces. \n      Implemented by the orthogonal complement of the supremum.\\<close>\n  \"Inf (Set_Monad l :: 'a::onb_enum ccsubspace set)\n  = - Sup (Set_Monad (map uminus l))\"", "lemma uniformity_ell2_code[code]: \"(uniformity :: ('a ell2 * _) filter) = Filter.abstract_filter (%_.\n    Code.abort STR ''no uniformity'' (%_. \n    let x = ((=)::'a\\<Rightarrow>_\\<Rightarrow>_) in uniformity))\""], "translations": [["", "lemma vec_of_ell2_inverse [code abstype]:\n  \"ell2_of_vec (vec_of_ell2 B) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ell2_of_vec (vec_of_ell2 B) = B", "unfolding ell2_of_vec_def vec_of_ell2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec (vec_of_basis_enum B) = B", "by (rule vec_of_basis_enum_inverse)"], ["", "text \\<open>This instantiation defines a code equation for equality tests for ell2.\\<close>"], ["", "instantiation ell2 :: (enum) equal begin"], ["", "definition [code]: \"equal_ell2 M N \\<longleftrightarrow> vec_of_ell2 M = vec_of_ell2 N\" \n  for M N :: \"'a::enum ell2\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ell2, equal_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "unfolding equal_ell2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (vec_of_ell2 x = vec_of_ell2 y) = (x = y)", "by (metis vec_of_ell2_inverse)"], ["", "end"], ["", "lemma vec_of_ell2_zero[code]:\n  \\<comment> \\<open>Code equation for computing the zero vector\\<close>\n  \"vec_of_ell2 (0::'a::enum ell2) = zero_vec (CARD('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_ell2 0 = 0\\<^sub>v CARD('a)", "by (simp add: vec_of_ell2_def vec_of_basis_enum_zero)"], ["", "lemma vec_of_ell2_ket[code]:\n  \\<comment> \\<open>Code equation for computing a standard basis vector\\<close>\n  \"vec_of_ell2 (ket i) = unit_vec (CARD('a)) (enum_idx i)\" \n  for i::\"'a::enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_ell2 (ket i) = unit_vec CARD('a) (enum_idx i)", "using vec_of_ell2_def vec_of_basis_enum_ket"], ["proof (prove)\nusing this:\n  vec_of_ell2 = vec_of_basis_enum\n  vec_of_basis_enum (ket ?i) = unit_vec CARD(?'a) (enum_idx ?i)\n\ngoal (1 subgoal):\n 1. vec_of_ell2 (ket i) = unit_vec CARD('a) (enum_idx i)", "by metis"], ["", "lemma vec_of_ell2_timesScalarVec[code]: \n  \\<comment> \\<open>Code equation for multiplying a vector with a complex scalar\\<close>\n  \"vec_of_ell2 (scaleC a \\<psi>) = smult_vec a (vec_of_ell2 \\<psi>)\"\n  for \\<psi> :: \"'a::enum ell2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_ell2 (a *\\<^sub>C \\<psi>) = a \\<cdot>\\<^sub>v vec_of_ell2 \\<psi>", "by (simp add: vec_of_ell2_def vec_of_basis_enum_scaleC)"], ["", "lemma vec_of_ell2_scaleR[code]: \n  \\<comment> \\<open>Code equation for multiplying a vector with a real scalar\\<close>\n  \"vec_of_ell2 (scaleR a \\<psi>) = smult_vec (complex_of_real a) (vec_of_ell2 \\<psi>)\"\n  for \\<psi> :: \"'a::enum ell2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_ell2 (a *\\<^sub>R \\<psi>) =\n    complex_of_real a \\<cdot>\\<^sub>v vec_of_ell2 \\<psi>", "by (simp add: vec_of_ell2_def vec_of_basis_enum_scaleR)"], ["", "lemma ell2_of_vec_plus[code]:\n  \\<comment> \\<open>Code equation for adding vectors\\<close>\n  \"vec_of_ell2 (x + y) =  (vec_of_ell2 x) + (vec_of_ell2 y)\" for x y :: \"'a::enum ell2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_ell2 (x + y) = vec_of_ell2 x + vec_of_ell2 y", "by (simp add: vec_of_ell2_def vec_of_basis_enum_add)"], ["", "lemma ell2_of_vec_minus[code]:\n  \\<comment> \\<open>Code equation for subtracting vectors\\<close>\n  \"vec_of_ell2 (x - y) =  (vec_of_ell2 x) - (vec_of_ell2 y)\" for x y :: \"'a::enum ell2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_ell2 (x - y) = vec_of_ell2 x - vec_of_ell2 y", "by (simp add: vec_of_ell2_def vec_of_basis_enum_minus)"], ["", "lemma ell2_of_vec_uminus[code]:\n  \\<comment> \\<open>Code equation for negating a vector\\<close>\n  \"vec_of_ell2 (- y) =  - (vec_of_ell2 y)\" for y :: \"'a::enum ell2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_ell2 (- y) = - vec_of_ell2 y", "by (simp add: vec_of_ell2_def vec_of_basis_enum_uminus)"], ["", "lemma cinner_ell2_code' [code]: \"cinner \\<psi> \\<phi> = cscalar_prod (vec_of_ell2 \\<phi>) (vec_of_ell2 \\<psi>)\"\n  \\<comment> \\<open>Code equation for the inner product of vectors\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<bullet>\\<^sub>C \\<phi> =\n    vec_of_ell2 \\<phi> \\<bullet>c vec_of_ell2 \\<psi>", "by (simp add: cscalar_prod_vec_of_basis_enum vec_of_ell2_def)"], ["", "lemma norm_ell2_code [code]: \n  \\<comment> \\<open>Code equation for the norm of a vector\\<close>\n  \"norm \\<psi> = (let \\<psi>' = vec_of_ell2 \\<psi> in\n    sqrt (\\<Sum> i \\<in> {0 ..< dim_vec \\<psi>'}. let z = vec_index \\<psi>' i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm \\<psi> =\n    (let \\<psi>' = vec_of_ell2 \\<psi>\n     in sqrt\n         (\\<Sum>i = 0..<dim_vec \\<psi>'.\n             let z = \\<psi>' $ i in (Re z)\\<^sup>2 + (Im z)\\<^sup>2))", "by (simp add: norm_ell2_vec_of_basis_enum vec_of_ell2_def)"], ["", "lemma times_ell2_code'[code]: \n  \\<comment> \\<open>Code equation for the product in the algebra of one-dimensional vectors\\<close>\n  fixes \\<psi> \\<phi> :: \"'a::{CARD_1,enum} ell2\"\n  shows \"vec_of_ell2 (\\<psi> * \\<phi>)\n   = vec_of_list [vec_index (vec_of_ell2 \\<psi>) 0 * vec_index (vec_of_ell2 \\<phi>) 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_ell2 (\\<psi> * \\<phi>) =\n    vec_of_list [vec_of_ell2 \\<psi> $ 0 * vec_of_ell2 \\<phi> $ 0]", "by (simp add: vec_of_ell2_def vec_of_basis_enum_times)"], ["", "lemma divide_ell2_code'[code]: \n  \\<comment> \\<open>Code equation for the product in the algebra of one-dimensional vectors\\<close>\n  fixes \\<psi> \\<phi> :: \"'a::{CARD_1,enum} ell2\"\n  shows \"vec_of_ell2 (\\<psi> / \\<phi>)\n   = vec_of_list [vec_index (vec_of_ell2 \\<psi>) 0 / vec_index (vec_of_ell2 \\<phi>) 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_ell2 (\\<psi> / \\<phi>) =\n    vec_of_list [vec_of_ell2 \\<psi> $ 0 / vec_of_ell2 \\<phi> $ 0]", "by (simp add: vec_of_ell2_def vec_of_basis_enum_divide)"], ["", "lemma inverse_ell2_code'[code]: \n  \\<comment> \\<open>Code equation for the product in the algebra of one-dimensional vectors\\<close>\n  fixes \\<psi> :: \"'a::{CARD_1,enum} ell2\"\n  shows \"vec_of_ell2 (inverse \\<psi>)\n   = vec_of_list [inverse (vec_index (vec_of_ell2 \\<psi>) 0)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_ell2 (inverse \\<psi>) =\n    vec_of_list [inverse (vec_of_ell2 \\<psi> $ 0)]", "by (simp add: vec_of_ell2_def vec_of_basis_enum_to_inverse)"], ["", "lemma one_ell2_code'[code]: \n  \\<comment> \\<open>Code equation for the unit in the algebra of one-dimensional vectors\\<close>\n  \"vec_of_ell2 (1 :: 'a::{CARD_1,enum} ell2) = vec_of_list [1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_ell2 1 = vec_of_list [1]", "by (simp add: vec_of_ell2_def vec_of_basis_enum_1)"], ["", "subsection \\<open>Vector/Matrix\\<close>"], ["", "text \\<open>We proceed to give code equations for operations involving both\n  operators (cblinfun) and vectors. As explained above, we have to restrict\n  the equations to vectors of type \\<^typ>\\<open>'a ell2\\<close> even though the theory is available\n  for any type of class \\<^class>\\<open>onb_enum\\<close>. As a consequence, we run into an\n  addition technicality now. For example, to define a code equation for applying\n  an operator to a vector, we might try to give the following lemma:\n\n\\<^theory_text>\\<open>lemma cblinfun_apply_code[code]:\n  \"vec_of_ell2 (M *\\<^sub>V x) = (mult_mat_vec (mat_of_cblinfun M) (vec_of_ell2 x))\"\n  by (simp add: mat_of_cblinfun_cblinfun_apply vec_of_ell2_def)\\<close>\n\n  Unfortunately, this does not work, Isabelle produces the warning \n  \"Projection as head in equation\", most likely due to the fact that\n  the type of \\<^term>\\<open>(*\\<^sub>V)\\<close> in the equation is less general than the type of \n  \\<^term>\\<open>(*\\<^sub>V)\\<close> (it is restricted to @{type ell2}). We overcome this problem\n  by defining a constant \\<open>cblinfun_apply_code\\<close> which is equal to \\<^term>\\<open>(*\\<^sub>V)\\<close>\n  but has a more restricted type. We then instruct the code generation \n  to replace occurrences of \\<^term>\\<open>(*\\<^sub>V)\\<close> by \\<open>cblinfun_apply_code\\<close> (where possible),\n  and we add code generation for \\<open>cblinfun_apply_code\\<close> instead of \\<^term>\\<open>(*\\<^sub>V)\\<close>.\n\\<close>"], ["", "definition cblinfun_apply_code :: \"'a ell2 \\<Rightarrow>\\<^sub>C\\<^sub>L 'b ell2 \\<Rightarrow> 'a ell2 \\<Rightarrow> 'b ell2\" \n  where [code del, code_abbrev]: \"cblinfun_apply_code = (*\\<^sub>V)\"\n    \\<comment> \\<open>@{attribute code_abbrev} instructs the code generation to replace the\n     rhs \\<^term>\\<open>(*\\<^sub>V)\\<close> by the lhs \\<^term>\\<open>cblinfun_apply_code\\<close> before starting \n     the actual code generation.\\<close>"], ["", "lemma cblinfun_apply_code[code]:\n  \\<comment> \\<open>Code equation for \\<^term>\\<open>cblinfun_apply_code\\<close>, i.e., for applying an operator\n     to an \\<^type>\\<open>ell2\\<close> vector\\<close>\n  \"vec_of_ell2 (cblinfun_apply_code M x) = (mult_mat_vec (mat_of_cblinfun M) (vec_of_ell2 x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_of_ell2 (cblinfun_apply_code M x) =\n    mat_of_cblinfun M *\\<^sub>v vec_of_ell2 x", "by (simp add: cblinfun_apply_code_def mat_of_cblinfun_cblinfun_apply vec_of_ell2_def)"], ["", "text \\<open>For the constant \\<^term>\\<open>vector_to_cblinfun\\<close> (canonical isomorphism from\n  vectors to operators), we have the same problem and define a constant\n  \\<open>vector_to_cblinfun_code\\<close> with more restricted type\\<close>"], ["", "definition vector_to_cblinfun_code :: \"'a ell2 \\<Rightarrow> 'b::one_dim \\<Rightarrow>\\<^sub>C\\<^sub>L 'a ell2\" where\n  [code del,code_abbrev]: \"vector_to_cblinfun_code = vector_to_cblinfun\"\n  \\<comment> \\<open>@{attribute code_abbrev} instructs the code generation to replace the\n     rhs \\<^term>\\<open>vector_to_cblinfun\\<close> by the lhs \\<^term>\\<open>vector_to_cblinfun_code\\<close>\n     before starting the actual code generation.\\<close>"], ["", "lemma vector_to_cblinfun_code[code]: \n  \\<comment> \\<open>Code equation for translating a vector into an operation (single-column matrix)\\<close>\n  \"mat_of_cblinfun (vector_to_cblinfun_code \\<psi>) = mat_of_cols (CARD('a)) [vec_of_ell2 \\<psi>]\"\n  for \\<psi>::\"'a::enum ell2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun (vector_to_cblinfun_code \\<psi>) =\n    mat_of_cols CARD('a) [vec_of_ell2 \\<psi>]", "by (simp add: mat_of_cblinfun_vector_to_cblinfun  vec_of_ell2_def vector_to_cblinfun_code_def)"], ["", "subsection \\<open>Subspaces\\<close>"], ["", "text \\<open>In this section, we define code equations for handling subspaces, i.e.,\nvalues of type \\<^typ>\\<open>'a ccsubspace\\<close>. We choose to computationally represent\na subspace by a list of vectors that span the subspace. That is,\nif \\<^term>\\<open>vecs\\<close> are vectors (type \\<^typ>\\<open>complex vec\\<close>), \\<open>SPAN vecs\\<close> is defined to be their\nspan. Then the code generation can simply represent all subspaces in this form, and \nwe need to define the operations on subspaces in terms of list of vectors \n(e.g., the closed union of two subspaces would be computed as the concatenation \nof the two lists, to give one of the simplest examples).\n\nTo support this, \\<open>SPAN\\<close> is declared as a \"\\<open>code_datatype\\<close>\".\n(Not as an abstract datatype like \\<^term>\\<open>cblinfun_of_mat\\<close>/\\<^term>\\<open>mat_of_cblinfun\\<close>\nbecause that would require \\<open>SPAN\\<close> to be injective.)\n\nThen all code equations for different operations need to be formulated as\nfunctions of values of the form \\<open>SPAN x\\<close>. (E.g., \\<open>SPAN x + SPAN y = SPAN (\\<dots>)\\<close>.)\\<close>"], ["", "definition [code del]: \"SPAN x = (let n = length (canonical_basis :: 'a::onb_enum list) in\n    ccspan (basis_enum_of_vec ` Set.filter (\\<lambda>v. dim_vec v = n) (set x)) :: 'a ccsubspace)\"\n  \\<comment> \\<open>The SPAN of vectors x, as a \\<^type>\\<open>ccsubspace\\<close>.\n      We filter out vectors of the wrong dimension because \\<open>SPAN\\<close> needs to have\n      well-defined behavior even in cases that would not actually occur in an execution.\\<close>"], ["", "code_datatype SPAN"], ["", "text \\<open>We first declare code equations for \\<^term>\\<open>Proj\\<close>, i.e., for\nturning a subspace into a projector. This means, we would need a code equation\nof the form \\<open>mat_of_cblinfun (Proj (SPAN S)) = \\<dots>\\<close>. However, this equation is\nnot accepted by the code generation for reasons we do not understand. But\nif we define an auxiliary constant \\<open>mat_of_cblinfun_Proj_code\\<close> that stands for \n\\<open>mat_of_cblinfun (Proj _)\\<close>, define a code equation for \\<open>mat_of_cblinfun_Proj_code\\<close>,\nand then define a code equation for \\<open>mat_of_cblinfun (Proj S)\\<close> in terms of \n\\<open>mat_of_cblinfun_Proj_code\\<close>, Isabelle accepts the code equations.\\<close>"], ["", "definition \"mat_of_cblinfun_Proj_code S = mat_of_cblinfun (Proj S)\""], ["", "declare mat_of_cblinfun_Proj_code_def[symmetric, code]"], ["", "lemma mat_of_cblinfun_Proj_code_code[code]: \n  \\<comment> \\<open>Code equation for computing a projector onto a set S of vectors.\n     We first make the vectors S into an orthonormal basis using\n     the Gram-Schmidt procedure and then compute the projector\n     as the sum of the \"butterflies\" \\<open>x * x*\\<close> of the vectors \\<open>x\\<in>S\\<close>\n     (done by \\<^term>\\<open>mk_projector_orthog\\<close>).\\<close>\n  \"mat_of_cblinfun_Proj_code (SPAN S :: 'a::onb_enum ccsubspace) = \n    (let d = length (canonical_basis :: 'a list) in mk_projector_orthog d \n              (gram_schmidt0 d (filter (\\<lambda>v. dim_vec v = d) S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun_Proj_code (SPAN S) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d\n         (gram_schmidt0 d (filter (\\<lambda>v. dim_vec v = d) S)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_of_cblinfun_Proj_code (SPAN S) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d\n         (gram_schmidt0 d (filter (\\<lambda>v. dim_vec v = d) S)))", "have *: \"map_option vec_of_basis_enum (if dim_vec x = length (canonical_basis :: 'a list) then Some (basis_enum_of_vec x :: 'a) else None)\n      = (if dim_vec x = length (canonical_basis :: 'a list) then Some x else None)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option vec_of_basis_enum\n     (if dim_vec x = length canonical_basis then Some (basis_enum_of_vec x)\n      else None) =\n    (if dim_vec x = length canonical_basis then Some x else None)", "by auto"], ["proof (state)\nthis:\n  map_option vec_of_basis_enum\n   (if dim_vec ?x = length canonical_basis then Some (basis_enum_of_vec ?x)\n    else None) =\n  (if dim_vec ?x = length canonical_basis then Some ?x else None)\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun_Proj_code (SPAN S) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d\n         (gram_schmidt0 d (filter (\\<lambda>v. dim_vec v = d) S)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun_Proj_code (SPAN S) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d\n         (gram_schmidt0 d (filter (\\<lambda>v. dim_vec v = d) S)))", "unfolding SPAN_def mat_of_cblinfun_Proj_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun\n     (Proj\n       (let n = length canonical_basis\n        in ccspan\n            (basis_enum_of_vec `\n             Set.filter (\\<lambda>v. dim_vec v = n) (set S)))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d\n         (gram_schmidt0 d (filter (\\<lambda>v. dim_vec v = d) S)))", "using mat_of_cblinfun_Proj_ccspan[where S = \n        \"map basis_enum_of_vec (filter (\\<lambda>v. dim_vec v = (length (canonical_basis :: 'a list))) S) :: 'a list\"]"], ["proof (prove)\nusing this:\n  mat_of_cblinfun\n   (Proj\n     (ccspan\n       (set (map basis_enum_of_vec\n              (filter (\\<lambda>v. dim_vec v = length canonical_basis)\n                S))))) =\n  (let d = length canonical_basis\n   in mk_projector_orthog d\n       (gram_schmidt0 d\n         (map vec_of_basis_enum\n           (map basis_enum_of_vec\n             (filter (\\<lambda>v. dim_vec v = length canonical_basis) S)))))\n\ngoal (1 subgoal):\n 1. mat_of_cblinfun\n     (Proj\n       (let n = length canonical_basis\n        in ccspan\n            (basis_enum_of_vec `\n             Set.filter (\\<lambda>v. dim_vec v = n) (set S)))) =\n    (let d = length canonical_basis\n     in mk_projector_orthog d\n         (gram_schmidt0 d (filter (\\<lambda>v. dim_vec v = d) S)))", "apply (simp only: Let_def map_filter_map_filter filter_set image_set map_map_filter o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun\n     (Proj\n       (ccspan\n         (set (List.map_filter\n                (\\<lambda>x.\n                    if dim_vec x = length canonical_basis\n                    then Some (basis_enum_of_vec x) else None)\n                S)))) =\n    mk_projector_orthog (length canonical_basis)\n     (gram_schmidt0 (length canonical_basis)\n       (List.map_filter\n         (\\<lambda>x.\n             map_option vec_of_basis_enum\n              (if dim_vec x = length canonical_basis\n               then Some (basis_enum_of_vec x) else None))\n         S)) \\<Longrightarrow>\n    mk_projector_orthog (length canonical_basis)\n     (gram_schmidt0 (length canonical_basis)\n       (List.map_filter\n         (\\<lambda>x.\n             map_option vec_of_basis_enum\n              (if dim_vec x = length canonical_basis\n               then Some (basis_enum_of_vec x) else None))\n         S)) =\n    mk_projector_orthog (length canonical_basis)\n     (gram_schmidt0 (length canonical_basis)\n       (filter (\\<lambda>v. dim_vec v = length canonical_basis) S))", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun\n     (Proj\n       (ccspan\n         (set (List.map_filter\n                (\\<lambda>x.\n                    if dim_vec x = length canonical_basis\n                    then Some (basis_enum_of_vec x) else None)\n                S)))) =\n    mk_projector_orthog (length canonical_basis)\n     (gram_schmidt0 (length canonical_basis)\n       (List.map_filter\n         (\\<lambda>x.\n             if dim_vec x = length canonical_basis then Some x else None)\n         S)) \\<Longrightarrow>\n    mk_projector_orthog (length canonical_basis)\n     (gram_schmidt0 (length canonical_basis)\n       (List.map_filter\n         (\\<lambda>x.\n             if dim_vec x = length canonical_basis then Some x else None)\n         S)) =\n    mk_projector_orthog (length canonical_basis)\n     (gram_schmidt0 (length canonical_basis)\n       (filter (\\<lambda>v. dim_vec v = length canonical_basis) S))", "by (simp add: map_filter_map_filter[symmetric])"], ["proof (state)\nthis:\n  mat_of_cblinfun_Proj_code (SPAN S) =\n  (let d = length canonical_basis\n   in mk_projector_orthog d\n       (gram_schmidt0 d (filter (\\<lambda>v. dim_vec v = d) S)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma top_ccsubspace_code[code]: \n  \\<comment> \\<open>Code equation for \\<^term>\\<open>top\\<close>, the subspace containing everything.\n      Top is represented as the span of the standard basis vectors.\\<close>\n  \"(top::'a ccsubspace) =\n      (let n = length (canonical_basis :: 'a::onb_enum list) in SPAN (unit_vecs n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> = (let n = length canonical_basis in SPAN (unit_vecs n))", "unfolding SPAN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> =\n    (let n = length canonical_basis; na = length canonical_basis\n     in ccspan\n         (basis_enum_of_vec `\n          Set.filter (\\<lambda>v. dim_vec v = na) (set (unit_vecs n))))", "apply (simp only: index_unit_vec Let_def map_filter_map_filter filter_set image_set map_map_filter \n      map_filter_map o_def unit_vecs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> =\n    ccspan\n     (set (List.map_filter\n            (\\<lambda>x.\n                if length canonical_basis = length canonical_basis\n                then Some\n                      (basis_enum_of_vec\n                        (unit_vec (length canonical_basis) x))\n                else None)\n            [0..<length canonical_basis]))", "apply (simp add: basis_enum_of_vec_unit_vec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> = ccspan ((!) canonical_basis ` {0..<length canonical_basis})", "apply (subst nth_image)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length canonical_basis \\<le> length canonical_basis\n 2. \\<top> = ccspan (set (take (length canonical_basis) canonical_basis))", "by (auto simp: )"], ["", "lemma bot_as_span[code]: \n  \\<comment> \\<open>Code equation for \\<^term>\\<open>bot\\<close>, the subspace containing everything.\n      Top is represented as the span of the standard basis vectors.\\<close>\n  \"(bot::'a::onb_enum ccsubspace) = SPAN []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> = SPAN []", "unfolding SPAN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> =\n    (let n = length canonical_basis\n     in ccspan\n         (basis_enum_of_vec `\n          Set.filter (\\<lambda>v. dim_vec v = n) (set [])))", "by (auto simp: Set.filter_def)"], ["", "lemma sup_spans[code]:\n  \\<comment> \\<open>Code equation for the join (lub) of two subspaces (union of the generating lists)\\<close>\n  \"SPAN A \\<squnion> SPAN B = SPAN (A @ B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPAN A \\<squnion> SPAN B = SPAN (A @ B)", "unfolding SPAN_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let n = length canonical_basis\n     in ccspan\n         (basis_enum_of_vec `\n          Set.filter (\\<lambda>v. dim_vec v = n) (set A))) \\<squnion>\n    (let n = length canonical_basis\n     in ccspan\n         (basis_enum_of_vec `\n          Set.filter (\\<lambda>v. dim_vec v = n) (set B))) =\n    (let n = length canonical_basis\n     in ccspan\n         (basis_enum_of_vec `\n          Set.filter (\\<lambda>v. dim_vec v = n) (set (A @ B))))", "by (auto simp: ccspan_union image_Un filter_Un Let_def)"], ["", "text \\<open>We do not need an equation for \\<^term>\\<open>(+)\\<close> because \\<^term>\\<open>(+)\\<close>\nis defined in terms of \\<^term>\\<open>(\\<squnion>)\\<close> (for \\<^type>\\<open>ccsubspace\\<close>), thus the code generation automatically\ncomputes \\<^term>\\<open>(+)\\<close> in terms of the code for \\<^term>\\<open>(\\<squnion>)\\<close>\\<close>"], ["", "definition [code del,code_abbrev]: \"Span_code (S::'a::enum ell2 set) = (ccspan S)\"\n  \\<comment> \\<open>A copy of \\<^term>\\<open>ccspan\\<close> with restricted type. For analogous reasons as\n     \\<^term>\\<open>cblinfun_apply_code\\<close>, see there for explanations\\<close>"], ["", "lemma span_Set_Monad[code]: \"Span_code (Set_Monad l) = (SPAN (map vec_of_ell2 l))\"\n  \\<comment> \\<open>Code equation for the span of a finite set. (\\<^term>\\<open>Set_Monad\\<close> is a datatype\n     constructor that represents sets as lists in the computation.)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Span_code (Set_Monad l) = SPAN (map vec_of_ell2 l)", "apply (simp add: Span_code_def SPAN_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan (set l) =\n    ccspan\n     (basis_enum_of_vec `\n      Set.filter (\\<lambda>v. dim_vec v = CARD('a)) (vec_of_ell2 ` set l))", "apply (subst Set_filter_unchanged)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> vec_of_ell2 ` set l \\<Longrightarrow> dim_vec x = CARD('a)\n 2. ccspan (set l) = ccspan (basis_enum_of_vec ` vec_of_ell2 ` set l)", "apply (auto simp add: vec_of_ell2_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan (set l) = ccspan (basis_enum_of_vec ` vec_of_ell2 ` set l)", "by (metis (no_types, lifting) ell2_of_vec_def image_image map_idI set_map vec_of_ell2_inverse)"], ["", "text \\<open>This instantiation defines a code equation for equality tests for \\<^type>\\<open>ccsubspace\\<close>.\n      The actual code for equality tests is given below (lemma \\<open>equal_ccsubspace_code\\<close>).\\<close>"], ["", "instantiation ccsubspace :: (onb_enum) equal begin"], ["", "definition [code del]: \"equal_ccsubspace (A::'a ccsubspace) B = (A=B)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, equal_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "unfolding equal_ccsubspace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (x = y) = (x = y)", "by simp"], ["", "end"], ["", "lemma leq_ccsubspace_code[code]:\n  \\<comment> \\<open>Code equation for deciding inclusion of one space in another.\n     Uses the constant \\<^term>\\<open>is_subspace_of_vec_list\\<close> which implements the actual\n     computation by checking for each generator of A whether it is in the\n     span of B (by orthogonal projection onto an orthonormal basis of B\n     which is computed using Gram-Schmidt).\\<close>\n  \"SPAN A \\<le> (SPAN B :: 'a::onb_enum ccsubspace)\n      \\<longleftrightarrow> (let d = length (canonical_basis :: 'a list) in\n          is_subspace_of_vec_list d\n          (filter (\\<lambda>v. dim_vec v = d) A)\n          (filter (\\<lambda>v. dim_vec v = d) B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SPAN A \\<le> SPAN B) =\n    (let d = length canonical_basis\n     in is_subspace_of_vec_list d (filter (\\<lambda>v. dim_vec v = d) A)\n         (filter (\\<lambda>v. dim_vec v = d) B))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SPAN A \\<le> SPAN B) =\n    (let d = length canonical_basis\n     in is_subspace_of_vec_list d (filter (\\<lambda>v. dim_vec v = d) A)\n         (filter (\\<lambda>v. dim_vec v = d) B))", "define d A' B' where \"d = length (canonical_basis :: 'a list)\"\n    and \"A' = filter (\\<lambda>v. dim_vec v = d) A\"\n    and \"B' = filter (\\<lambda>v. dim_vec v = d) B\""], ["proof (state)\nthis:\n  d = length canonical_basis\n  A' = filter (\\<lambda>v. dim_vec v = d) A\n  B' = filter (\\<lambda>v. dim_vec v = d) B\n\ngoal (1 subgoal):\n 1. (SPAN A \\<le> SPAN B) =\n    (let d = length canonical_basis\n     in is_subspace_of_vec_list d (filter (\\<lambda>v. dim_vec v = d) A)\n         (filter (\\<lambda>v. dim_vec v = d) B))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SPAN A \\<le> SPAN B) =\n    (let d = length canonical_basis\n     in is_subspace_of_vec_list d (filter (\\<lambda>v. dim_vec v = d) A)\n         (filter (\\<lambda>v. dim_vec v = d) B))", "unfolding SPAN_def d_def[symmetric] filter_set Let_def\n      A'_def[symmetric] B'_def[symmetric] image_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ccspan (set (map basis_enum_of_vec A'))\n     \\<le> ccspan (set (map basis_enum_of_vec B'))) =\n    is_subspace_of_vec_list d A' B'", "apply (subst ccspan_leq_using_vec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subspace_of_vec_list (length canonical_basis)\n     (map vec_of_basis_enum (map basis_enum_of_vec A'))\n     (map vec_of_basis_enum (map basis_enum_of_vec B')) =\n    is_subspace_of_vec_list d A' B'", "unfolding d_def[symmetric] map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subspace_of_vec_list d\n     (map (\\<lambda>x. vec_of_basis_enum (basis_enum_of_vec x)) A')\n     (map (\\<lambda>x. vec_of_basis_enum (basis_enum_of_vec x)) B') =\n    is_subspace_of_vec_list d A' B'", "apply (subst map_cong[where xs=A', OF refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set A' \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec x) = ?g x\n 2. is_subspace_of_vec_list d (map ?g A')\n     (map (\\<lambda>x. vec_of_basis_enum (basis_enum_of_vec x)) B') =\n    is_subspace_of_vec_list d A' B'", "apply (rule basis_enum_of_vec_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set A' \\<Longrightarrow> dim_vec x = length canonical_basis\n 2. is_subspace_of_vec_list d (map (\\<lambda>x. x) A')\n     (map (\\<lambda>x. vec_of_basis_enum (basis_enum_of_vec x)) B') =\n    is_subspace_of_vec_list d A' B'", "apply (simp add: A'_def d_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_subspace_of_vec_list d (map (\\<lambda>x. x) A')\n     (map (\\<lambda>x. vec_of_basis_enum (basis_enum_of_vec x)) B') =\n    is_subspace_of_vec_list d A' B'", "apply (subst map_cong[where xs=B', OF refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set B' \\<Longrightarrow>\n       vec_of_basis_enum (basis_enum_of_vec x) = ?g3 x\n 2. is_subspace_of_vec_list d (map (\\<lambda>x. x) A') (map ?g3 B') =\n    is_subspace_of_vec_list d A' B'", "apply (rule basis_enum_of_vec_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set B' \\<Longrightarrow> dim_vec x = length canonical_basis\n 2. is_subspace_of_vec_list d (map (\\<lambda>x. x) A')\n     (map (\\<lambda>x. x) B') =\n    is_subspace_of_vec_list d A' B'", "by (simp_all add: B'_def d_def)"], ["proof (state)\nthis:\n  (SPAN A \\<le> SPAN B) =\n  (let d = length canonical_basis\n   in is_subspace_of_vec_list d (filter (\\<lambda>v. dim_vec v = d) A)\n       (filter (\\<lambda>v. dim_vec v = d) B))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma equal_ccsubspace_code[code]:\n  \\<comment> \\<open>Code equation for equality test. By checking mutual inclusion\n      (for which we have code by the preceding code equation).\\<close>\n  \"HOL.equal (A::_ ccsubspace) B = (A\\<le>B \\<and> B\\<le>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal A B = (A \\<le> B \\<and> B \\<le> A)", "unfolding equal_ccsubspace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A = B) = (A \\<le> B \\<and> B \\<le> A)", "by auto"], ["", "lemma apply_cblinfun_code[code]:\n  \\<comment> \\<open>Code equation for applying an operator \\<^term>\\<open>A\\<close> to a subspace. \n      Simply by multiplying each generator with \\<^term>\\<open>A\\<close>\\<close>\n  \"A *\\<^sub>S SPAN S = (let d = length (canonical_basis :: 'a list) in\n         SPAN (map (mult_mat_vec (mat_of_cblinfun A))\n               (filter (\\<lambda>v. dim_vec v = d) S)))\"\n  for A::\"'a::onb_enum \\<Rightarrow>\\<^sub>C\\<^sub>L'b::onb_enum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN S =\n    (let d = length canonical_basis\n     in SPAN\n         (map ((*\\<^sub>v) (mat_of_cblinfun A))\n           (filter (\\<lambda>v. dim_vec v = d) S)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN S =\n    (let d = length canonical_basis\n     in SPAN\n         (map ((*\\<^sub>v) (mat_of_cblinfun A))\n           (filter (\\<lambda>v. dim_vec v = d) S)))", "define dA dB S'\n    where \"dA = length (canonical_basis :: 'a list)\"\n      and \"dB = length (canonical_basis :: 'b list)\"\n      and \"S' = filter (\\<lambda>v. dim_vec v = dA) S\""], ["proof (state)\nthis:\n  dA = length canonical_basis\n  dB = length canonical_basis\n  S' = filter (\\<lambda>v. dim_vec v = dA) S\n\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN S =\n    (let d = length canonical_basis\n     in SPAN\n         (map ((*\\<^sub>v) (mat_of_cblinfun A))\n           (filter (\\<lambda>v. dim_vec v = d) S)))", "have \"cblinfun_image A (SPAN S) = A *\\<^sub>S ccspan (set (map basis_enum_of_vec S'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN S = A *\\<^sub>S ccspan (set (map basis_enum_of_vec S'))", "unfolding SPAN_def dA_def[symmetric] Let_def S'_def filter_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>S\n    ccspan\n     (basis_enum_of_vec ` set (filter (\\<lambda>v. dim_vec v = dA) S)) =\n    A *\\<^sub>S\n    ccspan\n     (set (map basis_enum_of_vec (filter (\\<lambda>v. dim_vec v = dA) S)))", "by simp"], ["proof (state)\nthis:\n  A *\\<^sub>S SPAN S = A *\\<^sub>S ccspan (set (map basis_enum_of_vec S'))\n\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN S =\n    (let d = length canonical_basis\n     in SPAN\n         (map ((*\\<^sub>v) (mat_of_cblinfun A))\n           (filter (\\<lambda>v. dim_vec v = d) S)))", "also"], ["proof (state)\nthis:\n  A *\\<^sub>S SPAN S = A *\\<^sub>S ccspan (set (map basis_enum_of_vec S'))\n\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN S =\n    (let d = length canonical_basis\n     in SPAN\n         (map ((*\\<^sub>v) (mat_of_cblinfun A))\n           (filter (\\<lambda>v. dim_vec v = d) S)))", "have \"\\<dots> = ccspan ((\\<lambda>x. basis_enum_of_vec \n            (mat_of_cblinfun A *\\<^sub>v vec_of_basis_enum (basis_enum_of_vec x :: 'a))) ` set S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>S ccspan (set (map basis_enum_of_vec S')) =\n    ccspan\n     ((\\<lambda>x.\n          basis_enum_of_vec\n           (mat_of_cblinfun A *\\<^sub>v\n            vec_of_basis_enum (basis_enum_of_vec x))) `\n      set S')", "apply (subst cblinfun_apply_ccspan_using_vec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan\n     (basis_enum_of_vec `\n      set (map ((*\\<^sub>v) (mat_of_cblinfun A))\n            (map vec_of_basis_enum (map basis_enum_of_vec S')))) =\n    ccspan\n     ((\\<lambda>x.\n          basis_enum_of_vec\n           (mat_of_cblinfun A *\\<^sub>v\n            vec_of_basis_enum (basis_enum_of_vec x))) `\n      set S')", "by (simp add: image_image)"], ["proof (state)\nthis:\n  A *\\<^sub>S ccspan (set (map basis_enum_of_vec S')) =\n  ccspan\n   ((\\<lambda>x.\n        basis_enum_of_vec\n         (mat_of_cblinfun A *\\<^sub>v\n          vec_of_basis_enum (basis_enum_of_vec x))) `\n    set S')\n\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN S =\n    (let d = length canonical_basis\n     in SPAN\n         (map ((*\\<^sub>v) (mat_of_cblinfun A))\n           (filter (\\<lambda>v. dim_vec v = d) S)))", "also"], ["proof (state)\nthis:\n  A *\\<^sub>S ccspan (set (map basis_enum_of_vec S')) =\n  ccspan\n   ((\\<lambda>x.\n        basis_enum_of_vec\n         (mat_of_cblinfun A *\\<^sub>v\n          vec_of_basis_enum (basis_enum_of_vec x))) `\n    set S')\n\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN S =\n    (let d = length canonical_basis\n     in SPAN\n         (map ((*\\<^sub>v) (mat_of_cblinfun A))\n           (filter (\\<lambda>v. dim_vec v = d) S)))", "have \"\\<dots> = ccspan ((\\<lambda>x. basis_enum_of_vec (mat_of_cblinfun A *\\<^sub>v x)) ` set S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan\n     ((\\<lambda>x.\n          basis_enum_of_vec\n           (mat_of_cblinfun A *\\<^sub>v\n            vec_of_basis_enum (basis_enum_of_vec x))) `\n      set S') =\n    ccspan\n     ((\\<lambda>x. basis_enum_of_vec (mat_of_cblinfun A *\\<^sub>v x)) `\n      set S')", "apply (subst image_cong[OF refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set S' \\<Longrightarrow>\n       basis_enum_of_vec\n        (mat_of_cblinfun A *\\<^sub>v\n         vec_of_basis_enum (basis_enum_of_vec x)) =\n       ?g x\n 2. ccspan (?g ` set S') =\n    ccspan\n     ((\\<lambda>x. basis_enum_of_vec (mat_of_cblinfun A *\\<^sub>v x)) `\n      set S')", "apply (subst basis_enum_of_vec_inverse)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> set S' \\<Longrightarrow> dim_vec x = length canonical_basis\n 2. \\<And>x.\n       x \\<in> set S' \\<Longrightarrow>\n       basis_enum_of_vec (mat_of_cblinfun A *\\<^sub>v x) = ?g2 x x\n 3. ccspan ((\\<lambda>x. ?g2 x x) ` set S') =\n    ccspan\n     ((\\<lambda>x. basis_enum_of_vec (mat_of_cblinfun A *\\<^sub>v x)) `\n      set S')", "by (auto simp add: S'_def dA_def)"], ["proof (state)\nthis:\n  ccspan\n   ((\\<lambda>x.\n        basis_enum_of_vec\n         (mat_of_cblinfun A *\\<^sub>v\n          vec_of_basis_enum (basis_enum_of_vec x))) `\n    set S') =\n  ccspan\n   ((\\<lambda>x. basis_enum_of_vec (mat_of_cblinfun A *\\<^sub>v x)) `\n    set S')\n\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN S =\n    (let d = length canonical_basis\n     in SPAN\n         (map ((*\\<^sub>v) (mat_of_cblinfun A))\n           (filter (\\<lambda>v. dim_vec v = d) S)))", "also"], ["proof (state)\nthis:\n  ccspan\n   ((\\<lambda>x.\n        basis_enum_of_vec\n         (mat_of_cblinfun A *\\<^sub>v\n          vec_of_basis_enum (basis_enum_of_vec x))) `\n    set S') =\n  ccspan\n   ((\\<lambda>x. basis_enum_of_vec (mat_of_cblinfun A *\\<^sub>v x)) `\n    set S')\n\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN S =\n    (let d = length canonical_basis\n     in SPAN\n         (map ((*\\<^sub>v) (mat_of_cblinfun A))\n           (filter (\\<lambda>v. dim_vec v = d) S)))", "have \"\\<dots> = SPAN (map (mult_mat_vec (mat_of_cblinfun A)) S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan\n     ((\\<lambda>x. basis_enum_of_vec (mat_of_cblinfun A *\\<^sub>v x)) `\n      set S') =\n    SPAN (map ((*\\<^sub>v) (mat_of_cblinfun A)) S')", "unfolding SPAN_def dB_def[symmetric] Let_def filter_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan\n     ((\\<lambda>x. basis_enum_of_vec (mat_of_cblinfun A *\\<^sub>v x)) `\n      set S') =\n    ccspan\n     (basis_enum_of_vec `\n      set (filter (\\<lambda>v. dim_vec v = dB)\n            (map ((*\\<^sub>v) (mat_of_cblinfun A)) S')))", "apply (subst filter_True)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set (map ((*\\<^sub>v) (mat_of_cblinfun A)) S').\n       dim_vec x = dB\n 2. ccspan\n     ((\\<lambda>x. basis_enum_of_vec (mat_of_cblinfun A *\\<^sub>v x)) `\n      set S') =\n    ccspan\n     (basis_enum_of_vec ` set (map ((*\\<^sub>v) (mat_of_cblinfun A)) S'))", "by (simp_all add: dB_def mat_of_cblinfun_def image_image)"], ["proof (state)\nthis:\n  ccspan\n   ((\\<lambda>x. basis_enum_of_vec (mat_of_cblinfun A *\\<^sub>v x)) `\n    set S') =\n  SPAN (map ((*\\<^sub>v) (mat_of_cblinfun A)) S')\n\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN S =\n    (let d = length canonical_basis\n     in SPAN\n         (map ((*\\<^sub>v) (mat_of_cblinfun A))\n           (filter (\\<lambda>v. dim_vec v = d) S)))", "finally"], ["proof (chain)\npicking this:\n  A *\\<^sub>S SPAN S = SPAN (map ((*\\<^sub>v) (mat_of_cblinfun A)) S')", "show ?thesis"], ["proof (prove)\nusing this:\n  A *\\<^sub>S SPAN S = SPAN (map ((*\\<^sub>v) (mat_of_cblinfun A)) S')\n\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN S =\n    (let d = length canonical_basis\n     in SPAN\n         (map ((*\\<^sub>v) (mat_of_cblinfun A))\n           (filter (\\<lambda>v. dim_vec v = d) S)))", "unfolding dA_def[symmetric] S'_def[symmetric] Let_def"], ["proof (prove)\nusing this:\n  A *\\<^sub>S SPAN S = SPAN (map ((*\\<^sub>v) (mat_of_cblinfun A)) S')\n\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN S = SPAN (map ((*\\<^sub>v) (mat_of_cblinfun A)) S')", "by simp"], ["proof (state)\nthis:\n  A *\\<^sub>S SPAN S =\n  (let d = length canonical_basis\n   in SPAN\n       (map ((*\\<^sub>v) (mat_of_cblinfun A))\n         (filter (\\<lambda>v. dim_vec v = d) S)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition [code del, code_abbrev]: \"range_cblinfun_code A = A *\\<^sub>S top\"\n  \\<comment> \\<open>A new constant for the special case of applying an operator to the subspace \\<^term>\\<open>top\\<close>\n  (i.e., for computing the range of the operator). We do this to be able to give\n  more specialized code for this specific situation. (The generic code for\n  \\<^term>\\<open>(*\\<^sub>S)\\<close> would work but is less efficient because it involves repeated matrix \n  multiplications. @{attribute code_abbrev} makes sure occurrences of \\<^term>\\<open>A *\\<^sub>S top\\<close>\n  are replaced before starting the actual code generation.\\<close>"], ["", "lemma range_cblinfun_code[code]: \n  \\<comment> \\<open>Code equation for computing the range of an operator \\<^term>\\<open>A\\<close>.\n      Returns the columns of the matrix representation of \\<^term>\\<open>A\\<close>.\\<close>\n  fixes A :: \"'a::onb_enum \\<Rightarrow>\\<^sub>C\\<^sub>L 'b::onb_enum\"\n  shows \"range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "define dA dB\n    where \"dA = length (canonical_basis :: 'a list)\"\n      and \"dB = length (canonical_basis :: 'b list)\""], ["proof (state)\nthis:\n  dA = length canonical_basis\n  dB = length canonical_basis\n\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "have carrier_A: \"mat_of_cblinfun A \\<in> carrier_mat dB dA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_of_cblinfun A \\<in> carrier_mat dB dA", "unfolding mat_of_cblinfun_def dA_def dB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length canonical_basis) (length canonical_basis)\n     (\\<lambda>(i, j).\n         crepresentation (set canonical_basis)\n          (A *\\<^sub>V canonical_basis ! j) (canonical_basis ! i))\n    \\<in> carrier_mat (length canonical_basis) (length canonical_basis)", "by simp"], ["proof (state)\nthis:\n  mat_of_cblinfun A \\<in> carrier_mat dB dA\n\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "have \"range_cblinfun_code A = A *\\<^sub>S SPAN (unit_vecs dA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range_cblinfun_code A = A *\\<^sub>S SPAN (unit_vecs dA)", "unfolding range_cblinfun_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>S \\<top> = A *\\<^sub>S SPAN (unit_vecs dA)", "by (metis dA_def top_ccsubspace_code)"], ["proof (state)\nthis:\n  range_cblinfun_code A = A *\\<^sub>S SPAN (unit_vecs dA)\n\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "also"], ["proof (state)\nthis:\n  range_cblinfun_code A = A *\\<^sub>S SPAN (unit_vecs dA)\n\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "have \"\\<dots> = SPAN (map (\\<lambda>i. mat_of_cblinfun A *\\<^sub>v unit_vec dA i) [0..<dA])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>S SPAN (unit_vecs dA) =\n    SPAN\n     (map (\\<lambda>i. mat_of_cblinfun A *\\<^sub>v unit_vec dA i) [0..<dA])", "unfolding apply_cblinfun_code dA_def[symmetric] Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPAN\n     (map ((*\\<^sub>v) (mat_of_cblinfun A))\n       (filter (\\<lambda>v. dim_vec v = dA) (unit_vecs dA))) =\n    SPAN\n     (map (\\<lambda>i. mat_of_cblinfun A *\\<^sub>v unit_vec dA i) [0..<dA])", "apply (subst filter_True)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set (unit_vecs dA). dim_vec x = dA\n 2. SPAN (map ((*\\<^sub>v) (mat_of_cblinfun A)) (unit_vecs dA)) =\n    SPAN\n     (map (\\<lambda>i. mat_of_cblinfun A *\\<^sub>v unit_vec dA i) [0..<dA])", "apply (meson carrier_vecD subset_code(1) unit_vecs_carrier)"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPAN (map ((*\\<^sub>v) (mat_of_cblinfun A)) (unit_vecs dA)) =\n    SPAN\n     (map (\\<lambda>i. mat_of_cblinfun A *\\<^sub>v unit_vec dA i) [0..<dA])", "by (simp add: unit_vecs_def o_def)"], ["proof (state)\nthis:\n  A *\\<^sub>S SPAN (unit_vecs dA) =\n  SPAN\n   (map (\\<lambda>i. mat_of_cblinfun A *\\<^sub>v unit_vec dA i) [0..<dA])\n\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "also"], ["proof (state)\nthis:\n  A *\\<^sub>S SPAN (unit_vecs dA) =\n  SPAN\n   (map (\\<lambda>i. mat_of_cblinfun A *\\<^sub>v unit_vec dA i) [0..<dA])\n\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "have \"\\<dots> = SPAN (map (\\<lambda>x. mat_of_cblinfun A *\\<^sub>v col (1\\<^sub>m dA) x) [0..<dA])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPAN\n     (map (\\<lambda>i. mat_of_cblinfun A *\\<^sub>v unit_vec dA i)\n       [0..<dA]) =\n    SPAN\n     (map (\\<lambda>x. mat_of_cblinfun A *\\<^sub>v col (1\\<^sub>m dA) x)\n       [0..<dA])", "apply (subst map_cong[OF refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set [0..<dA] \\<Longrightarrow>\n       mat_of_cblinfun A *\\<^sub>v unit_vec dA x = ?g x\n 2. SPAN (map ?g [0..<dA]) =\n    SPAN\n     (map (\\<lambda>x. mat_of_cblinfun A *\\<^sub>v col (1\\<^sub>m dA) x)\n       [0..<dA])", "by auto"], ["proof (state)\nthis:\n  SPAN\n   (map (\\<lambda>i. mat_of_cblinfun A *\\<^sub>v unit_vec dA i) [0..<dA]) =\n  SPAN\n   (map (\\<lambda>x. mat_of_cblinfun A *\\<^sub>v col (1\\<^sub>m dA) x)\n     [0..<dA])\n\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "also"], ["proof (state)\nthis:\n  SPAN\n   (map (\\<lambda>i. mat_of_cblinfun A *\\<^sub>v unit_vec dA i) [0..<dA]) =\n  SPAN\n   (map (\\<lambda>x. mat_of_cblinfun A *\\<^sub>v col (1\\<^sub>m dA) x)\n     [0..<dA])\n\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "have \"\\<dots> = SPAN (map (col (mat_of_cblinfun A * 1\\<^sub>m dA)) [0..<dA])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPAN\n     (map (\\<lambda>x. mat_of_cblinfun A *\\<^sub>v col (1\\<^sub>m dA) x)\n       [0..<dA]) =\n    SPAN (map (col (mat_of_cblinfun A * 1\\<^sub>m dA)) [0..<dA])", "apply (subst map_cong[OF refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set [0..<dA] \\<Longrightarrow>\n       mat_of_cblinfun A *\\<^sub>v col (1\\<^sub>m dA) x = ?g x\n 2. SPAN (map ?g [0..<dA]) =\n    SPAN (map (col (mat_of_cblinfun A * 1\\<^sub>m dA)) [0..<dA])", "apply (subst col_mult2[symmetric])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       x \\<in> set [0..<dA] \\<Longrightarrow>\n       mat_of_cblinfun A \\<in> carrier_mat (?nr2 x) (?n2 x)\n 2. \\<And>x.\n       x \\<in> set [0..<dA] \\<Longrightarrow>\n       1\\<^sub>m dA \\<in> carrier_mat (?n2 x) (?nc2 x)\n 3. \\<And>x. x \\<in> set [0..<dA] \\<Longrightarrow> x < ?nc2 x\n 4. \\<And>x.\n       x \\<in> set [0..<dA] \\<Longrightarrow>\n       col (mat_of_cblinfun A * 1\\<^sub>m dA) x = ?g2 x x\n 5. SPAN (map (\\<lambda>x. ?g2 x x) [0..<dA]) =\n    SPAN (map (col (mat_of_cblinfun A * 1\\<^sub>m dA)) [0..<dA])", "apply (rule carrier_A)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> set [0..<dA] \\<Longrightarrow>\n       1\\<^sub>m dA \\<in> carrier_mat dA (?nc2 x)\n 2. \\<And>x. x \\<in> set [0..<dA] \\<Longrightarrow> x < ?nc2 x\n 3. \\<And>x.\n       x \\<in> set [0..<dA] \\<Longrightarrow>\n       col (mat_of_cblinfun A * 1\\<^sub>m dA) x = ?g2 x x\n 4. SPAN (map (\\<lambda>x. ?g2 x x) [0..<dA]) =\n    SPAN (map (col (mat_of_cblinfun A * 1\\<^sub>m dA)) [0..<dA])", "by auto"], ["proof (state)\nthis:\n  SPAN\n   (map (\\<lambda>x. mat_of_cblinfun A *\\<^sub>v col (1\\<^sub>m dA) x)\n     [0..<dA]) =\n  SPAN (map (col (mat_of_cblinfun A * 1\\<^sub>m dA)) [0..<dA])\n\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "also"], ["proof (state)\nthis:\n  SPAN\n   (map (\\<lambda>x. mat_of_cblinfun A *\\<^sub>v col (1\\<^sub>m dA) x)\n     [0..<dA]) =\n  SPAN (map (col (mat_of_cblinfun A * 1\\<^sub>m dA)) [0..<dA])\n\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "have \"\\<dots> = SPAN (cols (mat_of_cblinfun A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPAN (map (col (mat_of_cblinfun A * 1\\<^sub>m dA)) [0..<dA]) =\n    SPAN (cols (mat_of_cblinfun A))", "unfolding cols_def dA_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPAN (map (col (mat_of_cblinfun A * 1\\<^sub>m dA)) [0..<dA]) =\n    SPAN (map (col (mat_of_cblinfun A)) [0..<dim_col (mat_of_cblinfun A)])", "apply (subst right_mult_one_mat[OF carrier_A])"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPAN (map (col (mat_of_cblinfun A)) [0..<dA]) =\n    SPAN (map (col (mat_of_cblinfun A)) [0..<dim_col (mat_of_cblinfun A)])", "using carrier_A"], ["proof (prove)\nusing this:\n  mat_of_cblinfun A \\<in> carrier_mat dB dA\n\ngoal (1 subgoal):\n 1. SPAN (map (col (mat_of_cblinfun A)) [0..<dA]) =\n    SPAN (map (col (mat_of_cblinfun A)) [0..<dim_col (mat_of_cblinfun A)])", "by blast"], ["proof (state)\nthis:\n  SPAN (map (col (mat_of_cblinfun A * 1\\<^sub>m dA)) [0..<dA]) =\n  SPAN (cols (mat_of_cblinfun A))\n\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "finally"], ["proof (chain)\npicking this:\n  range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "show ?thesis"], ["proof (prove)\nusing this:\n  range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))\n\ngoal (1 subgoal):\n 1. range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))", "by -"], ["proof (state)\nthis:\n  range_cblinfun_code A = SPAN (cols (mat_of_cblinfun A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uminus_Span_code[code]: \"- X = range_cblinfun_code (id_cblinfun - Proj X)\"\n  \\<comment> \\<open>Code equation for the orthogonal complement of a subspace \\<^term>\\<open>X\\<close>. \n      Computed as the range of one minus the projector on \\<^term>\\<open>X\\<close>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. - X = range_cblinfun_code (id_cblinfun - Proj X)", "unfolding range_cblinfun_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - X = (id_cblinfun - Proj X) *\\<^sub>S \\<top>", "by (metis Proj_ortho_compl Proj_range)"], ["", "lemma kernel_code[code]: \n  \\<comment> \\<open>Computes the kernel of an operator \\<^term>\\<open>A\\<close>.\n      This is implemented using the existing functions \n      for transforming a matrix into row echelon form (\\<^term>\\<open>gauss_jordan_single\\<close>)\n      and for computing a basis of the kernel of such a matrix\n      (\\<^term>\\<open>find_base_vectors\\<close>)\\<close>\n  \"kernel A = SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))\" \n  for A::\"('a::onb_enum,'b::onb_enum) cblinfun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "define dA dB Am Ag base\n    where \"dA = length (canonical_basis :: 'a list)\"\n      and \"dB = length (canonical_basis :: 'b list)\"\n      and \"Am = mat_of_cblinfun A\"\n      and \"Ag = gauss_jordan_single Am\"\n      and \"base = find_base_vectors Ag\""], ["proof (state)\nthis:\n  dA = length canonical_basis\n  dB = length canonical_basis\n  Am = mat_of_cblinfun A\n  Ag = gauss_jordan_single Am\n  base = find_base_vectors Ag\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "interpret complex_vec_space dA"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "have Am_carrier: \"Am \\<in> carrier_mat dB dA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Am \\<in> carrier_mat dB dA", "unfolding Am_def mat_of_cblinfun_def dA_def dB_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (length canonical_basis) (length canonical_basis)\n     (\\<lambda>(i, j).\n         crepresentation (set canonical_basis)\n          (A *\\<^sub>V canonical_basis ! j) (canonical_basis ! i))\n    \\<in> carrier_mat (length canonical_basis) (length canonical_basis)", "by simp"], ["proof (state)\nthis:\n  Am \\<in> carrier_mat dB dA\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "have row_echelon: \"row_echelon_form Ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form Ag", "unfolding Ag_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. row_echelon_form (gauss_jordan_single Am)", "using Am_carrier refl"], ["proof (prove)\nusing this:\n  Am \\<in> carrier_mat dB dA\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. row_echelon_form (gauss_jordan_single Am)", "by (rule gauss_jordan_single)"], ["proof (state)\nthis:\n  row_echelon_form Ag\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "have Ag_carrier: \"Ag \\<in> carrier_mat dB dA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ag \\<in> carrier_mat dB dA", "unfolding Ag_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_jordan_single Am \\<in> carrier_mat dB dA", "using Am_carrier refl"], ["proof (prove)\nusing this:\n  Am \\<in> carrier_mat dB dA\n  ?t = ?t\n\ngoal (1 subgoal):\n 1. gauss_jordan_single Am \\<in> carrier_mat dB dA", "by (rule gauss_jordan_single(2))"], ["proof (state)\nthis:\n  Ag \\<in> carrier_mat dB dA\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "have base_carrier: \"set base \\<subseteq> carrier_vec dA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set base \\<subseteq> carrier_vec dA", "unfolding base_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (find_base_vectors Ag) \\<subseteq> carrier_vec dA", "using find_base_vectors(1)[OF row_echelon Ag_carrier]"], ["proof (prove)\nusing this:\n  set (find_base_vectors Ag) \\<subseteq> mat_kernel Ag\n\ngoal (1 subgoal):\n 1. set (find_base_vectors Ag) \\<subseteq> carrier_vec dA", "using Ag_carrier mat_kernel_def"], ["proof (prove)\nusing this:\n  set (find_base_vectors Ag) \\<subseteq> mat_kernel Ag\n  Ag \\<in> carrier_mat dB dA\n  mat_kernel ?A =\n  {v \\<in> carrier_vec (dim_col ?A).\n   ?A *\\<^sub>v v = 0\\<^sub>v (dim_row ?A)}\n\ngoal (1 subgoal):\n 1. set (find_base_vectors Ag) \\<subseteq> carrier_vec dA", "by blast"], ["proof (state)\nthis:\n  set base \\<subseteq> carrier_vec dA\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "interpret k: kernel dB dA Ag"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Kernel.kernel dB dA Ag", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ag \\<in> carrier_mat dB dA", "using Ag_carrier"], ["proof (prove)\nusing this:\n  Ag \\<in> carrier_mat dB dA\n\ngoal (1 subgoal):\n 1. Ag \\<in> carrier_mat dB dA", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "have basis_base: \"kernel.basis dA Ag (set base)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k.basis (set base)", "using row_echelon Ag_carrier"], ["proof (prove)\nusing this:\n  row_echelon_form Ag\n  Ag \\<in> carrier_mat dB dA\n\ngoal (1 subgoal):\n 1. k.basis (set base)", "unfolding base_def"], ["proof (prove)\nusing this:\n  row_echelon_form Ag\n  Ag \\<in> carrier_mat dB dA\n\ngoal (1 subgoal):\n 1. k.basis (set (find_base_vectors Ag))", "by (rule find_base_vectors(3))"], ["proof (state)\nthis:\n  k.basis (set base)\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "have \"space_as_set (SPAN base)\n       = space_as_set (ccspan (basis_enum_of_vec ` set base :: 'a set))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space_as_set (SPAN base) =\n    space_as_set (ccspan (basis_enum_of_vec ` set base))", "unfolding SPAN_def dA_def[symmetric] Let_def filter_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. space_as_set\n     (ccspan\n       (basis_enum_of_vec `\n        set (filter (\\<lambda>v. dim_vec v = dA) base))) =\n    space_as_set (ccspan (basis_enum_of_vec ` set base))", "apply (subst filter_True)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set base. dim_vec x = dA\n 2. space_as_set (ccspan (basis_enum_of_vec ` set base)) =\n    space_as_set (ccspan (basis_enum_of_vec ` set base))", "using base_carrier"], ["proof (prove)\nusing this:\n  set base \\<subseteq> carrier_vec dA\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set base. dim_vec x = dA\n 2. space_as_set (ccspan (basis_enum_of_vec ` set base)) =\n    space_as_set (ccspan (basis_enum_of_vec ` set base))", "by auto"], ["proof (state)\nthis:\n  space_as_set (SPAN base) =\n  space_as_set (ccspan (basis_enum_of_vec ` set base))\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "also"], ["proof (state)\nthis:\n  space_as_set (SPAN base) =\n  space_as_set (ccspan (basis_enum_of_vec ` set base))\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "have \"\\<dots> = cspan (basis_enum_of_vec ` set base)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space_as_set (ccspan (basis_enum_of_vec ` set base)) =\n    cspan (basis_enum_of_vec ` set base)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>base.\n       closure (cspan (basis_enum_of_vec ` set base)) =\n       cspan (basis_enum_of_vec ` set base)", "apply (subst closure_finite_cspan)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>base. finite (basis_enum_of_vec ` set base)\n 2. \\<And>base.\n       cspan (basis_enum_of_vec ` set base) =\n       cspan (basis_enum_of_vec ` set base)", "by simp_all"], ["proof (state)\nthis:\n  space_as_set (ccspan (basis_enum_of_vec ` set base)) =\n  cspan (basis_enum_of_vec ` set base)\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "also"], ["proof (state)\nthis:\n  space_as_set (ccspan (basis_enum_of_vec ` set base)) =\n  cspan (basis_enum_of_vec ` set base)\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "have \"\\<dots> = basis_enum_of_vec ` span (set base)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (basis_enum_of_vec ` set base) =\n    basis_enum_of_vec ` local.span (set base)", "apply (subst basis_enum_of_vec_span)"], ["proof (prove)\ngoal (3 subgoals):\n 1. length canonical_basis = dA\n 2. set base \\<subseteq> carrier_vec dA\n 3. cspan (basis_enum_of_vec ` set base) =\n    cspan (basis_enum_of_vec ` set base)", "using base_carrier dA_def"], ["proof (prove)\nusing this:\n  set base \\<subseteq> carrier_vec dA\n  dA = length canonical_basis\n\ngoal (3 subgoals):\n 1. length canonical_basis = dA\n 2. set base \\<subseteq> carrier_vec dA\n 3. cspan (basis_enum_of_vec ` set base) =\n    cspan (basis_enum_of_vec ` set base)", "by auto"], ["proof (state)\nthis:\n  cspan (basis_enum_of_vec ` set base) =\n  basis_enum_of_vec ` local.span (set base)\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "also"], ["proof (state)\nthis:\n  cspan (basis_enum_of_vec ` set base) =\n  basis_enum_of_vec ` local.span (set base)\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "have \"\\<dots> = basis_enum_of_vec ` mat_kernel Ag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` local.span (set base) =\n    basis_enum_of_vec ` mat_kernel Ag", "using basis_base k.Ker.basis_def k.span_same"], ["proof (prove)\nusing this:\n  k.basis (set base)\n  k.basis ?A =\n  (k.lin_indpt ?A \\<and>\n   k.span ?A = mat_kernel Ag \\<and> ?A \\<subseteq> mat_kernel Ag)\n  ?S \\<subseteq> mat_kernel Ag \\<Longrightarrow> k.span ?S = local.span ?S\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` local.span (set base) =\n    basis_enum_of_vec ` mat_kernel Ag", "by auto"], ["proof (state)\nthis:\n  basis_enum_of_vec ` local.span (set base) =\n  basis_enum_of_vec ` mat_kernel Ag\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "also"], ["proof (state)\nthis:\n  basis_enum_of_vec ` local.span (set base) =\n  basis_enum_of_vec ` mat_kernel Ag\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "have \"\\<dots> = basis_enum_of_vec ` {v \\<in> carrier_vec dA. Ag *\\<^sub>v v = 0\\<^sub>v dB}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec ` mat_kernel Ag =\n    basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Ag *\\<^sub>v v = 0\\<^sub>v dB}", "apply (rule arg_cong[where f=\"\\<lambda>x. basis_enum_of_vec ` x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_kernel Ag = {v \\<in> carrier_vec dA. Ag *\\<^sub>v v = 0\\<^sub>v dB}", "unfolding mat_kernel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> carrier_vec (dim_col Ag).\n     Ag *\\<^sub>v v = 0\\<^sub>v (dim_row Ag)} =\n    {v \\<in> carrier_vec dA. Ag *\\<^sub>v v = 0\\<^sub>v dB}", "using Ag_carrier"], ["proof (prove)\nusing this:\n  Ag \\<in> carrier_mat dB dA\n\ngoal (1 subgoal):\n 1. {v \\<in> carrier_vec (dim_col Ag).\n     Ag *\\<^sub>v v = 0\\<^sub>v (dim_row Ag)} =\n    {v \\<in> carrier_vec dA. Ag *\\<^sub>v v = 0\\<^sub>v dB}", "by simp"], ["proof (state)\nthis:\n  basis_enum_of_vec ` mat_kernel Ag =\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. Ag *\\<^sub>v v = 0\\<^sub>v dB}\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "also"], ["proof (state)\nthis:\n  basis_enum_of_vec ` mat_kernel Ag =\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. Ag *\\<^sub>v v = 0\\<^sub>v dB}\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "have \"\\<dots> = basis_enum_of_vec ` {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Ag *\\<^sub>v v = 0\\<^sub>v dB} =\n    basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB}", "using gauss_jordan_single(1)[OF Am_carrier Ag_def[symmetric]]"], ["proof (prove)\nusing this:\n  ?x \\<in> carrier_vec dA \\<Longrightarrow>\n  (Am *\\<^sub>v ?x = 0\\<^sub>v dB) = (Ag *\\<^sub>v ?x = 0\\<^sub>v dB)\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Ag *\\<^sub>v v = 0\\<^sub>v dB} =\n    basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB}", "by auto"], ["proof (state)\nthis:\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. Ag *\\<^sub>v v = 0\\<^sub>v dB} =\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB}\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "also"], ["proof (state)\nthis:\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. Ag *\\<^sub>v v = 0\\<^sub>v dB} =\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB}\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "have \"\\<dots> = {w. A *\\<^sub>V w = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n    {w. A *\\<^sub>V w = (0::'b)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n    {w. A *\\<^sub>V w = (0::'b)}", "have \"basis_enum_of_vec ` {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB}\n        = basis_enum_of_vec ` {v \\<in> carrier_vec dA. A *\\<^sub>V basis_enum_of_vec v = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n    basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. A *\\<^sub>V basis_enum_of_vec v = (0::'b)}", "apply (rule arg_cong[where f=\"\\<lambda>t. basis_enum_of_vec ` t\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n    {v \\<in> carrier_vec dA. A *\\<^sub>V basis_enum_of_vec v = (0::'b)}", "apply (rule Collect_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       (v \\<in> carrier_vec dA \\<and> Am *\\<^sub>v v = 0\\<^sub>v dB) =\n       (v \\<in> carrier_vec dA \\<and>\n        A *\\<^sub>V basis_enum_of_vec v = (0::'b))", "apply (simp add: Am_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       (v \\<in> carrier_vec dA \\<and>\n        mat_of_cblinfun A *\\<^sub>v v = 0\\<^sub>v dB) =\n       (v \\<in> carrier_vec dA \\<and>\n        A *\\<^sub>V basis_enum_of_vec v = (0::'b))", "by (metis Am_carrier Am_def carrier_matD(2) carrier_vecD dB_def mat_carrier \n          mat_of_cblinfun_def mat_of_cblinfun_cblinfun_apply vec_of_basis_enum_inverse \n          basis_enum_of_vec_inverse vec_of_basis_enum_zero)"], ["proof (state)\nthis:\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. A *\\<^sub>V basis_enum_of_vec v = (0::'b)}\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n    {w. A *\\<^sub>V w = (0::'b)}", "also"], ["proof (state)\nthis:\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. A *\\<^sub>V basis_enum_of_vec v = (0::'b)}\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n    {w. A *\\<^sub>V w = (0::'b)}", "have \"\\<dots> = {w \\<in> basis_enum_of_vec ` carrier_vec dA. A *\\<^sub>V w = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. A *\\<^sub>V basis_enum_of_vec v = (0::'b)} =\n    {w \\<in> basis_enum_of_vec ` carrier_vec dA. A *\\<^sub>V w = (0::'b)}", "apply (subst Compr_image_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> basis_enum_of_vec ` carrier_vec dA. A *\\<^sub>V x = (0::'b)} =\n    {w \\<in> basis_enum_of_vec ` carrier_vec dA. A *\\<^sub>V w = (0::'b)}", "by simp"], ["proof (state)\nthis:\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. A *\\<^sub>V basis_enum_of_vec v = (0::'b)} =\n  {w \\<in> basis_enum_of_vec ` carrier_vec dA. A *\\<^sub>V w = (0::'b)}\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n    {w. A *\\<^sub>V w = (0::'b)}", "also"], ["proof (state)\nthis:\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. A *\\<^sub>V basis_enum_of_vec v = (0::'b)} =\n  {w \\<in> basis_enum_of_vec ` carrier_vec dA. A *\\<^sub>V w = (0::'b)}\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n    {w. A *\\<^sub>V w = (0::'b)}", "have \"\\<dots> = {w. A *\\<^sub>V w = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {w \\<in> basis_enum_of_vec ` carrier_vec dA. A *\\<^sub>V w = (0::'b)} =\n    {w. A *\\<^sub>V w = (0::'b)}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       A *\\<^sub>V x = (0::'b) \\<Longrightarrow>\n       x \\<in> basis_enum_of_vec ` carrier_vec dA", "by (metis (no_types, lifting) Am_carrier Am_def carrier_matD(2) carrier_vec_dim_vec dim_vec_of_basis_enum' image_iff mat_carrier mat_of_cblinfun_def vec_of_basis_enum_inverse)"], ["proof (state)\nthis:\n  {w \\<in> basis_enum_of_vec ` carrier_vec dA. A *\\<^sub>V w = (0::'b)} =\n  {w. A *\\<^sub>V w = (0::'b)}\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n    {w. A *\\<^sub>V w = (0::'b)}", "finally"], ["proof (chain)\npicking this:\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n  {w. A *\\<^sub>V w = (0::'b)}", "show ?thesis"], ["proof (prove)\nusing this:\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n  {w. A *\\<^sub>V w = (0::'b)}\n\ngoal (1 subgoal):\n 1. basis_enum_of_vec `\n    {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n    {w. A *\\<^sub>V w = (0::'b)}", "by -"], ["proof (state)\nthis:\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n  {w. A *\\<^sub>V w = (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n  {w. A *\\<^sub>V w = (0::'b)}\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "also"], ["proof (state)\nthis:\n  basis_enum_of_vec `\n  {v \\<in> carrier_vec dA. Am *\\<^sub>v v = 0\\<^sub>v dB} =\n  {w. A *\\<^sub>V w = (0::'b)}\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "have \"\\<dots> = space_as_set (kernel A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {w. A *\\<^sub>V w = (0::'b)} = space_as_set (kernel A)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       bounded_clinear A \\<Longrightarrow> {w. A w = (0::'b)} = A -` {0::'b}", "by auto"], ["proof (state)\nthis:\n  {w. A *\\<^sub>V w = (0::'b)} = space_as_set (kernel A)\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "finally"], ["proof (chain)\npicking this:\n  space_as_set (SPAN base) = space_as_set (kernel A)", "have \"SPAN base = kernel A\""], ["proof (prove)\nusing this:\n  space_as_set (SPAN base) = space_as_set (kernel A)\n\ngoal (1 subgoal):\n 1. SPAN base = kernel A", "by (simp add: space_as_set_inject)"], ["proof (state)\nthis:\n  SPAN base = kernel A\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "then"], ["proof (chain)\npicking this:\n  SPAN base = kernel A", "show ?thesis"], ["proof (prove)\nusing this:\n  SPAN base = kernel A\n\ngoal (1 subgoal):\n 1. kernel A =\n    SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))", "by (simp add: base_def Ag_def Am_def)"], ["proof (state)\nthis:\n  kernel A =\n  SPAN (find_base_vectors (gauss_jordan_single (mat_of_cblinfun A)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_ccsubspace_code[code]: \n  \\<comment> \\<open>Code equation for intersection of subspaces.\n     Reduced to orthogonal complement and sum of subspaces\n     for which we already have code equations.\\<close>\n  \"(A::'a::onb_enum ccsubspace) \\<sqinter> B = - (- A \\<squnion> - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<sqinter> B = - (- A \\<squnion> - B)", "by (subst ortho_involution[symmetric], subst compl_inf, simp)"], ["", "lemma Sup_ccsubspace_code[code]:\n  \\<comment> \\<open>Supremum (sum) of a set of subspaces. Implemented\n     by repeated pairwise sum.\\<close>\n  \"Sup (Set_Monad l :: 'a::onb_enum ccsubspace set) = fold sup l bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (Set_Monad l) = fold (\\<squnion>) l \\<bottom>", "unfolding Set_Monad_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> (set l) = fold (\\<squnion>) l \\<bottom>", "by (simp add: Sup_set_fold)"], ["", "lemma Inf_ccsubspace_code[code]: \n  \\<comment> \\<open>Infimum (intersection) of a set of subspaces. \n      Implemented by the orthogonal complement of the supremum.\\<close>\n  \"Inf (Set_Monad l :: 'a::onb_enum ccsubspace set)\n  = - Sup (Set_Monad (map uminus l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (Set_Monad l) = - \\<Squnion> (Set_Monad (map uminus l))", "unfolding Set_Monad_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (set l) = - \\<Squnion> (set (map uminus l))", "apply (induction l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Sqinter> (set []) = - \\<Squnion> (set (map uminus []))\n 2. \\<And>a l.\n       \\<Sqinter> (set l) =\n       - \\<Squnion> (set (map uminus l)) \\<Longrightarrow>\n       \\<Sqinter> (set (a # l)) = - \\<Squnion> (set (map uminus (a # l)))", "by auto"], ["", "subsection \\<open>Miscellanea\\<close>"], ["", "text \\<open>This is a hack to circumvent a bug in the code generation. The automatically\n  generated code for the class \\<^class>\\<open>uniformity\\<close> has a type that is different from\n  what the generated code later assumes, leading to compilation errors (in ML at least)\n  in any expression involving \\<^typ>\\<open>_ ell2\\<close> (even if the constant \\<^const>\\<open>uniformity\\<close> is\n  not actually used).\n  \n  The fragment below circumvents this by forcing Isabelle to use the right type.\n  (The logically useless fragment \"\\<open>let x = ((=)::'a\\<Rightarrow>_\\<Rightarrow>_)\\<close>\" achieves this.)\\<close>"], ["", "lemma uniformity_ell2_code[code]: \"(uniformity :: ('a ell2 * _) filter) = Filter.abstract_filter (%_.\n    Code.abort STR ''no uniformity'' (%_. \n    let x = ((=)::'a\\<Rightarrow>_\\<Rightarrow>_) in uniformity))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uniformity =\n    Filter.abstract_filter\n     (\\<lambda>_.\n         Code.abort STR ''no uniformity''\n          (\\<lambda>_. let x = (=) in uniformity))", "by simp"], ["", "text \\<open>Code equation for \\<^term>\\<open>UNIV\\<close>. \n  It is now implemented via type class \\<^class>\\<open>enum\\<close> \n  (which provides a list of all values).\\<close>"], ["", "declare [[code drop: UNIV]]"], ["", "declare enum_class.UNIV_enum[code]"], ["", "text \\<open>Setup for code generation involving sets of \\<^type>\\<open>ell2\\<close>/\\<^type>\\<open>ccsubspace\\<close>.\n  This configures to use lists for representing sets in code.\\<close>"], ["", "derive (eq) ceq ccsubspace"], ["", "derive (no) ccompare ccsubspace"], ["", "derive (monad) set_impl ccsubspace"], ["", "derive (eq) ceq ell2"], ["", "derive (no) ccompare ell2"], ["", "derive (monad) set_impl ell2"], ["", "unbundle no_jnf_notation"], ["", "unbundle no_cblinfun_notation"], ["", "end"]]}