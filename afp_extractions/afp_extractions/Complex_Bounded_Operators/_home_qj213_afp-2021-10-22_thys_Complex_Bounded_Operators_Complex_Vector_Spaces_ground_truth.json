{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators/Complex_Vector_Spaces.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Bounded_Operators", "problem_names": ["lemma (in scaleC) scaleC_real: assumes \"r\\<in>\\<real>\" shows \"r *\\<^sub>C x = Re r *\\<^sub>R x\"", "lemma of_complex_of_real_eq [simp]: \"of_complex (of_real n) = of_real n\"", "lemma Complexs_of_real [simp]: \"of_real r \\<in> \\<complex>\"", "lemma Reals_in_Complexs: \"\\<real> \\<subseteq> \\<complex>\"", "lemma (in clinear) \"linear f\"", "lemma (in bounded_clinear) bounded_linear: \"bounded_linear f\"", "lemma clinear_times: \"clinear (\\<lambda>x. c * x)\"\n  for c :: \"'a::complex_algebra\"", "lemma (in clinear) linear:\n  shows \\<open>linear f\\<close>", "lemma bounded_clinearI:\n  assumes \\<open>\\<And>b1 b2. f (b1 + b2) = f b1 + f b2\\<close>\n  assumes \\<open>\\<And>r b. f (r *\\<^sub>C b) = r *\\<^sub>C f b\\<close>\n  assumes \\<open>\\<forall>x. norm (f x) \\<le> norm x * K\\<close>\n  shows \"bounded_clinear f\"", "lemma bounded_clinear_id[simp]: \\<open>bounded_clinear id\\<close>", "lemma cbilinear_add_left:\n  assumes \\<open>cbilinear f\\<close>\n  shows \\<open>f (a + b) c = f a c + f b c\\<close>", "lemma cbilinear_add_right:\n  assumes \\<open>cbilinear f\\<close>\n  shows \\<open>f a (b + c) = f a b + f a c\\<close>", "lemma cbilinear_times:\n  fixes g' :: \\<open>'a::complex_vector \\<Rightarrow> complex\\<close> and g :: \\<open>'b::complex_vector \\<Rightarrow> complex\\<close>\n  assumes \\<open>\\<And> x y. h x y = (g' x)*(g y)\\<close> and \\<open>clinear g\\<close> and \\<open>clinear g'\\<close>\n  shows \\<open>cbilinear h\\<close>", "lemma csubspace_is_subspace: \"csubspace A \\<Longrightarrow> subspace A\"", "lemma span_subset_cspan: \"span A \\<subseteq> cspan A\"", "lemma cindependent_implies_independent: \n  assumes \"cindependent (S::'a::complex_vector set)\"\n  shows \"independent S\"", "lemma cspan_singleton: \"cspan {x} = {\\<alpha> *\\<^sub>C x| \\<alpha>. True}\"", "lemma cspan_as_span:\n  \"cspan (B::'a::complex_vector set) = span (B \\<union> scaleC \\<i> ` B)\"", "lemma isomorphic_equal_cdim:\n  assumes lin_f: \\<open>clinear f\\<close>\n  assumes inj_f: \\<open>inj_on f (cspan S)\\<close>\n  assumes im_S: \\<open>f ` S = T\\<close>\n  shows \\<open>cdim S = cdim T\\<close>", "lemma cindependent_inter_scaleC_cindependent:\n  assumes a1: \"cindependent (B::'a::complex_vector set)\" and a3: \"c \\<noteq> 1\"\n  shows \"B \\<inter> (*\\<^sub>C) c ` B = {}\"", "lemma real_independent_from_complex_independent:\n  assumes \"cindependent (B::'a::complex_vector set)\"\n  defines \"B' == ((*\\<^sub>C) \\<i> ` B)\"\n  shows \"independent (B \\<union> B')\"", "lemma crepresentation_from_representation: \n  assumes a1: \"cindependent B\" and a2: \"b \\<in> B\" and a3: \"finite B\"\n  shows \"crepresentation B \\<psi> b = (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b)\n                           + \\<i> *\\<^sub>C (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> (\\<i> *\\<^sub>C b))\"", "lemma CARD_1_vec_0[simp]: \\<open>(\\<psi> :: _ ::{complex_vector,CARD_1}) = 0\\<close>", "lemma scaleC_cindependent:\n  assumes a1: \"cindependent (B::'a::complex_vector set)\" and a3: \"c \\<noteq> 0\"\n  shows \"cindependent ((*\\<^sub>C) c ` B)\"", "lemma antilinear_imp_scaleC:\n  fixes D :: \"complex \\<Rightarrow> 'a::complex_vector\"\n  assumes \"antilinear D\"\n  obtains d where \"D = (\\<lambda>x. cnj x *\\<^sub>C d)\"", "lemma antilinearI:\n  assumes \"\\<And>x y. f (x + y) = f x + f y\"\n    and \"\\<And>c x. f (c *\\<^sub>C x) = cnj c *\\<^sub>C f x\"\n  shows \"antilinear f\"", "lemma antilinear_o_antilinear: \"antilinear f \\<Longrightarrow> antilinear g \\<Longrightarrow> clinear (g o f)\"", "lemma clinear_o_antilinear: \"antilinear f \\<Longrightarrow> clinear g \\<Longrightarrow> antilinear (g o f)\"", "lemma antilinear_o_clinear: \"clinear f \\<Longrightarrow> antilinear g \\<Longrightarrow> antilinear (g o f)\"", "lemma bounded_antilinearI:\n  assumes \\<open>\\<And>b1 b2. f (b1 + b2) = f b1 + f b2\\<close>\n  assumes \\<open>\\<And>r b. f (r *\\<^sub>C b) = cnj r *\\<^sub>C f b\\<close>\n  assumes \\<open>\\<forall>x. norm (f x) \\<le> norm x * K\\<close>\n  shows \"bounded_antilinear f\"", "lemma (in bounded_antilinear) bounded_linear: \"bounded_linear f\"", "lemma (in bounded_antilinear) antilinear: \"antilinear f\"", "lemma bounded_antilinear_intro:\n  assumes \"\\<And>x y. f (x + y) = f x + f y\"\n    and \"\\<And>r x. f (scaleC r x) = scaleC (cnj r) (f x)\"\n    and \"\\<And>x. norm (f x) \\<le> norm x * K\"\n  shows \"bounded_antilinear f\"", "lemma bounded_antilinear_0[simp]: \\<open>bounded_antilinear (\\<lambda>_. 0)\\<close>", "lemma cnj_bounded_antilinear[simp]: \"bounded_antilinear cnj\"", "lemma bounded_antilinear_o_bounded_antilinear:\n  assumes \"bounded_antilinear f\"\n    and \"bounded_antilinear g\"\n  shows \"bounded_clinear (\\<lambda>x. f (g x))\"", "lemma bounded_antilinear_o_bounded_clinear:\n  assumes \"bounded_antilinear f\"\n    and \"bounded_clinear g\"\n  shows \"bounded_antilinear (\\<lambda>x. f (g x))\"", "lemma bounded_clinear_o_bounded_antilinear:\n  assumes \"bounded_clinear f\"\n    and \"bounded_antilinear g\"\n  shows \"bounded_antilinear (\\<lambda>x. f (g x))\"", "lemma bij_clinear_imp_inv_clinear: \"clinear (inv f)\"\n  if a1: \"clinear f\" and a2: \"bij f\"", "lemma (in bounded_sesquilinear) bounded_bilinear[simp]: \"bounded_bilinear prod\"", "lemma (in bounded_sesquilinear) bounded_antilinear_left: \"bounded_antilinear (\\<lambda>a. prod a b)\"", "lemma (in bounded_sesquilinear) bounded_clinear_right: \"bounded_clinear (\\<lambda>b. prod a b)\"", "lemma (in bounded_sesquilinear) comp1:\n  assumes \\<open>bounded_clinear g\\<close>\n  shows \\<open>bounded_sesquilinear (\\<lambda>x. prod (g x))\\<close>", "lemma (in bounded_sesquilinear) comp2:\n  assumes \\<open>bounded_clinear g\\<close>\n  shows \\<open>bounded_sesquilinear (\\<lambda>x y. prod x (g y))\\<close>", "lemma (in bounded_sesquilinear) comp: \"bounded_clinear f \\<Longrightarrow> bounded_clinear g \\<Longrightarrow> bounded_sesquilinear (\\<lambda>x y. prod (f x) (g y))\"", "lemma bounded_clinear_const_scaleR:\n  fixes c :: real\n  assumes \\<open>bounded_clinear f\\<close>\n  shows \\<open>bounded_clinear (\\<lambda> x. c *\\<^sub>R f x )\\<close>", "lemma bounded_linear_bounded_clinear:\n  \\<open>bounded_linear A \\<Longrightarrow> \\<forall>c x. A (c *\\<^sub>C x) = c *\\<^sub>C A x \\<Longrightarrow> bounded_clinear A\\<close>", "lemma comp_bounded_clinear:\n  fixes  A :: \\<open>'b::complex_normed_vector \\<Rightarrow> 'c::complex_normed_vector\\<close> \n    and B :: \\<open>'a::complex_normed_vector \\<Rightarrow> 'b\\<close>\n  assumes \\<open>bounded_clinear A\\<close> and \\<open>bounded_clinear B\\<close>\n  shows \\<open>bounded_clinear (A \\<circ> B)\\<close>", "lemmas isCont_scaleC [simp] =\n  bounded_bilinear.isCont [OF bounded_cbilinear_scaleC[THEN bounded_cbilinear.bounded_bilinear]]", "lemmas sums_of_complex = bounded_linear.sums [OF bounded_clinear_of_complex[THEN bounded_clinear.bounded_linear]]", "lemmas summable_of_complex = bounded_linear.summable [OF bounded_clinear_of_complex[THEN bounded_clinear.bounded_linear]]", "lemmas suminf_of_complex = bounded_linear.suminf [OF bounded_clinear_of_complex[THEN bounded_clinear.bounded_linear]]", "lemmas sums_scaleC_left = bounded_linear.sums[OF bounded_clinear_scaleC_left[THEN bounded_clinear.bounded_linear]]", "lemmas summable_scaleC_left = bounded_linear.summable[OF bounded_clinear_scaleC_left[THEN bounded_clinear.bounded_linear]]", "lemmas suminf_scaleC_left = bounded_linear.suminf[OF bounded_clinear_scaleC_left[THEN bounded_clinear.bounded_linear]]", "lemmas sums_scaleC_right = bounded_linear.sums[OF bounded_clinear_scaleC_right[THEN bounded_clinear.bounded_linear]]", "lemmas summable_scaleC_right = bounded_linear.summable[OF bounded_clinear_scaleC_right[THEN bounded_clinear.bounded_linear]]", "lemmas suminf_scaleC_right = bounded_linear.suminf[OF bounded_clinear_scaleC_right[THEN bounded_clinear.bounded_linear]]", "lemma closed_scaleC: \n  fixes S::\\<open>'a::complex_normed_vector set\\<close> and a :: complex\n  assumes \\<open>closed S\\<close>\n  shows \\<open>closed ((*\\<^sub>C) a ` S)\\<close>", "lemma closure_scaleC: \n  fixes S::\\<open>'a::complex_normed_vector set\\<close>\n  shows \\<open>closure ((*\\<^sub>C) a ` S) = (*\\<^sub>C) a ` closure S\\<close>", "lemma onorm_scalarC:\n  fixes f :: \\<open>'a::complex_normed_vector \\<Rightarrow> 'b::complex_normed_vector\\<close>\n  assumes a1: \\<open>bounded_clinear f\\<close>\n  shows  \\<open>onorm (\\<lambda> x. r *\\<^sub>C (f x)) = (cmod r) * onorm f\\<close>", "lemma onorm_scaleC_left_lemma:\n  fixes f :: \"'a::complex_normed_vector\"\n  assumes r: \"bounded_clinear r\"\n  shows \"onorm (\\<lambda>x. r x *\\<^sub>C f) \\<le> onorm r * norm f\"", "lemma onorm_scaleC_left:\n  fixes f :: \"'a::complex_normed_vector\"\n  assumes f: \"bounded_clinear r\"\n  shows \"onorm (\\<lambda>x. r x *\\<^sub>C f) = onorm r * norm f\"", "lemma vector_finitely_spanned:\n  assumes \\<open>z \\<in> cspan T\\<close>\n  shows \\<open>\\<exists> S. finite S \\<and> S \\<subseteq> T \\<and> z \\<in> cspan S\\<close>", "lemma cdim_UNIV_basis_enum[simp]: \\<open>cdim (UNIV::'a::basis_enum set) = length (canonical_basis::'a list)\\<close>", "lemma finite_basis: \"\\<exists>basis::'a::cfinite_dim set. finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV\"", "lemma cindependent_cfinite_dim_finite:\n  assumes \\<open>cindependent (S::'a::cfinite_dim set)\\<close>\n  shows \\<open>finite S\\<close>", "lemma cfinite_dim_finite_subspace_basis:\n  assumes \\<open>csubspace X\\<close>\n  shows \"\\<exists>basis::'a::cfinite_dim set. finite basis \\<and> cindependent basis \\<and> cspan basis = X\"", "lemma finite_span_complete_aux:\n  fixes b :: \"'b::real_normed_vector\" and B :: \"'b set\"\n    and  rep :: \"'basis::finite \\<Rightarrow> 'b\" and abs :: \"'b \\<Rightarrow> 'basis\"\n  assumes t: \"type_definition rep abs B\"\n    and t1: \"finite B\" and t2: \"b\\<in>B\" and t3: \"independent B\"\n  shows \"\\<exists>D>0. \\<forall>\\<psi>. norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\"\n    and \"complete (span B)\"", "lemma finite_span_complete[simp]:\n  fixes A :: \"'a::real_normed_vector set\"\n  assumes \"finite A\"\n  shows \"complete (span A)\"", "lemma finite_span_representation_bounded:\n  fixes B :: \"'a::real_normed_vector set\"\n  assumes \"finite B\" and \"independent B\"\n  shows \"\\<exists>D>0. \\<forall>\\<psi> b. abs (representation B \\<psi> b) \\<le> norm \\<psi> * D\"", "lemma finite_cspan_complete[simp]: \n  fixes B :: \"'a::complex_normed_vector set\"\n  assumes \"finite B\"\n  shows \"complete (cspan B)\"", "lemma finite_span_closed[simp]:\n  fixes B :: \"'a::real_normed_vector set\"\n  assumes \"finite B\"\n  shows \"closed (real_vector.span B)\"", "lemma finite_cspan_closed[simp]:\n  fixes S::\\<open>'a::complex_normed_vector set\\<close>\n  assumes a1: \\<open>finite S\\<close>\n  shows \\<open>closed (cspan S)\\<close>", "lemma closure_finite_cspan:\n  fixes T::\\<open>'a::complex_normed_vector set\\<close>\n  assumes \\<open>finite T\\<close>\n  shows \\<open>closure (cspan T)  = cspan T\\<close>", "lemma finite_cspan_crepresentation_bounded:\n  fixes B :: \"'a::complex_normed_vector set\"\n  assumes a1: \"finite B\" and a2: \"cindependent B\"\n  shows \"\\<exists>D>0. \\<forall>\\<psi> b. norm (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\"", "lemma bounded_clinear_finite_dim[simp]:\n  fixes f :: \\<open>'a::{cfinite_dim,complex_normed_vector} \\<Rightarrow> 'b::complex_normed_vector\\<close>\n  assumes \\<open>clinear f\\<close>\n  shows \\<open>bounded_clinear f\\<close>", "lemma csubspace_INF[simp]: \"(\\<And>x. x \\<in> A \\<Longrightarrow> csubspace x) \\<Longrightarrow> csubspace (\\<Inter>A)\"", "lemma closure_is_csubspace[simp]:\n  fixes A::\"('a::complex_normed_vector) set\"\n  assumes \\<open>csubspace A\\<close>\n  shows \\<open>csubspace (closure A)\\<close>", "lemma csubspace_set_plus:\n  assumes \\<open>csubspace A\\<close> and \\<open>csubspace B\\<close>\n  shows \\<open>csubspace (A + B)\\<close>", "lemma closed_csubspace_0[simp]:\n  \"closed_csubspace ({0} :: ('a::{complex_vector,t1_space}) set)\"", "lemma closed_csubspace_UNIV[simp]: \"closed_csubspace (UNIV::('a::{complex_vector,topological_space}) set)\"", "lemma closed_csubspace_inter[simp]:\n  assumes \"closed_csubspace A\" and \"closed_csubspace B\"\n  shows \"closed_csubspace (A\\<inter>B)\"", "lemma closed_csubspace_INF[simp]:\n  assumes a1: \"\\<forall>A\\<in>\\<A>. closed_csubspace A\"\n  shows \"closed_csubspace (\\<Inter>\\<A>)\"", "lemma csubspace_space_as_set[simp]: \\<open>csubspace (space_as_set S)\\<close>", "lemma zero_cblinfun_image[simp]: \"0 *\\<^sub>C S = bot\" for S :: \"_ ccsubspace\"", "lemma csubspace_scaleC_invariant: \n  fixes a S\n  assumes \\<open>a \\<noteq> 0\\<close> and \\<open>csubspace S\\<close>\n  shows \\<open>(*\\<^sub>C) a ` S = S\\<close>", "lemma ccsubspace_scaleC_invariant[simp]: \"a \\<noteq> 0 \\<Longrightarrow> a *\\<^sub>C S = S\" for S :: \"_ ccsubspace\"", "lemma ccsubspace_top_not_bot[simp]: \n  \"(top::'a::{complex_vector,t1_space,not_singleton} ccsubspace) \\<noteq> bot\"", "lemma ccsubspace_bot_not_top[simp]:\n  \"(bot::'a::{complex_vector,t1_space,not_singleton} ccsubspace) \\<noteq> top\"", "lemma ccspan_canonical_basis[simp]: \"ccspan (set canonical_basis) = top\"", "lemma ccspan_Inf_def: \\<open>ccspan A = Inf {S. A \\<subseteq> space_as_set S}\\<close>\n  for A::\\<open>('a::cbanach) set\\<close>", "lemma cspan_singleton_scaleC[simp]: \"(a::complex)\\<noteq>0 \\<Longrightarrow> cspan { a *\\<^sub>C \\<psi> } = cspan {\\<psi>}\"\n  for \\<psi>::\"'a::complex_vector\"", "lemma closure_is_closed_csubspace[simp]:\n  fixes S::\\<open>'a::complex_normed_vector set\\<close>\n  assumes \\<open>csubspace S\\<close>\n  shows \\<open>closed_csubspace (closure S)\\<close>", "lemma ccspan_singleton_scaleC[simp]: \"(a::complex)\\<noteq>0 \\<Longrightarrow> ccspan {a *\\<^sub>C \\<psi>} = ccspan {\\<psi>}\"", "lemma clinear_continuous_at:\n  assumes \\<open>bounded_clinear f\\<close> \n  shows \\<open>isCont f x\\<close>", "lemma clinear_continuous_within:\n  assumes \\<open>bounded_clinear f\\<close> \n  shows \\<open>continuous (at x within s) f\\<close>", "lemma antilinear_continuous_at:\n  assumes \\<open>bounded_antilinear f\\<close> \n  shows \\<open>isCont f x\\<close>", "lemma antilinear_continuous_within:\n  assumes \\<open>bounded_antilinear f\\<close> \n  shows \\<open>continuous (at x within s) f\\<close>", "lemma bounded_clinear_eq_on:\n  fixes A B :: \"'a::complex_normed_vector \\<Rightarrow> 'b::complex_normed_vector\"\n  assumes \\<open>bounded_clinear A\\<close> and \\<open>bounded_clinear B\\<close> and\n    eq: \\<open>\\<And>x. x \\<in> G \\<Longrightarrow> A x = B x\\<close> and t: \\<open>t \\<in> closure (cspan G)\\<close>\n  shows \\<open>A t = B t\\<close>", "lemma ccspan_leqI:\n  assumes \\<open>M \\<subseteq> space_as_set S\\<close>\n  shows \\<open>ccspan M \\<le> S\\<close>", "lemma ccspan_mono:\n  assumes \\<open>A \\<subseteq> B\\<close>\n  shows \\<open>ccspan A \\<le> ccspan B\\<close>", "lemma bounded_sesquilinear_add:\n  \\<open>bounded_sesquilinear (\\<lambda> x y. A x y + B x y)\\<close> if \\<open>bounded_sesquilinear A\\<close> and \\<open>bounded_sesquilinear B\\<close>", "lemma bounded_sesquilinear_uminus:\n  \\<open>bounded_sesquilinear (\\<lambda> x y. - A x y)\\<close> if \\<open>bounded_sesquilinear A\\<close>", "lemma bounded_sesquilinear_diff:\n  \\<open>bounded_sesquilinear (\\<lambda> x y. A x y - B x y)\\<close> if \\<open>bounded_sesquilinear A\\<close> and \\<open>bounded_sesquilinear B\\<close>", "lemma ccsubspace_leI:\n  assumes t1: \"space_as_set A \\<subseteq> space_as_set B\"\n  shows \"A \\<le> B\"", "lemma ccspan_of_empty[simp]: \"ccspan {} = bot\"", "lemma space_as_set_inf[simp]: \"space_as_set (A \\<sqinter> B) = space_as_set A \\<inter> space_as_set B\"", "lemma zero_ccsubspace_transfer[transfer_rule]: \\<open>pcr_ccsubspace (=) {0} 0\\<close>", "lemma closed_sum_comm: \\<open>A +\\<^sub>M B = B +\\<^sub>M A\\<close> for A B :: \"_::ab_semigroup_add\"", "lemma closed_sum_left_subset: \\<open>0 \\<in> B \\<Longrightarrow> A \\<subseteq> A +\\<^sub>M B\\<close> for A B :: \"_::monoid_add\"", "lemma closed_sum_right_subset: \\<open>0 \\<in> A \\<Longrightarrow> B \\<subseteq> A +\\<^sub>M B\\<close> for A B :: \"_::monoid_add\"", "lemma finite_cspan_closed_csubspace:\n  assumes \"finite (S::'a::complex_normed_vector set)\"\n  shows \"closed_csubspace (cspan S)\"", "lemma closed_sum_is_sup:\n  fixes A B C:: \\<open>('a::{complex_vector,topological_space}) set\\<close>\n  assumes \\<open>closed_csubspace C\\<close>\n  assumes \\<open>A \\<subseteq> C\\<close> and \\<open>B \\<subseteq> C\\<close>\n  shows \\<open>(A +\\<^sub>M B) \\<subseteq> C\\<close>", "lemma closed_subspace_closed_sum:\n  fixes A B::\"('a::complex_normed_vector) set\"\n  assumes a1: \\<open>csubspace A\\<close> and a2: \\<open>csubspace B\\<close>\n  shows \\<open>closed_csubspace (A +\\<^sub>M B)\\<close>", "lemma closed_sum_assoc:\n  fixes A B C::\"'a::real_normed_vector set\"\n  shows \\<open>A +\\<^sub>M (B +\\<^sub>M C) = (A +\\<^sub>M B) +\\<^sub>M C\\<close>", "lemma closed_sum_zero_left[simp]:\n  fixes A :: \\<open>('a::{monoid_add, topological_space}) set\\<close>\n  shows \\<open>{0} +\\<^sub>M A = closure A\\<close>", "lemma closed_sum_zero_right[simp]:\n  fixes A :: \\<open>('a::{monoid_add, topological_space}) set\\<close>\n  shows \\<open>A +\\<^sub>M {0} = closure A\\<close>", "lemma closed_sum_closure_right[simp]:\n  fixes A B :: \\<open>'a::real_normed_vector set\\<close>\n  shows \\<open>A +\\<^sub>M closure B = A +\\<^sub>M B\\<close>", "lemma closed_sum_closure_left[simp]:\n  fixes A B :: \\<open>'a::real_normed_vector set\\<close>\n  shows \\<open>closure A +\\<^sub>M B = A +\\<^sub>M B\\<close>", "lemma closed_sum_mono_left:\n  assumes \\<open>A \\<subseteq> B\\<close>\n  shows \\<open>A +\\<^sub>M C \\<subseteq> B +\\<^sub>M C\\<close>", "lemma closed_sum_mono_right:\n  assumes \\<open>A \\<subseteq> B\\<close>\n  shows \\<open>C +\\<^sub>M A \\<subseteq> C +\\<^sub>M B\\<close>", "lemma closed_sum_cspan[simp]:\n  shows \\<open>cspan X +\\<^sub>M cspan Y = closure (cspan (X \\<union> Y))\\<close>", "lemma closure_image_closed_sum: \n  assumes \\<open>bounded_linear U\\<close>\n  shows \\<open>closure (U ` (A +\\<^sub>M B)) = closure (U ` A) +\\<^sub>M closure (U ` B)\\<close>", "lemma ccspan_union: \"ccspan A \\<squnion> ccspan B = ccspan (A \\<union> B)\"", "lemma ccsubspace_plus_sup: \"y \\<le> x \\<Longrightarrow> z \\<le> x \\<Longrightarrow> y + z \\<le> x\" \n  for x y z :: \"'a::complex_normed_vector ccsubspace\"", "lemma ccsubspace_Sup_empty: \"Sup {} = (0::_ ccsubspace)\"", "lemma ccsubspace_add_right_incr[simp]: \"a \\<le> a + c\" for a::\"_ ccsubspace\"", "lemma ccsubspace_add_left_incr[simp]: \"a \\<le> c + a\" for a::\"_ ccsubspace\"", "lemma bounded_antilinear_to_conjugate_space[simp]: \\<open>bounded_antilinear to_conjugate_space\\<close>", "lemma bounded_antilinear_from_conjugate_space[simp]: \\<open>bounded_antilinear from_conjugate_space\\<close>", "lemma antilinear_to_conjugate_space[simp]: \\<open>antilinear to_conjugate_space\\<close>", "lemma antilinear_from_conjugate_space[simp]: \\<open>antilinear from_conjugate_space\\<close>", "lemma cspan_to_conjugate_space[simp]: \"cspan (to_conjugate_space ` X) = to_conjugate_space ` cspan X\"", "lemma surj_to_conjugate_space[simp]: \"surj to_conjugate_space\"", "lemmas has_derivative_scaleC[simp, derivative_intros] =\n  bounded_bilinear.FDERIV[OF bounded_cbilinear_scaleC[THEN bounded_cbilinear.bounded_bilinear]]", "lemma norm_to_conjugate_space[simp]: \\<open>norm (to_conjugate_space x) = norm x\\<close>", "lemma norm_from_conjugate_space[simp]: \\<open>norm (from_conjugate_space x) = norm x\\<close>", "lemma closure_to_conjugate_space: \\<open>closure (to_conjugate_space ` X) = to_conjugate_space ` closure X\\<close>", "lemma closure_from_conjugate_space: \\<open>closure (from_conjugate_space ` X) = from_conjugate_space ` closure X\\<close>", "lemma bounded_antilinear_eq_on:\n  fixes A B :: \"'a::complex_normed_vector \\<Rightarrow> 'b::complex_normed_vector\"\n  assumes \\<open>bounded_antilinear A\\<close> and \\<open>bounded_antilinear B\\<close> and\n    eq: \\<open>\\<And>x. x \\<in> G \\<Longrightarrow> A x = B x\\<close> and t: \\<open>t \\<in> closure (cspan G)\\<close>\n  shows \\<open>A t = B t\\<close>", "lemma csubspace_is_convex[simp]:\n  assumes a1: \"csubspace M\"\n  shows \"convex M\"", "lemma kernel_is_csubspace[simp]:\n  assumes a1: \"clinear f\"\n  shows \"csubspace  (f -` {0})\"", "lemma kernel_is_closed_csubspace[simp]:\n  assumes a1: \"bounded_clinear f\"\n  shows \"closed_csubspace (f -` {0})\"", "lemma range_is_clinear[simp]:\n  assumes a1: \"clinear f\"\n  shows \"csubspace (range f)\"", "lemma ccspan_superset:\n  \\<open>A \\<subseteq> space_as_set (ccspan A)\\<close> \n  for A :: \\<open>'a::complex_normed_vector set\\<close>", "lemma fst_scaleC [simp]: \"fst (scaleC r A) = scaleC r (fst A)\"", "lemma snd_scaleC [simp]: \"snd (scaleC r A) = scaleC r (snd A)\"", "lemma module_prod_scale_eq_scaleC: \"module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = scaleC\"", "lemmas continuous = continuous", "lemmas uniform_limit = uniform_limit", "lemmas Cauchy = Cauchy", "lemmas continuous = continuous", "lemmas uniform_limit = uniform_limit", "lemmas tendsto = tendsto", "lemmas isCont = isCont", "lemmas tendsto = tendsto", "lemmas isCont = isCont", "lemmas tendsto_scaleC [tendsto_intros] =\n  bounded_cbilinear.tendsto [OF bounded_cbilinear_scaleC]"], "translations": [["", "lemma (in scaleC) scaleC_real: assumes \"r\\<in>\\<real>\" shows \"r *\\<^sub>C x = Re r *\\<^sub>R x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>C x = Re r *\\<^sub>R x", "unfolding scaleR_scaleC"], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>C x = complex_of_real (Re r) *\\<^sub>C x", "using assms"], ["proof (prove)\nusing this:\n  r \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. r *\\<^sub>C x = complex_of_real (Re r) *\\<^sub>C x", "by simp"], ["", "lemma of_complex_of_real_eq [simp]: \"of_complex (of_real n) = of_real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_complex (complex_of_real n) = of_real n", "unfolding of_complex_def of_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n *\\<^sub>R 1) *\\<^sub>C (1::'a) = n *\\<^sub>R (1::'a)", "unfolding scaleR_scaleC"], ["proof (prove)\ngoal (1 subgoal):\n 1. (complex_of_real n *\\<^sub>C 1) *\\<^sub>C (1::'a) =\n    complex_of_real n *\\<^sub>C (1::'a)", "by simp"], ["", "lemma Complexs_of_real [simp]: \"of_real r \\<in> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real r \\<in> \\<complex>", "unfolding Complexs_def of_real_def of_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>R (1::'a) \\<in> range (\\<lambda>c. c *\\<^sub>C (1::'a))", "apply (subst scaleR_scaleC)"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real r *\\<^sub>C (1::'a)\n    \\<in> range (\\<lambda>c. c *\\<^sub>C (1::'a))", "by simp"], ["", "lemma Reals_in_Complexs: \"\\<real> \\<subseteq> \\<complex>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<real> \\<subseteq> \\<complex>", "unfolding Reals_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range of_real \\<subseteq> \\<complex>", "by auto"], ["", "lemma (in clinear) \"linear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear f", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b1 b2. f (b1 + b2) = f b1 + f b2\n 2. \\<And>r b. f (r *\\<^sub>R b) = r *\\<^sub>R f b", "by (simp_all add: add scaleC scaleR_scaleC)"], ["", "lemma (in bounded_clinear) bounded_linear: \"bounded_linear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear f", "by (simp add: add bounded bounded_linear.intro bounded_linear_axioms.intro linearI scaleC scaleR_scaleC)"], ["", "lemma clinear_times: \"clinear (\\<lambda>x. c * x)\"\n  for c :: \"'a::complex_algebra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear ((*) c)", "by (auto simp: clinearI distrib_left)"], ["", "lemma (in clinear) linear:\n  shows \\<open>linear f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear f", "by (simp add: add linearI scaleC scaleR_scaleC)"], ["", "lemma bounded_clinearI:\n  assumes \\<open>\\<And>b1 b2. f (b1 + b2) = f b1 + f b2\\<close>\n  assumes \\<open>\\<And>r b. f (r *\\<^sub>C b) = r *\\<^sub>C f b\\<close>\n  assumes \\<open>\\<forall>x. norm (f x) \\<le> norm x * K\\<close>\n  shows \"bounded_clinear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear f", "using assms"], ["proof (prove)\nusing this:\n  f (?b1.0 + ?b2.0) = f ?b1.0 + f ?b2.0\n  f (?r *\\<^sub>C ?b) = ?r *\\<^sub>C f ?b\n  \\<forall>x. norm (f x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. bounded_clinear f", "by (auto intro!: exI bounded_clinear.intro clinearI simp: bounded_clinear_axioms_def)"], ["", "lemma bounded_clinear_id[simp]: \\<open>bounded_clinear id\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear id", "by (simp add: id_def)"], ["", "(* The following would be a natural inclusion of locales, but unfortunately it leads to\n   name conflicts upon interpretation of bounded_cbilinear *)\n(* sublocale bounded_cbilinear \\<subseteq> bounded_bilinear\n  by (rule bounded_bilinear) *)"], ["", "definition cbilinear :: \\<open>('a::complex_vector \\<Rightarrow> 'b::complex_vector \\<Rightarrow> 'c::complex_vector) \\<Rightarrow> bool\\<close>\n  where \\<open>cbilinear = (\\<lambda> f. (\\<forall> y. clinear (\\<lambda> x. f x y)) \\<and> (\\<forall> x. clinear (\\<lambda> y. f x y)) )\\<close>"], ["", "lemma cbilinear_add_left:\n  assumes \\<open>cbilinear f\\<close>\n  shows \\<open>f (a + b) c = f a c + f b c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (a + b) c = f a c + f b c", "by (smt (verit, del_insts) assms cbilinear_def complex_vector.linear_add)"], ["", "lemma cbilinear_add_right:\n  assumes \\<open>cbilinear f\\<close>\n  shows \\<open>f a (b + c) = f a b + f a c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f a (b + c) = f a b + f a c", "by (smt (verit, del_insts) assms cbilinear_def complex_vector.linear_add)"], ["", "lemma cbilinear_times:\n  fixes g' :: \\<open>'a::complex_vector \\<Rightarrow> complex\\<close> and g :: \\<open>'b::complex_vector \\<Rightarrow> complex\\<close>\n  assumes \\<open>\\<And> x y. h x y = (g' x)*(g y)\\<close> and \\<open>clinear g\\<close> and \\<open>clinear g'\\<close>\n  shows \\<open>cbilinear h\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cbilinear h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cbilinear h", "have w1: \"h (b1 + b2) y = h b1 y + h b2 y\"\n    for b1 :: 'a\n      and b2 :: 'a\n      and y"], ["proof (prove)\ngoal (1 subgoal):\n 1. h (b1 + b2) y = h b1 y + h b2 y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. h (b1 + b2) y = h b1 y + h b2 y", "have \\<open>h (b1 + b2) y = g' (b1 + b2) * g y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. h (b1 + b2) y = g' (b1 + b2) * g y", "using \\<open>\\<And> x y. h x y = (g' x)*(g y)\\<close>"], ["proof (prove)\nusing this:\n  h ?x ?y = g' ?x * g ?y\n\ngoal (1 subgoal):\n 1. h (b1 + b2) y = g' (b1 + b2) * g y", "by auto"], ["proof (state)\nthis:\n  h (b1 + b2) y = g' (b1 + b2) * g y\n\ngoal (1 subgoal):\n 1. h (b1 + b2) y = h b1 y + h b2 y", "also"], ["proof (state)\nthis:\n  h (b1 + b2) y = g' (b1 + b2) * g y\n\ngoal (1 subgoal):\n 1. h (b1 + b2) y = h b1 y + h b2 y", "have \\<open>\\<dots> = (g' b1 + g' b2) * g y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' (b1 + b2) * g y = (g' b1 + g' b2) * g y", "using \\<open>clinear g'\\<close>"], ["proof (prove)\nusing this:\n  clinear g'\n\ngoal (1 subgoal):\n 1. g' (b1 + b2) * g y = (g' b1 + g' b2) * g y", "unfolding clinear_def"], ["proof (prove)\nusing this:\n  Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) g'\n\ngoal (1 subgoal):\n 1. g' (b1 + b2) * g y = (g' b1 + g' b2) * g y", "by (simp add: assms(3) complex_vector.linear_add)"], ["proof (state)\nthis:\n  g' (b1 + b2) * g y = (g' b1 + g' b2) * g y\n\ngoal (1 subgoal):\n 1. h (b1 + b2) y = h b1 y + h b2 y", "also"], ["proof (state)\nthis:\n  g' (b1 + b2) * g y = (g' b1 + g' b2) * g y\n\ngoal (1 subgoal):\n 1. h (b1 + b2) y = h b1 y + h b2 y", "have \\<open>\\<dots> = g' b1 * g y + g' b2 * g y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g' b1 + g' b2) * g y = g' b1 * g y + g' b2 * g y", "by (simp add: ring_class.ring_distribs(2))"], ["proof (state)\nthis:\n  (g' b1 + g' b2) * g y = g' b1 * g y + g' b2 * g y\n\ngoal (1 subgoal):\n 1. h (b1 + b2) y = h b1 y + h b2 y", "also"], ["proof (state)\nthis:\n  (g' b1 + g' b2) * g y = g' b1 * g y + g' b2 * g y\n\ngoal (1 subgoal):\n 1. h (b1 + b2) y = h b1 y + h b2 y", "have \\<open>\\<dots> = h b1 y + h b2 y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' b1 * g y + g' b2 * g y = h b1 y + h b2 y", "using assms(1)"], ["proof (prove)\nusing this:\n  h ?x ?y = g' ?x * g ?y\n\ngoal (1 subgoal):\n 1. g' b1 * g y + g' b2 * g y = h b1 y + h b2 y", "by auto"], ["proof (state)\nthis:\n  g' b1 * g y + g' b2 * g y = h b1 y + h b2 y\n\ngoal (1 subgoal):\n 1. h (b1 + b2) y = h b1 y + h b2 y", "finally"], ["proof (chain)\npicking this:\n  h (b1 + b2) y = h b1 y + h b2 y", "show ?thesis"], ["proof (prove)\nusing this:\n  h (b1 + b2) y = h b1 y + h b2 y\n\ngoal (1 subgoal):\n 1. h (b1 + b2) y = h b1 y + h b2 y", "by blast"], ["proof (state)\nthis:\n  h (b1 + b2) y = h b1 y + h b2 y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h (?b1.0 + ?b2.0) ?y = h ?b1.0 ?y + h ?b2.0 ?y\n\ngoal (1 subgoal):\n 1. cbilinear h", "have w2: \"h (r *\\<^sub>C b) y = r *\\<^sub>C h b y\"\n    for r :: complex\n      and b :: 'a\n      and y"], ["proof (prove)\ngoal (1 subgoal):\n 1. h (r *\\<^sub>C b) y = r *\\<^sub>C h b y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. h (r *\\<^sub>C b) y = r *\\<^sub>C h b y", "have \\<open>h (r *\\<^sub>C b) y = g' (r *\\<^sub>C b) * g y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. h (r *\\<^sub>C b) y = g' (r *\\<^sub>C b) * g y", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  h (r *\\<^sub>C b) y = g' (r *\\<^sub>C b) * g y\n\ngoal (1 subgoal):\n 1. h (r *\\<^sub>C b) y = r *\\<^sub>C h b y", "also"], ["proof (state)\nthis:\n  h (r *\\<^sub>C b) y = g' (r *\\<^sub>C b) * g y\n\ngoal (1 subgoal):\n 1. h (r *\\<^sub>C b) y = r *\\<^sub>C h b y", "have \\<open>\\<dots> = r *\\<^sub>C (g' b * g y)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' (r *\\<^sub>C b) * g y = r *\\<^sub>C (g' b * g y)", "by (simp add: assms(3) complex_vector.linear_scale)"], ["proof (state)\nthis:\n  g' (r *\\<^sub>C b) * g y = r *\\<^sub>C (g' b * g y)\n\ngoal (1 subgoal):\n 1. h (r *\\<^sub>C b) y = r *\\<^sub>C h b y", "also"], ["proof (state)\nthis:\n  g' (r *\\<^sub>C b) * g y = r *\\<^sub>C (g' b * g y)\n\ngoal (1 subgoal):\n 1. h (r *\\<^sub>C b) y = r *\\<^sub>C h b y", "have \\<open>\\<dots> = r *\\<^sub>C (h b y)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>C (g' b * g y) = r *\\<^sub>C h b y", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  r *\\<^sub>C (g' b * g y) = r *\\<^sub>C h b y\n\ngoal (1 subgoal):\n 1. h (r *\\<^sub>C b) y = r *\\<^sub>C h b y", "finally"], ["proof (chain)\npicking this:\n  h (r *\\<^sub>C b) y = r *\\<^sub>C h b y", "show ?thesis"], ["proof (prove)\nusing this:\n  h (r *\\<^sub>C b) y = r *\\<^sub>C h b y\n\ngoal (1 subgoal):\n 1. h (r *\\<^sub>C b) y = r *\\<^sub>C h b y", "by blast"], ["proof (state)\nthis:\n  h (r *\\<^sub>C b) y = r *\\<^sub>C h b y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h (?r *\\<^sub>C ?b) ?y = ?r *\\<^sub>C h ?b ?y\n\ngoal (1 subgoal):\n 1. cbilinear h", "have \"clinear (\\<lambda>x. h x y)\"\n    for y :: 'b"], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear (\\<lambda>x. h x y)", "unfolding clinear_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) (\\<lambda>x. h x y)", "by (meson clinearI clinear_def w1 w2)"], ["proof (state)\nthis:\n  clinear (\\<lambda>x. h x ?y)\n\ngoal (1 subgoal):\n 1. cbilinear h", "hence t2: \"\\<forall>y. clinear (\\<lambda>x. h x y)\""], ["proof (prove)\nusing this:\n  clinear (\\<lambda>x. h x ?y)\n\ngoal (1 subgoal):\n 1. \\<forall>y. clinear (\\<lambda>x. h x y)", "by simp"], ["proof (state)\nthis:\n  \\<forall>y. clinear (\\<lambda>x. h x y)\n\ngoal (1 subgoal):\n 1. cbilinear h", "have v1: \"h x (b1 + b2) = h x b1 + h x b2\"\n    for b1 :: 'b\n      and b2 :: 'b\n      and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. h x (b1 + b2) = h x b1 + h x b2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. h x (b1 + b2) = h x b1 + h x b2", "have \\<open>h x (b1 + b2)  = g' x * g (b1 + b2)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. h x (b1 + b2) = g' x * g (b1 + b2)", "using \\<open>\\<And> x y. h x y = (g' x)*(g y)\\<close>"], ["proof (prove)\nusing this:\n  h ?x ?y = g' ?x * g ?y\n\ngoal (1 subgoal):\n 1. h x (b1 + b2) = g' x * g (b1 + b2)", "by auto"], ["proof (state)\nthis:\n  h x (b1 + b2) = g' x * g (b1 + b2)\n\ngoal (1 subgoal):\n 1. h x (b1 + b2) = h x b1 + h x b2", "also"], ["proof (state)\nthis:\n  h x (b1 + b2) = g' x * g (b1 + b2)\n\ngoal (1 subgoal):\n 1. h x (b1 + b2) = h x b1 + h x b2", "have \\<open>\\<dots> = g' x * (g b1 + g b2)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' x * g (b1 + b2) = g' x * (g b1 + g b2)", "using \\<open>clinear g'\\<close>"], ["proof (prove)\nusing this:\n  clinear g'\n\ngoal (1 subgoal):\n 1. g' x * g (b1 + b2) = g' x * (g b1 + g b2)", "unfolding clinear_def"], ["proof (prove)\nusing this:\n  Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) g'\n\ngoal (1 subgoal):\n 1. g' x * g (b1 + b2) = g' x * (g b1 + g b2)", "by (simp add: assms(2) complex_vector.linear_add)"], ["proof (state)\nthis:\n  g' x * g (b1 + b2) = g' x * (g b1 + g b2)\n\ngoal (1 subgoal):\n 1. h x (b1 + b2) = h x b1 + h x b2", "also"], ["proof (state)\nthis:\n  g' x * g (b1 + b2) = g' x * (g b1 + g b2)\n\ngoal (1 subgoal):\n 1. h x (b1 + b2) = h x b1 + h x b2", "have \\<open>\\<dots> = g' x * g b1 + g' x * g b2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' x * (g b1 + g b2) = g' x * g b1 + g' x * g b2", "by (simp add: ring_class.ring_distribs(1))"], ["proof (state)\nthis:\n  g' x * (g b1 + g b2) = g' x * g b1 + g' x * g b2\n\ngoal (1 subgoal):\n 1. h x (b1 + b2) = h x b1 + h x b2", "also"], ["proof (state)\nthis:\n  g' x * (g b1 + g b2) = g' x * g b1 + g' x * g b2\n\ngoal (1 subgoal):\n 1. h x (b1 + b2) = h x b1 + h x b2", "have \\<open>\\<dots> = h x b1 + h x b2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' x * g b1 + g' x * g b2 = h x b1 + h x b2", "using assms(1)"], ["proof (prove)\nusing this:\n  h ?x ?y = g' ?x * g ?y\n\ngoal (1 subgoal):\n 1. g' x * g b1 + g' x * g b2 = h x b1 + h x b2", "by auto"], ["proof (state)\nthis:\n  g' x * g b1 + g' x * g b2 = h x b1 + h x b2\n\ngoal (1 subgoal):\n 1. h x (b1 + b2) = h x b1 + h x b2", "finally"], ["proof (chain)\npicking this:\n  h x (b1 + b2) = h x b1 + h x b2", "show ?thesis"], ["proof (prove)\nusing this:\n  h x (b1 + b2) = h x b1 + h x b2\n\ngoal (1 subgoal):\n 1. h x (b1 + b2) = h x b1 + h x b2", "by blast"], ["proof (state)\nthis:\n  h x (b1 + b2) = h x b1 + h x b2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h ?x (?b1.0 + ?b2.0) = h ?x ?b1.0 + h ?x ?b2.0\n\ngoal (1 subgoal):\n 1. cbilinear h", "have v2:  \"h x (r *\\<^sub>C b) = r *\\<^sub>C h x b\"\n    for r :: complex\n      and b :: 'b\n      and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. h x (r *\\<^sub>C b) = r *\\<^sub>C h x b", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. h x (r *\\<^sub>C b) = r *\\<^sub>C h x b", "have \\<open>h x (r *\\<^sub>C b) =  g' x * g (r *\\<^sub>C b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. h x (r *\\<^sub>C b) = g' x * g (r *\\<^sub>C b)", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  h x (r *\\<^sub>C b) = g' x * g (r *\\<^sub>C b)\n\ngoal (1 subgoal):\n 1. h x (r *\\<^sub>C b) = r *\\<^sub>C h x b", "also"], ["proof (state)\nthis:\n  h x (r *\\<^sub>C b) = g' x * g (r *\\<^sub>C b)\n\ngoal (1 subgoal):\n 1. h x (r *\\<^sub>C b) = r *\\<^sub>C h x b", "have \\<open>\\<dots> = r *\\<^sub>C (g' x * g b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. g' x * g (r *\\<^sub>C b) = r *\\<^sub>C (g' x * g b)", "by (simp add: assms(2) complex_vector.linear_scale)"], ["proof (state)\nthis:\n  g' x * g (r *\\<^sub>C b) = r *\\<^sub>C (g' x * g b)\n\ngoal (1 subgoal):\n 1. h x (r *\\<^sub>C b) = r *\\<^sub>C h x b", "also"], ["proof (state)\nthis:\n  g' x * g (r *\\<^sub>C b) = r *\\<^sub>C (g' x * g b)\n\ngoal (1 subgoal):\n 1. h x (r *\\<^sub>C b) = r *\\<^sub>C h x b", "have \\<open>\\<dots> = r *\\<^sub>C (h x b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>C (g' x * g b) = r *\\<^sub>C h x b", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  r *\\<^sub>C (g' x * g b) = r *\\<^sub>C h x b\n\ngoal (1 subgoal):\n 1. h x (r *\\<^sub>C b) = r *\\<^sub>C h x b", "finally"], ["proof (chain)\npicking this:\n  h x (r *\\<^sub>C b) = r *\\<^sub>C h x b", "show ?thesis"], ["proof (prove)\nusing this:\n  h x (r *\\<^sub>C b) = r *\\<^sub>C h x b\n\ngoal (1 subgoal):\n 1. h x (r *\\<^sub>C b) = r *\\<^sub>C h x b", "by blast"], ["proof (state)\nthis:\n  h x (r *\\<^sub>C b) = r *\\<^sub>C h x b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h ?x (?r *\\<^sub>C ?b) = ?r *\\<^sub>C h ?x ?b\n\ngoal (1 subgoal):\n 1. cbilinear h", "have \"Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) (h x)\"\n    for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) (h x)", "using v1 v2"], ["proof (prove)\nusing this:\n  h ?x (?b1.0 + ?b2.0) = h ?x ?b1.0 + h ?x ?b2.0\n  h ?x (?r *\\<^sub>C ?b) = ?r *\\<^sub>C h ?x ?b\n\ngoal (1 subgoal):\n 1. Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) (h x)", "by (meson clinearI clinear_def)"], ["proof (state)\nthis:\n  Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) (h ?x)\n\ngoal (1 subgoal):\n 1. cbilinear h", "hence t1: \"\\<forall>x. clinear (h x)\""], ["proof (prove)\nusing this:\n  Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) (h ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>x. clinear (h x)", "unfolding clinear_def"], ["proof (prove)\nusing this:\n  Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) (h ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>x. Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) (h x)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. clinear (h x)\n\ngoal (1 subgoal):\n 1. cbilinear h", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cbilinear h", "unfolding cbilinear_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y. clinear (\\<lambda>x. h x y)) \\<and>\n    (\\<forall>x. clinear (h x))", "by (simp add: t1 t2)"], ["proof (state)\nthis:\n  cbilinear h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma csubspace_is_subspace: \"csubspace A \\<Longrightarrow> subspace A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace A \\<Longrightarrow> subspace A", "apply (rule subspaceI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. csubspace A \\<Longrightarrow> (0::'a) \\<in> A\n 2. \\<And>x y.\n       \\<lbrakk>csubspace A; x \\<in> A; y \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x + y \\<in> A\n 3. \\<And>c x.\n       \\<lbrakk>csubspace A; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> c *\\<^sub>R x \\<in> A", "by (auto simp: complex_vector.subspace_def scaleR_scaleC)"], ["", "lemma span_subset_cspan: \"span A \\<subseteq> cspan A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span A \\<subseteq> cspan A", "unfolding span_def complex_vector.span_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace hull A \\<subseteq> csubspace hull A", "by (simp add: csubspace_is_subspace hull_antimono)"], ["", "lemma cindependent_implies_independent: \n  assumes \"cindependent (S::'a::complex_vector set)\"\n  shows \"independent S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. independent S", "using assms"], ["proof (prove)\nusing this:\n  cindependent S\n\ngoal (1 subgoal):\n 1. independent S", "unfolding dependent_def complex_vector.dependent_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>a\\<in>S. a \\<in> cspan (S - {a}))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>S. a \\<in> span (S - {a}))", "using span_subset_cspan"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>a\\<in>S. a \\<in> cspan (S - {a}))\n  span ?A \\<subseteq> cspan ?A\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>S. a \\<in> span (S - {a}))", "by blast"], ["", "lemma cspan_singleton: \"cspan {x} = {\\<alpha> *\\<^sub>C x| \\<alpha>. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan {x} = {\\<alpha> *\\<^sub>C x |\\<alpha>. True}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cspan {x} = {\\<alpha> *\\<^sub>C x |\\<alpha>. True}", "have \\<open>cspan {x} = {y. y\\<in>cspan {x}}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan {x} = {y. y \\<in> cspan {x}}", "by auto"], ["proof (state)\nthis:\n  cspan {x} = {y. y \\<in> cspan {x}}\n\ngoal (1 subgoal):\n 1. cspan {x} = {\\<alpha> *\\<^sub>C x |\\<alpha>. True}", "also"], ["proof (state)\nthis:\n  cspan {x} = {y. y \\<in> cspan {x}}\n\ngoal (1 subgoal):\n 1. cspan {x} = {\\<alpha> *\\<^sub>C x |\\<alpha>. True}", "have \\<open>\\<dots> = {\\<alpha> *\\<^sub>C x| \\<alpha>. True}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y \\<in> cspan {x}} = {\\<alpha> *\\<^sub>C x |\\<alpha>. True}", "apply (subst complex_vector.span_breakdown_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>k. y - k *\\<^sub>C x \\<in> cspan {}} =\n    {\\<alpha> *\\<^sub>C x |\\<alpha>. True}", "by auto"], ["proof (state)\nthis:\n  {y. y \\<in> cspan {x}} = {\\<alpha> *\\<^sub>C x |\\<alpha>. True}\n\ngoal (1 subgoal):\n 1. cspan {x} = {\\<alpha> *\\<^sub>C x |\\<alpha>. True}", "finally"], ["proof (chain)\npicking this:\n  cspan {x} = {\\<alpha> *\\<^sub>C x |\\<alpha>. True}", "show ?thesis"], ["proof (prove)\nusing this:\n  cspan {x} = {\\<alpha> *\\<^sub>C x |\\<alpha>. True}\n\ngoal (1 subgoal):\n 1. cspan {x} = {\\<alpha> *\\<^sub>C x |\\<alpha>. True}", "by -"], ["proof (state)\nthis:\n  cspan {x} = {\\<alpha> *\\<^sub>C x |\\<alpha>. True}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cspan_as_span:\n  \"cspan (B::'a::complex_vector set) = span (B \\<union> scaleC \\<i> ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan B = span (B \\<union> (*\\<^sub>C) \\<i> ` B)", "proof auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "let ?cspan = complex_vector.span"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "let ?rspan = real_vector.span"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "fix \\<psi>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "assume cspan: \"\\<psi> \\<in> ?cspan B\""], ["proof (state)\nthis:\n  \\<psi> \\<in> cspan B\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "have \"\\<exists>B' r. finite B' \\<and> B' \\<subseteq> B \\<and> \\<psi> = (\\<Sum>b\\<in>B'. r b *\\<^sub>C b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B' r.\n       finite B' \\<and>\n       B' \\<subseteq> B \\<and> \\<psi> = (\\<Sum>b\\<in>B'. r b *\\<^sub>C b)", "using complex_vector.span_explicit[of B] cspan"], ["proof (prove)\nusing this:\n  cspan B =\n  {\\<Sum>a\\<in>t. r a *\\<^sub>C a |t r. finite t \\<and> t \\<subseteq> B}\n  \\<psi> \\<in> cspan B\n\ngoal (1 subgoal):\n 1. \\<exists>B' r.\n       finite B' \\<and>\n       B' \\<subseteq> B \\<and> \\<psi> = (\\<Sum>b\\<in>B'. r b *\\<^sub>C b)", "by auto"], ["proof (state)\nthis:\n  \\<exists>B' r.\n     finite B' \\<and>\n     B' \\<subseteq> B \\<and> \\<psi> = (\\<Sum>b\\<in>B'. r b *\\<^sub>C b)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "then"], ["proof (chain)\npicking this:\n  \\<exists>B' r.\n     finite B' \\<and>\n     B' \\<subseteq> B \\<and> \\<psi> = (\\<Sum>b\\<in>B'. r b *\\<^sub>C b)", "obtain B' r where \"finite B'\" and \"B' \\<subseteq> B\" and \\<psi>_explicit: \"\\<psi> = (\\<Sum>b\\<in>B'. r b *\\<^sub>C b)\""], ["proof (prove)\nusing this:\n  \\<exists>B' r.\n     finite B' \\<and>\n     B' \\<subseteq> B \\<and> \\<psi> = (\\<Sum>b\\<in>B'. r b *\\<^sub>C b)\n\ngoal (1 subgoal):\n 1. (\\<And>B' r.\n        \\<lbrakk>finite B'; B' \\<subseteq> B;\n         \\<psi> = (\\<Sum>b\\<in>B'. r b *\\<^sub>C b)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim"], ["proof (state)\nthis:\n  finite B'\n  B' \\<subseteq> B\n  \\<psi> = (\\<Sum>b\\<in>B'. r b *\\<^sub>C b)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "define R where \"R = B \\<union> scaleC \\<i> ` B\""], ["proof (state)\nthis:\n  R = B \\<union> (*\\<^sub>C) \\<i> ` B\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "have x2: \"(case x of (b, i) \\<Rightarrow> if i \n            then Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b \n            else Re (r b) *\\<^sub>R b) \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\"\n    if \"x \\<in> B' \\<times> (UNIV::bool set)\"\n    for x :: \"'a \\<times> bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of\n     (b, i) \\<Rightarrow>\n       if i then Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b\n       else Re (r b) *\\<^sub>R b)\n    \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)", "using that \\<open>B' \\<subseteq> B\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> B' \\<times> UNIV\n  B' \\<subseteq> B\n\ngoal (1 subgoal):\n 1. (case x of\n     (b, i) \\<Rightarrow>\n       if i then Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b\n       else Re (r b) *\\<^sub>R b)\n    \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)", "by (auto simp add: real_vector.span_base real_vector.span_scale subset_iff)"], ["proof (state)\nthis:\n  ?x2 \\<in> B' \\<times> UNIV \\<Longrightarrow>\n  (case ?x2 of\n   (b, i) \\<Rightarrow>\n     if i then Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b\n     else Re (r b) *\\<^sub>R b)\n  \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "have x1: \"\\<psi> = (\\<Sum>x\\<in>B'. \\<Sum>i\\<in>UNIV. if i then Im (r x) *\\<^sub>R \\<i> *\\<^sub>C x else Re (r x) *\\<^sub>R x)\"\n    if \"\\<And>b. r b *\\<^sub>C b = Re (r b) *\\<^sub>R b + Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> =\n    (\\<Sum>x\\<in>B'.\n       \\<Sum>i\\<in>UNIV.\n         if i then Im (r x) *\\<^sub>R \\<i> *\\<^sub>C x\n         else Re (r x) *\\<^sub>R x)", "using that"], ["proof (prove)\nusing this:\n  r ?b2 *\\<^sub>C ?b2 =\n  Re (r ?b2) *\\<^sub>R ?b2 + Im (r ?b2) *\\<^sub>R \\<i> *\\<^sub>C ?b2\n\ngoal (1 subgoal):\n 1. \\<psi> =\n    (\\<Sum>x\\<in>B'.\n       \\<Sum>i\\<in>UNIV.\n         if i then Im (r x) *\\<^sub>R \\<i> *\\<^sub>C x\n         else Re (r x) *\\<^sub>R x)", "by (simp add: UNIV_bool \\<psi>_explicit)"], ["proof (state)\nthis:\n  (\\<And>b.\n      r b *\\<^sub>C b =\n      Re (r b) *\\<^sub>R b +\n      Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b) \\<Longrightarrow>\n  \\<psi> =\n  (\\<Sum>x\\<in>B'.\n     \\<Sum>i\\<in>UNIV.\n       if i then Im (r x) *\\<^sub>R \\<i> *\\<^sub>C x\n       else Re (r x) *\\<^sub>R x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "moreover"], ["proof (state)\nthis:\n  (\\<And>b.\n      r b *\\<^sub>C b =\n      Re (r b) *\\<^sub>R b +\n      Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b) \\<Longrightarrow>\n  \\<psi> =\n  (\\<Sum>x\\<in>B'.\n     \\<Sum>i\\<in>UNIV.\n       if i then Im (r x) *\\<^sub>R \\<i> *\\<^sub>C x\n       else Re (r x) *\\<^sub>R x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "have \"r b *\\<^sub>C b = Re (r b) *\\<^sub>R b + Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. r b *\\<^sub>C b =\n    Re (r b) *\\<^sub>R b + Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b", "using complex_eq scaleC_add_left scaleC_scaleC scaleR_scaleC"], ["proof (prove)\nusing this:\n  ?a = complex_of_real (Re ?a) + \\<i> * complex_of_real (Im ?a)\n  (?a + ?b) *\\<^sub>C ?x = ?a *\\<^sub>C ?x + ?b *\\<^sub>C ?x\n  ?a *\\<^sub>C ?b *\\<^sub>C ?x = (?a * ?b) *\\<^sub>C ?x\n  (*\\<^sub>R) ?r = (*\\<^sub>C) (complex_of_real ?r)\n\ngoal (1 subgoal):\n 1. r b *\\<^sub>C b =\n    Re (r b) *\\<^sub>R b + Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b", "by (metis (no_types, lifting) complex_of_real_i i_complex_of_real)"], ["proof (state)\nthis:\n  r ?b2 *\\<^sub>C ?b2 =\n  Re (r ?b2) *\\<^sub>R ?b2 + Im (r ?b2) *\\<^sub>R \\<i> *\\<^sub>C ?b2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "ultimately"], ["proof (chain)\npicking this:\n  (\\<And>b.\n      r b *\\<^sub>C b =\n      Re (r b) *\\<^sub>R b +\n      Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b) \\<Longrightarrow>\n  \\<psi> =\n  (\\<Sum>x\\<in>B'.\n     \\<Sum>i\\<in>UNIV.\n       if i then Im (r x) *\\<^sub>R \\<i> *\\<^sub>C x\n       else Re (r x) *\\<^sub>R x)\n  r ?b2 *\\<^sub>C ?b2 =\n  Re (r ?b2) *\\<^sub>R ?b2 + Im (r ?b2) *\\<^sub>R \\<i> *\\<^sub>C ?b2", "have \"\\<psi> = (\\<Sum>(b,i)\\<in>(B'\\<times>UNIV). if i then Im (r b) *\\<^sub>R (\\<i> *\\<^sub>C b) else Re (r b) *\\<^sub>R b)\""], ["proof (prove)\nusing this:\n  (\\<And>b.\n      r b *\\<^sub>C b =\n      Re (r b) *\\<^sub>R b +\n      Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b) \\<Longrightarrow>\n  \\<psi> =\n  (\\<Sum>x\\<in>B'.\n     \\<Sum>i\\<in>UNIV.\n       if i then Im (r x) *\\<^sub>R \\<i> *\\<^sub>C x\n       else Re (r x) *\\<^sub>R x)\n  r ?b2 *\\<^sub>C ?b2 =\n  Re (r ?b2) *\\<^sub>R ?b2 + Im (r ?b2) *\\<^sub>R \\<i> *\\<^sub>C ?b2\n\ngoal (1 subgoal):\n 1. \\<psi> =\n    (\\<Sum>(b, i)\\<in>B' \\<times> UNIV.\n       if i then Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b\n       else Re (r b) *\\<^sub>R b)", "by (simp add: sum.cartesian_product)"], ["proof (state)\nthis:\n  \\<psi> =\n  (\\<Sum>(b, i)\\<in>B' \\<times> UNIV.\n     if i then Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b\n     else Re (r b) *\\<^sub>R b)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "also"], ["proof (state)\nthis:\n  \\<psi> =\n  (\\<Sum>(b, i)\\<in>B' \\<times> UNIV.\n     if i then Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b\n     else Re (r b) *\\<^sub>R b)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "have \"\\<dots> \\<in> ?rspan R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(b, i)\\<in>B' \\<times> UNIV.\n       if i then Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b\n       else Re (r b) *\\<^sub>R b)\n    \\<in> span R", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(b, i)\\<in>B' \\<times> UNIV.\n       if i then Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b\n       else Re (r b) *\\<^sub>R b)\n    \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)", "using x2"], ["proof (prove)\nusing this:\n  ?x2 \\<in> B' \\<times> UNIV \\<Longrightarrow>\n  (case ?x2 of\n   (b, i) \\<Rightarrow>\n     if i then Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b\n     else Re (r b) *\\<^sub>R b)\n  \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n\ngoal (1 subgoal):\n 1. (\\<Sum>(b, i)\\<in>B' \\<times> UNIV.\n       if i then Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b\n       else Re (r b) *\\<^sub>R b)\n    \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)", "by (rule real_vector.span_sum)"], ["proof (state)\nthis:\n  (\\<Sum>(b, i)\\<in>B' \\<times> UNIV.\n     if i then Im (r b) *\\<^sub>R \\<i> *\\<^sub>C b\n     else Re (r b) *\\<^sub>R b)\n  \\<in> span R\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> cspan B \\<Longrightarrow>\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B)\n 2. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "finally"], ["proof (chain)\npicking this:\n  \\<psi> \\<in> span R", "show \"\\<psi> \\<in> ?rspan R\""], ["proof (prove)\nusing this:\n  \\<psi> \\<in> span R\n\ngoal (1 subgoal):\n 1. \\<psi> \\<in> span R", "by -"], ["proof (state)\nthis:\n  \\<psi> \\<in> span R\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "let ?cspan = complex_vector.span"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "let ?rspan = real_vector.span"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "define R where \"R = B \\<union> scaleC \\<i> ` B\""], ["proof (state)\nthis:\n  R = B \\<union> (*\\<^sub>C) \\<i> ` B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "fix \\<psi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "assume rspan: \"\\<psi> \\<in> ?rspan R\""], ["proof (state)\nthis:\n  \\<psi> \\<in> span R\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "have \"subspace {a. a \\<in> cspan B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace {a. a \\<in> cspan B}", "by (rule real_vector.subspaceI, auto simp add: complex_vector.span_zero \n        complex_vector.span_add_eq2 complex_vector.span_scale scaleR_scaleC)"], ["proof (state)\nthis:\n  subspace {a. a \\<in> cspan B}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "moreover"], ["proof (state)\nthis:\n  subspace {a. a \\<in> cspan B}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "have \"x \\<in> cspan B\"\n    if \"x \\<in> R\"\n    for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> cspan B", "using that R_def complex_vector.span_base complex_vector.span_scale"], ["proof (prove)\nusing this:\n  x \\<in> R\n  R = B \\<union> (*\\<^sub>C) \\<i> ` B\n  ?a \\<in> ?S \\<Longrightarrow> ?a \\<in> cspan ?S\n  ?x \\<in> cspan ?S \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> cspan ?S\n\ngoal (1 subgoal):\n 1. x \\<in> cspan B", "by fastforce"], ["proof (state)\nthis:\n  ?x2 \\<in> R \\<Longrightarrow> ?x2 \\<in> cspan B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> span (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<Longrightarrow>\n       x \\<in> cspan B", "ultimately"], ["proof (chain)\npicking this:\n  subspace {a. a \\<in> cspan B}\n  ?x2 \\<in> R \\<Longrightarrow> ?x2 \\<in> cspan B", "show \"\\<psi> \\<in> ?cspan B\""], ["proof (prove)\nusing this:\n  subspace {a. a \\<in> cspan B}\n  ?x2 \\<in> R \\<Longrightarrow> ?x2 \\<in> cspan B\n\ngoal (1 subgoal):\n 1. \\<psi> \\<in> cspan B", "using real_vector.span_induct rspan"], ["proof (prove)\nusing this:\n  subspace {a. a \\<in> cspan B}\n  ?x2 \\<in> R \\<Longrightarrow> ?x2 \\<in> cspan B\n  \\<lbrakk>?x \\<in> span ?S; subspace (Collect ?P);\n   \\<And>x. x \\<in> ?S \\<Longrightarrow> ?P x\\<rbrakk>\n  \\<Longrightarrow> ?P ?x\n  \\<psi> \\<in> span R\n\ngoal (1 subgoal):\n 1. \\<psi> \\<in> cspan B", "by blast"], ["proof (state)\nthis:\n  \\<psi> \\<in> cspan B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isomorphic_equal_cdim:\n  assumes lin_f: \\<open>clinear f\\<close>\n  assumes inj_f: \\<open>inj_on f (cspan S)\\<close>\n  assumes im_S: \\<open>f ` S = T\\<close>\n  shows \\<open>cdim S = cdim T\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cdim S = cdim T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cdim S = cdim T", "obtain SB where SB_span: \"cspan SB = cspan S\" and indep_SB: \\<open>cindependent SB\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>SB.\n        \\<lbrakk>cspan SB = cspan S; cindependent SB\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis complex_vector.basis_exists complex_vector.span_mono complex_vector.span_span subset_antisym)"], ["proof (state)\nthis:\n  cspan SB = cspan S\n  cindependent SB\n\ngoal (1 subgoal):\n 1. cdim S = cdim T", "with lin_f inj_f"], ["proof (chain)\npicking this:\n  clinear f\n  inj_on f (cspan S)\n  cspan SB = cspan S\n  cindependent SB", "have indep_fSB: \\<open>cindependent (f ` SB)\\<close>"], ["proof (prove)\nusing this:\n  clinear f\n  inj_on f (cspan S)\n  cspan SB = cspan S\n  cindependent SB\n\ngoal (1 subgoal):\n 1. cindependent (f ` SB)", "apply (rule_tac complex_vector.linear_independent_injective_image)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>clinear f; inj_on f (cspan S); cspan SB = cspan S;\n     cindependent SB\\<rbrakk>\n    \\<Longrightarrow> clinear f\n 2. \\<lbrakk>clinear f; inj_on f (cspan S); cspan SB = cspan S;\n     cindependent SB\\<rbrakk>\n    \\<Longrightarrow> cindependent SB\n 3. \\<lbrakk>clinear f; inj_on f (cspan S); cspan SB = cspan S;\n     cindependent SB\\<rbrakk>\n    \\<Longrightarrow> inj_on f (cspan SB)", "by auto"], ["proof (state)\nthis:\n  cindependent (f ` SB)\n\ngoal (1 subgoal):\n 1. cdim S = cdim T", "from lin_f"], ["proof (chain)\npicking this:\n  clinear f", "have \\<open>cspan (f ` SB) = f ` cspan SB\\<close>"], ["proof (prove)\nusing this:\n  clinear f\n\ngoal (1 subgoal):\n 1. cspan (f ` SB) = f ` cspan SB", "by (meson complex_vector.linear_span_image)"], ["proof (state)\nthis:\n  cspan (f ` SB) = f ` cspan SB\n\ngoal (1 subgoal):\n 1. cdim S = cdim T", "also"], ["proof (state)\nthis:\n  cspan (f ` SB) = f ` cspan SB\n\ngoal (1 subgoal):\n 1. cdim S = cdim T", "from SB_span lin_f"], ["proof (chain)\npicking this:\n  cspan SB = cspan S\n  clinear f", "have \\<open>\\<dots> = cspan T\\<close>"], ["proof (prove)\nusing this:\n  cspan SB = cspan S\n  clinear f\n\ngoal (1 subgoal):\n 1. f ` cspan SB = cspan T", "by (metis complex_vector.linear_span_image im_S)"], ["proof (state)\nthis:\n  f ` cspan SB = cspan T\n\ngoal (1 subgoal):\n 1. cdim S = cdim T", "finally"], ["proof (chain)\npicking this:\n  cspan (f ` SB) = cspan T", "have \\<open>cdim T = card (f ` SB)\\<close>"], ["proof (prove)\nusing this:\n  cspan (f ` SB) = cspan T\n\ngoal (1 subgoal):\n 1. cdim T = card (f ` SB)", "using indep_fSB complex_vector.dim_eq_card"], ["proof (prove)\nusing this:\n  cspan (f ` SB) = cspan T\n  cindependent (f ` SB)\n  \\<lbrakk>cspan ?B = cspan ?V; cindependent ?B\\<rbrakk>\n  \\<Longrightarrow> cdim ?V = card ?B\n\ngoal (1 subgoal):\n 1. cdim T = card (f ` SB)", "by blast"], ["proof (state)\nthis:\n  cdim T = card (f ` SB)\n\ngoal (1 subgoal):\n 1. cdim S = cdim T", "also"], ["proof (state)\nthis:\n  cdim T = card (f ` SB)\n\ngoal (1 subgoal):\n 1. cdim S = cdim T", "have \\<open>\\<dots> = card SB\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (f ` SB) = card SB", "apply (rule card_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f SB", "using inj_f"], ["proof (prove)\nusing this:\n  inj_on f (cspan S)\n\ngoal (1 subgoal):\n 1. inj_on f SB", "by (metis SB_span complex_vector.linear_inj_on_span_iff_independent_image indep_fSB lin_f)"], ["proof (state)\nthis:\n  card (f ` SB) = card SB\n\ngoal (1 subgoal):\n 1. cdim S = cdim T", "also"], ["proof (state)\nthis:\n  card (f ` SB) = card SB\n\ngoal (1 subgoal):\n 1. cdim S = cdim T", "have \\<open>\\<dots> = cdim S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. card SB = cdim S", "using indep_SB SB_span"], ["proof (prove)\nusing this:\n  cindependent SB\n  cspan SB = cspan S\n\ngoal (1 subgoal):\n 1. card SB = cdim S", "by (metis complex_vector.dim_eq_card)"], ["proof (state)\nthis:\n  card SB = cdim S\n\ngoal (1 subgoal):\n 1. cdim S = cdim T", "finally"], ["proof (chain)\npicking this:\n  cdim T = cdim S", "show ?thesis"], ["proof (prove)\nusing this:\n  cdim T = cdim S\n\ngoal (1 subgoal):\n 1. cdim S = cdim T", "by simp"], ["proof (state)\nthis:\n  cdim S = cdim T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cindependent_inter_scaleC_cindependent:\n  assumes a1: \"cindependent (B::'a::complex_vector set)\" and a3: \"c \\<noteq> 1\"\n  shows \"B \\<inter> (*\\<^sub>C) c ` B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<inter> (*\\<^sub>C) c ` B = {}", "proof (rule classical, cases \\<open>c = 0\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c = 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}\n 2. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "case True"], ["proof (state)\nthis:\n  c = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c = 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}\n 2. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "then"], ["proof (chain)\npicking this:\n  c = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  c = 0\n\ngoal (1 subgoal):\n 1. B \\<inter> (*\\<^sub>C) c ` B = {}", "using a1"], ["proof (prove)\nusing this:\n  c = 0\n  cindependent B\n\ngoal (1 subgoal):\n 1. B \\<inter> (*\\<^sub>C) c ` B = {}", "by (auto simp add: complex_vector.dependent_zero)"], ["proof (state)\nthis:\n  B \\<inter> (*\\<^sub>C) c ` B = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "case False"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "assume \"\\<not>(B \\<inter> (*\\<^sub>C) c ` B = {})\""], ["proof (state)\nthis:\n  B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "hence \"B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}\""], ["proof (prove)\nusing this:\n  B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "then"], ["proof (chain)\npicking this:\n  B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}", "obtain x where u1: \"x \\<in> B \\<inter> (*\\<^sub>C) c ` B\""], ["proof (prove)\nusing this:\n  B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> B \\<inter> (*\\<^sub>C) c ` B \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> B \\<inter> (*\\<^sub>C) c ` B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "then"], ["proof (chain)\npicking this:\n  x \\<in> B \\<inter> (*\\<^sub>C) c ` B", "obtain b where u2: \"x = b\" and u3: \"b\\<in>B\""], ["proof (prove)\nusing this:\n  x \\<in> B \\<inter> (*\\<^sub>C) c ` B\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>x = b; b \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = b\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "then"], ["proof (chain)\npicking this:\n  x = b\n  b \\<in> B", "obtain b' where u2': \"x = c *\\<^sub>C b'\" and u3': \"b'\\<in>B\""], ["proof (prove)\nusing this:\n  x = b\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>x = c *\\<^sub>C b'; b' \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using u1"], ["proof (prove)\nusing this:\n  x = b\n  b \\<in> B\n  x \\<in> B \\<inter> (*\\<^sub>C) c ` B\n\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        \\<lbrakk>x = c *\\<^sub>C b'; b' \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = c *\\<^sub>C b'\n  b' \\<in> B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "have g1: \"b = c *\\<^sub>C b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = c *\\<^sub>C b'", "using u2 and u2'"], ["proof (prove)\nusing this:\n  x = b\n  x = c *\\<^sub>C b'\n\ngoal (1 subgoal):\n 1. b = c *\\<^sub>C b'", "by simp"], ["proof (state)\nthis:\n  b = c *\\<^sub>C b'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "hence \"b \\<in> complex_vector.span {b'}\""], ["proof (prove)\nusing this:\n  b = c *\\<^sub>C b'\n\ngoal (1 subgoal):\n 1. b \\<in> cspan {b'}", "using False"], ["proof (prove)\nusing this:\n  b = c *\\<^sub>C b'\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b \\<in> cspan {b'}", "by (simp add: complex_vector.span_base complex_vector.span_scale)"], ["proof (state)\nthis:\n  b \\<in> cspan {b'}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "hence \"b = b'\""], ["proof (prove)\nusing this:\n  b \\<in> cspan {b'}\n\ngoal (1 subgoal):\n 1. b = b'", "by (metis  u3' a1 complex_vector.dependent_def complex_vector.span_base \n        complex_vector.span_scale insertE insert_Diff u2 u2' u3)"], ["proof (state)\nthis:\n  b = b'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "hence \"b' = c *\\<^sub>C b'\""], ["proof (prove)\nusing this:\n  b = b'\n\ngoal (1 subgoal):\n 1. b' = c *\\<^sub>C b'", "using g1"], ["proof (prove)\nusing this:\n  b = b'\n  b = c *\\<^sub>C b'\n\ngoal (1 subgoal):\n 1. b' = c *\\<^sub>C b'", "by blast"], ["proof (state)\nthis:\n  b' = c *\\<^sub>C b'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<inter> (*\\<^sub>C) c ` B \\<noteq> {}; c \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> B \\<inter> (*\\<^sub>C) c ` B = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  b' = c *\\<^sub>C b'\n\ngoal (1 subgoal):\n 1. B \\<inter> (*\\<^sub>C) c ` B = {}", "by (metis a1 a3 complex_vector.dependent_zero complex_vector.scale_right_imp_eq\n        mult_cancel_right2 scaleC_scaleC u3')"], ["proof (state)\nthis:\n  B \\<inter> (*\\<^sub>C) c ` B = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma real_independent_from_complex_independent:\n  assumes \"cindependent (B::'a::complex_vector set)\"\n  defines \"B' == ((*\\<^sub>C) \\<i> ` B)\"\n  shows \"independent (B \\<union> B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. independent (B \\<union> B')", "proof (rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. dependent (B \\<union> B') \\<Longrightarrow> False", "assume \\<open>dependent (B \\<union> B')\\<close>"], ["proof (state)\nthis:\n  dependent (B \\<union> B')\n\ngoal (1 subgoal):\n 1. dependent (B \\<union> B') \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  dependent (B \\<union> B')", "obtain T f0 x where [simp]: \\<open>finite T\\<close> and \\<open>T \\<subseteq> B \\<union> B'\\<close> and f0_sum: \\<open>(\\<Sum>v\\<in>T. f0 v *\\<^sub>R v) = 0\\<close>\n    and x: \\<open>x \\<in> T\\<close> and f0_x: \\<open>f0 x \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  dependent (B \\<union> B')\n\ngoal (1 subgoal):\n 1. (\\<And>T f0 x.\n        \\<lbrakk>finite T; T \\<subseteq> B \\<union> B';\n         (\\<Sum>v\\<in>T. f0 v *\\<^sub>R v) = (0::'a); x \\<in> T;\n         f0 x \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: real_vector.dependent_explicit)"], ["proof (state)\nthis:\n  finite T\n  T \\<subseteq> B \\<union> B'\n  (\\<Sum>v\\<in>T. f0 v *\\<^sub>R v) = (0::'a)\n  x \\<in> T\n  f0 x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dependent (B \\<union> B') \\<Longrightarrow> False", "define f T1 T2 T' f' x' where \\<open>f v = (if v \\<in> T then f0 v else 0)\\<close> \n    and \\<open>T1 = T \\<inter> B\\<close> and \\<open>T2 = scaleC (-\\<i>) ` (T \\<inter> B')\\<close>\n    and \\<open>T' = T1 \\<union> T2\\<close> and \\<open>f' v = f v + \\<i> * f (\\<i> *\\<^sub>C v)\\<close>\n    and \\<open>x' = (if x \\<in> T1 then x else -\\<i> *\\<^sub>C x)\\<close> for v"], ["proof (state)\nthis:\n  f ?v = (if ?v \\<in> T then f0 ?v else 0)\n  T1 = T \\<inter> B\n  T2 = (*\\<^sub>C) (- \\<i>) ` (T \\<inter> B')\n  T' = T1 \\<union> T2\n  f' ?v =\n  complex_of_real (f ?v) + \\<i> * complex_of_real (f (\\<i> *\\<^sub>C ?v))\n  x' = (if x \\<in> T1 then x else - \\<i> *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. dependent (B \\<union> B') \\<Longrightarrow> False", "have \\<open>B \\<inter> B' = {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<inter> B' = {}", "by (simp add: assms cindependent_inter_scaleC_cindependent)"], ["proof (state)\nthis:\n  B \\<inter> B' = {}\n\ngoal (1 subgoal):\n 1. dependent (B \\<union> B') \\<Longrightarrow> False", "have \\<open>T' \\<subseteq> B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. T' \\<subseteq> B", "by (auto simp: T'_def T1_def T2_def B'_def)"], ["proof (state)\nthis:\n  T' \\<subseteq> B\n\ngoal (1 subgoal):\n 1. dependent (B \\<union> B') \\<Longrightarrow> False", "have [simp]: \\<open>finite T'\\<close> \\<open>finite T1\\<close> \\<open>finite T2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite T' &&& finite T1 &&& finite T2", "by (auto simp add: T'_def T1_def T2_def)"], ["proof (state)\nthis:\n  finite T'\n  finite T1\n  finite T2\n\ngoal (1 subgoal):\n 1. dependent (B \\<union> B') \\<Longrightarrow> False", "have f_sum: \\<open>(\\<Sum>v\\<in>T. f v *\\<^sub>R v) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T. f v *\\<^sub>R v) = (0::'a)", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T. (if v \\<in> T then f0 v else 0) *\\<^sub>R v) = (0::'a)", "using f0_sum"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>T. f0 v *\\<^sub>R v) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T. (if v \\<in> T then f0 v else 0) *\\<^sub>R v) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T. f v *\\<^sub>R v) = (0::'a)\n\ngoal (1 subgoal):\n 1. dependent (B \\<union> B') \\<Longrightarrow> False", "have f_x: \\<open>f x \\<noteq> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<noteq> 0", "using f0_x x"], ["proof (prove)\nusing this:\n  f0 x \\<noteq> 0\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. f x \\<noteq> 0", "by (auto simp: f_def)"], ["proof (state)\nthis:\n  f x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dependent (B \\<union> B') \\<Longrightarrow> False", "have f'_sum: \\<open>(\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "have \\<open>(\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (\\<Sum>v\\<in>T'. complex_of_real (f v) *\\<^sub>C v) + (\\<Sum>v\\<in>T'. (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) =\n    (\\<Sum>v\\<in>T'. complex_of_real (f v) *\\<^sub>C v) +\n    (\\<Sum>v\\<in>T'.\n       (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v)", "by (auto simp: f'_def sum.distrib scaleC_add_left)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) =\n  (\\<Sum>v\\<in>T'. complex_of_real (f v) *\\<^sub>C v) +\n  (\\<Sum>v\\<in>T'.\n     (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) =\n  (\\<Sum>v\\<in>T'. complex_of_real (f v) *\\<^sub>C v) +\n  (\\<Sum>v\\<in>T'.\n     (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "have \\<open>(\\<Sum>v\\<in>T'. complex_of_real (f v) *\\<^sub>C v) = (\\<Sum>v\\<in>T1. f v *\\<^sub>R v)\\<close> (is \\<open>_ = ?left\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. complex_of_real (f v) *\\<^sub>C v) =\n    (\\<Sum>v\\<in>T1. f v *\\<^sub>R v)", "apply (auto simp: T'_def scaleR_scaleC intro!: sum.mono_neutral_cong_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<notin> T1; i \\<in> T2; i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> f i = 0", "using T'_def T1_def \\<open>T' \\<subseteq> B\\<close> f_def"], ["proof (prove)\nusing this:\n  T' = T1 \\<union> T2\n  T1 = T \\<inter> B\n  T' \\<subseteq> B\n  f ?v = (if ?v \\<in> T then f0 ?v else 0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<notin> T1; i \\<in> T2; i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> f i = 0", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T'. complex_of_real (f v) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>T1. f v *\\<^sub>R v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T'. complex_of_real (f v) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>T1. f v *\\<^sub>R v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "have \\<open>(\\<Sum>v\\<in>T'. (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v) = (\\<Sum>v\\<in>T2. (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v)\\<close> (is \\<open>_ = ?right\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'.\n       (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v) =\n    (\\<Sum>v\\<in>T2.\n       (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v)", "apply (auto simp: T'_def intro!: sum.mono_neutral_cong_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<notin> T2; i \\<in> T1; i \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> f (\\<i> *\\<^sub>C i) = 0", "by (smt (z3) B'_def IntE IntI T1_def T2_def \\<open>f \\<equiv> \\<lambda>v. if v \\<in> T then f0 v else 0\\<close> add.inverse_inverse complex_vector.vector_space_axioms i_squared imageI mult_minus_left vector_space.vector_space_assms(3) vector_space.vector_space_assms(4))"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T'.\n     (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>T2.\n     (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T'.\n     (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>T2.\n     (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "have \\<open>?right = (\\<Sum>v\\<in>T\\<inter>B'. f v *\\<^sub>R v)\\<close> (is \\<open>_ = ?right\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T2.\n       (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v) =\n    (\\<Sum>v\\<in>T \\<inter> B'. f v *\\<^sub>R v)", "apply (rule sum.reindex_cong[symmetric, where l=\\<open>scaleC \\<i>\\<close>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on ((*\\<^sub>C) \\<i>) T2\n 2. T \\<inter> B' = (*\\<^sub>C) \\<i> ` T2\n 3. \\<And>x.\n       x \\<in> T2 \\<Longrightarrow>\n       f (\\<i> *\\<^sub>C x) *\\<^sub>R \\<i> *\\<^sub>C x =\n       (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C x))) *\\<^sub>C x", "apply (auto simp: T2_def image_image scaleR_scaleC)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((*\\<^sub>C) \\<i>)\n     ((\\<lambda>x. - (\\<i> *\\<^sub>C x)) ` (T \\<inter> B'))", "using inj_on_def"], ["proof (prove)\nusing this:\n  inj_on ?f ?A =\n  (\\<forall>x\\<in>?A.\n      \\<forall>y\\<in>?A. ?f x = ?f y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. inj_on ((*\\<^sub>C) \\<i>)\n     ((\\<lambda>x. - (\\<i> *\\<^sub>C x)) ` (T \\<inter> B'))", "by fastforce"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T2.\n     (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>T \\<inter> B'. f v *\\<^sub>R v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T2.\n     (\\<i> * complex_of_real (f (\\<i> *\\<^sub>C v))) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>T \\<inter> B'. f v *\\<^sub>R v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "have \\<open>?left + ?right = (\\<Sum>v\\<in>T. f v *\\<^sub>R v)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T1. f v *\\<^sub>R v) +\n    (\\<Sum>v\\<in>T \\<inter> B'. f v *\\<^sub>R v) =\n    (\\<Sum>v\\<in>T. f v *\\<^sub>R v)", "apply (subst sum.union_disjoint[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite T1\n 2. finite (T \\<inter> B')\n 3. T1 \\<inter> (T \\<inter> B') = {}\n 4. (\\<Sum>v\\<in>T1 \\<union> T \\<inter> B'. f v *\\<^sub>R v) =\n    (\\<Sum>v\\<in>T. f v *\\<^sub>R v)", "using \\<open>B \\<inter> B' = {}\\<close> \\<open>T \\<subseteq> B \\<union> B'\\<close>"], ["proof (prove)\nusing this:\n  B \\<inter> B' = {}\n  T \\<subseteq> B \\<union> B'\n\ngoal (4 subgoals):\n 1. finite T1\n 2. finite (T \\<inter> B')\n 3. T1 \\<inter> (T \\<inter> B') = {}\n 4. (\\<Sum>v\\<in>T1 \\<union> T \\<inter> B'. f v *\\<^sub>R v) =\n    (\\<Sum>v\\<in>T. f v *\\<^sub>R v)", "apply (auto simp: T1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B \\<inter> B' = {}; T \\<subseteq> B \\<union> B'\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>v\\<in>T \\<inter> B \\<union> T \\<inter> B'.\n                         f v *\\<^sub>R v) =\n                      (\\<Sum>v\\<in>T. f v *\\<^sub>R v)", "by (metis Int_Un_distrib Un_Int_eq(4) sup.absorb_iff1)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T1. f v *\\<^sub>R v) +\n  (\\<Sum>v\\<in>T \\<inter> B'. f v *\\<^sub>R v) =\n  (\\<Sum>v\\<in>T. f v *\\<^sub>R v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T1. f v *\\<^sub>R v) +\n  (\\<Sum>v\\<in>T \\<inter> B'. f v *\\<^sub>R v) =\n  (\\<Sum>v\\<in>T. f v *\\<^sub>R v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "have \\<open>\\<dots> = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T. f v *\\<^sub>R v) = (0::'a)", "by (rule f_sum)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T. f v *\\<^sub>R v) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)", "by -"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)\n\ngoal (1 subgoal):\n 1. dependent (B \\<union> B') \\<Longrightarrow> False", "have x': \\<open>x' \\<in> T'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<in> T'", "using \\<open>T \\<subseteq> B \\<union> B'\\<close> x"], ["proof (prove)\nusing this:\n  T \\<subseteq> B \\<union> B'\n  x \\<in> T\n\ngoal (1 subgoal):\n 1. x' \\<in> T'", "by (auto simp: x'_def T'_def T1_def T2_def)"], ["proof (state)\nthis:\n  x' \\<in> T'\n\ngoal (1 subgoal):\n 1. dependent (B \\<union> B') \\<Longrightarrow> False", "have f'_x': \\<open>f' x' \\<noteq> 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f' x' \\<noteq> 0", "using Complex_eq Complex_eq_0 f'_def f_x x'_def"], ["proof (prove)\nusing this:\n  Complex ?a ?b = complex_of_real ?a + \\<i> * complex_of_real ?b\n  (Complex ?a ?b = 0) = (?a = 0 \\<and> ?b = 0)\n  f' ?v =\n  complex_of_real (f ?v) + \\<i> * complex_of_real (f (\\<i> *\\<^sub>C ?v))\n  f x \\<noteq> 0\n  x' = (if x \\<in> T1 then x else - \\<i> *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. f' x' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f' x' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dependent (B \\<union> B') \\<Longrightarrow> False", "from \\<open>finite T'\\<close> \\<open>T' \\<subseteq> B\\<close> f'_sum x' f'_x'"], ["proof (chain)\npicking this:\n  finite T'\n  T' \\<subseteq> B\n  (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)\n  x' \\<in> T'\n  f' x' \\<noteq> 0", "have \\<open>cdependent B\\<close>"], ["proof (prove)\nusing this:\n  finite T'\n  T' \\<subseteq> B\n  (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)\n  x' \\<in> T'\n  f' x' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cdependent B", "using complex_vector.independent_explicit_module"], ["proof (prove)\nusing this:\n  finite T'\n  T' \\<subseteq> B\n  (\\<Sum>v\\<in>T'. f' v *\\<^sub>C v) = (0::'a)\n  x' \\<in> T'\n  f' x' \\<noteq> 0\n  cindependent ?s =\n  (\\<forall>t u v.\n      finite t \\<longrightarrow>\n      t \\<subseteq> ?s \\<longrightarrow>\n      (\\<Sum>v\\<in>t. u v *\\<^sub>C v) = (0::?'a) \\<longrightarrow>\n      v \\<in> t \\<longrightarrow> u v = 0)\n\ngoal (1 subgoal):\n 1. cdependent B", "by blast"], ["proof (state)\nthis:\n  cdependent B\n\ngoal (1 subgoal):\n 1. dependent (B \\<union> B') \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  cindependent B\n  B' \\<equiv> (*\\<^sub>C) \\<i> ` B\n  cdependent B", "show False"], ["proof (prove)\nusing this:\n  cindependent B\n  B' \\<equiv> (*\\<^sub>C) \\<i> ` B\n  cdependent B\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crepresentation_from_representation: \n  assumes a1: \"cindependent B\" and a2: \"b \\<in> B\" and a3: \"finite B\"\n  shows \"crepresentation B \\<psi> b = (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b)\n                           + \\<i> *\\<^sub>C (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> (\\<i> *\\<^sub>C b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "proof (cases \"\\<psi> \\<in> cspan B\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "define B' where \"B' = B \\<union> (*\\<^sub>C) \\<i> ` B\""], ["proof (state)\nthis:\n  B' = B \\<union> (*\\<^sub>C) \\<i> ` B\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "case True"], ["proof (state)\nthis:\n  \\<psi> \\<in> cspan B\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "define r  where \"r v = real_vector.representation B' \\<psi> v\" for v"], ["proof (state)\nthis:\n  r ?v = representation B' \\<psi> ?v\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "define r' where \"r' v = real_vector.representation B' \\<psi> (\\<i> *\\<^sub>C v)\" for v"], ["proof (state)\nthis:\n  r' ?v = representation B' \\<psi> (\\<i> *\\<^sub>C ?v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "define f  where \"f v = r v + \\<i> *\\<^sub>C r' v\" for v"], ["proof (state)\nthis:\n  f ?v = complex_of_real (r ?v) + \\<i> *\\<^sub>C complex_of_real (r' ?v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "define g  where \"g v = crepresentation B \\<psi> v\" for v"], ["proof (state)\nthis:\n  g ?v = crepresentation B \\<psi> ?v\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"(\\<Sum>v | g v \\<noteq> 0. g v *\\<^sub>C v) = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v | g v \\<noteq> 0. g v *\\<^sub>C v) = \\<psi>", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v | crepresentation B \\<psi> v \\<noteq> 0.\n       crepresentation B \\<psi> v *\\<^sub>C v) =\n    \\<psi>", "using Collect_cong Collect_mono_iff DiffD1 DiffD2 True a1 \n      complex_vector.finite_representation\n      complex_vector.sum_nonzero_representation_eq sum.mono_neutral_cong_left"], ["proof (prove)\nusing this:\n  (\\<And>x. ?P x = ?Q x) \\<Longrightarrow> {x. ?P x} = {x. ?Q x}\n  (Collect ?P \\<subseteq> Collect ?Q) =\n  (\\<forall>x. ?P x \\<longrightarrow> ?Q x)\n  ?c \\<in> ?A - ?B \\<Longrightarrow> ?c \\<in> ?A\n  \\<lbrakk>?c \\<in> ?A - ?B; ?c \\<in> ?B\\<rbrakk> \\<Longrightarrow> ?P\n  \\<psi> \\<in> cspan B\n  cindependent B\n  finite {b. crepresentation ?basis ?v b \\<noteq> 0}\n  \\<lbrakk>cindependent ?basis; ?v \\<in> cspan ?basis\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>b | crepresentation ?basis ?v b \\<noteq> 0.\n                       crepresentation ?basis ?v b *\\<^sub>C b) =\n                    ?v\n  \\<lbrakk>finite ?T; ?S \\<subseteq> ?T;\n   \\<forall>i\\<in>?T - ?S. ?h i = (0::?'a);\n   \\<And>x. x \\<in> ?S \\<Longrightarrow> ?g x = ?h x\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?S = sum ?h ?T\n\ngoal (1 subgoal):\n 1. (\\<Sum>v | crepresentation B \\<psi> v \\<noteq> 0.\n       crepresentation B \\<psi> v *\\<^sub>C v) =\n    \\<psi>", "by fastforce"], ["proof (state)\nthis:\n  (\\<Sum>v | g v \\<noteq> 0. g v *\\<^sub>C v) = \\<psi>\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>v | g v \\<noteq> 0. g v *\\<^sub>C v) = \\<psi>\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"finite {v. g v \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v. g v \\<noteq> 0}", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v. crepresentation B \\<psi> v \\<noteq> 0}", "by (simp add: complex_vector.finite_representation)"], ["proof (state)\nthis:\n  finite {v. g v \\<noteq> 0}\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "moreover"], ["proof (state)\nthis:\n  finite {v. g v \\<noteq> 0}\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"v \\<in> B\"\n    if \"g v \\<noteq> 0\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> B", "using that"], ["proof (prove)\nusing this:\n  g v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<in> B", "unfolding g_def"], ["proof (prove)\nusing this:\n  crepresentation B \\<psi> v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<in> B", "by (simp add: complex_vector.representation_ne_zero)"], ["proof (state)\nthis:\n  g ?v \\<noteq> 0 \\<Longrightarrow> ?v \\<in> B\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>v | g v \\<noteq> 0. g v *\\<^sub>C v) = \\<psi>\n  finite {v. g v \\<noteq> 0}\n  g ?v \\<noteq> 0 \\<Longrightarrow> ?v \\<in> B", "have rep1: \"(\\<Sum>v\\<in>B. g v *\\<^sub>C v) = \\<psi>\""], ["proof (prove)\nusing this:\n  (\\<Sum>v | g v \\<noteq> 0. g v *\\<^sub>C v) = \\<psi>\n  finite {v. g v \\<noteq> 0}\n  g ?v \\<noteq> 0 \\<Longrightarrow> ?v \\<in> B\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. g v *\\<^sub>C v) = \\<psi>", "unfolding g_def"], ["proof (prove)\nusing this:\n  (\\<Sum>v | crepresentation B \\<psi> v \\<noteq> 0.\n     crepresentation B \\<psi> v *\\<^sub>C v) =\n  \\<psi>\n  finite {v. crepresentation B \\<psi> v \\<noteq> 0}\n  crepresentation B \\<psi> ?v \\<noteq> 0 \\<Longrightarrow> ?v \\<in> B\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. crepresentation B \\<psi> v *\\<^sub>C v) = \\<psi>", "using a3 True a1 complex_vector.sum_representation_eq"], ["proof (prove)\nusing this:\n  (\\<Sum>v | crepresentation B \\<psi> v \\<noteq> 0.\n     crepresentation B \\<psi> v *\\<^sub>C v) =\n  \\<psi>\n  finite {v. crepresentation B \\<psi> v \\<noteq> 0}\n  crepresentation B \\<psi> ?v \\<noteq> 0 \\<Longrightarrow> ?v \\<in> B\n  finite B\n  \\<psi> \\<in> cspan B\n  cindependent B\n  \\<lbrakk>cindependent ?basis; ?v \\<in> cspan ?basis; finite ?B;\n   ?basis \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>b\\<in>?B.\n                       crepresentation ?basis ?v b *\\<^sub>C b) =\n                    ?v\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. crepresentation B \\<psi> v *\\<^sub>C v) = \\<psi>", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. g v *\\<^sub>C v) = \\<psi>\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have l0': \"inj ((*\\<^sub>C) \\<i>::'a \\<Rightarrow>'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ((*\\<^sub>C) \\<i>)", "unfolding inj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       \\<i> *\\<^sub>C x = \\<i> *\\<^sub>C y \\<longrightarrow> x = y", "by simp"], ["proof (state)\nthis:\n  inj ((*\\<^sub>C) \\<i>)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have l0: \"inj ((*\\<^sub>C) (- \\<i>)::'a \\<Rightarrow>'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ((*\\<^sub>C) (- \\<i>))", "unfolding inj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       - \\<i> *\\<^sub>C x = - \\<i> *\\<^sub>C y \\<longrightarrow> x = y", "by simp"], ["proof (state)\nthis:\n  inj ((*\\<^sub>C) (- \\<i>))\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have l1: \"(*\\<^sub>C) (- \\<i>) ` B \\<inter> B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (*\\<^sub>C) (- \\<i>) ` B \\<inter> B = {}", "using cindependent_inter_scaleC_cindependent[where B=B and c = \"- \\<i>\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>cindependent B; - \\<i> \\<noteq> 1\\<rbrakk>\n  \\<Longrightarrow> B \\<inter> (*\\<^sub>C) (- \\<i>) ` B = {}\n\ngoal (1 subgoal):\n 1. (*\\<^sub>C) (- \\<i>) ` B \\<inter> B = {}", "by (metis Int_commute a1 add.inverse_inverse complex_i_not_one i_squared mult_cancel_left1 \n        neg_equal_0_iff_equal)"], ["proof (state)\nthis:\n  (*\\<^sub>C) (- \\<i>) ` B \\<inter> B = {}\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have l2: \"B \\<inter> (*\\<^sub>C) \\<i> ` B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<inter> (*\\<^sub>C) \\<i> ` B = {}", "by (simp add: a1 cindependent_inter_scaleC_cindependent)"], ["proof (state)\nthis:\n  B \\<inter> (*\\<^sub>C) \\<i> ` B = {}\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have rr1: \"r (\\<i> *\\<^sub>C v) = r' v\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. r (\\<i> *\\<^sub>C v) = r' v", "unfolding r_def r'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. representation B' \\<psi> (\\<i> *\\<^sub>C v) =\n    representation B' \\<psi> (\\<i> *\\<^sub>C v)", "by simp"], ["proof (state)\nthis:\n  r (\\<i> *\\<^sub>C ?v) = r' ?v\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have k1: \"independent B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. independent B'", "unfolding B'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. independent (B \\<union> (*\\<^sub>C) \\<i> ` B)", "using a1 real_independent_from_complex_independent"], ["proof (prove)\nusing this:\n  cindependent B\n  cindependent ?B \\<Longrightarrow>\n  independent (?B \\<union> (*\\<^sub>C) \\<i> ` ?B)\n\ngoal (1 subgoal):\n 1. independent (B \\<union> (*\\<^sub>C) \\<i> ` B)", "by simp"], ["proof (state)\nthis:\n  independent B'\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"\\<psi> \\<in> span B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<in> span B'", "using B'_def True cspan_as_span"], ["proof (prove)\nusing this:\n  B' = B \\<union> (*\\<^sub>C) \\<i> ` B\n  \\<psi> \\<in> cspan B\n  cspan ?B = span (?B \\<union> (*\\<^sub>C) \\<i> ` ?B)\n\ngoal (1 subgoal):\n 1. \\<psi> \\<in> span B'", "by blast"], ["proof (state)\nthis:\n  \\<psi> \\<in> span B'\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"v \\<in> B'\"\n    if \"r v \\<noteq> 0\"\n    for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> B'", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> B'", "using r_def real_vector.representation_ne_zero that"], ["proof (prove)\nusing this:\n  r ?v = representation B' \\<psi> ?v\n  representation ?basis ?v ?b \\<noteq> 0 \\<Longrightarrow> ?b \\<in> ?basis\n  r v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<in> B'", "by auto"], ["proof (state)\nthis:\n  r ?v \\<noteq> 0 \\<Longrightarrow> ?v \\<in> B'\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"finite B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite B'", "unfolding B'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (B \\<union> (*\\<^sub>C) \\<i> ` B)", "using a3"], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. finite (B \\<union> (*\\<^sub>C) \\<i> ` B)", "by simp"], ["proof (state)\nthis:\n  finite B'\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"(\\<Sum>v\\<in>B'. r v *\\<^sub>R v) = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B'. r v *\\<^sub>R v) = \\<psi>", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B'. representation B' \\<psi> v *\\<^sub>R v) = \\<psi>", "using True  Real_Vector_Spaces.real_vector.sum_representation_eq[where B = B' and basis = B' \n        and v = \\<psi>]"], ["proof (prove)\nusing this:\n  \\<psi> \\<in> cspan B\n  \\<lbrakk>independent B'; \\<psi> \\<in> span B'; finite B';\n   B' \\<subseteq> B'\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>b\\<in>B'.\n                       representation B' \\<psi> b *\\<^sub>R b) =\n                    \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B'. representation B' \\<psi> v *\\<^sub>R v) = \\<psi>", "by (smt Real_Vector_Spaces.dependent_raw_def \\<open>\\<psi> \\<in> Real_Vector_Spaces.span B'\\<close> \\<open>finite B'\\<close> \n        equalityD2 k1)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B'. r v *\\<^sub>R v) = \\<psi>\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have d1: \"(\\<Sum>v\\<in>B. r (\\<i> *\\<^sub>C v) *\\<^sub>R (\\<i> *\\<^sub>C v)) = (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. r (\\<i> *\\<^sub>C v) *\\<^sub>R \\<i> *\\<^sub>C v) =\n    (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v)", "using l0'"], ["proof (prove)\nusing this:\n  inj ((*\\<^sub>C) \\<i>)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. r (\\<i> *\\<^sub>C v) *\\<^sub>R \\<i> *\\<^sub>C v) =\n    (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v)", "by (metis (mono_tags, lifting) inj_eq inj_on_def sum.reindex_cong)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. r (\\<i> *\\<^sub>C v) *\\<^sub>R \\<i> *\\<^sub>C v) =\n  (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"(\\<Sum>v\\<in>B. (r v + \\<i> * (r' v)) *\\<^sub>C v) = (\\<Sum>v\\<in>B. r v *\\<^sub>C v + (\\<i> * r' v) *\\<^sub>C v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B.\n       (complex_of_real (r v) + \\<i> * complex_of_real (r' v)) *\\<^sub>C\n       v) =\n    (\\<Sum>v\\<in>B.\n       complex_of_real (r v) *\\<^sub>C v +\n       (\\<i> * complex_of_real (r' v)) *\\<^sub>C v)", "by (meson scaleC_left.add)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B.\n     (complex_of_real (r v) + \\<i> * complex_of_real (r' v)) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>B.\n     complex_of_real (r v) *\\<^sub>C v +\n     (\\<i> * complex_of_real (r' v)) *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B.\n     (complex_of_real (r v) + \\<i> * complex_of_real (r' v)) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>B.\n     complex_of_real (r v) *\\<^sub>C v +\n     (\\<i> * complex_of_real (r' v)) *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"\\<dots> = (\\<Sum>v\\<in>B. r v *\\<^sub>C v) + (\\<Sum>v\\<in>B. (\\<i> * r' v) *\\<^sub>C v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B.\n       complex_of_real (r v) *\\<^sub>C v +\n       (\\<i> * complex_of_real (r' v)) *\\<^sub>C v) =\n    (\\<Sum>v\\<in>B. complex_of_real (r v) *\\<^sub>C v) +\n    (\\<Sum>v\\<in>B. (\\<i> * complex_of_real (r' v)) *\\<^sub>C v)", "using sum.distrib"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>?A. ?g x + ?h x) = sum ?g ?A + sum ?h ?A\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B.\n       complex_of_real (r v) *\\<^sub>C v +\n       (\\<i> * complex_of_real (r' v)) *\\<^sub>C v) =\n    (\\<Sum>v\\<in>B. complex_of_real (r v) *\\<^sub>C v) +\n    (\\<Sum>v\\<in>B. (\\<i> * complex_of_real (r' v)) *\\<^sub>C v)", "by fastforce"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B.\n     complex_of_real (r v) *\\<^sub>C v +\n     (\\<i> * complex_of_real (r' v)) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>B. complex_of_real (r v) *\\<^sub>C v) +\n  (\\<Sum>v\\<in>B. (\\<i> * complex_of_real (r' v)) *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B.\n     complex_of_real (r v) *\\<^sub>C v +\n     (\\<i> * complex_of_real (r' v)) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>B. complex_of_real (r v) *\\<^sub>C v) +\n  (\\<Sum>v\\<in>B. (\\<i> * complex_of_real (r' v)) *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"\\<dots> = (\\<Sum>v\\<in>B. r v *\\<^sub>C v) + (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C (r' v *\\<^sub>C v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. complex_of_real (r v) *\\<^sub>C v) +\n    (\\<Sum>v\\<in>B. (\\<i> * complex_of_real (r' v)) *\\<^sub>C v) =\n    (\\<Sum>v\\<in>B. complex_of_real (r v) *\\<^sub>C v) +\n    (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C complex_of_real (r' v) *\\<^sub>C v)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. complex_of_real (r v) *\\<^sub>C v) +\n  (\\<Sum>v\\<in>B. (\\<i> * complex_of_real (r' v)) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>B. complex_of_real (r v) *\\<^sub>C v) +\n  (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C complex_of_real (r' v) *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. complex_of_real (r v) *\\<^sub>C v) +\n  (\\<Sum>v\\<in>B. (\\<i> * complex_of_real (r' v)) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>B. complex_of_real (r v) *\\<^sub>C v) +\n  (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C complex_of_real (r' v) *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"\\<dots> = (\\<Sum>v\\<in>B. r v *\\<^sub>R v) + (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C (r (\\<i> *\\<^sub>C v) *\\<^sub>R v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. complex_of_real (r v) *\\<^sub>C v) +\n    (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C complex_of_real (r' v) *\\<^sub>C v) =\n    (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n    (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C r (\\<i> *\\<^sub>C v) *\\<^sub>R v)", "unfolding r'_def r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B.\n       complex_of_real (representation B' \\<psi> v) *\\<^sub>C v) +\n    (\\<Sum>v\\<in>B.\n       \\<i> *\\<^sub>C\n       complex_of_real\n        (representation B' \\<psi> (\\<i> *\\<^sub>C v)) *\\<^sub>C\n       v) =\n    (\\<Sum>v\\<in>B. representation B' \\<psi> v *\\<^sub>R v) +\n    (\\<Sum>v\\<in>B.\n       \\<i> *\\<^sub>C\n       representation B' \\<psi> (\\<i> *\\<^sub>C v) *\\<^sub>R v)", "by (metis (mono_tags, lifting) scaleR_scaleC sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. complex_of_real (r v) *\\<^sub>C v) +\n  (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C complex_of_real (r' v) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n  (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C r (\\<i> *\\<^sub>C v) *\\<^sub>R v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. complex_of_real (r v) *\\<^sub>C v) +\n  (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C complex_of_real (r' v) *\\<^sub>C v) =\n  (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n  (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C r (\\<i> *\\<^sub>C v) *\\<^sub>R v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"\\<dots> = (\\<Sum>v\\<in>B. r v *\\<^sub>R v) + (\\<Sum>v\\<in>B. r (\\<i> *\\<^sub>C v) *\\<^sub>R (\\<i> *\\<^sub>C v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n    (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C r (\\<i> *\\<^sub>C v) *\\<^sub>R v) =\n    (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n    (\\<Sum>v\\<in>B. r (\\<i> *\\<^sub>C v) *\\<^sub>R \\<i> *\\<^sub>C v)", "by (metis (no_types, lifting) complex_vector.scale_left_commute scaleR_scaleC)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n  (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C r (\\<i> *\\<^sub>C v) *\\<^sub>R v) =\n  (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n  (\\<Sum>v\\<in>B. r (\\<i> *\\<^sub>C v) *\\<^sub>R \\<i> *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n  (\\<Sum>v\\<in>B. \\<i> *\\<^sub>C r (\\<i> *\\<^sub>C v) *\\<^sub>R v) =\n  (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n  (\\<Sum>v\\<in>B. r (\\<i> *\\<^sub>C v) *\\<^sub>R \\<i> *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"\\<dots> = (\\<Sum>v\\<in>B. r v *\\<^sub>R v) + (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n    (\\<Sum>v\\<in>B. r (\\<i> *\\<^sub>C v) *\\<^sub>R \\<i> *\\<^sub>C v) =\n    (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n    (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v)", "using d1"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>B. r (\\<i> *\\<^sub>C v) *\\<^sub>R \\<i> *\\<^sub>C v) =\n  (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n    (\\<Sum>v\\<in>B. r (\\<i> *\\<^sub>C v) *\\<^sub>R \\<i> *\\<^sub>C v) =\n    (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n    (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n  (\\<Sum>v\\<in>B. r (\\<i> *\\<^sub>C v) *\\<^sub>R \\<i> *\\<^sub>C v) =\n  (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n  (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n  (\\<Sum>v\\<in>B. r (\\<i> *\\<^sub>C v) *\\<^sub>R \\<i> *\\<^sub>C v) =\n  (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n  (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"\\<dots> = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n    (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v) =\n    \\<psi>", "using l2 \\<open>(\\<Sum>v\\<in>B'. r v *\\<^sub>R v) = \\<psi>\\<close>"], ["proof (prove)\nusing this:\n  B \\<inter> (*\\<^sub>C) \\<i> ` B = {}\n  (\\<Sum>v\\<in>B'. r v *\\<^sub>R v) = \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n    (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v) =\n    \\<psi>", "unfolding B'_def"], ["proof (prove)\nusing this:\n  B \\<inter> (*\\<^sub>C) \\<i> ` B = {}\n  (\\<Sum>v\\<in>B \\<union> (*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v) = \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n    (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v) =\n    \\<psi>", "by (simp add: a3 sum.union_disjoint)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. r v *\\<^sub>R v) +\n  (\\<Sum>v\\<in>(*\\<^sub>C) \\<i> ` B. r v *\\<^sub>R v) =\n  \\<psi>\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>v\\<in>B.\n     (complex_of_real (r v) + \\<i> * complex_of_real (r' v)) *\\<^sub>C v) =\n  \\<psi>", "have \"(\\<Sum>v\\<in>B. f v *\\<^sub>C v) = \\<psi>\""], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>B.\n     (complex_of_real (r v) + \\<i> * complex_of_real (r' v)) *\\<^sub>C v) =\n  \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. f v *\\<^sub>C v) = \\<psi>", "unfolding r'_def r_def f_def"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>B.\n     (complex_of_real (representation B' \\<psi> v) +\n      \\<i> *\n      complex_of_real\n       (representation B' \\<psi> (\\<i> *\\<^sub>C v))) *\\<^sub>C\n     v) =\n  \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B.\n       (complex_of_real (representation B' \\<psi> v) +\n        \\<i> *\\<^sub>C\n        complex_of_real\n         (representation B' \\<psi> (\\<i> *\\<^sub>C v))) *\\<^sub>C\n       v) =\n    \\<psi>", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. f v *\\<^sub>C v) = \\<psi>\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "hence \"0 = (\\<Sum>v\\<in>B. f v *\\<^sub>C v) - (\\<Sum>v\\<in>B. crepresentation B \\<psi> v *\\<^sub>C v)\""], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>B. f v *\\<^sub>C v) = \\<psi>\n\ngoal (1 subgoal):\n 1. (0::'a) =\n    (\\<Sum>v\\<in>B. f v *\\<^sub>C v) -\n    (\\<Sum>v\\<in>B. crepresentation B \\<psi> v *\\<^sub>C v)", "using rep1"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>B. f v *\\<^sub>C v) = \\<psi>\n  (\\<Sum>v\\<in>B. g v *\\<^sub>C v) = \\<psi>\n\ngoal (1 subgoal):\n 1. (0::'a) =\n    (\\<Sum>v\\<in>B. f v *\\<^sub>C v) -\n    (\\<Sum>v\\<in>B. crepresentation B \\<psi> v *\\<^sub>C v)", "unfolding g_def"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>B. f v *\\<^sub>C v) = \\<psi>\n  (\\<Sum>v\\<in>B. crepresentation B \\<psi> v *\\<^sub>C v) = \\<psi>\n\ngoal (1 subgoal):\n 1. (0::'a) =\n    (\\<Sum>v\\<in>B. f v *\\<^sub>C v) -\n    (\\<Sum>v\\<in>B. crepresentation B \\<psi> v *\\<^sub>C v)", "by simp"], ["proof (state)\nthis:\n  (0::'a) =\n  (\\<Sum>v\\<in>B. f v *\\<^sub>C v) -\n  (\\<Sum>v\\<in>B. crepresentation B \\<psi> v *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "also"], ["proof (state)\nthis:\n  (0::'a) =\n  (\\<Sum>v\\<in>B. f v *\\<^sub>C v) -\n  (\\<Sum>v\\<in>B. crepresentation B \\<psi> v *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"\\<dots> = (\\<Sum>v\\<in>B. f v *\\<^sub>C v - crepresentation B \\<psi> v *\\<^sub>C v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. f v *\\<^sub>C v) -\n    (\\<Sum>v\\<in>B. crepresentation B \\<psi> v *\\<^sub>C v) =\n    (\\<Sum>v\\<in>B.\n       f v *\\<^sub>C v - crepresentation B \\<psi> v *\\<^sub>C v)", "by (simp add: sum_subtractf)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. f v *\\<^sub>C v) -\n  (\\<Sum>v\\<in>B. crepresentation B \\<psi> v *\\<^sub>C v) =\n  (\\<Sum>v\\<in>B. f v *\\<^sub>C v - crepresentation B \\<psi> v *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. f v *\\<^sub>C v) -\n  (\\<Sum>v\\<in>B. crepresentation B \\<psi> v *\\<^sub>C v) =\n  (\\<Sum>v\\<in>B. f v *\\<^sub>C v - crepresentation B \\<psi> v *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"\\<dots> = (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B.\n       f v *\\<^sub>C v - crepresentation B \\<psi> v *\\<^sub>C v) =\n    (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v)", "by (metis scaleC_left.diff)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B.\n     f v *\\<^sub>C v - crepresentation B \\<psi> v *\\<^sub>C v) =\n  (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "finally"], ["proof (chain)\npicking this:\n  (0::'a) = (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v)", "have \"0 = (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v)\""], ["proof (prove)\nusing this:\n  (0::'a) = (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v)\n\ngoal (1 subgoal):\n 1. (0::'a) =\n    (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v)", "."], ["proof (state)\nthis:\n  (0::'a) = (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "hence \"(\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v) = 0\""], ["proof (prove)\nusing this:\n  (0::'a) = (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v) =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v) = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "hence \"f b - crepresentation B \\<psi> b = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v) = (0::'a)\n\ngoal (1 subgoal):\n 1. f b - crepresentation B \\<psi> b = 0", "using a1 a2 a3 complex_vector.independentD[where s = B and t = B \n        and u = \"\\<lambda>v. f v - crepresentation B \\<psi> v\" and v = b]\n      order_refl"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v) = (0::'a)\n  cindependent B\n  b \\<in> B\n  finite B\n  \\<lbrakk>cindependent B; finite B; B \\<subseteq> B;\n   (\\<Sum>v\\<in>B. (f v - crepresentation B \\<psi> v) *\\<^sub>C v) =\n   (0::'a);\n   b \\<in> B\\<rbrakk>\n  \\<Longrightarrow> f b - crepresentation B \\<psi> b = 0\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. f b - crepresentation B \\<psi> b = 0", "by smt"], ["proof (state)\nthis:\n  f b - crepresentation B \\<psi> b = 0\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "hence \"crepresentation B \\<psi> b = f b\""], ["proof (prove)\nusing this:\n  f b - crepresentation B \\<psi> b = 0\n\ngoal (1 subgoal):\n 1. crepresentation B \\<psi> b = f b", "by simp"], ["proof (state)\nthis:\n  crepresentation B \\<psi> b = f b\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))\n 2. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "thus ?thesis"], ["proof (prove)\nusing this:\n  crepresentation B \\<psi> b = f b\n\ngoal (1 subgoal):\n 1. crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "unfolding f_def r_def r'_def B'_def"], ["proof (prove)\nusing this:\n  crepresentation B \\<psi> b =\n  complex_of_real\n   (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n  \\<i> *\\<^sub>C\n  complex_of_real\n   (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n     (\\<i> *\\<^sub>C b))\n\ngoal (1 subgoal):\n 1. crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "by auto"], ["proof (state)\nthis:\n  crepresentation B \\<psi> b =\n  complex_of_real\n   (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n  \\<i> *\\<^sub>C\n  complex_of_real\n   (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n     (\\<i> *\\<^sub>C b))\n\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "define B' where \"B' = B \\<union> (*\\<^sub>C) \\<i> ` B\""], ["proof (state)\nthis:\n  B' = B \\<union> (*\\<^sub>C) \\<i> ` B\n\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "case False"], ["proof (state)\nthis:\n  \\<psi> \\<notin> cspan B\n\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have b2: \"\\<psi> \\<notin> real_vector.span B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> span B'", "unfolding B'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> span (B \\<union> (*\\<^sub>C) \\<i> ` B)", "using False cspan_as_span"], ["proof (prove)\nusing this:\n  \\<psi> \\<notin> cspan B\n  cspan ?B = span (?B \\<union> (*\\<^sub>C) \\<i> ` ?B)\n\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> span (B \\<union> (*\\<^sub>C) \\<i> ` B)", "by auto"], ["proof (state)\nthis:\n  \\<psi> \\<notin> span B'\n\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"\\<psi> \\<notin> complex_vector.span B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> cspan B", "using False"], ["proof (prove)\nusing this:\n  \\<psi> \\<notin> cspan B\n\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> cspan B", "by blast"], ["proof (state)\nthis:\n  \\<psi> \\<notin> cspan B\n\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"crepresentation B \\<psi> b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crepresentation B \\<psi> b = 0", "unfolding complex_vector.representation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if cindependent B \\<and> \\<psi> \\<in> cspan B\n     then SOME f.\n             (\\<forall>v. f v \\<noteq> 0 \\<longrightarrow> v \\<in> B) \\<and>\n             finite {v. f v \\<noteq> 0} \\<and>\n             (\\<Sum>v | f v \\<noteq> 0. f v *\\<^sub>C v) = \\<psi>\n     else (\\<lambda>b. 0))\n     b =\n    0", "by (simp add: False)"], ["proof (state)\nthis:\n  crepresentation B \\<psi> b = 0\n\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "moreover"], ["proof (state)\nthis:\n  crepresentation B \\<psi> b = 0\n\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"real_vector.representation B' \\<psi> b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. representation B' \\<psi> b = 0", "unfolding real_vector.representation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if independent B' \\<and> \\<psi> \\<in> span B'\n     then SOME f.\n             (\\<forall>v.\n                 f v \\<noteq> 0 \\<longrightarrow> v \\<in> B') \\<and>\n             finite {v. f v \\<noteq> 0} \\<and>\n             (\\<Sum>v | f v \\<noteq> 0. f v *\\<^sub>R v) = \\<psi>\n     else (\\<lambda>b. 0))\n     b =\n    0", "by (simp add: b2)"], ["proof (state)\nthis:\n  representation B' \\<psi> b = 0\n\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "moreover"], ["proof (state)\nthis:\n  representation B' \\<psi> b = 0\n\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "have \"real_vector.representation B' \\<psi> ((*\\<^sub>C) \\<i> b) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. representation B' \\<psi> (\\<i> *\\<^sub>C b) = 0", "unfolding real_vector.representation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if independent B' \\<and> \\<psi> \\<in> span B'\n     then SOME f.\n             (\\<forall>v.\n                 f v \\<noteq> 0 \\<longrightarrow> v \\<in> B') \\<and>\n             finite {v. f v \\<noteq> 0} \\<and>\n             (\\<Sum>v | f v \\<noteq> 0. f v *\\<^sub>R v) = \\<psi>\n     else (\\<lambda>b. 0))\n     (\\<i> *\\<^sub>C b) =\n    0", "by (simp add: b2)"], ["proof (state)\nthis:\n  representation B' \\<psi> (\\<i> *\\<^sub>C b) = 0\n\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> cspan B \\<Longrightarrow>\n    crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "ultimately"], ["proof (chain)\npicking this:\n  crepresentation B \\<psi> b = 0\n  representation B' \\<psi> b = 0\n  representation B' \\<psi> (\\<i> *\\<^sub>C b) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  crepresentation B \\<psi> b = 0\n  representation B' \\<psi> b = 0\n  representation B' \\<psi> (\\<i> *\\<^sub>C b) = 0\n\ngoal (1 subgoal):\n 1. crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "unfolding B'_def"], ["proof (prove)\nusing this:\n  crepresentation B \\<psi> b = 0\n  representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b = 0\n  representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n   (\\<i> *\\<^sub>C b) =\n  0\n\ngoal (1 subgoal):\n 1. crepresentation B \\<psi> b =\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real\n     (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n       (\\<i> *\\<^sub>C b))", "by simp"], ["proof (state)\nthis:\n  crepresentation B \\<psi> b =\n  complex_of_real\n   (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi> b) +\n  \\<i> *\\<^sub>C\n  complex_of_real\n   (representation (B \\<union> (*\\<^sub>C) \\<i> ` B) \\<psi>\n     (\\<i> *\\<^sub>C b))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma CARD_1_vec_0[simp]: \\<open>(\\<psi> :: _ ::{complex_vector,CARD_1}) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> = (0::'a)", "by auto"], ["", "lemma scaleC_cindependent:\n  assumes a1: \"cindependent (B::'a::complex_vector set)\" and a3: \"c \\<noteq> 0\"\n  shows \"cindependent ((*\\<^sub>C) c ` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent ((*\\<^sub>C) c ` B)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cindependent ((*\\<^sub>C) c ` B)", "have \"u y = 0\"\n    if g1: \"y\\<in>S\" and g2: \"(\\<Sum>x\\<in>S. u x *\\<^sub>C x) = 0\" and g3: \"finite S\" and g4: \"S\\<subseteq>(*\\<^sub>C) c ` B\"\n    for u y S"], ["proof (prove)\ngoal (1 subgoal):\n 1. u y = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. u y = 0", "define v where \"v x = u (c *\\<^sub>C x)\" for x"], ["proof (state)\nthis:\n  v ?x = u (c *\\<^sub>C ?x)\n\ngoal (1 subgoal):\n 1. u y = 0", "obtain S' where \"S'\\<subseteq>B\" and S_S': \"S = (*\\<^sub>C) c ` S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S'.\n        \\<lbrakk>S' \\<subseteq> B; S = (*\\<^sub>C) c ` S'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson g4 subset_imageE)"], ["proof (state)\nthis:\n  S' \\<subseteq> B\n  S = (*\\<^sub>C) c ` S'\n\ngoal (1 subgoal):\n 1. u y = 0", "have \"inj ((*\\<^sub>C) c::'a\\<Rightarrow>_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ((*\\<^sub>C) c)", "unfolding inj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. c *\\<^sub>C x = c *\\<^sub>C y \\<longrightarrow> x = y", "using a3"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>x y. c *\\<^sub>C x = c *\\<^sub>C y \\<longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  inj ((*\\<^sub>C) c)\n\ngoal (1 subgoal):\n 1. u y = 0", "hence \"finite S'\""], ["proof (prove)\nusing this:\n  inj ((*\\<^sub>C) c)\n\ngoal (1 subgoal):\n 1. finite S'", "using S_S' finite_imageD g3 subset_inj_on"], ["proof (prove)\nusing this:\n  inj ((*\\<^sub>C) c)\n  S = (*\\<^sub>C) c ` S'\n  \\<lbrakk>finite (?f ` ?A); inj_on ?f ?A\\<rbrakk>\n  \\<Longrightarrow> finite ?A\n  finite S\n  \\<lbrakk>inj_on ?f ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> inj_on ?f ?A\n\ngoal (1 subgoal):\n 1. finite S'", "by blast"], ["proof (state)\nthis:\n  finite S'\n\ngoal (1 subgoal):\n 1. u y = 0", "have \"t \\<in> (*\\<^sub>C) (inverse c) ` S\"\n      if \"t \\<in> S'\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> (*\\<^sub>C) (inverse c) ` S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> (*\\<^sub>C) (inverse c) ` S", "have \"c *\\<^sub>C t \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C t \\<in> S", "using \\<open>S = (*\\<^sub>C) c ` S'\\<close> that"], ["proof (prove)\nusing this:\n  S = (*\\<^sub>C) c ` S'\n  t \\<in> S'\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C t \\<in> S", "by blast"], ["proof (state)\nthis:\n  c *\\<^sub>C t \\<in> S\n\ngoal (1 subgoal):\n 1. t \\<in> (*\\<^sub>C) (inverse c) ` S", "hence \"(inverse c) *\\<^sub>C (c *\\<^sub>C t) \\<in> (*\\<^sub>C) (inverse c) ` S\""], ["proof (prove)\nusing this:\n  c *\\<^sub>C t \\<in> S\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C t /\\<^sub>C c \\<in> (*\\<^sub>C) (inverse c) ` S", "by blast"], ["proof (state)\nthis:\n  c *\\<^sub>C t /\\<^sub>C c \\<in> (*\\<^sub>C) (inverse c) ` S\n\ngoal (1 subgoal):\n 1. t \\<in> (*\\<^sub>C) (inverse c) ` S", "moreover"], ["proof (state)\nthis:\n  c *\\<^sub>C t /\\<^sub>C c \\<in> (*\\<^sub>C) (inverse c) ` S\n\ngoal (1 subgoal):\n 1. t \\<in> (*\\<^sub>C) (inverse c) ` S", "have \"(inverse c) *\\<^sub>C (c *\\<^sub>C t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C t /\\<^sub>C c = t", "by (simp add: a3)"], ["proof (state)\nthis:\n  c *\\<^sub>C t /\\<^sub>C c = t\n\ngoal (1 subgoal):\n 1. t \\<in> (*\\<^sub>C) (inverse c) ` S", "ultimately"], ["proof (chain)\npicking this:\n  c *\\<^sub>C t /\\<^sub>C c \\<in> (*\\<^sub>C) (inverse c) ` S\n  c *\\<^sub>C t /\\<^sub>C c = t", "show ?thesis"], ["proof (prove)\nusing this:\n  c *\\<^sub>C t /\\<^sub>C c \\<in> (*\\<^sub>C) (inverse c) ` S\n  c *\\<^sub>C t /\\<^sub>C c = t\n\ngoal (1 subgoal):\n 1. t \\<in> (*\\<^sub>C) (inverse c) ` S", "by simp"], ["proof (state)\nthis:\n  t \\<in> (*\\<^sub>C) (inverse c) ` S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> S' \\<Longrightarrow> ?t \\<in> (*\\<^sub>C) (inverse c) ` S\n\ngoal (1 subgoal):\n 1. u y = 0", "moreover"], ["proof (state)\nthis:\n  ?t \\<in> S' \\<Longrightarrow> ?t \\<in> (*\\<^sub>C) (inverse c) ` S\n\ngoal (1 subgoal):\n 1. u y = 0", "have \"t \\<in> S'\"\n      if \"t \\<in> (*\\<^sub>C) (inverse c) ` S\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> S'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> S'", "obtain t' where \"t = (inverse c) *\\<^sub>C t'\" and \"t' \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t = t' /\\<^sub>C c; t' \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>t \\<in> (*\\<^sub>C) (inverse c) ` S\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> (*\\<^sub>C) (inverse c) ` S\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t = t' /\\<^sub>C c; t' \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t = t' /\\<^sub>C c\n  t' \\<in> S\n\ngoal (1 subgoal):\n 1. t \\<in> S'", "have \"c *\\<^sub>C t = c *\\<^sub>C ((inverse c) *\\<^sub>C t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C t = c *\\<^sub>C (t' /\\<^sub>C c)", "using \\<open>t = (inverse c) *\\<^sub>C t'\\<close>"], ["proof (prove)\nusing this:\n  t = t' /\\<^sub>C c\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C t = c *\\<^sub>C (t' /\\<^sub>C c)", "by simp"], ["proof (state)\nthis:\n  c *\\<^sub>C t = c *\\<^sub>C (t' /\\<^sub>C c)\n\ngoal (1 subgoal):\n 1. t \\<in> S'", "also"], ["proof (state)\nthis:\n  c *\\<^sub>C t = c *\\<^sub>C (t' /\\<^sub>C c)\n\ngoal (1 subgoal):\n 1. t \\<in> S'", "have \"\\<dots> = (c * (inverse c)) *\\<^sub>C t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C (t' /\\<^sub>C c) = (c * inverse c) *\\<^sub>C t'", "by simp"], ["proof (state)\nthis:\n  c *\\<^sub>C (t' /\\<^sub>C c) = (c * inverse c) *\\<^sub>C t'\n\ngoal (1 subgoal):\n 1. t \\<in> S'", "also"], ["proof (state)\nthis:\n  c *\\<^sub>C (t' /\\<^sub>C c) = (c * inverse c) *\\<^sub>C t'\n\ngoal (1 subgoal):\n 1. t \\<in> S'", "have \"\\<dots> = t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c * inverse c) *\\<^sub>C t' = t'", "by (simp add: a3)"], ["proof (state)\nthis:\n  (c * inverse c) *\\<^sub>C t' = t'\n\ngoal (1 subgoal):\n 1. t \\<in> S'", "finally"], ["proof (chain)\npicking this:\n  c *\\<^sub>C t = t'", "have \"c *\\<^sub>C t = t'\""], ["proof (prove)\nusing this:\n  c *\\<^sub>C t = t'\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C t = t'", "."], ["proof (state)\nthis:\n  c *\\<^sub>C t = t'\n\ngoal (1 subgoal):\n 1. t \\<in> S'", "thus ?thesis"], ["proof (prove)\nusing this:\n  c *\\<^sub>C t = t'\n\ngoal (1 subgoal):\n 1. t \\<in> S'", "using \\<open>t' \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  c *\\<^sub>C t = t'\n  t' \\<in> S\n\ngoal (1 subgoal):\n 1. t \\<in> S'", "using \\<open>S = (*\\<^sub>C) c ` S'\\<close> a3 complex_vector.scale_left_imp_eq"], ["proof (prove)\nusing this:\n  c *\\<^sub>C t = t'\n  t' \\<in> S\n  S = (*\\<^sub>C) c ` S'\n  c \\<noteq> 0\n  \\<lbrakk>?a \\<noteq> 0; ?a *\\<^sub>C ?x = ?a *\\<^sub>C ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. t \\<in> S'", "by blast"], ["proof (state)\nthis:\n  t \\<in> S'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> (*\\<^sub>C) (inverse c) ` S \\<Longrightarrow> ?t \\<in> S'\n\ngoal (1 subgoal):\n 1. u y = 0", "ultimately"], ["proof (chain)\npicking this:\n  ?t \\<in> S' \\<Longrightarrow> ?t \\<in> (*\\<^sub>C) (inverse c) ` S\n  ?t \\<in> (*\\<^sub>C) (inverse c) ` S \\<Longrightarrow> ?t \\<in> S'", "have \"S' = (*\\<^sub>C) (inverse c) ` S\""], ["proof (prove)\nusing this:\n  ?t \\<in> S' \\<Longrightarrow> ?t \\<in> (*\\<^sub>C) (inverse c) ` S\n  ?t \\<in> (*\\<^sub>C) (inverse c) ` S \\<Longrightarrow> ?t \\<in> S'\n\ngoal (1 subgoal):\n 1. S' = (*\\<^sub>C) (inverse c) ` S", "by blast"], ["proof (state)\nthis:\n  S' = (*\\<^sub>C) (inverse c) ` S\n\ngoal (1 subgoal):\n 1. u y = 0", "hence \"inverse c *\\<^sub>C y \\<in> S'\""], ["proof (prove)\nusing this:\n  S' = (*\\<^sub>C) (inverse c) ` S\n\ngoal (1 subgoal):\n 1. y /\\<^sub>C c \\<in> S'", "using that(1)"], ["proof (prove)\nusing this:\n  S' = (*\\<^sub>C) (inverse c) ` S\n  y \\<in> S\n\ngoal (1 subgoal):\n 1. y /\\<^sub>C c \\<in> S'", "by blast"], ["proof (state)\nthis:\n  y /\\<^sub>C c \\<in> S'\n\ngoal (1 subgoal):\n 1. u y = 0", "have t: \"inj (((*\\<^sub>C) c)::'a \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj ((*\\<^sub>C) c)", "using a3 complex_vector.injective_scale[where c = c]"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  c \\<noteq> 0 \\<Longrightarrow> inj ((*\\<^sub>C) c)\n\ngoal (1 subgoal):\n 1. inj ((*\\<^sub>C) c)", "by blast"], ["proof (state)\nthis:\n  inj ((*\\<^sub>C) c)\n\ngoal (1 subgoal):\n 1. u y = 0", "have \"0 = (\\<Sum>x\\<in>(*\\<^sub>C) c ` S'. u x *\\<^sub>C x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) = (\\<Sum>x\\<in>(*\\<^sub>C) c ` S'. u x *\\<^sub>C x)", "using \\<open>S = (*\\<^sub>C) c ` S'\\<close> that(2)"], ["proof (prove)\nusing this:\n  S = (*\\<^sub>C) c ` S'\n  (\\<Sum>x\\<in>S. u x *\\<^sub>C x) = (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) = (\\<Sum>x\\<in>(*\\<^sub>C) c ` S'. u x *\\<^sub>C x)", "by auto"], ["proof (state)\nthis:\n  (0::'a) = (\\<Sum>x\\<in>(*\\<^sub>C) c ` S'. u x *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. u y = 0", "also"], ["proof (state)\nthis:\n  (0::'a) = (\\<Sum>x\\<in>(*\\<^sub>C) c ` S'. u x *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. u y = 0", "have \"\\<dots> = (\\<Sum>x\\<in>S'. v x *\\<^sub>C (c *\\<^sub>C x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>(*\\<^sub>C) c ` S'. u x *\\<^sub>C x) =\n    (\\<Sum>x\\<in>S'. v x *\\<^sub>C c *\\<^sub>C x)", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>(*\\<^sub>C) c ` S'. u x *\\<^sub>C x) =\n    (\\<Sum>x\\<in>S'. u (c *\\<^sub>C x) *\\<^sub>C c *\\<^sub>C x)", "using t Groups_Big.comm_monoid_add_class.sum.reindex[where h = \"((*\\<^sub>C) c)\" and A = S' \n          and g = \"\\<lambda>x. u x *\\<^sub>C x\"] subset_inj_on"], ["proof (prove)\nusing this:\n  inj ((*\\<^sub>C) c)\n  inj_on ((*\\<^sub>C) c) S' \\<Longrightarrow>\n  (\\<Sum>x\\<in>(*\\<^sub>C) c ` S'. u x *\\<^sub>C x) =\n  sum ((\\<lambda>x. u x *\\<^sub>C x) \\<circ> (*\\<^sub>C) c) S'\n  \\<lbrakk>inj_on ?f ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> inj_on ?f ?A\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>(*\\<^sub>C) c ` S'. u x *\\<^sub>C x) =\n    (\\<Sum>x\\<in>S'. u (c *\\<^sub>C x) *\\<^sub>C c *\\<^sub>C x)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>(*\\<^sub>C) c ` S'. u x *\\<^sub>C x) =\n  (\\<Sum>x\\<in>S'. v x *\\<^sub>C c *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. u y = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>(*\\<^sub>C) c ` S'. u x *\\<^sub>C x) =\n  (\\<Sum>x\\<in>S'. v x *\\<^sub>C c *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. u y = 0", "have \"\\<dots> = c *\\<^sub>C (\\<Sum>x\\<in>S'. v x *\\<^sub>C x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>S'. v x *\\<^sub>C c *\\<^sub>C x) =\n    c *\\<^sub>C (\\<Sum>x\\<in>S'. v x *\\<^sub>C x)", "by (metis (mono_tags, lifting) complex_vector.scale_left_commute scaleC_right.sum sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>S'. v x *\\<^sub>C c *\\<^sub>C x) =\n  c *\\<^sub>C (\\<Sum>x\\<in>S'. v x *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. u y = 0", "finally"], ["proof (chain)\npicking this:\n  (0::'a) = c *\\<^sub>C (\\<Sum>x\\<in>S'. v x *\\<^sub>C x)", "have \"0 = c *\\<^sub>C (\\<Sum>x\\<in>S'. v x *\\<^sub>C x)\""], ["proof (prove)\nusing this:\n  (0::'a) = c *\\<^sub>C (\\<Sum>x\\<in>S'. v x *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. (0::'a) = c *\\<^sub>C (\\<Sum>x\\<in>S'. v x *\\<^sub>C x)", "."], ["proof (state)\nthis:\n  (0::'a) = c *\\<^sub>C (\\<Sum>x\\<in>S'. v x *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. u y = 0", "hence \"(\\<Sum>x\\<in>S'. v x *\\<^sub>C x) = 0\""], ["proof (prove)\nusing this:\n  (0::'a) = c *\\<^sub>C (\\<Sum>x\\<in>S'. v x *\\<^sub>C x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>S'. v x *\\<^sub>C x) = (0::'a)", "using a3"], ["proof (prove)\nusing this:\n  (0::'a) = c *\\<^sub>C (\\<Sum>x\\<in>S'. v x *\\<^sub>C x)\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>S'. v x *\\<^sub>C x) = (0::'a)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>S'. v x *\\<^sub>C x) = (0::'a)\n\ngoal (1 subgoal):\n 1. u y = 0", "hence \"v (inverse c *\\<^sub>C y) = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>S'. v x *\\<^sub>C x) = (0::'a)\n\ngoal (1 subgoal):\n 1. v (y /\\<^sub>C c) = 0", "using \\<open>inverse c *\\<^sub>C y \\<in> S'\\<close> \\<open>finite S'\\<close> \\<open>S' \\<subseteq> B\\<close> a1\n        complex_vector.independentD"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>S'. v x *\\<^sub>C x) = (0::'a)\n  y /\\<^sub>C c \\<in> S'\n  finite S'\n  S' \\<subseteq> B\n  cindependent B\n  \\<lbrakk>cindependent ?s; finite ?t; ?t \\<subseteq> ?s;\n   (\\<Sum>v\\<in>?t. ?u v *\\<^sub>C v) = (0::?'a); ?v \\<in> ?t\\<rbrakk>\n  \\<Longrightarrow> ?u ?v = 0\n\ngoal (1 subgoal):\n 1. v (y /\\<^sub>C c) = 0", "by blast"], ["proof (state)\nthis:\n  v (y /\\<^sub>C c) = 0\n\ngoal (1 subgoal):\n 1. u y = 0", "thus \"u y = 0\""], ["proof (prove)\nusing this:\n  v (y /\\<^sub>C c) = 0\n\ngoal (1 subgoal):\n 1. u y = 0", "unfolding v_def"], ["proof (prove)\nusing this:\n  u (c *\\<^sub>C (y /\\<^sub>C c)) = 0\n\ngoal (1 subgoal):\n 1. u y = 0", "by (simp add: a3)"], ["proof (state)\nthis:\n  u y = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> ?S; (\\<Sum>x\\<in>?S. ?u x *\\<^sub>C x) = (0::'a);\n   finite ?S; ?S \\<subseteq> (*\\<^sub>C) c ` B\\<rbrakk>\n  \\<Longrightarrow> ?u ?y = 0\n\ngoal (1 subgoal):\n 1. cindependent ((*\\<^sub>C) c ` B)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> ?S; (\\<Sum>x\\<in>?S. ?u x *\\<^sub>C x) = (0::'a);\n   finite ?S; ?S \\<subseteq> (*\\<^sub>C) c ` B\\<rbrakk>\n  \\<Longrightarrow> ?u ?y = 0\n\ngoal (1 subgoal):\n 1. cindependent ((*\\<^sub>C) c ` B)", "using complex_vector.dependent_explicit"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<in> ?S; (\\<Sum>x\\<in>?S. ?u x *\\<^sub>C x) = (0::'a);\n   finite ?S; ?S \\<subseteq> (*\\<^sub>C) c ` B\\<rbrakk>\n  \\<Longrightarrow> ?u ?y = 0\n  cdependent ?s =\n  (\\<exists>t u.\n      finite t \\<and>\n      t \\<subseteq> ?s \\<and>\n      (\\<Sum>v\\<in>t. u v *\\<^sub>C v) = (0::?'a) \\<and>\n      (\\<exists>v\\<in>t. u v \\<noteq> 0))\n\ngoal (1 subgoal):\n 1. cindependent ((*\\<^sub>C) c ` B)", "by (simp add: complex_vector.dependent_explicit )"], ["proof (state)\nthis:\n  cindependent ((*\\<^sub>C) c ` B)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Antilinear maps and friends\\<close>"], ["", "locale antilinear = additive f for f :: \"'a::complex_vector \\<Rightarrow> 'b::complex_vector\" +\n  assumes scaleC: \"f (scaleC r x) = cnj r *\\<^sub>C f x\""], ["", "sublocale antilinear \\<subseteq> linear"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear f", "proof (rule linearI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b1 b2. f (b1 + b2) = f b1 + f b2\n 2. \\<And>r b. f (r *\\<^sub>R b) = r *\\<^sub>R f b", "show \"f (b1 + b2) = f b1 + f b2\"\n    for b1 :: 'a\n      and b2 :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (b1 + b2) = f b1 + f b2", "by (simp add: add)"], ["proof (state)\nthis:\n  f (?b1.0 + ?b2.0) = f ?b1.0 + f ?b2.0\n\ngoal (1 subgoal):\n 1. \\<And>r b. f (r *\\<^sub>R b) = r *\\<^sub>R f b", "show \"f (r *\\<^sub>R b) = r *\\<^sub>R f b\"\n    for r :: real\n      and b :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (r *\\<^sub>R b) = r *\\<^sub>R f b", "unfolding scaleR_scaleC"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (complex_of_real r *\\<^sub>C b) = complex_of_real r *\\<^sub>C f b", "by (subst scaleC, simp)"], ["proof (state)\nthis:\n  f (?r *\\<^sub>R ?b) = ?r *\\<^sub>R f ?b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma antilinear_imp_scaleC:\n  fixes D :: \"complex \\<Rightarrow> 'a::complex_vector\"\n  assumes \"antilinear D\"\n  obtains d where \"D = (\\<lambda>x. cnj x *\\<^sub>C d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        D = (\\<lambda>x. cnj x *\\<^sub>C d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        D = (\\<lambda>x. cnj x *\\<^sub>C d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "interpret clinear \"D o cnj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear (D \\<circ> cnj)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       (D \\<circ> cnj) (b1 + b2) = (D \\<circ> cnj) b1 + (D \\<circ> cnj) b2\n 2. \\<And>r b.\n       (D \\<circ> cnj) (r *\\<^sub>C b) = r *\\<^sub>C (D \\<circ> cnj) b", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b1 b2. D (cnj b1 + cnj b2) = D (cnj b1) + D (cnj b2)\n 2. \\<And>r b. D (cnj r * cnj b) = r *\\<^sub>C D (cnj b)", "apply (simp add: additive.add assms antilinear.axioms(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r b. D (cnj r * cnj b) = r *\\<^sub>C D (cnj b)", "using assms antilinear.scaleC"], ["proof (prove)\nusing this:\n  antilinear D\n  antilinear ?f \\<Longrightarrow>\n  ?f (?r *\\<^sub>C ?x) = cnj ?r *\\<^sub>C ?f ?x\n\ngoal (1 subgoal):\n 1. \\<And>r b. D (cnj r * cnj b) = r *\\<^sub>C D (cnj b)", "by fastforce"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        D = (\\<lambda>x. cnj x *\\<^sub>C d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain d where \"D o cnj = (\\<lambda>x. x *\\<^sub>C d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        D \\<circ> cnj = (\\<lambda>x. x *\\<^sub>C d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using clinear_axioms complex_vector.linear_imp_scale"], ["proof (prove)\nusing this:\n  clinear (D \\<circ> cnj)\n  \\<lbrakk>clinear ?D;\n   \\<And>d.\n      ?D = (\\<lambda>x. x *\\<^sub>C d) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        D \\<circ> cnj = (\\<lambda>x. x *\\<^sub>C d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D \\<circ> cnj = (\\<lambda>x. x *\\<^sub>C d)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        D = (\\<lambda>x. cnj x *\\<^sub>C d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  D \\<circ> cnj = (\\<lambda>x. x *\\<^sub>C d)", "have \\<open>D = (\\<lambda>x. cnj x *\\<^sub>C d)\\<close>"], ["proof (prove)\nusing this:\n  D \\<circ> cnj = (\\<lambda>x. x *\\<^sub>C d)\n\ngoal (1 subgoal):\n 1. D = (\\<lambda>x. cnj x *\\<^sub>C d)", "by (metis comp_apply complex_cnj_cnj)"], ["proof (state)\nthis:\n  D = (\\<lambda>x. cnj x *\\<^sub>C d)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        D = (\\<lambda>x. cnj x *\\<^sub>C d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  D = (\\<lambda>x. cnj x *\\<^sub>C d)", "show ?thesis"], ["proof (prove)\nusing this:\n  D = (\\<lambda>x. cnj x *\\<^sub>C d)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary complex_antilinearD:\n  fixes f :: \"complex \\<Rightarrow> complex\"\n  assumes \"antilinear f\" obtains c where \"f = (\\<lambda>x. c * cnj x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        f = (\\<lambda>x. c * cnj x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule antilinear_imp_scaleC [OF assms]) (force simp: scaleC_conv_of_complex)"], ["", "lemma antilinearI:\n  assumes \"\\<And>x y. f (x + y) = f x + f y\"\n    and \"\\<And>c x. f (c *\\<^sub>C x) = cnj c *\\<^sub>C f x\"\n  shows \"antilinear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antilinear f", "by standard (rule assms)+"], ["", "lemma antilinear_o_antilinear: \"antilinear f \\<Longrightarrow> antilinear g \\<Longrightarrow> clinear (g o f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>antilinear f; antilinear g\\<rbrakk>\n    \\<Longrightarrow> clinear (g \\<circ> f)", "apply (rule clinearI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>antilinear f; antilinear g\\<rbrakk>\n       \\<Longrightarrow> (g \\<circ> f) (b1 + b2) =\n                         (g \\<circ> f) b1 + (g \\<circ> f) b2\n 2. \\<And>r b.\n       \\<lbrakk>antilinear f; antilinear g\\<rbrakk>\n       \\<Longrightarrow> (g \\<circ> f) (r *\\<^sub>C b) =\n                         r *\\<^sub>C (g \\<circ> f) b", "apply (simp add: additive.add antilinear_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r b.\n       \\<lbrakk>antilinear f; antilinear g\\<rbrakk>\n       \\<Longrightarrow> (g \\<circ> f) (r *\\<^sub>C b) =\n                         r *\\<^sub>C (g \\<circ> f) b", "by (simp add: antilinear.scaleC)"], ["", "lemma clinear_o_antilinear: \"antilinear f \\<Longrightarrow> clinear g \\<Longrightarrow> antilinear (g o f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>antilinear f; clinear g\\<rbrakk>\n    \\<Longrightarrow> antilinear (g \\<circ> f)", "apply (rule antilinearI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>antilinear f; clinear g\\<rbrakk>\n       \\<Longrightarrow> (g \\<circ> f) (x + y) =\n                         (g \\<circ> f) x + (g \\<circ> f) y\n 2. \\<And>c x.\n       \\<lbrakk>antilinear f; clinear g\\<rbrakk>\n       \\<Longrightarrow> (g \\<circ> f) (c *\\<^sub>C x) =\n                         cnj c *\\<^sub>C (g \\<circ> f) x", "apply (simp add: additive.add complex_vector.linear_add antilinear_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c x.\n       \\<lbrakk>antilinear f; clinear g\\<rbrakk>\n       \\<Longrightarrow> (g \\<circ> f) (c *\\<^sub>C x) =\n                         cnj c *\\<^sub>C (g \\<circ> f) x", "by (simp add: complex_vector.linear_scale antilinear.scaleC)"], ["", "lemma antilinear_o_clinear: \"clinear f \\<Longrightarrow> antilinear g \\<Longrightarrow> antilinear (g o f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>clinear f; antilinear g\\<rbrakk>\n    \\<Longrightarrow> antilinear (g \\<circ> f)", "apply (rule antilinearI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>clinear f; antilinear g\\<rbrakk>\n       \\<Longrightarrow> (g \\<circ> f) (x + y) =\n                         (g \\<circ> f) x + (g \\<circ> f) y\n 2. \\<And>c x.\n       \\<lbrakk>clinear f; antilinear g\\<rbrakk>\n       \\<Longrightarrow> (g \\<circ> f) (c *\\<^sub>C x) =\n                         cnj c *\\<^sub>C (g \\<circ> f) x", "apply (simp add: additive.add complex_vector.linear_add antilinear_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c x.\n       \\<lbrakk>clinear f; antilinear g\\<rbrakk>\n       \\<Longrightarrow> (g \\<circ> f) (c *\\<^sub>C x) =\n                         cnj c *\\<^sub>C (g \\<circ> f) x", "by (simp add: complex_vector.linear_scale antilinear.scaleC)"], ["", "locale bounded_antilinear = antilinear f for f :: \"'a::complex_normed_vector \\<Rightarrow> 'b::complex_normed_vector\" +\n  assumes bounded: \"\\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K\""], ["", "lemma bounded_antilinearI:\n  assumes \\<open>\\<And>b1 b2. f (b1 + b2) = f b1 + f b2\\<close>\n  assumes \\<open>\\<And>r b. f (r *\\<^sub>C b) = cnj r *\\<^sub>C f b\\<close>\n  assumes \\<open>\\<forall>x. norm (f x) \\<le> norm x * K\\<close>\n  shows \"bounded_antilinear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear f", "using assms"], ["proof (prove)\nusing this:\n  f (?b1.0 + ?b2.0) = f ?b1.0 + f ?b2.0\n  f (?r *\\<^sub>C ?b) = cnj ?r *\\<^sub>C f ?b\n  \\<forall>x. norm (f x) \\<le> norm x * K\n\ngoal (1 subgoal):\n 1. bounded_antilinear f", "by (auto intro!: exI bounded_antilinear.intro antilinearI simp: bounded_antilinear_axioms_def)"], ["", "sublocale bounded_antilinear \\<subseteq> bounded_linear"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear f", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f x) \\<le> norm x * K", "by (fact bounded)"], ["", "lemma (in bounded_antilinear) bounded_linear: \"bounded_linear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear f", "by (fact bounded_linear)"], ["", "lemma (in bounded_antilinear) antilinear: \"antilinear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antilinear f", "by (fact antilinear_axioms)"], ["", "lemma bounded_antilinear_intro:\n  assumes \"\\<And>x y. f (x + y) = f x + f y\"\n    and \"\\<And>r x. f (scaleC r x) = scaleC (cnj r) (f x)\"\n    and \"\\<And>x. norm (f x) \\<le> norm x * K\"\n  shows \"bounded_antilinear f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear f", "by standard (blast intro: assms)+"], ["", "lemma bounded_antilinear_0[simp]: \\<open>bounded_antilinear (\\<lambda>_. 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear (\\<lambda>_. 0::'b)", "by (rule bounded_antilinear_intro[where K=0], auto)"], ["", "lemma cnj_bounded_antilinear[simp]: \"bounded_antilinear cnj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear cnj", "apply (rule bounded_antilinear_intro [where K = 1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. cnj (x + y) = cnj x + cnj y\n 2. \\<And>r x. cnj (r *\\<^sub>C x) = cnj r *\\<^sub>C cnj x\n 3. \\<And>x. cmod (cnj x) \\<le> cmod x * 1", "by auto"], ["", "lemma bounded_antilinear_o_bounded_antilinear:\n  assumes \"bounded_antilinear f\"\n    and \"bounded_antilinear g\"\n  shows \"bounded_clinear (\\<lambda>x. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. f (g x))", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2. f (g (b1 + b2)) = f (g b1) + f (g b2)\n 2. \\<And>r b. f (g (r *\\<^sub>C b)) = r *\\<^sub>C f (g b)\n 3. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "interpret f: bounded_antilinear f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear f", "by fact"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2. f (g (b1 + b2)) = f (g b1) + f (g b2)\n 2. \\<And>r b. f (g (r *\\<^sub>C b)) = r *\\<^sub>C f (g b)\n 3. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "interpret g: bounded_antilinear g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear g", "by fact"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2. f (g (b1 + b2)) = f (g b1) + f (g b2)\n 2. \\<And>r b. f (g (r *\\<^sub>C b)) = r *\\<^sub>C f (g b)\n 3. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "fix b1 b2 b r"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b1 b2. f (g (b1 + b2)) = f (g b1) + f (g b2)\n 2. \\<And>r b. f (g (r *\\<^sub>C b)) = r *\\<^sub>C f (g b)\n 3. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "show \"f (g (b1 + b2)) = f (g b1) + f (g b2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (g (b1 + b2)) = f (g b1) + f (g b2)", "by (simp add: f.add g.add)"], ["proof (state)\nthis:\n  f (g (b1 + b2)) = f (g b1) + f (g b2)\n\ngoal (2 subgoals):\n 1. \\<And>r b. f (g (r *\\<^sub>C b)) = r *\\<^sub>C f (g b)\n 2. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "show \"f (g (r *\\<^sub>C b)) = r *\\<^sub>C f (g b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (g (r *\\<^sub>C b)) = r *\\<^sub>C f (g b)", "by (simp add: f.scaleC g.scaleC)"], ["proof (state)\nthis:\n  f (g (r *\\<^sub>C b)) = r *\\<^sub>C f (g b)\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "have \"bounded_linear (\\<lambda>x. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear (\\<lambda>x. f (g x))", "using f.bounded_linear g.bounded_linear"], ["proof (prove)\nusing this:\n  bounded_linear f\n  bounded_linear g\n\ngoal (1 subgoal):\n 1. bounded_linear (\\<lambda>x. f (g x))", "by (rule bounded_linear_compose)"], ["proof (state)\nthis:\n  bounded_linear (\\<lambda>x. f (g x))\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "then"], ["proof (chain)\npicking this:\n  bounded_linear (\\<lambda>x. f (g x))", "show \"\\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K\""], ["proof (prove)\nusing this:\n  bounded_linear (\\<lambda>x. f (g x))\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "by (rule bounded_linear.bounded)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_antilinear_o_bounded_clinear:\n  assumes \"bounded_antilinear f\"\n    and \"bounded_clinear g\"\n  shows \"bounded_antilinear (\\<lambda>x. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear (\\<lambda>x. f (g x))", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. f (g (x + y)) = f (g x) + f (g y)\n 2. \\<And>r x. f (g (r *\\<^sub>C x)) = cnj r *\\<^sub>C f (g x)\n 3. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "interpret f: bounded_antilinear f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear f", "by fact"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. f (g (x + y)) = f (g x) + f (g y)\n 2. \\<And>r x. f (g (r *\\<^sub>C x)) = cnj r *\\<^sub>C f (g x)\n 3. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "interpret g: bounded_clinear g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear g", "by fact"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. f (g (x + y)) = f (g x) + f (g y)\n 2. \\<And>r x. f (g (r *\\<^sub>C x)) = cnj r *\\<^sub>C f (g x)\n 3. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "show \"f (g (x + y)) = f (g x) + f (g y)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (g (x + y)) = f (g x) + f (g y)", "by (simp only: f.add g.add)"], ["proof (state)\nthis:\n  f (g (?x + ?y)) = f (g ?x) + f (g ?y)\n\ngoal (2 subgoals):\n 1. \\<And>r x. f (g (r *\\<^sub>C x)) = cnj r *\\<^sub>C f (g x)\n 2. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "show \"f (g (scaleC r x)) = scaleC (cnj r) (f (g x))\" for r x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (g (r *\\<^sub>C x)) = cnj r *\\<^sub>C f (g x)", "by (simp add: f.scaleC g.scaleC)"], ["proof (state)\nthis:\n  f (g (?r *\\<^sub>C ?x)) = cnj ?r *\\<^sub>C f (g ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "have \"bounded_linear (\\<lambda>x. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear (\\<lambda>x. f (g x))", "using f.bounded_linear g.bounded_linear"], ["proof (prove)\nusing this:\n  bounded_linear f\n  bounded_linear g\n\ngoal (1 subgoal):\n 1. bounded_linear (\\<lambda>x. f (g x))", "by (rule bounded_linear_compose)"], ["proof (state)\nthis:\n  bounded_linear (\\<lambda>x. f (g x))\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "then"], ["proof (chain)\npicking this:\n  bounded_linear (\\<lambda>x. f (g x))", "show \"\\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K\""], ["proof (prove)\nusing this:\n  bounded_linear (\\<lambda>x. f (g x))\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "by (rule bounded_linear.bounded)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_clinear_o_bounded_antilinear:\n  assumes \"bounded_clinear f\"\n    and \"bounded_antilinear g\"\n  shows \"bounded_antilinear (\\<lambda>x. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear (\\<lambda>x. f (g x))", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. f (g (x + y)) = f (g x) + f (g y)\n 2. \\<And>r x. f (g (r *\\<^sub>C x)) = cnj r *\\<^sub>C f (g x)\n 3. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "interpret f: bounded_clinear f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear f", "by fact"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. f (g (x + y)) = f (g x) + f (g y)\n 2. \\<And>r x. f (g (r *\\<^sub>C x)) = cnj r *\\<^sub>C f (g x)\n 3. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "interpret g: bounded_antilinear g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear g", "by fact"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. f (g (x + y)) = f (g x) + f (g y)\n 2. \\<And>r x. f (g (r *\\<^sub>C x)) = cnj r *\\<^sub>C f (g x)\n 3. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "show \"f (g (x + y)) = f (g x) + f (g y)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (g (x + y)) = f (g x) + f (g y)", "by (simp only: f.add g.add)"], ["proof (state)\nthis:\n  f (g (?x + ?y)) = f (g ?x) + f (g ?y)\n\ngoal (2 subgoals):\n 1. \\<And>r x. f (g (r *\\<^sub>C x)) = cnj r *\\<^sub>C f (g x)\n 2. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "show \"f (g (scaleC r x)) = scaleC (cnj r) (f (g x))\" for r x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (g (r *\\<^sub>C x)) = cnj r *\\<^sub>C f (g x)", "using f.scaleC g.scaleC"], ["proof (prove)\nusing this:\n  f (?r *\\<^sub>C ?b) = ?r *\\<^sub>C f ?b\n  g (?r *\\<^sub>C ?x) = cnj ?r *\\<^sub>C g ?x\n\ngoal (1 subgoal):\n 1. f (g (r *\\<^sub>C x)) = cnj r *\\<^sub>C f (g x)", "by fastforce"], ["proof (state)\nthis:\n  f (g (?r *\\<^sub>C ?x)) = cnj ?r *\\<^sub>C f (g ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "have \"bounded_linear (\\<lambda>x. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear (\\<lambda>x. f (g x))", "using f.bounded_linear g.bounded_linear"], ["proof (prove)\nusing this:\n  bounded_linear f\n  bounded_linear g\n\ngoal (1 subgoal):\n 1. bounded_linear (\\<lambda>x. f (g x))", "by (rule bounded_linear_compose)"], ["proof (state)\nthis:\n  bounded_linear (\\<lambda>x. f (g x))\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "then"], ["proof (chain)\npicking this:\n  bounded_linear (\\<lambda>x. f (g x))", "show \"\\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K\""], ["proof (prove)\nusing this:\n  bounded_linear (\\<lambda>x. f (g x))\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K", "by (rule bounded_linear.bounded)"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>x. norm (f (g x)) \\<le> norm x * K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_clinear_imp_inv_clinear: \"clinear (inv f)\"\n  if a1: \"clinear f\" and a2: \"bij f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clinear (inv f)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b1 b2. inv f (b1 + b2) = inv f b1 + inv f b2\n 2. \\<And>r b. inv f (r *\\<^sub>C b) = r *\\<^sub>C inv f b", "fix b1 b2 r b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b1 b2. inv f (b1 + b2) = inv f b1 + inv f b2\n 2. \\<And>r b. inv f (r *\\<^sub>C b) = r *\\<^sub>C inv f b", "show \"inv f (b1 + b2) = inv f b1 + inv f b2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv f (b1 + b2) = inv f b1 + inv f b2", "by (simp add: a1 a2 bij_is_inj bij_is_surj complex_vector.linear_add inv_f_eq surj_f_inv_f)"], ["proof (state)\nthis:\n  inv f (b1 + b2) = inv f b1 + inv f b2\n\ngoal (1 subgoal):\n 1. \\<And>r b. inv f (r *\\<^sub>C b) = r *\\<^sub>C inv f b", "show \"inv f (r *\\<^sub>C b) = r *\\<^sub>C inv f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv f (r *\\<^sub>C b) = r *\\<^sub>C inv f b", "using that"], ["proof (prove)\nusing this:\n  clinear f\n  bij f\n\ngoal (1 subgoal):\n 1. inv f (r *\\<^sub>C b) = r *\\<^sub>C inv f b", "by (smt bij_inv_eq_iff clinear_def complex_vector.linear_scale)"], ["proof (state)\nthis:\n  inv f (r *\\<^sub>C b) = r *\\<^sub>C inv f b\n\ngoal:\nNo subgoals!", "qed"], ["", "locale bounded_sesquilinear =\n  fixes \n    prod :: \"'a::complex_normed_vector \\<Rightarrow> 'b::complex_normed_vector \\<Rightarrow> 'c::complex_normed_vector\"\n      (infixl \"**\" 70)\n  assumes add_left: \"prod (a + a') b = prod a b + prod a' b\"\n    and add_right: \"prod a (b + b') = prod a b + prod a b'\"\n    and scaleC_left: \"prod (r *\\<^sub>C a) b = (cnj r) *\\<^sub>C (prod a b)\"\n    and scaleC_right: \"prod a (r *\\<^sub>C b) = r *\\<^sub>C (prod a b)\"\n    and bounded: \"\\<exists>K. \\<forall>a b. norm (prod a b) \\<le> norm a * norm b * K\""], ["", "sublocale bounded_sesquilinear \\<subseteq> bounded_bilinear"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_bilinear (**)", "apply standard"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a a' b. (a + a') ** b = a ** b + a' ** b\n 2. \\<And>a b b'. a ** (b + b') = a ** b + a ** b'\n 3. \\<And>r a b. r *\\<^sub>R a ** b = r *\\<^sub>R (a ** b)\n 4. \\<And>a r b. a ** r *\\<^sub>R b = r *\\<^sub>R (a ** b)\n 5. \\<exists>K. \\<forall>a b. norm (a ** b) \\<le> norm a * norm b * K", "by (auto simp: add_left add_right scaleC_left scaleC_right bounded scaleR_scaleC)"], ["", "lemma (in bounded_sesquilinear) bounded_bilinear[simp]: \"bounded_bilinear prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_bilinear (**)", "by (fact bounded_bilinear_axioms)"], ["", "lemma (in bounded_sesquilinear) bounded_antilinear_left: \"bounded_antilinear (\\<lambda>a. prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear (\\<lambda>a. a ** b)", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. (x + y) ** b = x ** b + y ** b\n 2. \\<And>r x. r *\\<^sub>C x ** b = cnj r *\\<^sub>C (x ** b)\n 3. \\<exists>K. \\<forall>x. norm (x ** b) \\<le> norm x * K", "apply (auto simp add: scaleC_left add_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (x ** b) \\<le> norm x * K", "by (metis ab_semigroup_mult_class.mult_ac(1) bounded)"], ["", "lemma (in bounded_sesquilinear) bounded_clinear_right: \"bounded_clinear (\\<lambda>b. prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear ((**) a)", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b1 b2. a ** (b1 + b2) = a ** b1 + a ** b2\n 2. \\<And>r b. a ** r *\\<^sub>C b = r *\\<^sub>C (a ** b)\n 3. \\<exists>K. \\<forall>x. norm (a ** x) \\<le> norm x * K", "apply (auto simp add: scaleC_right add_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>x. norm (a ** x) \\<le> norm x * K", "by (metis ab_semigroup_mult_class.mult_ac(1) ordered_field_class.sign_simps(34) pos_bounded)"], ["", "lemma (in bounded_sesquilinear) comp1:\n  assumes \\<open>bounded_clinear g\\<close>\n  shows \\<open>bounded_sesquilinear (\\<lambda>x. prod (g x))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x. (**) (g x))", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. g (a + a') ** b = g a ** b + g a' ** b\n 2. \\<And>a b b'. g a ** (b + b') = g a ** b + g a ** b'\n 3. \\<And>r a b. g (r *\\<^sub>C a) ** b = cnj r *\\<^sub>C (g a ** b)\n 4. \\<And>a r b. g a ** r *\\<^sub>C b = r *\\<^sub>C (g a ** b)\n 5. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "interpret bounded_clinear g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear g", "by fact"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. g (a + a') ** b = g a ** b + g a' ** b\n 2. \\<And>a b b'. g a ** (b + b') = g a ** b + g a ** b'\n 3. \\<And>r a b. g (r *\\<^sub>C a) ** b = cnj r *\\<^sub>C (g a ** b)\n 4. \\<And>a r b. g a ** r *\\<^sub>C b = r *\\<^sub>C (g a ** b)\n 5. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "fix a a' b b' r"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. g (a + a') ** b = g a ** b + g a' ** b\n 2. \\<And>a b b'. g a ** (b + b') = g a ** b + g a ** b'\n 3. \\<And>r a b. g (r *\\<^sub>C a) ** b = cnj r *\\<^sub>C (g a ** b)\n 4. \\<And>a r b. g a ** r *\\<^sub>C b = r *\\<^sub>C (g a ** b)\n 5. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "show \"prod (g (a + a')) b = prod (g a) b + prod (g a') b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (a + a') ** b = g a ** b + g a' ** b", "by (simp add: add add_left)"], ["proof (state)\nthis:\n  g (a + a') ** b = g a ** b + g a' ** b\n\ngoal (4 subgoals):\n 1. \\<And>a b b'. g a ** (b + b') = g a ** b + g a ** b'\n 2. \\<And>r a b. g (r *\\<^sub>C a) ** b = cnj r *\\<^sub>C (g a ** b)\n 3. \\<And>a r b. g a ** r *\\<^sub>C b = r *\\<^sub>C (g a ** b)\n 4. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "show \"prod (g a) (b + b') = prod (g a) b + prod (g a) b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g a ** (b + b') = g a ** b + g a ** b'", "by (simp add: add add_right)"], ["proof (state)\nthis:\n  g a ** (b + b') = g a ** b + g a ** b'\n\ngoal (3 subgoals):\n 1. \\<And>r a b. g (r *\\<^sub>C a) ** b = cnj r *\\<^sub>C (g a ** b)\n 2. \\<And>a r b. g a ** r *\\<^sub>C b = r *\\<^sub>C (g a ** b)\n 3. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "show \"prod (g (r *\\<^sub>C a)) b = cnj r *\\<^sub>C prod (g a) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (r *\\<^sub>C a) ** b = cnj r *\\<^sub>C (g a ** b)", "by (simp add: scaleC scaleC_left)"], ["proof (state)\nthis:\n  g (r *\\<^sub>C a) ** b = cnj r *\\<^sub>C (g a ** b)\n\ngoal (2 subgoals):\n 1. \\<And>a r b. g a ** r *\\<^sub>C b = r *\\<^sub>C (g a ** b)\n 2. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "show \"prod (g a) (r *\\<^sub>C b) = r *\\<^sub>C prod (g a) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g a ** r *\\<^sub>C b = r *\\<^sub>C (g a ** b)", "by (simp add: scaleC_right)"], ["proof (state)\nthis:\n  g a ** r *\\<^sub>C b = r *\\<^sub>C (g a ** b)\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "interpret bounded_bilinear \\<open>(\\<lambda>x. prod (g x))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_bilinear (\\<lambda>x. (**) (g x))", "by (simp add: bounded_linear comp1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "show \"\\<exists>K. \\<forall>a b. norm (prod (g a) b) \\<le> norm a * norm b * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "using bounded"], ["proof (prove)\nusing this:\n  \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K", "by blast"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>a b. norm (g a ** b) \\<le> norm a * norm b * K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in bounded_sesquilinear) comp2:\n  assumes \\<open>bounded_clinear g\\<close>\n  shows \\<open>bounded_sesquilinear (\\<lambda>x y. prod x (g y))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x y. x ** g y)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. (a + a') ** g b = a ** g b + a' ** g b\n 2. \\<And>a b b'. a ** g (b + b') = a ** g b + a ** g b'\n 3. \\<And>r a b. r *\\<^sub>C a ** g b = cnj r *\\<^sub>C (a ** g b)\n 4. \\<And>a r b. a ** g (r *\\<^sub>C b) = r *\\<^sub>C (a ** g b)\n 5. \\<exists>K. \\<forall>a b. norm (a ** g b) \\<le> norm a * norm b * K", "interpret bounded_clinear g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear g", "by fact"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. (a + a') ** g b = a ** g b + a' ** g b\n 2. \\<And>a b b'. a ** g (b + b') = a ** g b + a ** g b'\n 3. \\<And>r a b. r *\\<^sub>C a ** g b = cnj r *\\<^sub>C (a ** g b)\n 4. \\<And>a r b. a ** g (r *\\<^sub>C b) = r *\\<^sub>C (a ** g b)\n 5. \\<exists>K. \\<forall>a b. norm (a ** g b) \\<le> norm a * norm b * K", "fix a a' b b' r"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. (a + a') ** g b = a ** g b + a' ** g b\n 2. \\<And>a b b'. a ** g (b + b') = a ** g b + a ** g b'\n 3. \\<And>r a b. r *\\<^sub>C a ** g b = cnj r *\\<^sub>C (a ** g b)\n 4. \\<And>a r b. a ** g (r *\\<^sub>C b) = r *\\<^sub>C (a ** g b)\n 5. \\<exists>K. \\<forall>a b. norm (a ** g b) \\<le> norm a * norm b * K", "show \"prod (a + a') (g b) = prod a (g b) + prod a' (g b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + a') ** g b = a ** g b + a' ** g b", "by (simp add: add add_left)"], ["proof (state)\nthis:\n  (a + a') ** g b = a ** g b + a' ** g b\n\ngoal (4 subgoals):\n 1. \\<And>a b b'. a ** g (b + b') = a ** g b + a ** g b'\n 2. \\<And>r a b. r *\\<^sub>C a ** g b = cnj r *\\<^sub>C (a ** g b)\n 3. \\<And>a r b. a ** g (r *\\<^sub>C b) = r *\\<^sub>C (a ** g b)\n 4. \\<exists>K. \\<forall>a b. norm (a ** g b) \\<le> norm a * norm b * K", "show \"prod a (g (b + b')) = prod a (g b) + prod a (g b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ** g (b + b') = a ** g b + a ** g b'", "by (simp add: add add_right)"], ["proof (state)\nthis:\n  a ** g (b + b') = a ** g b + a ** g b'\n\ngoal (3 subgoals):\n 1. \\<And>r a b. r *\\<^sub>C a ** g b = cnj r *\\<^sub>C (a ** g b)\n 2. \\<And>a r b. a ** g (r *\\<^sub>C b) = r *\\<^sub>C (a ** g b)\n 3. \\<exists>K. \\<forall>a b. norm (a ** g b) \\<le> norm a * norm b * K", "show \"prod (r *\\<^sub>C a) (g b) = cnj r *\\<^sub>C prod a (g b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>C a ** g b = cnj r *\\<^sub>C (a ** g b)", "by (simp add: scaleC scaleC_left)"], ["proof (state)\nthis:\n  r *\\<^sub>C a ** g b = cnj r *\\<^sub>C (a ** g b)\n\ngoal (2 subgoals):\n 1. \\<And>a r b. a ** g (r *\\<^sub>C b) = r *\\<^sub>C (a ** g b)\n 2. \\<exists>K. \\<forall>a b. norm (a ** g b) \\<le> norm a * norm b * K", "show \"prod a (g (r *\\<^sub>C b)) = r *\\<^sub>C prod a (g b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ** g (r *\\<^sub>C b) = r *\\<^sub>C (a ** g b)", "by (simp add: scaleC scaleC_right)"], ["proof (state)\nthis:\n  a ** g (r *\\<^sub>C b) = r *\\<^sub>C (a ** g b)\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (a ** g b) \\<le> norm a * norm b * K", "interpret bounded_bilinear \\<open>(\\<lambda>x y. prod x (g y))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_bilinear (\\<lambda>x y. x ** g y)", "apply (rule bounded_bilinear.flip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_bilinear (\\<lambda>y x. x ** g y)", "using _ bounded_linear"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  bounded_linear g\n\ngoal (1 subgoal):\n 1. bounded_bilinear (\\<lambda>y x. x ** g y)", "apply (rule bounded_bilinear.comp1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_bilinear (\\<lambda>a b. b ** a)", "using bounded_bilinear"], ["proof (prove)\nusing this:\n  bounded_bilinear (**)\n\ngoal (1 subgoal):\n 1. bounded_bilinear (\\<lambda>a b. b ** a)", "by (rule bounded_bilinear.flip)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (a ** g b) \\<le> norm a * norm b * K", "show \"\\<exists>K. \\<forall>a b. norm (prod a (g b)) \\<le> norm a * norm b * K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (a ** g b) \\<le> norm a * norm b * K", "using bounded"], ["proof (prove)\nusing this:\n  \\<exists>K. \\<forall>a b. norm (a ** g b) \\<le> norm a * norm b * K\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (a ** g b) \\<le> norm a * norm b * K", "by blast"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>a b. norm (a ** g b) \\<le> norm a * norm b * K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in bounded_sesquilinear) comp: \"bounded_clinear f \\<Longrightarrow> bounded_clinear g \\<Longrightarrow> bounded_sesquilinear (\\<lambda>x y. prod (f x) (g y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded_clinear f; bounded_clinear g\\<rbrakk>\n    \\<Longrightarrow> bounded_sesquilinear (\\<lambda>x y. f x ** g y)", "using comp1 bounded_sesquilinear.comp2"], ["proof (prove)\nusing this:\n  bounded_clinear ?g \\<Longrightarrow>\n  bounded_sesquilinear (\\<lambda>x. (**) (?g x))\n  \\<lbrakk>bounded_sesquilinear ?prod; bounded_clinear ?g\\<rbrakk>\n  \\<Longrightarrow> bounded_sesquilinear (\\<lambda>x y. ?prod x (?g y))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded_clinear f; bounded_clinear g\\<rbrakk>\n    \\<Longrightarrow> bounded_sesquilinear (\\<lambda>x y. f x ** g y)", "by auto"], ["", "lemma bounded_clinear_const_scaleR:\n  fixes c :: real\n  assumes \\<open>bounded_clinear f\\<close>\n  shows \\<open>bounded_clinear (\\<lambda> x. c *\\<^sub>R f x )\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. c *\\<^sub>R f x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. c *\\<^sub>R f x)", "have  \\<open>bounded_clinear (\\<lambda> x. (complex_of_real c) *\\<^sub>C f x )\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. complex_of_real c *\\<^sub>C f x)", "by (simp add: assms bounded_clinear_const_scaleC)"], ["proof (state)\nthis:\n  bounded_clinear (\\<lambda>x. complex_of_real c *\\<^sub>C f x)\n\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. c *\\<^sub>R f x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  bounded_clinear (\\<lambda>x. complex_of_real c *\\<^sub>C f x)\n\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. c *\\<^sub>R f x)", "by (simp add: scaleR_scaleC)"], ["proof (state)\nthis:\n  bounded_clinear (\\<lambda>x. c *\\<^sub>R f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_linear_bounded_clinear:\n  \\<open>bounded_linear A \\<Longrightarrow> \\<forall>c x. A (c *\\<^sub>C x) = c *\\<^sub>C A x \\<Longrightarrow> bounded_clinear A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bounded_linear A;\n     \\<forall>c x. A (c *\\<^sub>C x) = c *\\<^sub>C A x\\<rbrakk>\n    \\<Longrightarrow> bounded_clinear A", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>bounded_linear A;\n        \\<forall>c x. A (c *\\<^sub>C x) = c *\\<^sub>C A x\\<rbrakk>\n       \\<Longrightarrow> A (b1 + b2) = A b1 + A b2\n 2. \\<And>r b.\n       \\<lbrakk>bounded_linear A;\n        \\<forall>c x. A (c *\\<^sub>C x) = c *\\<^sub>C A x\\<rbrakk>\n       \\<Longrightarrow> A (r *\\<^sub>C b) = r *\\<^sub>C A b\n 3. \\<lbrakk>bounded_linear A;\n     \\<forall>c x. A (c *\\<^sub>C x) = c *\\<^sub>C A x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>K. \\<forall>x. norm (A x) \\<le> norm x * K", "by (simp_all add: linear_simps bounded_linear.bounded)"], ["", "lemma comp_bounded_clinear:\n  fixes  A :: \\<open>'b::complex_normed_vector \\<Rightarrow> 'c::complex_normed_vector\\<close> \n    and B :: \\<open>'a::complex_normed_vector \\<Rightarrow> 'b\\<close>\n  assumes \\<open>bounded_clinear A\\<close> and \\<open>bounded_clinear B\\<close>\n  shows \\<open>bounded_clinear (A \\<circ> B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (A \\<circ> B)", "by (metis clinear_compose assms(1) assms(2) bounded_clinear_axioms_def bounded_clinear_compose bounded_clinear_def o_def)"], ["", "lemmas isCont_scaleC [simp] =\n  bounded_bilinear.isCont [OF bounded_cbilinear_scaleC[THEN bounded_cbilinear.bounded_bilinear]]"], ["", "subsection \\<open>Misc 2\\<close>"], ["", "lemmas sums_of_complex = bounded_linear.sums [OF bounded_clinear_of_complex[THEN bounded_clinear.bounded_linear]]"], ["", "lemmas summable_of_complex = bounded_linear.summable [OF bounded_clinear_of_complex[THEN bounded_clinear.bounded_linear]]"], ["", "lemmas suminf_of_complex = bounded_linear.suminf [OF bounded_clinear_of_complex[THEN bounded_clinear.bounded_linear]]"], ["", "lemmas sums_scaleC_left = bounded_linear.sums[OF bounded_clinear_scaleC_left[THEN bounded_clinear.bounded_linear]]"], ["", "lemmas summable_scaleC_left = bounded_linear.summable[OF bounded_clinear_scaleC_left[THEN bounded_clinear.bounded_linear]]"], ["", "lemmas suminf_scaleC_left = bounded_linear.suminf[OF bounded_clinear_scaleC_left[THEN bounded_clinear.bounded_linear]]"], ["", "lemmas sums_scaleC_right = bounded_linear.sums[OF bounded_clinear_scaleC_right[THEN bounded_clinear.bounded_linear]]"], ["", "lemmas summable_scaleC_right = bounded_linear.summable[OF bounded_clinear_scaleC_right[THEN bounded_clinear.bounded_linear]]"], ["", "lemmas suminf_scaleC_right = bounded_linear.suminf[OF bounded_clinear_scaleC_right[THEN bounded_clinear.bounded_linear]]"], ["", "lemma closed_scaleC: \n  fixes S::\\<open>'a::complex_normed_vector set\\<close> and a :: complex\n  assumes \\<open>closed S\\<close>\n  shows \\<open>closed ((*\\<^sub>C) a ` S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed ((*\\<^sub>C) a ` S)", "proof (cases \\<open>a = 0\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> closed ((*\\<^sub>C) a ` S)\n 2. a \\<noteq> 0 \\<Longrightarrow> closed ((*\\<^sub>C) a ` S)", "case True"], ["proof (state)\nthis:\n  a = 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<Longrightarrow> closed ((*\\<^sub>C) a ` S)\n 2. a \\<noteq> 0 \\<Longrightarrow> closed ((*\\<^sub>C) a ` S)", "then"], ["proof (chain)\npicking this:\n  a = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a = 0\n\ngoal (1 subgoal):\n 1. closed ((*\\<^sub>C) a ` S)", "apply (cases \\<open>S = {}\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = 0; S = {}\\<rbrakk>\n    \\<Longrightarrow> closed ((*\\<^sub>C) a ` S)\n 2. \\<lbrakk>a = 0; S \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> closed ((*\\<^sub>C) a ` S)", "by (auto simp: image_constant)"], ["proof (state)\nthis:\n  closed ((*\\<^sub>C) a ` S)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> closed ((*\\<^sub>C) a ` S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> closed ((*\\<^sub>C) a ` S)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> closed ((*\\<^sub>C) a ` S)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> 0", "have \\<open>(*\\<^sub>C) a ` S = (*\\<^sub>C) (inverse a) -` S\\<close>"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (*\\<^sub>C) a ` S = (*\\<^sub>C) (inverse a) -` S", "by (auto simp add: rev_image_eqI)"], ["proof (state)\nthis:\n  (*\\<^sub>C) a ` S = (*\\<^sub>C) (inverse a) -` S\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> closed ((*\\<^sub>C) a ` S)", "moreover"], ["proof (state)\nthis:\n  (*\\<^sub>C) a ` S = (*\\<^sub>C) (inverse a) -` S\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> closed ((*\\<^sub>C) a ` S)", "have \\<open>closed ((*\\<^sub>C) (inverse a) -` S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed ((*\\<^sub>C) (inverse a) -` S)", "by (simp add: assms continuous_closed_vimage)"], ["proof (state)\nthis:\n  closed ((*\\<^sub>C) (inverse a) -` S)\n\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> closed ((*\\<^sub>C) a ` S)", "ultimately"], ["proof (chain)\npicking this:\n  (*\\<^sub>C) a ` S = (*\\<^sub>C) (inverse a) -` S\n  closed ((*\\<^sub>C) (inverse a) -` S)", "show ?thesis"], ["proof (prove)\nusing this:\n  (*\\<^sub>C) a ` S = (*\\<^sub>C) (inverse a) -` S\n  closed ((*\\<^sub>C) (inverse a) -` S)\n\ngoal (1 subgoal):\n 1. closed ((*\\<^sub>C) a ` S)", "by simp"], ["proof (state)\nthis:\n  closed ((*\\<^sub>C) a ` S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closure_scaleC: \n  fixes S::\\<open>'a::complex_normed_vector set\\<close>\n  shows \\<open>closure ((*\\<^sub>C) a ` S) = (*\\<^sub>C) a ` closure S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure ((*\\<^sub>C) a ` S) = (*\\<^sub>C) a ` closure S", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. closure ((*\\<^sub>C) a ` S) \\<subseteq> (*\\<^sub>C) a ` closure S\n 2. (*\\<^sub>C) a ` closure S \\<subseteq> closure ((*\\<^sub>C) a ` S)", "have \\<open>closed (closure S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (closure S)", "by simp"], ["proof (state)\nthis:\n  closed (closure S)\n\ngoal (2 subgoals):\n 1. closure ((*\\<^sub>C) a ` S) \\<subseteq> (*\\<^sub>C) a ` closure S\n 2. (*\\<^sub>C) a ` closure S \\<subseteq> closure ((*\\<^sub>C) a ` S)", "show \"closure ((*\\<^sub>C) a ` S) \\<subseteq> (*\\<^sub>C) a ` closure S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closure ((*\\<^sub>C) a ` S) \\<subseteq> (*\\<^sub>C) a ` closure S", "by (simp add: closed_scaleC closure_minimal closure_subset image_mono)"], ["proof (state)\nthis:\n  closure ((*\\<^sub>C) a ` S) \\<subseteq> (*\\<^sub>C) a ` closure S\n\ngoal (1 subgoal):\n 1. (*\\<^sub>C) a ` closure S \\<subseteq> closure ((*\\<^sub>C) a ` S)", "have \"x \\<in> closure ((*\\<^sub>C) a ` S)\"\n    if \"x \\<in> (*\\<^sub>C) a ` closure S\"\n    for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> closure ((*\\<^sub>C) a ` S)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> closure ((*\\<^sub>C) a ` S)", "obtain t where \\<open>x = ((*\\<^sub>C) a) t\\<close> and \\<open>t \\<in> closure S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>x = a *\\<^sub>C t; t \\<in> closure S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>x \\<in> (*\\<^sub>C) a ` closure S\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> (*\\<^sub>C) a ` closure S\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>x = a *\\<^sub>C t; t \\<in> closure S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = a *\\<^sub>C t\n  t \\<in> closure S\n\ngoal (1 subgoal):\n 1. x \\<in> closure ((*\\<^sub>C) a ` S)", "have \\<open>\\<exists>s. (\\<forall>n. s n \\<in> S) \\<and> s \\<longlonglongrightarrow> t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s.\n       (\\<forall>n. s n \\<in> S) \\<and> s \\<longlonglongrightarrow> t", "using \\<open>t \\<in> closure S\\<close> Elementary_Topology.closure_sequential"], ["proof (prove)\nusing this:\n  t \\<in> closure S\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       (\\<forall>n. s n \\<in> S) \\<and> s \\<longlonglongrightarrow> t", "by blast"], ["proof (state)\nthis:\n  \\<exists>s. (\\<forall>n. s n \\<in> S) \\<and> s \\<longlonglongrightarrow> t\n\ngoal (1 subgoal):\n 1. x \\<in> closure ((*\\<^sub>C) a ` S)", "then"], ["proof (chain)\npicking this:\n  \\<exists>s. (\\<forall>n. s n \\<in> S) \\<and> s \\<longlonglongrightarrow> t", "obtain s where \\<open>\\<forall>n. s n \\<in> S\\<close> and \\<open>s \\<longlonglongrightarrow> t\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>s. (\\<forall>n. s n \\<in> S) \\<and> s \\<longlonglongrightarrow> t\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>\\<forall>n. s n \\<in> S;\n         s \\<longlonglongrightarrow> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>n. s n \\<in> S\n  s \\<longlonglongrightarrow> t\n\ngoal (1 subgoal):\n 1. x \\<in> closure ((*\\<^sub>C) a ` S)", "have \\<open>(\\<forall> n. scaleC a (s n) \\<in> ((*\\<^sub>C) a ` S))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. a *\\<^sub>C s n \\<in> (*\\<^sub>C) a ` S", "using \\<open>\\<forall>n. s n \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>n. s n \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>n. a *\\<^sub>C s n \\<in> (*\\<^sub>C) a ` S", "by blast"], ["proof (state)\nthis:\n  \\<forall>n. a *\\<^sub>C s n \\<in> (*\\<^sub>C) a ` S\n\ngoal (1 subgoal):\n 1. x \\<in> closure ((*\\<^sub>C) a ` S)", "moreover"], ["proof (state)\nthis:\n  \\<forall>n. a *\\<^sub>C s n \\<in> (*\\<^sub>C) a ` S\n\ngoal (1 subgoal):\n 1. x \\<in> closure ((*\\<^sub>C) a ` S)", "have \\<open>(\\<lambda> n. scaleC a (s n)) \\<longlonglongrightarrow> x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. a *\\<^sub>C s n) \\<longlonglongrightarrow> x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. a *\\<^sub>C s n) \\<longlonglongrightarrow> x", "have \\<open>isCont (scaleC a) t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont ((*\\<^sub>C) a) t", "by simp"], ["proof (state)\nthis:\n  isCont ((*\\<^sub>C) a) t\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. a *\\<^sub>C s n) \\<longlonglongrightarrow> x", "thus ?thesis"], ["proof (prove)\nusing this:\n  isCont ((*\\<^sub>C) a) t\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. a *\\<^sub>C s n) \\<longlonglongrightarrow> x", "using  \\<open>s \\<longlonglongrightarrow> t\\<close>  \\<open>x = ((*\\<^sub>C) a) t\\<close>"], ["proof (prove)\nusing this:\n  isCont ((*\\<^sub>C) a) t\n  s \\<longlonglongrightarrow> t\n  x = a *\\<^sub>C t\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. a *\\<^sub>C s n) \\<longlonglongrightarrow> x", "by (simp add: isCont_tendsto_compose)"], ["proof (state)\nthis:\n  (\\<lambda>n. a *\\<^sub>C s n) \\<longlonglongrightarrow> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>n. a *\\<^sub>C s n) \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. x \\<in> closure ((*\\<^sub>C) a ` S)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>n. a *\\<^sub>C s n \\<in> (*\\<^sub>C) a ` S\n  (\\<lambda>n. a *\\<^sub>C s n) \\<longlonglongrightarrow> x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n. a *\\<^sub>C s n \\<in> (*\\<^sub>C) a ` S\n  (\\<lambda>n. a *\\<^sub>C s n) \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. x \\<in> closure ((*\\<^sub>C) a ` S)", "using Elementary_Topology.closure_sequential"], ["proof (prove)\nusing this:\n  \\<forall>n. a *\\<^sub>C s n \\<in> (*\\<^sub>C) a ` S\n  (\\<lambda>n. a *\\<^sub>C s n) \\<longlonglongrightarrow> x\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n\ngoal (1 subgoal):\n 1. x \\<in> closure ((*\\<^sub>C) a ` S)", "by metis"], ["proof (state)\nthis:\n  x \\<in> closure ((*\\<^sub>C) a ` S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> (*\\<^sub>C) a ` closure S \\<Longrightarrow>\n  ?x \\<in> closure ((*\\<^sub>C) a ` S)\n\ngoal (1 subgoal):\n 1. (*\\<^sub>C) a ` closure S \\<subseteq> closure ((*\\<^sub>C) a ` S)", "thus \"(*\\<^sub>C) a ` closure S \\<subseteq> closure ((*\\<^sub>C) a ` S)\""], ["proof (prove)\nusing this:\n  ?x \\<in> (*\\<^sub>C) a ` closure S \\<Longrightarrow>\n  ?x \\<in> closure ((*\\<^sub>C) a ` S)\n\ngoal (1 subgoal):\n 1. (*\\<^sub>C) a ` closure S \\<subseteq> closure ((*\\<^sub>C) a ` S)", "by blast"], ["proof (state)\nthis:\n  (*\\<^sub>C) a ` closure S \\<subseteq> closure ((*\\<^sub>C) a ` S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma onorm_scalarC:\n  fixes f :: \\<open>'a::complex_normed_vector \\<Rightarrow> 'b::complex_normed_vector\\<close>\n  assumes a1: \\<open>bounded_clinear f\\<close>\n  shows  \\<open>onorm (\\<lambda> x. r *\\<^sub>C (f x)) = (cmod r) * onorm f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "have \\<open>(norm (f x)) / norm x \\<le> onorm f\\<close>\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (f x) / norm x \\<le> onorm f", "using a1"], ["proof (prove)\nusing this:\n  bounded_clinear f\n\ngoal (1 subgoal):\n 1. norm (f x) / norm x \\<le> onorm f", "by (simp add: bounded_clinear.bounded_linear le_onorm)"], ["proof (state)\nthis:\n  norm (f ?x) / norm ?x \\<le> onorm f\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "hence t2: \\<open>bdd_above {(norm (f x)) / norm x | x. True}\\<close>"], ["proof (prove)\nusing this:\n  norm (f ?x) / norm ?x \\<le> onorm f\n\ngoal (1 subgoal):\n 1. bdd_above {norm (f x) / norm x |x. True}", "by fastforce"], ["proof (state)\nthis:\n  bdd_above {norm (f x) / norm x |x. True}\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "have \\<open>continuous_on UNIV ( (*) w ) \\<close>\n    for w::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV ((*) w)", "by simp"], ["proof (state)\nthis:\n  continuous_on UNIV ((*) ?w)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "hence \\<open>isCont ( ((*) (cmod r)) ) x\\<close>\n    for x"], ["proof (prove)\nusing this:\n  continuous_on UNIV ((*) ?w)\n\ngoal (1 subgoal):\n 1. isCont ((*) (cmod r)) x", "by simp"], ["proof (state)\nthis:\n  isCont ((*) (cmod r)) ?x\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "hence t3: \\<open>continuous (at_left (Sup {(norm (f x)) / norm x | x. True})) ((*) (cmod r))\\<close>"], ["proof (prove)\nusing this:\n  isCont ((*) (cmod r)) ?x\n\ngoal (1 subgoal):\n 1. continuous (at_left (\\<Squnion> {norm (f x) / norm x |x. True}))\n     ((*) (cmod r))", "using Elementary_Topology.continuous_at_imp_continuous_within"], ["proof (prove)\nusing this:\n  isCont ((*) (cmod r)) ?x\n  isCont ?f ?x \\<Longrightarrow> continuous (at ?x within ?s) ?f\n\ngoal (1 subgoal):\n 1. continuous (at_left (\\<Squnion> {norm (f x) / norm x |x. True}))\n     ((*) (cmod r))", "by blast"], ["proof (state)\nthis:\n  continuous (at_left (\\<Squnion> {norm (f x) / norm x |x. True}))\n   ((*) (cmod r))\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "have \\<open>{(norm (f x)) / norm x | x. True} \\<noteq> {}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {norm (f x) / norm x |x. True} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  {norm (f x) / norm x |x. True} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "moreover"], ["proof (state)\nthis:\n  {norm (f x) / norm x |x. True} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "have \\<open>mono ((*) (cmod r))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono ((*) (cmod r))", "by (simp add: monoI ordered_comm_semiring_class.comm_mult_left_mono)"], ["proof (state)\nthis:\n  mono ((*) (cmod r))\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "ultimately"], ["proof (chain)\npicking this:\n  {norm (f x) / norm x |x. True} \\<noteq> {}\n  mono ((*) (cmod r))", "have \\<open>Sup {((*) (cmod r)) ((norm (f x)) / norm x) | x. True}\n         = ((*) (cmod r)) (Sup {(norm (f x)) / norm x | x. True})\\<close>"], ["proof (prove)\nusing this:\n  {norm (f x) / norm x |x. True} \\<noteq> {}\n  mono ((*) (cmod r))\n\ngoal (1 subgoal):\n 1. \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n    cmod r * \\<Squnion> {norm (f x) / norm x |x. True}", "using t2 t3"], ["proof (prove)\nusing this:\n  {norm (f x) / norm x |x. True} \\<noteq> {}\n  mono ((*) (cmod r))\n  bdd_above {norm (f x) / norm x |x. True}\n  continuous (at_left (\\<Squnion> {norm (f x) / norm x |x. True}))\n   ((*) (cmod r))\n\ngoal (1 subgoal):\n 1. \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n    cmod r * \\<Squnion> {norm (f x) / norm x |x. True}", "by (simp add:  continuous_at_Sup_mono full_SetCompr_eq image_image)"], ["proof (state)\nthis:\n  \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n  cmod r * \\<Squnion> {norm (f x) / norm x |x. True}\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "hence  \\<open>Sup {(cmod r) * ((norm (f x)) / norm x) | x. True}\n         = (cmod r) * (Sup {(norm (f x)) / norm x | x. True})\\<close>"], ["proof (prove)\nusing this:\n  \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n  cmod r * \\<Squnion> {norm (f x) / norm x |x. True}\n\ngoal (1 subgoal):\n 1. \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n    cmod r * \\<Squnion> {norm (f x) / norm x |x. True}", "by blast"], ["proof (state)\nthis:\n  \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n  cmod r * \\<Squnion> {norm (f x) / norm x |x. True}\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "moreover"], ["proof (state)\nthis:\n  \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n  cmod r * \\<Squnion> {norm (f x) / norm x |x. True}\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "have \\<open>Sup {(cmod r) * ((norm (f x)) / norm x) | x. True}\n                = (SUP x. cmod r * norm (f x) / norm x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n    (SUP x. cmod r * norm (f x) / norm x)", "by (simp add: full_SetCompr_eq)"], ["proof (state)\nthis:\n  \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n  (SUP x. cmod r * norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "moreover"], ["proof (state)\nthis:\n  \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n  (SUP x. cmod r * norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "have \\<open>(Sup {(norm (f x)) / norm x | x. True})\n                = (SUP x. norm (f x) / norm x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {norm (f x) / norm x |x. True} = (SUP x. norm (f x) / norm x)", "by (simp add: full_SetCompr_eq)"], ["proof (state)\nthis:\n  \\<Squnion> {norm (f x) / norm x |x. True} = (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "ultimately"], ["proof (chain)\npicking this:\n  \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n  cmod r * \\<Squnion> {norm (f x) / norm x |x. True}\n  \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n  (SUP x. cmod r * norm (f x) / norm x)\n  \\<Squnion> {norm (f x) / norm x |x. True} = (SUP x. norm (f x) / norm x)", "have t1: \"(SUP x. cmod r * norm (f x) / norm x) \n      = cmod r * (SUP x. norm (f x) / norm x)\""], ["proof (prove)\nusing this:\n  \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n  cmod r * \\<Squnion> {norm (f x) / norm x |x. True}\n  \\<Squnion> {cmod r * (norm (f x) / norm x) |x. True} =\n  (SUP x. cmod r * norm (f x) / norm x)\n  \\<Squnion> {norm (f x) / norm x |x. True} = (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. (SUP x. cmod r * norm (f x) / norm x) =\n    cmod r * (SUP x. norm (f x) / norm x)", "by simp"], ["proof (state)\nthis:\n  (SUP x. cmod r * norm (f x) / norm x) =\n  cmod r * (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "have \\<open>onorm (\\<lambda> x. r *\\<^sub>C (f x)) = (SUP x. norm ( (\\<lambda> t. r *\\<^sub>C (f t)) x) / norm x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) =\n    (SUP x. norm (r *\\<^sub>C f x) / norm x)", "by (simp add: onorm_def)"], ["proof (state)\nthis:\n  onorm (\\<lambda>x. r *\\<^sub>C f x) =\n  (SUP x. norm (r *\\<^sub>C f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "hence \\<open>onorm (\\<lambda> x. r *\\<^sub>C (f x)) = (SUP x. (cmod r) * (norm (f x)) / norm x)\\<close>"], ["proof (prove)\nusing this:\n  onorm (\\<lambda>x. r *\\<^sub>C f x) =\n  (SUP x. norm (r *\\<^sub>C f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) =\n    (SUP x. cmod r * norm (f x) / norm x)", "by simp"], ["proof (state)\nthis:\n  onorm (\\<lambda>x. r *\\<^sub>C f x) =\n  (SUP x. cmod r * norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "also"], ["proof (state)\nthis:\n  onorm (\\<lambda>x. r *\\<^sub>C f x) =\n  (SUP x. cmod r * norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "have \\<open>... = (cmod r) * (SUP x. (norm (f x)) / norm x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP x. cmod r * norm (f x) / norm x) =\n    cmod r * (SUP x. norm (f x) / norm x)", "using t1"], ["proof (prove)\nusing this:\n  (SUP x. cmod r * norm (f x) / norm x) =\n  cmod r * (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. (SUP x. cmod r * norm (f x) / norm x) =\n    cmod r * (SUP x. norm (f x) / norm x)", "."], ["proof (state)\nthis:\n  (SUP x. cmod r * norm (f x) / norm x) =\n  cmod r * (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "finally"], ["proof (chain)\npicking this:\n  onorm (\\<lambda>x. r *\\<^sub>C f x) =\n  cmod r * (SUP x. norm (f x) / norm x)", "show ?thesis"], ["proof (prove)\nusing this:\n  onorm (\\<lambda>x. r *\\<^sub>C f x) =\n  cmod r * (SUP x. norm (f x) / norm x)\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f", "by (simp add: onorm_def)"], ["proof (state)\nthis:\n  onorm (\\<lambda>x. r *\\<^sub>C f x) = cmod r * onorm f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma onorm_scaleC_left_lemma:\n  fixes f :: \"'a::complex_normed_vector\"\n  assumes r: \"bounded_clinear r\"\n  shows \"onorm (\\<lambda>x. r x *\\<^sub>C f) \\<le> onorm r * norm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r x *\\<^sub>C f) \\<le> onorm r * norm f", "proof (rule onorm_bound)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> onorm r * norm f\n 2. \\<And>x. norm (r x *\\<^sub>C f) \\<le> onorm r * norm f * norm x", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> onorm r * norm f\n 2. \\<And>x. norm (r x *\\<^sub>C f) \\<le> onorm r * norm f * norm x", "have \"norm (r x *\\<^sub>C f) = norm (r x) * norm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (r x *\\<^sub>C f) = cmod (r x) * norm f", "by simp"], ["proof (state)\nthis:\n  norm (r x *\\<^sub>C f) = cmod (r x) * norm f\n\ngoal (2 subgoals):\n 1. 0 \\<le> onorm r * norm f\n 2. \\<And>x. norm (r x *\\<^sub>C f) \\<le> onorm r * norm f * norm x", "also"], ["proof (state)\nthis:\n  norm (r x *\\<^sub>C f) = cmod (r x) * norm f\n\ngoal (2 subgoals):\n 1. 0 \\<le> onorm r * norm f\n 2. \\<And>x. norm (r x *\\<^sub>C f) \\<le> onorm r * norm f * norm x", "have \"\\<dots> \\<le> onorm r * norm x * norm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (r x) * norm f \\<le> onorm r * norm x * norm f", "by (simp add: bounded_clinear.bounded_linear mult.commute mult_left_mono onorm r)"], ["proof (state)\nthis:\n  cmod (r x) * norm f \\<le> onorm r * norm x * norm f\n\ngoal (2 subgoals):\n 1. 0 \\<le> onorm r * norm f\n 2. \\<And>x. norm (r x *\\<^sub>C f) \\<le> onorm r * norm f * norm x", "finally"], ["proof (chain)\npicking this:\n  norm (r x *\\<^sub>C f) \\<le> onorm r * norm x * norm f", "show \"norm (r x *\\<^sub>C f) \\<le> onorm r * norm f * norm x\""], ["proof (prove)\nusing this:\n  norm (r x *\\<^sub>C f) \\<le> onorm r * norm x * norm f\n\ngoal (1 subgoal):\n 1. norm (r x *\\<^sub>C f) \\<le> onorm r * norm f * norm x", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  norm (r x *\\<^sub>C f) \\<le> onorm r * norm f * norm x\n\ngoal (1 subgoal):\n 1. 0 \\<le> onorm r * norm f", "show \"0 \\<le> onorm r * norm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> onorm r * norm f", "by (simp add: bounded_clinear.bounded_linear onorm_pos_le r)"], ["proof (state)\nthis:\n  0 \\<le> onorm r * norm f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma onorm_scaleC_left:\n  fixes f :: \"'a::complex_normed_vector\"\n  assumes f: \"bounded_clinear r\"\n  shows \"onorm (\\<lambda>x. r x *\\<^sub>C f) = onorm r * norm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r x *\\<^sub>C f) = onorm r * norm f", "proof (cases \"f = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = (0::'a) \\<Longrightarrow>\n    onorm (\\<lambda>x. r x *\\<^sub>C f) = onorm r * norm f\n 2. f \\<noteq> (0::'a) \\<Longrightarrow>\n    onorm (\\<lambda>x. r x *\\<^sub>C f) = onorm r * norm f", "assume \"f \\<noteq> 0\""], ["proof (state)\nthis:\n  f \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. f = (0::'a) \\<Longrightarrow>\n    onorm (\\<lambda>x. r x *\\<^sub>C f) = onorm r * norm f\n 2. f \\<noteq> (0::'a) \\<Longrightarrow>\n    onorm (\\<lambda>x. r x *\\<^sub>C f) = onorm r * norm f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r x *\\<^sub>C f) = onorm r * norm f", "proof (rule order_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. onorm (\\<lambda>x. r x *\\<^sub>C f) \\<le> onorm r * norm f\n 2. onorm r * norm f \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)", "show \"onorm (\\<lambda>x. r x *\\<^sub>C f) \\<le> onorm r * norm f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r x *\\<^sub>C f) \\<le> onorm r * norm f", "using f"], ["proof (prove)\nusing this:\n  bounded_clinear r\n\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r x *\\<^sub>C f) \\<le> onorm r * norm f", "by (rule onorm_scaleC_left_lemma)"], ["proof (state)\nthis:\n  onorm (\\<lambda>x. r x *\\<^sub>C f) \\<le> onorm r * norm f\n\ngoal (1 subgoal):\n 1. onorm r * norm f \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. onorm r * norm f \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)", "have bl1: \"bounded_clinear (\\<lambda>x. r x *\\<^sub>C f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. r x *\\<^sub>C f)", "by (metis bounded_clinear_scaleC_const f)"], ["proof (state)\nthis:\n  bounded_clinear (\\<lambda>x. r x *\\<^sub>C f)\n\ngoal (1 subgoal):\n 1. onorm r * norm f \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)", "have x1:\"bounded_clinear (\\<lambda>x. r x * norm f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. r x * complex_of_real (norm f))", "by (metis bounded_clinear_mult_const f)"], ["proof (state)\nthis:\n  bounded_clinear (\\<lambda>x. r x * complex_of_real (norm f))\n\ngoal (1 subgoal):\n 1. onorm r * norm f \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)", "have \"onorm r \\<le> onorm (\\<lambda>x. r x * complex_of_real (norm f)) / norm f\"\n      if \"onorm r \\<le> onorm (\\<lambda>x. r x * complex_of_real (norm f)) * cmod (1 / complex_of_real (norm f))\"\n        and \"f \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm r\n    \\<le> onorm (\\<lambda>x. r x * complex_of_real (norm f)) / norm f", "using that"], ["proof (prove)\nusing this:\n  onorm r\n  \\<le> onorm (\\<lambda>x. r x * complex_of_real (norm f)) *\n        cmod (1 / complex_of_real (norm f))\n  f \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. onorm r\n    \\<le> onorm (\\<lambda>x. r x * complex_of_real (norm f)) / norm f", "by (metis complex_of_real_cmod complex_of_real_nn_iff field_class.field_divide_inverse \n          inverse_eq_divide nice_ordered_field_class.zero_le_divide_1_iff norm_ge_zero of_real_1 \n          of_real_divide of_real_eq_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>onorm r\n           \\<le> onorm (\\<lambda>x. r x * complex_of_real (norm f)) *\n                 cmod (1 / complex_of_real (norm f));\n   f \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> onorm r\n                    \\<le> onorm\n                           (\\<lambda>x. r x * complex_of_real (norm f)) /\n                          norm f\n\ngoal (1 subgoal):\n 1. onorm r * norm f \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)", "hence \"onorm r \\<le> onorm (\\<lambda>x. r x * norm f) * inverse (norm f)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>onorm r\n           \\<le> onorm (\\<lambda>x. r x * complex_of_real (norm f)) *\n                 cmod (1 / complex_of_real (norm f));\n   f \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> onorm r\n                    \\<le> onorm\n                           (\\<lambda>x. r x * complex_of_real (norm f)) /\n                          norm f\n\ngoal (1 subgoal):\n 1. onorm r\n    \\<le> onorm (\\<lambda>x. r x * complex_of_real (norm f)) *\n          inverse (norm f)", "using \\<open>f \\<noteq> 0\\<close> onorm_scaleC_left_lemma[OF x1, of \"inverse (norm f)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>onorm r\n           \\<le> onorm (\\<lambda>x. r x * complex_of_real (norm f)) *\n                 cmod (1 / complex_of_real (norm f));\n   f \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> onorm r\n                    \\<le> onorm\n                           (\\<lambda>x. r x * complex_of_real (norm f)) /\n                          norm f\n  f \\<noteq> (0::'a)\n  onorm\n   (\\<lambda>x.\n       (r x * complex_of_real (norm f)) *\\<^sub>C\n       complex_of_real (inverse (norm f)))\n  \\<le> onorm (\\<lambda>x. r x * complex_of_real (norm f)) *\n        cmod (complex_of_real (inverse (norm f)))\n\ngoal (1 subgoal):\n 1. onorm r\n    \\<le> onorm (\\<lambda>x. r x * complex_of_real (norm f)) *\n          inverse (norm f)", "by (simp add: inverse_eq_divide)"], ["proof (state)\nthis:\n  onorm r\n  \\<le> onorm (\\<lambda>x. r x * complex_of_real (norm f)) *\n        inverse (norm f)\n\ngoal (1 subgoal):\n 1. onorm r * norm f \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)", "also"], ["proof (state)\nthis:\n  onorm r\n  \\<le> onorm (\\<lambda>x. r x * complex_of_real (norm f)) *\n        inverse (norm f)\n\ngoal (1 subgoal):\n 1. onorm r * norm f \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)", "have \"onorm (\\<lambda>x. r x * norm f) \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onorm (\\<lambda>x. r x * complex_of_real (norm f))\n    \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)", "proof (rule onorm_bound)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)\n 2. \\<And>x.\n       cmod (r x * complex_of_real (norm f))\n       \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f) * norm x", "have \"bounded_linear (\\<lambda>x. r x *\\<^sub>C f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear (\\<lambda>x. r x *\\<^sub>C f)", "using bl1 bounded_clinear.bounded_linear"], ["proof (prove)\nusing this:\n  bounded_clinear (\\<lambda>x. r x *\\<^sub>C f)\n  bounded_clinear ?f \\<Longrightarrow> bounded_linear ?f\n\ngoal (1 subgoal):\n 1. bounded_linear (\\<lambda>x. r x *\\<^sub>C f)", "by auto"], ["proof (state)\nthis:\n  bounded_linear (\\<lambda>x. r x *\\<^sub>C f)\n\ngoal (2 subgoals):\n 1. 0 \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)\n 2. \\<And>x.\n       cmod (r x * complex_of_real (norm f))\n       \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f) * norm x", "thus \"0 \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)\""], ["proof (prove)\nusing this:\n  bounded_linear (\\<lambda>x. r x *\\<^sub>C f)\n\ngoal (1 subgoal):\n 1. 0 \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)", "by (rule Operator_Norm.onorm_pos_le)"], ["proof (state)\nthis:\n  0 \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       cmod (r x * complex_of_real (norm f))\n       \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f) * norm x", "show \"cmod (r x * complex_of_real (norm f)) \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f) * norm x\"\n        for x :: 'b"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (r x * complex_of_real (norm f))\n    \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f) * norm x", "by (smt \\<open>bounded_linear (\\<lambda>x. r x *\\<^sub>C f)\\<close> complex_of_real_cmod complex_of_real_nn_iff \n            complex_scaleC_def norm_ge_zero norm_scaleC of_real_eq_iff onorm)"], ["proof (state)\nthis:\n  cmod (r ?x * complex_of_real (norm f))\n  \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f) * norm ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  onorm (\\<lambda>x. r x * complex_of_real (norm f))\n  \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)\n\ngoal (1 subgoal):\n 1. onorm r * norm f \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x * inverse (norm f) \\<le> y * inverse (norm f)) \\<Longrightarrow>\n  onorm r \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f) * inverse (norm f)", "show \"onorm r * norm f \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x * inverse (norm f) \\<le> y * inverse (norm f)) \\<Longrightarrow>\n  onorm r \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f) * inverse (norm f)\n\ngoal (1 subgoal):\n 1. onorm r * norm f \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)", "using \\<open>f \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x * inverse (norm f) \\<le> y * inverse (norm f)) \\<Longrightarrow>\n  onorm r \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f) * inverse (norm f)\n  f \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. onorm r * norm f \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)", "by (simp add: inverse_eq_divide pos_le_divide_eq mult.commute)"], ["proof (state)\nthis:\n  onorm r * norm f \\<le> onorm (\\<lambda>x. r x *\\<^sub>C f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  onorm (\\<lambda>x. r x *\\<^sub>C f) = onorm r * norm f\n\ngoal (1 subgoal):\n 1. f = (0::'a) \\<Longrightarrow>\n    onorm (\\<lambda>x. r x *\\<^sub>C f) = onorm r * norm f", "qed (simp add: onorm_zero)"], ["", "subsection \\<open>Finite dimension and canonical basis\\<close>"], ["", "lemma vector_finitely_spanned:\n  assumes \\<open>z \\<in> cspan T\\<close>\n  shows \\<open>\\<exists> S. finite S \\<and> S \\<subseteq> T \\<and> z \\<in> cspan S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> S \\<subseteq> T \\<and> z \\<in> cspan S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> S \\<subseteq> T \\<and> z \\<in> cspan S", "have \\<open>\\<exists> S r. finite S \\<and> S \\<subseteq> T \\<and> z = (\\<Sum>a\\<in>S. r a *\\<^sub>C a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S r.\n       finite S \\<and>\n       S \\<subseteq> T \\<and> z = (\\<Sum>a\\<in>S. r a *\\<^sub>C a)", "using complex_vector.span_explicit[where b = \"T\"]\n      assms"], ["proof (prove)\nusing this:\n  cspan T =\n  {\\<Sum>a\\<in>t. r a *\\<^sub>C a |t r. finite t \\<and> t \\<subseteq> T}\n  z \\<in> cspan T\n\ngoal (1 subgoal):\n 1. \\<exists>S r.\n       finite S \\<and>\n       S \\<subseteq> T \\<and> z = (\\<Sum>a\\<in>S. r a *\\<^sub>C a)", "by auto"], ["proof (state)\nthis:\n  \\<exists>S r.\n     finite S \\<and>\n     S \\<subseteq> T \\<and> z = (\\<Sum>a\\<in>S. r a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> S \\<subseteq> T \\<and> z \\<in> cspan S", "then"], ["proof (chain)\npicking this:\n  \\<exists>S r.\n     finite S \\<and>\n     S \\<subseteq> T \\<and> z = (\\<Sum>a\\<in>S. r a *\\<^sub>C a)", "obtain S r where \\<open>finite S\\<close> and \\<open>S \\<subseteq> T\\<close> and \\<open>z = (\\<Sum>a\\<in>S. r a *\\<^sub>C a)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>S r.\n     finite S \\<and>\n     S \\<subseteq> T \\<and> z = (\\<Sum>a\\<in>S. r a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. (\\<And>S r.\n        \\<lbrakk>finite S; S \\<subseteq> T;\n         z = (\\<Sum>a\\<in>S. r a *\\<^sub>C a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite S\n  S \\<subseteq> T\n  z = (\\<Sum>a\\<in>S. r a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> S \\<subseteq> T \\<and> z \\<in> cspan S", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite S\n  S \\<subseteq> T\n  z = (\\<Sum>a\\<in>S. r a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> S \\<subseteq> T \\<and> z \\<in> cspan S", "by (meson complex_vector.span_scale complex_vector.span_sum complex_vector.span_superset subset_iff)"], ["proof (state)\nthis:\n  \\<exists>S. finite S \\<and> S \\<subseteq> T \\<and> z \\<in> cspan S\n\ngoal:\nNo subgoals!", "qed"], ["", "setup \\<open>Sign.add_const_constraint (\"Complex_Vector_Spaces0.cindependent\", SOME \\<^typ>\\<open>'a set \\<Rightarrow> bool\\<close>)\\<close>"], ["", "setup \\<open>Sign.add_const_constraint (\\<^const_name>\\<open>cdependent\\<close>, SOME \\<^typ>\\<open>'a set \\<Rightarrow> bool\\<close>)\\<close>"], ["", "setup \\<open>Sign.add_const_constraint (\\<^const_name>\\<open>cspan\\<close>, SOME \\<^typ>\\<open>'a set \\<Rightarrow> 'a set\\<close>)\\<close>"], ["", "class cfinite_dim = complex_vector +\n  assumes cfinitely_spanned: \"\\<exists>S::'a set. finite S \\<and> cspan S = UNIV\""], ["", "class basis_enum = complex_vector +\n  fixes canonical_basis :: \"'a list\"\n  assumes distinct_canonical_basis[simp]: \n    \"distinct canonical_basis\"\n    and is_cindependent_set[simp]:\n    \"cindependent (set canonical_basis)\"\n    and is_generator_set[simp]:\n    \"cspan (set canonical_basis) = UNIV\""], ["", "setup \\<open>Sign.add_const_constraint (\"Complex_Vector_Spaces0.cindependent\", SOME \\<^typ>\\<open>'a::complex_vector set \\<Rightarrow> bool\\<close>)\\<close>"], ["", "setup \\<open>Sign.add_const_constraint (\\<^const_name>\\<open>cdependent\\<close>, SOME \\<^typ>\\<open>'a::complex_vector set \\<Rightarrow> bool\\<close>)\\<close>"], ["", "setup \\<open>Sign.add_const_constraint (\\<^const_name>\\<open>cspan\\<close>, SOME \\<^typ>\\<open>'a::complex_vector set \\<Rightarrow> 'a set\\<close>)\\<close>"], ["", "lemma cdim_UNIV_basis_enum[simp]: \\<open>cdim (UNIV::'a::basis_enum set) = length (canonical_basis::'a list)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cdim UNIV = length canonical_basis", "apply (subst is_generator_set[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cdim (cspan (set canonical_basis)) = length canonical_basis", "apply (subst complex_vector.dim_span_eq_card_independent)"], ["proof (prove)\ngoal (2 subgoals):\n 1. cindependent (set canonical_basis)\n 2. card (set canonical_basis) = length canonical_basis", "apply (rule is_cindependent_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set canonical_basis) = length canonical_basis", "using distinct_canonical_basis distinct_card"], ["proof (prove)\nusing this:\n  distinct canonical_basis\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. card (set canonical_basis) = length canonical_basis", "by blast"], ["", "lemma finite_basis: \"\\<exists>basis::'a::cfinite_dim set. finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>basis.\n       finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>basis.\n       finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV", "from cfinitely_spanned"], ["proof (chain)\npicking this:\n  \\<exists>S. finite S \\<and> cspan S = UNIV", "obtain S :: \\<open>'a set\\<close> where \\<open>finite S\\<close> and \\<open>cspan S = UNIV\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>S. finite S \\<and> cspan S = UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>finite S; cspan S = UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite S\n  cspan S = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>basis.\n       finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV", "from complex_vector.maximal_independent_subset"], ["proof (chain)\npicking this:\n  (\\<And>B.\n      \\<lbrakk>B \\<subseteq> ?V; cindependent B;\n       ?V \\<subseteq> cspan B\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain B :: \\<open>'a set\\<close> where \\<open>B \\<subseteq> S\\<close> and \\<open>cindependent B\\<close> and \\<open>S \\<subseteq> cspan B\\<close>"], ["proof (prove)\nusing this:\n  (\\<And>B.\n      \\<lbrakk>B \\<subseteq> ?V; cindependent B;\n       ?V \\<subseteq> cspan B\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>B \\<subseteq> S; cindependent B;\n         S \\<subseteq> cspan B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  B \\<subseteq> S\n  cindependent B\n  S \\<subseteq> cspan B\n\ngoal (1 subgoal):\n 1. \\<exists>basis.\n       finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV", "moreover"], ["proof (state)\nthis:\n  B \\<subseteq> S\n  cindependent B\n  S \\<subseteq> cspan B\n\ngoal (1 subgoal):\n 1. \\<exists>basis.\n       finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV", "have \\<open>finite B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite B", "using \\<open>B \\<subseteq> S\\<close> \\<open>finite S\\<close>"], ["proof (prove)\nusing this:\n  B \\<subseteq> S\n  finite S\n\ngoal (1 subgoal):\n 1. finite B", "by (meson finite_subset)"], ["proof (state)\nthis:\n  finite B\n\ngoal (1 subgoal):\n 1. \\<exists>basis.\n       finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV", "moreover"], ["proof (state)\nthis:\n  finite B\n\ngoal (1 subgoal):\n 1. \\<exists>basis.\n       finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV", "have \\<open>cspan B = UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan B = UNIV", "using \\<open>cspan S = UNIV\\<close> \\<open>S \\<subseteq> cspan B\\<close>"], ["proof (prove)\nusing this:\n  cspan S = UNIV\n  S \\<subseteq> cspan B\n\ngoal (1 subgoal):\n 1. cspan B = UNIV", "by (metis complex_vector.span_eq top_greatest)"], ["proof (state)\nthis:\n  cspan B = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>basis.\n       finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV", "ultimately"], ["proof (chain)\npicking this:\n  B \\<subseteq> S\n  cindependent B\n  S \\<subseteq> cspan B\n  finite B\n  cspan B = UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  B \\<subseteq> S\n  cindependent B\n  S \\<subseteq> cspan B\n  finite B\n  cspan B = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>basis.\n       finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV", "by auto"], ["proof (state)\nthis:\n  \\<exists>basis.\n     finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "instance basis_enum \\<subseteq> cfinite_dim"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, cfinite_dim_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> cspan S = UNIV", "apply (rule exI[of _ \\<open>set canonical_basis\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set canonical_basis) \\<and> cspan (set canonical_basis) = UNIV", "using is_cindependent_set is_generator_set"], ["proof (prove)\nusing this:\n  cindependent (set canonical_basis)\n  cspan (set canonical_basis) = UNIV\n\ngoal (1 subgoal):\n 1. finite (set canonical_basis) \\<and> cspan (set canonical_basis) = UNIV", "by auto"], ["", "lemma cindependent_cfinite_dim_finite:\n  assumes \\<open>cindependent (S::'a::cfinite_dim set)\\<close>\n  shows \\<open>finite S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "by (metis assms cfinitely_spanned complex_vector.independent_span_bound top_greatest)"], ["", "lemma cfinite_dim_finite_subspace_basis:\n  assumes \\<open>csubspace X\\<close>\n  shows \"\\<exists>basis::'a::cfinite_dim set. finite basis \\<and> cindependent basis \\<and> cspan basis = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>basis.\n       finite basis \\<and> cindependent basis \\<and> cspan basis = X", "by (meson assms cindependent_cfinite_dim_finite complex_vector.basis_exists complex_vector.span_subspace)"], ["", "text \\<open>The following auxiliary lemma (\\<open>finite_span_complete_aux\\<close>) shows more or less the same as \\<open>finite_span_representation_bounded\\<close>,\n   \\<open>finite_span_complete\\<close> below (see there for an intuition about the mathematical \n   content of the lemmas). However, there is one difference: Here we additionally assume here\n   that there is a bijection rep/abs between a finite type \\<^typ>\\<open>'basis\\<close> and the set $B$.\n   This is needed to be able to use results about euclidean spaces that are formulated w.r.t.\n   the type class \\<^class>\\<open>finite\\<close>\n\n   Since we anyway assume that $B$ is finite, this added assumption does not make the lemma\n   weaker. However, we cannot derive the existence of \\<^typ>\\<open>'basis\\<close> inside the proof\n   (HOL does not support such reasoning). Therefore we have the type \\<^typ>\\<open>'basis\\<close> as\n   an explicit assumption and remove it using @{attribute internalize_sort} after the proof.\\<close>"], ["", "lemma finite_span_complete_aux:\n  fixes b :: \"'b::real_normed_vector\" and B :: \"'b set\"\n    and  rep :: \"'basis::finite \\<Rightarrow> 'b\" and abs :: \"'b \\<Rightarrow> 'basis\"\n  assumes t: \"type_definition rep abs B\"\n    and t1: \"finite B\" and t2: \"b\\<in>B\" and t3: \"independent B\"\n  shows \"\\<exists>D>0. \\<forall>\\<psi>. norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\"\n    and \"complete (span B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D &&&\n    complete (span B)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "define repr  where \"repr = real_vector.representation B\""], ["proof (state)\nthis:\n  repr = representation B\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "define repr' where \"repr' \\<psi> = Abs_euclidean_space (repr \\<psi> o rep)\" for \\<psi>"], ["proof (state)\nthis:\n  repr' ?\\<psi> = Abs_euclidean_space (repr ?\\<psi> \\<circ> rep)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "define comb  where \"comb l = (\\<Sum>b\\<in>B. l b *\\<^sub>R b)\" for l"], ["proof (state)\nthis:\n  comb ?l = (\\<Sum>b\\<in>B. ?l b *\\<^sub>R b)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "define comb' where \"comb' l = comb (Rep_euclidean_space l o abs)\" for l"], ["proof (state)\nthis:\n  comb' ?l = comb (Rep_euclidean_space ?l \\<circ> abs)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have comb_cong: \"comb x = comb y\" if \"\\<And>z. z\\<in>B \\<Longrightarrow> x z = y z\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. comb x = comb y", "unfolding comb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>B. x b *\\<^sub>R b) = (\\<Sum>b\\<in>B. y b *\\<^sub>R b)", "using that"], ["proof (prove)\nusing this:\n  ?z \\<in> B \\<Longrightarrow> x ?z = y ?z\n\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>B. x b *\\<^sub>R b) = (\\<Sum>b\\<in>B. y b *\\<^sub>R b)", "by auto"], ["proof (state)\nthis:\n  (\\<And>z. z \\<in> B \\<Longrightarrow> ?x z = ?y z) \\<Longrightarrow>\n  comb ?x = comb ?y\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have comb_repr[simp]: \"comb (repr \\<psi>) = \\<psi>\" if \"\\<psi> \\<in> real_vector.span B\" for \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. comb (repr \\<psi>) = \\<psi>", "using \\<open>comb \\<equiv> \\<lambda>l. \\<Sum>b\\<in>B. l b *\\<^sub>R b\\<close> local.repr_def real_vector.sum_representation_eq t1 t3 that"], ["proof (prove)\nusing this:\n  comb \\<equiv> \\<lambda>l. \\<Sum>b\\<in>B. l b *\\<^sub>R b\n  repr = representation B\n  \\<lbrakk>independent ?basis; ?v \\<in> span ?basis; finite ?B;\n   ?basis \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>b\\<in>?B.\n                       representation ?basis ?v b *\\<^sub>R b) =\n                    ?v\n  finite B\n  independent B\n  \\<psi> \\<in> span B\n\ngoal (1 subgoal):\n 1. comb (repr \\<psi>) = \\<psi>", "by fastforce"], ["proof (state)\nthis:\n  ?\\<psi> \\<in> span B \\<Longrightarrow> comb (repr ?\\<psi>) = ?\\<psi>\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have w5:\"(\\<Sum>b | (b \\<in> B \\<longrightarrow> x b \\<noteq> 0) \\<and> b \\<in> B. x b *\\<^sub>R b) =\n    (\\<Sum>b\\<in>B. x b *\\<^sub>R b)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b | (b \\<in> B \\<longrightarrow> x b \\<noteq> 0) \\<and>\n               b \\<in> B.\n       x b *\\<^sub>R b) =\n    (\\<Sum>b\\<in>B. x b *\\<^sub>R b)", "using \\<open>finite B\\<close>"], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (b \\<in> B \\<longrightarrow> x b \\<noteq> 0) \\<and>\n               b \\<in> B.\n       x b *\\<^sub>R b) =\n    (\\<Sum>b\\<in>B. x b *\\<^sub>R b)", "by (smt DiffD1 DiffD2 mem_Collect_eq real_vector.scale_eq_0_iff subset_eq sum.mono_neutral_left)"], ["proof (state)\nthis:\n  (\\<Sum>b | (b \\<in> B \\<longrightarrow> ?x b \\<noteq> 0) \\<and> b \\<in> B.\n     ?x b *\\<^sub>R b) =\n  (\\<Sum>b\\<in>B. ?x b *\\<^sub>R b)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have \"representation B (\\<Sum>b\\<in>B. x b *\\<^sub>R b) =  (\\<lambda>b. if b \\<in> B then x b else 0)\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. representation B (\\<Sum>b\\<in>B. x b *\\<^sub>R b) =\n    (\\<lambda>b. if b \\<in> B then x b else 0)", "proof (rule real_vector.representation_eqI)"], ["proof (state)\ngoal (5 subgoals):\n 1. independent B\n 2. (\\<Sum>b\\<in>B. x b *\\<^sub>R b) \\<in> span B\n 3. \\<And>b.\n       (if b \\<in> B then x b else 0) \\<noteq> 0 \\<Longrightarrow> b \\<in> B\n 4. finite {b. (if b \\<in> B then x b else 0) \\<noteq> 0}\n 5. (\\<Sum>b | (if b \\<in> B then x b else 0) \\<noteq> 0.\n       (if b \\<in> B then x b else 0) *\\<^sub>R b) =\n    (\\<Sum>b\\<in>B. x b *\\<^sub>R b)", "show \"independent B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. independent B", "by (simp add: t3)"], ["proof (state)\nthis:\n  independent B\n\ngoal (4 subgoals):\n 1. (\\<Sum>b\\<in>B. x b *\\<^sub>R b) \\<in> span B\n 2. \\<And>b.\n       (if b \\<in> B then x b else 0) \\<noteq> 0 \\<Longrightarrow> b \\<in> B\n 3. finite {b. (if b \\<in> B then x b else 0) \\<noteq> 0}\n 4. (\\<Sum>b | (if b \\<in> B then x b else 0) \\<noteq> 0.\n       (if b \\<in> B then x b else 0) *\\<^sub>R b) =\n    (\\<Sum>b\\<in>B. x b *\\<^sub>R b)", "show \"(\\<Sum>b\\<in>B. x b *\\<^sub>R b) \\<in> span B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>B. x b *\\<^sub>R b) \\<in> span B", "by (meson real_vector.span_scale real_vector.span_sum real_vector.span_superset subset_iff)"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>B. x b *\\<^sub>R b) \\<in> span B\n\ngoal (3 subgoals):\n 1. \\<And>b.\n       (if b \\<in> B then x b else 0) \\<noteq> 0 \\<Longrightarrow> b \\<in> B\n 2. finite {b. (if b \\<in> B then x b else 0) \\<noteq> 0}\n 3. (\\<Sum>b | (if b \\<in> B then x b else 0) \\<noteq> 0.\n       (if b \\<in> B then x b else 0) *\\<^sub>R b) =\n    (\\<Sum>b\\<in>B. x b *\\<^sub>R b)", "show \"b \\<in> B\"\n      if \"(if b \\<in> B then x b else 0) \\<noteq> 0\"\n      for b :: 'b"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> B", "using that"], ["proof (prove)\nusing this:\n  (if b \\<in> B then x b else 0) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. b \\<in> B", "by meson"], ["proof (state)\nthis:\n  (if ?b \\<in> B then x ?b else 0) \\<noteq> 0 \\<Longrightarrow> ?b \\<in> B\n\ngoal (2 subgoals):\n 1. finite {b. (if b \\<in> B then x b else 0) \\<noteq> 0}\n 2. (\\<Sum>b | (if b \\<in> B then x b else 0) \\<noteq> 0.\n       (if b \\<in> B then x b else 0) *\\<^sub>R b) =\n    (\\<Sum>b\\<in>B. x b *\\<^sub>R b)", "show \"finite {b. (if b \\<in> B then x b else 0) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {b. (if b \\<in> B then x b else 0) \\<noteq> 0}", "using t1"], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. finite {b. (if b \\<in> B then x b else 0) \\<noteq> 0}", "by auto"], ["proof (state)\nthis:\n  finite {b. (if b \\<in> B then x b else 0) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (if b \\<in> B then x b else 0) \\<noteq> 0.\n       (if b \\<in> B then x b else 0) *\\<^sub>R b) =\n    (\\<Sum>b\\<in>B. x b *\\<^sub>R b)", "show \"(\\<Sum>b | (if b \\<in> B then x b else 0) \\<noteq> 0. (if b \\<in> B then x b else 0) *\\<^sub>R b) = (\\<Sum>b\\<in>B. x b *\\<^sub>R b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b | (if b \\<in> B then x b else 0) \\<noteq> 0.\n       (if b \\<in> B then x b else 0) *\\<^sub>R b) =\n    (\\<Sum>b\\<in>B. x b *\\<^sub>R b)", "using w5"], ["proof (prove)\nusing this:\n  (\\<Sum>b | (b \\<in> B \\<longrightarrow> ?x b \\<noteq> 0) \\<and> b \\<in> B.\n     ?x b *\\<^sub>R b) =\n  (\\<Sum>b\\<in>B. ?x b *\\<^sub>R b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>b | (if b \\<in> B then x b else 0) \\<noteq> 0.\n       (if b \\<in> B then x b else 0) *\\<^sub>R b) =\n    (\\<Sum>b\\<in>B. x b *\\<^sub>R b)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>b | (if b \\<in> B then x b else 0) \\<noteq> 0.\n     (if b \\<in> B then x b else 0) *\\<^sub>R b) =\n  (\\<Sum>b\\<in>B. x b *\\<^sub>R b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  representation B (\\<Sum>b\\<in>B. ?x b *\\<^sub>R b) =\n  (\\<lambda>b. if b \\<in> B then ?x b else 0)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "hence repr_comb[simp]: \"repr (comb x) = (\\<lambda>b. if b\\<in>B then x b else 0)\" for x"], ["proof (prove)\nusing this:\n  representation B (\\<Sum>b\\<in>B. ?x b *\\<^sub>R b) =\n  (\\<lambda>b. if b \\<in> B then ?x b else 0)\n\ngoal (1 subgoal):\n 1. repr (comb x) = (\\<lambda>b. if b \\<in> B then x b else 0)", "unfolding repr_def comb_def"], ["proof (prove)\nusing this:\n  representation B (\\<Sum>b\\<in>B. ?x b *\\<^sub>R b) =\n  (\\<lambda>b. if b \\<in> B then ?x b else 0)\n\ngoal (1 subgoal):\n 1. representation B (\\<Sum>b\\<in>B. x b *\\<^sub>R b) =\n    (\\<lambda>b. if b \\<in> B then x b else 0)", "."], ["proof (state)\nthis:\n  repr (comb ?x) = (\\<lambda>b. if b \\<in> B then ?x b else 0)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have repr_bad[simp]: \"repr \\<psi> = (\\<lambda>_. 0)\" if \"\\<psi> \\<notin> real_vector.span B\" for \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. repr \\<psi> = (\\<lambda>_. 0)", "unfolding repr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. representation B \\<psi> = (\\<lambda>_. 0)", "using that"], ["proof (prove)\nusing this:\n  \\<psi> \\<notin> span B\n\ngoal (1 subgoal):\n 1. representation B \\<psi> = (\\<lambda>_. 0)", "by (simp add: real_vector.representation_def)"], ["proof (state)\nthis:\n  ?\\<psi> \\<notin> span B \\<Longrightarrow> repr ?\\<psi> = (\\<lambda>_. 0)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have [simp]: \"repr' \\<psi> = 0\" if \"\\<psi> \\<notin> real_vector.span B\" for \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. repr' \\<psi> = 0", "unfolding repr'_def repr_bad[OF that]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_euclidean_space ((\\<lambda>_. 0) \\<circ> rep) = 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rep. (\\<lambda>_. 0) \\<circ> rep = (\\<lambda>_. 0)", "by auto"], ["proof (state)\nthis:\n  ?\\<psi> \\<notin> span B \\<Longrightarrow> repr' ?\\<psi> = 0\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have comb'_repr'[simp]: \"comb' (repr' \\<psi>) = \\<psi>\" \n    if \"\\<psi> \\<in> real_vector.span B\" for \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. comb' (repr' \\<psi>) = \\<psi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comb' (repr' \\<psi>) = \\<psi>", "have x1: \"(repr \\<psi> \\<circ> rep \\<circ> abs) z = repr \\<psi> z\"\n      if \"z \\<in> B\"\n      for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. (repr \\<psi> \\<circ> rep \\<circ> abs) z = repr \\<psi> z", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. repr \\<psi> (rep (abs z)) = repr \\<psi> z", "using t that type_definition.Abs_inverse"], ["proof (prove)\nusing this:\n  type_definition rep abs B\n  z \\<in> B\n  \\<lbrakk>type_definition ?Rep ?Abs ?A; ?y \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?Rep (?Abs ?y) = ?y\n\ngoal (1 subgoal):\n 1. repr \\<psi> (rep (abs z)) = repr \\<psi> z", "by fastforce"], ["proof (state)\nthis:\n  ?z \\<in> B \\<Longrightarrow>\n  (repr \\<psi> \\<circ> rep \\<circ> abs) ?z = repr \\<psi> ?z\n\ngoal (1 subgoal):\n 1. comb' (repr' \\<psi>) = \\<psi>", "have \"comb' (repr' \\<psi>) = comb ((repr \\<psi> \\<circ> rep) \\<circ> abs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comb' (repr' \\<psi>) = comb (repr \\<psi> \\<circ> rep \\<circ> abs)", "unfolding comb'_def repr'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. comb\n     (Rep_euclidean_space\n       (Abs_euclidean_space (repr \\<psi> \\<circ> rep)) \\<circ>\n      abs) =\n    comb (repr \\<psi> \\<circ> rep \\<circ> abs)", "by (subst Abs_euclidean_space_inverse; simp)"], ["proof (state)\nthis:\n  comb' (repr' \\<psi>) = comb (repr \\<psi> \\<circ> rep \\<circ> abs)\n\ngoal (1 subgoal):\n 1. comb' (repr' \\<psi>) = \\<psi>", "also"], ["proof (state)\nthis:\n  comb' (repr' \\<psi>) = comb (repr \\<psi> \\<circ> rep \\<circ> abs)\n\ngoal (1 subgoal):\n 1. comb' (repr' \\<psi>) = \\<psi>", "have \"\\<dots> = comb (repr \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comb (repr \\<psi> \\<circ> rep \\<circ> abs) = comb (repr \\<psi>)", "using x1 comb_cong"], ["proof (prove)\nusing this:\n  ?z \\<in> B \\<Longrightarrow>\n  (repr \\<psi> \\<circ> rep \\<circ> abs) ?z = repr \\<psi> ?z\n  (\\<And>z. z \\<in> B \\<Longrightarrow> ?x z = ?y z) \\<Longrightarrow>\n  comb ?x = comb ?y\n\ngoal (1 subgoal):\n 1. comb (repr \\<psi> \\<circ> rep \\<circ> abs) = comb (repr \\<psi>)", "by blast"], ["proof (state)\nthis:\n  comb (repr \\<psi> \\<circ> rep \\<circ> abs) = comb (repr \\<psi>)\n\ngoal (1 subgoal):\n 1. comb' (repr' \\<psi>) = \\<psi>", "also"], ["proof (state)\nthis:\n  comb (repr \\<psi> \\<circ> rep \\<circ> abs) = comb (repr \\<psi>)\n\ngoal (1 subgoal):\n 1. comb' (repr' \\<psi>) = \\<psi>", "have \"\\<dots> = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comb (repr \\<psi>) = \\<psi>", "using that"], ["proof (prove)\nusing this:\n  \\<psi> \\<in> span B\n\ngoal (1 subgoal):\n 1. comb (repr \\<psi>) = \\<psi>", "by simp"], ["proof (state)\nthis:\n  comb (repr \\<psi>) = \\<psi>\n\ngoal (1 subgoal):\n 1. comb' (repr' \\<psi>) = \\<psi>", "finally"], ["proof (chain)\npicking this:\n  comb' (repr' \\<psi>) = \\<psi>", "show ?thesis"], ["proof (prove)\nusing this:\n  comb' (repr' \\<psi>) = \\<psi>\n\ngoal (1 subgoal):\n 1. comb' (repr' \\<psi>) = \\<psi>", "by -"], ["proof (state)\nthis:\n  comb' (repr' \\<psi>) = \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<psi> \\<in> span B \\<Longrightarrow> comb' (repr' ?\\<psi>) = ?\\<psi>\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have t1: \"Abs_euclidean_space (Rep_euclidean_space t) = t\"\n    if \"\\<And>x. rep x \\<in> B\"\n    for t::\"'a euclidean_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_euclidean_space (Rep_euclidean_space t) = t", "apply (subst Rep_euclidean_space_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t = t", "by simp"], ["proof (state)\nthis:\n  (\\<And>x. rep x \\<in> B) \\<Longrightarrow>\n  Abs_euclidean_space (Rep_euclidean_space ?t1) = ?t1\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have \"Abs_euclidean_space\n     (\\<lambda>y. if rep y \\<in> B \n           then Rep_euclidean_space x y\n           else 0) = x\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_euclidean_space\n     (\\<lambda>y. if rep y \\<in> B then Rep_euclidean_space x y else 0) =\n    x", "using type_definition.Rep[OF t]"], ["proof (prove)\nusing this:\n  rep ?x \\<in> B\n\ngoal (1 subgoal):\n 1. Abs_euclidean_space\n     (\\<lambda>y. if rep y \\<in> B then Rep_euclidean_space x y else 0) =\n    x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. rep x \\<in> B) \\<Longrightarrow>\n    Abs_euclidean_space (Rep_euclidean_space x) = x", "using t1"], ["proof (prove)\nusing this:\n  (\\<And>x. rep x \\<in> B) \\<Longrightarrow>\n  Abs_euclidean_space (Rep_euclidean_space ?t1) = ?t1\n\ngoal (1 subgoal):\n 1. (\\<And>x. rep x \\<in> B) \\<Longrightarrow>\n    Abs_euclidean_space (Rep_euclidean_space x) = x", "by blast"], ["proof (state)\nthis:\n  Abs_euclidean_space\n   (\\<lambda>y. if rep y \\<in> B then Rep_euclidean_space ?x1 y else 0) =\n  ?x1\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "hence \"Abs_euclidean_space\n     (\\<lambda>y. if rep y \\<in> B\n           then Rep_euclidean_space x (abs (rep y))\n           else 0) = x\"\n    for x"], ["proof (prove)\nusing this:\n  Abs_euclidean_space\n   (\\<lambda>y. if rep y \\<in> B then Rep_euclidean_space ?x1 y else 0) =\n  ?x1\n\ngoal (1 subgoal):\n 1. Abs_euclidean_space\n     (\\<lambda>y.\n         if rep y \\<in> B then Rep_euclidean_space x (abs (rep y)) else 0) =\n    x", "apply (subst type_definition.Rep_inverse[OF t])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        Abs_euclidean_space\n         (\\<lambda>y.\n             if rep y \\<in> B then Rep_euclidean_space x y else 0) =\n        x) \\<Longrightarrow>\n    Abs_euclidean_space\n     (\\<lambda>y. if rep y \\<in> B then Rep_euclidean_space x y else 0) =\n    x", "by simp"], ["proof (state)\nthis:\n  Abs_euclidean_space\n   (\\<lambda>y.\n       if rep y \\<in> B then Rep_euclidean_space ?x1 (abs (rep y)) else 0) =\n  ?x1\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "hence repr'_comb'[simp]: \"repr' (comb' x) = x\" for x"], ["proof (prove)\nusing this:\n  Abs_euclidean_space\n   (\\<lambda>y.\n       if rep y \\<in> B then Rep_euclidean_space ?x1 (abs (rep y)) else 0) =\n  ?x1\n\ngoal (1 subgoal):\n 1. repr' (comb' x) = x", "unfolding comb'_def repr'_def o_def"], ["proof (prove)\nusing this:\n  Abs_euclidean_space\n   (\\<lambda>y.\n       if rep y \\<in> B then Rep_euclidean_space ?x1 (abs (rep y)) else 0) =\n  ?x1\n\ngoal (1 subgoal):\n 1. Abs_euclidean_space\n     (\\<lambda>xa.\n         repr (comb (\\<lambda>xa. Rep_euclidean_space x (abs xa)))\n          (rep xa)) =\n    x", "by simp"], ["proof (state)\nthis:\n  repr' (comb' ?x1) = ?x1\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have sphere: \"compact (sphere 0 d :: 'basis euclidean_space set)\" for d"], ["proof (prove)\ngoal (1 subgoal):\n 1. compact (sphere 0 d)", "using compact_sphere"], ["proof (prove)\nusing this:\n  compact (sphere ?a ?r)\n\ngoal (1 subgoal):\n 1. compact (sphere 0 d)", "by blast"], ["proof (state)\nthis:\n  compact (sphere 0 ?d1)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have \"complete (UNIV :: 'basis euclidean_space set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete UNIV", "by (simp add: complete_UNIV)"], ["proof (state)\nthis:\n  complete UNIV\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have \"(\\<Sum>b\\<in>B. (Rep_euclidean_space (x + y) \\<circ> abs) b *\\<^sub>R b) = (\\<Sum>b\\<in>B. (Rep_euclidean_space x \\<circ> abs) b *\\<^sub>R b) + (\\<Sum>b\\<in>B. (Rep_euclidean_space y \\<circ> abs) b *\\<^sub>R b)\"\n    for x :: \"'basis euclidean_space\"\n      and y :: \"'basis euclidean_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>B.\n       (Rep_euclidean_space (x + y) \\<circ> abs) b *\\<^sub>R b) =\n    (\\<Sum>b\\<in>B. (Rep_euclidean_space x \\<circ> abs) b *\\<^sub>R b) +\n    (\\<Sum>b\\<in>B. (Rep_euclidean_space y \\<circ> abs) b *\\<^sub>R b)", "apply (transfer fixing: abs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y B.\n       (\\<Sum>b\\<in>B.\n          ((\\<lambda>xa. x xa + y xa) \\<circ> abs) b *\\<^sub>R b) =\n       (\\<Sum>b\\<in>B. (x \\<circ> abs) b *\\<^sub>R b) +\n       (\\<Sum>b\\<in>B. (y \\<circ> abs) b *\\<^sub>R b)", "by (simp add: scaleR_add_left sum.distrib)"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>B.\n     (Rep_euclidean_space (?x1 + ?y1) \\<circ> abs) b *\\<^sub>R b) =\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?x1 \\<circ> abs) b *\\<^sub>R b) +\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?y1 \\<circ> abs) b *\\<^sub>R b)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>B.\n     (Rep_euclidean_space (?x1 + ?y1) \\<circ> abs) b *\\<^sub>R b) =\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?x1 \\<circ> abs) b *\\<^sub>R b) +\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?y1 \\<circ> abs) b *\\<^sub>R b)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have \"(\\<Sum>b\\<in>B. (Rep_euclidean_space (c *\\<^sub>R x) \\<circ> abs) b *\\<^sub>R b) = c *\\<^sub>R (\\<Sum>b\\<in>B. (Rep_euclidean_space x \\<circ> abs) b *\\<^sub>R b)\"\n    for c :: real\n      and x :: \"'basis euclidean_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>B.\n       (Rep_euclidean_space (c *\\<^sub>R x) \\<circ> abs) b *\\<^sub>R b) =\n    c *\\<^sub>R\n    (\\<Sum>b\\<in>B. (Rep_euclidean_space x \\<circ> abs) b *\\<^sub>R b)", "apply (transfer fixing: abs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c x B.\n       (\\<Sum>b\\<in>B.\n          ((\\<lambda>xa. c * x xa) \\<circ> abs) b *\\<^sub>R b) =\n       c *\\<^sub>R (\\<Sum>b\\<in>B. (x \\<circ> abs) b *\\<^sub>R b)", "by (simp add: real_vector.scale_sum_right)"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>B.\n     (Rep_euclidean_space (?c1 *\\<^sub>R ?x1) \\<circ> abs) b *\\<^sub>R b) =\n  ?c1 *\\<^sub>R\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?x1 \\<circ> abs) b *\\<^sub>R b)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>b\\<in>B.\n     (Rep_euclidean_space (?x1 + ?y1) \\<circ> abs) b *\\<^sub>R b) =\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?x1 \\<circ> abs) b *\\<^sub>R b) +\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?y1 \\<circ> abs) b *\\<^sub>R b)\n  (\\<Sum>b\\<in>B.\n     (Rep_euclidean_space (?c1 *\\<^sub>R ?x1) \\<circ> abs) b *\\<^sub>R b) =\n  ?c1 *\\<^sub>R\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?x1 \\<circ> abs) b *\\<^sub>R b)", "have blin_comb': \"bounded_linear comb'\""], ["proof (prove)\nusing this:\n  (\\<Sum>b\\<in>B.\n     (Rep_euclidean_space (?x1 + ?y1) \\<circ> abs) b *\\<^sub>R b) =\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?x1 \\<circ> abs) b *\\<^sub>R b) +\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?y1 \\<circ> abs) b *\\<^sub>R b)\n  (\\<Sum>b\\<in>B.\n     (Rep_euclidean_space (?c1 *\\<^sub>R ?x1) \\<circ> abs) b *\\<^sub>R b) =\n  ?c1 *\\<^sub>R\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?x1 \\<circ> abs) b *\\<^sub>R b)\n\ngoal (1 subgoal):\n 1. bounded_linear comb'", "unfolding comb_def comb'_def"], ["proof (prove)\nusing this:\n  (\\<Sum>b\\<in>B.\n     (Rep_euclidean_space (?x1 + ?y1) \\<circ> abs) b *\\<^sub>R b) =\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?x1 \\<circ> abs) b *\\<^sub>R b) +\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?y1 \\<circ> abs) b *\\<^sub>R b)\n  (\\<Sum>b\\<in>B.\n     (Rep_euclidean_space (?c1 *\\<^sub>R ?x1) \\<circ> abs) b *\\<^sub>R b) =\n  ?c1 *\\<^sub>R\n  (\\<Sum>b\\<in>B. (Rep_euclidean_space ?x1 \\<circ> abs) b *\\<^sub>R b)\n\ngoal (1 subgoal):\n 1. bounded_linear\n     (\\<lambda>l.\n         \\<Sum>b\\<in>B. (Rep_euclidean_space l \\<circ> abs) b *\\<^sub>R b)", "by (rule bounded_linearI')"], ["proof (state)\nthis:\n  bounded_linear comb'\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "hence \"continuous_on X comb'\" for X"], ["proof (prove)\nusing this:\n  bounded_linear comb'\n\ngoal (1 subgoal):\n 1. continuous_on X comb'", "by (simp add: linear_continuous_on)"], ["proof (state)\nthis:\n  continuous_on ?X1 comb'\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "hence \"compact (comb' ` sphere 0 d)\" for d"], ["proof (prove)\nusing this:\n  continuous_on ?X1 comb'\n\ngoal (1 subgoal):\n 1. compact (comb' ` sphere 0 d)", "using sphere"], ["proof (prove)\nusing this:\n  continuous_on ?X1 comb'\n  compact (sphere 0 ?d1)\n\ngoal (1 subgoal):\n 1. compact (comb' ` sphere 0 d)", "by (rule compact_continuous_image)"], ["proof (state)\nthis:\n  compact (comb' ` sphere 0 ?d1)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "hence compact_norm_comb': \"compact (norm ` comb' ` sphere 0 1)\""], ["proof (prove)\nusing this:\n  compact (comb' ` sphere 0 ?d1)\n\ngoal (1 subgoal):\n 1. compact (norm ` comb' ` sphere 0 1)", "using compact_continuous_image continuous_on_norm_id"], ["proof (prove)\nusing this:\n  compact (comb' ` sphere 0 ?d1)\n  \\<lbrakk>continuous_on ?s ?f; compact ?s\\<rbrakk>\n  \\<Longrightarrow> compact (?f ` ?s)\n  continuous_on ?S norm\n\ngoal (1 subgoal):\n 1. compact (norm ` comb' ` sphere 0 1)", "by blast"], ["proof (state)\nthis:\n  compact (norm ` comb' ` sphere 0 1)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have not0: \"0 \\<notin> norm ` comb' ` sphere 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> norm ` comb' ` sphere 0 1", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<in> norm ` comb' ` sphere 0 1 \\<Longrightarrow> False", "assume \"0 \\<in> norm ` comb' ` sphere 0 1\""], ["proof (state)\nthis:\n  0 \\<in> norm ` comb' ` sphere 0 1\n\ngoal (1 subgoal):\n 1. 0 \\<in> norm ` comb' ` sphere 0 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 \\<in> norm ` comb' ` sphere 0 1", "obtain x where nc0: \"norm (comb' x) = 0\" and x: \"x \\<in> sphere 0 1\""], ["proof (prove)\nusing this:\n  0 \\<in> norm ` comb' ` sphere 0 1\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>norm (comb' x) = 0; x \\<in> sphere 0 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  norm (comb' x) = 0\n  x \\<in> sphere 0 1\n\ngoal (1 subgoal):\n 1. 0 \\<in> norm ` comb' ` sphere 0 1 \\<Longrightarrow> False", "hence \"comb' x = 0\""], ["proof (prove)\nusing this:\n  norm (comb' x) = 0\n  x \\<in> sphere 0 1\n\ngoal (1 subgoal):\n 1. comb' x = (0::'b)", "by simp"], ["proof (state)\nthis:\n  comb' x = (0::'b)\n\ngoal (1 subgoal):\n 1. 0 \\<in> norm ` comb' ` sphere 0 1 \\<Longrightarrow> False", "hence \"repr' (comb' x) = 0\""], ["proof (prove)\nusing this:\n  comb' x = (0::'b)\n\ngoal (1 subgoal):\n 1. repr' (comb' x) = 0", "unfolding repr'_def o_def repr_def"], ["proof (prove)\nusing this:\n  comb' x = (0::'b)\n\ngoal (1 subgoal):\n 1. Abs_euclidean_space (\\<lambda>xa. representation B (comb' x) (rep xa)) =\n    0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. comb' x = (0::'b) \\<Longrightarrow>\n    Abs_euclidean_space (\\<lambda>x. representation B (0::'b) (rep x)) = 0", "by (smt repr'_comb' blin_comb' dist_0_norm linear_simps(3) mem_sphere norm_zero x)"], ["proof (state)\nthis:\n  repr' (comb' x) = 0\n\ngoal (1 subgoal):\n 1. 0 \\<in> norm ` comb' ` sphere 0 1 \\<Longrightarrow> False", "hence \"x = 0\""], ["proof (prove)\nusing this:\n  repr' (comb' x) = 0\n\ngoal (1 subgoal):\n 1. x = 0", "by auto"], ["proof (state)\nthis:\n  x = 0\n\ngoal (1 subgoal):\n 1. 0 \\<in> norm ` comb' ` sphere 0 1 \\<Longrightarrow> False", "with x"], ["proof (chain)\npicking this:\n  x \\<in> sphere 0 1\n  x = 0", "show False"], ["proof (prove)\nusing this:\n  x \\<in> sphere 0 1\n  x = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<notin> norm ` comb' ` sphere 0 1\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have \"closed (norm ` comb' ` sphere 0 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (norm ` comb' ` sphere 0 1)", "using compact_imp_closed compact_norm_comb'"], ["proof (prove)\nusing this:\n  compact ?s \\<Longrightarrow> closed ?s\n  compact (norm ` comb' ` sphere 0 1)\n\ngoal (1 subgoal):\n 1. closed (norm ` comb' ` sphere 0 1)", "by blast"], ["proof (state)\nthis:\n  closed (norm ` comb' ` sphere 0 1)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "moreover"], ["proof (state)\nthis:\n  closed (norm ` comb' ` sphere 0 1)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have \"0 \\<notin> norm ` comb' ` sphere 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> norm ` comb' ` sphere 0 1", "by (simp add: not0)"], ["proof (state)\nthis:\n  0 \\<notin> norm ` comb' ` sphere 0 1\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "ultimately"], ["proof (chain)\npicking this:\n  closed (norm ` comb' ` sphere 0 1)\n  0 \\<notin> norm ` comb' ` sphere 0 1", "have \"\\<exists>d>0. \\<forall>x\\<in>norm ` comb' ` sphere 0 1. d \\<le> dist 0 x\""], ["proof (prove)\nusing this:\n  closed (norm ` comb' ` sphere 0 1)\n  0 \\<notin> norm ` comb' ` sphere 0 1\n\ngoal (1 subgoal):\n 1. \\<exists>d>0. \\<forall>x\\<in>norm ` comb' ` sphere 0 1. d \\<le> dist 0 x", "by (meson separate_point_closed)"], ["proof (state)\nthis:\n  \\<exists>d>0. \\<forall>x\\<in>norm ` comb' ` sphere 0 1. d \\<le> dist 0 x\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "then"], ["proof (chain)\npicking this:\n  \\<exists>d>0. \\<forall>x\\<in>norm ` comb' ` sphere 0 1. d \\<le> dist 0 x", "obtain d where d: \"x\\<in>norm ` comb' ` sphere 0 1 \\<Longrightarrow> d \\<le> dist 0 x\"  \n    and \"d > 0\" for x"], ["proof (prove)\nusing this:\n  \\<exists>d>0. \\<forall>x\\<in>norm ` comb' ` sphere 0 1. d \\<le> dist 0 x\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>\\<And>x.\n                    x \\<in> norm ` comb' ` sphere 0 1 \\<Longrightarrow>\n                    d \\<le> dist 0 x;\n         0 < d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?x1 \\<in> norm ` comb' ` sphere 0 1 \\<Longrightarrow> d \\<le> dist 0 ?x1\n  0 < d\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "define D where \"D = 1/d\""], ["proof (state)\nthis:\n  D = 1 / d\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "hence \"D > 0\""], ["proof (prove)\nusing this:\n  D = 1 / d\n\ngoal (1 subgoal):\n 1. 0 < D", "using \\<open>d>0\\<close>"], ["proof (prove)\nusing this:\n  D = 1 / d\n  0 < d\n\ngoal (1 subgoal):\n 1. 0 < D", "unfolding D_def"], ["proof (prove)\nusing this:\n  1 / d = 1 / d\n  0 < d\n\ngoal (1 subgoal):\n 1. 0 < 1 / d", "by auto"], ["proof (state)\nthis:\n  0 < D\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have \"x \\<ge> d\"  \n    if \"x\\<in>norm ` comb' ` sphere 0 1\" \n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> x", "using d that"], ["proof (prove)\nusing this:\n  ?x1 \\<in> norm ` comb' ` sphere 0 1 \\<Longrightarrow> d \\<le> dist 0 ?x1\n  x \\<in> norm ` comb' ` sphere 0 1\n\ngoal (1 subgoal):\n 1. d \\<le> x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> norm ` comb' ` sphere 0 1 \\<Longrightarrow>\n                   d \\<le> \\<bar>x\\<bar>;\n        x = norm (comb' xa); norm xa = 1\\<rbrakk>\n       \\<Longrightarrow> d \\<le> norm (comb' xa)", "by fastforce"], ["proof (state)\nthis:\n  ?x1 \\<in> norm ` comb' ` sphere 0 1 \\<Longrightarrow> d \\<le> ?x1\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "hence *: \"norm (comb' x) \\<ge> d\" if \"norm x = 1\" for x"], ["proof (prove)\nusing this:\n  ?x1 \\<in> norm ` comb' ` sphere 0 1 \\<Longrightarrow> d \\<le> ?x1\n\ngoal (1 subgoal):\n 1. d \\<le> norm (comb' x)", "using that"], ["proof (prove)\nusing this:\n  ?x1 \\<in> norm ` comb' ` sphere 0 1 \\<Longrightarrow> d \\<le> ?x1\n  norm x = 1\n\ngoal (1 subgoal):\n 1. d \\<le> norm (comb' x)", "by auto"], ["proof (state)\nthis:\n  norm ?x1 = 1 \\<Longrightarrow> d \\<le> norm (comb' ?x1)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have norm_comb': \"norm (comb' x) \\<ge> d * norm x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. d * norm x \\<le> norm (comb' x)", "proof (cases \"x=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> d * norm x \\<le> norm (comb' x)\n 2. x \\<noteq> 0 \\<Longrightarrow> d * norm x \\<le> norm (comb' x)", "show \"d * norm x \\<le> norm (comb' x)\"\n      if \"x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d * norm x \\<le> norm (comb' x)", "using that"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. d * norm x \\<le> norm (comb' x)", "by simp"], ["proof (state)\nthis:\n  x = 0 \\<Longrightarrow> d * norm x \\<le> norm (comb' x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> d * norm x \\<le> norm (comb' x)", "show \"d * norm x \\<le> norm (comb' x)\"\n      if \"x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d * norm x \\<le> norm (comb' x)", "using that"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d * norm x \\<le> norm (comb' x)", "using *[of \"(1/norm x) *\\<^sub>R x\"]"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  norm ((1 / norm x) *\\<^sub>R x) = 1 \\<Longrightarrow>\n  d \\<le> norm (comb' ((1 / norm x) *\\<^sub>R x))\n\ngoal (1 subgoal):\n 1. d * norm x \\<le> norm (comb' x)", "unfolding linear_simps(5)[OF blin_comb']"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  norm ((1 / norm x) *\\<^sub>R x) = 1 \\<Longrightarrow>\n  d \\<le> norm ((1 / norm x) *\\<^sub>R comb' x)\n\ngoal (1 subgoal):\n 1. d * norm x \\<le> norm (comb' x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> 0; d \\<le> norm (comb' x) / norm x\\<rbrakk>\n    \\<Longrightarrow> d * norm x \\<le> norm (comb' x)", "by (simp add: le_divide_eq)"], ["proof (state)\nthis:\n  x \\<noteq> 0 \\<Longrightarrow> d * norm x \\<le> norm (comb' x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d * norm ?x1 \\<le> norm (comb' ?x1)\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "have *:  \"norm (repr' \\<psi>) \\<le> norm \\<psi> * D\" for \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (repr' \\<psi>) \\<le> norm \\<psi> * D", "proof (cases \"\\<psi> \\<in> real_vector.span B\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<psi> \\<in> span B \\<Longrightarrow>\n    norm (repr' \\<psi>) \\<le> norm \\<psi> * D\n 2. \\<psi> \\<notin> span B \\<Longrightarrow>\n    norm (repr' \\<psi>) \\<le> norm \\<psi> * D", "show \"norm (repr' \\<psi>) \\<le> norm \\<psi> * D\"\n      if \"\\<psi> \\<in> span B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (repr' \\<psi>) \\<le> norm \\<psi> * D", "using that"], ["proof (prove)\nusing this:\n  \\<psi> \\<in> span B\n\ngoal (1 subgoal):\n 1. norm (repr' \\<psi>) \\<le> norm \\<psi> * D", "unfolding D_def"], ["proof (prove)\nusing this:\n  \\<psi> \\<in> span B\n\ngoal (1 subgoal):\n 1. norm (repr' \\<psi>) \\<le> norm \\<psi> * (1 / d)", "using norm_comb'[of \"repr' \\<psi>\"] \\<open>d>0\\<close>"], ["proof (prove)\nusing this:\n  \\<psi> \\<in> span B\n  d * norm (repr' \\<psi>) \\<le> norm (comb' (repr' \\<psi>))\n  0 < d\n\ngoal (1 subgoal):\n 1. norm (repr' \\<psi>) \\<le> norm \\<psi> * (1 / d)", "by (simp_all add: linordered_field_class.mult_imp_le_div_pos mult.commute)"], ["proof (state)\nthis:\n  \\<psi> \\<in> span B \\<Longrightarrow>\n  norm (repr' \\<psi>) \\<le> norm \\<psi> * D\n\ngoal (1 subgoal):\n 1. \\<psi> \\<notin> span B \\<Longrightarrow>\n    norm (repr' \\<psi>) \\<le> norm \\<psi> * D", "show \"norm (repr' \\<psi>) \\<le> norm \\<psi> * D\"\n      if \"\\<psi> \\<notin> span B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (repr' \\<psi>) \\<le> norm \\<psi> * D", "using that \\<open>0 < D\\<close>"], ["proof (prove)\nusing this:\n  \\<psi> \\<notin> span B\n  0 < D\n\ngoal (1 subgoal):\n 1. norm (repr' \\<psi>) \\<le> norm \\<psi> * D", "by auto"], ["proof (state)\nthis:\n  \\<psi> \\<notin> span B \\<Longrightarrow>\n  norm (repr' \\<psi>) \\<le> norm \\<psi> * D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (repr' ?\\<psi>1) \\<le> norm ?\\<psi>1 * D\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "hence \"norm (Rep_euclidean_space (repr' \\<psi>) (abs b)) \\<le> norm \\<psi> * D\" for \\<psi>"], ["proof (prove)\nusing this:\n  norm (repr' ?\\<psi>1) \\<le> norm ?\\<psi>1 * D\n\ngoal (1 subgoal):\n 1. norm (Rep_euclidean_space (repr' \\<psi>) (abs b)) \\<le> norm \\<psi> * D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        norm (repr' \\<psi>) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n    norm (Rep_euclidean_space (repr' \\<psi>) (abs b)) \\<le> norm \\<psi> * D", "have \"(Rep_euclidean_space (repr' \\<psi>) (abs b)) = repr' \\<psi> \\<bullet> euclidean_space_basis_vector (abs b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_euclidean_space (repr' \\<psi>) (abs b) =\n    repr' \\<psi> \\<bullet> euclidean_space_basis_vector (abs b)", "apply (transfer fixing: abs b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>repr' \\<psi>.\n       repr' \\<psi> (abs b) =\n       (\\<Sum>x\\<in>UNIV. repr' \\<psi> x * indicat_real {abs b} x)", "by auto"], ["proof (state)\nthis:\n  Rep_euclidean_space (repr' \\<psi>) (abs b) =\n  repr' \\<psi> \\<bullet> euclidean_space_basis_vector (abs b)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        norm (repr' \\<psi>) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n    norm (Rep_euclidean_space (repr' \\<psi>) (abs b)) \\<le> norm \\<psi> * D", "also"], ["proof (state)\nthis:\n  Rep_euclidean_space (repr' \\<psi>) (abs b) =\n  repr' \\<psi> \\<bullet> euclidean_space_basis_vector (abs b)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        norm (repr' \\<psi>) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n    norm (Rep_euclidean_space (repr' \\<psi>) (abs b)) \\<le> norm \\<psi> * D", "have \"\\<bar>\\<dots>\\<bar> \\<le> norm (repr' \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>repr' \\<psi> \\<bullet> euclidean_space_basis_vector (abs b)\\<bar>\n    \\<le> norm (repr' \\<psi>)", "apply (rule Basis_le_norm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_space_basis_vector (abs b) \\<in> Basis", "unfolding Basis_euclidean_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean_space_basis_vector (abs b)\n    \\<in> range euclidean_space_basis_vector", "by simp"], ["proof (state)\nthis:\n  \\<bar>repr' \\<psi> \\<bullet> euclidean_space_basis_vector (abs b)\\<bar>\n  \\<le> norm (repr' \\<psi>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        norm (repr' \\<psi>) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n    norm (Rep_euclidean_space (repr' \\<psi>) (abs b)) \\<le> norm \\<psi> * D", "also"], ["proof (state)\nthis:\n  \\<bar>repr' \\<psi> \\<bullet> euclidean_space_basis_vector (abs b)\\<bar>\n  \\<le> norm (repr' \\<psi>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        norm (repr' \\<psi>) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n    norm (Rep_euclidean_space (repr' \\<psi>) (abs b)) \\<le> norm \\<psi> * D", "have \"\\<dots> \\<le> norm \\<psi> * D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (repr' \\<psi>) \\<le> norm \\<psi> * D", "using *"], ["proof (prove)\nusing this:\n  norm (repr' ?\\<psi>1) \\<le> norm ?\\<psi>1 * D\n\ngoal (1 subgoal):\n 1. norm (repr' \\<psi>) \\<le> norm \\<psi> * D", "by auto"], ["proof (state)\nthis:\n  norm (repr' \\<psi>) \\<le> norm \\<psi> * D\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        norm (repr' \\<psi>) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n    norm (Rep_euclidean_space (repr' \\<psi>) (abs b)) \\<le> norm \\<psi> * D", "finally"], ["proof (chain)\npicking this:\n  \\<bar>Rep_euclidean_space (repr' \\<psi>) (abs b)\\<bar>\n  \\<le> norm \\<psi> * D", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>Rep_euclidean_space (repr' \\<psi>) (abs b)\\<bar>\n  \\<le> norm \\<psi> * D\n\ngoal (1 subgoal):\n 1. norm (Rep_euclidean_space (repr' \\<psi>) (abs b)) \\<le> norm \\<psi> * D", "by simp"], ["proof (state)\nthis:\n  norm (Rep_euclidean_space (repr' \\<psi>) (abs b)) \\<le> norm \\<psi> * D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (Rep_euclidean_space (repr' ?\\<psi>1) (abs b))\n  \\<le> norm ?\\<psi>1 * D\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "hence \"norm (repr \\<psi> b) \\<le> norm \\<psi> * D\" for \\<psi>"], ["proof (prove)\nusing this:\n  norm (Rep_euclidean_space (repr' ?\\<psi>1) (abs b))\n  \\<le> norm ?\\<psi>1 * D\n\ngoal (1 subgoal):\n 1. norm (repr \\<psi> b) \\<le> norm \\<psi> * D", "unfolding repr'_def"], ["proof (prove)\nusing this:\n  norm\n   (Rep_euclidean_space (Abs_euclidean_space (repr ?\\<psi>1 \\<circ> rep))\n     (abs b))\n  \\<le> norm ?\\<psi>1 * D\n\ngoal (1 subgoal):\n 1. norm (repr \\<psi> b) \\<le> norm \\<psi> * D", "by (smt \\<open>comb' \\<equiv> \\<lambda>l. comb (Rep_euclidean_space l \\<circ> abs)\\<close> \n        \\<open>repr' \\<equiv> \\<lambda>\\<psi>. Abs_euclidean_space (repr \\<psi> \\<circ> rep)\\<close> comb'_repr' comp_apply norm_le_zero_iff \n        repr_bad repr_comb)"], ["proof (state)\nthis:\n  norm (repr ?\\<psi>1 b) \\<le> norm ?\\<psi>1 * D\n\ngoal (2 subgoals):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>.\n          norm (representation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. complete (span B)", "thus \"\\<exists>D>0. \\<forall>\\<psi>. norm (repr \\<psi> b) \\<le> norm \\<psi> * D\""], ["proof (prove)\nusing this:\n  norm (repr ?\\<psi>1 b) \\<le> norm ?\\<psi>1 * D\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>. norm (repr \\<psi> b) \\<le> norm \\<psi> * D", "using \\<open>D>0\\<close>"], ["proof (prove)\nusing this:\n  norm (repr ?\\<psi>1 b) \\<le> norm ?\\<psi>1 * D\n  0 < D\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi>. norm (repr \\<psi> b) \\<le> norm \\<psi> * D", "by auto"], ["proof (state)\nthis:\n  \\<exists>D>0. \\<forall>\\<psi>. norm (repr \\<psi> b) \\<le> norm \\<psi> * D\n\ngoal (1 subgoal):\n 1. complete (span B)", "from \\<open>d>0\\<close>"], ["proof (chain)\npicking this:\n  0 < d", "have complete_comb': \"complete (comb' ` UNIV)\""], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. complete (range comb')", "proof (rule complete_isometric_image)"], ["proof (state)\ngoal (4 subgoals):\n 1. subspace UNIV\n 2. bounded_linear comb'\n 3. \\<forall>x\\<in>UNIV. d * norm x \\<le> norm (comb' x)\n 4. complete UNIV", "show \"subspace (UNIV::'basis euclidean_space set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace UNIV", "by simp"], ["proof (state)\nthis:\n  subspace UNIV\n\ngoal (3 subgoals):\n 1. bounded_linear comb'\n 2. \\<forall>x\\<in>UNIV. d * norm x \\<le> norm (comb' x)\n 3. complete UNIV", "show \"bounded_linear comb'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear comb'", "by (simp add: blin_comb')"], ["proof (state)\nthis:\n  bounded_linear comb'\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>UNIV. d * norm x \\<le> norm (comb' x)\n 2. complete UNIV", "show \"\\<forall>x\\<in>UNIV. d * norm x \\<le> norm (comb' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV. d * norm x \\<le> norm (comb' x)", "by (simp add: norm_comb')"], ["proof (state)\nthis:\n  \\<forall>x\\<in>UNIV. d * norm x \\<le> norm (comb' x)\n\ngoal (1 subgoal):\n 1. complete UNIV", "show \"complete (UNIV::'basis euclidean_space set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete UNIV", "by (simp add: \\<open>complete UNIV\\<close>)"], ["proof (state)\nthis:\n  complete UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  complete (range comb')\n\ngoal (1 subgoal):\n 1. complete (span B)", "have range_comb': \"comb' ` UNIV = real_vector.span B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range comb' = span B", "proof (auto simp: image_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa. comb' xa \\<in> span B\n 2. \\<And>x. x \\<in> span B \\<Longrightarrow> \\<exists>xa. x = comb' xa", "show \"comb' x \\<in> real_vector.span B\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. comb' x \\<in> span B", "by (metis comb'_def comb_cong comb_repr local.repr_def repr_bad repr_comb real_vector.representation_zero real_vector.span_zero)"], ["proof (state)\nthis:\n  comb' ?x1 \\<in> span B\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> span B \\<Longrightarrow> \\<exists>xa. x = comb' xa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> span B \\<Longrightarrow> \\<exists>xa. x = comb' xa", "fix \\<psi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> span B \\<Longrightarrow> \\<exists>xa. x = comb' xa", "assume \"\\<psi> \\<in> real_vector.span B\""], ["proof (state)\nthis:\n  \\<psi> \\<in> span B\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> span B \\<Longrightarrow> \\<exists>xa. x = comb' xa", "then"], ["proof (chain)\npicking this:\n  \\<psi> \\<in> span B", "obtain f where f: \"comb f = \\<psi>\""], ["proof (prove)\nusing this:\n  \\<psi> \\<in> span B\n\ngoal (1 subgoal):\n 1. (\\<And>f. comb f = \\<psi> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<in> span B \\<Longrightarrow> \\<exists>f. comb f = \\<psi>", "unfolding span_finite[OF \\<open>finite B\\<close>] comb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi>\n    \\<in> range\n           (\\<lambda>u. \\<Sum>v\\<in>B. u v *\\<^sub>R v) \\<Longrightarrow>\n    \\<exists>f. (\\<Sum>b\\<in>B. f b *\\<^sub>R b) = \\<psi>", "by auto"], ["proof (state)\nthis:\n  comb f = \\<psi>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> span B \\<Longrightarrow> \\<exists>xa. x = comb' xa", "define f' where \"f' b = (if b\\<in>B then f b else 0)\" for b :: 'b"], ["proof (state)\nthis:\n  f' ?b = (if ?b \\<in> B then f ?b else 0)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> span B \\<Longrightarrow> \\<exists>xa. x = comb' xa", "have f': \"comb f' = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comb f' = \\<psi>", "unfolding f[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. comb f' = comb f", "apply (rule comb_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z. z \\<in> B \\<Longrightarrow> f' z = f z", "unfolding f'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> B \\<Longrightarrow> (if z \\<in> B then f z else 0) = f z", "by simp"], ["proof (state)\nthis:\n  comb f' = \\<psi>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> span B \\<Longrightarrow> \\<exists>xa. x = comb' xa", "define x :: \"'basis euclidean_space\" where \"x = Abs_euclidean_space (f' o rep)\""], ["proof (state)\nthis:\n  x = Abs_euclidean_space (f' \\<circ> rep)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> span B \\<Longrightarrow> \\<exists>xa. x = comb' xa", "have \"\\<psi> = comb' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> = comb' x", "by (metis (no_types, lifting) \\<open>\\<psi> \\<in> span B\\<close> \\<open>repr' \\<equiv> \\<lambda>\\<psi>. Abs_euclidean_space (repr \\<psi> \\<circ> rep)\\<close> \n          comb'_repr' f' fun.map_cong repr_comb t type_definition.Rep_range x_def)"], ["proof (state)\nthis:\n  \\<psi> = comb' x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> span B \\<Longrightarrow> \\<exists>xa. x = comb' xa", "thus \"\\<exists>x. \\<psi> = comb' x\""], ["proof (prove)\nusing this:\n  \\<psi> = comb' x\n\ngoal (1 subgoal):\n 1. \\<exists>x. \\<psi> = comb' x", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. \\<psi> = comb' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  range comb' = span B\n\ngoal (1 subgoal):\n 1. complete (span B)", "from range_comb' complete_comb'"], ["proof (chain)\npicking this:\n  range comb' = span B\n  complete (range comb')", "show \"complete (real_vector.span B)\""], ["proof (prove)\nusing this:\n  range comb' = span B\n  complete (range comb')\n\ngoal (1 subgoal):\n 1. complete (span B)", "by simp"], ["proof (state)\nthis:\n  complete (span B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_span_complete[simp]:\n  fixes A :: \"'a::real_normed_vector set\"\n  assumes \"finite A\"\n  shows \"complete (span A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete (span A)", "text \\<open>The span of a finite set is complete.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. complete (span A)", "proof (cases \"A \\<noteq> {} \\<and> A \\<noteq> {0}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "case True"], ["proof (state)\nthis:\n  A \\<noteq> {} \\<and> A \\<noteq> {0::'a}\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "obtain B where\n    BT: \"real_vector.span B = real_vector.span A\"\n    and \"independent B\"  \n    and \"finite B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>span B = span A; independent B; finite B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson True assms finite_subset real_vector.maximal_independent_subset real_vector.span_eq\n        real_vector.span_superset subset_trans)"], ["proof (state)\nthis:\n  span B = span A\n  independent B\n  finite B\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "have \"B\\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<noteq> {}", "apply (rule ccontr, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> False", "using BT True"], ["proof (prove)\nusing this:\n  span B = span A\n  A \\<noteq> {} \\<and> A \\<noteq> {0::'a}\n\ngoal (1 subgoal):\n 1. B = {} \\<Longrightarrow> False", "by (metis real_vector.span_superset real_vector.span_empty subset_singletonD)"], ["proof (state)\nthis:\n  B \\<noteq> {}\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "(* The following generalizes finite_span_complete_aux to hold without the assumption\n     that 'basis has type class finite *)"], ["proof (state)\nthis:\n  B \\<noteq> {}\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "{"], ["proof (state)\nthis:\n  B \\<noteq> {}\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "(* The type variable 'basisT must not be the same as the one used in finite_span_complete_aux,\n       otherwise \"internalize_sort\" below fails *)"], ["proof (state)\nthis:\n  B \\<noteq> {}\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "assume \"\\<exists>(Rep :: 'basisT\\<Rightarrow>'a) Abs. type_definition Rep Abs B\""], ["proof (state)\nthis:\n  \\<exists>Rep Abs. type_definition Rep Abs B\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "then"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs B", "obtain rep :: \"'basisT \\<Rightarrow> 'a\" and abs :: \"'a \\<Rightarrow> 'basisT\" where t: \"type_definition rep abs B\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs B\n\ngoal (1 subgoal):\n 1. (\\<And>rep abs.\n        type_definition rep abs B \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  type_definition rep abs B\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "have basisT_finite: \"class.finite TYPE('basisT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.finite TYPE('basisT)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "using \\<open>finite B\\<close> t"], ["proof (prove)\nusing this:\n  finite B\n  type_definition rep abs B\n\ngoal (1 subgoal):\n 1. finite UNIV", "by (metis (mono_tags, hide_lams) ex_new_if_finite finite_imageI image_eqI type_definition_def)"], ["proof (state)\nthis:\n  class.finite TYPE('basisT)\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "note finite_span_complete_aux(2)[internalize_sort \"'basis::finite\"]"], ["proof (state)\nthis:\n  \\<lbrakk>class.finite TYPE(?'a); type_definition ?rep ?abs ?B; finite ?B;\n   ?b \\<in> ?B; independent ?B\\<rbrakk>\n  \\<Longrightarrow> complete (span ?B)\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "note this[OF basisT_finite t]"], ["proof (state)\nthis:\n  \\<lbrakk>finite B; ?b \\<in> B; independent B\\<rbrakk>\n  \\<Longrightarrow> complete (span B)\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>Rep Abs. type_definition Rep Abs B; finite B;\n   ?b6 \\<in> B; independent B\\<rbrakk>\n  \\<Longrightarrow> complete (span B)\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "note this[cancel_type_definition, OF \\<open>B\\<noteq>{}\\<close> \\<open>finite B\\<close> _ \\<open>independent B\\<close>]"], ["proof (state)\nthis:\n  ?b6 \\<in> B \\<Longrightarrow> complete (span B)\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "hence \"complete (real_vector.span B)\""], ["proof (prove)\nusing this:\n  ?b6 \\<in> B \\<Longrightarrow> complete (span B)\n\ngoal (1 subgoal):\n 1. complete (span B)", "using \\<open>B\\<noteq>{}\\<close>"], ["proof (prove)\nusing this:\n  ?b6 \\<in> B \\<Longrightarrow> complete (span B)\n  B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. complete (span B)", "by auto"], ["proof (state)\nthis:\n  complete (span B)\n\ngoal (2 subgoals):\n 1. A \\<noteq> {} \\<and> A \\<noteq> {0::'a} \\<Longrightarrow>\n    complete (span A)\n 2. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "thus \"complete (real_vector.span A)\""], ["proof (prove)\nusing this:\n  complete (span B)\n\ngoal (1 subgoal):\n 1. complete (span A)", "unfolding BT"], ["proof (prove)\nusing this:\n  complete (span A)\n\ngoal (1 subgoal):\n 1. complete (span A)", "by simp"], ["proof (state)\nthis:\n  complete (span A)\n\ngoal (1 subgoal):\n 1. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "case False"], ["proof (state)\nthis:\n  \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a})\n\ngoal (1 subgoal):\n 1. \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a}) \\<Longrightarrow>\n    complete (span A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a})\n\ngoal (1 subgoal):\n 1. complete (span A)", "using complete_singleton"], ["proof (prove)\nusing this:\n  \\<not> (A \\<noteq> {} \\<and> A \\<noteq> {0::'a})\n  complete {?s}\n\ngoal (1 subgoal):\n 1. complete (span A)", "by auto"], ["proof (state)\nthis:\n  complete (span A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_span_representation_bounded:\n  fixes B :: \"'a::real_normed_vector set\"\n  assumes \"finite B\" and \"independent B\"\n  shows \"\\<exists>D>0. \\<forall>\\<psi> b. abs (representation B \\<psi> b) \\<le> norm \\<psi> * D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "text \\<open>\n  Assume $B$ is a finite linear independent set of vectors (in a real normed vector space).\n  Let $\\alpha^\\psi_b$ be the coefficients of $\\psi$ expressed as a linear combination over $B$.\n  Then $\\alpha$ is is uniformly cblinfun (i.e., $\\lvert\\alpha^\\psi_b \\leq D \\lVert\\psi\\rVert\\psi$\n  for some $D$ independent of $\\psi,b$).\n\n  (This also holds when $b$ is not in the span of $B$ because of the way \\<open>real_vector.representation\\<close>\n  is defined in this corner case.)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "proof (cases \"B\\<noteq>{}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "case True"], ["proof (state)\nthis:\n  B \\<noteq> {}\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "(* The following generalizes finite_span_complete_aux to hold without the assumption\n     that 'basis has type class finite *)"], ["proof (state)\nthis:\n  B \\<noteq> {}\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "define repr  where \"repr = real_vector.representation B\""], ["proof (state)\nthis:\n  repr = representation B\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "{"], ["proof (state)\nthis:\n  repr = representation B\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "(* Step 1: Create a fake type definition by introducing a new type variable 'basis\n               and then assuming the existence of the morphisms Rep/Abs to B\n               This is then roughly equivalent to \"typedef 'basis = B\" *)\n    (* The type variable 'basisT must not be the same as the one used in finite_span_complete_aux\n       (I.e., we cannot call it 'basis) *)"], ["proof (state)\nthis:\n  repr = representation B\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "assume \"\\<exists>(Rep :: 'basisT\\<Rightarrow>'a) Abs. type_definition Rep Abs B\""], ["proof (state)\nthis:\n  \\<exists>Rep Abs. type_definition Rep Abs B\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "then"], ["proof (chain)\npicking this:\n  \\<exists>Rep Abs. type_definition Rep Abs B", "obtain rep :: \"'basisT \\<Rightarrow> 'a\" and abs :: \"'a \\<Rightarrow> 'basisT\" where t: \"type_definition rep abs B\""], ["proof (prove)\nusing this:\n  \\<exists>Rep Abs. type_definition Rep Abs B\n\ngoal (1 subgoal):\n 1. (\\<And>rep abs.\n        type_definition rep abs B \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  type_definition rep abs B\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "(* Step 2: We show that our fake typedef 'basisT could be instantiated as type class finite *)"], ["proof (state)\nthis:\n  type_definition rep abs B\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "have basisT_finite: \"class.finite TYPE('basisT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.finite TYPE('basisT)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "using \\<open>finite B\\<close> t"], ["proof (prove)\nusing this:\n  finite B\n  type_definition rep abs B\n\ngoal (1 subgoal):\n 1. finite UNIV", "by (metis (mono_tags, hide_lams) ex_new_if_finite finite_imageI image_eqI type_definition_def)"], ["proof (state)\nthis:\n  class.finite TYPE('basisT)\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "(* Step 3: We take the finite_span_complete_aux and remove the requirement that 'basis::finite\n               (instead, a precondition \"class.finite TYPE('basisT)\" is introduced) *)"], ["proof (state)\nthis:\n  class.finite TYPE('basisT)\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "note finite_span_complete_aux(1)[internalize_sort \"'basis::finite\"]"], ["proof (state)\nthis:\n  \\<lbrakk>class.finite TYPE(?'a); type_definition ?rep ?abs ?B; finite ?B;\n   ?b \\<in> ?B; independent ?B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>D>0.\n                       \\<forall>\\<psi>.\n                          norm (representation ?B \\<psi> ?b)\n                          \\<le> norm \\<psi> * D\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "(* Step 4: We instantiate the premises *)"], ["proof (state)\nthis:\n  \\<lbrakk>class.finite TYPE(?'a); type_definition ?rep ?abs ?B; finite ?B;\n   ?b \\<in> ?B; independent ?B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>D>0.\n                       \\<forall>\\<psi>.\n                          norm (representation ?B \\<psi> ?b)\n                          \\<le> norm \\<psi> * D\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "note this[OF basisT_finite t]"], ["proof (state)\nthis:\n  \\<lbrakk>finite B; ?b \\<in> B; independent B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>D>0.\n                       \\<forall>\\<psi>.\n                          norm (representation B \\<psi> ?b)\n                          \\<le> norm \\<psi> * D\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>Rep Abs. type_definition Rep Abs B; finite B;\n   ?b6 \\<in> B; independent B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>D>0.\n                       \\<forall>\\<psi>.\n                          norm (representation B \\<psi> ?b6)\n                          \\<le> norm \\<psi> * D\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "(* Now we have the desired fact, except that it still assumes that B is isomorphic to some type 'basis\n     together with the assumption that there are morphisms between 'basis and B. 'basis and that premise\n     are removed using cancel_type_definition\n  *)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<exists>Rep Abs. type_definition Rep Abs B; finite B;\n   ?b6 \\<in> B; independent B\\<rbrakk>\n  \\<Longrightarrow> \\<exists>D>0.\n                       \\<forall>\\<psi>.\n                          norm (representation B \\<psi> ?b6)\n                          \\<le> norm \\<psi> * D\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "note this[cancel_type_definition, OF True \\<open>finite B\\<close> _ \\<open>independent B\\<close>]"], ["proof (state)\nthis:\n  ?b6 \\<in> B \\<Longrightarrow>\n  \\<exists>D>0.\n     \\<forall>\\<psi>.\n        norm (representation B \\<psi> ?b6) \\<le> norm \\<psi> * D\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "hence d2:\"\\<exists>D. \\<forall>\\<psi>. D>0 \\<and> norm (repr \\<psi> b) \\<le> norm \\<psi> * D\" if \\<open>b\\<in>B\\<close> for b"], ["proof (prove)\nusing this:\n  ?b6 \\<in> B \\<Longrightarrow>\n  \\<exists>D>0.\n     \\<forall>\\<psi>.\n        norm (representation B \\<psi> ?b6) \\<le> norm \\<psi> * D\n\ngoal (1 subgoal):\n 1. \\<exists>D.\n       \\<forall>\\<psi>.\n          0 < D \\<and> norm (repr \\<psi> b) \\<le> norm \\<psi> * D", "by (simp add: repr_def that True)"], ["proof (state)\nthis:\n  ?b \\<in> B \\<Longrightarrow>\n  \\<exists>D.\n     \\<forall>\\<psi>.\n        0 < D \\<and> norm (repr \\<psi> ?b) \\<le> norm \\<psi> * D\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "have d1: \" (\\<And>b. b \\<in> B \\<Longrightarrow>\n          \\<exists>D. \\<forall>\\<psi>. 0 < D \\<and> norm (repr \\<psi> b) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n    \\<exists>D. \\<forall>b \\<psi>. b \\<in> B \\<longrightarrow>\n               0 < D b \\<and> norm (repr \\<psi> b) \\<le> norm \\<psi> * D b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        b \\<in> B \\<Longrightarrow>\n        \\<exists>D.\n           \\<forall>\\<psi>.\n              0 < D \\<and>\n              norm (repr \\<psi> b) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n    \\<exists>D.\n       \\<forall>b \\<psi>.\n          b \\<in> B \\<longrightarrow>\n          0 < D b \\<and> norm (repr \\<psi> b) \\<le> norm \\<psi> * D b", "apply (rule choice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        b \\<in> B \\<Longrightarrow>\n        \\<exists>D.\n           \\<forall>\\<psi>.\n              0 < D \\<and>\n              norm (repr \\<psi> b) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n    \\<forall>b.\n       \\<exists>y.\n          \\<forall>\\<psi>.\n             b \\<in> B \\<longrightarrow>\n             0 < y \\<and> norm (repr \\<psi> b) \\<le> norm \\<psi> * y", "by auto"], ["proof (state)\nthis:\n  (\\<And>b.\n      b \\<in> B \\<Longrightarrow>\n      \\<exists>D.\n         \\<forall>\\<psi>.\n            0 < D \\<and>\n            norm (repr \\<psi> b) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n  \\<exists>D.\n     \\<forall>b \\<psi>.\n        b \\<in> B \\<longrightarrow>\n        0 < D b \\<and> norm (repr \\<psi> b) \\<le> norm \\<psi> * D b\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "then"], ["proof (chain)\npicking this:\n  (\\<And>b.\n      b \\<in> B \\<Longrightarrow>\n      \\<exists>D.\n         \\<forall>\\<psi>.\n            0 < D \\<and>\n            norm (repr \\<psi> b) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n  \\<exists>D.\n     \\<forall>b \\<psi>.\n        b \\<in> B \\<longrightarrow>\n        0 < D b \\<and> norm (repr \\<psi> b) \\<le> norm \\<psi> * D b", "obtain D where D: \"D b > 0 \\<and> norm (repr \\<psi> b) \\<le> norm \\<psi> * D b\" if \"b\\<in>B\" for b \\<psi>"], ["proof (prove)\nusing this:\n  (\\<And>b.\n      b \\<in> B \\<Longrightarrow>\n      \\<exists>D.\n         \\<forall>\\<psi>.\n            0 < D \\<and>\n            norm (repr \\<psi> b) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n  \\<exists>D.\n     \\<forall>b \\<psi>.\n        b \\<in> B \\<longrightarrow>\n        0 < D b \\<and> norm (repr \\<psi> b) \\<le> norm \\<psi> * D b\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        (\\<And>b \\<psi>.\n            b \\<in> B \\<Longrightarrow>\n            0 < D b \\<and>\n            norm (repr \\<psi> b) \\<le> norm \\<psi> * D b) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>b.\n         b \\<in> B \\<Longrightarrow>\n         \\<exists>D.\n            \\<forall>\\<psi>.\n               0 < D \\<and>\n               norm (repr \\<psi> b) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n     \\<exists>D.\n        \\<forall>b \\<psi>.\n           b \\<in> B \\<longrightarrow>\n           0 < D b \\<and>\n           norm (repr \\<psi> b) \\<le> norm \\<psi> * D b) \\<Longrightarrow>\n    \\<exists>D.\n       \\<forall>b \\<psi>.\n          b \\<in> B \\<longrightarrow>\n          0 < D b \\<and> norm (repr \\<psi> b) \\<le> norm \\<psi> * D b", "using d2"], ["proof (prove)\nusing this:\n  ?b \\<in> B \\<Longrightarrow>\n  \\<exists>D.\n     \\<forall>\\<psi>.\n        0 < D \\<and> norm (repr \\<psi> ?b) \\<le> norm \\<psi> * D\n\ngoal (1 subgoal):\n 1. ((\\<And>b.\n         b \\<in> B \\<Longrightarrow>\n         \\<exists>D.\n            \\<forall>\\<psi>.\n               0 < D \\<and>\n               norm (repr \\<psi> b) \\<le> norm \\<psi> * D) \\<Longrightarrow>\n     \\<exists>D.\n        \\<forall>b \\<psi>.\n           b \\<in> B \\<longrightarrow>\n           0 < D b \\<and>\n           norm (repr \\<psi> b) \\<le> norm \\<psi> * D b) \\<Longrightarrow>\n    \\<exists>D.\n       \\<forall>b \\<psi>.\n          b \\<in> B \\<longrightarrow>\n          0 < D b \\<and> norm (repr \\<psi> b) \\<le> norm \\<psi> * D b", "by blast"], ["proof (state)\nthis:\n  ?b \\<in> B \\<Longrightarrow>\n  0 < D ?b \\<and> norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * D ?b\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "hence Dpos: \"D b > 0\" and Dbound: \"norm (repr \\<psi> b) \\<le> norm \\<psi> * D b\" \n    if \"b\\<in>B\" for b \\<psi>"], ["proof (prove)\nusing this:\n  ?b \\<in> B \\<Longrightarrow>\n  0 < D ?b \\<and> norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * D ?b\n\ngoal (1 subgoal):\n 1. 0 < D b &&& norm (repr \\<psi> b) \\<le> norm \\<psi> * D b", "using that"], ["proof (prove)\nusing this:\n  ?b \\<in> B \\<Longrightarrow>\n  0 < D ?b \\<and> norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * D ?b\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. 0 < D b &&& norm (repr \\<psi> b) \\<le> norm \\<psi> * D b", "by auto"], ["proof (state)\nthis:\n  ?b \\<in> B \\<Longrightarrow> 0 < D ?b\n  ?b \\<in> B \\<Longrightarrow>\n  norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * D ?b\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "define Dall where \"Dall = Max (D`B)\""], ["proof (state)\nthis:\n  Dall = Max (D ` B)\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "have \"Dall > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Dall", "unfolding Dall_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Max (D ` B)", "using \\<open>finite B\\<close> \\<open>B\\<noteq>{}\\<close> Dpos"], ["proof (prove)\nusing this:\n  finite B\n  B \\<noteq> {}\n  ?b \\<in> B \\<Longrightarrow> 0 < D ?b\n\ngoal (1 subgoal):\n 1. 0 < Max (D ` B)", "by (metis (mono_tags, lifting) Max_in finite_imageI image_iff image_is_empty)"], ["proof (state)\nthis:\n  0 < Dall\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "have \"Dall \\<ge> D b\" if \"b\\<in>B\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. D b \\<le> Dall", "unfolding Dall_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. D b \\<le> Max (D ` B)", "using \\<open>finite B\\<close> that"], ["proof (prove)\nusing this:\n  finite B\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. D b \\<le> Max (D ` B)", "by auto"], ["proof (state)\nthis:\n  ?b \\<in> B \\<Longrightarrow> D ?b \\<le> Dall\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "with Dbound"], ["proof (chain)\npicking this:\n  ?b \\<in> B \\<Longrightarrow>\n  norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * D ?b\n  ?b \\<in> B \\<Longrightarrow> D ?b \\<le> Dall", "have \"norm (repr \\<psi> b) \\<le> norm \\<psi> * Dall\" if \"b\\<in>B\" for b \\<psi>"], ["proof (prove)\nusing this:\n  ?b \\<in> B \\<Longrightarrow>\n  norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * D ?b\n  ?b \\<in> B \\<Longrightarrow> D ?b \\<le> Dall\n\ngoal (1 subgoal):\n 1. norm (repr \\<psi> b) \\<le> norm \\<psi> * Dall", "using that"], ["proof (prove)\nusing this:\n  ?b \\<in> B \\<Longrightarrow>\n  norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * D ?b\n  ?b \\<in> B \\<Longrightarrow> D ?b \\<le> Dall\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. norm (repr \\<psi> b) \\<le> norm \\<psi> * Dall", "by (smt mult_left_mono norm_not_less_zero)"], ["proof (state)\nthis:\n  ?b \\<in> B \\<Longrightarrow>\n  norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * Dall\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "moreover"], ["proof (state)\nthis:\n  ?b \\<in> B \\<Longrightarrow>\n  norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * Dall\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "have \"norm (repr \\<psi> b) \\<le> norm \\<psi> * Dall\" if \"b\\<notin>B\" for b \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (repr \\<psi> b) \\<le> norm \\<psi> * Dall", "unfolding repr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (representation B \\<psi> b) \\<le> norm \\<psi> * Dall", "using real_vector.representation_ne_zero True"], ["proof (prove)\nusing this:\n  representation ?basis ?v ?b \\<noteq> 0 \\<Longrightarrow> ?b \\<in> ?basis\n  B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. norm (representation B \\<psi> b) \\<le> norm \\<psi> * Dall", "by (metis calculation empty_subsetI less_le_trans local.repr_def norm_ge_zero norm_zero not_less \n        subsetI subset_antisym)"], ["proof (state)\nthis:\n  ?b \\<notin> B \\<Longrightarrow>\n  norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * Dall\n\ngoal (2 subgoals):\n 1. B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n 2. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "ultimately"], ["proof (chain)\npicking this:\n  ?b \\<in> B \\<Longrightarrow>\n  norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * Dall\n  ?b \\<notin> B \\<Longrightarrow>\n  norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * Dall", "show \"\\<exists>D>0. \\<forall>\\<psi> b. abs (repr \\<psi> b) \\<le> norm \\<psi> * D\""], ["proof (prove)\nusing this:\n  ?b \\<in> B \\<Longrightarrow>\n  norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * Dall\n  ?b \\<notin> B \\<Longrightarrow>\n  norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * Dall\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b. \\<bar>repr \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "using \\<open>Dall > 0\\<close> real_norm_def"], ["proof (prove)\nusing this:\n  ?b \\<in> B \\<Longrightarrow>\n  norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * Dall\n  ?b \\<notin> B \\<Longrightarrow>\n  norm (repr ?\\<psi> ?b) \\<le> norm ?\\<psi> * Dall\n  0 < Dall\n  norm ?r = \\<bar>?r\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b. \\<bar>repr \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "by metis"], ["proof (state)\nthis:\n  \\<exists>D>0.\n     \\<forall>\\<psi> b. \\<bar>repr \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n\ngoal (1 subgoal):\n 1. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "case False"], ["proof (state)\nthis:\n  \\<not> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> B \\<noteq> {} \\<Longrightarrow>\n    \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "unfolding repr_def"], ["proof (prove)\nusing this:\n  \\<not> B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "using real_vector.representation_ne_zero[of B]"], ["proof (prove)\nusing this:\n  \\<not> B \\<noteq> {}\n  representation B ?v ?b \\<noteq> 0 \\<Longrightarrow> ?b \\<in> B\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "using nice_ordered_field_class.linordered_field_no_ub"], ["proof (prove)\nusing this:\n  \\<not> B \\<noteq> {}\n  representation B ?v ?b \\<noteq> 0 \\<Longrightarrow> ?b \\<in> B\n  \\<forall>x. \\<exists>y. x < y\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>D>0.\n     \\<forall>\\<psi> b.\n        \\<bar>representation B \\<psi> b\\<bar> \\<le> norm \\<psi> * D\n\ngoal:\nNo subgoals!", "qed"], ["", "hide_fact finite_span_complete_aux"], ["", "lemma finite_cspan_complete[simp]: \n  fixes B :: \"'a::complex_normed_vector set\"\n  assumes \"finite B\"\n  shows \"complete (cspan B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete (cspan B)", "by (simp add: assms cspan_as_span)"], ["", "lemma finite_span_closed[simp]:\n  fixes B :: \"'a::real_normed_vector set\"\n  assumes \"finite B\"\n  shows \"closed (real_vector.span B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (span B)", "by (simp add: assms complete_imp_closed)"], ["", "lemma finite_cspan_closed[simp]:\n  fixes S::\\<open>'a::complex_normed_vector set\\<close>\n  assumes a1: \\<open>finite S\\<close>\n  shows \\<open>closed (cspan S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (cspan S)", "by (simp add: assms complete_imp_closed)"], ["", "lemma closure_finite_cspan:\n  fixes T::\\<open>'a::complex_normed_vector set\\<close>\n  assumes \\<open>finite T\\<close>\n  shows \\<open>closure (cspan T)  = cspan T\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (cspan T) = cspan T", "by (simp add: assms)"], ["", "lemma finite_cspan_crepresentation_bounded:\n  fixes B :: \"'a::complex_normed_vector set\"\n  assumes a1: \"finite B\" and a2: \"cindependent B\"\n  shows \"\\<exists>D>0. \\<forall>\\<psi> b. norm (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "define B' where \"B' = (B \\<union> scaleC \\<i> ` B)\""], ["proof (state)\nthis:\n  B' = B \\<union> (*\\<^sub>C) \\<i> ` B\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "have independent_B': \"independent B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. independent B'", "using B'_def \\<open>cindependent B\\<close>"], ["proof (prove)\nusing this:\n  B' = B \\<union> (*\\<^sub>C) \\<i> ` B\n  cindependent B\n\ngoal (1 subgoal):\n 1. independent B'", "by (simp add: real_independent_from_complex_independent a1)"], ["proof (state)\nthis:\n  independent B'\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "have \"finite B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite B'", "unfolding B'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (B \\<union> (*\\<^sub>C) \\<i> ` B)", "using \\<open>finite B\\<close>"], ["proof (prove)\nusing this:\n  finite B\n\ngoal (1 subgoal):\n 1. finite (B \\<union> (*\\<^sub>C) \\<i> ` B)", "by simp"], ["proof (state)\nthis:\n  finite B'\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "obtain D' where \"D' > 0\" and D': \"norm (real_vector.representation B' \\<psi> b) \\<le> norm \\<psi> * D'\" \n    for \\<psi> b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>D'.\n        \\<lbrakk>0 < D';\n         \\<And>\\<psi> b.\n            norm (representation B' \\<psi> b)\n            \\<le> norm \\<psi> * D'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D'>0.\n       \\<forall>\\<psi> b.\n          norm (representation B' \\<psi> b) \\<le> norm \\<psi> * D'", "using independent_B' \\<open>finite B'\\<close>"], ["proof (prove)\nusing this:\n  independent B'\n  finite B'\n\ngoal (1 subgoal):\n 1. \\<exists>D'>0.\n       \\<forall>\\<psi> b.\n          norm (representation B' \\<psi> b) \\<le> norm \\<psi> * D'", "by (simp add: finite_span_representation_bounded)"], ["proof (state)\nthis:\n  0 < D'\n  norm (representation B' ?\\<psi> ?b) \\<le> norm ?\\<psi> * D'\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "define D where \"D = 2*D'\""], ["proof (state)\nthis:\n  D = 2 * D'\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "from \\<open>D' > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < D'", "have \\<open>D > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < D'\n\ngoal (1 subgoal):\n 1. 0 < D", "unfolding D_def"], ["proof (prove)\nusing this:\n  0 < D'\n\ngoal (1 subgoal):\n 1. 0 < 2 * D'", "by simp"], ["proof (state)\nthis:\n  0 < D\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "have \"norm (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\" for \\<psi> b"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "proof (cases \"b\\<in>B\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "case True"], ["proof (state)\nthis:\n  b \\<in> B\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "have d3: \"norm \\<i> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<i> = 1", "by simp"], ["proof (state)\nthis:\n  cmod \\<i> = 1\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "have \"norm (\\<i> *\\<^sub>C complex_of_real (real_vector.representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n          = norm \\<i> * norm (complex_of_real (real_vector.representation B' \\<psi> (\\<i> *\\<^sub>C b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (\\<i> *\\<^sub>C\n      complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n    cmod \\<i> *\n    cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))", "using norm_scaleC"], ["proof (prove)\nusing this:\n  norm (?a *\\<^sub>C ?x) = cmod ?a * norm ?x\n\ngoal (1 subgoal):\n 1. cmod\n     (\\<i> *\\<^sub>C\n      complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n    cmod \\<i> *\n    cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))", "by blast"], ["proof (state)\nthis:\n  cmod\n   (\\<i> *\\<^sub>C\n    complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n  cmod \\<i> *\n  cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "also"], ["proof (state)\nthis:\n  cmod\n   (\\<i> *\\<^sub>C\n    complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n  cmod \\<i> *\n  cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "have \"\\<dots> = norm (complex_of_real (real_vector.representation B' \\<psi> (\\<i> *\\<^sub>C b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<i> *\n    cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n    cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))", "using d3"], ["proof (prove)\nusing this:\n  cmod \\<i> = 1\n\ngoal (1 subgoal):\n 1. cmod \\<i> *\n    cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n    cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))", "by simp"], ["proof (state)\nthis:\n  cmod \\<i> *\n  cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n  cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "finally"], ["proof (chain)\npicking this:\n  cmod\n   (\\<i> *\\<^sub>C\n    complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n  cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))", "have d2:\"norm (\\<i> *\\<^sub>C complex_of_real (real_vector.representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n          = norm (complex_of_real (real_vector.representation B' \\<psi> (\\<i> *\\<^sub>C b)))\""], ["proof (prove)\nusing this:\n  cmod\n   (\\<i> *\\<^sub>C\n    complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n  cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n\ngoal (1 subgoal):\n 1. cmod\n     (\\<i> *\\<^sub>C\n      complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n    cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))", "."], ["proof (state)\nthis:\n  cmod\n   (\\<i> *\\<^sub>C\n    complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n  cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "have \"norm (crepresentation B \\<psi> b)\n        = norm (complex_of_real (real_vector.representation B' \\<psi> b)\n            + \\<i> *\\<^sub>C complex_of_real (real_vector.representation B' \\<psi> (\\<i> *\\<^sub>C b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (crepresentation B \\<psi> b) =\n    cmod\n     (complex_of_real (representation B' \\<psi> b) +\n      \\<i> *\\<^sub>C\n      complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))", "by (simp add: B'_def True a1 a2 crepresentation_from_representation)"], ["proof (state)\nthis:\n  cmod (crepresentation B \\<psi> b) =\n  cmod\n   (complex_of_real (representation B' \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "also"], ["proof (state)\nthis:\n  cmod (crepresentation B \\<psi> b) =\n  cmod\n   (complex_of_real (representation B' \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "have \"\\<dots> \\<le> norm (complex_of_real (real_vector.representation B' \\<psi> b))\n             + norm (\\<i> *\\<^sub>C complex_of_real (real_vector.representation B' \\<psi> (\\<i> *\\<^sub>C b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod\n     (complex_of_real (representation B' \\<psi> b) +\n      \\<i> *\\<^sub>C\n      complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n    \\<le> cmod (complex_of_real (representation B' \\<psi> b)) +\n          cmod\n           (\\<i> *\\<^sub>C\n            complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))", "using norm_triangle_ineq"], ["proof (prove)\nusing this:\n  norm (?x + ?y) \\<le> norm ?x + norm ?y\n\ngoal (1 subgoal):\n 1. cmod\n     (complex_of_real (representation B' \\<psi> b) +\n      \\<i> *\\<^sub>C\n      complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n    \\<le> cmod (complex_of_real (representation B' \\<psi> b)) +\n          cmod\n           (\\<i> *\\<^sub>C\n            complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))", "by blast"], ["proof (state)\nthis:\n  cmod\n   (complex_of_real (representation B' \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n  \\<le> cmod (complex_of_real (representation B' \\<psi> b)) +\n        cmod\n         (\\<i> *\\<^sub>C\n          complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "also"], ["proof (state)\nthis:\n  cmod\n   (complex_of_real (representation B' \\<psi> b) +\n    \\<i> *\\<^sub>C\n    complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n  \\<le> cmod (complex_of_real (representation B' \\<psi> b)) +\n        cmod\n         (\\<i> *\\<^sub>C\n          complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "have \"\\<dots> = norm (complex_of_real (real_vector.representation B' \\<psi> b))\n                  + norm (complex_of_real (real_vector.representation B' \\<psi> (\\<i> *\\<^sub>C b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (complex_of_real (representation B' \\<psi> b)) +\n    cmod\n     (\\<i> *\\<^sub>C\n      complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n    cmod (complex_of_real (representation B' \\<psi> b)) +\n    cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))", "using d2"], ["proof (prove)\nusing this:\n  cmod\n   (\\<i> *\\<^sub>C\n    complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n  cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n\ngoal (1 subgoal):\n 1. cmod (complex_of_real (representation B' \\<psi> b)) +\n    cmod\n     (\\<i> *\\<^sub>C\n      complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n    cmod (complex_of_real (representation B' \\<psi> b)) +\n    cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))", "by simp"], ["proof (state)\nthis:\n  cmod (complex_of_real (representation B' \\<psi> b)) +\n  cmod\n   (\\<i> *\\<^sub>C\n    complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n  cmod (complex_of_real (representation B' \\<psi> b)) +\n  cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "also"], ["proof (state)\nthis:\n  cmod (complex_of_real (representation B' \\<psi> b)) +\n  cmod\n   (\\<i> *\\<^sub>C\n    complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n  cmod (complex_of_real (representation B' \\<psi> b)) +\n  cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b)))\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "have \"\\<dots> = norm (real_vector.representation B' \\<psi> b)\n                  + norm (real_vector.representation B' \\<psi> (\\<i> *\\<^sub>C b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (complex_of_real (representation B' \\<psi> b)) +\n    cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n    norm (representation B' \\<psi> b) +\n    norm (representation B' \\<psi> (\\<i> *\\<^sub>C b))", "by simp"], ["proof (state)\nthis:\n  cmod (complex_of_real (representation B' \\<psi> b)) +\n  cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n  norm (representation B' \\<psi> b) +\n  norm (representation B' \\<psi> (\\<i> *\\<^sub>C b))\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "also"], ["proof (state)\nthis:\n  cmod (complex_of_real (representation B' \\<psi> b)) +\n  cmod (complex_of_real (representation B' \\<psi> (\\<i> *\\<^sub>C b))) =\n  norm (representation B' \\<psi> b) +\n  norm (representation B' \\<psi> (\\<i> *\\<^sub>C b))\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "have \"\\<dots> \\<le> norm \\<psi> * D' + norm \\<psi> * D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (representation B' \\<psi> b) +\n    norm (representation B' \\<psi> (\\<i> *\\<^sub>C b))\n    \\<le> norm \\<psi> * D' + norm \\<psi> * D'", "by (rule add_mono; rule D')"], ["proof (state)\nthis:\n  norm (representation B' \\<psi> b) +\n  norm (representation B' \\<psi> (\\<i> *\\<^sub>C b))\n  \\<le> norm \\<psi> * D' + norm \\<psi> * D'\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "also"], ["proof (state)\nthis:\n  norm (representation B' \\<psi> b) +\n  norm (representation B' \\<psi> (\\<i> *\\<^sub>C b))\n  \\<le> norm \\<psi> * D' + norm \\<psi> * D'\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "have \"\\<dots> \\<le> norm \\<psi> * D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm \\<psi> * D' + norm \\<psi> * D' \\<le> norm \\<psi> * D", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm \\<psi> * D' + norm \\<psi> * D' \\<le> norm \\<psi> * (2 * D')", "by linarith"], ["proof (state)\nthis:\n  norm \\<psi> * D' + norm \\<psi> * D' \\<le> norm \\<psi> * D\n\ngoal (2 subgoals):\n 1. b \\<in> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n 2. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "finally"], ["proof (chain)\npicking this:\n  cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n\ngoal (1 subgoal):\n 1. cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "by auto"], ["proof (state)\nthis:\n  cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "case False"], ["proof (state)\nthis:\n  b \\<notin> B\n\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "hence \"crepresentation B \\<psi> b = 0\""], ["proof (prove)\nusing this:\n  b \\<notin> B\n\ngoal (1 subgoal):\n 1. crepresentation B \\<psi> b = 0", "using complex_vector.representation_ne_zero"], ["proof (prove)\nusing this:\n  b \\<notin> B\n  crepresentation ?basis ?v ?b \\<noteq> 0 \\<Longrightarrow> ?b \\<in> ?basis\n\ngoal (1 subgoal):\n 1. crepresentation B \\<psi> b = 0", "by blast"], ["proof (state)\nthis:\n  crepresentation B \\<psi> b = 0\n\ngoal (1 subgoal):\n 1. b \\<notin> B \\<Longrightarrow>\n    cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "thus ?thesis"], ["proof (prove)\nusing this:\n  crepresentation B \\<psi> b = 0\n\ngoal (1 subgoal):\n 1. cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "by (smt \\<open>0 < D\\<close> norm_ge_zero norm_zero split_mult_pos_le)"], ["proof (state)\nthis:\n  cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cmod (crepresentation B ?\\<psi> ?b) \\<le> norm ?\\<psi> * D\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "with \\<open>D > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < D\n  cmod (crepresentation B ?\\<psi> ?b) \\<le> norm ?\\<psi> * D", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < D\n  cmod (crepresentation B ?\\<psi> ?b) \\<le> norm ?\\<psi> * D\n\ngoal (1 subgoal):\n 1. \\<exists>D>0.\n       \\<forall>\\<psi> b.\n          cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D", "by auto"], ["proof (state)\nthis:\n  \\<exists>D>0.\n     \\<forall>\\<psi> b.\n        cmod (crepresentation B \\<psi> b) \\<le> norm \\<psi> * D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_clinear_finite_dim[simp]:\n  fixes f :: \\<open>'a::{cfinite_dim,complex_normed_vector} \\<Rightarrow> 'b::complex_normed_vector\\<close>\n  assumes \\<open>clinear f\\<close>\n  shows \\<open>bounded_clinear f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear f", "include notation_norm"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_clinear f", "obtain basis :: \\<open>'a set\\<close> where b1: \"complex_vector.span basis = UNIV\"\n    and b2: \"cindependent basis\"\n    and b3:\"finite basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>basis.\n        \\<lbrakk>cspan basis = UNIV; cindependent basis;\n         finite basis\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using finite_basis"], ["proof (prove)\nusing this:\n  \\<exists>basis.\n     finite basis \\<and> cindependent basis \\<and> cspan basis = UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>basis.\n        \\<lbrakk>cspan basis = UNIV; cindependent basis;\n         finite basis\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cspan basis = UNIV\n  cindependent basis\n  finite basis\n\ngoal (1 subgoal):\n 1. bounded_clinear f", "have \"\\<exists>C>0. \\<forall>\\<psi> b. cmod (crepresentation basis \\<psi> b) \\<le> \\<parallel>\\<psi>\\<parallel> * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C>0.\n       \\<forall>\\<psi> b.\n          cmod (crepresentation basis \\<psi> b)\n          \\<le> \\<parallel>\\<psi>\\<parallel> * C", "using finite_cspan_crepresentation_bounded[where B = basis] b2 b3"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite basis; cindependent basis\\<rbrakk>\n  \\<Longrightarrow> \\<exists>D>0.\n                       \\<forall>\\<psi> b.\n                          cmod (crepresentation basis \\<psi> b)\n                          \\<le> \\<parallel>\\<psi>\\<parallel> * D\n  cindependent basis\n  finite basis\n\ngoal (1 subgoal):\n 1. \\<exists>C>0.\n       \\<forall>\\<psi> b.\n          cmod (crepresentation basis \\<psi> b)\n          \\<le> \\<parallel>\\<psi>\\<parallel> * C", "by blast"], ["proof (state)\nthis:\n  \\<exists>C>0.\n     \\<forall>\\<psi> b.\n        cmod (crepresentation basis \\<psi> b)\n        \\<le> \\<parallel>\\<psi>\\<parallel> * C\n\ngoal (1 subgoal):\n 1. bounded_clinear f", "then"], ["proof (chain)\npicking this:\n  \\<exists>C>0.\n     \\<forall>\\<psi> b.\n        cmod (crepresentation basis \\<psi> b)\n        \\<le> \\<parallel>\\<psi>\\<parallel> * C", "obtain C where s1: \"cmod (crepresentation basis \\<psi> b) \\<le> \\<parallel>\\<psi>\\<parallel> * C\" \n    and s2: \"C > 0\"\n  for \\<psi> b"], ["proof (prove)\nusing this:\n  \\<exists>C>0.\n     \\<forall>\\<psi> b.\n        cmod (crepresentation basis \\<psi> b)\n        \\<le> \\<parallel>\\<psi>\\<parallel> * C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>\\<And>\\<psi> b.\n                    cmod (crepresentation basis \\<psi> b)\n                    \\<le> \\<parallel>\\<psi>\\<parallel> * C;\n         0 < C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cmod (crepresentation basis ?\\<psi> ?b)\n  \\<le> \\<parallel>?\\<psi>\\<parallel> * C\n  0 < C\n\ngoal (1 subgoal):\n 1. bounded_clinear f", "define M where \"M = C * (\\<Sum>a\\<in>basis. \\<parallel>f a\\<parallel>)\""], ["proof (state)\nthis:\n  M = C * (\\<Sum>a\\<in>basis. \\<parallel>f a\\<parallel>)\n\ngoal (1 subgoal):\n 1. bounded_clinear f", "have \"\\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M\"\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "define r where \"r b = crepresentation basis x b\" for b"], ["proof (state)\nthis:\n  r ?b = crepresentation basis x ?b\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "have x_span: \"x \\<in> complex_vector.span basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> cspan basis", "by (simp add: b1)"], ["proof (state)\nthis:\n  x \\<in> cspan basis\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "have f0: \"v \\<in> basis\"\n      if \"r v \\<noteq> 0\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> basis", "using complex_vector.representation_ne_zero r_def that"], ["proof (prove)\nusing this:\n  crepresentation ?basis ?v ?b \\<noteq> 0 \\<Longrightarrow> ?b \\<in> ?basis\n  r ?b = crepresentation basis x ?b\n  r v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<in> basis", "by auto"], ["proof (state)\nthis:\n  r ?v \\<noteq> 0 \\<Longrightarrow> ?v \\<in> basis\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "have w:\"{a|a. r a \\<noteq> 0} \\<subseteq> basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a |a. r a \\<noteq> 0} \\<subseteq> basis", "using f0"], ["proof (prove)\nusing this:\n  r ?v \\<noteq> 0 \\<Longrightarrow> ?v \\<in> basis\n\ngoal (1 subgoal):\n 1. {a |a. r a \\<noteq> 0} \\<subseteq> basis", "by blast"], ["proof (state)\nthis:\n  {a |a. r a \\<noteq> 0} \\<subseteq> basis\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "hence f1: \"finite {a|a. r a \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  {a |a. r a \\<noteq> 0} \\<subseteq> basis\n\ngoal (1 subgoal):\n 1. finite {a |a. r a \\<noteq> 0}", "using b3 rev_finite_subset"], ["proof (prove)\nusing this:\n  {a |a. r a \\<noteq> 0} \\<subseteq> basis\n  finite basis\n  \\<lbrakk>finite ?B; ?A \\<subseteq> ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite {a |a. r a \\<noteq> 0}", "by auto"], ["proof (state)\nthis:\n  finite {a |a. r a \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "have f2: \"(\\<Sum>a| r a \\<noteq> 0. r a *\\<^sub>C a) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a | r a \\<noteq> 0. r a *\\<^sub>C a) = x", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a | crepresentation basis x a \\<noteq> 0.\n       crepresentation basis x a *\\<^sub>C a) =\n    x", "using b2 complex_vector.sum_nonzero_representation_eq x_span\n        Collect_cong"], ["proof (prove)\nusing this:\n  cindependent basis\n  \\<lbrakk>cindependent ?basis; ?v \\<in> cspan ?basis\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>b | crepresentation ?basis ?v b \\<noteq> 0.\n                       crepresentation ?basis ?v b *\\<^sub>C b) =\n                    ?v\n  x \\<in> cspan basis\n  (\\<And>x. ?P x = ?Q x) \\<Longrightarrow> {x. ?P x} = {x. ?Q x}\n\ngoal (1 subgoal):\n 1. (\\<Sum>a | crepresentation basis x a \\<noteq> 0.\n       crepresentation basis x a *\\<^sub>C a) =\n    x", "by fastforce"], ["proof (state)\nthis:\n  (\\<Sum>a | r a \\<noteq> 0. r a *\\<^sub>C a) = x\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "have g1: \"(\\<Sum>a\\<in>basis. crepresentation basis x a *\\<^sub>C a) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>basis. crepresentation basis x a *\\<^sub>C a) = x", "by (simp add: b2 b3 complex_vector.sum_representation_eq x_span)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>basis. crepresentation basis x a *\\<^sub>C a) = x\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "have f3: \"(\\<Sum>a\\<in>basis. r a *\\<^sub>C a) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>basis. r a *\\<^sub>C a) = x", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>basis. crepresentation basis x a *\\<^sub>C a) = x", "by (simp add: g1)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>basis. r a *\\<^sub>C a) = x\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "hence \"f x = f (\\<Sum>a\\<in>basis. r a *\\<^sub>C a)\""], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<in>basis. r a *\\<^sub>C a) = x\n\ngoal (1 subgoal):\n 1. f x = f (\\<Sum>a\\<in>basis. r a *\\<^sub>C a)", "by simp"], ["proof (state)\nthis:\n  f x = f (\\<Sum>a\\<in>basis. r a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "also"], ["proof (state)\nthis:\n  f x = f (\\<Sum>a\\<in>basis. r a *\\<^sub>C a)\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "have \"\\<dots> = (\\<Sum>a\\<in>basis. r a *\\<^sub>C f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<Sum>a\\<in>basis. r a *\\<^sub>C a) =\n    (\\<Sum>a\\<in>basis. r a *\\<^sub>C f a)", "by (smt (verit, ccfv_SIG) assms complex_vector.linear_scale complex_vector.linear_sum sum.cong)"], ["proof (state)\nthis:\n  f (\\<Sum>a\\<in>basis. r a *\\<^sub>C a) =\n  (\\<Sum>a\\<in>basis. r a *\\<^sub>C f a)\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "finally"], ["proof (chain)\npicking this:\n  f x = (\\<Sum>a\\<in>basis. r a *\\<^sub>C f a)", "have \"f x = (\\<Sum>a\\<in>basis. r a *\\<^sub>C f a)\""], ["proof (prove)\nusing this:\n  f x = (\\<Sum>a\\<in>basis. r a *\\<^sub>C f a)\n\ngoal (1 subgoal):\n 1. f x = (\\<Sum>a\\<in>basis. r a *\\<^sub>C f a)", "."], ["proof (state)\nthis:\n  f x = (\\<Sum>a\\<in>basis. r a *\\<^sub>C f a)\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "hence \"\\<parallel>f x\\<parallel> = \\<parallel>(\\<Sum>a\\<in>basis. r a *\\<^sub>C f a)\\<parallel>\""], ["proof (prove)\nusing this:\n  f x = (\\<Sum>a\\<in>basis. r a *\\<^sub>C f a)\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> =\n    \\<parallel>\\<Sum>a\\<in>basis. r a *\\<^sub>C f a\\<parallel>", "by simp"], ["proof (state)\nthis:\n  \\<parallel>f x\\<parallel> =\n  \\<parallel>\\<Sum>a\\<in>basis. r a *\\<^sub>C f a\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "also"], ["proof (state)\nthis:\n  \\<parallel>f x\\<parallel> =\n  \\<parallel>\\<Sum>a\\<in>basis. r a *\\<^sub>C f a\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "have \"\\<dots> \\<le> (\\<Sum>a\\<in>basis. \\<parallel>r a *\\<^sub>C f a\\<parallel>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>\\<Sum>a\\<in>basis. r a *\\<^sub>C f a\\<parallel>\n    \\<le> (\\<Sum>a\\<in>basis. \\<parallel>r a *\\<^sub>C f a\\<parallel>)", "by (simp add: sum_norm_le)"], ["proof (state)\nthis:\n  \\<parallel>\\<Sum>a\\<in>basis. r a *\\<^sub>C f a\\<parallel>\n  \\<le> (\\<Sum>a\\<in>basis. \\<parallel>r a *\\<^sub>C f a\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "also"], ["proof (state)\nthis:\n  \\<parallel>\\<Sum>a\\<in>basis. r a *\\<^sub>C f a\\<parallel>\n  \\<le> (\\<Sum>a\\<in>basis. \\<parallel>r a *\\<^sub>C f a\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "have \"\\<dots> \\<le> (\\<Sum>a\\<in>basis. \\<parallel>r a\\<parallel> * \\<parallel>f a\\<parallel>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>basis. \\<parallel>r a *\\<^sub>C f a\\<parallel>)\n    \\<le> (\\<Sum>a\\<in>basis. cmod (r a) * \\<parallel>f a\\<parallel>)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>basis. \\<parallel>r a *\\<^sub>C f a\\<parallel>)\n  \\<le> (\\<Sum>a\\<in>basis. cmod (r a) * \\<parallel>f a\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>basis. \\<parallel>r a *\\<^sub>C f a\\<parallel>)\n  \\<le> (\\<Sum>a\\<in>basis. cmod (r a) * \\<parallel>f a\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "have \"\\<dots> \\<le> (\\<Sum>a\\<in>basis. \\<parallel>x\\<parallel> * C * \\<parallel>f a\\<parallel>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>basis. cmod (r a) * \\<parallel>f a\\<parallel>)\n    \\<le> (\\<Sum>a\\<in>basis.\n             \\<parallel>x\\<parallel> * C * \\<parallel>f a\\<parallel>)", "using sum_mono s1"], ["proof (prove)\nusing this:\n  (\\<And>i. i \\<in> ?K \\<Longrightarrow> ?f i \\<le> ?g i) \\<Longrightarrow>\n  sum ?f ?K \\<le> sum ?g ?K\n  cmod (crepresentation basis ?\\<psi> ?b)\n  \\<le> \\<parallel>?\\<psi>\\<parallel> * C\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>basis. cmod (r a) * \\<parallel>f a\\<parallel>)\n    \\<le> (\\<Sum>a\\<in>basis.\n             \\<parallel>x\\<parallel> * C * \\<parallel>f a\\<parallel>)", "unfolding r_def"], ["proof (prove)\nusing this:\n  (\\<And>i. i \\<in> ?K \\<Longrightarrow> ?f i \\<le> ?g i) \\<Longrightarrow>\n  sum ?f ?K \\<le> sum ?g ?K\n  cmod (crepresentation basis ?\\<psi> ?b)\n  \\<le> \\<parallel>?\\<psi>\\<parallel> * C\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>basis.\n       cmod (crepresentation basis x a) * \\<parallel>f a\\<parallel>)\n    \\<le> (\\<Sum>a\\<in>basis.\n             \\<parallel>x\\<parallel> * C * \\<parallel>f a\\<parallel>)", "by (simp add: sum_mono mult_right_mono)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>basis. cmod (r a) * \\<parallel>f a\\<parallel>)\n  \\<le> (\\<Sum>a\\<in>basis.\n           \\<parallel>x\\<parallel> * C * \\<parallel>f a\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>basis. cmod (r a) * \\<parallel>f a\\<parallel>)\n  \\<le> (\\<Sum>a\\<in>basis.\n           \\<parallel>x\\<parallel> * C * \\<parallel>f a\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "have \"\\<dots> \\<le> \\<parallel>x\\<parallel> * C * (\\<Sum>a\\<in>basis. \\<parallel>f a\\<parallel>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>basis.\n       \\<parallel>x\\<parallel> * C * \\<parallel>f a\\<parallel>)\n    \\<le> \\<parallel>x\\<parallel> * C *\n          (\\<Sum>a\\<in>basis. \\<parallel>f a\\<parallel>)", "using sum_distrib_left"], ["proof (prove)\nusing this:\n  ?r * sum ?f ?A = (\\<Sum>n\\<in>?A. ?r * ?f n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>basis.\n       \\<parallel>x\\<parallel> * C * \\<parallel>f a\\<parallel>)\n    \\<le> \\<parallel>x\\<parallel> * C *\n          (\\<Sum>a\\<in>basis. \\<parallel>f a\\<parallel>)", "by (smt sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>basis.\n     \\<parallel>x\\<parallel> * C * \\<parallel>f a\\<parallel>)\n  \\<le> \\<parallel>x\\<parallel> * C *\n        (\\<Sum>a\\<in>basis. \\<parallel>f a\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "also"], ["proof (state)\nthis:\n  (\\<Sum>a\\<in>basis.\n     \\<parallel>x\\<parallel> * C * \\<parallel>f a\\<parallel>)\n  \\<le> \\<parallel>x\\<parallel> * C *\n        (\\<Sum>a\\<in>basis. \\<parallel>f a\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "have \"\\<dots> = \\<parallel>x\\<parallel> * M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>x\\<parallel> * C *\n    (\\<Sum>a\\<in>basis. \\<parallel>f a\\<parallel>) =\n    \\<parallel>x\\<parallel> * M", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>x\\<parallel> * C *\n    (\\<Sum>a\\<in>basis. \\<parallel>f a\\<parallel>) =\n    \\<parallel>x\\<parallel> *\n    (C * (\\<Sum>a\\<in>basis. \\<parallel>f a\\<parallel>))", "by linarith"], ["proof (state)\nthis:\n  \\<parallel>x\\<parallel> * C *\n  (\\<Sum>a\\<in>basis. \\<parallel>f a\\<parallel>) =\n  \\<parallel>x\\<parallel> * M\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M\n\ngoal (1 subgoal):\n 1. \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M", "."], ["proof (state)\nthis:\n  \\<parallel>f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<parallel>f ?x\\<parallel> \\<le> \\<parallel>?x\\<parallel> * M\n\ngoal (1 subgoal):\n 1. bounded_clinear f", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>f ?x\\<parallel> \\<le> \\<parallel>?x\\<parallel> * M\n\ngoal (1 subgoal):\n 1. bounded_clinear f", "using assms bounded_clinear_def bounded_clinear_axioms_def"], ["proof (prove)\nusing this:\n  \\<parallel>f ?x\\<parallel> \\<le> \\<parallel>?x\\<parallel> * M\n  clinear f\n  bounded_clinear ?f \\<equiv> clinear ?f \\<and> bounded_clinear_axioms ?f\n  bounded_clinear_axioms ?f \\<equiv>\n  \\<exists>K.\n     \\<forall>x.\n        \\<parallel>?f x\\<parallel> \\<le> \\<parallel>x\\<parallel> * K\n\ngoal (1 subgoal):\n 1. bounded_clinear f", "by blast"], ["proof (state)\nthis:\n  bounded_clinear f\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Closed subspaces\\<close>"], ["", "lemma csubspace_INF[simp]: \"(\\<And>x. x \\<in> A \\<Longrightarrow> csubspace x) \\<Longrightarrow> csubspace (\\<Inter>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> csubspace x) \\<Longrightarrow>\n    csubspace (\\<Inter> A)", "by (simp add: complex_vector.subspace_Inter)"], ["", "locale closed_csubspace =\n  fixes A::\"('a::{complex_vector,topological_space}) set\"\n  assumes subspace: \"csubspace A\"\n  assumes closed: \"closed A\""], ["", "declare closed_csubspace.subspace[simp]"], ["", "lemma closure_is_csubspace[simp]:\n  fixes A::\"('a::complex_normed_vector) set\"\n  assumes \\<open>csubspace A\\<close>\n  shows \\<open>csubspace (closure A)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace (closure A)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. csubspace (closure A)", "have \"x \\<in> closure A \\<Longrightarrow> y \\<in> closure A \\<Longrightarrow> x+y \\<in> closure A\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> closure A; y \\<in> closure A\\<rbrakk>\n    \\<Longrightarrow> x + y \\<in> closure A", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> closure A; y \\<in> closure A\\<rbrakk>\n    \\<Longrightarrow> x + y \\<in> closure A", "assume \\<open>x\\<in>(closure A)\\<close>"], ["proof (state)\nthis:\n  x \\<in> closure A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> closure A; y \\<in> closure A\\<rbrakk>\n    \\<Longrightarrow> x + y \\<in> closure A", "then"], ["proof (chain)\npicking this:\n  x \\<in> closure A", "obtain xx where \\<open>\\<forall> n::nat. xx n \\<in> A\\<close> and \\<open>xx \\<longlonglongrightarrow> x\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> closure A\n\ngoal (1 subgoal):\n 1. (\\<And>xx.\n        \\<lbrakk>\\<forall>n. xx n \\<in> A;\n         xx \\<longlonglongrightarrow> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using closure_sequential"], ["proof (prove)\nusing this:\n  x \\<in> closure A\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n\ngoal (1 subgoal):\n 1. (\\<And>xx.\n        \\<lbrakk>\\<forall>n. xx n \\<in> A;\n         xx \\<longlonglongrightarrow> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>n. xx n \\<in> A\n  xx \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> closure A; y \\<in> closure A\\<rbrakk>\n    \\<Longrightarrow> x + y \\<in> closure A", "assume \\<open>y\\<in>(closure A)\\<close>"], ["proof (state)\nthis:\n  y \\<in> closure A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> closure A; y \\<in> closure A\\<rbrakk>\n    \\<Longrightarrow> x + y \\<in> closure A", "then"], ["proof (chain)\npicking this:\n  y \\<in> closure A", "obtain yy where \\<open>\\<forall> n::nat. yy n \\<in> A\\<close> and \\<open>yy \\<longlonglongrightarrow> y\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> closure A\n\ngoal (1 subgoal):\n 1. (\\<And>yy.\n        \\<lbrakk>\\<forall>n. yy n \\<in> A;\n         yy \\<longlonglongrightarrow> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using closure_sequential"], ["proof (prove)\nusing this:\n  y \\<in> closure A\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n\ngoal (1 subgoal):\n 1. (\\<And>yy.\n        \\<lbrakk>\\<forall>n. yy n \\<in> A;\n         yy \\<longlonglongrightarrow> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>n. yy n \\<in> A\n  yy \\<longlonglongrightarrow> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> closure A; y \\<in> closure A\\<rbrakk>\n    \\<Longrightarrow> x + y \\<in> closure A", "have \\<open>\\<forall> n::nat. (xx n) + (yy n) \\<in> A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. xx n + yy n \\<in> A", "using \\<open>\\<forall>n. xx n \\<in> A\\<close> \\<open>\\<forall>n. yy n \\<in> A\\<close> assms complex_vector.subspace_def"], ["proof (prove)\nusing this:\n  \\<forall>n. xx n \\<in> A\n  \\<forall>n. yy n \\<in> A\n  csubspace A\n  csubspace ?S =\n  ((0::?'a) \\<in> ?S \\<and>\n   (\\<forall>x\\<in>?S. \\<forall>y\\<in>?S. x + y \\<in> ?S) \\<and>\n   (\\<forall>c. \\<forall>x\\<in>?S. c *\\<^sub>C x \\<in> ?S))\n\ngoal (1 subgoal):\n 1. \\<forall>n. xx n + yy n \\<in> A", "by (simp add: complex_vector.subspace_def)"], ["proof (state)\nthis:\n  \\<forall>n. xx n + yy n \\<in> A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> closure A; y \\<in> closure A\\<rbrakk>\n    \\<Longrightarrow> x + y \\<in> closure A", "hence  \\<open>(\\<lambda> n. (xx n) + (yy n)) \\<longlonglongrightarrow> x + y\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>n. xx n + yy n \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. xx n + yy n) \\<longlonglongrightarrow> x + y", "using  \\<open>xx \\<longlonglongrightarrow> x\\<close> \\<open>yy \\<longlonglongrightarrow> y\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>n. xx n + yy n \\<in> A\n  xx \\<longlonglongrightarrow> x\n  yy \\<longlonglongrightarrow> y\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. xx n + yy n) \\<longlonglongrightarrow> x + y", "by (simp add: tendsto_add)"], ["proof (state)\nthis:\n  (\\<lambda>n. xx n + yy n) \\<longlonglongrightarrow> x + y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> closure A; y \\<in> closure A\\<rbrakk>\n    \\<Longrightarrow> x + y \\<in> closure A", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. xx n + yy n) \\<longlonglongrightarrow> x + y\n\ngoal (1 subgoal):\n 1. x + y \\<in> closure A", "using  \\<open>\\<forall> n::nat. (xx n) + (yy n) \\<in> A\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. xx n + yy n) \\<longlonglongrightarrow> x + y\n  \\<forall>n. xx n + yy n \\<in> A\n\ngoal (1 subgoal):\n 1. x + y \\<in> closure A", "by (meson closure_sequential)"], ["proof (state)\nthis:\n  x + y \\<in> closure A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> closure A; ?y \\<in> closure A\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<in> closure A\n\ngoal (1 subgoal):\n 1. csubspace (closure A)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> closure A; ?y \\<in> closure A\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<in> closure A\n\ngoal (1 subgoal):\n 1. csubspace (closure A)", "have \"x\\<in>(closure A) \\<Longrightarrow> c *\\<^sub>C x \\<in> (closure A)\" for x c"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> closure A \\<Longrightarrow> c *\\<^sub>C x \\<in> closure A", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> closure A \\<Longrightarrow> c *\\<^sub>C x \\<in> closure A", "assume \\<open>x\\<in>(closure A)\\<close>"], ["proof (state)\nthis:\n  x \\<in> closure A\n\ngoal (1 subgoal):\n 1. x \\<in> closure A \\<Longrightarrow> c *\\<^sub>C x \\<in> closure A", "then"], ["proof (chain)\npicking this:\n  x \\<in> closure A", "obtain xx where \\<open>\\<forall> n::nat. xx n \\<in> A\\<close> and \\<open>xx \\<longlonglongrightarrow> x\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> closure A\n\ngoal (1 subgoal):\n 1. (\\<And>xx.\n        \\<lbrakk>\\<forall>n. xx n \\<in> A;\n         xx \\<longlonglongrightarrow> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using closure_sequential"], ["proof (prove)\nusing this:\n  x \\<in> closure A\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n\ngoal (1 subgoal):\n 1. (\\<And>xx.\n        \\<lbrakk>\\<forall>n. xx n \\<in> A;\n         xx \\<longlonglongrightarrow> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>n. xx n \\<in> A\n  xx \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. x \\<in> closure A \\<Longrightarrow> c *\\<^sub>C x \\<in> closure A", "have \\<open>\\<forall> n::nat. c *\\<^sub>C (xx n) \\<in> A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. c *\\<^sub>C xx n \\<in> A", "using \\<open>\\<forall>n. xx n \\<in> A\\<close> assms complex_vector.subspace_def"], ["proof (prove)\nusing this:\n  \\<forall>n. xx n \\<in> A\n  csubspace A\n  csubspace ?S =\n  ((0::?'a) \\<in> ?S \\<and>\n   (\\<forall>x\\<in>?S. \\<forall>y\\<in>?S. x + y \\<in> ?S) \\<and>\n   (\\<forall>c. \\<forall>x\\<in>?S. c *\\<^sub>C x \\<in> ?S))\n\ngoal (1 subgoal):\n 1. \\<forall>n. c *\\<^sub>C xx n \\<in> A", "by (simp add: complex_vector.subspace_def)"], ["proof (state)\nthis:\n  \\<forall>n. c *\\<^sub>C xx n \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<in> closure A \\<Longrightarrow> c *\\<^sub>C x \\<in> closure A", "have \\<open>isCont (\\<lambda> t. c *\\<^sub>C t) x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont ((*\\<^sub>C) c) x", "using bounded_clinear.bounded_linear bounded_clinear_scaleC_right linear_continuous_at"], ["proof (prove)\nusing this:\n  bounded_clinear ?f \\<Longrightarrow> bounded_linear ?f\n  bounded_clinear ((*\\<^sub>C) ?c)\n  bounded_linear ?f \\<Longrightarrow> isCont ?f ?a\n\ngoal (1 subgoal):\n 1. isCont ((*\\<^sub>C) c) x", "by auto"], ["proof (state)\nthis:\n  isCont ((*\\<^sub>C) c) x\n\ngoal (1 subgoal):\n 1. x \\<in> closure A \\<Longrightarrow> c *\\<^sub>C x \\<in> closure A", "hence  \\<open>(\\<lambda> n. c *\\<^sub>C (xx n)) \\<longlonglongrightarrow> c *\\<^sub>C x\\<close>"], ["proof (prove)\nusing this:\n  isCont ((*\\<^sub>C) c) x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. c *\\<^sub>C xx n) \\<longlonglongrightarrow> c *\\<^sub>C x", "using  \\<open>xx \\<longlonglongrightarrow> x\\<close>"], ["proof (prove)\nusing this:\n  isCont ((*\\<^sub>C) c) x\n  xx \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. c *\\<^sub>C xx n) \\<longlonglongrightarrow> c *\\<^sub>C x", "by (simp add: isCont_tendsto_compose)"], ["proof (state)\nthis:\n  (\\<lambda>n. c *\\<^sub>C xx n) \\<longlonglongrightarrow> c *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. x \\<in> closure A \\<Longrightarrow> c *\\<^sub>C x \\<in> closure A", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. c *\\<^sub>C xx n) \\<longlonglongrightarrow> c *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> closure A", "using  \\<open>\\<forall> n::nat. c *\\<^sub>C (xx n) \\<in> A\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. c *\\<^sub>C xx n) \\<longlonglongrightarrow> c *\\<^sub>C x\n  \\<forall>n. c *\\<^sub>C xx n \\<in> A\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> closure A", "by (meson closure_sequential)"], ["proof (state)\nthis:\n  c *\\<^sub>C x \\<in> closure A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> closure A \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> closure A\n\ngoal (1 subgoal):\n 1. csubspace (closure A)", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> closure A \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> closure A\n\ngoal (1 subgoal):\n 1. csubspace (closure A)", "have \"0 \\<in> (closure A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> closure A", "using assms closure_subset complex_vector.subspace_def"], ["proof (prove)\nusing this:\n  csubspace A\n  ?S \\<subseteq> closure ?S\n  csubspace ?S =\n  ((0::?'a) \\<in> ?S \\<and>\n   (\\<forall>x\\<in>?S. \\<forall>y\\<in>?S. x + y \\<in> ?S) \\<and>\n   (\\<forall>c. \\<forall>x\\<in>?S. c *\\<^sub>C x \\<in> ?S))\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> closure A", "by (metis in_mono)"], ["proof (state)\nthis:\n  (0::'a) \\<in> closure A\n\ngoal (1 subgoal):\n 1. csubspace (closure A)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> closure A; ?y \\<in> closure A\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<in> closure A\n  ?x \\<in> closure A \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> closure A\n  (0::'a) \\<in> closure A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> closure A; ?y \\<in> closure A\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<in> closure A\n  ?x \\<in> closure A \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> closure A\n  (0::'a) \\<in> closure A\n\ngoal (1 subgoal):\n 1. csubspace (closure A)", "by (simp add: complex_vector.subspaceI)"], ["proof (state)\nthis:\n  csubspace (closure A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma csubspace_set_plus:\n  assumes \\<open>csubspace A\\<close> and \\<open>csubspace B\\<close>\n  shows \\<open>csubspace (A + B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace (A + B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. csubspace (A + B)", "define C where \\<open>C = {\\<psi>+\\<phi>| \\<psi> \\<phi>. \\<psi>\\<in>A \\<and> \\<phi>\\<in>B}\\<close>"], ["proof (state)\nthis:\n  C = {\\<psi> + \\<phi> |\\<psi> \\<phi>. \\<psi> \\<in> A \\<and> \\<phi> \\<in> B}\n\ngoal (1 subgoal):\n 1. csubspace (A + B)", "have  \"x\\<in>C \\<Longrightarrow> y\\<in>C \\<Longrightarrow> x+y\\<in>C\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> C; y \\<in> C\\<rbrakk> \\<Longrightarrow> x + y \\<in> C", "using C_def assms(1) assms(2) complex_vector.subspace_add complex_vector.subspace_sums"], ["proof (prove)\nusing this:\n  C = {\\<psi> + \\<phi> |\\<psi> \\<phi>. \\<psi> \\<in> A \\<and> \\<phi> \\<in> B}\n  csubspace A\n  csubspace B\n  \\<lbrakk>csubspace ?S; ?x \\<in> ?S; ?y \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<in> ?S\n  \\<lbrakk>csubspace ?S; csubspace ?T\\<rbrakk>\n  \\<Longrightarrow> csubspace {x + y |x y. x \\<in> ?S \\<and> y \\<in> ?T}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> C; y \\<in> C\\<rbrakk> \\<Longrightarrow> x + y \\<in> C", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> C; ?y \\<in> C\\<rbrakk> \\<Longrightarrow> ?x + ?y \\<in> C\n\ngoal (1 subgoal):\n 1. csubspace (A + B)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> C; ?y \\<in> C\\<rbrakk> \\<Longrightarrow> ?x + ?y \\<in> C\n\ngoal (1 subgoal):\n 1. csubspace (A + B)", "have \"c *\\<^sub>C x \\<in> C\" if \\<open>x\\<in>C\\<close> for x c"], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> C", "have \"csubspace C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace C", "by (simp add: C_def assms(1) assms(2) complex_vector.subspace_sums)"], ["proof (state)\nthis:\n  csubspace C\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> C", "then"], ["proof (chain)\npicking this:\n  csubspace C", "show ?thesis"], ["proof (prove)\nusing this:\n  csubspace C\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> C", "using that"], ["proof (prove)\nusing this:\n  csubspace C\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> C", "by (simp add: complex_vector.subspace_def)"], ["proof (state)\nthis:\n  c *\\<^sub>C x \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> C \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> C\n\ngoal (1 subgoal):\n 1. csubspace (A + B)", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> C \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> C\n\ngoal (1 subgoal):\n 1. csubspace (A + B)", "have  \"0 \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> C", "using  \\<open>C = {\\<psi> + \\<phi> |\\<psi> \\<phi>. \\<psi> \\<in> A \\<and> \\<phi> \\<in> B}\\<close> add.inverse_neutral add_uminus_conv_diff assms(1) assms(2) diff_0  mem_Collect_eq\n      add.right_inverse"], ["proof (prove)\nusing this:\n  C = {\\<psi> + \\<phi> |\\<psi> \\<phi>. \\<psi> \\<in> A \\<and> \\<phi> \\<in> B}\n  - (0::?'a) = (0::?'a)\n  ?a + - ?b = ?a - ?b\n  csubspace A\n  csubspace B\n  (0::?'a) - ?a = - ?a\n  (?a \\<in> Collect ?P) = ?P ?a\n  ?a + - ?a = (0::?'a)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> C", "by (metis (mono_tags, lifting) complex_vector.subspace_0)"], ["proof (state)\nthis:\n  (0::'a) \\<in> C\n\ngoal (1 subgoal):\n 1. csubspace (A + B)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> C; ?y \\<in> C\\<rbrakk> \\<Longrightarrow> ?x + ?y \\<in> C\n  ?x \\<in> C \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> C\n  (0::'a) \\<in> C", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> C; ?y \\<in> C\\<rbrakk> \\<Longrightarrow> ?x + ?y \\<in> C\n  ?x \\<in> C \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> C\n  (0::'a) \\<in> C\n\ngoal (1 subgoal):\n 1. csubspace (A + B)", "unfolding C_def complex_vector.subspace_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n                     \\<psi> \\<in> A \\<and> \\<phi> \\<in> B};\n   ?y \\<in> {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n             \\<psi> \\<in> A \\<and> \\<phi> \\<in> B}\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y\n                    \\<in> {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n                           \\<psi> \\<in> A \\<and> \\<phi> \\<in> B}\n  ?x \\<in> {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n            \\<psi> \\<in> A \\<and> \\<phi> \\<in> B} \\<Longrightarrow>\n  ?c *\\<^sub>C ?x\n  \\<in> {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n         \\<psi> \\<in> A \\<and> \\<phi> \\<in> B}\n  (0::'a)\n  \\<in> {\\<psi> + \\<phi> |\\<psi> \\<phi>.\n         \\<psi> \\<in> A \\<and> \\<phi> \\<in> B}\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> A + B \\<and>\n    (\\<forall>x\\<in>A + B. \\<forall>y\\<in>A + B. x + y \\<in> A + B) \\<and>\n    (\\<forall>c. \\<forall>x\\<in>A + B. c *\\<^sub>C x \\<in> A + B)", "by (smt mem_Collect_eq set_plus_elim set_plus_intro)"], ["proof (state)\nthis:\n  csubspace (A + B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_csubspace_0[simp]:\n  \"closed_csubspace ({0} :: ('a::{complex_vector,t1_space}) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace {0::'a}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. closed_csubspace {0::'a}", "have \\<open>csubspace {0}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace {0::'b}", "using add.right_neutral complex_vector.subspace_def scaleC_right.zero"], ["proof (prove)\nusing this:\n  ?a + (0::?'a) = ?a\n  csubspace ?S =\n  ((0::?'a) \\<in> ?S \\<and>\n   (\\<forall>x\\<in>?S. \\<forall>y\\<in>?S. x + y \\<in> ?S) \\<and>\n   (\\<forall>c. \\<forall>x\\<in>?S. c *\\<^sub>C x \\<in> ?S))\n  ?a *\\<^sub>C (0::?'a) = (0::?'a)\n\ngoal (1 subgoal):\n 1. csubspace {0::'b}", "by blast"], ["proof (state)\nthis:\n  csubspace {0::?'b1}\n\ngoal (1 subgoal):\n 1. closed_csubspace {0::'a}", "moreover"], ["proof (state)\nthis:\n  csubspace {0::?'b1}\n\ngoal (1 subgoal):\n 1. closed_csubspace {0::'a}", "have \"closed ({0} :: 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {0::'a}", "by simp"], ["proof (state)\nthis:\n  closed {0::'a}\n\ngoal (1 subgoal):\n 1. closed_csubspace {0::'a}", "ultimately"], ["proof (chain)\npicking this:\n  csubspace {0::?'b1}\n  closed {0::'a}", "show ?thesis"], ["proof (prove)\nusing this:\n  csubspace {0::?'b1}\n  closed {0::'a}\n\ngoal (1 subgoal):\n 1. closed_csubspace {0::'a}", "by (simp add: closed_csubspace_def)"], ["proof (state)\nthis:\n  closed_csubspace {0::'a}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_csubspace_UNIV[simp]: \"closed_csubspace (UNIV::('a::{complex_vector,topological_space}) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace UNIV", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. closed_csubspace UNIV", "have \\<open>csubspace UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace UNIV", "by simp"], ["proof (state)\nthis:\n  csubspace UNIV\n\ngoal (1 subgoal):\n 1. closed_csubspace UNIV", "moreover"], ["proof (state)\nthis:\n  csubspace UNIV\n\ngoal (1 subgoal):\n 1. closed_csubspace UNIV", "have \\<open>closed UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed UNIV", "by simp"], ["proof (state)\nthis:\n  closed UNIV\n\ngoal (1 subgoal):\n 1. closed_csubspace UNIV", "ultimately"], ["proof (chain)\npicking this:\n  csubspace UNIV\n  closed UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  csubspace UNIV\n  closed UNIV\n\ngoal (1 subgoal):\n 1. closed_csubspace UNIV", "unfolding closed_csubspace_def"], ["proof (prove)\nusing this:\n  csubspace UNIV\n  closed UNIV\n\ngoal (1 subgoal):\n 1. csubspace UNIV \\<and> closed UNIV", "by auto"], ["proof (state)\nthis:\n  closed_csubspace UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_csubspace_inter[simp]:\n  assumes \"closed_csubspace A\" and \"closed_csubspace B\"\n  shows \"closed_csubspace (A\\<inter>B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (A \\<inter> B)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. closed_csubspace (A \\<inter> B)", "obtain C where \\<open>C = A \\<inter> B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C. C = A \\<inter> B \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  C = A \\<inter> B\n\ngoal (1 subgoal):\n 1. closed_csubspace (A \\<inter> B)", "have \\<open>csubspace C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace C", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. csubspace C", "have \"x\\<in>C \\<Longrightarrow> y\\<in>C \\<Longrightarrow> x+y\\<in>C\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> C; y \\<in> C\\<rbrakk> \\<Longrightarrow> x + y \\<in> C", "by (metis IntD1 IntD2 IntI \\<open>C = A \\<inter> B\\<close> assms(1) assms(2) complex_vector.subspace_def closed_csubspace_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> C; ?y \\<in> C\\<rbrakk> \\<Longrightarrow> ?x + ?y \\<in> C\n\ngoal (1 subgoal):\n 1. csubspace C", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> C; ?y \\<in> C\\<rbrakk> \\<Longrightarrow> ?x + ?y \\<in> C\n\ngoal (1 subgoal):\n 1. csubspace C", "have \"x\\<in>C \\<Longrightarrow> c *\\<^sub>C x \\<in> C\" for x c"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> C \\<Longrightarrow> c *\\<^sub>C x \\<in> C", "by (metis IntD1 IntD2 IntI \\<open>C = A \\<inter> B\\<close> assms(1) assms(2) complex_vector.subspace_def closed_csubspace_def)"], ["proof (state)\nthis:\n  ?x \\<in> C \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> C\n\ngoal (1 subgoal):\n 1. csubspace C", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> C \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> C\n\ngoal (1 subgoal):\n 1. csubspace C", "have \"0 \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> C", "using  \\<open>C = A \\<inter> B\\<close> assms(1) assms(2) complex_vector.subspace_def closed_csubspace_def"], ["proof (prove)\nusing this:\n  C = A \\<inter> B\n  closed_csubspace A\n  closed_csubspace B\n  csubspace ?S =\n  ((0::?'a) \\<in> ?S \\<and>\n   (\\<forall>x\\<in>?S. \\<forall>y\\<in>?S. x + y \\<in> ?S) \\<and>\n   (\\<forall>c. \\<forall>x\\<in>?S. c *\\<^sub>C x \\<in> ?S))\n  closed_csubspace ?A \\<equiv> csubspace ?A \\<and> closed ?A\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> C", "by fastforce"], ["proof (state)\nthis:\n  (0::'a) \\<in> C\n\ngoal (1 subgoal):\n 1. csubspace C", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> C; ?y \\<in> C\\<rbrakk> \\<Longrightarrow> ?x + ?y \\<in> C\n  ?x \\<in> C \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> C\n  (0::'a) \\<in> C", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> C; ?y \\<in> C\\<rbrakk> \\<Longrightarrow> ?x + ?y \\<in> C\n  ?x \\<in> C \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> C\n  (0::'a) \\<in> C\n\ngoal (1 subgoal):\n 1. csubspace C", "by (simp add: complex_vector.subspace_def)"], ["proof (state)\nthis:\n  csubspace C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  csubspace C\n\ngoal (1 subgoal):\n 1. closed_csubspace (A \\<inter> B)", "moreover"], ["proof (state)\nthis:\n  csubspace C\n\ngoal (1 subgoal):\n 1. closed_csubspace (A \\<inter> B)", "have \\<open>closed C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed C", "using  \\<open>C = A \\<inter> B\\<close>"], ["proof (prove)\nusing this:\n  C = A \\<inter> B\n\ngoal (1 subgoal):\n 1. closed C", "by (simp add: assms(1) assms(2) closed_Int closed_csubspace.closed)"], ["proof (state)\nthis:\n  closed C\n\ngoal (1 subgoal):\n 1. closed_csubspace (A \\<inter> B)", "ultimately"], ["proof (chain)\npicking this:\n  csubspace C\n  closed C", "show ?thesis"], ["proof (prove)\nusing this:\n  csubspace C\n  closed C\n\ngoal (1 subgoal):\n 1. closed_csubspace (A \\<inter> B)", "using  \\<open>C = A \\<inter> B\\<close>"], ["proof (prove)\nusing this:\n  csubspace C\n  closed C\n  C = A \\<inter> B\n\ngoal (1 subgoal):\n 1. closed_csubspace (A \\<inter> B)", "by (simp add: closed_csubspace_def)"], ["proof (state)\nthis:\n  closed_csubspace (A \\<inter> B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_csubspace_INF[simp]:\n  assumes a1: \"\\<forall>A\\<in>\\<A>. closed_csubspace A\"\n  shows \"closed_csubspace (\\<Inter>\\<A>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (\\<Inter> \\<A>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. closed_csubspace (\\<Inter> \\<A>)", "have \\<open>csubspace (\\<Inter>\\<A>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace (\\<Inter> \\<A>)", "by (simp add: assms closed_csubspace.subspace complex_vector.subspace_Inter)"], ["proof (state)\nthis:\n  csubspace (\\<Inter> \\<A>)\n\ngoal (1 subgoal):\n 1. closed_csubspace (\\<Inter> \\<A>)", "moreover"], ["proof (state)\nthis:\n  csubspace (\\<Inter> \\<A>)\n\ngoal (1 subgoal):\n 1. closed_csubspace (\\<Inter> \\<A>)", "have \\<open>closed (\\<Inter>\\<A>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (\\<Inter> \\<A>)", "by (simp add: assms closed_Inter closed_csubspace.closed)"], ["proof (state)\nthis:\n  closed (\\<Inter> \\<A>)\n\ngoal (1 subgoal):\n 1. closed_csubspace (\\<Inter> \\<A>)", "ultimately"], ["proof (chain)\npicking this:\n  csubspace (\\<Inter> \\<A>)\n  closed (\\<Inter> \\<A>)", "show ?thesis"], ["proof (prove)\nusing this:\n  csubspace (\\<Inter> \\<A>)\n  closed (\\<Inter> \\<A>)\n\ngoal (1 subgoal):\n 1. closed_csubspace (\\<Inter> \\<A>)", "by (simp add: closed_csubspace.intro)"], ["proof (state)\nthis:\n  closed_csubspace (\\<Inter> \\<A>)\n\ngoal:\nNo subgoals!", "qed"], ["", "typedef (overloaded) ('a::\"{complex_vector,topological_space}\") \n  ccsubspace = \\<open>{S::'a set. closed_csubspace S}\\<close>\n  morphisms space_as_set Abs_clinear_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {S. closed_csubspace S}", "using Complex_Vector_Spaces.closed_csubspace_UNIV"], ["proof (prove)\nusing this:\n  closed_csubspace UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {S. closed_csubspace S}", "by blast"], ["", "setup_lifting type_definition_ccsubspace"], ["", "lemma csubspace_space_as_set[simp]: \\<open>csubspace (space_as_set S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace (space_as_set S)", "by (metis closed_csubspace_def mem_Collect_eq space_as_set)"], ["", "instantiation ccsubspace :: (complex_normed_vector) scaleC begin"], ["", "lift_definition scaleC_ccsubspace :: \"complex \\<Rightarrow> 'a ccsubspace \\<Rightarrow> 'a ccsubspace\" is\n  \"\\<lambda>c S. (*\\<^sub>C) c ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>complex set.\n       closed_csubspace set \\<Longrightarrow>\n       closed_csubspace ((*\\<^sub>C) complex ` set)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>complex set.\n       closed_csubspace set \\<Longrightarrow>\n       csubspace ((*\\<^sub>C) complex ` set)\n 2. \\<And>complex set.\n       closed_csubspace set \\<Longrightarrow>\n       closed ((*\\<^sub>C) complex ` set)", "show \"csubspace ((*\\<^sub>C) c ` S)\"\n    if \"closed_csubspace S\"\n    for c :: complex\n      and S :: \"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace ((*\\<^sub>C) c ` S)", "using that"], ["proof (prove)\nusing this:\n  closed_csubspace S\n\ngoal (1 subgoal):\n 1. csubspace ((*\\<^sub>C) c ` S)", "by (simp add: closed_csubspace.subspace complex_vector.linear_subspace_image)"], ["proof (state)\nthis:\n  closed_csubspace ?S \\<Longrightarrow> csubspace ((*\\<^sub>C) ?c ` ?S)\n\ngoal (1 subgoal):\n 1. \\<And>complex set.\n       closed_csubspace set \\<Longrightarrow>\n       closed ((*\\<^sub>C) complex ` set)", "show \"closed ((*\\<^sub>C) c ` S)\"\n    if \"closed_csubspace S\"\n    for c :: complex\n      and S :: \"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed ((*\\<^sub>C) c ` S)", "using that"], ["proof (prove)\nusing this:\n  closed_csubspace S\n\ngoal (1 subgoal):\n 1. closed ((*\\<^sub>C) c ` S)", "by (simp add: closed_scaleC closed_csubspace.closed)"], ["proof (state)\nthis:\n  closed_csubspace ?S \\<Longrightarrow> closed ((*\\<^sub>C) ?c ` ?S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition scaleR_ccsubspace :: \"real \\<Rightarrow> 'a ccsubspace \\<Rightarrow> 'a ccsubspace\" is\n  \"\\<lambda>c S. (*\\<^sub>R) c ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real set.\n       closed_csubspace set \\<Longrightarrow>\n       closed_csubspace ((*\\<^sub>R) real ` set)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>real set.\n       closed_csubspace set \\<Longrightarrow>\n       csubspace ((*\\<^sub>R) real ` set)\n 2. \\<And>real set.\n       closed_csubspace set \\<Longrightarrow>\n       closed ((*\\<^sub>R) real ` set)", "show \"csubspace ((*\\<^sub>R) r ` S)\"\n    if \"closed_csubspace S\"\n    for r :: real\n      and S :: \"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace ((*\\<^sub>R) r ` S)", "using that"], ["proof (prove)\nusing this:\n  closed_csubspace S\n\ngoal (1 subgoal):\n 1. csubspace ((*\\<^sub>R) r ` S)", "using bounded_clinear_def bounded_clinear_scaleC_right scaleR_scaleC"], ["proof (prove)\nusing this:\n  closed_csubspace S\n  bounded_clinear ?f \\<equiv> clinear ?f \\<and> bounded_clinear_axioms ?f\n  bounded_clinear ((*\\<^sub>C) ?c)\n  (*\\<^sub>R) ?r = (*\\<^sub>C) (complex_of_real ?r)\n\ngoal (1 subgoal):\n 1. csubspace ((*\\<^sub>R) r ` S)", "by (simp add: scaleR_scaleC closed_csubspace.subspace complex_vector.linear_subspace_image)"], ["proof (state)\nthis:\n  closed_csubspace ?S \\<Longrightarrow> csubspace ((*\\<^sub>R) ?r ` ?S)\n\ngoal (1 subgoal):\n 1. \\<And>real set.\n       closed_csubspace set \\<Longrightarrow>\n       closed ((*\\<^sub>R) real ` set)", "show \"closed ((*\\<^sub>R) r ` S)\"\n    if \"closed_csubspace S\"\n    for r :: real\n      and S :: \"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed ((*\\<^sub>R) r ` S)", "using that"], ["proof (prove)\nusing this:\n  closed_csubspace S\n\ngoal (1 subgoal):\n 1. closed ((*\\<^sub>R) r ` S)", "by (simp add: closed_scaling closed_csubspace.closed)"], ["proof (state)\nthis:\n  closed_csubspace ?S \\<Longrightarrow> closed ((*\\<^sub>R) ?r ` ?S)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, scaleC_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)", "show \"((*\\<^sub>R) r::'a ccsubspace \\<Rightarrow> _) = (*\\<^sub>C) (complex_of_real r)\" for r :: real"], ["proof (prove)\ngoal (1 subgoal):\n 1. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)", "by (simp add: scaleR_scaleC scaleC_ccsubspace_def scaleR_ccsubspace_def)"], ["proof (state)\nthis:\n  (*\\<^sub>R) ?r = (*\\<^sub>C) (complex_of_real ?r)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation ccsubspace :: (\"{complex_vector,t1_space}\") bot begin"], ["", "lift_definition bot_ccsubspace :: \\<open>'a ccsubspace\\<close> is \\<open>{0}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace {0::'a}", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, bot_class)", ".."], ["", "end"], ["", "lemma zero_cblinfun_image[simp]: \"0 *\\<^sub>C S = bot\" for S :: \"_ ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 *\\<^sub>C S = \\<bottom>", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       closed_csubspace S \\<Longrightarrow> (*\\<^sub>C) 0 ` S = {0::'b}", "have \"(0::'b) \\<in> (\\<lambda>x. 0) ` S\"\n    if \"closed_csubspace S\"\n    for S::\"'b set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'b) \\<in> (\\<lambda>x. 0::'b) ` S", "using that"], ["proof (prove)\nusing this:\n  closed_csubspace S\n\ngoal (1 subgoal):\n 1. (0::'b) \\<in> (\\<lambda>x. 0::'b) ` S", "unfolding closed_csubspace_def"], ["proof (prove)\nusing this:\n  csubspace S \\<and> closed S\n\ngoal (1 subgoal):\n 1. (0::'b) \\<in> (\\<lambda>x. 0::'b) ` S", "by (simp add: complex_vector.linear_subspace_image complex_vector.module_hom_zero \n        complex_vector.subspace_0)"], ["proof (state)\nthis:\n  closed_csubspace ?S \\<Longrightarrow>\n  (0::'b) \\<in> (\\<lambda>x. 0::'b) ` ?S\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       closed_csubspace S \\<Longrightarrow> (*\\<^sub>C) 0 ` S = {0::'b}", "thus \"(*\\<^sub>C) 0 ` S = {0::'b}\"\n    if \"closed_csubspace (S::'b set)\"\n    for S :: \"'b set\""], ["proof (prove)\nusing this:\n  closed_csubspace ?S \\<Longrightarrow>\n  (0::'b) \\<in> (\\<lambda>x. 0::'b) ` ?S\n\ngoal (1 subgoal):\n 1. (*\\<^sub>C) 0 ` S = {0::'b}", "using that"], ["proof (prove)\nusing this:\n  closed_csubspace ?S \\<Longrightarrow>\n  (0::'b) \\<in> (\\<lambda>x. 0::'b) ` ?S\n  closed_csubspace S\n\ngoal (1 subgoal):\n 1. (*\\<^sub>C) 0 ` S = {0::'b}", "by (auto intro !: exI [of _ 0])"], ["proof (state)\nthis:\n  closed_csubspace ?S \\<Longrightarrow> (*\\<^sub>C) 0 ` ?S = {0::'b}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma csubspace_scaleC_invariant: \n  fixes a S\n  assumes \\<open>a \\<noteq> 0\\<close> and \\<open>csubspace S\\<close>\n  shows \\<open>(*\\<^sub>C) a ` S = S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (*\\<^sub>C) a ` S = S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (*\\<^sub>C) a ` S = S", "have  \\<open>x \\<in> (*\\<^sub>C) a ` S \\<Longrightarrow> x \\<in> S\\<close>\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (*\\<^sub>C) a ` S \\<Longrightarrow> x \\<in> S", "using assms(2) complex_vector.subspace_scale"], ["proof (prove)\nusing this:\n  csubspace S\n  \\<lbrakk>csubspace ?S; ?x \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> ?S\n\ngoal (1 subgoal):\n 1. x \\<in> (*\\<^sub>C) a ` S \\<Longrightarrow> x \\<in> S", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> (*\\<^sub>C) a ` S \\<Longrightarrow> ?x \\<in> S\n\ngoal (1 subgoal):\n 1. (*\\<^sub>C) a ` S = S", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> (*\\<^sub>C) a ` S \\<Longrightarrow> ?x \\<in> S\n\ngoal (1 subgoal):\n 1. (*\\<^sub>C) a ` S = S", "have  \\<open>x \\<in> S \\<Longrightarrow> x \\<in> (*\\<^sub>C) a ` S\\<close>\n    for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> x \\<in> (*\\<^sub>C) a ` S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> x \\<in> (*\\<^sub>C) a ` S", "assume \"x \\<in> S\""], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> x \\<in> (*\\<^sub>C) a ` S", "hence \"\\<exists>c aa. (c / a) *\\<^sub>C aa \\<in> S \\<and> c *\\<^sub>C aa = x\""], ["proof (prove)\nusing this:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>c aa. (c / a) *\\<^sub>C aa \\<in> S \\<and> c *\\<^sub>C aa = x", "using assms(2) complex_vector.subspace_def scaleC_one"], ["proof (prove)\nusing this:\n  x \\<in> S\n  csubspace S\n  csubspace ?S =\n  ((0::?'a) \\<in> ?S \\<and>\n   (\\<forall>x\\<in>?S. \\<forall>y\\<in>?S. x + y \\<in> ?S) \\<and>\n   (\\<forall>c. \\<forall>x\\<in>?S. c *\\<^sub>C x \\<in> ?S))\n  1 *\\<^sub>C ?x = ?x\n\ngoal (1 subgoal):\n 1. \\<exists>c aa. (c / a) *\\<^sub>C aa \\<in> S \\<and> c *\\<^sub>C aa = x", "by metis"], ["proof (state)\nthis:\n  \\<exists>c aa. (c / a) *\\<^sub>C aa \\<in> S \\<and> c *\\<^sub>C aa = x\n\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> x \\<in> (*\\<^sub>C) a ` S", "hence \"\\<exists>aa. aa \\<in> S \\<and> a *\\<^sub>C aa = x\""], ["proof (prove)\nusing this:\n  \\<exists>c aa. (c / a) *\\<^sub>C aa \\<in> S \\<and> c *\\<^sub>C aa = x\n\ngoal (1 subgoal):\n 1. \\<exists>aa. aa \\<in> S \\<and> a *\\<^sub>C aa = x", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<exists>c aa. (c / a) *\\<^sub>C aa \\<in> S \\<and> c *\\<^sub>C aa = x\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>aa. aa \\<in> S \\<and> a *\\<^sub>C aa = x", "by auto"], ["proof (state)\nthis:\n  \\<exists>aa. aa \\<in> S \\<and> a *\\<^sub>C aa = x\n\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> x \\<in> (*\\<^sub>C) a ` S", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>aa. aa \\<in> S \\<and> a *\\<^sub>C aa = x\n\ngoal (1 subgoal):\n 1. x \\<in> (*\\<^sub>C) a ` S", "by (meson image_iff)"], ["proof (state)\nthis:\n  x \\<in> (*\\<^sub>C) a ` S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> S \\<Longrightarrow> ?x \\<in> (*\\<^sub>C) a ` S\n\ngoal (1 subgoal):\n 1. (*\\<^sub>C) a ` S = S", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> (*\\<^sub>C) a ` S \\<Longrightarrow> ?x \\<in> S\n  ?x \\<in> S \\<Longrightarrow> ?x \\<in> (*\\<^sub>C) a ` S", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> (*\\<^sub>C) a ` S \\<Longrightarrow> ?x \\<in> S\n  ?x \\<in> S \\<Longrightarrow> ?x \\<in> (*\\<^sub>C) a ` S\n\ngoal (1 subgoal):\n 1. (*\\<^sub>C) a ` S = S", "by blast"], ["proof (state)\nthis:\n  (*\\<^sub>C) a ` S = S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccsubspace_scaleC_invariant[simp]: \"a \\<noteq> 0 \\<Longrightarrow> a *\\<^sub>C S = S\" for S :: \"_ ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow> a *\\<^sub>C S = S", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a S.\n       \\<lbrakk>a \\<noteq> 0; closed_csubspace S\\<rbrakk>\n       \\<Longrightarrow> (*\\<^sub>C) a ` S = S", "by (simp add: closed_csubspace.subspace csubspace_scaleC_invariant)"], ["", "instantiation ccsubspace :: (\"{complex_vector,topological_space}\") \"top\"\nbegin"], ["", "lift_definition top_ccsubspace :: \\<open>'a ccsubspace\\<close> is \\<open>UNIV\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace UNIV", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, top_class)", ".."], ["", "end"], ["", "lemma ccsubspace_top_not_bot[simp]: \n  \"(top::'a::{complex_vector,t1_space,not_singleton} ccsubspace) \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<noteq> \\<bottom>", "(* The type class t1_space is needed because the definition of bot in ccsubspace needs it *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<noteq> \\<bottom>", "by (metis UNIV_not_singleton bot_ccsubspace.rep_eq top_ccsubspace.rep_eq)"], ["", "lemma ccsubspace_bot_not_top[simp]:\n  \"(bot::'a::{complex_vector,t1_space,not_singleton} ccsubspace) \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<noteq> \\<top>", "using ccsubspace_top_not_bot"], ["proof (prove)\nusing this:\n  \\<top> \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<bottom> \\<noteq> \\<top>", "by metis"], ["", "instantiation ccsubspace :: (\"{complex_vector,topological_space}\") \"Inf\"\nbegin"], ["", "lift_definition Inf_ccsubspace::\\<open>'a ccsubspace set \\<Rightarrow> 'a ccsubspace\\<close>\n  is \\<open>\\<lambda> S. \\<Inter> S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           closed_csubspace x) \\<Longrightarrow>\n       closed_csubspace (\\<Inter> set)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           closed_csubspace x) \\<Longrightarrow>\n       csubspace (\\<Inter> set)\n 2. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           closed_csubspace x) \\<Longrightarrow>\n       closed (\\<Inter> set)", "fix S :: \"'a set set\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           closed_csubspace x) \\<Longrightarrow>\n       csubspace (\\<Inter> set)\n 2. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           closed_csubspace x) \\<Longrightarrow>\n       closed (\\<Inter> set)", "assume closed: \"closed_csubspace x\" if \\<open>x \\<in> S\\<close> for x"], ["proof (state)\nthis:\n  ?x \\<in> S \\<Longrightarrow> closed_csubspace ?x\n\ngoal (2 subgoals):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           closed_csubspace x) \\<Longrightarrow>\n       csubspace (\\<Inter> set)\n 2. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           closed_csubspace x) \\<Longrightarrow>\n       closed (\\<Inter> set)", "show \"csubspace (\\<Inter> S::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace (\\<Inter> S)", "by (simp add: closed closed_csubspace.subspace)"], ["proof (state)\nthis:\n  csubspace (\\<Inter> S)\n\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           closed_csubspace x) \\<Longrightarrow>\n       closed (\\<Inter> set)", "show \"closed (\\<Inter> S::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (\\<Inter> S)", "by (simp add: closed closed_csubspace.closed)"], ["proof (state)\nthis:\n  closed (\\<Inter> S)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, Inf_class)", ".."], ["", "end"], ["", "lift_definition ccspan :: \"'a::complex_normed_vector set \\<Rightarrow> 'a ccsubspace\"\n  is \"\\<lambda>G. closure (cspan G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set. closed_csubspace (closure (cspan set))", "proof (rule closed_csubspace.intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>set. csubspace (closure (cspan set))\n 2. \\<And>set. closed (closure (cspan set))", "fix S :: \"'a set\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>set. csubspace (closure (cspan set))\n 2. \\<And>set. closed (closure (cspan set))", "show \"csubspace (closure (cspan S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace (closure (cspan S))", "by (simp add: closure_is_csubspace)"], ["proof (state)\nthis:\n  csubspace (closure (cspan S))\n\ngoal (1 subgoal):\n 1. \\<And>set. closed (closure (cspan set))", "show \"closed (closure (cspan S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (closure (cspan S))", "by simp"], ["proof (state)\nthis:\n  closed (closure (cspan S))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccspan_canonical_basis[simp]: \"ccspan (set canonical_basis) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan (set canonical_basis) = \\<top>", "using ccspan.rep_eq space_as_set_inject top_ccsubspace.rep_eq\n    closure_UNIV is_generator_set"], ["proof (prove)\nusing this:\n  space_as_set (ccspan ?x) = closure (cspan ?x)\n  (space_as_set ?x = space_as_set ?y) = (?x = ?y)\n  space_as_set \\<top> = UNIV\n  closure UNIV = UNIV\n  cspan (set canonical_basis) = UNIV\n\ngoal (1 subgoal):\n 1. ccspan (set canonical_basis) = \\<top>", "by metis"], ["", "lemma ccspan_Inf_def: \\<open>ccspan A = Inf {S. A \\<subseteq> space_as_set S}\\<close>\n  for A::\\<open>('a::cbanach) set\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan A = \\<Sqinter> {S. A \\<subseteq> space_as_set S}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ccspan A = \\<Sqinter> {S. A \\<subseteq> space_as_set S}", "have \\<open>x \\<in> space_as_set (ccspan A) \n    \\<Longrightarrow> x \\<in> space_as_set (Inf {S. A \\<subseteq> space_as_set S})\\<close>\n    for x::'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "assume \\<open>x \\<in> space_as_set (ccspan A)\\<close>"], ["proof (state)\nthis:\n  x \\<in> space_as_set (ccspan A)\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "hence \"x \\<in> closure (cspan A)\""], ["proof (prove)\nusing this:\n  x \\<in> space_as_set (ccspan A)\n\ngoal (1 subgoal):\n 1. x \\<in> closure (cspan A)", "by (simp add: ccspan.rep_eq)"], ["proof (state)\nthis:\n  x \\<in> closure (cspan A)\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "hence \\<open>x \\<in> closure (complex_vector.span A)\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> closure (cspan A)\n\ngoal (1 subgoal):\n 1. x \\<in> closure (cspan A)", "unfolding ccspan_def"], ["proof (prove)\nusing this:\n  x \\<in> closure (cspan A)\n\ngoal (1 subgoal):\n 1. x \\<in> closure (cspan A)", "by simp"], ["proof (state)\nthis:\n  x \\<in> closure (cspan A)\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "hence \\<open>\\<exists> y::nat \\<Rightarrow> 'a. (\\<forall> n. y n \\<in> (complex_vector.span A)) \\<and> y \\<longlonglongrightarrow> x\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> closure (cspan A)\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       (\\<forall>n. y n \\<in> cspan A) \\<and> y \\<longlonglongrightarrow> x", "by (simp add: closure_sequential)"], ["proof (state)\nthis:\n  \\<exists>y.\n     (\\<forall>n. y n \\<in> cspan A) \\<and> y \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "then"], ["proof (chain)\npicking this:\n  \\<exists>y.\n     (\\<forall>n. y n \\<in> cspan A) \\<and> y \\<longlonglongrightarrow> x", "obtain y where \\<open>\\<forall> n. y n \\<in> (complex_vector.span A)\\<close> and \\<open>y \\<longlonglongrightarrow> x\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>y.\n     (\\<forall>n. y n \\<in> cspan A) \\<and> y \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>\\<forall>n. y n \\<in> cspan A;\n         y \\<longlonglongrightarrow> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>n. y n \\<in> cspan A\n  y \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "have \\<open>y n \\<in> \\<Inter> {S. (complex_vector.span A) \\<subseteq> S \\<and> closed_csubspace S}\\<close>\n      for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. y n \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}", "using  \\<open>\\<forall> n. y n \\<in> (complex_vector.span A)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>n. y n \\<in> cspan A\n\ngoal (1 subgoal):\n 1. y n \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}", "by auto"], ["proof (state)\nthis:\n  y ?n \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "have \\<open>closed_csubspace S \\<Longrightarrow> closed S\\<close>\n      for S::\\<open>'a set\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace S \\<Longrightarrow> closed S", "by (simp add: closed_csubspace.closed)"], ["proof (state)\nthis:\n  closed_csubspace ?S \\<Longrightarrow> closed ?S\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "hence \\<open>closed ( \\<Inter> {S. (complex_vector.span A) \\<subseteq> S \\<and> closed_csubspace S})\\<close>"], ["proof (prove)\nusing this:\n  closed_csubspace ?S \\<Longrightarrow> closed ?S\n\ngoal (1 subgoal):\n 1. closed (\\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S})", "by simp"], ["proof (state)\nthis:\n  closed (\\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S})\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "hence \\<open>x \\<in> \\<Inter> {S. (complex_vector.span A) \\<subseteq> S \\<and> closed_csubspace S}\\<close>"], ["proof (prove)\nusing this:\n  closed (\\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S})\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}", "using \\<open>y \\<longlonglongrightarrow> x\\<close>"], ["proof (prove)\nusing this:\n  closed (\\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S})\n  y \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}", "using \\<open>\\<And>n. y n \\<in> \\<Inter> {S. complex_vector.span A \\<subseteq> S \\<and> closed_csubspace S}\\<close> closed_sequentially"], ["proof (prove)\nusing this:\n  closed (\\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S})\n  y \\<longlonglongrightarrow> x\n  y ?n \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n  \\<lbrakk>closed ?s; \\<forall>n. ?f n \\<in> ?s;\n   ?f \\<longlonglongrightarrow> ?l\\<rbrakk>\n  \\<Longrightarrow> ?l \\<in> ?s\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}", "by blast"], ["proof (state)\nthis:\n  x \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "moreover"], ["proof (state)\nthis:\n  x \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "have \\<open>{S. A \\<subseteq> S \\<and> closed_csubspace S} \\<subseteq> {S. (complex_vector.span A) \\<subseteq> S \\<and> closed_csubspace S}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {S. A \\<subseteq> S \\<and> closed_csubspace S}\n    \\<subseteq> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}", "using Collect_mono_iff"], ["proof (prove)\nusing this:\n  (Collect ?P \\<subseteq> Collect ?Q) =\n  (\\<forall>x. ?P x \\<longrightarrow> ?Q x)\n\ngoal (1 subgoal):\n 1. {S. A \\<subseteq> S \\<and> closed_csubspace S}\n    \\<subseteq> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}", "by (simp add: Collect_mono_iff closed_csubspace.subspace complex_vector.span_minimal)"], ["proof (state)\nthis:\n  {S. A \\<subseteq> S \\<and> closed_csubspace S}\n  \\<subseteq> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n  {S. A \\<subseteq> S \\<and> closed_csubspace S}\n  \\<subseteq> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}", "have \\<open>x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n  {S. A \\<subseteq> S \\<and> closed_csubspace S}\n  \\<subseteq> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}", "by blast"], ["proof (state)\nthis:\n  x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "moreover"], ["proof (state)\nthis:\n  x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "have \"(x::'a) \\<in> \\<Inter> {x. A \\<subseteq> x \\<and> closed_csubspace x}\"\n      if \"(x::'a) \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}\"\n      for x :: 'a\n        and A :: \"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<Inter> {x. A \\<subseteq> x \\<and> closed_csubspace x}", "using that"], ["proof (prove)\nusing this:\n  x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Inter> {x. A \\<subseteq> x \\<and> closed_csubspace x}", "by simp"], ["proof (state)\nthis:\n  ?x \\<in> \\<Inter>\n            {S. ?A \\<subseteq> S \\<and>\n                closed_csubspace S} \\<Longrightarrow>\n  ?x \\<in> \\<Inter> {x. ?A \\<subseteq> x \\<and> closed_csubspace x}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n    x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}\n  ?x \\<in> \\<Inter>\n            {S. ?A \\<subseteq> S \\<and>\n                closed_csubspace S} \\<Longrightarrow>\n  ?x \\<in> \\<Inter> {x. ?A \\<subseteq> x \\<and> closed_csubspace x}", "show \\<open>x \\<in> space_as_set (Inf {S. A \\<subseteq> space_as_set S})\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}\n  ?x \\<in> \\<Inter>\n            {S. ?A \\<subseteq> S \\<and>\n                closed_csubspace S} \\<Longrightarrow>\n  ?x \\<in> \\<Inter> {x. ?A \\<subseteq> x \\<and> closed_csubspace x}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>x \\<in> \\<Inter>\n                         {S. A \\<subseteq> S \\<and> closed_csubspace S};\n        \\<And>x A.\n           x \\<in> \\<Inter>\n                    {S. A \\<subseteq> S \\<and>\n                        closed_csubspace S} \\<Longrightarrow>\n           x \\<in> \\<Inter>\n                    {x. A \\<subseteq> x \\<and> closed_csubspace x}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<Inter>\n                                  {x. A \\<subseteq> x \\<and>\nclosed_csubspace x}", "."], ["proof (state)\nthis:\n  x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n  ?x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})\n\ngoal (1 subgoal):\n 1. ccspan A = \\<Sqinter> {S. A \\<subseteq> space_as_set S}", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n  ?x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})\n\ngoal (1 subgoal):\n 1. ccspan A = \\<Sqinter> {S. A \\<subseteq> space_as_set S}", "have \\<open>x \\<in> space_as_set (Inf {S. A \\<subseteq> space_as_set S})\n             \\<Longrightarrow> x \\<in> space_as_set (ccspan A)\\<close>\n    for x::'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space_as_set\n             (\\<Sqinter>\n               {S. A \\<subseteq> space_as_set S}) \\<Longrightarrow>\n    x \\<in> space_as_set (ccspan A)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> space_as_set\n             (\\<Sqinter>\n               {S. A \\<subseteq> space_as_set S}) \\<Longrightarrow>\n    x \\<in> space_as_set (ccspan A)", "assume \\<open>x \\<in> space_as_set (Inf {S. A \\<subseteq> space_as_set S})\\<close>"], ["proof (state)\nthis:\n  x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set\n             (\\<Sqinter>\n               {S. A \\<subseteq> space_as_set S}) \\<Longrightarrow>\n    x \\<in> space_as_set (ccspan A)", "hence \\<open>x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A.\n       x \\<in> \\<Inter>\n                {x. A \\<subseteq> x \\<and>\n                    closed_csubspace x} \\<Longrightarrow>\n       x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}", "by blast"], ["proof (state)\nthis:\n  x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set\n             (\\<Sqinter>\n               {S. A \\<subseteq> space_as_set S}) \\<Longrightarrow>\n    x \\<in> space_as_set (ccspan A)", "moreover"], ["proof (state)\nthis:\n  x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set\n             (\\<Sqinter>\n               {S. A \\<subseteq> space_as_set S}) \\<Longrightarrow>\n    x \\<in> space_as_set (ccspan A)", "have \\<open>{S. (complex_vector.span A) \\<subseteq> S \\<and> closed_csubspace S} \\<subseteq> {S. A \\<subseteq> S \\<and> closed_csubspace S}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n    \\<subseteq> {S. A \\<subseteq> S \\<and> closed_csubspace S}", "using Collect_mono_iff complex_vector.span_superset"], ["proof (prove)\nusing this:\n  (Collect ?P \\<subseteq> Collect ?Q) =\n  (\\<forall>x. ?P x \\<longrightarrow> ?Q x)\n  ?S \\<subseteq> cspan ?S\n\ngoal (1 subgoal):\n 1. {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n    \\<subseteq> {S. A \\<subseteq> S \\<and> closed_csubspace S}", "by fastforce"], ["proof (state)\nthis:\n  {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n  \\<subseteq> {S. A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set\n             (\\<Sqinter>\n               {S. A \\<subseteq> space_as_set S}) \\<Longrightarrow>\n    x \\<in> space_as_set (ccspan A)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}\n  {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n  \\<subseteq> {S. A \\<subseteq> S \\<and> closed_csubspace S}", "have \\<open>x \\<in> \\<Inter> {S. (complex_vector.span A) \\<subseteq> S \\<and> closed_csubspace S}\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> \\<Inter> {S. A \\<subseteq> S \\<and> closed_csubspace S}\n  {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n  \\<subseteq> {S. A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}", "by blast"], ["proof (state)\nthis:\n  x \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set\n             (\\<Sqinter>\n               {S. A \\<subseteq> space_as_set S}) \\<Longrightarrow>\n    x \\<in> space_as_set (ccspan A)", "thus \\<open>x \\<in> space_as_set (ccspan A)\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> \\<Inter> {S. cspan A \\<subseteq> S \\<and> closed_csubspace S}\n\ngoal (1 subgoal):\n 1. x \\<in> space_as_set (ccspan A)", "by (metis (no_types, lifting) Inter_iff space_as_set closure_subset mem_Collect_eq ccspan.rep_eq)"], ["proof (state)\nthis:\n  x \\<in> space_as_set (ccspan A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> space_as_set\n            (\\<Sqinter> {S. A \\<subseteq> space_as_set S}) \\<Longrightarrow>\n  ?x \\<in> space_as_set (ccspan A)\n\ngoal (1 subgoal):\n 1. ccspan A = \\<Sqinter> {S. A \\<subseteq> space_as_set S}", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n  ?x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})\n  ?x \\<in> space_as_set\n            (\\<Sqinter> {S. A \\<subseteq> space_as_set S}) \\<Longrightarrow>\n  ?x \\<in> space_as_set (ccspan A)", "have \\<open>space_as_set (ccspan A) = space_as_set (Inf {S. A \\<subseteq> space_as_set S})\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> space_as_set (ccspan A) \\<Longrightarrow>\n  ?x \\<in> space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})\n  ?x \\<in> space_as_set\n            (\\<Sqinter> {S. A \\<subseteq> space_as_set S}) \\<Longrightarrow>\n  ?x \\<in> space_as_set (ccspan A)\n\ngoal (1 subgoal):\n 1. space_as_set (ccspan A) =\n    space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})", "by blast"], ["proof (state)\nthis:\n  space_as_set (ccspan A) =\n  space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})\n\ngoal (1 subgoal):\n 1. ccspan A = \\<Sqinter> {S. A \\<subseteq> space_as_set S}", "thus ?thesis"], ["proof (prove)\nusing this:\n  space_as_set (ccspan A) =\n  space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})\n\ngoal (1 subgoal):\n 1. ccspan A = \\<Sqinter> {S. A \\<subseteq> space_as_set S}", "using space_as_set_inject"], ["proof (prove)\nusing this:\n  space_as_set (ccspan A) =\n  space_as_set (\\<Sqinter> {S. A \\<subseteq> space_as_set S})\n  (space_as_set ?x = space_as_set ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. ccspan A = \\<Sqinter> {S. A \\<subseteq> space_as_set S}", "by auto"], ["proof (state)\nthis:\n  ccspan A = \\<Sqinter> {S. A \\<subseteq> space_as_set S}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cspan_singleton_scaleC[simp]: \"(a::complex)\\<noteq>0 \\<Longrightarrow> cspan { a *\\<^sub>C \\<psi> } = cspan {\\<psi>}\"\n  for \\<psi>::\"'a::complex_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    cspan {a *\\<^sub>C \\<psi>} = cspan {\\<psi>}", "by (smt complex_vector.dependent_single complex_vector.independent_insert \n      complex_vector.scale_eq_0_iff complex_vector.span_base complex_vector.span_redundant \n      complex_vector.span_scale doubleton_eq_iff insert_absorb insert_absorb2 insert_commute \n      singletonI)"], ["", "lemma closure_is_closed_csubspace[simp]:\n  fixes S::\\<open>'a::complex_normed_vector set\\<close>\n  assumes \\<open>csubspace S\\<close>\n  shows \\<open>closed_csubspace (closure S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (closure S)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. closed_csubspace (closure S)", "fix x y :: 'a and c :: complex"], ["proof (state)\ngoal (1 subgoal):\n 1. closed_csubspace (closure S)", "have \"x + y \\<in> closure S\"\n    if \"x \\<in> closure S\"\n      and \"y \\<in> closure S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<in> closure S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x + y \\<in> closure S", "have \\<open>\\<exists> r. (\\<forall> n::nat. r n \\<in> S) \\<and> r \\<longlonglongrightarrow> x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       (\\<forall>n. r n \\<in> S) \\<and> r \\<longlonglongrightarrow> x", "using closure_sequential that(1)"], ["proof (prove)\nusing this:\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n  x \\<in> closure S\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       (\\<forall>n. r n \\<in> S) \\<and> r \\<longlonglongrightarrow> x", "by auto"], ["proof (state)\nthis:\n  \\<exists>r. (\\<forall>n. r n \\<in> S) \\<and> r \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. x + y \\<in> closure S", "then"], ["proof (chain)\npicking this:\n  \\<exists>r. (\\<forall>n. r n \\<in> S) \\<and> r \\<longlonglongrightarrow> x", "obtain r where \\<open>\\<forall> n::nat. r n \\<in> S\\<close> and \\<open>r \\<longlonglongrightarrow> x\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>r. (\\<forall>n. r n \\<in> S) \\<and> r \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>\\<forall>n. r n \\<in> S;\n         r \\<longlonglongrightarrow> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>n. r n \\<in> S\n  r \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. x + y \\<in> closure S", "have \\<open>\\<exists> s. (\\<forall> n::nat. s n \\<in> S) \\<and> s \\<longlonglongrightarrow> y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s.\n       (\\<forall>n. s n \\<in> S) \\<and> s \\<longlonglongrightarrow> y", "using closure_sequential that(2)"], ["proof (prove)\nusing this:\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n  y \\<in> closure S\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       (\\<forall>n. s n \\<in> S) \\<and> s \\<longlonglongrightarrow> y", "by auto"], ["proof (state)\nthis:\n  \\<exists>s. (\\<forall>n. s n \\<in> S) \\<and> s \\<longlonglongrightarrow> y\n\ngoal (1 subgoal):\n 1. x + y \\<in> closure S", "then"], ["proof (chain)\npicking this:\n  \\<exists>s. (\\<forall>n. s n \\<in> S) \\<and> s \\<longlonglongrightarrow> y", "obtain s where \\<open>\\<forall> n::nat. s n \\<in> S\\<close> and \\<open>s \\<longlonglongrightarrow> y\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>s. (\\<forall>n. s n \\<in> S) \\<and> s \\<longlonglongrightarrow> y\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>\\<forall>n. s n \\<in> S;\n         s \\<longlonglongrightarrow> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>n. s n \\<in> S\n  s \\<longlonglongrightarrow> y\n\ngoal (1 subgoal):\n 1. x + y \\<in> closure S", "have \\<open>\\<forall> n::nat. r n + s n \\<in> S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. r n + s n \\<in> S", "using \\<open>\\<forall>n. r n \\<in> S\\<close> \\<open>\\<forall>n. s n \\<in> S\\<close> assms complex_vector.subspace_add"], ["proof (prove)\nusing this:\n  \\<forall>n. r n \\<in> S\n  \\<forall>n. s n \\<in> S\n  csubspace S\n  \\<lbrakk>csubspace ?S; ?x \\<in> ?S; ?y \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<in> ?S\n\ngoal (1 subgoal):\n 1. \\<forall>n. r n + s n \\<in> S", "by blast"], ["proof (state)\nthis:\n  \\<forall>n. r n + s n \\<in> S\n\ngoal (1 subgoal):\n 1. x + y \\<in> closure S", "moreover"], ["proof (state)\nthis:\n  \\<forall>n. r n + s n \\<in> S\n\ngoal (1 subgoal):\n 1. x + y \\<in> closure S", "have \\<open>(\\<lambda> n. r n + s n) \\<longlonglongrightarrow> x + y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. r n + s n) \\<longlonglongrightarrow> x + y", "by (simp add: \\<open>r \\<longlonglongrightarrow> x\\<close> \\<open>s \\<longlonglongrightarrow> y\\<close> tendsto_add)"], ["proof (state)\nthis:\n  (\\<lambda>n. r n + s n) \\<longlonglongrightarrow> x + y\n\ngoal (1 subgoal):\n 1. x + y \\<in> closure S", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>n. r n + s n \\<in> S\n  (\\<lambda>n. r n + s n) \\<longlonglongrightarrow> x + y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n. r n + s n \\<in> S\n  (\\<lambda>n. r n + s n) \\<longlonglongrightarrow> x + y\n\ngoal (1 subgoal):\n 1. x + y \\<in> closure S", "using assms that(1) that(2)"], ["proof (prove)\nusing this:\n  \\<forall>n. r n + s n \\<in> S\n  (\\<lambda>n. r n + s n) \\<longlonglongrightarrow> x + y\n  csubspace S\n  x \\<in> closure S\n  y \\<in> closure S\n\ngoal (1 subgoal):\n 1. x + y \\<in> closure S", "by (simp add: complex_vector.subspace_add)"], ["proof (state)\nthis:\n  x + y \\<in> closure S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> closure S; y \\<in> closure S\\<rbrakk>\n  \\<Longrightarrow> x + y \\<in> closure S\n\ngoal (1 subgoal):\n 1. closed_csubspace (closure S)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<in> closure S; y \\<in> closure S\\<rbrakk>\n  \\<Longrightarrow> x + y \\<in> closure S\n\ngoal (1 subgoal):\n 1. closed_csubspace (closure S)", "have \"c *\\<^sub>C x \\<in> closure S\"\n    if \"x \\<in> closure S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> closure S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> closure S", "have \\<open>\\<exists> y. (\\<forall> n::nat. y n \\<in> S) \\<and> y \\<longlonglongrightarrow> x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       (\\<forall>n. y n \\<in> S) \\<and> y \\<longlonglongrightarrow> x", "using Elementary_Topology.closure_sequential that"], ["proof (prove)\nusing this:\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n  x \\<in> closure S\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       (\\<forall>n. y n \\<in> S) \\<and> y \\<longlonglongrightarrow> x", "by auto"], ["proof (state)\nthis:\n  \\<exists>y. (\\<forall>n. y n \\<in> S) \\<and> y \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> closure S", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. (\\<forall>n. y n \\<in> S) \\<and> y \\<longlonglongrightarrow> x", "obtain y where \\<open>\\<forall> n::nat. y n \\<in> S\\<close> and \\<open>y \\<longlonglongrightarrow> x\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>y. (\\<forall>n. y n \\<in> S) \\<and> y \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>\\<forall>n. y n \\<in> S;\n         y \\<longlonglongrightarrow> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>n. y n \\<in> S\n  y \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> closure S", "have \\<open>isCont (scaleC c) x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont ((*\\<^sub>C) c) x", "by simp"], ["proof (state)\nthis:\n  isCont ((*\\<^sub>C) c) x\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> closure S", "hence \\<open>(\\<lambda> n. scaleC c (y n)) \\<longlonglongrightarrow> scaleC c x\\<close>"], ["proof (prove)\nusing this:\n  isCont ((*\\<^sub>C) c) x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. c *\\<^sub>C y n) \\<longlonglongrightarrow> c *\\<^sub>C x", "using  \\<open>y \\<longlonglongrightarrow> x\\<close>"], ["proof (prove)\nusing this:\n  isCont ((*\\<^sub>C) c) x\n  y \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. c *\\<^sub>C y n) \\<longlonglongrightarrow> c *\\<^sub>C x", "by (simp add: isCont_tendsto_compose)"], ["proof (state)\nthis:\n  (\\<lambda>n. c *\\<^sub>C y n) \\<longlonglongrightarrow> c *\\<^sub>C x\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> closure S", "from  \\<open>\\<forall> n::nat. y n \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n. y n \\<in> S", "have  \\<open>\\<forall> n::nat. scaleC c (y n) \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>n. y n \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>n. c *\\<^sub>C y n \\<in> S", "using assms complex_vector.subspace_scale"], ["proof (prove)\nusing this:\n  \\<forall>n. y n \\<in> S\n  csubspace S\n  \\<lbrakk>csubspace ?S; ?x \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> ?c *\\<^sub>C ?x \\<in> ?S\n\ngoal (1 subgoal):\n 1. \\<forall>n. c *\\<^sub>C y n \\<in> S", "by auto"], ["proof (state)\nthis:\n  \\<forall>n. c *\\<^sub>C y n \\<in> S\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> closure S", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n. c *\\<^sub>C y n \\<in> S\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> closure S", "using assms that"], ["proof (prove)\nusing this:\n  \\<forall>n. c *\\<^sub>C y n \\<in> S\n  csubspace S\n  x \\<in> closure S\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C x \\<in> closure S", "by (simp add: complex_vector.subspace_scale)"], ["proof (state)\nthis:\n  c *\\<^sub>C x \\<in> closure S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> closure S \\<Longrightarrow> c *\\<^sub>C x \\<in> closure S\n\ngoal (1 subgoal):\n 1. closed_csubspace (closure S)", "moreover"], ["proof (state)\nthis:\n  x \\<in> closure S \\<Longrightarrow> c *\\<^sub>C x \\<in> closure S\n\ngoal (1 subgoal):\n 1. closed_csubspace (closure S)", "have \"0 \\<in> closure S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<in> closure S", "by (simp add: assms complex_vector.subspace_0)"], ["proof (state)\nthis:\n  (0::'a) \\<in> closure S\n\ngoal (1 subgoal):\n 1. closed_csubspace (closure S)", "moreover"], ["proof (state)\nthis:\n  (0::'a) \\<in> closure S\n\ngoal (1 subgoal):\n 1. closed_csubspace (closure S)", "have \"closed (closure S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (closure S)", "by auto"], ["proof (state)\nthis:\n  closed (closure S)\n\ngoal (1 subgoal):\n 1. closed_csubspace (closure S)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> closure S; y \\<in> closure S\\<rbrakk>\n  \\<Longrightarrow> x + y \\<in> closure S\n  x \\<in> closure S \\<Longrightarrow> c *\\<^sub>C x \\<in> closure S\n  (0::'a) \\<in> closure S\n  closed (closure S)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> closure S; y \\<in> closure S\\<rbrakk>\n  \\<Longrightarrow> x + y \\<in> closure S\n  x \\<in> closure S \\<Longrightarrow> c *\\<^sub>C x \\<in> closure S\n  (0::'a) \\<in> closure S\n  closed (closure S)\n\ngoal (1 subgoal):\n 1. closed_csubspace (closure S)", "by (simp add: assms closed_csubspace_def)"], ["proof (state)\nthis:\n  closed_csubspace (closure S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccspan_singleton_scaleC[simp]: \"(a::complex)\\<noteq>0 \\<Longrightarrow> ccspan {a *\\<^sub>C \\<psi>} = ccspan {\\<psi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 \\<Longrightarrow>\n    ccspan {a *\\<^sub>C \\<psi>} = ccspan {\\<psi>}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a \\<psi>.\n       a \\<noteq> 0 \\<Longrightarrow>\n       closure (cspan {a *\\<^sub>C \\<psi>}) = closure (cspan {\\<psi>})", "by simp"], ["", "lemma clinear_continuous_at:\n  assumes \\<open>bounded_clinear f\\<close> \n  shows \\<open>isCont f x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont f x", "by (simp add: assms bounded_clinear.bounded_linear linear_continuous_at)"], ["", "lemma clinear_continuous_within:\n  assumes \\<open>bounded_clinear f\\<close> \n  shows \\<open>continuous (at x within s) f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at x within s) f", "by (simp add: assms bounded_clinear.bounded_linear linear_continuous_within)"], ["", "lemma antilinear_continuous_at:\n  assumes \\<open>bounded_antilinear f\\<close> \n  shows \\<open>isCont f x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. isCont f x", "by (simp add: assms bounded_antilinear.bounded_linear linear_continuous_at)"], ["", "lemma antilinear_continuous_within:\n  assumes \\<open>bounded_antilinear f\\<close> \n  shows \\<open>continuous (at x within s) f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at x within s) f", "by (simp add: assms bounded_antilinear.bounded_linear linear_continuous_within)"], ["", "lemma bounded_clinear_eq_on:\n  fixes A B :: \"'a::complex_normed_vector \\<Rightarrow> 'b::complex_normed_vector\"\n  assumes \\<open>bounded_clinear A\\<close> and \\<open>bounded_clinear B\\<close> and\n    eq: \\<open>\\<And>x. x \\<in> G \\<Longrightarrow> A x = B x\\<close> and t: \\<open>t \\<in> closure (cspan G)\\<close>\n  shows \\<open>A t = B t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A t = B t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A t = B t", "have eq': \\<open>A t = B t\\<close> if \\<open>t \\<in> cspan G\\<close> for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. A t = B t", "using _ _ that eq"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  t \\<in> cspan G\n  ?x \\<in> G \\<Longrightarrow> A ?x = B ?x\n\ngoal (1 subgoal):\n 1. A t = B t", "apply (rule complex_vector.linear_eq_on)"], ["proof (prove)\ngoal (3 subgoals):\n 1. clinear A\n 2. clinear B\n 3. \\<And>b. b \\<in> G \\<Longrightarrow> b \\<in> G", "by (auto simp: assms bounded_clinear.clinear)"], ["proof (state)\nthis:\n  ?t \\<in> cspan G \\<Longrightarrow> A ?t = B ?t\n\ngoal (1 subgoal):\n 1. A t = B t", "have \\<open>A t - B t = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A t - B t = (0::'b)", "using _ _ t"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  t \\<in> closure (cspan G)\n\ngoal (1 subgoal):\n 1. A t - B t = (0::'b)", "apply (rule continuous_constant_on_closure)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on (closure (cspan G)) (\\<lambda>a. A a - B a)\n 2. \\<And>x. x \\<in> cspan G \\<Longrightarrow> A x - B x = (0::'b)", "by (auto simp add: eq' assms(1) assms(2) clinear_continuous_at continuous_at_imp_continuous_on)"], ["proof (state)\nthis:\n  A t - B t = (0::'b)\n\ngoal (1 subgoal):\n 1. A t = B t", "then"], ["proof (chain)\npicking this:\n  A t - B t = (0::'b)", "show ?thesis"], ["proof (prove)\nusing this:\n  A t - B t = (0::'b)\n\ngoal (1 subgoal):\n 1. A t = B t", "by auto"], ["proof (state)\nthis:\n  A t = B t\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation ccsubspace :: (\"{complex_vector,topological_space}\") \"order\"\nbegin"], ["", "lift_definition less_eq_ccsubspace :: \\<open>'a ccsubspace \\<Rightarrow> 'a ccsubspace \\<Rightarrow> bool\\<close>\n  is  \\<open>(\\<subseteq>)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "declare less_eq_ccsubspace_def[code del]"], ["", "lift_definition less_ccsubspace :: \\<open>'a ccsubspace \\<Rightarrow> 'a ccsubspace \\<Rightarrow> bool\\<close>\n  is \\<open>(\\<subset>)\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "declare less_ccsubspace_def[code del]"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, order_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "fix x y z :: \"'a ccsubspace\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"(x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by (simp add: less_eq_ccsubspace.rep_eq less_le_not_le less_ccsubspace.rep_eq)"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "by (simp add: less_eq_ccsubspace.rep_eq)"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x \\<le> z\" if \"x \\<le> y\" and \"y \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> z", "using that less_eq_ccsubspace.rep_eq"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> z\n  (?x \\<le> ?xa) = (space_as_set ?x \\<subseteq> space_as_set ?xa)\n\ngoal (1 subgoal):\n 1. x \\<le> z", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x = y\" if \"x \\<le> y\" and \"y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using that"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. x = y", "by (simp add: space_as_set_inject less_eq_ccsubspace.rep_eq)"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma ccspan_leqI:\n  assumes \\<open>M \\<subseteq> space_as_set S\\<close>\n  shows \\<open>ccspan M \\<le> S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan M \\<le> S", "using assms"], ["proof (prove)\nusing this:\n  M \\<subseteq> space_as_set S\n\ngoal (1 subgoal):\n 1. ccspan M \\<le> S", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M S.\n       \\<lbrakk>closed_csubspace S; M \\<subseteq> S\\<rbrakk>\n       \\<Longrightarrow> closure (cspan M) \\<subseteq> S", "by (simp add: closed_csubspace.closed closure_minimal complex_vector.span_minimal)"], ["", "lemma ccspan_mono:\n  assumes \\<open>A \\<subseteq> B\\<close>\n  shows \\<open>ccspan A \\<le> ccspan B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan A \\<le> ccspan B", "apply (transfer fixing: A B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (cspan A) \\<subseteq> closure (cspan B)", "by (simp add: assms closure_mono complex_vector.span_mono)"], ["", "lemma bounded_sesquilinear_add:\n  \\<open>bounded_sesquilinear (\\<lambda> x y. A x y + B x y)\\<close> if \\<open>bounded_sesquilinear A\\<close> and \\<open>bounded_sesquilinear B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x y. A x y + B x y)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b.\n       A (a + a') b + B (a + a') b = A a b + B a b + (A a' b + B a' b)\n 2. \\<And>a b b'.\n       A a (b + b') + B a (b + b') = A a b + B a b + (A a b' + B a b')\n 3. \\<And>r a b.\n       A (r *\\<^sub>C a) b + B (r *\\<^sub>C a) b =\n       cnj r *\\<^sub>C (A a b + B a b)\n 4. \\<And>a r b.\n       A a (r *\\<^sub>C b) + B a (r *\\<^sub>C b) =\n       r *\\<^sub>C (A a b + B a b)\n 5. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "fix a a' :: 'a and b b' :: 'b and r :: complex"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b.\n       A (a + a') b + B (a + a') b = A a b + B a b + (A a' b + B a' b)\n 2. \\<And>a b b'.\n       A a (b + b') + B a (b + b') = A a b + B a b + (A a b' + B a b')\n 3. \\<And>r a b.\n       A (r *\\<^sub>C a) b + B (r *\\<^sub>C a) b =\n       cnj r *\\<^sub>C (A a b + B a b)\n 4. \\<And>a r b.\n       A a (r *\\<^sub>C b) + B a (r *\\<^sub>C b) =\n       r *\\<^sub>C (A a b + B a b)\n 5. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "show \"A (a + a') b + B (a + a') b = (A a b + B a b) + (A a' b + B a' b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A (a + a') b + B (a + a') b = A a b + B a b + (A a' b + B a' b)", "by (simp add: bounded_sesquilinear.add_left that(1) that(2))"], ["proof (state)\nthis:\n  A (a + a') b + B (a + a') b = A a b + B a b + (A a' b + B a' b)\n\ngoal (4 subgoals):\n 1. \\<And>a b b'.\n       A a (b + b') + B a (b + b') = A a b + B a b + (A a b' + B a b')\n 2. \\<And>r a b.\n       A (r *\\<^sub>C a) b + B (r *\\<^sub>C a) b =\n       cnj r *\\<^sub>C (A a b + B a b)\n 3. \\<And>a r b.\n       A a (r *\\<^sub>C b) + B a (r *\\<^sub>C b) =\n       r *\\<^sub>C (A a b + B a b)\n 4. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "show \\<open>A a (b + b') + B a (b + b') = (A a b + B a b) + (A a b' + B a b')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A a (b + b') + B a (b + b') = A a b + B a b + (A a b' + B a b')", "by (simp add: bounded_sesquilinear.add_right that(1) that(2))"], ["proof (state)\nthis:\n  A a (b + b') + B a (b + b') = A a b + B a b + (A a b' + B a b')\n\ngoal (3 subgoals):\n 1. \\<And>r a b.\n       A (r *\\<^sub>C a) b + B (r *\\<^sub>C a) b =\n       cnj r *\\<^sub>C (A a b + B a b)\n 2. \\<And>a r b.\n       A a (r *\\<^sub>C b) + B a (r *\\<^sub>C b) =\n       r *\\<^sub>C (A a b + B a b)\n 3. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "show \\<open>A (r *\\<^sub>C a) b + B (r *\\<^sub>C a) b = cnj r *\\<^sub>C (A a b + B a b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A (r *\\<^sub>C a) b + B (r *\\<^sub>C a) b =\n    cnj r *\\<^sub>C (A a b + B a b)", "by (simp add: bounded_sesquilinear.scaleC_left scaleC_add_right that(1) that(2))"], ["proof (state)\nthis:\n  A (r *\\<^sub>C a) b + B (r *\\<^sub>C a) b =\n  cnj r *\\<^sub>C (A a b + B a b)\n\ngoal (2 subgoals):\n 1. \\<And>a r b.\n       A a (r *\\<^sub>C b) + B a (r *\\<^sub>C b) =\n       r *\\<^sub>C (A a b + B a b)\n 2. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "show \\<open>A a (r *\\<^sub>C b) + B a (r *\\<^sub>C b) = r *\\<^sub>C (A a b + B a b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A a (r *\\<^sub>C b) + B a (r *\\<^sub>C b) = r *\\<^sub>C (A a b + B a b)", "by (simp add: bounded_sesquilinear.scaleC_right scaleC_add_right that(1) that(2))"], ["proof (state)\nthis:\n  A a (r *\\<^sub>C b) + B a (r *\\<^sub>C b) = r *\\<^sub>C (A a b + B a b)\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "show \\<open>\\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "have \\<open>\\<exists> KA. \\<forall> a b. norm (A a b) \\<le> norm a * norm b * KA\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>KA. \\<forall>a b. norm (A a b) \\<le> norm a * norm b * KA", "by (simp add: bounded_sesquilinear.bounded that(1))"], ["proof (state)\nthis:\n  \\<exists>KA. \\<forall>a b. norm (A a b) \\<le> norm a * norm b * KA\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "then"], ["proof (chain)\npicking this:\n  \\<exists>KA. \\<forall>a b. norm (A a b) \\<le> norm a * norm b * KA", "obtain KA where \\<open>\\<forall> a b. norm (A a b) \\<le> norm a * norm b * KA\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>KA. \\<forall>a b. norm (A a b) \\<le> norm a * norm b * KA\n\ngoal (1 subgoal):\n 1. (\\<And>KA.\n        \\<forall>a b.\n           norm (A a b) \\<le> norm a * norm b * KA \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>a b. norm (A a b) \\<le> norm a * norm b * KA\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "have \\<open>\\<exists> KB. \\<forall> a b. norm (B a b) \\<le> norm a * norm b * KB\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>KB. \\<forall>a b. norm (B a b) \\<le> norm a * norm b * KB", "by (simp add: bounded_sesquilinear.bounded that(2))"], ["proof (state)\nthis:\n  \\<exists>KB. \\<forall>a b. norm (B a b) \\<le> norm a * norm b * KB\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "then"], ["proof (chain)\npicking this:\n  \\<exists>KB. \\<forall>a b. norm (B a b) \\<le> norm a * norm b * KB", "obtain KB where \\<open>\\<forall> a b. norm (B a b) \\<le> norm a * norm b * KB\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>KB. \\<forall>a b. norm (B a b) \\<le> norm a * norm b * KB\n\ngoal (1 subgoal):\n 1. (\\<And>KB.\n        \\<forall>a b.\n           norm (B a b) \\<le> norm a * norm b * KB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>a b. norm (B a b) \\<le> norm a * norm b * KB\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "have \\<open>norm (A a b + B a b) \\<le> norm a * norm b * (KA + KB)\\<close>\n      for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A a b + B a b) \\<le> norm a * norm b * (KA + KB)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. norm (A a b + B a b) \\<le> norm a * norm b * (KA + KB)", "have \\<open>norm (A a b + B a b) \\<le> norm (A a b) +  norm (B a b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A a b + B a b) \\<le> norm (A a b) + norm (B a b)", "using norm_triangle_ineq"], ["proof (prove)\nusing this:\n  norm (?x + ?y) \\<le> norm ?x + norm ?y\n\ngoal (1 subgoal):\n 1. norm (A a b + B a b) \\<le> norm (A a b) + norm (B a b)", "by blast"], ["proof (state)\nthis:\n  norm (A a b + B a b) \\<le> norm (A a b) + norm (B a b)\n\ngoal (1 subgoal):\n 1. norm (A a b + B a b) \\<le> norm a * norm b * (KA + KB)", "also"], ["proof (state)\nthis:\n  norm (A a b + B a b) \\<le> norm (A a b) + norm (B a b)\n\ngoal (1 subgoal):\n 1. norm (A a b + B a b) \\<le> norm a * norm b * (KA + KB)", "have \\<open>\\<dots> \\<le> norm a * norm b * KA + norm a * norm b * KB\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (A a b) + norm (B a b)\n    \\<le> norm a * norm b * KA + norm a * norm b * KB", "using  \\<open>\\<forall> a b. norm (A a b) \\<le> norm a * norm b * KA\\<close>\n          \\<open>\\<forall> a b. norm (B a b) \\<le> norm a * norm b * KB\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>a b. norm (A a b) \\<le> norm a * norm b * KA\n  \\<forall>a b. norm (B a b) \\<le> norm a * norm b * KB\n\ngoal (1 subgoal):\n 1. norm (A a b) + norm (B a b)\n    \\<le> norm a * norm b * KA + norm a * norm b * KB", "using add_mono"], ["proof (prove)\nusing this:\n  \\<forall>a b. norm (A a b) \\<le> norm a * norm b * KA\n  \\<forall>a b. norm (B a b) \\<le> norm a * norm b * KB\n  \\<lbrakk>?a \\<le> ?b; ?c \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a + ?c \\<le> ?b + ?d\n\ngoal (1 subgoal):\n 1. norm (A a b) + norm (B a b)\n    \\<le> norm a * norm b * KA + norm a * norm b * KB", "by blast"], ["proof (state)\nthis:\n  norm (A a b) + norm (B a b)\n  \\<le> norm a * norm b * KA + norm a * norm b * KB\n\ngoal (1 subgoal):\n 1. norm (A a b + B a b) \\<le> norm a * norm b * (KA + KB)", "also"], ["proof (state)\nthis:\n  norm (A a b) + norm (B a b)\n  \\<le> norm a * norm b * KA + norm a * norm b * KB\n\ngoal (1 subgoal):\n 1. norm (A a b + B a b) \\<le> norm a * norm b * (KA + KB)", "have \\<open>\\<dots>=  norm a * norm b * (KA + KB)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm a * norm b * KA + norm a * norm b * KB =\n    norm a * norm b * (KA + KB)", "by (simp add: mult.commute ring_class.ring_distribs(2))"], ["proof (state)\nthis:\n  norm a * norm b * KA + norm a * norm b * KB = norm a * norm b * (KA + KB)\n\ngoal (1 subgoal):\n 1. norm (A a b + B a b) \\<le> norm a * norm b * (KA + KB)", "finally"], ["proof (chain)\npicking this:\n  norm (A a b + B a b) \\<le> norm a * norm b * (KA + KB)", "show ?thesis"], ["proof (prove)\nusing this:\n  norm (A a b + B a b) \\<le> norm a * norm b * (KA + KB)\n\ngoal (1 subgoal):\n 1. norm (A a b + B a b) \\<le> norm a * norm b * (KA + KB)", "by blast"], ["proof (state)\nthis:\n  norm (A a b + B a b) \\<le> norm a * norm b * (KA + KB)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (A ?a ?b + B ?a ?b) \\<le> norm ?a * norm ?b * (KA + KB)\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "thus ?thesis"], ["proof (prove)\nusing this:\n  norm (A ?a ?b + B ?a ?b) \\<le> norm ?a * norm ?b * (KA + KB)\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K", "by blast"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>a b. norm (A a b + B a b) \\<le> norm a * norm b * K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_sesquilinear_uminus:\n  \\<open>bounded_sesquilinear (\\<lambda> x y. - A x y)\\<close> if \\<open>bounded_sesquilinear A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x y. - A x y)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. - A (a + a') b = - A a b + - A a' b\n 2. \\<And>a b b'. - A a (b + b') = - A a b + - A a b'\n 3. \\<And>r a b. - A (r *\\<^sub>C a) b = cnj r *\\<^sub>C - A a b\n 4. \\<And>a r b. - A a (r *\\<^sub>C b) = r *\\<^sub>C - A a b\n 5. \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K", "fix a a' :: 'a and b b' :: 'b and r :: complex"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a a' b. - A (a + a') b = - A a b + - A a' b\n 2. \\<And>a b b'. - A a (b + b') = - A a b + - A a b'\n 3. \\<And>r a b. - A (r *\\<^sub>C a) b = cnj r *\\<^sub>C - A a b\n 4. \\<And>a r b. - A a (r *\\<^sub>C b) = r *\\<^sub>C - A a b\n 5. \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K", "show \"- A (a + a') b = (- A a b) + (- A a' b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - A (a + a') b = - A a b + - A a' b", "by (simp add: bounded_sesquilinear.add_left that)"], ["proof (state)\nthis:\n  - A (a + a') b = - A a b + - A a' b\n\ngoal (4 subgoals):\n 1. \\<And>a b b'. - A a (b + b') = - A a b + - A a b'\n 2. \\<And>r a b. - A (r *\\<^sub>C a) b = cnj r *\\<^sub>C - A a b\n 3. \\<And>a r b. - A a (r *\\<^sub>C b) = r *\\<^sub>C - A a b\n 4. \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K", "show \\<open>- A a (b + b') = (- A a b) + (- A a b')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. - A a (b + b') = - A a b + - A a b'", "by (simp add: bounded_sesquilinear.add_right that)"], ["proof (state)\nthis:\n  - A a (b + b') = - A a b + - A a b'\n\ngoal (3 subgoals):\n 1. \\<And>r a b. - A (r *\\<^sub>C a) b = cnj r *\\<^sub>C - A a b\n 2. \\<And>a r b. - A a (r *\\<^sub>C b) = r *\\<^sub>C - A a b\n 3. \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K", "show \\<open>- A (r *\\<^sub>C a) b = cnj r *\\<^sub>C (- A a b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. - A (r *\\<^sub>C a) b = cnj r *\\<^sub>C - A a b", "by (simp add: bounded_sesquilinear.scaleC_left that)"], ["proof (state)\nthis:\n  - A (r *\\<^sub>C a) b = cnj r *\\<^sub>C - A a b\n\ngoal (2 subgoals):\n 1. \\<And>a r b. - A a (r *\\<^sub>C b) = r *\\<^sub>C - A a b\n 2. \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K", "show \\<open>- A a (r *\\<^sub>C b) = r *\\<^sub>C (- A a b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. - A a (r *\\<^sub>C b) = r *\\<^sub>C - A a b", "by (simp add: bounded_sesquilinear.scaleC_right that)"], ["proof (state)\nthis:\n  - A a (r *\\<^sub>C b) = r *\\<^sub>C - A a b\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K", "show \\<open>\\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K", "have \\<open>\\<exists> KA. \\<forall> a b. norm (A a b) \\<le> norm a * norm b * KA\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>KA. \\<forall>a b. norm (A a b) \\<le> norm a * norm b * KA", "by (simp add: bounded_sesquilinear.bounded that(1))"], ["proof (state)\nthis:\n  \\<exists>KA. \\<forall>a b. norm (A a b) \\<le> norm a * norm b * KA\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K", "then"], ["proof (chain)\npicking this:\n  \\<exists>KA. \\<forall>a b. norm (A a b) \\<le> norm a * norm b * KA", "obtain KA where \\<open>\\<forall> a b. norm (A a b) \\<le> norm a * norm b * KA\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>KA. \\<forall>a b. norm (A a b) \\<le> norm a * norm b * KA\n\ngoal (1 subgoal):\n 1. (\\<And>KA.\n        \\<forall>a b.\n           norm (A a b) \\<le> norm a * norm b * KA \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>a b. norm (A a b) \\<le> norm a * norm b * KA\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K", "have \\<open>norm (- A a b) \\<le> norm a * norm b * KA\\<close>\n      for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (- A a b) \\<le> norm a * norm b * KA", "by (simp add: \\<open>\\<forall>a b. norm (A a b) \\<le> norm a * norm b * KA\\<close>)"], ["proof (state)\nthis:\n  norm (- A ?a ?b) \\<le> norm ?a * norm ?b * KA\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K", "thus ?thesis"], ["proof (prove)\nusing this:\n  norm (- A ?a ?b) \\<le> norm ?a * norm ?b * KA\n\ngoal (1 subgoal):\n 1. \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K", "by blast"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>K. \\<forall>a b. norm (- A a b) \\<le> norm a * norm b * K\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_sesquilinear_diff:\n  \\<open>bounded_sesquilinear (\\<lambda> x y. A x y - B x y)\\<close> if \\<open>bounded_sesquilinear A\\<close> and \\<open>bounded_sesquilinear B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x y. A x y - B x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x y. A x y - B x y)", "have \\<open>bounded_sesquilinear (\\<lambda> x y. - B x y)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x y. - B x y)", "using that(2)"], ["proof (prove)\nusing this:\n  bounded_sesquilinear B\n\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x y. - B x y)", "by (rule bounded_sesquilinear_uminus)"], ["proof (state)\nthis:\n  bounded_sesquilinear (\\<lambda>x y. - B x y)\n\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x y. A x y - B x y)", "then"], ["proof (chain)\npicking this:\n  bounded_sesquilinear (\\<lambda>x y. - B x y)", "have \\<open>bounded_sesquilinear (\\<lambda> x y. A x y + (- B x y))\\<close>"], ["proof (prove)\nusing this:\n  bounded_sesquilinear (\\<lambda>x y. - B x y)\n\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x y. A x y + - B x y)", "using that(1)"], ["proof (prove)\nusing this:\n  bounded_sesquilinear (\\<lambda>x y. - B x y)\n  bounded_sesquilinear A\n\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x y. A x y + - B x y)", "by (rule bounded_sesquilinear_add[rotated])"], ["proof (state)\nthis:\n  bounded_sesquilinear (\\<lambda>x y. A x y + - B x y)\n\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x y. A x y - B x y)", "then"], ["proof (chain)\npicking this:\n  bounded_sesquilinear (\\<lambda>x y. A x y + - B x y)", "show ?thesis"], ["proof (prove)\nusing this:\n  bounded_sesquilinear (\\<lambda>x y. A x y + - B x y)\n\ngoal (1 subgoal):\n 1. bounded_sesquilinear (\\<lambda>x y. A x y - B x y)", "by auto"], ["proof (state)\nthis:\n  bounded_sesquilinear (\\<lambda>x y. A x y - B x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccsubspace_leI:\n  assumes t1: \"space_as_set A \\<subseteq> space_as_set B\"\n  shows \"A \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<le> B", "using t1"], ["proof (prove)\nusing this:\n  space_as_set A \\<subseteq> space_as_set B\n\ngoal (1 subgoal):\n 1. A \\<le> B", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       \\<lbrakk>closed_csubspace A; closed_csubspace B;\n        A \\<subseteq> B\\<rbrakk>\n       \\<Longrightarrow> A \\<subseteq> B", "by -"], ["", "lemma ccspan_of_empty[simp]: \"ccspan {} = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan {} = \\<bottom>", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. closure (cspan {}) = {0::'a}", "show \"closure (cspan {}) = {0::'a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (cspan {}) = {0::'a}", "by simp"], ["proof (state)\nthis:\n  closure (cspan {}) = {0::'a}\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation ccsubspace :: (\"{complex_vector,topological_space}\") inf begin"], ["", "lift_definition inf_ccsubspace :: \"'a ccsubspace \\<Rightarrow> 'a ccsubspace \\<Rightarrow> 'a ccsubspace\" \n  is \"(\\<inter>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       \\<lbrakk>closed_csubspace set1; closed_csubspace set2\\<rbrakk>\n       \\<Longrightarrow> closed_csubspace (set1 \\<inter> set2)", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, inf_class)", ".."], ["", "end"], ["", "lemma space_as_set_inf[simp]: \"space_as_set (A \\<sqinter> B) = space_as_set A \\<inter> space_as_set B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space_as_set (A \\<sqinter> B) = space_as_set A \\<inter> space_as_set B", "by (rule inf_ccsubspace.rep_eq)"], ["", "instantiation ccsubspace :: (\"{complex_vector,topological_space}\") order_top begin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, order_top_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<le> \\<top>", "show \"a \\<le> \\<top>\"\n    for a :: \"'a ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> \\<top>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. closed_csubspace a \\<Longrightarrow> a \\<subseteq> UNIV", "by simp"], ["proof (state)\nthis:\n  ?a \\<le> \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation ccsubspace :: (\"{complex_vector,t1_space}\") order_bot begin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, order_bot_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. \\<bottom> \\<le> a", "show \"(\\<bottom>::'a ccsubspace) \\<le> a\"\n    for a :: \"'a ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<le> a", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. closed_csubspace x \\<Longrightarrow> {0::'a} \\<subseteq> x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. closed_csubspace x \\<Longrightarrow> (0::'a) \\<in> x", "using closed_csubspace.subspace complex_vector.subspace_0"], ["proof (prove)\nusing this:\n  closed_csubspace ?A \\<Longrightarrow> csubspace ?A\n  csubspace ?S \\<Longrightarrow> (0::?'a) \\<in> ?S\n\ngoal (1 subgoal):\n 1. \\<And>x. closed_csubspace x \\<Longrightarrow> (0::'a) \\<in> x", "by blast"], ["proof (state)\nthis:\n  \\<bottom> \\<le> ?a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation ccsubspace :: (\"{complex_vector,topological_space}\") semilattice_inf begin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, semilattice_inf_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z", "fix x y z :: \\<open>'a ccsubspace\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z", "show \"x \\<sqinter> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>closed_csubspace x; closed_csubspace y\\<rbrakk>\n       \\<Longrightarrow> x \\<inter> y \\<subseteq> x", "by simp"], ["proof (state)\nthis:\n  x \\<sqinter> y \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> y\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z", "show \"x \\<sqinter> y \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>closed_csubspace x; closed_csubspace y\\<rbrakk>\n       \\<Longrightarrow> x \\<inter> y \\<subseteq> y", "by simp"], ["proof (state)\nthis:\n  x \\<sqinter> y \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z", "show \"x \\<le> y \\<sqinter> z\" if \"x \\<le> y\" and \"x \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<sqinter> z", "using that"], ["proof (prove)\nusing this:\n  x \\<le> y\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<sqinter> z", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>closed_csubspace x; closed_csubspace y; x \\<subseteq> y;\n        closed_csubspace z; x \\<subseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<subseteq> y \\<inter> z", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n  \\<Longrightarrow> x \\<le> y \\<sqinter> z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation ccsubspace :: (\"{complex_vector,t1_space}\") zero begin"], ["", "definition zero_ccsubspace :: \"'a ccsubspace\" where [simp]: \"zero_ccsubspace = bot\""], ["", "lemma zero_ccsubspace_transfer[transfer_rule]: \\<open>pcr_ccsubspace (=) {0} 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pcr_ccsubspace (=) {0::'a} 0", "unfolding zero_ccsubspace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pcr_ccsubspace (=) {0::'a} \\<bottom>", "by transfer_prover"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, zero_class)", ".."], ["", "end"], ["", "subsection \\<open>Closed sums\\<close>"], ["", "definition closed_sum:: \\<open>'a::{semigroup_add,topological_space} set \\<Rightarrow> 'a set \\<Rightarrow> 'a set\\<close> where\n  \\<open>closed_sum A B = closure (A + B)\\<close>"], ["", "notation closed_sum (infixl \"+\\<^sub>M\" 65)"], ["", "lemma closed_sum_comm: \\<open>A +\\<^sub>M B = B +\\<^sub>M A\\<close> for A B :: \"_::ab_semigroup_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A +\\<^sub>M B = B +\\<^sub>M A", "by (simp add: add.commute closed_sum_def)"], ["", "lemma closed_sum_left_subset: \\<open>0 \\<in> B \\<Longrightarrow> A \\<subseteq> A +\\<^sub>M B\\<close> for A B :: \"_::monoid_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'c) \\<in> B \\<Longrightarrow> A \\<subseteq> A +\\<^sub>M B", "by (metis add.right_neutral closed_sum_def closure_subset in_mono set_plus_intro subsetI)"], ["", "lemma closed_sum_right_subset: \\<open>0 \\<in> A \\<Longrightarrow> B \\<subseteq> A +\\<^sub>M B\\<close> for A B :: \"_::monoid_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'c) \\<in> A \\<Longrightarrow> B \\<subseteq> A +\\<^sub>M B", "by (metis add.left_neutral closed_sum_def closure_subset set_plus_intro subset_iff)"], ["", "lemma finite_cspan_closed_csubspace:\n  assumes \"finite (S::'a::complex_normed_vector set)\"\n  shows \"closed_csubspace (cspan S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (cspan S)", "by (simp add: assms closed_csubspace.intro)"], ["", "lemma closed_sum_is_sup:\n  fixes A B C:: \\<open>('a::{complex_vector,topological_space}) set\\<close>\n  assumes \\<open>closed_csubspace C\\<close>\n  assumes \\<open>A \\<subseteq> C\\<close> and \\<open>B \\<subseteq> C\\<close>\n  shows \\<open>(A +\\<^sub>M B) \\<subseteq> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A +\\<^sub>M B \\<subseteq> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A +\\<^sub>M B \\<subseteq> C", "have \\<open>A + B \\<subseteq> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A + B \\<subseteq> C", "using assms"], ["proof (prove)\nusing this:\n  closed_csubspace C\n  A \\<subseteq> C\n  B \\<subseteq> C\n\ngoal (1 subgoal):\n 1. A + B \\<subseteq> C", "unfolding set_plus_def"], ["proof (prove)\nusing this:\n  closed_csubspace C\n  A \\<subseteq> C\n  B \\<subseteq> C\n\ngoal (1 subgoal):\n 1. {c. \\<exists>a\\<in>A. \\<exists>b\\<in>B. c = a + b} \\<subseteq> C", "using closed_csubspace.subspace complex_vector.subspace_add"], ["proof (prove)\nusing this:\n  closed_csubspace C\n  A \\<subseteq> C\n  B \\<subseteq> C\n  closed_csubspace ?A \\<Longrightarrow> csubspace ?A\n  \\<lbrakk>csubspace ?S; ?x \\<in> ?S; ?y \\<in> ?S\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<in> ?S\n\ngoal (1 subgoal):\n 1. {c. \\<exists>a\\<in>A. \\<exists>b\\<in>B. c = a + b} \\<subseteq> C", "by blast"], ["proof (state)\nthis:\n  A + B \\<subseteq> C\n\ngoal (1 subgoal):\n 1. A +\\<^sub>M B \\<subseteq> C", "then"], ["proof (chain)\npicking this:\n  A + B \\<subseteq> C", "show \\<open>(A +\\<^sub>M B) \\<subseteq> C\\<close>"], ["proof (prove)\nusing this:\n  A + B \\<subseteq> C\n\ngoal (1 subgoal):\n 1. A +\\<^sub>M B \\<subseteq> C", "unfolding closed_sum_def"], ["proof (prove)\nusing this:\n  A + B \\<subseteq> C\n\ngoal (1 subgoal):\n 1. closure (A + B) \\<subseteq> C", "using \\<open>closed_csubspace C\\<close>"], ["proof (prove)\nusing this:\n  A + B \\<subseteq> C\n  closed_csubspace C\n\ngoal (1 subgoal):\n 1. closure (A + B) \\<subseteq> C", "by (simp add: closed_csubspace.closed closure_minimal)"], ["proof (state)\nthis:\n  A +\\<^sub>M B \\<subseteq> C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_subspace_closed_sum:\n  fixes A B::\"('a::complex_normed_vector) set\"\n  assumes a1: \\<open>csubspace A\\<close> and a2: \\<open>csubspace B\\<close>\n  shows \\<open>closed_csubspace (A +\\<^sub>M B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (A +\\<^sub>M B)", "using a1 a2 closed_sum_def"], ["proof (prove)\nusing this:\n  csubspace A\n  csubspace B\n  ?A +\\<^sub>M ?B = closure (?A + ?B)\n\ngoal (1 subgoal):\n 1. closed_csubspace (A +\\<^sub>M B)", "by (metis closure_is_closed_csubspace csubspace_set_plus)"], ["", "lemma closed_sum_assoc:\n  fixes A B C::\"'a::real_normed_vector set\"\n  shows \\<open>A +\\<^sub>M (B +\\<^sub>M C) = (A +\\<^sub>M B) +\\<^sub>M C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A +\\<^sub>M (B +\\<^sub>M C) = A +\\<^sub>M B +\\<^sub>M C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A +\\<^sub>M (B +\\<^sub>M C) = A +\\<^sub>M B +\\<^sub>M C", "have \\<open>A + closure B \\<subseteq> closure (A + B)\\<close> for A B :: \"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A + closure B \\<subseteq> closure (A + B)", "by (meson closure_subset closure_sum dual_order.trans order_refl set_plus_mono2)"], ["proof (state)\nthis:\n  ?A + closure ?B \\<subseteq> closure (?A + ?B)\n\ngoal (1 subgoal):\n 1. A +\\<^sub>M (B +\\<^sub>M C) = A +\\<^sub>M B +\\<^sub>M C", "then"], ["proof (chain)\npicking this:\n  ?A + closure ?B \\<subseteq> closure (?A + ?B)", "have \\<open>A +\\<^sub>M (B +\\<^sub>M C) = closure (A + (B + C))\\<close>"], ["proof (prove)\nusing this:\n  ?A + closure ?B \\<subseteq> closure (?A + ?B)\n\ngoal (1 subgoal):\n 1. A +\\<^sub>M (B +\\<^sub>M C) = closure (A + (B + C))", "unfolding closed_sum_def"], ["proof (prove)\nusing this:\n  ?A + closure ?B \\<subseteq> closure (?A + ?B)\n\ngoal (1 subgoal):\n 1. closure (A + closure (B + C)) = closure (A + (B + C))", "by (meson antisym_conv closed_closure closure_minimal closure_mono closure_subset equalityD1 set_plus_mono2)"], ["proof (state)\nthis:\n  A +\\<^sub>M (B +\\<^sub>M C) = closure (A + (B + C))\n\ngoal (1 subgoal):\n 1. A +\\<^sub>M (B +\\<^sub>M C) = A +\\<^sub>M B +\\<^sub>M C", "moreover"], ["proof (state)\nthis:\n  A +\\<^sub>M (B +\\<^sub>M C) = closure (A + (B + C))\n\ngoal (1 subgoal):\n 1. A +\\<^sub>M (B +\\<^sub>M C) = A +\\<^sub>M B +\\<^sub>M C", "have \\<open>closure A + B \\<subseteq> closure (A + B)\\<close> for A B :: \"'a set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closure A + B \\<subseteq> closure (A + B)", "by (meson closure_subset closure_sum dual_order.trans order_refl set_plus_mono2)"], ["proof (state)\nthis:\n  closure ?A + ?B \\<subseteq> closure (?A + ?B)\n\ngoal (1 subgoal):\n 1. A +\\<^sub>M (B +\\<^sub>M C) = A +\\<^sub>M B +\\<^sub>M C", "then"], ["proof (chain)\npicking this:\n  closure ?A + ?B \\<subseteq> closure (?A + ?B)", "have \\<open>(A +\\<^sub>M B) +\\<^sub>M C = closure ((A + B) + C)\\<close>"], ["proof (prove)\nusing this:\n  closure ?A + ?B \\<subseteq> closure (?A + ?B)\n\ngoal (1 subgoal):\n 1. A +\\<^sub>M B +\\<^sub>M C = closure (A + B + C)", "unfolding closed_sum_def"], ["proof (prove)\nusing this:\n  closure ?A + ?B \\<subseteq> closure (?A + ?B)\n\ngoal (1 subgoal):\n 1. closure (closure (A + B) + C) = closure (A + B + C)", "by (meson closed_closure closure_minimal closure_mono closure_subset eq_iff set_plus_mono2)"], ["proof (state)\nthis:\n  A +\\<^sub>M B +\\<^sub>M C = closure (A + B + C)\n\ngoal (1 subgoal):\n 1. A +\\<^sub>M (B +\\<^sub>M C) = A +\\<^sub>M B +\\<^sub>M C", "ultimately"], ["proof (chain)\npicking this:\n  A +\\<^sub>M (B +\\<^sub>M C) = closure (A + (B + C))\n  A +\\<^sub>M B +\\<^sub>M C = closure (A + B + C)", "show ?thesis"], ["proof (prove)\nusing this:\n  A +\\<^sub>M (B +\\<^sub>M C) = closure (A + (B + C))\n  A +\\<^sub>M B +\\<^sub>M C = closure (A + B + C)\n\ngoal (1 subgoal):\n 1. A +\\<^sub>M (B +\\<^sub>M C) = A +\\<^sub>M B +\\<^sub>M C", "by (simp add: ab_semigroup_add_class.add_ac(1))"], ["proof (state)\nthis:\n  A +\\<^sub>M (B +\\<^sub>M C) = A +\\<^sub>M B +\\<^sub>M C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_sum_zero_left[simp]:\n  fixes A :: \\<open>('a::{monoid_add, topological_space}) set\\<close>\n  shows \\<open>{0} +\\<^sub>M A = closure A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {0::'a} +\\<^sub>M A = closure A", "unfolding closed_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure ({0::'a} + A) = closure A", "by (metis add.left_neutral set_zero)"], ["", "lemma closed_sum_zero_right[simp]:\n  fixes A :: \\<open>('a::{monoid_add, topological_space}) set\\<close>\n  shows \\<open>A +\\<^sub>M {0} = closure A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A +\\<^sub>M {0::'a} = closure A", "unfolding closed_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (A + {0::'a}) = closure A", "by (metis add.right_neutral set_zero)"], ["", "lemma closed_sum_closure_right[simp]:\n  fixes A B :: \\<open>'a::real_normed_vector set\\<close>\n  shows \\<open>A +\\<^sub>M closure B = A +\\<^sub>M B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A +\\<^sub>M closure B = A +\\<^sub>M B", "by (metis closed_sum_assoc closed_sum_def closed_sum_zero_right closure_closure)"], ["", "lemma closed_sum_closure_left[simp]:\n  fixes A B :: \\<open>'a::real_normed_vector set\\<close>\n  shows \\<open>closure A +\\<^sub>M B = A +\\<^sub>M B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure A +\\<^sub>M B = A +\\<^sub>M B", "by (simp add: closed_sum_comm)"], ["", "lemma closed_sum_mono_left:\n  assumes \\<open>A \\<subseteq> B\\<close>\n  shows \\<open>A +\\<^sub>M C \\<subseteq> B +\\<^sub>M C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A +\\<^sub>M C \\<subseteq> B +\\<^sub>M C", "by (simp add: assms closed_sum_def closure_mono set_plus_mono2)"], ["", "lemma closed_sum_mono_right:\n  assumes \\<open>A \\<subseteq> B\\<close>\n  shows \\<open>C +\\<^sub>M A \\<subseteq> C +\\<^sub>M B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. C +\\<^sub>M A \\<subseteq> C +\\<^sub>M B", "by (simp add: assms closed_sum_def closure_mono set_plus_mono2)"], ["", "instantiation ccsubspace :: (complex_normed_vector) sup begin"], ["", "lift_definition sup_ccsubspace :: \"'a ccsubspace \\<Rightarrow> 'a ccsubspace \\<Rightarrow> 'a ccsubspace\" \n  \\<comment> \\<open>Note that \\<^term>\\<open>A+B\\<close> would not be a closed subspace, we need the closure. See, e.g., \\<^url>\\<open>https://math.stackexchange.com/a/1786792/403528\\<close>.\\<close>\n  is \"\\<lambda>A B::'a set. A +\\<^sub>M B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       \\<lbrakk>closed_csubspace set1; closed_csubspace set2\\<rbrakk>\n       \\<Longrightarrow> closed_csubspace (set1 +\\<^sub>M set2)", "by (simp add: closed_subspace_closed_sum)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, sup_class)", ".."], ["", "end"], ["", "lemma closed_sum_cspan[simp]:\n  shows \\<open>cspan X +\\<^sub>M cspan Y = closure (cspan (X \\<union> Y))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan X +\\<^sub>M cspan Y = closure (cspan (X \\<union> Y))", "by (smt (verit, best) Collect_cong closed_sum_def complex_vector.span_Un set_plus_def)"], ["", "lemma closure_image_closed_sum: \n  assumes \\<open>bounded_linear U\\<close>\n  shows \\<open>closure (U ` (A +\\<^sub>M B)) = closure (U ` A) +\\<^sub>M closure (U ` B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (U ` (A +\\<^sub>M B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closure (U ` (A +\\<^sub>M B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "have \\<open>closure (U ` (A +\\<^sub>M B)) = closure (U ` closure (closure A + closure B))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (U ` (A +\\<^sub>M B)) =\n    closure (U ` closure (closure A + closure B))", "unfolding closed_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (U ` closure (A + B)) =\n    closure (U ` closure (closure A + closure B))", "by (smt (verit, best) closed_closure closure_minimal closure_mono closure_subset closure_sum set_plus_mono2 subset_antisym)"], ["proof (state)\nthis:\n  closure (U ` (A +\\<^sub>M B)) =\n  closure (U ` closure (closure A + closure B))\n\ngoal (1 subgoal):\n 1. closure (U ` (A +\\<^sub>M B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "also"], ["proof (state)\nthis:\n  closure (U ` (A +\\<^sub>M B)) =\n  closure (U ` closure (closure A + closure B))\n\ngoal (1 subgoal):\n 1. closure (U ` (A +\\<^sub>M B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "have \\<open>\\<dots> = closure (U ` (closure A + closure B))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (U ` closure (closure A + closure B)) =\n    closure (U ` (closure A + closure B))", "using assms closure_bounded_linear_image_subset_eq"], ["proof (prove)\nusing this:\n  bounded_linear U\n  bounded_linear ?f \\<Longrightarrow>\n  closure (?f ` closure ?S) = closure (?f ` ?S)\n\ngoal (1 subgoal):\n 1. closure (U ` closure (closure A + closure B)) =\n    closure (U ` (closure A + closure B))", "by blast"], ["proof (state)\nthis:\n  closure (U ` closure (closure A + closure B)) =\n  closure (U ` (closure A + closure B))\n\ngoal (1 subgoal):\n 1. closure (U ` (A +\\<^sub>M B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "also"], ["proof (state)\nthis:\n  closure (U ` closure (closure A + closure B)) =\n  closure (U ` (closure A + closure B))\n\ngoal (1 subgoal):\n 1. closure (U ` (A +\\<^sub>M B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "have \\<open>\\<dots> = closure (U ` closure A + U ` closure B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (U ` (closure A + closure B)) =\n    closure (U ` closure A + U ` closure B)", "apply (subst image_set_plus)"], ["proof (prove)\ngoal (2 subgoals):\n 1. linear U\n 2. closure (U ` closure A + U ` closure B) =\n    closure (U ` closure A + U ` closure B)", "by (simp_all add: assms bounded_linear.linear)"], ["proof (state)\nthis:\n  closure (U ` (closure A + closure B)) =\n  closure (U ` closure A + U ` closure B)\n\ngoal (1 subgoal):\n 1. closure (U ` (A +\\<^sub>M B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "also"], ["proof (state)\nthis:\n  closure (U ` (closure A + closure B)) =\n  closure (U ` closure A + U ` closure B)\n\ngoal (1 subgoal):\n 1. closure (U ` (A +\\<^sub>M B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "have \\<open>\\<dots> = closure (closure (U ` A) + closure (U ` B))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (U ` closure A + U ` closure B) =\n    closure (closure (U ` A) + closure (U ` B))", "by (smt (verit, ccfv_SIG) assms closed_closure closure_bounded_linear_image_subset closure_bounded_linear_image_subset_eq closure_minimal closure_mono closure_sum dual_order.eq_iff set_plus_mono2)"], ["proof (state)\nthis:\n  closure (U ` closure A + U ` closure B) =\n  closure (closure (U ` A) + closure (U ` B))\n\ngoal (1 subgoal):\n 1. closure (U ` (A +\\<^sub>M B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "also"], ["proof (state)\nthis:\n  closure (U ` closure A + U ` closure B) =\n  closure (closure (U ` A) + closure (U ` B))\n\ngoal (1 subgoal):\n 1. closure (U ` (A +\\<^sub>M B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "have \\<open>\\<dots> = closure (U ` A) +\\<^sub>M closure (U ` B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (closure (U ` A) + closure (U ` B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "using closed_sum_def"], ["proof (prove)\nusing this:\n  ?A +\\<^sub>M ?B = closure (?A + ?B)\n\ngoal (1 subgoal):\n 1. closure (closure (U ` A) + closure (U ` B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "by blast"], ["proof (state)\nthis:\n  closure (closure (U ` A) + closure (U ` B)) =\n  closure (U ` A) +\\<^sub>M closure (U ` B)\n\ngoal (1 subgoal):\n 1. closure (U ` (A +\\<^sub>M B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "finally"], ["proof (chain)\npicking this:\n  closure (U ` (A +\\<^sub>M B)) = closure (U ` A) +\\<^sub>M closure (U ` B)", "show ?thesis"], ["proof (prove)\nusing this:\n  closure (U ` (A +\\<^sub>M B)) = closure (U ` A) +\\<^sub>M closure (U ` B)\n\ngoal (1 subgoal):\n 1. closure (U ` (A +\\<^sub>M B)) =\n    closure (U ` A) +\\<^sub>M closure (U ` B)", "by -"], ["proof (state)\nthis:\n  closure (U ` (A +\\<^sub>M B)) = closure (U ` A) +\\<^sub>M closure (U ` B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ccspan_union: \"ccspan A \\<squnion> ccspan B = ccspan (A \\<union> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccspan A \\<squnion> ccspan B = ccspan (A \\<union> B)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B.\n       closure (cspan A) +\\<^sub>M closure (cspan B) =\n       closure (cspan (A \\<union> B))", "by simp"], ["", "instantiation ccsubspace :: (complex_normed_vector) \"Sup\"\nbegin"], ["", "lift_definition Sup_ccsubspace::\\<open>'a ccsubspace set \\<Rightarrow> 'a ccsubspace\\<close>\n  is \\<open>\\<lambda>S. closure (complex_vector.span (Union S))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           closed_csubspace x) \\<Longrightarrow>\n       closed_csubspace (closure (cspan (\\<Union> set)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           closed_csubspace x) \\<Longrightarrow>\n       csubspace (closure (cspan (\\<Union> set)))\n 2. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           closed_csubspace x) \\<Longrightarrow>\n       closed (closure (cspan (\\<Union> set)))", "show \"csubspace (closure (complex_vector.span (\\<Union> S::'a set)))\"\n    if \"\\<And>x::'a set. x \\<in> S \\<Longrightarrow> closed_csubspace x\"\n    for S :: \"'a set set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace (closure (cspan (\\<Union> S)))", "using that"], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> closed_csubspace ?x\n\ngoal (1 subgoal):\n 1. csubspace (closure (cspan (\\<Union> S)))", "by (simp add: closure_is_closed_csubspace)"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> ?S \\<Longrightarrow> closed_csubspace x) \\<Longrightarrow>\n  csubspace (closure (cspan (\\<Union> ?S)))\n\ngoal (1 subgoal):\n 1. \\<And>set.\n       (\\<And>x.\n           x \\<in> set \\<Longrightarrow>\n           closed_csubspace x) \\<Longrightarrow>\n       closed (closure (cspan (\\<Union> set)))", "show \"closed (closure (complex_vector.span (\\<Union> S::'a set)))\"\n    if \"\\<And>x. (x::'a set) \\<in> S \\<Longrightarrow> closed_csubspace x\"\n    for S :: \"'a set set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (closure (cspan (\\<Union> S)))", "using that"], ["proof (prove)\nusing this:\n  ?x \\<in> S \\<Longrightarrow> closed_csubspace ?x\n\ngoal (1 subgoal):\n 1. closed (closure (cspan (\\<Union> S)))", "by simp"], ["proof (state)\nthis:\n  (\\<And>x.\n      x \\<in> ?S \\<Longrightarrow> closed_csubspace x) \\<Longrightarrow>\n  closed (closure (cspan (\\<Union> ?S)))\n\ngoal:\nNo subgoals!", "qed"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, Sup_class)", ".."], ["", "end"], ["", "instance ccsubspace :: (\"{complex_normed_vector}\") semilattice_sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, semilattice_sup_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "fix x y z :: \\<open>'a ccsubspace\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "show \\<open>x \\<le> sup x y\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x \\<squnion> y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>closed_csubspace x; closed_csubspace y\\<rbrakk>\n       \\<Longrightarrow> x \\<subseteq> x +\\<^sub>M y", "by (simp add: closed_csubspace_def closed_sum_left_subset complex_vector.subspace_0)"], ["proof (state)\nthis:\n  x \\<le> x \\<squnion> y\n\ngoal (2 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "show \"y \\<le> sup x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<squnion> y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>closed_csubspace y; closed_csubspace x\\<rbrakk>\n       \\<Longrightarrow> y \\<subseteq> x +\\<^sub>M y", "by (simp add: closed_csubspace_def closed_sum_right_subset complex_vector.subspace_0)"], ["proof (state)\nthis:\n  y \\<le> x \\<squnion> y\n\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "show \"sup x y \\<le> z\" if \"x \\<le> z\" and \"y \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<le> z", "using that"], ["proof (prove)\nusing this:\n  x \\<le> z\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<le> z", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x z y.\n       \\<lbrakk>closed_csubspace x; closed_csubspace z; x \\<subseteq> z;\n        closed_csubspace y; y \\<subseteq> z\\<rbrakk>\n       \\<Longrightarrow> x +\\<^sub>M y \\<subseteq> z", "apply (rule closed_sum_is_sup)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x z y.\n       \\<lbrakk>closed_csubspace x; closed_csubspace z; x \\<subseteq> z;\n        closed_csubspace y; y \\<subseteq> z\\<rbrakk>\n       \\<Longrightarrow> closed_csubspace z\n 2. \\<And>x z y.\n       \\<lbrakk>closed_csubspace x; closed_csubspace z; x \\<subseteq> z;\n        closed_csubspace y; y \\<subseteq> z\\<rbrakk>\n       \\<Longrightarrow> x \\<subseteq> z\n 3. \\<And>x z y.\n       \\<lbrakk>closed_csubspace x; closed_csubspace z; x \\<subseteq> z;\n        closed_csubspace y; y \\<subseteq> z\\<rbrakk>\n       \\<Longrightarrow> y \\<subseteq> z", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> z; y \\<le> z\\<rbrakk>\n  \\<Longrightarrow> x \\<squnion> y \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["", "instance ccsubspace :: (\"{complex_normed_vector}\") complete_lattice"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, complete_lattice_class)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> \\<Sqinter> A \\<le> x\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> A\n 3. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> \\<Squnion> A\n 4. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       \\<Squnion> A \\<le> z\n 5. \\<Sqinter> {} = \\<top>\n 6. \\<Squnion> {} = \\<bottom>", "show \"Inf A \\<le> x\"\n    if \"x \\<in> A\"\n    for x :: \"'a ccsubspace\"\n      and A :: \"'a ccsubspace set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> A \\<le> x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<Sqinter> A \\<le> x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>closed_csubspace x; Ball A closed_csubspace;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<Inter> A \\<subseteq> x", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> ?A \\<Longrightarrow> \\<Sqinter> ?A \\<le> ?x\n\ngoal (5 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> A\n 2. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> \\<Squnion> A\n 3. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       \\<Squnion> A \\<le> z\n 4. \\<Sqinter> {} = \\<top>\n 5. \\<Squnion> {} = \\<bottom>", "have b1: \"z \\<subseteq> \\<Inter> A\"\n    if \"Ball A closed_csubspace\" and\n      \"closed_csubspace z\" and\n      \"(\\<And>x. closed_csubspace x \\<Longrightarrow> x \\<in> A \\<Longrightarrow> z \\<subseteq> x)\"\n    for z::\"'a set\" and A"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<subseteq> \\<Inter> A", "using that"], ["proof (prove)\nusing this:\n  Ball A closed_csubspace\n  closed_csubspace z\n  \\<lbrakk>closed_csubspace ?x; ?x \\<in> A\\<rbrakk>\n  \\<Longrightarrow> z \\<subseteq> ?x\n\ngoal (1 subgoal):\n 1. z \\<subseteq> \\<Inter> A", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>Ball ?A closed_csubspace; closed_csubspace ?z;\n   \\<And>x.\n      \\<lbrakk>closed_csubspace x; x \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?z \\<subseteq> x\\<rbrakk>\n  \\<Longrightarrow> ?z \\<subseteq> \\<Inter> ?A\n\ngoal (5 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> A\n 2. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> \\<Squnion> A\n 3. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       \\<Squnion> A \\<le> z\n 4. \\<Sqinter> {} = \\<top>\n 5. \\<Squnion> {} = \\<bottom>", "show \"z \\<le> Inf A\"\n    if \"\\<And>x::'a ccsubspace. x \\<in> A \\<Longrightarrow> z \\<le> x\"\n    for A :: \"'a ccsubspace set\"\n      and z :: \"'a ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> \\<Sqinter> A", "using that"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> z \\<le> ?x\n\ngoal (1 subgoal):\n 1. z \\<le> \\<Sqinter> A", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Ball A closed_csubspace; closed_csubspace z;\n        \\<And>x.\n           \\<lbrakk>closed_csubspace x; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> z \\<subseteq> x\\<rbrakk>\n       \\<Longrightarrow> z \\<subseteq> \\<Inter> A", "using b1"], ["proof (prove)\nusing this:\n  \\<lbrakk>Ball ?A closed_csubspace; closed_csubspace ?z;\n   \\<And>x.\n      \\<lbrakk>closed_csubspace x; x \\<in> ?A\\<rbrakk>\n      \\<Longrightarrow> ?z \\<subseteq> x\\<rbrakk>\n  \\<Longrightarrow> ?z \\<subseteq> \\<Inter> ?A\n\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Ball A closed_csubspace; closed_csubspace z;\n        \\<And>x.\n           \\<lbrakk>closed_csubspace x; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> z \\<subseteq> x\\<rbrakk>\n       \\<Longrightarrow> z \\<subseteq> \\<Inter> A", "by blast"], ["proof (state)\nthis:\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> ?z \\<le> x) \\<Longrightarrow>\n  ?z \\<le> \\<Sqinter> ?A\n\ngoal (4 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> \\<Squnion> A\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       \\<Squnion> A \\<le> z\n 3. \\<Sqinter> {} = \\<top>\n 4. \\<Squnion> {} = \\<bottom>", "show \"x \\<le> Sup A\"\n    if \"x \\<in> A\"\n    for x :: \"'a ccsubspace\"\n      and A :: \"'a ccsubspace set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> A", "using that"], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. x \\<le> \\<Squnion> A", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>closed_csubspace x; Ball A closed_csubspace;\n        x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> x \\<subseteq> closure (cspan (\\<Union> A))", "by (meson Union_upper closure_subset complex_vector.span_superset dual_order.trans)"], ["proof (state)\nthis:\n  ?x \\<in> ?A \\<Longrightarrow> ?x \\<le> \\<Squnion> ?A\n\ngoal (3 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       \\<Squnion> A \\<le> z\n 2. \\<Sqinter> {} = \\<top>\n 3. \\<Squnion> {} = \\<bottom>", "show \"Sup A \\<le> z\"\n    if \"\\<And>x::'a ccsubspace. x \\<in> A \\<Longrightarrow> x \\<le> z\"\n    for A :: \"'a ccsubspace set\"\n      and z :: \"'a ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> A \\<le> z", "using that"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> ?x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<Squnion> A \\<le> z", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Ball A closed_csubspace; closed_csubspace z;\n        \\<And>x.\n           \\<lbrakk>closed_csubspace x; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> x \\<subseteq> z\\<rbrakk>\n       \\<Longrightarrow> closure (cspan (\\<Union> A)) \\<subseteq> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Ball A closed_csubspace; closed_csubspace z;\n        \\<And>x.\n           \\<lbrakk>closed_csubspace x; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> x \\<subseteq> z\\<rbrakk>\n       \\<Longrightarrow> closure (cspan (\\<Union> A)) \\<subseteq> z", "fix A :: \"'a set set\" and z :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Ball A closed_csubspace; closed_csubspace z;\n        \\<And>x.\n           \\<lbrakk>closed_csubspace x; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> x \\<subseteq> z\\<rbrakk>\n       \\<Longrightarrow> closure (cspan (\\<Union> A)) \\<subseteq> z", "assume A_closed: \"Ball A closed_csubspace\""], ["proof (state)\nthis:\n  Ball A closed_csubspace\n\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Ball A closed_csubspace; closed_csubspace z;\n        \\<And>x.\n           \\<lbrakk>closed_csubspace x; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> x \\<subseteq> z\\<rbrakk>\n       \\<Longrightarrow> closure (cspan (\\<Union> A)) \\<subseteq> z", "assume \"closed_csubspace z\""], ["proof (state)\nthis:\n  closed_csubspace z\n\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Ball A closed_csubspace; closed_csubspace z;\n        \\<And>x.\n           \\<lbrakk>closed_csubspace x; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> x \\<subseteq> z\\<rbrakk>\n       \\<Longrightarrow> closure (cspan (\\<Union> A)) \\<subseteq> z", "assume in_z: \"\\<And>x. closed_csubspace x \\<Longrightarrow> x \\<in> A \\<Longrightarrow> x \\<subseteq> z\""], ["proof (state)\nthis:\n  \\<lbrakk>closed_csubspace ?x; ?x \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ?x \\<subseteq> z\n\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Ball A closed_csubspace; closed_csubspace z;\n        \\<And>x.\n           \\<lbrakk>closed_csubspace x; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> x \\<subseteq> z\\<rbrakk>\n       \\<Longrightarrow> closure (cspan (\\<Union> A)) \\<subseteq> z", "from A_closed in_z"], ["proof (chain)\npicking this:\n  Ball A closed_csubspace\n  \\<lbrakk>closed_csubspace ?x; ?x \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ?x \\<subseteq> z", "have \\<open>V \\<subseteq> z\\<close> if \\<open>V \\<in> A\\<close> for V"], ["proof (prove)\nusing this:\n  Ball A closed_csubspace\n  \\<lbrakk>closed_csubspace ?x; ?x \\<in> A\\<rbrakk>\n  \\<Longrightarrow> ?x \\<subseteq> z\n\ngoal (1 subgoal):\n 1. V \\<subseteq> z", "by (simp add: that)"], ["proof (state)\nthis:\n  ?V \\<in> A \\<Longrightarrow> ?V \\<subseteq> z\n\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Ball A closed_csubspace; closed_csubspace z;\n        \\<And>x.\n           \\<lbrakk>closed_csubspace x; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> x \\<subseteq> z\\<rbrakk>\n       \\<Longrightarrow> closure (cspan (\\<Union> A)) \\<subseteq> z", "then"], ["proof (chain)\npicking this:\n  ?V \\<in> A \\<Longrightarrow> ?V \\<subseteq> z", "have \\<open>\\<Union> A \\<subseteq> z\\<close>"], ["proof (prove)\nusing this:\n  ?V \\<in> A \\<Longrightarrow> ?V \\<subseteq> z\n\ngoal (1 subgoal):\n 1. \\<Union> A \\<subseteq> z", "by (simp add: Sup_le_iff)"], ["proof (state)\nthis:\n  \\<Union> A \\<subseteq> z\n\ngoal (1 subgoal):\n 1. \\<And>A z.\n       \\<lbrakk>Ball A closed_csubspace; closed_csubspace z;\n        \\<And>x.\n           \\<lbrakk>closed_csubspace x; x \\<in> A\\<rbrakk>\n           \\<Longrightarrow> x \\<subseteq> z\\<rbrakk>\n       \\<Longrightarrow> closure (cspan (\\<Union> A)) \\<subseteq> z", "with \\<open>closed_csubspace z\\<close>"], ["proof (chain)\npicking this:\n  closed_csubspace z\n  \\<Union> A \\<subseteq> z", "show \"closure (cspan (\\<Union> A)) \\<subseteq> z\""], ["proof (prove)\nusing this:\n  closed_csubspace z\n  \\<Union> A \\<subseteq> z\n\ngoal (1 subgoal):\n 1. closure (cspan (\\<Union> A)) \\<subseteq> z", "by (simp add: closed_csubspace_def closure_minimal complex_vector.span_def subset_hull)"], ["proof (state)\nthis:\n  closure (cspan (\\<Union> A)) \\<subseteq> z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<le> ?z) \\<Longrightarrow>\n  \\<Squnion> ?A \\<le> ?z\n\ngoal (2 subgoals):\n 1. \\<Sqinter> {} = \\<top>\n 2. \\<Squnion> {} = \\<bottom>", "show \"Inf {} = (top::'a ccsubspace)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> {} = \\<top>", "using \\<open>\\<And>z A. (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow> z \\<le> Inf A\\<close> top.extremum_uniqueI"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> ?z \\<le> x) \\<Longrightarrow>\n  ?z \\<le> \\<Sqinter> ?A\n  \\<top> \\<le> ?a \\<Longrightarrow> ?a = \\<top>\n\ngoal (1 subgoal):\n 1. \\<Sqinter> {} = \\<top>", "by auto"], ["proof (state)\nthis:\n  \\<Sqinter> {} = \\<top>\n\ngoal (1 subgoal):\n 1. \\<Squnion> {} = \\<bottom>", "show \"Sup {} = (bot::'a ccsubspace)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {} = \\<bottom>", "using \\<open>\\<And>z A. (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow> Sup A \\<le> z\\<close> bot.extremum_uniqueI"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> x \\<le> ?z) \\<Longrightarrow>\n  \\<Squnion> ?A \\<le> ?z\n  ?a \\<le> \\<bottom> \\<Longrightarrow> ?a = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<Squnion> {} = \\<bottom>", "by auto"], ["proof (state)\nthis:\n  \\<Squnion> {} = \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation ccsubspace :: (complex_normed_vector) comm_monoid_add begin"], ["", "definition plus_ccsubspace :: \"'a ccsubspace \\<Rightarrow> _ \\<Rightarrow> _\"\n  where [simp]: \"plus_ccsubspace = sup\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ccsubspace, comm_monoid_add_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a", "fix a b c :: \\<open>'a ccsubspace\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a", "show \"a + b + c = a + (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "using sup.assoc"], ["proof (prove)\nusing this:\n  ?a \\<squnion> ?b \\<squnion> ?c = ?a \\<squnion> (?b \\<squnion> ?c)\n\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "by auto"], ["proof (state)\nthis:\n  a + b + c = a + (b + c)\n\ngoal (2 subgoals):\n 1. \\<And>a b. a + b = b + a\n 2. \\<And>a. 0 + a = a", "show \"a + b = b + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = b + a", "by (simp add: sup.commute)"], ["proof (state)\nthis:\n  a + b = b + a\n\ngoal (1 subgoal):\n 1. \\<And>a. 0 + a = a", "show \"0 + a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + a = a", "by (simp add: zero_ccsubspace_def)"], ["proof (state)\nthis:\n  0 + a = a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma ccsubspace_plus_sup: \"y \\<le> x \\<Longrightarrow> z \\<le> x \\<Longrightarrow> y + z \\<le> x\" \n  for x y z :: \"'a::complex_normed_vector ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk> \\<Longrightarrow> y + z \\<le> x", "unfolding plus_ccsubspace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> y \\<squnion> z \\<le> x", "by auto"], ["", "lemma ccsubspace_Sup_empty: \"Sup {} = (0::_ ccsubspace)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {} = 0", "unfolding zero_ccsubspace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {} = \\<bottom>", "by auto"], ["", "lemma ccsubspace_add_right_incr[simp]: \"a \\<le> a + c\" for a::\"_ ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> a + c", "by (simp add: add_increasing2)"], ["", "lemma ccsubspace_add_left_incr[simp]: \"a \\<le> c + a\" for a::\"_ ccsubspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> c + a", "by (simp add: add_increasing)"], ["", "subsection \\<open>Conjugate space\\<close>"], ["", "typedef 'a conjugate_space = \"UNIV :: 'a set\"\n  morphisms from_conjugate_space to_conjugate_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", ".."], ["", "setup_lifting type_definition_conjugate_space"], ["", "instantiation conjugate_space :: (complex_vector) complex_vector begin"], ["", "lift_definition scaleC_conjugate_space :: \\<open>complex \\<Rightarrow> 'a conjugate_space \\<Rightarrow> 'a conjugate_space\\<close> is \\<open>\\<lambda>c x. cnj c *\\<^sub>C x\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition scaleR_conjugate_space :: \\<open>real \\<Rightarrow> 'a conjugate_space \\<Rightarrow> 'a conjugate_space\\<close> is \\<open>\\<lambda>r x. r *\\<^sub>R x\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition plus_conjugate_space :: \"'a conjugate_space \\<Rightarrow> 'a conjugate_space \\<Rightarrow> 'a conjugate_space\" is \"(+)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uminus_conjugate_space :: \"'a conjugate_space \\<Rightarrow> 'a conjugate_space\" is \\<open>\\<lambda>x. -x\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition zero_conjugate_space :: \"'a conjugate_space\" is 0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition minus_conjugate_space :: \"'a conjugate_space \\<Rightarrow> 'a conjugate_space \\<Rightarrow> 'a conjugate_space\" is \"(-)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a conjugate_space, complex_vector_class)", "apply (intro_classes; transfer)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (cnj (complex_of_real r))\n 2. \\<And>a b c. a + b + c = a + (b + c)\n 3. \\<And>a b. a + b = b + a\n 4. \\<And>a. (0::'a) + a = a\n 5. \\<And>a. - a + a = (0::'a)\n 6. \\<And>a b. a - b = a + - b\n 7. \\<And>a x y.\n       cnj a *\\<^sub>C (x + y) = cnj a *\\<^sub>C x + cnj a *\\<^sub>C y\n 8. \\<And>a b x.\n       cnj (a + b) *\\<^sub>C x = cnj a *\\<^sub>C x + cnj b *\\<^sub>C x\n 9. \\<And>a b x. cnj a *\\<^sub>C cnj b *\\<^sub>C x = cnj (a * b) *\\<^sub>C x\n 10. \\<And>x. cnj 1 *\\<^sub>C x = x", "by (simp_all add: scaleR_scaleC scaleC_add_right scaleC_left.add)"], ["", "end"], ["", "instantiation conjugate_space :: (complex_normed_vector) complex_normed_vector begin"], ["", "lift_definition sgn_conjugate_space :: \"'a conjugate_space \\<Rightarrow> 'a conjugate_space\" is \"sgn\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition norm_conjugate_space :: \"'a conjugate_space \\<Rightarrow> real\" is norm"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition dist_conjugate_space :: \"'a conjugate_space \\<Rightarrow> 'a conjugate_space \\<Rightarrow> real\" is dist"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uniformity_conjugate_space :: \"('a conjugate_space \\<times> 'a conjugate_space) filter\" is uniformity"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition  open_conjugate_space :: \"'a conjugate_space set \\<Rightarrow> bool\" is \"open\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a conjugate_space, complex_normed_vector_class)", "apply (intro_classes; transfer)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x y. dist x y = norm (x - y)\n 2. \\<And>x. sgn x = x /\\<^sub>R norm x\n 3. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 4. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 5. \\<And>x. (norm x = 0) = (x = (0::'a))\n 6. \\<And>x y. norm (x + y) \\<le> norm x + norm y\n 7. \\<And>a x. norm (a *\\<^sub>R x) = \\<bar>a\\<bar> * norm x\n 8. \\<And>a x. norm (cnj a *\\<^sub>C x) = cmod a * norm x", "by (simp_all add: dist_norm sgn_div_norm open_uniformity uniformity_dist norm_triangle_ineq)"], ["", "end"], ["", "instantiation conjugate_space :: (cbanach) cbanach begin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a conjugate_space, cbanach_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "unfolding Cauchy_def convergent_def LIMSEQ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<forall>e>0.\n          \\<exists>M.\n             \\<forall>m\\<ge>M.\n                \\<forall>n\\<ge>M. dist (X m) (X n) < e \\<Longrightarrow>\n       \\<exists>L.\n          \\<forall>r>0. \\<exists>no. \\<forall>n\\<ge>no. dist (X n) L < r", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<forall>e>0.\n          \\<exists>M.\n             \\<forall>m\\<ge>M.\n                \\<forall>n\\<ge>M. dist (X m) (X n) < e \\<Longrightarrow>\n       \\<exists>L.\n          \\<forall>r>0. \\<exists>no. \\<forall>n\\<ge>no. dist (X n) L < r", "using Cauchy_convergent"], ["proof (prove)\nusing this:\n  Cauchy ?X \\<Longrightarrow> convergent ?X\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<forall>e>0.\n          \\<exists>M.\n             \\<forall>m\\<ge>M.\n                \\<forall>n\\<ge>M. dist (X m) (X n) < e \\<Longrightarrow>\n       \\<exists>L.\n          \\<forall>r>0. \\<exists>no. \\<forall>n\\<ge>no. dist (X n) L < r", "unfolding Cauchy_def convergent_def LIMSEQ_def"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     \\<exists>M.\n        \\<forall>m\\<ge>M.\n           \\<forall>n\\<ge>M. dist (?X m) (?X n) < e \\<Longrightarrow>\n  \\<exists>L.\n     \\<forall>r>0. \\<exists>no. \\<forall>n\\<ge>no. dist (?X n) L < r\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<forall>e>0.\n          \\<exists>M.\n             \\<forall>m\\<ge>M.\n                \\<forall>n\\<ge>M. dist (X m) (X n) < e \\<Longrightarrow>\n       \\<exists>L.\n          \\<forall>r>0. \\<exists>no. \\<forall>n\\<ge>no. dist (X n) L < r", "by metis"], ["", "end"], ["", "lemma bounded_antilinear_to_conjugate_space[simp]: \\<open>bounded_antilinear to_conjugate_space\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear to_conjugate_space", "by (rule bounded_antilinear_intro[where K=1]; transfer; auto)"], ["", "lemma bounded_antilinear_from_conjugate_space[simp]: \\<open>bounded_antilinear from_conjugate_space\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_antilinear from_conjugate_space", "by (rule bounded_antilinear_intro[where K=1]; transfer; auto)"], ["", "lemma antilinear_to_conjugate_space[simp]: \\<open>antilinear to_conjugate_space\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. antilinear to_conjugate_space", "by (rule antilinearI; transfer, auto)"], ["", "lemma antilinear_from_conjugate_space[simp]: \\<open>antilinear from_conjugate_space\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. antilinear from_conjugate_space", "by (rule antilinearI; transfer, auto)"], ["", "lemma cspan_to_conjugate_space[simp]: \"cspan (to_conjugate_space ` X) = to_conjugate_space ` cspan X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (to_conjugate_space ` X) = to_conjugate_space ` cspan X", "unfolding complex_vector.span_def complex_vector.subspace_def hull_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter>\n     {t. (0 \\<in> t \\<and>\n          (\\<forall>x\\<in>t. \\<forall>y\\<in>t. x + y \\<in> t) \\<and>\n          (\\<forall>c. \\<forall>x\\<in>t. c *\\<^sub>C x \\<in> t)) \\<and>\n         to_conjugate_space ` X \\<subseteq> t} =\n    to_conjugate_space `\n    \\<Inter>\n     {t. ((0::'a) \\<in> t \\<and>\n          (\\<forall>x\\<in>t. \\<forall>y\\<in>t. x + y \\<in> t) \\<and>\n          (\\<forall>c. \\<forall>x\\<in>t. c *\\<^sub>C x \\<in> t)) \\<and>\n         X \\<subseteq> t}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<Inter>\n        {t. ((0::'a) \\<in> t \\<and>\n             (\\<forall>x\\<in>t. \\<forall>y\\<in>t. x + y \\<in> t) \\<and>\n             (\\<forall>c.\n                 \\<forall>x\\<in>t. cnj c *\\<^sub>C x \\<in> t)) \\<and>\n            (\\<lambda>x. x) ` X \\<subseteq> t} =\n       (\\<lambda>x. x) `\n       \\<Inter>\n        {t. ((0::'a) \\<in> t \\<and>\n             (\\<forall>x\\<in>t. \\<forall>y\\<in>t. x + y \\<in> t) \\<and>\n             (\\<forall>c. \\<forall>x\\<in>t. c *\\<^sub>C x \\<in> t)) \\<and>\n            X \\<subseteq> t}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<Inter>\n        {t. (0::'a) \\<in> t \\<and>\n            (\\<forall>x\\<in>t. \\<forall>y\\<in>t. x + y \\<in> t) \\<and>\n            (\\<forall>c. \\<forall>x\\<in>t. cnj c *\\<^sub>C x \\<in> t) \\<and>\n            X \\<subseteq> t} =\n       \\<Inter>\n        {t. (0::'a) \\<in> t \\<and>\n            (\\<forall>x\\<in>t. \\<forall>y\\<in>t. x + y \\<in> t) \\<and>\n            (\\<forall>c. \\<forall>x\\<in>t. c *\\<^sub>C x \\<in> t) \\<and>\n            X \\<subseteq> t}", "by (metis (no_types, hide_lams) complex_cnj_cnj)"], ["", "lemma surj_to_conjugate_space[simp]: \"surj to_conjugate_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj to_conjugate_space", "by (meson surj_def to_conjugate_space_cases)"], ["", "lemmas has_derivative_scaleC[simp, derivative_intros] =\n  bounded_bilinear.FDERIV[OF bounded_cbilinear_scaleC[THEN bounded_cbilinear.bounded_bilinear]]"], ["", "lemma norm_to_conjugate_space[simp]: \\<open>norm (to_conjugate_space x) = norm x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (to_conjugate_space x) = norm x", "by (fact norm_conjugate_space.abs_eq)"], ["", "lemma norm_from_conjugate_space[simp]: \\<open>norm (from_conjugate_space x) = norm x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (from_conjugate_space x) = norm x", "by (simp add: norm_conjugate_space.rep_eq)"], ["", "lemma closure_to_conjugate_space: \\<open>closure (to_conjugate_space ` X) = to_conjugate_space ` closure X\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (to_conjugate_space ` X) = to_conjugate_space ` closure X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closure (to_conjugate_space ` X) = to_conjugate_space ` closure X", "have 1: \\<open>to_conjugate_space ` closure X \\<subseteq> closure (to_conjugate_space ` X)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_conjugate_space ` closure X\n    \\<subseteq> closure (to_conjugate_space ` X)", "apply (rule closure_bounded_linear_image_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear to_conjugate_space", "by (simp add: bounded_antilinear.bounded_linear)"], ["proof (state)\nthis:\n  to_conjugate_space ` closure X\n  \\<subseteq> closure (to_conjugate_space ` X)\n\ngoal (1 subgoal):\n 1. closure (to_conjugate_space ` X) = to_conjugate_space ` closure X", "have \\<open>\\<dots> = to_conjugate_space ` from_conjugate_space ` closure (to_conjugate_space ` X)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (to_conjugate_space ` X) =\n    to_conjugate_space `\n    from_conjugate_space ` closure (to_conjugate_space ` X)", "by (simp add: from_conjugate_space_inverse image_image)"], ["proof (state)\nthis:\n  closure (to_conjugate_space ` X) =\n  to_conjugate_space `\n  from_conjugate_space ` closure (to_conjugate_space ` X)\n\ngoal (1 subgoal):\n 1. closure (to_conjugate_space ` X) = to_conjugate_space ` closure X", "also"], ["proof (state)\nthis:\n  closure (to_conjugate_space ` X) =\n  to_conjugate_space `\n  from_conjugate_space ` closure (to_conjugate_space ` X)\n\ngoal (1 subgoal):\n 1. closure (to_conjugate_space ` X) = to_conjugate_space ` closure X", "have \\<open>\\<dots> \\<subseteq> to_conjugate_space ` closure (from_conjugate_space ` to_conjugate_space ` X)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_conjugate_space `\n    from_conjugate_space ` closure (to_conjugate_space ` X)\n    \\<subseteq> to_conjugate_space `\n                closure (from_conjugate_space ` to_conjugate_space ` X)", "apply (rule image_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. from_conjugate_space ` closure (to_conjugate_space ` X)\n    \\<subseteq> closure (from_conjugate_space ` to_conjugate_space ` X)", "apply (rule closure_bounded_linear_image_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear from_conjugate_space", "by (simp add: bounded_antilinear.bounded_linear)"], ["proof (state)\nthis:\n  to_conjugate_space `\n  from_conjugate_space ` closure (to_conjugate_space ` X)\n  \\<subseteq> to_conjugate_space `\n              closure (from_conjugate_space ` to_conjugate_space ` X)\n\ngoal (1 subgoal):\n 1. closure (to_conjugate_space ` X) = to_conjugate_space ` closure X", "also"], ["proof (state)\nthis:\n  to_conjugate_space `\n  from_conjugate_space ` closure (to_conjugate_space ` X)\n  \\<subseteq> to_conjugate_space `\n              closure (from_conjugate_space ` to_conjugate_space ` X)\n\ngoal (1 subgoal):\n 1. closure (to_conjugate_space ` X) = to_conjugate_space ` closure X", "have \\<open>\\<dots> = to_conjugate_space ` closure X\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_conjugate_space `\n    closure (from_conjugate_space ` to_conjugate_space ` X) =\n    to_conjugate_space ` closure X", "by (simp add: to_conjugate_space_inverse image_image)"], ["proof (state)\nthis:\n  to_conjugate_space `\n  closure (from_conjugate_space ` to_conjugate_space ` X) =\n  to_conjugate_space ` closure X\n\ngoal (1 subgoal):\n 1. closure (to_conjugate_space ` X) = to_conjugate_space ` closure X", "finally"], ["proof (chain)\npicking this:\n  closure (to_conjugate_space ` X)\n  \\<subseteq> to_conjugate_space ` closure X", "show ?thesis"], ["proof (prove)\nusing this:\n  closure (to_conjugate_space ` X)\n  \\<subseteq> to_conjugate_space ` closure X\n\ngoal (1 subgoal):\n 1. closure (to_conjugate_space ` X) = to_conjugate_space ` closure X", "using 1"], ["proof (prove)\nusing this:\n  closure (to_conjugate_space ` X)\n  \\<subseteq> to_conjugate_space ` closure X\n  to_conjugate_space ` closure X\n  \\<subseteq> closure (to_conjugate_space ` X)\n\ngoal (1 subgoal):\n 1. closure (to_conjugate_space ` X) = to_conjugate_space ` closure X", "by simp"], ["proof (state)\nthis:\n  closure (to_conjugate_space ` X) = to_conjugate_space ` closure X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closure_from_conjugate_space: \\<open>closure (from_conjugate_space ` X) = from_conjugate_space ` closure X\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (from_conjugate_space ` X) = from_conjugate_space ` closure X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closure (from_conjugate_space ` X) = from_conjugate_space ` closure X", "have 1: \\<open>from_conjugate_space ` closure X \\<subseteq> closure (from_conjugate_space ` X)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. from_conjugate_space ` closure X\n    \\<subseteq> closure (from_conjugate_space ` X)", "apply (rule closure_bounded_linear_image_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear from_conjugate_space", "by (simp add: bounded_antilinear.bounded_linear)"], ["proof (state)\nthis:\n  from_conjugate_space ` closure X\n  \\<subseteq> closure (from_conjugate_space ` X)\n\ngoal (1 subgoal):\n 1. closure (from_conjugate_space ` X) = from_conjugate_space ` closure X", "have \\<open>\\<dots> = from_conjugate_space ` to_conjugate_space ` closure (from_conjugate_space ` X)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (from_conjugate_space ` X) =\n    from_conjugate_space `\n    to_conjugate_space ` closure (from_conjugate_space ` X)", "by (simp add: to_conjugate_space_inverse image_image)"], ["proof (state)\nthis:\n  closure (from_conjugate_space ` X) =\n  from_conjugate_space `\n  to_conjugate_space ` closure (from_conjugate_space ` X)\n\ngoal (1 subgoal):\n 1. closure (from_conjugate_space ` X) = from_conjugate_space ` closure X", "also"], ["proof (state)\nthis:\n  closure (from_conjugate_space ` X) =\n  from_conjugate_space `\n  to_conjugate_space ` closure (from_conjugate_space ` X)\n\ngoal (1 subgoal):\n 1. closure (from_conjugate_space ` X) = from_conjugate_space ` closure X", "have \\<open>\\<dots> \\<subseteq> from_conjugate_space ` closure (to_conjugate_space ` from_conjugate_space ` X)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. from_conjugate_space `\n    to_conjugate_space ` closure (from_conjugate_space ` X)\n    \\<subseteq> from_conjugate_space `\n                closure (to_conjugate_space ` from_conjugate_space ` X)", "apply (rule image_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_conjugate_space ` closure (from_conjugate_space ` X)\n    \\<subseteq> closure (to_conjugate_space ` from_conjugate_space ` X)", "apply (rule closure_bounded_linear_image_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear to_conjugate_space", "by (simp add: bounded_antilinear.bounded_linear)"], ["proof (state)\nthis:\n  from_conjugate_space `\n  to_conjugate_space ` closure (from_conjugate_space ` X)\n  \\<subseteq> from_conjugate_space `\n              closure (to_conjugate_space ` from_conjugate_space ` X)\n\ngoal (1 subgoal):\n 1. closure (from_conjugate_space ` X) = from_conjugate_space ` closure X", "also"], ["proof (state)\nthis:\n  from_conjugate_space `\n  to_conjugate_space ` closure (from_conjugate_space ` X)\n  \\<subseteq> from_conjugate_space `\n              closure (to_conjugate_space ` from_conjugate_space ` X)\n\ngoal (1 subgoal):\n 1. closure (from_conjugate_space ` X) = from_conjugate_space ` closure X", "have \\<open>\\<dots> = from_conjugate_space ` closure X\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. from_conjugate_space `\n    closure (to_conjugate_space ` from_conjugate_space ` X) =\n    from_conjugate_space ` closure X", "by (simp add: from_conjugate_space_inverse image_image)"], ["proof (state)\nthis:\n  from_conjugate_space `\n  closure (to_conjugate_space ` from_conjugate_space ` X) =\n  from_conjugate_space ` closure X\n\ngoal (1 subgoal):\n 1. closure (from_conjugate_space ` X) = from_conjugate_space ` closure X", "finally"], ["proof (chain)\npicking this:\n  closure (from_conjugate_space ` X)\n  \\<subseteq> from_conjugate_space ` closure X", "show ?thesis"], ["proof (prove)\nusing this:\n  closure (from_conjugate_space ` X)\n  \\<subseteq> from_conjugate_space ` closure X\n\ngoal (1 subgoal):\n 1. closure (from_conjugate_space ` X) = from_conjugate_space ` closure X", "using 1"], ["proof (prove)\nusing this:\n  closure (from_conjugate_space ` X)\n  \\<subseteq> from_conjugate_space ` closure X\n  from_conjugate_space ` closure X\n  \\<subseteq> closure (from_conjugate_space ` X)\n\ngoal (1 subgoal):\n 1. closure (from_conjugate_space ` X) = from_conjugate_space ` closure X", "by simp"], ["proof (state)\nthis:\n  closure (from_conjugate_space ` X) = from_conjugate_space ` closure X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bounded_antilinear_eq_on:\n  fixes A B :: \"'a::complex_normed_vector \\<Rightarrow> 'b::complex_normed_vector\"\n  assumes \\<open>bounded_antilinear A\\<close> and \\<open>bounded_antilinear B\\<close> and\n    eq: \\<open>\\<And>x. x \\<in> G \\<Longrightarrow> A x = B x\\<close> and t: \\<open>t \\<in> closure (cspan G)\\<close>\n  shows \\<open>A t = B t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A t = B t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A t = B t", "let ?A = \\<open>\\<lambda>x. A (from_conjugate_space x)\\<close> and ?B = \\<open>\\<lambda>x. B (from_conjugate_space x)\\<close>\n    and ?G = \\<open>to_conjugate_space ` G\\<close> and ?t = \\<open>to_conjugate_space t\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. A t = B t", "have \\<open>bounded_clinear ?A\\<close> and \\<open>bounded_clinear ?B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_clinear (\\<lambda>x. A (from_conjugate_space x)) &&&\n    bounded_clinear (\\<lambda>x. B (from_conjugate_space x))", "by (auto intro!: bounded_antilinear_o_bounded_antilinear[OF \\<open>bounded_antilinear A\\<close>]\n        bounded_antilinear_o_bounded_antilinear[OF \\<open>bounded_antilinear B\\<close>])"], ["proof (state)\nthis:\n  bounded_clinear (\\<lambda>x. A (from_conjugate_space x))\n  bounded_clinear (\\<lambda>x. B (from_conjugate_space x))\n\ngoal (1 subgoal):\n 1. A t = B t", "moreover"], ["proof (state)\nthis:\n  bounded_clinear (\\<lambda>x. A (from_conjugate_space x))\n  bounded_clinear (\\<lambda>x. B (from_conjugate_space x))\n\ngoal (1 subgoal):\n 1. A t = B t", "from eq"], ["proof (chain)\npicking this:\n  ?x \\<in> G \\<Longrightarrow> A ?x = B ?x", "have \\<open>\\<And>x. x \\<in> ?G \\<Longrightarrow> ?A x = ?B x\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> G \\<Longrightarrow> A ?x = B ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> to_conjugate_space ` G \\<Longrightarrow>\n       A (from_conjugate_space x) = B (from_conjugate_space x)", "by (metis image_iff iso_tuple_UNIV_I to_conjugate_space_inverse)"], ["proof (state)\nthis:\n  ?x \\<in> to_conjugate_space ` G \\<Longrightarrow>\n  A (from_conjugate_space ?x) = B (from_conjugate_space ?x)\n\ngoal (1 subgoal):\n 1. A t = B t", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> to_conjugate_space ` G \\<Longrightarrow>\n  A (from_conjugate_space ?x) = B (from_conjugate_space ?x)\n\ngoal (1 subgoal):\n 1. A t = B t", "from t"], ["proof (chain)\npicking this:\n  t \\<in> closure (cspan G)", "have \\<open>?t \\<in> closure (cspan ?G)\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> closure (cspan G)\n\ngoal (1 subgoal):\n 1. to_conjugate_space t \\<in> closure (cspan (to_conjugate_space ` G))", "by (metis bounded_antilinear.bounded_linear bounded_antilinear_to_conjugate_space closure_bounded_linear_image_subset cspan_to_conjugate_space imageI subsetD)"], ["proof (state)\nthis:\n  to_conjugate_space t \\<in> closure (cspan (to_conjugate_space ` G))\n\ngoal (1 subgoal):\n 1. A t = B t", "ultimately"], ["proof (chain)\npicking this:\n  bounded_clinear (\\<lambda>x. A (from_conjugate_space x))\n  bounded_clinear (\\<lambda>x. B (from_conjugate_space x))\n  ?x \\<in> to_conjugate_space ` G \\<Longrightarrow>\n  A (from_conjugate_space ?x) = B (from_conjugate_space ?x)\n  to_conjugate_space t \\<in> closure (cspan (to_conjugate_space ` G))", "have \\<open>?A ?t = ?B ?t\\<close>"], ["proof (prove)\nusing this:\n  bounded_clinear (\\<lambda>x. A (from_conjugate_space x))\n  bounded_clinear (\\<lambda>x. B (from_conjugate_space x))\n  ?x \\<in> to_conjugate_space ` G \\<Longrightarrow>\n  A (from_conjugate_space ?x) = B (from_conjugate_space ?x)\n  to_conjugate_space t \\<in> closure (cspan (to_conjugate_space ` G))\n\ngoal (1 subgoal):\n 1. A (from_conjugate_space (to_conjugate_space t)) =\n    B (from_conjugate_space (to_conjugate_space t))", "by (rule bounded_clinear_eq_on)"], ["proof (state)\nthis:\n  A (from_conjugate_space (to_conjugate_space t)) =\n  B (from_conjugate_space (to_conjugate_space t))\n\ngoal (1 subgoal):\n 1. A t = B t", "then"], ["proof (chain)\npicking this:\n  A (from_conjugate_space (to_conjugate_space t)) =\n  B (from_conjugate_space (to_conjugate_space t))", "show \\<open>A t = B t\\<close>"], ["proof (prove)\nusing this:\n  A (from_conjugate_space (to_conjugate_space t)) =\n  B (from_conjugate_space (to_conjugate_space t))\n\ngoal (1 subgoal):\n 1. A t = B t", "by (simp add: to_conjugate_space_inverse)"], ["proof (state)\nthis:\n  A t = B t\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation complex :: basis_enum begin"], ["", "definition \"canonical_basis = [1::complex]\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(complex, basis_enum_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct canonical_basis\n 2. cindependent (set canonical_basis)\n 3. cspan (set canonical_basis) = UNIV", "show \"distinct (canonical_basis::complex list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct canonical_basis", "by (simp add: canonical_basis_complex_def)"], ["proof (state)\nthis:\n  distinct canonical_basis\n\ngoal (2 subgoals):\n 1. cindependent (set canonical_basis)\n 2. cspan (set canonical_basis) = UNIV", "show \"cindependent (set (canonical_basis::complex list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent (set canonical_basis)", "unfolding canonical_basis_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cindependent (set [1])", "by auto"], ["proof (state)\nthis:\n  cindependent (set canonical_basis)\n\ngoal (1 subgoal):\n 1. cspan (set canonical_basis) = UNIV", "show \"cspan (set (canonical_basis::complex list)) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (set canonical_basis) = UNIV", "unfolding canonical_basis_complex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cspan (set [1]) = UNIV", "apply (auto simp add: cspan_raw_def vector_space_over_itself.span_Basis)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> module.span (*\\<^sub>C) {1}", "by (metis complex_scaleC_def complex_vector.span_base complex_vector.span_scale cspan_raw_def insertI1 mult.right_neutral)"], ["proof (state)\nthis:\n  cspan (set canonical_basis) = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma csubspace_is_convex[simp]:\n  assumes a1: \"csubspace M\"\n  shows \"convex M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convex M", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. convex M", "have \\<open>\\<forall>x\\<in>M. \\<forall>y\\<in> M. \\<forall>u. \\<forall>v. u *\\<^sub>C x + v *\\<^sub>C y \\<in>  M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>M.\n       \\<forall>y\\<in>M. \\<forall>u v. u *\\<^sub>C x + v *\\<^sub>C y \\<in> M", "using a1"], ["proof (prove)\nusing this:\n  csubspace M\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>M.\n       \\<forall>y\\<in>M. \\<forall>u v. u *\\<^sub>C x + v *\\<^sub>C y \\<in> M", "by (simp add:  complex_vector.subspace_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>M.\n     \\<forall>y\\<in>M. \\<forall>u v. u *\\<^sub>C x + v *\\<^sub>C y \\<in> M\n\ngoal (1 subgoal):\n 1. convex M", "hence \\<open>\\<forall>x\\<in>M. \\<forall>y\\<in>M. \\<forall>u::real. \\<forall>v::real. u *\\<^sub>R x + v *\\<^sub>R y \\<in> M\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>M.\n     \\<forall>y\\<in>M. \\<forall>u v. u *\\<^sub>C x + v *\\<^sub>C y \\<in> M\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>M.\n       \\<forall>y\\<in>M. \\<forall>u v. u *\\<^sub>R x + v *\\<^sub>R y \\<in> M", "by (simp add: scaleR_scaleC)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>M.\n     \\<forall>y\\<in>M. \\<forall>u v. u *\\<^sub>R x + v *\\<^sub>R y \\<in> M\n\ngoal (1 subgoal):\n 1. convex M", "hence \\<open>\\<forall>x\\<in>M. \\<forall>y\\<in>M. \\<forall>u\\<ge>0. \\<forall>v\\<ge>0. u + v = 1 \\<longrightarrow> u *\\<^sub>R x + v *\\<^sub>R y \\<in>M\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>M.\n     \\<forall>y\\<in>M. \\<forall>u v. u *\\<^sub>R x + v *\\<^sub>R y \\<in> M\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>M.\n       \\<forall>y\\<in>M.\n          \\<forall>u\\<ge>0.\n             \\<forall>v\\<ge>0.\n                u + v = 1 \\<longrightarrow>\n                u *\\<^sub>R x + v *\\<^sub>R y \\<in> M", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>M.\n     \\<forall>y\\<in>M.\n        \\<forall>u\\<ge>0.\n           \\<forall>v\\<ge>0.\n              u + v = 1 \\<longrightarrow>\n              u *\\<^sub>R x + v *\\<^sub>R y \\<in> M\n\ngoal (1 subgoal):\n 1. convex M", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>M.\n     \\<forall>y\\<in>M.\n        \\<forall>u\\<ge>0.\n           \\<forall>v\\<ge>0.\n              u + v = 1 \\<longrightarrow>\n              u *\\<^sub>R x + v *\\<^sub>R y \\<in> M\n\ngoal (1 subgoal):\n 1. convex M", "using convex_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>M.\n     \\<forall>y\\<in>M.\n        \\<forall>u\\<ge>0.\n           \\<forall>v\\<ge>0.\n              u + v = 1 \\<longrightarrow>\n              u *\\<^sub>R x + v *\\<^sub>R y \\<in> M\n  convex ?s =\n  (\\<forall>x\\<in>?s.\n      \\<forall>y\\<in>?s.\n         \\<forall>u\\<ge>0.\n            \\<forall>v\\<ge>0.\n               u + v = 1 \\<longrightarrow>\n               u *\\<^sub>R x + v *\\<^sub>R y \\<in> ?s)\n\ngoal (1 subgoal):\n 1. convex M", "by blast"], ["proof (state)\nthis:\n  convex M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kernel_is_csubspace[simp]:\n  assumes a1: \"clinear f\"\n  shows \"csubspace  (f -` {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "have w3: \\<open>t *\\<^sub>C x \\<in> {x. f x = 0}\\<close> \n    if b1: \"x \\<in> {x. f x = 0}\"\n    for x t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t *\\<^sub>C x \\<in> {x. f x = (0::'b)}", "by (metis assms complex_vector.linear_subspace_kernel complex_vector.subspace_def that)"], ["proof (state)\nthis:\n  ?x \\<in> {x. f x = (0::'b)} \\<Longrightarrow>\n  ?t *\\<^sub>C ?x \\<in> {x. f x = (0::'b)}\n\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "have \\<open>f 0 = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (0::'a) = (0::'b)", "by (simp add: assms complex_vector.linear_0)"], ["proof (state)\nthis:\n  f (0::'a) = (0::'b)\n\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "hence s2: \\<open>0 \\<in> {x. f x = 0}\\<close>"], ["proof (prove)\nusing this:\n  f (0::'a) = (0::'b)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<in> {x. f x = (0::'b)}", "by blast"], ["proof (state)\nthis:\n  (0::'a) \\<in> {x. f x = (0::'b)}\n\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "have w4: \"x + y \\<in> {x. f x = 0}\"\n    if c1: \"x \\<in> {x. f x = 0}\" and c2: \"y \\<in> {x. f x = 0}\"\n    for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<in> {x. f x = (0::'b)}", "using assms c1 c2 complex_vector.linear_add"], ["proof (prove)\nusing this:\n  clinear f\n  x \\<in> {x. f x = (0::'b)}\n  y \\<in> {x. f x = (0::'b)}\n  clinear ?f \\<Longrightarrow> ?f (?b1.0 + ?b2.0) = ?f ?b1.0 + ?f ?b2.0\n\ngoal (1 subgoal):\n 1. x + y \\<in> {x. f x = (0::'b)}", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> {x. f x = (0::'b)}; ?y \\<in> {x. f x = (0::'b)}\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<in> {x. f x = (0::'b)}\n\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "have s4: \\<open>c *\\<^sub>C t \\<in> {x. f x = 0}\\<close> \n    if \"t \\<in> {x. f x = 0}\"\n    for t c"], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>C t \\<in> {x. f x = (0::'b)}", "using that w3"], ["proof (prove)\nusing this:\n  t \\<in> {x. f x = (0::'b)}\n  ?x \\<in> {x. f x = (0::'b)} \\<Longrightarrow>\n  ?t *\\<^sub>C ?x \\<in> {x. f x = (0::'b)}\n\ngoal (1 subgoal):\n 1. c *\\<^sub>C t \\<in> {x. f x = (0::'b)}", "by auto"], ["proof (state)\nthis:\n  ?t \\<in> {x. f x = (0::'b)} \\<Longrightarrow>\n  ?c *\\<^sub>C ?t \\<in> {x. f x = (0::'b)}\n\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "have s5: \"u + v \\<in> {x. f x = 0}\"\n    if \"u \\<in> {x. f x = 0}\" and \"v \\<in> {x. f x = 0}\"\n    for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. u + v \\<in> {x. f x = (0::'b)}", "using w4 that(1) that(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> {x. f x = (0::'b)}; ?y \\<in> {x. f x = (0::'b)}\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<in> {x. f x = (0::'b)}\n  u \\<in> {x. f x = (0::'b)}\n  v \\<in> {x. f x = (0::'b)}\n\ngoal (1 subgoal):\n 1. u + v \\<in> {x. f x = (0::'b)}", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?u \\<in> {x. f x = (0::'b)}; ?v \\<in> {x. f x = (0::'b)}\\<rbrakk>\n  \\<Longrightarrow> ?u + ?v \\<in> {x. f x = (0::'b)}\n\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "have f3: \"f -` {b. b = 0 \\<or> b \\<in> {}} = {a. f a = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f -` {b. b = (0::'b) \\<or> b \\<in> {}} = {a. f a = (0::'b)}", "by blast"], ["proof (state)\nthis:\n  f -` {b. b = (0::'b) \\<or> b \\<in> {}} = {a. f a = (0::'b)}\n\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "have \"csubspace {a. f a = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace {a. f a = (0::'b)}", "by (metis complex_vector.subspace_def s2 s4 s5)"], ["proof (state)\nthis:\n  csubspace {a. f a = (0::'b)}\n\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "thus ?thesis"], ["proof (prove)\nusing this:\n  csubspace {a. f a = (0::'b)}\n\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "using f3"], ["proof (prove)\nusing this:\n  csubspace {a. f a = (0::'b)}\n  f -` {b. b = (0::'b) \\<or> b \\<in> {}} = {a. f a = (0::'b)}\n\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "by auto"], ["proof (state)\nthis:\n  csubspace (f -` {0::'b})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kernel_is_closed_csubspace[simp]:\n  assumes a1: \"bounded_clinear f\"\n  shows \"closed_csubspace (f -` {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_csubspace (f -` {0::'b})", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. closed_csubspace (f -` {0::'b})", "have \\<open>csubspace (f -` {0})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "using assms bounded_clinear.clinear complex_vector.linear_subspace_vimage complex_vector.subspace_single_0"], ["proof (prove)\nusing this:\n  bounded_clinear f\n  bounded_clinear ?f \\<Longrightarrow> clinear ?f\n  \\<lbrakk>clinear ?f; csubspace ?S\\<rbrakk>\n  \\<Longrightarrow> csubspace (?f -` ?S)\n  csubspace {0::?'a}\n\ngoal (1 subgoal):\n 1. csubspace (f -` {0::'b})", "by blast"], ["proof (state)\nthis:\n  csubspace (f -` {0::'b})\n\ngoal (1 subgoal):\n 1. closed_csubspace (f -` {0::'b})", "have \"L \\<in> {x. f x = 0}\"\n    if \"r \\<longlonglongrightarrow> L\" and \"\\<forall> n. r n \\<in> {x. f x = 0}\"\n    for r and  L"], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<in> {x. f x = (0::'b)}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. L \\<in> {x. f x = (0::'b)}", "have d1: \\<open>\\<forall> n. f (r n) = 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. f (r n) = (0::'b)", "using that(2)"], ["proof (prove)\nusing this:\n  \\<forall>n. r n \\<in> {x. f x = (0::'b)}\n\ngoal (1 subgoal):\n 1. \\<forall>n. f (r n) = (0::'b)", "by auto"], ["proof (state)\nthis:\n  \\<forall>n. f (r n) = (0::'b)\n\ngoal (1 subgoal):\n 1. L \\<in> {x. f x = (0::'b)}", "have \\<open>(\\<lambda> n. f (r n)) \\<longlonglongrightarrow> f L\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (r n)) \\<longlonglongrightarrow> f L", "using assms clinear_continuous_at continuous_within_tendsto_compose' that(1)"], ["proof (prove)\nusing this:\n  bounded_clinear f\n  bounded_clinear ?f \\<Longrightarrow> isCont ?f ?x\n  \\<lbrakk>continuous (at ?a within ?s) ?f; \\<And>n. ?x n \\<in> ?s;\n   (?x \\<longlongrightarrow> ?a) ?F\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>n. ?f (?x n)) \\<longlongrightarrow> ?f ?a) ?F\n  r \\<longlonglongrightarrow> L\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. f (r n)) \\<longlonglongrightarrow> f L", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>n. f (r n)) \\<longlonglongrightarrow> f L\n\ngoal (1 subgoal):\n 1. L \\<in> {x. f x = (0::'b)}", "hence \\<open>(\\<lambda> n. 0) \\<longlonglongrightarrow> f L\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. f (r n)) \\<longlonglongrightarrow> f L\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 0::'b) \\<longlonglongrightarrow> f L", "using d1"], ["proof (prove)\nusing this:\n  (\\<lambda>n. f (r n)) \\<longlonglongrightarrow> f L\n  \\<forall>n. f (r n) = (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 0::'b) \\<longlonglongrightarrow> f L", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. 0::'b) \\<longlonglongrightarrow> f L\n\ngoal (1 subgoal):\n 1. L \\<in> {x. f x = (0::'b)}", "hence \\<open>f L = 0\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>n. 0::'b) \\<longlonglongrightarrow> f L\n\ngoal (1 subgoal):\n 1. f L = (0::'b)", "using limI"], ["proof (prove)\nusing this:\n  (\\<lambda>n. 0::'b) \\<longlonglongrightarrow> f L\n  ?X \\<longlonglongrightarrow> ?L \\<Longrightarrow> lim ?X = ?L\n\ngoal (1 subgoal):\n 1. f L = (0::'b)", "by fastforce"], ["proof (state)\nthis:\n  f L = (0::'b)\n\ngoal (1 subgoal):\n 1. L \\<in> {x. f x = (0::'b)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  f L = (0::'b)\n\ngoal (1 subgoal):\n 1. L \\<in> {x. f x = (0::'b)}", "by blast"], ["proof (state)\nthis:\n  L \\<in> {x. f x = (0::'b)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?r \\<longlonglongrightarrow> ?L;\n   \\<forall>n. ?r n \\<in> {x. f x = (0::'b)}\\<rbrakk>\n  \\<Longrightarrow> ?L \\<in> {x. f x = (0::'b)}\n\ngoal (1 subgoal):\n 1. closed_csubspace (f -` {0::'b})", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?r \\<longlonglongrightarrow> ?L;\n   \\<forall>n. ?r n \\<in> {x. f x = (0::'b)}\\<rbrakk>\n  \\<Longrightarrow> ?L \\<in> {x. f x = (0::'b)}", "have s3: \\<open>closed (f -` {0})\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r \\<longlonglongrightarrow> ?L;\n   \\<forall>n. ?r n \\<in> {x. f x = (0::'b)}\\<rbrakk>\n  \\<Longrightarrow> ?L \\<in> {x. f x = (0::'b)}\n\ngoal (1 subgoal):\n 1. closed (f -` {0::'b})", "using closed_sequential_limits"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r \\<longlonglongrightarrow> ?L;\n   \\<forall>n. ?r n \\<in> {x. f x = (0::'b)}\\<rbrakk>\n  \\<Longrightarrow> ?L \\<in> {x. f x = (0::'b)}\n  closed ?S =\n  (\\<forall>x l.\n      (\\<forall>n. x n \\<in> ?S) \\<and>\n      x \\<longlonglongrightarrow> l \\<longrightarrow>\n      l \\<in> ?S)\n\ngoal (1 subgoal):\n 1. closed (f -` {0::'b})", "by force"], ["proof (state)\nthis:\n  closed (f -` {0::'b})\n\ngoal (1 subgoal):\n 1. closed_csubspace (f -` {0::'b})", "with \\<open>csubspace (f -` {0})\\<close>"], ["proof (chain)\npicking this:\n  csubspace (f -` {0::'b})\n  closed (f -` {0::'b})", "show ?thesis"], ["proof (prove)\nusing this:\n  csubspace (f -` {0::'b})\n  closed (f -` {0::'b})\n\ngoal (1 subgoal):\n 1. closed_csubspace (f -` {0::'b})", "using closed_csubspace.intro"], ["proof (prove)\nusing this:\n  csubspace (f -` {0::'b})\n  closed (f -` {0::'b})\n  \\<lbrakk>csubspace ?A; closed ?A\\<rbrakk>\n  \\<Longrightarrow> closed_csubspace ?A\n\ngoal (1 subgoal):\n 1. closed_csubspace (f -` {0::'b})", "by blast"], ["proof (state)\nthis:\n  closed_csubspace (f -` {0::'b})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma range_is_clinear[simp]:\n  assumes a1: \"clinear f\"\n  shows \"csubspace (range f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csubspace (range f)", "using assms complex_vector.linear_subspace_image complex_vector.subspace_UNIV"], ["proof (prove)\nusing this:\n  clinear f\n  \\<lbrakk>clinear ?f; csubspace ?S\\<rbrakk>\n  \\<Longrightarrow> csubspace (?f ` ?S)\n  csubspace UNIV\n\ngoal (1 subgoal):\n 1. csubspace (range f)", "by blast"], ["", "lemma ccspan_superset:\n  \\<open>A \\<subseteq> space_as_set (ccspan A)\\<close> \n  for A :: \\<open>'a::complex_normed_vector set\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> space_as_set (ccspan A)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A. A \\<subseteq> closure (cspan A)", "by (meson closure_subset complex_vector.span_superset subset_trans)"], ["", "subsection \\<open>Product is a Complex Vector Space\\<close>"], ["", "(* Follows closely Product_Vector.thy *)"], ["", "instantiation prod :: (complex_vector, complex_vector) complex_vector\nbegin"], ["", "definition scaleC_prod_def:\n  \"scaleC r A = (scaleC r (fst A), scaleC r (snd A))\""], ["", "lemma fst_scaleC [simp]: \"fst (scaleC r A) = scaleC r (fst A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (r *\\<^sub>C A) = r *\\<^sub>C fst A", "unfolding scaleC_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (r *\\<^sub>C fst A, r *\\<^sub>C snd A) = r *\\<^sub>C fst A", "by simp"], ["", "lemma snd_scaleC [simp]: \"snd (scaleC r A) = scaleC r (snd A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (r *\\<^sub>C A) = r *\\<^sub>C snd A", "unfolding scaleC_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (r *\\<^sub>C fst A, r *\\<^sub>C snd A) = r *\\<^sub>C snd A", "by simp"], ["", "proposition scaleC_Pair [simp]: \"scaleC r (a, b) = (scaleC r a, scaleC r b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r *\\<^sub>C (a, b) = (r *\\<^sub>C a, r *\\<^sub>C b)", "unfolding scaleC_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (r *\\<^sub>C fst (a, b), r *\\<^sub>C snd (a, b)) =\n    (r *\\<^sub>C a, r *\\<^sub>C b)", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, complex_vector_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 3. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 4. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 5. \\<And>x. 1 *\\<^sub>C x = x", "fix a b :: complex and x y :: \"'a \\<times> 'b\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a x y. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n 3. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 4. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 5. \\<And>x. 1 *\\<^sub>C x = x", "show \"scaleC a (x + y) = scaleC a x + scaleC a y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y", "by (simp add: scaleC_add_right scaleC_prod_def)"], ["proof (state)\nthis:\n  a *\\<^sub>C (x + y) = a *\\<^sub>C x + a *\\<^sub>C y\n\ngoal (4 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a b x. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n 3. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 4. \\<And>x. 1 *\\<^sub>C x = x", "show \"scaleC (a + b) x = scaleC a x + scaleC b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x", "by (simp add: Complex_Vector_Spaces.scaleC_prod_def scaleC_left.add)"], ["proof (state)\nthis:\n  (a + b) *\\<^sub>C x = a *\\<^sub>C x + b *\\<^sub>C x\n\ngoal (3 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>a b x. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n 3. \\<And>x. 1 *\\<^sub>C x = x", "show \"scaleC a (scaleC b x) = scaleC (a * b) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x", "by (simp add: prod_eq_iff)"], ["proof (state)\nthis:\n  a *\\<^sub>C b *\\<^sub>C x = (a * b) *\\<^sub>C x\n\ngoal (2 subgoals):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)\n 2. \\<And>x. 1 *\\<^sub>C x = x", "show \"scaleC 1 x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 *\\<^sub>C x = x", "by (simp add: prod_eq_iff)"], ["proof (state)\nthis:\n  1 *\\<^sub>C x = x\n\ngoal (1 subgoal):\n 1. \\<And>r. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)", "show \\<open>(scaleR :: _ \\<Rightarrow> _ \\<Rightarrow> 'a*'b) r = (*\\<^sub>C) (complex_of_real r)\\<close> for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. (*\\<^sub>R) r = (*\\<^sub>C) (complex_of_real r)", "by (auto intro!: ext simp: scaleR_scaleC scaleC_prod_def scaleR_prod_def)"], ["proof (state)\nthis:\n  (*\\<^sub>R) ?r = (*\\<^sub>C) (complex_of_real ?r)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma module_prod_scale_eq_scaleC: \"module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = scaleC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = (*\\<^sub>C)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. module_prod.scale (*\\<^sub>C) (*\\<^sub>C) x = (*\\<^sub>C) x", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       module_prod.scale (*\\<^sub>C) (*\\<^sub>C) x xa = x *\\<^sub>C xa", "apply (subst module_prod.scale_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa. module_prod (*\\<^sub>C) (*\\<^sub>C)\n 2. \\<And>x xa. (x *\\<^sub>C fst xa, x *\\<^sub>C snd xa) = x *\\<^sub>C xa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_prod (*\\<^sub>C) (*\\<^sub>C)", "by unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. (x *\\<^sub>C fst xa, x *\\<^sub>C snd xa) = x *\\<^sub>C xa", "by (simp add: scaleC_prod_def)"], ["", "interpretation complex_vector?: vector_space_prod \"scaleC::_\\<Rightarrow>_\\<Rightarrow>'a::complex_vector\" \"scaleC::_\\<Rightarrow>_\\<Rightarrow>'b::complex_vector\"\n  rewrites \"scale = ((*\\<^sub>C)::_\\<Rightarrow>_\\<Rightarrow>('a \\<times> 'b))\"\n    and \"module.dependent (*\\<^sub>C) = cdependent\"\n    and \"module.representation (*\\<^sub>C) = crepresentation\"\n    and \"module.subspace (*\\<^sub>C) = csubspace\"\n    and \"module.span (*\\<^sub>C) = cspan\"\n    and \"vector_space.extend_basis (*\\<^sub>C) = cextend_basis\"\n    and \"vector_space.dim (*\\<^sub>C) = cdim\"\n    and \"Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((vector_space_prod (*\\<^sub>C) (*\\<^sub>C) &&&\n      module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = (*\\<^sub>C)) &&&\n     module.dependent (*\\<^sub>C) = cdependent &&&\n     module.representation (*\\<^sub>C) = crepresentation) &&&\n    (module.subspace (*\\<^sub>C) = csubspace &&&\n     module.span (*\\<^sub>C) = cspan) &&&\n    vector_space.extend_basis (*\\<^sub>C) = cextend_basis &&&\n    vector_space.dim (*\\<^sub>C) = cdim &&&\n    Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_space_prod (*\\<^sub>C) (*\\<^sub>C)", "by unfold_locales"], ["proof (prove)\ngoal (8 subgoals):\n 1. module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = (*\\<^sub>C)\n 2. module.dependent (*\\<^sub>C) = cdependent\n 3. module.representation (*\\<^sub>C) = crepresentation\n 4. module.subspace (*\\<^sub>C) = csubspace\n 5. module.span (*\\<^sub>C) = cspan\n 6. vector_space.extend_basis (*\\<^sub>C) = cextend_basis\n 7. vector_space.dim (*\\<^sub>C) = cdim\n 8. Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_prod.scale (*\\<^sub>C) (*\\<^sub>C) = (*\\<^sub>C)", "by (fact module_prod_scale_eq_scaleC)"], ["proof (prove)\ngoal (7 subgoals):\n 1. module.dependent (*\\<^sub>C) = cdependent\n 2. module.representation (*\\<^sub>C) = crepresentation\n 3. module.subspace (*\\<^sub>C) = csubspace\n 4. module.span (*\\<^sub>C) = cspan\n 5. vector_space.extend_basis (*\\<^sub>C) = cextend_basis\n 6. vector_space.dim (*\\<^sub>C) = cdim\n 7. Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) = clinear", "unfolding cdependent_raw_def crepresentation_raw_def csubspace_raw_def cspan_raw_def\n    cextend_basis_raw_def cdim_raw_def clinear_def"], ["proof (prove)\ngoal (7 subgoals):\n 1. module.dependent (*\\<^sub>C) = module.dependent (*\\<^sub>C)\n 2. module.representation (*\\<^sub>C) = module.representation (*\\<^sub>C)\n 3. module.subspace (*\\<^sub>C) = module.subspace (*\\<^sub>C)\n 4. module.span (*\\<^sub>C) = module.span (*\\<^sub>C)\n 5. vector_space.extend_basis (*\\<^sub>C) =\n    vector_space.extend_basis (*\\<^sub>C)\n 6. vector_space.dim (*\\<^sub>C) = vector_space.dim (*\\<^sub>C)\n 7. Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C) =\n    Vector_Spaces.linear (*\\<^sub>C) (*\\<^sub>C)", "by (rule refl)+"], ["", "subsection \\<open>Copying existing theorems into sublocales\\<close>"], ["", "context bounded_clinear begin"], ["", "interpretation bounded_linear f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear f", "by (rule bounded_linear)"], ["", "lemmas continuous = continuous"], ["", "lemmas uniform_limit = uniform_limit"], ["", "lemmas Cauchy = Cauchy"], ["", "end"], ["", "context bounded_antilinear begin"], ["", "interpretation bounded_linear f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear f", "by (rule bounded_linear)"], ["", "lemmas continuous = continuous"], ["", "lemmas uniform_limit = uniform_limit"], ["", "end"], ["", "context bounded_cbilinear begin"], ["", "interpretation bounded_bilinear prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_bilinear (**)", "by simp"], ["", "lemmas tendsto = tendsto"], ["", "lemmas isCont = isCont"], ["", "end"], ["", "context bounded_sesquilinear begin"], ["", "interpretation bounded_bilinear prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_bilinear (**)", "by simp"], ["", "lemmas tendsto = tendsto"], ["", "lemmas isCont = isCont"], ["", "end"], ["", "lemmas tendsto_scaleC [tendsto_intros] =\n  bounded_cbilinear.tendsto [OF bounded_cbilinear_scaleC]"], ["", "end"]]}