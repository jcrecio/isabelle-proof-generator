{"file_name": "/home/qj213/afp-2021-10-22/thys/Imperative_Insertion_Sort/Imperative_Insertion_Sort.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Imperative_Insertion_Sort", "problem_names": ["lemma insertion_sort_alt_def:\n  \"insertion_sort a = (Array.len a \\<bind> sort_upto a)\"", "lemma effect_shiftr_f:\n  assumes \"effect (shiftr_f a i) h h' u\"\n  shows \"Ref.get h' i = Ref.get h i - 1 \\<and>\n    Array.get h' a = list_update (Array.get h a) (Ref.get h i) (Array.get h a ! (Ref.get h i - 1))\"", "lemma success_shiftr_p:\n  \"Ref.get h i < Array.length h a \\<Longrightarrow> success (shiftr_p a key i) h\"", "lemma effect_shiftr:\n  assumes \"Ref.get h i = j\" (is \"?i h = _\")\n    and \"j < Array.length h a\"\n    and \"sorted (take j (Array.get h a))\"\n    and \"effect (while (shiftr_p a key i) (shiftr_f a i)) h h' u\"\n  shows \"Array.length h a = Array.length h' a \\<and>\n    ?i h' \\<le> j \\<and>\n    mset (list_update (Array.get h a) j key) =\n      mset (list_update (Array.get h' a) (?i h') key) \\<and>\n    ini h a j = both h' a j i \\<and>\n    sorted (both h' a j i) \\<and>\n    (\\<forall>x \\<in> set (right h' a j i). x > key)\"", "lemma sorted_take_nth:\n  assumes \"0 < i\" and \"i < length xs\" and \"xs ! (i - 1) \\<le> y\"\n    and \"sorted (take i xs)\"\n  shows \"\\<forall>x \\<in> set (take i xs). x \\<le> y\"", "lemma effect_for_insert_elt:\n  assumes \"l \\<le> Array.length h a\"\n    and \"1 \\<le> l\"\n    and \"effect (for [1 ..< l] (insert_elt a)) h h' u\"\n  shows \"Array.length h a = Array.length h' a \\<and>\n    sorted (take l (Array.get h' a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h' a)\"", "lemma effect_insertion_sort:\n  assumes \"effect (insertion_sort a) h h' u\"\n  shows \"mset (Array.get h a) = mset (Array.get h' a) \\<and> sorted (Array.get h' a)\"", "lemma success_shiftr_f:\n  assumes \"Ref.get h i < Array.length h a\"\n  shows \"success (shiftr_f a i) h\"", "lemma success_shiftr:\n  assumes \"Ref.get h i < Array.length h a\"\n  shows \"success (while (shiftr_p a key i) (shiftr_f a i)) h\"", "lemma effect_shiftr_index:\n  assumes \"effect (shiftr a key i) h h' u\"\n  shows \"Ref.get h' i \\<le> Ref.get h i\"", "lemma effect_shiftr_length:\n  assumes \"effect (shiftr a key i) h h' u\"\n  shows \"Array.length h' a = Array.length h a\"", "lemma success_insert_elt:\n  assumes \"k < Array.length h a\"\n  shows \"success (insert_elt a k) h\"", "lemma for_insert_elt_correct:\n  assumes \"l \\<le> Array.length h a\"\n    and \"1 \\<le> l\"\n  shows \"\\<exists>h'. effect (for [1 ..< l] (insert_elt a)) h h' () \\<and>\n    Array.length h a = Array.length h' a \\<and>\n    sorted (take l (Array.get h' a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h' a)\"", "lemma insertion_sort_correct:\n  \"\\<exists>h'. effect (insertion_sort a) h h' u \\<and>\n    mset (Array.get h a) = mset (Array.get h' a) \\<and>\n    sorted (Array.get h' a)\""], "translations": [["", "lemma insertion_sort_alt_def:\n  \"insertion_sort a = (Array.len a \\<bind> sort_upto a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion_sort a = Array.len a \\<bind> sort_upto a", "by (simp add: insertion_sort_def sort_upto_def shiftr_def shiftr_p_def shiftr_f_def insert_elt_def)"], ["", "subsection \\<open>Partial Correctness\\<close>"], ["", "lemma effect_shiftr_f:\n  assumes \"effect (shiftr_f a i) h h' u\"\n  shows \"Ref.get h' i = Ref.get h i - 1 \\<and>\n    Array.get h' a = list_update (Array.get h a) (Ref.get h i) (Array.get h a ! (Ref.get h i - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref.get h' i = Ref.get h i - 1 \\<and>\n    Array.get h' a = (Array.get h a)\n    [Ref.get h i := Array.get h a ! (Ref.get h i - 1)]", "using assms"], ["proof (prove)\nusing this:\n  effect (shiftr_f a i) h h' u\n\ngoal (1 subgoal):\n 1. Ref.get h' i = Ref.get h i - 1 \\<and>\n    Array.get h' a = (Array.get h a)\n    [Ref.get h i := Array.get h a ! (Ref.get h i - 1)]", "by (auto simp: shiftr_f_def elim!: effect_elims)"], ["", "lemma success_shiftr_p:\n  \"Ref.get h i < Array.length h a \\<Longrightarrow> success (shiftr_p a key i) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref.get h i < Array.length h a \\<Longrightarrow>\n    success (shiftr_p a key i) h", "by (auto simp: success_def shiftr_p_def execute_simps)"], ["", "interpretation ro_shiftr_p: ro_cond \"shiftr_p a key i\" for a key i"], ["proof (prove)\ngoal (1 subgoal):\n 1. ro_cond (shiftr_p a key i)", "by (unfold_locales)\n     (auto simp: shiftr_p_def success_def execute_simps execute_bind_case split: option.split, metis effectI effect_nthE)"], ["", "(*[0 .. j - 1]*)"], ["", "definition [simp]: \"ini h a j = take j (Array.get h a)\""], ["", "(*[0 .. i - 1]*)"], ["", "definition [simp]: \"left h a i = take (Ref.get h i) (Array.get h a)\""], ["", "(*[i+1 .. j]*)"], ["", "definition [simp]: \"right h a j i = take (j - Ref.get h i) (drop (Ref.get h i + 1) (Array.get h a))\""], ["", "(*[0 .. i - 1, i + 1 .. j]*)"], ["", "definition [simp]: \"both h a j i = left h a i @ right h a j i\""], ["", "lemma effect_shiftr:\n  assumes \"Ref.get h i = j\" (is \"?i h = _\")\n    and \"j < Array.length h a\"\n    and \"sorted (take j (Array.get h a))\"\n    and \"effect (while (shiftr_p a key i) (shiftr_f a i)) h h' u\"\n  shows \"Array.length h a = Array.length h' a \\<and>\n    ?i h' \\<le> j \\<and>\n    mset (list_update (Array.get h a) j key) =\n      mset (list_update (Array.get h' a) (?i h') key) \\<and>\n    ini h a j = both h' a j i \\<and>\n    sorted (both h' a j i) \\<and>\n    (\\<forall>x \\<in> set (right h' a j i). x > key)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h' a \\<and>\n    Ref.get h' i \\<le> j \\<and>\n    mset ((Array.get h a)[j := key]) =\n    mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n    ini h a j = both h' a j i \\<and>\n    sorted (both h' a j i) \\<and>\n    (\\<forall>x\\<in>set (right h' a j i). key < x)", "using assms(4, 2)"], ["proof (prove)\nusing this:\n  effect (while (shiftr_p a key i) (shiftr_f a i)) h h' u\n  j < Array.length h a\n\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h' a \\<and>\n    Ref.get h' i \\<le> j \\<and>\n    mset ((Array.get h a)[j := key]) =\n    mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n    ini h a j = both h' a j i \\<and>\n    sorted (both h' a j i) \\<and>\n    (\\<forall>x\\<in>set (right h' a j i). key < x)", "proof (induction rule: ro_shiftr_p.effect_while_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. j < Array.length h a \\<Longrightarrow>\n    Array.length h a = Array.length h a \\<and>\n    Ref.get h i \\<le> j \\<and>\n    mset ((Array.get h a)[j := key]) =\n    mset ((Array.get h a)[Ref.get h i := key]) \\<and>\n    ini h a j = both h a j i \\<and>\n    sorted (both h a j i) \\<and> Ball (set (right h a j i)) ((<) key)\n 2. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "case base"], ["proof (state)\nthis:\n  j < Array.length h a\n\ngoal (2 subgoals):\n 1. j < Array.length h a \\<Longrightarrow>\n    Array.length h a = Array.length h a \\<and>\n    Ref.get h i \\<le> j \\<and>\n    mset ((Array.get h a)[j := key]) =\n    mset ((Array.get h a)[Ref.get h i := key]) \\<and>\n    ini h a j = both h a j i \\<and>\n    sorted (both h a j i) \\<and> Ball (set (right h a j i)) ((<) key)\n 2. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h a \\<and>\n    Ref.get h i \\<le> j \\<and>\n    mset ((Array.get h a)[j := key]) =\n    mset ((Array.get h a)[Ref.get h i := key]) \\<and>\n    ini h a j = both h a j i \\<and>\n    sorted (both h a j i) \\<and>\n    (\\<forall>a\\<in>set (right h a j i). key < a)", "using assms"], ["proof (prove)\nusing this:\n  Ref.get h i = j\n  j < Array.length h a\n  sorted (take j (Array.get h a))\n  effect (while (shiftr_p a key i) (shiftr_f a i)) h h' u\n\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h a \\<and>\n    Ref.get h i \\<le> j \\<and>\n    mset ((Array.get h a)[j := key]) =\n    mset ((Array.get h a)[Ref.get h i := key]) \\<and>\n    ini h a j = both h a j i \\<and>\n    sorted (both h a j i) \\<and>\n    (\\<forall>a\\<in>set (right h a j i). key < a)", "by auto"], ["proof (state)\nthis:\n  Array.length h a = Array.length h a \\<and>\n  Ref.get h i \\<le> j \\<and>\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h a)[Ref.get h i := key]) \\<and>\n  ini h a j = both h a j i \\<and>\n  sorted (both h a j i) \\<and> (\\<forall>a\\<in>set (right h a j i). key < a)\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "case (step h' h'' u)"], ["proof (state)\nthis:\n  j < Array.length h a \\<Longrightarrow>\n  Array.length h a = Array.length h' a \\<and>\n  Ref.get h' i \\<le> j \\<and>\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n  ini h a j = both h' a j i \\<and>\n  sorted (both h' a j i) \\<and>\n  (\\<forall>a\\<in>set (right h' a j i). key < a)\n  success (shiftr_p a key i) h'\n  cond (shiftr_p a key i) h'\n  effect (shiftr_f a i) h' h'' u\n  j < Array.length h a\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "from \\<open>success (shiftr_p a key i) h'\\<close> and \\<open>cond (shiftr_p a key i) h'\\<close>"], ["proof (chain)\npicking this:\n  success (shiftr_p a key i) h'\n  cond (shiftr_p a key i) h'", "have \"?i h' > 0\" and\n    key: \"Array.get h' a ! (?i h' - 1) > key\""], ["proof (prove)\nusing this:\n  success (shiftr_p a key i) h'\n  cond (shiftr_p a key i) h'\n\ngoal (1 subgoal):\n 1. 0 < Ref.get h' i &&& key < Array.get h' a ! (Ref.get h' i - 1)", "by (auto dest!: ro_shiftr_p.success_cond_effect)\n       (auto simp: shiftr_p_def elim!: effect_elims effect_ifE)"], ["proof (state)\nthis:\n  0 < Ref.get h' i\n  key < Array.get h' a ! (Ref.get h' i - 1)\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "from effect_shiftr_f [OF \\<open>effect (shiftr_f a i) h' h'' u\\<close>]"], ["proof (chain)\npicking this:\n  Ref.get h'' i = Ref.get h' i - 1 \\<and>\n  Array.get h'' a = (Array.get h' a)\n  [Ref.get h' i := Array.get h' a ! (Ref.get h' i - 1)]", "have [simp]: \"?i h'' = ?i h' - 1\"\n    \"Array.get h'' a = list_update (Array.get h' a) (?i h') (Array.get h' a ! (?i h' - 1))\""], ["proof (prove)\nusing this:\n  Ref.get h'' i = Ref.get h' i - 1 \\<and>\n  Array.get h'' a = (Array.get h' a)\n  [Ref.get h' i := Array.get h' a ! (Ref.get h' i - 1)]\n\ngoal (1 subgoal):\n 1. Ref.get h'' i = Ref.get h' i - 1 &&&\n    Array.get h'' a = (Array.get h' a)\n    [Ref.get h' i := Array.get h' a ! (Ref.get h' i - 1)]", "by auto"], ["proof (state)\nthis:\n  Ref.get h'' i = Ref.get h' i - 1\n  Array.get h'' a = (Array.get h' a)\n  [Ref.get h' i := Array.get h' a ! (Ref.get h' i - 1)]\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "from step"], ["proof (chain)\npicking this:\n  j < Array.length h a \\<Longrightarrow>\n  Array.length h a = Array.length h' a \\<and>\n  Ref.get h' i \\<le> j \\<and>\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n  ini h a j = both h' a j i \\<and>\n  sorted (both h' a j i) \\<and>\n  (\\<forall>a\\<in>set (right h' a j i). key < a)\n  success (shiftr_p a key i) h'\n  cond (shiftr_p a key i) h'\n  effect (shiftr_f a i) h' h'' u\n  j < Array.length h a", "have *: \"?i h' < length (Array.get h' a)\"\n    and **: \"?i h' - (Suc 0) \\<le> ?i h'\" \"?i h' \\<le> length (Array.get h' a)\"\n    and \"?i h' \\<le> j\"\n    and \"?i h' < Suc j\"\n    and IH: \"ini h a j = both h' a j i\""], ["proof (prove)\nusing this:\n  j < Array.length h a \\<Longrightarrow>\n  Array.length h a = Array.length h' a \\<and>\n  Ref.get h' i \\<le> j \\<and>\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n  ini h a j = both h' a j i \\<and>\n  sorted (both h' a j i) \\<and>\n  (\\<forall>a\\<in>set (right h' a j i). key < a)\n  success (shiftr_p a key i) h'\n  cond (shiftr_p a key i) h'\n  effect (shiftr_f a i) h' h'' u\n  j < Array.length h a\n\ngoal (1 subgoal):\n 1. (Ref.get h' i < length (Array.get h' a) &&&\n     Ref.get h' i - Suc 0 \\<le> Ref.get h' i &&&\n     Ref.get h' i \\<le> length (Array.get h' a)) &&&\n    Ref.get h' i \\<le> j &&&\n    Ref.get h' i < Suc j &&& ini h a j = both h' a j i", "by (auto simp add: Array.length_def)"], ["proof (state)\nthis:\n  Ref.get h' i < length (Array.get h' a)\n  Ref.get h' i - Suc 0 \\<le> Ref.get h' i\n  Ref.get h' i \\<le> length (Array.get h' a)\n  Ref.get h' i \\<le> j\n  Ref.get h' i < Suc j\n  ini h a j = both h' a j i\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "have \"Array.length h a = Array.length h'' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h'' a", "using step"], ["proof (prove)\nusing this:\n  j < Array.length h a \\<Longrightarrow>\n  Array.length h a = Array.length h' a \\<and>\n  Ref.get h' i \\<le> j \\<and>\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n  ini h a j = both h' a j i \\<and>\n  sorted (both h' a j i) \\<and>\n  (\\<forall>a\\<in>set (right h' a j i). key < a)\n  success (shiftr_p a key i) h'\n  cond (shiftr_p a key i) h'\n  effect (shiftr_f a i) h' h'' u\n  j < Array.length h a\n\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h'' a", "by (simp add: Array.length_def)"], ["proof (state)\nthis:\n  Array.length h a = Array.length h'' a\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "moreover"], ["proof (state)\nthis:\n  Array.length h a = Array.length h'' a\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "have \"?i h'' \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref.get h'' i \\<le> j", "using step"], ["proof (prove)\nusing this:\n  j < Array.length h a \\<Longrightarrow>\n  Array.length h a = Array.length h' a \\<and>\n  Ref.get h' i \\<le> j \\<and>\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n  ini h a j = both h' a j i \\<and>\n  sorted (both h' a j i) \\<and>\n  (\\<forall>a\\<in>set (right h' a j i). key < a)\n  success (shiftr_p a key i) h'\n  cond (shiftr_p a key i) h'\n  effect (shiftr_f a i) h' h'' u\n  j < Array.length h a\n\ngoal (1 subgoal):\n 1. Ref.get h'' i \\<le> j", "by auto"], ["proof (state)\nthis:\n  Ref.get h'' i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "moreover"], ["proof (state)\nthis:\n  Ref.get h'' i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "have \"mset (list_update (Array.get h a) j key) =\n    mset (list_update (Array.get h'' a) (?i h'') key)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset ((Array.get h a)[j := key]) =\n    mset ((Array.get h'' a)[Ref.get h'' i := key])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mset ((Array.get h a)[j := key]) =\n    mset ((Array.get h'' a)[Ref.get h'' i := key])", "have \"?i h' < length (Array.get h' a)\"\n      and \"?i h' - 1 < length (Array.get h' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref.get h' i < length (Array.get h' a) &&&\n    Ref.get h' i - 1 < length (Array.get h' a)", "using *"], ["proof (prove)\nusing this:\n  Ref.get h' i < length (Array.get h' a)\n\ngoal (1 subgoal):\n 1. Ref.get h' i < length (Array.get h' a) &&&\n    Ref.get h' i - 1 < length (Array.get h' a)", "by auto"], ["proof (state)\nthis:\n  Ref.get h' i < length (Array.get h' a)\n  Ref.get h' i - 1 < length (Array.get h' a)\n\ngoal (1 subgoal):\n 1. mset ((Array.get h a)[j := key]) =\n    mset ((Array.get h'' a)[Ref.get h'' i := key])", "then"], ["proof (chain)\npicking this:\n  Ref.get h' i < length (Array.get h' a)\n  Ref.get h' i - 1 < length (Array.get h' a)", "show ?thesis"], ["proof (prove)\nusing this:\n  Ref.get h' i < length (Array.get h' a)\n  Ref.get h' i - 1 < length (Array.get h' a)\n\ngoal (1 subgoal):\n 1. mset ((Array.get h a)[j := key]) =\n    mset ((Array.get h'' a)[Ref.get h'' i := key])", "using step"], ["proof (prove)\nusing this:\n  Ref.get h' i < length (Array.get h' a)\n  Ref.get h' i - 1 < length (Array.get h' a)\n  j < Array.length h a \\<Longrightarrow>\n  Array.length h a = Array.length h' a \\<and>\n  Ref.get h' i \\<le> j \\<and>\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n  ini h a j = both h' a j i \\<and>\n  sorted (both h' a j i) \\<and>\n  (\\<forall>a\\<in>set (right h' a j i). key < a)\n  success (shiftr_p a key i) h'\n  cond (shiftr_p a key i) h'\n  effect (shiftr_f a i) h' h'' u\n  j < Array.length h a\n\ngoal (1 subgoal):\n 1. mset ((Array.get h a)[j := key]) =\n    mset ((Array.get h'' a)[Ref.get h'' i := key])", "by (simp add: mset_update ac_simps nth_list_update)"], ["proof (state)\nthis:\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h'' a)[Ref.get h'' i := key])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h'' a)[Ref.get h'' i := key])\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "moreover"], ["proof (state)\nthis:\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h'' a)[Ref.get h'' i := key])\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "have \"ini h a j = both h'' a j i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ini h a j = both h'' a j i", "using \\<open>0 < ?i h'\\<close> and \\<open>?i h' \\<le> j\\<close> and \\<open>?i h' < length (Array.get h' a)\\<close> and ** and IH"], ["proof (prove)\nusing this:\n  0 < Ref.get h' i\n  Ref.get h' i \\<le> j\n  Ref.get h' i < length (Array.get h' a)\n  Ref.get h' i - Suc 0 \\<le> Ref.get h' i\n  Ref.get h' i \\<le> length (Array.get h' a)\n  ini h a j = both h' a j i\n\ngoal (1 subgoal):\n 1. ini h a j = both h'' a j i", "by (auto simp: upd_conv_take_nth_drop Suc_diff_le min_absorb1)\n       (metis Suc_lessD Suc_pred take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  ini h a j = both h'' a j i\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "moreover"], ["proof (state)\nthis:\n  ini h a j = both h'' a j i\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "have \"sorted (both h'' a j i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (both h'' a j i)", "using step and \\<open>0 < ?i h'\\<close> and \\<open>?i h' \\<le> j\\<close> and \\<open>?i h' < length (Array.get h' a)\\<close> and **"], ["proof (prove)\nusing this:\n  j < Array.length h a \\<Longrightarrow>\n  Array.length h a = Array.length h' a \\<and>\n  Ref.get h' i \\<le> j \\<and>\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n  ini h a j = both h' a j i \\<and>\n  sorted (both h' a j i) \\<and>\n  (\\<forall>a\\<in>set (right h' a j i). key < a)\n  success (shiftr_p a key i) h'\n  cond (shiftr_p a key i) h'\n  effect (shiftr_f a i) h' h'' u\n  j < Array.length h a\n  0 < Ref.get h' i\n  Ref.get h' i \\<le> j\n  Ref.get h' i < length (Array.get h' a)\n  Ref.get h' i - Suc 0 \\<le> Ref.get h' i\n  Ref.get h' i \\<le> length (Array.get h' a)\n\ngoal (1 subgoal):\n 1. sorted (both h'' a j i)", "by (auto simp: IH upd_conv_take_nth_drop Suc_diff_le min_absorb1)\n       (metis Suc_lessD Suc_pred append.simps append_assoc take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  sorted (both h'' a j i)\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "moreover"], ["proof (state)\nthis:\n  sorted (both h'' a j i)\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "have \"\\<forall>x \\<in> set (right h'' a j i). x > key\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (right h'' a j i). key < x", "using step and \\<open>0 < ?i h'\\<close> and \\<open>?i h' < length (Array.get h' a)\\<close> and key"], ["proof (prove)\nusing this:\n  j < Array.length h a \\<Longrightarrow>\n  Array.length h a = Array.length h' a \\<and>\n  Ref.get h' i \\<le> j \\<and>\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n  ini h a j = both h' a j i \\<and>\n  sorted (both h' a j i) \\<and>\n  (\\<forall>a\\<in>set (right h' a j i). key < a)\n  success (shiftr_p a key i) h'\n  cond (shiftr_p a key i) h'\n  effect (shiftr_f a i) h' h'' u\n  j < Array.length h a\n  0 < Ref.get h' i\n  Ref.get h' i < length (Array.get h' a)\n  key < Array.get h' a ! (Ref.get h' i - 1)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (right h'' a j i). key < x", "by (auto simp: upd_conv_take_nth_drop Suc_diff_le)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (right h'' a j i). key < x\n\ngoal (1 subgoal):\n 1. \\<And>ha h' u.\n       \\<lbrakk>j < Array.length h a \\<Longrightarrow>\n                Array.length h a = Array.length ha a \\<and>\n                Ref.get ha i \\<le> j \\<and>\n                mset ((Array.get h a)[j := key]) =\n                mset ((Array.get ha a)[Ref.get ha i := key]) \\<and>\n                ini h a j = both ha a j i \\<and>\n                sorted (both ha a j i) \\<and>\n                Ball (set (right ha a j i)) ((<) key);\n        success (shiftr_p a key i) ha; cond (shiftr_p a key i) ha;\n        effect (shiftr_f a i) ha h' u; j < Array.length h a\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         Ref.get h' i \\<le> j \\<and>\n                         mset ((Array.get h a)[j := key]) =\n                         mset ((Array.get h' a)[Ref.get h' i := key]) \\<and>\n                         ini h a j = both h' a j i \\<and>\n                         sorted (both h' a j i) \\<and>\n                         Ball (set (right h' a j i)) ((<) key)", "ultimately"], ["proof (chain)\npicking this:\n  Array.length h a = Array.length h'' a\n  Ref.get h'' i \\<le> j\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h'' a)[Ref.get h'' i := key])\n  ini h a j = both h'' a j i\n  sorted (both h'' a j i)\n  \\<forall>x\\<in>set (right h'' a j i). key < x", "show ?case"], ["proof (prove)\nusing this:\n  Array.length h a = Array.length h'' a\n  Ref.get h'' i \\<le> j\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h'' a)[Ref.get h'' i := key])\n  ini h a j = both h'' a j i\n  sorted (both h'' a j i)\n  \\<forall>x\\<in>set (right h'' a j i). key < x\n\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h'' a \\<and>\n    Ref.get h'' i \\<le> j \\<and>\n    mset ((Array.get h a)[j := key]) =\n    mset ((Array.get h'' a)[Ref.get h'' i := key]) \\<and>\n    ini h a j = both h'' a j i \\<and>\n    sorted (both h'' a j i) \\<and>\n    (\\<forall>a\\<in>set (right h'' a j i). key < a)", "by blast"], ["proof (state)\nthis:\n  Array.length h a = Array.length h'' a \\<and>\n  Ref.get h'' i \\<le> j \\<and>\n  mset ((Array.get h a)[j := key]) =\n  mset ((Array.get h'' a)[Ref.get h'' i := key]) \\<and>\n  ini h a j = both h'' a j i \\<and>\n  sorted (both h'' a j i) \\<and>\n  (\\<forall>a\\<in>set (right h'' a j i). key < a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sorted_take_nth:\n  assumes \"0 < i\" and \"i < length xs\" and \"xs ! (i - 1) \\<le> y\"\n    and \"sorted (take i xs)\"\n  shows \"\\<forall>x \\<in> set (take i xs). x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (take i xs). x \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (take i xs). x \\<le> y", "have \"take i xs = take (i - 1) xs @ [xs ! (i - 1)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take i xs = take (i - 1) xs @ [xs ! (i - 1)]", "using \\<open>0 < i\\<close> and \\<open>i < length xs\\<close>"], ["proof (prove)\nusing this:\n  0 < i\n  i < length xs\n\ngoal (1 subgoal):\n 1. take i xs = take (i - 1) xs @ [xs ! (i - 1)]", "by (metis Suc_diff_1 less_imp_diff_less take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take i xs = take (i - 1) xs @ [xs ! (i - 1)]\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (take i xs). x \\<le> y", "then"], ["proof (chain)\npicking this:\n  take i xs = take (i - 1) xs @ [xs ! (i - 1)]", "show ?thesis"], ["proof (prove)\nusing this:\n  take i xs = take (i - 1) xs @ [xs ! (i - 1)]\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (take i xs). x \\<le> y", "using \\<open>sorted (take i xs)\\<close> and \\<open>xs ! (i - 1) \\<le>y\\<close>"], ["proof (prove)\nusing this:\n  take i xs = take (i - 1) xs @ [xs ! (i - 1)]\n  sorted (take i xs)\n  xs ! (i - 1) \\<le> y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (take i xs). x \\<le> y", "by (auto simp: sorted_append)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (take i xs). x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma effect_for_insert_elt:\n  assumes \"l \\<le> Array.length h a\"\n    and \"1 \\<le> l\"\n    and \"effect (for [1 ..< l] (insert_elt a)) h h' u\"\n  shows \"Array.length h a = Array.length h' a \\<and>\n    sorted (take l (Array.get h' a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h' a \\<and>\n    sorted (take l (Array.get h' a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h' a)", "using assms(2-)"], ["proof (prove)\nusing this:\n  1 \\<le> l\n  effect (for [1..<l] (insert_elt a)) h h' u\n\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h' a \\<and>\n    sorted (take l (Array.get h' a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h' a)", "proof (induction l h' rule: effect_for_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. Array.length h a = Array.length h a \\<and>\n    sorted (take 1 (Array.get h a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h a)\n 2. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Array.length h a = Array.length h a \\<and>\n    sorted (take 1 (Array.get h a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h a)\n 2. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h a \\<and>\n    sorted (take 1 (Array.get h a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h a)", "by (cases \"Array.get h a\") simp_all"], ["proof (state)\nthis:\n  Array.length h a = Array.length h a \\<and>\n  sorted (take 1 (Array.get h a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h a)\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "case (step j h' h'' u)"], ["proof (state)\nthis:\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "with assms(1)"], ["proof (chain)\npicking this:\n  l \\<le> Array.length h a\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)", "have \"j < Array.length h' a\""], ["proof (prove)\nusing this:\n  l \\<le> Array.length h a\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n\ngoal (1 subgoal):\n 1. j < Array.length h' a", "by auto"], ["proof (state)\nthis:\n  j < Array.length h' a\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "from step"], ["proof (chain)\npicking this:\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)", "have sorted: \"sorted (take j (Array.get h' a))\""], ["proof (prove)\nusing this:\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n\ngoal (1 subgoal):\n 1. sorted (take j (Array.get h' a))", "by blast"], ["proof (state)\nthis:\n  sorted (take j (Array.get h' a))\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "from step(3) [unfolded insert_elt_def]"], ["proof (chain)\npicking this:\n  effect\n   ((a.(j)) \\<bind>\n    (\\<lambda>key.\n        ref j \\<bind>\n        (\\<lambda>i.\n            shiftr a key i \\<bind>\n            (\\<lambda>_.\n                !i \\<bind> (\\<lambda>i'. a.(i') \\<leftarrow> key)))))\n   h' h'' u", "obtain key and h\\<^sub>1 and i and h\\<^sub>2 and i'\n    where key: \"key = Array.get h' a ! j\"\n      and \"effect (ref j) h' h\\<^sub>1 i\"\n      and ref\\<^sub>1: \"Ref.get h\\<^sub>1 i = j\"\n      and shiftr': \"effect (shiftr a key i) h\\<^sub>1 h\\<^sub>2 ()\"\n      and [simp]: \"Ref.get h\\<^sub>2 i = i'\"\n      and [simp]: \"h'' = Array.update a i' key h\\<^sub>2\"\n      and \"i' < Array.length h\\<^sub>2 a\""], ["proof (prove)\nusing this:\n  effect\n   ((a.(j)) \\<bind>\n    (\\<lambda>key.\n        ref j \\<bind>\n        (\\<lambda>i.\n            shiftr a key i \\<bind>\n            (\\<lambda>_.\n                !i \\<bind> (\\<lambda>i'. a.(i') \\<leftarrow> key)))))\n   h' h'' u\n\ngoal (1 subgoal):\n 1. (\\<And>key h\\<^sub>1 i h\\<^sub>2 i'.\n        \\<lbrakk>key = Array.get h' a ! j; effect (ref j) h' h\\<^sub>1 i;\n         Ref.get h\\<^sub>1 i = j;\n         effect (shiftr a key i) h\\<^sub>1 h\\<^sub>2 ();\n         Ref.get h\\<^sub>2 i = i'; h'' = Array.update a i' key h\\<^sub>2;\n         i' < Array.length h\\<^sub>2 a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim effect_bindE effect_nthE effect_lookupE effect_updE)\n         (auto intro: effect_intros, metis effect_refE)"], ["proof (state)\nthis:\n  key = Array.get h' a ! j\n  effect (ref j) h' h\\<^sub>1 i\n  Ref.get h\\<^sub>1 i = j\n  effect (shiftr a key i) h\\<^sub>1 h\\<^sub>2 ()\n  Ref.get h\\<^sub>2 i = i'\n  h'' = Array.update a i' key h\\<^sub>2\n  i' < Array.length h\\<^sub>2 a\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "from \\<open>effect (ref j) h' h\\<^sub>1 i\\<close>"], ["proof (chain)\npicking this:\n  effect (ref j) h' h\\<^sub>1 i", "have [simp]: \"Array.get h\\<^sub>1 a = Array.get h' a\""], ["proof (prove)\nusing this:\n  effect (ref j) h' h\\<^sub>1 i\n\ngoal (1 subgoal):\n 1. Array.get h\\<^sub>1 a = Array.get h' a", "by (metis array_get_alloc effectE execute_ref option.sel)"], ["proof (state)\nthis:\n  Array.get h\\<^sub>1 a = Array.get h' a\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have [simp]: \"Array.length h\\<^sub>1 a = Array.length h' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length h\\<^sub>1 a = Array.length h' a", "by (simp add: Array.length_def)"], ["proof (state)\nthis:\n  Array.length h\\<^sub>1 a = Array.length h' a\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "from step and assms(1)"], ["proof (chain)\npicking this:\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n  l \\<le> Array.length h a", "have \"j < Array.length h\\<^sub>1 a\" \"sorted (take j (Array.get h\\<^sub>1 a))\""], ["proof (prove)\nusing this:\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n  l \\<le> Array.length h a\n\ngoal (1 subgoal):\n 1. j < Array.length h\\<^sub>1 a &&& sorted (take j (Array.get h\\<^sub>1 a))", "by auto"], ["proof (state)\nthis:\n  j < Array.length h\\<^sub>1 a\n  sorted (take j (Array.get h\\<^sub>1 a))\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "note shiftr = effect_shiftr [OF ref\\<^sub>1 this shiftr' [unfolded shiftr_def], simplified]"], ["proof (state)\nthis:\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have \"i' \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' \\<le> j", "using shiftr"], ["proof (prove)\nusing this:\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n\ngoal (1 subgoal):\n 1. i' \\<le> j", "by simp"], ["proof (state)\nthis:\n  i' \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have \"i' < length (Array.get h\\<^sub>2 a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' < length (Array.get h\\<^sub>2 a)", "by (metis \\<open>i' < Array.length h\\<^sub>2 a\\<close> length_def)"], ["proof (state)\nthis:\n  i' < length (Array.get h\\<^sub>2 a)\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have [simp]: \"min (Suc j) i' = i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Suc j) i' = i'", "using \\<open>i' \\<le> j\\<close>"], ["proof (prove)\nusing this:\n  i' \\<le> j\n\ngoal (1 subgoal):\n 1. min (Suc j) i' = i'", "by simp"], ["proof (state)\nthis:\n  min (Suc j) i' = i'\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have [simp]: \"min (length (Array.get h\\<^sub>2 a)) i' = i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (length (Array.get h\\<^sub>2 a)) i' = i'", "using \\<open>i' < length (Array.get h\\<^sub>2 a)\\<close>"], ["proof (prove)\nusing this:\n  i' < length (Array.get h\\<^sub>2 a)\n\ngoal (1 subgoal):\n 1. min (length (Array.get h\\<^sub>2 a)) i' = i'", "by (simp)"], ["proof (state)\nthis:\n  min (length (Array.get h\\<^sub>2 a)) i' = i'\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have take_Suc_j: \"take (Suc j) (list_update (Array.get h\\<^sub>2 a) i' key) =\n    take i' (Array.get h\\<^sub>2 a) @ key # take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc j) ((Array.get h\\<^sub>2 a)[i' := key]) =\n    take i' (Array.get h\\<^sub>2 a) @\n    key # take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))", "unfolding upd_conv_take_nth_drop [OF \\<open>i' < length (Array.get h\\<^sub>2 a)\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc j)\n     (take i' (Array.get h\\<^sub>2 a) @\n      key # drop (Suc i') (Array.get h\\<^sub>2 a)) =\n    take i' (Array.get h\\<^sub>2 a) @\n    key # take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))", "by (auto) (metis Suc_diff_le \\<open>i' \\<le> j\\<close> take_Suc_Cons)"], ["proof (state)\nthis:\n  take (Suc j) ((Array.get h\\<^sub>2 a)[i' := key]) =\n  take i' (Array.get h\\<^sub>2 a) @\n  key # take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have \"Array.length h a = Array.length h'' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h'' a", "using shiftr"], ["proof (prove)\nusing this:\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h'' a", "by (auto) (metis step.IH)"], ["proof (state)\nthis:\n  Array.length h a = Array.length h'' a\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "moreover"], ["proof (state)\nthis:\n  Array.length h a = Array.length h'' a\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have \"mset (Array.get h a) = mset (Array.get h'' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (Array.get h a) = mset (Array.get h'' a)", "using shiftr and step"], ["proof (prove)\nusing this:\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n\ngoal (1 subgoal):\n 1. mset (Array.get h a) = mset (Array.get h'' a)", "by (simp add: key)"], ["proof (state)\nthis:\n  mset (Array.get h a) = mset (Array.get h'' a)\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "moreover"], ["proof (state)\nthis:\n  mset (Array.get h a) = mset (Array.get h'' a)\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have \"sorted (take (Suc j) (Array.get h'' a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "from ro_shiftr_p.effect_while_post [OF shiftr' [unfolded shiftr_def]]"], ["proof (chain)\npicking this:\n  success (shiftr_p a key i) h\\<^sub>2 \\<and>\n  \\<not> cond (shiftr_p a key i) h\\<^sub>2", "have \"i' = 0 \\<or> (0 < i' \\<and> key \\<ge> Array.get h\\<^sub>2 a ! (i' - 1))\""], ["proof (prove)\nusing this:\n  success (shiftr_p a key i) h\\<^sub>2 \\<and>\n  \\<not> cond (shiftr_p a key i) h\\<^sub>2\n\ngoal (1 subgoal):\n 1. i' = 0 \\<or> 0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key", "by (auto dest!: ro_shiftr_p.success_not_cond_effect)\n         (auto elim!: effect_elims simp: shiftr_p_def)"], ["proof (state)\nthis:\n  i' = 0 \\<or> 0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "then"], ["proof (chain)\npicking this:\n  i' = 0 \\<or> 0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key", "show ?thesis"], ["proof (prove)\nusing this:\n  i' = 0 \\<or> 0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i' = 0 \\<Longrightarrow> sorted (take (Suc j) (Array.get h'' a))\n 2. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "assume [simp]: \"i' = 0\""], ["proof (state)\nthis:\n  i' = 0\n\ngoal (2 subgoals):\n 1. i' = 0 \\<Longrightarrow> sorted (take (Suc j) (Array.get h'' a))\n 2. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "have *: \"take (Suc j) (list_update (Array.get h\\<^sub>2 a) 0 key) =\n        key # take j (drop 1 (Array.get h\\<^sub>2 a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc j) ((Array.get h\\<^sub>2 a)[0 := key]) =\n    key # take j (drop 1 (Array.get h\\<^sub>2 a))", "by (simp) (metis \\<open>i' = 0\\<close> append_Nil take_Suc_j diff_zero take_0)"], ["proof (state)\nthis:\n  take (Suc j) ((Array.get h\\<^sub>2 a)[0 := key]) =\n  key # take j (drop 1 (Array.get h\\<^sub>2 a))\n\ngoal (2 subgoals):\n 1. i' = 0 \\<Longrightarrow> sorted (take (Suc j) (Array.get h'' a))\n 2. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "from sorted and shiftr"], ["proof (chain)\npicking this:\n  sorted (take j (Array.get h' a))\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)", "have \"sorted (take j (drop 1 (Array.get h\\<^sub>2 a)))\"\n        and \"\\<forall>x \\<in> set (take j (drop 1 (Array.get h\\<^sub>2 a))). key < x\""], ["proof (prove)\nusing this:\n  sorted (take j (Array.get h' a))\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n\ngoal (1 subgoal):\n 1. sorted (take j (drop 1 (Array.get h\\<^sub>2 a))) &&&\n    \\<forall>x\\<in>set (take j (drop 1 (Array.get h\\<^sub>2 a))). key < x", "by simp_all"], ["proof (state)\nthis:\n  sorted (take j (drop 1 (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take j (drop 1 (Array.get h\\<^sub>2 a))). key < x\n\ngoal (2 subgoals):\n 1. i' = 0 \\<Longrightarrow> sorted (take (Suc j) (Array.get h'' a))\n 2. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "then"], ["proof (chain)\npicking this:\n  sorted (take j (drop 1 (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take j (drop 1 (Array.get h\\<^sub>2 a))). key < x", "have \"sorted (key # take j (drop 1 (Array.get h\\<^sub>2 a)))\""], ["proof (prove)\nusing this:\n  sorted (take j (drop 1 (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take j (drop 1 (Array.get h\\<^sub>2 a))). key < x\n\ngoal (1 subgoal):\n 1. sorted (key # take j (drop 1 (Array.get h\\<^sub>2 a)))", "by (metis less_imp_le sorted.simps(2))"], ["proof (state)\nthis:\n  sorted (key # take j (drop 1 (Array.get h\\<^sub>2 a)))\n\ngoal (2 subgoals):\n 1. i' = 0 \\<Longrightarrow> sorted (take (Suc j) (Array.get h'' a))\n 2. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "then"], ["proof (chain)\npicking this:\n  sorted (key # take j (drop 1 (Array.get h\\<^sub>2 a)))", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted (key # take j (drop 1 (Array.get h\\<^sub>2 a)))\n\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "by (simp add: *)"], ["proof (state)\nthis:\n  sorted (take (Suc j) (Array.get h'' a))\n\ngoal (1 subgoal):\n 1. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "assume \"0 < i' \\<and> key \\<ge> Array.get h\\<^sub>2 a ! (i' - 1)\""], ["proof (state)\nthis:\n  0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n\ngoal (1 subgoal):\n 1. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "moreover"], ["proof (state)\nthis:\n  0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n\ngoal (1 subgoal):\n 1. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "have \"sorted (take i' (Array.get h\\<^sub>2 a) @ take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)))\"\n        and \"\\<forall>x \\<in> set (take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))). key < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted\n     (take i' (Array.get h\\<^sub>2 a) @\n      take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) &&&\n    \\<forall>x\\<in>set (take (j - i')\n                         (drop (Suc i') (Array.get h\\<^sub>2 a))).\n       key < x", "using shiftr"], ["proof (prove)\nusing this:\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n\ngoal (1 subgoal):\n 1. sorted\n     (take i' (Array.get h\\<^sub>2 a) @\n      take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) &&&\n    \\<forall>x\\<in>set (take (j - i')\n                         (drop (Suc i') (Array.get h\\<^sub>2 a))).\n       key < x", "by auto"], ["proof (state)\nthis:\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take (j - i')\n                       (drop (Suc i') (Array.get h\\<^sub>2 a))).\n     key < x\n\ngoal (1 subgoal):\n 1. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "ultimately"], ["proof (chain)\npicking this:\n  0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take (j - i')\n                       (drop (Suc i') (Array.get h\\<^sub>2 a))).\n     key < x", "have \"\\<forall>x \\<in> set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key\""], ["proof (prove)\nusing this:\n  0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take (j - i')\n                       (drop (Suc i') (Array.get h\\<^sub>2 a))).\n     key < x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key", "using sorted_take_nth [OF _ \\<open>i' < length (Array.get h\\<^sub>2 a)\\<close>, of key]"], ["proof (prove)\nusing this:\n  0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take (j - i')\n                       (drop (Suc i') (Array.get h\\<^sub>2 a))).\n     key < x\n  \\<lbrakk>0 < i'; Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key;\n   sorted (take i' (Array.get h\\<^sub>2 a))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)).\n                       x \\<le> key\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key", "by (simp add: sorted_append)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key\n\ngoal (1 subgoal):\n 1. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key\n\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "using shiftr"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "by (auto simp: take_Suc_j sorted_append less_imp_le)"], ["proof (state)\nthis:\n  sorted (take (Suc j) (Array.get h'' a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted (take (Suc j) (Array.get h'' a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted (take (Suc j) (Array.get h'' a))\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>1 \\<le> k; k < l;\n        Array.length h a = Array.length ha a \\<and>\n        sorted (take k (Array.get ha a)) \\<and>\n        mset (Array.get h a) = mset (Array.get ha a);\n        effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "ultimately"], ["proof (chain)\npicking this:\n  Array.length h a = Array.length h'' a\n  mset (Array.get h a) = mset (Array.get h'' a)\n  sorted (take (Suc j) (Array.get h'' a))", "show ?case"], ["proof (prove)\nusing this:\n  Array.length h a = Array.length h'' a\n  mset (Array.get h a) = mset (Array.get h'' a)\n  sorted (take (Suc j) (Array.get h'' a))\n\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h'' a \\<and>\n    sorted (take (Suc j) (Array.get h'' a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h'' a)", "by blast"], ["proof (state)\nthis:\n  Array.length h a = Array.length h'' a \\<and>\n  sorted (take (Suc j) (Array.get h'' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h'' a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma effect_insertion_sort:\n  assumes \"effect (insertion_sort a) h h' u\"\n  shows \"mset (Array.get h a) = mset (Array.get h' a) \\<and> sorted (Array.get h' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (Array.get h a) = mset (Array.get h' a) \\<and>\n    sorted (Array.get h' a)", "using assms"], ["proof (prove)\nusing this:\n  effect (insertion_sort a) h h' u\n\ngoal (1 subgoal):\n 1. mset (Array.get h a) = mset (Array.get h' a) \\<and>\n    sorted (Array.get h' a)", "apply (cases \"Array.length h a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>effect (insertion_sort a) h h' u; Array.length h a = 0\\<rbrakk>\n    \\<Longrightarrow> mset (Array.get h a) = mset (Array.get h' a) \\<and>\n                      sorted (Array.get h' a)\n 2. \\<And>nat.\n       \\<lbrakk>effect (insertion_sort a) h h' u;\n        Array.length h a = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mset (Array.get h a) = mset (Array.get h' a) \\<and>\n                         sorted (Array.get h' a)", "apply (auto elim!: effect_elims simp: insertion_sort_def Array.length_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>effect (insertion_sort a) h h' u;\n        Array.length h a = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mset (Array.get h a) = mset (Array.get h' a) \\<and>\n                         sorted (Array.get h' a)", "unfolding insertion_sort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>effect\n                 (Array.len a \\<bind>\n                  (\\<lambda>l.\n                      for [1..<l]\n                       (\\<lambda>j.\n                           (a.(j)) \\<bind>\n                           (\\<lambda>key.\n                               ref j \\<bind>\n                               (\\<lambda>i.\n                                   while\n                                    (!i \\<bind>\n                                     (\\<lambda>i'.\n   if 0 < i' then (a.(i' - 1)) \\<bind> (\\<lambda>x. return (key < x))\n   else return False))\n                                    (!i \\<bind>\n                                     (\\<lambda>i'.\n   (a.(i' - 1)) \\<bind>\n   (\\<lambda>x.\n       (a.(i') \\<leftarrow> x) \\<bind> (\\<lambda>_. i := i' - 1)))) \\<bind>\n                                   (\\<lambda>_.\n !i \\<bind> (\\<lambda>i'. a.(i') \\<leftarrow> key)))))))\n                 h h' u;\n        Array.length h a = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mset (Array.get h a) = mset (Array.get h' a) \\<and>\n                         sorted (Array.get h' a)", "unfolding shiftr_p_def [symmetric] shiftr_f_def [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>effect\n                 (Array.len a \\<bind>\n                  (\\<lambda>l.\n                      for [1..<l]\n                       (\\<lambda>j.\n                           (a.(j)) \\<bind>\n                           (\\<lambda>key.\n                               ref j \\<bind>\n                               (\\<lambda>i.\n                                   while (shiftr_p a key i)\n                                    (shiftr_f a i) \\<bind>\n                                   (\\<lambda>_.\n !i \\<bind> (\\<lambda>i'. a.(i') \\<leftarrow> key)))))))\n                 h h' u;\n        Array.length h a = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mset (Array.get h a) = mset (Array.get h' a) \\<and>\n                         sorted (Array.get h' a)", "unfolding shiftr_def [symmetric] insert_elt_def [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>effect\n                 (Array.len a \\<bind>\n                  (\\<lambda>l. for [1..<l] (insert_elt a)))\n                 h h' u;\n        Array.length h a = Suc nat\\<rbrakk>\n       \\<Longrightarrow> mset (Array.get h a) = mset (Array.get h' a) \\<and>\n                         sorted (Array.get h' a)", "apply (elim effect_elims)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat h'a r.\n       \\<lbrakk>Array.length h a = Suc nat;\n        effect (for [1..<r] (insert_elt a)) h'a h' u;\n        r = Array.length h'a a; h'a = h\\<rbrakk>\n       \\<Longrightarrow> mset (Array.get h a) = mset (Array.get h' a) \\<and>\n                         sorted (Array.get h' a)", "apply (simp only:)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat h'a r.\n       \\<lbrakk>Array.length h a = Suc nat;\n        effect (for [1..<Suc nat] (insert_elt a)) h h' u; r = Suc nat;\n        h'a = h\\<rbrakk>\n       \\<Longrightarrow> mset (Array.get h a) = mset (Array.get h' a) \\<and>\n                         sorted (Array.get h' a)", "apply (subgoal_tac \"Suc nat \\<le> Array.length h a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat h'a r.\n       \\<lbrakk>Array.length h a = Suc nat;\n        effect (for [1..<Suc nat] (insert_elt a)) h h' u; r = Suc nat;\n        h'a = h; Suc nat \\<le> Array.length h a\\<rbrakk>\n       \\<Longrightarrow> mset (Array.get h a) = mset (Array.get h' a) \\<and>\n                         sorted (Array.get h' a)\n 2. \\<And>nat h'a r.\n       \\<lbrakk>Array.length h a = Suc nat;\n        effect (for [1..<Suc nat] (insert_elt a)) h h' u; r = Suc nat;\n        h'a = h\\<rbrakk>\n       \\<Longrightarrow> Suc nat \\<le> Array.length h a", "apply (drule effect_for_insert_elt)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nat h'a r.\n       \\<lbrakk>Array.length h a = Suc nat;\n        effect (for [1..<Suc nat] (insert_elt a)) h h' u; r = Suc nat;\n        h'a = h\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> Suc nat\n 2. \\<And>nat h'a r.\n       \\<lbrakk>Array.length h a = Suc nat;\n        effect (for [1..<Suc nat] (insert_elt a)) h h' u; r = Suc nat;\n        h'a = h\\<rbrakk>\n       \\<Longrightarrow> effect (for [1..<Suc nat] (insert_elt a)) h\n                          (?h'22 nat h'a r) (?u22 nat h'a r)\n 3. \\<And>nat h'a r.\n       \\<lbrakk>Array.length h a = Suc nat;\n        effect (for [1..<Suc nat] (insert_elt a)) h h' u; r = Suc nat;\n        h'a = h;\n        Array.length h a = Array.length (?h'22 nat h'a r) a \\<and>\n        sorted (take (Suc nat) (Array.get (?h'22 nat h'a r) a)) \\<and>\n        mset (Array.get h a) = mset (Array.get (?h'22 nat h'a r) a)\\<rbrakk>\n       \\<Longrightarrow> mset (Array.get h a) = mset (Array.get h' a) \\<and>\n                         sorted (Array.get h' a)\n 4. \\<And>nat h'a r.\n       \\<lbrakk>Array.length h a = Suc nat;\n        effect (for [1..<Suc nat] (insert_elt a)) h h' u; r = Suc nat;\n        h'a = h\\<rbrakk>\n       \\<Longrightarrow> Suc nat \\<le> Array.length h a", "apply (auto simp: Array.length_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Total Correctness\\<close>"], ["", "lemma success_shiftr_f:\n  assumes \"Ref.get h i < Array.length h a\"\n  shows \"success (shiftr_f a i) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. success (shiftr_f a i) h", "using assms"], ["proof (prove)\nusing this:\n  Ref.get h i < Array.length h a\n\ngoal (1 subgoal):\n 1. success (shiftr_f a i) h", "by (auto simp: success_def shiftr_f_def execute_simps)"], ["", "lemma success_shiftr:\n  assumes \"Ref.get h i < Array.length h a\"\n  shows \"success (while (shiftr_p a key i) (shiftr_f a i)) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. success (while (shiftr_p a key i) (shiftr_f a i)) h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. success (while (shiftr_p a key i) (shiftr_f a i)) h", "have \"wf (measure (\\<lambda>h. Ref.get h i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure (\\<lambda>h. Ref.get h i))", "by (metis wf_measure)"], ["proof (state)\nthis:\n  wf (measure (\\<lambda>h. Ref.get h i))\n\ngoal (1 subgoal):\n 1. success (while (shiftr_p a key i) (shiftr_f a i)) h", "then"], ["proof (chain)\npicking this:\n  wf (measure (\\<lambda>h. Ref.get h i))", "show ?thesis"], ["proof (prove)\nusing this:\n  wf (measure (\\<lambda>h. Ref.get h i))\n\ngoal (1 subgoal):\n 1. success (while (shiftr_p a key i) (shiftr_f a i)) h", "proof (induct taking: \"\\<lambda>h. Ref.get h i < Array.length h a\" rule: ro_shiftr_p.success_while_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       Ref.get h i < Array.length h a \\<Longrightarrow>\n       success (shiftr_p a key i) h\n 2. \\<And>h.\n       \\<lbrakk>Ref.get h i < Array.length h a;\n        success (shiftr_p a key i) h; cond (shiftr_p a key i) h\\<rbrakk>\n       \\<Longrightarrow> success (shiftr_f a i) h\n 3. Ref.get h i < Array.length h a\n 4. \\<And>h h' r.\n       \\<lbrakk>Ref.get h i < Array.length h a;\n        success (shiftr_p a key i) h; cond (shiftr_p a key i) h;\n        effect (shiftr_f a i) h h' r\\<rbrakk>\n       \\<Longrightarrow> (h', h)\n                         \\<in> measure (\\<lambda>h. Ref.get h i) \\<and>\n                         Ref.get h' i < Array.length h' a", "case (success_cond h)"], ["proof (state)\nthis:\n  Ref.get h i < Array.length h a\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       Ref.get h i < Array.length h a \\<Longrightarrow>\n       success (shiftr_p a key i) h\n 2. \\<And>h.\n       \\<lbrakk>Ref.get h i < Array.length h a;\n        success (shiftr_p a key i) h; cond (shiftr_p a key i) h\\<rbrakk>\n       \\<Longrightarrow> success (shiftr_f a i) h\n 3. Ref.get h i < Array.length h a\n 4. \\<And>h h' r.\n       \\<lbrakk>Ref.get h i < Array.length h a;\n        success (shiftr_p a key i) h; cond (shiftr_p a key i) h;\n        effect (shiftr_f a i) h h' r\\<rbrakk>\n       \\<Longrightarrow> (h', h)\n                         \\<in> measure (\\<lambda>h. Ref.get h i) \\<and>\n                         Ref.get h' i < Array.length h' a", "then"], ["proof (chain)\npicking this:\n  Ref.get h i < Array.length h a", "show ?case"], ["proof (prove)\nusing this:\n  Ref.get h i < Array.length h a\n\ngoal (1 subgoal):\n 1. success (shiftr_p a key i) h", "by (metis success_shiftr_p)"], ["proof (state)\nthis:\n  success (shiftr_p a key i) h\n\ngoal (3 subgoals):\n 1. \\<And>h.\n       \\<lbrakk>Ref.get h i < Array.length h a;\n        success (shiftr_p a key i) h; cond (shiftr_p a key i) h\\<rbrakk>\n       \\<Longrightarrow> success (shiftr_f a i) h\n 2. Ref.get h i < Array.length h a\n 3. \\<And>h h' r.\n       \\<lbrakk>Ref.get h i < Array.length h a;\n        success (shiftr_p a key i) h; cond (shiftr_p a key i) h;\n        effect (shiftr_f a i) h h' r\\<rbrakk>\n       \\<Longrightarrow> (h', h)\n                         \\<in> measure (\\<lambda>h. Ref.get h i) \\<and>\n                         Ref.get h' i < Array.length h' a", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h.\n       \\<lbrakk>Ref.get h i < Array.length h a;\n        success (shiftr_p a key i) h; cond (shiftr_p a key i) h\\<rbrakk>\n       \\<Longrightarrow> success (shiftr_f a i) h\n 2. Ref.get h i < Array.length h a\n 3. \\<And>h h' r.\n       \\<lbrakk>Ref.get h i < Array.length h a;\n        success (shiftr_p a key i) h; cond (shiftr_p a key i) h;\n        effect (shiftr_f a i) h h' r\\<rbrakk>\n       \\<Longrightarrow> (h', h)\n                         \\<in> measure (\\<lambda>h. Ref.get h i) \\<and>\n                         Ref.get h' i < Array.length h' a", "case (success_body h)"], ["proof (state)\nthis:\n  Ref.get h i < Array.length h a\n  success (shiftr_p a key i) h\n  cond (shiftr_p a key i) h\n\ngoal (3 subgoals):\n 1. \\<And>h.\n       \\<lbrakk>Ref.get h i < Array.length h a;\n        success (shiftr_p a key i) h; cond (shiftr_p a key i) h\\<rbrakk>\n       \\<Longrightarrow> success (shiftr_f a i) h\n 2. Ref.get h i < Array.length h a\n 3. \\<And>h h' r.\n       \\<lbrakk>Ref.get h i < Array.length h a;\n        success (shiftr_p a key i) h; cond (shiftr_p a key i) h;\n        effect (shiftr_f a i) h h' r\\<rbrakk>\n       \\<Longrightarrow> (h', h)\n                         \\<in> measure (\\<lambda>h. Ref.get h i) \\<and>\n                         Ref.get h' i < Array.length h' a", "then"], ["proof (chain)\npicking this:\n  Ref.get h i < Array.length h a\n  success (shiftr_p a key i) h\n  cond (shiftr_p a key i) h", "show ?case"], ["proof (prove)\nusing this:\n  Ref.get h i < Array.length h a\n  success (shiftr_p a key i) h\n  cond (shiftr_p a key i) h\n\ngoal (1 subgoal):\n 1. success (shiftr_f a i) h", "by (blast intro: success_shiftr_f)"], ["proof (state)\nthis:\n  success (shiftr_f a i) h\n\ngoal (2 subgoals):\n 1. Ref.get h i < Array.length h a\n 2. \\<And>h h' r.\n       \\<lbrakk>Ref.get h i < Array.length h a;\n        success (shiftr_p a key i) h; cond (shiftr_p a key i) h;\n        effect (shiftr_f a i) h h' r\\<rbrakk>\n       \\<Longrightarrow> (h', h)\n                         \\<in> measure (\\<lambda>h. Ref.get h i) \\<and>\n                         Ref.get h' i < Array.length h' a", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. Ref.get h i < Array.length h a\n 2. \\<And>h h' r.\n       \\<lbrakk>Ref.get h i < Array.length h a;\n        success (shiftr_p a key i) h; cond (shiftr_p a key i) h;\n        effect (shiftr_f a i) h h' r\\<rbrakk>\n       \\<Longrightarrow> (h', h)\n                         \\<in> measure (\\<lambda>h. Ref.get h i) \\<and>\n                         Ref.get h' i < Array.length h' a", "case (step h h' r)"], ["proof (state)\nthis:\n  Ref.get h i < Array.length h a\n  success (shiftr_p a key i) h\n  cond (shiftr_p a key i) h\n  effect (shiftr_f a i) h h' r\n\ngoal (2 subgoals):\n 1. Ref.get h i < Array.length h a\n 2. \\<And>h h' r.\n       \\<lbrakk>Ref.get h i < Array.length h a;\n        success (shiftr_p a key i) h; cond (shiftr_p a key i) h;\n        effect (shiftr_f a i) h h' r\\<rbrakk>\n       \\<Longrightarrow> (h', h)\n                         \\<in> measure (\\<lambda>h. Ref.get h i) \\<and>\n                         Ref.get h' i < Array.length h' a", "then"], ["proof (chain)\npicking this:\n  Ref.get h i < Array.length h a\n  success (shiftr_p a key i) h\n  cond (shiftr_p a key i) h\n  effect (shiftr_f a i) h h' r", "show ?case"], ["proof (prove)\nusing this:\n  Ref.get h i < Array.length h a\n  success (shiftr_p a key i) h\n  cond (shiftr_p a key i) h\n  effect (shiftr_f a i) h h' r\n\ngoal (1 subgoal):\n 1. (h', h) \\<in> measure (\\<lambda>h. Ref.get h i) \\<and>\n    Ref.get h' i < Array.length h' a", "by (auto dest!: effect_shiftr_f ro_shiftr_p.success_cond_effect simp: length_def)\n         (auto simp: shiftr_p_def elim!: effect_elims effect_ifE)"], ["proof (state)\nthis:\n  (h', h) \\<in> measure (\\<lambda>h. Ref.get h i) \\<and>\n  Ref.get h' i < Array.length h' a\n\ngoal (1 subgoal):\n 1. Ref.get h i < Array.length h a", "qed fact"], ["proof (state)\nthis:\n  success (while (shiftr_p a key i) (shiftr_f a i)) h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma effect_shiftr_index:\n  assumes \"effect (shiftr a key i) h h' u\"\n  shows \"Ref.get h' i \\<le> Ref.get h i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ref.get h' i \\<le> Ref.get h i", "using assms"], ["proof (prove)\nusing this:\n  effect (shiftr a key i) h h' u\n\ngoal (1 subgoal):\n 1. Ref.get h' i \\<le> Ref.get h i", "unfolding shiftr_def"], ["proof (prove)\nusing this:\n  effect (while (shiftr_p a key i) (shiftr_f a i)) h h' u\n\ngoal (1 subgoal):\n 1. Ref.get h' i \\<le> Ref.get h i", "by (induct h' rule: ro_shiftr_p.effect_while_induct) (auto dest: effect_shiftr_f)"], ["", "lemma effect_shiftr_length:\n  assumes \"effect (shiftr a key i) h h' u\"\n  shows \"Array.length h' a = Array.length h a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length h' a = Array.length h a", "using assms"], ["proof (prove)\nusing this:\n  effect (shiftr a key i) h h' u\n\ngoal (1 subgoal):\n 1. Array.length h' a = Array.length h a", "unfolding shiftr_def"], ["proof (prove)\nusing this:\n  effect (while (shiftr_p a key i) (shiftr_f a i)) h h' u\n\ngoal (1 subgoal):\n 1. Array.length h' a = Array.length h a", "by (induct h' rule: ro_shiftr_p.effect_while_induct) (auto simp: length_def dest: effect_shiftr_f)"], ["", "lemma success_insert_elt:\n  assumes \"k < Array.length h a\"\n  shows \"success (insert_elt a k) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "obtain key where \"effect (a.(k)) h h key\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>key.\n        effect (a.(k)) h h key \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  k < Array.length h a\n\ngoal (1 subgoal):\n 1. (\\<And>key.\n        effect (a.(k)) h h key \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: effect_intros)"], ["proof (state)\nthis:\n  effect (a.(k)) h h key\n\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "moreover"], ["proof (state)\nthis:\n  effect (a.(k)) h h key\n\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "obtain i and h\\<^sub>1 where \"effect (ref k) h h\\<^sub>1 i\"\n    and [simp]: \"Ref.get h\\<^sub>1 i = k\"\n    and [simp]: \"Array.length h\\<^sub>1 a = Array.length h a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h\\<^sub>1 i.\n        \\<lbrakk>effect (ref k) h h\\<^sub>1 i; Ref.get h\\<^sub>1 i = k;\n         Array.length h\\<^sub>1 a = Array.length h a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: ref_def length_def) (metis Ref.get_alloc array_get_alloc effect_heapI)"], ["proof (state)\nthis:\n  effect (ref k) h h\\<^sub>1 i\n  Ref.get h\\<^sub>1 i = k\n  Array.length h\\<^sub>1 a = Array.length h a\n\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "moreover"], ["proof (state)\nthis:\n  effect (ref k) h h\\<^sub>1 i\n  Ref.get h\\<^sub>1 i = k\n  Array.length h\\<^sub>1 a = Array.length h a\n\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "obtain h\\<^sub>2 where *: \"effect (shiftr a key i) h\\<^sub>1 h\\<^sub>2 ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h\\<^sub>2.\n        effect (shiftr a key i) h\\<^sub>1 h\\<^sub>2 () \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using success_shiftr [of h\\<^sub>1 i a key] and assms"], ["proof (prove)\nusing this:\n  Ref.get h\\<^sub>1 i < Array.length h\\<^sub>1 a \\<Longrightarrow>\n  success (while (shiftr_p a key i) (shiftr_f a i)) h\\<^sub>1\n  k < Array.length h a\n\ngoal (1 subgoal):\n 1. (\\<And>h\\<^sub>2.\n        effect (shiftr a key i) h\\<^sub>1 h\\<^sub>2 () \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: success_def effect_def shiftr_def)"], ["proof (state)\nthis:\n  effect (shiftr a key i) h\\<^sub>1 h\\<^sub>2 ()\n\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "moreover"], ["proof (state)\nthis:\n  effect (shiftr a key i) h\\<^sub>1 h\\<^sub>2 ()\n\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "have \"effect (! i) h\\<^sub>2 h\\<^sub>2 (Ref.get h\\<^sub>2 i)\"\n    and \"Ref.get h\\<^sub>2 i \\<le> Ref.get h\\<^sub>1 i\"\n    and \"Ref.get h\\<^sub>2 i < Array.length h\\<^sub>2 a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. effect (!i) h\\<^sub>2 h\\<^sub>2 (Ref.get h\\<^sub>2 i) &&&\n    Ref.get h\\<^sub>2 i \\<le> Ref.get h\\<^sub>1 i &&&\n    Ref.get h\\<^sub>2 i < Array.length h\\<^sub>2 a", "using effect_shiftr_index [OF *] and effect_shiftr_length [OF *] and assms"], ["proof (prove)\nusing this:\n  Ref.get h\\<^sub>2 i \\<le> Ref.get h\\<^sub>1 i\n  Array.length h\\<^sub>2 a = Array.length h\\<^sub>1 a\n  k < Array.length h a\n\ngoal (1 subgoal):\n 1. effect (!i) h\\<^sub>2 h\\<^sub>2 (Ref.get h\\<^sub>2 i) &&&\n    Ref.get h\\<^sub>2 i \\<le> Ref.get h\\<^sub>1 i &&&\n    Ref.get h\\<^sub>2 i < Array.length h\\<^sub>2 a", "by (auto intro!: effect_intros)"], ["proof (state)\nthis:\n  effect (!i) h\\<^sub>2 h\\<^sub>2 (Ref.get h\\<^sub>2 i)\n  Ref.get h\\<^sub>2 i \\<le> Ref.get h\\<^sub>1 i\n  Ref.get h\\<^sub>2 i < Array.length h\\<^sub>2 a\n\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "moreover"], ["proof (state)\nthis:\n  effect (!i) h\\<^sub>2 h\\<^sub>2 (Ref.get h\\<^sub>2 i)\n  Ref.get h\\<^sub>2 i \\<le> Ref.get h\\<^sub>1 i\n  Ref.get h\\<^sub>2 i < Array.length h\\<^sub>2 a\n\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "then"], ["proof (chain)\npicking this:\n  effect (!i) h\\<^sub>2 h\\<^sub>2 (Ref.get h\\<^sub>2 i)\n  Ref.get h\\<^sub>2 i \\<le> Ref.get h\\<^sub>1 i\n  Ref.get h\\<^sub>2 i < Array.length h\\<^sub>2 a", "obtain h\\<^sub>3 and r where \"effect (a.(Ref.get h\\<^sub>2 i) \\<leftarrow> key) h\\<^sub>2 h\\<^sub>3 r\""], ["proof (prove)\nusing this:\n  effect (!i) h\\<^sub>2 h\\<^sub>2 (Ref.get h\\<^sub>2 i)\n  Ref.get h\\<^sub>2 i \\<le> Ref.get h\\<^sub>1 i\n  Ref.get h\\<^sub>2 i < Array.length h\\<^sub>2 a\n\ngoal (1 subgoal):\n 1. (\\<And>h\\<^sub>3 r.\n        effect (a.(Ref.get h\\<^sub>2 i) \\<leftarrow> key) h\\<^sub>2\n         h\\<^sub>3 r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  effect (!i) h\\<^sub>2 h\\<^sub>2 (Ref.get h\\<^sub>2 i)\n  Ref.get h\\<^sub>2 i \\<le> Ref.get h\\<^sub>1 i\n  Ref.get h\\<^sub>2 i < Array.length h\\<^sub>2 a\n  k < Array.length h a\n\ngoal (1 subgoal):\n 1. (\\<And>h\\<^sub>3 r.\n        effect (a.(Ref.get h\\<^sub>2 i) \\<leftarrow> key) h\\<^sub>2\n         h\\<^sub>3 r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: effect_def execute_simps)"], ["proof (state)\nthis:\n  effect (a.(Ref.get h\\<^sub>2 i) \\<leftarrow> key) h\\<^sub>2 h\\<^sub>3 r\n\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "ultimately"], ["proof (chain)\npicking this:\n  effect (a.(k)) h h key\n  effect (ref k) h h\\<^sub>1 i\n  Ref.get h\\<^sub>1 i = k\n  Array.length h\\<^sub>1 a = Array.length h a\n  effect (shiftr a key i) h\\<^sub>1 h\\<^sub>2 ()\n  effect (!i) h\\<^sub>2 h\\<^sub>2 (Ref.get h\\<^sub>2 i)\n  Ref.get h\\<^sub>2 i \\<le> Ref.get h\\<^sub>1 i\n  Ref.get h\\<^sub>2 i < Array.length h\\<^sub>2 a\n  effect (a.(Ref.get h\\<^sub>2 i) \\<leftarrow> key) h\\<^sub>2 h\\<^sub>3 r", "have \"effect (insert_elt a k) h h\\<^sub>3 r\""], ["proof (prove)\nusing this:\n  effect (a.(k)) h h key\n  effect (ref k) h h\\<^sub>1 i\n  Ref.get h\\<^sub>1 i = k\n  Array.length h\\<^sub>1 a = Array.length h a\n  effect (shiftr a key i) h\\<^sub>1 h\\<^sub>2 ()\n  effect (!i) h\\<^sub>2 h\\<^sub>2 (Ref.get h\\<^sub>2 i)\n  Ref.get h\\<^sub>2 i \\<le> Ref.get h\\<^sub>1 i\n  Ref.get h\\<^sub>2 i < Array.length h\\<^sub>2 a\n  effect (a.(Ref.get h\\<^sub>2 i) \\<leftarrow> key) h\\<^sub>2 h\\<^sub>3 r\n\ngoal (1 subgoal):\n 1. effect (insert_elt a k) h h\\<^sub>3 r", "by (auto simp: insert_elt_def intro: effect_intros)"], ["proof (state)\nthis:\n  effect (insert_elt a k) h h\\<^sub>3 r\n\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "then"], ["proof (chain)\npicking this:\n  effect (insert_elt a k) h h\\<^sub>3 r", "show ?thesis"], ["proof (prove)\nusing this:\n  effect (insert_elt a k) h h\\<^sub>3 r\n\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "by (metis effectE)"], ["proof (state)\nthis:\n  success (insert_elt a k) h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma for_insert_elt_correct:\n  assumes \"l \\<le> Array.length h a\"\n    and \"1 \\<le> l\"\n  shows \"\\<exists>h'. effect (for [1 ..< l] (insert_elt a)) h h' () \\<and>\n    Array.length h a = Array.length h' a \\<and>\n    sorted (take l (Array.get h' a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       effect (for [1..<l] (insert_elt a)) h h' () \\<and>\n       Array.length h a = Array.length h' a \\<and>\n       sorted (take l (Array.get h' a)) \\<and>\n       mset (Array.get h a) = mset (Array.get h' a)", "using assms(2)"], ["proof (prove)\nusing this:\n  1 \\<le> l\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       effect (for [1..<l] (insert_elt a)) h h' () \\<and>\n       Array.length h a = Array.length h' a \\<and>\n       sorted (take l (Array.get h' a)) \\<and>\n       mset (Array.get h a) = mset (Array.get h' a)", "proof (induction rule: for_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k ha.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l\\<rbrakk>\n       \\<Longrightarrow> success (insert_elt a k) ha\n 2. Array.length h a = Array.length h a \\<and>\n    sorted (take 1 (Array.get h a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h a)\n 3. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "case (succeed k h)"], ["proof (state)\nthis:\n  Array.length h a = Array.length h a \\<and>\n  sorted (take k (Array.get h a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h a)\n  1 \\<le> k\n  k < l\n\ngoal (3 subgoals):\n 1. \\<And>k ha.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l\\<rbrakk>\n       \\<Longrightarrow> success (insert_elt a k) ha\n 2. Array.length h a = Array.length h a \\<and>\n    sorted (take 1 (Array.get h a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h a)\n 3. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "then"], ["proof (chain)\npicking this:\n  Array.length h a = Array.length h a \\<and>\n  sorted (take k (Array.get h a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h a)\n  1 \\<le> k\n  k < l", "show ?case"], ["proof (prove)\nusing this:\n  Array.length h a = Array.length h a \\<and>\n  sorted (take k (Array.get h a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h a)\n  1 \\<le> k\n  k < l\n\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "using assms and success_insert_elt [of k h a]"], ["proof (prove)\nusing this:\n  Array.length h a = Array.length h a \\<and>\n  sorted (take k (Array.get h a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h a)\n  1 \\<le> k\n  k < l\n  l \\<le> Array.length h a\n  1 \\<le> l\n  k < Array.length h a \\<Longrightarrow> success (insert_elt a k) h\n\ngoal (1 subgoal):\n 1. success (insert_elt a k) h", "by auto"], ["proof (state)\nthis:\n  success (insert_elt a k) h\n\ngoal (2 subgoals):\n 1. Array.length h a = Array.length h a \\<and>\n    sorted (take 1 (Array.get h a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h a)\n 2. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. Array.length h a = Array.length h a \\<and>\n    sorted (take 1 (Array.get h a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h a)\n 2. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Array.length h a = Array.length h a \\<and>\n    sorted (take 1 (Array.get h a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h a)\n 2. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h a \\<and>\n    sorted (take 1 (Array.get h a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h a)", "by (cases \"Array.get h a\") simp_all"], ["proof (state)\nthis:\n  Array.length h a = Array.length h a \\<and>\n  sorted (take 1 (Array.get h a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h a)\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "case (step j h' h'' u)"], ["proof (state)\nthis:\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "with assms(1)"], ["proof (chain)\npicking this:\n  l \\<le> Array.length h a\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u", "have \"j < Array.length h' a\""], ["proof (prove)\nusing this:\n  l \\<le> Array.length h a\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n\ngoal (1 subgoal):\n 1. j < Array.length h' a", "by auto"], ["proof (state)\nthis:\n  j < Array.length h' a\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "from step"], ["proof (chain)\npicking this:\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u", "have sorted: \"sorted (take j (Array.get h' a))\""], ["proof (prove)\nusing this:\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n\ngoal (1 subgoal):\n 1. sorted (take j (Array.get h' a))", "by blast"], ["proof (state)\nthis:\n  sorted (take j (Array.get h' a))\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "from step(4) [unfolded insert_elt_def]"], ["proof (chain)\npicking this:\n  effect\n   ((a.(j)) \\<bind>\n    (\\<lambda>key.\n        ref j \\<bind>\n        (\\<lambda>i.\n            shiftr a key i \\<bind>\n            (\\<lambda>_.\n                !i \\<bind> (\\<lambda>i'. a.(i') \\<leftarrow> key)))))\n   h' h'' u", "obtain key and h\\<^sub>1 and i and h\\<^sub>2 and i'\n    where key: \"key = Array.get h' a ! j\"\n      and \"effect (ref j) h' h\\<^sub>1 i\"\n      and ref\\<^sub>1: \"Ref.get h\\<^sub>1 i = j\"\n      and shiftr': \"effect (shiftr a key i) h\\<^sub>1 h\\<^sub>2 ()\"\n      and [simp]: \"Ref.get h\\<^sub>2 i = i'\"\n      and [simp]: \"h'' = Array.update a i' key h\\<^sub>2\"\n      and \"i' < Array.length h\\<^sub>2 a\""], ["proof (prove)\nusing this:\n  effect\n   ((a.(j)) \\<bind>\n    (\\<lambda>key.\n        ref j \\<bind>\n        (\\<lambda>i.\n            shiftr a key i \\<bind>\n            (\\<lambda>_.\n                !i \\<bind> (\\<lambda>i'. a.(i') \\<leftarrow> key)))))\n   h' h'' u\n\ngoal (1 subgoal):\n 1. (\\<And>key h\\<^sub>1 i h\\<^sub>2 i'.\n        \\<lbrakk>key = Array.get h' a ! j; effect (ref j) h' h\\<^sub>1 i;\n         Ref.get h\\<^sub>1 i = j;\n         effect (shiftr a key i) h\\<^sub>1 h\\<^sub>2 ();\n         Ref.get h\\<^sub>2 i = i'; h'' = Array.update a i' key h\\<^sub>2;\n         i' < Array.length h\\<^sub>2 a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim effect_bindE effect_nthE effect_lookupE effect_updE)\n         (auto intro: effect_intros, metis effect_refE)"], ["proof (state)\nthis:\n  key = Array.get h' a ! j\n  effect (ref j) h' h\\<^sub>1 i\n  Ref.get h\\<^sub>1 i = j\n  effect (shiftr a key i) h\\<^sub>1 h\\<^sub>2 ()\n  Ref.get h\\<^sub>2 i = i'\n  h'' = Array.update a i' key h\\<^sub>2\n  i' < Array.length h\\<^sub>2 a\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "from \\<open>effect (ref j) h' h\\<^sub>1 i\\<close>"], ["proof (chain)\npicking this:\n  effect (ref j) h' h\\<^sub>1 i", "have [simp]: \"Array.get h\\<^sub>1 a = Array.get h' a\""], ["proof (prove)\nusing this:\n  effect (ref j) h' h\\<^sub>1 i\n\ngoal (1 subgoal):\n 1. Array.get h\\<^sub>1 a = Array.get h' a", "by (metis array_get_alloc effectE execute_ref option.sel)"], ["proof (state)\nthis:\n  Array.get h\\<^sub>1 a = Array.get h' a\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have [simp]: \"Array.length h\\<^sub>1 a = Array.length h' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length h\\<^sub>1 a = Array.length h' a", "by (simp add: Array.length_def)"], ["proof (state)\nthis:\n  Array.length h\\<^sub>1 a = Array.length h' a\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "from step and assms(1)"], ["proof (chain)\npicking this:\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n  l \\<le> Array.length h a", "have \"j < Array.length h\\<^sub>1 a\" \"sorted (take j (Array.get h\\<^sub>1 a))\""], ["proof (prove)\nusing this:\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n  l \\<le> Array.length h a\n\ngoal (1 subgoal):\n 1. j < Array.length h\\<^sub>1 a &&& sorted (take j (Array.get h\\<^sub>1 a))", "by auto"], ["proof (state)\nthis:\n  j < Array.length h\\<^sub>1 a\n  sorted (take j (Array.get h\\<^sub>1 a))\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "note shiftr = effect_shiftr [OF ref\\<^sub>1 this shiftr' [unfolded shiftr_def], simplified]"], ["proof (state)\nthis:\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have \"i' \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' \\<le> j", "using shiftr"], ["proof (prove)\nusing this:\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n\ngoal (1 subgoal):\n 1. i' \\<le> j", "by simp"], ["proof (state)\nthis:\n  i' \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have \"i' < length (Array.get h\\<^sub>2 a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' < length (Array.get h\\<^sub>2 a)", "by (metis \\<open>i' < Array.length h\\<^sub>2 a\\<close> length_def)"], ["proof (state)\nthis:\n  i' < length (Array.get h\\<^sub>2 a)\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have [simp]: \"min (Suc j) i' = i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Suc j) i' = i'", "using \\<open>i' \\<le> j\\<close>"], ["proof (prove)\nusing this:\n  i' \\<le> j\n\ngoal (1 subgoal):\n 1. min (Suc j) i' = i'", "by simp"], ["proof (state)\nthis:\n  min (Suc j) i' = i'\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have [simp]: \"min (length (Array.get h\\<^sub>2 a)) i' = i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (length (Array.get h\\<^sub>2 a)) i' = i'", "using \\<open>i' < length (Array.get h\\<^sub>2 a)\\<close>"], ["proof (prove)\nusing this:\n  i' < length (Array.get h\\<^sub>2 a)\n\ngoal (1 subgoal):\n 1. min (length (Array.get h\\<^sub>2 a)) i' = i'", "by (simp)"], ["proof (state)\nthis:\n  min (length (Array.get h\\<^sub>2 a)) i' = i'\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have take_Suc_j: \"take (Suc j) (list_update (Array.get h\\<^sub>2 a) i' key) =\n    take i' (Array.get h\\<^sub>2 a) @ key # take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc j) ((Array.get h\\<^sub>2 a)[i' := key]) =\n    take i' (Array.get h\\<^sub>2 a) @\n    key # take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))", "unfolding upd_conv_take_nth_drop [OF \\<open>i' < length (Array.get h\\<^sub>2 a)\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc j)\n     (take i' (Array.get h\\<^sub>2 a) @\n      key # drop (Suc i') (Array.get h\\<^sub>2 a)) =\n    take i' (Array.get h\\<^sub>2 a) @\n    key # take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))", "by (auto) (metis Suc_diff_le \\<open>i' \\<le> j\\<close> take_Suc_Cons)"], ["proof (state)\nthis:\n  take (Suc j) ((Array.get h\\<^sub>2 a)[i' := key]) =\n  take i' (Array.get h\\<^sub>2 a) @\n  key # take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have \"Array.length h a = Array.length h'' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h'' a", "using shiftr"], ["proof (prove)\nusing this:\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h'' a", "by (auto) (metis step.hyps(1))"], ["proof (state)\nthis:\n  Array.length h a = Array.length h'' a\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "moreover"], ["proof (state)\nthis:\n  Array.length h a = Array.length h'' a\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have \"mset (Array.get h a) = mset (Array.get h'' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (Array.get h a) = mset (Array.get h'' a)", "using shiftr and step"], ["proof (prove)\nusing this:\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n  Array.length h a = Array.length h' a \\<and>\n  sorted (take j (Array.get h' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h' a)\n  1 \\<le> j\n  j < l\n  effect (insert_elt a j) h' h'' u\n\ngoal (1 subgoal):\n 1. mset (Array.get h a) = mset (Array.get h'' a)", "by (simp add: key)"], ["proof (state)\nthis:\n  mset (Array.get h a) = mset (Array.get h'' a)\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "moreover"], ["proof (state)\nthis:\n  mset (Array.get h a) = mset (Array.get h'' a)\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "have \"sorted (take (Suc j) (Array.get h'' a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "from ro_shiftr_p.effect_while_post [OF shiftr' [unfolded shiftr_def]]"], ["proof (chain)\npicking this:\n  success (shiftr_p a key i) h\\<^sub>2 \\<and>\n  \\<not> cond (shiftr_p a key i) h\\<^sub>2", "have \"i' = 0 \\<or> (0 < i' \\<and> key \\<ge> Array.get h\\<^sub>2 a ! (i' - 1))\""], ["proof (prove)\nusing this:\n  success (shiftr_p a key i) h\\<^sub>2 \\<and>\n  \\<not> cond (shiftr_p a key i) h\\<^sub>2\n\ngoal (1 subgoal):\n 1. i' = 0 \\<or> 0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key", "by (auto dest!: ro_shiftr_p.success_not_cond_effect)\n         (auto elim!: effect_elims simp: shiftr_p_def)"], ["proof (state)\nthis:\n  i' = 0 \\<or> 0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "then"], ["proof (chain)\npicking this:\n  i' = 0 \\<or> 0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key", "show ?thesis"], ["proof (prove)\nusing this:\n  i' = 0 \\<or> 0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i' = 0 \\<Longrightarrow> sorted (take (Suc j) (Array.get h'' a))\n 2. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "assume [simp]: \"i' = 0\""], ["proof (state)\nthis:\n  i' = 0\n\ngoal (2 subgoals):\n 1. i' = 0 \\<Longrightarrow> sorted (take (Suc j) (Array.get h'' a))\n 2. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "have *: \"take (Suc j) (list_update (Array.get h\\<^sub>2 a) 0 key) =\n        key # take j (drop 1 (Array.get h\\<^sub>2 a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc j) ((Array.get h\\<^sub>2 a)[0 := key]) =\n    key # take j (drop 1 (Array.get h\\<^sub>2 a))", "by (simp) (metis \\<open>i' = 0\\<close> append_Nil take_Suc_j diff_zero take_0)"], ["proof (state)\nthis:\n  take (Suc j) ((Array.get h\\<^sub>2 a)[0 := key]) =\n  key # take j (drop 1 (Array.get h\\<^sub>2 a))\n\ngoal (2 subgoals):\n 1. i' = 0 \\<Longrightarrow> sorted (take (Suc j) (Array.get h'' a))\n 2. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "from sorted and shiftr"], ["proof (chain)\npicking this:\n  sorted (take j (Array.get h' a))\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)", "have \"sorted (take j (drop 1 (Array.get h\\<^sub>2 a)))\"\n        and \"\\<forall>x \\<in> set (take j (drop 1 (Array.get h\\<^sub>2 a))). key < x\""], ["proof (prove)\nusing this:\n  sorted (take j (Array.get h' a))\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n\ngoal (1 subgoal):\n 1. sorted (take j (drop 1 (Array.get h\\<^sub>2 a))) &&&\n    \\<forall>x\\<in>set (take j (drop 1 (Array.get h\\<^sub>2 a))). key < x", "by simp_all"], ["proof (state)\nthis:\n  sorted (take j (drop 1 (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take j (drop 1 (Array.get h\\<^sub>2 a))). key < x\n\ngoal (2 subgoals):\n 1. i' = 0 \\<Longrightarrow> sorted (take (Suc j) (Array.get h'' a))\n 2. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "then"], ["proof (chain)\npicking this:\n  sorted (take j (drop 1 (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take j (drop 1 (Array.get h\\<^sub>2 a))). key < x", "have \"sorted (key # take j (drop 1 (Array.get h\\<^sub>2 a)))\""], ["proof (prove)\nusing this:\n  sorted (take j (drop 1 (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take j (drop 1 (Array.get h\\<^sub>2 a))). key < x\n\ngoal (1 subgoal):\n 1. sorted (key # take j (drop 1 (Array.get h\\<^sub>2 a)))", "by (metis less_imp_le sorted.simps(2))"], ["proof (state)\nthis:\n  sorted (key # take j (drop 1 (Array.get h\\<^sub>2 a)))\n\ngoal (2 subgoals):\n 1. i' = 0 \\<Longrightarrow> sorted (take (Suc j) (Array.get h'' a))\n 2. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "then"], ["proof (chain)\npicking this:\n  sorted (key # take j (drop 1 (Array.get h\\<^sub>2 a)))", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted (key # take j (drop 1 (Array.get h\\<^sub>2 a)))\n\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "by (simp add: *)"], ["proof (state)\nthis:\n  sorted (take (Suc j) (Array.get h'' a))\n\ngoal (1 subgoal):\n 1. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "assume \"0 < i' \\<and> key \\<ge> Array.get h\\<^sub>2 a ! (i' - 1)\""], ["proof (state)\nthis:\n  0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n\ngoal (1 subgoal):\n 1. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "moreover"], ["proof (state)\nthis:\n  0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n\ngoal (1 subgoal):\n 1. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "have \"sorted (take i' (Array.get h\\<^sub>2 a) @ take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)))\"\n        and \"\\<forall>x \\<in> set (take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))). key < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted\n     (take i' (Array.get h\\<^sub>2 a) @\n      take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) &&&\n    \\<forall>x\\<in>set (take (j - i')\n                         (drop (Suc i') (Array.get h\\<^sub>2 a))).\n       key < x", "using shiftr"], ["proof (prove)\nusing this:\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n\ngoal (1 subgoal):\n 1. sorted\n     (take i' (Array.get h\\<^sub>2 a) @\n      take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) &&&\n    \\<forall>x\\<in>set (take (j - i')\n                         (drop (Suc i') (Array.get h\\<^sub>2 a))).\n       key < x", "by auto"], ["proof (state)\nthis:\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take (j - i')\n                       (drop (Suc i') (Array.get h\\<^sub>2 a))).\n     key < x\n\ngoal (1 subgoal):\n 1. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "ultimately"], ["proof (chain)\npicking this:\n  0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take (j - i')\n                       (drop (Suc i') (Array.get h\\<^sub>2 a))).\n     key < x", "have \"\\<forall>x \\<in> set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key\""], ["proof (prove)\nusing this:\n  0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take (j - i')\n                       (drop (Suc i') (Array.get h\\<^sub>2 a))).\n     key < x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key", "using sorted_take_nth [OF _ \\<open>i' < length (Array.get h\\<^sub>2 a)\\<close>, of key]"], ["proof (prove)\nusing this:\n  0 < i' \\<and> Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)))\n  \\<forall>x\\<in>set (take (j - i')\n                       (drop (Suc i') (Array.get h\\<^sub>2 a))).\n     key < x\n  \\<lbrakk>0 < i'; Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key;\n   sorted (take i' (Array.get h\\<^sub>2 a))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)).\n                       x \\<le> key\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key", "by (simp add: sorted_append)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key\n\ngoal (1 subgoal):\n 1. 0 < i' \\<and>\n    Array.get h\\<^sub>2 a ! (i' - 1) \\<le> key \\<Longrightarrow>\n    sorted (take (Suc j) (Array.get h'' a))", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key\n\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "using shiftr"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (take i' (Array.get h\\<^sub>2 a)). x \\<le> key\n  Array.length h' a = Array.length h\\<^sub>2 a \\<and>\n  i' \\<le> j \\<and>\n  mset ((Array.get h' a)[j := key]) =\n  mset ((Array.get h\\<^sub>2 a)[i' := key]) \\<and>\n  take j (Array.get h' a) =\n  take i' (Array.get h\\<^sub>2 a) @\n  take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a)) \\<and>\n  sorted\n   (take i' (Array.get h\\<^sub>2 a) @\n    take (j - i') (drop (Suc i') (Array.get h\\<^sub>2 a))) \\<and>\n  (\\<forall>x\\<in>set (take (j - i')\n                        (drop (Suc i') (Array.get h\\<^sub>2 a))).\n      key < x)\n\ngoal (1 subgoal):\n 1. sorted (take (Suc j) (Array.get h'' a))", "by (auto simp: take_Suc_j sorted_append less_imp_le)"], ["proof (state)\nthis:\n  sorted (take (Suc j) (Array.get h'' a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted (take (Suc j) (Array.get h'' a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted (take (Suc j) (Array.get h'' a))\n\ngoal (1 subgoal):\n 1. \\<And>k ha h' r.\n       \\<lbrakk>Array.length h a = Array.length ha a \\<and>\n                sorted (take k (Array.get ha a)) \\<and>\n                mset (Array.get h a) = mset (Array.get ha a);\n        1 \\<le> k; k < l; effect (insert_elt a k) ha h' r\\<rbrakk>\n       \\<Longrightarrow> Array.length h a = Array.length h' a \\<and>\n                         sorted (take (Suc k) (Array.get h' a)) \\<and>\n                         mset (Array.get h a) = mset (Array.get h' a)", "ultimately"], ["proof (chain)\npicking this:\n  Array.length h a = Array.length h'' a\n  mset (Array.get h a) = mset (Array.get h'' a)\n  sorted (take (Suc j) (Array.get h'' a))", "show ?case"], ["proof (prove)\nusing this:\n  Array.length h a = Array.length h'' a\n  mset (Array.get h a) = mset (Array.get h'' a)\n  sorted (take (Suc j) (Array.get h'' a))\n\ngoal (1 subgoal):\n 1. Array.length h a = Array.length h'' a \\<and>\n    sorted (take (Suc j) (Array.get h'' a)) \\<and>\n    mset (Array.get h a) = mset (Array.get h'' a)", "by blast"], ["proof (state)\nthis:\n  Array.length h a = Array.length h'' a \\<and>\n  sorted (take (Suc j) (Array.get h'' a)) \\<and>\n  mset (Array.get h a) = mset (Array.get h'' a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertion_sort_correct:\n  \"\\<exists>h'. effect (insertion_sort a) h h' u \\<and>\n    mset (Array.get h a) = mset (Array.get h' a) \\<and>\n    sorted (Array.get h' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       effect (insertion_sort a) h h' u \\<and>\n       mset (Array.get h a) = mset (Array.get h' a) \\<and>\n       sorted (Array.get h' a)", "proof (cases \"Array.length h a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Array.length h a = 0 \\<Longrightarrow>\n    \\<exists>h'.\n       effect (insertion_sort a) h h' u \\<and>\n       mset (Array.get h a) = mset (Array.get h' a) \\<and>\n       sorted (Array.get h' a)\n 2. Array.length h a \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>h'.\n       effect (insertion_sort a) h h' u \\<and>\n       mset (Array.get h a) = mset (Array.get h' a) \\<and>\n       sorted (Array.get h' a)", "assume \"Array.length h a = 0\""], ["proof (state)\nthis:\n  Array.length h a = 0\n\ngoal (2 subgoals):\n 1. Array.length h a = 0 \\<Longrightarrow>\n    \\<exists>h'.\n       effect (insertion_sort a) h h' u \\<and>\n       mset (Array.get h a) = mset (Array.get h' a) \\<and>\n       sorted (Array.get h' a)\n 2. Array.length h a \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>h'.\n       effect (insertion_sort a) h h' u \\<and>\n       mset (Array.get h a) = mset (Array.get h' a) \\<and>\n       sorted (Array.get h' a)", "then"], ["proof (chain)\npicking this:\n  Array.length h a = 0", "have \"effect (insertion_sort a) h h ()\"\n    and \"mset (Array.get h a) = mset (Array.get h a)\"\n    and \"sorted (Array.get h a)\""], ["proof (prove)\nusing this:\n  Array.length h a = 0\n\ngoal (1 subgoal):\n 1. effect (insertion_sort a) h h () &&&\n    mset (Array.get h a) = mset (Array.get h a) &&& sorted (Array.get h a)", "by (auto simp: insertion_sort_def length_def intro!: effect_intros)"], ["proof (state)\nthis:\n  effect (insertion_sort a) h h ()\n  mset (Array.get h a) = mset (Array.get h a)\n  sorted (Array.get h a)\n\ngoal (2 subgoals):\n 1. Array.length h a = 0 \\<Longrightarrow>\n    \\<exists>h'.\n       effect (insertion_sort a) h h' u \\<and>\n       mset (Array.get h a) = mset (Array.get h' a) \\<and>\n       sorted (Array.get h' a)\n 2. Array.length h a \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>h'.\n       effect (insertion_sort a) h h' u \\<and>\n       mset (Array.get h a) = mset (Array.get h' a) \\<and>\n       sorted (Array.get h' a)", "then"], ["proof (chain)\npicking this:\n  effect (insertion_sort a) h h ()\n  mset (Array.get h a) = mset (Array.get h a)\n  sorted (Array.get h a)", "show ?thesis"], ["proof (prove)\nusing this:\n  effect (insertion_sort a) h h ()\n  mset (Array.get h a) = mset (Array.get h a)\n  sorted (Array.get h a)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       effect (insertion_sort a) h h' u \\<and>\n       mset (Array.get h a) = mset (Array.get h' a) \\<and>\n       sorted (Array.get h' a)", "by auto"], ["proof (state)\nthis:\n  \\<exists>h'.\n     effect (insertion_sort a) h h' u \\<and>\n     mset (Array.get h a) = mset (Array.get h' a) \\<and>\n     sorted (Array.get h' a)\n\ngoal (1 subgoal):\n 1. Array.length h a \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>h'.\n       effect (insertion_sort a) h h' u \\<and>\n       mset (Array.get h a) = mset (Array.get h' a) \\<and>\n       sorted (Array.get h' a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Array.length h a \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>h'.\n       effect (insertion_sort a) h h' u \\<and>\n       mset (Array.get h a) = mset (Array.get h' a) \\<and>\n       sorted (Array.get h' a)", "assume \"Array.length h a \\<noteq> 0\""], ["proof (state)\nthis:\n  Array.length h a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Array.length h a \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>h'.\n       effect (insertion_sort a) h h' u \\<and>\n       mset (Array.get h a) = mset (Array.get h' a) \\<and>\n       sorted (Array.get h' a)", "then"], ["proof (chain)\npicking this:\n  Array.length h a \\<noteq> 0", "have \"1 \\<le> Array.length h a\""], ["proof (prove)\nusing this:\n  Array.length h a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> Array.length h a", "by auto"], ["proof (state)\nthis:\n  1 \\<le> Array.length h a\n\ngoal (1 subgoal):\n 1. Array.length h a \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>h'.\n       effect (insertion_sort a) h h' u \\<and>\n       mset (Array.get h a) = mset (Array.get h' a) \\<and>\n       sorted (Array.get h' a)", "from for_insert_elt_correct [OF le_refl this]"], ["proof (chain)\npicking this:\n  \\<exists>h'.\n     effect (for [1..<Array.length h a] (insert_elt a)) h h' () \\<and>\n     Array.length h a = Array.length h' a \\<and>\n     sorted (take (Array.length h a) (Array.get h' a)) \\<and>\n     mset (Array.get h a) = mset (Array.get h' a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>h'.\n     effect (for [1..<Array.length h a] (insert_elt a)) h h' () \\<and>\n     Array.length h a = Array.length h' a \\<and>\n     sorted (take (Array.length h a) (Array.get h' a)) \\<and>\n     mset (Array.get h a) = mset (Array.get h' a)\n\ngoal (1 subgoal):\n 1. \\<exists>h'.\n       effect (insertion_sort a) h h' u \\<and>\n       mset (Array.get h a) = mset (Array.get h' a) \\<and>\n       sorted (Array.get h' a)", "by (auto simp: insertion_sort_alt_def sort_upto_def)\n       (metis One_nat_def effect_bindI effect_insertion_sort effect_lengthI insertion_sort_alt_def sort_upto_def)"], ["proof (state)\nthis:\n  \\<exists>h'.\n     effect (insertion_sort a) h h' u \\<and>\n     mset (Array.get h a) = mset (Array.get h' a) \\<and>\n     sorted (Array.get h' a)\n\ngoal:\nNo subgoals!", "qed"], ["", "export_code insertion_sort in Haskell"], ["", "end"]]}