{"file_name": "/home/qj213/afp-2021-10-22/thys/Graph_Saturation/CombinedCorrectness.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Graph_Saturation", "problem_names": ["lemma gr_transl_rules:\n  \"x \\<in> transl_rules T \\<Longrightarrow> graph_rule x\"", "lemma check_consistency:\n  assumes \"finite T\" \"finite C\"\n  shows \"check_consistency C (transl_rules T) \\<longleftrightarrow> consistent (t::nat itself) C T\"\n   (is \"?lhs = ?rhs\")", "lemma check_entailment:\n  assumes \"finite T\" \"finite C\"\n  shows \"check_entailment C (transl_rules T) S \\<longleftrightarrow> entails (t::nat itself) C T (fst S, (A_Int (fst S) (snd S)))\"\n   (is \"?lhs = ?rhs\")"], "translations": [["", "lemma gr_transl_rules:\n  \"x \\<in> transl_rules T \\<Longrightarrow> graph_rule x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> transl_rules T \\<Longrightarrow> graph_rule x", "using graph_rule_translation"], ["proof (prove)\nusing this:\n  graph_rule (translation ?X, translation (A_Int ?X ?Y))\n\ngoal (1 subgoal):\n 1. x \\<in> transl_rules T \\<Longrightarrow> graph_rule x", "unfolding transl_rules_def"], ["proof (prove)\nusing this:\n  graph_rule (translation ?X, translation (A_Int ?X ?Y))\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>(x, y)\\<in>T.\n                {(translation x, translation (A_Int x y)),\n                 (translation y,\n                  translation (A_Int y x))}) \\<Longrightarrow>\n    graph_rule x", "by blast"], ["", "term entails"], ["", "lemma check_consistency:\n  assumes \"finite T\" \"finite C\"\n  shows \"check_consistency C (transl_rules T) \\<longleftrightarrow> consistent (t::nat itself) C T\"\n   (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "from assms(1)"], ["proof (chain)\npicking this:\n  finite T", "have fin_t:\"finite (transl_rules T)\""], ["proof (prove)\nusing this:\n  finite T\n\ngoal (1 subgoal):\n 1. finite (transl_rules T)", "unfolding transl_rules_def"], ["proof (prove)\nusing this:\n  finite T\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>(x, y)\\<in>T.\n         {(translation x, translation (A_Int x y)),\n          (translation y, translation (A_Int y x))})", "by fast"], ["proof (state)\nthis:\n  finite (transl_rules T)\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "define L where\n    \"L = fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union> {S_Bot,S_Top,S_Idt} \\<union> S_Const ` C\""], ["proof (state)\nthis:\n  L =\n  fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n  {S_Bot, S_Top, S_Idt} \\<union>\n  S_Const ` C\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "have \"finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))", "using fin_t gr_transl_rules"], ["proof (prove)\nusing this:\n  finite (transl_rules T)\n  ?x \\<in> transl_rules ?T \\<Longrightarrow> graph_rule ?x\n\ngoal (1 subgoal):\n 1. finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))", "by auto"], ["proof (state)\nthis:\n  finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "hence fin_l:\"finite L\""], ["proof (prove)\nusing this:\n  finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))\n\ngoal (1 subgoal):\n 1. finite L", "unfolding L_def"], ["proof (prove)\nusing this:\n  finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))\n\ngoal (1 subgoal):\n 1. finite\n     (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n      {S_Bot, S_Top, S_Idt} \\<union>\n      S_Const ` C)", "using assms(2)"], ["proof (prove)\nusing this:\n  finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))\n  finite C\n\ngoal (1 subgoal):\n 1. finite\n     (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n      {S_Bot, S_Top, S_Idt} \\<union>\n      S_Const ` C)", "by auto"], ["proof (state)\nthis:\n  finite L\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "define Rules where \"Rules = transl_rules T \\<union> standard_rules C L\""], ["proof (state)\nthis:\n  Rules = transl_rules T \\<union> standard_rules C L\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "hence fin_r:\"finite Rules\""], ["proof (prove)\nusing this:\n  Rules = transl_rules T \\<union> standard_rules C L\n\ngoal (1 subgoal):\n 1. finite Rules", "using assms(2) fin_t fin_l"], ["proof (prove)\nusing this:\n  Rules = transl_rules T \\<union> standard_rules C L\n  finite C\n  finite (transl_rules T)\n  finite L\n\ngoal (1 subgoal):\n 1. finite Rules", "unfolding standard_rules_def"], ["proof (prove)\nusing this:\n  Rules =\n  transl_rules T \\<union>\n  (constant_rules C \\<union> identity_rules L \\<union>\n   {top_rule S_Top, nonempty_rule})\n  finite C\n  finite (transl_rules T)\n  finite L\n\ngoal (1 subgoal):\n 1. finite Rules", "by auto"], ["proof (state)\nthis:\n  finite Rules\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "have incl_L:\"fst ` (\\<Union> ((edges o snd) ` Rules)) \\<subseteq> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` \\<Union> ((edges \\<circ> snd) ` Rules) \\<subseteq> L", "unfolding L_def Rules_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    \\<Union>\n     ((edges \\<circ> snd) `\n      (transl_rules T \\<union>\n       standard_rules C\n        (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n         {S_Bot, S_Top, S_Idt} \\<union>\n         S_Const ` C)))\n    \\<subseteq> fst `\n                \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n                {S_Bot, S_Top, S_Idt} \\<union>\n                S_Const ` C", "by (auto elim:standard_rules_edges)"], ["proof (state)\nthis:\n  fst ` \\<Union> ((edges \\<circ> snd) ` Rules) \\<subseteq> L\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "have \"\\<forall>R\\<in>transl_rules T. graph_rule R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>transl_rules T. graph_rule R", "using gr_transl_rules"], ["proof (prove)\nusing this:\n  ?x \\<in> transl_rules ?T \\<Longrightarrow> graph_rule ?x\n\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>transl_rules T. graph_rule R", "by blast"], ["proof (state)\nthis:\n  \\<forall>R\\<in>transl_rules T. graph_rule R\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "moreover"], ["proof (state)\nthis:\n  \\<forall>R\\<in>transl_rules T. graph_rule R\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "have \"\\<forall>R\\<in> constant_rules C. graph_rule R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>constant_rules C. graph_rule R", "using constant_rules_graph_rule"], ["proof (prove)\nusing this:\n  ?x \\<in> constant_rules ?C \\<Longrightarrow> graph_rule ?x\n\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>constant_rules C. graph_rule R", "by auto"], ["proof (state)\nthis:\n  \\<forall>R\\<in>constant_rules C. graph_rule R\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "moreover"], ["proof (state)\nthis:\n  \\<forall>R\\<in>constant_rules C. graph_rule R\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "have \"\\<forall>R\\<in> identity_rules L. graph_rule R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>identity_rules L. graph_rule R", "using identity_rules_graph_rule"], ["proof (prove)\nusing this:\n  ?x \\<in> identity_rules ?L \\<Longrightarrow> graph_rule ?x\n\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>identity_rules L. graph_rule R", "by auto"], ["proof (state)\nthis:\n  \\<forall>R\\<in>identity_rules L. graph_rule R\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "moreover"], ["proof (state)\nthis:\n  \\<forall>R\\<in>identity_rules L. graph_rule R\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "have \"\\<forall>R\\<in> {top_rule S_Top,nonempty_rule}. graph_rule R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R", "using are_rules(1,2)"], ["proof (prove)\nusing this:\n  graph_rule nonempty_rule\n  graph_rule (top_rule ?t)\n\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>R\\<in>transl_rules T. graph_rule R\n  \\<forall>R\\<in>constant_rules C. graph_rule R\n  \\<forall>R\\<in>identity_rules L. graph_rule R\n  \\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R", "have gr:\"set_of_graph_rules Rules\""], ["proof (prove)\nusing this:\n  \\<forall>R\\<in>transl_rules T. graph_rule R\n  \\<forall>R\\<in>constant_rules C. graph_rule R\n  \\<forall>R\\<in>identity_rules L. graph_rule R\n  \\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R\n\ngoal (1 subgoal):\n 1. set_of_graph_rules Rules", "unfolding set_of_graph_rules_def Rules_def ball_Un standard_rules_def"], ["proof (prove)\nusing this:\n  \\<forall>R\\<in>transl_rules T. graph_rule R\n  \\<forall>R\\<in>constant_rules C. graph_rule R\n  \\<forall>R\\<in>identity_rules L. graph_rule R\n  \\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R\n\ngoal (1 subgoal):\n 1. (\\<forall>R\\<in>transl_rules T. graph_rule R) \\<and>\n    ((\\<forall>R\\<in>constant_rules C. graph_rule R) \\<and>\n     (\\<forall>R\\<in>identity_rules L. graph_rule R)) \\<and>\n    (\\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R)", "by blast"], ["proof (state)\nthis:\n  set_of_graph_rules Rules\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "define sel where \"sel = non_constructive_selector Rules\""], ["proof (state)\nthis:\n  sel = non_constructive_selector Rules\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "hence sel:\"valid_selector Rules sel\""], ["proof (prove)\nusing this:\n  sel = non_constructive_selector Rules\n\ngoal (1 subgoal):\n 1. valid_selector Rules sel", "using gr non_constructive_selector"], ["proof (prove)\nusing this:\n  sel = non_constructive_selector Rules\n  set_of_graph_rules Rules\n  set_of_graph_rules ?Rs \\<Longrightarrow>\n  valid_selector ?Rs (non_constructive_selector ?Rs)\n\ngoal (1 subgoal):\n 1. valid_selector Rules sel", "by auto"], ["proof (state)\nthis:\n  valid_selector Rules sel\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "define cfg where \"cfg = the_lcg sel Rules (0, {})\""], ["proof (state)\nthis:\n  cfg = the_lcg sel Rules (0, {})\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "have cfg:\"cfg = the_model C (transl_rules T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg = the_model C (transl_rules T)", "unfolding cfg_def sel_def Rules_def L_def the_model_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_lcg\n     (non_constructive_selector\n       (transl_rules T \\<union>\n        standard_rules C\n         (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n          {S_Bot, S_Top, S_Idt} \\<union>\n          S_Const ` C)))\n     (transl_rules T \\<union>\n      standard_rules C\n       (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n        {S_Bot, S_Top, S_Idt} \\<union>\n        S_Const ` C))\n     (0, {}) =\n    the_lcg\n     (non_constructive_selector\n       (transl_rules T \\<union>\n        standard_rules C\n         (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n          {S_Bot, S_Top, S_Idt} \\<union>\n          S_Const ` C)))\n     (transl_rules T \\<union>\n      standard_rules C\n       (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n        {S_Bot, S_Top, S_Idt} \\<union>\n        S_Const ` C))\n     (0, {})", ".."], ["proof (state)\nthis:\n  cfg = the_model C (transl_rules T)\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "have cfg_c:\"least_consequence_graph TYPE('a + nat) Rules (graph_of (0,{})) cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least_consequence_graph TYPE('a + nat) Rules (graph_of (0, {})) cfg", "unfolding cfg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. least_consequence_graph TYPE('a + nat) Rules (graph_of (0, {}))\n     (the_lcg sel Rules (0, {}))", "by (rule lcg_through_make_step[OF fin_r gr _ sel],auto)"], ["proof (state)\nthis:\n  least_consequence_graph TYPE('a + nat) Rules (graph_of (0, {})) cfg\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "hence cfg_sdt:\"maintainedA (standard_rules C L) cfg\"\n    and cfg_g: \"graph cfg\"\n    and cfg_l:\"least TYPE('a + nat) Rules (graph_of (0, {})) cfg\"\n    and cfg_m:\"r \\<in> transl_rules T \\<Longrightarrow> maintained r cfg\" for r"], ["proof (prove)\nusing this:\n  least_consequence_graph TYPE('a + nat) Rules (graph_of (0, {})) cfg\n\ngoal (1 subgoal):\n 1. (maintainedA (standard_rules C L) cfg &&& graph cfg) &&&\n    least TYPE('a + nat) Rules (graph_of (0, {})) cfg &&&\n    (r \\<in> transl_rules T \\<Longrightarrow> maintained r cfg)", "unfolding Rules_def least_consequence_graph_def"], ["proof (prove)\nusing this:\n  consequence_graph (transl_rules T \\<union> standard_rules C L) cfg \\<and>\n  least TYPE('a + nat) (transl_rules T \\<union> standard_rules C L)\n   (graph_of (0, {})) cfg\n\ngoal (1 subgoal):\n 1. (maintainedA (standard_rules C L) cfg &&& graph cfg) &&&\n    least TYPE('a + nat) (transl_rules T \\<union> standard_rules C L)\n     (graph_of (0, {})) cfg &&&\n    (r \\<in> transl_rules T \\<Longrightarrow> maintained r cfg)", "by auto"], ["proof (state)\nthis:\n  maintainedA (standard_rules C L) cfg\n  graph cfg\n  least TYPE('a + nat) Rules (graph_of (0, {})) cfg\n  ?r1 \\<in> transl_rules T \\<Longrightarrow> maintained ?r1 cfg\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "have cfg_lbl:\"fst ` edges cfg \\<subseteq> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` edges cfg \\<subseteq> L", "unfolding cfg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` edges (the_lcg sel Rules (0, {})) \\<subseteq> L", "by (auto intro!: the_lcg_edges[OF sel incl_L])"], ["proof (state)\nthis:\n  fst ` edges cfg \\<subseteq> L\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "have d1: \"?lhs \\<Longrightarrow> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) \\<Longrightarrow>\n    \\<exists>G. model C G T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) \\<Longrightarrow>\n    \\<exists>G. model C G T", "assume ?lhs"], ["proof (state)\nthis:\n  check_consistency C (transl_rules T)\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) \\<Longrightarrow>\n    \\<exists>G. model C G T", "from maintained_standard_noconstants[OF cfg_sdt cfg_g cfg_lbl this[folded cfg]]"], ["proof (chain)\npicking this:\n  \\<exists>f g G.\n     G = map_graph_fn G (f \\<circ> g) \\<and>\n     G = map_graph_fn cfg f \\<and>\n     subgraph (map_graph_fn G g) cfg \\<and>\n     standard' C G \\<and>\n     (\\<forall>r. maintained r cfg \\<longrightarrow> maintained r G) \\<and>\n     (\\<forall>x y e.\n         x \\<in> vertices cfg \\<longrightarrow>\n         y \\<in> vertices cfg \\<longrightarrow>\n         (g (f x), g (f y))\n         \\<in> :map_graph_fn G g:\\<lbrakk>e\\<rbrakk> \\<longrightarrow>\n         (x, y) \\<in> :cfg:\\<lbrakk>e\\<rbrakk>)", "obtain G :: \"('a Standard_Constant, 'a + nat) labeled_graph\"\n      where G_std:\"standard' C G\"\n      and m:\"maintained r cfg \\<Longrightarrow> maintained r G\"\n      for r :: \"('a Standard_Constant, nat) Graph_PreRule\""], ["proof (prove)\nusing this:\n  \\<exists>f g G.\n     G = map_graph_fn G (f \\<circ> g) \\<and>\n     G = map_graph_fn cfg f \\<and>\n     subgraph (map_graph_fn G g) cfg \\<and>\n     standard' C G \\<and>\n     (\\<forall>r. maintained r cfg \\<longrightarrow> maintained r G) \\<and>\n     (\\<forall>x y e.\n         x \\<in> vertices cfg \\<longrightarrow>\n         y \\<in> vertices cfg \\<longrightarrow>\n         (g (f x), g (f y))\n         \\<in> :map_graph_fn G g:\\<lbrakk>e\\<rbrakk> \\<longrightarrow>\n         (x, y) \\<in> :cfg:\\<lbrakk>e\\<rbrakk>)\n\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>standard' C G;\n         \\<And>r. maintained r cfg \\<Longrightarrow> maintained r G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  standard' C G\n  maintained ?r1 cfg \\<Longrightarrow> maintained ?r1 G\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) \\<Longrightarrow>\n    \\<exists>G. model C G T", "hence g:\"graph G\""], ["proof (prove)\nusing this:\n  standard' C G\n  maintained ?r1 cfg \\<Longrightarrow> maintained ?r1 G\n\ngoal (1 subgoal):\n 1. graph G", "unfolding standard_def"], ["proof (prove)\nusing this:\n  graph G \\<and>\n  vertices G \\<noteq> {} \\<and>\n  ident_rel S_Idt G \\<and>\n  getRel S_Bot G = {} \\<and>\n  getRel S_Top G =\n  {(x, y). x \\<in> vertices G \\<and> y \\<in> vertices G} \\<and>\n  (\\<forall>(l, v)\\<in>(\\<lambda>c. (S_Const c, Inl c)) ` C.\n      getRel l G = {(v, v)})\n  maintained ?r1 cfg \\<Longrightarrow> maintained ?r1 G\n\ngoal (1 subgoal):\n 1. graph G", "by auto"], ["proof (state)\nthis:\n  graph G\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) \\<Longrightarrow>\n    \\<exists>G. model C G T", "have \"(a,b)\\<in>T \\<Longrightarrow> G \\<Turnstile> (a,b)\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> T \\<Longrightarrow> G \\<Turnstile> (a, b)", "proof(subst eq_as_subsets,standard)"], ["proof (state)\ngoal (2 subgoals):\n 1. (a, b) \\<in> T \\<Longrightarrow> G \\<Turnstile> a \\<sqsubseteq> b\n 2. (a, b) \\<in> T \\<Longrightarrow> G \\<Turnstile> b \\<sqsubseteq> a", "assume a:\"(a,b)\\<in>T\""], ["proof (state)\nthis:\n  (a, b) \\<in> T\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> T \\<Longrightarrow> G \\<Turnstile> a \\<sqsubseteq> b\n 2. (a, b) \\<in> T \\<Longrightarrow> G \\<Turnstile> b \\<sqsubseteq> a", "from a cfg_m[unfolded transl_rules_def,THEN m]"], ["proof (chain)\npicking this:\n  (a, b) \\<in> T\n  ?r1\n  \\<in> (\\<Union>(x, y)\\<in>T.\n            {(translation x, translation (A_Int x y)),\n             (translation y, translation (A_Int y x))}) \\<Longrightarrow>\n  maintained ?r1 G", "show \"G \\<Turnstile> a \\<sqsubseteq> b\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> T\n  ?r1\n  \\<in> (\\<Union>(x, y)\\<in>T.\n            {(translation x, translation (A_Int x y)),\n             (translation y, translation (A_Int y x))}) \\<Longrightarrow>\n  maintained ?r1 G\n\ngoal (1 subgoal):\n 1. G \\<Turnstile> a \\<sqsubseteq> b", "by (subst maintained_holds_iff[OF g,symmetric]) blast"], ["proof (state)\nthis:\n  G \\<Turnstile> a \\<sqsubseteq> b\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> T \\<Longrightarrow> G \\<Turnstile> b \\<sqsubseteq> a", "from a cfg_m[unfolded transl_rules_def,THEN m]"], ["proof (chain)\npicking this:\n  (a, b) \\<in> T\n  ?r1\n  \\<in> (\\<Union>(x, y)\\<in>T.\n            {(translation x, translation (A_Int x y)),\n             (translation y, translation (A_Int y x))}) \\<Longrightarrow>\n  maintained ?r1 G", "show \"G \\<Turnstile> b \\<sqsubseteq> a\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> T\n  ?r1\n  \\<in> (\\<Union>(x, y)\\<in>T.\n            {(translation x, translation (A_Int x y)),\n             (translation y, translation (A_Int y x))}) \\<Longrightarrow>\n  maintained ?r1 G\n\ngoal (1 subgoal):\n 1. G \\<Turnstile> b \\<sqsubseteq> a", "by (subst maintained_holds_iff[OF g,symmetric]) blast"], ["proof (state)\nthis:\n  G \\<Turnstile> b \\<sqsubseteq> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?a1, ?b1) \\<in> T \\<Longrightarrow> G \\<Turnstile> (?a1, ?b1)\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) \\<Longrightarrow>\n    \\<exists>G. model C G T", "hence h:\"(\\<forall>S\\<in>T. G \\<Turnstile> S)\""], ["proof (prove)\nusing this:\n  (?a1, ?b1) \\<in> T \\<Longrightarrow> G \\<Turnstile> (?a1, ?b1)\n\ngoal (1 subgoal):\n 1. \\<forall>S\\<in>T. G \\<Turnstile> S", "by auto"], ["proof (state)\nthis:\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) \\<Longrightarrow>\n    \\<exists>G. model C G T", "with G_std"], ["proof (chain)\npicking this:\n  standard' C G\n  \\<forall>S\\<in>T. G \\<Turnstile> S", "show ?rhs"], ["proof (prove)\nusing this:\n  standard' C G\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. \\<exists>G. model C G T", "unfolding model_def"], ["proof (prove)\nusing this:\n  standard' C G\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. \\<exists>G. standard' C G \\<and> (\\<forall>S\\<in>T. G \\<Turnstile> S)", "by blast"], ["proof (state)\nthis:\n  \\<exists>G. model C G T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  check_consistency C (transl_rules T) \\<Longrightarrow>\n  \\<exists>G. model C G T\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "have d2: \"\\<not> ?lhs \\<Longrightarrow> ?rhs \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"\\<not> ?lhs\""], ["proof (state)\nthis:\n  getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {}", "obtain a b where ab:\"(S_Bot,a,b) \\<in> edges cfg\"\n      \"a \\<in> vertices cfg\" \"b \\<in> vertices cfg\""], ["proof (prove)\nusing this:\n  getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>(S_Bot, a, b) \\<in> edges cfg; a \\<in> vertices cfg;\n         b \\<in> vertices cfg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cfg_g"], ["proof (prove)\nusing this:\n  getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {}\n  graph cfg\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>(S_Bot, a, b) \\<in> edges cfg; a \\<in> vertices cfg;\n         b \\<in> vertices cfg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding cfg getRel_def"], ["proof (prove)\nusing this:\n  {(x, y).\n   (S_Bot, x, y) \\<in> edges (the_model C (transl_rules T))} \\<noteq>\n  {}\n  graph (the_model C (transl_rules T))\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>(S_Bot, a, b) \\<in> edges (the_model C (transl_rules T));\n         a \\<in> vertices (the_model C (transl_rules T));\n         b \\<in> vertices (the_model C (transl_rules T))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (S_Bot, a, b) \\<in> edges cfg\n  a \\<in> vertices cfg\n  b \\<in> vertices cfg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>G. model C G T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>G. model C G T", "obtain G :: \"('a Standard_Constant, 'a + nat) labeled_graph\"\n      where G:\"model C G T\""], ["proof (prove)\nusing this:\n  \\<exists>G. model C G T\n\ngoal (1 subgoal):\n 1. (\\<And>G. model C G T \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  model C G T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "with model_def"], ["proof (chain)\npicking this:\n  model ?C ?G ?T \\<equiv>\n  standard' ?C ?G \\<and> (\\<forall>S\\<in>?T. ?G \\<Turnstile> S)\n  model C G T", "have std:\"standard' C G\" and holds:\"\\<forall>S\\<in>T. G \\<Turnstile> S\""], ["proof (prove)\nusing this:\n  model ?C ?G ?T \\<equiv>\n  standard' ?C ?G \\<and> (\\<forall>S\\<in>?T. ?G \\<Turnstile> S)\n  model C G T\n\ngoal (1 subgoal):\n 1. standard' C G &&& \\<forall>S\\<in>T. G \\<Turnstile> S", "by fast+"], ["proof (state)\nthis:\n  standard' C G\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "hence g:\"graph G\""], ["proof (prove)\nusing this:\n  standard' C G\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. graph G", "unfolding standard_def"], ["proof (prove)\nusing this:\n  graph G \\<and>\n  vertices G \\<noteq> {} \\<and>\n  ident_rel S_Idt G \\<and>\n  getRel S_Bot G = {} \\<and>\n  getRel S_Top G =\n  {(x, y). x \\<in> vertices G \\<and> y \\<in> vertices G} \\<and>\n  (\\<forall>(l, v)\\<in>(\\<lambda>c. (S_Const c, Inl c)) ` C.\n      getRel l G = {(v, v)})\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. graph G", "by auto"], ["proof (state)\nthis:\n  graph G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "from maintained_holds_iff[OF g] holds"], ["proof (chain)\npicking this:\n  maintained\n   (translation ?e\\<^sub>L, translation (A_Int ?e\\<^sub>L ?e\\<^sub>R)) G =\n  G \\<Turnstile> ?e\\<^sub>L \\<sqsubseteq> ?e\\<^sub>R\n  \\<forall>S\\<in>T. G \\<Turnstile> S", "have \"maintainedA (transl_rules T) G\""], ["proof (prove)\nusing this:\n  maintained\n   (translation ?e\\<^sub>L, translation (A_Int ?e\\<^sub>L ?e\\<^sub>R)) G =\n  G \\<Turnstile> ?e\\<^sub>L \\<sqsubseteq> ?e\\<^sub>R\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. maintainedA (transl_rules T) G", "unfolding transl_rules_def"], ["proof (prove)\nusing this:\n  maintained\n   (translation ?e\\<^sub>L, translation (A_Int ?e\\<^sub>L ?e\\<^sub>R)) G =\n  G \\<Turnstile> ?e\\<^sub>L \\<sqsubseteq> ?e\\<^sub>R\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. maintainedA\n     (\\<Union>(x, y)\\<in>T.\n         {(translation x, translation (A_Int x y)),\n          (translation y, translation (A_Int y x))})\n     G", "by auto"], ["proof (state)\nthis:\n  maintainedA (transl_rules T) G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "hence mnt:\"maintainedA Rules G\""], ["proof (prove)\nusing this:\n  maintainedA (transl_rules T) G\n\ngoal (1 subgoal):\n 1. maintainedA Rules G", "unfolding Rules_def"], ["proof (prove)\nusing this:\n  maintainedA (transl_rules T) G\n\ngoal (1 subgoal):\n 1. maintainedA (transl_rules T \\<union> standard_rules C L) G", "using standard_maintains_rules[OF std]"], ["proof (prove)\nusing this:\n  maintainedA (transl_rules T) G\n  maintainedA (standard_rules C ?L) G\n\ngoal (1 subgoal):\n 1. maintainedA (transl_rules T \\<union> standard_rules C L) G", "by auto"], ["proof (state)\nthis:\n  maintainedA Rules G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "from consequence_graphI[OF _ _ g] gr[unfolded set_of_graph_rules_def] mnt"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>R. R \\<in> ?Rs \\<Longrightarrow> maintained R G;\n   \\<And>R. R \\<in> ?Rs \\<Longrightarrow> subgraph (fst R) (snd R)\\<rbrakk>\n  \\<Longrightarrow> consequence_graph ?Rs G\n  \\<forall>R\\<in>Rules. graph_rule R\n  maintainedA Rules G", "have cg:\"consequence_graph Rules G\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>R. R \\<in> ?Rs \\<Longrightarrow> maintained R G;\n   \\<And>R. R \\<in> ?Rs \\<Longrightarrow> subgraph (fst R) (snd R)\\<rbrakk>\n  \\<Longrightarrow> consequence_graph ?Rs G\n  \\<forall>R\\<in>Rules. graph_rule R\n  maintainedA Rules G\n\ngoal (1 subgoal):\n 1. consequence_graph Rules G", "by fast"], ["proof (state)\nthis:\n  consequence_graph Rules G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "with cfg_l[unfolded least_def]"], ["proof (chain)\npicking this:\n  subgraph (graph_of (0, {})) cfg \\<and>\n  (\\<forall>C.\n      consequence_graph Rules C \\<longrightarrow>\n      maintained (graph_of (0, {}), cfg) C)\n  consequence_graph Rules G", "have mtd:\"maintained (graph_of (0, {}), cfg) G\""], ["proof (prove)\nusing this:\n  subgraph (graph_of (0, {})) cfg \\<and>\n  (\\<forall>C.\n      consequence_graph Rules C \\<longrightarrow>\n      maintained (graph_of (0, {}), cfg) C)\n  consequence_graph Rules G\n\ngoal (1 subgoal):\n 1. maintained (graph_of (0, {}), cfg) G", "by blast"], ["proof (state)\nthis:\n  maintained (graph_of (0, {}), cfg) G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "have \"graph_homomorphism (fst (graph_of (0::nat, {}), cfg)) G {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_homomorphism (fst (graph_of (0, {}), cfg)) G {}", "unfolding graph_homomorphism_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vertices (fst (graph_of (0, {}), cfg)) = Domain {} \\<and>\n    graph (fst (graph_of (0, {}), cfg)) \\<and>\n    graph G \\<and>\n    {} `` vertices (fst (graph_of (0, {}), cfg))\n    \\<subseteq> vertices G \\<and>\n    univalent {} \\<and>\n    edge_preserving {} (edges (fst (graph_of (0, {}), cfg))) (edges G)", "using g"], ["proof (prove)\nusing this:\n  graph G\n\ngoal (1 subgoal):\n 1. vertices (fst (graph_of (0, {}), cfg)) = Domain {} \\<and>\n    graph (fst (graph_of (0, {}), cfg)) \\<and>\n    graph G \\<and>\n    {} `` vertices (fst (graph_of (0, {}), cfg))\n    \\<subseteq> vertices G \\<and>\n    univalent {} \\<and>\n    edge_preserving {} (edges (fst (graph_of (0, {}), cfg))) (edges G)", "by auto"], ["proof (state)\nthis:\n  graph_homomorphism (fst (graph_of (0, {}), cfg)) G {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "with mtd maintained_def"], ["proof (chain)\npicking this:\n  maintained (graph_of (0, {}), cfg) G\n  maintained ?R ?G \\<equiv>\n  \\<forall>f.\n     graph_homomorphism (fst ?R) ?G f \\<longrightarrow> extensible ?R ?G f\n  graph_homomorphism (fst (graph_of (0, {}), cfg)) G {}", "have \"extensible (graph_of (0, {}), cfg) G {}\""], ["proof (prove)\nusing this:\n  maintained (graph_of (0, {}), cfg) G\n  maintained ?R ?G \\<equiv>\n  \\<forall>f.\n     graph_homomorphism (fst ?R) ?G f \\<longrightarrow> extensible ?R ?G f\n  graph_homomorphism (fst (graph_of (0, {}), cfg)) G {}\n\ngoal (1 subgoal):\n 1. extensible (graph_of (0, {}), cfg) G {}", "by auto"], ["proof (state)\nthis:\n  extensible (graph_of (0, {}), cfg) G {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  extensible (graph_of (0, {}), cfg) G {}", "obtain g where \"edges (map_graph g cfg) \\<subseteq> edges G\" \"vertices cfg = Domain g\""], ["proof (prove)\nusing this:\n  extensible (graph_of (0, {}), cfg) G {}\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>edges (map_graph g cfg) \\<subseteq> edges G;\n         vertices cfg = Domain g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding extensible_def graph_homomorphism_def2 graph_union_iff"], ["proof (prove)\nusing this:\n  \\<exists>g.\n     (vertices (snd (graph_of (0, {}), cfg)) = Domain g \\<and>\n      univalent g \\<and>\n      graph (snd (graph_of (0, {}), cfg)) \\<and>\n      graph G \\<and>\n      edges (map_graph g (snd (graph_of (0, {}), cfg)))\n      \\<subseteq> edges G \\<and>\n      vertices (map_graph g (snd (graph_of (0, {}), cfg)))\n      \\<subseteq> vertices G) \\<and>\n     agree_on (fst (graph_of (0, {}), cfg)) {} g\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>edges (map_graph g cfg) \\<subseteq> edges G;\n         vertices cfg = Domain g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  edges (map_graph g cfg) \\<subseteq> edges G\n  vertices cfg = Domain g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"\\<exists> a b. (S_Bot,a,b) \\<in> edges G\""], ["proof (prove)\nusing this:\n  edges (map_graph g cfg) \\<subseteq> edges G\n  vertices cfg = Domain g\n\ngoal (1 subgoal):\n 1. \\<exists>a b. (S_Bot, a, b) \\<in> edges G", "using ab"], ["proof (prove)\nusing this:\n  edges (map_graph g cfg) \\<subseteq> edges G\n  vertices cfg = Domain g\n  (S_Bot, a, b) \\<in> edges cfg\n  a \\<in> vertices cfg\n  b \\<in> vertices cfg\n\ngoal (1 subgoal):\n 1. \\<exists>a b. (S_Bot, a, b) \\<in> edges G", "unfolding edge_preserving"], ["proof (prove)\nusing this:\n  edges (map_graph g cfg) \\<subseteq> edges G\n  vertices cfg = Domain g\n  (S_Bot, a, b) \\<in> edges cfg\n  a \\<in> vertices cfg\n  b \\<in> vertices cfg\n\ngoal (1 subgoal):\n 1. \\<exists>a b. (S_Bot, a, b) \\<in> edges G", "by auto"], ["proof (state)\nthis:\n  \\<exists>a b. (S_Bot, a, b) \\<in> edges G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n     \\<exists>G. model C G T\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>a b. (S_Bot, a, b) \\<in> edges G\n\ngoal (1 subgoal):\n 1. False", "using std"], ["proof (prove)\nusing this:\n  \\<exists>a b. (S_Bot, a, b) \\<in> edges G\n  standard' C G\n\ngoal (1 subgoal):\n 1. False", "unfolding standard_def getRel_def"], ["proof (prove)\nusing this:\n  \\<exists>a b. (S_Bot, a, b) \\<in> edges G\n  graph G \\<and>\n  vertices G \\<noteq> {} \\<and>\n  {(x, y). (S_Idt, x, y) \\<in> edges G} =\n  (\\<lambda>x. (x, x)) ` vertices G \\<and>\n  {(x, y). (S_Bot, x, y) \\<in> edges G} = {} \\<and>\n  {(x, y). (S_Top, x, y) \\<in> edges G} =\n  {(x, y). x \\<in> vertices G \\<and> y \\<in> vertices G} \\<and>\n  (\\<forall>(l, v)\\<in>(\\<lambda>c. (S_Const c, Inl c)) ` C.\n      {(x, y). (l, x, y) \\<in> edges G} = {(v, v)})\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n   \\<exists>G. model C G T\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "from d1 d2"], ["proof (chain)\npicking this:\n  check_consistency C (transl_rules T) \\<Longrightarrow>\n  \\<exists>G. model C G T\n  \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n   \\<exists>G. model C G T\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  check_consistency C (transl_rules T) \\<Longrightarrow>\n  \\<exists>G. model C G T\n  \\<lbrakk>getRel S_Bot (the_model C (transl_rules T)) \\<noteq> {};\n   \\<exists>G. model C G T\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. check_consistency C (transl_rules T) = (\\<exists>G. model C G T)", "by metis"], ["proof (state)\nthis:\n  check_consistency C (transl_rules T) = (\\<exists>G. model C G T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma check_entailment:\n  assumes \"finite T\" \"finite C\"\n  shows \"check_entailment C (transl_rules T) S \\<longleftrightarrow> entails (t::nat itself) C T (fst S, (A_Int (fst S) (snd S)))\"\n   (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "from assms(1)"], ["proof (chain)\npicking this:\n  finite T", "have fin_t:\"finite (transl_rules T)\""], ["proof (prove)\nusing this:\n  finite T\n\ngoal (1 subgoal):\n 1. finite (transl_rules T)", "unfolding transl_rules_def"], ["proof (prove)\nusing this:\n  finite T\n\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>(x, y)\\<in>T.\n         {(translation x, translation (A_Int x y)),\n          (translation y, translation (A_Int y x))})", "by fast"], ["proof (state)\nthis:\n  finite (transl_rules T)\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "define R where \"R = transl_rule S\""], ["proof (state)\nthis:\n  R = transl_rule S\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "define init where \"init = (card (vertices (fst R)), edges (fst R))\""], ["proof (state)\nthis:\n  init = (card (vertices (fst R)), edges (fst R))\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have gi[intro]:\"graph (graph_of init)\" and init:\"graph_of init = translation (fst S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph (graph_of init) &&& graph_of init = translation (fst S)", "using verts_in_translation[of \"fst S\"]"], ["proof (prove)\nusing this:\n  inv_translation (vertices (translation (fst S)))\n\ngoal (1 subgoal):\n 1. graph (graph_of init) &&& graph_of init = translation (fst S)", "unfolding inv_translation_def init_def R_def"], ["proof (prove)\nusing this:\n  {0..<card (vertices (translation (fst S)))} =\n  vertices (translation (fst S)) \\<and>\n  {0, 1} \\<subseteq> vertices (translation (fst S))\n\ngoal (1 subgoal):\n 1. graph\n     (graph_of\n       (card (vertices (fst (transl_rule S))),\n        edges (fst (transl_rule S)))) &&&\n    graph_of\n     (card (vertices (fst (transl_rule S))), edges (fst (transl_rule S))) =\n    translation (fst S)", "by auto"], ["proof (state)\nthis:\n  graph (graph_of init)\n  graph_of init = translation (fst S)\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "define Rs where \"Rs = transl_rules T\""], ["proof (state)\nthis:\n  Rs = transl_rules T\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "define L where\n    \"L = fst ` (\\<Union> ((edges o snd) ` Rs)) \\<union> {S_Bot,S_Top,S_Idt} \\<union> S_Const ` C \\<union> fst ` edges (fst R)\""], ["proof (state)\nthis:\n  L =\n  fst ` \\<Union> ((edges \\<circ> snd) ` Rs) \\<union>\n  {S_Bot, S_Top, S_Idt} \\<union>\n  S_Const ` C \\<union>\n  fst ` edges (fst R)\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have \"finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))", "using fin_t gr_transl_rules"], ["proof (prove)\nusing this:\n  finite (transl_rules T)\n  ?x \\<in> transl_rules ?T \\<Longrightarrow> graph_rule ?x\n\ngoal (1 subgoal):\n 1. finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))", "by auto"], ["proof (state)\nthis:\n  finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "hence fin_l:\"finite L\""], ["proof (prove)\nusing this:\n  finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))\n\ngoal (1 subgoal):\n 1. finite L", "unfolding L_def Rs_def R_def"], ["proof (prove)\nusing this:\n  finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))\n\ngoal (1 subgoal):\n 1. finite\n     (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n      {S_Bot, S_Top, S_Idt} \\<union>\n      S_Const ` C \\<union>\n      fst ` edges (fst (transl_rule S)))", "using assms(2)"], ["proof (prove)\nusing this:\n  finite (\\<Union> ((edges \\<circ> snd) ` transl_rules T))\n  finite C\n\ngoal (1 subgoal):\n 1. finite\n     (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n      {S_Bot, S_Top, S_Idt} \\<union>\n      S_Const ` C \\<union>\n      fst ` edges (fst (transl_rule S)))", "by auto"], ["proof (state)\nthis:\n  finite L\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have fin_t:\"finite Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Rs", "using fin_t Rs_def"], ["proof (prove)\nusing this:\n  finite (transl_rules T)\n  Rs = transl_rules T\n\ngoal (1 subgoal):\n 1. finite Rs", "by auto"], ["proof (state)\nthis:\n  finite Rs\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "define Rules where \"Rules = Rs \\<union> standard_rules C L\""], ["proof (state)\nthis:\n  Rules = Rs \\<union> standard_rules C L\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "hence fin_r:\"finite Rules\""], ["proof (prove)\nusing this:\n  Rules = Rs \\<union> standard_rules C L\n\ngoal (1 subgoal):\n 1. finite Rules", "using assms(2) fin_t fin_l"], ["proof (prove)\nusing this:\n  Rules = Rs \\<union> standard_rules C L\n  finite C\n  finite Rs\n  finite L\n\ngoal (1 subgoal):\n 1. finite Rules", "unfolding standard_rules_def"], ["proof (prove)\nusing this:\n  Rules =\n  Rs \\<union>\n  (constant_rules C \\<union> identity_rules L \\<union>\n   {top_rule S_Top, nonempty_rule})\n  finite C\n  finite Rs\n  finite L\n\ngoal (1 subgoal):\n 1. finite Rules", "by auto"], ["proof (state)\nthis:\n  finite Rules\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have incl_L:\"fst ` (\\<Union> ((edges o snd) ` Rules)) \\<subseteq> L\" \"fst ` snd init \\<subseteq> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` \\<Union> ((edges \\<circ> snd) ` Rules) \\<subseteq> L &&&\n    fst ` snd init \\<subseteq> L", "unfolding L_def Rules_def init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    \\<Union>\n     ((edges \\<circ> snd) `\n      (Rs \\<union>\n       standard_rules C\n        (fst ` \\<Union> ((edges \\<circ> snd) ` Rs) \\<union>\n         {S_Bot, S_Top, S_Idt} \\<union>\n         S_Const ` C \\<union>\n         fst ` edges (fst R))))\n    \\<subseteq> fst ` \\<Union> ((edges \\<circ> snd) ` Rs) \\<union>\n                {S_Bot, S_Top, S_Idt} \\<union>\n                S_Const ` C \\<union>\n                fst ` edges (fst R) &&&\n    fst ` snd (card (vertices (fst R)), edges (fst R))\n    \\<subseteq> fst ` \\<Union> ((edges \\<circ> snd) ` Rs) \\<union>\n                {S_Bot, S_Top, S_Idt} \\<union>\n                S_Const ` C \\<union>\n                fst ` edges (fst R)", "by (auto elim:standard_rules_edges)"], ["proof (state)\nthis:\n  fst ` \\<Union> ((edges \\<circ> snd) ` Rules) \\<subseteq> L\n  fst ` snd init \\<subseteq> L\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have \"\\<forall>R\\<in>transl_rules T. graph_rule R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>transl_rules T. graph_rule R", "using gr_transl_rules"], ["proof (prove)\nusing this:\n  ?x \\<in> transl_rules ?T \\<Longrightarrow> graph_rule ?x\n\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>transl_rules T. graph_rule R", "by blast"], ["proof (state)\nthis:\n  \\<forall>R\\<in>transl_rules T. graph_rule R\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "moreover"], ["proof (state)\nthis:\n  \\<forall>R\\<in>transl_rules T. graph_rule R\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have \"\\<forall>R\\<in> constant_rules C. graph_rule R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>constant_rules C. graph_rule R", "using constant_rules_graph_rule"], ["proof (prove)\nusing this:\n  ?x \\<in> constant_rules ?C \\<Longrightarrow> graph_rule ?x\n\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>constant_rules C. graph_rule R", "by auto"], ["proof (state)\nthis:\n  \\<forall>R\\<in>constant_rules C. graph_rule R\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "moreover"], ["proof (state)\nthis:\n  \\<forall>R\\<in>constant_rules C. graph_rule R\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have \"\\<forall>R\\<in> identity_rules L. graph_rule R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>identity_rules L. graph_rule R", "using identity_rules_graph_rule"], ["proof (prove)\nusing this:\n  ?x \\<in> identity_rules ?L \\<Longrightarrow> graph_rule ?x\n\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>identity_rules L. graph_rule R", "by auto"], ["proof (state)\nthis:\n  \\<forall>R\\<in>identity_rules L. graph_rule R\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "moreover"], ["proof (state)\nthis:\n  \\<forall>R\\<in>identity_rules L. graph_rule R\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have \"\\<forall>R\\<in> {top_rule S_Top,nonempty_rule}. graph_rule R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R", "using are_rules(1,2)"], ["proof (prove)\nusing this:\n  graph_rule nonempty_rule\n  graph_rule (top_rule ?t)\n\ngoal (1 subgoal):\n 1. \\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>R\\<in>transl_rules T. graph_rule R\n  \\<forall>R\\<in>constant_rules C. graph_rule R\n  \\<forall>R\\<in>identity_rules L. graph_rule R\n  \\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R", "have gr:\"set_of_graph_rules Rules\""], ["proof (prove)\nusing this:\n  \\<forall>R\\<in>transl_rules T. graph_rule R\n  \\<forall>R\\<in>constant_rules C. graph_rule R\n  \\<forall>R\\<in>identity_rules L. graph_rule R\n  \\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R\n\ngoal (1 subgoal):\n 1. set_of_graph_rules Rules", "unfolding set_of_graph_rules_def Rules_def ball_Un standard_rules_def Rs_def"], ["proof (prove)\nusing this:\n  \\<forall>R\\<in>transl_rules T. graph_rule R\n  \\<forall>R\\<in>constant_rules C. graph_rule R\n  \\<forall>R\\<in>identity_rules L. graph_rule R\n  \\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R\n\ngoal (1 subgoal):\n 1. (\\<forall>R\\<in>transl_rules T. graph_rule R) \\<and>\n    ((\\<forall>R\\<in>constant_rules C. graph_rule R) \\<and>\n     (\\<forall>R\\<in>identity_rules L. graph_rule R)) \\<and>\n    (\\<forall>R\\<in>{top_rule S_Top, nonempty_rule}. graph_rule R)", "by blast"], ["proof (state)\nthis:\n  set_of_graph_rules Rules\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "define sel where \"sel = non_constructive_selector Rules\""], ["proof (state)\nthis:\n  sel = non_constructive_selector Rules\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "hence sel:\"valid_selector Rules sel\""], ["proof (prove)\nusing this:\n  sel = non_constructive_selector Rules\n\ngoal (1 subgoal):\n 1. valid_selector Rules sel", "using gr non_constructive_selector"], ["proof (prove)\nusing this:\n  sel = non_constructive_selector Rules\n  set_of_graph_rules Rules\n  set_of_graph_rules ?Rs \\<Longrightarrow>\n  valid_selector ?Rs (non_constructive_selector ?Rs)\n\ngoal (1 subgoal):\n 1. valid_selector Rules sel", "by auto"], ["proof (state)\nthis:\n  valid_selector Rules sel\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "define cfg where \"cfg = the_lcg sel Rules init\""], ["proof (state)\nthis:\n  cfg = the_lcg sel Rules init\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have cfg:\"cfg = entailment_model C Rs (fst R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg = entailment_model C Rs (fst R)", "unfolding cfg_def sel_def Rules_def L_def entailment_model_def Let_def init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_lcg\n     (non_constructive_selector\n       (Rs \\<union>\n        standard_rules C\n         (fst ` \\<Union> ((edges \\<circ> snd) ` Rs) \\<union>\n          {S_Bot, S_Top, S_Idt} \\<union>\n          S_Const ` C \\<union>\n          fst ` edges (fst R))))\n     (Rs \\<union>\n      standard_rules C\n       (fst ` \\<Union> ((edges \\<circ> snd) ` Rs) \\<union>\n        {S_Bot, S_Top, S_Idt} \\<union>\n        S_Const ` C \\<union>\n        fst ` edges (fst R)))\n     (card (vertices (fst R)), edges (fst R)) =\n    the_lcg\n     (non_constructive_selector\n       (Rs \\<union>\n        standard_rules C\n         (fst ` \\<Union> ((edges \\<circ> snd) ` Rs) \\<union>\n          {S_Bot, S_Top, S_Idt} \\<union>\n          S_Const ` C \\<union>\n          fst ` edges (fst R))))\n     (Rs \\<union>\n      standard_rules C\n       (fst ` \\<Union> ((edges \\<circ> snd) ` Rs) \\<union>\n        {S_Bot, S_Top, S_Idt} \\<union>\n        S_Const ` C \\<union>\n        fst ` edges (fst R)))\n     (card (vertices (fst R)), edges (fst R))", ".."], ["proof (state)\nthis:\n  cfg = entailment_model C Rs (fst R)\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have cfg_c:\"least_consequence_graph TYPE('a + nat) Rules (graph_of init) cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. least_consequence_graph TYPE('a + nat) Rules (graph_of init) cfg", "unfolding cfg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. least_consequence_graph TYPE('a + nat) Rules (graph_of init)\n     (the_lcg sel Rules init)", "by (rule lcg_through_make_step[OF fin_r gr gi sel])"], ["proof (state)\nthis:\n  least_consequence_graph TYPE('a + nat) Rules (graph_of init) cfg\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "hence cfg_sdt:\"maintainedA (standard_rules C L) cfg\"\n    and cfg_g: \"graph cfg\"\n    and cfg_l:\"least TYPE('a + nat) Rules (graph_of init) cfg\"\n    and cfg_m:\"r \\<in> Rs \\<Longrightarrow> maintained r cfg\" for r"], ["proof (prove)\nusing this:\n  least_consequence_graph TYPE('a + nat) Rules (graph_of init) cfg\n\ngoal (1 subgoal):\n 1. (maintainedA (standard_rules C L) cfg &&& graph cfg) &&&\n    least TYPE('a + nat) Rules (graph_of init) cfg &&&\n    (r \\<in> Rs \\<Longrightarrow> maintained r cfg)", "unfolding Rules_def least_consequence_graph_def"], ["proof (prove)\nusing this:\n  consequence_graph (Rs \\<union> standard_rules C L) cfg \\<and>\n  least TYPE('a + nat) (Rs \\<union> standard_rules C L) (graph_of init) cfg\n\ngoal (1 subgoal):\n 1. (maintainedA (standard_rules C L) cfg &&& graph cfg) &&&\n    least TYPE('a + nat) (Rs \\<union> standard_rules C L) (graph_of init)\n     cfg &&&\n    (r \\<in> Rs \\<Longrightarrow> maintained r cfg)", "by auto"], ["proof (state)\nthis:\n  maintainedA (standard_rules C L) cfg\n  graph cfg\n  least TYPE('a + nat) Rules (graph_of init) cfg\n  ?r1 \\<in> Rs \\<Longrightarrow> maintained ?r1 cfg\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have cfg_lbl:\"fst ` edges cfg \\<subseteq> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` edges cfg \\<subseteq> L", "unfolding cfg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` edges (the_lcg sel Rules init) \\<subseteq> L", "by (auto intro!: the_lcg_edges[OF sel incl_L])"], ["proof (state)\nthis:\n  fst ` edges cfg \\<subseteq> L\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have \"(0,1) \\<in> :translation (fst S):\\<lbrakk>fst S\\<rbrakk>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0, 1) \\<in> :translation (fst S):\\<lbrakk>fst S\\<rbrakk>", "by (fact translation_self)"], ["proof (state)\nthis:\n  (0, 1) \\<in> :translation (fst S):\\<lbrakk>fst S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "hence \"(0,1) \\<in> :graph_of init:\\<lbrakk>fst S\\<rbrakk>\""], ["proof (prove)\nusing this:\n  (0, 1) \\<in> :translation (fst S):\\<lbrakk>fst S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. (0, 1) \\<in> :graph_of init:\\<lbrakk>fst S\\<rbrakk>", "unfolding init"], ["proof (prove)\nusing this:\n  (0, 1) \\<in> :translation (fst S):\\<lbrakk>fst S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. (0, 1) \\<in> :translation (fst S):\\<lbrakk>fst S\\<rbrakk>", "by auto"], ["proof (state)\nthis:\n  (0, 1) \\<in> :graph_of init:\\<lbrakk>fst S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "from subgraph_semantics[OF _ this] cfg_l[unfolded least_def]"], ["proof (chain)\npicking this:\n  subgraph (graph_of init) ?B \\<Longrightarrow>\n  (0, 1) \\<in> :?B:\\<lbrakk>fst S\\<rbrakk>\n  subgraph (graph_of init) cfg \\<and>\n  (\\<forall>C.\n      consequence_graph Rules C \\<longrightarrow>\n      maintained (graph_of init, cfg) C)", "have cfg_fst:\"(0,1) \\<in> :cfg:\\<lbrakk>fst S\\<rbrakk>\""], ["proof (prove)\nusing this:\n  subgraph (graph_of init) ?B \\<Longrightarrow>\n  (0, 1) \\<in> :?B:\\<lbrakk>fst S\\<rbrakk>\n  subgraph (graph_of init) cfg \\<and>\n  (\\<forall>C.\n      consequence_graph Rules C \\<longrightarrow>\n      maintained (graph_of init, cfg) C)\n\ngoal (1 subgoal):\n 1. (0, 1) \\<in> :cfg:\\<lbrakk>fst S\\<rbrakk>", "unfolding cfg_def"], ["proof (prove)\nusing this:\n  subgraph (graph_of init) ?B \\<Longrightarrow>\n  (0, 1) \\<in> :?B:\\<lbrakk>fst S\\<rbrakk>\n  subgraph (graph_of init) (the_lcg sel Rules init) \\<and>\n  (\\<forall>C.\n      consequence_graph Rules C \\<longrightarrow>\n      maintained (graph_of init, the_lcg sel Rules init) C)\n\ngoal (1 subgoal):\n 1. (0, 1) \\<in> :the_lcg sel Rules init:\\<lbrakk>fst S\\<rbrakk>", "by auto"], ["proof (state)\nthis:\n  (0, 1) \\<in> :cfg:\\<lbrakk>fst S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "from semantics_in_vertices[OF cfg_g this]"], ["proof (chain)\npicking this:\n  0 \\<in> vertices cfg\n  1 \\<in> vertices cfg", "have cfg_01:\"0 \\<in> vertices cfg\" \"1 \\<in> vertices cfg\" \"(0,1)\\<in>vertices cfg\\<times>vertices cfg\""], ["proof (prove)\nusing this:\n  0 \\<in> vertices cfg\n  1 \\<in> vertices cfg\n\ngoal (1 subgoal):\n 1. 0 \\<in> vertices cfg &&&\n    1 \\<in> vertices cfg &&& (0, 1) \\<in> vertices cfg \\<times> vertices cfg", "by auto"], ["proof (state)\nthis:\n  0 \\<in> vertices cfg\n  1 \\<in> vertices cfg\n  (0, 1) \\<in> vertices cfg \\<times> vertices cfg\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have d1: \"\\<not> ?lhs \\<Longrightarrow> ?rhs \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n     entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n    \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n     entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"\\<not> ?lhs\""], ["proof (state)\nthis:\n  \\<not> check_entailment C (transl_rules T) S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n     entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n    \\<Longrightarrow> False", "hence gr:\"(0,1) \\<notin> :cfg:\\<lbrakk>snd S\\<rbrakk>\" \"getRel S_Bot cfg = {}\""], ["proof (prove)\nusing this:\n  \\<not> check_entailment C (transl_rules T) S\n\ngoal (1 subgoal):\n 1. (0, 1) \\<notin> :cfg:\\<lbrakk>snd S\\<rbrakk> &&& getRel S_Bot cfg = {}", "unfolding entailment_model_def cfg R_def Rs_def Let_def"], ["proof (prove)\nusing this:\n  \\<not> ((0, 1)\n          \\<in> :the_lcg\n                  (non_constructive_selector\n                    (transl_rules T \\<union>\n                     standard_rules C\n                      (fst `\n                       \\<Union>\n                        ((edges \\<circ> snd) ` transl_rules T) \\<union>\n                       {S_Bot, S_Top, S_Idt} \\<union>\n                       S_Const ` C \\<union>\n                       fst ` edges (translation (fst S)))))\n                  (transl_rules T \\<union>\n                   standard_rules C\n                    (fst `\n                     \\<Union>\n                      ((edges \\<circ> snd) ` transl_rules T) \\<union>\n                     {S_Bot, S_Top, S_Idt} \\<union>\n                     S_Const ` C \\<union>\n                     fst ` edges (translation (fst S))))\n                  (card (vertices (translation (fst S))),\n                   edges\n                    (translation (fst S))):\\<lbrakk>snd S\\<rbrakk> \\<or>\n          getRel S_Bot\n           (the_lcg\n             (non_constructive_selector\n               (transl_rules T \\<union>\n                standard_rules C\n                 (fst `\n                  \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n                  {S_Bot, S_Top, S_Idt} \\<union>\n                  S_Const ` C \\<union>\n                  fst ` edges (translation (fst S)))))\n             (transl_rules T \\<union>\n              standard_rules C\n               (fst `\n                \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n                {S_Bot, S_Top, S_Idt} \\<union>\n                S_Const ` C \\<union>\n                fst ` edges (translation (fst S))))\n             (card (vertices (translation (fst S))),\n              edges (translation (fst S)))) \\<noteq>\n          {})\n\ngoal (1 subgoal):\n 1. (0, 1)\n    \\<notin> :the_lcg\n               (non_constructive_selector\n                 (transl_rules T \\<union>\n                  standard_rules C\n                   (fst `\n                    \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n                    {S_Bot, S_Top, S_Idt} \\<union>\n                    S_Const ` C \\<union>\n                    fst ` edges (fst (transl_rule S)))))\n               (transl_rules T \\<union>\n                standard_rules C\n                 (fst `\n                  \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n                  {S_Bot, S_Top, S_Idt} \\<union>\n                  S_Const ` C \\<union>\n                  fst ` edges (fst (transl_rule S))))\n               (card (vertices (fst (transl_rule S))),\n                edges (fst (transl_rule S))):\\<lbrakk>snd S\\<rbrakk> &&&\n    getRel S_Bot\n     (the_lcg\n       (non_constructive_selector\n         (transl_rules T \\<union>\n          standard_rules C\n           (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n            {S_Bot, S_Top, S_Idt} \\<union>\n            S_Const ` C \\<union>\n            fst ` edges (fst (transl_rule S)))))\n       (transl_rules T \\<union>\n        standard_rules C\n         (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n          {S_Bot, S_Top, S_Idt} \\<union>\n          S_Const ` C \\<union>\n          fst ` edges (fst (transl_rule S))))\n       (card (vertices (fst (transl_rule S))),\n        edges (fst (transl_rule S)))) =\n    {}", "by auto"], ["proof (state)\nthis:\n  (0, 1) \\<notin> :cfg:\\<lbrakk>snd S\\<rbrakk>\n  getRel S_Bot cfg = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n     entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n    \\<Longrightarrow> False", "from maintained_standard_noconstants[OF cfg_sdt cfg_g cfg_lbl gr(2)]"], ["proof (chain)\npicking this:\n  \\<exists>f g G.\n     G = map_graph_fn G (f \\<circ> g) \\<and>\n     G = map_graph_fn cfg f \\<and>\n     subgraph (map_graph_fn G g) cfg \\<and>\n     standard' C G \\<and>\n     (\\<forall>r. maintained r cfg \\<longrightarrow> maintained r G) \\<and>\n     (\\<forall>x y e.\n         x \\<in> vertices cfg \\<longrightarrow>\n         y \\<in> vertices cfg \\<longrightarrow>\n         (g (f x), g (f y))\n         \\<in> :map_graph_fn G g:\\<lbrakk>e\\<rbrakk> \\<longrightarrow>\n         (x, y) \\<in> :cfg:\\<lbrakk>e\\<rbrakk>)", "obtain G :: \"('a Standard_Constant, 'a + nat) labeled_graph\" and f g\n      where fg:\"G = map_graph_fn G (f \\<circ> g)\"\n      and f:\"G = map_graph_fn cfg f\" \"subgraph (map_graph_fn G g) cfg\"\n      and G_std:\"standard' C G\"\n      and m:\"\\<And> r:: ('a Standard_Constant, nat) Graph_PreRule. maintained r cfg \\<Longrightarrow> maintained r G\"\n      and e:\"\\<And> x y e. x \\<in> vertices cfg \\<Longrightarrow> y \\<in> vertices cfg \\<Longrightarrow> \n                          (g (f x), g (f y)) \\<in> :map_graph_fn G g:\\<lbrakk>e\\<rbrakk> \\<Longrightarrow> (x,y) \\<in> :cfg:\\<lbrakk>e\\<rbrakk>\""], ["proof (prove)\nusing this:\n  \\<exists>f g G.\n     G = map_graph_fn G (f \\<circ> g) \\<and>\n     G = map_graph_fn cfg f \\<and>\n     subgraph (map_graph_fn G g) cfg \\<and>\n     standard' C G \\<and>\n     (\\<forall>r. maintained r cfg \\<longrightarrow> maintained r G) \\<and>\n     (\\<forall>x y e.\n         x \\<in> vertices cfg \\<longrightarrow>\n         y \\<in> vertices cfg \\<longrightarrow>\n         (g (f x), g (f y))\n         \\<in> :map_graph_fn G g:\\<lbrakk>e\\<rbrakk> \\<longrightarrow>\n         (x, y) \\<in> :cfg:\\<lbrakk>e\\<rbrakk>)\n\ngoal (1 subgoal):\n 1. (\\<And>G f g.\n        \\<lbrakk>G = map_graph_fn G (f \\<circ> g); G = map_graph_fn cfg f;\n         subgraph (map_graph_fn G g) cfg; standard' C G;\n         \\<And>r. maintained r cfg \\<Longrightarrow> maintained r G;\n         \\<And>x y e.\n            \\<lbrakk>x \\<in> vertices cfg; y \\<in> vertices cfg;\n             (g (f x), g (f y))\n             \\<in> :map_graph_fn G g:\\<lbrakk>e\\<rbrakk>\\<rbrakk>\n            \\<Longrightarrow> (x, y) \\<in> :cfg:\\<lbrakk>e\\<rbrakk>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarify blast"], ["proof (state)\nthis:\n  G = map_graph_fn G (f \\<circ> g)\n  G = map_graph_fn cfg f\n  subgraph (map_graph_fn G g) cfg\n  standard' C G\n  maintained ?r1 cfg \\<Longrightarrow> maintained ?r1 G\n  \\<lbrakk>?x1 \\<in> vertices cfg; ?y1 \\<in> vertices cfg;\n   (g (f ?x1), g (f ?y1))\n   \\<in> :map_graph_fn G g:\\<lbrakk>?e1\\<rbrakk>\\<rbrakk>\n  \\<Longrightarrow> (?x1, ?y1) \\<in> :cfg:\\<lbrakk>?e1\\<rbrakk>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n     entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n    \\<Longrightarrow> False", "(* just blast also works, but clarify blast is much faster *)"], ["proof (state)\nthis:\n  G = map_graph_fn G (f \\<circ> g)\n  G = map_graph_fn cfg f\n  subgraph (map_graph_fn G g) cfg\n  standard' C G\n  maintained ?r1 cfg \\<Longrightarrow> maintained ?r1 G\n  \\<lbrakk>?x1 \\<in> vertices cfg; ?y1 \\<in> vertices cfg;\n   (g (f ?x1), g (f ?y1))\n   \\<in> :map_graph_fn G g:\\<lbrakk>?e1\\<rbrakk>\\<rbrakk>\n  \\<Longrightarrow> (?x1, ?y1) \\<in> :cfg:\\<lbrakk>?e1\\<rbrakk>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n     entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n    \\<Longrightarrow> False", "hence g:\"graph G\""], ["proof (prove)\nusing this:\n  G = map_graph_fn G (f \\<circ> g)\n  G = map_graph_fn cfg f\n  subgraph (map_graph_fn G g) cfg\n  standard' C G\n  maintained ?r1 cfg \\<Longrightarrow> maintained ?r1 G\n  \\<lbrakk>?x1 \\<in> vertices cfg; ?y1 \\<in> vertices cfg;\n   (g (f ?x1), g (f ?y1))\n   \\<in> :map_graph_fn G g:\\<lbrakk>?e1\\<rbrakk>\\<rbrakk>\n  \\<Longrightarrow> (?x1, ?y1) \\<in> :cfg:\\<lbrakk>?e1\\<rbrakk>\n\ngoal (1 subgoal):\n 1. graph G", "unfolding standard_def"], ["proof (prove)\nusing this:\n  G = map_graph_fn G (f \\<circ> g)\n  G = map_graph_fn cfg f\n  subgraph (map_graph_fn G g) cfg\n  graph G \\<and>\n  vertices G \\<noteq> {} \\<and>\n  ident_rel S_Idt G \\<and>\n  getRel S_Bot G = {} \\<and>\n  getRel S_Top G =\n  {(x, y). x \\<in> vertices G \\<and> y \\<in> vertices G} \\<and>\n  (\\<forall>(l, v)\\<in>(\\<lambda>c. (S_Const c, Inl c)) ` C.\n      getRel l G = {(v, v)})\n  maintained ?r1 cfg \\<Longrightarrow> maintained ?r1 G\n  \\<lbrakk>?x1 \\<in> vertices cfg; ?y1 \\<in> vertices cfg;\n   (g (f ?x1), g (f ?y1))\n   \\<in> :map_graph_fn G g:\\<lbrakk>?e1\\<rbrakk>\\<rbrakk>\n  \\<Longrightarrow> (?x1, ?y1) \\<in> :cfg:\\<lbrakk>?e1\\<rbrakk>\n\ngoal (1 subgoal):\n 1. graph G", "by auto"], ["proof (state)\nthis:\n  graph G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n     entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n    \\<Longrightarrow> False", "have \"(a,b)\\<in>T \\<Longrightarrow> G \\<Turnstile> (a,b)\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> T \\<Longrightarrow> G \\<Turnstile> (a, b)", "apply(subst eq_as_subsets)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> T \\<Longrightarrow>\n    G \\<Turnstile> a \\<sqsubseteq> b \\<and> G \\<Turnstile> b \\<sqsubseteq> a", "using cfg_m[unfolded transl_rules_def Rs_def,THEN m]"], ["proof (prove)\nusing this:\n  ?r1\n  \\<in> (\\<Union>(x, y)\\<in>T.\n            {(translation x, translation (A_Int x y)),\n             (translation y, translation (A_Int y x))}) \\<Longrightarrow>\n  maintained ?r1 G\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> T \\<Longrightarrow>\n    G \\<Turnstile> a \\<sqsubseteq> b \\<and> G \\<Turnstile> b \\<sqsubseteq> a", "unfolding maintained_holds_iff[OF g,symmetric]"], ["proof (prove)\nusing this:\n  ?r1\n  \\<in> (\\<Union>(x, y)\\<in>T.\n            {(translation x, translation (A_Int x y)),\n             (translation y, translation (A_Int y x))}) \\<Longrightarrow>\n  maintained ?r1 G\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> T \\<Longrightarrow>\n    maintained (translation a, translation (A_Int a b)) G \\<and>\n    maintained (translation b, translation (A_Int b a)) G", "by blast"], ["proof (state)\nthis:\n  (?a1, ?b1) \\<in> T \\<Longrightarrow> G \\<Turnstile> (?a1, ?b1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n     entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n    \\<Longrightarrow> False", "hence h:\"(\\<forall>S\\<in>T. G \\<Turnstile> S)\""], ["proof (prove)\nusing this:\n  (?a1, ?b1) \\<in> T \\<Longrightarrow> G \\<Turnstile> (?a1, ?b1)\n\ngoal (1 subgoal):\n 1. \\<forall>S\\<in>T. G \\<Turnstile> S", "by auto"], ["proof (state)\nthis:\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n     entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"?rhs\""], ["proof (state)\nthis:\n  entails t C T (fst S \\<sqsubseteq> snd S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n     entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n    \\<Longrightarrow> False", "from this[unfolded entails_def model_def] G_std h"], ["proof (chain)\npicking this:\n  \\<forall>G.\n     standard' C G \\<and>\n     (\\<forall>S\\<in>T. G \\<Turnstile> S) \\<longrightarrow>\n     G \\<Turnstile> fst S \\<sqsubseteq> snd S\n  standard' C G\n  \\<forall>S\\<in>T. G \\<Turnstile> S", "have \"G \\<Turnstile> fst S \\<sqsubseteq> snd S\""], ["proof (prove)\nusing this:\n  \\<forall>G.\n     standard' C G \\<and>\n     (\\<forall>S\\<in>T. G \\<Turnstile> S) \\<longrightarrow>\n     G \\<Turnstile> fst S \\<sqsubseteq> snd S\n  standard' C G\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. G \\<Turnstile> fst S \\<sqsubseteq> snd S", "by blast"], ["proof (state)\nthis:\n  G \\<Turnstile> fst S \\<sqsubseteq> snd S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n     entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n    \\<Longrightarrow> False", "with cfg_fst cfg_g f(1)"], ["proof (chain)\npicking this:\n  (0, 1) \\<in> :cfg:\\<lbrakk>fst S\\<rbrakk>\n  graph cfg\n  G = map_graph_fn cfg f\n  G \\<Turnstile> fst S \\<sqsubseteq> snd S", "have \"(f 0, f 1) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>\""], ["proof (prove)\nusing this:\n  (0, 1) \\<in> :cfg:\\<lbrakk>fst S\\<rbrakk>\n  graph cfg\n  G = map_graph_fn cfg f\n  G \\<Turnstile> fst S \\<sqsubseteq> snd S\n\ngoal (1 subgoal):\n 1. (f 0, f 1) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "by auto"], ["proof (state)\nthis:\n  (f 0, f 1) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n     entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (f 0, f 1) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "have \"(g (f 0), g (f 1)) \\<in> :map_graph_fn G g:\\<lbrakk>snd S\\<rbrakk>\""], ["proof (prove)\nusing this:\n  (f 0, f 1) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. (g (f 0), g (f 1)) \\<in> :map_graph_fn G g:\\<lbrakk>snd S\\<rbrakk>", "using map_graph_in[OF g]"], ["proof (prove)\nusing this:\n  (f 0, f 1) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>\n  (?a, ?b) \\<in> :G:\\<lbrakk>?e\\<rbrakk> \\<Longrightarrow>\n  (?f ?a, ?f ?b) \\<in> :map_graph_fn G ?f:\\<lbrakk>?e\\<rbrakk>\n\ngoal (1 subgoal):\n 1. (g (f 0), g (f 1)) \\<in> :map_graph_fn G g:\\<lbrakk>snd S\\<rbrakk>", "by auto"], ["proof (state)\nthis:\n  (g (f 0), g (f 1)) \\<in> :map_graph_fn G g:\\<lbrakk>snd S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n     entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n    \\<Longrightarrow> False", "with e cfg_01(1,2) gr(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x1 \\<in> vertices cfg; ?y1 \\<in> vertices cfg;\n   (g (f ?x1), g (f ?y1))\n   \\<in> :map_graph_fn G g:\\<lbrakk>?e1\\<rbrakk>\\<rbrakk>\n  \\<Longrightarrow> (?x1, ?y1) \\<in> :cfg:\\<lbrakk>?e1\\<rbrakk>\n  0 \\<in> vertices cfg\n  1 \\<in> vertices cfg\n  (0, 1) \\<notin> :cfg:\\<lbrakk>snd S\\<rbrakk>\n  (g (f 0), g (f 1)) \\<in> :map_graph_fn G g:\\<lbrakk>snd S\\<rbrakk>", "show \"False\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1 \\<in> vertices cfg; ?y1 \\<in> vertices cfg;\n   (g (f ?x1), g (f ?y1))\n   \\<in> :map_graph_fn G g:\\<lbrakk>?e1\\<rbrakk>\\<rbrakk>\n  \\<Longrightarrow> (?x1, ?y1) \\<in> :cfg:\\<lbrakk>?e1\\<rbrakk>\n  0 \\<in> vertices cfg\n  1 \\<in> vertices cfg\n  (0, 1) \\<notin> :cfg:\\<lbrakk>snd S\\<rbrakk>\n  (g (f 0), g (f 1)) \\<in> :map_graph_fn G g:\\<lbrakk>snd S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n   entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "have \"?lhs \\<Longrightarrow> model C G T \\<Longrightarrow> (a,b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk> \\<Longrightarrow> (a,b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>\"\n    for G :: \"('a Standard_Constant, 'a + nat) labeled_graph\" and a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "assume mod:\"model C G T\""], ["proof (state)\nthis:\n  model C G T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "from mod model_def"], ["proof (chain)\npicking this:\n  model C G T\n  model ?C ?G ?T \\<equiv>\n  standard' ?C ?G \\<and> (\\<forall>S\\<in>?T. ?G \\<Turnstile> S)", "have std:\"standard' C G\" and holds:\"\\<forall>S\\<in>T. G \\<Turnstile> S\""], ["proof (prove)\nusing this:\n  model C G T\n  model ?C ?G ?T \\<equiv>\n  standard' ?C ?G \\<and> (\\<forall>S\\<in>?T. ?G \\<Turnstile> S)\n\ngoal (1 subgoal):\n 1. standard' C G &&& \\<forall>S\\<in>T. G \\<Turnstile> S", "by fast+"], ["proof (state)\nthis:\n  standard' C G\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "hence g:\"graph G\""], ["proof (prove)\nusing this:\n  standard' C G\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. graph G", "unfolding standard_def"], ["proof (prove)\nusing this:\n  graph G \\<and>\n  vertices G \\<noteq> {} \\<and>\n  ident_rel S_Idt G \\<and>\n  getRel S_Bot G = {} \\<and>\n  getRel S_Top G =\n  {(x, y). x \\<in> vertices G \\<and> y \\<in> vertices G} \\<and>\n  (\\<forall>(l, v)\\<in>(\\<lambda>c. (S_Const c, Inl c)) ` C.\n      getRel l G = {(v, v)})\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n\ngoal (1 subgoal):\n 1. graph G", "by auto"], ["proof (state)\nthis:\n  graph G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "with maintained_holds_iff[OF g] holds"], ["proof (chain)\npicking this:\n  maintained\n   (translation ?e\\<^sub>L, translation (A_Int ?e\\<^sub>L ?e\\<^sub>R)) G =\n  G \\<Turnstile> ?e\\<^sub>L \\<sqsubseteq> ?e\\<^sub>R\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n  graph G", "have \"maintainedA Rs G\""], ["proof (prove)\nusing this:\n  maintained\n   (translation ?e\\<^sub>L, translation (A_Int ?e\\<^sub>L ?e\\<^sub>R)) G =\n  G \\<Turnstile> ?e\\<^sub>L \\<sqsubseteq> ?e\\<^sub>R\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n  graph G\n\ngoal (1 subgoal):\n 1. maintainedA Rs G", "unfolding transl_rules_def Rs_def"], ["proof (prove)\nusing this:\n  maintained\n   (translation ?e\\<^sub>L, translation (A_Int ?e\\<^sub>L ?e\\<^sub>R)) G =\n  G \\<Turnstile> ?e\\<^sub>L \\<sqsubseteq> ?e\\<^sub>R\n  \\<forall>S\\<in>T. G \\<Turnstile> S\n  graph G\n\ngoal (1 subgoal):\n 1. maintainedA\n     (\\<Union>(x, y)\\<in>T.\n         {(translation x, translation (A_Int x y)),\n          (translation y, translation (A_Int y x))})\n     G", "by auto"], ["proof (state)\nthis:\n  maintainedA Rs G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "hence mnt:\"maintainedA Rules G\""], ["proof (prove)\nusing this:\n  maintainedA Rs G\n\ngoal (1 subgoal):\n 1. maintainedA Rules G", "unfolding Rules_def"], ["proof (prove)\nusing this:\n  maintainedA Rs G\n\ngoal (1 subgoal):\n 1. maintainedA (Rs \\<union> standard_rules C L) G", "using standard_maintains_rules[OF std]"], ["proof (prove)\nusing this:\n  maintainedA Rs G\n  maintainedA (standard_rules C ?L) G\n\ngoal (1 subgoal):\n 1. maintainedA (Rs \\<union> standard_rules C L) G", "by auto"], ["proof (state)\nthis:\n  maintainedA Rules G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "from consequence_graphI[OF _ _ g] gr[unfolded set_of_graph_rules_def] mnt"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>R. R \\<in> ?Rs \\<Longrightarrow> maintained R G;\n   \\<And>R. R \\<in> ?Rs \\<Longrightarrow> subgraph (fst R) (snd R)\\<rbrakk>\n  \\<Longrightarrow> consequence_graph ?Rs G\n  \\<forall>R\\<in>Rules. graph_rule R\n  maintainedA Rules G", "have cg:\"consequence_graph Rules G\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>R. R \\<in> ?Rs \\<Longrightarrow> maintained R G;\n   \\<And>R. R \\<in> ?Rs \\<Longrightarrow> subgraph (fst R) (snd R)\\<rbrakk>\n  \\<Longrightarrow> consequence_graph ?Rs G\n  \\<forall>R\\<in>Rules. graph_rule R\n  maintainedA Rules G\n\ngoal (1 subgoal):\n 1. consequence_graph Rules G", "by fast"], ["proof (state)\nthis:\n  consequence_graph Rules G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "with cfg_l[unfolded least_def]"], ["proof (chain)\npicking this:\n  subgraph (graph_of init) cfg \\<and>\n  (\\<forall>C.\n      consequence_graph Rules C \\<longrightarrow>\n      maintained (graph_of init, cfg) C)\n  consequence_graph Rules G", "have mtd:\"maintained (graph_of init, cfg) G\""], ["proof (prove)\nusing this:\n  subgraph (graph_of init) cfg \\<and>\n  (\\<forall>C.\n      consequence_graph Rules C \\<longrightarrow>\n      maintained (graph_of init, cfg) C)\n  consequence_graph Rules G\n\ngoal (1 subgoal):\n 1. maintained (graph_of init, cfg) G", "by auto"], ["proof (state)\nthis:\n  maintained (graph_of init, cfg) G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "assume ab:\"(a,b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\""], ["proof (state)\nthis:\n  (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "hence abv:\"a \\<in> vertices G\" \"b \\<in> vertices G\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. a \\<in> vertices G &&& b \\<in> vertices G", "using semantics_in_vertices[OF g]"], ["proof (prove)\nusing this:\n  (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\n  (?a, ?b) \\<in> :G:\\<lbrakk>?e\\<rbrakk> \\<Longrightarrow>\n  ?a \\<in> vertices G\n  (?a, ?b) \\<in> :G:\\<lbrakk>?e\\<rbrakk> \\<Longrightarrow>\n  ?b \\<in> vertices G\n\ngoal (1 subgoal):\n 1. a \\<in> vertices G &&& b \\<in> vertices G", "by auto"], ["proof (state)\nthis:\n  a \\<in> vertices G\n  b \\<in> vertices G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "from ab translation[OF g] init"], ["proof (chain)\npicking this:\n  (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\n  ((?x, ?y) \\<in> :G:\\<lbrakk>?e\\<rbrakk>) =\n  (\\<exists>f.\n      graph_homomorphism (translation ?e) G f \\<and>\n      (0, ?x) \\<in> f \\<and> (1, ?y) \\<in> f)\n  graph_of init = translation (fst S)", "obtain f where f:\"graph_homomorphism (graph_of init) G f\" \"(0, a) \\<in> f \\<and> (1, b) \\<in> f\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\n  ((?x, ?y) \\<in> :G:\\<lbrakk>?e\\<rbrakk>) =\n  (\\<exists>f.\n      graph_homomorphism (translation ?e) G f \\<and>\n      (0, ?x) \\<in> f \\<and> (1, ?y) \\<in> f)\n  graph_of init = translation (fst S)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>graph_homomorphism (graph_of init) G f;\n         (0, a) \\<in> f \\<and> (1, b) \\<in> f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  graph_homomorphism (graph_of init) G f\n  (0, a) \\<in> f \\<and> (1, b) \\<in> f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "from maintainedD2[OF mtd f(1)]"], ["proof (chain)\npicking this:\n  (\\<And>g.\n      \\<lbrakk>graph_homomorphism cfg G g; f \\<subseteq> g\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain g\n      where g:\"graph_homomorphism cfg G g\" and \"f \\<subseteq> g\""], ["proof (prove)\nusing this:\n  (\\<And>g.\n      \\<lbrakk>graph_homomorphism cfg G g; f \\<subseteq> g\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>graph_homomorphism cfg G g; f \\<subseteq> g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  graph_homomorphism cfg G g\n  f \\<subseteq> g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "with f"], ["proof (chain)\npicking this:\n  graph_homomorphism (graph_of init) G f\n  (0, a) \\<in> f \\<and> (1, b) \\<in> f\n  graph_homomorphism cfg G g\n  f \\<subseteq> g", "have g01:\"(0, a) \\<in> g\" \"(1, b) \\<in> g\""], ["proof (prove)\nusing this:\n  graph_homomorphism (graph_of init) G f\n  (0, a) \\<in> f \\<and> (1, b) \\<in> f\n  graph_homomorphism cfg G g\n  f \\<subseteq> g\n\ngoal (1 subgoal):\n 1. (0, a) \\<in> g &&& (1, b) \\<in> g", "by auto"], ["proof (state)\nthis:\n  (0, a) \\<in> g\n  (1, b) \\<in> g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "assume ?lhs"], ["proof (state)\nthis:\n  check_entailment C (transl_rules T) S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "then"], ["proof (chain)\npicking this:\n  check_entailment C (transl_rules T) S", "consider (maintained) \"(0,1) \\<in> :cfg:\\<lbrakk>snd S\\<rbrakk>\" | (no_models) \":cfg:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {}\""], ["proof (prove)\nusing this:\n  check_entailment C (transl_rules T) S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(0, 1) \\<in> :cfg:\\<lbrakk>snd S\\<rbrakk> \\<Longrightarrow>\n             thesis;\n     :cfg:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {} \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using cfg_g"], ["proof (prove)\nusing this:\n  check_entailment C (transl_rules T) S\n  graph cfg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(0, 1) \\<in> :cfg:\\<lbrakk>snd S\\<rbrakk> \\<Longrightarrow>\n             thesis;\n     :cfg:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {} \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding cfg entailment_model_def Let_def Rs_def R_def"], ["proof (prove)\nusing this:\n  (0, 1)\n  \\<in> :the_lcg\n          (non_constructive_selector\n            (transl_rules T \\<union>\n             standard_rules C\n              (fst `\n               \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n               {S_Bot, S_Top, S_Idt} \\<union>\n               S_Const ` C \\<union>\n               fst ` edges (translation (fst S)))))\n          (transl_rules T \\<union>\n           standard_rules C\n            (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n             {S_Bot, S_Top, S_Idt} \\<union>\n             S_Const ` C \\<union>\n             fst ` edges (translation (fst S))))\n          (card (vertices (translation (fst S))),\n           edges (translation (fst S))):\\<lbrakk>snd S\\<rbrakk> \\<or>\n  getRel S_Bot\n   (the_lcg\n     (non_constructive_selector\n       (transl_rules T \\<union>\n        standard_rules C\n         (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n          {S_Bot, S_Top, S_Idt} \\<union>\n          S_Const ` C \\<union>\n          fst ` edges (translation (fst S)))))\n     (transl_rules T \\<union>\n      standard_rules C\n       (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n        {S_Bot, S_Top, S_Idt} \\<union>\n        S_Const ` C \\<union>\n        fst ` edges (translation (fst S))))\n     (card (vertices (translation (fst S))),\n      edges (translation (fst S)))) \\<noteq>\n  {}\n  graph\n   (the_lcg\n     (non_constructive_selector\n       (transl_rules T \\<union>\n        standard_rules C\n         (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n          {S_Bot, S_Top, S_Idt} \\<union>\n          S_Const ` C \\<union>\n          fst ` edges (fst (transl_rule S)))))\n     (transl_rules T \\<union>\n      standard_rules C\n       (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n        {S_Bot, S_Top, S_Idt} \\<union>\n        S_Const ` C \\<union>\n        fst ` edges (fst (transl_rule S))))\n     (card (vertices (fst (transl_rule S))), edges (fst (transl_rule S))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(0, 1)\n             \\<in> :the_lcg\n                     (non_constructive_selector\n                       (transl_rules T \\<union>\n                        standard_rules C\n                         (fst `\n                          \\<Union>\n                           ((edges \\<circ> snd) ` transl_rules T) \\<union>\n                          {S_Bot, S_Top, S_Idt} \\<union>\n                          S_Const ` C \\<union>\n                          fst ` edges (fst (transl_rule S)))))\n                     (transl_rules T \\<union>\n                      standard_rules C\n                       (fst `\n                        \\<Union>\n                         ((edges \\<circ> snd) ` transl_rules T) \\<union>\n                        {S_Bot, S_Top, S_Idt} \\<union>\n                        S_Const ` C \\<union>\n                        fst ` edges (fst (transl_rule S))))\n                     (card (vertices (fst (transl_rule S))),\n                      edges\n                       (fst (transl_rule\n                              S))):\\<lbrakk>snd S\\<rbrakk> \\<Longrightarrow>\n             thesis;\n     :the_lcg\n       (non_constructive_selector\n         (transl_rules T \\<union>\n          standard_rules C\n           (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n            {S_Bot, S_Top, S_Idt} \\<union>\n            S_Const ` C \\<union>\n            fst ` edges (fst (transl_rule S)))))\n       (transl_rules T \\<union>\n        standard_rules C\n         (fst ` \\<Union> ((edges \\<circ> snd) ` transl_rules T) \\<union>\n          {S_Bot, S_Top, S_Idt} \\<union>\n          S_Const ` C \\<union>\n          fst ` edges (fst (transl_rule S))))\n       (card (vertices (fst (transl_rule S))),\n        edges (fst (transl_rule S))):\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq>\n     {} \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>(0, 1) \\<in> :cfg:\\<lbrakk>snd S\\<rbrakk> \\<Longrightarrow>\n           ?thesis1;\n   :cfg:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {} \\<Longrightarrow>\n   ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>check_entailment C (transl_rules T) S; model C G T;\n     (a, b) \\<in> :G:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "thus \"(a,b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(0, 1) \\<in> :cfg:\\<lbrakk>snd S\\<rbrakk> \\<Longrightarrow>\n           ?thesis1;\n   :cfg:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {} \\<Longrightarrow>\n   ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. (0, 1) \\<in> :cfg:\\<lbrakk>snd S\\<rbrakk> \\<Longrightarrow>\n    (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>\n 2. :cfg:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {} \\<Longrightarrow>\n    (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "case maintained"], ["proof (state)\nthis:\n  (0, 1) \\<in> :cfg:\\<lbrakk>snd S\\<rbrakk>\n\ngoal (2 subgoals):\n 1. (0, 1) \\<in> :cfg:\\<lbrakk>snd S\\<rbrakk> \\<Longrightarrow>\n    (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>\n 2. :cfg:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {} \\<Longrightarrow>\n    (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "from graph_homomorphism_semantics[OF g maintained g01]"], ["proof (chain)\npicking this:\n  (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "show ?thesis"], ["proof (prove)\nusing this:\n  (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "."], ["proof (state)\nthis:\n  (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. :cfg:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {} \\<Longrightarrow>\n    (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. :cfg:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {} \\<Longrightarrow>\n    (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "case no_models"], ["proof (state)\nthis:\n  :cfg:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. :cfg:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {} \\<Longrightarrow>\n    (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "from graph_homomorphism_nonempty[OF g no_models]"], ["proof (chain)\npicking this:\n  :G:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {}", "have \"getRel S_Bot G \\<noteq> {}\""], ["proof (prove)\nusing this:\n  :G:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. getRel S_Bot G \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  getRel S_Bot G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. :cfg:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {} \\<Longrightarrow>\n    (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "hence False"], ["proof (prove)\nusing this:\n  getRel S_Bot G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "using std"], ["proof (prove)\nusing this:\n  getRel S_Bot G \\<noteq> {}\n  standard' C G\n\ngoal (1 subgoal):\n 1. False", "unfolding standard_def"], ["proof (prove)\nusing this:\n  getRel S_Bot G \\<noteq> {}\n  graph G \\<and>\n  vertices G \\<noteq> {} \\<and>\n  ident_rel S_Idt G \\<and>\n  getRel S_Bot G = {} \\<and>\n  getRel S_Top G =\n  {(x, y). x \\<in> vertices G \\<and> y \\<in> vertices G} \\<and>\n  (\\<forall>(l, v)\\<in>(\\<lambda>c. (S_Const c, Inl c)) ` C.\n      getRel l G = {(v, v)})\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. :cfg:\\<lbrakk>\\<bottom>\\<rbrakk> \\<noteq> {} \\<Longrightarrow>\n    (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>", "by auto"], ["proof (state)\nthis:\n  (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a, b) \\<in> :G:\\<lbrakk>snd S\\<rbrakk>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>check_entailment C (transl_rules T) S; model C ?G1 T;\n   (?a1, ?b1) \\<in> :?G1:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n  \\<Longrightarrow> (?a1, ?b1) \\<in> :?G1:\\<lbrakk>snd S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "hence d2:\"?lhs \\<Longrightarrow> ?rhs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>check_entailment C (transl_rules T) S; model C ?G1 T;\n   (?a1, ?b1) \\<in> :?G1:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n  \\<Longrightarrow> (?a1, ?b1) \\<in> :?G1:\\<lbrakk>snd S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S \\<Longrightarrow>\n    entails t C T (fst S \\<sqsubseteq> snd S)", "unfolding entails_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>check_entailment C (transl_rules T) S; model C ?G1 T;\n   (?a1, ?b1) \\<in> :?G1:\\<lbrakk>fst S\\<rbrakk>\\<rbrakk>\n  \\<Longrightarrow> (?a1, ?b1) \\<in> :?G1:\\<lbrakk>snd S\\<rbrakk>\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S \\<Longrightarrow>\n    \\<forall>G.\n       model C G T \\<longrightarrow>\n       G \\<Turnstile> fst S \\<sqsubseteq> snd S", "by auto"], ["proof (state)\nthis:\n  check_entailment C (transl_rules T) S \\<Longrightarrow>\n  entails t C T (fst S \\<sqsubseteq> snd S)\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "from d1 d2"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n   entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n  \\<Longrightarrow> False\n  check_entailment C (transl_rules T) S \\<Longrightarrow>\n  entails t C T (fst S \\<sqsubseteq> snd S)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> check_entailment C (transl_rules T) S;\n   entails t C T (fst S \\<sqsubseteq> snd S)\\<rbrakk>\n  \\<Longrightarrow> False\n  check_entailment C (transl_rules T) S \\<Longrightarrow>\n  entails t C T (fst S \\<sqsubseteq> snd S)\n\ngoal (1 subgoal):\n 1. check_entailment C (transl_rules T) S =\n    entails t C T (fst S \\<sqsubseteq> snd S)", "by metis"], ["proof (state)\nthis:\n  check_entailment C (transl_rules T) S =\n  entails t C T (fst S \\<sqsubseteq> snd S)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}