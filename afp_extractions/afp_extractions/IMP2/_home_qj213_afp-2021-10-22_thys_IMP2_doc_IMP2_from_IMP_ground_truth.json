{"file_name": "/home/qj213/afp-2021-10-22/thys/IMP2/doc/IMP2_from_IMP.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IMP2", "problem_names": ["lemma \"exp_count_up1 = exp_count_up2\"", "lemma \"V ''x'' = Vidx ''x'' (N 0)\"", "lemma \\<open>Assign ''x'' v = AssignIdx ''x'' (N 0) v\\<close>", "lemmas nat_distribs = nat_add_distrib nat_diff_distrib Suc_diff_le nat_mult_distrib nat_div_distrib", "lemma \"s\\<^sub>0 ''n'' 0 \\<ge> 0 \\<Longrightarrow> wlp \\<pi> exp_count_up1 (\\<lambda>s. s ''a'' 0 = 2^nat (s\\<^sub>0 ''n'' 0)) s\\<^sub>0\"", "lemma \"s\\<^sub>0 ''n'' 0 \\<ge> 0 \\<Longrightarrow> wlp \\<pi> exp_count_up1 (\\<lambda>s. s ''a'' 0 = 2^nat (s\\<^sub>0 ''n'' 0)) s\\<^sub>0\"", "lemma \"let n = s\\<^sub>0 ''n'' 0 in n \\<ge> 0 \n    \\<Longrightarrow> wlp \\<pi> exp_count_up1 (\\<lambda>s. let a = s ''a'' 0; n\\<^sub>0 = s\\<^sub>0 ''n'' 0 in a = 2^nat (n\\<^sub>0)) s\\<^sub>0\"", "lemma \"VAR (s x) P = (let v=s x in P v)\""], "translations": [["", "lemma \"exp_count_up1 = exp_count_up2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp_count_up1 = exp_count_up2", "unfolding exp_count_up1_def exp_count_up2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ''a'' ::= N 1;; ''c'' ::= N 0;;\n    WHILE Cmpop (<) (V ''c'') (V ''n'')\n    DO (''a'' ::= Binop (*) (N 2) (V ''a'');;\n        ''c'' ::= Binop (+) (V ''c'') (N 1)) =\n    ''a'' ::= N 1;; ''c'' ::= N 0;;\n    WHILE Cmpop (<) (V ''c'') (V ''n'')\n    DO (''a'' ::= Binop (*) (N 2) (V ''a'');;\n        ''c'' ::= Binop (+) (V ''c'') (N 1))", ".."], ["", "subsection \\<open>Operators and Arrays\\<close>"], ["", "text \\<open>We reflect arbitrary Isabelle functions into the syntax: \\<close>"], ["", "value \"bval (Cmpop (\\<le>) (Binop (+) (Unop uminus (V ''x'')) (N 42)) (N 50)) <''x'':=(\\<lambda>_. -5)> \""], ["", "thm aval.simps bval.simps"], ["", "text \\<open>Every variable is an array, indexed by integers, no bounds.\n    Syntax shortcuts to access index 0.\n  \\<close>"], ["", "term \\<open>Vidx ''a'' (i::aexp)\\<close> \\<comment> \\<open>Array access at index \\<open>i\\<close>\\<close>"], ["", "lemma \"V ''x'' = Vidx ''x'' (N 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V ''x'' = V ''x''", ".. \\<comment> \\<open>Shortcut for access at index \\<open>0\\<close>\\<close>"], ["", "text \\<open>New commands:\\<close>"], ["", "term \\<open>AssignIdx ''a'' (i::aexp) (v::aexp)\\<close> \\<comment> \\<open>Assign at index. Replaces assign.\\<close>"], ["", "term \\<open>''a''[i] ::= v\\<close>  \\<comment> \\<open>Standard syntax\\<close>"], ["", "term \\<open>\\<^imp>\\<open> a[i] = v \\<close>\\<close> \\<comment> \\<open>Fancy syntax\\<close>"], ["", "lemma \\<open>Assign ''x'' v = AssignIdx ''x'' (N 0) v\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ''x'' ::= v = ''x'' ::= v", ".. \\<comment> \\<open>Shortcut for assignment to index \\<open>0\\<close>\\<close>"], ["", "term \\<open>''x'' ::= v\\<close>"], ["", "term \\<open>\\<^imp>\\<open>x = v+1\\<close>\\<close>"], ["", "text \\<open>Note: In fancy syntax, assignment between variables is always parsed as array copy.\n    This is no problem unless a variable is used as both, array and plain value, \n    which should be avoided anyway.\n  \\<close>"], ["", "term \\<open>ArrayCpy ''d'' ''s''\\<close> \\<comment> \\<open>Copy whole array. Both operands are variable names.\\<close>"], ["", "term \\<open>''d''[] ::= ''s''\\<close>"], ["", "term \\<open>\\<^imp>\\<open>d = s\\<close>\\<close>"], ["", "term \\<open>ArrayClear ''a''\\<close> \\<comment> \\<open>Initialize array to all zeroes.\\<close>"], ["", "term \\<open>CLEAR ''a''[]\\<close>"], ["", "term \\<open>\\<^imp>\\<open>clear a[]\\<close>\\<close>"], ["", "text \\<open>Semantics of these is straightforward\\<close>"], ["", "thm big_step.AssignIdx big_step.ArrayCpy big_step.ArrayClear"], ["", "subsection \\<open>Local and Global Variables\\<close>"], ["", "term \\<open>is_global\\<close>"], ["", "term \\<open>is_local\\<close> \\<comment> \\<open>Partitions variable names\\<close>"], ["", "term \\<open><s\\<^sub>1|s\\<^sub>2>\\<close> \\<comment> \\<open>State with locals from \\<open>s\\<^sub>1\\<close> and globals from \\<open>s\\<^sub>2\\<close>\\<close>"], ["", "term \\<open>SCOPE c\\<close>"], ["", "term \\<open>\\<^imp>\\<open>scope { skip }\\<close>\\<close>    \\<comment> \\<open>Execute \\<open>c\\<close> with fresh set of local variables\\<close>"], ["", "thm big_step.Scope"], ["", "subsubsection \\<open>Parameter Passing\\<close>"], ["", "text \\<open>Parameters and return values by global variables: This is syntactic sugar only:\\<close>"], ["", "context fixes f :: com begin"], ["", "term \\<open>\\<^imp>\\<open> (r1,r2) = f(x1,x2,x3)\\<close>\\<close>"], ["", "end"], ["", "subsection \\<open>Recursive procedures\\<close>"], ["", "term \\<open>PCall ''name''\\<close>"], ["", "thm big_step.PCall"], ["", "subsubsection \\<open>Procedure Scope\\<close>"], ["", "text \\<open>Execute command with local set of procedures\\<close>"], ["", "term \\<open>PScope \\<pi> c\\<close>"], ["", "thm big_step.PScope"], ["", "subsubsection \\<open>Syntactic sugar for procedure call with parameters\\<close>"], ["", "term \\<open>\\<^imp>\\<open>(r1,r2) = rec name(x1,x2,x3)\\<close>\\<close>"], ["", "subsection \\<open>More Readable VCs\\<close>"], ["", "lemmas nat_distribs = nat_add_distrib nat_diff_distrib Suc_diff_le nat_mult_distrib nat_div_distrib"], ["", "lemma \"s\\<^sub>0 ''n'' 0 \\<ge> 0 \\<Longrightarrow> wlp \\<pi> exp_count_up1 (\\<lambda>s. s ''a'' 0 = 2^nat (s\\<^sub>0 ''n'' 0)) s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> s\\<^sub>0 ''n'' 0 \\<Longrightarrow>\n    wlp \\<pi> exp_count_up1\n     (\\<lambda>s. s ''a'' 0 = 2 ^ nat (s\\<^sub>0 ''n'' 0)) s\\<^sub>0", "unfolding exp_count_up1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> s\\<^sub>0 ''n'' 0 \\<Longrightarrow>\n    wlp \\<pi>\n     (''a'' ::= N 1;; ''c'' ::= N 0;;\n      WHILE Cmpop (<) (V ''c'') (V ''n'')\n      DO (''a'' ::= Binop (*) (N 2) (V ''a'');;\n          ''c'' ::= Binop (+) (V ''c'') (N 1)))\n     (\\<lambda>s. s ''a'' 0 = 2 ^ nat (s\\<^sub>0 ''n'' 0)) s\\<^sub>0", "apply (subst annotate_whileI[where \n          I=\"\\<lambda>s. s ''n'' 0 = s\\<^sub>0 ''n'' 0 \\<and>  s ''a'' 0 = 2 ^ nat (s ''c'' 0) \\<and> 0 \\<le> s ''c'' 0 \\<and> s ''c'' 0 \\<le> s\\<^sub>0 ''n'' 0\" \n        ])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> s\\<^sub>0 ''n'' 0 \\<Longrightarrow>\n    wlp \\<pi>\n     (''a'' ::= N 1;; ''c'' ::= N 0;;\n      WHILE {\\<lambda>s.\n                s ''n'' 0 = s\\<^sub>0 ''n'' 0 \\<and>\n                s ''a'' 0 = 2 ^ nat (s ''c'' 0) \\<and>\n                0 \\<le> s ''c'' 0 \\<and>\n                s ''c'' 0\n                \\<le> s\\<^sub>0 ''n'' 0} Cmpop (<) (V ''c'') (V ''n'')\n      DO (''a'' ::= Binop (*) (N 2) (V ''a'');;\n          ''c'' ::= Binop (+) (V ''c'') (N 1)))\n     (\\<lambda>s. s ''a'' 0 = 2 ^ nat (s\\<^sub>0 ''n'' 0)) s\\<^sub>0", "apply (i_vcg_preprocess; i_vcg_gen; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<paragraph>''invar-pres'';\n        modifies {''a'', ''c''} s\n         (s\\<^sub>0\n          (''c'' := (s\\<^sub>0 ''c'')(0 := 0),\n           ''a'' := (s\\<^sub>0 ''a'')(0 := 1)));\n        s ''c'' 0 < s\\<^sub>0 ''n'' 0; s ''n'' 0 = s\\<^sub>0 ''n'' 0;\n        s ''a'' 0 = 2 ^ nat (s ''c'' 0); 0 \\<le> s ''c'' 0\\<rbrakk>\n       \\<Longrightarrow> 2 * 2 ^ nat (s ''c'' 0) = 2 ^ nat (s ''c'' 0 + 1)", "text \\<open>The postprocessor converts from states applied to string names to actual variables\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<paragraph>''invar-pres'';\n        modifies {''a'', ''c''} s\n         (s\\<^sub>0\n          (''c'' := (s\\<^sub>0 ''c'')(0 := 0),\n           ''a'' := (s\\<^sub>0 ''a'')(0 := 1)));\n        s ''c'' 0 < s\\<^sub>0 ''n'' 0; s ''n'' 0 = s\\<^sub>0 ''n'' 0;\n        s ''a'' 0 = 2 ^ nat (s ''c'' 0); 0 \\<le> s ''c'' 0\\<rbrakk>\n       \\<Longrightarrow> 2 * 2 ^ nat (s ''c'' 0) = 2 ^ nat (s ''c'' 0 + 1)", "apply i_vcg_postprocess"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''invar-pres''; c < n\\<^sub>0;\n        n\\<^sub>0 = n\\<^sub>0; a = 2 ^ nat c; 0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> 2 * 2 ^ nat c = 2 ^ nat (c + 1)", "by (auto simp: algebra_simps nat_distribs)"], ["", "lemma \"s\\<^sub>0 ''n'' 0 \\<ge> 0 \\<Longrightarrow> wlp \\<pi> exp_count_up1 (\\<lambda>s. s ''a'' 0 = 2^nat (s\\<^sub>0 ''n'' 0)) s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> s\\<^sub>0 ''n'' 0 \\<Longrightarrow>\n    wlp \\<pi> exp_count_up1\n     (\\<lambda>s. s ''a'' 0 = 2 ^ nat (s\\<^sub>0 ''n'' 0)) s\\<^sub>0", "unfolding exp_count_up1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> s\\<^sub>0 ''n'' 0 \\<Longrightarrow>\n    wlp \\<pi>\n     (''a'' ::= N 1;; ''c'' ::= N 0;;\n      WHILE Cmpop (<) (V ''c'') (V ''n'')\n      DO (''a'' ::= Binop (*) (N 2) (V ''a'');;\n          ''c'' ::= Binop (+) (V ''c'') (N 1)))\n     (\\<lambda>s. s ''a'' 0 = 2 ^ nat (s\\<^sub>0 ''n'' 0)) s\\<^sub>0", "apply (subst annotate_whileI[where \n          I=\"\\<lambda>s. s ''n'' 0 = s\\<^sub>0 ''n'' 0 \\<and>  s ''a'' 0 = 2 ^ nat (s ''c'' 0) \\<and> 0 \\<le> s ''c'' 0 \\<and> s ''c'' 0 \\<le> s\\<^sub>0 ''n'' 0\" \n        ])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> s\\<^sub>0 ''n'' 0 \\<Longrightarrow>\n    wlp \\<pi>\n     (''a'' ::= N 1;; ''c'' ::= N 0;;\n      WHILE {\\<lambda>s.\n                s ''n'' 0 = s\\<^sub>0 ''n'' 0 \\<and>\n                s ''a'' 0 = 2 ^ nat (s ''c'' 0) \\<and>\n                0 \\<le> s ''c'' 0 \\<and>\n                s ''c'' 0\n                \\<le> s\\<^sub>0 ''n'' 0} Cmpop (<) (V ''c'') (V ''n'')\n      DO (''a'' ::= Binop (*) (N 2) (V ''a'');;\n          ''c'' ::= Binop (+) (V ''c'') (N 1)))\n     (\\<lambda>s. s ''a'' 0 = 2 ^ nat (s\\<^sub>0 ''n'' 0)) s\\<^sub>0", "text \\<open>The postprocessor is invoked by default\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> s\\<^sub>0 ''n'' 0 \\<Longrightarrow>\n    wlp \\<pi>\n     (''a'' ::= N 1;; ''c'' ::= N 0;;\n      WHILE {\\<lambda>s.\n                s ''n'' 0 = s\\<^sub>0 ''n'' 0 \\<and>\n                s ''a'' 0 = 2 ^ nat (s ''c'' 0) \\<and>\n                0 \\<le> s ''c'' 0 \\<and>\n                s ''c'' 0\n                \\<le> s\\<^sub>0 ''n'' 0} Cmpop (<) (V ''c'') (V ''n'')\n      DO (''a'' ::= Binop (*) (N 2) (V ''a'');;\n          ''c'' ::= Binop (+) (V ''c'') (N 1)))\n     (\\<lambda>s. s ''a'' 0 = 2 ^ nat (s\\<^sub>0 ''n'' 0)) s\\<^sub>0", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''invar-initial''; 0 \\<le> n\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> 1 = 2 ^ nat 0 \\<and> 0 \\<le> 0\n 2. \\<And>c a n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''invar-pres''; 0 \\<le> n\\<^sub>0;\n        n\\<^sub>0 = n\\<^sub>0 \\<and>\n        a = 2 ^ nat c \\<and> 0 \\<le> c \\<and> c \\<le> n\\<^sub>0;\n        c < n\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> 2 * 2 ^ nat c = 2 ^ nat (c + 1) \\<and>\n                         0 \\<le> c + 1 \\<and> c + 1 \\<le> n\\<^sub>0\n 3. \\<And>c a n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''invar-post''; 0 \\<le> n\\<^sub>0;\n        n\\<^sub>0 = n\\<^sub>0 \\<and>\n        a = 2 ^ nat c \\<and> 0 \\<le> c \\<and> c \\<le> n\\<^sub>0;\n        \\<not> c < n\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> 2 ^ nat c = 2 ^ nat n\\<^sub>0", "oops"], ["", "subsection \\<open>Specification Commands\\<close>"], ["", "text \\<open>IMP2 provides a set of commands to simplify specification and annotation of programs.\\<close>"], ["", "text \\<open>Old way of proving a specification: \\<close>"], ["", "lemma \"let n = s\\<^sub>0 ''n'' 0 in n \\<ge> 0 \n    \\<Longrightarrow> wlp \\<pi> exp_count_up1 (\\<lambda>s. let a = s ''a'' 0; n\\<^sub>0 = s\\<^sub>0 ''n'' 0 in a = 2^nat (n\\<^sub>0)) s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Let (s\\<^sub>0 ''n'' 0) ((\\<le>) 0) \\<Longrightarrow>\n    wlp \\<pi> exp_count_up1\n     (\\<lambda>s.\n         let a = s ''a'' 0; n\\<^sub>0 = s\\<^sub>0 ''n'' 0\n         in a = 2 ^ nat n\\<^sub>0)\n     s\\<^sub>0", "unfolding exp_count_up1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Let (s\\<^sub>0 ''n'' 0) ((\\<le>) 0) \\<Longrightarrow>\n    wlp \\<pi>\n     (''a'' ::= N 1;; ''c'' ::= N 0;;\n      WHILE Cmpop (<) (V ''c'') (V ''n'')\n      DO (''a'' ::= Binop (*) (N 2) (V ''a'');;\n          ''c'' ::= Binop (+) (V ''c'') (N 1)))\n     (\\<lambda>s.\n         let a = s ''a'' 0; n\\<^sub>0 = s\\<^sub>0 ''n'' 0\n         in a = 2 ^ nat n\\<^sub>0)\n     s\\<^sub>0", "apply (subst annotate_whileI[where \n          I=\"\\<lambda>s. s ''n'' 0 = s\\<^sub>0 ''n'' 0 \\<and>  s ''a'' 0 = 2 ^ nat (s ''c'' 0) \\<and> 0 \\<le> s ''c'' 0 \\<and> s ''c'' 0 \\<le> s\\<^sub>0 ''n'' 0\" \n          (* Similar for invar! *)\n        ])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Let (s\\<^sub>0 ''n'' 0) ((\\<le>) 0) \\<Longrightarrow>\n    wlp \\<pi>\n     (''a'' ::= N 1;; ''c'' ::= N 0;;\n      WHILE {\\<lambda>s.\n                s ''n'' 0 = s\\<^sub>0 ''n'' 0 \\<and>\n                s ''a'' 0 = 2 ^ nat (s ''c'' 0) \\<and>\n                0 \\<le> s ''c'' 0 \\<and>\n                s ''c'' 0\n                \\<le> s\\<^sub>0 ''n'' 0} Cmpop (<) (V ''c'') (V ''n'')\n      DO (''a'' ::= Binop (*) (N 2) (V ''a'');;\n          ''c'' ::= Binop (+) (V ''c'') (N 1)))\n     (\\<lambda>s.\n         let a = s ''a'' 0; n\\<^sub>0 = s\\<^sub>0 ''n'' 0\n         in a = 2 ^ nat n\\<^sub>0)\n     s\\<^sub>0", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''invar-initial'';\n        Let n\\<^sub>0 ((\\<le>) 0)\\<rbrakk>\n       \\<Longrightarrow> 1 = 2 ^ nat 0 \\<and>\n                         0 \\<le> 0 \\<and> 0 \\<le> n\\<^sub>0\n 2. \\<And>c a n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''invar-pres''; Let n\\<^sub>0 ((\\<le>) 0);\n        n\\<^sub>0 = n\\<^sub>0 \\<and>\n        a = 2 ^ nat c \\<and> 0 \\<le> c \\<and> c \\<le> n\\<^sub>0;\n        c < n\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> 2 * 2 ^ nat c = 2 ^ nat (c + 1) \\<and>\n                         0 \\<le> c + 1 \\<and> c + 1 \\<le> n\\<^sub>0\n 3. \\<And>c a n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''invar-post''; Let n\\<^sub>0 ((\\<le>) 0);\n        n\\<^sub>0 = n\\<^sub>0 \\<and>\n        a = 2 ^ nat c \\<and> 0 \\<le> c \\<and> c \\<le> n\\<^sub>0;\n        \\<not> c < n\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> let a = 2 ^ nat c; n\\<^sub>0 = n\\<^sub>0\n                         in a = 2 ^ nat n\\<^sub>0", "apply (auto simp: algebra_simps nat_distribs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"VAR (s x) P = (let v=s x in P v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. VAR (s x) P = Let (s x) P", "unfolding VAR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (s x) = Let (s x) P", "by simp"], ["", "text \\<open>IMP2 specification commands\\<close>"], ["", "program_spec (partial) exp_count_up\n    assumes \"0\\<le>n\"               \\<comment> \\<open>Precondition. Use variable names of program.\\<close>\n    ensures \"a = 2^nat n\\<^sub>0\"       \\<comment> \\<open>Postcondition. Use variable names of programs. \n                                      Suffix with \\<open>\\<cdot>\\<^sub>0\\<close> to refer to initial state\\<close>\n    defines                     \\<comment> \\<open>Program\\<close>\n    \\<open>\n      a = 1;\n      c = 0;\n      while (c<n) \n        @invariant \\<open>n=n\\<^sub>0 \\<and> a=2^nat c \\<and> 0\\<le>c \\<and> c\\<le>n\\<close> \\<comment> \\<open>\n            Invar annotation. Variable names and suffix \\<open>\\<cdot>\\<^sub>0\\<close> for variables from initial state.\\<close>\n      {\n        a=2*a;\n        c=c+1\n      }\n    \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT'_partial Map.empty\n     (\\<lambda>\\<ss>.\n         VAR (\\<ss> ''n'' 0) (\\<lambda>n. BB_PROTECT (0 \\<le> n)))\n     (\\<lambda>\\<ss>\\<^sub>0. ''a'' ::= N 1;; ''c'' ::= N 0;;\n         WHILE {ANNOTATION\n                 (\\<lambda>\\<ss>.\n                     VAR (\\<ss> ''n'' 0)\n                      (\\<lambda>n.\n                          VAR (\\<ss> ''c'' 0)\n                           (\\<lambda>c.\n                               VAR (\\<ss> ''a'' 0)\n                                (\\<lambda>a.\n                                    VAR (\\<ss>\\<^sub>0 ''n'' 0)\n                                     (\\<lambda>n\\<^sub>0.\n   BB_PROTECT\n    (n = n\\<^sub>0 \\<and>\n     a = 2 ^ nat c \\<and>\n     0 \\<le> c \\<and> c \\<le> n))))))} Cmpop (<) (V ''c'') (V ''n'')\n         DO (''a'' ::= Binop (*) (N 2) (V ''a'');;\n             ''c'' ::= Binop (+) (V ''c'') (N 1)))\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''a'' 0)\n          (\\<lambda>a.\n              VAR (\\<ss>\\<^sub>0 ''n'' 0)\n               (\\<lambda>n\\<^sub>0. BB_PROTECT (a = 2 ^ nat n\\<^sub>0))))", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''invar-initial''; 0 \\<le> n\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> n\\<^sub>0 = n\\<^sub>0 \\<and>\n                         1 = 2 ^ nat 0 \\<and>\n                         0 \\<le> 0 \\<and> 0 \\<le> n\\<^sub>0\n 2. \\<And>n\\<^sub>0 c a.\n       \\<lbrakk>\\<paragraph>''invar-pres''; 0 \\<le> n\\<^sub>0;\n        n\\<^sub>0 = n\\<^sub>0 \\<and>\n        a = 2 ^ nat c \\<and> 0 \\<le> c \\<and> c \\<le> n\\<^sub>0;\n        c < n\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> n\\<^sub>0 = n\\<^sub>0 \\<and>\n                         2 * a = 2 ^ nat (c + 1) \\<and>\n                         0 \\<le> c + 1 \\<and> c + 1 \\<le> n\\<^sub>0\n 3. \\<And>n\\<^sub>0 c a.\n       \\<lbrakk>\\<paragraph>''invar-post''; 0 \\<le> n\\<^sub>0;\n        n\\<^sub>0 = n\\<^sub>0 \\<and>\n        a = 2 ^ nat c \\<and> 0 \\<le> c \\<and> c \\<le> n\\<^sub>0;\n        \\<not> c < n\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> a = 2 ^ nat n\\<^sub>0", "by (auto simp: algebra_simps nat_distribs)"], ["", "thm exp_count_up_spec"], ["", "thm exp_count_up_def"], ["", "(* \n    We can also annotate \n      @variant \\<open>measure-expression\\<close> \n        (interpreted over variables (v) and variables at program start (v\\<^sub>0) \n        \n    or, both @variant \\<open>\\<dots>\\<close> and @relation \\<open>R\\<close>:\n      R :: 'a rel, and variant produces an 'a\n      \n  *)"], ["", "procedure_spec exp_count_up_proc(n) returns a\n    assumes \"0\\<le>n\"               \n    ensures \"a = 2^nat n\\<^sub>0\"      \n    defines                     \n    \\<open>\n      a = 1;\n      c = 0;\n      while (c<n) \n        @invariant \\<open>n=n\\<^sub>0 \\<and> a=2^nat c \\<and> 0\\<le>c \\<and> c\\<le>n\\<close> \n        @variant \\<open>n-c\\<close>\n      {\n        a=2*a;\n        c=c+1\n      }\n    \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty\n     (\\<lambda>\\<ss>.\n         VAR (\\<ss> ''n'' 0) (\\<lambda>n. BB_PROTECT (0 \\<le> n)))\n     (\\<lambda>\\<ss>\\<^sub>0. ''a'' ::= N 1;; ''c'' ::= N 0;;\n         WHILE {ANNOTATION\n                 (\\<lambda>\\<ss>.\n                     VAR (\\<ss> ''n'' 0)\n                      (\\<lambda>n.\n                          VAR (\\<ss> ''c'' 0)\n                           (\\<lambda>c.\n                               BB_PROTECT\n                                (n -\n                                 c))))} {ANNOTATION\n    (\\<lambda>\\<ss>.\n        VAR (\\<ss> ''n'' 0)\n         (\\<lambda>n.\n             VAR (\\<ss> ''c'' 0)\n              (\\<lambda>c.\n                  VAR (\\<ss> ''a'' 0)\n                   (\\<lambda>a.\n                       VAR (\\<ss>\\<^sub>0 ''n'' 0)\n                        (\\<lambda>n\\<^sub>0.\n                            BB_PROTECT\n                             (n = n\\<^sub>0 \\<and>\n                              a = 2 ^ nat c \\<and>\n                              0 \\<le> c \\<and>\n                              c \\<le> n))))))} Cmpop (<) (V ''c'') (V ''n'')\n         DO (''a'' ::= Binop (*) (N 2) (V ''a'');;\n             ''c'' ::= Binop (+) (V ''c'') (N 1)))\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''a'' 0)\n          (\\<lambda>a.\n              VAR (\\<ss>\\<^sub>0 ''n'' 0)\n               (\\<lambda>n\\<^sub>0. BB_PROTECT (a = 2 ^ nat n\\<^sub>0))))", "apply vcg"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''rel-wf''; 0 \\<le> n\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> wf (measure nat)\n 2. \\<And>n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''invar-initial''; 0 \\<le> n\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> n\\<^sub>0 = n\\<^sub>0 \\<and>\n                         1 = 2 ^ nat 0 \\<and>\n                         0 \\<le> 0 \\<and> 0 \\<le> n\\<^sub>0\n 3. \\<And>n\\<^sub>0 c a.\n       \\<lbrakk>\\<paragraph>''Invar pres''; 0 \\<le> n\\<^sub>0;\n        n\\<^sub>0 = n\\<^sub>0 \\<and>\n        a = 2 ^ nat c \\<and> 0 \\<le> c \\<and> c \\<le> n\\<^sub>0;\n        c < n\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> n\\<^sub>0 = n\\<^sub>0 \\<and>\n                         2 * a = 2 ^ nat (c + 1) \\<and>\n                         0 \\<le> c + 1 \\<and> c + 1 \\<le> n\\<^sub>0\n 4. \\<And>n\\<^sub>0 c a.\n       \\<lbrakk>\\<paragraph>''Var pres''; 0 \\<le> n\\<^sub>0;\n        n\\<^sub>0 = n\\<^sub>0 \\<and>\n        a = 2 ^ nat c \\<and> 0 \\<le> c \\<and> c \\<le> n\\<^sub>0;\n        c < n\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> (n\\<^sub>0 - (c + 1), n\\<^sub>0 - c)\n                         \\<in> measure nat\n 5. \\<And>n\\<^sub>0 c a.\n       \\<lbrakk>\\<paragraph>''invar-post''; 0 \\<le> n\\<^sub>0;\n        n\\<^sub>0 = n\\<^sub>0 \\<and>\n        a = 2 ^ nat c \\<and> 0 \\<le> c \\<and> c \\<le> n\\<^sub>0;\n        \\<not> c < n\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> a = 2 ^ nat n\\<^sub>0", "by (auto simp: algebra_simps nat_distribs)"], ["", "text \\<open>Simple Recursion\\<close>"], ["", "recursive_spec \n    exp_rec(n) returns a assumes \"0\\<le>n\" ensures \"a=2^nat n\\<^sub>0\" variant \"n\"\n    defines \\<open>if (n==0) a=1 else {t=rec exp_rec(n-1); a=2*t}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. PROVE_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0\n     {(\\<lambda>\\<ss>. VAR (\\<ss> ''n'' 0) BB_PROTECT,\n       \\<lambda>\\<ss>.\n          VAR (\\<ss> ''n'' 0) (\\<lambda>n. BB_PROTECT (0 \\<le> n)),\n       \\<lambda>\\<ss>\\<^sub>0.\n          IF Cmpop (=) (V ''n'') (N 0) THEN ''a'' ::= N 1\n          ELSE ((''G_par_1'' ::= Binop (-) (V ''n'') (N 1);;\n                 Params (PCall ''exp_rec'');;\n                 ArrayCpy_retv ''t'' ''G_ret_1'');;\n                ''a'' ::= Binop (*) (N 2) (V ''t'')),\n       \\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n          VAR (\\<ss> ''a'' 0)\n           (\\<lambda>a.\n               VAR (\\<ss>\\<^sub>0 ''n'' 0)\n                (\\<lambda>n\\<^sub>0. BB_PROTECT (a = 2 ^ nat n\\<^sub>0))))}", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''then''; 0 \\<le> 0; n\\<^sub>0 = 0\\<rbrakk>\n       \\<Longrightarrow> 1 = 2 ^ nat 0\n 2. \\<And>n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''else''; 0 \\<le> n\\<^sub>0;\n        n\\<^sub>0 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (n\\<^sub>0 - 1, n\\<^sub>0) \\<in> measure nat \\<and>\n                         0 \\<le> n\\<^sub>0 - 1\n 3. \\<And>t' n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''else''; 0 \\<le> n\\<^sub>0;\n        n\\<^sub>0 \\<noteq> 0; t' = 2 ^ nat (n\\<^sub>0 - 1)\\<rbrakk>\n       \\<Longrightarrow> 2 * t' = 2 ^ nat n\\<^sub>0", "apply (auto simp: algebra_simps nat_distribs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''else''; 0 \\<le> n\\<^sub>0;\n        n\\<^sub>0 \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> 2 * 2 ^ (nat n\\<^sub>0 - Suc 0) = 2 ^ nat n\\<^sub>0", "by (metis Suc_le_D diff_Suc_Suc dvd_1_left dvd_imp_le minus_nat.diff_0 nat_0_iff nat_int neq0_conv of_nat_0 order_class.order.antisym pos_int_cases power_Suc zless_nat_eq_int_zless)"], ["", "text \\<open>Mutual Recursion: See Examples\\<close>"], ["", "end"]]}