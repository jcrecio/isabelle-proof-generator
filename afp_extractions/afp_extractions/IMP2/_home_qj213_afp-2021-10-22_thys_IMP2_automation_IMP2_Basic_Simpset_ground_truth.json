{"file_name": "/home/qj213/afp-2021-10-22/thys/IMP2/automation/IMP2_Basic_Simpset.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IMP2", "problem_names": ["lemmas [named_ss vcg_bb cong] = ASSUMPTION_cong NO_MATCH_cong", "lemmas [named_ss vcg_bb cong] = if_weak_cong", "lemma short_circuit: \n    \"a\\<and>b \\<longleftrightarrow> (if a then b else False)\"\n    \"a\\<or>b \\<longleftrightarrow> (if a then True else b)\"", "lemma BB_PROTECT_cong[named_ss vcg_bb cong]: \"BB_PROTECT a = BB_PROTECT a\"", "lemma BB_PROTECT: \"p \\<equiv> BB_PROTECT p\"", "lemmas [named_ss vcg_bb] =\n    refl if_True if_False HOL.simp_thms\n    True_implies_equals False_implies_equals", "lemmas [named_ss vcg_bb] =\n    char.inject[unfolded short_circuit]", "lemma [unfolded short_circuit,named_ss vcg_bb]:\n    fixes x y :: char and xs ys :: string\n    shows\n    \"x#xs = y#ys \\<longleftrightarrow> x=y \\<and> xs=ys\" \n    \"x#xs \\<noteq> []\" \"[] \\<noteq> x#xs\"", "lemma [named_ss vcg_bb]: \n    fixes s::state\n    shows\n    \"(s(x:=v)) x = v\"  \n    \"(s(x:=v)) y = (if x=y then v else s y)\"", "lemma [named_ss vcg_bb]: \n    fixes a::val\n    shows\n    \"(a(i:=pv)) i = pv\"", "lemma combine_query': \"<s|t> (x#xs) = (if is_global (x#xs) then t (x#xs) else s (x#xs))\"", "lemma combine_upd':\n    \"<s|t>((x#xs):=v) = (if is_global (x#xs) then <s|t((x#xs):=v)> else <s((x#xs):=v)|t>)\"", "lemmas [named_ss vcg_bb] = combine_collapse combine_nest", "lemmas [named_ss vcg_bb] = combine_query' combine_upd'", "lemma query_prog[named_ss vcg_bb]: \"(\\<pi>(k\\<mapsto>v)) k' = (if k'=k then Some v else \\<pi> k')\" for \\<pi> :: program", "lemmas vcg_bb_set[unfolded short_circuit, named_ss vcg_bb] =\n    Un_insert_left Un_insert_right insert_commute insert_absorb2 Un_empty_left Un_empty_right\n    insert_iff empty_iff", "lemma set_filter_simps[named_ss vcg_bb]:\n    \"Set.filter P {} = {}\"\n    \"Set.filter P (insert x xs) = (if P x then insert x (Set.filter P xs) else Set.filter P xs)\"", "lemma set_collect_simps[named_ss vcg_bb]:\n    \"Set.filter P UNIV = Collect P\"\n    \"Set.filter P (Collect Q) = Collect (\\<lambda>x. P x \\<and> Q x)\"\n    \"x\\<in>UNIV\"\n    \"x\\<in>Collect P \\<longleftrightarrow> P x\"\n    \"insert x UNIV = UNIV\""], "translations": [["", "lemmas [named_ss vcg_bb cong] = ASSUMPTION_cong NO_MATCH_cong"], ["", "declaration \\<open>K\n    let\n      val asm_sol = mk_solver \"ASSUMPTION\" (fn ctxt =>\n        resolve_tac ctxt [@{thm ASSUMPTION_I}] THEN'\n        resolve_tac ctxt (Simplifier.prems_of ctxt))\n    in\n      Named_Simpsets.map_ctxt @{named_simpset vcg_bb} (\n           (fn ctxt => Simplifier.addSolver (ctxt,asm_sol))\n        #> (fn ctxt => ctxt addsimprocs [@{simproc NO_MATCH}])\n      )\n    end\n  \\<close>"], ["", "text \\<open>Congruence rules for short-circuit behaviour on if. \n    This is useful, as this simpset has to perform basic computations, \n    like variable name comparison, etc.\n    \n    Attention: Do not add short-circuit behaviour on \\<open>\\<and>,\\<or>\\<close>, or anything that might\n      clash with the evaluation of the semantics of aexp or bexp!\n    \n  \\<close>"], ["", "(*\n    TODO: Conceptually, we have two different things here. The \\<and>,\\<or> which we use to compute,\n      and the \\<and>,\\<or> that are part of the aval/bval semantics. \n      At the end, we should keep those separated!\n  *)"], ["", "lemmas [named_ss vcg_bb cong] = if_weak_cong"], ["", "(*conj_left_cong disj_left_cong*)"], ["", "lemma short_circuit: \n    \"a\\<and>b \\<longleftrightarrow> (if a then b else False)\"\n    \"a\\<or>b \\<longleftrightarrow> (if a then True else b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<and> b) = (if a then b else False) &&&\n    (a \\<or> b) = (if a then True else b)", "by auto"], ["", "text \\<open>Protection of user-specified terms, like pre/postcondition and invariants\n    from bb-computation\\<close>"], ["", "text \\<open>Tag to protect user annotations\\<close>"], ["", "definition \"BB_PROTECT \\<equiv> \\<lambda>a. a\""], ["", "lemma BB_PROTECT_cong[named_ss vcg_bb cong]: \"BB_PROTECT a = BB_PROTECT a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BB_PROTECT a = BB_PROTECT a", "by simp"], ["", "lemma BB_PROTECT: \"p \\<equiv> BB_PROTECT p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<equiv> BB_PROTECT p", "by (simp add: BB_PROTECT_def)"], ["", "ML \\<open>\n    fun mk_BB_PROTECT t = let val T=fastype_of t in \n      Const (@{const_name BB_PROTECT}, T --> T)$t end \n      \n    fun dest_BB_PROTECT (Const (@{const_name BB_PROTECT}, _)$t) = t\n      | dest_BB_PROTECT t = raise TERM(\"dest_BB_PROTECT\", [t]);\n  \\<close>"], ["", "text \\<open>Basic Logic\\<close>"], ["", "lemmas [named_ss vcg_bb] =\n    refl if_True if_False HOL.simp_thms\n    True_implies_equals False_implies_equals"], ["", "text \\<open>String Comparison\\<close>"], ["", "lemmas [named_ss vcg_bb] =\n    char.inject[unfolded short_circuit]"], ["", "lemma [unfolded short_circuit,named_ss vcg_bb]:\n    fixes x y :: char and xs ys :: string\n    shows\n    \"x#xs = y#ys \\<longleftrightarrow> x=y \\<and> xs=ys\" \n    \"x#xs \\<noteq> []\" \"[] \\<noteq> x#xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs = y # ys) = (x = y \\<and> xs = ys) &&&\n    x # xs \\<noteq> [] &&& [] \\<noteq> x # xs", "by auto"], ["", "text \\<open>State Query\\<close>"], ["", "lemma [named_ss vcg_bb]: \n    fixes s::state\n    shows\n    \"(s(x:=v)) x = v\"  \n    \"(s(x:=v)) y = (if x=y then v else s y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s(x := v)) x = v &&& (s(x := v)) y = (if x = y then v else s y)", "by auto"], ["", "(* For array indexing, we only decide syntactically equal queries, and leave the rest untouched *)"], ["", "lemma [named_ss vcg_bb]: \n    fixes a::val\n    shows\n    \"(a(i:=pv)) i = pv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a(i := pv)) i = pv", "by auto"], ["", "text \\<open> Local/Global Variables \\<close>"], ["", "text \\<open>For the next two lemmas, we use a crude heuristics to ensure that they are not \n    applied to symbolic variable names: A variable name must be a (non-empty) list.\\<close>"], ["", "lemma combine_query': \"<s|t> (x#xs) = (if is_global (x#xs) then t (x#xs) else s (x#xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <s|t> (x # xs) = (if is_global (x # xs) then t (x # xs) else s (x # xs))", "by (auto simp: combine_query)"], ["", "lemma combine_upd':\n    \"<s|t>((x#xs):=v) = (if is_global (x#xs) then <s|t((x#xs):=v)> else <s((x#xs):=v)|t>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <s|t>(x # xs := v) =\n    (if is_global (x # xs) then <s|t(x # xs := v)> else <s(x # xs := v)|t>)", "by (auto simp: combine_upd)"], ["", "lemmas [named_ss vcg_bb] = combine_collapse combine_nest"], ["", "lemmas [named_ss vcg_bb] = combine_query' combine_upd'"], ["", "lemma query_prog[named_ss vcg_bb]: \"(\\<pi>(k\\<mapsto>v)) k' = (if k'=k then Some v else \\<pi> k')\" for \\<pi> :: program"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi>(k \\<mapsto> v)) k' = (if k' = k then Some v else \\<pi> k')", "by auto"], ["", "text \\<open>Sets and Computation of Variable Sets\\<close>"], ["", "lemmas vcg_bb_set[unfolded short_circuit, named_ss vcg_bb] =\n    Un_insert_left Un_insert_right insert_commute insert_absorb2 Un_empty_left Un_empty_right\n    insert_iff empty_iff"], ["", "lemma set_filter_simps[named_ss vcg_bb]:\n    \"Set.filter P {} = {}\"\n    \"Set.filter P (insert x xs) = (if P x then insert x (Set.filter P xs) else Set.filter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.filter P {} = {} &&&\n    Set.filter P (insert x xs) =\n    (if P x then insert x (Set.filter P xs) else Set.filter P xs)", "by auto"], ["", "lemma set_collect_simps[named_ss vcg_bb]:\n    \"Set.filter P UNIV = Collect P\"\n    \"Set.filter P (Collect Q) = Collect (\\<lambda>x. P x \\<and> Q x)\"\n    \"x\\<in>UNIV\"\n    \"x\\<in>Collect P \\<longleftrightarrow> P x\"\n    \"insert x UNIV = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Set.filter P UNIV = Collect P &&&\n     Set.filter P (Collect Q) = {x. P x \\<and> Q x}) &&&\n    x \\<in> UNIV &&& (x \\<in> Collect P) = P x &&& insert x UNIV = UNIV", "by auto"], ["", "method i_vcg_bb = (simp named_ss vcg_bb: )"], ["", "end"]]}