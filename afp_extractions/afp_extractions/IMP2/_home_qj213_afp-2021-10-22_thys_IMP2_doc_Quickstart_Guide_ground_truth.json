{"file_name": "/home/qj213/afp-2021-10-22/thys/IMP2/doc/Quickstart_Guide.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IMP2", "problem_names": ["lemma array_sum_aux: \"l\\<^sub>0\\<le>l \\<Longrightarrow> {l\\<^sub>0..<l + 1} = insert l {l\\<^sub>0..<l}\" for l\\<^sub>0 l :: int"], "translations": [["", "lemma array_sum_aux: \"l\\<^sub>0\\<le>l \\<Longrightarrow> {l\\<^sub>0..<l + 1} = insert l {l\\<^sub>0..<l}\" for l\\<^sub>0 l :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. l\\<^sub>0 \\<le> l \\<Longrightarrow>\n    {l\\<^sub>0..<l + 1} = insert l {l\\<^sub>0..<l}", "by auto"], ["", "procedure_spec array_sum(a,l,h) returns s assumes \"l\\<le>h\" ensures \\<open>s = (\\<Sum>i=l\\<^sub>0..<h\\<^sub>0. a\\<^sub>0 i)\\<close> defines \n    \\<open> s=0; \n      while (l<h) \n        @variant \\<open>h-l\\<close>\n        @invariant \\<open>l\\<^sub>0\\<le>l \\<and> l\\<le>h \\<and> s = (\\<Sum>i=l\\<^sub>0..<l. a i)\\<close>\n      { s = s+a[l]; l=l+1 } \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty\n     (\\<lambda>\\<ss>.\n         VAR (\\<ss> ''l'' 0)\n          (\\<lambda>l.\n              VAR (\\<ss> ''h'' 0) (\\<lambda>h. BB_PROTECT (l \\<le> h))))\n     (\\<lambda>\\<ss>\\<^sub>0. ''s'' ::= N 0;;\n         WHILE {ANNOTATION\n                 (\\<lambda>\\<ss>.\n                     VAR (\\<ss> ''l'' 0)\n                      (\\<lambda>l.\n                          VAR (\\<ss> ''h'' 0)\n                           (\\<lambda>h.\n                               BB_PROTECT\n                                (h -\n                                 l))))} {ANNOTATION\n    (\\<lambda>\\<ss>.\n        VAR (\\<ss> ''s'' 0)\n         (\\<lambda>s.\n             VAR (\\<ss> ''l'' 0)\n              (\\<lambda>l.\n                  VAR (\\<ss> ''h'' 0)\n                   (\\<lambda>h.\n                       VAR (\\<ss> ''a'')\n                        (\\<lambda>a.\n                            VAR (\\<ss>\\<^sub>0 ''l'' 0)\n                             (\\<lambda>l\\<^sub>0.\n                                 BB_PROTECT\n                                  (l\\<^sub>0 \\<le> l \\<and>\n                                   l \\<le> h \\<and>\n                                   s =\n                                   sum a\n                                    {l\\<^sub>0..<l})))))))} Cmpop (<)\n                       (V ''l'') (V ''h'')\n         DO (''s'' ::= Binop (+) (V ''s'') (Vidx ''a'' (V ''l''));;\n             ''l'' ::= Binop (+) (V ''l'') (N 1)))\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''s'' 0)\n          (\\<lambda>s.\n              VAR (\\<ss>\\<^sub>0 ''l'' 0)\n               (\\<lambda>l\\<^sub>0.\n                   VAR (\\<ss>\\<^sub>0 ''h'' 0)\n                    (\\<lambda>h\\<^sub>0.\n                        VAR (\\<ss>\\<^sub>0 ''a'')\n                         (\\<lambda>a\\<^sub>0.\n                             BB_PROTECT\n                              (s =\n                               sum a\\<^sub>0 {l\\<^sub>0..<h\\<^sub>0}))))))", "apply vcg_cs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a\\<^sub>0 l\\<^sub>0 h\\<^sub>0 l.\n       \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0 \\<le> l;\n        l < h\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> sum a\\<^sub>0 {l\\<^sub>0..<l} + a\\<^sub>0 l =\n                         sum a\\<^sub>0 {l\\<^sub>0..<l + 1}", "apply (simp add: array_sum_aux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Proving Techniques\\<close>"], ["", "text \\<open>This section contains a small collection of techniques to tackle large proofs.\\<close>"], ["", "subsubsection \\<open>Auxiliary Lemmas\\<close>"], ["", "text \\<open>Prove auxiliary lemmas, and try to keep the actual proof of the specification small.\n    As a rule of thumb: All VCs that cannot be solved by a simple @{method auto} invocation\n    should go to an auxiliary lemma. \n    \n    The auxiliary lemma may either re-state the whole VC, or only prove the ``essence'' of the VC, \n    such that the rest of its proof becomes automatic again.\n    See the @{const array_sum} program above for an example or the latter case.\n    \n    \\<^bold>\\<open>Pitfall\\<close> When extracting auxiliary lemmas, it is too easy to get too general types, which\n      may render the lemmas unprovable. As an example, omitting the explicit type constraints\n      from @{thm [source] \"array_sum_aux\"} will yield an unprovable statement.\n  \\<close>"], ["", "subsubsection \\<open>Inlining\\<close>"], ["", "text \\<open>More complex procedure bodies can be modularized by either splitting them into \n    multiple procedures, or using inlining and @{command program_spec} to explicitly prove a \n    specification for a part of a program. Cf.\\ the insertion sort example for the latter technique. \\<close>"], ["", "subsubsection \\<open>Functional Refinement\\<close>"], ["", "text \\<open>\n    Sometimes, it makes sense to state the algorithm functionally first, and then prove that\n    the implementation behaves like the functional program, and, separately, that the functional \n    program is correct. Cf.\\ the mergesort example.\n  \\<close>"], ["", "subsubsection \\<open>Data Refinement\\<close>"], ["", "text \\<open>Moreover, it sometimes makes sense to abstract the concrete variables to abstract types, \n    over which the algorithm is then specified. For example, an array \\<open>a\\<close> with a range \\<open>l..<h\\<close> can \n    be understood as a list. Or an array can be used as a bitvector set. \n    Cf.\\ the mergesort and dedup examples. \\<close>"], ["", "subsection \\<open>Troubleshooting\\<close>"], ["", "text \\<open>We list a few common problems and their solutions here\\<close>"], ["", "subsubsection \\<open>Invalid Variables in Annotations\\<close>"], ["", "text \\<open>Undeclared variables in annotations are highlighted, however, no warning or error is produced. \n  Usually, the generated VCs will not be provable. The most common mistake is to \n  forget the \\<open>\\<^sub>0\\<close> suffix when referring to parameter values in (in)variants and postconditions.\\<close>"], ["", "text \\<open>Note the highlighting of unused variables in the following example\\<close>"], ["", "procedure_spec foo(x1,x2) returns y assumes \"x1>x2+x3\" ensures \"y = x1\\<^sub>0+x2\" defines \\<open>\n      y=0;\n    while (x1>0)\n      @variant \\<open>y + x3\\<close>\n      @invariant \\<open>y>x3\\<close>\n      {\n        x1=x2\n      }\n  \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty\n     (\\<lambda>\\<ss>.\n         VAR (\\<ss> ''x2'' 0)\n          (\\<lambda>x2.\n              VAR (\\<ss> ''x1'' 0)\n               (\\<lambda>x1. BB_PROTECT (x2 + x3 < x1))))\n     (\\<lambda>\\<ss>\\<^sub>0. ''y'' ::= N 0;;\n         WHILE {ANNOTATION\n                 (\\<lambda>\\<ss>.\n                     VAR (\\<ss> ''y'' 0)\n                      (\\<lambda>y.\n                          BB_PROTECT\n                           (y +\n                            x3)))} {ANNOTATION\n                                     (\\<lambda>\\<ss>.\n   VAR (\\<ss> ''y'' 0)\n    (\\<lambda>y.\n        BB_PROTECT (x3 < y)))} Cmpop (\\<lambda>x y. y < x) (V ''x1'') (N 0)\n         DO ''x1''[] ::= ''x2'')\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''y'' 0)\n          (\\<lambda>y.\n              VAR (\\<ss>\\<^sub>0 ''x1'' 0)\n               (\\<lambda>x1\\<^sub>0. BB_PROTECT (y = x1\\<^sub>0 + x2))))", "oops"], ["", "text \\<open>Even worse, if the most general type of an annotation becomes too general,\n    as free variables have type \\<^typ>\\<open>'a\\<close> by default, you will see an internal type error.\n    \n    Try replacing the variant or invariant with a free variable in the above example.\n  \\<close>"], ["", "(* TODO: Is there an expects-error unit-test command in Isabelle already? *)"], ["", "subsubsection \\<open>Wrong Annotations\\<close>"], ["", "text \\<open>For total correctness, you must annotate a loop variant and invariant. \n    For partial correctness, you must annotate an invariant, but \\<^bold>\\<open>no variant\\<close>.\n    \n    When not following this rule, the VCG will get stuck in an internal state\n  \\<close>"], ["", "procedure_spec (partial) foo () assumes True ensures True defines \\<open>\n    while (n>0) @variant \\<open>n\\<close> @invariant \\<open>True\\<close>\n    { n=n-1 }\n  \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT'_partial Map.empty (\\<lambda>\\<ss>. BB_PROTECT True)\n     (\\<lambda>\\<ss>\\<^sub>0.\n         WHILE {ANNOTATION\n                 (\\<lambda>\\<ss>.\n                     VAR (\\<ss> ''n'' 0)\n                      BB_PROTECT)} {ANNOTATION\n                                     (\\<lambda>\\<ss>.\n   BB_PROTECT True)} Cmpop (\\<lambda>x y. y < x) (V ''n'') (N 0)\n         DO ''n'' ::= Binop (-) (V ''n'') (N 1))\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>. BB_PROTECT True)", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<ss>\\<^sub>0.\n       True \\<Longrightarrow>\n       wlp Map.empty\n        (WHILE {\\<lambda>\\<ss>.\n                   \\<ss> ''n''\n                    0} {\\<lambda>\\<ss>.\n                           True} Cmpop (\\<lambda>x y. y < x) (V ''n'') (N 0)\n         DO ''n'' ::= Binop (-) (V ''n'') (N 1))\n        (\\<lambda>\\<ss>. True) \\<ss>\\<^sub>0", "oops"], ["", "subsubsection \\<open>Calls to Undefined Procedures\\<close>"], ["", "text \\<open>Calling an undefined procedure usually results in a type error, as the procedure \n    name gets interpreted as an Isabelle term, e.g., either it refers to an existing constant, \n    or is interpreted as a free variable\\<close>"], ["", "(* term \\<open>\\<^imp>\\<open> undefined() \\<close>\\<close> (* Type unification failed *) *)"], ["", "subsection \\<open>Missing Features\\<close>"], ["", "text \\<open>This is an (incomplete) list of missing features.\\<close>"], ["", "subsubsection \\<open>Elaborate Warnings and Errors\\<close>"], ["", "text \\<open>Currently, the IMP2 tools only produce minimal error and warning messages.\n    Quite often, the user sees the raw error message as produced by Isabelle unfiltered, \n    including all internal details of the tools. \n  \\<close>"], ["", "subsubsection \\<open>Static Type Checking\\<close>"], ["", "text \\<open>We do no static type checking at all. \n    In particular, we do not check, nor does our semantic enforce, that procedures are called \n    with the same number of arguments as they were declared. \n    Programs that violate this convention may even have provable properties, as argument \n    and parameter passing is modeled as macros on top of the semantics, and the semantics has no\n    notion of failure.\n  \\<close>"], ["", "subsubsection \\<open>Structure Types\\<close>"], ["", "text \\<open>Every variable is an integer arrays. Plain integer variables are implemented as \n    macros on top of this, by referring to index \\<open>0\\<close>.\n    \n    The most urgent addition to increase usability would be record types. \n    With them, we could model encapsulation and data refinement more explicitly, by\n    collecting all parts of a data structure in a single (record-typed) variable.\n\n    An easy way of adding record types would follow a similar route as arrays, \n    modeling values of variables as a recursive tree-structured datatype.\n    \n    @{theory_text [display] \\<open>datatype val = PRIM int | STRUCT \"fname \\<Rightarrow> val\" | ARRAY \"int \\<Rightarrow> val\"\\<close>}\n\n    However, for modeling the semantics, we most likely want to introduce an explicit error state,\n    to distinguish type errors (e.g. accessing a record field of an integer value) from nontermination.\n    \\<close>"], ["", "subsubsection \\<open>Function Calls as Expressions\\<close>"], ["", "text \\<open>Currently, function calls are modeled as statements, and thus, cannot be nested into \n    expressions. Doing so would require to simultaneously specify the semantics of \n    commands and expressions, which makes things more complex. \n    \n    As the language is intended to be simple, we have not done this.\n  \\<close>"], ["", "subsubsection \\<open>Ghost Variables\\<close>"], ["", "text \\<open>Ghost variables are a valuable tool for expressing (data) refinement, \n    and hinting the VCG towards the abstract algorithm structure.\n    \n    We believe that we can add ghost variables with annotations on top of the VCG,\n    without actually changing the program semantics.\n  \\<close>"], ["", "subsubsection \\<open>Concurrency\\<close>"], ["", "text \\<open>IMP2 is a single threaded language. \n    We have no current plans to add concurrency, as this would greatly complicate both the \n    semantics and the VCG, which is contrary to the goal of a simple language for educational \n    purposes.\n  \\<close>"], ["", "subsubsection \\<open>Pointers and Memory\\<close>"], ["", "text \\<open>Adding pointers and memory allocation to IMP2 is theoretically possible, but, again, \n    this would complicate the semantics and the VCG.\n\n    However, as the author has some experience in VCGs using separation logic, he might actually\n    add pointers and memory allocation to IMP2 in the near future.\n  \\<close>"], ["", "end"]]}