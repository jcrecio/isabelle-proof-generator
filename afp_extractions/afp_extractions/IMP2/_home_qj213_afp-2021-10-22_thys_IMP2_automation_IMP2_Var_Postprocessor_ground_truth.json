{"file_name": "/home/qj213/afp-2021-10-22/thys/IMP2/automation/IMP2_Var_Postprocessor.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IMP2", "problem_names": ["lemma RENAMINGD: \"RENAMING s d \\<Longrightarrow> s = d\"", "lemma RENAMINGI:\n    assumes \"\\<And>d. RENAMING s d \\<Longrightarrow> P\"\n    shows \"P\""], "translations": [["", "lemma RENAMINGD: \"RENAMING s d \\<Longrightarrow> s = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RENAMING s d \\<Longrightarrow> s = d", "unfolding RENAMING_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = d \\<Longrightarrow> s = d", "by auto"], ["", "lemma RENAMINGI:\n    assumes \"\\<And>d. RENAMING s d \\<Longrightarrow> P\"\n    shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  RENAMING s ?d \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "unfolding RENAMING_def"], ["proof (prove)\nusing this:\n  s = ?d \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by simp"], ["", "ML \\<open>\n    structure Renaming = struct\n      fun RENAMING_rl ctxt (s,d) = let\n        (* FIXME: Rough approximation to hit \\<And>d. \\<dots> *)\n        fun rn (Abs (\"d\",T,t)) = Abs (d,T,t)\n          | rn (a$b) = rn a $ rn b\n          | rn t = t\n    \n        val s = Thm.cterm_of ctxt s\n          \n        val thm = @{thm RENAMINGI}\n          |> Drule.infer_instantiate' ctxt [SOME s]\n        \n        val t = thm  |> Thm.prop_of |> rn\n        val thm' = Thm.renamed_prop t thm\n      in thm' end\n  \n      \n      fun apply_renamings_tac ctxt = let\n        fun is_renaming (Const (@{const_name RENAMING},_)$_$_) = true | is_renaming _ = false\n      in \n        Subgoal_Focus_Some.FOCUS_SOME_PREMS (fn _ => Thm.term_of #> HOLogic.dest_Trueprop #> is_renaming)\n          (fn {context=ctxt, prems, ...} => let \n            val thms = map (fn t => @{thm RENAMINGD} OF [t]) prems\n          in \n            Local_Defs.unfold_tac ctxt thms end) ctxt\n      \n      end\n      \n      \n      fun remove_renamings_tac ctxt = let \n        (* TODO: Unsafe. Should check that source does not occur elsewhere in goal! *)\n      in\n        SELECT_GOAL (\n          REPEAT_DETERM (HEADGOAL (eresolve_tac ctxt @{thms thin_rl[of \"RENAMING _ _\"]})\n            THEN Local_Defs.unfold_tac ctxt @{thms triv_forall_equality}\n          ))\n      end\n      \n      \n    end\n  \\<close>"], ["", "method_setup i_vcg_apply_renamings_tac = \\<open>Scan.succeed (SIMPLE_METHOD' o Renaming.apply_renamings_tac)\\<close>"], ["", "method_setup i_vcg_remove_renamings_tac = \\<open>Scan.succeed (SIMPLE_METHOD' o Renaming.remove_renamings_tac)\\<close>"], ["", "definition NAMING_HINT :: \"state \\<Rightarrow> string \\<Rightarrow> string \\<Rightarrow> bool\" where \"NAMING_HINT s x n \\<equiv> True\""], ["", "ML \\<open>\n    (*\n      Postprocess VCs to convert states applied to variable names to actual logical variables.\n    *)\n    structure VC_Postprocessor = struct\n    \n      (* Guess suffix from name, e.g. \"a\\<^sub>3\" \\<mapsto> \"\\<^sub>3\" *)  \n      val guess_suffix = let\n        val sfxs = [\"'\",\"\\<^sub>\",\"\\<^sup>\",\"\\<^bsub>\",\"\\<^bsup>\"]\n      in  \n        Symbol.explode #> chop_prefix (not o member op = sfxs) #> snd #> implode\n      end\n    \n      fun guess_renaming param_rename_tab ((s,x),(kind,vname)) = let\n\n        fun name_of (Free (n,_)) = n\n          | name_of _ = \"v\"\n            \n        val sname = the_default (name_of s) (Termtab.lookup param_rename_tab s)\n      \n        val sfx = guess_suffix sname\n        val src = case kind of\n          IMP_Syntax.ARRAY => s$x | IMP_Syntax.VAL => s$x$ @{term \"0::int\"}\n      \n        val dst = suffix sfx vname\n      in\n        (src,dst)\n      end\n      \n      \n      structure Candtab = Table(type key = term*term val ord = prod_ord Term_Ord.fast_term_ord Term_Ord.fast_term_ord)\n      \n      fun add_state_candidates ((s as Free (_,@{typ state})) $ x) = (\n        case try HOLogic.dest_string x of\n          SOME vname => apfst (Candtab.update ((s,x),(IMP_Syntax.ARRAY,vname)))\n        | NONE => apsnd (insert op= s) #> add_state_candidates x  \n      )\n      | add_state_candidates ((s as Free (_,@{typ state})) $ x $ @{term \"0::int\"}) = (\n        case try HOLogic.dest_string x of\n          SOME vname => apfst (Candtab.default ((s,x),(IMP_Syntax.VAL,vname)))\n        | NONE => apsnd (insert op= s) #> add_state_candidates x  \n      )\n      | add_state_candidates (s as Free (_,@{typ state})) = apsnd (insert op= s)\n      | add_state_candidates (a$b) = add_state_candidates a #> add_state_candidates b\n      | add_state_candidates (Abs (_,_,t)) = add_state_candidates t\n      | add_state_candidates _ = I\n      \n      fun hint_renaming hint_tab (rn as (sx,(kind,_))) = case Candtab.lookup hint_tab sx of\n        NONE => rn\n      | SOME vname' => (sx,(kind,vname'))\n      \n      fun compute_renamings param_rename_tab hint_tab (good,bad) = \n        subtract (fn (bs, ((s,_),_)) => bs=s) bad (Candtab.dest good)\n      |> map (hint_renaming hint_tab)  \n      |> map (guess_renaming param_rename_tab)\n      \n      (* Naming hints go to hint-tab in #1, other premises go to list in #2 *)\n      fun add_naming_hint (@{const Trueprop}$(@{const NAMING_HINT}$s$x$n)) = (case try HOLogic.dest_string n of\n          SOME n => apfst (Candtab.update ((s,x),n))\n        | NONE => (warning \"NAMING_HINT with non-string constant ignored\"; I)\n        )\n      | add_naming_hint t = apsnd (cons t)\n      \n      \n      val insert_vbind_tac = Subgoal.FOCUS_PREMS (fn {context=ctxt, concl, params, prems, ...} => let\n          val conclt = Thm.term_of concl\n          \n          val param_rename_tab = params |> map (apsnd (Thm.term_of) #> swap) |> Termtab.make \n          \n          val (hint_tab,prem_ts) = \n            fold (add_naming_hint o Thm.prop_of) prems (Candtab.empty,[]) \n          \n          (* val _ = @{print} (hint_tab,prem_ts)  *)\n            \n          val renamings = \n              add_state_candidates conclt (Candtab.empty,[]) \n            |> fold (add_state_candidates) prem_ts\n            |> compute_renamings param_rename_tab hint_tab\n            \n          val tacs = map (resolve_tac ctxt o single o Renaming.RENAMING_rl ctxt) renamings\n        in\n          EVERY1 tacs\n        end\n        )\n      \n      fun remove_tac ctxt = let \n        (* TODO: Unsafe. Should check that source does not occur elsewhere in goal! *)\n      in\n        SELECT_GOAL (REPEAT_DETERM (HEADGOAL (eresolve_tac ctxt @{thms thin_rl[of \"NAMING_HINT _ _ _\"]})))\n        THEN' Renaming.remove_renamings_tac ctxt\n      end\n        \n        \n      fun postprocess_vc_tac ctxt =\n        insert_vbind_tac ctxt\n        THEN' Renaming.apply_renamings_tac ctxt\n        THEN' remove_tac ctxt\n  \n    end\n  \\<close>"], ["", "method_setup i_vcg_insert_vbind_tac = \\<open>Scan.succeed (SIMPLE_METHOD' o VC_Postprocessor.insert_vbind_tac)\\<close>"], ["", "method_setup i_vcg_postprocess_vars = \\<open>Scan.succeed (SIMPLE_METHOD' o VC_Postprocessor.postprocess_vc_tac)\\<close>"], ["", "end"]]}