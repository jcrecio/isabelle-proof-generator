{"file_name": "/home/qj213/afp-2021-10-22/thys/IMP2/automation/IMP2_Specification.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IMP2", "problem_names": ["lemmas [named_ss vcg_bb cong] = refl[of \"ANNOTATION _\"]", "lemma HT_to_mod: \"HT \\<pi> P c Q = HT_mods \\<pi> (ANALYZE (lhsv \\<pi> c)) P c Q\"", "lemma HT_partial_to_mod: \"HT_partial \\<pi> P c Q = HT_partial_mods \\<pi> (ANALYZE (lhsv \\<pi> c)) P c Q\"", "lemma mk_lhsv_thm:  \n  assumes \"c \\<equiv> cmd\"\n  shows \"lhsv \\<pi> c = ANALYZE (lhsv \\<pi> cmd)\" \"lhsv' c = ANALYZE (lhsv' cmd)\"", "lemma adjust_assign_after:\n  assumes \"HT \\<pi> P c Q\"\n  shows \"HT \\<pi> P (c;;x[]::=y) (\\<lambda>s\\<^sub>0 s. \\<exists>vx. Q s\\<^sub>0 (s(x:=vx,y:=s x)))\"", "lemma adjust_assign_before:\n  assumes HT: \"HT \\<pi> P c Q\"  \n  shows \"HT \\<pi> (\\<lambda>s. P (s(x:=s y)) ) (x[]::=y;; c) (\\<lambda>s\\<^sub>0 s. Q (s\\<^sub>0(x:=s\\<^sub>0 y)) s)\"", "lemma adjust_scope:\n  assumes HT: \"HT \\<pi> P c Q\"\n  shows \"HT \\<pi> (\\<lambda>s. P (<<>|s>)) (SCOPE c) (\\<lambda>s\\<^sub>0 s. \\<exists>l. Q (<<>|s\\<^sub>0>) (<l|s>))\"", "lemma adjust_assign_after_partial:\n  assumes \"HT_partial \\<pi> P c Q\"\n  shows \"HT_partial \\<pi> P (c;;x[]::=y) (\\<lambda>s\\<^sub>0 s. \\<exists>vx. Q s\\<^sub>0 (s(x:=vx,y:=s x)))\"", "lemma adjust_assign_before_partial:\n  assumes HT: \"HT_partial \\<pi> P c Q\"  \n  shows \"HT_partial \\<pi> (\\<lambda>s. P (s(x:=s y)) ) (x[]::=y;; c) (\\<lambda>s\\<^sub>0 s. Q (s\\<^sub>0(x:=s\\<^sub>0 y)) s)\"", "lemma adjust_scope_partial:\n  assumes HT: \"HT_partial \\<pi> P c Q\"\n  shows \"HT_partial \\<pi> (\\<lambda>s. P (<<>|s>)) (SCOPE c) (\\<lambda>s\\<^sub>0 s. \\<exists>l. Q (<<>|s\\<^sub>0>) (<l|s>))\"", "lemma HT_strengthen_modset:  \n  assumes \"HT \\<pi> P c Q\"\n  shows \"HT \\<pi> P c (\\<lambda>s\\<^sub>0 s. Q s\\<^sub>0 s \\<and> modifies (lhsv \\<pi> c) s s\\<^sub>0)\"", "lemma HT_partial_strengthen_modset:  \n  assumes \"HT_partial \\<pi> P c Q\"\n  shows \"HT_partial \\<pi> P c (\\<lambda>s\\<^sub>0 s. Q s\\<^sub>0 s \\<and> modifies (lhsv \\<pi> c) s s\\<^sub>0)\"", "lemma ADJUST_PRE_SCOPE_unfolds:\n    \"\\<And>P. ADJUST_PRE_SCOPE (\\<lambda>_. P) = (\\<lambda>_. P)\"\n    \"\\<And>P. ADJUST_PRE_SCOPE (\\<lambda>s. VAR v (\\<lambda>x. P x s)) = VAR v (\\<lambda>x. ADJUST_PRE_SCOPE (\\<lambda>s. P x s))\"\n    \n    \"\\<And>P. is_global x \\<Longrightarrow> ADJUST_PRE_SCOPE (\\<lambda>s. VAR (s x i) (\\<lambda>x. P x s)) = (\\<lambda>s. VAR (s x i) (\\<lambda>x. ADJUST_PRE_SCOPE (\\<lambda>s. P x s) s))\"\n    \"\\<And>P. is_global x \\<Longrightarrow> ADJUST_PRE_SCOPE (\\<lambda>s. VAR (s x) (\\<lambda>x. P x s)) = (\\<lambda>s. VAR (s x) (\\<lambda>x. ADJUST_PRE_SCOPE (\\<lambda>s. P x s) s))\"", "lemma ADJUST_PRE_PARAM_unfolds:  \n    \"\\<And>P. ADJUST_PRE_PARAM l G (\\<lambda>_. P) = (\\<lambda>_. P)\"\n    \"\\<And>P. ADJUST_PRE_PARAM l G (\\<lambda>s. VAR v (\\<lambda>x. P x s)) = VAR v (\\<lambda>x. ADJUST_PRE_PARAM l G (\\<lambda>s. P x s))\"\n    \n    \n    \"\\<And>P. ADJUST_PRE_PARAM l G (\\<lambda>s. VAR (s l i) (\\<lambda>x. P x s)) = (\\<lambda>s. VAR (s G i) (\\<lambda>x. ADJUST_PRE_PARAM l G (\\<lambda>s. P x s) s))\"\n    \"\\<And>P. ADJUST_PRE_PARAM l G (\\<lambda>s. VAR (s l) (\\<lambda>x. P x s)) = (\\<lambda>s. VAR (s G) (\\<lambda>x. ADJUST_PRE_PARAM l G (\\<lambda>s. P x s) s))\"\n    \n    \"\\<And>P. x\\<noteq>l \\<Longrightarrow> ADJUST_PRE_PARAM l G (\\<lambda>s. VAR (s x i) (\\<lambda>x. P x s)) = (\\<lambda>s. VAR (s x i) (\\<lambda>x. ADJUST_PRE_PARAM l G (\\<lambda>s. P x s) s))\"\n    \"\\<And>P. x\\<noteq>l \\<Longrightarrow> ADJUST_PRE_PARAM l G (\\<lambda>s. VAR (s x) (\\<lambda>x. P x s)) = (\\<lambda>s. VAR (s x) (\\<lambda>x. ADJUST_PRE_PARAM l G (\\<lambda>s. P x s) s))\"", "lemma ADJUST_POST_SCOPE_unfolds:\n    \"\\<And>P. ADJUST_POST_SCOPE (\\<lambda>_ _. P) = (\\<lambda>_ _. P)\"\n    \n    \"\\<And>P. is_global x \\<Longrightarrow> ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x i) (\\<lambda>x. ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. is_global x \\<Longrightarrow> ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x) (\\<lambda>x. ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \n    \"\\<And>P. is_global x \\<Longrightarrow> ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. is_global x \\<Longrightarrow> ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"", "lemma ADJUST_POST_PARAM_unfolds: \n    \"\\<And>P. ADJUST_POST_PARAM l G (\\<lambda>_ _. P) = (\\<lambda>_ _. P)\" \n    \n    \"\\<And>P. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 l i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 G i) (\\<lambda>x. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 l) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 G) (\\<lambda>x. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n  \n    \"\\<And>P. x\\<noteq>l \\<Longrightarrow> ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x i) (\\<lambda>x. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. x\\<noteq>l \\<Longrightarrow> ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x) (\\<lambda>x. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \n    \"\\<And>P. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"", "lemma ADJUST_POST_RETV_unfolds:\n    \"\\<And>P. ADJUST_POST_RETV G l (\\<lambda>_ _. P) = (\\<lambda>_ _. P)\"\n    \n    \"\\<And>P. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x i) (\\<lambda>x. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x) (\\<lambda>x. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n  \n    \"\\<And>P. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. VAR (s l i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s G i) (\\<lambda>x. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. VAR (s l) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s G) (\\<lambda>x. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n      \n    \"\\<And>P. \\<lbrakk>x\\<noteq>G; x\\<noteq>l\\<rbrakk> \\<Longrightarrow> ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. \\<lbrakk>x\\<noteq>G; x\\<noteq>l\\<rbrakk> \\<Longrightarrow> ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"", "lemmas ADJUST_unfolds = ADJUST_PRE_SCOPE_unfolds ADJUST_PRE_PARAM_unfolds \n    ADJUST_POST_SCOPE_unfolds ADJUST_POST_PARAM_unfolds ADJUST_POST_RETV_unfolds", "lemma HT_mods_adjust_scope: \n    assumes \"HT_mods \\<pi> vs P c Q\"\n    shows \"HT_mods \\<pi> (Set.filter is_global vs) (ADJUST_PRE_SCOPE P) (SCOPE c) (ADJUST_POST_SCOPE Q)\"", "lemma HT_mods_adjust_param: \n    assumes \"HT_mods \\<pi> vs P c Q\"\n    shows \"HT_mods \\<pi> (insert l vs) (ADJUST_PRE_PARAM l G P) (l[]::=G;; c) (ADJUST_POST_PARAM l G Q)\"", "lemma HT_mods_adjust_retv:\n    assumes \"HT_mods \\<pi> vs P c Q\"\n    shows \"HT_mods \\<pi> (insert G vs) P (c;; G[]::=l) (ADJUST_POST_RETV G l Q)\"", "lemma HT_partial_mods_adjust_scope: \n    assumes \"HT_partial_mods \\<pi> vs P c Q\"\n    shows \"HT_partial_mods \\<pi> (Set.filter is_global vs) (ADJUST_PRE_SCOPE P) (SCOPE c) (ADJUST_POST_SCOPE Q)\"", "lemma HT_partial_mods_adjust_param: \n    assumes \"HT_partial_mods \\<pi> vs P c Q\"\n    shows \"HT_partial_mods \\<pi> (insert l vs) (ADJUST_PRE_PARAM l G P) (l[]::=G;; c) (ADJUST_POST_PARAM l G Q)\"", "lemma HT_partial_mods_adjust_retv:\n    assumes \"HT_partial_mods \\<pi> vs P c Q\"\n    shows \"HT_partial_mods \\<pi> (insert G vs) P (c;; G[]::=l) (ADJUST_POST_RETV G l Q)\"", "lemma HT_generalize_penv:\n  assumes \"HT_mods Map.empty mods P c Q\"\n  shows \"HT_mods \\<pi> mods P c Q\"", "lemma HT_mods_fold_call:\n  assumes \"\\<pi> p = Some c\"\n  assumes \"HT_mods \\<pi> mods P c Q\"\n  shows \"HT_mods \\<pi> mods P (PCall p) Q\"", "lemma localize_HT_mods: \n  assumes \"HT_mods \\<pi> mods P (PCall p) Q\"\n  shows \"HT_mods \\<pi>' mods P (PScope \\<pi> (PCall p)) Q\"", "lemmas localize_HT_mods' = localize_HT_mods[where \\<pi>'=\"Map.empty\"]", "lemma PROVE_\\<Theta>I[vcg_preprocess_rules]:\n  \"PROVE_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 {}\" \n  \"\\<lbrakk>\\<lbrakk>RENAMING f\\<^sub>0 f; BB_PROTECT (P s\\<^sub>0)\\<rbrakk> \\<Longrightarrow> wp \\<pi> (c s\\<^sub>0) (Q s\\<^sub>0) s\\<^sub>0; PROVE_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 \\<Theta>\\<rbrakk> \\<Longrightarrow> PROVE_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 (insert (f,(P,c,Q)) \\<Theta>)\"", "lemma JOIN_VARS: \n  \"\\<And>v f g P. JOIN_VARS (VAR v (\\<lambda>x. f x)) g P = VAR v (\\<lambda>x. JOIN_VARS (f x) g P)\"\n  \"\\<And>v f g P. JOIN_VARS f (VAR v (\\<lambda>x. g x)) P = VAR v (\\<lambda>x. JOIN_VARS f (g x) P)\"\n  \"\\<And>f g P. JOIN_VARS (BB_PROTECT f) (BB_PROTECT g) P = P f g\"", "lemmas ASSUME_\\<Theta>E1 = thin_rl[of \"ASSUME_\\<Theta> _ _ _ _ {}\"]", "lemma ASSUME_\\<Theta>E2:\n  assumes \"ASSUME_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 R (insert (f,(P,c,Q)) \\<Theta>)\"\n  obtains \"HT' \\<pi> (\\<lambda>s. JOIN_VARS (f s) (P s) (\\<lambda>v P. BB_PROTECT ((v,(f\\<^sub>0 s\\<^sub>0))\\<in>R \\<and> P))) c Q\" \"ASSUME_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 R \\<Theta>\"", "lemmas ASSUME_\\<Theta>E = ASSUME_\\<Theta>E1 ASSUME_\\<Theta>E2", "lemma vcg_HT'setI:    \n  assumes \"wf R\"\n  assumes RL: \"\\<And>f\\<^sub>0 s\\<^sub>0. \\<lbrakk> ASSUME_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 R \\<Theta> \\<rbrakk> \\<Longrightarrow> PROVE_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 \\<Theta>\"\n  shows \"HT'set \\<pi> \\<Theta>\""], "translations": [["", "lemmas [named_ss vcg_bb cong] = refl[of \"ANNOTATION _\"]"], ["", "ML \\<open> structure IMP_Annotations \n  = struct\n    fun strip_annotations ctxt = \n      Local_Defs.unfold ctxt (Named_Theorems.get ctxt @{named_theorems vcg_annotation_defs})\n    \n    fun strip_annotations_term ctxt = \n      Thm.cterm_of ctxt #> Drule.mk_term #> \n      strip_annotations ctxt #>\n      Drule.dest_term #> Thm.term_of\n\n    fun mk_ANNOTATION t = let val T=fastype_of t in \n      Const (@{const_name ANNOTATION}, T --> T)$t end \n      \n    fun dest_ANNOTATION (Const (@{const_name ANNOTATION}, _)$t) = t\n      | dest_ANNOTATION t = raise TERM(\"dest_ANNOTATION\", [t]);\n      \n    \n    (* Provides a context for reading the term, and a postprocessing function *)\n    type term_annot_reader = Proof.context * (term -> term)  \n    fun gen_read_ta rd ((ctxt,post):term_annot_reader) src = rd ctxt src |> mk_BB_PROTECT |> post\n    val read_ta_from_cartouche = gen_read_ta Term_Annot.read_term\n\n    (* Annotations *)\n    \n    type cmd_annotation_readers = {\n      rel_rd : term_annot_reader,\n      variant_rd : term_annot_reader,\n      invar_rd : term_annot_reader,\n      com_post: term -> term\n    }\n    \n          \n    fun gen_interpret_annotations (annot_readers : cmd_annotation_readers) ctxt prog_t = let\n    \n      (* TODO/FIXME: Terms are read independently, which will cause too generic types to be inferred *)\n\n      val read_invar = read_ta_from_cartouche (#invar_rd annot_readers)\n      val read_variant = read_ta_from_cartouche (#variant_rd annot_readers)\n      val read_rel = read_ta_from_cartouche (#rel_rd annot_readers)\n          \n      val mpt = map_types (map_type_tfree (K dummyT))\n      \n      fun interp_while_annot (t,@{syntax_const \"_invariant_annotation\"}) (R,V,I) = (R,V,read_invar t :: I)\n        | interp_while_annot (t,@{syntax_const \"_variant_annotation\"})   (R,V,I) = (R,read_variant t :: V,I)\n        | interp_while_annot (t,@{syntax_const \"_relation_annotation\"})  (R,V,I) = (read_rel t :: R,V,I)\n        | interp_while_annot (_,ty) _ = error (\"Unknown annotation type for while loop: \" ^ ty)\n      \n      fun interp_while_annots annots = let\n        val annots = HOLogic.strip_tuple annots\n          |> map (apsnd (dest_Const #> fst) o Term_Annot.dest_annotated_term)\n          \n        val (Rs,Vs,Is) = fold interp_while_annot annots ([],[],[])\n         \n        val _ = length Rs > 1 andalso error \"Multiple relation annotations to loop\"\n        val _ = length Vs > 1 andalso error \"Multiple variant annotations to loop\"\n        val _ = length Is > 1 andalso error \"Multiple invariants not yet supported. Combine them into one\"\n         \n        local val m = map mk_ANNOTATION in\n          val (Rs, Vs, Is) = (m Rs, m Vs, m Is)\n        end\n        \n        \n      in \n        case (Rs,Vs,Is) of\n          ([],[],[]) => mpt @{const While}\n        | ([],[],[I]) => mpt @{const WHILE_annotI} $ I\n        | ([],[V],[I]) => mpt @{const WHILE_annotVI} $ V $ I\n        | ([R],[V],[I]) => mpt @{const WHILE_annotRVI ('a)} $ R $ V $ I\n        | _ => error \"Illegal combination of annotations to while loop. The legal ones are: None, I, VI, RVI\"\n      \n      end\n      \n      fun interp (Const (@{const_abbrev While_Annot},_)$annots) = interp_while_annots annots\n        | interp (a$b) = interp a $ interp b\n        | interp (Abs (x,T,t)) = Abs (x,T,interp t)\n        | interp t = t\n    \n        \n      val prog_t = interp prog_t\n\n      (* All terms have been abstracted over vinfo, and over the variables of v0info. \n        Now, the whole term is valid wrt vinfo0/ctxt0, which contains declarations \n        of variables0 and state0\n        *** TODO: Ideally, one would like to check teh term in a context that does not include \n              variables, but only state decl!\n      *)      \n      val prog_t = Syntax.check_term ctxt prog_t\n      \n            \n      (* We now also abstract over state0, to make the program a function from state0 to an (annotated) command *)\n      val res = (#com_post annot_readers) prog_t\n\n      (*\n      (* Alternatively, we strip the annotations from the program. This should also remove state0! *)\n      val prog_t = strip_annotations_term ctxt prog_t\n      *)\n      \n    in\n      res\n    end\n\n\n    (*\n      Make a reader according to a list of program variable abstractions.\n      Each list item has the form (vars,sfx,full), where vars is a list of IMP variables,\n      sfx is a suffix to be appended to the Isabelle variables, and full indicates whether the\n      abstraction over the state should be done immediately, or delayed.\n      \n      The result is a reader, and a second term transformation to do the delayed abstractions.\n    *)\n    fun gen_mk_reader rds ctxt = let\n      fun mk [] ctxt = ((ctxt, I), I)\n        | mk ((vars,sfx,full)::rds) ctxt = let\n            val vars = IMP_Parser.merge_variables vars\n            val (vinfo,ctxt) = Program_Variables.declare_variables vars sfx ctxt\n            val ((ctxt,pps1),pps2) = mk rds ctxt\n                        \n            val absv = Program_Variables.abstract_vars vinfo\n            val abss = Program_Variables.abstract_state vinfo\n            \n            val (pps1,pps2) = if full then (absv #> pps1 #> abss,pps2) else (absv #> pps1, pps2 #> abss)\n          in\n            ((ctxt,pps1),pps2)\n          end\n          \n    in\n      mk rds ctxt\n    end\n\n    type rd_config = {\n      add_vars  : IMP_Syntax.impvar list,           (* Additional variable declarations *)\n      in_vars   : string list option,               (* Input variables: Default all vars *)\n      out_vars  : string list option,               (* Output variables: Default all vars *)\n      prog_vars : IMP_Syntax.impvar list            (* Variables in program *)\n    }\n    \n        \n    local  \n      fun vars_dflt (cfg:rd_config) NONE = (#prog_vars cfg) @ (#add_vars cfg)\n        | vars_dflt (cfg:rd_config) (SOME vs) = let\n            val (gvs,lvs) = List.partition (IMP_Syntax.is_global) vs\n            val _ = if gvs <> [] then \n              Pretty.block [Pretty.str \"Ignoring global parameter/return variables: \",\n                            Pretty.list \"\" \"\" (map (Pretty.str) gvs)]\n              |> Pretty.string_of |> warning             \n            else () \n        \n          in\n            (filter (fst #> member op= lvs) (#prog_vars cfg @ #add_vars cfg ))\n          @ (filter (fst #> IMP_Syntax.is_global) (#add_vars cfg))  \n          end\n       \n      fun cfg_in_vars cfg = vars_dflt cfg (#in_vars cfg)\n      fun cfg_out_vars cfg = vars_dflt cfg (#out_vars cfg)\n        \n    in        \n      (* Standard annotation readers *)\n      \n      \n      fun mk_annot_readers (cfg:rd_config) ctxt = let\n        val in_vars = cfg_in_vars cfg\n        val prog_vars = (#prog_vars cfg) @ (#add_vars cfg)\n        \n        val (rel_rd,_) = gen_mk_reader [] ctxt\n        val (annot_rd,post) = gen_mk_reader [(in_vars,\"\\<^sub>0\",false),(prog_vars,\"\",true)] ctxt\n      in \n        { \n          rel_rd = rel_rd,\n          variant_rd = annot_rd,\n          invar_rd = annot_rd,\n          com_post = post\n        }\n      end\n        \n      fun mk_pre_reader cfg ctxt = gen_mk_reader [(cfg_in_vars cfg,\"\",true)] ctxt |> #1\n        \n      fun mk_post_reader cfg ctxt = let\n        val in_vars = cfg_in_vars cfg\n        val out_vars = cfg_out_vars cfg\n      in\n        gen_mk_reader [(in_vars,\"\\<^sub>0\",true),(out_vars,\"\",true)] ctxt |> #1\n      end  \n  \n      fun mk_variant_reader cfg ctxt = let\n        val in_vars = cfg_in_vars cfg\n      in\n        gen_mk_reader [(in_vars,\"\",true)] ctxt |> #1\n      end\n\n      fun read_program cfg ctxt prog_t = \n        gen_interpret_annotations (mk_annot_readers cfg ctxt) ctxt prog_t\n  \n      \n    end            \n    \n  end\n\\<close>"], ["", "subsection \\<open>Hoare Triple Syntax\\<close>"], ["", "(* In-Term notation for Hoare Triples*)"], ["", "syntax \"_Htriple\" :: \"cartouche_position \\<Rightarrow> cartouche_position \\<Rightarrow> cartouche_position \\<Rightarrow> logic\" (\"\\<^htriple>_ _ _\")"], ["", "syntax \"_Htriple_Partial\" :: \"cartouche_position \\<Rightarrow> cartouche_position \\<Rightarrow> cartouche_position \\<Rightarrow> logic\" (\"\\<^htriple_partial>_ _ _\")"], ["", "ML \\<open> structure VCG_Htriple_Syntax \n  = struct\n    \n    fun mk_htriple' total env (pre,prog_t,post) = let    \n      (* Assemble Hoare-triple *)\n      val HT_const = if total then @{const HT'} else @{const HT'_partial}\n      val res = HT_const$ env $pre$prog_t$post\n    in\n      res\n    end\n    \n    fun decon_cartouche_ast ((c as Const (@{syntax_const \"_constrain\"}, _)) $ Free (s, _) $ p) = (\n      case Term_Position.decode_position p of \n        SOME (pos, _) => ((s,pos) (*, fn t => c$t$p*))\n      | NONE => raise TERM (\"cartouche with invalid pos\",[c,p])  \n    )\n    | decon_cartouche_ast t = raise TERM (\"decon_cartouche_ast\",[t])  \n        \n    \n    fun htriple_tr total ctxt [tpre, prog_t, tpost] = let\n      open IMP_Annotations\n    \n      val (vars,prog_t) = decon_cartouche_ast prog_t |> IMP_Parser.parse_command_at ctxt\n      \n      val cfg = { add_vars = [], in_vars=NONE, out_vars=NONE, prog_vars=vars }\n      \n      val prog_t = read_program cfg ctxt prog_t\n        \n      val tpre = decon_cartouche_ast tpre \n        |> read_ta_from_cartouche (mk_pre_reader cfg ctxt)\n        \n      val tpost = decon_cartouche_ast tpost\n        |> read_ta_from_cartouche (mk_post_reader cfg ctxt)\n\n      val res = mk_htriple' total @{term \"Map.empty :: program\"} (tpre,prog_t,tpost)  \n              \n    in \n      IMP_Parser.mark_term res |> @{print}\n    end\n    | htriple_tr _ _ args = raise TERM (\"htriple_tr\", args)\n      \n    \n  end\n\\<close>"], ["", "parse_translation \\<open>[\n  (@{syntax_const \"_Htriple\"}, VCG_Htriple_Syntax.htriple_tr true),\n  (@{syntax_const \"_Htriple_Partial\"}, VCG_Htriple_Syntax.htriple_tr false)\n  ]\n\\<close>"], ["", "term \\<open>\\<^htriple_partial> \\<open>undefined x :: bool\\<close> \\<open>while (n\\<noteq>0) @invariant \\<open>x=1+undefined+n+foo\\<close> n = n - 1; x=x+1\\<close> \\<open>True\\<close>\\<close>"], ["", "term \\<open>\\<^htriple_partial> \\<open>n\\<ge>0+x+notex\\<close> \\<open>while (n\\<noteq>0) n = n - 1; x=x+1\\<close> \\<open>n=0 \\<and> x=1+x\\<^sub>0\\<close>\\<close>"], ["", "term \\<open>\\<^htriple> \\<open>n\\<ge>0+x+notex\\<close> \\<open>while (n\\<noteq>0) n = n - 1; x=x+1\\<close> \\<open>n=0 \\<and> x=1+x\\<^sub>0\\<close>\\<close>"], ["", "subsection \\<open>Postprocessing of Proved Specifications\\<close>"], ["", "subsubsection \\<open>Modified Sets\\<close>"], ["", "lemma HT_to_mod: \"HT \\<pi> P c Q = HT_mods \\<pi> (ANALYZE (lhsv \\<pi> c)) P c Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT \\<pi> P c Q = HT_mods \\<pi> (ANALYZE (lhsv \\<pi> c)) P c Q", "by (auto simp: HT_mods_def BB_PROTECT_def HT_def intro: wp_strengthen_modset wp_conseq)"], ["", "lemma HT_partial_to_mod: \"HT_partial \\<pi> P c Q = HT_partial_mods \\<pi> (ANALYZE (lhsv \\<pi> c)) P c Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_partial \\<pi> P c Q =\n    HT_partial_mods \\<pi> (ANALYZE (lhsv \\<pi> c)) P c Q", "by (auto simp: HT_partial_mods_def BB_PROTECT_def HT_partial_def intro: wlp_strengthen_modset wlp_conseq)"], ["", "lemma mk_lhsv_thm:  \n  assumes \"c \\<equiv> cmd\"\n  shows \"lhsv \\<pi> c = ANALYZE (lhsv \\<pi> cmd)\" \"lhsv' c = ANALYZE (lhsv' cmd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhsv \\<pi> c = ANALYZE (lhsv \\<pi> cmd) &&&\n    lhsv' c = ANALYZE (lhsv' cmd)", "using assms"], ["proof (prove)\nusing this:\n  c \\<equiv> cmd\n\ngoal (1 subgoal):\n 1. lhsv \\<pi> c = ANALYZE (lhsv \\<pi> cmd) &&&\n    lhsv' c = ANALYZE (lhsv' cmd)", "by simp_all"], ["", "ML \\<open> structure IMP2_Modified_Analysis \n    = struct\n      fun dest_HT_mods (Const (@{const_name HT_mods},_)$pi$mods$P$c$Q) = (true,pi,mods,P,c,Q)\n        | dest_HT_mods (Const (@{const_name HT_partial_mods},_)$pi$mods$P$c$Q) = (false,pi,mods,P,c,Q)\n        | dest_HT_mods t = raise TERM(\"dest_HT_mods\",[t])\n          \n\n      (* Valid modset must be set literal of string literals *)\n      val is_valid_modset = can (HOLogic.dest_set #> map HOLogic.dest_string)\n        \n      (* Weaker criterion for valid modset  \n      val is_valid_modset = not o exists_subterm (fn @{const lhsv} => true | _ => false)\n      *)\n      \n                \n         \n      (* HT \\<rightarrow> HT_mods *) \n      fun mk_HT_mods ctxt thm = let\n        (* Local_Defs.unfold will destroy names of bound variables here!?, so using simplify! *)\n        fun simplified ctxt thms = simplify (Simplifier.clear_simpset ctxt addsimps thms)\n      \n        val ctxt = Named_Simpsets.put @{named_simpset vcg_bb} ctxt\n      in\n           thm\n        |> simplified ctxt @{thms HT_to_mod HT_partial_to_mod}\n        |> Simplifier.simplify ctxt\n      end    \n\n      \n      (* c\\<equiv>com \\<rightarrow> [ lhsv c = \\<dots>, lshv' c = \\<dots> ] *)\n      fun mk_lhsv_thms ctxt def_thm = let\n        val ctxt = Named_Simpsets.put @{named_simpset vcg_bb} ctxt\n      in\n        map (fn thm => (def_thm RS thm) |> Simplifier.simplify ctxt) @{thms mk_lhsv_thm}\n      end\n      \n    end\n  \\<close>"], ["", "subsubsection \\<open>Parameter Passing\\<close>"], ["", "(* Forward assignment rule + renaming of assigned variable *)"], ["", "lemma adjust_assign_after:\n  assumes \"HT \\<pi> P c Q\"\n  shows \"HT \\<pi> P (c;;x[]::=y) (\\<lambda>s\\<^sub>0 s. \\<exists>vx. Q s\\<^sub>0 (s(x:=vx,y:=s x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT \\<pi> P (c;; x[] ::= y)\n     (\\<lambda>s\\<^sub>0 s. \\<exists>vx. Q s\\<^sub>0 (s(x := vx, y := s x)))", "using assms"], ["proof (prove)\nusing this:\n  HT \\<pi> P c Q\n\ngoal (1 subgoal):\n 1. HT \\<pi> P (c;; x[] ::= y)\n     (\\<lambda>s\\<^sub>0 s. \\<exists>vx. Q s\\<^sub>0 (s(x := vx, y := s x)))", "unfolding HT_def"], ["proof (prove)\nusing this:\n  \\<forall>s\\<^sub>0.\n     P s\\<^sub>0 \\<longrightarrow> wp \\<pi> c (Q s\\<^sub>0) s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<^sub>0.\n       P s\\<^sub>0 \\<longrightarrow>\n       wp \\<pi> (c;; x[] ::= y)\n        (\\<lambda>s. \\<exists>vx. Q s\\<^sub>0 (s(x := vx, y := s x)))\n        s\\<^sub>0", "apply (auto simp: wp_eq[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       \\<lbrakk>\\<forall>s\\<^sub>0.\n                   P s\\<^sub>0 \\<longrightarrow>\n                   wp \\<pi> c (Q s\\<^sub>0) s\\<^sub>0;\n        P s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> wp \\<pi> c\n                          (\\<lambda>s.\n                              \\<exists>vx.\n                                 Q s\\<^sub>0 (s(x := vx, y := s y)))\n                          s\\<^sub>0", "by (metis (mono_tags, lifting) fun_upd_triv wp_conseq)"], ["", "(* Standard backwards assignment rule *)"], ["", "lemma adjust_assign_before:\n  assumes HT: \"HT \\<pi> P c Q\"  \n  shows \"HT \\<pi> (\\<lambda>s. P (s(x:=s y)) ) (x[]::=y;; c) (\\<lambda>s\\<^sub>0 s. Q (s\\<^sub>0(x:=s\\<^sub>0 y)) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT \\<pi> (\\<lambda>s. P (s(x := s y))) (x[] ::= y;; c)\n     (\\<lambda>s\\<^sub>0. Q (s\\<^sub>0(x := s\\<^sub>0 y)))", "unfolding HT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<^sub>0.\n       P (s\\<^sub>0(x := s\\<^sub>0 y)) \\<longrightarrow>\n       wp \\<pi> (x[] ::= y;; c) (Q (s\\<^sub>0(x := s\\<^sub>0 y))) s\\<^sub>0", "apply (clarsimp simp: wp_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       P (s\\<^sub>0(x := s\\<^sub>0 y)) \\<Longrightarrow>\n       wp \\<pi> c (Q (s\\<^sub>0(x := s\\<^sub>0 y)))\n        (s\\<^sub>0(x := s\\<^sub>0 y))", "using HT_def assms"], ["proof (prove)\nusing this:\n  HT ?\\<pi> ?P ?c ?Q \\<equiv>\n  \\<forall>s\\<^sub>0.\n     ?P s\\<^sub>0 \\<longrightarrow> wp ?\\<pi> ?c (?Q s\\<^sub>0) s\\<^sub>0\n  HT \\<pi> P c Q\n\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       P (s\\<^sub>0(x := s\\<^sub>0 y)) \\<Longrightarrow>\n       wp \\<pi> c (Q (s\\<^sub>0(x := s\\<^sub>0 y)))\n        (s\\<^sub>0(x := s\\<^sub>0 y))", "by auto"], ["", "(* Forward + backward assignment rules, simultaneously for all local variables! *)"], ["", "lemma adjust_scope:\n  assumes HT: \"HT \\<pi> P c Q\"\n  shows \"HT \\<pi> (\\<lambda>s. P (<<>|s>)) (SCOPE c) (\\<lambda>s\\<^sub>0 s. \\<exists>l. Q (<<>|s\\<^sub>0>) (<l|s>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT \\<pi> (\\<lambda>s. P <<>|s>) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s. \\<exists>l. Q <<>|s\\<^sub>0> <l|s>)", "unfolding HT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<^sub>0.\n       P <<>|s\\<^sub>0> \\<longrightarrow>\n       wp \\<pi> (SCOPE c) (\\<lambda>s. \\<exists>l. Q <<>|s\\<^sub>0> <l|s>)\n        s\\<^sub>0", "apply (clarsimp simp: wp_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       P <<>|s\\<^sub>0> \\<Longrightarrow>\n       wp \\<pi> c\n        (\\<lambda>s'. \\<exists>l. Q <<>|s\\<^sub>0> <l|<s\\<^sub>0|s'>>)\n        <<>|s\\<^sub>0>", "by (smt HT_def assms combine_collapse combine_nest(1) wp_conseq)"], ["", "(* Forward assignment rule + renaming of assigned variable *)"], ["", "lemma adjust_assign_after_partial:\n  assumes \"HT_partial \\<pi> P c Q\"\n  shows \"HT_partial \\<pi> P (c;;x[]::=y) (\\<lambda>s\\<^sub>0 s. \\<exists>vx. Q s\\<^sub>0 (s(x:=vx,y:=s x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_partial \\<pi> P (c;; x[] ::= y)\n     (\\<lambda>s\\<^sub>0 s. \\<exists>vx. Q s\\<^sub>0 (s(x := vx, y := s x)))", "using assms"], ["proof (prove)\nusing this:\n  HT_partial \\<pi> P c Q\n\ngoal (1 subgoal):\n 1. HT_partial \\<pi> P (c;; x[] ::= y)\n     (\\<lambda>s\\<^sub>0 s. \\<exists>vx. Q s\\<^sub>0 (s(x := vx, y := s x)))", "unfolding HT_partial_def"], ["proof (prove)\nusing this:\n  \\<forall>s\\<^sub>0.\n     P s\\<^sub>0 \\<longrightarrow> wlp \\<pi> c (Q s\\<^sub>0) s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<^sub>0.\n       P s\\<^sub>0 \\<longrightarrow>\n       wlp \\<pi> (c;; x[] ::= y)\n        (\\<lambda>s. \\<exists>vx. Q s\\<^sub>0 (s(x := vx, y := s x)))\n        s\\<^sub>0", "apply (auto simp: wlp_eq[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       \\<lbrakk>\\<forall>s\\<^sub>0.\n                   P s\\<^sub>0 \\<longrightarrow>\n                   wlp \\<pi> c (Q s\\<^sub>0) s\\<^sub>0;\n        P s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> wlp \\<pi> c\n                          (\\<lambda>s.\n                              \\<exists>vx.\n                                 Q s\\<^sub>0 (s(x := vx, y := s y)))\n                          s\\<^sub>0", "by (metis (mono_tags, lifting) fun_upd_triv wlp_conseq)"], ["", "(* Standard backwards assignment rule *)"], ["", "lemma adjust_assign_before_partial:\n  assumes HT: \"HT_partial \\<pi> P c Q\"  \n  shows \"HT_partial \\<pi> (\\<lambda>s. P (s(x:=s y)) ) (x[]::=y;; c) (\\<lambda>s\\<^sub>0 s. Q (s\\<^sub>0(x:=s\\<^sub>0 y)) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_partial \\<pi> (\\<lambda>s. P (s(x := s y))) (x[] ::= y;; c)\n     (\\<lambda>s\\<^sub>0. Q (s\\<^sub>0(x := s\\<^sub>0 y)))", "unfolding HT_partial_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<^sub>0.\n       P (s\\<^sub>0(x := s\\<^sub>0 y)) \\<longrightarrow>\n       wlp \\<pi> (x[] ::= y;; c) (Q (s\\<^sub>0(x := s\\<^sub>0 y))) s\\<^sub>0", "apply (clarsimp simp: wlp_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       P (s\\<^sub>0(x := s\\<^sub>0 y)) \\<Longrightarrow>\n       wlp \\<pi> c (Q (s\\<^sub>0(x := s\\<^sub>0 y)))\n        (s\\<^sub>0(x := s\\<^sub>0 y))", "using HT_partial_def assms"], ["proof (prove)\nusing this:\n  HT_partial ?\\<pi> ?P ?c ?Q \\<equiv>\n  \\<forall>s\\<^sub>0.\n     ?P s\\<^sub>0 \\<longrightarrow> wlp ?\\<pi> ?c (?Q s\\<^sub>0) s\\<^sub>0\n  HT_partial \\<pi> P c Q\n\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       P (s\\<^sub>0(x := s\\<^sub>0 y)) \\<Longrightarrow>\n       wlp \\<pi> c (Q (s\\<^sub>0(x := s\\<^sub>0 y)))\n        (s\\<^sub>0(x := s\\<^sub>0 y))", "by auto"], ["", "(* Forward + backward assignment rules, simultaneously for all local variables! *)"], ["", "lemma adjust_scope_partial:\n  assumes HT: \"HT_partial \\<pi> P c Q\"\n  shows \"HT_partial \\<pi> (\\<lambda>s. P (<<>|s>)) (SCOPE c) (\\<lambda>s\\<^sub>0 s. \\<exists>l. Q (<<>|s\\<^sub>0>) (<l|s>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_partial \\<pi> (\\<lambda>s. P <<>|s>) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s. \\<exists>l. Q <<>|s\\<^sub>0> <l|s>)", "unfolding HT_partial_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<^sub>0.\n       P <<>|s\\<^sub>0> \\<longrightarrow>\n       wlp \\<pi> (SCOPE c) (\\<lambda>s. \\<exists>l. Q <<>|s\\<^sub>0> <l|s>)\n        s\\<^sub>0", "apply (clarsimp simp: wlp_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       P <<>|s\\<^sub>0> \\<Longrightarrow>\n       wlp \\<pi> c\n        (\\<lambda>s'. \\<exists>l. Q <<>|s\\<^sub>0> <l|<s\\<^sub>0|s'>>)\n        <<>|s\\<^sub>0>", "by (smt HT_partial_def assms combine_collapse combine_nest(1) wlp_conseq)"], ["", "definition \"ADJUST_PRE_SCOPE P \\<equiv> (\\<lambda>s. P <<>|s>)\""], ["", "definition \"ADJUST_PRE_PARAM l G P \\<equiv> (\\<lambda>s. P (s(l:=s G)))\""], ["", "definition \"ADJUST_POST_SCOPE Q \\<equiv> (\\<lambda>s\\<^sub>0 s. \\<exists>l. Q (<<>|s\\<^sub>0>) (<l|s>))\""], ["", "definition \"ADJUST_POST_PARAM l G Q \\<equiv> (\\<lambda>s\\<^sub>0 s. Q (s\\<^sub>0(l:=s\\<^sub>0 G)) s)\""], ["", "definition \"ADJUST_POST_RETV G l Q \\<equiv> (\\<lambda>s\\<^sub>0 s. \\<exists>vx. Q s\\<^sub>0 (s(G:=vx,l:=s G)))\""], ["", "lemma HT_strengthen_modset:  \n  assumes \"HT \\<pi> P c Q\"\n  shows \"HT \\<pi> P c (\\<lambda>s\\<^sub>0 s. Q s\\<^sub>0 s \\<and> modifies (lhsv \\<pi> c) s s\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT \\<pi> P c\n     (\\<lambda>s\\<^sub>0 s.\n         Q s\\<^sub>0 s \\<and> modifies (lhsv \\<pi> c) s s\\<^sub>0)", "using assms"], ["proof (prove)\nusing this:\n  HT \\<pi> P c Q\n\ngoal (1 subgoal):\n 1. HT \\<pi> P c\n     (\\<lambda>s\\<^sub>0 s.\n         Q s\\<^sub>0 s \\<and> modifies (lhsv \\<pi> c) s s\\<^sub>0)", "unfolding HT_def"], ["proof (prove)\nusing this:\n  \\<forall>s\\<^sub>0.\n     P s\\<^sub>0 \\<longrightarrow> wp \\<pi> c (Q s\\<^sub>0) s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<^sub>0.\n       P s\\<^sub>0 \\<longrightarrow>\n       wp \\<pi> c\n        (\\<lambda>s.\n            Q s\\<^sub>0 s \\<and> modifies (lhsv \\<pi> c) s s\\<^sub>0)\n        s\\<^sub>0", "by (auto intro: wp_strengthen_modset)"], ["", "lemma HT_partial_strengthen_modset:  \n  assumes \"HT_partial \\<pi> P c Q\"\n  shows \"HT_partial \\<pi> P c (\\<lambda>s\\<^sub>0 s. Q s\\<^sub>0 s \\<and> modifies (lhsv \\<pi> c) s s\\<^sub>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_partial \\<pi> P c\n     (\\<lambda>s\\<^sub>0 s.\n         Q s\\<^sub>0 s \\<and> modifies (lhsv \\<pi> c) s s\\<^sub>0)", "using assms"], ["proof (prove)\nusing this:\n  HT_partial \\<pi> P c Q\n\ngoal (1 subgoal):\n 1. HT_partial \\<pi> P c\n     (\\<lambda>s\\<^sub>0 s.\n         Q s\\<^sub>0 s \\<and> modifies (lhsv \\<pi> c) s s\\<^sub>0)", "unfolding HT_partial_def"], ["proof (prove)\nusing this:\n  \\<forall>s\\<^sub>0.\n     P s\\<^sub>0 \\<longrightarrow> wlp \\<pi> c (Q s\\<^sub>0) s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<^sub>0.\n       P s\\<^sub>0 \\<longrightarrow>\n       wlp \\<pi> c\n        (\\<lambda>s.\n            Q s\\<^sub>0 s \\<and> modifies (lhsv \\<pi> c) s s\\<^sub>0)\n        s\\<^sub>0", "by (auto intro: wlp_strengthen_modset)"], ["", "context\n  notes [abs_def, simp] = VAR_def \n    ADJUST_PRE_SCOPE_def ADJUST_PRE_PARAM_def ADJUST_POST_SCOPE_def ADJUST_POST_PARAM_def ADJUST_POST_RETV_def\n  notes [simp] = combine_query\nbegin"], ["", "text \\<open>A lot of straightforward lemmas, to transfer specification of function body to function specification\\<close>"], ["", "lemma ADJUST_PRE_SCOPE_unfolds:\n    \"\\<And>P. ADJUST_PRE_SCOPE (\\<lambda>_. P) = (\\<lambda>_. P)\"\n    \"\\<And>P. ADJUST_PRE_SCOPE (\\<lambda>s. VAR v (\\<lambda>x. P x s)) = VAR v (\\<lambda>x. ADJUST_PRE_SCOPE (\\<lambda>s. P x s))\"\n    \n    \"\\<And>P. is_global x \\<Longrightarrow> ADJUST_PRE_SCOPE (\\<lambda>s. VAR (s x i) (\\<lambda>x. P x s)) = (\\<lambda>s. VAR (s x i) (\\<lambda>x. ADJUST_PRE_SCOPE (\\<lambda>s. P x s) s))\"\n    \"\\<And>P. is_global x \\<Longrightarrow> ADJUST_PRE_SCOPE (\\<lambda>s. VAR (s x) (\\<lambda>x. P x s)) = (\\<lambda>s. VAR (s x) (\\<lambda>x. ADJUST_PRE_SCOPE (\\<lambda>s. P x s) s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>P. ADJUST_PRE_SCOPE (\\<lambda>_. P) = (\\<lambda>_. P)) &&&\n     (\\<And>P.\n         ADJUST_PRE_SCOPE (\\<lambda>s. VAR v (\\<lambda>x. P x s)) =\n         VAR v (\\<lambda>x. ADJUST_PRE_SCOPE (P x)))) &&&\n    (\\<And>P.\n        is_global x \\<Longrightarrow>\n        ADJUST_PRE_SCOPE (\\<lambda>s. VAR (s x i) (\\<lambda>x. P x s)) =\n        (\\<lambda>s.\n            VAR (s x i) (\\<lambda>x. ADJUST_PRE_SCOPE (P x) s))) &&&\n    (\\<And>P.\n        is_global x \\<Longrightarrow>\n        ADJUST_PRE_SCOPE (\\<lambda>s. VAR (s x) (\\<lambda>x. P x s)) =\n        (\\<lambda>s. VAR (s x) (\\<lambda>x. ADJUST_PRE_SCOPE (P x) s)))", "by auto"], ["", "lemma ADJUST_PRE_PARAM_unfolds:  \n    \"\\<And>P. ADJUST_PRE_PARAM l G (\\<lambda>_. P) = (\\<lambda>_. P)\"\n    \"\\<And>P. ADJUST_PRE_PARAM l G (\\<lambda>s. VAR v (\\<lambda>x. P x s)) = VAR v (\\<lambda>x. ADJUST_PRE_PARAM l G (\\<lambda>s. P x s))\"\n    \n    \n    \"\\<And>P. ADJUST_PRE_PARAM l G (\\<lambda>s. VAR (s l i) (\\<lambda>x. P x s)) = (\\<lambda>s. VAR (s G i) (\\<lambda>x. ADJUST_PRE_PARAM l G (\\<lambda>s. P x s) s))\"\n    \"\\<And>P. ADJUST_PRE_PARAM l G (\\<lambda>s. VAR (s l) (\\<lambda>x. P x s)) = (\\<lambda>s. VAR (s G) (\\<lambda>x. ADJUST_PRE_PARAM l G (\\<lambda>s. P x s) s))\"\n    \n    \"\\<And>P. x\\<noteq>l \\<Longrightarrow> ADJUST_PRE_PARAM l G (\\<lambda>s. VAR (s x i) (\\<lambda>x. P x s)) = (\\<lambda>s. VAR (s x i) (\\<lambda>x. ADJUST_PRE_PARAM l G (\\<lambda>s. P x s) s))\"\n    \"\\<And>P. x\\<noteq>l \\<Longrightarrow> ADJUST_PRE_PARAM l G (\\<lambda>s. VAR (s x) (\\<lambda>x. P x s)) = (\\<lambda>s. VAR (s x) (\\<lambda>x. ADJUST_PRE_PARAM l G (\\<lambda>s. P x s) s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>P. ADJUST_PRE_PARAM l G (\\<lambda>_. P) = (\\<lambda>_. P)) &&&\n     (\\<And>P.\n         ADJUST_PRE_PARAM l G (\\<lambda>s. VAR v (\\<lambda>x. P x s)) =\n         VAR v (\\<lambda>x. ADJUST_PRE_PARAM l G (P x))) &&&\n     (\\<And>P.\n         ADJUST_PRE_PARAM l G\n          (\\<lambda>s. VAR (s l i) (\\<lambda>x. P x s)) =\n         (\\<lambda>s.\n             VAR (s G i) (\\<lambda>x. ADJUST_PRE_PARAM l G (P x) s)))) &&&\n    (\\<And>P.\n        ADJUST_PRE_PARAM l G (\\<lambda>s. VAR (s l) (\\<lambda>x. P x s)) =\n        (\\<lambda>s.\n            VAR (s G) (\\<lambda>x. ADJUST_PRE_PARAM l G (P x) s))) &&&\n    (\\<And>P.\n        x \\<noteq> l \\<Longrightarrow>\n        ADJUST_PRE_PARAM l G (\\<lambda>s. VAR (s x i) (\\<lambda>x. P x s)) =\n        (\\<lambda>s.\n            VAR (s x i) (\\<lambda>x. ADJUST_PRE_PARAM l G (P x) s))) &&&\n    (\\<And>P.\n        x \\<noteq> l \\<Longrightarrow>\n        ADJUST_PRE_PARAM l G (\\<lambda>s. VAR (s x) (\\<lambda>x. P x s)) =\n        (\\<lambda>s. VAR (s x) (\\<lambda>x. ADJUST_PRE_PARAM l G (P x) s)))", "by auto"], ["", "lemma ADJUST_POST_SCOPE_unfolds:\n    \"\\<And>P. ADJUST_POST_SCOPE (\\<lambda>_ _. P) = (\\<lambda>_ _. P)\"\n    \n    \"\\<And>P. is_global x \\<Longrightarrow> ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x i) (\\<lambda>x. ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. is_global x \\<Longrightarrow> ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x) (\\<lambda>x. ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \n    \"\\<And>P. is_global x \\<Longrightarrow> ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. is_global x \\<Longrightarrow> ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. ADJUST_POST_SCOPE (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>P. ADJUST_POST_SCOPE (\\<lambda>_ _. P) = (\\<lambda>_ _. P)) &&&\n     (\\<And>P.\n         is_global x \\<Longrightarrow>\n         ADJUST_POST_SCOPE\n          (\\<lambda>s\\<^sub>0 s.\n              VAR (s\\<^sub>0 x i) (\\<lambda>x. P x s\\<^sub>0 s)) =\n         (\\<lambda>s\\<^sub>0 s.\n             VAR (s\\<^sub>0 x i)\n              (\\<lambda>x. ADJUST_POST_SCOPE (P x) s\\<^sub>0 s)))) &&&\n    (\\<And>P.\n        is_global x \\<Longrightarrow>\n        ADJUST_POST_SCOPE\n         (\\<lambda>s\\<^sub>0 s.\n             VAR (s\\<^sub>0 x) (\\<lambda>x. P x s\\<^sub>0 s)) =\n        (\\<lambda>s\\<^sub>0 s.\n            VAR (s\\<^sub>0 x)\n             (\\<lambda>x. ADJUST_POST_SCOPE (P x) s\\<^sub>0 s))) &&&\n    (\\<And>P.\n        is_global x \\<Longrightarrow>\n        ADJUST_POST_SCOPE\n         (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. P x s\\<^sub>0 s)) =\n        (\\<lambda>s\\<^sub>0 s.\n            VAR (s x i)\n             (\\<lambda>x. ADJUST_POST_SCOPE (P x) s\\<^sub>0 s))) &&&\n    (\\<And>P.\n        is_global x \\<Longrightarrow>\n        ADJUST_POST_SCOPE\n         (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. P x s\\<^sub>0 s)) =\n        (\\<lambda>s\\<^sub>0 s.\n            VAR (s x) (\\<lambda>x. ADJUST_POST_SCOPE (P x) s\\<^sub>0 s)))", "by auto"], ["", "lemma ADJUST_POST_PARAM_unfolds: \n    \"\\<And>P. ADJUST_POST_PARAM l G (\\<lambda>_ _. P) = (\\<lambda>_ _. P)\" \n    \n    \"\\<And>P. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 l i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 G i) (\\<lambda>x. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 l) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 G) (\\<lambda>x. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n  \n    \"\\<And>P. x\\<noteq>l \\<Longrightarrow> ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x i) (\\<lambda>x. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. x\\<noteq>l \\<Longrightarrow> ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x) (\\<lambda>x. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \n    \"\\<And>P. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. ADJUST_POST_PARAM l G (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>P.\n         ADJUST_POST_PARAM l G (\\<lambda>_ _. P) = (\\<lambda>_ _. P)) &&&\n     (\\<And>P.\n         ADJUST_POST_PARAM l G\n          (\\<lambda>s\\<^sub>0 s.\n              VAR (s\\<^sub>0 l i) (\\<lambda>x. P x s\\<^sub>0 s)) =\n         (\\<lambda>s\\<^sub>0 s.\n             VAR (s\\<^sub>0 G i)\n              (\\<lambda>x. ADJUST_POST_PARAM l G (P x) s\\<^sub>0 s))) &&&\n     (\\<And>P.\n         ADJUST_POST_PARAM l G\n          (\\<lambda>s\\<^sub>0 s.\n              VAR (s\\<^sub>0 l) (\\<lambda>x. P x s\\<^sub>0 s)) =\n         (\\<lambda>s\\<^sub>0 s.\n             VAR (s\\<^sub>0 G)\n              (\\<lambda>x. ADJUST_POST_PARAM l G (P x) s\\<^sub>0 s)))) &&&\n    ((\\<And>P.\n         x \\<noteq> l \\<Longrightarrow>\n         ADJUST_POST_PARAM l G\n          (\\<lambda>s\\<^sub>0 s.\n              VAR (s\\<^sub>0 x i) (\\<lambda>x. P x s\\<^sub>0 s)) =\n         (\\<lambda>s\\<^sub>0 s.\n             VAR (s\\<^sub>0 x i)\n              (\\<lambda>x. ADJUST_POST_PARAM l G (P x) s\\<^sub>0 s))) &&&\n     (\\<And>P.\n         x \\<noteq> l \\<Longrightarrow>\n         ADJUST_POST_PARAM l G\n          (\\<lambda>s\\<^sub>0 s.\n              VAR (s\\<^sub>0 x) (\\<lambda>x. P x s\\<^sub>0 s)) =\n         (\\<lambda>s\\<^sub>0 s.\n             VAR (s\\<^sub>0 x)\n              (\\<lambda>x. ADJUST_POST_PARAM l G (P x) s\\<^sub>0 s)))) &&&\n    (\\<And>P.\n        ADJUST_POST_PARAM l G\n         (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. P x s\\<^sub>0 s)) =\n        (\\<lambda>s\\<^sub>0 s.\n            VAR (s x i)\n             (\\<lambda>x. ADJUST_POST_PARAM l G (P x) s\\<^sub>0 s))) &&&\n    (\\<And>P.\n        ADJUST_POST_PARAM l G\n         (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. P x s\\<^sub>0 s)) =\n        (\\<lambda>s\\<^sub>0 s.\n            VAR (s x)\n             (\\<lambda>x. ADJUST_POST_PARAM l G (P x) s\\<^sub>0 s)))", "by auto"], ["", "lemma ADJUST_POST_RETV_unfolds:\n    \"\\<And>P. ADJUST_POST_RETV G l (\\<lambda>_ _. P) = (\\<lambda>_ _. P)\"\n    \n    \"\\<And>P. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x i) (\\<lambda>x. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s\\<^sub>0 x) (\\<lambda>x. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n  \n    \"\\<And>P. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. VAR (s l i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s G i) (\\<lambda>x. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. VAR (s l) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s G) (\\<lambda>x. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n      \n    \"\\<And>P. \\<lbrakk>x\\<noteq>G; x\\<noteq>l\\<rbrakk> \\<Longrightarrow> ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s x i) (\\<lambda>x. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\"\n    \"\\<And>P. \\<lbrakk>x\\<noteq>G; x\\<noteq>l\\<rbrakk> \\<Longrightarrow> ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. P x s\\<^sub>0 s)) = (\\<lambda>s\\<^sub>0 s. VAR (s x) (\\<lambda>x. ADJUST_POST_RETV G l (\\<lambda>s\\<^sub>0 s. P x s\\<^sub>0 s) s\\<^sub>0 s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>P.\n         ADJUST_POST_RETV G l (\\<lambda>_ _. P) = (\\<lambda>_ _. P)) &&&\n     (\\<And>P.\n         ADJUST_POST_RETV G l\n          (\\<lambda>s\\<^sub>0 s.\n              VAR (s\\<^sub>0 x i) (\\<lambda>x. P x s\\<^sub>0 s)) =\n         (\\<lambda>s\\<^sub>0 s.\n             VAR (s\\<^sub>0 x i)\n              (\\<lambda>x. ADJUST_POST_RETV G l (P x) s\\<^sub>0 s))) &&&\n     (\\<And>P.\n         ADJUST_POST_RETV G l\n          (\\<lambda>s\\<^sub>0 s.\n              VAR (s\\<^sub>0 x) (\\<lambda>x. P x s\\<^sub>0 s)) =\n         (\\<lambda>s\\<^sub>0 s.\n             VAR (s\\<^sub>0 x)\n              (\\<lambda>x. ADJUST_POST_RETV G l (P x) s\\<^sub>0 s)))) &&&\n    ((\\<And>P.\n         ADJUST_POST_RETV G l\n          (\\<lambda>s\\<^sub>0 s.\n              VAR (s l i) (\\<lambda>x. P x s\\<^sub>0 s)) =\n         (\\<lambda>s\\<^sub>0 s.\n             VAR (s G i)\n              (\\<lambda>x. ADJUST_POST_RETV G l (P x) s\\<^sub>0 s))) &&&\n     (\\<And>P.\n         ADJUST_POST_RETV G l\n          (\\<lambda>s\\<^sub>0 s. VAR (s l) (\\<lambda>x. P x s\\<^sub>0 s)) =\n         (\\<lambda>s\\<^sub>0 s.\n             VAR (s G)\n              (\\<lambda>x. ADJUST_POST_RETV G l (P x) s\\<^sub>0 s)))) &&&\n    (\\<And>P.\n        \\<lbrakk>x \\<noteq> G; x \\<noteq> l\\<rbrakk>\n        \\<Longrightarrow> ADJUST_POST_RETV G l\n                           (\\<lambda>s\\<^sub>0 s.\n                               VAR (s x i) (\\<lambda>x. P x s\\<^sub>0 s)) =\n                          (\\<lambda>s\\<^sub>0 s.\n                              VAR (s x i)\n                               (\\<lambda>x.\n                                   ADJUST_POST_RETV G l (P x) s\\<^sub>0\n                                    s))) &&&\n    (\\<And>P.\n        \\<lbrakk>x \\<noteq> G; x \\<noteq> l\\<rbrakk>\n        \\<Longrightarrow> ADJUST_POST_RETV G l\n                           (\\<lambda>s\\<^sub>0 s.\n                               VAR (s x) (\\<lambda>x. P x s\\<^sub>0 s)) =\n                          (\\<lambda>s\\<^sub>0 s.\n                              VAR (s x)\n                               (\\<lambda>x.\n                                   ADJUST_POST_RETV G l (P x) s\\<^sub>0 s)))", "by auto"], ["", "lemmas ADJUST_unfolds = ADJUST_PRE_SCOPE_unfolds ADJUST_PRE_PARAM_unfolds \n    ADJUST_POST_SCOPE_unfolds ADJUST_POST_PARAM_unfolds ADJUST_POST_RETV_unfolds"], ["", "(* TODO: Clean up these proofs! *)"], ["", "lemma HT_mods_adjust_scope: \n    assumes \"HT_mods \\<pi> vs P c Q\"\n    shows \"HT_mods \\<pi> (Set.filter is_global vs) (ADJUST_PRE_SCOPE P) (SCOPE c) (ADJUST_POST_SCOPE Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_mods \\<pi> (Set.filter is_global vs) (ADJUST_PRE_SCOPE P) (SCOPE c)\n     (ADJUST_POST_SCOPE Q)", "using assms"], ["proof (prove)\nusing this:\n  HT_mods \\<pi> vs P c Q\n\ngoal (1 subgoal):\n 1. HT_mods \\<pi> (Set.filter is_global vs) (ADJUST_PRE_SCOPE P) (SCOPE c)\n     (ADJUST_POST_SCOPE Q)", "unfolding HT_mods_def"], ["proof (prove)\nusing this:\n  HT \\<pi> P c\n   (\\<lambda>s\\<^sub>0 s. modifies vs s s\\<^sub>0 \\<and> Q s\\<^sub>0 s)\n\ngoal (1 subgoal):\n 1. HT \\<pi> (ADJUST_PRE_SCOPE P) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s.\n         modifies (Set.filter is_global vs) s s\\<^sub>0 \\<and>\n         ADJUST_POST_SCOPE Q s\\<^sub>0 s)", "apply (drule_tac adjust_scope)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT \\<pi> (\\<lambda>s. P <<>|s>) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s.\n         \\<exists>l.\n            modifies vs <l|s> <<>|s\\<^sub>0> \\<and>\n            Q <<>|s\\<^sub>0> <l|s>) \\<Longrightarrow>\n    HT \\<pi> (ADJUST_PRE_SCOPE P) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s.\n         modifies (Set.filter is_global vs) s s\\<^sub>0 \\<and>\n         ADJUST_POST_SCOPE Q s\\<^sub>0 s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT \\<pi> (\\<lambda>s. P <<>|s>) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s.\n         \\<exists>l.\n            modifies vs <l|s> <<>|s\\<^sub>0> \\<and>\n            Q <<>|s\\<^sub>0> <l|s>) \\<Longrightarrow>\n    HT \\<pi> (\\<lambda>s. P <<>|s>) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s.\n         modifies (Set.filter is_global vs) s s\\<^sub>0 \\<and>\n         (\\<exists>l. Q <<>|s\\<^sub>0> <l|s>))", "apply (drule_tac HT_strengthen_modset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT \\<pi> (\\<lambda>s. P <<>|s>) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s.\n         (\\<exists>l.\n             modifies vs <l|s> <<>|s\\<^sub>0> \\<and>\n             Q <<>|s\\<^sub>0> <l|s>) \\<and>\n         modifies (lhsv \\<pi> (SCOPE c)) s s\\<^sub>0) \\<Longrightarrow>\n    HT \\<pi> (\\<lambda>s. P <<>|s>) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s.\n         modifies (Set.filter is_global vs) s s\\<^sub>0 \\<and>\n         (\\<exists>l. Q <<>|s\\<^sub>0> <l|s>))", "apply (erule HT_conseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s. P <<>|s> \\<Longrightarrow> P <<>|s>\n 2. \\<And>s\\<^sub>0 s.\n       \\<lbrakk>P <<>|s\\<^sub>0>; P <<>|s\\<^sub>0>;\n        (\\<exists>l.\n            modifies vs <l|s> <<>|s\\<^sub>0> \\<and>\n            Q <<>|s\\<^sub>0> <l|s>) \\<and>\n        modifies (lhsv \\<pi> (SCOPE c)) s s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> modifies (Set.filter is_global vs) s\n                          s\\<^sub>0 \\<and>\n                         (\\<exists>l. Q <<>|s\\<^sub>0> <l|s>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0 s.\n       \\<lbrakk>P <<>|s\\<^sub>0>; P <<>|s\\<^sub>0>;\n        (\\<exists>l.\n            modifies vs <l|s> <<>|s\\<^sub>0> \\<and>\n            Q <<>|s\\<^sub>0> <l|s>) \\<and>\n        modifies (lhsv \\<pi> (SCOPE c)) s s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> modifies (Set.filter is_global vs) s\n                          s\\<^sub>0 \\<and>\n                         (\\<exists>l. Q <<>|s\\<^sub>0> <l|s>)", "apply (clarsimp simp: modifies_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0 s l.\n       \\<lbrakk>P <<>|s\\<^sub>0>;\n        modifies (Set.filter is_global (lhsv \\<pi> c)) s s\\<^sub>0;\n        modifies (Collect is_global \\<union> vs) l <>;\n        modifies ({a. is_local a} \\<union> vs) s s\\<^sub>0;\n        Q <<>|s\\<^sub>0> <l|s>\\<rbrakk>\n       \\<Longrightarrow> modifies (Set.filter is_global vs) s\n                          s\\<^sub>0 \\<and>\n                         (\\<exists>l. Q <<>|s\\<^sub>0> <l|s>)", "apply (drule (1) modifies_join)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0 s l.\n       \\<lbrakk>P <<>|s\\<^sub>0>;\n        modifies (Collect is_global \\<union> vs) l <>;\n        modifies ({a. is_local a} \\<union> vs) s s\\<^sub>0;\n        Q <<>|s\\<^sub>0> <l|s>;\n        modifies\n         (Set.filter is_global (lhsv \\<pi> c) \\<inter>\n          ({a. is_local a} \\<union> vs))\n         s s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> modifies (Set.filter is_global vs) s\n                          s\\<^sub>0 \\<and>\n                         (\\<exists>l. Q <<>|s\\<^sub>0> <l|s>)", "apply (auto elim: modifies_mono[rotated])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma HT_mods_adjust_param: \n    assumes \"HT_mods \\<pi> vs P c Q\"\n    shows \"HT_mods \\<pi> (insert l vs) (ADJUST_PRE_PARAM l G P) (l[]::=G;; c) (ADJUST_POST_PARAM l G Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_mods \\<pi> (insert l vs) (ADJUST_PRE_PARAM l G P) (l[] ::= G;; c)\n     (ADJUST_POST_PARAM l G Q)", "using assms"], ["proof (prove)\nusing this:\n  HT_mods \\<pi> vs P c Q\n\ngoal (1 subgoal):\n 1. HT_mods \\<pi> (insert l vs) (ADJUST_PRE_PARAM l G P) (l[] ::= G;; c)\n     (ADJUST_POST_PARAM l G Q)", "unfolding HT_mods_def"], ["proof (prove)\nusing this:\n  HT \\<pi> P c\n   (\\<lambda>s\\<^sub>0 s. modifies vs s s\\<^sub>0 \\<and> Q s\\<^sub>0 s)\n\ngoal (1 subgoal):\n 1. HT \\<pi> (ADJUST_PRE_PARAM l G P) (l[] ::= G;; c)\n     (\\<lambda>s\\<^sub>0 s.\n         modifies (insert l vs) s s\\<^sub>0 \\<and>\n         ADJUST_POST_PARAM l G Q s\\<^sub>0 s)", "apply (drule_tac adjust_assign_before[of \\<pi> P c _ l G])"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT \\<pi> (\\<lambda>s. P (s(l := s G))) (l[] ::= G;; c)\n     (\\<lambda>s\\<^sub>0 s.\n         modifies vs s (s\\<^sub>0(l := s\\<^sub>0 G)) \\<and>\n         Q (s\\<^sub>0(l := s\\<^sub>0 G)) s) \\<Longrightarrow>\n    HT \\<pi> (ADJUST_PRE_PARAM l G P) (l[] ::= G;; c)\n     (\\<lambda>s\\<^sub>0 s.\n         modifies (insert l vs) s s\\<^sub>0 \\<and>\n         ADJUST_POST_PARAM l G Q s\\<^sub>0 s)", "apply (erule HT_conseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s. ADJUST_PRE_PARAM l G P s \\<Longrightarrow> P (s(l := s G))\n 2. \\<And>s\\<^sub>0 s.\n       \\<lbrakk>P (s\\<^sub>0(l := s\\<^sub>0 G));\n        ADJUST_PRE_PARAM l G P s\\<^sub>0;\n        modifies vs s (s\\<^sub>0(l := s\\<^sub>0 G)) \\<and>\n        Q (s\\<^sub>0(l := s\\<^sub>0 G)) s\\<rbrakk>\n       \\<Longrightarrow> modifies (insert l vs) s s\\<^sub>0 \\<and>\n                         ADJUST_POST_PARAM l G Q s\\<^sub>0 s", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0 s.\n       \\<lbrakk>P (s\\<^sub>0(l := s\\<^sub>0 G));\n        ADJUST_PRE_PARAM l G P s\\<^sub>0;\n        modifies vs s (s\\<^sub>0(l := s\\<^sub>0 G)) \\<and>\n        Q (s\\<^sub>0(l := s\\<^sub>0 G)) s\\<rbrakk>\n       \\<Longrightarrow> modifies (insert l vs) s s\\<^sub>0 \\<and>\n                         ADJUST_POST_PARAM l G Q s\\<^sub>0 s", "apply (auto simp: modifies_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma HT_mods_adjust_retv:\n    assumes \"HT_mods \\<pi> vs P c Q\"\n    shows \"HT_mods \\<pi> (insert G vs) P (c;; G[]::=l) (ADJUST_POST_RETV G l Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_mods \\<pi> (insert G vs) P (c;; G[] ::= l) (ADJUST_POST_RETV G l Q)", "using assms"], ["proof (prove)\nusing this:\n  HT_mods \\<pi> vs P c Q\n\ngoal (1 subgoal):\n 1. HT_mods \\<pi> (insert G vs) P (c;; G[] ::= l) (ADJUST_POST_RETV G l Q)", "unfolding HT_mods_def"], ["proof (prove)\nusing this:\n  HT \\<pi> P c\n   (\\<lambda>s\\<^sub>0 s. modifies vs s s\\<^sub>0 \\<and> Q s\\<^sub>0 s)\n\ngoal (1 subgoal):\n 1. HT \\<pi> P (c;; G[] ::= l)\n     (\\<lambda>s\\<^sub>0 s.\n         modifies (insert G vs) s s\\<^sub>0 \\<and>\n         ADJUST_POST_RETV G l Q s\\<^sub>0 s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT \\<pi> P c\n     (\\<lambda>s\\<^sub>0 s.\n         modifies vs s s\\<^sub>0 \\<and> Q s\\<^sub>0 s) \\<Longrightarrow>\n    HT \\<pi> P (c;; G[] ::= l)\n     (\\<lambda>s\\<^sub>0 s.\n         modifies (insert G vs) s s\\<^sub>0 \\<and>\n         (\\<exists>vx. Q s\\<^sub>0 (s(G := vx, l := s G))))", "apply (unfold HT_def; clarsimp simp: wp_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       \\<lbrakk>\\<forall>s\\<^sub>0.\n                   P s\\<^sub>0 \\<longrightarrow>\n                   wp \\<pi> c\n                    (\\<lambda>s.\n                        modifies vs s s\\<^sub>0 \\<and> Q s\\<^sub>0 s)\n                    s\\<^sub>0;\n        P s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> wp \\<pi> c\n                          (wp \\<pi> (G[] ::= l)\n                            (\\<lambda>s.\n                                modifies (insert G vs) s s\\<^sub>0 \\<and>\n                                (\\<exists>vx.\n                                    Q s\\<^sub>0 (s(G := vx, l := s G)))))\n                          s\\<^sub>0", "apply (drule spec, erule (1) impE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       \\<lbrakk>P s\\<^sub>0;\n        wp \\<pi> c\n         (\\<lambda>s. modifies vs s s\\<^sub>0 \\<and> Q s\\<^sub>0 s)\n         s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> wp \\<pi> c\n                          (wp \\<pi> (G[] ::= l)\n                            (\\<lambda>s.\n                                modifies (insert G vs) s s\\<^sub>0 \\<and>\n                                (\\<exists>vx.\n                                    Q s\\<^sub>0 (s(G := vx, l := s G)))))\n                          s\\<^sub>0", "apply (erule wp_conseq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0 s.\n       \\<lbrakk>P s\\<^sub>0;\n        modifies vs s s\\<^sub>0 \\<and> Q s\\<^sub>0 s\\<rbrakk>\n       \\<Longrightarrow> wp \\<pi> (G[] ::= l)\n                          (\\<lambda>s.\n                              modifies (insert G vs) s s\\<^sub>0 \\<and>\n                              (\\<exists>vx.\n                                  Q s\\<^sub>0 (s(G := vx, l := s G))))\n                          s", "apply (auto simp add: wp_eq modifies_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0 s.\n       \\<lbrakk>P s\\<^sub>0;\n        \\<forall>x. x \\<notin> vs \\<longrightarrow> s x = s\\<^sub>0 x;\n        Q s\\<^sub>0 s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vx. Q s\\<^sub>0 (s(G := vx, l := s l))", "by (metis fun_upd_triv)"], ["", "lemma HT_partial_mods_adjust_scope: \n    assumes \"HT_partial_mods \\<pi> vs P c Q\"\n    shows \"HT_partial_mods \\<pi> (Set.filter is_global vs) (ADJUST_PRE_SCOPE P) (SCOPE c) (ADJUST_POST_SCOPE Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_partial_mods \\<pi> (Set.filter is_global vs) (ADJUST_PRE_SCOPE P)\n     (SCOPE c) (ADJUST_POST_SCOPE Q)", "using assms"], ["proof (prove)\nusing this:\n  HT_partial_mods \\<pi> vs P c Q\n\ngoal (1 subgoal):\n 1. HT_partial_mods \\<pi> (Set.filter is_global vs) (ADJUST_PRE_SCOPE P)\n     (SCOPE c) (ADJUST_POST_SCOPE Q)", "unfolding HT_partial_mods_def"], ["proof (prove)\nusing this:\n  HT_partial \\<pi> P c\n   (\\<lambda>s\\<^sub>0 s. Q s\\<^sub>0 s \\<and> modifies vs s s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. HT_partial \\<pi> (ADJUST_PRE_SCOPE P) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s.\n         ADJUST_POST_SCOPE Q s\\<^sub>0 s \\<and>\n         modifies (Set.filter is_global vs) s s\\<^sub>0)", "apply (drule_tac adjust_scope_partial)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_partial \\<pi> (\\<lambda>s. P <<>|s>) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s.\n         \\<exists>l.\n            Q <<>|s\\<^sub>0> <l|s> \\<and>\n            modifies vs <l|s> <<>|s\\<^sub>0>) \\<Longrightarrow>\n    HT_partial \\<pi> (ADJUST_PRE_SCOPE P) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s.\n         ADJUST_POST_SCOPE Q s\\<^sub>0 s \\<and>\n         modifies (Set.filter is_global vs) s s\\<^sub>0)", "apply (drule_tac HT_partial_strengthen_modset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_partial \\<pi> (\\<lambda>s. P <<>|s>) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s.\n         (\\<exists>l.\n             Q <<>|s\\<^sub>0> <l|s> \\<and>\n             modifies vs <l|s> <<>|s\\<^sub>0>) \\<and>\n         modifies (lhsv \\<pi> (SCOPE c)) s s\\<^sub>0) \\<Longrightarrow>\n    HT_partial \\<pi> (ADJUST_PRE_SCOPE P) (SCOPE c)\n     (\\<lambda>s\\<^sub>0 s.\n         ADJUST_POST_SCOPE Q s\\<^sub>0 s \\<and>\n         modifies (Set.filter is_global vs) s s\\<^sub>0)", "apply (erule HT_partial_conseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s. ADJUST_PRE_SCOPE P s \\<Longrightarrow> P <<>|s>\n 2. \\<And>s\\<^sub>0 s.\n       \\<lbrakk>P <<>|s\\<^sub>0>; ADJUST_PRE_SCOPE P s\\<^sub>0;\n        (\\<exists>l.\n            Q <<>|s\\<^sub>0> <l|s> \\<and>\n            modifies vs <l|s> <<>|s\\<^sub>0>) \\<and>\n        modifies (lhsv \\<pi> (SCOPE c)) s s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> ADJUST_POST_SCOPE Q s\\<^sub>0 s \\<and>\n                         modifies (Set.filter is_global vs) s s\\<^sub>0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0 s.\n       \\<lbrakk>P <<>|s\\<^sub>0>; ADJUST_PRE_SCOPE P s\\<^sub>0;\n        (\\<exists>l.\n            Q <<>|s\\<^sub>0> <l|s> \\<and>\n            modifies vs <l|s> <<>|s\\<^sub>0>) \\<and>\n        modifies (lhsv \\<pi> (SCOPE c)) s s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> ADJUST_POST_SCOPE Q s\\<^sub>0 s \\<and>\n                         modifies (Set.filter is_global vs) s s\\<^sub>0", "apply (clarsimp simp: modifies_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0 s l.\n       \\<lbrakk>P <<>|s\\<^sub>0>;\n        modifies (Set.filter is_global (lhsv \\<pi> c)) s s\\<^sub>0;\n        Q <<>|s\\<^sub>0> <l|s>;\n        modifies (Collect is_global \\<union> vs) l <>;\n        modifies ({a. is_local a} \\<union> vs) s s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l. Q <<>|s\\<^sub>0> <l|s>) \\<and>\n                         modifies (Set.filter is_global vs) s s\\<^sub>0", "apply (drule (1) modifies_join)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0 s l.\n       \\<lbrakk>P <<>|s\\<^sub>0>; Q <<>|s\\<^sub>0> <l|s>;\n        modifies (Collect is_global \\<union> vs) l <>;\n        modifies ({a. is_local a} \\<union> vs) s s\\<^sub>0;\n        modifies\n         (Set.filter is_global (lhsv \\<pi> c) \\<inter>\n          ({a. is_local a} \\<union> vs))\n         s s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>l. Q <<>|s\\<^sub>0> <l|s>) \\<and>\n                         modifies (Set.filter is_global vs) s s\\<^sub>0", "apply (auto elim: modifies_mono[rotated])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma HT_partial_mods_adjust_param: \n    assumes \"HT_partial_mods \\<pi> vs P c Q\"\n    shows \"HT_partial_mods \\<pi> (insert l vs) (ADJUST_PRE_PARAM l G P) (l[]::=G;; c) (ADJUST_POST_PARAM l G Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_partial_mods \\<pi> (insert l vs) (ADJUST_PRE_PARAM l G P)\n     (l[] ::= G;; c) (ADJUST_POST_PARAM l G Q)", "using assms"], ["proof (prove)\nusing this:\n  HT_partial_mods \\<pi> vs P c Q\n\ngoal (1 subgoal):\n 1. HT_partial_mods \\<pi> (insert l vs) (ADJUST_PRE_PARAM l G P)\n     (l[] ::= G;; c) (ADJUST_POST_PARAM l G Q)", "unfolding HT_partial_mods_def"], ["proof (prove)\nusing this:\n  HT_partial \\<pi> P c\n   (\\<lambda>s\\<^sub>0 s. Q s\\<^sub>0 s \\<and> modifies vs s s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. HT_partial \\<pi> (ADJUST_PRE_PARAM l G P) (l[] ::= G;; c)\n     (\\<lambda>s\\<^sub>0 s.\n         ADJUST_POST_PARAM l G Q s\\<^sub>0 s \\<and>\n         modifies (insert l vs) s s\\<^sub>0)", "apply (drule_tac adjust_assign_before_partial[of \\<pi> P c _ l G])"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_partial \\<pi> (\\<lambda>s. P (s(l := s G))) (l[] ::= G;; c)\n     (\\<lambda>s\\<^sub>0 s.\n         Q (s\\<^sub>0(l := s\\<^sub>0 G)) s \\<and>\n         modifies vs s (s\\<^sub>0(l := s\\<^sub>0 G))) \\<Longrightarrow>\n    HT_partial \\<pi> (ADJUST_PRE_PARAM l G P) (l[] ::= G;; c)\n     (\\<lambda>s\\<^sub>0 s.\n         ADJUST_POST_PARAM l G Q s\\<^sub>0 s \\<and>\n         modifies (insert l vs) s s\\<^sub>0)", "apply (erule HT_partial_conseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s. ADJUST_PRE_PARAM l G P s \\<Longrightarrow> P (s(l := s G))\n 2. \\<And>s\\<^sub>0 s.\n       \\<lbrakk>P (s\\<^sub>0(l := s\\<^sub>0 G));\n        ADJUST_PRE_PARAM l G P s\\<^sub>0;\n        Q (s\\<^sub>0(l := s\\<^sub>0 G)) s \\<and>\n        modifies vs s (s\\<^sub>0(l := s\\<^sub>0 G))\\<rbrakk>\n       \\<Longrightarrow> ADJUST_POST_PARAM l G Q s\\<^sub>0 s \\<and>\n                         modifies (insert l vs) s s\\<^sub>0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0 s.\n       \\<lbrakk>P (s\\<^sub>0(l := s\\<^sub>0 G));\n        ADJUST_PRE_PARAM l G P s\\<^sub>0;\n        Q (s\\<^sub>0(l := s\\<^sub>0 G)) s \\<and>\n        modifies vs s (s\\<^sub>0(l := s\\<^sub>0 G))\\<rbrakk>\n       \\<Longrightarrow> ADJUST_POST_PARAM l G Q s\\<^sub>0 s \\<and>\n                         modifies (insert l vs) s s\\<^sub>0", "apply (auto simp: modifies_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma HT_partial_mods_adjust_retv:\n    assumes \"HT_partial_mods \\<pi> vs P c Q\"\n    shows \"HT_partial_mods \\<pi> (insert G vs) P (c;; G[]::=l) (ADJUST_POST_RETV G l Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_partial_mods \\<pi> (insert G vs) P (c;; G[] ::= l)\n     (ADJUST_POST_RETV G l Q)", "using assms"], ["proof (prove)\nusing this:\n  HT_partial_mods \\<pi> vs P c Q\n\ngoal (1 subgoal):\n 1. HT_partial_mods \\<pi> (insert G vs) P (c;; G[] ::= l)\n     (ADJUST_POST_RETV G l Q)", "unfolding HT_partial_mods_def"], ["proof (prove)\nusing this:\n  HT_partial \\<pi> P c\n   (\\<lambda>s\\<^sub>0 s. Q s\\<^sub>0 s \\<and> modifies vs s s\\<^sub>0)\n\ngoal (1 subgoal):\n 1. HT_partial \\<pi> P (c;; G[] ::= l)\n     (\\<lambda>s\\<^sub>0 s.\n         ADJUST_POST_RETV G l Q s\\<^sub>0 s \\<and>\n         modifies (insert G vs) s s\\<^sub>0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_partial \\<pi> P c\n     (\\<lambda>s\\<^sub>0 s.\n         Q s\\<^sub>0 s \\<and> modifies vs s s\\<^sub>0) \\<Longrightarrow>\n    HT_partial \\<pi> P (c;; G[] ::= l)\n     (\\<lambda>s\\<^sub>0 s.\n         (\\<exists>vx. Q s\\<^sub>0 (s(G := vx, l := s G))) \\<and>\n         modifies (insert G vs) s s\\<^sub>0)", "apply (unfold HT_partial_def; clarsimp simp: wlp_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       \\<lbrakk>\\<forall>s\\<^sub>0.\n                   P s\\<^sub>0 \\<longrightarrow>\n                   wlp \\<pi> c\n                    (\\<lambda>s.\n                        Q s\\<^sub>0 s \\<and> modifies vs s s\\<^sub>0)\n                    s\\<^sub>0;\n        P s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> wlp \\<pi> c\n                          (wlp \\<pi> (G[] ::= l)\n                            (\\<lambda>s.\n                                (\\<exists>vx.\n                                    Q s\\<^sub>0\n                                     (s(G := vx, l := s G))) \\<and>\n                                modifies (insert G vs) s s\\<^sub>0))\n                          s\\<^sub>0", "apply (drule spec, erule (1) impE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       \\<lbrakk>P s\\<^sub>0;\n        wlp \\<pi> c\n         (\\<lambda>s. Q s\\<^sub>0 s \\<and> modifies vs s s\\<^sub>0)\n         s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> wlp \\<pi> c\n                          (wlp \\<pi> (G[] ::= l)\n                            (\\<lambda>s.\n                                (\\<exists>vx.\n                                    Q s\\<^sub>0\n                                     (s(G := vx, l := s G))) \\<and>\n                                modifies (insert G vs) s s\\<^sub>0))\n                          s\\<^sub>0", "apply (erule wlp_conseq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0 s.\n       \\<lbrakk>P s\\<^sub>0;\n        Q s\\<^sub>0 s \\<and> modifies vs s s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> wlp \\<pi> (G[] ::= l)\n                          (\\<lambda>s.\n                              (\\<exists>vx.\n                                  Q s\\<^sub>0 (s(G := vx, l := s G))) \\<and>\n                              modifies (insert G vs) s s\\<^sub>0)\n                          s", "apply (auto simp add: wlp_eq modifies_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0 s.\n       \\<lbrakk>P s\\<^sub>0; Q s\\<^sub>0 s;\n        \\<forall>x.\n           x \\<notin> vs \\<longrightarrow> s x = s\\<^sub>0 x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vx. Q s\\<^sub>0 (s(G := vx, l := s l))", "by (metis fun_upd_triv)"], ["", "end"], ["", "lemma HT_generalize_penv:\n  assumes \"HT_mods Map.empty mods P c Q\"\n  shows \"HT_mods \\<pi> mods P c Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_mods \\<pi> mods P c Q", "using assms"], ["proof (prove)\nusing this:\n  HT_mods Map.empty mods P c Q\n\ngoal (1 subgoal):\n 1. HT_mods \\<pi> mods P c Q", "unfolding HT_mods_def HT_def wp_def"], ["proof (prove)\nusing this:\n  \\<forall>s\\<^sub>0.\n     P s\\<^sub>0 \\<longrightarrow>\n     (\\<exists>t.\n         Map.empty: (c, s\\<^sub>0) \\<Rightarrow> t \\<and>\n         modifies mods t s\\<^sub>0 \\<and> Q s\\<^sub>0 t)\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<^sub>0.\n       P s\\<^sub>0 \\<longrightarrow>\n       (\\<exists>t.\n           \\<pi>: (c, s\\<^sub>0) \\<Rightarrow> t \\<and>\n           modifies mods t s\\<^sub>0 \\<and> Q s\\<^sub>0 t)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       \\<lbrakk>\\<forall>s\\<^sub>0.\n                   P s\\<^sub>0 \\<longrightarrow>\n                   (\\<exists>t.\n                       Map.empty: (c, s\\<^sub>0) \\<Rightarrow> t \\<and>\n                       modifies mods t s\\<^sub>0 \\<and> Q s\\<^sub>0 t);\n        P s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            \\<pi>: (c, s\\<^sub>0) \\<Rightarrow> t \\<and>\n                            modifies mods t s\\<^sub>0 \\<and> Q s\\<^sub>0 t", "using big_step_mono_prog map_le_empty"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<pi> \\<subseteq>\\<^sub>m ?\\<pi>';\n   ?\\<pi>: (?c, ?s) \\<Rightarrow> ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<pi>': (?c, ?s) \\<Rightarrow> ?t\n  Map.empty \\<subseteq>\\<^sub>m ?g\n\ngoal (1 subgoal):\n 1. \\<And>s\\<^sub>0.\n       \\<lbrakk>\\<forall>s\\<^sub>0.\n                   P s\\<^sub>0 \\<longrightarrow>\n                   (\\<exists>t.\n                       Map.empty: (c, s\\<^sub>0) \\<Rightarrow> t \\<and>\n                       modifies mods t s\\<^sub>0 \\<and> Q s\\<^sub>0 t);\n        P s\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            \\<pi>: (c, s\\<^sub>0) \\<Rightarrow> t \\<and>\n                            modifies mods t s\\<^sub>0 \\<and> Q s\\<^sub>0 t", "by blast"], ["", "ML \\<open>structure IMP2_Parameters \n  = struct\n    fun adjust_retv_rl ctxt G l thm = let\n      val G = HOLogic.mk_string G |> Thm.cterm_of ctxt\n      val l = HOLogic.mk_string l |> Thm.cterm_of ctxt\n      \n      val rs_thms = @{thms HT_mods_adjust_retv HT_partial_mods_adjust_retv}\n        |> map (Drule.infer_instantiate' ctxt [NONE, NONE, NONE, NONE, NONE, SOME G, SOME l])\n    in thm RS_fst rs_thms end\n  \n    fun adjust_param_rl ctxt G l thm = let\n      val G = HOLogic.mk_string G |> Thm.cterm_of ctxt\n      val l = HOLogic.mk_string l |> Thm.cterm_of ctxt\n      \n      val rs_thms = @{thms HT_mods_adjust_param HT_partial_mods_adjust_param}\n        |> map (Drule.infer_instantiate' ctxt [NONE, NONE, NONE, NONE, NONE, SOME l, SOME G])\n    in thm RS_fst rs_thms end\n    \n    fun adjust_scope_rl (_:Proof.context) thm = thm RS_fst @{thms HT_mods_adjust_scope HT_partial_mods_adjust_scope}\n      \n    \n    fun adjust_proc_rl imp_params imp_retvs ctxt thm = let\n      val params = IMP_Syntax.zip_with_param_names imp_params\n      val retvs = IMP_Syntax.zip_with_ret_names imp_retvs\n      \n      val ctxt = Named_Simpsets.put @{named_simpset vcg_bb} ctxt\n      val ctxt = ctxt addsimps @{thms ADJUST_unfolds}\n  \n      val thm = thm\n        |> fold_rev (uncurry (adjust_retv_rl ctxt)) retvs\n        |> fold_rev (uncurry (adjust_param_rl ctxt)) params\n        |> adjust_scope_rl ctxt\n        |> Simplifier.simplify ctxt\n    \n    in\n      thm\n    end\n  \n  end\n\\<close>"], ["", "subsubsection \\<open>Recursion\\<close>"], ["", "lemma HT_mods_fold_call:\n  assumes \"\\<pi> p = Some c\"\n  assumes \"HT_mods \\<pi> mods P c Q\"\n  shows \"HT_mods \\<pi> mods P (PCall p) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_mods \\<pi> mods P (PCall p) Q", "using assms"], ["proof (prove)\nusing this:\n  \\<pi> p = Some c\n  HT_mods \\<pi> mods P c Q\n\ngoal (1 subgoal):\n 1. HT_mods \\<pi> mods P (PCall p) Q", "unfolding HT_mods_def HT_def"], ["proof (prove)\nusing this:\n  \\<pi> p = Some c\n  \\<forall>s\\<^sub>0.\n     P s\\<^sub>0 \\<longrightarrow>\n     wp \\<pi> c (\\<lambda>s. modifies mods s s\\<^sub>0 \\<and> Q s\\<^sub>0 s)\n      s\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<^sub>0.\n       P s\\<^sub>0 \\<longrightarrow>\n       wp \\<pi> (PCall p)\n        (\\<lambda>s. modifies mods s s\\<^sub>0 \\<and> Q s\\<^sub>0 s)\n        s\\<^sub>0", "by (auto simp: wp_eq wp_pcall_eq)"], ["", "lemma localize_HT_mods: \n  assumes \"HT_mods \\<pi> mods P (PCall p) Q\"\n  shows \"HT_mods \\<pi>' mods P (PScope \\<pi> (PCall p)) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT_mods \\<pi>' mods P (PScope \\<pi> (PCall p)) Q", "using assms"], ["proof (prove)\nusing this:\n  HT_mods \\<pi> mods P (PCall p) Q\n\ngoal (1 subgoal):\n 1. HT_mods \\<pi>' mods P (PScope \\<pi> (PCall p)) Q", "unfolding HT_mods_def HT_def wp_def"], ["proof (prove)\nusing this:\n  \\<forall>s\\<^sub>0.\n     P s\\<^sub>0 \\<longrightarrow>\n     (\\<exists>t.\n         \\<pi>: (PCall p, s\\<^sub>0) \\<Rightarrow> t \\<and>\n         modifies mods t s\\<^sub>0 \\<and> Q s\\<^sub>0 t)\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<^sub>0.\n       P s\\<^sub>0 \\<longrightarrow>\n       (\\<exists>t.\n           \\<pi>': (PScope \\<pi> (PCall p),\n                    s\\<^sub>0) \\<Rightarrow> t \\<and>\n           modifies mods t s\\<^sub>0 \\<and> Q s\\<^sub>0 t)", "by (simp add: localize_recursion)"], ["", "lemmas localize_HT_mods' = localize_HT_mods[where \\<pi>'=\"Map.empty\"]"], ["", "definition \"PROVE_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 \\<Theta> \\<equiv> \\<forall>P c Q. (f\\<^sub>0,(P,c,Q))\\<in>\\<Theta> \\<and> P s\\<^sub>0 \\<longrightarrow> wp \\<pi> (c s\\<^sub>0) (Q s\\<^sub>0) s\\<^sub>0\""], ["", "lemma PROVE_\\<Theta>I[vcg_preprocess_rules]:\n  \"PROVE_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 {}\" \n  \"\\<lbrakk>\\<lbrakk>RENAMING f\\<^sub>0 f; BB_PROTECT (P s\\<^sub>0)\\<rbrakk> \\<Longrightarrow> wp \\<pi> (c s\\<^sub>0) (Q s\\<^sub>0) s\\<^sub>0; PROVE_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 \\<Theta>\\<rbrakk> \\<Longrightarrow> PROVE_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 (insert (f,(P,c,Q)) \\<Theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROVE_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 {} &&&\n    (\\<lbrakk>\\<lbrakk>RENAMING f\\<^sub>0 f;\n               BB_PROTECT (P s\\<^sub>0)\\<rbrakk>\n              \\<Longrightarrow> wp \\<pi> (c s\\<^sub>0) (Q s\\<^sub>0)\n                                 s\\<^sub>0;\n      PROVE_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 \\<Theta>\\<rbrakk>\n     \\<Longrightarrow> PROVE_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0\n                        (insert (f, P, c, Q) \\<Theta>))", "unfolding PROVE_\\<Theta>_def BB_PROTECT_def RENAMING_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P c Q.\n       (f\\<^sub>0, P, c, Q) \\<in> {} \\<and> P s\\<^sub>0 \\<longrightarrow>\n       wp \\<pi> (c s\\<^sub>0) (Q s\\<^sub>0) s\\<^sub>0 &&&\n    (\\<lbrakk>\\<lbrakk>f\\<^sub>0 = f; P s\\<^sub>0\\<rbrakk>\n              \\<Longrightarrow> wp \\<pi> (c s\\<^sub>0) (Q s\\<^sub>0)\n                                 s\\<^sub>0;\n      \\<forall>P c Q.\n         (f\\<^sub>0, P, c, Q) \\<in> \\<Theta> \\<and>\n         P s\\<^sub>0 \\<longrightarrow>\n         wp \\<pi> (c s\\<^sub>0) (Q s\\<^sub>0) s\\<^sub>0\\<rbrakk>\n     \\<Longrightarrow> \\<forall>Pa ca Qa.\n                          (f\\<^sub>0, Pa, ca, Qa)\n                          \\<in> insert (f, P, c, Q) \\<Theta> \\<and>\n                          Pa s\\<^sub>0 \\<longrightarrow>\n                          wp \\<pi> (ca s\\<^sub>0) (Qa s\\<^sub>0) s\\<^sub>0)", "by auto"], ["", "definition \"JOIN_VARS f g P \\<equiv> P f g\""], ["", "lemma JOIN_VARS: \n  \"\\<And>v f g P. JOIN_VARS (VAR v (\\<lambda>x. f x)) g P = VAR v (\\<lambda>x. JOIN_VARS (f x) g P)\"\n  \"\\<And>v f g P. JOIN_VARS f (VAR v (\\<lambda>x. g x)) P = VAR v (\\<lambda>x. JOIN_VARS f (g x) P)\"\n  \"\\<And>f g P. JOIN_VARS (BB_PROTECT f) (BB_PROTECT g) P = P f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v f g P.\n        JOIN_VARS (VAR v f) g P =\n        VAR v (\\<lambda>x. JOIN_VARS (f x) g P)) &&&\n    (\\<And>v f g P.\n        JOIN_VARS f (VAR v g) P =\n        VAR v (\\<lambda>x. JOIN_VARS f (g x) P)) &&&\n    (\\<And>f g P. JOIN_VARS (BB_PROTECT f) (BB_PROTECT g) P = P f g)", "by (auto simp: JOIN_VARS_def BB_PROTECT_def VAR_def)"], ["", "ML \\<open>\n  fun join_vars_rl ctxt thm0 = let \n    val thm = Local_Defs.unfold ctxt @{thms JOIN_VARS} thm0\n    \n    val t = Thm.prop_of thm\n    val cns = Term.add_const_names t []\n    val _ = member op= cns @{const_name JOIN_VARS} andalso raise THM(\"join_vars_rl: not joined\",~1,[thm0,thm])\n  in\n    thm\n  end\n\\<close>"], ["", "definition \"ASSUME_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 R \\<Theta> \\<equiv> HT'set_r (\\<lambda>f' s'. ((f' s'),(f\\<^sub>0 s\\<^sub>0))\\<in>R ) \\<pi> \\<Theta>\""], ["", "lemmas ASSUME_\\<Theta>E1 = thin_rl[of \"ASSUME_\\<Theta> _ _ _ _ {}\"]"], ["", "lemma ASSUME_\\<Theta>E2:\n  assumes \"ASSUME_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 R (insert (f,(P,c,Q)) \\<Theta>)\"\n  obtains \"HT' \\<pi> (\\<lambda>s. JOIN_VARS (f s) (P s) (\\<lambda>v P. BB_PROTECT ((v,(f\\<^sub>0 s\\<^sub>0))\\<in>R \\<and> P))) c Q\" \"ASSUME_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 R \\<Theta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>HT' \\<pi>\n               (\\<lambda>s.\n                   JOIN_VARS (f s) (P s)\n                    (\\<lambda>v P.\n                        BB_PROTECT\n                         ((v, f\\<^sub>0 s\\<^sub>0) \\<in> R \\<and> P)))\n               c Q;\n      ASSUME_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 R \\<Theta>\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ASSUME_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 R (insert (f, P, c, Q) \\<Theta>)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>HT' \\<pi>\n               (\\<lambda>s.\n                   JOIN_VARS (f s) (P s)\n                    (\\<lambda>v P.\n                        BB_PROTECT\n                         ((v, f\\<^sub>0 s\\<^sub>0) \\<in> R \\<and> P)))\n               c Q;\n      ASSUME_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 R \\<Theta>\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ASSUME_\\<Theta>_def HT'set_r_def JOIN_VARS_def BB_PROTECT_def"], ["proof (prove)\nusing this:\n  \\<forall>(n, P, c, Q)\\<in>insert (f, P, c, Q) \\<Theta>.\n     HT' \\<pi> (\\<lambda>s. (n s, f\\<^sub>0 s\\<^sub>0) \\<in> R \\<and> P s) c\n      Q\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>HT' \\<pi>\n               (\\<lambda>s. (f s, f\\<^sub>0 s\\<^sub>0) \\<in> R \\<and> P s) c\n               Q;\n      \\<forall>(n, P, c, Q)\\<in>\\<Theta>.\n         HT' \\<pi>\n          (\\<lambda>s. (n s, f\\<^sub>0 s\\<^sub>0) \\<in> R \\<and> P s) c\n          Q\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemmas ASSUME_\\<Theta>E = ASSUME_\\<Theta>E1 ASSUME_\\<Theta>E2"], ["", "lemma vcg_HT'setI:    \n  assumes \"wf R\"\n  assumes RL: \"\\<And>f\\<^sub>0 s\\<^sub>0. \\<lbrakk> ASSUME_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 R \\<Theta> \\<rbrakk> \\<Longrightarrow> PROVE_\\<Theta> \\<pi> f\\<^sub>0 s\\<^sub>0 \\<Theta>\"\n  shows \"HT'set \\<pi> \\<Theta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT'set \\<pi> \\<Theta>", "using assms HT'setI[of R \\<pi> \\<Theta>]"], ["proof (prove)\nusing this:\n  wf R\n  ASSUME_\\<Theta> \\<pi> ?f\\<^sub>0 ?s\\<^sub>0 R \\<Theta> \\<Longrightarrow>\n  PROVE_\\<Theta> \\<pi> ?f\\<^sub>0 ?s\\<^sub>0 \\<Theta>\n  \\<lbrakk>wf R;\n   \\<And>f P c Q s\\<^sub>0.\n      \\<lbrakk>HT'set_r (\\<lambda>f' s'. (f' s', f s\\<^sub>0) \\<in> R) \\<pi>\n                \\<Theta>;\n       (f, P, c, Q) \\<in> \\<Theta>; P s\\<^sub>0\\<rbrakk>\n      \\<Longrightarrow> wp \\<pi> (c s\\<^sub>0) (Q s\\<^sub>0)\n                         s\\<^sub>0\\<rbrakk>\n  \\<Longrightarrow> HT'set \\<pi> \\<Theta>\n\ngoal (1 subgoal):\n 1. HT'set \\<pi> \\<Theta>", "unfolding ASSUME_\\<Theta>_def PROVE_\\<Theta>_def HT'set_def"], ["proof (prove)\nusing this:\n  wf R\n  HT'set_r (\\<lambda>f' s'. (f' s', ?f\\<^sub>0 ?s\\<^sub>0) \\<in> R) \\<pi>\n   \\<Theta> \\<Longrightarrow>\n  \\<forall>P c Q.\n     (?f\\<^sub>0, P, c, Q) \\<in> \\<Theta> \\<and>\n     P ?s\\<^sub>0 \\<longrightarrow>\n     wp \\<pi> (c ?s\\<^sub>0) (Q ?s\\<^sub>0) ?s\\<^sub>0\n  \\<lbrakk>wf R;\n   \\<And>f P c Q s\\<^sub>0.\n      \\<lbrakk>HT'set_r (\\<lambda>f' s'. (f' s', f s\\<^sub>0) \\<in> R) \\<pi>\n                \\<Theta>;\n       (f, P, c, Q) \\<in> \\<Theta>; P s\\<^sub>0\\<rbrakk>\n      \\<Longrightarrow> wp \\<pi> (c s\\<^sub>0) (Q s\\<^sub>0)\n                         s\\<^sub>0\\<rbrakk>\n  \\<Longrightarrow> \\<forall>(n, P, c, Q)\\<in>\\<Theta>. HT' \\<pi> P c Q\n\ngoal (1 subgoal):\n 1. \\<forall>(n, P, c, Q)\\<in>\\<Theta>. HT' \\<pi> P c Q", "by auto"], ["", "subsubsection \\<open>Consistency Check\\<close>"], ["", "ML \\<open>structure Spec_Consistency_Check \n  = struct\n      fun check_ht_mods thm = let\n        val (_,_,mods,P,_,Q) = Thm.concl_of thm \n          |> HOLogic.dest_Trueprop |> IMP2_Modified_Analysis.dest_HT_mods\n      \n        fun fail msg = raise THM (\"Consistency check: \"^msg,~1,[thm])\n        \n        (* Check that modset is OK *)  \n        val _ = IMP2_Modified_Analysis.is_valid_modset mods orelse fail \"invalid modset\"\n        \n        (* Check for relicts in pre/postcondition *)\n        val bad_consts = [\n          @{const_name ADJUST_PRE_PARAM}, \n          @{const_name ADJUST_PRE_SCOPE}, \n          @{const_name ADJUST_POST_PARAM}, \n          @{const_name ADJUST_POST_RETV}, \n          @{const_name ADJUST_POST_SCOPE}\n          ]\n\n        fun is_bad_const (n,_) = member op= bad_consts n\n          \n        val _ = exists_Const is_bad_const P andalso fail \"VCG relict in precondition\"\n        val _ = exists_Const is_bad_const Q andalso fail \"VCG relict in precondition\"\n      in\n        ()\n      end\n  \n  end\n\\<close>"], ["", "(* Summarizes postprocessors for specifications *)"], ["", "ML \\<open>structure Spec_Postprocessing \n  = struct\n    (*\n      Strip annotations\n    *)\n    fun cnv_HT'_to_HT ctxt = \n         IMP_Annotations.strip_annotations ctxt\n      #> Local_Defs.unfold ctxt @{thms HT'_unfolds}\n    \n    (*\n      Modifies Analysis\n    *)\n    val cnv_HT_to_HTmod = IMP2_Modified_Analysis.mk_HT_mods\n      \n    (*\n      Make procedure frame\n    *)\n    val cnv_body_to_proc = IMP2_Parameters.adjust_proc_rl\n    \n    (*\n      Generalize over procedure environment\n    *)\n    fun cnv_HTmod_generalize_penv thm = thm RS_fst @{thms HT_generalize_penv asm_rl}\n  \n    (*\n      Define command as constant\n    *)\n    fun define_HTmod_const binding thm lthy = let\n      (* Extract Command *)\n      val (_,_,_,_,cmd,_) = Thm.concl_of thm |> HOLogic.dest_Trueprop |> IMP2_Modified_Analysis.dest_HT_mods\n\n      (* Define *)\n      val lhs = Free (Binding.name_of binding, fastype_of cmd)\n      val eqn = Logic.mk_equals (lhs,cmd)\n      val ((lhs,(_,def_thm)),lthy) = Specification.definition (SOME (binding,NONE,Mixfix.NoSyn)) [] [] ((Binding.empty,[]),eqn) lthy\n      \n      (* Fold definition in theorem *)\n      val thm = Local_Defs.fold lthy [def_thm] thm\n      \n      (* Sanity check: Has definition actually been folded? *)\n      val _ = exists_subterm (curry op = lhs) (Thm.prop_of thm)\n        orelse raise THM(\"spec_program_cmd: Failed to fold command definition\",~1,[thm])\n      \n    in\n      ((binding,def_thm,thm), lthy)\n    end \n    \n    (*\n      Declare defined command and specification to VCG\n    *)\n    fun declare_defined_spec (binding,def_thm,thm) lthy = let\n      (* Sanity check: Various consistency checks *)  \n      val _ = Spec_Consistency_Check.check_ht_mods thm\n\n      val note = snd oo Local_Theory.note\n\n      (* Note specification theorem, register as [vcg_rule] *)\n      val spec_thm_name = Binding.suffix_name \"_spec\" binding\n      val lthy = note ((spec_thm_name,@{attributes [vcg_specs]}),[thm]) lthy \n                \n      (* Create lhsv-theorems, register as vcg_bb simp-rule *)\n      val lhsv_thms = IMP2_Modified_Analysis.mk_lhsv_thms lthy def_thm\n      val lhsv_thm_name = Binding.suffix_name \"_lhsv\" binding\n      val lthy = note ((lhsv_thm_name,@{attributes [named_ss vcg_bb]}),lhsv_thms) lthy\n    in\n      lthy\n    end\n\n    fun define_declare binding thm = \n        define_HTmod_const binding thm \n      #> uncurry declare_defined_spec\n        \n\n  end\n\\<close>"], ["", "subsection \\<open>Program Specification Commands\\<close>"], ["", "ML \\<open>structure Simple_Program_Specification \n  = struct\n    fun simple_spec_program_cmd binding partial add_vars params pre_src post_src cmd_src lthy = let\n      val total = not partial\n      \n      open IMP_Annotations\n      \n      val (prog_vars,prog_t) = IMP_Parser.parse_command_at lthy cmd_src\n      \n      val cfg = case params of \n        NONE => { add_vars = add_vars, in_vars=NONE, out_vars=NONE, prog_vars=prog_vars }\n      | SOME (pvs,rvs) => { add_vars = add_vars, in_vars=SOME pvs, out_vars=SOME rvs, prog_vars=prog_vars }\n      \n      val prog_t = read_program cfg lthy prog_t\n      \n      val pre = gen_read_ta Syntax.read_term (mk_pre_reader cfg lthy) pre_src\n      val post = gen_read_ta Syntax.read_term (mk_post_reader cfg lthy) post_src\n      \n      val goal = VCG_Htriple_Syntax.mk_htriple' total @{term \"Map.empty::program\"} (pre,prog_t,post)\n      \n      val goal = HOLogic.mk_Trueprop goal\n\n      fun after_qed thmss lthy = let\n      \n        val param_post = case params of \n          NONE => K I \n        | SOME (pvs,rvs) => Spec_Postprocessing.cnv_body_to_proc pvs rvs\n      \n        val thm = flat thmss \n          |> the_single\n          |> Spec_Postprocessing.cnv_HT'_to_HT lthy\n          |> Spec_Postprocessing.cnv_HT_to_HTmod lthy\n          |> param_post lthy\n          |> Spec_Postprocessing.cnv_HTmod_generalize_penv\n\n        val lthy = Spec_Postprocessing.define_declare binding thm lthy\n      in\n        lthy\n      end\n    \n    in Proof.theorem NONE after_qed [[(goal,[])]] lthy end\n\n  end\n\\<close>"], ["", "ML \\<open>structure Recursive_Program_Specification \n  = struct\n      type proc_spec_src = {    \n        binding:  binding,                   (* name *)\n        params: string list,                 (* parameters *)\n        retvs: string list,                  (* return variables *)\n        addvars: IMP_Syntax.impvar list,     (* additional variables *)\n        pre_src: string,                     (* precondition src *)\n        post_src: string,                    (* postcondition src *)\n        variant_src: string,                 (* variant src *)\n        cmd_src: string * Position.T         (* body src *)\n      }\n  \n      type proc_spec = {    \n        binding:  binding,                   (* name *)\n        params: string list,                 (* parameters *)\n        retvs: string list,                  (* return variables *)\n        addvars: IMP_Syntax.impvar list,     (* additional variables *)\n        pre: term,                           (* precondition src *)\n        post: term,                          (* postcondition src *)\n        variant: term,                       (* variant src *)\n        cmd: term                            (* body src *)\n      }\n      \n          \n      fun check_spec ctxt (spec_src : proc_spec_src) = let\n        open IMP_Annotations\n      \n        val (prog_vars,prog_t) = IMP_Parser.parse_command_at ctxt (#cmd_src spec_src)\n        val cfg = { \n          add_vars = #addvars spec_src, \n          in_vars=SOME (#params spec_src), \n          out_vars=SOME (#retvs spec_src), \n          prog_vars=prog_vars }\n        \n        val prog_t = read_program cfg ctxt prog_t\n        \n        val pre = gen_read_ta Syntax.read_term (mk_pre_reader cfg ctxt) (#pre_src spec_src)\n        val post = gen_read_ta Syntax.read_term (mk_post_reader cfg ctxt) (#post_src spec_src)\n        val variant = gen_read_ta Syntax.read_term (mk_variant_reader cfg ctxt) (#variant_src spec_src)\n        \n      in\n        ({\n          binding = (#binding spec_src),\n          params=(#params spec_src),\n          retvs=(#retvs spec_src),\n          addvars=(#addvars spec_src),\n          pre=pre,\n          post=post,\n          variant=variant,\n          cmd=prog_t\n        })\n      end\n  \n  \n      fun adjust_thm params retvs ctxt = let\n        open Spec_Postprocessing\n      in\n        I\n        #> cnv_HT'_to_HT ctxt\n        #> cnv_HT_to_HTmod ctxt\n        #> cnv_body_to_proc params retvs ctxt\n      end\n      \n      fun gen_spec_program_cmd rel_src spec_srcs lthy = let\n      \n        val ctxt = lthy\n      \n        fun trace msg = tracing msg\n      \n        val _ = trace \"(* Check Specification *)\"\n      \n        val rel = the_default @{term \\<open>measure nat\\<close>} (Option.map (Syntax.read_term ctxt) rel_src)\n        val relT = fastype_of rel |> HOLogic.dest_setT |> HOLogic.dest_prodT |> fst\n      \n        val specs = map (check_spec ctxt) spec_srcs\n  \n        val _ = trace \"(* Create dummy procedure environment *)\"\n        (*val ctxt0 = ctxt*)\n        val (pe_var,ctxt) = yield_singleton Proof_Context.add_fixes (@{binding \\<pi>},SOME @{typ program},Mixfix.NoSyn) ctxt\n        val pe_var = Free (pe_var,@{typ program})\n        \n        val _ = trace \"(* Define initial goal *)\"\n        fun mk_theta_entry {variant, pre, cmd, post, ...} = HOLogic.mk_tuple [variant, HOLogic.mk_tuple [pre,cmd,post]]\n        \n        val thetaT = @{typ \"'a \\<Theta>elem_t\"} |> typ_subst_atomic [(@{typ 'a},relT)]\n        val theta = map mk_theta_entry specs |> HOLogic.mk_set thetaT\n        \n        val HT'setC = @{const HT'set ('a)} |> subst_atomic_types [(@{typ 'a},relT)]\n        val goal = HT'setC $ pe_var $ theta\n          |> HOLogic.mk_Trueprop\n        \n        val _ = trace \"(* Start proof *)\"\n        val st = Thm.cterm_of ctxt goal |> Goal.init  \n          \n        val _ = trace \"(* Apply recursion rule, and solve wf-precondition *)\"\n        val crel = Thm.cterm_of ctxt rel\n        val sr_rl = Drule.infer_instantiate' ctxt [SOME crel] @{thm vcg_HT'setI}\n  \n        val st = Det_Goal_Refine.apply1 \"\" (resolve_tac ctxt [sr_rl]) st\n        val st = Det_Goal_Refine.apply1 \"Failed to solve wf-goal\" \n          (SOLVED' (force_tac ctxt ORELSE' SELECT_GOAL (print_tac ctxt \"\"))) st\n  \n        val _ = trace \"(* Explode theta-assumptions *)\"\n        val st = Det_Goal_Refine.apply1 \"\" (REPEAT_ALL_NEW (ematch_tac ctxt @{thms ASSUME_\\<Theta>E})) st\n      \n        (* At this point, we have: \\<And>f\\<^sub>0 s\\<^sub>0. \\<lbrakk> HT' \\<pi> \\<dots>; HT' \\<pi> \\<dots>; \\<dots> \\<rbrakk> \\<Longrightarrow> PROVE_\\<Theta> \\<pi> \\<dots> *)\n        \n        val _ = trace \"(* Join VARs in preconditions *)\"\n        val st = Det_Goal_Refine.apply1 \"\" (Thm_Mapping.map_all_prems_tac join_vars_rl ctxt) st\n        \n        val _ = trace \"(* Wrap premises *)\"\n        fun wrap_thm_rl {params,retvs,...} ctxt thm = adjust_thm params retvs ctxt thm\n        val wrap_thm_rls = map wrap_thm_rl specs \n        val st = Det_Goal_Refine.apply1 \"\" (Thm_Mapping.map_prems_tac wrap_thm_rls ctxt) st\n        \n        val _ = trace \"(* Read wrapped commands to define procedure environment *)\"\n        val cmds = Logic.prems_of_goal (Thm.prop_of st) 1\n          |> map (\n               HOLogic.dest_Trueprop \n            #> IMP2_Modified_Analysis.dest_HT_mods\n            #> #5\n          )\n          \n        val _ = trace \"(* Define procedure environment *)\"\n        fun proc_name_t_of {binding, ...} = HOLogic.mk_string (Binding.name_of binding)\n          \n        val penv_pairs = specs ~~ cmds\n          |> map (apfst proc_name_t_of)\n        \n        val penv = HOLOption.mk_map_list @{typ pname} @{typ com} penv_pairs\n                  \n        val eqn = Logic.mk_equals (pe_var,penv) |> Thm.cterm_of ctxt\n        val (pe_def,ctxt) = yield_singleton (Assumption.add_assms Local_Defs.def_export) eqn ctxt\n  \n        \n        val _ = trace \"(* Add theorem for lhsv\\<pi> \\<pi> *)\"\n        val lhsv_pi_thm = (@{lemma \\<open>\\<And>\\<pi> \\<pi>r. \\<pi>\\<equiv>\\<pi>r \\<Longrightarrow> lhsv\\<pi> \\<pi> = ANALYZE (lhsv\\<pi> \\<pi>r)\\<close> by auto} OF [pe_def])\n          |> vcg_bb_simplify [] ctxt\n          \n        val ctxt = Context.proof_map (Named_Simpsets.add_simp @{named_simpset vcg_bb} lhsv_pi_thm) ctxt\n  \n        val _ = trace \"(* Finish modifies-analysis in HT' assumptions *)\"\n        fun finish_mdf ctxt thm = \n          (@{lemma \\<open>\\<And>\\<pi> vs P c Q. HT_mods \\<pi> vs P c Q \\<Longrightarrow> HT_mods \\<pi> (ANALYZE vs) P c Q\\<close> by auto} OF [thm])\n          |> vcg_bb_simplify [] ctxt\n          \n        val st = Det_Goal_Refine.apply1 \"\" (Thm_Mapping.map_all_prems_tac finish_mdf ctxt) st\n        \n        val _ = trace \"(* Wrap assumptions into calls *)\"\n        (** First, show unfold theorems *)\n        fun mk_unfold_thm (pname,com) = Goal.prove ctxt [] [] \n          (HOLogic.mk_eq (pe_var$pname,HOLOption.mk_Some com) |> HOLogic.mk_Trueprop)\n          (fn {context=ctxt, ...} => ALLGOALS (vcg_bb_simp_tac [pe_def] ctxt))\n        \n        val unfold_thms = map mk_unfold_thm penv_pairs\n                \n        val wrap_call_rls = map (fn ufthm => fn _ => fn htthm => @{thm HT_mods_fold_call} OF [ufthm,htthm]) unfold_thms\n        val st = Det_Goal_Refine.apply1 \"\" (Thm_Mapping.map_prems_tac wrap_call_rls ctxt) st\n  \n        val _ = trace \"(* Focus on goal *)\"\n        val st_before_focus = st val ctxt_before_focus = ctxt\n        val (focus as {context = ctxt, prems, ...},st) = Subgoal.focus ctxt 1 NONE st\n        \n        val _ = trace \"(* Note ht-premises *)\"\n        val (_,ctxt) = Proof_Context.note_thms \"\" \n            ((Binding.name \"rec_rules\",[Named_Theorems.add @{named_theorems vcg_specs}]), \n              [(prems,[])]) ctxt\n        \n        val _ = trace \"(* Prepare user proof *)\"\n        val termss = Thm.prems_of st |> map (fn t => (t,[]))\n        \n        (* --- user proof is logically here --- *)\n        \n        fun after_qed thmss goal_ctxt' = let\n          val thms = flat thmss |> Proof_Context.export goal_ctxt' ctxt\n          val _ = trace \"(* Solve subgoals of st *)\"\n          val st = fold (fn thm => fn st => Thm.implies_elim st thm) thms st (* TODO: Use resolve_tac here? *)\n           \n          val st = singleton (Proof_Context.export ctxt (#context focus)) st\n          \n          val _ = trace \"(* retrofit over focus, and finish goal *)\"\n          val st = Subgoal.retrofit (#context focus) ctxt_before_focus (#params focus) (#asms focus) 1 st st_before_focus \n            |> Det_Goal_Refine.seq_first \"\"\n          val ctxt = ctxt_before_focus  \n            \n          val thm = Goal.finish ctxt st |> Goal.norm_result ctxt\n          \n          val _ = trace \"(* Explode HT'set goal into single HTs *)\"\n          fun explode_HT'set thm = (case try (fn thm => thm RS @{thm HT'setD(1)}) thm of\n            NONE => []\n          | SOME thm' => thm' :: explode_HT'set (thm RS @{thm HT'setD(2)}))\n  \n          val thms = explode_HT'set thm\n                  \n          val _ = trace \"(* Adjust theorems *)\"\n          \n          val thms = thms\n            |> Thm_Mapping.map_thms ctxt wrap_thm_rls\n            |> Thm_Mapping.map_thms ctxt wrap_call_rls\n          \n          val thms = map (fn thm => thm RS @{thm localize_HT_mods}) thms  \n  \n          val _ = trace \"(* Define constants *)\"\n          \n          val ctxt = fold \n            (fn ({binding,...},thm) => Spec_Postprocessing.define_declare binding thm) \n            (specs ~~ thms) ctxt\n            \n        in\n          ctxt\n        end      \n  \n      in Proof.theorem NONE after_qed [termss] ctxt end\n  end\n\\<close>"], ["", "ML \\<open> structure Program_Specification_Parser \n  = struct\n    val parse_param_decls = Args.parens (Parse.enum \",\" Parse.name)\n    \n    val parse_var_decl = Parse.name -- Scan.optional (\\<^keyword>\\<open>[\\<close>--\\<^keyword>\\<open>]\\<close> >> K IMP_Syntax.ARRAY) IMP_Syntax.VAL\n    val parse_var_decls = Scan.optional (\\<^keyword>\\<open>for\\<close> |-- Scan.repeat parse_var_decl) []\n  \n    val parse_returns_clause = Scan.optional (\n      \\<^keyword>\\<open>returns\\<close> |-- (Args.parens (Parse.enum \",\" Parse.name) || Parse.name >> single)\n    ) []\n    \n    val parse_proc_spec = (\n          Parse.binding \n       -- parse_param_decls\n       -- parse_returns_clause\n      --| \\<^keyword>\\<open>assumes\\<close> -- Parse.term \n      --| \\<^keyword>\\<open>ensures\\<close> -- Parse.term \n      --| \\<^keyword>\\<open>variant\\<close> -- Parse.term \n       -- parse_var_decls\n      --| \\<^keyword>\\<open>defines\\<close> -- (Parse.position (Parse.cartouche>>cartouche)) \n      ) >> (fn (((((((binding,params),retvs),pre_src),post_src),variant_src),addvars),cmd_src) => \n        {\n          binding = binding, \n          params=params, \n          retvs=retvs, \n          pre_src=pre_src, \n          post_src=post_src, \n          variant_src=variant_src,\n          addvars=addvars,\n          cmd_src=cmd_src} : Recursive_Program_Specification.proc_spec_src\n      )\n    \n    \n  end\n\\<close>"], ["", "ML \\<open>\n    let\n      open Simple_Program_Specification Recursive_Program_Specification Program_Specification_Parser\n    in\n      \n      Outer_Syntax.local_theory_to_proof \\<^command_keyword>\\<open>program_spec\\<close> \"Define IMP program and prove specification\"\n        ((Args.mode \"partial\" -- Parse.binding \n          --| \\<^keyword>\\<open>assumes\\<close> -- Parse.term \n          --| \\<^keyword>\\<open>ensures\\<close> -- Parse.term \n           -- parse_var_decls\n          --| \\<^keyword>\\<open>defines\\<close> -- (Parse.position (Parse.cartouche>>cartouche)) \n          ) >> (fn (((((partial,bnd),pre_src),post_src),addvars),cmd_src) => \n                  simple_spec_program_cmd bnd partial addvars NONE pre_src post_src cmd_src));\n    \n    \n    Outer_Syntax.local_theory_to_proof \\<^command_keyword>\\<open>procedure_spec\\<close> \"Define IMP procedure and prove specification\"\n      ((Args.mode \"partial\" -- Parse.binding \n         -- parse_param_decls\n         -- parse_returns_clause\n        --| \\<^keyword>\\<open>assumes\\<close> -- Parse.term \n        --| \\<^keyword>\\<open>ensures\\<close> -- Parse.term \n         -- parse_var_decls\n        --| \\<^keyword>\\<open>defines\\<close> -- (Parse.position (Parse.cartouche>>cartouche)) \n        ) >>\n        \n          (fn (((((((partial,bnd),params),retvs),pre_src),post_src),addvars),cmd_src) => \n                simple_spec_program_cmd bnd partial addvars (SOME (params,retvs)) pre_src post_src cmd_src\n             )\n         );\n          \n      Outer_Syntax.local_theory_to_proof \\<^command_keyword>\\<open>recursive_spec\\<close> \"Define IMP procedure and prove specification\"\n        (    Scan.option (\\<^keyword>\\<open>relation\\<close> |-- Parse.term)\n          -- Parse.and_list1 parse_proc_spec \n          >> (fn (rel,specs) => gen_spec_program_cmd rel specs))\n        \n    end\n  \\<close>"], ["", "end"]]}