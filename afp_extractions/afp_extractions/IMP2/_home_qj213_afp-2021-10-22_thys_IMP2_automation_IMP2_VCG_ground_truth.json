{"file_name": "/home/qj213/afp-2021-10-22/thys/IMP2/automation/IMP2_VCG.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IMP2", "problem_names": ["lemma HT'_I[vcg_preprocess_rules]:\n    assumes \"\\<And>\\<ss>\\<^sub>0. \\<lbrakk> P \\<ss>\\<^sub>0 \\<rbrakk> \\<Longrightarrow> wp \\<pi> (c \\<ss>\\<^sub>0) (Q \\<ss>\\<^sub>0) \\<ss>\\<^sub>0\"\n    shows \"HT' \\<pi> P c Q\"", "lemma HT'_partial_I[vcg_preprocess_rules]:\n    assumes \"\\<And>\\<ss>\\<^sub>0. \\<lbrakk> P \\<ss>\\<^sub>0 \\<rbrakk> \\<Longrightarrow> wlp \\<pi> (c \\<ss>\\<^sub>0) (Q \\<ss>\\<^sub>0) \\<ss>\\<^sub>0\"\n    shows \"HT'_partial \\<pi> P c Q\"", "lemmas [vcg_preprocess_rules] = allI impI conjI", "lemma move_goal_indication_to_front[simp, named_ss vcg_bb]: \n    \"NO_MATCH (\\<paragraph>x) P \\<Longrightarrow> (P\\<Longrightarrow>\\<paragraph>n\\<Longrightarrow>PROP Q) \\<equiv> (\\<paragraph>n \\<Longrightarrow> P \\<Longrightarrow> PROP Q)\"", "lemma vcg_wlp_modularity_rl[vcg_frame_rules]:\n    assumes \"HT_partial_mods \\<pi> mods P c Q\"\n    assumes \"P s\"\n    assumes \"\\<And>s'. \\<lbrakk>modifies mods s' s; Q s s'\\<rbrakk> \\<Longrightarrow> Q' s'\"\n    shows \"wlp \\<pi> (c) (\\<lambda>s'. Q' s') s\"", "lemma vcg_wp_modularity_rl[vcg_frame_rules]:\n    assumes \"HT_mods \\<pi> mods P c Q\"\n    assumes \"P s\"\n    assumes \"\\<And>s'. \\<lbrakk>modifies mods s' s ; Q s s'\\<rbrakk> \\<Longrightarrow>Q' s'\"\n    shows \"wp \\<pi> (c) (\\<lambda>s'. Q' s') s\"", "lemma vcg_wp_wlp_modularity_rl[vcg_frame_rules]:\n    assumes \"HT_mods \\<pi> mods P c Q\"\n    assumes \"P s\"\n    assumes \"\\<And>s'. \\<lbrakk>modifies mods s' s; Q s s'\\<rbrakk> \\<Longrightarrow> Q' s'\"\n    shows \"wlp \\<pi> (c) (\\<lambda>s'. Q' s') s\"", "lemmas [named_ss vcg_bb] = Params_def Inline_def", "lemmas [named_ss vcg_bb] = \n    wp_skip_eq wp_seq_eq wlp_skip_eq wlp_seq_eq", "lemmas [named_ss vcg_bb] = \n    aval.simps bval.simps", "lemma [named_ss vcg_bb]:\n    \"UPD_STATE (s(x:=w)) x v = s(x:=v)\"\n    \"x\\<noteq>y \\<Longrightarrow> UPD_STATE (s(x:=w)) y v = (UPD_STATE s y v)(x:=w)\"  \n    \"NO_MATCH (SS(XX:=VV)) s \\<Longrightarrow> UPD_STATE s x v = s(x:=v)\"", "lemma [named_ss vcg_bb]:\n    \"UPD_STATE_IDX (s(x:=w)) x i v = s(x:=UPD_IDX w i v)\"\n    \"x\\<noteq>y \\<Longrightarrow> UPD_STATE_IDX (s(x:=w)) y i v = (UPD_STATE_IDX s y i v)(x:=w)\"  \n    \"NO_MATCH (SS(XX:=VV)) s \\<Longrightarrow> UPD_STATE_IDX s x i v = s(x:=UPD_IDX (s x) i v)\"", "lemma [named_ss vcg_bb]:  \n    \"UPD_IDX (a(i:=v)) i = UPD_IDX a i\"\n    \"UPD_IDX a i v = (a(i:=v))\"", "lemma vcg_assign_idx_unfolds[named_ss vcg_bb]:\n    \"wlp \\<pi> (x[i] ::= a) Q s = Q (UPD_STATE_IDX s x (aval i s) (aval a s))\"\n    \"wp \\<pi> (x[i] ::= a) Q s = Q (UPD_STATE_IDX s x (aval i s) (aval a s))\"", "lemma vcg_arraycpy_unfolds[named_ss vcg_bb]:\n    \"wlp \\<pi> (x[] ::= a) Q s = Q (UPD_STATE s x (s a))\"\n    \"wp \\<pi> (x[] ::= a) Q s = Q (UPD_STATE s x (s a))\"", "lemma vcg_arrayinit_unfolds[named_ss vcg_bb]:\n    \"wlp \\<pi> (CLEAR x[]) Q s = Q (UPD_STATE s x (\\<lambda>_. 0))\"\n    \"wp \\<pi> (CLEAR x[]) Q s = Q (UPD_STATE s x (\\<lambda>_. 0))\"", "lemma vcg_AssignIdx_retv_wlp_unfold[named_ss vcg_bb]:\n    \"wlp \\<pi> (AssignIdx_retv x i a) Q s = (NAMING_HINT s a x \\<longrightarrow> wlp \\<pi> (x[i]::=V a) Q s)\"", "lemma vcg_AssignIdx_retv_wp_unfold[named_ss vcg_bb]:\n    \"wp \\<pi> (AssignIdx_retv x i a) Q s = (NAMING_HINT s a x \\<longrightarrow> wp \\<pi> (x[i]::=V a) Q s)\"", "lemma vcg_ArrayCpy_retv_wlp_unfold[named_ss vcg_bb]:\n    \"wlp \\<pi> (ArrayCpy_retv x a) Q s = (NAMING_HINT s a x \\<longrightarrow> wlp \\<pi> (x[]::=a) Q s)\"", "lemma vcg_ArrayCpy_retv_wp_unfold[named_ss vcg_bb]:\n    \"wp \\<pi> (ArrayCpy_retv x a) Q s = (NAMING_HINT s a x \\<longrightarrow> wp \\<pi> (x[]::=a) Q s)\"", "lemma naming_hint_impI_simp[named_ss vcg_bb]: \n    \"Trueprop (NAMING_HINT s a x \\<longrightarrow> P) \\<equiv> (NAMING_HINT s a x \\<Longrightarrow> P)\"", "lemmas [named_ss vcg_bb] = \n    wp_scope_eq wlp_scope_eq", "lemma wlp_whileI_modset:\n    fixes c \\<pi>\n    defines [simp]: \"modset \\<equiv> ANALYZE (lhsv \\<pi> c)\"\n    assumes INIT: \"I s\\<^sub>0\"\n    assumes STEP: \"\\<And>s. \\<lbrakk> modifies modset s s\\<^sub>0; I s; bval b s \\<rbrakk> \\<Longrightarrow> wlp \\<pi> c (\\<lambda>s'. I s') s\"\n    assumes FINAL: \"\\<And>s. \\<lbrakk> modifies modset s s\\<^sub>0; I s; \\<not>bval b s \\<rbrakk> \\<Longrightarrow> Q s\"\n    shows \"wlp \\<pi> (WHILE b DO c) Q s\\<^sub>0\"", "lemma wp_whileI_modset:\n    fixes c \\<pi>\n    defines [simp]: \"modset \\<equiv> ANALYZE (lhsv \\<pi> c)\"\n    assumes WF: \"wf R\"\n    assumes INIT: \"I s\\<^sub>0\"\n    assumes STEP: \"\\<And>s. \\<lbrakk> modifies modset s s\\<^sub>0; I s; bval b s \\<rbrakk> \\<Longrightarrow> wp \\<pi> c (\\<lambda>s'. I s' \\<and> (s',s)\\<in>R) s\"\n    assumes FINAL: \"\\<And>s. \\<lbrakk> modifies modset s s\\<^sub>0; I s; \\<not>bval b s \\<rbrakk> \\<Longrightarrow> Q s\"\n    shows \"wp \\<pi> (WHILE b DO c) Q s\\<^sub>0\"", "lemma invar_var_goalI[vcg_comb_rules]:\n    \"invar_var_goal I R v s s'\" if \"\\<paragraph>''Invar pres'' \\<Longrightarrow> I s'\" \"\\<paragraph>''Var pres'' \\<Longrightarrow> (v s',v s)\\<in>R\"", "lemma wp_while_rl[vcg_comb_rules]:\n    assumes \"\\<paragraph>''rel-wf'' \\<Longrightarrow> wf R\"\n    assumes \"\\<paragraph>''invar-initial'' \\<Longrightarrow> I s\\<^sub>0\"\n    assumes \"\\<And>s. \\<lbrakk> modifies modset s s\\<^sub>0; I s; bval b s \\<rbrakk> \n      \\<Longrightarrow> wp \\<pi> c (invar_var_goal I R v s) s\"\n    assumes \"\\<And>s. \\<lbrakk> \\<paragraph>''invar-post''; modifies modset s s\\<^sub>0; I s; \\<not>bval b s \\<rbrakk> \\<Longrightarrow> Q s\"\n    assumes [simp]: \"modset = ANALYZE (lhsv \\<pi> c)\"\n    shows \"wp \\<pi> (WHILE_annotRVI R v I b c) Q s\\<^sub>0\"", "lemma wp_while_rl_dfltR[vcg_comb_rules]: \n    \"wp \\<pi> (WHILE_annotRVI (measure nat) v I b c) Q s\\<^sub>0 \\<Longrightarrow> wp \\<pi> (WHILE_annotVI v I b c) Q s\\<^sub>0\"", "lemma wlp_while_rl[vcg_comb_rules]:\n    assumes \"\\<paragraph>''invar-initial'' \\<Longrightarrow> I s\\<^sub>0\"\n    assumes \"\\<And>s. \\<lbrakk> \\<paragraph>''invar-pres''; modifies modset s s\\<^sub>0; I s; bval b s \\<rbrakk> \\<Longrightarrow> wlp \\<pi> c I s\"\n    assumes \"\\<And>s. \\<lbrakk> \\<paragraph>''invar-post''; modifies modset s s\\<^sub>0; I s; \\<not>bval b s \\<rbrakk> \\<Longrightarrow> Q s\"\n    assumes [simp]: \"modset = ANALYZE (lhsv \\<pi> c)\"\n    shows \"wlp \\<pi> (WHILE_annotI I b c) Q s\\<^sub>0\"", "lemma wlp_if_rl[vcg_comb_rules]:\n    assumes \"\\<lbrakk>\\<paragraph>''then''; bval b s\\<rbrakk> \\<Longrightarrow> wlp \\<pi> c\\<^sub>1 Q s\"\n    assumes \"\\<lbrakk>\\<paragraph>''else''; \\<not>bval b s\\<rbrakk> \\<Longrightarrow> wlp \\<pi> c\\<^sub>2 Q s\"\n    shows \"wlp \\<pi> (IF b THEN c\\<^sub>1 ELSE c\\<^sub>2) Q s\"", "lemma wp_if_rl[vcg_comb_rules]:\n    assumes \"\\<lbrakk>\\<paragraph>''then''; bval b s\\<rbrakk> \\<Longrightarrow> wp \\<pi> c\\<^sub>1 Q s\"\n    assumes \"\\<lbrakk>\\<paragraph>''else''; \\<not>bval b s\\<rbrakk> \\<Longrightarrow> wp \\<pi> c\\<^sub>2 Q s\"\n    shows \"wp \\<pi> (IF b THEN c\\<^sub>1 ELSE c\\<^sub>2) Q s\""], "translations": [["", "lemma HT'_I[vcg_preprocess_rules]:\n    assumes \"\\<And>\\<ss>\\<^sub>0. \\<lbrakk> P \\<ss>\\<^sub>0 \\<rbrakk> \\<Longrightarrow> wp \\<pi> (c \\<ss>\\<^sub>0) (Q \\<ss>\\<^sub>0) \\<ss>\\<^sub>0\"\n    shows \"HT' \\<pi> P c Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' \\<pi> P c Q", "using assms"], ["proof (prove)\nusing this:\n  P ?\\<ss>\\<^sub>0 \\<Longrightarrow>\n  wp \\<pi> (c ?\\<ss>\\<^sub>0) (Q ?\\<ss>\\<^sub>0) ?\\<ss>\\<^sub>0\n\ngoal (1 subgoal):\n 1. HT' \\<pi> P c Q", "unfolding BB_PROTECT_def HT'_def"], ["proof (prove)\nusing this:\n  P ?\\<ss>\\<^sub>0 \\<Longrightarrow>\n  wp \\<pi> (c ?\\<ss>\\<^sub>0) (Q ?\\<ss>\\<^sub>0) ?\\<ss>\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<^sub>0.\n       P s\\<^sub>0 \\<longrightarrow>\n       wp \\<pi> (c s\\<^sub>0) (Q s\\<^sub>0) s\\<^sub>0", "by auto"], ["", "lemma HT'_partial_I[vcg_preprocess_rules]:\n    assumes \"\\<And>\\<ss>\\<^sub>0. \\<lbrakk> P \\<ss>\\<^sub>0 \\<rbrakk> \\<Longrightarrow> wlp \\<pi> (c \\<ss>\\<^sub>0) (Q \\<ss>\\<^sub>0) \\<ss>\\<^sub>0\"\n    shows \"HT'_partial \\<pi> P c Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HT'_partial \\<pi> P c Q", "using assms"], ["proof (prove)\nusing this:\n  P ?\\<ss>\\<^sub>0 \\<Longrightarrow>\n  wlp \\<pi> (c ?\\<ss>\\<^sub>0) (Q ?\\<ss>\\<^sub>0) ?\\<ss>\\<^sub>0\n\ngoal (1 subgoal):\n 1. HT'_partial \\<pi> P c Q", "unfolding BB_PROTECT_def HT'_partial_def"], ["proof (prove)\nusing this:\n  P ?\\<ss>\\<^sub>0 \\<Longrightarrow>\n  wlp \\<pi> (c ?\\<ss>\\<^sub>0) (Q ?\\<ss>\\<^sub>0) ?\\<ss>\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<^sub>0.\n       P s\\<^sub>0 \\<longrightarrow>\n       wlp \\<pi> (c s\\<^sub>0) (Q s\\<^sub>0) s\\<^sub>0", "by auto"], ["", "lemmas [vcg_preprocess_rules] = allI impI conjI"], ["", "method i_vcg_preprocess = \n    (intro vcg_preprocess_rules)?"], ["", "subsection \\<open>VC rules\\<close>"], ["", "named_theorems vcg_comb_rules \\<open>VCG rules for Combinators\\<close>"], ["", "subsubsection \\<open>Goal Indication\\<close>"], ["", "text \\<open>A marker to indicate where a goal comes from.\\<close>"], ["", "(* TODO: Noschinski has driven this to the extreme, allowing to generate a \n    complete isar case setup from such annotations. \n    We should adapt (at least parts of) this idea!\n  *)"], ["", "definition GOAL_INDICATION :: \"'a \\<Rightarrow> bool\" (\"\\<paragraph>_\" [1000])\n    where \"GOAL_INDICATION _ \\<equiv> True\""], ["", "lemma move_goal_indication_to_front[simp, named_ss vcg_bb]: \n    \"NO_MATCH (\\<paragraph>x) P \\<Longrightarrow> (P\\<Longrightarrow>\\<paragraph>n\\<Longrightarrow>PROP Q) \\<equiv> (\\<paragraph>n \\<Longrightarrow> P \\<Longrightarrow> PROP Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NO_MATCH \\<paragraph>x P \\<Longrightarrow>\n    (\\<lbrakk>P; \\<paragraph>n\\<rbrakk> \\<Longrightarrow> PROP Q) \\<equiv>\n    (\\<lbrakk>\\<paragraph>n; P\\<rbrakk> \\<Longrightarrow> PROP Q)", "by (rule swap_prems_eq)"], ["", "(* TODO: Would like to use PROP P here, to also move over \n      meta-premises like \\<open>\\<And>x. a\\<Longrightarrow>b\\<close>, but \\<open>NO_MATCH\\<close> requires type! *)"], ["", "subsubsection \\<open>Modularity (Frame) Rules\\<close>"], ["", "text \\<open>Frame rules are only applied if their first assumption can be \n    discharged by a specification rule.\\<close>"], ["", "named_theorems vcg_frame_rules \\<open>Frame rules for VCG Approximation Phase\\<close>"], ["", "lemma vcg_wlp_modularity_rl[vcg_frame_rules]:\n    assumes \"HT_partial_mods \\<pi> mods P c Q\"\n    assumes \"P s\"\n    assumes \"\\<And>s'. \\<lbrakk>modifies mods s' s; Q s s'\\<rbrakk> \\<Longrightarrow> Q' s'\"\n    shows \"wlp \\<pi> (c) (\\<lambda>s'. Q' s') s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> c Q' s", "using vcg_wlp_conseq assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>HT_partial_mods ?\\<pi> ?mods ?P ?c ?Q; ?P ?s;\n   \\<And>s'.\n      \\<lbrakk>modifies ?mods s' ?s; ?Q ?s s'\\<rbrakk>\n      \\<Longrightarrow> ?Q' s'\\<rbrakk>\n  \\<Longrightarrow> wlp ?\\<pi> ?c ?Q' ?s\n  HT_partial_mods \\<pi> mods P c Q\n  P s\n  \\<lbrakk>modifies mods ?s' s; Q s ?s'\\<rbrakk> \\<Longrightarrow> Q' ?s'\n\ngoal (1 subgoal):\n 1. wlp \\<pi> c Q' s", "by metis"], ["", "lemma vcg_wp_modularity_rl[vcg_frame_rules]:\n    assumes \"HT_mods \\<pi> mods P c Q\"\n    assumes \"P s\"\n    assumes \"\\<And>s'. \\<lbrakk>modifies mods s' s ; Q s s'\\<rbrakk> \\<Longrightarrow>Q' s'\"\n    shows \"wp \\<pi> (c) (\\<lambda>s'. Q' s') s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp \\<pi> c Q' s", "using vcg_wp_conseq assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>HT_mods ?\\<pi> ?mods ?P ?c ?Q; ?P ?s;\n   \\<And>s'.\n      \\<lbrakk>modifies ?mods s' ?s; ?Q ?s s'\\<rbrakk>\n      \\<Longrightarrow> ?Q' s'\\<rbrakk>\n  \\<Longrightarrow> wp ?\\<pi> ?c ?Q' ?s\n  HT_mods \\<pi> mods P c Q\n  P s\n  \\<lbrakk>modifies mods ?s' s; Q s ?s'\\<rbrakk> \\<Longrightarrow> Q' ?s'\n\ngoal (1 subgoal):\n 1. wp \\<pi> c Q' s", "by metis"], ["", "lemma vcg_wp_wlp_modularity_rl[vcg_frame_rules]:\n    assumes \"HT_mods \\<pi> mods P c Q\"\n    assumes \"P s\"\n    assumes \"\\<And>s'. \\<lbrakk>modifies mods s' s; Q s s'\\<rbrakk> \\<Longrightarrow> Q' s'\"\n    shows \"wlp \\<pi> (c) (\\<lambda>s'. Q' s') s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> c Q' s", "using vcg_wlp_wp_conseq assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>HT_mods ?\\<pi> ?mods ?P ?c ?Q; ?P ?s;\n   \\<And>s'.\n      \\<lbrakk>modifies ?mods s' ?s; ?Q ?s s'\\<rbrakk>\n      \\<Longrightarrow> ?Q' s'\\<rbrakk>\n  \\<Longrightarrow> wlp ?\\<pi> ?c ?Q' ?s\n  HT_mods \\<pi> mods P c Q\n  P s\n  \\<lbrakk>modifies mods ?s' s; Q s ?s'\\<rbrakk> \\<Longrightarrow> Q' ?s'\n\ngoal (1 subgoal):\n 1. wlp \\<pi> c Q' s", "by metis"], ["", "lemmas [named_ss vcg_bb] = Params_def Inline_def"], ["", "subsubsection \\<open>Skip and Sequential Composition\\<close>"], ["", "text \\<open>Skip and sequential composition are unfolded by the VCG basic simpset\\<close>"], ["", "lemmas [named_ss vcg_bb] = \n    wp_skip_eq wp_seq_eq wlp_skip_eq wlp_seq_eq"], ["", "subsubsection \\<open>Assignments\\<close>"], ["", "text \\<open>Assignments are unfolded, using the UPD_STATE constants with a custom simpset \n    to efficiently handle state updates.\n  \\<close>"], ["", "lemmas [named_ss vcg_bb] = \n    aval.simps bval.simps"], ["", "definition UPD_STATE :: \"state \\<Rightarrow> vname \\<Rightarrow> val \\<Rightarrow> state\" where\n    \"UPD_STATE s x v \\<equiv> s(x:=v)\""], ["", "definition UPD_IDX :: \"val \\<Rightarrow> int \\<Rightarrow> pval \\<Rightarrow> val\" where\n    \"UPD_IDX av i pv \\<equiv> av(i:=pv)\""], ["", "definition UPD_STATE_IDX :: \"state \\<Rightarrow> vname \\<Rightarrow> int \\<Rightarrow> pval \\<Rightarrow> state\" where\n    \"UPD_STATE_IDX s x i v \\<equiv> s(x:=UPD_IDX (s x) i v)\""], ["", "lemma [named_ss vcg_bb]:\n    \"UPD_STATE (s(x:=w)) x v = s(x:=v)\"\n    \"x\\<noteq>y \\<Longrightarrow> UPD_STATE (s(x:=w)) y v = (UPD_STATE s y v)(x:=w)\"  \n    \"NO_MATCH (SS(XX:=VV)) s \\<Longrightarrow> UPD_STATE s x v = s(x:=v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UPD_STATE (s(x := w)) x v = s(x := v) &&&\n    (x \\<noteq> y \\<Longrightarrow>\n     UPD_STATE (s(x := w)) y v = (UPD_STATE s y v)(x := w)) &&&\n    (NO_MATCH (SS(XX := VV)) s \\<Longrightarrow>\n     UPD_STATE s x v = s(x := v))", "by (auto simp: UPD_STATE_def)"], ["", "lemma [named_ss vcg_bb]:\n    \"UPD_STATE_IDX (s(x:=w)) x i v = s(x:=UPD_IDX w i v)\"\n    \"x\\<noteq>y \\<Longrightarrow> UPD_STATE_IDX (s(x:=w)) y i v = (UPD_STATE_IDX s y i v)(x:=w)\"  \n    \"NO_MATCH (SS(XX:=VV)) s \\<Longrightarrow> UPD_STATE_IDX s x i v = s(x:=UPD_IDX (s x) i v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UPD_STATE_IDX (s(x := w)) x i v = s(x := UPD_IDX w i v) &&&\n    (x \\<noteq> y \\<Longrightarrow>\n     UPD_STATE_IDX (s(x := w)) y i v = (UPD_STATE_IDX s y i v)(x := w)) &&&\n    (NO_MATCH (SS(XX := VV)) s \\<Longrightarrow>\n     UPD_STATE_IDX s x i v = s(x := UPD_IDX (s x) i v))", "by (auto simp: UPD_STATE_IDX_def)"], ["", "(* Note (hack): These two rewrite rules exploit inner-to-outer rewrite order\n    to ensure that the first rule is applied first.\n  *)"], ["", "lemma [named_ss vcg_bb]:  \n    \"UPD_IDX (a(i:=v)) i = UPD_IDX a i\"\n    \"UPD_IDX a i v = (a(i:=v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UPD_IDX (a(i := v)) i = UPD_IDX a i &&& UPD_IDX a i v = a(i := v)", "by (auto simp: UPD_IDX_def)"], ["", "lemma vcg_assign_idx_unfolds[named_ss vcg_bb]:\n    \"wlp \\<pi> (x[i] ::= a) Q s = Q (UPD_STATE_IDX s x (aval i s) (aval a s))\"\n    \"wp \\<pi> (x[i] ::= a) Q s = Q (UPD_STATE_IDX s x (aval i s) (aval a s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> (x[i] ::= a) Q s =\n    Q (UPD_STATE_IDX s x (aval i s) (aval a s)) &&&\n    wp \\<pi> (x[i] ::= a) Q s = Q (UPD_STATE_IDX s x (aval i s) (aval a s))", "unfolding UPD_STATE_IDX_def UPD_IDX_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> (x[i] ::= a) Q s = Q (s(x := (s x)(aval i s := aval a s))) &&&\n    wp \\<pi> (x[i] ::= a) Q s = Q (s(x := (s x)(aval i s := aval a s)))", "by (simp_all add: wlp_eq wp_eq)"], ["", "lemma vcg_arraycpy_unfolds[named_ss vcg_bb]:\n    \"wlp \\<pi> (x[] ::= a) Q s = Q (UPD_STATE s x (s a))\"\n    \"wp \\<pi> (x[] ::= a) Q s = Q (UPD_STATE s x (s a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> (x[] ::= a) Q s = Q (UPD_STATE s x (s a)) &&&\n    wp \\<pi> (x[] ::= a) Q s = Q (UPD_STATE s x (s a))", "unfolding UPD_STATE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> (x[] ::= a) Q s = Q (s(x := s a)) &&&\n    wp \\<pi> (x[] ::= a) Q s = Q (s(x := s a))", "by (simp_all add: wlp_eq wp_eq)"], ["", "lemma vcg_arrayinit_unfolds[named_ss vcg_bb]:\n    \"wlp \\<pi> (CLEAR x[]) Q s = Q (UPD_STATE s x (\\<lambda>_. 0))\"\n    \"wp \\<pi> (CLEAR x[]) Q s = Q (UPD_STATE s x (\\<lambda>_. 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> (CLEAR x[]) Q s = Q (UPD_STATE s x (\\<lambda>_. 0)) &&&\n    wp \\<pi> (CLEAR x[]) Q s = Q (UPD_STATE s x (\\<lambda>_. 0))", "unfolding UPD_STATE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> (CLEAR x[]) Q s = Q (s(x := \\<lambda>_. 0)) &&&\n    wp \\<pi> (CLEAR x[]) Q s = Q (s(x := \\<lambda>_. 0))", "by (simp_all add: wlp_eq wp_eq)"], ["", "text \\<open>Special case for procedure return value: \n    Insert a renaming to keep name of original variable\\<close>"], ["", "lemma vcg_AssignIdx_retv_wlp_unfold[named_ss vcg_bb]:\n    \"wlp \\<pi> (AssignIdx_retv x i a) Q s = (NAMING_HINT s a x \\<longrightarrow> wlp \\<pi> (x[i]::=V a) Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> (AssignIdx_retv x i a) Q s =\n    (NAMING_HINT s a x \\<longrightarrow> wlp \\<pi> (x[i] ::= V a) Q s)", "unfolding AssignIdx_retv_def NAMING_HINT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> (x[i] ::= V a) Q s =\n    (True \\<longrightarrow> wlp \\<pi> (x[i] ::= V a) Q s)", "by auto"], ["", "lemma vcg_AssignIdx_retv_wp_unfold[named_ss vcg_bb]:\n    \"wp \\<pi> (AssignIdx_retv x i a) Q s = (NAMING_HINT s a x \\<longrightarrow> wp \\<pi> (x[i]::=V a) Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp \\<pi> (AssignIdx_retv x i a) Q s =\n    (NAMING_HINT s a x \\<longrightarrow> wp \\<pi> (x[i] ::= V a) Q s)", "unfolding AssignIdx_retv_def NAMING_HINT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wp \\<pi> (x[i] ::= V a) Q s =\n    (True \\<longrightarrow> wp \\<pi> (x[i] ::= V a) Q s)", "by auto"], ["", "lemma vcg_ArrayCpy_retv_wlp_unfold[named_ss vcg_bb]:\n    \"wlp \\<pi> (ArrayCpy_retv x a) Q s = (NAMING_HINT s a x \\<longrightarrow> wlp \\<pi> (x[]::=a) Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> (ArrayCpy_retv x a) Q s =\n    (NAMING_HINT s a x \\<longrightarrow> wlp \\<pi> (x[] ::= a) Q s)", "unfolding ArrayCpy_retv_def NAMING_HINT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> (x[] ::= a) Q s =\n    (True \\<longrightarrow> wlp \\<pi> (x[] ::= a) Q s)", "by auto"], ["", "lemma vcg_ArrayCpy_retv_wp_unfold[named_ss vcg_bb]:\n    \"wp \\<pi> (ArrayCpy_retv x a) Q s = (NAMING_HINT s a x \\<longrightarrow> wp \\<pi> (x[]::=a) Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp \\<pi> (ArrayCpy_retv x a) Q s =\n    (NAMING_HINT s a x \\<longrightarrow> wp \\<pi> (x[] ::= a) Q s)", "unfolding ArrayCpy_retv_def NAMING_HINT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wp \\<pi> (x[] ::= a) Q s =\n    (True \\<longrightarrow> wp \\<pi> (x[] ::= a) Q s)", "by auto"], ["", "lemma naming_hint_impI_simp[named_ss vcg_bb]: \n    \"Trueprop (NAMING_HINT s a x \\<longrightarrow> P) \\<equiv> (NAMING_HINT s a x \\<Longrightarrow> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NAMING_HINT s a x \\<longrightarrow> P \\<equiv>\n    (NAMING_HINT s a x \\<Longrightarrow> P)", "by rule auto"], ["", "subsubsection \\<open>Scope\\<close>"], ["", "lemmas [named_ss vcg_bb] = \n    wp_scope_eq wlp_scope_eq"], ["", "subsubsection \\<open>While\\<close>"], ["", "lemma wlp_whileI_modset:\n    fixes c \\<pi>\n    defines [simp]: \"modset \\<equiv> ANALYZE (lhsv \\<pi> c)\"\n    assumes INIT: \"I s\\<^sub>0\"\n    assumes STEP: \"\\<And>s. \\<lbrakk> modifies modset s s\\<^sub>0; I s; bval b s \\<rbrakk> \\<Longrightarrow> wlp \\<pi> c (\\<lambda>s'. I s') s\"\n    assumes FINAL: \"\\<And>s. \\<lbrakk> modifies modset s s\\<^sub>0; I s; \\<not>bval b s \\<rbrakk> \\<Longrightarrow> Q s\"\n    shows \"wlp \\<pi> (WHILE b DO c) Q s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> (WHILE b DO c) Q s\\<^sub>0", "apply (rule wlp_whileI[where I=\"\\<lambda>s. I s \\<and> modifies modset s s\\<^sub>0\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. I s\\<^sub>0 \\<and> modifies modset s\\<^sub>0 s\\<^sub>0\n 2. \\<And>\\<ss>.\n       \\<lbrakk>I \\<ss> \\<and> modifies modset \\<ss> s\\<^sub>0;\n        bval b \\<ss>\\<rbrakk>\n       \\<Longrightarrow> wlp \\<pi> c\n                          (\\<lambda>s.\n                              I s \\<and> modifies modset s s\\<^sub>0)\n                          \\<ss>\n 3. \\<And>\\<ss>.\n       \\<lbrakk>I \\<ss> \\<and> modifies modset \\<ss> s\\<^sub>0;\n        \\<not> bval b \\<ss>\\<rbrakk>\n       \\<Longrightarrow> Q \\<ss>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. I s\\<^sub>0 \\<and> modifies modset s\\<^sub>0 s\\<^sub>0", "using INIT"], ["proof (prove)\nusing this:\n  I s\\<^sub>0\n\ngoal (1 subgoal):\n 1. I s\\<^sub>0 \\<and> modifies modset s\\<^sub>0 s\\<^sub>0", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<ss>.\n       \\<lbrakk>I \\<ss> \\<and> modifies modset \\<ss> s\\<^sub>0;\n        bval b \\<ss>\\<rbrakk>\n       \\<Longrightarrow> wlp \\<pi> c\n                          (\\<lambda>s.\n                              I s \\<and> modifies modset s s\\<^sub>0)\n                          \\<ss>\n 2. \\<And>\\<ss>.\n       \\<lbrakk>I \\<ss> \\<and> modifies modset \\<ss> s\\<^sub>0;\n        \\<not> bval b \\<ss>\\<rbrakk>\n       \\<Longrightarrow> Q \\<ss>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n     bval b \\<ss>_\\<rbrakk>\n    \\<Longrightarrow> wlp \\<pi> c\n                       (\\<lambda>s. I s \\<and> modifies modset s s\\<^sub>0)\n                       \\<ss>_", "apply (rule wlp_conseq, rule wlp_strengthen_modset, rule STEP)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n     bval b \\<ss>_\\<rbrakk>\n    \\<Longrightarrow> modifies modset \\<ss>_ s\\<^sub>0\n 2. \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n     bval b \\<ss>_\\<rbrakk>\n    \\<Longrightarrow> I \\<ss>_\n 3. \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n     bval b \\<ss>_\\<rbrakk>\n    \\<Longrightarrow> bval b \\<ss>_\n 4. \\<And>s.\n       \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n        bval b \\<ss>_; I s \\<and> modifies (lhsv \\<pi> c) s \\<ss>_\\<rbrakk>\n       \\<Longrightarrow> I s \\<and> modifies modset s s\\<^sub>0", "apply (auto dest: modifies_trans simp: modifies_sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<ss>.\n       \\<lbrakk>I \\<ss> \\<and> modifies modset \\<ss> s\\<^sub>0;\n        \\<not> bval b \\<ss>\\<rbrakk>\n       \\<Longrightarrow> Q \\<ss>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n     \\<not> bval b \\<ss>_\\<rbrakk>\n    \\<Longrightarrow> Q \\<ss>_", "using FINAL"], ["proof (prove)\nusing this:\n  \\<lbrakk>modifies modset ?s s\\<^sub>0; I ?s; \\<not> bval b ?s\\<rbrakk>\n  \\<Longrightarrow> Q ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n     \\<not> bval b \\<ss>_\\<rbrakk>\n    \\<Longrightarrow> Q \\<ss>_", "by (simp add: modifies_sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wp_whileI_modset:\n    fixes c \\<pi>\n    defines [simp]: \"modset \\<equiv> ANALYZE (lhsv \\<pi> c)\"\n    assumes WF: \"wf R\"\n    assumes INIT: \"I s\\<^sub>0\"\n    assumes STEP: \"\\<And>s. \\<lbrakk> modifies modset s s\\<^sub>0; I s; bval b s \\<rbrakk> \\<Longrightarrow> wp \\<pi> c (\\<lambda>s'. I s' \\<and> (s',s)\\<in>R) s\"\n    assumes FINAL: \"\\<And>s. \\<lbrakk> modifies modset s s\\<^sub>0; I s; \\<not>bval b s \\<rbrakk> \\<Longrightarrow> Q s\"\n    shows \"wp \\<pi> (WHILE b DO c) Q s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp \\<pi> (WHILE b DO c) Q s\\<^sub>0", "apply (rule wp_whileI[where I=\"\\<lambda>s. I s \\<and> modifies modset s s\\<^sub>0\" and R=R])"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf R\n 2. I s\\<^sub>0 \\<and> modifies modset s\\<^sub>0 s\\<^sub>0\n 3. \\<And>\\<ss>.\n       \\<lbrakk>I \\<ss> \\<and> modifies modset \\<ss> s\\<^sub>0;\n        bval b \\<ss>\\<rbrakk>\n       \\<Longrightarrow> wp \\<pi> c\n                          (\\<lambda>\\<ss>'.\n                              (I \\<ss>' \\<and>\n                               modifies modset \\<ss>' s\\<^sub>0) \\<and>\n                              (\\<ss>', \\<ss>) \\<in> R)\n                          \\<ss>\n 4. \\<And>\\<ss>.\n       \\<lbrakk>I \\<ss> \\<and> modifies modset \\<ss> s\\<^sub>0;\n        \\<not> bval b \\<ss>\\<rbrakk>\n       \\<Longrightarrow> Q \\<ss>", "apply (rule WF)"], ["proof (prove)\ngoal (3 subgoals):\n 1. I s\\<^sub>0 \\<and> modifies modset s\\<^sub>0 s\\<^sub>0\n 2. \\<And>\\<ss>.\n       \\<lbrakk>I \\<ss> \\<and> modifies modset \\<ss> s\\<^sub>0;\n        bval b \\<ss>\\<rbrakk>\n       \\<Longrightarrow> wp \\<pi> c\n                          (\\<lambda>\\<ss>'.\n                              (I \\<ss>' \\<and>\n                               modifies modset \\<ss>' s\\<^sub>0) \\<and>\n                              (\\<ss>', \\<ss>) \\<in> R)\n                          \\<ss>\n 3. \\<And>\\<ss>.\n       \\<lbrakk>I \\<ss> \\<and> modifies modset \\<ss> s\\<^sub>0;\n        \\<not> bval b \\<ss>\\<rbrakk>\n       \\<Longrightarrow> Q \\<ss>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. I s\\<^sub>0 \\<and> modifies modset s\\<^sub>0 s\\<^sub>0", "using INIT"], ["proof (prove)\nusing this:\n  I s\\<^sub>0\n\ngoal (1 subgoal):\n 1. I s\\<^sub>0 \\<and> modifies modset s\\<^sub>0 s\\<^sub>0", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<ss>.\n       \\<lbrakk>I \\<ss> \\<and> modifies modset \\<ss> s\\<^sub>0;\n        bval b \\<ss>\\<rbrakk>\n       \\<Longrightarrow> wp \\<pi> c\n                          (\\<lambda>\\<ss>'.\n                              (I \\<ss>' \\<and>\n                               modifies modset \\<ss>' s\\<^sub>0) \\<and>\n                              (\\<ss>', \\<ss>) \\<in> R)\n                          \\<ss>\n 2. \\<And>\\<ss>.\n       \\<lbrakk>I \\<ss> \\<and> modifies modset \\<ss> s\\<^sub>0;\n        \\<not> bval b \\<ss>\\<rbrakk>\n       \\<Longrightarrow> Q \\<ss>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n     bval b \\<ss>_\\<rbrakk>\n    \\<Longrightarrow> wp \\<pi> c\n                       (\\<lambda>\\<ss>'.\n                           (I \\<ss>' \\<and>\n                            modifies modset \\<ss>' s\\<^sub>0) \\<and>\n                           (\\<ss>', \\<ss>_) \\<in> R)\n                       \\<ss>_", "apply (rule wp_conseq, rule wp_strengthen_modset, rule STEP)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n     bval b \\<ss>_\\<rbrakk>\n    \\<Longrightarrow> modifies modset \\<ss>_ s\\<^sub>0\n 2. \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n     bval b \\<ss>_\\<rbrakk>\n    \\<Longrightarrow> I \\<ss>_\n 3. \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n     bval b \\<ss>_\\<rbrakk>\n    \\<Longrightarrow> bval b \\<ss>_\n 4. \\<And>s.\n       \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n        bval b \\<ss>_;\n        (I s \\<and> (s, \\<ss>_) \\<in> R) \\<and>\n        modifies (lhsv \\<pi> c) s \\<ss>_\\<rbrakk>\n       \\<Longrightarrow> (I s \\<and> modifies modset s s\\<^sub>0) \\<and>\n                         (s, \\<ss>_) \\<in> R", "apply (auto dest: modifies_trans simp: modifies_sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<ss>.\n       \\<lbrakk>I \\<ss> \\<and> modifies modset \\<ss> s\\<^sub>0;\n        \\<not> bval b \\<ss>\\<rbrakk>\n       \\<Longrightarrow> Q \\<ss>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n     \\<not> bval b \\<ss>_\\<rbrakk>\n    \\<Longrightarrow> Q \\<ss>_", "using FINAL"], ["proof (prove)\nusing this:\n  \\<lbrakk>modifies modset ?s s\\<^sub>0; I ?s; \\<not> bval b ?s\\<rbrakk>\n  \\<Longrightarrow> Q ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<ss>_ \\<and> modifies modset \\<ss>_ s\\<^sub>0;\n     \\<not> bval b \\<ss>_\\<rbrakk>\n    \\<Longrightarrow> Q \\<ss>_", "by (simp add: modifies_sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition invar_var_goal where\n    \"invar_var_goal I R v s s' \\<equiv> I s' \\<and> (v s',v s)\\<in>R\""], ["", "lemma invar_var_goalI[vcg_comb_rules]:\n    \"invar_var_goal I R v s s'\" if \"\\<paragraph>''Invar pres'' \\<Longrightarrow> I s'\" \"\\<paragraph>''Var pres'' \\<Longrightarrow> (v s',v s)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_var_goal I R v s s'", "using that"], ["proof (prove)\nusing this:\n  \\<paragraph>''Invar pres'' \\<Longrightarrow> I s'\n  \\<paragraph>''Var pres'' \\<Longrightarrow> (v s', v s) \\<in> R\n\ngoal (1 subgoal):\n 1. invar_var_goal I R v s s'", "unfolding invar_var_goal_def GOAL_INDICATION_def"], ["proof (prove)\nusing this:\n  True \\<Longrightarrow> I s'\n  True \\<Longrightarrow> (v s', v s) \\<in> R\n\ngoal (1 subgoal):\n 1. I s' \\<and> (v s', v s) \\<in> R", "by auto"], ["", "lemma wp_while_rl[vcg_comb_rules]:\n    assumes \"\\<paragraph>''rel-wf'' \\<Longrightarrow> wf R\"\n    assumes \"\\<paragraph>''invar-initial'' \\<Longrightarrow> I s\\<^sub>0\"\n    assumes \"\\<And>s. \\<lbrakk> modifies modset s s\\<^sub>0; I s; bval b s \\<rbrakk> \n      \\<Longrightarrow> wp \\<pi> c (invar_var_goal I R v s) s\"\n    assumes \"\\<And>s. \\<lbrakk> \\<paragraph>''invar-post''; modifies modset s s\\<^sub>0; I s; \\<not>bval b s \\<rbrakk> \\<Longrightarrow> Q s\"\n    assumes [simp]: \"modset = ANALYZE (lhsv \\<pi> c)\"\n    shows \"wp \\<pi> (WHILE_annotRVI R v I b c) Q s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp \\<pi> (WHILE {R} {v} {I} b DO c) Q s\\<^sub>0", "using wp_whileI_modset[of \"inv_image R v\" I, OF _ assms(2)] assms(1,3,4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf (inv_image R v); \\<paragraph>''invar-initial'';\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv ?\\<pi> ?c)) s s\\<^sub>0; I s;\n       bval ?b s\\<rbrakk>\n      \\<Longrightarrow> wp ?\\<pi> ?c\n                         (\\<lambda>s'.\n                             I s' \\<and> (s', s) \\<in> inv_image R v)\n                         s;\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv ?\\<pi> ?c)) s s\\<^sub>0; I s;\n       \\<not> bval ?b s\\<rbrakk>\n      \\<Longrightarrow> ?Q s\\<rbrakk>\n  \\<Longrightarrow> wp ?\\<pi> (WHILE ?b DO ?c) ?Q s\\<^sub>0\n  \\<paragraph>''rel-wf'' \\<Longrightarrow> wf R\n  \\<lbrakk>modifies modset ?s s\\<^sub>0; I ?s; bval b ?s\\<rbrakk>\n  \\<Longrightarrow> wp \\<pi> c (invar_var_goal I R v ?s) ?s\n  \\<lbrakk>\\<paragraph>''invar-post''; modifies modset ?s s\\<^sub>0; I ?s;\n   \\<not> bval b ?s\\<rbrakk>\n  \\<Longrightarrow> Q ?s\n\ngoal (1 subgoal):\n 1. wp \\<pi> (WHILE {R} {v} {I} b DO c) Q s\\<^sub>0", "unfolding WHILE_annotRVI_def GOAL_INDICATION_def invar_var_goal_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf (inv_image R v); True;\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv ?\\<pi> ?c)) s s\\<^sub>0; I s;\n       bval ?b s\\<rbrakk>\n      \\<Longrightarrow> wp ?\\<pi> ?c\n                         (\\<lambda>s'.\n                             I s' \\<and> (s', s) \\<in> inv_image R v)\n                         s;\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv ?\\<pi> ?c)) s s\\<^sub>0; I s;\n       \\<not> bval ?b s\\<rbrakk>\n      \\<Longrightarrow> ?Q s\\<rbrakk>\n  \\<Longrightarrow> wp ?\\<pi> (WHILE ?b DO ?c) ?Q s\\<^sub>0\n  True \\<Longrightarrow> wf R\n  \\<lbrakk>modifies modset ?s s\\<^sub>0; I ?s; bval b ?s\\<rbrakk>\n  \\<Longrightarrow> wp \\<pi> c\n                     (\\<lambda>s'. I s' \\<and> (v s', v ?s) \\<in> R) ?s\n  \\<lbrakk>True; modifies modset ?s s\\<^sub>0; I ?s;\n   \\<not> bval b ?s\\<rbrakk>\n  \\<Longrightarrow> Q ?s\n\ngoal (1 subgoal):\n 1. wp \\<pi> (WHILE b DO c) Q s\\<^sub>0", "by auto"], ["", "lemma wp_while_rl_dfltR[vcg_comb_rules]: \n    \"wp \\<pi> (WHILE_annotRVI (measure nat) v I b c) Q s\\<^sub>0 \\<Longrightarrow> wp \\<pi> (WHILE_annotVI v I b c) Q s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp \\<pi> (WHILE {measure nat} {v} {I} b DO c) Q\n     s\\<^sub>0 \\<Longrightarrow>\n    wp \\<pi> (WHILE {v} {I} b DO c) Q s\\<^sub>0", "unfolding WHILE_annotRVI_def WHILE_annotVI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wp \\<pi> (WHILE b DO c) Q s\\<^sub>0 \\<Longrightarrow>\n    wp \\<pi> (WHILE b DO c) Q s\\<^sub>0", "by auto"], ["", "lemma wlp_while_rl[vcg_comb_rules]:\n    assumes \"\\<paragraph>''invar-initial'' \\<Longrightarrow> I s\\<^sub>0\"\n    assumes \"\\<And>s. \\<lbrakk> \\<paragraph>''invar-pres''; modifies modset s s\\<^sub>0; I s; bval b s \\<rbrakk> \\<Longrightarrow> wlp \\<pi> c I s\"\n    assumes \"\\<And>s. \\<lbrakk> \\<paragraph>''invar-post''; modifies modset s s\\<^sub>0; I s; \\<not>bval b s \\<rbrakk> \\<Longrightarrow> Q s\"\n    assumes [simp]: \"modset = ANALYZE (lhsv \\<pi> c)\"\n    shows \"wlp \\<pi> (WHILE_annotI I b c) Q s\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> (WHILE {I} b DO c) Q s\\<^sub>0", "using wlp_whileI_modset[of I, OF _ assms(2)] assms(1,3,4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?s\\<^sub>0;\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv \\<pi> c)) s ?s\\<^sub>0; I s;\n       bval ?b s\\<rbrakk>\n      \\<Longrightarrow> \\<paragraph>''invar-pres'';\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv \\<pi> c)) s ?s\\<^sub>0; I s;\n       bval ?b s\\<rbrakk>\n      \\<Longrightarrow> modifies modset s s\\<^sub>0;\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv \\<pi> c)) s ?s\\<^sub>0; I s;\n       bval ?b s\\<rbrakk>\n      \\<Longrightarrow> I s;\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv \\<pi> c)) s ?s\\<^sub>0; I s;\n       bval ?b s\\<rbrakk>\n      \\<Longrightarrow> bval b s;\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv \\<pi> c)) s ?s\\<^sub>0; I s;\n       \\<not> bval ?b s\\<rbrakk>\n      \\<Longrightarrow> ?Q s\\<rbrakk>\n  \\<Longrightarrow> wlp \\<pi> (WHILE ?b DO c) ?Q ?s\\<^sub>0\n  \\<paragraph>''invar-initial'' \\<Longrightarrow> I s\\<^sub>0\n  \\<lbrakk>\\<paragraph>''invar-post''; modifies modset ?s s\\<^sub>0; I ?s;\n   \\<not> bval b ?s\\<rbrakk>\n  \\<Longrightarrow> Q ?s\n  modset = ANALYZE (lhsv \\<pi> c)\n\ngoal (1 subgoal):\n 1. wlp \\<pi> (WHILE {I} b DO c) Q s\\<^sub>0", "unfolding WHILE_annotI_def GOAL_INDICATION_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>I ?s\\<^sub>0;\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv \\<pi> c)) s ?s\\<^sub>0; I s;\n       bval ?b s\\<rbrakk>\n      \\<Longrightarrow> True;\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv \\<pi> c)) s ?s\\<^sub>0; I s;\n       bval ?b s\\<rbrakk>\n      \\<Longrightarrow> modifies modset s s\\<^sub>0;\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv \\<pi> c)) s ?s\\<^sub>0; I s;\n       bval ?b s\\<rbrakk>\n      \\<Longrightarrow> I s;\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv \\<pi> c)) s ?s\\<^sub>0; I s;\n       bval ?b s\\<rbrakk>\n      \\<Longrightarrow> bval b s;\n   \\<And>s.\n      \\<lbrakk>modifies (ANALYZE (lhsv \\<pi> c)) s ?s\\<^sub>0; I s;\n       \\<not> bval ?b s\\<rbrakk>\n      \\<Longrightarrow> ?Q s\\<rbrakk>\n  \\<Longrightarrow> wlp \\<pi> (WHILE ?b DO c) ?Q ?s\\<^sub>0\n  True \\<Longrightarrow> I s\\<^sub>0\n  \\<lbrakk>True; modifies modset ?s s\\<^sub>0; I ?s;\n   \\<not> bval b ?s\\<rbrakk>\n  \\<Longrightarrow> Q ?s\n  modset = ANALYZE (lhsv \\<pi> c)\n\ngoal (1 subgoal):\n 1. wlp \\<pi> (WHILE b DO c) Q s\\<^sub>0", "by auto"], ["", "lemma wlp_if_rl[vcg_comb_rules]:\n    assumes \"\\<lbrakk>\\<paragraph>''then''; bval b s\\<rbrakk> \\<Longrightarrow> wlp \\<pi> c\\<^sub>1 Q s\"\n    assumes \"\\<lbrakk>\\<paragraph>''else''; \\<not>bval b s\\<rbrakk> \\<Longrightarrow> wlp \\<pi> c\\<^sub>2 Q s\"\n    shows \"wlp \\<pi> (IF b THEN c\\<^sub>1 ELSE c\\<^sub>2) Q s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wlp \\<pi> (IF b THEN c\\<^sub>1 ELSE c\\<^sub>2) Q s", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<paragraph>''then''; bval b s\\<rbrakk>\n  \\<Longrightarrow> wlp \\<pi> c\\<^sub>1 Q s\n  \\<lbrakk>\\<paragraph>''else''; \\<not> bval b s\\<rbrakk>\n  \\<Longrightarrow> wlp \\<pi> c\\<^sub>2 Q s\n\ngoal (1 subgoal):\n 1. wlp \\<pi> (IF b THEN c\\<^sub>1 ELSE c\\<^sub>2) Q s", "unfolding GOAL_INDICATION_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>True; bval b s\\<rbrakk> \\<Longrightarrow> wlp \\<pi> c\\<^sub>1 Q s\n  \\<lbrakk>True; \\<not> bval b s\\<rbrakk>\n  \\<Longrightarrow> wlp \\<pi> c\\<^sub>2 Q s\n\ngoal (1 subgoal):\n 1. wlp \\<pi> (IF b THEN c\\<^sub>1 ELSE c\\<^sub>2) Q s", "by (simp add: wlp_if_eq)"], ["", "lemma wp_if_rl[vcg_comb_rules]:\n    assumes \"\\<lbrakk>\\<paragraph>''then''; bval b s\\<rbrakk> \\<Longrightarrow> wp \\<pi> c\\<^sub>1 Q s\"\n    assumes \"\\<lbrakk>\\<paragraph>''else''; \\<not>bval b s\\<rbrakk> \\<Longrightarrow> wp \\<pi> c\\<^sub>2 Q s\"\n    shows \"wp \\<pi> (IF b THEN c\\<^sub>1 ELSE c\\<^sub>2) Q s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wp \\<pi> (IF b THEN c\\<^sub>1 ELSE c\\<^sub>2) Q s", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<paragraph>''then''; bval b s\\<rbrakk>\n  \\<Longrightarrow> wp \\<pi> c\\<^sub>1 Q s\n  \\<lbrakk>\\<paragraph>''else''; \\<not> bval b s\\<rbrakk>\n  \\<Longrightarrow> wp \\<pi> c\\<^sub>2 Q s\n\ngoal (1 subgoal):\n 1. wp \\<pi> (IF b THEN c\\<^sub>1 ELSE c\\<^sub>2) Q s", "unfolding GOAL_INDICATION_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>True; bval b s\\<rbrakk> \\<Longrightarrow> wp \\<pi> c\\<^sub>1 Q s\n  \\<lbrakk>True; \\<not> bval b s\\<rbrakk>\n  \\<Longrightarrow> wp \\<pi> c\\<^sub>2 Q s\n\ngoal (1 subgoal):\n 1. wp \\<pi> (IF b THEN c\\<^sub>1 ELSE c\\<^sub>2) Q s", "by (simp add: wp_if_eq)"], ["", "subsection \\<open>VCG Methods\\<close>"], ["", "subsubsection \\<open>Generation\\<close>"], ["", "method i_vcg_step = \n    (rule vcg_comb_rules)\n  | ((rule vcg_frame_rules, rule vcg_specs))\n  | (simp (no_asm_use) named_ss vcg_bb: )"], ["", "method i_vcg_gen = (i_vcg_step; i_vcg_gen)?"], ["", "method i_vcg_rem_annot = simp named_ss vcg_bb: ANNOTATION_def"], ["", "subsubsection \\<open>Postprocessing\\<close>"], ["", "method i_vcg_remove_hints = ((determ \\<open>thin_tac \"modifies _ _ _\"\\<close>)+)?; i_vcg_remove_renamings_tac"], ["", "text \\<open>Postprocessing exposes user annotations completely, and then abstracts over variable names.\\<close>"], ["", "method i_vcg_postprocess =\n    i_vcg_modifies_simp?;\n    i_vcg_apply_renamings_tac?;\n    i_vcg_remove_hints?;\n    (unfold BB_PROTECT_def VAR_def)?;\n    i_vcg_postprocess_vars"], ["", "subsubsection \\<open>Main Method\\<close>"], ["", "method vcg = \n    i_vcg_preprocess; \n    i_vcg_gen; \n    i_vcg_rem_annot?; \n    i_vcg_postprocess"], ["", "method vcg_cs = vcg;(clarsimp?)"], ["", "end"]]}