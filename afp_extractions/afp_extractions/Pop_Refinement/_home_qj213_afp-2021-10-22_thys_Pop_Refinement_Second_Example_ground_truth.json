{"file_name": "/home/qj213/afp-2021-10-22/thys/Pop_Refinement/Second_Example.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pop_Refinement", "problem_names": ["lemma eval_wfe:\n  \"wfe \\<Gamma> e \\<Longrightarrow> match \\<sigma> \\<Gamma> \\<Longrightarrow> eval \\<sigma> e \\<noteq> None\"", "lemma exec_always:\n  \"\\<exists>\\<rho>. s \\<rhd> \\<sigma> \\<leadsto> \\<rho>\"", "lemma exec_wfs_match:\n  \"wfs \\<Gamma> s \\<Longrightarrow> match \\<sigma> \\<Gamma> \\<Longrightarrow> s \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<Longrightarrow> match \\<sigma>' \\<Gamma>\"", "lemma exec_wfs_no_error:\n  \"wfs \\<Gamma> s \\<Longrightarrow> match \\<sigma> \\<Gamma> \\<Longrightarrow> \\<not> (s \\<rhd> \\<sigma> \\<leadsto> None)\"", "lemma exec_wfs_always_match:\n  \"wfs \\<Gamma> s \\<Longrightarrow> match \\<sigma> \\<Gamma> \\<Longrightarrow> \\<exists>\\<sigma>'. s \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and> match \\<sigma>' \\<Gamma>\"", "lemma exec_wfp_no_error:\n  \"wfp p \\<Longrightarrow> \\<sigma> \\<in> states p \\<Longrightarrow> \\<not> (body p \\<rhd> \\<sigma> \\<leadsto> None)\"", "lemma exec_wfp_in_states:\n  \"wfp p \\<Longrightarrow> \\<sigma> \\<in> states p \\<Longrightarrow> body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<Longrightarrow> \\<sigma>' \\<in> states p\"", "lemma exec_wfp_always_in_states:\n  \"wfp p \\<Longrightarrow> \\<sigma> \\<in> states p \\<Longrightarrow> \\<exists>\\<sigma>'. body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and> \\<sigma>' \\<in> states p\"", "lemma spec\\<^sub>0_GNI:\n  \"spec\\<^sub>0 p \\<Longrightarrow> GNI (traces p)\"", "lemma vars\\<^sub>0_correct:\n  \"vars p = vars\\<^sub>0 \\<Longrightarrow> io_vars p\"", "lemma reduce_wf_prog_to_body:\n  \"vars p = vars\\<^sub>0 \\<Longrightarrow> wfp p \\<longleftrightarrow> wfs \\<Gamma>\\<^sub>0 (body p)\"", "lemma low_proc_non0\\<^sub>1_correct:\n  \"vars p = vars\\<^sub>0 \\<Longrightarrow> low_proc_non0\\<^sub>1 p \\<longleftrightarrow> low_proc_non0 p\"", "lemma low_proc_0\\<^sub>1_correct:\n  \"vars p = vars\\<^sub>0 \\<Longrightarrow> low_proc_0\\<^sub>1 p \\<longleftrightarrow> low_proc_0 p\"", "lemma high_proc\\<^sub>1_correct:\n  \"vars p = vars\\<^sub>0 \\<Longrightarrow> high_proc\\<^sub>1 p \\<longleftrightarrow> high_proc p\"", "lemma step_1_correct:\n  \"spec\\<^sub>1 p \\<Longrightarrow> spec\\<^sub>0 p\"", "lemma reduce_wf_body_to_stmts:\n  \"body_split p s\\<^sub>L s\\<^sub>H \\<Longrightarrow> wfs \\<Gamma>\\<^sub>0 (body p) \\<longleftrightarrow> wfs \\<Gamma>\\<^sub>0 s\\<^sub>L \\<and> wfs \\<Gamma>\\<^sub>0 s\\<^sub>H\"", "lemma proc\\<^sub>2_correct:\n  assumes Body: \"body_split p s\\<^sub>L s\\<^sub>H\"\n  assumes WfLow: \"wfs \\<Gamma>\\<^sub>0 s\\<^sub>L\"\n  assumes WfHigh: \"wfs \\<Gamma>\\<^sub>0 s\\<^sub>H\"\n  assumes LowNon0: \"low_proc_non0\\<^sub>2 s\\<^sub>L\"\n  assumes Low0: \"low_proc_0\\<^sub>2 s\\<^sub>L\"\n  assumes LowSame: \"low_proc_no_input_change s\\<^sub>L\"\n  assumes High: \"high_proc\\<^sub>2 s\\<^sub>H\"\n  assumes HighSame: \"high_proc_no_low_output_change s\\<^sub>H\"\n  shows \"low_proc_non0\\<^sub>1 p \\<and> low_proc_0\\<^sub>1 p \\<and> high_proc\\<^sub>1 p\"", "lemma step_2_correct:\n  \"spec\\<^sub>2 p \\<Longrightarrow> spec\\<^sub>1 p\"", "lemma wfs_s\\<^sub>L\\<^sub>0:\n  \"wfs \\<Gamma>\\<^sub>0 s\\<^sub>L\\<^sub>0\"", "lemma low_proc_non0_s\\<^sub>L\\<^sub>0:\n  \"low_proc_non0\\<^sub>2 s\\<^sub>L\\<^sub>0\"", "lemma low_proc_0_s\\<^sub>L\\<^sub>0:\n  \"low_proc_0\\<^sub>2 s\\<^sub>L\\<^sub>0\"", "lemma low_proc_no_input_change_s\\<^sub>L\\<^sub>0:\n  \"low_proc_no_input_change s\\<^sub>L\\<^sub>0\"", "lemma step_3_correct:\n  \"spec\\<^sub>3 p \\<Longrightarrow> spec\\<^sub>2 p\"", "lemma high_proc\\<^sub>4_correct:\n  \"high_proc\\<^sub>4 s\\<^sub>H \\<Longrightarrow> high_proc\\<^sub>2 s\\<^sub>H\"", "lemma step_4_correct:\n  \"spec\\<^sub>4 p \\<Longrightarrow> spec\\<^sub>3 p\"", "lemma wfs_s\\<^sub>H\\<^sub>0:\n  \"wfs \\<Gamma>\\<^sub>0 s\\<^sub>H\\<^sub>0\"", "lemma high_proc\\<^sub>4_s\\<^sub>H\\<^sub>0:\n  \"high_proc\\<^sub>4 s\\<^sub>H\\<^sub>0\"", "lemma high_proc_no_low_output_change_s\\<^sub>H\\<^sub>0:\n  \"high_proc_no_low_output_change s\\<^sub>H\\<^sub>0\"", "lemma step_5_correct:\n  \"spec\\<^sub>5 p \\<Longrightarrow> spec\\<^sub>4 p\"", "lemma step_6_correct:\n  \"spec\\<^sub>6 p \\<Longrightarrow> spec\\<^sub>5 p\"", "lemma p\\<^sub>0_sat_spec\\<^sub>0:\n  \"spec\\<^sub>0 p\\<^sub>0\""], "translations": [["", "lemma eval_wfe:\n  \"wfe \\<Gamma> e \\<Longrightarrow> match \\<sigma> \\<Gamma> \\<Longrightarrow> eval \\<sigma> e \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfe \\<Gamma> e; match \\<sigma> \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> eval \\<sigma> e \\<noteq> None", "by (induct e, auto simp: match_def add_opt_def)"], ["", "text \\<open>Executing a statement in a state yields a new state,\nor an error (@{const None})\nif the evaluation of an expression yields an error\nor if an assignment operates on a variable not in the state.\nNon-determinism is modeled via a relation\nbetween old states and results,\nwhere a result is either a new state or an error.\\<close>"], ["", "inductive exec :: \"stmt \\<Rightarrow> state \\<Rightarrow> state option \\<Rightarrow> bool\"\n  (\"_ \\<rhd> _ \\<leadsto> _\" [50, 50, 50] 50)\nwhere\n  ExecAssignNoVar:\n    \"v \\<notin> dom \\<sigma> \\<Longrightarrow> Assign v e \\<rhd> \\<sigma> \\<leadsto> None\" |\n  ExecAssignEvalError:\n    \"eval \\<sigma> e = None \\<Longrightarrow> Assign v e \\<rhd> \\<sigma> \\<leadsto> None\" |\n  ExecAssignOK: \"\n    v \\<in> dom \\<sigma> \\<Longrightarrow>\n    eval \\<sigma> e = Some u \\<Longrightarrow>\n    Assign v e \\<rhd> \\<sigma> \\<leadsto> Some (\\<sigma>(v \\<mapsto> u))\" |\n  ExecRandomNoVar:\n    \"v \\<notin> dom \\<sigma> \\<Longrightarrow> Random v \\<rhd> \\<sigma> \\<leadsto> None\" |\n  ExecRandomOK:\n    \"v \\<in> dom \\<sigma> \\<Longrightarrow> Random v \\<rhd> \\<sigma> \\<leadsto> Some (\\<sigma>(v \\<mapsto> u))\" |\n  ExecCondEvalError1:\n    \"eval \\<sigma> e\\<^sub>1 = None \\<Longrightarrow> IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> None\" |\n  ExecCondEvalError2:\n    \"eval \\<sigma> e\\<^sub>2 = None \\<Longrightarrow> IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> None\" |\n  ExecCondTrue: \"\n    eval \\<sigma> e\\<^sub>1 = Some u\\<^sub>1 \\<Longrightarrow>\n    eval \\<sigma> e\\<^sub>2 = Some u\\<^sub>2 \\<Longrightarrow>\n    u\\<^sub>1 = u\\<^sub>2 \\<Longrightarrow>\n    s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> \\<rho> \\<Longrightarrow>\n    IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> \\<rho>\" |\n  ExecCondFalse: \"\n    eval \\<sigma> e\\<^sub>1 = Some u\\<^sub>1 \\<Longrightarrow>\n    eval \\<sigma> e\\<^sub>2 = Some u\\<^sub>2 \\<Longrightarrow>\n    u\\<^sub>1 \\<noteq> u\\<^sub>2 \\<Longrightarrow>\n    s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> \\<rho> \\<Longrightarrow>\n    IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> \\<rho>\" |\n  ExecSeqError:\n    \"s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> None \\<Longrightarrow> Seq s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> None\" |\n  ExecSeqOK:\n    \"s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<Longrightarrow> s\\<^sub>2 \\<rhd> \\<sigma>' \\<leadsto> \\<rho> \\<Longrightarrow> Seq s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> \\<rho>\""], ["", "text \\<open>The execution of any statement in any state always yields a result.\\<close>"], ["", "lemma exec_always:\n  \"\\<exists>\\<rho>. s \\<rhd> \\<sigma> \\<leadsto> \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<rho>. s \\<rhd> \\<sigma> \\<leadsto> \\<rho>", "proof (induct s arbitrary: \\<sigma>)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2a \\<sigma>. Ex (exec (Assign x1 x2a) \\<sigma>)\n 2. \\<And>x \\<sigma>. Ex (exec (Random x) \\<sigma>)\n 3. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (IfEq x1 x2a s1 s2) \\<sigma>)\n 4. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (Seq s1 s2) \\<sigma>)", "case Assign"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>x1 x2a \\<sigma>. Ex (exec (Assign x1 x2a) \\<sigma>)\n 2. \\<And>x \\<sigma>. Ex (exec (Random x) \\<sigma>)\n 3. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (IfEq x1 x2a s1 s2) \\<sigma>)\n 4. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (Seq s1 s2) \\<sigma>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. Assign x1_ x2a_ \\<rhd> \\<sigma> \\<leadsto> a", "by (metis\n    ExecAssignEvalError ExecAssignNoVar ExecAssignOK option.exhaust)"], ["proof (state)\nthis:\n  \\<exists>a. Assign x1_ x2a_ \\<rhd> \\<sigma> \\<leadsto> a\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma>. Ex (exec (Random x) \\<sigma>)\n 2. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (IfEq x1 x2a s1 s2) \\<sigma>)\n 3. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (Seq s1 s2) \\<sigma>)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma>. Ex (exec (Random x) \\<sigma>)\n 2. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (IfEq x1 x2a s1 s2) \\<sigma>)\n 3. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (Seq s1 s2) \\<sigma>)", "case Random"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma>. Ex (exec (Random x) \\<sigma>)\n 2. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (IfEq x1 x2a s1 s2) \\<sigma>)\n 3. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (Seq s1 s2) \\<sigma>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. Random x_ \\<rhd> \\<sigma> \\<leadsto> a", "by (metis ExecRandomNoVar ExecRandomOK)"], ["proof (state)\nthis:\n  \\<exists>a. Random x_ \\<rhd> \\<sigma> \\<leadsto> a\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (IfEq x1 x2a s1 s2) \\<sigma>)\n 2. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (Seq s1 s2) \\<sigma>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (IfEq x1 x2a s1 s2) \\<sigma>)\n 2. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (Seq s1 s2) \\<sigma>)", "case IfEq"], ["proof (state)\nthis:\n  \\<exists>a. s1_ \\<rhd> ?\\<sigma> \\<leadsto> a\n  \\<exists>a. s2_ \\<rhd> ?\\<sigma> \\<leadsto> a\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (IfEq x1 x2a s1 s2) \\<sigma>)\n 2. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (Seq s1 s2) \\<sigma>)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>a. s1_ \\<rhd> ?\\<sigma> \\<leadsto> a\n  \\<exists>a. s2_ \\<rhd> ?\\<sigma> \\<leadsto> a\n\ngoal (1 subgoal):\n 1. \\<exists>a. IfEq x1_ x2a_ s1_ s2_ \\<rhd> \\<sigma> \\<leadsto> a", "by (metis\n    ExecCondEvalError1 ExecCondEvalError2 ExecCondFalse ExecCondTrue\n    option.exhaust)"], ["proof (state)\nthis:\n  \\<exists>a. IfEq x1_ x2a_ s1_ s2_ \\<rhd> \\<sigma> \\<leadsto> a\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (Seq s1 s2) \\<sigma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (Seq s1 s2) \\<sigma>)", "case Seq"], ["proof (state)\nthis:\n  \\<exists>a. s1_ \\<rhd> ?\\<sigma> \\<leadsto> a\n  \\<exists>a. s2_ \\<rhd> ?\\<sigma> \\<leadsto> a\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>. Ex (exec s1 \\<sigma>);\n        \\<And>\\<sigma>. Ex (exec s2 \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Ex (exec (Seq s1 s2) \\<sigma>)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>a. s1_ \\<rhd> ?\\<sigma> \\<leadsto> a\n  \\<exists>a. s2_ \\<rhd> ?\\<sigma> \\<leadsto> a\n\ngoal (1 subgoal):\n 1. \\<exists>a. Seq s1_ s2_ \\<rhd> \\<sigma> \\<leadsto> a", "by (metis ExecSeqError ExecSeqOK option.exhaust)"], ["proof (state)\nthis:\n  \\<exists>a. Seq s1_ s2_ \\<rhd> \\<sigma> \\<leadsto> a\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Executing a well-formed statement in a state that matches the context\nnever yields an error and always yields states that match the context.\\<close>"], ["", "lemma exec_wfs_match:\n  \"wfs \\<Gamma> s \\<Longrightarrow> match \\<sigma> \\<Gamma> \\<Longrightarrow> s \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<Longrightarrow> match \\<sigma>' \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfs \\<Gamma> s; match \\<sigma> \\<Gamma>;\n     s \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "proof (induct s arbitrary: \\<sigma> \\<sigma>')"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>wfs \\<Gamma> (Assign x1 x2a); match \\<sigma> \\<Gamma>;\n        Assign x1 x2a \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>;\n        Random x \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 3. \\<And>x1 x2a s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>;\n        IfEq x1 x2a s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 4. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "case (Assign v e)"], ["proof (state)\nthis:\n  wfs \\<Gamma> (Assign v e)\n  match \\<sigma> \\<Gamma>\n  Assign v e \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>wfs \\<Gamma> (Assign x1 x2a); match \\<sigma> \\<Gamma>;\n        Assign x1 x2a \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>;\n        Random x \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 3. \\<And>x1 x2a s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>;\n        IfEq x1 x2a s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 4. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  wfs \\<Gamma> (Assign v e)\n  match \\<sigma> \\<Gamma>\n  Assign v e \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'", "obtain u\n  where \"eval \\<sigma> e = Some u\"\n  and \"\\<sigma>' = \\<sigma>(v \\<mapsto> u)\""], ["proof (prove)\nusing this:\n  wfs \\<Gamma> (Assign v e)\n  match \\<sigma> \\<Gamma>\n  Assign v e \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>eval \\<sigma> e = Some u;\n         \\<sigma>' = \\<sigma>(v \\<mapsto> u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: exec.cases)"], ["proof (state)\nthis:\n  eval \\<sigma> e = Some u\n  \\<sigma>' = \\<sigma>(v \\<mapsto> u)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2a \\<sigma> \\<sigma>'.\n       \\<lbrakk>wfs \\<Gamma> (Assign x1 x2a); match \\<sigma> \\<Gamma>;\n        Assign x1 x2a \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>;\n        Random x \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 3. \\<And>x1 x2a s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>;\n        IfEq x1 x2a s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 4. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "with Assign"], ["proof (chain)\npicking this:\n  wfs \\<Gamma> (Assign v e)\n  match \\<sigma> \\<Gamma>\n  Assign v e \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  eval \\<sigma> e = Some u\n  \\<sigma>' = \\<sigma>(v \\<mapsto> u)", "show ?case"], ["proof (prove)\nusing this:\n  wfs \\<Gamma> (Assign v e)\n  match \\<sigma> \\<Gamma>\n  Assign v e \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  eval \\<sigma> e = Some u\n  \\<sigma>' = \\<sigma>(v \\<mapsto> u)\n\ngoal (1 subgoal):\n 1. match \\<sigma>' \\<Gamma>", "by (metis\n    domIff dom_fun_upd fun_upd_triv match_def option.distinct(1) wfs.simps(1))"], ["proof (state)\nthis:\n  match \\<sigma>' \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>;\n        Random x \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 2. \\<And>x1 x2a s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>;\n        IfEq x1 x2a s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 3. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>;\n        Random x \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 2. \\<And>x1 x2a s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>;\n        IfEq x1 x2a s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 3. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "case (Random v)"], ["proof (state)\nthis:\n  wfs \\<Gamma> (Random v)\n  match \\<sigma> \\<Gamma>\n  Random v \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>;\n        Random x \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 2. \\<And>x1 x2a s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>;\n        IfEq x1 x2a s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 3. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  wfs \\<Gamma> (Random v)\n  match \\<sigma> \\<Gamma>\n  Random v \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'", "obtain u\n  where \"\\<sigma>' = \\<sigma>(v \\<mapsto> u)\""], ["proof (prove)\nusing this:\n  wfs \\<Gamma> (Random v)\n  match \\<sigma> \\<Gamma>\n  Random v \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<sigma>' = \\<sigma>(v \\<mapsto> u) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: exec.cases)"], ["proof (state)\nthis:\n  \\<sigma>' = \\<sigma>(v \\<mapsto> u)\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>'.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>;\n        Random x \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 2. \\<And>x1 x2a s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>;\n        IfEq x1 x2a s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 3. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "with Random"], ["proof (chain)\npicking this:\n  wfs \\<Gamma> (Random v)\n  match \\<sigma> \\<Gamma>\n  Random v \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  \\<sigma>' = \\<sigma>(v \\<mapsto> u)", "show ?case"], ["proof (prove)\nusing this:\n  wfs \\<Gamma> (Random v)\n  match \\<sigma> \\<Gamma>\n  Random v \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  \\<sigma>' = \\<sigma>(v \\<mapsto> u)\n\ngoal (1 subgoal):\n 1. match \\<sigma>' \\<Gamma>", "by (metis\n    domIff dom_fun_upd fun_upd_triv match_def option.distinct(1) wfs.simps(2))"], ["proof (state)\nthis:\n  match \\<sigma>' \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>;\n        IfEq x1 x2a s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 2. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2a s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>;\n        IfEq x1 x2a s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 2. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "case (IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  wfs \\<Gamma> (IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n  IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1\n   s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>;\n        IfEq x1 x2a s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 2. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "hence \"s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<or> s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  wfs \\<Gamma> (IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n  IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1\n   s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<or>\n    s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'", "by (blast elim: exec.cases)"], ["proof (state)\nthis:\n  s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<or>\n  s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>;\n        IfEq x1 x2a s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>\n 2. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "with IfEq"], ["proof (chain)\npicking this:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  wfs \\<Gamma> (IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n  IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1\n   s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<or>\n  s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  wfs \\<Gamma> (IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n  IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1\n   s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<or>\n  s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. match \\<sigma>' \\<Gamma>", "by (metis wfs.simps(3))"], ["proof (state)\nthis:\n  match \\<sigma>' \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "case (Seq s\\<^sub>1 s\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  wfs \\<Gamma> (Seq s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n  Seq s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  wfs \\<Gamma> (Seq s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n  Seq s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'", "obtain \\<sigma>\\<^sub>i\n  where \"s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\"\n  and \"s\\<^sub>2 \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  wfs \\<Gamma> (Seq s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n  Seq s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>i.\n        \\<lbrakk>s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i;\n         s\\<^sub>2 \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some\n                 \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast elim: exec.cases)"], ["proof (state)\nthis:\n  s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  s\\<^sub>2 \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma> \\<sigma>'.\n                   \\<lbrakk>wfs \\<Gamma> s1; match \\<sigma> \\<Gamma>;\n                    s1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n                   \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        \\<And>\\<sigma> \\<sigma>'.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>;\n            s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n           \\<Longrightarrow> match \\<sigma>' \\<Gamma>;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>;\n        Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> match \\<sigma>' \\<Gamma>", "with Seq"], ["proof (chain)\npicking this:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  wfs \\<Gamma> (Seq s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n  Seq s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  s\\<^sub>2 \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>;\n   s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' \\<Gamma>\n  wfs \\<Gamma> (Seq s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n  Seq s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  s\\<^sub>2 \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. match \\<sigma>' \\<Gamma>", "by (metis wfs.simps(4))"], ["proof (state)\nthis:\n  match \\<sigma>' \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_wfs_no_error:\n  \"wfs \\<Gamma> s \\<Longrightarrow> match \\<sigma> \\<Gamma> \\<Longrightarrow> \\<not> (s \\<rhd> \\<sigma> \\<leadsto> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfs \\<Gamma> s; match \\<sigma> \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<not> s \\<rhd> \\<sigma> \\<leadsto> None", "proof (induct s arbitrary: \\<sigma>)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2a \\<sigma>.\n       \\<lbrakk>wfs \\<Gamma> (Assign x1 x2a);\n        match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Assign x1\n                                 x2a \\<rhd> \\<sigma> \\<leadsto> None\n 2. \\<And>x \\<sigma>.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Random x \\<rhd> \\<sigma> \\<leadsto> None\n 3. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> IfEq x1 x2a s1\n                                 s2 \\<rhd> \\<sigma> \\<leadsto> None\n 4. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "case (Assign v e)"], ["proof (state)\nthis:\n  wfs \\<Gamma> (Assign v e)\n  match \\<sigma> \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2a \\<sigma>.\n       \\<lbrakk>wfs \\<Gamma> (Assign x1 x2a);\n        match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Assign x1\n                                 x2a \\<rhd> \\<sigma> \\<leadsto> None\n 2. \\<And>x \\<sigma>.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Random x \\<rhd> \\<sigma> \\<leadsto> None\n 3. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> IfEq x1 x2a s1\n                                 s2 \\<rhd> \\<sigma> \\<leadsto> None\n 4. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "hence Var: \"v \\<in> dom \\<sigma>\""], ["proof (prove)\nusing this:\n  wfs \\<Gamma> (Assign v e)\n  match \\<sigma> \\<Gamma>\n\ngoal (1 subgoal):\n 1. v \\<in> dom \\<sigma>", "by (auto simp: match_def)"], ["proof (state)\nthis:\n  v \\<in> dom \\<sigma>\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2a \\<sigma>.\n       \\<lbrakk>wfs \\<Gamma> (Assign x1 x2a);\n        match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Assign x1\n                                 x2a \\<rhd> \\<sigma> \\<leadsto> None\n 2. \\<And>x \\<sigma>.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Random x \\<rhd> \\<sigma> \\<leadsto> None\n 3. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> IfEq x1 x2a s1\n                                 s2 \\<rhd> \\<sigma> \\<leadsto> None\n 4. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "from Assign"], ["proof (chain)\npicking this:\n  wfs \\<Gamma> (Assign v e)\n  match \\<sigma> \\<Gamma>", "have \"eval \\<sigma> e \\<noteq> None\""], ["proof (prove)\nusing this:\n  wfs \\<Gamma> (Assign v e)\n  match \\<sigma> \\<Gamma>\n\ngoal (1 subgoal):\n 1. eval \\<sigma> e \\<noteq> None", "by (metis eval_wfe wfs.simps(1))"], ["proof (state)\nthis:\n  eval \\<sigma> e \\<noteq> None\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2a \\<sigma>.\n       \\<lbrakk>wfs \\<Gamma> (Assign x1 x2a);\n        match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Assign x1\n                                 x2a \\<rhd> \\<sigma> \\<leadsto> None\n 2. \\<And>x \\<sigma>.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Random x \\<rhd> \\<sigma> \\<leadsto> None\n 3. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> IfEq x1 x2a s1\n                                 s2 \\<rhd> \\<sigma> \\<leadsto> None\n 4. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "with Var"], ["proof (chain)\npicking this:\n  v \\<in> dom \\<sigma>\n  eval \\<sigma> e \\<noteq> None", "show ?case"], ["proof (prove)\nusing this:\n  v \\<in> dom \\<sigma>\n  eval \\<sigma> e \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<not> Assign v e \\<rhd> \\<sigma> \\<leadsto> None", "by (auto elim: exec.cases)"], ["proof (state)\nthis:\n  \\<not> Assign v e \\<rhd> \\<sigma> \\<leadsto> None\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma>.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Random x \\<rhd> \\<sigma> \\<leadsto> None\n 2. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> IfEq x1 x2a s1\n                                 s2 \\<rhd> \\<sigma> \\<leadsto> None\n 3. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma>.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Random x \\<rhd> \\<sigma> \\<leadsto> None\n 2. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> IfEq x1 x2a s1\n                                 s2 \\<rhd> \\<sigma> \\<leadsto> None\n 3. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "case (Random v)"], ["proof (state)\nthis:\n  wfs \\<Gamma> (Random v)\n  match \\<sigma> \\<Gamma>\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma>.\n       \\<lbrakk>wfs \\<Gamma> (Random x); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Random x \\<rhd> \\<sigma> \\<leadsto> None\n 2. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> IfEq x1 x2a s1\n                                 s2 \\<rhd> \\<sigma> \\<leadsto> None\n 3. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "thus ?case"], ["proof (prove)\nusing this:\n  wfs \\<Gamma> (Random v)\n  match \\<sigma> \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<not> Random v \\<rhd> \\<sigma> \\<leadsto> None", "by (auto simp: match_def elim: exec.cases)"], ["proof (state)\nthis:\n  \\<not> Random v \\<rhd> \\<sigma> \\<leadsto> None\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> IfEq x1 x2a s1\n                                 s2 \\<rhd> \\<sigma> \\<leadsto> None\n 2. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> IfEq x1 x2a s1\n                                 s2 \\<rhd> \\<sigma> \\<leadsto> None\n 2. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "case (IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> None\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> None\n  wfs \\<Gamma> (IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> IfEq x1 x2a s1\n                                 s2 \\<rhd> \\<sigma> \\<leadsto> None\n 2. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> None\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> None\n  wfs \\<Gamma> (IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>", "obtain u\\<^sub>1 u\\<^sub>2\n  where \"eval \\<sigma> e\\<^sub>1 = Some u\\<^sub>1\"\n  and \"eval \\<sigma> e\\<^sub>2 = Some u\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> None\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> None\n  wfs \\<Gamma> (IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>u\\<^sub>1 u\\<^sub>2.\n        \\<lbrakk>eval \\<sigma> e\\<^sub>1 = Some u\\<^sub>1;\n         eval \\<sigma> e\\<^sub>2 = Some u\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis eval_wfe not_Some_eq wfs.simps(3))"], ["proof (state)\nthis:\n  eval \\<sigma> e\\<^sub>1 = Some u\\<^sub>1\n  eval \\<sigma> e\\<^sub>2 = Some u\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2a s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (IfEq x1 x2a s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> IfEq x1 x2a s1\n                                 s2 \\<rhd> \\<sigma> \\<leadsto> None\n 2. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "with IfEq"], ["proof (chain)\npicking this:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> None\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> None\n  wfs \\<Gamma> (IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n  eval \\<sigma> e\\<^sub>1 = Some u\\<^sub>1\n  eval \\<sigma> e\\<^sub>2 = Some u\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> None\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> None\n  wfs \\<Gamma> (IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n  eval \\<sigma> e\\<^sub>1 = Some u\\<^sub>1\n  eval \\<sigma> e\\<^sub>2 = Some u\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<not> IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1\n            s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> None", "by (auto elim: exec.cases)"], ["proof (state)\nthis:\n  \\<not> IfEq e\\<^sub>1 e\\<^sub>2 s\\<^sub>1\n          s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> None\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "case (Seq s\\<^sub>1 s\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> None\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> None\n  wfs \\<Gamma> (Seq s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>wfs \\<Gamma> s1;\n                    match \\<sigma> \\<Gamma>\\<rbrakk>\n                   \\<Longrightarrow> \\<not> s1 \\<rhd> \\<sigma> \\<leadsto> None;\n        \\<And>\\<sigma>.\n           \\<lbrakk>wfs \\<Gamma> s2; match \\<sigma> \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<not> s2 \\<rhd> \\<sigma> \\<leadsto> None;\n        wfs \\<Gamma> (Seq s1 s2); match \\<sigma> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<not> Seq s1 s2 \\<rhd> \\<sigma> \\<leadsto> None", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Seq s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> None", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Seq s\\<^sub>1\n     s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> None \\<Longrightarrow>\n    False", "assume \"Seq s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> None\""], ["proof (state)\nthis:\n  Seq s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> None\n\ngoal (1 subgoal):\n 1. Seq s\\<^sub>1\n     s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> None \\<Longrightarrow>\n    False", "hence \"s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> None \\<or> (\\<exists>\\<sigma>'. s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and> s\\<^sub>2 \\<rhd> \\<sigma>' \\<leadsto> None)\""], ["proof (prove)\nusing this:\n  Seq s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> None\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> None \\<or>\n    (\\<exists>\\<sigma>''.\n        s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'' \\<and>\n        s\\<^sub>2 \\<rhd> \\<sigma>'' \\<leadsto> None)", "by (auto elim: exec.cases)"], ["proof (state)\nthis:\n  s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> None \\<or>\n  (\\<exists>\\<sigma>''.\n      s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'' \\<and>\n      s\\<^sub>2 \\<rhd> \\<sigma>'' \\<leadsto> None)\n\ngoal (1 subgoal):\n 1. Seq s\\<^sub>1\n     s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> None \\<Longrightarrow>\n    False", "with Seq exec_wfs_match"], ["proof (chain)\npicking this:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> None\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> None\n  wfs \\<Gamma> (Seq s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n  \\<lbrakk>wfs ?\\<Gamma> ?s; match ?\\<sigma> ?\\<Gamma>;\n   ?s \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' ?\\<Gamma>\n  s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> None \\<or>\n  (\\<exists>\\<sigma>''.\n      s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'' \\<and>\n      s\\<^sub>2 \\<rhd> \\<sigma>'' \\<leadsto> None)", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>1; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>1 \\<rhd> ?\\<sigma> \\<leadsto> None\n  \\<lbrakk>wfs \\<Gamma> s\\<^sub>2; match ?\\<sigma> \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<not> s\\<^sub>2 \\<rhd> ?\\<sigma> \\<leadsto> None\n  wfs \\<Gamma> (Seq s\\<^sub>1 s\\<^sub>2)\n  match \\<sigma> \\<Gamma>\n  \\<lbrakk>wfs ?\\<Gamma> ?s; match ?\\<sigma> ?\\<Gamma>;\n   ?s \\<rhd> ?\\<sigma> \\<leadsto> Some ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> match ?\\<sigma>' ?\\<Gamma>\n  s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> None \\<or>\n  (\\<exists>\\<sigma>''.\n      s\\<^sub>1 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'' \\<and>\n      s\\<^sub>2 \\<rhd> \\<sigma>'' \\<leadsto> None)\n\ngoal (1 subgoal):\n 1. False", "by (metis wfs.simps(4))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> Seq s\\<^sub>1 s\\<^sub>2 \\<rhd> \\<sigma> \\<leadsto> None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exec_wfs_always_match:\n  \"wfs \\<Gamma> s \\<Longrightarrow> match \\<sigma> \\<Gamma> \\<Longrightarrow> \\<exists>\\<sigma>'. s \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and> match \\<sigma>' \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfs \\<Gamma> s; match \\<sigma> \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>'.\n                         s \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and>\n                         match \\<sigma>' \\<Gamma>", "by (metis exec_always exec_wfs_match exec_wfs_no_error option.exhaust)"], ["", "text \\<open>The states of a program\nare the ones that match the context of the program.\\<close>"], ["", "definition states :: \"prog \\<Rightarrow> state set\"\nwhere \"states p \\<equiv> {\\<sigma>. match \\<sigma> (ctxt p)}\""], ["", "text \\<open>Executing the body of a well-formed program in a state of the program\nalways yields some state of the program, and never an error.\\<close>"], ["", "lemma exec_wfp_no_error:\n  \"wfp p \\<Longrightarrow> \\<sigma> \\<in> states p \\<Longrightarrow> \\<not> (body p \\<rhd> \\<sigma> \\<leadsto> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfp p; \\<sigma> \\<in> states p\\<rbrakk>\n    \\<Longrightarrow> \\<not> body p \\<rhd> \\<sigma> \\<leadsto> None", "by (metis exec_wfs_no_error mem_Collect_eq states_def wfp_def)"], ["", "lemma exec_wfp_in_states:\n  \"wfp p \\<Longrightarrow> \\<sigma> \\<in> states p \\<Longrightarrow> body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<Longrightarrow> \\<sigma>' \\<in> states p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfp p; \\<sigma> \\<in> states p;\n     body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>' \\<in> states p", "by (metis exec_wfs_match mem_Collect_eq states_def wfp_def)"], ["", "lemma exec_wfp_always_in_states:\n  \"wfp p \\<Longrightarrow> \\<sigma> \\<in> states p \\<Longrightarrow> \\<exists>\\<sigma>'. body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and> \\<sigma>' \\<in> states p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfp p; \\<sigma> \\<in> states p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<sigma>'.\n                         body\n                          p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and>\n                         \\<sigma>' \\<in> states p", "by (metis exec_always exec_wfp_in_states exec_wfp_no_error option.exhaust)"], ["", "text \\<open>Program execution can be described\nin terms of the trace formalism in~\\cite{ClarksonSchneiderHyperproperties}.\nEvery possible (non-erroneous) execution of a program\ncan be described by a trace of two states---initial and final.\nIn this definition,\nerroneous executions do not contribute to the traces of a program;\nonly well-formed programs are of interest,\nwhich, as proved above, never execute erroneously.\nDue to non-determinism, there may be traces\nwith the same initial state and different final states.\\<close>"], ["", "record trace =\n  initial :: state\n  final :: state"], ["", "inductive_set traces :: \"prog \\<Rightarrow> trace set\"\nfor p::prog\nwhere [intro!]: \"\n  \\<sigma> \\<in> states p \\<Longrightarrow>\n  body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<Longrightarrow>\n  \\<lparr>initial = \\<sigma>, final = \\<sigma>'\\<rparr> \\<in> traces p\""], ["", "text \\<open>The finite traces of a program could be turned into infinite traces\nby infinitely stuttering the final state,\nobtaining the `executions' defined in~\\cite{ClarksonSchneiderHyperproperties}.\nHowever, such infinite traces carry no additional information\ncompared to the finite traces from which they are derived:\nfor programs in this language,\nthe infinite executions of~\\cite{ClarksonSchneiderHyperproperties}\nare modeled as finite traces of type @{typ trace}.\\<close>"], ["", "section \\<open>Requirement Specification\\<close>"], ["", "text \\<open>\\label{sec:specificationII}\\<close>"], ["", "text \\<open>The target program\nmust process low and high inputs to yield low and high outputs,\naccording to constraints that involve\nboth non-determinism and under-specification,\nwith no information flowing from high inputs to low outputs.%\n\\footnote{As in \\secref{sec:hyper},\n`low' and `high' have the usual security meaning,\ne.g.\\ `low' means `unclassified' and `high' means `classified'.}\\<close>"], ["", "subsection \\<open>Input/Output Variables\\<close>"], ["", "text \\<open>\\label{sec:specII:iovars}\\<close>"], ["", "text \\<open>Even though the language defined in \\secref{sec:targetII}\nhas no explicit features for input and output,\nan external agent could\nwrite values into some variables,\nexecute the program body,\nand read values from some variables.\nThus, variables may be regarded as holding\ninputs (in the initial state) and outputs (in the final state).\\<close>"], ["", "text \\<open>In the target program, four variables are required:\n\\begin{itemize}\n\\item\nA variable @{term \"''lowIn''\"} to hold low inputs.\n\\item\nA variable @{term \"''lowOut''\"} to hold low outputs.\n\\item\nA variable @{term \"''highIn''\"} to hold high inputs.\n\\item\nA variable @{term \"''highOut''\"} to hold high outputs.\n\\end{itemize}\nOther variables are allowed but not required.\\<close>"], ["", "definition io_vars :: \"prog \\<Rightarrow> bool\"\nwhere \"io_vars p \\<equiv> ctxt p \\<supseteq> {''lowIn'', ''lowOut'', ''highIn'', ''highOut''}\""], ["", "subsection \\<open>Low Processing\\<close>"], ["", "text \\<open>\\label{sec:specII:lowproc}\\<close>"], ["", "text \\<open>If the low input is not 0,\nthe low output must be 1 plus the low input.\nThat is,\nfor every possible execution of the program\nwhere the initial state's low input is not 0,\nthe final state's low output must be 1 plus the low input.\nIf there are multiple possible final states for the same initial state\ndue to non-determinism,\nall of them must have the same required low output.\nThus, processing of non-0 low inputs must be deterministic.\\<close>"], ["", "definition low_proc_non0 :: \"prog \\<Rightarrow> bool\"\nwhere \"low_proc_non0 p \\<equiv>\n  \\<forall>\\<sigma> \\<in> states p. \\<forall>\\<sigma>'.\n    the (\\<sigma> ''lowIn'') \\<noteq> 0 \\<and>\n    body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<longrightarrow>\n    the (\\<sigma>' ''lowOut'') = the (\\<sigma> ''lowIn'') + 1\""], ["", "text \\<open>If the low input is 0, the low output must be a random value.\nThat is,\nfor every possible initial state of the program whose low input is 0,\nand for every possible value,\nthere must exist an execution of the program\nwhose final state has that value as low output.\nExecutions corresponding to all possible values must be possible.\nThus, processing of the 0 low input must be non-deterministic.\\<close>"], ["", "definition low_proc_0 :: \"prog \\<Rightarrow> bool\"\nwhere \"low_proc_0 p \\<equiv>\n  \\<forall>\\<sigma> \\<in> states p. \\<forall>u.\n    the (\\<sigma> ''lowIn'') = 0 \\<longrightarrow>\n    (\\<exists>\\<sigma>'. body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and> the (\\<sigma>' ''lowOut'') = u)\""], ["", "subsection \\<open>High Processing\\<close>"], ["", "text \\<open>\\label{sec:specII:highproc}\\<close>"], ["", "text \\<open>The high output must be\nat least as large as the sum of the low and high inputs.\nThat is,\nfor every possible execution of the program,\nthe final state's high output must satisfy the constraint.\nIf there are multiple possible final states for the same initial state\ndue to non-determinism,\nall of them must contain a high output that satisfies the constraint.\nSince different high outputs may satisfy the constraint given the same inputs,\nnot all the possible final states from a given initial state\nmust have the same high output.\nThus, processing of high inputs is under-specified;\nit can be realized deterministically or non-deterministically.\\<close>"], ["", "definition high_proc :: \"prog \\<Rightarrow> bool\"\nwhere \"high_proc p \\<equiv>\n  \\<forall>\\<sigma> \\<in> states p. \\<forall>\\<sigma>'.\n    body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<longrightarrow>\n    the (\\<sigma>' ''highOut'') \\<ge> the (\\<sigma> ''lowIn'') + the (\\<sigma> ''highIn'')\""], ["", "subsection \\<open>All Requirements\\<close>"], ["", "text \\<open>\\label{sec:specII:all}\\<close>"], ["", "text \\<open>Besides satisfying the above requirements on\ninput/output variables, low processing, and high processing,\nthe target program must be well-formed.\\<close>"], ["", "definition spec\\<^sub>0 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>0 p \\<equiv>\n  wfp p \\<and> io_vars p \\<and> low_proc_non0 p \\<and> low_proc_0 p \\<and> high_proc p\""], ["", "subsection \\<open>Generalized Non-Interference\\<close>"], ["", "text \\<open>\\label{sec:specII:GNI}\\<close>"], ["", "text \\<open>The parameters of the GNI formulation in \\secref{sec:hyper}\nare instantiated according to the target program under consideration.\nIn an execution of the program:\n\\begin{itemize}\n\\item\nThe value of the variable @{term \"''lowIn''\"} in the initial state\nis the low input.\n\\item\nThe value of the variable @{term \"''lowOut''\"} in the final state\nis the low output.\n\\item\nThe value of the variable @{term \"''highIn''\"} in the initial state\nis the high input.\n\\item\nThe value of the variable @{term \"''highOut''\"} in the final state\nis the high output.\n\\end{itemize}\\<close>"], ["", "definition low_in :: \"trace \\<Rightarrow> nat\"\nwhere \"low_in \\<tau> \\<equiv> the (initial \\<tau> ''lowIn'')\""], ["", "definition low_out :: \"trace \\<Rightarrow> nat\"\nwhere \"low_out \\<tau> \\<equiv> the (final \\<tau> ''lowOut'')\""], ["", "definition high_in :: \"trace \\<Rightarrow> nat\"\nwhere \"high_in \\<tau> \\<equiv> the (initial \\<tau> ''highIn'')\""], ["", "definition high_out :: \"trace \\<Rightarrow> nat\"\nwhere \"high_out \\<tau> \\<equiv> the (final \\<tau> ''highOut'')\""], ["", "interpretation\n  Target: generalized_non_interference low_in low_out high_in high_out"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation GNI :: \"trace set \\<Rightarrow> bool\"\nwhere \"GNI \\<equiv> Target.GNI\""], ["", "text \\<open>The requirements in @{const spec\\<^sub>0} imply that\nthe set of traces of the target program satisfies GNI.\\<close>"], ["", "lemma spec\\<^sub>0_GNI:\n  \"spec\\<^sub>0 p \\<Longrightarrow> GNI (traces p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>0 p \\<Longrightarrow> GNI (traces p)", "proof (auto simp: Target.GNI_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>\\<^sub>1 \\<tau>\\<^sub>2.\n       \\<lbrakk>spec\\<^sub>0 p; \\<tau>\\<^sub>1 \\<in> traces p;\n        \\<tau>\\<^sub>2 \\<in> traces p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n                            high_in \\<tau>\\<^sub>3 =\n                            high_in \\<tau>\\<^sub>1 \\<and>\n                            low_in \\<tau>\\<^sub>3 =\n                            low_in \\<tau>\\<^sub>2 \\<and>\n                            low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "assume Spec: \"spec\\<^sub>0 p\"\n  \\<comment> \\<open>Consider a trace @{text \\<tau>\\<^sub>1} and its high input:\\<close>"], ["proof (state)\nthis:\n  spec\\<^sub>0 p\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>\\<^sub>1 \\<tau>\\<^sub>2.\n       \\<lbrakk>spec\\<^sub>0 p; \\<tau>\\<^sub>1 \\<in> traces p;\n        \\<tau>\\<^sub>2 \\<in> traces p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n                            high_in \\<tau>\\<^sub>3 =\n                            high_in \\<tau>\\<^sub>1 \\<and>\n                            low_in \\<tau>\\<^sub>3 =\n                            low_in \\<tau>\\<^sub>2 \\<and>\n                            low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "fix \\<tau>\\<^sub>1::trace"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>\\<^sub>1 \\<tau>\\<^sub>2.\n       \\<lbrakk>spec\\<^sub>0 p; \\<tau>\\<^sub>1 \\<in> traces p;\n        \\<tau>\\<^sub>2 \\<in> traces p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n                            high_in \\<tau>\\<^sub>3 =\n                            high_in \\<tau>\\<^sub>1 \\<and>\n                            low_in \\<tau>\\<^sub>3 =\n                            low_in \\<tau>\\<^sub>2 \\<and>\n                            low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "define highIn where \"highIn = high_in \\<tau>\\<^sub>1\"\n  \\<comment> \\<open>Consider a trace @{text \\<tau>\\<^sub>2},\n        its low input and output,\n        and its states:\\<close>"], ["proof (state)\nthis:\n  highIn = high_in \\<tau>\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>\\<^sub>1 \\<tau>\\<^sub>2.\n       \\<lbrakk>spec\\<^sub>0 p; \\<tau>\\<^sub>1 \\<in> traces p;\n        \\<tau>\\<^sub>2 \\<in> traces p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n                            high_in \\<tau>\\<^sub>3 =\n                            high_in \\<tau>\\<^sub>1 \\<and>\n                            low_in \\<tau>\\<^sub>3 =\n                            low_in \\<tau>\\<^sub>2 \\<and>\n                            low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "fix \\<tau>\\<^sub>2::trace"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>\\<^sub>1 \\<tau>\\<^sub>2.\n       \\<lbrakk>spec\\<^sub>0 p; \\<tau>\\<^sub>1 \\<in> traces p;\n        \\<tau>\\<^sub>2 \\<in> traces p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n                            high_in \\<tau>\\<^sub>3 =\n                            high_in \\<tau>\\<^sub>1 \\<and>\n                            low_in \\<tau>\\<^sub>3 =\n                            low_in \\<tau>\\<^sub>2 \\<and>\n                            low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "define lowIn lowOut \\<sigma>\\<^sub>2 \\<sigma>\\<^sub>2'\n    where \"lowIn = low_in \\<tau>\\<^sub>2\"\n      and \"lowOut = low_out \\<tau>\\<^sub>2\"\n      and \"\\<sigma>\\<^sub>2 = initial \\<tau>\\<^sub>2\"\n      and \"\\<sigma>\\<^sub>2' = final \\<tau>\\<^sub>2\""], ["proof (state)\nthis:\n  lowIn = low_in \\<tau>\\<^sub>2\n  lowOut = low_out \\<tau>\\<^sub>2\n  \\<sigma>\\<^sub>2 = initial \\<tau>\\<^sub>2\n  \\<sigma>\\<^sub>2' = final \\<tau>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>\\<^sub>1 \\<tau>\\<^sub>2.\n       \\<lbrakk>spec\\<^sub>0 p; \\<tau>\\<^sub>1 \\<in> traces p;\n        \\<tau>\\<^sub>2 \\<in> traces p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n                            high_in \\<tau>\\<^sub>3 =\n                            high_in \\<tau>\\<^sub>1 \\<and>\n                            low_in \\<tau>\\<^sub>3 =\n                            low_in \\<tau>\\<^sub>2 \\<and>\n                            low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "assume \"\\<tau>\\<^sub>2 \\<in> traces p\""], ["proof (state)\nthis:\n  \\<tau>\\<^sub>2 \\<in> traces p\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>\\<^sub>1 \\<tau>\\<^sub>2.\n       \\<lbrakk>spec\\<^sub>0 p; \\<tau>\\<^sub>1 \\<in> traces p;\n        \\<tau>\\<^sub>2 \\<in> traces p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n                            high_in \\<tau>\\<^sub>3 =\n                            high_in \\<tau>\\<^sub>1 \\<and>\n                            low_in \\<tau>\\<^sub>3 =\n                            low_in \\<tau>\\<^sub>2 \\<and>\n                            low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "hence Exec2: \"body p \\<rhd> \\<sigma>\\<^sub>2 \\<leadsto> Some \\<sigma>\\<^sub>2'\"\n  and State2: \"\\<sigma>\\<^sub>2 \\<in> states p\""], ["proof (prove)\nusing this:\n  \\<tau>\\<^sub>2 \\<in> traces p\n\ngoal (1 subgoal):\n 1. body p \\<rhd> \\<sigma>\\<^sub>2 \\<leadsto> Some \\<sigma>\\<^sub>2' &&&\n    \\<sigma>\\<^sub>2 \\<in> states p", "by (auto simp: \\<sigma>\\<^sub>2_def \\<sigma>\\<^sub>2'_def elim: traces.cases)\n  \\<comment> \\<open>Construct the initial state of the witness trace @{text \\<tau>\\<^sub>3}:\\<close>"], ["proof (state)\nthis:\n  body p \\<rhd> \\<sigma>\\<^sub>2 \\<leadsto> Some \\<sigma>\\<^sub>2'\n  \\<sigma>\\<^sub>2 \\<in> states p\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>\\<^sub>1 \\<tau>\\<^sub>2.\n       \\<lbrakk>spec\\<^sub>0 p; \\<tau>\\<^sub>1 \\<in> traces p;\n        \\<tau>\\<^sub>2 \\<in> traces p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n                            high_in \\<tau>\\<^sub>3 =\n                            high_in \\<tau>\\<^sub>1 \\<and>\n                            low_in \\<tau>\\<^sub>3 =\n                            low_in \\<tau>\\<^sub>2 \\<and>\n                            low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "define \\<sigma>\\<^sub>3 where \"\\<sigma>\\<^sub>3 = \\<sigma>\\<^sub>2 (''highIn'' \\<mapsto> highIn)\""], ["proof (state)\nthis:\n  \\<sigma>\\<^sub>3 = \\<sigma>\\<^sub>2(''highIn'' \\<mapsto> highIn)\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>\\<^sub>1 \\<tau>\\<^sub>2.\n       \\<lbrakk>spec\\<^sub>0 p; \\<tau>\\<^sub>1 \\<in> traces p;\n        \\<tau>\\<^sub>2 \\<in> traces p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n                            high_in \\<tau>\\<^sub>3 =\n                            high_in \\<tau>\\<^sub>1 \\<and>\n                            low_in \\<tau>\\<^sub>3 =\n                            low_in \\<tau>\\<^sub>2 \\<and>\n                            low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "hence LowIn3: \"the (\\<sigma>\\<^sub>3 ''lowIn'') = lowIn\"\n  and HighIn3: \"the (\\<sigma>\\<^sub>3 ''highIn'') = highIn\""], ["proof (prove)\nusing this:\n  \\<sigma>\\<^sub>3 = \\<sigma>\\<^sub>2(''highIn'' \\<mapsto> highIn)\n\ngoal (1 subgoal):\n 1. the (\\<sigma>\\<^sub>3 ''lowIn'') = lowIn &&&\n    the (\\<sigma>\\<^sub>3 ''highIn'') = highIn", "by (auto simp: lowIn_def low_in_def \\<sigma>\\<^sub>2_def)"], ["proof (state)\nthis:\n  the (\\<sigma>\\<^sub>3 ''lowIn'') = lowIn\n  the (\\<sigma>\\<^sub>3 ''highIn'') = highIn\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>\\<^sub>1 \\<tau>\\<^sub>2.\n       \\<lbrakk>spec\\<^sub>0 p; \\<tau>\\<^sub>1 \\<in> traces p;\n        \\<tau>\\<^sub>2 \\<in> traces p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n                            high_in \\<tau>\\<^sub>3 =\n                            high_in \\<tau>\\<^sub>1 \\<and>\n                            low_in \\<tau>\\<^sub>3 =\n                            low_in \\<tau>\\<^sub>2 \\<and>\n                            low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "from Spec State2"], ["proof (chain)\npicking this:\n  spec\\<^sub>0 p\n  \\<sigma>\\<^sub>2 \\<in> states p", "have State3: \"\\<sigma>\\<^sub>3 \\<in> states p\""], ["proof (prove)\nusing this:\n  spec\\<^sub>0 p\n  \\<sigma>\\<^sub>2 \\<in> states p\n\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>3 \\<in> states p", "by (auto simp: \\<sigma>\\<^sub>3_def states_def match_def spec\\<^sub>0_def io_vars_def)\n  \\<comment> \\<open>Construct the final state of @{text \\<tau>\\<^sub>3}, and @{text \\<tau>\\<^sub>3},\n        by cases on @{term lowIn}:\\<close>"], ["proof (state)\nthis:\n  \\<sigma>\\<^sub>3 \\<in> states p\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>\\<^sub>1 \\<tau>\\<^sub>2.\n       \\<lbrakk>spec\\<^sub>0 p; \\<tau>\\<^sub>1 \\<in> traces p;\n        \\<tau>\\<^sub>2 \\<in> traces p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n                            high_in \\<tau>\\<^sub>3 =\n                            high_in \\<tau>\\<^sub>1 \\<and>\n                            low_in \\<tau>\\<^sub>3 =\n                            low_in \\<tau>\\<^sub>2 \\<and>\n                            low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "show\n    \"\\<exists>\\<tau>\\<^sub>3 \\<in> traces p.\n      high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n      low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n      low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n       high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n       low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n       low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "proof (cases lowIn)"], ["proof (state)\ngoal (2 subgoals):\n 1. lowIn = 0 \\<Longrightarrow>\n    \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n       high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n       low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n       low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\n 2. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "case 0\n    \\<comment> \\<open>Use as final state the one required by @{term low_proc_0}:\\<close>"], ["proof (state)\nthis:\n  lowIn = 0\n\ngoal (2 subgoals):\n 1. lowIn = 0 \\<Longrightarrow>\n    \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n       high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n       low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n       low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\n 2. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "with Spec State3 LowIn3"], ["proof (chain)\npicking this:\n  spec\\<^sub>0 p\n  \\<sigma>\\<^sub>3 \\<in> states p\n  the (\\<sigma>\\<^sub>3 ''lowIn'') = lowIn\n  lowIn = 0", "obtain \\<sigma>\\<^sub>3'\n    where Exec3: \"body p \\<rhd> \\<sigma>\\<^sub>3 \\<leadsto> Some \\<sigma>\\<^sub>3'\"\n    and LowOut3: \"the (\\<sigma>\\<^sub>3' ''lowOut'') = lowOut\""], ["proof (prove)\nusing this:\n  spec\\<^sub>0 p\n  \\<sigma>\\<^sub>3 \\<in> states p\n  the (\\<sigma>\\<^sub>3 ''lowIn'') = lowIn\n  lowIn = 0\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>3'.\n        \\<lbrakk>body\n                  p \\<rhd> \\<sigma>\\<^sub>3 \\<leadsto> Some\n                  \\<sigma>\\<^sub>3';\n         the (\\<sigma>\\<^sub>3' ''lowOut'') = lowOut\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: spec\\<^sub>0_def low_proc_0_def)\n    \\<comment> \\<open>Construct @{text \\<tau>\\<^sub>3} from its initial and final states:\\<close>"], ["proof (state)\nthis:\n  body p \\<rhd> \\<sigma>\\<^sub>3 \\<leadsto> Some \\<sigma>\\<^sub>3'\n  the (\\<sigma>\\<^sub>3' ''lowOut'') = lowOut\n\ngoal (2 subgoals):\n 1. lowIn = 0 \\<Longrightarrow>\n    \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n       high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n       low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n       low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\n 2. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "define \\<tau>\\<^sub>3 where \"\\<tau>\\<^sub>3 = \\<lparr>initial = \\<sigma>\\<^sub>3, final = \\<sigma>\\<^sub>3'\\<rparr>\""], ["proof (state)\nthis:\n  \\<tau>\\<^sub>3 =\n  \\<lparr>initial = \\<sigma>\\<^sub>3, final = \\<sigma>\\<^sub>3'\\<rparr>\n\ngoal (2 subgoals):\n 1. lowIn = 0 \\<Longrightarrow>\n    \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n       high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n       low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n       low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\n 2. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "with Exec3 State3"], ["proof (chain)\npicking this:\n  body p \\<rhd> \\<sigma>\\<^sub>3 \\<leadsto> Some \\<sigma>\\<^sub>3'\n  \\<sigma>\\<^sub>3 \\<in> states p\n  \\<tau>\\<^sub>3 =\n  \\<lparr>initial = \\<sigma>\\<^sub>3, final = \\<sigma>\\<^sub>3'\\<rparr>", "have Trace3: \"\\<tau>\\<^sub>3 \\<in> traces p\""], ["proof (prove)\nusing this:\n  body p \\<rhd> \\<sigma>\\<^sub>3 \\<leadsto> Some \\<sigma>\\<^sub>3'\n  \\<sigma>\\<^sub>3 \\<in> states p\n  \\<tau>\\<^sub>3 =\n  \\<lparr>initial = \\<sigma>\\<^sub>3, final = \\<sigma>\\<^sub>3'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<tau>\\<^sub>3 \\<in> traces p", "by auto"], ["proof (state)\nthis:\n  \\<tau>\\<^sub>3 \\<in> traces p\n\ngoal (2 subgoals):\n 1. lowIn = 0 \\<Longrightarrow>\n    \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n       high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n       low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n       low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\n 2. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "have \"high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1\"\n    and \"low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2\"\n    and \"low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 &&&\n    low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 &&&\n    low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "by (auto simp:\n      high_in_def low_in_def low_out_def\n      \\<tau>\\<^sub>3_def \\<sigma>\\<^sub>2_def \\<sigma>\\<^sub>2'_def\n      highIn_def lowIn_def lowOut_def\n      LowIn3 HighIn3 LowOut3)"], ["proof (state)\nthis:\n  high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1\n  low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2\n  low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\n\ngoal (2 subgoals):\n 1. lowIn = 0 \\<Longrightarrow>\n    \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n       high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n       low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n       low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\n 2. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "with Trace3"], ["proof (chain)\npicking this:\n  \\<tau>\\<^sub>3 \\<in> traces p\n  high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1\n  low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2\n  low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau>\\<^sub>3 \\<in> traces p\n  high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1\n  low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2\n  low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n       high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n       low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n       low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n     high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n     low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n     low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "case Suc"], ["proof (state)\nthis:\n  lowIn = Suc nat_\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "hence Not0: \"lowIn \\<noteq> 0\""], ["proof (prove)\nusing this:\n  lowIn = Suc nat_\n\ngoal (1 subgoal):\n 1. lowIn \\<noteq> 0", "by auto\n    \\<comment> \\<open>Derive @{term \\<tau>\\<^sub>2}'s low output from @{term low_proc_non0}:\\<close>"], ["proof (state)\nthis:\n  lowIn \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "with Exec2 State2 Spec"], ["proof (chain)\npicking this:\n  body p \\<rhd> \\<sigma>\\<^sub>2 \\<leadsto> Some \\<sigma>\\<^sub>2'\n  \\<sigma>\\<^sub>2 \\<in> states p\n  spec\\<^sub>0 p\n  lowIn \\<noteq> 0", "have LowOut2: \"lowOut = lowIn + 1\""], ["proof (prove)\nusing this:\n  body p \\<rhd> \\<sigma>\\<^sub>2 \\<leadsto> Some \\<sigma>\\<^sub>2'\n  \\<sigma>\\<^sub>2 \\<in> states p\n  spec\\<^sub>0 p\n  lowIn \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lowOut = lowIn + 1", "by (auto simp:\n      spec\\<^sub>0_def low_proc_non0_def \\<sigma>\\<^sub>2_def \\<sigma>\\<^sub>2'_def\n      low_in_def low_out_def lowIn_def lowOut_def)\n    \\<comment> \\<open>Use any final state for @{text \\<tau>\\<^sub>3}:\\<close>"], ["proof (state)\nthis:\n  lowOut = lowIn + 1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "from Spec"], ["proof (chain)\npicking this:\n  spec\\<^sub>0 p", "have \"wfp p\""], ["proof (prove)\nusing this:\n  spec\\<^sub>0 p\n\ngoal (1 subgoal):\n 1. wfp p", "by (auto simp: spec\\<^sub>0_def)"], ["proof (state)\nthis:\n  wfp p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "with State3"], ["proof (chain)\npicking this:\n  \\<sigma>\\<^sub>3 \\<in> states p\n  wfp p", "obtain \\<sigma>\\<^sub>3'\n    where Exec3: \"body p \\<rhd> \\<sigma>\\<^sub>3 \\<leadsto> Some \\<sigma>\\<^sub>3'\""], ["proof (prove)\nusing this:\n  \\<sigma>\\<^sub>3 \\<in> states p\n  wfp p\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>3'.\n        body\n         p \\<rhd> \\<sigma>\\<^sub>3 \\<leadsto> Some\n         \\<sigma>\\<^sub>3' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis exec_always exec_wfp_no_error not_Some_eq)\n    \\<comment> \\<open>Derive @{text \\<tau>\\<^sub>3}'s low output from @{term low_proc_non0}:\\<close>"], ["proof (state)\nthis:\n  body p \\<rhd> \\<sigma>\\<^sub>3 \\<leadsto> Some \\<sigma>\\<^sub>3'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "with State3 Spec Not0"], ["proof (chain)\npicking this:\n  \\<sigma>\\<^sub>3 \\<in> states p\n  spec\\<^sub>0 p\n  lowIn \\<noteq> 0\n  body p \\<rhd> \\<sigma>\\<^sub>3 \\<leadsto> Some \\<sigma>\\<^sub>3'", "have LowOut3: \"the (\\<sigma>\\<^sub>3' ''lowOut'') = lowIn + 1\""], ["proof (prove)\nusing this:\n  \\<sigma>\\<^sub>3 \\<in> states p\n  spec\\<^sub>0 p\n  lowIn \\<noteq> 0\n  body p \\<rhd> \\<sigma>\\<^sub>3 \\<leadsto> Some \\<sigma>\\<^sub>3'\n\ngoal (1 subgoal):\n 1. the (\\<sigma>\\<^sub>3' ''lowOut'') = lowIn + 1", "by (auto simp: spec\\<^sub>0_def low_proc_non0_def LowIn3)\n    \\<comment> \\<open>Construct @{text \\<tau>\\<^sub>3} from its initial and final states:\\<close>"], ["proof (state)\nthis:\n  the (\\<sigma>\\<^sub>3' ''lowOut'') = lowIn + 1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "define \\<tau>\\<^sub>3 where \"\\<tau>\\<^sub>3 = \\<lparr>initial = \\<sigma>\\<^sub>3, final = \\<sigma>\\<^sub>3'\\<rparr>\""], ["proof (state)\nthis:\n  \\<tau>\\<^sub>3 =\n  \\<lparr>initial = \\<sigma>\\<^sub>3, final = \\<sigma>\\<^sub>3'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "with Exec3 State3"], ["proof (chain)\npicking this:\n  body p \\<rhd> \\<sigma>\\<^sub>3 \\<leadsto> Some \\<sigma>\\<^sub>3'\n  \\<sigma>\\<^sub>3 \\<in> states p\n  \\<tau>\\<^sub>3 =\n  \\<lparr>initial = \\<sigma>\\<^sub>3, final = \\<sigma>\\<^sub>3'\\<rparr>", "have Trace3: \"\\<tau>\\<^sub>3 \\<in> traces p\""], ["proof (prove)\nusing this:\n  body p \\<rhd> \\<sigma>\\<^sub>3 \\<leadsto> Some \\<sigma>\\<^sub>3'\n  \\<sigma>\\<^sub>3 \\<in> states p\n  \\<tau>\\<^sub>3 =\n  \\<lparr>initial = \\<sigma>\\<^sub>3, final = \\<sigma>\\<^sub>3'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<tau>\\<^sub>3 \\<in> traces p", "by auto"], ["proof (state)\nthis:\n  \\<tau>\\<^sub>3 \\<in> traces p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "have \"high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1\"\n    and \"low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2\"\n    and \"low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 &&&\n    low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 &&&\n    low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "by (auto simp:\n      high_in_def low_in_def low_out_def\n      \\<tau>\\<^sub>3_def \\<sigma>\\<^sub>3_def \\<sigma>\\<^sub>2_def\n      LowOut2 LowOut3\n      highIn_def lowOut_def[unfolded low_out_def, symmetric])"], ["proof (state)\nthis:\n  high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1\n  low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2\n  low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       lowIn = Suc nat \\<Longrightarrow>\n       \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n          high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n          low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n          low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "with Trace3"], ["proof (chain)\npicking this:\n  \\<tau>\\<^sub>3 \\<in> traces p\n  high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1\n  low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2\n  low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau>\\<^sub>3 \\<in> traces p\n  high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1\n  low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2\n  low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n       high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n       low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n       low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n     high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n     low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n     low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<tau>\\<^sub>3\\<in>traces p.\n     high_in \\<tau>\\<^sub>3 = high_in \\<tau>\\<^sub>1 \\<and>\n     low_in \\<tau>\\<^sub>3 = low_in \\<tau>\\<^sub>2 \\<and>\n     low_out \\<tau>\\<^sub>3 = low_out \\<tau>\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Since GNI is implied by @{const spec\\<^sub>0}\nand since every pop-refinement of @{const spec\\<^sub>0} implies @{const spec\\<^sub>0},\nGNI is preserved through every pop-refinement of @{const spec\\<^sub>0}.\nPop-refinement differs from the popular notion of refinement\nas inclusion of sets of traces (e.g.~\\cite{AbadiLamportRefinement}),\nwhich does not preserve GNI~\\cite{ClarksonSchneiderHyperproperties}.\\<close>"], ["", "section \\<open>Stepwise Refinement\\<close>"], ["", "text \\<open>\\label{sec:refinementII}\\<close>"], ["", "text \\<open>The remark at the beginning of \\secref{sec:refinementI}\napplies here as well:\nthe following sequence of refinement steps\nmay be overkill for obtaining an implementation of @{const spec\\<^sub>0},\nbut illustrates concepts that should apply to more complex cases.\\<close>"], ["", "subsection \\<open>Step 1\\<close>"], ["", "text \\<open>\\label{sec:refII:stepI}\\<close>"], ["", "text \\<open>The program needs no other variables\nbesides those prescribed by @{const io_vars}.\nThus, @{const io_vars} is refined to a stronger condition\nthat constrains the program to contain exactly those variables,\nin a certain order.\\<close>"], ["", "abbreviation vars\\<^sub>0 :: \"name list\"\nwhere \"vars\\<^sub>0 \\<equiv> [''lowIn'', ''lowOut'', ''highIn'', ''highOut'']\"\n\\<comment> \\<open>The order of the variables in the list is arbitrary.\\<close>"], ["", "lemma vars\\<^sub>0_correct:\n  \"vars p = vars\\<^sub>0 \\<Longrightarrow> io_vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars p = vars\\<^sub>0 \\<Longrightarrow> io_vars p", "by (auto simp: io_vars_def ctxt_def)"], ["", "text \\<open>The refinement of @{const io_vars}\nreduces the well-formedness of the program\nto the well-formedness of the body.\\<close>"], ["", "abbreviation \\<Gamma>\\<^sub>0 :: ctxt\nwhere \"\\<Gamma>\\<^sub>0 \\<equiv> {''lowIn'', ''lowOut'', ''highIn'', ''highOut''}\""], ["", "lemma reduce_wf_prog_to_body:\n  \"vars p = vars\\<^sub>0 \\<Longrightarrow> wfp p \\<longleftrightarrow> wfs \\<Gamma>\\<^sub>0 (body p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars p = vars\\<^sub>0 \\<Longrightarrow>\n    wfp p = wfs \\<Gamma>\\<^sub>0 (body p)", "by (auto simp: wfp_def ctxt_def)"], ["", "text \\<open>The refinement of @{const io_vars}\ninduces a simplification of the processing constraints:\nsince the context of the program is now defined to be @{const \\<Gamma>\\<^sub>0},\nthe @{term \"\\<sigma> \\<in> states p\"} conditions are replaced\nwith @{term \"match \\<sigma> \\<Gamma>\\<^sub>0\"} conditions.\\<close>"], ["", "definition low_proc_non0\\<^sub>1 :: \"prog \\<Rightarrow> bool\"\nwhere \"low_proc_non0\\<^sub>1 p \\<equiv>\n  \\<forall>\\<sigma> \\<sigma>'.\n    match \\<sigma> \\<Gamma>\\<^sub>0 \\<and>\n    the (\\<sigma> ''lowIn'') \\<noteq> 0 \\<and>\n    body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<longrightarrow>\n    the (\\<sigma>' ''lowOut'') = the (\\<sigma> ''lowIn'') + 1\""], ["", "lemma low_proc_non0\\<^sub>1_correct:\n  \"vars p = vars\\<^sub>0 \\<Longrightarrow> low_proc_non0\\<^sub>1 p \\<longleftrightarrow> low_proc_non0 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars p = vars\\<^sub>0 \\<Longrightarrow>\n    low_proc_non0\\<^sub>1 p = low_proc_non0 p", "by (auto simp: low_proc_non0\\<^sub>1_def low_proc_non0_def states_def ctxt_def)"], ["", "definition low_proc_0\\<^sub>1 :: \"prog \\<Rightarrow> bool\"\nwhere \"low_proc_0\\<^sub>1 p \\<equiv>\n  \\<forall>\\<sigma> u.\n    match \\<sigma> \\<Gamma>\\<^sub>0 \\<and>\n    the (\\<sigma> ''lowIn'') = 0 \\<longrightarrow>\n    (\\<exists>\\<sigma>'. body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and> the (\\<sigma>' ''lowOut'') = u)\""], ["", "lemma low_proc_0\\<^sub>1_correct:\n  \"vars p = vars\\<^sub>0 \\<Longrightarrow> low_proc_0\\<^sub>1 p \\<longleftrightarrow> low_proc_0 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars p = vars\\<^sub>0 \\<Longrightarrow>\n    low_proc_0\\<^sub>1 p = low_proc_0 p", "by (auto simp: low_proc_0\\<^sub>1_def low_proc_0_def states_def ctxt_def)"], ["", "definition high_proc\\<^sub>1 :: \"prog \\<Rightarrow> bool\"\nwhere \"high_proc\\<^sub>1 p \\<equiv>\n  \\<forall>\\<sigma> \\<sigma>'.\n    match \\<sigma> \\<Gamma>\\<^sub>0 \\<and>\n    body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<longrightarrow>\n    the (\\<sigma>' ''highOut'') \\<ge> the (\\<sigma> ''lowIn'') + the (\\<sigma> ''highIn'')\""], ["", "lemma high_proc\\<^sub>1_correct:\n  \"vars p = vars\\<^sub>0 \\<Longrightarrow> high_proc\\<^sub>1 p \\<longleftrightarrow> high_proc p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars p = vars\\<^sub>0 \\<Longrightarrow>\n    high_proc\\<^sub>1 p = high_proc p", "by (auto simp: high_proc\\<^sub>1_def high_proc_def states_def ctxt_def)"], ["", "text \\<open>The refinement of @{const spec\\<^sub>0} consists of\nthe refinement of @{const io_vars} and of the simplified constraints.\\<close>"], ["", "definition spec\\<^sub>1 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>1 p \\<equiv>\n  vars p = vars\\<^sub>0 \\<and>\n  wfs \\<Gamma>\\<^sub>0 (body p) \\<and>\n  low_proc_non0\\<^sub>1 p \\<and>\n  low_proc_0\\<^sub>1 p \\<and>\n  high_proc\\<^sub>1 p\""], ["", "lemma step_1_correct:\n  \"spec\\<^sub>1 p \\<Longrightarrow> spec\\<^sub>0 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>1 p \\<Longrightarrow> spec\\<^sub>0 p", "by (auto simp:\n  spec\\<^sub>1_def spec\\<^sub>0_def\n  vars\\<^sub>0_correct\n  reduce_wf_prog_to_body\n  low_proc_non0\\<^sub>1_correct\n  low_proc_0\\<^sub>1_correct\n  high_proc\\<^sub>1_correct)"], ["", "subsection \\<open>Step 2\\<close>"], ["", "text \\<open>\\label{sec:refII:stepII}\\<close>"], ["", "text \\<open>The body of the target program is split\ninto two sequential statements---%\none to compute the low output and one to compute the high output.\\<close>"], ["", "definition body_split :: \"prog \\<Rightarrow> stmt \\<Rightarrow> stmt \\<Rightarrow> bool\"\nwhere \"body_split p s\\<^sub>L s\\<^sub>H \\<equiv> body p = Seq s\\<^sub>L s\\<^sub>H\"\n\\<comment> \\<open>The order of the two statements in the body is arbitrary.\\<close>"], ["", "text \\<open>The splitting reduces the well-formedness of the body\nto the well-formedness of the two statements.\\<close>"], ["", "lemma reduce_wf_body_to_stmts:\n  \"body_split p s\\<^sub>L s\\<^sub>H \\<Longrightarrow> wfs \\<Gamma>\\<^sub>0 (body p) \\<longleftrightarrow> wfs \\<Gamma>\\<^sub>0 s\\<^sub>L \\<and> wfs \\<Gamma>\\<^sub>0 s\\<^sub>H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. body_split p s\\<^sub>L s\\<^sub>H \\<Longrightarrow>\n    wfs \\<Gamma>\\<^sub>0 (body p) =\n    (wfs \\<Gamma>\\<^sub>0 s\\<^sub>L \\<and> wfs \\<Gamma>\\<^sub>0 s\\<^sub>H)", "by (auto simp: body_split_def)"], ["", "text \\<open>The processing predicates over programs\nare refined to predicates over the statements @{term s\\<^sub>L} and @{term s\\<^sub>H}.\nSince @{term s\\<^sub>H} follows @{term s\\<^sub>L}:\n\\begin{itemize}\n\\item\n@{term s\\<^sub>H} must not change the low output, which is computed by @{term s\\<^sub>L}.\n\\item\n@{term s\\<^sub>L} must not change the low and high inputs, which are used by @{term s\\<^sub>H}.\n\\end{itemize}\\<close>"], ["", "definition low_proc_non0\\<^sub>2 :: \"stmt \\<Rightarrow> bool\"\nwhere \"low_proc_non0\\<^sub>2 s\\<^sub>L \\<equiv>\n  \\<forall>\\<sigma> \\<sigma>'.\n    match \\<sigma> \\<Gamma>\\<^sub>0 \\<and>\n    the (\\<sigma> ''lowIn'') \\<noteq> 0 \\<and>\n    s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<longrightarrow>\n    the (\\<sigma>' ''lowOut'') = the (\\<sigma> ''lowIn'') + 1\""], ["", "definition low_proc_0\\<^sub>2 :: \"stmt \\<Rightarrow> bool\"\nwhere \"low_proc_0\\<^sub>2 s\\<^sub>L \\<equiv>\n  \\<forall>\\<sigma> u.\n    match \\<sigma> \\<Gamma>\\<^sub>0 \\<and>\n    the (\\<sigma> ''lowIn'') = 0 \\<longrightarrow>\n    (\\<exists>\\<sigma>'. s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and> the (\\<sigma>' ''lowOut'') = u)\""], ["", "definition low_proc_no_input_change :: \"stmt \\<Rightarrow> bool\"\nwhere \"low_proc_no_input_change s\\<^sub>L \\<equiv>\n  \\<forall>\\<sigma> \\<sigma>'.\n    match \\<sigma> \\<Gamma>\\<^sub>0 \\<and>\n    s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<longrightarrow>\n    the (\\<sigma>' ''lowIn'') = the (\\<sigma> ''lowIn'') \\<and>\n    the (\\<sigma>' ''highIn'') = the (\\<sigma> ''highIn'')\""], ["", "definition high_proc\\<^sub>2 :: \"stmt \\<Rightarrow> bool\"\nwhere \"high_proc\\<^sub>2 s\\<^sub>H \\<equiv>\n  \\<forall>\\<sigma> \\<sigma>'.\n    match \\<sigma> \\<Gamma>\\<^sub>0 \\<and>\n    s\\<^sub>H \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<longrightarrow>\n    the (\\<sigma>' ''highOut'') \\<ge> the (\\<sigma> ''lowIn'') + the (\\<sigma> ''highIn'')\""], ["", "definition high_proc_no_low_output_change :: \"stmt \\<Rightarrow> bool\"\nwhere \"high_proc_no_low_output_change s\\<^sub>H \\<equiv>\n  \\<forall>\\<sigma> \\<sigma>'.\n    match \\<sigma> \\<Gamma>\\<^sub>0 \\<and>\n    s\\<^sub>H \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<longrightarrow>\n    the (\\<sigma>' ''lowOut'') = the (\\<sigma> ''lowOut'')\""], ["", "lemma proc\\<^sub>2_correct:\n  assumes Body: \"body_split p s\\<^sub>L s\\<^sub>H\"\n  assumes WfLow: \"wfs \\<Gamma>\\<^sub>0 s\\<^sub>L\"\n  assumes WfHigh: \"wfs \\<Gamma>\\<^sub>0 s\\<^sub>H\"\n  assumes LowNon0: \"low_proc_non0\\<^sub>2 s\\<^sub>L\"\n  assumes Low0: \"low_proc_0\\<^sub>2 s\\<^sub>L\"\n  assumes LowSame: \"low_proc_no_input_change s\\<^sub>L\"\n  assumes High: \"high_proc\\<^sub>2 s\\<^sub>H\"\n  assumes HighSame: \"high_proc_no_low_output_change s\\<^sub>H\"\n  shows \"low_proc_non0\\<^sub>1 p \\<and> low_proc_0\\<^sub>1 p \\<and> high_proc\\<^sub>1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. low_proc_non0\\<^sub>1 p \\<and>\n    low_proc_0\\<^sub>1 p \\<and> high_proc\\<^sub>1 p", "proof (auto, goal_cases)\n  \\<comment> \\<open>Processing of non-0 low input:\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. low_proc_non0\\<^sub>1 p\n 2. low_proc_0\\<^sub>1 p\n 3. high_proc\\<^sub>1 p", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. low_proc_non0\\<^sub>1 p\n 2. low_proc_0\\<^sub>1 p\n 3. high_proc\\<^sub>1 p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. low_proc_non0\\<^sub>1 p", "proof (auto simp: low_proc_non0\\<^sub>1_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        0 < the (\\<sigma> ''lowIn'');\n        body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowOut'') =\n                         Suc (the (\\<sigma> ''lowIn''))", "fix \\<sigma> \\<sigma>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        0 < the (\\<sigma> ''lowIn'');\n        body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowOut'') =\n                         Suc (the (\\<sigma> ''lowIn''))", "assume \"body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\""], ["proof (state)\nthis:\n  body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        0 < the (\\<sigma> ''lowIn'');\n        body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowOut'') =\n                         Suc (the (\\<sigma> ''lowIn''))", "with Body"], ["proof (chain)\npicking this:\n  body_split p s\\<^sub>L s\\<^sub>H\n  body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'", "obtain \\<sigma>\\<^sub>i\n    where ExecLow: \"s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\"\n    and ExecHigh: \"s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\""], ["proof (prove)\nusing this:\n  body_split p s\\<^sub>L s\\<^sub>H\n  body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>i.\n        \\<lbrakk>s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i;\n         s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some\n                 \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: body_split_def elim: exec.cases)"], ["proof (state)\nthis:\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        0 < the (\\<sigma> ''lowIn'');\n        body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowOut'') =\n                         Suc (the (\\<sigma> ''lowIn''))", "assume Non0: \"the (\\<sigma> ''lowIn'') > 0\""], ["proof (state)\nthis:\n  0 < the (\\<sigma> ''lowIn'')\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        0 < the (\\<sigma> ''lowIn'');\n        body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowOut'') =\n                         Suc (the (\\<sigma> ''lowIn''))", "assume InitMatch: \"match \\<sigma> \\<Gamma>\\<^sub>0\""], ["proof (state)\nthis:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        0 < the (\\<sigma> ''lowIn'');\n        body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowOut'') =\n                         Suc (the (\\<sigma> ''lowIn''))", "with ExecLow WfLow"], ["proof (chain)\npicking this:\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  wfs \\<Gamma>\\<^sub>0 s\\<^sub>L\n  match \\<sigma> \\<Gamma>\\<^sub>0", "have \"match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0\""], ["proof (prove)\nusing this:\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  wfs \\<Gamma>\\<^sub>0 s\\<^sub>L\n  match \\<sigma> \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0", "by (auto simp: exec_wfs_match)"], ["proof (state)\nthis:\n  match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        0 < the (\\<sigma> ''lowIn'');\n        body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowOut'') =\n                         Suc (the (\\<sigma> ''lowIn''))", "with Non0 InitMatch ExecLow ExecHigh HighSame LowNon0"], ["proof (chain)\npicking this:\n  0 < the (\\<sigma> ''lowIn'')\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n  high_proc_no_low_output_change s\\<^sub>H\n  low_proc_non0\\<^sub>2 s\\<^sub>L\n  match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0", "show \"the (\\<sigma>' ''lowOut'') = Suc (the (\\<sigma> ''lowIn''))\""], ["proof (prove)\nusing this:\n  0 < the (\\<sigma> ''lowIn'')\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n  high_proc_no_low_output_change s\\<^sub>H\n  low_proc_non0\\<^sub>2 s\\<^sub>L\n  match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. the (\\<sigma>' ''lowOut'') = Suc (the (\\<sigma> ''lowIn''))", "unfolding high_proc_no_low_output_change_def low_proc_non0\\<^sub>2_def"], ["proof (prove)\nusing this:\n  0 < the (\\<sigma> ''lowIn'')\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n  \\<forall>\\<sigma> \\<sigma>'.\n     match \\<sigma> \\<Gamma>\\<^sub>0 \\<and>\n     s\\<^sub>H \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<longrightarrow>\n     the (\\<sigma>' ''lowOut'') = the (\\<sigma> ''lowOut'')\n  \\<forall>\\<sigma> \\<sigma>'.\n     match \\<sigma> \\<Gamma>\\<^sub>0 \\<and>\n     the (\\<sigma> ''lowIn'') \\<noteq> 0 \\<and>\n     s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<longrightarrow>\n     the (\\<sigma>' ''lowOut'') = the (\\<sigma> ''lowIn'') + 1\n  match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. the (\\<sigma>' ''lowOut'') = Suc (the (\\<sigma> ''lowIn''))", "by (metis Suc_eq_plus1 gr_implies_not0)"], ["proof (state)\nthis:\n  the (\\<sigma>' ''lowOut'') = Suc (the (\\<sigma> ''lowIn''))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  low_proc_non0\\<^sub>1 p\n\ngoal (2 subgoals):\n 1. low_proc_0\\<^sub>1 p\n 2. high_proc\\<^sub>1 p", "next\n  \\<comment> \\<open>Processing of 0 low input:\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. low_proc_0\\<^sub>1 p\n 2. high_proc\\<^sub>1 p", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. low_proc_0\\<^sub>1 p\n 2. high_proc\\<^sub>1 p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. low_proc_0\\<^sub>1 p", "proof (auto simp: low_proc_0\\<^sub>1_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            body\n                             p \\<rhd> \\<sigma> \\<leadsto> Some\n                     \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "fix \\<sigma> u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            body\n                             p \\<rhd> \\<sigma> \\<leadsto> Some\n                     \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "assume InitMatch: \"match \\<sigma> \\<Gamma>\\<^sub>0\"\n    and \"the (\\<sigma> ''lowIn'') = 0\""], ["proof (state)\nthis:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  the (\\<sigma> ''lowIn'') = 0\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            body\n                             p \\<rhd> \\<sigma> \\<leadsto> Some\n                     \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "with Low0"], ["proof (chain)\npicking this:\n  low_proc_0\\<^sub>2 s\\<^sub>L\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  the (\\<sigma> ''lowIn'') = 0", "obtain \\<sigma>\\<^sub>i\n    where ExecLow: \"s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\"\n    and LowOut: \"the (\\<sigma>\\<^sub>i ''lowOut'') = u\""], ["proof (prove)\nusing this:\n  low_proc_0\\<^sub>2 s\\<^sub>L\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  the (\\<sigma> ''lowIn'') = 0\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>i.\n        \\<lbrakk>s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i;\n         the (\\<sigma>\\<^sub>i ''lowOut'') = u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: low_proc_0\\<^sub>2_def)"], ["proof (state)\nthis:\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  the (\\<sigma>\\<^sub>i ''lowOut'') = u\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            body\n                             p \\<rhd> \\<sigma> \\<leadsto> Some\n                     \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "from InitMatch ExecLow WfLow"], ["proof (chain)\npicking this:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  wfs \\<Gamma>\\<^sub>0 s\\<^sub>L", "have MidMatch: \"match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0\""], ["proof (prove)\nusing this:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  wfs \\<Gamma>\\<^sub>0 s\\<^sub>L\n\ngoal (1 subgoal):\n 1. match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0", "by (auto simp: exec_wfs_match)"], ["proof (state)\nthis:\n  match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            body\n                             p \\<rhd> \\<sigma> \\<leadsto> Some\n                     \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "with WfHigh"], ["proof (chain)\npicking this:\n  wfs \\<Gamma>\\<^sub>0 s\\<^sub>H\n  match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0", "obtain \\<sigma>'\n    where ExecHigh: \"s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\""], ["proof (prove)\nusing this:\n  wfs \\<Gamma>\\<^sub>0 s\\<^sub>H\n  match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'.\n        s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some\n                \\<sigma>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis exec_wfs_always_match)"], ["proof (state)\nthis:\n  s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            body\n                             p \\<rhd> \\<sigma> \\<leadsto> Some\n                     \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "with HighSame MidMatch"], ["proof (chain)\npicking this:\n  high_proc_no_low_output_change s\\<^sub>H\n  match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0\n  s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'", "have \"the (\\<sigma>' ''lowOut'') = the (\\<sigma>\\<^sub>i ''lowOut'')\""], ["proof (prove)\nusing this:\n  high_proc_no_low_output_change s\\<^sub>H\n  match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0\n  s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. the (\\<sigma>' ''lowOut'') = the (\\<sigma>\\<^sub>i ''lowOut'')", "by (auto simp: high_proc_no_low_output_change_def)"], ["proof (state)\nthis:\n  the (\\<sigma>' ''lowOut'') = the (\\<sigma>\\<^sub>i ''lowOut'')\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            body\n                             p \\<rhd> \\<sigma> \\<leadsto> Some\n                     \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "with ExecLow ExecHigh Body LowOut"], ["proof (chain)\npicking this:\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n  body_split p s\\<^sub>L s\\<^sub>H\n  the (\\<sigma>\\<^sub>i ''lowOut'') = u\n  the (\\<sigma>' ''lowOut'') = the (\\<sigma>\\<^sub>i ''lowOut'')", "show \"\\<exists>\\<sigma>'. body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and> the (\\<sigma>' ''lowOut'') = u\""], ["proof (prove)\nusing this:\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n  body_split p s\\<^sub>L s\\<^sub>H\n  the (\\<sigma>\\<^sub>i ''lowOut'') = u\n  the (\\<sigma>' ''lowOut'') = the (\\<sigma>\\<^sub>i ''lowOut'')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'.\n       body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and>\n       the (\\<sigma>' ''lowOut'') = u", "by (auto simp add: body_split_def dest: ExecSeqOK)"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>'.\n     body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and>\n     the (\\<sigma>' ''lowOut'') = u\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  low_proc_0\\<^sub>1 p\n\ngoal (1 subgoal):\n 1. high_proc\\<^sub>1 p", "next\n  \\<comment> \\<open>Processing of high input:\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. high_proc\\<^sub>1 p", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. high_proc\\<^sub>1 p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. high_proc\\<^sub>1 p", "proof (auto simp: high_proc\\<^sub>1_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma> ''lowIn'') +\n                         the (\\<sigma> ''highIn'')\n                         \\<le> the (\\<sigma>' ''highOut'')", "fix \\<sigma> \\<sigma>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma> ''lowIn'') +\n                         the (\\<sigma> ''highIn'')\n                         \\<le> the (\\<sigma>' ''highOut'')", "assume \"body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\""], ["proof (state)\nthis:\n  body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma> ''lowIn'') +\n                         the (\\<sigma> ''highIn'')\n                         \\<le> the (\\<sigma>' ''highOut'')", "with Body"], ["proof (chain)\npicking this:\n  body_split p s\\<^sub>L s\\<^sub>H\n  body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'", "obtain \\<sigma>\\<^sub>i\n    where ExecLow: \"s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\"\n    and ExecHigh: \"s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\""], ["proof (prove)\nusing this:\n  body_split p s\\<^sub>L s\\<^sub>H\n  body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>\\<^sub>i.\n        \\<lbrakk>s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i;\n         s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some\n                 \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: body_split_def elim: exec.cases)"], ["proof (state)\nthis:\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma> ''lowIn'') +\n                         the (\\<sigma> ''highIn'')\n                         \\<le> the (\\<sigma>' ''highOut'')", "assume InitMatch: \"match \\<sigma> \\<Gamma>\\<^sub>0\""], ["proof (state)\nthis:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma> ''lowIn'') +\n                         the (\\<sigma> ''highIn'')\n                         \\<le> the (\\<sigma>' ''highOut'')", "with ExecLow WfLow"], ["proof (chain)\npicking this:\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  wfs \\<Gamma>\\<^sub>0 s\\<^sub>L\n  match \\<sigma> \\<Gamma>\\<^sub>0", "have \"match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0\""], ["proof (prove)\nusing this:\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  wfs \\<Gamma>\\<^sub>0 s\\<^sub>L\n  match \\<sigma> \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0", "by (auto simp: exec_wfs_match)"], ["proof (state)\nthis:\n  match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        body p \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma> ''lowIn'') +\n                         the (\\<sigma> ''highIn'')\n                         \\<le> the (\\<sigma>' ''highOut'')", "with InitMatch ExecLow ExecHigh LowSame High"], ["proof (chain)\npicking this:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n  low_proc_no_input_change s\\<^sub>L\n  high_proc\\<^sub>2 s\\<^sub>H\n  match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0", "show \"the (\\<sigma>' ''highOut'') \\<ge> the (\\<sigma> ''lowIn'') + the (\\<sigma> ''highIn'')\""], ["proof (prove)\nusing this:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n  low_proc_no_input_change s\\<^sub>L\n  high_proc\\<^sub>2 s\\<^sub>H\n  match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. the (\\<sigma> ''lowIn'') + the (\\<sigma> ''highIn'')\n    \\<le> the (\\<sigma>' ''highOut'')", "unfolding low_proc_no_input_change_def high_proc\\<^sub>2_def"], ["proof (prove)\nusing this:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>\\<^sub>i\n  s\\<^sub>H \\<rhd> \\<sigma>\\<^sub>i \\<leadsto> Some \\<sigma>'\n  \\<forall>\\<sigma> \\<sigma>'.\n     match \\<sigma> \\<Gamma>\\<^sub>0 \\<and>\n     s\\<^sub>L \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<longrightarrow>\n     the (\\<sigma>' ''lowIn'') = the (\\<sigma> ''lowIn'') \\<and>\n     the (\\<sigma>' ''highIn'') = the (\\<sigma> ''highIn'')\n  \\<forall>\\<sigma> \\<sigma>'.\n     match \\<sigma> \\<Gamma>\\<^sub>0 \\<and>\n     s\\<^sub>H \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<longrightarrow>\n     the (\\<sigma> ''lowIn'') + the (\\<sigma> ''highIn'')\n     \\<le> the (\\<sigma>' ''highOut'')\n  match \\<sigma>\\<^sub>i \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. the (\\<sigma> ''lowIn'') + the (\\<sigma> ''highIn'')\n    \\<le> the (\\<sigma>' ''highOut'')", "by metis"], ["proof (state)\nthis:\n  the (\\<sigma> ''lowIn'') + the (\\<sigma> ''highIn'')\n  \\<le> the (\\<sigma>' ''highOut'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  high_proc\\<^sub>1 p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The refined specification consists of\nthe splitting of the body into the two sequential statements\nand the refined well-formedness and processing constraints.\\<close>"], ["", "definition spec\\<^sub>2 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>2 p \\<equiv>\n  vars p = vars\\<^sub>0 \\<and>\n  (\\<exists>s\\<^sub>L s\\<^sub>H.\n    body_split p s\\<^sub>L s\\<^sub>H \\<and>\n    wfs \\<Gamma>\\<^sub>0 s\\<^sub>L \\<and>\n    wfs \\<Gamma>\\<^sub>0 s\\<^sub>H \\<and>\n    low_proc_non0\\<^sub>2 s\\<^sub>L \\<and>\n    low_proc_0\\<^sub>2 s\\<^sub>L \\<and>\n    low_proc_no_input_change s\\<^sub>L \\<and>\n    high_proc\\<^sub>2 s\\<^sub>H \\<and>\n    high_proc_no_low_output_change s\\<^sub>H)\""], ["", "lemma step_2_correct:\n  \"spec\\<^sub>2 p \\<Longrightarrow> spec\\<^sub>1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>2 p \\<Longrightarrow> spec\\<^sub>1 p", "by (auto simp: spec\\<^sub>2_def spec\\<^sub>1_def reduce_wf_body_to_stmts proc\\<^sub>2_correct)"], ["", "subsection \\<open>Step 3\\<close>"], ["", "text \\<open>\\label{sec:refII:stepIII}\\<close>"], ["", "text \\<open>The processing constraints\n@{const low_proc_non0\\<^sub>2} and @{const low_proc_0\\<^sub>2} on @{term s\\<^sub>L}\nsuggest the use of a conditional that\nrandomizes @{term \"''lowOut''\"} if @{term \"''lowIn''\"} is 0,\nand stores 1 plus @{term \"''lowIn''\"} into @{term \"''lowOut''\"} otherwise.\\<close>"], ["", "abbreviation s\\<^sub>L\\<^sub>0 :: stmt\nwhere \"s\\<^sub>L\\<^sub>0 \\<equiv>\n  IfEq\n    (Var ''lowIn'')\n    (Const 0)\n    (Random ''lowOut'')\n    (Assign ''lowOut'' (Add (Var ''lowIn'') (Const 1)))\""], ["", "lemma wfs_s\\<^sub>L\\<^sub>0:\n  \"wfs \\<Gamma>\\<^sub>0 s\\<^sub>L\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfs \\<Gamma>\\<^sub>0 s\\<^sub>L\\<^sub>0", "by auto"], ["", "lemma low_proc_non0_s\\<^sub>L\\<^sub>0:\n  \"low_proc_non0\\<^sub>2 s\\<^sub>L\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. low_proc_non0\\<^sub>2 s\\<^sub>L\\<^sub>0", "proof (auto simp only: low_proc_non0\\<^sub>2_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>';\n        0 < the (\\<sigma> ''lowIn'')\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowOut'') =\n                         the (\\<sigma> ''lowIn'') + 1", "fix \\<sigma> \\<sigma>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>';\n        0 < the (\\<sigma> ''lowIn'')\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowOut'') =\n                         the (\\<sigma> ''lowIn'') + 1", "assume Match: \"match \\<sigma> \\<Gamma>\\<^sub>0\""], ["proof (state)\nthis:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>';\n        0 < the (\\<sigma> ''lowIn'')\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowOut'') =\n                         the (\\<sigma> ''lowIn'') + 1", "assume \"s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\"\n  and \"the (\\<sigma> ''lowIn'') > 0\""], ["proof (state)\nthis:\n  s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  0 < the (\\<sigma> ''lowIn'')\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>';\n        0 < the (\\<sigma> ''lowIn'')\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowOut'') =\n                         the (\\<sigma> ''lowIn'') + 1", "hence \"(Assign ''lowOut'' (Add (Var ''lowIn'') (Const 1))) \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\""], ["proof (prove)\nusing this:\n  s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  0 < the (\\<sigma> ''lowIn'')\n\ngoal (1 subgoal):\n 1. Assign ''lowOut''\n     (Add (Var ''lowIn'')\n       (Const 1)) \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'", "by (auto elim: exec.cases)"], ["proof (state)\nthis:\n  Assign ''lowOut''\n   (Add (Var ''lowIn'') (Const 1)) \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>';\n        0 < the (\\<sigma> ''lowIn'')\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowOut'') =\n                         the (\\<sigma> ''lowIn'') + 1", "hence \"\\<sigma>' = \\<sigma> (''lowOut'' \\<mapsto> the (eval \\<sigma> (Add (Var ''lowIn'') (Const 1))))\""], ["proof (prove)\nusing this:\n  Assign ''lowOut''\n   (Add (Var ''lowIn'') (Const 1)) \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<sigma>' = \\<sigma>(''lowOut'' \\<mapsto>\n    the (eval \\<sigma> (Add (Var ''lowIn'') (Const 1))))", "by (auto elim: exec.cases)"], ["proof (state)\nthis:\n  \\<sigma>' = \\<sigma>(''lowOut'' \\<mapsto>\n  the (eval \\<sigma> (Add (Var ''lowIn'') (Const 1))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>';\n        0 < the (\\<sigma> ''lowIn'')\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowOut'') =\n                         the (\\<sigma> ''lowIn'') + 1", "with Match"], ["proof (chain)\npicking this:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  \\<sigma>' = \\<sigma>(''lowOut'' \\<mapsto>\n  the (eval \\<sigma> (Add (Var ''lowIn'') (Const 1))))", "show \"the (\\<sigma>' ''lowOut'') = the (\\<sigma> ''lowIn'') + 1\""], ["proof (prove)\nusing this:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  \\<sigma>' = \\<sigma>(''lowOut'' \\<mapsto>\n  the (eval \\<sigma> (Add (Var ''lowIn'') (Const 1))))\n\ngoal (1 subgoal):\n 1. the (\\<sigma>' ''lowOut'') = the (\\<sigma> ''lowIn'') + 1", "by (auto simp: match_def add_opt_def split: option.split)"], ["proof (state)\nthis:\n  the (\\<sigma>' ''lowOut'') = the (\\<sigma> ''lowIn'') + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma low_proc_0_s\\<^sub>L\\<^sub>0:\n  \"low_proc_0\\<^sub>2 s\\<^sub>L\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. low_proc_0\\<^sub>2 s\\<^sub>L\\<^sub>0", "proof (auto simp only: low_proc_0\\<^sub>2_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some\n                                    \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "fix \\<sigma> u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some\n                                    \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "assume Match: \"match \\<sigma> \\<Gamma>\\<^sub>0\"\n  and \"the (\\<sigma> ''lowIn'') = 0\""], ["proof (state)\nthis:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  the (\\<sigma> ''lowIn'') = 0\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some\n                                    \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "hence LowIn0: \"\\<sigma> ''lowIn'' = Some 0\""], ["proof (prove)\nusing this:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  the (\\<sigma> ''lowIn'') = 0\n\ngoal (1 subgoal):\n 1. \\<sigma> ''lowIn'' = Some 0", "by (cases \"\\<sigma> ''lowIn''\", auto simp: match_def)"], ["proof (state)\nthis:\n  \\<sigma> ''lowIn'' = Some 0\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some\n                                    \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "from Match"], ["proof (chain)\npicking this:\n  match \\<sigma> \\<Gamma>\\<^sub>0", "have \"''lowOut'' \\<in> dom \\<sigma>\""], ["proof (prove)\nusing this:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. ''lowOut'' \\<in> dom \\<sigma>", "by (auto simp: match_def)"], ["proof (state)\nthis:\n  ''lowOut'' \\<in> dom \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some\n                                    \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "then"], ["proof (chain)\npicking this:\n  ''lowOut'' \\<in> dom \\<sigma>", "obtain \\<sigma>'\n  where ExecRand: \"Random ''lowOut'' \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\"\n  and \"\\<sigma>' = \\<sigma> (''lowOut'' \\<mapsto> u)\""], ["proof (prove)\nusing this:\n  ''lowOut'' \\<in> dom \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'.\n        \\<lbrakk>Random\n                  ''lowOut'' \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>';\n         \\<sigma>' = \\<sigma>(''lowOut'' \\<mapsto> u)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: ExecRandomOK)"], ["proof (state)\nthis:\n  Random ''lowOut'' \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  \\<sigma>' = \\<sigma>(''lowOut'' \\<mapsto> u)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some\n                                    \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "hence \"the (\\<sigma>' ''lowOut'') = u\""], ["proof (prove)\nusing this:\n  Random ''lowOut'' \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  \\<sigma>' = \\<sigma>(''lowOut'' \\<mapsto> u)\n\ngoal (1 subgoal):\n 1. the (\\<sigma>' ''lowOut'') = u", "by auto"], ["proof (state)\nthis:\n  the (\\<sigma>' ''lowOut'') = u\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> u.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        the (\\<sigma> ''lowIn'') = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>'.\n                            s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some\n                                    \\<sigma>' \\<and>\n                            the (\\<sigma>' ''lowOut'') = u", "with ExecRand LowIn0"], ["proof (chain)\npicking this:\n  Random ''lowOut'' \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  \\<sigma> ''lowIn'' = Some 0\n  the (\\<sigma>' ''lowOut'') = u", "show \"\\<exists>\\<sigma>'. s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and> the (\\<sigma>' ''lowOut'') = u\""], ["proof (prove)\nusing this:\n  Random ''lowOut'' \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n  \\<sigma> ''lowIn'' = Some 0\n  the (\\<sigma>' ''lowOut'') = u\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'.\n       s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and>\n       the (\\<sigma>' ''lowOut'') = u", "by (metis ExecCondTrue eval.simps(1) eval.simps(2))"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>'.\n     s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<and>\n     the (\\<sigma>' ''lowOut'') = u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma low_proc_no_input_change_s\\<^sub>L\\<^sub>0:\n  \"low_proc_no_input_change s\\<^sub>L\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. low_proc_no_input_change s\\<^sub>L\\<^sub>0", "proof (unfold low_proc_no_input_change_def, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowIn'') =\n                         the (\\<sigma> ''lowIn'') \\<and>\n                         the (\\<sigma>' ''highIn'') =\n                         the (\\<sigma> ''highIn'')", "fix \\<sigma> \\<sigma>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowIn'') =\n                         the (\\<sigma> ''lowIn'') \\<and>\n                         the (\\<sigma>' ''highIn'') =\n                         the (\\<sigma> ''highIn'')", "assume \"s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\""], ["proof (state)\nthis:\n  s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowIn'') =\n                         the (\\<sigma> ''lowIn'') \\<and>\n                         the (\\<sigma>' ''highIn'') =\n                         the (\\<sigma> ''highIn'')", "hence \"\n    Random ''lowOut'' \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<or>\n    Assign ''lowOut'' (Add (Var ''lowIn'') (Const 1)) \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\""], ["proof (prove)\nusing this:\n  s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. Random ''lowOut'' \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<or>\n    Assign ''lowOut''\n     (Add (Var ''lowIn'')\n       (Const 1)) \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'", "by (auto elim: exec.cases)"], ["proof (state)\nthis:\n  Random ''lowOut'' \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<or>\n  Assign ''lowOut''\n   (Add (Var ''lowIn'') (Const 1)) \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>L\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''lowIn'') =\n                         the (\\<sigma> ''lowIn'') \\<and>\n                         the (\\<sigma>' ''highIn'') =\n                         the (\\<sigma> ''highIn'')", "thus \"\n    the (\\<sigma>' ''lowIn'') = the (\\<sigma> ''lowIn'') \\<and>\n    the (\\<sigma>' ''highIn'') = the (\\<sigma> ''highIn'')\""], ["proof (prove)\nusing this:\n  Random ''lowOut'' \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<or>\n  Assign ''lowOut''\n   (Add (Var ''lowIn'') (Const 1)) \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. the (\\<sigma>' ''lowIn'') = the (\\<sigma> ''lowIn'') \\<and>\n    the (\\<sigma>' ''highIn'') = the (\\<sigma> ''highIn'')", "by (auto elim: exec.cases)"], ["proof (state)\nthis:\n  the (\\<sigma>' ''lowIn'') = the (\\<sigma> ''lowIn'') \\<and>\n  the (\\<sigma>' ''highIn'') = the (\\<sigma> ''highIn'')\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The refined specification is obtained\nby simplification using the definition of @{term s\\<^sub>L}.\\<close>"], ["", "definition spec\\<^sub>3 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>3 p \\<equiv>\n  vars p = vars\\<^sub>0 \\<and>\n  (\\<exists>s\\<^sub>H.\n    body_split p s\\<^sub>L\\<^sub>0 s\\<^sub>H \\<and>\n    wfs \\<Gamma>\\<^sub>0 s\\<^sub>H \\<and>\n    high_proc\\<^sub>2 s\\<^sub>H \\<and>\n    high_proc_no_low_output_change s\\<^sub>H)\""], ["", "lemma step_3_correct:\n  \"spec\\<^sub>3 p \\<Longrightarrow> spec\\<^sub>2 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>3 p \\<Longrightarrow> spec\\<^sub>2 p", "unfolding spec\\<^sub>3_def spec\\<^sub>2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars p = vars\\<^sub>0 \\<and>\n    (\\<exists>s\\<^sub>H.\n        body_split p s\\<^sub>L\\<^sub>0 s\\<^sub>H \\<and>\n        wfs \\<Gamma>\\<^sub>0 s\\<^sub>H \\<and>\n        high_proc\\<^sub>2 s\\<^sub>H \\<and>\n        high_proc_no_low_output_change s\\<^sub>H) \\<Longrightarrow>\n    vars p = vars\\<^sub>0 \\<and>\n    (\\<exists>s\\<^sub>L s\\<^sub>H.\n        body_split p s\\<^sub>L s\\<^sub>H \\<and>\n        wfs \\<Gamma>\\<^sub>0 s\\<^sub>L \\<and>\n        wfs \\<Gamma>\\<^sub>0 s\\<^sub>H \\<and>\n        low_proc_non0\\<^sub>2 s\\<^sub>L \\<and>\n        low_proc_0\\<^sub>2 s\\<^sub>L \\<and>\n        low_proc_no_input_change s\\<^sub>L \\<and>\n        high_proc\\<^sub>2 s\\<^sub>H \\<and>\n        high_proc_no_low_output_change s\\<^sub>H)", "by (metis\n  wfs_s\\<^sub>L\\<^sub>0 low_proc_non0_s\\<^sub>L\\<^sub>0 low_proc_0_s\\<^sub>L\\<^sub>0 low_proc_no_input_change_s\\<^sub>L\\<^sub>0)"], ["", "text \\<open>The non-determinism required by @{const low_proc_0}\ncannot be pop-refined away.\nIn particular, @{term s\\<^sub>L} cannot be defined\nto copy the high input to the low output when the low input is 0,\nwhich would lead to a program that does not satisfy GNI.\\<close>"], ["", "subsection \\<open>Step 4\\<close>"], ["", "text \\<open>\\label{sec:refII:stepIV}\\<close>"], ["", "text \\<open>The processing constraint @{const high_proc\\<^sub>2} on @{term s\\<^sub>H}\ncan be satisfied in different ways.\nA simple way is to pick the sum of the low and high inputs:\n@{const high_proc\\<^sub>2} is refined by replacing the inequality with an equality.\\<close>"], ["", "definition high_proc\\<^sub>4 :: \"stmt \\<Rightarrow> bool\"\nwhere \"high_proc\\<^sub>4 s\\<^sub>H \\<equiv>\n  \\<forall>\\<sigma> \\<sigma>'.\n    match \\<sigma> \\<Gamma>\\<^sub>0 \\<and>\n    s\\<^sub>H \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>' \\<longrightarrow>\n    the (\\<sigma>' ''highOut'') = the (\\<sigma> ''lowIn'') + the (\\<sigma> ''highIn'')\""], ["", "lemma high_proc\\<^sub>4_correct:\n  \"high_proc\\<^sub>4 s\\<^sub>H \\<Longrightarrow> high_proc\\<^sub>2 s\\<^sub>H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. high_proc\\<^sub>4 s\\<^sub>H \\<Longrightarrow>\n    high_proc\\<^sub>2 s\\<^sub>H", "by (auto simp: high_proc\\<^sub>4_def high_proc\\<^sub>2_def)"], ["", "text \\<open>The refined specification is obtained\nby substituting the refined processing constraint on @{term s\\<^sub>H}.\\<close>"], ["", "definition spec\\<^sub>4 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>4 p \\<equiv>\n  vars p = vars\\<^sub>0 \\<and>\n  (\\<exists>s\\<^sub>H.\n    body_split p s\\<^sub>L\\<^sub>0 s\\<^sub>H \\<and>\n    wfs \\<Gamma>\\<^sub>0 s\\<^sub>H \\<and>\n    high_proc\\<^sub>4 s\\<^sub>H \\<and>\n    high_proc_no_low_output_change s\\<^sub>H)\""], ["", "lemma step_4_correct:\n  \"spec\\<^sub>4 p \\<Longrightarrow> spec\\<^sub>3 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>4 p \\<Longrightarrow> spec\\<^sub>3 p", "by (auto simp: spec\\<^sub>4_def spec\\<^sub>3_def high_proc\\<^sub>4_correct)"], ["", "subsection \\<open>Step 5\\<close>"], ["", "text \\<open>\\label{sec:refII:stepV}\\<close>"], ["", "text \\<open>The refined processing constraint @{const high_proc\\<^sub>4} on @{term s\\<^sub>H}\nsuggest the use of an assignment that\nstores the sum of @{term \"''lowIn''\"} and @{term \"''highIn''\"}\ninto @{term \"''highOut''\"}.\\<close>"], ["", "abbreviation s\\<^sub>H\\<^sub>0 :: stmt\nwhere \"s\\<^sub>H\\<^sub>0 \\<equiv> Assign ''highOut'' (Add (Var ''lowIn'') (Var ''highIn''))\""], ["", "lemma wfs_s\\<^sub>H\\<^sub>0:\n  \"wfs \\<Gamma>\\<^sub>0 s\\<^sub>H\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfs \\<Gamma>\\<^sub>0 s\\<^sub>H\\<^sub>0", "by auto"], ["", "lemma high_proc\\<^sub>4_s\\<^sub>H\\<^sub>0:\n  \"high_proc\\<^sub>4 s\\<^sub>H\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. high_proc\\<^sub>4 s\\<^sub>H\\<^sub>0", "proof (auto simp: high_proc\\<^sub>4_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>H\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''highOut'') =\n                         the (\\<sigma> ''lowIn'') +\n                         the (\\<sigma> ''highIn'')", "fix \\<sigma> \\<sigma>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>H\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''highOut'') =\n                         the (\\<sigma> ''lowIn'') +\n                         the (\\<sigma> ''highIn'')", "assume Match: \"match \\<sigma> \\<Gamma>\\<^sub>0\""], ["proof (state)\nthis:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>H\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''highOut'') =\n                         the (\\<sigma> ''lowIn'') +\n                         the (\\<sigma> ''highIn'')", "assume \"s\\<^sub>H\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\""], ["proof (state)\nthis:\n  s\\<^sub>H\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>H\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''highOut'') =\n                         the (\\<sigma> ''lowIn'') +\n                         the (\\<sigma> ''highIn'')", "hence \"\n    \\<sigma>' = \\<sigma> (''highOut'' \\<mapsto> the (eval \\<sigma> (Add (Var ''lowIn'') (Var ''highIn''))))\""], ["proof (prove)\nusing this:\n  s\\<^sub>H\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<sigma>' = \\<sigma>(''highOut'' \\<mapsto>\n    the (eval \\<sigma> (Add (Var ''lowIn'') (Var ''highIn''))))", "by (auto elim: exec.cases)"], ["proof (state)\nthis:\n  \\<sigma>' = \\<sigma>(''highOut'' \\<mapsto>\n  the (eval \\<sigma> (Add (Var ''lowIn'') (Var ''highIn''))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>match \\<sigma> \\<Gamma>\\<^sub>0;\n        s\\<^sub>H\\<^sub>0 \\<rhd> \\<sigma> \\<leadsto> Some \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> the (\\<sigma>' ''highOut'') =\n                         the (\\<sigma> ''lowIn'') +\n                         the (\\<sigma> ''highIn'')", "with Match"], ["proof (chain)\npicking this:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  \\<sigma>' = \\<sigma>(''highOut'' \\<mapsto>\n  the (eval \\<sigma> (Add (Var ''lowIn'') (Var ''highIn''))))", "show \"the (\\<sigma>' ''highOut'') = the (\\<sigma> ''lowIn'') + the (\\<sigma> ''highIn'')\""], ["proof (prove)\nusing this:\n  match \\<sigma> \\<Gamma>\\<^sub>0\n  \\<sigma>' = \\<sigma>(''highOut'' \\<mapsto>\n  the (eval \\<sigma> (Add (Var ''lowIn'') (Var ''highIn''))))\n\ngoal (1 subgoal):\n 1. the (\\<sigma>' ''highOut'') =\n    the (\\<sigma> ''lowIn'') + the (\\<sigma> ''highIn'')", "by (auto simp: match_def add_opt_def split: option.split)"], ["proof (state)\nthis:\n  the (\\<sigma>' ''highOut'') =\n  the (\\<sigma> ''lowIn'') + the (\\<sigma> ''highIn'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma high_proc_no_low_output_change_s\\<^sub>H\\<^sub>0:\n  \"high_proc_no_low_output_change s\\<^sub>H\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. high_proc_no_low_output_change s\\<^sub>H\\<^sub>0", "by (auto simp: high_proc_no_low_output_change_def elim: exec.cases)"], ["", "text \\<open>The refined specification is obtained\nby simplification using the definition of @{term s\\<^sub>H}.\\<close>"], ["", "definition spec\\<^sub>5 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>5 p \\<equiv> vars p = vars\\<^sub>0 \\<and> body_split p s\\<^sub>L\\<^sub>0 s\\<^sub>H\\<^sub>0\""], ["", "lemma step_5_correct:\n  \"spec\\<^sub>5 p \\<Longrightarrow> spec\\<^sub>4 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>5 p \\<Longrightarrow> spec\\<^sub>4 p", "unfolding spec\\<^sub>5_def spec\\<^sub>4_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars p = vars\\<^sub>0 \\<and>\n    body_split p s\\<^sub>L\\<^sub>0 s\\<^sub>H\\<^sub>0 \\<Longrightarrow>\n    vars p = vars\\<^sub>0 \\<and>\n    (\\<exists>s\\<^sub>H.\n        body_split p s\\<^sub>L\\<^sub>0 s\\<^sub>H \\<and>\n        wfs \\<Gamma>\\<^sub>0 s\\<^sub>H \\<and>\n        high_proc\\<^sub>4 s\\<^sub>H \\<and>\n        high_proc_no_low_output_change s\\<^sub>H)", "by (metis wfs_s\\<^sub>H\\<^sub>0 high_proc\\<^sub>4_s\\<^sub>H\\<^sub>0 high_proc_no_low_output_change_s\\<^sub>H\\<^sub>0)"], ["", "subsection \\<open>Step 6\\<close>"], ["", "text \\<open>\\label{sec:refII:stepVI}\\<close>"], ["", "text \\<open>@{const spec\\<^sub>5}, which defines the variables and the body,\nis refined to characterize a unique program in explicit syntactic form.\\<close>"], ["", "abbreviation p\\<^sub>0 :: prog\nwhere \"p\\<^sub>0 \\<equiv> \\<lparr>vars = vars\\<^sub>0, body = Seq s\\<^sub>L\\<^sub>0 s\\<^sub>H\\<^sub>0\\<rparr>\""], ["", "definition spec\\<^sub>6 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>6 p \\<equiv> p = p\\<^sub>0\""], ["", "lemma step_6_correct:\n  \"spec\\<^sub>6 p \\<Longrightarrow> spec\\<^sub>5 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>6 p \\<Longrightarrow> spec\\<^sub>5 p", "by (auto simp: spec\\<^sub>6_def spec\\<^sub>5_def body_split_def)"], ["", "text \\<open>The program satisfies @{const spec\\<^sub>0} by construction.\nThe program witnesses the consistency of the requirements,\ni.e.\\ the fact that @{const spec\\<^sub>0} is not always false.\\<close>"], ["", "lemma p\\<^sub>0_sat_spec\\<^sub>0:\n  \"spec\\<^sub>0 p\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>0 p\\<^sub>0", "by (metis\n step_1_correct\n step_2_correct\n step_3_correct\n step_4_correct\n step_5_correct\n step_6_correct\n spec\\<^sub>6_def)"], ["", "text \\<open>From @{const p\\<^sub>0}, the program text\n\\begin{verbatim}\n  prog {\n    vars {\n      lowIn\n      lowOut\n      highIn\n      highOut\n    }\n    body {\n      if (lowIn == 0) {\n        randomize lowOut;\n      } else {\n        lowOut = lowIn + 1;\n      }\n      highOut = lowIn + highIn;\n    }\n  }\n\\end{verbatim}\nis easily obtained.\\<close>"], ["", "end %invisible"]]}