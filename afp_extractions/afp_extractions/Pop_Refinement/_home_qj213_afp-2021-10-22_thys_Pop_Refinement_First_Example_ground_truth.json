{"file_name": "/home/qj213/afp-2021-10-22/thys/Pop_Refinement/First_Example.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pop_Refinement", "problem_names": ["lemma eval_wfe:\n  \"wfe \\<Gamma> e \\<Longrightarrow> match \\<E> \\<Gamma> \\<Longrightarrow> eval \\<E> e \\<noteq> None\"", "lemma eval_wfp:\n  \"wfp p \\<Longrightarrow> \\<E> \\<in> envs p \\<Longrightarrow> eval \\<E> (body p) \\<noteq> None\"", "lemma supply_wfp: \"\n  wfp p \\<Longrightarrow>\n  length us = length (para p) \\<Longrightarrow>\n  \\<exists>\\<E> \\<in> envs p. supply p us = Some \\<E>\"", "lemma exec_wfp:\n  \"wfp p \\<Longrightarrow> length us = length (para p) \\<Longrightarrow> exec p us \\<noteq> None\"", "lemma reduce_prog_to_body: \"\n  para p = [''x'', ''y''] \\<Longrightarrow>\n  wfp p = wfe \\<Gamma>\\<^sub>x\\<^sub>y (body p) \\<and>\n  exec p [x, y] = eval (\\<E>\\<^sub>x\\<^sub>y x y) (body p)\"", "lemma step_1_correct:\n \"spec\\<^sub>1 p \\<Longrightarrow> spec\\<^sub>0 p\"", "lemma step_2_correct:\n \"spec\\<^sub>2 p \\<Longrightarrow> spec\\<^sub>1 p\"", "lemma reduce_body_to_addends: \"\n  body p = Add e\\<^sub>1 e\\<^sub>2 \\<Longrightarrow>\n  wfe \\<Gamma>\\<^sub>x\\<^sub>y (body p) = (wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>1 \\<and> wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>2) \\<and>\n  eval (\\<E>\\<^sub>x\\<^sub>y x y) (body p) = eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>1 \\<oplus> eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>2 \\<and>\n  coste (body p) = 1 + coste e\\<^sub>1 + coste e\\<^sub>2\"", "lemma step_3_correct:\n  \"spec\\<^sub>3 p \\<Longrightarrow> spec\\<^sub>2 p\"", "lemma f_rephrased:\n  \"f x y = x + (2 * x + 2 * y)\"", "lemma step_4_correct:\n  \"spec\\<^sub>4 p \\<Longrightarrow> spec\\<^sub>3 p\"", "lemma first_addend: \"\n  e\\<^sub>1 = Var ''x'' \\<Longrightarrow>\n  eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>1 = Some x \\<and>\n  wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>1 \\<and>\n  coste e\\<^sub>1 = 0\"", "lemma step_5_correct:\n  \"spec\\<^sub>5 p \\<Longrightarrow> spec\\<^sub>4 p\"", "lemma factorization:\n  \"(2::nat) * x + 2 * y = 2 * (x + y)\"", "lemma second_addend: \"\n  e\\<^sub>2 = Double (Add (Var ''x'') (Var ''y'')) \\<Longrightarrow>\n  eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>2 = Some (2 * x + 2 * y) \\<and>\n  wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>2 \\<and>\n  coste e\\<^sub>2 = 2\"", "lemma step_6_correct:\n  \"spec\\<^sub>6 p \\<Longrightarrow> spec\\<^sub>5 p\"", "lemma step_7_correct:\n  \"spec\\<^sub>7 p \\<Longrightarrow> spec\\<^sub>6 p\"", "lemma p\\<^sub>0_sat_spec\\<^sub>0:\n  \"spec\\<^sub>0 p\\<^sub>0\""], "translations": [["", "lemma eval_wfe:\n  \"wfe \\<Gamma> e \\<Longrightarrow> match \\<E> \\<Gamma> \\<Longrightarrow> eval \\<E> e \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfe \\<Gamma> e; match \\<E> \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> eval \\<E> e \\<noteq> None", "by (induct e, auto simp: match_def mul_opt_def add_opt_def)"], ["", "text \\<open>The environments of a program\nare the ones that match the context of the program.\\<close>"], ["", "definition envs :: \"prog \\<Rightarrow> env set\"\nwhere \"envs p \\<equiv> {\\<E>. match \\<E> (ctxt p)}\""], ["", "text \\<open>Evaluating the body of a well-formed program\nin an environment of the program\nnever yields an error.\\<close>"], ["", "lemma eval_wfp:\n  \"wfp p \\<Longrightarrow> \\<E> \\<in> envs p \\<Longrightarrow> eval \\<E> (body p) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfp p; \\<E> \\<in> envs p\\<rbrakk>\n    \\<Longrightarrow> eval \\<E> (body p) \\<noteq> None", "by (metis envs_def eval_wfe mem_Collect_eq wfp_def)"], ["", "text \\<open>Executing a program with values supplied to the parameters\nyields a non-negative integer result,\nor an error (@{const None})\nif the parameters are not distinct,\nthe number of supplied values differs from the number of parameters,\nor the evaluation of the body yields an error.\\<close>"], ["", "definition \"supply\" :: \"prog \\<Rightarrow> nat list \\<Rightarrow> env option\"\nwhere \"supply p us \\<equiv>\n  let vs = para p in\n  if distinct vs \\<and> length us = length vs\n  then Some (map_of (zip vs us))\n  else None\""], ["", "definition exec :: \"prog \\<Rightarrow> nat list \\<Rightarrow> nat option\"\nwhere \"exec p us \\<equiv>\n  case supply p us of Some \\<E> \\<Rightarrow> eval \\<E> (body p) | None \\<Rightarrow> None\""], ["", "text \\<open>Executing a well-formed program\nwith the same number of values as the number of parameters\nnever yields an error.\\<close>"], ["", "lemma supply_wfp: \"\n  wfp p \\<Longrightarrow>\n  length us = length (para p) \\<Longrightarrow>\n  \\<exists>\\<E> \\<in> envs p. supply p us = Some \\<E>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfp p; length us = length (para p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<E>\\<in>envs p. supply p us = Some \\<E>", "by (auto\n simp: wfp_def supply_def envs_def ctxt_def match_def split: option.split)"], ["", "lemma exec_wfp:\n  \"wfp p \\<Longrightarrow> length us = length (para p) \\<Longrightarrow> exec p us \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfp p; length us = length (para p)\\<rbrakk>\n    \\<Longrightarrow> exec p us \\<noteq> None", "by (metis eval_wfp exec_def option.simps(5) supply_wfp)"], ["", "subsection \\<open>Performance\\<close>"], ["", "text \\<open>\\label{sec:nonfunc}\\<close>"], ["", "text \\<open>As a non-functional semantic aspect,\nthe cost (e.g.\\ time and power) to execute a program\nis modeled as the number of doubling and addition operations.\\<close>"], ["", "fun coste :: \"expr \\<Rightarrow> nat\"\nwhere\n  \"coste (Const c) = 0\" |\n  \"coste (Var v) = 0\" |\n  \"coste (Double e) = 1 + coste e\" |\n  \"coste (Add e\\<^sub>1 e\\<^sub>2) = 1 + coste e\\<^sub>1 + coste e\\<^sub>2\""], ["", "definition costp :: \"prog \\<Rightarrow> nat\"\nwhere \"costp p \\<equiv> coste (body p)\""], ["", "section \\<open>Requirement Specification\\<close>"], ["", "text \\<open>\\label{sec:specificationI}\\<close>"], ["", "text \\<open>The target program must:\n\\begin{enumerate}\n\\item\nBe well-formed.\n\\item\nHave exactly the two parameters @{term \"''x''\"} and @{term \"''y''\"},\nin this order.\n\\item\nProduce the result @{term \"f x y\"}\nwhen @{term x} and @{term y}\nare supplied to @{term \"''x''\"} and @{term \"''y''\"},\nwhere @{term f} is defined below.\n\\item\nNot exceed cost 3.\n\\end{enumerate}\\<close>"], ["", "definition f :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\"\nwhere \"f x y \\<equiv> 3 * x + 2 * y\""], ["", "definition spec\\<^sub>0 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>0 p \\<equiv>\n  wfp p \\<and>\n  para p = [''x'', ''y''] \\<and>\n  (\\<forall>x y. exec p [x, y] = Some (f x y)) \\<and>\n  costp p \\<le> 3\""], ["", "text \\<open>@{const f} is used by @{const spec\\<^sub>0}\nto express a functional requirement on the execution of the program.\n@{const spec\\<^sub>0} includes\nthe non-functional requirement @{term \"costp(p) \\<le> 3\"}\nand the syntactic interface requirement @{term \"para(p) = [''x'', ''y'']\"},\nwhich are not expressed by @{const f} alone\nand are expressible only in terms of programs.\n@{const f} can be computed by a program\nwith cost higher than 3\nand with more or different parameters;\nit can also be computed by programs in different target languages.\\<close>"], ["", "section \\<open>Stepwise Refinement\\<close>"], ["", "text \\<open>\\label{sec:refinementI}\\<close>"], ["", "text \\<open>It is not difficult\nto write a program that satisfies @{const spec\\<^sub>0} and to prove that it does.\nBut with more complex target languages and requirement specifications,\nwriting a program and proving that it satisfies the requirements\nis notoriously difficult.\nStepwise refinement decomposes the proof into manageable pieces,\nconstructing the implementation along the way.\nThe following sequence of refinement steps\nmay be overkill for obtaining an implementation of @{const spec\\<^sub>0},\nbut illustrates concepts that should apply to more complex cases.\\<close>"], ["", "subsection \\<open>Step 1\\<close>"], ["", "text \\<open>\\label{sec:refI:stepI}\\<close>"], ["", "text \\<open>The second conjunct in @{const spec\\<^sub>0} determines the parameters,\nleaving only the body to be determined.\nThat conjunct also reduces\nthe well-formedness of the program to the well-formedness of the body,\nand the execution of the program to the evaluation of the body.\\<close>"], ["", "abbreviation \\<Gamma>\\<^sub>x\\<^sub>y :: ctxt\nwhere \"\\<Gamma>\\<^sub>x\\<^sub>y \\<equiv> {''x'', ''y''}\""], ["", "abbreviation \\<E>\\<^sub>x\\<^sub>y :: \"nat \\<Rightarrow> nat \\<Rightarrow> env\"\nwhere \"\\<E>\\<^sub>x\\<^sub>y x y \\<equiv> [''x'' \\<mapsto> x, ''y'' \\<mapsto> y]\""], ["", "lemma reduce_prog_to_body: \"\n  para p = [''x'', ''y''] \\<Longrightarrow>\n  wfp p = wfe \\<Gamma>\\<^sub>x\\<^sub>y (body p) \\<and>\n  exec p [x, y] = eval (\\<E>\\<^sub>x\\<^sub>y x y) (body p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. para p = [''x'', ''y''] \\<Longrightarrow>\n    wfp p = wfe \\<Gamma>\\<^sub>x\\<^sub>y (body p) \\<and>\n    exec p [x, y] = eval (\\<E>\\<^sub>x\\<^sub>y x y) (body p)", "by (auto simp: wfp_def ctxt_def exec_def supply_def fun_upd_twist)"], ["", "text \\<open>Using lemma \\<open>reduce_prog_to_body\\<close>,\nand using the definition of @{const costp}\nto reduce the cost of the program to the cost of the body,\n@{const spec\\<^sub>0} is refined as follows.\\<close>"], ["", "definition spec\\<^sub>1 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>1 p \\<equiv>\n  wfe \\<Gamma>\\<^sub>x\\<^sub>y (body p) \\<and>\n  para p = [''x'', ''y''] \\<and>\n  (\\<forall>x y. eval (\\<E>\\<^sub>x\\<^sub>y x y) (body p) = Some (f x y)) \\<and>\n  coste (body p) \\<le> 3\""], ["", "lemma step_1_correct:\n \"spec\\<^sub>1 p \\<Longrightarrow> spec\\<^sub>0 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>1 p \\<Longrightarrow> spec\\<^sub>0 p", "by (auto simp: spec\\<^sub>1_def spec\\<^sub>0_def reduce_prog_to_body costp_def)"], ["", "text \\<open>@{const spec\\<^sub>1} and @{const spec\\<^sub>0} are actually equivalent,\nbut the definition of @{const spec\\<^sub>1} is ``closer'' to the implementation\nthan the definition of @{const spec\\<^sub>0}:\nthe latter states constraints on the whole program,\nwhile the former states simpler constraints on the body,\ngiven that the parameters are already determined.\nThe proof of \\<open>step_1_correct\\<close>\ncan also be used to prove the equivalence of @{const spec\\<^sub>1} and @{const spec\\<^sub>0},\nbut in general proving inclusion is easier than proving equivalence.\nSome of the following refinement steps yield non-equivalent predicates.\\<close>"], ["", "subsection \\<open>Step 2\\<close>"], ["", "text \\<open>\\label{sec:refI:stepII}\\<close>"], ["", "text \\<open>The third conjunct in @{const spec\\<^sub>1} says that\nthe body computes @{term \"f x y\"},\nwhich depends on both @{term x} and @{term y},\nand which yields an odd result for some values of @{term x} and @{term y}.\nThus the body cannot be a constant, a variable, or a double,\nleaving a sum as the only option.\nAdding @{term \"\\<exists>e\\<^sub>1 e\\<^sub>2. body p = Add e\\<^sub>1 e\\<^sub>2\"} as a conjunct to @{const spec\\<^sub>1}\nand re-arranging the other conjuncts,\nmoving some of them under the existential quantification\nso that they can be simplified in the next refinement step,\n@{const spec\\<^sub>1} is refined as follows.\\<close>"], ["", "definition spec\\<^sub>2 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>2 p \\<equiv>\n  para p = [''x'', ''y''] \\<and>\n  (\\<exists>e\\<^sub>1 e\\<^sub>2.\n    body p = Add e\\<^sub>1 e\\<^sub>2 \\<and>\n    wfe \\<Gamma>\\<^sub>x\\<^sub>y (body p) \\<and>\n    (\\<forall>x y. eval (\\<E>\\<^sub>x\\<^sub>y x y) (body p) = Some (f x y)) \\<and>\n    coste (body p) \\<le> 3)\""], ["", "lemma step_2_correct:\n \"spec\\<^sub>2 p \\<Longrightarrow> spec\\<^sub>1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>2 p \\<Longrightarrow> spec\\<^sub>1 p", "by (auto simp: spec\\<^sub>2_def spec\\<^sub>1_def)"], ["", "text \\<open>This refinement step is guided by an analysis\nof the constraints in @{const spec\\<^sub>1}.\\<close>"], ["", "subsection \\<open>Step 3\\<close>"], ["", "text \\<open>\\label{sec:refI:stepIII}\\<close>"], ["", "text \\<open>The fact that the body is a sum\nreduces the well-formedness, evaluation, and cost of the body\nto the well-formedness, evaluation, and cost of the addends.\\<close>"], ["", "lemma reduce_body_to_addends: \"\n  body p = Add e\\<^sub>1 e\\<^sub>2 \\<Longrightarrow>\n  wfe \\<Gamma>\\<^sub>x\\<^sub>y (body p) = (wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>1 \\<and> wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>2) \\<and>\n  eval (\\<E>\\<^sub>x\\<^sub>y x y) (body p) = eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>1 \\<oplus> eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>2 \\<and>\n  coste (body p) = 1 + coste e\\<^sub>1 + coste e\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. body p = Add e\\<^sub>1 e\\<^sub>2 \\<Longrightarrow>\n    wfe \\<Gamma>\\<^sub>x\\<^sub>y (body p) =\n    (wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>1 \\<and>\n     wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>2) \\<and>\n    eval (\\<E>\\<^sub>x\\<^sub>y x y) (body p) =\n    eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>1 \\<oplus>\n    eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>2 \\<and>\n    coste (body p) = 1 + coste e\\<^sub>1 + coste e\\<^sub>2", "by auto"], ["", "text \\<open>Using \\<open>reduce_body_to_addends\\<close>\nand arithmetic simplification,\n@{const spec\\<^sub>2} is refined as follows.\\<close>"], ["", "definition spec\\<^sub>3 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>3 p \\<equiv>\n  para p = [''x'', ''y''] \\<and>\n  (\\<exists>e\\<^sub>1 e\\<^sub>2.\n    body p = Add e\\<^sub>1 e\\<^sub>2 \\<and>\n    wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>1 \\<and>\n    wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>2 \\<and>\n    (\\<forall>x y. eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>1 \\<oplus> eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>2 = Some (f x y)) \\<and>\n    coste e\\<^sub>1 + coste e\\<^sub>2 \\<le> 2)\""], ["", "lemma step_3_correct:\n  \"spec\\<^sub>3 p \\<Longrightarrow> spec\\<^sub>2 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>3 p \\<Longrightarrow> spec\\<^sub>2 p", "by (auto simp: spec\\<^sub>3_def spec\\<^sub>2_def)\n\\<comment> \\<open>No need to use @{text reduce_body_to_addends} explicitly,\\<close>\n\\<comment> \\<open>as the default rules that @{text auto} uses to prove it apply here too.\\<close>"], ["", "text \\<open>This refinement step\ndefines the top-level structure of the body,\nreducing the constraints on the body\nto simpler constraints on its components.\\<close>"], ["", "subsection \\<open>Step 4\\<close>"], ["", "text \\<open>\\label{sec:refI:stepIV}\\<close>"], ["", "text \\<open>The second-to-last conjunct in @{const spec\\<^sub>3}\nsuggests to split @{term \"f x y\"} into two addends\nto be computed by @{term e\\<^sub>1} and @{term e\\<^sub>2}.\\<close>"], ["", "text \\<open>The addends @{term \"(3::nat) * x\"} and @{term \"(2::nat) * y\"}\nsuggested by the definition of @{const f}\nwould lead to a blind alley,\nwhere the cost constraints could not be satisfied---%\nthe resulting @{term spec\\<^sub>4} would be always false.\nThe refinement step would be ``correct'' (by strict inclusion)\nbut the refinement sequence could never reach an implementation.\nIt would be necessary to backtrack to @{const spec\\<^sub>3}\nand split @{term \"f x y\"} differently.\\<close>"], ["", "text \\<open>To avoid the blind alley,\nthe definition of @{const f} is rephrased as follows.\\<close>"], ["", "lemma f_rephrased:\n  \"f x y = x + (2 * x + 2 * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x y = x + (2 * x + 2 * y)", "by (auto simp: f_def)"], ["", "text \\<open>This rephrased definition of @{const f}\ndoes not use the multiplication by 3 of the original definition,\nwhich is not (directly) supported by the target language;\nit only uses operations supported by the language.\\<close>"], ["", "text \\<open>Using \\<open>f_rephrased\\<close>, @{const spec\\<^sub>3} is refined as follows.\\<close>"], ["", "definition spec\\<^sub>4 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>4 p \\<equiv>\n  para p = [''x'', ''y''] \\<and>\n  (\\<exists>e\\<^sub>1 e\\<^sub>2.\n    body p = Add e\\<^sub>1 e\\<^sub>2 \\<and>\n    wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>1 \\<and>\n    wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>2 \\<and>\n    (\\<forall>x y. eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>1 = Some x) \\<and>\n    (\\<forall>x y. eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>2 = Some (2 * x + 2 * y)) \\<and>\n    coste e\\<^sub>1 + coste e\\<^sub>2 \\<le> 2)\""], ["", "lemma step_4_correct:\n  \"spec\\<^sub>4 p \\<Longrightarrow> spec\\<^sub>3 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>4 p \\<Longrightarrow> spec\\<^sub>3 p", "by (auto simp: spec\\<^sub>4_def spec\\<^sub>3_def add_opt_def f_rephrased)"], ["", "text \\<open>This refinement step reduces\nthe functional constraint on the body\nto simpler functional constraints on the addends.\nThe functional constraint can be decomposed in different ways,\nsome of which are incompatible with the non-functional cost constraint:\nblind alleys are avoided\nby taking the non-functional constraint into account.\\<close>"], ["", "subsection \\<open>Step 5\\<close>"], ["", "text \\<open>\\label{sec:refI:stepV}\\<close>"], ["", "text \\<open>The term @{term x}\nin the third-to-last conjunct in @{const spec\\<^sub>4}\nis a shallow embedding of the program expression \\verb|x|,\nwhose deep embedding is the term @{term \"Var ''x''\"}.\nUsing the latter as @{term e\\<^sub>1},\nthe third-to-last conjunct in @{const spec\\<^sub>4} is satisfied;\nthe expression is well-formed and has cost 0.\\<close>"], ["", "lemma first_addend: \"\n  e\\<^sub>1 = Var ''x'' \\<Longrightarrow>\n  eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>1 = Some x \\<and>\n  wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>1 \\<and>\n  coste e\\<^sub>1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e\\<^sub>1 = Var ''x'' \\<Longrightarrow>\n    eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>1 = Some x \\<and>\n    wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>1 \\<and> coste e\\<^sub>1 = 0", "by auto"], ["", "text \\<open>Adding @{term \"e\\<^sub>1 = Var ''x''\"} as a conjunct to @{const spec\\<^sub>4}\nand simplifying,\n@{const spec\\<^sub>4} is refined as follows.\\<close>"], ["", "definition spec\\<^sub>5 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>5 p \\<equiv>\n  para p = [''x'', ''y''] \\<and>\n  (\\<exists>e\\<^sub>2.\n    body p = Add (Var ''x'') e\\<^sub>2 \\<and>\n    wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>2 \\<and>\n    (\\<forall>x y. eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>2 = Some (2 * x + 2 * y)) \\<and>\n    coste e\\<^sub>2 \\<le> 2)\""], ["", "lemma step_5_correct:\n  \"spec\\<^sub>5 p \\<Longrightarrow> spec\\<^sub>4 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>5 p \\<Longrightarrow> spec\\<^sub>4 p", "by (auto simp: spec\\<^sub>5_def spec\\<^sub>4_def)\n\\<comment> \\<open>No need to use @{text first_addend} explicitly,\\<close>\n\\<comment> \\<open>as the default rules that @{text auto} uses to prove it apply here too.\\<close>"], ["", "text \\<open>This refinement step determines the first addend of the body,\nleaving only the second addend to be determined.\\<close>"], ["", "subsection \\<open>Step 6\\<close>"], ["", "text \\<open>\\label{sec:refI:stepVI}\\<close>"], ["", "text \\<open>The term @{term \"(2::nat) * x + 2 * y\"}\nin the second-to-last conjunct of @{const spec\\<^sub>5}\nis a shallow embedding of the program expression \\verb|2 * x + 2 * y|,\nwhose deep embedding is the term\n@{term \"Add (Double (Var ''x'')) (Double (Var ''y''))\"}.\nUsing the latter as @{term e\\<^sub>2},\nthe second-to-last conjunct in @{const spec\\<^sub>5} is satisfied,\nbut the last conjunct is not.\nThe following factorization of the shallowly embedded expression\nleads to a reduced cost of the corresponding deeply embedded expression.\\<close>"], ["", "lemma factorization:\n  \"(2::nat) * x + 2 * y = 2 * (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * x + 2 * y = 2 * (x + y)", "by auto"], ["", "text \\<open>The deeply embedded expression\n@{term \"Double (Add (Var ''x'') (Var ''y''))\"},\nwhich corresponds to the shallowly embedded expression\n@{term \"(2::nat) * (x + y)\"},\nsatisfies the second-to-last conjunct of @{const spec\\<^sub>5},\nis well-formed,\nand has cost 2.\\<close>"], ["", "lemma second_addend: \"\n  e\\<^sub>2 = Double (Add (Var ''x'') (Var ''y'')) \\<Longrightarrow>\n  eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>2 = Some (2 * x + 2 * y) \\<and>\n  wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>2 \\<and>\n  coste e\\<^sub>2 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e\\<^sub>2 = Double (Add (Var ''x'') (Var ''y'')) \\<Longrightarrow>\n    eval (\\<E>\\<^sub>x\\<^sub>y x y) e\\<^sub>2 = Some (2 * x + 2 * y) \\<and>\n    wfe \\<Gamma>\\<^sub>x\\<^sub>y e\\<^sub>2 \\<and> coste e\\<^sub>2 = 2", "by (auto simp: add_opt_def mul_opt_def)\n\\<comment> \\<open>No need to use @{text factorization} explicitly,\\<close>\n\\<comment> \\<open>as the default rules that @{text auto} uses to prove it apply here too.\\<close>"], ["", "text \\<open>Adding @{term \"e\\<^sub>2 = Double (Add (Var ''x'') (Var ''y''))\"}\nas a conjunct to @{const spec\\<^sub>5}\nand simplifying,\n@{const spec\\<^sub>5} is refined as follows.\\<close>"], ["", "definition spec\\<^sub>6 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>6 p \\<equiv>\n  para p = [''x'', ''y''] \\<and>\n  body p = Add (Var ''x'') (Double (Add (Var ''x'') (Var ''y'')))\""], ["", "lemma step_6_correct:\n  \"spec\\<^sub>6 p \\<Longrightarrow> spec\\<^sub>5 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>6 p \\<Longrightarrow> spec\\<^sub>5 p", "by (auto simp add: spec\\<^sub>6_def spec\\<^sub>5_def second_addend simp del: eval.simps)"], ["", "text \\<open>This refinement step determines the second addend of the body,\nleaving nothing else to be determined.\\<close>"], ["", "text \\<open>This and the previous refinement step\nturn semantic constraints on the program components @{term e\\<^sub>1} and @{term e\\<^sub>2}\ninto syntactic definitions of such components.\\<close>"], ["", "subsection \\<open>Step 7\\<close>"], ["", "text \\<open>\\label{sec:refI:stepVII}\\<close>"], ["", "text \\<open>@{const spec\\<^sub>6}, which defines the parameters and body,\nis refined to characterize a unique program in explicit syntactic form.\\<close>"], ["", "abbreviation p\\<^sub>0 :: prog\nwhere \"p\\<^sub>0 \\<equiv>\n  \\<lparr>para = [''x'', ''y''],\n   body = Add (Var ''x'') (Double (Add (Var ''x'') (Var ''y'')))\\<rparr>\""], ["", "definition spec\\<^sub>7 :: \"prog \\<Rightarrow> bool\"\nwhere \"spec\\<^sub>7 p \\<equiv> p = p\\<^sub>0\""], ["", "lemma step_7_correct:\n  \"spec\\<^sub>7 p \\<Longrightarrow> spec\\<^sub>6 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>7 p \\<Longrightarrow> spec\\<^sub>6 p", "by (auto simp: spec\\<^sub>7_def spec\\<^sub>6_def)"], ["", "text \\<open>The program satisfies @{const spec\\<^sub>0} by construction.\nThe program witnesses the consistency of the requirements,\ni.e.\\ the fact that @{const spec\\<^sub>0} is not always false.\\<close>"], ["", "lemma p\\<^sub>0_sat_spec\\<^sub>0:\n  \"spec\\<^sub>0 p\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec\\<^sub>0 p\\<^sub>0", "by (metis\n step_1_correct\n step_2_correct\n step_3_correct\n step_4_correct\n step_5_correct\n step_6_correct\n step_7_correct\n spec\\<^sub>7_def)"], ["", "text \\<open>From @{const p\\<^sub>0}, the program text\n\\begin{verbatim}\n  prog (x,y) {x + 2 * (x + y)}\n\\end{verbatim}\nis easily obtained.\\<close>"], ["", "end %invisible"]]}