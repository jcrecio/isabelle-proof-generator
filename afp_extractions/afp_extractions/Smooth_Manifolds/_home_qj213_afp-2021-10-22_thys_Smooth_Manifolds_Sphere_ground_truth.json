{"file_name": "/home/qj213/afp-2021-10-22/thys/Smooth_Manifolds/Sphere.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Smooth_Manifolds", "problem_names": ["lemma transfer_continuous_on1[transfer_rule]:\n  includes lifting_syntax\n  shows \"(rel_set (=) ===> ((=) ===> pcr_sphere (=)) ===> (=)) (\\<lambda>X::'a::t2_space set. continuous_on X) continuous_on\"", "lemma transfer_continuous_on2[transfer_rule]:\n  includes lifting_syntax\n  shows \"(rel_set (pcr_sphere (=)) ===> (pcr_sphere (=) ===> (=)) ===> (=)) (\\<lambda>X. continuous_on (X \\<inter> {x. norm x = 1})) (\\<lambda>X. continuous_on X)\"", "lemma st_proj1_inv_continuous:\n  \"continuous_on UNIV st_proj1_inv\"", "lemma st_proj1_continuous:\n  \"continuous_on (UNIV - {top_sphere}) st_proj1\"", "lemma st_proj1_inv: \"st_proj1_inv (st_proj1 x) = x\"\n  if \"x \\<noteq> top_sphere\"", "lemma st_proj1_inv_inv: \"st_proj1 (st_proj1_inv x) = x\"", "lemma st_proj1_inv_ne_top: \"st_proj1_inv xa \\<noteq> top_sphere\"", "lemma homeomorphism_st_proj1: \"homeomorphism (UNIV - {top_sphere}) UNIV st_proj1 st_proj1_inv\"", "lemma st_proj2_inv_continuous:\n  \"continuous_on UNIV st_proj2_inv\"", "lemma st_proj2_continuous:\n  \"continuous_on (UNIV - {bot_sphere}) st_proj2\"", "lemma st_proj2_inv: \"st_proj2_inv (st_proj2 x) = x\"\n  if \"x \\<noteq> bot_sphere\"", "lemma st_proj2_inv_inv: \"st_proj2 (st_proj2_inv x) = x\"", "lemma st_proj2_inv_ne_top: \"st_proj2_inv xa \\<noteq> bot_sphere\"", "lemma homeomorphism_st_proj2: \"homeomorphism (UNIV - {bot_sphere}) UNIV st_proj2 st_proj2_inv\"", "lemma st_projs_compat:\n  includes lifting_syntax\n  shows \"\\<infinity>-smooth_compat st_proj1_chart st_proj2_chart\"", "lemma c_manifold_atlas_sphere: \"c_manifold charts_sphere \\<infinity>\""], "translations": [["", "lemma transfer_continuous_on1[transfer_rule]:\n  includes lifting_syntax\n  shows \"(rel_set (=) ===> ((=) ===> pcr_sphere (=)) ===> (=)) (\\<lambda>X::'a::t2_space set. continuous_on X) continuous_on\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (=) ===> ((=) ===> pcr_sphere (=)) ===> (=)) continuous_on\n     continuous_on", "apply (rule continuous_on_transfer_right_total2)"], ["proof (prove)\ngoal (7 subgoals):\n 1. Domainp (pcr_sphere (=)) = ?BP\n 2. bi_unique (=)\n 3. bi_total (=)\n 4. (rel_set (=) ===> (=)) open open\n 5. bi_unique (pcr_sphere (=))\n 6. right_total (pcr_sphere (=))\n 7. (rel_set (pcr_sphere (=)) ===> (=)) (openin (top_of_set (Collect ?BP)))\n     open", "apply transfer_step"], ["proof (prove)\ngoal (6 subgoals):\n 1. bi_unique (=)\n 2. bi_total (=)\n 3. (rel_set (=) ===> (=)) open open\n 4. bi_unique (pcr_sphere (=))\n 5. right_total (pcr_sphere (=))\n 6. (rel_set (pcr_sphere (=)) ===> (=))\n     (openin (top_of_set {a. norm a = 1})) open", "apply transfer_step"], ["proof (prove)\ngoal (5 subgoals):\n 1. bi_total (=)\n 2. (rel_set (=) ===> (=)) open open\n 3. bi_unique (pcr_sphere (=))\n 4. right_total (pcr_sphere (=))\n 5. (rel_set (pcr_sphere (=)) ===> (=))\n     (openin (top_of_set {a. norm a = 1})) open", "apply transfer_step"], ["proof (prove)\ngoal (4 subgoals):\n 1. (rel_set (=) ===> (=)) open open\n 2. bi_unique (pcr_sphere (=))\n 3. right_total (pcr_sphere (=))\n 4. (rel_set (pcr_sphere (=)) ===> (=))\n     (openin (top_of_set {a. norm a = 1})) open", "apply transfer_prover"], ["proof (prove)\ngoal (3 subgoals):\n 1. bi_unique (pcr_sphere (=))\n 2. right_total (pcr_sphere (=))\n 3. (rel_set (pcr_sphere (=)) ===> (=))\n     (openin (top_of_set {a. norm a = 1})) open", "apply transfer_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. right_total (pcr_sphere (=))\n 2. (rel_set (pcr_sphere (=)) ===> (=))\n     (openin (top_of_set {a. norm a = 1})) open", "apply transfer_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (pcr_sphere (=)) ===> (=))\n     (openin (top_of_set {a. norm a = 1})) open", "apply transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma transfer_continuous_on2[transfer_rule]:\n  includes lifting_syntax\n  shows \"(rel_set (pcr_sphere (=)) ===> (pcr_sphere (=) ===> (=)) ===> (=)) (\\<lambda>X. continuous_on (X \\<inter> {x. norm x = 1})) (\\<lambda>X. continuous_on X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (pcr_sphere (=)) ===> (pcr_sphere (=) ===> (=)) ===> (=))\n     (\\<lambda>X. continuous_on (X \\<inter> {x. norm x = 1})) continuous_on", "apply (rule continuous_on_transfer_right_total)"], ["proof (prove)\ngoal (7 subgoals):\n 1. Domainp (pcr_sphere (=)) = (\\<lambda>x. norm x = 1)\n 2. bi_unique (pcr_sphere (=))\n 3. right_total (pcr_sphere (=))\n 4. (rel_set (pcr_sphere (=)) ===> (=))\n     (openin (top_of_set {x. norm x = 1})) open\n 5. bi_unique (=)\n 6. bi_total (=)\n 7. (rel_set (=) ===> (=)) open open", "apply transfer_step"], ["proof (prove)\ngoal (6 subgoals):\n 1. bi_unique (pcr_sphere (=))\n 2. right_total (pcr_sphere (=))\n 3. (rel_set (pcr_sphere (=)) ===> (=))\n     (openin (top_of_set {x. norm x = 1})) open\n 4. bi_unique (=)\n 5. bi_total (=)\n 6. (rel_set (=) ===> (=)) open open", "apply transfer_step"], ["proof (prove)\ngoal (5 subgoals):\n 1. right_total (pcr_sphere (=))\n 2. (rel_set (pcr_sphere (=)) ===> (=))\n     (openin (top_of_set {x. norm x = 1})) open\n 3. bi_unique (=)\n 4. bi_total (=)\n 5. (rel_set (=) ===> (=)) open open", "apply transfer_step"], ["proof (prove)\ngoal (4 subgoals):\n 1. (rel_set (pcr_sphere (=)) ===> (=))\n     (openin (top_of_set {x. norm x = 1})) open\n 2. bi_unique (=)\n 3. bi_total (=)\n 4. (rel_set (=) ===> (=)) open open", "apply transfer_prover"], ["proof (prove)\ngoal (3 subgoals):\n 1. bi_unique (=)\n 2. bi_total (=)\n 3. (rel_set (=) ===> (=)) open open", "apply transfer_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. bi_total (=)\n 2. (rel_set (=) ===> (=)) open open", "apply transfer_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (=) ===> (=)) open open", "apply transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma st_proj1_inv_continuous:\n  \"continuous_on UNIV st_proj1_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV st_proj1_inv", "by transfer (auto intro!: continuous_intros simp: add_nonneg_eq_0_iff)"], ["", "lemma st_proj1_continuous:\n  \"continuous_on (UNIV - {top_sphere}) st_proj1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (UNIV - {top_sphere}) st_proj1", "by transfer (auto intro!: continuous_intros simp: add_nonneg_eq_0_iff split_beta' norm_prod_def)"], ["", "lemma st_proj1_inv: \"st_proj1_inv (st_proj1 x) = x\"\n  if \"x \\<noteq> top_sphere\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st_proj1_inv (st_proj1 x) = x", "using that"], ["proof (prove)\nusing this:\n  x \\<noteq> top_sphere\n\ngoal (1 subgoal):\n 1. st_proj1_inv (st_proj1 x) = x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm x = 1; x \\<noteq> (0::'a, 1)\\<rbrakk>\n       \\<Longrightarrow> ((2 /\n                           ((norm\n                              (case x of\n                               (x, z) \\<Rightarrow>\n                                 x /\\<^sub>R (1 - z)))\\<^sup>2 +\n                            1)) *\\<^sub>R\n                          (case x of\n                           (x, z) \\<Rightarrow> x /\\<^sub>R (1 - z)),\n                          ((norm\n                             (case x of\n                              (x, z) \\<Rightarrow>\n                                x /\\<^sub>R (1 - z)))\\<^sup>2 -\n                           1) /\n                          ((norm\n                             (case x of\n                              (x, z) \\<Rightarrow>\n                                x /\\<^sub>R (1 - z)))\\<^sup>2 +\n                           1)) =\n                         x", "proof (clarsimp, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 - b) /\n                          ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 -\n                          1) /\n                         ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "fix a::'a and b::real"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 - b) /\n                          ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 -\n                          1) /\n                         ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "assume *: \"norm (a, b) = 1\" and ab: \"a = 0 \\<longrightarrow> b \\<noteq> 1\""], ["proof (state)\nthis:\n  norm (a, b) = 1\n  a = (0::'a) \\<longrightarrow> b \\<noteq> 1\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 - b) /\n                          ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 -\n                          1) /\n                         ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "then"], ["proof (chain)\npicking this:\n  norm (a, b) = 1\n  a = (0::'a) \\<longrightarrow> b \\<noteq> 1", "have \"b \\<noteq> 1\""], ["proof (prove)\nusing this:\n  norm (a, b) = 1\n  a = (0::'a) \\<longrightarrow> b \\<noteq> 1\n\ngoal (1 subgoal):\n 1. b \\<noteq> 1", "by (auto simp: norm_prod_def)"], ["proof (state)\nthis:\n  b \\<noteq> 1\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 - b) /\n                          ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 -\n                          1) /\n                         ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "have na: \"(norm a)\\<^sup>2 = 1 - b\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm a)\\<^sup>2 = 1 - b\\<^sup>2", "using *"], ["proof (prove)\nusing this:\n  norm (a, b) = 1\n\ngoal (1 subgoal):\n 1. (norm a)\\<^sup>2 = 1 - b\\<^sup>2", "unfolding norm_prod_def"], ["proof (prove)\nusing this:\n  sqrt ((norm (fst (a, b)))\\<^sup>2 + (norm (snd (a, b)))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. (norm a)\\<^sup>2 = 1 - b\\<^sup>2", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  (norm a)\\<^sup>2 = 1 - b\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 - b) /\n                          ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 -\n                          1) /\n                         ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "define S where \"S = norm (a /\\<^sub>R (1 - b))\""], ["proof (state)\nthis:\n  S = norm (a /\\<^sub>R (1 - b))\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 - b) /\n                          ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 -\n                          1) /\n                         ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "have \"b = (S\\<^sup>2 - 1) / (S\\<^sup>2 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = (S\\<^sup>2 - 1) / (S\\<^sup>2 + 1)", "by (auto simp: S_def divide_simps \\<open>b \\<noteq> 1\\<close> na)\n       (auto simp: power2_eq_square algebra_simps \\<open>b \\<noteq> 1\\<close>)"], ["proof (state)\nthis:\n  b = (S\\<^sup>2 - 1) / (S\\<^sup>2 + 1)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 - b) /\n                          ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 -\n                          1) /\n                         ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "then"], ["proof (chain)\npicking this:\n  b = (S\\<^sup>2 - 1) / (S\\<^sup>2 + 1)", "show \"((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 - 1) / ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 + 1) = b\""], ["proof (prove)\nusing this:\n  b = (S\\<^sup>2 - 1) / (S\\<^sup>2 + 1)\n\ngoal (1 subgoal):\n 1. ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 - 1) /\n    ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 + 1) =\n    b", "by (simp add: S_def)"], ["proof (state)\nthis:\n  ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 - 1) /\n  ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 + 1) =\n  b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 - b) /\n                          ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a", "have \"1 = (2 / (1 - b) / (S\\<^sup>2 + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = 2 / (1 - b) / (S\\<^sup>2 + 1)", "by (auto simp: S_def divide_simps \\<open>b \\<noteq> 1\\<close> na) (auto simp: power2_eq_square algebra_simps \\<open>b \\<noteq> 1\\<close>)"], ["proof (state)\nthis:\n  1 = 2 / (1 - b) / (S\\<^sup>2 + 1)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 - b) /\n                          ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a", "then"], ["proof (chain)\npicking this:\n  1 = 2 / (1 - b) / (S\\<^sup>2 + 1)", "have \"a = (2 / (1 - b) / (S\\<^sup>2 + 1)) *\\<^sub>R a\""], ["proof (prove)\nusing this:\n  1 = 2 / (1 - b) / (S\\<^sup>2 + 1)\n\ngoal (1 subgoal):\n 1. a = (2 / (1 - b) / (S\\<^sup>2 + 1)) *\\<^sub>R a", "by simp"], ["proof (state)\nthis:\n  a = (2 / (1 - b) / (S\\<^sup>2 + 1)) *\\<^sub>R a\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 - b) /\n                          ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a", "then"], ["proof (chain)\npicking this:\n  a = (2 / (1 - b) / (S\\<^sup>2 + 1)) *\\<^sub>R a", "show \"(2 * inverse (1 - b) / ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 + 1)) *\\<^sub>R a = a\""], ["proof (prove)\nusing this:\n  a = (2 / (1 - b) / (S\\<^sup>2 + 1)) *\\<^sub>R a\n\ngoal (1 subgoal):\n 1. (2 * inverse (1 - b) /\n     ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 + 1)) *\\<^sub>R\n    a =\n    a", "by (auto simp: S_def divide_simps)"], ["proof (state)\nthis:\n  (2 * inverse (1 - b) /\n   ((inverse \\<bar>1 - b\\<bar> * norm a)\\<^sup>2 + 1)) *\\<^sub>R\n  a =\n  a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma st_proj1_inv_inv: \"st_proj1 (st_proj1_inv x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st_proj1 (st_proj1_inv x) = x", "by transfer (auto simp: divide_simps add_nonneg_eq_0_iff)"], ["", "lemma st_proj1_inv_ne_top: \"st_proj1_inv xa \\<noteq> top_sphere\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st_proj1_inv xa \\<noteq> top_sphere", "by transfer (auto simp: divide_simps add_nonneg_eq_0_iff)"], ["", "lemma homeomorphism_st_proj1: \"homeomorphism (UNIV - {top_sphere}) UNIV st_proj1 st_proj1_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homeomorphism (UNIV - {top_sphere}) UNIV st_proj1 st_proj1_inv", "apply (auto simp: homeomorphism_def st_proj1_continuous st_proj1_inv_continuous st_proj1_inv_inv\n      st_proj1_inv st_proj1_inv_ne_top)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> st_proj1 ` (UNIV - {top_sphere})\n 2. \\<And>x. x \\<notin> range st_proj1_inv \\<Longrightarrow> x = top_sphere", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> st_proj1 ` (UNIV - {top_sphere})", "by (rule image_eqI[where x=\"st_proj1_inv x\"]) (auto simp: st_proj1_inv_inv st_proj1_inv_ne_top)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<notin> range st_proj1_inv \\<Longrightarrow> x = top_sphere", "by (metis rangeI st_proj1_inv)"], ["", "lemma st_proj2_inv_continuous:\n  \"continuous_on UNIV st_proj2_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV st_proj2_inv", "by transfer (auto intro!: continuous_intros simp: add_nonneg_eq_0_iff)"], ["", "lemma st_proj2_continuous:\n  \"continuous_on (UNIV - {bot_sphere}) st_proj2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (UNIV - {bot_sphere}) st_proj2", "apply (transfer; auto intro!: continuous_intros simp: add_nonneg_eq_0_iff split_beta' norm_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(norm a)\\<^sup>2 + b\\<^sup>2 = 1; 1 + b = 0\\<rbrakk>\n       \\<Longrightarrow> a = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(norm a)\\<^sup>2 + b\\<^sup>2 = 1; 1 + b = 0\\<rbrakk>\n       \\<Longrightarrow> a = (0::'a)", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(norm a)\\<^sup>2 + b\\<^sup>2 = 1; 1 + b = 0\\<rbrakk>\n       \\<Longrightarrow> a = (0::'a)", "assume 1: \"(norm a)^2 + b^2 = 1\" and 2: \"1 + b = 0\""], ["proof (state)\nthis:\n  (norm a)\\<^sup>2 + b\\<^sup>2 = 1\n  1 + b = 0\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(norm a)\\<^sup>2 + b\\<^sup>2 = 1; 1 + b = 0\\<rbrakk>\n       \\<Longrightarrow> a = (0::'a)", "have \"b = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = - 1", "using 2"], ["proof (prove)\nusing this:\n  1 + b = 0\n\ngoal (1 subgoal):\n 1. b = - 1", "by auto"], ["proof (state)\nthis:\n  b = - 1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(norm a)\\<^sup>2 + b\\<^sup>2 = 1; 1 + b = 0\\<rbrakk>\n       \\<Longrightarrow> a = (0::'a)", "then"], ["proof (chain)\npicking this:\n  b = - 1", "show \"a = 0\""], ["proof (prove)\nusing this:\n  b = - 1\n\ngoal (1 subgoal):\n 1. a = (0::'b)", "using 1"], ["proof (prove)\nusing this:\n  b = - 1\n  (norm a)\\<^sup>2 + b\\<^sup>2 = 1\n\ngoal (1 subgoal):\n 1. a = (0::'b)", "by auto"], ["proof (state)\nthis:\n  a = (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma st_proj2_inv: \"st_proj2_inv (st_proj2 x) = x\"\n  if \"x \\<noteq> bot_sphere\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st_proj2_inv (st_proj2 x) = x", "using that"], ["proof (prove)\nusing this:\n  x \\<noteq> bot_sphere\n\ngoal (1 subgoal):\n 1. st_proj2_inv (st_proj2 x) = x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>norm x = 1; x \\<noteq> (0::'a, - 1)\\<rbrakk>\n       \\<Longrightarrow> ((2 /\n                           ((norm\n                              (case x of\n                               (x, z) \\<Rightarrow>\n                                 x /\\<^sub>R (1 + z)))\\<^sup>2 +\n                            1)) *\\<^sub>R\n                          (case x of\n                           (x, z) \\<Rightarrow> x /\\<^sub>R (1 + z)),\n                          (1 -\n                           (norm\n                             (case x of\n                              (x, z) \\<Rightarrow>\n                                x /\\<^sub>R (1 + z)))\\<^sup>2) /\n                          ((norm\n                             (case x of\n                              (x, z) \\<Rightarrow>\n                                x /\\<^sub>R (1 + z)))\\<^sup>2 +\n                           1)) =\n                         x", "proof (clarsimp, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 + b) /\n                          ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (1 -\n                          (inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2) /\n                         ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "fix a::'a and b::real"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 + b) /\n                          ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (1 -\n                          (inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2) /\n                         ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "assume *: \"norm (a, b) = 1\" and ab: \"a = 0 \\<longrightarrow> b \\<noteq> -1\""], ["proof (state)\nthis:\n  norm (a, b) = 1\n  a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 + b) /\n                          ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (1 -\n                          (inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2) /\n                         ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "then"], ["proof (chain)\npicking this:\n  norm (a, b) = 1\n  a = (0::'a) \\<longrightarrow> b \\<noteq> - 1", "have \"b \\<noteq> -1\""], ["proof (prove)\nusing this:\n  norm (a, b) = 1\n  a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. b \\<noteq> - 1", "by (auto simp: norm_prod_def)"], ["proof (state)\nthis:\n  b \\<noteq> - 1\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 + b) /\n                          ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (1 -\n                          (inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2) /\n                         ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "then"], ["proof (chain)\npicking this:\n  b \\<noteq> - 1", "have \"1 + b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  b \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. 1 + b \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  1 + b \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 + b) /\n                          ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (1 -\n                          (inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2) /\n                         ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "then"], ["proof (chain)\npicking this:\n  1 + b \\<noteq> 0", "have \"2 + b * 2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  1 + b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 + b * 2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  2 + b * 2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 + b) /\n                          ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (1 -\n                          (inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2) /\n                         ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "have na: \"(norm a)\\<^sup>2 = 1 - b\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (norm a)\\<^sup>2 = 1 - b\\<^sup>2", "using *"], ["proof (prove)\nusing this:\n  norm (a, b) = 1\n\ngoal (1 subgoal):\n 1. (norm a)\\<^sup>2 = 1 - b\\<^sup>2", "unfolding norm_prod_def"], ["proof (prove)\nusing this:\n  sqrt ((norm (fst (a, b)))\\<^sup>2 + (norm (snd (a, b)))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. (norm a)\\<^sup>2 = 1 - b\\<^sup>2", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  (norm a)\\<^sup>2 = 1 - b\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 + b) /\n                          ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (1 -\n                          (inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2) /\n                         ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "define S where \"S = norm (a /\\<^sub>R (1 + b))\""], ["proof (state)\nthis:\n  S = norm (a /\\<^sub>R (1 + b))\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 + b) /\n                          ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (1 -\n                          (inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2) /\n                         ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "have \"b = (1 - S\\<^sup>2) / (S\\<^sup>2 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = (1 - S\\<^sup>2) / (S\\<^sup>2 + 1)", "by (auto simp: S_def divide_simps \\<open>b \\<noteq> -1\\<close> na)\n       (auto simp: power2_eq_square algebra_simps \\<open>b \\<noteq> -1\\<close> \\<open>1 + b \\<noteq> 0\\<close> \\<open>2 + b * 2 \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  b = (1 - S\\<^sup>2) / (S\\<^sup>2 + 1)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 + b) /\n                          ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a\n 2. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (1 -\n                          (inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2) /\n                         ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                          1) =\n                         b", "then"], ["proof (chain)\npicking this:\n  b = (1 - S\\<^sup>2) / (S\\<^sup>2 + 1)", "show \"(1 - (inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2) / ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 + 1) = b\""], ["proof (prove)\nusing this:\n  b = (1 - S\\<^sup>2) / (S\\<^sup>2 + 1)\n\ngoal (1 subgoal):\n 1. (1 - (inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2) /\n    ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 + 1) =\n    b", "by (simp add: S_def)"], ["proof (state)\nthis:\n  (1 - (inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2) /\n  ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 + 1) =\n  b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 + b) /\n                          ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a", "have \"1 = (2 / (1 + b) / (S\\<^sup>2 + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = 2 / (1 + b) / (S\\<^sup>2 + 1)", "by (auto simp: S_def divide_simps \\<open>b \\<noteq> -1\\<close> na)\n       (auto simp: power2_eq_square algebra_simps \\<open>b \\<noteq> -1\\<close> \\<open>1 + b \\<noteq> 0\\<close> \\<open>2 + b * 2 \\<noteq> 0\\<close>)"], ["proof (state)\nthis:\n  1 = 2 / (1 + b) / (S\\<^sup>2 + 1)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 + b) /\n                          ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a", "then"], ["proof (chain)\npicking this:\n  1 = 2 / (1 + b) / (S\\<^sup>2 + 1)", "have \"a = (2 / (1 + b) / (S\\<^sup>2 + 1)) *\\<^sub>R a\""], ["proof (prove)\nusing this:\n  1 = 2 / (1 + b) / (S\\<^sup>2 + 1)\n\ngoal (1 subgoal):\n 1. a = (2 / (1 + b) / (S\\<^sup>2 + 1)) *\\<^sub>R a", "by simp"], ["proof (state)\nthis:\n  a = (2 / (1 + b) / (S\\<^sup>2 + 1)) *\\<^sub>R a\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>norm (a, b) = 1;\n        a = (0::'a) \\<longrightarrow> b \\<noteq> - 1\\<rbrakk>\n       \\<Longrightarrow> (2 * inverse (1 + b) /\n                          ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 +\n                           1)) *\\<^sub>R\n                         a =\n                         a", "then"], ["proof (chain)\npicking this:\n  a = (2 / (1 + b) / (S\\<^sup>2 + 1)) *\\<^sub>R a", "show \"(2 * inverse (1 + b) / ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 + 1)) *\\<^sub>R a = a\""], ["proof (prove)\nusing this:\n  a = (2 / (1 + b) / (S\\<^sup>2 + 1)) *\\<^sub>R a\n\ngoal (1 subgoal):\n 1. (2 * inverse (1 + b) /\n     ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 + 1)) *\\<^sub>R\n    a =\n    a", "by (auto simp: S_def divide_simps)"], ["proof (state)\nthis:\n  (2 * inverse (1 + b) /\n   ((inverse \\<bar>1 + b\\<bar> * norm a)\\<^sup>2 + 1)) *\\<^sub>R\n  a =\n  a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma st_proj2_inv_inv: \"st_proj2 (st_proj2_inv x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st_proj2 (st_proj2_inv x) = x", "by transfer (auto simp: divide_simps add_nonneg_eq_0_iff)"], ["", "lemma st_proj2_inv_ne_top: \"st_proj2_inv xa \\<noteq> bot_sphere\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st_proj2_inv xa \\<noteq> bot_sphere", "by transfer (auto simp: divide_simps add_nonneg_eq_0_iff)"], ["", "lemma homeomorphism_st_proj2: \"homeomorphism (UNIV - {bot_sphere}) UNIV st_proj2 st_proj2_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homeomorphism (UNIV - {bot_sphere}) UNIV st_proj2 st_proj2_inv", "apply (auto simp: homeomorphism_def st_proj2_continuous st_proj2_inv_continuous st_proj2_inv_inv\n      st_proj2_inv st_proj2_inv_ne_top)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> st_proj2 ` (UNIV - {bot_sphere})\n 2. \\<And>x. x \\<notin> range st_proj2_inv \\<Longrightarrow> x = bot_sphere", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> st_proj2 ` (UNIV - {bot_sphere})", "by (rule image_eqI[where x=\"st_proj2_inv x\"]) (auto simp: st_proj2_inv_inv st_proj2_inv_ne_top)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<notin> range st_proj2_inv \\<Longrightarrow> x = bot_sphere", "by (metis rangeI st_proj2_inv)"], ["", "lift_definition st_proj1_chart :: \"('a sphere, 'a::euclidean_space) chart\"\n  is \"(UNIV - {top_sphere::'a sphere}, UNIV::'a set, st_proj1, st_proj1_inv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (UNIV - {top_sphere}, UNIV, st_proj1, st_proj1_inv)\n    \\<in> {(d, d', f, f').\n           open d \\<and> open d' \\<and> homeomorphism d d' f f'}", "using homeomorphism_st_proj1"], ["proof (prove)\nusing this:\n  homeomorphism (UNIV - {top_sphere}) UNIV st_proj1 st_proj1_inv\n\ngoal (1 subgoal):\n 1. (UNIV - {top_sphere}, UNIV, st_proj1, st_proj1_inv)\n    \\<in> {(d, d', f, f').\n           open d \\<and> open d' \\<and> homeomorphism d d' f f'}", "by blast"], ["", "lift_definition st_proj2_chart :: \"('a sphere, 'a::euclidean_space) chart\"\n  is \"(UNIV - {bot_sphere::'a sphere}, UNIV::'a set, st_proj2, st_proj2_inv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (UNIV - {bot_sphere}, UNIV, st_proj2, st_proj2_inv)\n    \\<in> {(d, d', f, f').\n           open d \\<and> open d' \\<and> homeomorphism d d' f f'}", "using homeomorphism_st_proj2"], ["proof (prove)\nusing this:\n  homeomorphism (UNIV - {bot_sphere}) UNIV st_proj2 st_proj2_inv\n\ngoal (1 subgoal):\n 1. (UNIV - {bot_sphere}, UNIV, st_proj2, st_proj2_inv)\n    \\<in> {(d, d', f, f').\n           open d \\<and> open d' \\<and> homeomorphism d d' f f'}", "by blast"], ["", "lemma st_projs_compat:\n  includes lifting_syntax\n  shows \"\\<infinity>-smooth_compat st_proj1_chart st_proj2_chart\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity>-smooth_compat st_proj1_chart st_proj2_chart", "unfolding smooth_compat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on\n     (apply_chart st_proj1_chart `\n      (domain st_proj1_chart \\<inter> domain st_proj2_chart))\n     (apply_chart st_proj2_chart \\<circ> inv_chart st_proj1_chart) \\<and>\n    smooth_on\n     (apply_chart st_proj2_chart `\n      (domain st_proj1_chart \\<inter> domain st_proj2_chart))\n     (apply_chart st_proj1_chart \\<circ> inv_chart st_proj2_chart)", "apply (transfer; auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. smooth_on\n     (st_proj1 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj2 \\<circ> st_proj1_inv)\n 2. smooth_on\n     (st_proj2 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj1 \\<circ> st_proj2_inv)", "proof goal_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. smooth_on\n     (st_proj1 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj2 \\<circ> st_proj1_inv)\n 2. smooth_on\n     (st_proj2 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj1 \\<circ> st_proj2_inv)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. smooth_on\n     (st_proj1 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj2 \\<circ> st_proj1_inv)\n 2. smooth_on\n     (st_proj2 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj1 \\<circ> st_proj2_inv)", "have *: \"smooth_on ((\\<lambda>(x::'a, z). x /\\<^sub>R (1 - z)) ` (({a. norm a = 1} - {(0, 1)}) \\<inter> ({a. norm a = 1} - {(0, - 1)})))\n     ((\\<lambda>(x, z). x /\\<^sub>R (1 + z)) \\<circ> (\\<lambda>x. ((2 / ((norm x)\\<^sup>2 + 1)) *\\<^sub>R x, ((norm x)\\<^sup>2 - 1) / ((norm x)\\<^sup>2 + 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on\n     ((\\<lambda>(x, z). x /\\<^sub>R (1 - z)) `\n      (({a. norm a = 1} - {(0::'a, 1)}) \\<inter>\n       ({a. norm a = 1} - {(0::'a, - 1)})))\n     ((\\<lambda>(x, z). x /\\<^sub>R (1 + z)) \\<circ>\n      (\\<lambda>x.\n          ((2 / ((norm x)\\<^sup>2 + 1)) *\\<^sub>R x,\n           ((norm x)\\<^sup>2 - 1) / ((norm x)\\<^sup>2 + 1))))", "apply (rule smooth_on_subset[where T=\"UNIV - {0}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. smooth_on (UNIV - {0::'a})\n     ((\\<lambda>(x, z). x /\\<^sub>R (1 + z)) \\<circ>\n      (\\<lambda>x.\n          ((2 / ((norm x)\\<^sup>2 + 1)) *\\<^sub>R x,\n           ((norm x)\\<^sup>2 - 1) / ((norm x)\\<^sup>2 + 1))))\n 2. (\\<lambda>(x, z). x /\\<^sub>R (1 - z)) `\n    (({a. norm a = 1} - {(0::'a, 1)}) \\<inter>\n     ({a. norm a = 1} - {(0::'a, - 1)}))\n    \\<subseteq> UNIV - {0::'a}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on (UNIV - {0::'a})\n     ((\\<lambda>(x, z). x /\\<^sub>R (1 + z)) \\<circ>\n      (\\<lambda>x.\n          ((2 / ((norm x)\\<^sup>2 + 1)) *\\<^sub>R x,\n           ((norm x)\\<^sup>2 - 1) / ((norm x)\\<^sup>2 + 1))))", "by (auto intro!: smooth_on_divide smooth_on_inverse smooth_on_scaleR smooth_on_mult smooth_on_add\n          smooth_on_minus smooth_on_norm simp: o_def power2_eq_square add_nonneg_eq_0_iff divide_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, z). x /\\<^sub>R (1 - z)) `\n    (({a. norm a = 1} - {(0::'a, 1)}) \\<inter>\n     ({a. norm a = 1} - {(0::'a, - 1)}))\n    \\<subseteq> UNIV - {0::'a}", "apply (auto simp: norm_prod_def power2_eq_square)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b * b = 1; b \\<noteq> 1\\<rbrakk> \\<Longrightarrow> b = - 1", "apply sos"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  smooth_on\n   ((\\<lambda>(x, z). x /\\<^sub>R (1 - z)) `\n    (({a. norm a = 1} - {(0::'a, 1)}) \\<inter>\n     ({a. norm a = 1} - {(0::'a, - 1)})))\n   ((\\<lambda>(x, z). x /\\<^sub>R (1 + z)) \\<circ>\n    (\\<lambda>x.\n        ((2 / ((norm x)\\<^sup>2 + 1)) *\\<^sub>R x,\n         ((norm x)\\<^sup>2 - 1) / ((norm x)\\<^sup>2 + 1))))\n\ngoal (2 subgoals):\n 1. smooth_on\n     (st_proj1 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj2 \\<circ> st_proj1_inv)\n 2. smooth_on\n     (st_proj2 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj1 \\<circ> st_proj2_inv)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on\n     (st_proj1 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj2 \\<circ> st_proj1_inv)", "by transfer (rule *)"], ["proof (state)\nthis:\n  smooth_on\n   (st_proj1 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n   (st_proj2 \\<circ> st_proj1_inv)\n\ngoal (1 subgoal):\n 1. smooth_on\n     (st_proj2 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj1 \\<circ> st_proj2_inv)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. smooth_on\n     (st_proj2 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj1 \\<circ> st_proj2_inv)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. smooth_on\n     (st_proj2 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj1 \\<circ> st_proj2_inv)", "have *: \"smooth_on ((\\<lambda>(x::'a, z). x /\\<^sub>R (1 + z)) ` (({a. norm a = 1} - {(0, 1)}) \\<inter> ({a. norm a = 1} - {(0, - 1)})))\n     ((\\<lambda>(x, z). x /\\<^sub>R (1 - z)) \\<circ> (\\<lambda>x. ((2 / ((norm x)\\<^sup>2 + 1)) *\\<^sub>R x, (1 - (norm x)\\<^sup>2) / ((norm x)\\<^sup>2 + 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on\n     ((\\<lambda>(x, z). x /\\<^sub>R (1 + z)) `\n      (({a. norm a = 1} - {(0::'a, 1)}) \\<inter>\n       ({a. norm a = 1} - {(0::'a, - 1)})))\n     ((\\<lambda>(x, z). x /\\<^sub>R (1 - z)) \\<circ>\n      (\\<lambda>x.\n          ((2 / ((norm x)\\<^sup>2 + 1)) *\\<^sub>R x,\n           (1 - (norm x)\\<^sup>2) / ((norm x)\\<^sup>2 + 1))))", "apply (rule smooth_on_subset[where T=\"UNIV - {0}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. smooth_on (UNIV - {0::'a})\n     ((\\<lambda>(x, z). x /\\<^sub>R (1 - z)) \\<circ>\n      (\\<lambda>x.\n          ((2 / ((norm x)\\<^sup>2 + 1)) *\\<^sub>R x,\n           (1 - (norm x)\\<^sup>2) / ((norm x)\\<^sup>2 + 1))))\n 2. (\\<lambda>(x, z). x /\\<^sub>R (1 + z)) `\n    (({a. norm a = 1} - {(0::'a, 1)}) \\<inter>\n     ({a. norm a = 1} - {(0::'a, - 1)}))\n    \\<subseteq> UNIV - {0::'a}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on (UNIV - {0::'a})\n     ((\\<lambda>(x, z). x /\\<^sub>R (1 - z)) \\<circ>\n      (\\<lambda>x.\n          ((2 / ((norm x)\\<^sup>2 + 1)) *\\<^sub>R x,\n           (1 - (norm x)\\<^sup>2) / ((norm x)\\<^sup>2 + 1))))", "by (auto intro!: smooth_on_divide smooth_on_inverse smooth_on_scaleR smooth_on_mult smooth_on_add\n          smooth_on_minus smooth_on_norm simp: o_def power2_eq_square add_nonneg_eq_0_iff divide_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, z). x /\\<^sub>R (1 + z)) `\n    (({a. norm a = 1} - {(0::'a, 1)}) \\<inter>\n     ({a. norm a = 1} - {(0::'a, - 1)}))\n    \\<subseteq> UNIV - {0::'a}", "apply (auto simp: norm_prod_def add_eq_0_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>b\\<^sup>2 = 1; b \\<noteq> 1\\<rbrakk>\n       \\<Longrightarrow> b = - 1", "apply sos"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  smooth_on\n   ((\\<lambda>(x, z). x /\\<^sub>R (1 + z)) `\n    (({a. norm a = 1} - {(0::'a, 1)}) \\<inter>\n     ({a. norm a = 1} - {(0::'a, - 1)})))\n   ((\\<lambda>(x, z). x /\\<^sub>R (1 - z)) \\<circ>\n    (\\<lambda>x.\n        ((2 / ((norm x)\\<^sup>2 + 1)) *\\<^sub>R x,\n         (1 - (norm x)\\<^sup>2) / ((norm x)\\<^sup>2 + 1))))\n\ngoal (1 subgoal):\n 1. smooth_on\n     (st_proj2 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj1 \\<circ> st_proj2_inv)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on\n     (st_proj2 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n     (st_proj1 \\<circ> st_proj2_inv)", "by transfer (rule *)"], ["proof (state)\nthis:\n  smooth_on\n   (st_proj2 ` ((UNIV - {top_sphere}) \\<inter> (UNIV - {bot_sphere})))\n   (st_proj1 \\<circ> st_proj2_inv)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition charts_sphere :: \"('a::euclidean_space sphere, 'a) chart set\" where\n  \"charts_sphere \\<equiv> {st_proj1_chart, st_proj2_chart}\""], ["", "lemma c_manifold_atlas_sphere: \"c_manifold charts_sphere \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_manifold charts_sphere \\<infinity>", "apply (unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>c1 \\<in> charts_sphere; c2 \\<in> charts_sphere\\<rbrakk>\n       \\<Longrightarrow> \\<infinity>-smooth_compat c1 c2", "unfolding charts_sphere_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>c1 \\<in> {st_proj1_chart, st_proj2_chart};\n        c2 \\<in> {st_proj1_chart, st_proj2_chart}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity>-smooth_compat c1 c2", "using smooth_compat_commute smooth_compat_refl st_projs_compat"], ["proof (prove)\nusing this:\n  ?k-smooth_compat ?x ?y = ?k-smooth_compat ?y ?x\n  ?k-smooth_compat ?x ?x\n  \\<infinity>-smooth_compat st_proj1_chart st_proj2_chart\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>c1 \\<in> {st_proj1_chart, st_proj2_chart};\n        c2 \\<in> {st_proj1_chart, st_proj2_chart}\\<rbrakk>\n       \\<Longrightarrow> \\<infinity>-smooth_compat c1 c2", "by fastforce"], ["", "end"]]}