{"file_name": "/home/qj213/afp-2021-10-22/thys/Smooth_Manifolds/Analysis_More.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Smooth_Manifolds", "problem_names": ["lemma openin_open_Int'[intro]:\n  \"open S \\<Longrightarrow> openin (top_of_set U) (S \\<inter> U)\"", "lemma Sigma_transfer[transfer_rule]:\n  \"(rel_set A ===> (A ===> rel_set B) ===> rel_set (rel_prod A B)) Sigma Sigma\"", "lemma filterlim_transfer[transfer_rule]:\n  \"((A ===> B) ===> rel_filter B ===> rel_filter A ===> (=)) filterlim filterlim\"\n  if [transfer_rule]: \"bi_unique B\"", "lemma nhds_transfer[transfer_rule]:\n  \"(A ===> rel_filter A) nhds nhds\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\"", "lemma at_within_transfer[transfer_rule]:\n  \"(A ===> rel_set A ===> rel_filter A) at_within at_within\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\"", "lemma continuous_on_transfer[transfer_rule]:\n  \"(rel_set A ===> (A ===> B) ===> (=)) continuous_on continuous_on\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\"\n    \"bi_unique B\" \"bi_total B\" \"(rel_set B ===> (=)) open open\"", "lemma continuous_on_transfer_right_total[transfer_rule]:\n  \"(rel_set A ===> (A ===> B) ===> (=)) (\\<lambda>X::'a::t2_space set. continuous_on (X \\<inter> Collect AP)) (\\<lambda>Y::'b::t2_space set. continuous_on Y)\"\n  if DomainA: \"Domainp A = AP\"\n    and [folded DomainA, transfer_rule]: \"bi_unique A\" \"right_total A\" \"(rel_set A ===> (=)) (openin (top_of_set (Collect AP))) open\"\n    \"bi_unique B\" \"bi_total B\" \"(rel_set B ===> (=)) open open\"", "lemma continuous_on_transfer_right_total2[transfer_rule]:\n  \"(rel_set A ===> (A ===> B) ===> (=)) (\\<lambda>X::'a::t2_space set. continuous_on X) (\\<lambda>Y::'b::t2_space set. continuous_on Y)\"\n  if DomainB: \"Domainp B = BP\"\n  and [folded DomainB, transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\"\n    \"bi_unique B\" \"right_total B\" \"(rel_set B ===> (=)) ((openin (top_of_set (Collect BP)))) open\"", "lemma generate_topology_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total A\" \"bi_unique A\"\n  shows \"(rel_set (rel_set A) ===> rel_set A ===> (=)) (generate_topology o (insert (Collect (Domainp A)))) generate_topology\"", "lemmas [simp del] = mem_ball", "lemma in_closureI[intro, simp]: \"x \\<in> X \\<Longrightarrow> x \\<in> closure X\"", "lemmas open_continuous_vimage = continuous_on_open_vimage[THEN iffD1, rule_format]", "lemma open_continuous_vimage': \"open s \\<Longrightarrow> continuous_on s f \\<Longrightarrow> open B \\<Longrightarrow> open (s \\<inter> f -` B)\"", "lemma support_on_mono: \"support_on carrier f \\<subseteq> support_on carrier g\"\n  if \"\\<And>x. x \\<in> carrier \\<Longrightarrow> f x \\<noteq> 0 \\<Longrightarrow> g x \\<noteq> 0\"", "lemma image_prod: \"(\\<lambda>(x, y). (f x, g y)) ` (A \\<times> B) = f ` A \\<times> g ` B\"", "lemma closed_csupport_on[intro, simp]: \"closed (csupport_on carrier \\<phi>)\"", "lemma not_in_csupportD: \"x \\<notin> csupport_on carrier \\<phi> \\<Longrightarrow> x \\<in> carrier \\<Longrightarrow> \\<phi> x = 0\"", "lemma csupport_on_mono: \"csupport_on carrier f \\<subseteq> csupport_on carrier g\"\n  if \"\\<And>x. x \\<in> carrier \\<Longrightarrow> f x \\<noteq> 0 \\<Longrightarrow> g x \\<noteq> 0\"", "lemma homeomorphism_empty[simp]:\n  \"homeomorphism {} t f f' \\<longleftrightarrow> t = {}\"\n  \"homeomorphism s {} f f' \\<longleftrightarrow> s = {}\"", "lemma homeomorphism_add:\n  \"homeomorphism UNIV UNIV (\\<lambda>x. x + c) (\\<lambda>x. x - c)\"\n  for c::\"_::real_normed_vector\"", "lemma in_range_scaleR_iff: \"x \\<in> range ((*\\<^sub>R) c) \\<longleftrightarrow> c = 0 \\<longrightarrow> x = 0\"\n  for x::\"_::real_vector\"", "lemma homeomorphism_scaleR:\n  \"homeomorphism UNIV UNIV (\\<lambda>x. c *\\<^sub>R x::_::real_normed_vector) (\\<lambda>x. x /\\<^sub>R c)\"\n  if \"c \\<noteq> 0\"", "lemma homeomorphism_prod:\n  \"homeomorphism (a \\<times> b) (c \\<times> d) (\\<lambda>(x, y). (f x, g y)) (\\<lambda>(x, y). (f' x, g' y))\"\n  if \"homeomorphism a c f f'\"\n     \"homeomorphism b d g g'\"", "lemma openin_subtopology_eq_generate_topology:\n  \"openin (top_of_set S) x = generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x\"\n  if open_gen: \"open = generate_topology BB\" and subset: \"x \\<subseteq> S\"", "lemma topology_eq_iff: \"t = s \\<longleftrightarrow> (topspace t = topspace s \\<and>\n  (\\<forall>x\\<subseteq>topspace t. openin t x = openin s x))\"", "lemma finer_than_iff_nhds:\n  \"T1 finer_than T2 \\<longleftrightarrow> (\\<forall>X. openin T2 X \\<longrightarrow> openin T1 (X \\<inter> topspace T1)) \\<and> (topspace T1 \\<subseteq> topspace T2)\"", "lemma continuous_on_finer_topo:\n  \"continuous_map s t f\"\n  if \"continuous_map s' t f\" \"s finer_than s'\"", "lemma continuous_on_finer_topo2:\n  \"continuous_map s t f\"\n  if \"continuous_map s t' f\" \"t' finer_than t\"", "lemma antisym_finer_than: \"S = T\" if \"S finer_than T\" \"T finer_than S\"", "lemma subtopology_finer_than[simp]: \"top_of_set X finer_than euclidean\"", "lemma support_on_nonneg_sum:\n  \"support_on X (\\<lambda>x. \\<Sum>i\\<in>S. f i x) = (\\<Union>i\\<in>S. support_on X (f i))\"\n  if \"finite S\" \"\\<And>x i . x \\<in> X \\<Longrightarrow> i \\<in> S \\<Longrightarrow> f i x \\<ge> 0\"\n  for f::\"_\\<Rightarrow>_\\<Rightarrow>_::ordered_comm_monoid_add\"", "lemma support_on_nonneg_sum_subset:\n  \"support_on X (\\<lambda>x. \\<Sum>i\\<in>S. f i x) \\<subseteq> (\\<Union>i\\<in>S. support_on X (f i))\"\n  for f::\"_\\<Rightarrow>_\\<Rightarrow>_::ordered_comm_monoid_add\"", "lemma support_on_nonneg_sum_subset':\n  \"support_on X (\\<lambda>x. \\<Sum>i\\<in>S x. f i x) \\<subseteq> (\\<Union>x\\<in>X. (\\<Union>i\\<in>S x. support_on X (f i)))\"\n  for f::\"_\\<Rightarrow>_\\<Rightarrow>_::ordered_comm_monoid_add\"", "lemma openin_final_topology:\n  \"openin (final_topology X Y f) =\n    (\\<lambda>U. U \\<subseteq> X \\<and> (\\<forall>i. openin (Y i) (f i -` U \\<inter> topspace (Y i))))\"", "lemma topspace_final_topology:\n  \"topspace (final_topology X Y f) = X\"\n  if \"\\<And>i. f i \\<in> topspace (Y i) \\<rightarrow> X\"", "lemma continuous_on_final_topologyI2:\n  \"continuous_map (Y i) (final_topology X Y f) (f i)\"\n  if \"\\<And>i. f i \\<in> topspace (Y i) \\<rightarrow> X\"", "lemma continuous_on_final_topologyI1:\n  \"continuous_map (final_topology X Y f) Z g\"\n  if hyp: \"\\<And>i. continuous_map (Y i) Z (g o f i)\"\n    and that: \"\\<And>i. f i \\<in> topspace (Y i) \\<rightarrow> X\" \"g \\<in> X \\<rightarrow> topspace Z\"", "lemma continuous_on_final_topology_iff:\n  \"continuous_map (final_topology X Y f) Z g \\<longleftrightarrow> (\\<forall>i. continuous_map (Y i) Z (g o f i))\"\n  if \"\\<And>i. f i \\<in> topspace (Y i) \\<rightarrow> X\" \"g \\<in> X \\<rightarrow> topspace Z\"", "lemma openin_map_topology:\n  \"openin (map_topology p X) = (\\<lambda>U. U \\<subseteq> p ` topspace X \\<and> openin X (p -` U \\<inter> topspace X))\"", "lemma topspace_map_topology[simp]: \"topspace (map_topology f T) = f ` topspace T\"", "lemma continuous_on_map_topology:\n  \"continuous_map T (map_topology f T) f\"", "lemma continuous_map_composeD:\n  \"continuous_map T X (g \\<circ> f) \\<Longrightarrow> g \\<in> f ` topspace T \\<rightarrow> topspace X\"", "lemma continuous_on_map_topology2:\n  \"continuous_map T X (g \\<circ> f) \\<longleftrightarrow> continuous_map (map_topology f T) X g\"", "lemma map_sub_finer_than_commute:\n  \"map_topology f (subtopology T (f -` X)) finer_than subtopology (map_topology f T) X\"", "lemma sub_map_finer_than_commute:\n  \"subtopology (map_topology f T) X finer_than map_topology f (subtopology T (f -` X))\"\n  if \"openin T (f -` X)\"\\<comment> \\<open>this is more or less the condition from\n    \\<^url>\\<open>https://math.stackexchange.com/questions/705840/quotient-topology-vs-subspace-topology\\<close>\\<close>", "lemma subtopology_map_topology:\n  \"subtopology (map_topology f T) X = map_topology f (subtopology T (f -` X))\"\n  if \"openin T (f -` X)\"", "lemma quotient_map_map_topology:\n  \"quotient_map X (map_topology f X) f\"", "lemma topological_space_quotient: \"class.topological_space (openin (map_topology f euclidean))\"\n  if \"surj f\"", "lemma t2_space_quotient: \"class.t2_space (open::'b set \\<Rightarrow> bool)\"\n  if open_def: \"open = (openin (map_topology (p::'a::t2_space\\<Rightarrow>'b::topological_space) euclidean))\"\n    \"surj p\" and open_p: \"\\<And>X. open X \\<Longrightarrow> open (p ` X)\" and \"closed {(x, y). p x = p y}\" (is \"closed ?R\")", "lemma second_countable_topology_quotient: \"class.second_countable_topology (open::'b set \\<Rightarrow> bool)\"\n  if open_def: \"open = (openin (map_topology (p::'a::second_countable_topology\\<Rightarrow>'b::topological_space) euclidean))\"\n    \"surj p\" and open_p: \"\\<And>X. open X \\<Longrightarrow> open (p ` X)\"", "lemma closure_Union: \"closure (\\<Union>X) = (\\<Union>x\\<in>X. closure x)\" if \"finite X\"", "lemma compact_if_closed_subset_of_compact:\n  \"compact S\" if \"closed S\" \"compact T\" \"S \\<subseteq> T\"", "lemmas locally_finite_onI = locally_finite_on_def[THEN iffD2, rule_format]", "lemma locally_finite_onE:\n  assumes \"locally_finite_on X I U\"\n  assumes \"p \\<in> X\"\n  obtains N where \"p \\<in> N\" \"open N\" \"finite {i\\<in>I. U i \\<inter> N \\<noteq> {}}\"", "lemma locally_finite_onD:\n  assumes \"locally_finite_on X I U\"\n  assumes \"p \\<in> X\"\n  shows \"finite {i\\<in>I. p \\<in> U i}\"", "lemma locally_finite_on_open_coverI: \"locally_finite_on X I U\"\n  if fin: \"\\<And>j. j \\<in> I \\<Longrightarrow> finite {i\\<in>I. U i \\<inter> U j \\<noteq> {}}\"\n    and open_cover: \"X \\<subseteq> (\\<Union>i\\<in>I. U i)\" \"\\<And>i. i \\<in> I \\<Longrightarrow> open (U i)\"", "lemma locally_finite_compactD:\n  \"finite {i\\<in>I. U i \\<inter> V \\<noteq> {}}\"\n  if lf: \"locally_finite_on X I U\"\n    and compact: \"compact V\"\n    and subset: \"V \\<subseteq> X\"", "lemma closure_Int_open_eq_empty: \"open S \\<Longrightarrow> (closure T \\<inter> S) = {} \\<longleftrightarrow> T \\<inter> S = {}\"", "lemma locally_finite_on_subset:\n  assumes \"locally_finite_on X J U\"\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> V i \\<subseteq> U i\" \"I \\<subseteq> J\"\n  shows \"locally_finite_on X I V\"", "lemma locally_finite_on_closure:\n  \"locally_finite_on X I (\\<lambda>x. closure (U x))\"\n  if \"locally_finite_on X I U\"", "lemma locally_finite_on_closedin_Union_closure:\n  \"closedin (top_of_set X) (\\<Union>i\\<in>I. closure (U i))\"\n  if \"locally_finite_on X I U\" \"\\<And>i. i \\<in> I \\<Longrightarrow> closure (U i) \\<subseteq> X\"", "lemma closure_subtopology_minimal:\n  \"S \\<subseteq> T \\<Longrightarrow> closedin (top_of_set X) T \\<Longrightarrow> closure S \\<inter> X \\<subseteq> T\"", "lemma locally_finite_on_closure_Union:\n  \"(\\<Union>i\\<in>I. closure (U i)) = closure (\\<Union>i\\<in>I. (U i)) \\<inter> X\"\n  if \"locally_finite_on X I U\" \"\\<And>i. i \\<in> I \\<Longrightarrow> closure (U i) \\<subseteq> X\"", "lemma refines_subset: \"x refines y\" if \"z refines y\" \"x \\<subseteq> z\"", "lemma scaleR_fun_beta[simp]: \"(r *\\<^sub>R f) x = r *\\<^sub>R f x\"", "lemmas [simp del] = vimage_Un vimage_Int", "lemma finite_Collect_imageI: \"finite {U \\<in> f ` X. P U}\" if \"finite {x\\<in>X. P (f x)}\"", "lemma plus_compose: \"(x + y) \\<circ> f = (x \\<circ> f) + (y \\<circ> f)\"", "lemma mult_compose: \"(x * y) \\<circ> f = (x \\<circ> f) * (y \\<circ> f)\"", "lemma scaleR_compose: \"(c *\\<^sub>R x) \\<circ> f = c *\\<^sub>R (x \\<circ> f)\"", "lemma image_scaleR_ball:\n  fixes a :: \"'a::real_normed_vector\"\n  shows \"c \\<noteq> 0 \\<Longrightarrow> (*\\<^sub>R) c ` ball a r = ball (c *\\<^sub>R a) (abs c *\\<^sub>R r)\"", "lemma continuous_within_topologicalE:\n  assumes \"continuous (at x within s) f\"\n    \"open B\" \"f x \\<in> B\"\n  obtains A where \"open A\" \"x \\<in> A\" \"\\<And>y. y \\<in> s \\<Longrightarrow> y \\<in> A \\<Longrightarrow> f y \\<in> B\"", "lemma continuous_within_topologicalE':\n  assumes \"continuous (at x) f\"\n    \"open B\" \"f x \\<in> B\"\n  obtains A where \"open A\" \"x \\<in> A\" \"f ` A \\<subseteq> B\"", "lemma continuous_on_inverse: \"continuous_on S f \\<Longrightarrow> 0 \\<notin> f ` S \\<Longrightarrow> continuous_on S (\\<lambda>x. inverse (f x))\"\n  for f::\"_\\<Rightarrow>_::real_normed_div_algebra\"", "lemma has_derivative_plus_fun[derivative_intros]:\n  \"(x + y has_derivative x' + y') (at a within A)\"\n  if [derivative_intros]:\n    \"(x has_derivative x') (at a within A)\"\n    \"(y has_derivative y') (at a within A)\"", "lemma has_derivative_scaleR_fun[derivative_intros]:\n  \"(x *\\<^sub>R y has_derivative x *\\<^sub>R y') (at a within A)\"\n  if [derivative_intros]:\n    \"(y has_derivative y') (at a within A)\"", "lemma has_derivative_times_fun[derivative_intros]:\n  \"(x * y has_derivative (\\<lambda>h. x a * y' h + x' h * y a)) (at a within A)\"\n  if [derivative_intros]:\n    \"(x has_derivative x') (at a within A)\"\n    \"(y has_derivative y') (at a within A)\"\n  for x y::\"_\\<Rightarrow>'a::real_normed_algebra\"", "lemma real_sqrt_has_derivative_generic:\n  \"x \\<noteq> 0 \\<Longrightarrow> (sqrt has_derivative (*) ((if x > 0 then 1 else -1) * inverse (sqrt x) / 2)) (at x within S)\"", "lemma sqrt_has_derivative:\n  \"((\\<lambda>x. sqrt (f x)) has_derivative (\\<lambda>xa. (if 0 < f x then 1 else - 1) / (2 * sqrt (f x)) * f' xa)) (at x within S)\"\n  if \"(f has_derivative f') (at x within S)\" \"f x \\<noteq> 0\"", "lemmas has_derivative_norm_compose[derivative_intros] = has_derivative_compose[OF _ has_derivative_norm]", "lemmas differentiable_on_empty[simp]", "lemma differentiable_transform_eventually: \"f differentiable (at x within X)\"\n  if \"g differentiable (at x within X)\"\n    \"f x = g x\"\n    \"\\<forall>\\<^sub>F x in (at x within X). f x = g x\"", "lemma differentiable_within_eqI: \"f differentiable at x within X\"\n  if \"g differentiable at x within X\" \"\\<And>x. x \\<in> X \\<Longrightarrow> f x = g x\"\n    \"x \\<in> X\" \"open X\"", "lemma differentiable_eqI: \"f differentiable at x\"\n  if \"g differentiable at x\" \"\\<And>x. x \\<in> X \\<Longrightarrow> f x = g x\" \"x \\<in> X\" \"open X\"", "lemma differentiable_on_eqI:\n  \"f differentiable_on S\"\n  if \"g differentiable_on S\" \"\\<And>x. x \\<in> S \\<Longrightarrow> f x = g x\" \"open S\"", "lemma differentiable_on_comp: \"(f o g) differentiable_on S\"\n  if \"g differentiable_on S\" \"f differentiable_on (g ` S)\"", "lemma differentiable_on_comp2: \"(f o g) differentiable_on S\"\n  if  \"f differentiable_on T\" \"g differentiable_on S\" \"g ` S \\<subseteq> T\"", "lemmas differentiable_on_compose2 = differentiable_on_comp2[unfolded o_def]", "lemma differentiable_on_openD: \"f differentiable at x\"\n  if \"f differentiable_on X\" \"open X\" \"x \\<in> X\"", "lemma differentiable_on_add_fun[intro, simp]:\n  \"x differentiable_on UNIV \\<Longrightarrow> y differentiable_on UNIV \\<Longrightarrow> x + y differentiable_on UNIV\"", "lemma differentiable_on_mult_fun[intro, simp]:\n  \"x differentiable_on UNIV \\<Longrightarrow> y differentiable_on UNIV \\<Longrightarrow> x * y differentiable_on UNIV\"\n  for x y::\"_\\<Rightarrow>'a::real_normed_algebra\"", "lemma differentiable_on_scaleR_fun[intro, simp]:\n  \"y differentiable_on UNIV \\<Longrightarrow> x *\\<^sub>R y differentiable_on UNIV\"", "lemma sqrt_differentiable:\n  \"(\\<lambda>x. sqrt (f x)) differentiable (at x within S)\"\n  if \"f differentiable (at x within S)\" \"f x \\<noteq> 0\"", "lemma sqrt_differentiable_on: \"(\\<lambda>x. sqrt (f x)) differentiable_on S\"\n  if \"f differentiable_on S\" \"0 \\<notin> f ` S\"", "lemma differentiable_on_inverse: \"f differentiable_on S \\<Longrightarrow> 0 \\<notin> f ` S \\<Longrightarrow> (\\<lambda>x. inverse (f x)) differentiable_on S\"\n  for f::\"_\\<Rightarrow>_::real_normed_field\"", "lemma differentiable_on_openI:\n  \"f differentiable_on S\"\n  if \"open S\" \"\\<And>x. x \\<in> S \\<Longrightarrow> \\<exists>f'. (f has_derivative f') (at x)\"", "lemmas differentiable_norm_compose_at = differentiable_compose[OF differentiable_norm_at]", "lemma differentiable_on_Pair:\n  \"f differentiable_on S \\<Longrightarrow> g differentiable_on S \\<Longrightarrow> (\\<lambda>x. (f x, g x)) differentiable_on S\"", "lemma differentiable_at_fst:\n  \"(\\<lambda>x. fst (f x)) differentiable at x within X\" if \"f differentiable at x within X\"", "lemma differentiable_at_snd:\n  \"(\\<lambda>x. snd (f x)) differentiable at x within X\" if \"f differentiable at x within X\"", "lemmas frechet_derivative_worksI = frechet_derivative_works[THEN iffD1]", "lemma sin_differentiable_at: \"(\\<lambda>x. sin (f x::real)) differentiable at x within X\"\n  if \"f differentiable at x within X\"", "lemma cos_differentiable_at: \"(\\<lambda>x. cos (f x::real)) differentiable at x within X\"\n  if \"f differentiable at x within X\"", "lemmas frechet_derivative_transform_within_open_ext =\n  fun_cong[OF frechet_derivative_transform_within_open]", "lemmas frechet_derivative_at' = frechet_derivative_at[symmetric]", "lemma frechet_derivative_plus_fun:\n  \"x differentiable at a \\<Longrightarrow> y differentiable at a \\<Longrightarrow>\n  frechet_derivative (x + y) (at a) =\n    frechet_derivative x (at a) + frechet_derivative y (at a)\"", "lemmas frechet_derivative_plus = frechet_derivative_plus_fun[unfolded plus_fun_def]", "lemma frechet_derivative_zero_fun: \"frechet_derivative 0 (at a) = 0\"", "lemma frechet_derivative_sin:\n  \"frechet_derivative (\\<lambda>x. sin (f x)) (at x) = (\\<lambda>xa. frechet_derivative f (at x) xa * cos (f x))\"\n  if \"f differentiable (at x)\"\n  for f::\"_\\<Rightarrow>real\"", "lemma frechet_derivative_cos:\n  \"frechet_derivative (\\<lambda>x. cos (f x)) (at x) = (\\<lambda>xa. frechet_derivative f (at x) xa * - sin (f x))\"\n  if \"f differentiable (at x)\"\n  for f::\"_\\<Rightarrow>real\"", "lemma differentiable_sum_fun:\n  \"(\\<And>i. i \\<in> I \\<Longrightarrow> (f i differentiable at a)) \\<Longrightarrow> sum f I differentiable at a\"", "lemma frechet_derivative_sum_fun:\n  \"(\\<And>i. i \\<in> I \\<Longrightarrow> (f i differentiable at a)) \\<Longrightarrow>\n  frechet_derivative (\\<Sum>i\\<in>I. f i) (at a) = (\\<Sum>i\\<in>I. frechet_derivative (f i) (at a))\"", "lemma sum_fun_def: \"(\\<Sum>i\\<in>I. f i) = (\\<lambda>x. \\<Sum>i\\<in>I. f i x)\"", "lemmas frechet_derivative_sum = frechet_derivative_sum_fun[unfolded sum_fun_def]", "lemma frechet_derivative_times_fun:\n  \"f differentiable at a \\<Longrightarrow> g differentiable at a \\<Longrightarrow>\n  frechet_derivative (f * g) (at a) =\n  (\\<lambda>x. f a * frechet_derivative g (at a) x + frechet_derivative f (at a) x * g a)\"\n  for f g::\"_\\<Rightarrow>'a::real_normed_algebra\"", "lemmas frechet_derivative_times = frechet_derivative_times_fun[unfolded times_fun_def]", "lemma frechet_derivative_scaleR_fun:\n  \"y differentiable at a \\<Longrightarrow>\n  frechet_derivative (x *\\<^sub>R y) (at a) =\n    x *\\<^sub>R frechet_derivative y (at a)\"", "lemmas frechet_derivative_scaleR = frechet_derivative_scaleR_fun[unfolded scaleR_fun_def]", "lemma frechet_derivative_compose:\n  \"frechet_derivative (f o g) (at x) = frechet_derivative (f) (at (g x)) o frechet_derivative g (at x)\"\n  if \"g differentiable at x\" \"f differentiable at (g x)\"", "lemma frechet_derivative_compose_eucl:\n  \"frechet_derivative (f o g) (at x) =\n    (\\<lambda>v. \\<Sum>i\\<in>Basis. ((frechet_derivative g (at x) v) \\<bullet> i) *\\<^sub>R frechet_derivative f (at (g x)) i)\"\n  (is \"?l = ?r\")\n  if \"g differentiable at x\" \"f differentiable at (g x)\"", "lemma frechet_derivative_works_on_open:\n  \"f differentiable_on X \\<Longrightarrow> open X \\<Longrightarrow> x \\<in> X \\<Longrightarrow>\n    (f has_derivative frechet_derivative f (at x)) (at x)\"\n  and frechet_derivative_works_on:\n  \"f differentiable_on X \\<Longrightarrow> x \\<in> X \\<Longrightarrow>\n    (f has_derivative frechet_derivative f (at x within X)) (at x within X)\"", "lemma frechet_derivative_inverse: \"frechet_derivative (\\<lambda>x. inverse (f x)) (at x) =\n    (\\<lambda>h. - 1 / (f x)\\<^sup>2 * frechet_derivative f (at x) h)\"\n  if \"f differentiable at x\" \"f x \\<noteq> 0\" for f::\"_\\<Rightarrow>_::real_normed_field\"", "lemma frechet_derivative_sqrt: \"frechet_derivative (\\<lambda>x. sqrt (f x)) (at x) =\n  (\\<lambda>v. (if f x > 0 then 1 else -1) / (2 * sqrt (f x)) * frechet_derivative f (at x) v)\"\n  if \"f differentiable at x\" \"f x \\<noteq> 0\"", "lemma frechet_derivative_norm: \"frechet_derivative (\\<lambda>x. norm (f x)) (at x) =\n    (\\<lambda>v. frechet_derivative f (at x) v \\<bullet> sgn (f x))\"\n  if \"f differentiable at x\" \"f x \\<noteq> 0\" \n  for f::\"_\\<Rightarrow>_::real_inner\"", "lemma (in bounded_linear) frechet_derivative:\n  \"frechet_derivative f (at x) = f\"", "lemma (in bounded_bilinear) frechet_derivative:\n  includes no_matrix_mult\n  shows\n    \"x differentiable at a \\<Longrightarrow> y differentiable at a \\<Longrightarrow>\n      frechet_derivative (\\<lambda>a. x a ** y a) (at a) =\n        (\\<lambda>h. x a ** frechet_derivative y (at a) h + frechet_derivative x (at a) h ** y a)\"", "lemma frechet_derivative_divide: \"frechet_derivative (\\<lambda>x. f x / g x) (at x) =\n    (\\<lambda>h. frechet_derivative f (at x) h / (g x) -frechet_derivative g (at x) h * f x / (g x)\\<^sup>2)\"\n  if \"f differentiable at x\" \"g differentiable at x\" \"g x \\<noteq> 0\" for f::\"_\\<Rightarrow>_::real_normed_field\"", "lemma frechet_derivative_pair:\n  \"frechet_derivative (\\<lambda>x. (f x, g x)) (at x) = (\\<lambda>v. (frechet_derivative f (at x) v, frechet_derivative g (at x) v))\"\n  if \"f differentiable (at x)\" \"g differentiable (at x)\"", "lemma frechet_derivative_fst:\n  \"frechet_derivative (\\<lambda>x. fst (f x)) (at x) = (\\<lambda>xa. fst (frechet_derivative f (at x) xa))\"\n  if \"(f differentiable at x)\"\n  for f::\"_\\<Rightarrow>(_::real_normed_vector \\<times> _::real_normed_vector)\"", "lemma frechet_derivative_snd:\n  \"frechet_derivative (\\<lambda>x. snd (f x)) (at x) = (\\<lambda>xa. snd (frechet_derivative f (at x) xa))\"\n  if \"(f differentiable at x)\"\n  for f::\"_\\<Rightarrow>(_::real_normed_vector \\<times> _::real_normed_vector)\"", "lemma frechet_derivative_eq_vector_derivative_1:\n  assumes \"f differentiable at t\"\n  shows \"frechet_derivative f (at t) 1 = vector_derivative f (at t)\"", "lemma (in vector_space) dim_pos_finite_dimensional_vector_spaceE:\n  assumes \"dim (UNIV::'b set) > 0\"\n  obtains basis where \"finite_dimensional_vector_space scale basis\"", "lemmas_with [var_simplified explicit_ab_group_add,\n    unoverload_type 'd,\n    OF type.ab_group_add_axioms type_vector_space_on_with,\n    folded dim_S_def,\n    untransferred,\n    var_simplified implicit_ab_group_add]:\n    lt_dim_pos_finite_dimensional_vector_spaceE = vector_space.dim_pos_finite_dimensional_vector_spaceE", "lemmas_with [cancel_type_definition,\n    OF S_ne,\n    folded subset_iff',\n    simplified pred_fun_def, folded finite_dimensional_vector_space_on_with,\n    simplified\\<comment>\\<open>too much?\\<close>]:\n    dim_pos_finite_dimensional_vector_spaceE = lt_dim_pos_finite_dimensional_vector_spaceE", "lemma extensional0_0[intro, simp]: \"extensional0 X 0\"", "lemma extensional0_UNIV[intro, simp]: \"extensional0 UNIV f\"", "lemma ext_extensional0:\n  \"f = g\" if \"extensional0 S f\" \"extensional0 S g\" \"\\<And>x. x \\<in> S \\<Longrightarrow> f x = g x\"", "lemma extensional0_add[intro, simp]:\n  \"extensional0 S f \\<Longrightarrow> extensional0 S g \\<Longrightarrow> extensional0 S (f + g::_\\<Rightarrow>'a::comm_monoid_add)\"", "lemma extensinoal0_mult[intro, simp]:\n  \"extensional0 S x \\<Longrightarrow> extensional0 S y \\<Longrightarrow> extensional0 S (x * y)\"\n  for x y::\"_\\<Rightarrow>'a::mult_zero\"", "lemma extensional0_scaleR[intro, simp]: \"extensional0 S f \\<Longrightarrow> extensional0 S (c *\\<^sub>R f::_\\<Rightarrow>'a::real_vector)\"", "lemma extensional0_outside: \"x \\<notin> S \\<Longrightarrow> extensional0 S f \\<Longrightarrow> f x = 0\"", "lemma subspace_extensional0: \"subspace (Collect (extensional0 X))\"", "lemma restrict0_UNIV[simp]: \"restrict0 UNIV = (\\<lambda>x. x)\"", "lemma extensional0_restrict0[intro, simp]: \"extensional0 A (restrict0 A f)\"", "lemma restrict0_times: \"restrict0 A (x * y) = restrict0 A x * restrict0 A y\"\n  for x::\"'a\\<Rightarrow>'b::mult_zero\"", "lemma restrict0_apply_in[simp]: \"x \\<in> A \\<Longrightarrow> restrict0 A f x = f x\"", "lemma restrict0_apply_out[simp]: \"x \\<notin> A \\<Longrightarrow> restrict0 A f x = 0\"", "lemma restrict0_scaleR: \"restrict0 A (c *\\<^sub>R f::_\\<Rightarrow>'a::real_vector) = c *\\<^sub>R restrict0 A f\"", "lemma restrict0_add: \"restrict0 A (f + g::_\\<Rightarrow>'a::real_vector) = restrict0 A f + restrict0 A g\"", "lemma restrict0_restrict0: \"restrict0 X (restrict0 Y f) = restrict0 (X \\<inter> Y) f\""], "translations": [["", "lemma openin_open_Int'[intro]:\n  \"open S \\<Longrightarrow> openin (top_of_set U) (S \\<inter> U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open S \\<Longrightarrow> openin (top_of_set U) (S \\<inter> U)", "by (auto simp: openin_open)"], ["", "subsection \\<open>Parametricity rules for topology\\<close>"], ["", "text \\<open>TODO: also check with theory \\<open>Transfer_Euclidean_Space_Vector\\<close> in AFP/ODE...\\<close>"], ["", "context includes lifting_syntax begin"], ["", "lemma Sigma_transfer[transfer_rule]:\n  \"(rel_set A ===> (A ===> rel_set B) ===> rel_set (rel_prod A B)) Sigma Sigma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> rel_set B) ===> rel_set (rel_prod A B)) Sigma\n     Sigma", "unfolding Sigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> rel_set B) ===> rel_set (rel_prod A B))\n     (\\<lambda>A B. \\<Union>x\\<in>A. \\<Union>y\\<in>B x. {(x, y)})\n     (\\<lambda>A B. \\<Union>x\\<in>A. \\<Union>y\\<in>B x. {(x, y)})", "by transfer_prover"], ["", "lemma filterlim_transfer[transfer_rule]:\n  \"((A ===> B) ===> rel_filter B ===> rel_filter A ===> (=)) filterlim filterlim\"\n  if [transfer_rule]: \"bi_unique B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B) ===> rel_filter B ===> rel_filter A ===> (=)) filterlim\n     filterlim", "unfolding filterlim_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B) ===> rel_filter B ===> rel_filter A ===> (=))\n     (\\<lambda>f F2 F1.\n         \\<forall>P.\n            eventually P F2 \\<longrightarrow>\n            (\\<forall>\\<^sub>F x in F1. P (f x)))\n     (\\<lambda>f F2 F1.\n         \\<forall>P.\n            eventually P F2 \\<longrightarrow>\n            (\\<forall>\\<^sub>F x in F1. P (f x)))", "by transfer_prover"], ["", "lemma nhds_transfer[transfer_rule]:\n  \"(A ===> rel_filter A) nhds nhds\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> rel_filter A) nhds nhds", "unfolding nhds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> rel_filter A)\n     (\\<lambda>a. Inf (principal ` {S. open S \\<and> a \\<in> S}))\n     (\\<lambda>a. Inf (principal ` {S. open S \\<and> a \\<in> S}))", "by transfer_prover"], ["", "lemma at_within_transfer[transfer_rule]:\n  \"(A ===> rel_set A ===> rel_filter A) at_within at_within\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> rel_set A ===> rel_filter A) at_within at_within", "unfolding at_within_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> rel_set A ===> rel_filter A)\n     (\\<lambda>a s. inf (nhds a) (principal (s - {a})))\n     (\\<lambda>a s. inf (nhds a) (principal (s - {a})))", "by transfer_prover"], ["", "lemma continuous_on_transfer[transfer_rule]:\n  \"(rel_set A ===> (A ===> B) ===> (=)) continuous_on continuous_on\"\n  if [transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\"\n    \"bi_unique B\" \"bi_total B\" \"(rel_set B ===> (=)) open open\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> B) ===> (=)) continuous_on continuous_on", "unfolding continuous_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> B) ===> (=))\n     (\\<lambda>s f.\n         \\<forall>x\\<in>s. (f \\<longlongrightarrow> f x) (at x within s))\n     (\\<lambda>s f.\n         \\<forall>x\\<in>s. (f \\<longlongrightarrow> f x) (at x within s))", "by transfer_prover"], ["", "lemma continuous_on_transfer_right_total[transfer_rule]:\n  \"(rel_set A ===> (A ===> B) ===> (=)) (\\<lambda>X::'a::t2_space set. continuous_on (X \\<inter> Collect AP)) (\\<lambda>Y::'b::t2_space set. continuous_on Y)\"\n  if DomainA: \"Domainp A = AP\"\n    and [folded DomainA, transfer_rule]: \"bi_unique A\" \"right_total A\" \"(rel_set A ===> (=)) (openin (top_of_set (Collect AP))) open\"\n    \"bi_unique B\" \"bi_total B\" \"(rel_set B ===> (=)) open open\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> B) ===> (=))\n     (\\<lambda>X. continuous_on (X \\<inter> Collect AP)) continuous_on", "unfolding DomainA[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> B) ===> (=))\n     (\\<lambda>X. continuous_on (X \\<inter> Collect (Domainp A)))\n     continuous_on", "proof (intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A x y; (A ===> B) xa ya\\<rbrakk>\n       \\<Longrightarrow> continuous_on (x \\<inter> Collect (Domainp A)) xa =\n                         continuous_on y ya", "fix X Y f g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A x y; (A ===> B) xa ya\\<rbrakk>\n       \\<Longrightarrow> continuous_on (x \\<inter> Collect (Domainp A)) xa =\n                         continuous_on y ya", "assume H[transfer_rule]: \"rel_set A X Y\" \"(A ===> B) f g\""], ["proof (state)\nthis:\n  rel_set A X Y\n  (A ===> B) f g\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A x y; (A ===> B) xa ya\\<rbrakk>\n       \\<Longrightarrow> continuous_on (x \\<inter> Collect (Domainp A)) xa =\n                         continuous_on y ya", "from H(1)"], ["proof (chain)\npicking this:\n  rel_set A X Y", "have XA: \"x \\<in> X \\<Longrightarrow> Domainp A x\" for x"], ["proof (prove)\nusing this:\n  rel_set A X Y\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> Domainp A x", "by (auto simp: rel_set_def)"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> Domainp A ?x\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A x y; (A ===> B) xa ya\\<rbrakk>\n       \\<Longrightarrow> continuous_on (x \\<inter> Collect (Domainp A)) xa =\n                         continuous_on y ya", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> X \\<Longrightarrow> Domainp A ?x", "have *: \"X \\<inter> Collect (Domainp A) = X\""], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> Domainp A ?x\n\ngoal (1 subgoal):\n 1. X \\<inter> Collect (Domainp A) = X", "by auto"], ["proof (state)\nthis:\n  X \\<inter> Collect (Domainp A) = X\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A x y; (A ===> B) xa ya\\<rbrakk>\n       \\<Longrightarrow> continuous_on (x \\<inter> Collect (Domainp A)) xa =\n                         continuous_on y ya", "have \"openin (top_of_set (Collect (Domainp A))) (Collect (Domainp A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (top_of_set (Collect (Domainp A))) (Collect (Domainp A))", "by auto"], ["proof (state)\nthis:\n  openin (top_of_set (Collect (Domainp A))) (Collect (Domainp A))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A x y; (A ===> B) xa ya\\<rbrakk>\n       \\<Longrightarrow> continuous_on (x \\<inter> Collect (Domainp A)) xa =\n                         continuous_on y ya", "show \" continuous_on (X \\<inter> Collect (Domainp A)) f = continuous_on Y g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (X \\<inter> Collect (Domainp A)) f = continuous_on Y g", "unfolding continuous_on_eq_continuous_within continuous_within_topological *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X.\n        \\<forall>B.\n           open B \\<longrightarrow>\n           f x \\<in> B \\<longrightarrow>\n           (\\<exists>A.\n               open A \\<and>\n               x \\<in> A \\<and>\n               (\\<forall>y\\<in>X.\n                   y \\<in> A \\<longrightarrow> f y \\<in> B))) =\n    (\\<forall>x\\<in>Y.\n        \\<forall>B.\n           open B \\<longrightarrow>\n           g x \\<in> B \\<longrightarrow>\n           (\\<exists>A.\n               open A \\<and>\n               x \\<in> A \\<and>\n               (\\<forall>y\\<in>Y. y \\<in> A \\<longrightarrow> g y \\<in> B)))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X.\n        \\<forall>B.\n           open B \\<longrightarrow>\n           f x \\<in> B \\<longrightarrow>\n           (\\<exists>A.\n               open A \\<and>\n               x \\<in> A \\<and>\n               (\\<forall>y\\<in>X.\n                   y \\<in> A \\<longrightarrow> f y \\<in> B))) =\n    (\\<forall>x\\<in>X.\n        \\<forall>B.\n           open B \\<longrightarrow>\n           f x \\<in> B \\<longrightarrow>\n           (\\<exists>Aa\\<in>{Aa. Ball Aa (Domainp A)}.\n               openin (top_of_set (Collect (Domainp A))) Aa \\<and>\n               x \\<in> Aa \\<and>\n               (\\<forall>y\\<in>X.\n                   y \\<in> Aa \\<longrightarrow> f y \\<in> B)))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x B.\n       \\<lbrakk>\\<forall>x\\<in>X.\n                   \\<forall>B.\n                      open B \\<longrightarrow>\n                      f x \\<in> B \\<longrightarrow>\n                      (\\<exists>A.\n                          open A \\<and>\n                          x \\<in> A \\<and>\n                          (\\<forall>y\\<in>X.\n                              y \\<in> A \\<longrightarrow> f y \\<in> B));\n        x \\<in> X; open B; f x \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa\\<in>{Aa. Ball Aa (Domainp A)}.\n                            openin (top_of_set (Collect (Domainp A)))\n                             Aa \\<and>\n                            x \\<in> Aa \\<and>\n                            (\\<forall>y\\<in>X.\n                                y \\<in> Aa \\<longrightarrow> f y \\<in> B)\n 2. \\<And>x B.\n       \\<lbrakk>\\<forall>x\\<in>X.\n                   \\<forall>B.\n                      open B \\<longrightarrow>\n                      f x \\<in> B \\<longrightarrow>\n                      (\\<exists>Aa\\<in>{Aa. Ball Aa (Domainp A)}.\n                          openin (top_of_set (Collect (Domainp A)))\n                           Aa \\<and>\n                          x \\<in> Aa \\<and>\n                          (\\<forall>y\\<in>X.\n                              y \\<in> Aa \\<longrightarrow> f y \\<in> B));\n        x \\<in> X; open B; f x \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            open A \\<and>\n                            x \\<in> A \\<and>\n                            (\\<forall>y\\<in>X.\n                                y \\<in> A \\<longrightarrow> f y \\<in> B)", "subgoal for x B"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>B.\n                   open B \\<longrightarrow>\n                   f x \\<in> B \\<longrightarrow>\n                   (\\<exists>A.\n                       open A \\<and>\n                       x \\<in> A \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> A \\<longrightarrow> f y \\<in> B));\n     x \\<in> X; open B; f x \\<in> B\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Aa\\<in>{Aa. Ball Aa (Domainp A)}.\n                         openin (top_of_set (Collect (Domainp A))) Aa \\<and>\n                         x \\<in> Aa \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> Aa \\<longrightarrow> f y \\<in> B)", "apply (drule bspec, assumption, drule spec, drule mp, assumption, drule mp, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X; open B; f x \\<in> B;\n     \\<exists>A.\n        open A \\<and>\n        x \\<in> A \\<and>\n        (\\<forall>y\\<in>X. y \\<in> A \\<longrightarrow> f y \\<in> B)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Aa\\<in>{Aa. Ball Aa (Domainp A)}.\n                         openin (top_of_set (Collect (Domainp A))) Aa \\<and>\n                         x \\<in> Aa \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> Aa \\<longrightarrow> f y \\<in> B)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa.\n       \\<lbrakk>x \\<in> X; open B; open Aa; x \\<in> Aa;\n        \\<forall>y\\<in>X. y \\<in> Aa \\<longrightarrow> f y \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Aa.\n                            (\\<forall>x\\<in>Aa. Domainp A x) \\<and>\n                            openin (top_of_set (Collect (Domainp A)))\n                             Aa \\<and>\n                            x \\<in> Aa \\<and>\n                            (\\<forall>y\\<in>X.\n                                y \\<in> Aa \\<longrightarrow> f y \\<in> B)", "subgoal for AA"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X; open B; open AA; x \\<in> AA;\n     \\<forall>y\\<in>X. y \\<in> AA \\<longrightarrow> f y \\<in> B\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Aa.\n                         (\\<forall>x\\<in>Aa. Domainp A x) \\<and>\n                         openin (top_of_set (Collect (Domainp A))) Aa \\<and>\n                         x \\<in> Aa \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> Aa \\<longrightarrow> f y \\<in> B)", "apply (rule exI[where x=\"AA \\<inter> Collect (Domainp A)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X; open B; open AA; x \\<in> AA;\n     \\<forall>y\\<in>X. y \\<in> AA \\<longrightarrow> f y \\<in> B\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x\\<in>AA \\<inter> Collect (Domainp A).\n                          Domainp A x) \\<and>\n                      openin (top_of_set (Collect (Domainp A)))\n                       (AA \\<inter> Collect (Domainp A)) \\<and>\n                      x \\<in> AA \\<inter> Collect (Domainp A) \\<and>\n                      (\\<forall>y\\<in>X.\n                          y \\<in> AA \\<inter>\n                                  Collect (Domainp A) \\<longrightarrow>\n                          f y \\<in> B)", "by (auto intro: XA)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x B.\n       \\<lbrakk>\\<forall>x\\<in>X.\n                   \\<forall>B.\n                      open B \\<longrightarrow>\n                      f x \\<in> B \\<longrightarrow>\n                      (\\<exists>Aa\\<in>{Aa. Ball Aa (Domainp A)}.\n                          openin (top_of_set (Collect (Domainp A)))\n                           Aa \\<and>\n                          x \\<in> Aa \\<and>\n                          (\\<forall>y\\<in>X.\n                              y \\<in> Aa \\<longrightarrow> f y \\<in> B));\n        x \\<in> X; open B; f x \\<in> B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            open A \\<and>\n                            x \\<in> A \\<and>\n                            (\\<forall>y\\<in>X.\n                                y \\<in> A \\<longrightarrow> f y \\<in> B)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>B.\n                   open B \\<longrightarrow>\n                   f x \\<in> B \\<longrightarrow>\n                   (\\<exists>Aa\\<in>{Aa. Ball Aa (Domainp A)}.\n                       openin (top_of_set (Collect (Domainp A))) Aa \\<and>\n                       x \\<in> Aa \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> Aa \\<longrightarrow> f y \\<in> B));\n     x_ \\<in> X; open B_; f x_ \\<in> B_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x_ \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> B_)", "using XA"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> Domainp A ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>B.\n                   open B \\<longrightarrow>\n                   f x \\<in> B \\<longrightarrow>\n                   (\\<exists>Aa\\<in>{Aa. Ball Aa (Domainp A)}.\n                       openin (top_of_set (Collect (Domainp A))) Aa \\<and>\n                       x \\<in> Aa \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> Aa \\<longrightarrow> f y \\<in> B));\n     x_ \\<in> X; open B_; f x_ \\<in> B_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x_ \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> B_)", "by (force simp: openin_subtopology)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  continuous_on (X \\<inter> Collect (Domainp A)) f = continuous_on Y g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_on_transfer_right_total2[transfer_rule]:\n  \"(rel_set A ===> (A ===> B) ===> (=)) (\\<lambda>X::'a::t2_space set. continuous_on X) (\\<lambda>Y::'b::t2_space set. continuous_on Y)\"\n  if DomainB: \"Domainp B = BP\"\n  and [folded DomainB, transfer_rule]: \"bi_unique A\" \"bi_total A\" \"(rel_set A ===> (=)) open open\"\n    \"bi_unique B\" \"right_total B\" \"(rel_set B ===> (=)) ((openin (top_of_set (Collect BP)))) open\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> B) ===> (=)) continuous_on continuous_on", "unfolding DomainB[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> B) ===> (=)) continuous_on continuous_on", "proof (intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A x y; (A ===> B) xa ya\\<rbrakk>\n       \\<Longrightarrow> continuous_on x xa = continuous_on y ya", "fix X Y f g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A x y; (A ===> B) xa ya\\<rbrakk>\n       \\<Longrightarrow> continuous_on x xa = continuous_on y ya", "assume H[transfer_rule]: \"rel_set A X Y\" \"(A ===> B) f g\""], ["proof (state)\nthis:\n  rel_set A X Y\n  (A ===> B) f g\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A x y; (A ===> B) xa ya\\<rbrakk>\n       \\<Longrightarrow> continuous_on x xa = continuous_on y ya", "show \"continuous_on X f = continuous_on Y g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on X f = continuous_on Y g", "unfolding continuous_on_eq_continuous_within continuous_within_topological"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X.\n        \\<forall>B.\n           open B \\<longrightarrow>\n           f x \\<in> B \\<longrightarrow>\n           (\\<exists>A.\n               open A \\<and>\n               x \\<in> A \\<and>\n               (\\<forall>y\\<in>X.\n                   y \\<in> A \\<longrightarrow> f y \\<in> B))) =\n    (\\<forall>x\\<in>Y.\n        \\<forall>B.\n           open B \\<longrightarrow>\n           g x \\<in> B \\<longrightarrow>\n           (\\<exists>A.\n               open A \\<and>\n               x \\<in> A \\<and>\n               (\\<forall>y\\<in>Y. y \\<in> A \\<longrightarrow> g y \\<in> B)))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>X.\n        \\<forall>B.\n           open B \\<longrightarrow>\n           f x \\<in> B \\<longrightarrow>\n           (\\<exists>A.\n               open A \\<and>\n               x \\<in> A \\<and>\n               (\\<forall>y\\<in>X.\n                   y \\<in> A \\<longrightarrow> f y \\<in> B))) =\n    (\\<forall>x\\<in>X.\n        \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n           openin (top_of_set (Collect (Domainp B))) Ba \\<longrightarrow>\n           f x \\<in> Ba \\<longrightarrow>\n           (\\<exists>A.\n               open A \\<and>\n               x \\<in> A \\<and>\n               (\\<forall>y\\<in>X.\n                   y \\<in> A \\<longrightarrow> f y \\<in> Ba)))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x Ba.\n       \\<lbrakk>\\<forall>x\\<in>X.\n                   \\<forall>B.\n                      open B \\<longrightarrow>\n                      f x \\<in> B \\<longrightarrow>\n                      (\\<exists>A.\n                          open A \\<and>\n                          x \\<in> A \\<and>\n                          (\\<forall>y\\<in>X.\n                              y \\<in> A \\<longrightarrow> f y \\<in> B));\n        x \\<in> X; Ball Ba (Domainp B);\n        openin (top_of_set (Collect (Domainp B))) Ba; f x \\<in> Ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            open A \\<and>\n                            x \\<in> A \\<and>\n                            (\\<forall>y\\<in>X.\n                                y \\<in> A \\<longrightarrow> f y \\<in> Ba)\n 2. \\<And>x Ba.\n       \\<lbrakk>\\<forall>x\\<in>X.\n                   \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n                      openin (top_of_set (Collect (Domainp B)))\n                       Ba \\<longrightarrow>\n                      f x \\<in> Ba \\<longrightarrow>\n                      (\\<exists>A.\n                          open A \\<and>\n                          x \\<in> A \\<and>\n                          (\\<forall>y\\<in>X.\n                              y \\<in> A \\<longrightarrow> f y \\<in> Ba));\n        x \\<in> X; open Ba; f x \\<in> Ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            open A \\<and>\n                            x \\<in> A \\<and>\n                            (\\<forall>y\\<in>X.\n                                y \\<in> A \\<longrightarrow> f y \\<in> Ba)", "subgoal for x C"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>B.\n                   open B \\<longrightarrow>\n                   f x \\<in> B \\<longrightarrow>\n                   (\\<exists>A.\n                       open A \\<and>\n                       x \\<in> A \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> A \\<longrightarrow> f y \\<in> B));\n     x \\<in> X; Ball C (Domainp B);\n     openin (top_of_set (Collect (Domainp B))) C; f x \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> C)", "apply (clarsimp simp: openin_subtopology)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T b.\n       \\<lbrakk>\\<forall>x\\<in>X.\n                   \\<forall>B.\n                      open B \\<longrightarrow>\n                      f x \\<in> B \\<longrightarrow>\n                      (\\<exists>A.\n                          open A \\<and>\n                          x \\<in> A \\<and>\n                          (\\<forall>y\\<in>X.\n                              y \\<in> A \\<longrightarrow> f y \\<in> B));\n        x \\<in> X; open T; C = T \\<inter> Collect (Domainp B); f x \\<in> T;\n        B (f x) b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            open A \\<and>\n                            x \\<in> A \\<and>\n                            (\\<forall>y\\<in>X.\n                                y \\<in> A \\<longrightarrow>\n                                f y \\<in> T \\<and> Domainp B (f y))", "apply (drule bspec, assumption, drule spec, drule mp, assumption, drule mp, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T b.\n       \\<lbrakk>x \\<in> X; open T; C = T \\<inter> Collect (Domainp B);\n        f x \\<in> T; B (f x) b;\n        \\<exists>A.\n           open A \\<and>\n           x \\<in> A \\<and>\n           (\\<forall>y\\<in>X.\n               y \\<in> A \\<longrightarrow> f y \\<in> T)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            open A \\<and>\n                            x \\<in> A \\<and>\n                            (\\<forall>y\\<in>X.\n                                y \\<in> A \\<longrightarrow>\n                                f y \\<in> T \\<and> Domainp B (f y))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T b A.\n       \\<lbrakk>x \\<in> X; open T; C = T \\<inter> Collect (Domainp B);\n        B (f x) b; open A; x \\<in> A;\n        \\<forall>y\\<in>X. y \\<in> A \\<longrightarrow> f y \\<in> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            open A \\<and>\n                            x \\<in> A \\<and>\n                            (\\<forall>y\\<in>X.\n                                y \\<in> A \\<longrightarrow>\n                                f y \\<in> T \\<and> Domainp B (f y))", "by (meson Domainp_applyI H(1) H(2) rel_setD1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Ba.\n       \\<lbrakk>\\<forall>x\\<in>X.\n                   \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n                      openin (top_of_set (Collect (Domainp B)))\n                       Ba \\<longrightarrow>\n                      f x \\<in> Ba \\<longrightarrow>\n                      (\\<exists>A.\n                          open A \\<and>\n                          x \\<in> A \\<and>\n                          (\\<forall>y\\<in>X.\n                              y \\<in> A \\<longrightarrow> f y \\<in> Ba));\n        x \\<in> X; open Ba; f x \\<in> Ba\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            open A \\<and>\n                            x \\<in> A \\<and>\n                            (\\<forall>y\\<in>X.\n                                y \\<in> A \\<longrightarrow> f y \\<in> Ba)", "subgoal for x C"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n                   openin (top_of_set (Collect (Domainp B)))\n                    Ba \\<longrightarrow>\n                   f x \\<in> Ba \\<longrightarrow>\n                   (\\<exists>A.\n                       open A \\<and>\n                       x \\<in> A \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> A \\<longrightarrow> f y \\<in> Ba));\n     x \\<in> X; open C; f x \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> C)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n                   openin (top_of_set (Collect (Domainp B)))\n                    Ba \\<longrightarrow>\n                   f x \\<in> Ba \\<longrightarrow>\n                   (\\<exists>A.\n                       open A \\<and>\n                       x \\<in> A \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> A \\<longrightarrow> f y \\<in> Ba));\n     x \\<in> X; open C; f x \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> C)", "let ?sub = \"top_of_set (Collect (Domainp B))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n                   openin (top_of_set (Collect (Domainp B)))\n                    Ba \\<longrightarrow>\n                   f x \\<in> Ba \\<longrightarrow>\n                   (\\<exists>A.\n                       open A \\<and>\n                       x \\<in> A \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> A \\<longrightarrow> f y \\<in> Ba));\n     x \\<in> X; open C; f x \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> C)", "assume cont: \"\\<forall>x\\<in>X. \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n          openin (top_of_set (Collect (Domainp B))) Ba \\<longrightarrow> f x \\<in> Ba \\<longrightarrow> (\\<exists>Aa.  open Aa \\<and> x \\<in> Aa \\<and> (\\<forall>y\\<in>X. y \\<in> Aa \\<longrightarrow> f y \\<in> Ba))\"\n        and x: \"x \\<in> X\" \"open C\" \"f x \\<in> C\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>X.\n     \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n        openin (top_of_set (Collect (Domainp B))) Ba \\<longrightarrow>\n        f x \\<in> Ba \\<longrightarrow>\n        (\\<exists>Aa.\n            open Aa \\<and>\n            x \\<in> Aa \\<and>\n            (\\<forall>y\\<in>X. y \\<in> Aa \\<longrightarrow> f y \\<in> Ba))\n  x \\<in> X\n  open C\n  f x \\<in> C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n                   openin (top_of_set (Collect (Domainp B)))\n                    Ba \\<longrightarrow>\n                   f x \\<in> Ba \\<longrightarrow>\n                   (\\<exists>A.\n                       open A \\<and>\n                       x \\<in> A \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> A \\<longrightarrow> f y \\<in> Ba));\n     x \\<in> X; open C; f x \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> C)", "let ?B = \"C \\<inter> Collect (Domainp B)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n                   openin (top_of_set (Collect (Domainp B)))\n                    Ba \\<longrightarrow>\n                   f x \\<in> Ba \\<longrightarrow>\n                   (\\<exists>A.\n                       open A \\<and>\n                       x \\<in> A \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> A \\<longrightarrow> f y \\<in> Ba));\n     x \\<in> X; open C; f x \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> C)", "have \"?B \\<in> {A. Ball A (Domainp B)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<inter> Collect (Domainp B) \\<in> {A. Ball A (Domainp B)}", "by auto"], ["proof (state)\nthis:\n  C \\<inter> Collect (Domainp B) \\<in> {A. Ball A (Domainp B)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n                   openin (top_of_set (Collect (Domainp B)))\n                    Ba \\<longrightarrow>\n                   f x \\<in> Ba \\<longrightarrow>\n                   (\\<exists>A.\n                       open A \\<and>\n                       x \\<in> A \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> A \\<longrightarrow> f y \\<in> Ba));\n     x \\<in> X; open C; f x \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> C)", "have \"openin ?sub (Collect (Domainp B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (top_of_set (Collect (Domainp B))) (Collect (Domainp B))", "by auto"], ["proof (state)\nthis:\n  openin (top_of_set (Collect (Domainp B))) (Collect (Domainp B))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n                   openin (top_of_set (Collect (Domainp B)))\n                    Ba \\<longrightarrow>\n                   f x \\<in> Ba \\<longrightarrow>\n                   (\\<exists>A.\n                       open A \\<and>\n                       x \\<in> A \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> A \\<longrightarrow> f y \\<in> Ba));\n     x \\<in> X; open C; f x \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> C)", "then"], ["proof (chain)\npicking this:\n  openin (top_of_set (Collect (Domainp B))) (Collect (Domainp B))", "have \"openin ?sub ?B\""], ["proof (prove)\nusing this:\n  openin (top_of_set (Collect (Domainp B))) (Collect (Domainp B))\n\ngoal (1 subgoal):\n 1. openin (top_of_set (Collect (Domainp B)))\n     (C \\<inter> Collect (Domainp B))", "using \\<open>open C\\<close>"], ["proof (prove)\nusing this:\n  openin (top_of_set (Collect (Domainp B))) (Collect (Domainp B))\n  open C\n\ngoal (1 subgoal):\n 1. openin (top_of_set (Collect (Domainp B)))\n     (C \\<inter> Collect (Domainp B))", "by auto"], ["proof (state)\nthis:\n  openin (top_of_set (Collect (Domainp B))) (C \\<inter> Collect (Domainp B))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n                   openin (top_of_set (Collect (Domainp B)))\n                    Ba \\<longrightarrow>\n                   f x \\<in> Ba \\<longrightarrow>\n                   (\\<exists>A.\n                       open A \\<and>\n                       x \\<in> A \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> A \\<longrightarrow> f y \\<in> Ba));\n     x \\<in> X; open C; f x \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> C)", "moreover"], ["proof (state)\nthis:\n  openin (top_of_set (Collect (Domainp B))) (C \\<inter> Collect (Domainp B))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n                   openin (top_of_set (Collect (Domainp B)))\n                    Ba \\<longrightarrow>\n                   f x \\<in> Ba \\<longrightarrow>\n                   (\\<exists>A.\n                       open A \\<and>\n                       x \\<in> A \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> A \\<longrightarrow> f y \\<in> Ba));\n     x \\<in> X; open C; f x \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> C)", "have \"f x \\<in> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<in> C \\<inter> Collect (Domainp B)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> X\n  open C\n  f x \\<in> C\n\ngoal (1 subgoal):\n 1. f x \\<in> C \\<inter> Collect (Domainp B)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x C.\n       \\<lbrakk>x \\<in> X; open C; f x \\<in> C\\<rbrakk>\n       \\<Longrightarrow> f x \\<in> C \\<inter> Collect (Domainp B)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x C.\n       \\<lbrakk>x \\<in> X; open C; f x \\<in> C\\<rbrakk>\n       \\<Longrightarrow> Domainp B (f x)", "by (meson Domainp_applyI H(1) H(2) rel_setD1)"], ["proof (state)\nthis:\n  f x \\<in> C \\<inter> Collect (Domainp B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n                   openin (top_of_set (Collect (Domainp B)))\n                    Ba \\<longrightarrow>\n                   f x \\<in> Ba \\<longrightarrow>\n                   (\\<exists>A.\n                       open A \\<and>\n                       x \\<in> A \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> A \\<longrightarrow> f y \\<in> Ba));\n     x \\<in> X; open C; f x \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> C)", "ultimately"], ["proof (chain)\npicking this:\n  openin (top_of_set (Collect (Domainp B))) (C \\<inter> Collect (Domainp B))\n  f x \\<in> C \\<inter> Collect (Domainp B)", "obtain D where \"open D \\<and> x \\<in> D \\<and> (\\<forall>y\\<in>X. y \\<in> D \\<longrightarrow> f y \\<in> ?B)\""], ["proof (prove)\nusing this:\n  openin (top_of_set (Collect (Domainp B))) (C \\<inter> Collect (Domainp B))\n  f x \\<in> C \\<inter> Collect (Domainp B)\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        open D \\<and>\n        x \\<in> D \\<and>\n        (\\<forall>y\\<in>X.\n            y \\<in> D \\<longrightarrow>\n            f y \\<in> C \\<inter> Collect (Domainp B)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cont x"], ["proof (prove)\nusing this:\n  openin (top_of_set (Collect (Domainp B))) (C \\<inter> Collect (Domainp B))\n  f x \\<in> C \\<inter> Collect (Domainp B)\n  \\<forall>x\\<in>X.\n     \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n        openin (top_of_set (Collect (Domainp B))) Ba \\<longrightarrow>\n        f x \\<in> Ba \\<longrightarrow>\n        (\\<exists>Aa.\n            open Aa \\<and>\n            x \\<in> Aa \\<and>\n            (\\<forall>y\\<in>X. y \\<in> Aa \\<longrightarrow> f y \\<in> Ba))\n  x \\<in> X\n  open C\n  f x \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        open D \\<and>\n        x \\<in> D \\<and>\n        (\\<forall>y\\<in>X.\n            y \\<in> D \\<longrightarrow>\n            f y \\<in> C \\<inter> Collect (Domainp B)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  open D \\<and>\n  x \\<in> D \\<and>\n  (\\<forall>y\\<in>X.\n      y \\<in> D \\<longrightarrow> f y \\<in> C \\<inter> Collect (Domainp B))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>Ba\\<in>{A. Ball A (Domainp B)}.\n                   openin (top_of_set (Collect (Domainp B)))\n                    Ba \\<longrightarrow>\n                   f x \\<in> Ba \\<longrightarrow>\n                   (\\<exists>A.\n                       open A \\<and>\n                       x \\<in> A \\<and>\n                       (\\<forall>y\\<in>X.\n                           y \\<in> A \\<longrightarrow> f y \\<in> Ba));\n     x \\<in> X; open C; f x \\<in> C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         open A \\<and>\n                         x \\<in> A \\<and>\n                         (\\<forall>y\\<in>X.\n                             y \\<in> A \\<longrightarrow> f y \\<in> C)", "then"], ["proof (chain)\npicking this:\n  open D \\<and>\n  x \\<in> D \\<and>\n  (\\<forall>y\\<in>X.\n      y \\<in> D \\<longrightarrow> f y \\<in> C \\<inter> Collect (Domainp B))", "show \"\\<exists>A. open A \\<and> x \\<in> A \\<and> (\\<forall>y\\<in>X. y \\<in> A \\<longrightarrow> f y \\<in> C)\""], ["proof (prove)\nusing this:\n  open D \\<and>\n  x \\<in> D \\<and>\n  (\\<forall>y\\<in>X.\n      y \\<in> D \\<longrightarrow> f y \\<in> C \\<inter> Collect (Domainp B))\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       open A \\<and>\n       x \\<in> A \\<and>\n       (\\<forall>y\\<in>X. y \\<in> A \\<longrightarrow> f y \\<in> C)", "by auto"], ["proof (state)\nthis:\n  \\<exists>A.\n     open A \\<and>\n     x \\<in> A \\<and>\n     (\\<forall>y\\<in>X. y \\<in> A \\<longrightarrow> f y \\<in> C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  continuous_on X f = continuous_on Y g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma generate_topology_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total A\" \"bi_unique A\"\n  shows \"(rel_set (rel_set A) ===> rel_set A ===> (=)) (generate_topology o (insert (Collect (Domainp A)))) generate_topology\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (rel_set A) ===> rel_set A ===> (=))\n     (generate_topology \\<circ> insert (Collect (Domainp A)))\n     generate_topology", "proof (intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set (rel_set A) x y; rel_set A xa ya\\<rbrakk>\n       \\<Longrightarrow> (generate_topology \\<circ>\n                          insert (Collect (Domainp A)))\n                          x xa =\n                         generate_topology y ya", "fix B C X Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set (rel_set A) x y; rel_set A xa ya\\<rbrakk>\n       \\<Longrightarrow> (generate_topology \\<circ>\n                          insert (Collect (Domainp A)))\n                          x xa =\n                         generate_topology y ya", "assume t[transfer_rule]: \"rel_set (rel_set A) B C\" \"rel_set A X Y\""], ["proof (state)\nthis:\n  rel_set (rel_set A) B C\n  rel_set A X Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set (rel_set A) x y; rel_set A xa ya\\<rbrakk>\n       \\<Longrightarrow> (generate_topology \\<circ>\n                          insert (Collect (Domainp A)))\n                          x xa =\n                         generate_topology y ya", "then"], ["proof (chain)\npicking this:\n  rel_set (rel_set A) B C\n  rel_set A X Y", "have \"X \\<subseteq> Collect (Domainp A)\""], ["proof (prove)\nusing this:\n  rel_set (rel_set A) B C\n  rel_set A X Y\n\ngoal (1 subgoal):\n 1. X \\<subseteq> Collect (Domainp A)", "by (auto simp: rel_set_def)"], ["proof (state)\nthis:\n  X \\<subseteq> Collect (Domainp A)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set (rel_set A) x y; rel_set A xa ya\\<rbrakk>\n       \\<Longrightarrow> (generate_topology \\<circ>\n                          insert (Collect (Domainp A)))\n                          x xa =\n                         generate_topology y ya", "with t"], ["proof (chain)\npicking this:\n  rel_set (rel_set A) B C\n  rel_set A X Y\n  X \\<subseteq> Collect (Domainp A)", "have rI: \"rel_set A (X \\<inter> Collect (Domainp A)) Y\""], ["proof (prove)\nusing this:\n  rel_set (rel_set A) B C\n  rel_set A X Y\n  X \\<subseteq> Collect (Domainp A)\n\ngoal (1 subgoal):\n 1. rel_set A (X \\<inter> Collect (Domainp A)) Y", "by (auto simp: inf_absorb1)"], ["proof (state)\nthis:\n  rel_set A (X \\<inter> Collect (Domainp A)) Y\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set (rel_set A) x y; rel_set A xa ya\\<rbrakk>\n       \\<Longrightarrow> (generate_topology \\<circ>\n                          insert (Collect (Domainp A)))\n                          x xa =\n                         generate_topology y ya", "have eq_UNIV_I: \"Z = UNIV\" if [transfer_rule]: \"rel_set A {a. Domainp A a} Z\" for Z"], ["proof (prove)\ngoal (1 subgoal):\n 1. Z = UNIV", "using that assms"], ["proof (prove)\nusing this:\n  rel_set A {a. Domainp A a} Z\n  right_total A\n  bi_unique A\n\ngoal (1 subgoal):\n 1. Z = UNIV", "apply (auto simp: right_total_def rel_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y. \\<exists>x. A x y; bi_unique A;\n        \\<forall>x.\n           Domainp A x \\<longrightarrow> (\\<exists>xa\\<in>Z. A x xa);\n        \\<forall>y\\<in>Z. \\<exists>x. Domainp A x \\<and> A x y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Z", "using bi_uniqueDr"], ["proof (prove)\nusing this:\n  \\<lbrakk>bi_unique ?A; ?A ?x ?y; ?A ?x ?z\\<rbrakk>\n  \\<Longrightarrow> ?y = ?z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y. \\<exists>x. A x y; bi_unique A;\n        \\<forall>x.\n           Domainp A x \\<longrightarrow> (\\<exists>xa\\<in>Z. A x xa);\n        \\<forall>y\\<in>Z. \\<exists>x. Domainp A x \\<and> A x y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Z", "by fastforce"], ["proof (state)\nthis:\n  rel_set A {a. Domainp A a} ?Z \\<Longrightarrow> ?Z = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set (rel_set A) x y; rel_set A xa ya\\<rbrakk>\n       \\<Longrightarrow> (generate_topology \\<circ>\n                          insert (Collect (Domainp A)))\n                          x xa =\n                         generate_topology y ya", "show \"(generate_topology \\<circ> insert (Collect (Domainp A))) B X = generate_topology C Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (generate_topology \\<circ> insert (Collect (Domainp A))) B X =\n    generate_topology C Y", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate_topology (insert (Collect (Domainp A)) B) X =\n    generate_topology C Y", "proof (rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. generate_topology (insert (Collect (Domainp A)) B) X \\<Longrightarrow>\n    generate_topology C Y\n 2. generate_topology C Y \\<Longrightarrow>\n    generate_topology (insert (Collect (Domainp A)) B) X", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. generate_topology (insert (Collect (Domainp A)) B) X \\<Longrightarrow>\n    generate_topology C Y\n 2. generate_topology C Y \\<Longrightarrow>\n    generate_topology (insert (Collect (Domainp A)) B) X", "assume \"generate_topology (insert (Collect (Domainp A)) B) X\""], ["proof (state)\nthis:\n  generate_topology (insert (Collect (Domainp A)) B) X\n\ngoal (2 subgoals):\n 1. generate_topology (insert (Collect (Domainp A)) B) X \\<Longrightarrow>\n    generate_topology C Y\n 2. generate_topology C Y \\<Longrightarrow>\n    generate_topology (insert (Collect (Domainp A)) B) X", "then"], ["proof (chain)\npicking this:\n  generate_topology (insert (Collect (Domainp A)) B) X", "show \"generate_topology C Y\""], ["proof (prove)\nusing this:\n  generate_topology (insert (Collect (Domainp A)) B) X\n\ngoal (1 subgoal):\n 1. generate_topology C Y", "unfolding o_def"], ["proof (prove)\nusing this:\n  generate_topology (insert (Collect (Domainp A)) B) X\n\ngoal (1 subgoal):\n 1. generate_topology C Y", "using rI"], ["proof (prove)\nusing this:\n  generate_topology (insert (Collect (Domainp A)) B) X\n  rel_set A (X \\<inter> Collect (Domainp A)) Y\n\ngoal (1 subgoal):\n 1. generate_topology C Y", "proof (induction X arbitrary: Y)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>Y.\n       rel_set A (UNIV \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n       generate_topology C Y\n 2. \\<And>a b Y.\n       \\<lbrakk>generate_topology (insert (Collect (Domainp A)) B) a;\n        \\<And>Y.\n           rel_set A (a \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        generate_topology (insert (Collect (Domainp A)) B) b;\n        \\<And>Y.\n           rel_set A (b \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        rel_set A (a \\<inter> b \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 3. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 4. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "case [transfer_rule]: UNIV"], ["proof (state)\nthis:\n  rel_set A (UNIV \\<inter> {a. Domainp A a}) Y\n\ngoal (4 subgoals):\n 1. \\<And>Y.\n       rel_set A (UNIV \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n       generate_topology C Y\n 2. \\<And>a b Y.\n       \\<lbrakk>generate_topology (insert (Collect (Domainp A)) B) a;\n        \\<And>Y.\n           rel_set A (a \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        generate_topology (insert (Collect (Domainp A)) B) b;\n        \\<And>Y.\n           rel_set A (b \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        rel_set A (a \\<inter> b \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 3. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 4. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "with eq_UNIV_I[of Y]"], ["proof (chain)\npicking this:\n  rel_set A {a. Domainp A a} Y \\<Longrightarrow> Y = UNIV\n  rel_set A (UNIV \\<inter> {a. Domainp A a}) Y", "show ?case"], ["proof (prove)\nusing this:\n  rel_set A {a. Domainp A a} Y \\<Longrightarrow> Y = UNIV\n  rel_set A (UNIV \\<inter> {a. Domainp A a}) Y\n\ngoal (1 subgoal):\n 1. generate_topology C Y", "by (simp add: generate_topology.UNIV)"], ["proof (state)\nthis:\n  generate_topology C Y\n\ngoal (3 subgoals):\n 1. \\<And>a b Y.\n       \\<lbrakk>generate_topology (insert (Collect (Domainp A)) B) a;\n        \\<And>Y.\n           rel_set A (a \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        generate_topology (insert (Collect (Domainp A)) B) b;\n        \\<And>Y.\n           rel_set A (b \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        rel_set A (a \\<inter> b \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 3. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b Y.\n       \\<lbrakk>generate_topology (insert (Collect (Domainp A)) B) a;\n        \\<And>Y.\n           rel_set A (a \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        generate_topology (insert (Collect (Domainp A)) B) b;\n        \\<And>Y.\n           rel_set A (b \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        rel_set A (a \\<inter> b \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 3. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "case (Int a b)"], ["proof (state)\nthis:\n  generate_topology (insert (Collect (Domainp A)) B) a\n  generate_topology (insert (Collect (Domainp A)) B) b\n  rel_set A (a \\<inter> {a. Domainp A a}) ?Y \\<Longrightarrow>\n  generate_topology C ?Y\n  rel_set A (b \\<inter> {a. Domainp A a}) ?Y \\<Longrightarrow>\n  generate_topology C ?Y\n  rel_set A (a \\<inter> b \\<inter> {a. Domainp A a}) Y\n\ngoal (3 subgoals):\n 1. \\<And>a b Y.\n       \\<lbrakk>generate_topology (insert (Collect (Domainp A)) B) a;\n        \\<And>Y.\n           rel_set A (a \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        generate_topology (insert (Collect (Domainp A)) B) b;\n        \\<And>Y.\n           rel_set A (b \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        rel_set A (a \\<inter> b \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 3. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "note [transfer_rule] = Int(5)"], ["proof (state)\nthis:\n  rel_set A (a \\<inter> b \\<inter> {a. Domainp A a}) Y\n\ngoal (3 subgoals):\n 1. \\<And>a b Y.\n       \\<lbrakk>generate_topology (insert (Collect (Domainp A)) B) a;\n        \\<And>Y.\n           rel_set A (a \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        generate_topology (insert (Collect (Domainp A)) B) b;\n        \\<And>Y.\n           rel_set A (b \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        rel_set A (a \\<inter> b \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 3. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "obtain a' where a'[transfer_rule]: \"rel_set A (a \\<inter> Collect (Domainp A)) a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        rel_set A (a \\<inter> Collect (Domainp A)) a' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Domainp_iff Domainp_set Int_Collect)"], ["proof (state)\nthis:\n  rel_set A (a \\<inter> Collect (Domainp A)) a'\n\ngoal (3 subgoals):\n 1. \\<And>a b Y.\n       \\<lbrakk>generate_topology (insert (Collect (Domainp A)) B) a;\n        \\<And>Y.\n           rel_set A (a \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        generate_topology (insert (Collect (Domainp A)) B) b;\n        \\<And>Y.\n           rel_set A (b \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        rel_set A (a \\<inter> b \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 3. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "obtain b' where b'[transfer_rule]: \"rel_set A (b \\<inter> Collect (Domainp A)) b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b'.\n        rel_set A (b \\<inter> Collect (Domainp A)) b' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Domainp_iff Domainp_set Int_Collect)"], ["proof (state)\nthis:\n  rel_set A (b \\<inter> Collect (Domainp A)) b'\n\ngoal (3 subgoals):\n 1. \\<And>a b Y.\n       \\<lbrakk>generate_topology (insert (Collect (Domainp A)) B) a;\n        \\<And>Y.\n           rel_set A (a \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        generate_topology (insert (Collect (Domainp A)) B) b;\n        \\<And>Y.\n           rel_set A (b \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        rel_set A (a \\<inter> b \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 3. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "from Int.IH(1)[OF a'] Int.IH(2)[OF b']"], ["proof (chain)\npicking this:\n  generate_topology C a'\n  generate_topology C b'", "have \"generate_topology C a'\" \"generate_topology C b'\""], ["proof (prove)\nusing this:\n  generate_topology C a'\n  generate_topology C b'\n\ngoal (1 subgoal):\n 1. generate_topology C a' &&& generate_topology C b'", "by auto"], ["proof (state)\nthis:\n  generate_topology C a'\n  generate_topology C b'\n\ngoal (3 subgoals):\n 1. \\<And>a b Y.\n       \\<lbrakk>generate_topology (insert (Collect (Domainp A)) B) a;\n        \\<And>Y.\n           rel_set A (a \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        generate_topology (insert (Collect (Domainp A)) B) b;\n        \\<And>Y.\n           rel_set A (b \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        rel_set A (a \\<inter> b \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 3. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "from generate_topology.Int[OF this]"], ["proof (chain)\npicking this:\n  generate_topology C (a' \\<inter> b')", "have \"generate_topology C (a' \\<inter> b')\""], ["proof (prove)\nusing this:\n  generate_topology C (a' \\<inter> b')\n\ngoal (1 subgoal):\n 1. generate_topology C (a' \\<inter> b')", "."], ["proof (state)\nthis:\n  generate_topology C (a' \\<inter> b')\n\ngoal (3 subgoals):\n 1. \\<And>a b Y.\n       \\<lbrakk>generate_topology (insert (Collect (Domainp A)) B) a;\n        \\<And>Y.\n           rel_set A (a \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        generate_topology (insert (Collect (Domainp A)) B) b;\n        \\<And>Y.\n           rel_set A (b \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        rel_set A (a \\<inter> b \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 3. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "also"], ["proof (state)\nthis:\n  generate_topology C (a' \\<inter> b')\n\ngoal (3 subgoals):\n 1. \\<And>a b Y.\n       \\<lbrakk>generate_topology (insert (Collect (Domainp A)) B) a;\n        \\<And>Y.\n           rel_set A (a \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        generate_topology (insert (Collect (Domainp A)) B) b;\n        \\<And>Y.\n           rel_set A (b \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        rel_set A (a \\<inter> b \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 3. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "have \"a' \\<inter> b' = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' \\<inter> b' = Y", "by transfer auto"], ["proof (state)\nthis:\n  a' \\<inter> b' = Y\n\ngoal (3 subgoals):\n 1. \\<And>a b Y.\n       \\<lbrakk>generate_topology (insert (Collect (Domainp A)) B) a;\n        \\<And>Y.\n           rel_set A (a \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        generate_topology (insert (Collect (Domainp A)) B) b;\n        \\<And>Y.\n           rel_set A (b \\<inter> Collect (Domainp A)) Y \\<Longrightarrow>\n           generate_topology C Y;\n        rel_set A (a \\<inter> b \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 3. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "finally"], ["proof (chain)\npicking this:\n  generate_topology C Y", "show ?case"], ["proof (prove)\nusing this:\n  generate_topology C Y\n\ngoal (1 subgoal):\n 1. generate_topology C Y", "by (simp add: generate_topology.Int)"], ["proof (state)\nthis:\n  generate_topology C Y\n\ngoal (2 subgoals):\n 1. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "case (UN K)"], ["proof (state)\nthis:\n  ?k \\<in> K \\<Longrightarrow>\n  generate_topology (insert (Collect (Domainp A)) B) ?k\n  \\<lbrakk>?k \\<in> K; rel_set A (?k \\<inter> {a. Domainp A a}) ?Y\\<rbrakk>\n  \\<Longrightarrow> generate_topology C ?Y\n  rel_set A (\\<Union> K \\<inter> {a. Domainp A a}) Y\n\ngoal (2 subgoals):\n 1. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "note [transfer_rule] = UN(3)"], ["proof (state)\nthis:\n  rel_set A (\\<Union> K \\<inter> {a. Domainp A a}) Y\n\ngoal (2 subgoals):\n 1. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "have \"\\<exists>K'. \\<forall>k. rel_set A (k \\<inter> Collect (Domainp A)) (K' k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K'.\n       \\<forall>k. rel_set A (k \\<inter> Collect (Domainp A)) (K' k)", "by (rule choice) (metis Domainp_iff Domainp_set Int_Collect)"], ["proof (state)\nthis:\n  \\<exists>K'. \\<forall>k. rel_set A (k \\<inter> Collect (Domainp A)) (K' k)\n\ngoal (2 subgoals):\n 1. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "then"], ["proof (chain)\npicking this:\n  \\<exists>K'. \\<forall>k. rel_set A (k \\<inter> Collect (Domainp A)) (K' k)", "obtain K' where K': \"\\<And>k. rel_set A (k \\<inter> Collect (Domainp A)) (K' k)\""], ["proof (prove)\nusing this:\n  \\<exists>K'. \\<forall>k. rel_set A (k \\<inter> Collect (Domainp A)) (K' k)\n\ngoal (1 subgoal):\n 1. (\\<And>K'.\n        (\\<And>k.\n            rel_set A (k \\<inter> Collect (Domainp A))\n             (K' k)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  rel_set A (?k \\<inter> Collect (Domainp A)) (K' ?k)\n\ngoal (2 subgoals):\n 1. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "from UN.IH[OF _ this]"], ["proof (chain)\npicking this:\n  ?k \\<in> K \\<Longrightarrow> generate_topology C (K' ?k)", "have \"generate_topology C k'\" if \"k' \\<in> K'`K\" for k'"], ["proof (prove)\nusing this:\n  ?k \\<in> K \\<Longrightarrow> generate_topology C (K' ?k)\n\ngoal (1 subgoal):\n 1. generate_topology C k'", "using that"], ["proof (prove)\nusing this:\n  ?k \\<in> K \\<Longrightarrow> generate_topology C (K' ?k)\n  k' \\<in> K' ` K\n\ngoal (1 subgoal):\n 1. generate_topology C k'", "by auto"], ["proof (state)\nthis:\n  ?k' \\<in> K' ` K \\<Longrightarrow> generate_topology C ?k'\n\ngoal (2 subgoals):\n 1. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "from generate_topology.UN[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>k. k \\<in> ?K \\<Longrightarrow> k \\<in> K' ` K) \\<Longrightarrow>\n  generate_topology C (\\<Union> ?K)", "have \"generate_topology C (\\<Union>(K' ` K))\""], ["proof (prove)\nusing this:\n  (\\<And>k. k \\<in> ?K \\<Longrightarrow> k \\<in> K' ` K) \\<Longrightarrow>\n  generate_topology C (\\<Union> ?K)\n\ngoal (1 subgoal):\n 1. generate_topology C (\\<Union> (K' ` K))", "."], ["proof (state)\nthis:\n  generate_topology C (\\<Union> (K' ` K))\n\ngoal (2 subgoals):\n 1. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "also"], ["proof (state)\nthis:\n  generate_topology C (\\<Union> (K' ` K))\n\ngoal (2 subgoals):\n 1. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "from K'"], ["proof (chain)\npicking this:\n  rel_set A (?k \\<inter> Collect (Domainp A)) (K' ?k)", "have [transfer_rule]: \"(rel_set (=) ===> rel_set A) (\\<lambda>x. x \\<inter> Collect (Domainp A)) K'\""], ["proof (prove)\nusing this:\n  rel_set A (?k \\<inter> Collect (Domainp A)) (K' ?k)\n\ngoal (1 subgoal):\n 1. (rel_set (=) ===> rel_set A)\n     (\\<lambda>x. x \\<inter> Collect (Domainp A)) K'", "by (fastforce simp: rel_fun_def rel_set_def)"], ["proof (state)\nthis:\n  (rel_set (=) ===> rel_set A) (\\<lambda>x. x \\<inter> Collect (Domainp A))\n   K'\n\ngoal (2 subgoals):\n 1. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "have \"\\<Union>(K' ` K) = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (K' ` K) = Y", "by transfer auto"], ["proof (state)\nthis:\n  \\<Union> (K' ` K) = Y\n\ngoal (2 subgoals):\n 1. \\<And>K Y.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology (insert (Collect (Domainp A)) B) k;\n        \\<And>k Y.\n           \\<lbrakk>k \\<in> K;\n            rel_set A (k \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n           \\<Longrightarrow> generate_topology C Y;\n        rel_set A (\\<Union> K \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y\n 2. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "finally"], ["proof (chain)\npicking this:\n  generate_topology C Y", "show ?case"], ["proof (prove)\nusing this:\n  generate_topology C Y\n\ngoal (1 subgoal):\n 1. generate_topology C Y", "by (simp add: generate_topology.UN)"], ["proof (state)\nthis:\n  generate_topology C Y\n\ngoal (1 subgoal):\n 1. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "case (Basis s)"], ["proof (state)\nthis:\n  s \\<in> insert (Collect (Domainp A)) B\n  rel_set A (s \\<inter> {a. Domainp A a}) Y\n\ngoal (1 subgoal):\n 1. \\<And>s Y.\n       \\<lbrakk>s \\<in> insert (Collect (Domainp A)) B;\n        rel_set A (s \\<inter> Collect (Domainp A)) Y\\<rbrakk>\n       \\<Longrightarrow> generate_topology C Y", "from this(1)"], ["proof (chain)\npicking this:\n  s \\<in> insert (Collect (Domainp A)) B", "show ?case"], ["proof (prove)\nusing this:\n  s \\<in> insert (Collect (Domainp A)) B\n\ngoal (1 subgoal):\n 1. generate_topology C Y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s = Collect (Domainp A) \\<Longrightarrow> generate_topology C Y\n 2. s \\<in> B \\<Longrightarrow> generate_topology C Y", "assume \"s = Collect (Domainp A)\""], ["proof (state)\nthis:\n  s = Collect (Domainp A)\n\ngoal (2 subgoals):\n 1. s = Collect (Domainp A) \\<Longrightarrow> generate_topology C Y\n 2. s \\<in> B \\<Longrightarrow> generate_topology C Y", "with eq_UNIV_I[of Y] Basis(2)"], ["proof (chain)\npicking this:\n  rel_set A {a. Domainp A a} Y \\<Longrightarrow> Y = UNIV\n  rel_set A (s \\<inter> {a. Domainp A a}) Y\n  s = Collect (Domainp A)", "show ?case"], ["proof (prove)\nusing this:\n  rel_set A {a. Domainp A a} Y \\<Longrightarrow> Y = UNIV\n  rel_set A (s \\<inter> {a. Domainp A a}) Y\n  s = Collect (Domainp A)\n\ngoal (1 subgoal):\n 1. generate_topology C Y", "by (simp add: generate_topology.UNIV)"], ["proof (state)\nthis:\n  generate_topology C Y\n\ngoal (1 subgoal):\n 1. s \\<in> B \\<Longrightarrow> generate_topology C Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<in> B \\<Longrightarrow> generate_topology C Y", "assume \"s \\<in> B\""], ["proof (state)\nthis:\n  s \\<in> B\n\ngoal (1 subgoal):\n 1. s \\<in> B \\<Longrightarrow> generate_topology C Y", "with Basis(2)"], ["proof (chain)\npicking this:\n  rel_set A (s \\<inter> {a. Domainp A a}) Y\n  s \\<in> B", "obtain t where [transfer_rule]: \"rel_set A (s \\<inter> Collect (Domainp A)) t\""], ["proof (prove)\nusing this:\n  rel_set A (s \\<inter> {a. Domainp A a}) Y\n  s \\<in> B\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        rel_set A (s \\<inter> Collect (Domainp A)) t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rel_set A (s \\<inter> Collect (Domainp A)) t\n\ngoal (1 subgoal):\n 1. s \\<in> B \\<Longrightarrow> generate_topology C Y", "from Basis(1) t(1)"], ["proof (chain)\npicking this:\n  s \\<in> insert (Collect (Domainp A)) B\n  rel_set (rel_set A) B C", "have s: \"s \\<inter> Collect (Domainp A) = s\""], ["proof (prove)\nusing this:\n  s \\<in> insert (Collect (Domainp A)) B\n  rel_set (rel_set A) B C\n\ngoal (1 subgoal):\n 1. s \\<inter> Collect (Domainp A) = s", "by (force simp: rel_set_def)"], ["proof (state)\nthis:\n  s \\<inter> Collect (Domainp A) = s\n\ngoal (1 subgoal):\n 1. s \\<in> B \\<Longrightarrow> generate_topology C Y", "have \"t \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> C", "using \\<open>s \\<in> B\\<close> s"], ["proof (prove)\nusing this:\n  s \\<in> B\n  s \\<inter> Collect (Domainp A) = s\n\ngoal (1 subgoal):\n 1. t \\<in> C", "by transfer auto"], ["proof (state)\nthis:\n  t \\<in> C\n\ngoal (1 subgoal):\n 1. s \\<in> B \\<Longrightarrow> generate_topology C Y", "also"], ["proof (state)\nthis:\n  t \\<in> C\n\ngoal (1 subgoal):\n 1. s \\<in> B \\<Longrightarrow> generate_topology C Y", "note [transfer_rule] = Basis(2)"], ["proof (state)\nthis:\n  rel_set A (s \\<inter> {a. Domainp A a}) Y\n\ngoal (1 subgoal):\n 1. s \\<in> B \\<Longrightarrow> generate_topology C Y", "have \"t = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = Y", "by transfer auto"], ["proof (state)\nthis:\n  t = Y\n\ngoal (1 subgoal):\n 1. s \\<in> B \\<Longrightarrow> generate_topology C Y", "finally"], ["proof (chain)\npicking this:\n  Y \\<in> C", "show ?case"], ["proof (prove)\nusing this:\n  Y \\<in> C\n\ngoal (1 subgoal):\n 1. generate_topology C Y", "by (rule generate_topology.Basis)"], ["proof (state)\nthis:\n  generate_topology C Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  generate_topology C Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  generate_topology C Y\n\ngoal (1 subgoal):\n 1. generate_topology C Y \\<Longrightarrow>\n    generate_topology (insert (Collect (Domainp A)) B) X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. generate_topology C Y \\<Longrightarrow>\n    generate_topology (insert (Collect (Domainp A)) B) X", "assume \"generate_topology C Y\""], ["proof (state)\nthis:\n  generate_topology C Y\n\ngoal (1 subgoal):\n 1. generate_topology C Y \\<Longrightarrow>\n    generate_topology (insert (Collect (Domainp A)) B) X", "then"], ["proof (chain)\npicking this:\n  generate_topology C Y", "show \"generate_topology (insert (Collect (Domainp A)) B) X\""], ["proof (prove)\nusing this:\n  generate_topology C Y\n\ngoal (1 subgoal):\n 1. generate_topology (insert (Collect (Domainp A)) B) X", "using \\<open>rel_set A X Y\\<close>"], ["proof (prove)\nusing this:\n  generate_topology C Y\n  rel_set A X Y\n\ngoal (1 subgoal):\n 1. generate_topology (insert (Collect (Domainp A)) B) X", "proof (induction arbitrary: X)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>X.\n       rel_set A X UNIV \\<Longrightarrow>\n       generate_topology (insert (Collect (Domainp A)) B) X\n 2. \\<And>a b X.\n       \\<lbrakk>generate_topology C a;\n        \\<And>X.\n           rel_set A X a \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        generate_topology C b;\n        \\<And>X.\n           rel_set A X b \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        rel_set A X (a \\<inter> b)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 3. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 4. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "case [transfer_rule]: UNIV"], ["proof (state)\nthis:\n  rel_set A X UNIV\n\ngoal (4 subgoals):\n 1. \\<And>X.\n       rel_set A X UNIV \\<Longrightarrow>\n       generate_topology (insert (Collect (Domainp A)) B) X\n 2. \\<And>a b X.\n       \\<lbrakk>generate_topology C a;\n        \\<And>X.\n           rel_set A X a \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        generate_topology C b;\n        \\<And>X.\n           rel_set A X b \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        rel_set A X (a \\<inter> b)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 3. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 4. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "have \"UNIV = (UNIV::'b set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = UNIV", "by auto"], ["proof (state)\nthis:\n  UNIV = UNIV\n\ngoal (4 subgoals):\n 1. \\<And>X.\n       rel_set A X UNIV \\<Longrightarrow>\n       generate_topology (insert (Collect (Domainp A)) B) X\n 2. \\<And>a b X.\n       \\<lbrakk>generate_topology C a;\n        \\<And>X.\n           rel_set A X a \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        generate_topology C b;\n        \\<And>X.\n           rel_set A X b \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        rel_set A X (a \\<inter> b)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 3. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 4. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "then"], ["proof (chain)\npicking this:\n  UNIV = UNIV", "have \"X = {a. Domainp A a}\""], ["proof (prove)\nusing this:\n  UNIV = UNIV\n\ngoal (1 subgoal):\n 1. X = {a. Domainp A a}", "by transfer"], ["proof (state)\nthis:\n  X = {a. Domainp A a}\n\ngoal (4 subgoals):\n 1. \\<And>X.\n       rel_set A X UNIV \\<Longrightarrow>\n       generate_topology (insert (Collect (Domainp A)) B) X\n 2. \\<And>a b X.\n       \\<lbrakk>generate_topology C a;\n        \\<And>X.\n           rel_set A X a \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        generate_topology C b;\n        \\<And>X.\n           rel_set A X b \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        rel_set A X (a \\<inter> b)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 3. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 4. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "then"], ["proof (chain)\npicking this:\n  X = {a. Domainp A a}", "show ?case"], ["proof (prove)\nusing this:\n  X = {a. Domainp A a}\n\ngoal (1 subgoal):\n 1. generate_topology (insert {a. Domainp A a} B) X", "by (intro generate_topology.Basis) auto"], ["proof (state)\nthis:\n  generate_topology (insert {a. Domainp A a} B) X\n\ngoal (3 subgoals):\n 1. \\<And>a b X.\n       \\<lbrakk>generate_topology C a;\n        \\<And>X.\n           rel_set A X a \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        generate_topology C b;\n        \\<And>X.\n           rel_set A X b \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        rel_set A X (a \\<inter> b)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 3. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b X.\n       \\<lbrakk>generate_topology C a;\n        \\<And>X.\n           rel_set A X a \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        generate_topology C b;\n        \\<And>X.\n           rel_set A X b \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        rel_set A X (a \\<inter> b)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 3. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "case (Int a b)"], ["proof (state)\nthis:\n  generate_topology C a\n  generate_topology C b\n  rel_set A ?X a \\<Longrightarrow>\n  generate_topology (insert {a. Domainp A a} B) ?X\n  rel_set A ?X b \\<Longrightarrow>\n  generate_topology (insert {a. Domainp A a} B) ?X\n  rel_set A X (a \\<inter> b)\n\ngoal (3 subgoals):\n 1. \\<And>a b X.\n       \\<lbrakk>generate_topology C a;\n        \\<And>X.\n           rel_set A X a \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        generate_topology C b;\n        \\<And>X.\n           rel_set A X b \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        rel_set A X (a \\<inter> b)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 3. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "obtain a' b' where [transfer_rule]: \"rel_set A a' a\" \"rel_set A b' b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a' b'.\n        \\<lbrakk>rel_set A a' a; rel_set A b' b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson assms(1) right_total_def right_total_rel_set)"], ["proof (state)\nthis:\n  rel_set A a' a\n  rel_set A b' b\n\ngoal (3 subgoals):\n 1. \\<And>a b X.\n       \\<lbrakk>generate_topology C a;\n        \\<And>X.\n           rel_set A X a \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        generate_topology C b;\n        \\<And>X.\n           rel_set A X b \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        rel_set A X (a \\<inter> b)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 3. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "from generate_topology.Int[OF Int.IH(1)[OF this(1)] Int.IH(2)[OF this(2)]]"], ["proof (chain)\npicking this:\n  generate_topology (insert {a. Domainp A a} B) (a' \\<inter> b')", "have \"generate_topology (insert {a. Domainp A a} B) (a' \\<inter> b')\""], ["proof (prove)\nusing this:\n  generate_topology (insert {a. Domainp A a} B) (a' \\<inter> b')\n\ngoal (1 subgoal):\n 1. generate_topology (insert {a. Domainp A a} B) (a' \\<inter> b')", "by simp"], ["proof (state)\nthis:\n  generate_topology (insert {a. Domainp A a} B) (a' \\<inter> b')\n\ngoal (3 subgoals):\n 1. \\<And>a b X.\n       \\<lbrakk>generate_topology C a;\n        \\<And>X.\n           rel_set A X a \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        generate_topology C b;\n        \\<And>X.\n           rel_set A X b \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        rel_set A X (a \\<inter> b)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 3. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "also"], ["proof (state)\nthis:\n  generate_topology (insert {a. Domainp A a} B) (a' \\<inter> b')\n\ngoal (3 subgoals):\n 1. \\<And>a b X.\n       \\<lbrakk>generate_topology C a;\n        \\<And>X.\n           rel_set A X a \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        generate_topology C b;\n        \\<And>X.\n           rel_set A X b \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        rel_set A X (a \\<inter> b)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 3. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "define I where \"I = a \\<inter> b\""], ["proof (state)\nthis:\n  I = a \\<inter> b\n\ngoal (3 subgoals):\n 1. \\<And>a b X.\n       \\<lbrakk>generate_topology C a;\n        \\<And>X.\n           rel_set A X a \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        generate_topology C b;\n        \\<And>X.\n           rel_set A X b \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        rel_set A X (a \\<inter> b)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 3. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "from \\<open>rel_set A X (a \\<inter> b)\\<close>"], ["proof (chain)\npicking this:\n  rel_set A X (a \\<inter> b)", "have [transfer_rule]: \"rel_set A X I\""], ["proof (prove)\nusing this:\n  rel_set A X (a \\<inter> b)\n\ngoal (1 subgoal):\n 1. rel_set A X I", "by (simp add: I_def)"], ["proof (state)\nthis:\n  rel_set A X I\n\ngoal (3 subgoals):\n 1. \\<And>a b X.\n       \\<lbrakk>generate_topology C a;\n        \\<And>X.\n           rel_set A X a \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        generate_topology C b;\n        \\<And>X.\n           rel_set A X b \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        rel_set A X (a \\<inter> b)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 3. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "from I_def"], ["proof (chain)\npicking this:\n  I = a \\<inter> b", "have \"a' \\<inter> b' = X\""], ["proof (prove)\nusing this:\n  I = a \\<inter> b\n\ngoal (1 subgoal):\n 1. a' \\<inter> b' = X", "by transfer simp"], ["proof (state)\nthis:\n  a' \\<inter> b' = X\n\ngoal (3 subgoals):\n 1. \\<And>a b X.\n       \\<lbrakk>generate_topology C a;\n        \\<And>X.\n           rel_set A X a \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        generate_topology C b;\n        \\<And>X.\n           rel_set A X b \\<Longrightarrow>\n           generate_topology (insert (Collect (Domainp A)) B) X;\n        rel_set A X (a \\<inter> b)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 3. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "finally"], ["proof (chain)\npicking this:\n  generate_topology (insert {a. Domainp A a} B) X", "show ?case"], ["proof (prove)\nusing this:\n  generate_topology (insert {a. Domainp A a} B) X\n\ngoal (1 subgoal):\n 1. generate_topology (insert {a. Domainp A a} B) X", "."], ["proof (state)\nthis:\n  generate_topology (insert {a. Domainp A a} B) X\n\ngoal (2 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "case (UN K)"], ["proof (state)\nthis:\n  ?k \\<in> K \\<Longrightarrow> generate_topology C ?k\n  \\<lbrakk>?k \\<in> K; rel_set A ?X ?k\\<rbrakk>\n  \\<Longrightarrow> generate_topology (insert {a. Domainp A a} B) ?X\n  rel_set A X (\\<Union> K)\n\ngoal (2 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "have \"\\<exists>K'. \\<forall>k. rel_set A (K' k) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K'. \\<forall>k. rel_set A (K' k) k", "by (rule choice) (meson assms(1) right_total_def right_total_rel_set)"], ["proof (state)\nthis:\n  \\<exists>K'. \\<forall>k. rel_set A (K' k) k\n\ngoal (2 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "then"], ["proof (chain)\npicking this:\n  \\<exists>K'. \\<forall>k. rel_set A (K' k) k", "obtain K' where K': \"\\<And>k. rel_set A (K' k) k\""], ["proof (prove)\nusing this:\n  \\<exists>K'. \\<forall>k. rel_set A (K' k) k\n\ngoal (1 subgoal):\n 1. (\\<And>K'.\n        (\\<And>k. rel_set A (K' k) k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  rel_set A (K' ?k) ?k\n\ngoal (2 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "from UN.IH[OF _ this]"], ["proof (chain)\npicking this:\n  ?k \\<in> K \\<Longrightarrow>\n  generate_topology (insert {a. Domainp A a} B) (K' ?k)", "have \"generate_topology (insert {a. Domainp A a} B) k\"\n        if \"k \\<in> K'`K\" for k"], ["proof (prove)\nusing this:\n  ?k \\<in> K \\<Longrightarrow>\n  generate_topology (insert {a. Domainp A a} B) (K' ?k)\n\ngoal (1 subgoal):\n 1. generate_topology (insert {a. Domainp A a} B) k", "using that"], ["proof (prove)\nusing this:\n  ?k \\<in> K \\<Longrightarrow>\n  generate_topology (insert {a. Domainp A a} B) (K' ?k)\n  k \\<in> K' ` K\n\ngoal (1 subgoal):\n 1. generate_topology (insert {a. Domainp A a} B) k", "by auto"], ["proof (state)\nthis:\n  ?k \\<in> K' ` K \\<Longrightarrow>\n  generate_topology (insert {a. Domainp A a} B) ?k\n\ngoal (2 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "from generate_topology.UN[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>k. k \\<in> ?K \\<Longrightarrow> k \\<in> K' ` K) \\<Longrightarrow>\n  generate_topology (insert {a. Domainp A a} B) (\\<Union> ?K)", "have \"generate_topology (insert {a. Domainp A a} B) (\\<Union>(K'`K))\""], ["proof (prove)\nusing this:\n  (\\<And>k. k \\<in> ?K \\<Longrightarrow> k \\<in> K' ` K) \\<Longrightarrow>\n  generate_topology (insert {a. Domainp A a} B) (\\<Union> ?K)\n\ngoal (1 subgoal):\n 1. generate_topology (insert {a. Domainp A a} B) (\\<Union> (K' ` K))", "by auto"], ["proof (state)\nthis:\n  generate_topology (insert {a. Domainp A a} B) (\\<Union> (K' ` K))\n\ngoal (2 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "also"], ["proof (state)\nthis:\n  generate_topology (insert {a. Domainp A a} B) (\\<Union> (K' ` K))\n\ngoal (2 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "from K'"], ["proof (chain)\npicking this:\n  rel_set A (K' ?k) ?k", "have [transfer_rule]: \"(rel_set (=) ===> rel_set A) K' id\""], ["proof (prove)\nusing this:\n  rel_set A (K' ?k) ?k\n\ngoal (1 subgoal):\n 1. (rel_set (=) ===> rel_set A) K' id", "by (fastforce simp: rel_fun_def rel_set_def)"], ["proof (state)\nthis:\n  (rel_set (=) ===> rel_set A) K' id\n\ngoal (2 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "define U where \"U =  (\\<Union>(id ` K))\""], ["proof (state)\nthis:\n  U = \\<Union> (id ` K)\n\ngoal (2 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "from \\<open>rel_set A X _\\<close>"], ["proof (chain)\npicking this:\n  rel_set A X (\\<Union> K)", "have [transfer_rule]: \"rel_set A X U\""], ["proof (prove)\nusing this:\n  rel_set A X (\\<Union> K)\n\ngoal (1 subgoal):\n 1. rel_set A X U", "by (simp add: U_def)"], ["proof (state)\nthis:\n  rel_set A X U\n\ngoal (2 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "from U_def"], ["proof (chain)\npicking this:\n  U = \\<Union> (id ` K)", "have \"\\<Union>(K' ` K) = X\""], ["proof (prove)\nusing this:\n  U = \\<Union> (id ` K)\n\ngoal (1 subgoal):\n 1. \\<Union> (K' ` K) = X", "by transfer simp"], ["proof (state)\nthis:\n  \\<Union> (K' ` K) = X\n\ngoal (2 subgoals):\n 1. \\<And>K X.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology C k;\n        \\<And>k X.\n           \\<lbrakk>k \\<in> K; rel_set A X k\\<rbrakk>\n           \\<Longrightarrow> generate_topology\n                              (insert (Collect (Domainp A)) B) X;\n        rel_set A X (\\<Union> K)\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X\n 2. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "finally"], ["proof (chain)\npicking this:\n  generate_topology (insert {a. Domainp A a} B) X", "show ?case"], ["proof (prove)\nusing this:\n  generate_topology (insert {a. Domainp A a} B) X\n\ngoal (1 subgoal):\n 1. generate_topology (insert {a. Domainp A a} B) X", "."], ["proof (state)\nthis:\n  generate_topology (insert {a. Domainp A a} B) X\n\ngoal (1 subgoal):\n 1. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "case (Basis s)"], ["proof (state)\nthis:\n  s \\<in> C\n  rel_set A X s\n\ngoal (1 subgoal):\n 1. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "note [transfer_rule] = \\<open>rel_set A X s\\<close>"], ["proof (state)\nthis:\n  rel_set A X s\n\ngoal (1 subgoal):\n 1. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "from \\<open>s \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> C", "have \"X \\<in> B\""], ["proof (prove)\nusing this:\n  s \\<in> C\n\ngoal (1 subgoal):\n 1. X \\<in> B", "by transfer"], ["proof (state)\nthis:\n  X \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>s X.\n       \\<lbrakk>s \\<in> C; rel_set A X s\\<rbrakk>\n       \\<Longrightarrow> generate_topology (insert (Collect (Domainp A)) B)\n                          X", "then"], ["proof (chain)\npicking this:\n  X \\<in> B", "show ?case"], ["proof (prove)\nusing this:\n  X \\<in> B\n\ngoal (1 subgoal):\n 1. generate_topology (insert {a. Domainp A a} B) X", "by (intro generate_topology.Basis) auto"], ["proof (state)\nthis:\n  generate_topology (insert {a. Domainp A a} B) X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  generate_topology (insert (Collect (Domainp A)) B) X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (generate_topology \\<circ> insert (Collect (Domainp A))) B X =\n  generate_topology C Y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Miscellaneous\\<close>"], ["", "lemmas [simp del] = mem_ball"], ["", "lemma in_closureI[intro, simp]: \"x \\<in> X \\<Longrightarrow> x \\<in> closure X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> x \\<in> closure X", "using closure_subset"], ["proof (prove)\nusing this:\n  ?S \\<subseteq> closure ?S\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> x \\<in> closure X", "by auto"], ["", "lemmas open_continuous_vimage = continuous_on_open_vimage[THEN iffD1, rule_format]"], ["", "lemma open_continuous_vimage': \"open s \\<Longrightarrow> continuous_on s f \\<Longrightarrow> open B \\<Longrightarrow> open (s \\<inter> f -` B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>open s; continuous_on s f; open B\\<rbrakk>\n    \\<Longrightarrow> open (s \\<inter> f -` B)", "using open_continuous_vimage[of s f B]"], ["proof (prove)\nusing this:\n  \\<lbrakk>open s; continuous_on s f; open B\\<rbrakk>\n  \\<Longrightarrow> open (f -` B \\<inter> s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>open s; continuous_on s f; open B\\<rbrakk>\n    \\<Longrightarrow> open (s \\<inter> f -` B)", "by (auto simp: Int_commute)"], ["", "lemma support_on_mono: \"support_on carrier f \\<subseteq> support_on carrier g\"\n  if \"\\<And>x. x \\<in> carrier \\<Longrightarrow> f x \\<noteq> 0 \\<Longrightarrow> g x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_on carrier f \\<subseteq> support_on carrier g", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier; f ?x \\<noteq> (0::'b)\\<rbrakk>\n  \\<Longrightarrow> g ?x \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. support_on carrier f \\<subseteq> support_on carrier g", "by (auto simp: support_on_def)"], ["", "lemma image_prod: \"(\\<lambda>(x, y). (f x, g y)) ` (A \\<times> B) = f ` A \\<times> g ` B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). (f x, g y)) ` (A \\<times> B) = f ` A \\<times> g ` B", "by auto"], ["", "subsection \\<open>Closed support\\<close>"], ["", "definition \"csupport_on X S = closure (support_on X S)\""], ["", "lemma closed_csupport_on[intro, simp]: \"closed (csupport_on carrier \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (csupport_on carrier \\<phi>)", "by (auto simp: csupport_on_def)"], ["", "lemma not_in_csupportD: \"x \\<notin> csupport_on carrier \\<phi> \\<Longrightarrow> x \\<in> carrier \\<Longrightarrow> \\<phi> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> csupport_on carrier \\<phi>; x \\<in> carrier\\<rbrakk>\n    \\<Longrightarrow> \\<phi> x = (0::'b)", "by (auto simp: csupport_on_def support_on_def)"], ["", "lemma csupport_on_mono: \"csupport_on carrier f \\<subseteq> csupport_on carrier g\"\n  if \"\\<And>x. x \\<in> carrier \\<Longrightarrow> f x \\<noteq> 0 \\<Longrightarrow> g x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csupport_on carrier f \\<subseteq> csupport_on carrier g", "unfolding csupport_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (support_on carrier f)\n    \\<subseteq> closure (support_on carrier g)", "apply (rule closure_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. support_on carrier f \\<subseteq> support_on carrier g", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier; f ?x \\<noteq> (0::'b)\\<rbrakk>\n  \\<Longrightarrow> g ?x \\<noteq> (0::'c)\n\ngoal (1 subgoal):\n 1. support_on carrier f \\<subseteq> support_on carrier g", "by (rule support_on_mono)"], ["", "subsection \\<open>Homeomorphism\\<close>"], ["", "lemma homeomorphism_empty[simp]:\n  \"homeomorphism {} t f f' \\<longleftrightarrow> t = {}\"\n  \"homeomorphism s {} f f' \\<longleftrightarrow> s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homeomorphism {} t f f' = (t = {}) &&&\n    homeomorphism s {} f f' = (s = {})", "by (auto simp: homeomorphism_def)"], ["", "lemma homeomorphism_add:\n  \"homeomorphism UNIV UNIV (\\<lambda>x. x + c) (\\<lambda>x. x - c)\"\n  for c::\"_::real_normed_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homeomorphism UNIV UNIV (\\<lambda>x. x + c) (\\<lambda>x. x - c)", "unfolding homeomorphism_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>UNIV. x + c - c = x) \\<and>\n    surj (\\<lambda>x. x + c) \\<and>\n    continuous_on UNIV (\\<lambda>x. x + c) \\<and>\n    (\\<forall>y\\<in>UNIV. y - c + c = y) \\<and>\n    surj (\\<lambda>x. x - c) \\<and> continuous_on UNIV (\\<lambda>x. x - c)", "by (auto simp: algebra_simps continuous_intros intro!: image_eqI[where x=\"x - c\" for x])"], ["", "lemma in_range_scaleR_iff: \"x \\<in> range ((*\\<^sub>R) c) \\<longleftrightarrow> c = 0 \\<longrightarrow> x = 0\"\n  for x::\"_::real_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> range ((*\\<^sub>R) c)) = (c = 0 \\<longrightarrow> x = (0::'b))", "by (auto simp: intro!: image_eqI[where x=\"x /\\<^sub>R c\"])"], ["", "lemma homeomorphism_scaleR:\n  \"homeomorphism UNIV UNIV (\\<lambda>x. c *\\<^sub>R x::_::real_normed_vector) (\\<lambda>x. x /\\<^sub>R c)\"\n  if \"c \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homeomorphism UNIV UNIV ((*\\<^sub>R) c) (\\<lambda>x. x /\\<^sub>R c)", "using that"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. homeomorphism UNIV UNIV ((*\\<^sub>R) c) (\\<lambda>x. x /\\<^sub>R c)", "unfolding homeomorphism_def"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>UNIV. c *\\<^sub>R x /\\<^sub>R c = x) \\<and>\n    surj ((*\\<^sub>R) c) \\<and>\n    continuous_on UNIV ((*\\<^sub>R) c) \\<and>\n    (\\<forall>y\\<in>UNIV. c *\\<^sub>R (y /\\<^sub>R c) = y) \\<and>\n    surj ((*\\<^sub>R) (inverse c)) \\<and>\n    continuous_on UNIV ((*\\<^sub>R) (inverse c))", "by (auto simp: in_range_scaleR_iff algebra_simps intro!: continuous_intros)"], ["", "lemma homeomorphism_prod:\n  \"homeomorphism (a \\<times> b) (c \\<times> d) (\\<lambda>(x, y). (f x, g y)) (\\<lambda>(x, y). (f' x, g' y))\"\n  if \"homeomorphism a c f f'\"\n     \"homeomorphism b d g g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homeomorphism (a \\<times> b) (c \\<times> d)\n     (\\<lambda>(x, y). (f x, g y)) (\\<lambda>(x, y). (f' x, g' y))", "using that"], ["proof (prove)\nusing this:\n  homeomorphism a c f f'\n  homeomorphism b d g g'\n\ngoal (1 subgoal):\n 1. homeomorphism (a \\<times> b) (c \\<times> d)\n     (\\<lambda>(x, y). (f x, g y)) (\\<lambda>(x, y). (f' x, g' y))", "by (simp add: homeomorphism_def image_prod)\n    (auto simp add: split_beta intro!: continuous_intros elim: continuous_on_compose2)"], ["", "subsection \\<open>Generalizations\\<close>"], ["", "lemma openin_subtopology_eq_generate_topology:\n  \"openin (top_of_set S) x = generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x\"\n  if open_gen: \"open = generate_topology BB\" and subset: \"x \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (top_of_set S) x =\n    generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. openin (top_of_set S) x =\n    generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x", "have \"generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) (T \\<inter> S)\"\n    if \"generate_topology BB T\"\n    for T"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n     (T \\<inter> S)", "using that"], ["proof (prove)\nusing this:\n  generate_topology BB T\n\ngoal (1 subgoal):\n 1. generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n     (T \\<inter> S)", "proof (induction)"], ["proof (state)\ngoal (4 subgoals):\n 1. generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n     (UNIV \\<inter> S)\n 2. \\<And>a b.\n       \\<lbrakk>generate_topology BB a;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n         (a \\<inter> S);\n        generate_topology BB b;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n         (b \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (a \\<inter> b \\<inter> S)\n 3. \\<And>K.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology BB k;\n        \\<And>k.\n           k \\<in> K \\<Longrightarrow>\n           generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n            (k \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (\\<Union> K \\<inter> S)\n 4. \\<And>s.\n       s \\<in> BB \\<Longrightarrow>\n       generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n        (s \\<inter> S)", "case UNIV"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n     (UNIV \\<inter> S)\n 2. \\<And>a b.\n       \\<lbrakk>generate_topology BB a;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n         (a \\<inter> S);\n        generate_topology BB b;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n         (b \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (a \\<inter> b \\<inter> S)\n 3. \\<And>K.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology BB k;\n        \\<And>k.\n           k \\<in> K \\<Longrightarrow>\n           generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n            (k \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (\\<Union> K \\<inter> S)\n 4. \\<And>s.\n       s \\<in> BB \\<Longrightarrow>\n       generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n        (s \\<inter> S)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n     (UNIV \\<inter> S)", "by (auto intro!: generate_topology.Basis)"], ["proof (state)\nthis:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (UNIV \\<inter> S)\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>generate_topology BB a;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n         (a \\<inter> S);\n        generate_topology BB b;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n         (b \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (a \\<inter> b \\<inter> S)\n 2. \\<And>K.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology BB k;\n        \\<And>k.\n           k \\<in> K \\<Longrightarrow>\n           generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n            (k \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (\\<Union> K \\<inter> S)\n 3. \\<And>s.\n       s \\<in> BB \\<Longrightarrow>\n       generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n        (s \\<inter> S)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>generate_topology BB a;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n         (a \\<inter> S);\n        generate_topology BB b;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n         (b \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (a \\<inter> b \\<inter> S)\n 2. \\<And>K.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology BB k;\n        \\<And>k.\n           k \\<in> K \\<Longrightarrow>\n           generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n            (k \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (\\<Union> K \\<inter> S)\n 3. \\<And>s.\n       s \\<in> BB \\<Longrightarrow>\n       generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n        (s \\<inter> S)", "case (Int a b)"], ["proof (state)\nthis:\n  generate_topology BB a\n  generate_topology BB b\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (a \\<inter> S)\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (b \\<inter> S)\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>generate_topology BB a;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n         (a \\<inter> S);\n        generate_topology BB b;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n         (b \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (a \\<inter> b \\<inter> S)\n 2. \\<And>K.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology BB k;\n        \\<And>k.\n           k \\<in> K \\<Longrightarrow>\n           generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n            (k \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (\\<Union> K \\<inter> S)\n 3. \\<And>s.\n       s \\<in> BB \\<Longrightarrow>\n       generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n        (s \\<inter> S)", "have \"generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) (a \\<inter> S \\<inter> (b \\<inter> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n     (a \\<inter> S \\<inter> (b \\<inter> S))", "by (rule generate_topology.Int) (use Int in auto)"], ["proof (state)\nthis:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (a \\<inter> S \\<inter> (b \\<inter> S))\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>generate_topology BB a;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n         (a \\<inter> S);\n        generate_topology BB b;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n         (b \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (a \\<inter> b \\<inter> S)\n 2. \\<And>K.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology BB k;\n        \\<And>k.\n           k \\<in> K \\<Longrightarrow>\n           generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n            (k \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (\\<Union> K \\<inter> S)\n 3. \\<And>s.\n       s \\<in> BB \\<Longrightarrow>\n       generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n        (s \\<inter> S)", "then"], ["proof (chain)\npicking this:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (a \\<inter> S \\<inter> (b \\<inter> S))", "show ?case"], ["proof (prove)\nusing this:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (a \\<inter> S \\<inter> (b \\<inter> S))\n\ngoal (1 subgoal):\n 1. generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n     (a \\<inter> b \\<inter> S)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (a \\<inter> b \\<inter> S)\n\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology BB k;\n        \\<And>k.\n           k \\<in> K \\<Longrightarrow>\n           generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n            (k \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (\\<Union> K \\<inter> S)\n 2. \\<And>s.\n       s \\<in> BB \\<Longrightarrow>\n       generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n        (s \\<inter> S)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology BB k;\n        \\<And>k.\n           k \\<in> K \\<Longrightarrow>\n           generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n            (k \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (\\<Union> K \\<inter> S)\n 2. \\<And>s.\n       s \\<in> BB \\<Longrightarrow>\n       generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n        (s \\<inter> S)", "case (UN K)"], ["proof (state)\nthis:\n  ?k \\<in> K \\<Longrightarrow> generate_topology BB ?k\n  ?k \\<in> K \\<Longrightarrow>\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (?k \\<inter> S)\n\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology BB k;\n        \\<And>k.\n           k \\<in> K \\<Longrightarrow>\n           generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n            (k \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (\\<Union> K \\<inter> S)\n 2. \\<And>s.\n       s \\<in> BB \\<Longrightarrow>\n       generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n        (s \\<inter> S)", "then"], ["proof (chain)\npicking this:\n  ?k \\<in> K \\<Longrightarrow> generate_topology BB ?k\n  ?k \\<in> K \\<Longrightarrow>\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (?k \\<inter> S)", "have \"generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) (\\<Union>k\\<in>K. k \\<inter> S)\""], ["proof (prove)\nusing this:\n  ?k \\<in> K \\<Longrightarrow> generate_topology BB ?k\n  ?k \\<in> K \\<Longrightarrow>\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (?k \\<inter> S)\n\ngoal (1 subgoal):\n 1. generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n     (\\<Union>k\\<in>K. k \\<inter> S)", "by (intro generate_topology.UN) auto"], ["proof (state)\nthis:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (\\<Union>k\\<in>K. k \\<inter> S)\n\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>\\<And>k. k \\<in> K \\<Longrightarrow> generate_topology BB k;\n        \\<And>k.\n           k \\<in> K \\<Longrightarrow>\n           generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n            (k \\<inter> S)\\<rbrakk>\n       \\<Longrightarrow> generate_topology\n                          (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n                          (\\<Union> K \\<inter> S)\n 2. \\<And>s.\n       s \\<in> BB \\<Longrightarrow>\n       generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n        (s \\<inter> S)", "then"], ["proof (chain)\npicking this:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (\\<Union>k\\<in>K. k \\<inter> S)", "show ?case"], ["proof (prove)\nusing this:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (\\<Union>k\\<in>K. k \\<inter> S)\n\ngoal (1 subgoal):\n 1. generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n     (\\<Union> K \\<inter> S)", "by simp"], ["proof (state)\nthis:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (\\<Union> K \\<inter> S)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> BB \\<Longrightarrow>\n       generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n        (s \\<inter> S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> BB \\<Longrightarrow>\n       generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n        (s \\<inter> S)", "case (Basis s)"], ["proof (state)\nthis:\n  s \\<in> BB\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> BB \\<Longrightarrow>\n       generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n        (s \\<inter> S)", "then"], ["proof (chain)\npicking this:\n  s \\<in> BB", "show ?case"], ["proof (prove)\nusing this:\n  s \\<in> BB\n\ngoal (1 subgoal):\n 1. generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n     (s \\<inter> S)", "by (intro generate_topology.Basis) auto"], ["proof (state)\nthis:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (s \\<inter> S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  generate_topology BB ?T \\<Longrightarrow>\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (?T \\<inter> S)\n\ngoal (1 subgoal):\n 1. openin (top_of_set S) x =\n    generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x", "moreover"], ["proof (state)\nthis:\n  generate_topology BB ?T \\<Longrightarrow>\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (?T \\<inter> S)\n\ngoal (1 subgoal):\n 1. openin (top_of_set S) x =\n    generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x", "have \"\\<exists>T. generate_topology BB T \\<and> x = T \\<inter> S\"\n    if \"generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x\" \"x \\<noteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T. generate_topology BB T \\<and> x = T \\<inter> S", "using that"], ["proof (prove)\nusing this:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x\n  x \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>T. generate_topology BB T \\<and> x = T \\<inter> S", "proof (induction)"], ["proof (state)\ngoal (4 subgoals):\n 1. UNIV \\<noteq> UNIV \\<Longrightarrow>\n    \\<exists>T. generate_topology BB T \\<and> UNIV = T \\<inter> S\n 2. \\<And>a b.\n       \\<lbrakk>generate_topology\n                 (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) a;\n        a \\<noteq> UNIV \\<Longrightarrow>\n        \\<exists>T. generate_topology BB T \\<and> a = T \\<inter> S;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) b;\n        b \\<noteq> UNIV \\<Longrightarrow>\n        \\<exists>T. generate_topology BB T \\<and> b = T \\<inter> S;\n        a \\<inter> b \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            a \\<inter> b = T \\<inter> S\n 3. \\<And>K.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology\n                    (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) k;\n        \\<And>k.\n           \\<lbrakk>k \\<in> K; k \\<noteq> UNIV\\<rbrakk>\n           \\<Longrightarrow> \\<exists>T.\n                                generate_topology BB T \\<and>\n                                k = T \\<inter> S;\n        \\<Union> K \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            \\<Union> K = T \\<inter> S\n 4. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "case UNIV"], ["proof (state)\nthis:\n  UNIV \\<noteq> UNIV\n\ngoal (4 subgoals):\n 1. UNIV \\<noteq> UNIV \\<Longrightarrow>\n    \\<exists>T. generate_topology BB T \\<and> UNIV = T \\<inter> S\n 2. \\<And>a b.\n       \\<lbrakk>generate_topology\n                 (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) a;\n        a \\<noteq> UNIV \\<Longrightarrow>\n        \\<exists>T. generate_topology BB T \\<and> a = T \\<inter> S;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) b;\n        b \\<noteq> UNIV \\<Longrightarrow>\n        \\<exists>T. generate_topology BB T \\<and> b = T \\<inter> S;\n        a \\<inter> b \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            a \\<inter> b = T \\<inter> S\n 3. \\<And>K.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology\n                    (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) k;\n        \\<And>k.\n           \\<lbrakk>k \\<in> K; k \\<noteq> UNIV\\<rbrakk>\n           \\<Longrightarrow> \\<exists>T.\n                                generate_topology BB T \\<and>\n                                k = T \\<inter> S;\n        \\<Union> K \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            \\<Union> K = T \\<inter> S\n 4. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "then"], ["proof (chain)\npicking this:\n  UNIV \\<noteq> UNIV", "show ?case"], ["proof (prove)\nusing this:\n  UNIV \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>T. generate_topology BB T \\<and> UNIV = T \\<inter> S", "by simp"], ["proof (state)\nthis:\n  \\<exists>T. generate_topology BB T \\<and> UNIV = T \\<inter> S\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>generate_topology\n                 (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) a;\n        a \\<noteq> UNIV \\<Longrightarrow>\n        \\<exists>T. generate_topology BB T \\<and> a = T \\<inter> S;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) b;\n        b \\<noteq> UNIV \\<Longrightarrow>\n        \\<exists>T. generate_topology BB T \\<and> b = T \\<inter> S;\n        a \\<inter> b \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            a \\<inter> b = T \\<inter> S\n 2. \\<And>K.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology\n                    (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) k;\n        \\<And>k.\n           \\<lbrakk>k \\<in> K; k \\<noteq> UNIV\\<rbrakk>\n           \\<Longrightarrow> \\<exists>T.\n                                generate_topology BB T \\<and>\n                                k = T \\<inter> S;\n        \\<Union> K \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            \\<Union> K = T \\<inter> S\n 3. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>generate_topology\n                 (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) a;\n        a \\<noteq> UNIV \\<Longrightarrow>\n        \\<exists>T. generate_topology BB T \\<and> a = T \\<inter> S;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) b;\n        b \\<noteq> UNIV \\<Longrightarrow>\n        \\<exists>T. generate_topology BB T \\<and> b = T \\<inter> S;\n        a \\<inter> b \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            a \\<inter> b = T \\<inter> S\n 2. \\<And>K.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology\n                    (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) k;\n        \\<And>k.\n           \\<lbrakk>k \\<in> K; k \\<noteq> UNIV\\<rbrakk>\n           \\<Longrightarrow> \\<exists>T.\n                                generate_topology BB T \\<and>\n                                k = T \\<inter> S;\n        \\<Union> K \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            \\<Union> K = T \\<inter> S\n 3. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "case (Int a b)"], ["proof (state)\nthis:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) a\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) b\n  a \\<noteq> UNIV \\<Longrightarrow>\n  \\<exists>T. generate_topology BB T \\<and> a = T \\<inter> S\n  b \\<noteq> UNIV \\<Longrightarrow>\n  \\<exists>T. generate_topology BB T \\<and> b = T \\<inter> S\n  a \\<inter> b \\<noteq> UNIV\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>generate_topology\n                 (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) a;\n        a \\<noteq> UNIV \\<Longrightarrow>\n        \\<exists>T. generate_topology BB T \\<and> a = T \\<inter> S;\n        generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) b;\n        b \\<noteq> UNIV \\<Longrightarrow>\n        \\<exists>T. generate_topology BB T \\<and> b = T \\<inter> S;\n        a \\<inter> b \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            a \\<inter> b = T \\<inter> S\n 2. \\<And>K.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology\n                    (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) k;\n        \\<And>k.\n           \\<lbrakk>k \\<in> K; k \\<noteq> UNIV\\<rbrakk>\n           \\<Longrightarrow> \\<exists>T.\n                                generate_topology BB T \\<and>\n                                k = T \\<inter> S;\n        \\<Union> K \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            \\<Union> K = T \\<inter> S\n 3. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "then"], ["proof (chain)\npicking this:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) a\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) b\n  a \\<noteq> UNIV \\<Longrightarrow>\n  \\<exists>T. generate_topology BB T \\<and> a = T \\<inter> S\n  b \\<noteq> UNIV \\<Longrightarrow>\n  \\<exists>T. generate_topology BB T \\<and> b = T \\<inter> S\n  a \\<inter> b \\<noteq> UNIV", "show ?case"], ["proof (prove)\nusing this:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) a\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) b\n  a \\<noteq> UNIV \\<Longrightarrow>\n  \\<exists>T. generate_topology BB T \\<and> a = T \\<inter> S\n  b \\<noteq> UNIV \\<Longrightarrow>\n  \\<exists>T. generate_topology BB T \\<and> b = T \\<inter> S\n  a \\<inter> b \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>T. generate_topology BB T \\<and> a \\<inter> b = T \\<inter> S", "using generate_topology.Int"], ["proof (prove)\nusing this:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) a\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) b\n  a \\<noteq> UNIV \\<Longrightarrow>\n  \\<exists>T. generate_topology BB T \\<and> a = T \\<inter> S\n  b \\<noteq> UNIV \\<Longrightarrow>\n  \\<exists>T. generate_topology BB T \\<and> b = T \\<inter> S\n  a \\<inter> b \\<noteq> UNIV\n  \\<lbrakk>generate_topology ?S ?a; generate_topology ?S ?b\\<rbrakk>\n  \\<Longrightarrow> generate_topology ?S (?a \\<inter> ?b)\n\ngoal (1 subgoal):\n 1. \\<exists>T. generate_topology BB T \\<and> a \\<inter> b = T \\<inter> S", "by auto"], ["proof (state)\nthis:\n  \\<exists>T. generate_topology BB T \\<and> a \\<inter> b = T \\<inter> S\n\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology\n                    (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) k;\n        \\<And>k.\n           \\<lbrakk>k \\<in> K; k \\<noteq> UNIV\\<rbrakk>\n           \\<Longrightarrow> \\<exists>T.\n                                generate_topology BB T \\<and>\n                                k = T \\<inter> S;\n        \\<Union> K \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            \\<Union> K = T \\<inter> S\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology\n                    (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) k;\n        \\<And>k.\n           \\<lbrakk>k \\<in> K; k \\<noteq> UNIV\\<rbrakk>\n           \\<Longrightarrow> \\<exists>T.\n                                generate_topology BB T \\<and>\n                                k = T \\<inter> S;\n        \\<Union> K \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            \\<Union> K = T \\<inter> S\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "case (UN K)"], ["proof (state)\nthis:\n  ?k \\<in> K \\<Longrightarrow>\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) ?k\n  \\<lbrakk>?k \\<in> K; ?k \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       generate_topology BB T \\<and> ?k = T \\<inter> S\n  \\<Union> K \\<noteq> UNIV\n\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology\n                    (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) k;\n        \\<And>k.\n           \\<lbrakk>k \\<in> K; k \\<noteq> UNIV\\<rbrakk>\n           \\<Longrightarrow> \\<exists>T.\n                                generate_topology BB T \\<and>\n                                k = T \\<inter> S;\n        \\<Union> K \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            \\<Union> K = T \\<inter> S\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "from UN.IH"], ["proof (chain)\npicking this:\n  \\<lbrakk>?k \\<in> K; ?k \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       generate_topology BB T \\<and> ?k = T \\<inter> S", "have \"\\<forall>k\\<in>K-{UNIV}. \\<exists>T. generate_topology BB T \\<and> k = T \\<inter> S\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?k \\<in> K; ?k \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       generate_topology BB T \\<and> ?k = T \\<inter> S\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>K - {UNIV}.\n       \\<exists>T. generate_topology BB T \\<and> k = T \\<inter> S", "by auto"], ["proof (state)\nthis:\n  \\<forall>k\\<in>K - {UNIV}.\n     \\<exists>T. generate_topology BB T \\<and> k = T \\<inter> S\n\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology\n                    (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) k;\n        \\<And>k.\n           \\<lbrakk>k \\<in> K; k \\<noteq> UNIV\\<rbrakk>\n           \\<Longrightarrow> \\<exists>T.\n                                generate_topology BB T \\<and>\n                                k = T \\<inter> S;\n        \\<Union> K \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            \\<Union> K = T \\<inter> S\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "from this[THEN bchoice]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x\\<in>K - {UNIV}.\n        generate_topology BB (f x) \\<and> x = f x \\<inter> S", "obtain T where T: \"\\<And>k. k \\<in> T ` (K - {UNIV}) \\<Longrightarrow> generate_topology BB k\" \"\\<And>k. k \\<in> K - {UNIV} \\<Longrightarrow> k = (T k) \\<inter> S\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>x\\<in>K - {UNIV}.\n        generate_topology BB (f x) \\<and> x = f x \\<inter> S\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>\\<And>k.\n                    k \\<in> T ` (K - {UNIV}) \\<Longrightarrow>\n                    generate_topology BB k;\n         \\<And>k.\n            k \\<in> K - {UNIV} \\<Longrightarrow> k = T k \\<inter> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ?k \\<in> T ` (K - {UNIV}) \\<Longrightarrow> generate_topology BB ?k\n  ?k \\<in> K - {UNIV} \\<Longrightarrow> ?k = T ?k \\<inter> S\n\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology\n                    (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) k;\n        \\<And>k.\n           \\<lbrakk>k \\<in> K; k \\<noteq> UNIV\\<rbrakk>\n           \\<Longrightarrow> \\<exists>T.\n                                generate_topology BB T \\<and>\n                                k = T \\<inter> S;\n        \\<Union> K \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            \\<Union> K = T \\<inter> S\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "from generate_topology.UN[OF T(1)]"], ["proof (chain)\npicking this:\n  (\\<And>k.\n      k \\<in> ?K \\<Longrightarrow>\n      k \\<in> T ` (K - {UNIV})) \\<Longrightarrow>\n  generate_topology BB (\\<Union> ?K)", "have \"generate_topology BB (\\<Union>(T ` (K - {UNIV})))\""], ["proof (prove)\nusing this:\n  (\\<And>k.\n      k \\<in> ?K \\<Longrightarrow>\n      k \\<in> T ` (K - {UNIV})) \\<Longrightarrow>\n  generate_topology BB (\\<Union> ?K)\n\ngoal (1 subgoal):\n 1. generate_topology BB (\\<Union> (T ` (K - {UNIV})))", "by auto"], ["proof (state)\nthis:\n  generate_topology BB (\\<Union> (T ` (K - {UNIV})))\n\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology\n                    (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) k;\n        \\<And>k.\n           \\<lbrakk>k \\<in> K; k \\<noteq> UNIV\\<rbrakk>\n           \\<Longrightarrow> \\<exists>T.\n                                generate_topology BB T \\<and>\n                                k = T \\<inter> S;\n        \\<Union> K \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            \\<Union> K = T \\<inter> S\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "moreover"], ["proof (state)\nthis:\n  generate_topology BB (\\<Union> (T ` (K - {UNIV})))\n\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology\n                    (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) k;\n        \\<And>k.\n           \\<lbrakk>k \\<in> K; k \\<noteq> UNIV\\<rbrakk>\n           \\<Longrightarrow> \\<exists>T.\n                                generate_topology BB T \\<and>\n                                k = T \\<inter> S;\n        \\<Union> K \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            \\<Union> K = T \\<inter> S\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "have \"\\<Union>K = (\\<Union>(T ` (K - {UNIV}))) \\<inter> S\" if \"UNIV \\<notin> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> K = \\<Union> (T ` (K - {UNIV})) \\<inter> S", "using T(2) UN that"], ["proof (prove)\nusing this:\n  ?k \\<in> K - {UNIV} \\<Longrightarrow> ?k = T ?k \\<inter> S\n  ?k \\<in> K \\<Longrightarrow>\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) ?k\n  \\<lbrakk>?k \\<in> K; ?k \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       generate_topology BB T \\<and> ?k = T \\<inter> S\n  \\<Union> K \\<noteq> UNIV\n  UNIV \\<notin> K\n\ngoal (1 subgoal):\n 1. \\<Union> K = \\<Union> (T ` (K - {UNIV})) \\<inter> S", "by auto"], ["proof (state)\nthis:\n  UNIV \\<notin> K \\<Longrightarrow>\n  \\<Union> K = \\<Union> (T ` (K - {UNIV})) \\<inter> S\n\ngoal (2 subgoals):\n 1. \\<And>K.\n       \\<lbrakk>\\<And>k.\n                   k \\<in> K \\<Longrightarrow>\n                   generate_topology\n                    (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) k;\n        \\<And>k.\n           \\<lbrakk>k \\<in> K; k \\<noteq> UNIV\\<rbrakk>\n           \\<Longrightarrow> \\<exists>T.\n                                generate_topology BB T \\<and>\n                                k = T \\<inter> S;\n        \\<Union> K \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and>\n                            \\<Union> K = T \\<inter> S\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "ultimately"], ["proof (chain)\npicking this:\n  generate_topology BB (\\<Union> (T ` (K - {UNIV})))\n  UNIV \\<notin> K \\<Longrightarrow>\n  \\<Union> K = \\<Union> (T ` (K - {UNIV})) \\<inter> S", "show ?case"], ["proof (prove)\nusing this:\n  generate_topology BB (\\<Union> (T ` (K - {UNIV})))\n  UNIV \\<notin> K \\<Longrightarrow>\n  \\<Union> K = \\<Union> (T ` (K - {UNIV})) \\<inter> S\n\ngoal (1 subgoal):\n 1. \\<exists>T. generate_topology BB T \\<and> \\<Union> K = T \\<inter> S", "apply (cases \"UNIV \\<in> K\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>generate_topology BB (\\<Union> (T ` (K - {UNIV})));\n     UNIV \\<notin> K \\<Longrightarrow>\n     \\<Union> K = \\<Union> (T ` (K - {UNIV})) \\<inter> S;\n     UNIV \\<in> K\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         generate_topology BB T \\<and>\n                         \\<Union> K = T \\<inter> S\n 2. \\<lbrakk>generate_topology BB (\\<Union> (T ` (K - {UNIV})));\n     UNIV \\<notin> K \\<Longrightarrow>\n     \\<Union> K = \\<Union> (T ` (K - {UNIV})) \\<inter> S;\n     UNIV \\<notin> K\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         generate_topology BB T \\<and>\n                         \\<Union> K = T \\<inter> S", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>generate_topology BB (\\<Union> (T ` (K - {UNIV})));\n     UNIV \\<notin> K \\<Longrightarrow>\n     \\<Union> K = \\<Union> (T ` (K - {UNIV})) \\<inter> S;\n     UNIV \\<in> K\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         generate_topology BB T \\<and>\n                         \\<Union> K = T \\<inter> S", "using UN"], ["proof (prove)\nusing this:\n  ?k \\<in> K \\<Longrightarrow>\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) ?k\n  \\<lbrakk>?k \\<in> K; ?k \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       generate_topology BB T \\<and> ?k = T \\<inter> S\n  \\<Union> K \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>generate_topology BB (\\<Union> (T ` (K - {UNIV})));\n     UNIV \\<notin> K \\<Longrightarrow>\n     \\<Union> K = \\<Union> (T ` (K - {UNIV})) \\<inter> S;\n     UNIV \\<in> K\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         generate_topology BB T \\<and>\n                         \\<Union> K = T \\<inter> S", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>generate_topology BB (\\<Union> (T ` (K - {UNIV})));\n     UNIV \\<notin> K \\<Longrightarrow>\n     \\<Union> K = \\<Union> (T ` (K - {UNIV})) \\<inter> S;\n     UNIV \\<notin> K\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         generate_topology BB T \\<and>\n                         \\<Union> K = T \\<inter> S", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>generate_topology BB (\\<Union> (T ` (K - {UNIV})));\n     UNIV \\<notin> K \\<Longrightarrow>\n     \\<Union> K = \\<Union> (T ` (K - {UNIV})) \\<inter> S;\n     UNIV \\<notin> K\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T.\n                         generate_topology BB T \\<and>\n                         \\<Union> K = T \\<inter> S", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>T. generate_topology BB T \\<and> \\<Union> K = T \\<inter> S\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "case (Basis s)"], ["proof (state)\nthis:\n  s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB)\n  s \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB);\n        s \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            generate_topology BB T \\<and> s = T \\<inter> S", "then"], ["proof (chain)\npicking this:\n  s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB)\n  s \\<noteq> UNIV", "show ?case"], ["proof (prove)\nusing this:\n  s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB)\n  s \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>T. generate_topology BB T \\<and> s = T \\<inter> S", "using generate_topology.UNIV generate_topology.Basis"], ["proof (prove)\nusing this:\n  s \\<in> insert S ((\\<lambda>B. B \\<inter> S) ` BB)\n  s \\<noteq> UNIV\n  generate_topology ?S UNIV\n  ?s \\<in> ?S \\<Longrightarrow> generate_topology ?S ?s\n\ngoal (1 subgoal):\n 1. \\<exists>T. generate_topology BB T \\<and> s = T \\<inter> S", "by blast"], ["proof (state)\nthis:\n  \\<exists>T. generate_topology BB T \\<and> s = T \\<inter> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x;\n   x \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       generate_topology BB T \\<and> x = T \\<inter> S\n\ngoal (1 subgoal):\n 1. openin (top_of_set S) x =\n    generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x;\n   x \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       generate_topology BB T \\<and> x = T \\<inter> S\n\ngoal (1 subgoal):\n 1. openin (top_of_set S) x =\n    generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x", "have \"\\<exists>T. generate_topology BB T \\<and> UNIV = T \\<inter> S\" if \"generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x\"\n     \"x = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T. generate_topology BB T \\<and> UNIV = T \\<inter> S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>T. generate_topology BB T \\<and> UNIV = T \\<inter> S", "have \"S = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = UNIV", "using that \\<open>x \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x\n  x = UNIV\n  x \\<subseteq> S\n\ngoal (1 subgoal):\n 1. S = UNIV", "by auto"], ["proof (state)\nthis:\n  S = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>T. generate_topology BB T \\<and> UNIV = T \\<inter> S", "then"], ["proof (chain)\npicking this:\n  S = UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  S = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>T. generate_topology BB T \\<and> UNIV = T \\<inter> S", "by (simp add: generate_topology.UNIV)"], ["proof (state)\nthis:\n  \\<exists>T. generate_topology BB T \\<and> UNIV = T \\<inter> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x;\n   x = UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       generate_topology BB T \\<and> UNIV = T \\<inter> S\n\ngoal (1 subgoal):\n 1. openin (top_of_set S) x =\n    generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x", "ultimately"], ["proof (chain)\npicking this:\n  generate_topology BB ?T \\<Longrightarrow>\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (?T \\<inter> S)\n  \\<lbrakk>generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x;\n   x \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       generate_topology BB T \\<and> x = T \\<inter> S\n  \\<lbrakk>generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x;\n   x = UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       generate_topology BB T \\<and> UNIV = T \\<inter> S", "show ?thesis"], ["proof (prove)\nusing this:\n  generate_topology BB ?T \\<Longrightarrow>\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB))\n   (?T \\<inter> S)\n  \\<lbrakk>generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x;\n   x \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       generate_topology BB T \\<and> x = T \\<inter> S\n  \\<lbrakk>generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x;\n   x = UNIV\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T.\n                       generate_topology BB T \\<and> UNIV = T \\<inter> S\n\ngoal (1 subgoal):\n 1. openin (top_of_set S) x =\n    generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x", "by (metis open_gen open_openin openin_open_Int' openin_subtopology)"], ["proof (state)\nthis:\n  openin (top_of_set S) x =\n  generate_topology (insert S ((\\<lambda>B. B \\<inter> S) ` BB)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Equal topologies\\<close>"], ["", "lemma topology_eq_iff: \"t = s \\<longleftrightarrow> (topspace t = topspace s \\<and>\n  (\\<forall>x\\<subseteq>topspace t. openin t x = openin s x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t = s) =\n    (topspace t = topspace s \\<and>\n     (\\<forall>x\\<subseteq>topspace t. openin t x = openin s x))", "by (metis (full_types) openin_subset topology_eq)"], ["", "subsection \\<open>Finer topologies\\<close>"], ["", "definition finer_than (infix \"(finer'_than)\" 50)\n  where \"T1 finer_than T2 \\<longleftrightarrow> continuous_map T1 T2 (\\<lambda>x. x)\""], ["", "lemma finer_than_iff_nhds:\n  \"T1 finer_than T2 \\<longleftrightarrow> (\\<forall>X. openin T2 X \\<longrightarrow> openin T1 (X \\<inter> topspace T1)) \\<and> (topspace T1 \\<subseteq> topspace T2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (T1 finer_than T2) =\n    ((\\<forall>X.\n         openin T2 X \\<longrightarrow>\n         openin T1 (X \\<inter> topspace T1)) \\<and>\n     topspace T1 \\<subseteq> topspace T2)", "by (auto simp: finer_than_def continuous_map_alt)"], ["", "lemma continuous_on_finer_topo:\n  \"continuous_map s t f\"\n  if \"continuous_map s' t f\" \"s finer_than s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map s t f", "using that"], ["proof (prove)\nusing this:\n  continuous_map s' t f\n  s finer_than s'\n\ngoal (1 subgoal):\n 1. continuous_map s t f", "by (auto simp: finer_than_def o_def dest: continuous_map_compose)"], ["", "lemma continuous_on_finer_topo2:\n  \"continuous_map s t f\"\n  if \"continuous_map s t' f\" \"t' finer_than t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map s t f", "using that"], ["proof (prove)\nusing this:\n  continuous_map s t' f\n  t' finer_than t\n\ngoal (1 subgoal):\n 1. continuous_map s t f", "by (auto simp: finer_than_def o_def dest: continuous_map_compose)"], ["", "lemma antisym_finer_than: \"S = T\" if \"S finer_than T\" \"T finer_than S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = T", "using that"], ["proof (prove)\nusing this:\n  S finer_than T\n  T finer_than S\n\ngoal (1 subgoal):\n 1. S = T", "apply (auto simp: finer_than_def topology_eq_iff continuous_map_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>U.\n                   openin T U \\<longrightarrow>\n                   openin S (U \\<inter> topspace T);\n        topspace S = topspace T;\n        \\<forall>U.\n           openin S U \\<longrightarrow> openin T (U \\<inter> topspace T);\n        x \\<subseteq> topspace T; openin S x\\<rbrakk>\n       \\<Longrightarrow> openin T x\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>U.\n                   openin T U \\<longrightarrow>\n                   openin S (U \\<inter> topspace T);\n        topspace S = topspace T;\n        \\<forall>U.\n           openin S U \\<longrightarrow> openin T (U \\<inter> topspace T);\n        x \\<subseteq> topspace T; openin T x\\<rbrakk>\n       \\<Longrightarrow> openin S x", "apply (metis inf.orderE)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subtopology_finer_than[simp]: \"top_of_set X finer_than euclidean\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_of_set X finer_than euclidean", "by (auto simp: finer_than_iff_nhds openin_subtopology)"], ["", "subsection \\<open>Support\\<close>"], ["", "lemma support_on_nonneg_sum:\n  \"support_on X (\\<lambda>x. \\<Sum>i\\<in>S. f i x) = (\\<Union>i\\<in>S. support_on X (f i))\"\n  if \"finite S\" \"\\<And>x i . x \\<in> X \\<Longrightarrow> i \\<in> S \\<Longrightarrow> f i x \\<ge> 0\"\n  for f::\"_\\<Rightarrow>_\\<Rightarrow>_::ordered_comm_monoid_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_on X (\\<lambda>x. \\<Sum>i\\<in>S. f i x) =\n    (\\<Union>i\\<in>S. support_on X (f i))", "using that"], ["proof (prove)\nusing this:\n  finite S\n  \\<lbrakk>?x \\<in> X; ?i \\<in> S\\<rbrakk>\n  \\<Longrightarrow> (0::'f) \\<le> f ?i ?x\n\ngoal (1 subgoal):\n 1. support_on X (\\<lambda>x. \\<Sum>i\\<in>S. f i x) =\n    (\\<Union>i\\<in>S. support_on X (f i))", "by (auto simp: support_on_def sum_nonneg_eq_0_iff)"], ["", "lemma support_on_nonneg_sum_subset:\n  \"support_on X (\\<lambda>x. \\<Sum>i\\<in>S. f i x) \\<subseteq> (\\<Union>i\\<in>S. support_on X (f i))\"\n  for f::\"_\\<Rightarrow>_\\<Rightarrow>_::ordered_comm_monoid_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_on X (\\<lambda>x. \\<Sum>i\\<in>S. f i x)\n    \\<subseteq> (\\<Union>i\\<in>S. support_on X (f i))", "by (cases \"finite S\") (auto simp: support_on_def, meson sum.neutral)"], ["", "lemma support_on_nonneg_sum_subset':\n  \"support_on X (\\<lambda>x. \\<Sum>i\\<in>S x. f i x) \\<subseteq> (\\<Union>x\\<in>X. (\\<Union>i\\<in>S x. support_on X (f i)))\"\n  for f::\"_\\<Rightarrow>_\\<Rightarrow>_::ordered_comm_monoid_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_on X (\\<lambda>x. \\<Sum>i\\<in>S x. f i x)\n    \\<subseteq> (\\<Union>x\\<in>X. \\<Union>i\\<in>S x. support_on X (f i))", "by (auto simp: support_on_def, meson sum.neutral)"], ["", "subsection \\<open>Final topology (Bourbaki, General Topology I, 4.)\\<close>"], ["", "definition \"final_topology X Y f =\n  topology (\\<lambda>U. U \\<subseteq> X \\<and>\n    (\\<forall>i. openin (Y i) (f i -` U \\<inter> topspace (Y i))))\""], ["", "lemma openin_final_topology:\n  \"openin (final_topology X Y f) =\n    (\\<lambda>U. U \\<subseteq> X \\<and> (\\<forall>i. openin (Y i) (f i -` U \\<inter> topspace (Y i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (final_topology X Y f) =\n    (\\<lambda>U.\n        U \\<subseteq> X \\<and>\n        (\\<forall>i. openin (Y i) (f i -` U \\<inter> topspace (Y i))))", "unfolding final_topology_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. openin\n     (topology\n       (\\<lambda>U.\n           U \\<subseteq> X \\<and>\n           (\\<forall>i. openin (Y i) (f i -` U \\<inter> topspace (Y i))))) =\n    (\\<lambda>U.\n        U \\<subseteq> X \\<and>\n        (\\<forall>i. openin (Y i) (f i -` U \\<inter> topspace (Y i))))", "apply (rule topology_inverse')"], ["proof (prove)\ngoal (1 subgoal):\n 1. istopology\n     (\\<lambda>U.\n         U \\<subseteq> X \\<and>\n         (\\<forall>i. openin (Y i) (f i -` U \\<inter> topspace (Y i))))", "unfolding istopology_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>S T.\n        S \\<subseteq> X \\<and>\n        (\\<forall>i.\n            openin (Y i)\n             (f i -` S \\<inter> topspace (Y i))) \\<longrightarrow>\n        T \\<subseteq> X \\<and>\n        (\\<forall>i.\n            openin (Y i)\n             (f i -` T \\<inter> topspace (Y i))) \\<longrightarrow>\n        S \\<inter> T \\<subseteq> X \\<and>\n        (\\<forall>i.\n            openin (Y i)\n             (f i -` (S \\<inter> T) \\<inter> topspace (Y i)))) \\<and>\n    (\\<forall>\\<K>.\n        (\\<forall>K\\<in>\\<K>.\n            K \\<subseteq> X \\<and>\n            (\\<forall>i.\n                openin (Y i)\n                 (f i -` K \\<inter> topspace (Y i)))) \\<longrightarrow>\n        \\<Union> \\<K> \\<subseteq> X \\<and>\n        (\\<forall>i.\n            openin (Y i) (f i -` \\<Union> \\<K> \\<inter> topspace (Y i))))", "proof safe"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>S T x.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i));\n        x \\<in> S; x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 2. \\<And>S T i.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i))\\<rbrakk>\n       \\<Longrightarrow> openin (Y i)\n                          (f i -` (S \\<inter> T) \\<inter> topspace (Y i))\n 3. \\<And>\\<K> x Xa.\n       \\<lbrakk>\\<forall>K\\<in>\\<K>.\n                   K \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` K \\<inter> topspace (Y i)));\n        x \\<in> Xa; Xa \\<in> \\<K>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 4. \\<And>\\<K> i.\n       \\<forall>K\\<in>\\<K>.\n          K \\<subseteq> X \\<and>\n          (\\<forall>i.\n              openin (Y i)\n               (f i -` K \\<inter> topspace (Y i))) \\<Longrightarrow>\n       openin (Y i) (f i -` \\<Union> \\<K> \\<inter> topspace (Y i))", "fix S T i"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>S T x.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i));\n        x \\<in> S; x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 2. \\<And>S T i.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i))\\<rbrakk>\n       \\<Longrightarrow> openin (Y i)\n                          (f i -` (S \\<inter> T) \\<inter> topspace (Y i))\n 3. \\<And>\\<K> x Xa.\n       \\<lbrakk>\\<forall>K\\<in>\\<K>.\n                   K \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` K \\<inter> topspace (Y i)));\n        x \\<in> Xa; Xa \\<in> \\<K>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 4. \\<And>\\<K> i.\n       \\<forall>K\\<in>\\<K>.\n          K \\<subseteq> X \\<and>\n          (\\<forall>i.\n              openin (Y i)\n               (f i -` K \\<inter> topspace (Y i))) \\<Longrightarrow>\n       openin (Y i) (f i -` \\<Union> \\<K> \\<inter> topspace (Y i))", "assume \"\\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i))\"\n    \"\\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i))\""], ["proof (state)\nthis:\n  \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i))\n  \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i))\n\ngoal (4 subgoals):\n 1. \\<And>S T x.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i));\n        x \\<in> S; x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 2. \\<And>S T i.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i))\\<rbrakk>\n       \\<Longrightarrow> openin (Y i)\n                          (f i -` (S \\<inter> T) \\<inter> topspace (Y i))\n 3. \\<And>\\<K> x Xa.\n       \\<lbrakk>\\<forall>K\\<in>\\<K>.\n                   K \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` K \\<inter> topspace (Y i)));\n        x \\<in> Xa; Xa \\<in> \\<K>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 4. \\<And>\\<K> i.\n       \\<forall>K\\<in>\\<K>.\n          K \\<subseteq> X \\<and>\n          (\\<forall>i.\n              openin (Y i)\n               (f i -` K \\<inter> topspace (Y i))) \\<Longrightarrow>\n       openin (Y i) (f i -` \\<Union> \\<K> \\<inter> topspace (Y i))", "then"], ["proof (chain)\npicking this:\n  \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i))\n  \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i))", "have \"openin (Y i) (f i -` S \\<inter> topspace (Y i) \\<inter> (f i -` T \\<inter> topspace (Y i)))\"\n    (is \"openin _ ?I\")"], ["proof (prove)\nusing this:\n  \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i))\n  \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i))\n\ngoal (1 subgoal):\n 1. openin (Y i)\n     (f i -` S \\<inter> topspace (Y i) \\<inter>\n      (f i -` T \\<inter> topspace (Y i)))", "by auto"], ["proof (state)\nthis:\n  openin (Y i)\n   (f i -` S \\<inter> topspace (Y i) \\<inter>\n    (f i -` T \\<inter> topspace (Y i)))\n\ngoal (4 subgoals):\n 1. \\<And>S T x.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i));\n        x \\<in> S; x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 2. \\<And>S T i.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i))\\<rbrakk>\n       \\<Longrightarrow> openin (Y i)\n                          (f i -` (S \\<inter> T) \\<inter> topspace (Y i))\n 3. \\<And>\\<K> x Xa.\n       \\<lbrakk>\\<forall>K\\<in>\\<K>.\n                   K \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` K \\<inter> topspace (Y i)));\n        x \\<in> Xa; Xa \\<in> \\<K>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 4. \\<And>\\<K> i.\n       \\<forall>K\\<in>\\<K>.\n          K \\<subseteq> X \\<and>\n          (\\<forall>i.\n              openin (Y i)\n               (f i -` K \\<inter> topspace (Y i))) \\<Longrightarrow>\n       openin (Y i) (f i -` \\<Union> \\<K> \\<inter> topspace (Y i))", "also"], ["proof (state)\nthis:\n  openin (Y i)\n   (f i -` S \\<inter> topspace (Y i) \\<inter>\n    (f i -` T \\<inter> topspace (Y i)))\n\ngoal (4 subgoals):\n 1. \\<And>S T x.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i));\n        x \\<in> S; x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 2. \\<And>S T i.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i))\\<rbrakk>\n       \\<Longrightarrow> openin (Y i)\n                          (f i -` (S \\<inter> T) \\<inter> topspace (Y i))\n 3. \\<And>\\<K> x Xa.\n       \\<lbrakk>\\<forall>K\\<in>\\<K>.\n                   K \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` K \\<inter> topspace (Y i)));\n        x \\<in> Xa; Xa \\<in> \\<K>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 4. \\<And>\\<K> i.\n       \\<forall>K\\<in>\\<K>.\n          K \\<subseteq> X \\<and>\n          (\\<forall>i.\n              openin (Y i)\n               (f i -` K \\<inter> topspace (Y i))) \\<Longrightarrow>\n       openin (Y i) (f i -` \\<Union> \\<K> \\<inter> topspace (Y i))", "have \"?I = f i -` (S \\<inter> T) \\<inter> topspace (Y i)\"\n    (is \"_ = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. f i -` S \\<inter> topspace (Y i) \\<inter>\n    (f i -` T \\<inter> topspace (Y i)) =\n    f i -` (S \\<inter> T) \\<inter> topspace (Y i)", "by auto"], ["proof (state)\nthis:\n  f i -` S \\<inter> topspace (Y i) \\<inter>\n  (f i -` T \\<inter> topspace (Y i)) =\n  f i -` (S \\<inter> T) \\<inter> topspace (Y i)\n\ngoal (4 subgoals):\n 1. \\<And>S T x.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i));\n        x \\<in> S; x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 2. \\<And>S T i.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i))\\<rbrakk>\n       \\<Longrightarrow> openin (Y i)\n                          (f i -` (S \\<inter> T) \\<inter> topspace (Y i))\n 3. \\<And>\\<K> x Xa.\n       \\<lbrakk>\\<forall>K\\<in>\\<K>.\n                   K \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` K \\<inter> topspace (Y i)));\n        x \\<in> Xa; Xa \\<in> \\<K>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 4. \\<And>\\<K> i.\n       \\<forall>K\\<in>\\<K>.\n          K \\<subseteq> X \\<and>\n          (\\<forall>i.\n              openin (Y i)\n               (f i -` K \\<inter> topspace (Y i))) \\<Longrightarrow>\n       openin (Y i) (f i -` \\<Union> \\<K> \\<inter> topspace (Y i))", "finally"], ["proof (chain)\npicking this:\n  openin (Y i) (f i -` (S \\<inter> T) \\<inter> topspace (Y i))", "show \"openin (Y i) ?R\""], ["proof (prove)\nusing this:\n  openin (Y i) (f i -` (S \\<inter> T) \\<inter> topspace (Y i))\n\ngoal (1 subgoal):\n 1. openin (Y i) (f i -` (S \\<inter> T) \\<inter> topspace (Y i))", "."], ["proof (state)\nthis:\n  openin (Y i) (f i -` (S \\<inter> T) \\<inter> topspace (Y i))\n\ngoal (3 subgoals):\n 1. \\<And>S T x.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i));\n        x \\<in> S; x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 2. \\<And>\\<K> x Xa.\n       \\<lbrakk>\\<forall>K\\<in>\\<K>.\n                   K \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` K \\<inter> topspace (Y i)));\n        x \\<in> Xa; Xa \\<in> \\<K>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 3. \\<And>\\<K> i.\n       \\<forall>K\\<in>\\<K>.\n          K \\<subseteq> X \\<and>\n          (\\<forall>i.\n              openin (Y i)\n               (f i -` K \\<inter> topspace (Y i))) \\<Longrightarrow>\n       openin (Y i) (f i -` \\<Union> \\<K> \\<inter> topspace (Y i))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S T x.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i));\n        x \\<in> S; x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 2. \\<And>\\<K> x Xa.\n       \\<lbrakk>\\<forall>K\\<in>\\<K>.\n                   K \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` K \\<inter> topspace (Y i)));\n        x \\<in> Xa; Xa \\<in> \\<K>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 3. \\<And>\\<K> i.\n       \\<forall>K\\<in>\\<K>.\n          K \\<subseteq> X \\<and>\n          (\\<forall>i.\n              openin (Y i)\n               (f i -` K \\<inter> topspace (Y i))) \\<Longrightarrow>\n       openin (Y i) (f i -` \\<Union> \\<K> \\<inter> topspace (Y i))", "fix K i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S T x.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i));\n        x \\<in> S; x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 2. \\<And>\\<K> x Xa.\n       \\<lbrakk>\\<forall>K\\<in>\\<K>.\n                   K \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` K \\<inter> topspace (Y i)));\n        x \\<in> Xa; Xa \\<in> \\<K>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 3. \\<And>\\<K> i.\n       \\<forall>K\\<in>\\<K>.\n          K \\<subseteq> X \\<and>\n          (\\<forall>i.\n              openin (Y i)\n               (f i -` K \\<inter> topspace (Y i))) \\<Longrightarrow>\n       openin (Y i) (f i -` \\<Union> \\<K> \\<inter> topspace (Y i))", "assume \"\\<forall>U\\<in>K. U \\<subseteq> X \\<and> (\\<forall>i. openin (Y i) (f i -` U \\<inter> topspace (Y i)))\""], ["proof (state)\nthis:\n  \\<forall>U\\<in>K.\n     U \\<subseteq> X \\<and>\n     (\\<forall>i. openin (Y i) (f i -` U \\<inter> topspace (Y i)))\n\ngoal (3 subgoals):\n 1. \\<And>S T x.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i));\n        x \\<in> S; x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 2. \\<And>\\<K> x Xa.\n       \\<lbrakk>\\<forall>K\\<in>\\<K>.\n                   K \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` K \\<inter> topspace (Y i)));\n        x \\<in> Xa; Xa \\<in> \\<K>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 3. \\<And>\\<K> i.\n       \\<forall>K\\<in>\\<K>.\n          K \\<subseteq> X \\<and>\n          (\\<forall>i.\n              openin (Y i)\n               (f i -` K \\<inter> topspace (Y i))) \\<Longrightarrow>\n       openin (Y i) (f i -` \\<Union> \\<K> \\<inter> topspace (Y i))", "then"], ["proof (chain)\npicking this:\n  \\<forall>U\\<in>K.\n     U \\<subseteq> X \\<and>\n     (\\<forall>i. openin (Y i) (f i -` U \\<inter> topspace (Y i)))", "have \"openin (Y i) (\\<Union>X\\<in>K. f i -` X \\<inter> topspace (Y i))\""], ["proof (prove)\nusing this:\n  \\<forall>U\\<in>K.\n     U \\<subseteq> X \\<and>\n     (\\<forall>i. openin (Y i) (f i -` U \\<inter> topspace (Y i)))\n\ngoal (1 subgoal):\n 1. openin (Y i) (\\<Union>X\\<in>K. f i -` X \\<inter> topspace (Y i))", "by (intro openin_Union) auto"], ["proof (state)\nthis:\n  openin (Y i) (\\<Union>X\\<in>K. f i -` X \\<inter> topspace (Y i))\n\ngoal (3 subgoals):\n 1. \\<And>S T x.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i));\n        x \\<in> S; x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 2. \\<And>\\<K> x Xa.\n       \\<lbrakk>\\<forall>K\\<in>\\<K>.\n                   K \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` K \\<inter> topspace (Y i)));\n        x \\<in> Xa; Xa \\<in> \\<K>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 3. \\<And>\\<K> i.\n       \\<forall>K\\<in>\\<K>.\n          K \\<subseteq> X \\<and>\n          (\\<forall>i.\n              openin (Y i)\n               (f i -` K \\<inter> topspace (Y i))) \\<Longrightarrow>\n       openin (Y i) (f i -` \\<Union> \\<K> \\<inter> topspace (Y i))", "then"], ["proof (chain)\npicking this:\n  openin (Y i) (\\<Union>X\\<in>K. f i -` X \\<inter> topspace (Y i))", "show \"openin (Y i) (f i -` \\<Union>K \\<inter> topspace (Y i))\""], ["proof (prove)\nusing this:\n  openin (Y i) (\\<Union>X\\<in>K. f i -` X \\<inter> topspace (Y i))\n\ngoal (1 subgoal):\n 1. openin (Y i) (f i -` \\<Union> K \\<inter> topspace (Y i))", "by (auto simp: vimage_Union)"], ["proof (state)\nthis:\n  openin (Y i) (f i -` \\<Union> K \\<inter> topspace (Y i))\n\ngoal (2 subgoals):\n 1. \\<And>S T x.\n       \\<lbrakk>S \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` S \\<inter> topspace (Y i));\n        T \\<subseteq> X;\n        \\<forall>i. openin (Y i) (f i -` T \\<inter> topspace (Y i));\n        x \\<in> S; x \\<in> T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X\n 2. \\<And>\\<K> x Xa.\n       \\<lbrakk>\\<forall>K\\<in>\\<K>.\n                   K \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` K \\<inter> topspace (Y i)));\n        x \\<in> Xa; Xa \\<in> \\<K>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X", "qed force+"], ["", "lemma topspace_final_topology:\n  \"topspace (final_topology X Y f) = X\"\n  if \"\\<And>i. f i \\<in> topspace (Y i) \\<rightarrow> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. topspace (final_topology X Y f) = X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. topspace (final_topology X Y f) = X", "have *: \"f i -` X \\<inter> topspace (Y i) = topspace (Y i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. f i -` X \\<inter> topspace (Y i) = topspace (Y i)", "using that"], ["proof (prove)\nusing this:\n  f ?i \\<in> topspace (Y ?i) \\<rightarrow> X\n\ngoal (1 subgoal):\n 1. f i -` X \\<inter> topspace (Y i) = topspace (Y i)", "by auto"], ["proof (state)\nthis:\n  f ?i -` X \\<inter> topspace (Y ?i) = topspace (Y ?i)\n\ngoal (1 subgoal):\n 1. topspace (final_topology X Y f) = X", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. topspace (final_topology X Y f) = X", "unfolding topspace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (Collect (openin (final_topology X Y f))) = X", "unfolding openin_final_topology"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     {U. U \\<subseteq> X \\<and>\n         (\\<forall>i. openin (Y i) (f i -` U \\<inter> topspace (Y i)))} =\n    X", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Union>\n     {U. U \\<subseteq> X \\<and>\n         (\\<forall>i. openin (Y i) (f i -` U \\<inter> topspace (Y i)))}\n    \\<subseteq> X\n 2. X \\<subseteq> \\<Union>\n                   {U. U \\<subseteq> X \\<and>\n                       (\\<forall>i.\n                           openin (Y i) (f i -` U \\<inter> topspace (Y i)))}", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> \\<Union>\n                   {U. U \\<subseteq> X \\<and>\n                       (\\<forall>i.\n                           openin (Y i) (f i -` U \\<inter> topspace (Y i)))}", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x \\<in> \\<Union>\n                {U. U \\<subseteq> X \\<and>\n                    (\\<forall>i.\n                        openin (Y i) (f i -` U \\<inter> topspace (Y i)))}", "apply (rule UnionI[where X=X])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       X \\<in> {U. U \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` U \\<inter> topspace (Y i)))}\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> X", "using that"], ["proof (prove)\nusing this:\n  f ?i \\<in> topspace (Y ?i) \\<rightarrow> X\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       X \\<in> {U. U \\<subseteq> X \\<and>\n                   (\\<forall>i.\n                       openin (Y i) (f i -` U \\<inter> topspace (Y i)))}\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> X", "by (auto simp: *)"], ["proof (state)\nthis:\n  topspace (final_topology X Y f) = X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_on_final_topologyI2:\n  \"continuous_map (Y i) (final_topology X Y f) (f i)\"\n  if \"\\<And>i. f i \\<in> topspace (Y i) \\<rightarrow> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map (Y i) (final_topology X Y f) (f i)", "using that"], ["proof (prove)\nusing this:\n  f ?i \\<in> topspace (Y ?i) \\<rightarrow> X\n\ngoal (1 subgoal):\n 1. continuous_map (Y i) (final_topology X Y f) (f i)", "by (auto simp: openin_final_topology continuous_map_alt topspace_final_topology)"], ["", "lemma continuous_on_final_topologyI1:\n  \"continuous_map (final_topology X Y f) Z g\"\n  if hyp: \"\\<And>i. continuous_map (Y i) Z (g o f i)\"\n    and that: \"\\<And>i. f i \\<in> topspace (Y i) \\<rightarrow> X\" \"g \\<in> X \\<rightarrow> topspace Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map (final_topology X Y f) Z g", "unfolding continuous_map_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>U.\n        openin Z U \\<longrightarrow>\n        openin (final_topology X Y f)\n         (g -` U \\<inter> topspace (final_topology X Y f))) \\<and>\n    g ` topspace (final_topology X Y f) \\<subseteq> topspace Z", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U.\n       openin Z U \\<Longrightarrow>\n       openin (final_topology X Y f)\n        (g -` U \\<inter> topspace (final_topology X Y f))\n 2. \\<And>x xa.\n       xa \\<in> topspace (final_topology X Y f) \\<Longrightarrow>\n       g xa \\<in> topspace Z", "fix V"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U.\n       openin Z U \\<Longrightarrow>\n       openin (final_topology X Y f)\n        (g -` U \\<inter> topspace (final_topology X Y f))\n 2. \\<And>x xa.\n       xa \\<in> topspace (final_topology X Y f) \\<Longrightarrow>\n       g xa \\<in> topspace Z", "assume V: \"openin Z V\""], ["proof (state)\nthis:\n  openin Z V\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       openin Z U \\<Longrightarrow>\n       openin (final_topology X Y f)\n        (g -` U \\<inter> topspace (final_topology X Y f))\n 2. \\<And>x xa.\n       xa \\<in> topspace (final_topology X Y f) \\<Longrightarrow>\n       g xa \\<in> topspace Z", "have oV: \"openin (Y i) (f i -` g -` V \\<inter> topspace (Y i))\"\n    for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (Y i) (f i -` g -` V \\<inter> topspace (Y i))", "using hyp[rule_format, of i] V"], ["proof (prove)\nusing this:\n  continuous_map (Y i) Z (g \\<circ> f i)\n  openin Z V\n\ngoal (1 subgoal):\n 1. openin (Y i) (f i -` g -` V \\<inter> topspace (Y i))", "by (auto simp: continuous_map_alt vimage_comp dest!: spec[where x=V])"], ["proof (state)\nthis:\n  openin (Y ?i) (f ?i -` g -` V \\<inter> topspace (Y ?i))\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       openin Z U \\<Longrightarrow>\n       openin (final_topology X Y f)\n        (g -` U \\<inter> topspace (final_topology X Y f))\n 2. \\<And>x xa.\n       xa \\<in> topspace (final_topology X Y f) \\<Longrightarrow>\n       g xa \\<in> topspace Z", "have *: \"f i -` g -` V \\<inter> f i -` X \\<inter> topspace (Y i) =\n      f i -` g -` V \\<inter> topspace (Y i)\"\n    (is \"_ = ?rhs i\")\n    for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. f i -` g -` V \\<inter> f i -` X \\<inter> topspace (Y i) =\n    f i -` g -` V \\<inter> topspace (Y i)", "using that"], ["proof (prove)\nusing this:\n  continuous_map (Y ?i) Z (g \\<circ> f ?i)\n  f ?i \\<in> topspace (Y ?i) \\<rightarrow> X\n  g \\<in> X \\<rightarrow> topspace Z\n\ngoal (1 subgoal):\n 1. f i -` g -` V \\<inter> f i -` X \\<inter> topspace (Y i) =\n    f i -` g -` V \\<inter> topspace (Y i)", "by auto"], ["proof (state)\nthis:\n  f ?i -` g -` V \\<inter> f ?i -` X \\<inter> topspace (Y ?i) =\n  f ?i -` g -` V \\<inter> topspace (Y ?i)\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       openin Z U \\<Longrightarrow>\n       openin (final_topology X Y f)\n        (g -` U \\<inter> topspace (final_topology X Y f))\n 2. \\<And>x xa.\n       xa \\<in> topspace (final_topology X Y f) \\<Longrightarrow>\n       g xa \\<in> topspace Z", "show \"openin (final_topology X Y f) (g -` V \\<inter> topspace (final_topology X Y f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (final_topology X Y f)\n     (g -` V \\<inter> topspace (final_topology X Y f))", "by (auto simp: openin_final_topology oV topspace_final_topology that *)"], ["proof (state)\nthis:\n  openin (final_topology X Y f)\n   (g -` V \\<inter> topspace (final_topology X Y f))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       xa \\<in> topspace (final_topology X Y f) \\<Longrightarrow>\n       g xa \\<in> topspace Z", "qed (use that in \\<open>auto simp: topspace_final_topology\\<close>)"], ["", "lemma continuous_on_final_topology_iff:\n  \"continuous_map (final_topology X Y f) Z g \\<longleftrightarrow> (\\<forall>i. continuous_map (Y i) Z (g o f i))\"\n  if \"\\<And>i. f i \\<in> topspace (Y i) \\<rightarrow> X\" \"g \\<in> X \\<rightarrow> topspace Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map (final_topology X Y f) Z g =\n    (\\<forall>i. continuous_map (Y i) Z (g \\<circ> f i))", "using that"], ["proof (prove)\nusing this:\n  f ?i \\<in> topspace (Y ?i) \\<rightarrow> X\n  g \\<in> X \\<rightarrow> topspace Z\n\ngoal (1 subgoal):\n 1. continuous_map (final_topology X Y f) Z g =\n    (\\<forall>i. continuous_map (Y i) Z (g \\<circ> f i))", "by (auto intro!: continuous_on_final_topologyI1[OF _ that]\n      intro: continuous_map_compose[OF continuous_on_final_topologyI2[OF that(1)]])"], ["", "subsection \\<open>Quotient topology\\<close>"], ["", "definition map_topology :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a topology \\<Rightarrow> 'b topology\" where\n  \"map_topology p X = final_topology (p ` topspace X) (\\<lambda>_. X) (\\<lambda>(_::unit). p)\""], ["", "lemma openin_map_topology:\n  \"openin (map_topology p X) = (\\<lambda>U. U \\<subseteq> p ` topspace X \\<and> openin X (p -` U \\<inter> topspace X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (map_topology p X) =\n    (\\<lambda>U.\n        U \\<subseteq> p ` topspace X \\<and>\n        openin X (p -` U \\<inter> topspace X))", "by (auto simp: map_topology_def openin_final_topology)"], ["", "lemma topspace_map_topology[simp]: \"topspace (map_topology f T) = f ` topspace T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. topspace (map_topology f T) = f ` topspace T", "unfolding map_topology_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. topspace\n     (final_topology (f ` topspace T) (\\<lambda>_. T) (\\<lambda>_. f)) =\n    f ` topspace T", "by (subst topspace_final_topology) auto"], ["", "lemma continuous_on_map_topology:\n  \"continuous_map T (map_topology f T) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map T (map_topology f T) f", "unfolding continuous_map_alt openin_map_topology"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>U.\n        U \\<subseteq> f ` topspace T \\<and>\n        openin T (f -` U \\<inter> topspace T) \\<longrightarrow>\n        openin T (f -` U \\<inter> topspace T)) \\<and>\n    f ` topspace T \\<subseteq> topspace (map_topology f T)", "by auto"], ["", "lemma continuous_map_composeD:\n  \"continuous_map T X (g \\<circ> f) \\<Longrightarrow> g \\<in> f ` topspace T \\<rightarrow> topspace X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map T X (g \\<circ> f) \\<Longrightarrow>\n    g \\<in> f ` topspace T \\<rightarrow> topspace X", "by (auto simp: continuous_map_def)"], ["", "lemma continuous_on_map_topology2:\n  \"continuous_map T X (g \\<circ> f) \\<longleftrightarrow> continuous_map (map_topology f T) X g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map T X (g \\<circ> f) = continuous_map (map_topology f T) X g", "unfolding map_topology_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map T X (g \\<circ> f) =\n    continuous_map\n     (final_topology (f ` topspace T) (\\<lambda>_. T) (\\<lambda>_. f)) X g", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_map T X (g \\<circ> f) \\<Longrightarrow>\n    continuous_map\n     (final_topology (f ` topspace T) (\\<lambda>_. T) (\\<lambda>_. f)) X g\n 2. continuous_map\n     (final_topology (f ` topspace T) (\\<lambda>_. T) (\\<lambda>_. f)) X\n     g \\<Longrightarrow>\n    continuous_map T X (g \\<circ> f)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map T X (g \\<circ> f) \\<Longrightarrow>\n    continuous_map\n     (final_topology (f ` topspace T) (\\<lambda>_. T) (\\<lambda>_. f)) X g", "apply (rule continuous_on_final_topologyI1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       continuous_map T X (g \\<circ> f) \\<Longrightarrow>\n       continuous_map T X (g \\<circ> f)\n 2. \\<And>i.\n       continuous_map T X (g \\<circ> f) \\<Longrightarrow>\n       f \\<in> topspace T \\<rightarrow> f ` topspace T\n 3. continuous_map T X (g \\<circ> f) \\<Longrightarrow>\n    g \\<in> f ` topspace T \\<rightarrow> topspace X", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map T X (g \\<circ> f) \\<Longrightarrow>\n    continuous_map T X (g \\<circ> f)", "by assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       continuous_map T X (g \\<circ> f) \\<Longrightarrow>\n       f \\<in> topspace T \\<rightarrow> f ` topspace T\n 2. continuous_map T X (g \\<circ> f) \\<Longrightarrow>\n    g \\<in> f ` topspace T \\<rightarrow> topspace X", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map T X (g \\<circ> f) \\<Longrightarrow>\n    f \\<in> topspace T \\<rightarrow> f ` topspace T", "by force"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map T X (g \\<circ> f) \\<Longrightarrow>\n    g \\<in> f ` topspace T \\<rightarrow> topspace X", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map T X (g \\<circ> f) \\<Longrightarrow>\n    g \\<in> f ` topspace T \\<rightarrow> topspace X", "by (rule continuous_map_composeD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map\n     (final_topology (f ` topspace T) (\\<lambda>_. T) (\\<lambda>_. f)) X\n     g \\<Longrightarrow>\n    continuous_map T X (g \\<circ> f)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map\n     (final_topology (f ` topspace T) (\\<lambda>_. T) (\\<lambda>_. f)) X\n     g \\<Longrightarrow>\n    continuous_map T X (g \\<circ> f)", "apply (erule continuous_map_compose[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map T\n     (final_topology (f ` topspace T) (\\<lambda>_. T) (\\<lambda>_. f)) f", "apply (rule continuous_on_final_topologyI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. f \\<in> topspace T \\<rightarrow> f ` topspace T", "by force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_sub_finer_than_commute:\n  \"map_topology f (subtopology T (f -` X)) finer_than subtopology (map_topology f T) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_topology f (subtopology T (f -` X)) finer_than\n    subtopology (map_topology f T) X", "by (auto simp: finer_than_def continuous_map_def openin_subtopology openin_map_topology\n      topspace_subtopology)"], ["", "lemma sub_map_finer_than_commute:\n  \"subtopology (map_topology f T) X finer_than map_topology f (subtopology T (f -` X))\"\n  if \"openin T (f -` X)\"\\<comment> \\<open>this is more or less the condition from\n    \\<^url>\\<open>https://math.stackexchange.com/questions/705840/quotient-topology-vs-subspace-topology\\<close>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subtopology (map_topology f T) X finer_than\n    map_topology f (subtopology T (f -` X))", "unfolding finer_than_def continuous_map_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>U.\n        openin (map_topology f (subtopology T (f -` X))) U \\<longrightarrow>\n        openin (subtopology (map_topology f T) X)\n         ((\\<lambda>x. x) -` U \\<inter>\n          topspace (subtopology (map_topology f T) X))) \\<and>\n    (\\<lambda>x. x) ` topspace (subtopology (map_topology f T) X)\n    \\<subseteq> topspace (map_topology f (subtopology T (f -` X)))", "proof (rule conjI, clarsimp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U.\n       openin (map_topology f (subtopology T (f -` X))) U \\<Longrightarrow>\n       openin (subtopology (map_topology f T) X)\n        (U \\<inter> (f ` topspace T \\<inter> X))\n 2. (\\<lambda>x. x) ` topspace (subtopology (map_topology f T) X)\n    \\<subseteq> topspace (map_topology f (subtopology T (f -` X)))", "fix U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U.\n       openin (map_topology f (subtopology T (f -` X))) U \\<Longrightarrow>\n       openin (subtopology (map_topology f T) X)\n        (U \\<inter> (f ` topspace T \\<inter> X))\n 2. (\\<lambda>x. x) ` topspace (subtopology (map_topology f T) X)\n    \\<subseteq> topspace (map_topology f (subtopology T (f -` X)))", "assume \"openin (map_topology f (subtopology T (f -` X))) U\""], ["proof (state)\nthis:\n  openin (map_topology f (subtopology T (f -` X))) U\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       openin (map_topology f (subtopology T (f -` X))) U \\<Longrightarrow>\n       openin (subtopology (map_topology f T) X)\n        (U \\<inter> (f ` topspace T \\<inter> X))\n 2. (\\<lambda>x. x) ` topspace (subtopology (map_topology f T) X)\n    \\<subseteq> topspace (map_topology f (subtopology T (f -` X)))", "then"], ["proof (chain)\npicking this:\n  openin (map_topology f (subtopology T (f -` X))) U", "obtain W where W: \"U \\<subseteq> f ` (topspace T \\<inter> f -` X)\" \"openin T W\" \"f -` U \\<inter> (topspace T \\<inter> f -` X) = W \\<inter> f -` X\""], ["proof (prove)\nusing this:\n  openin (map_topology f (subtopology T (f -` X))) U\n\ngoal (1 subgoal):\n 1. (\\<And>W.\n        \\<lbrakk>U \\<subseteq> f ` (topspace T \\<inter> f -` X); openin T W;\n         f -` U \\<inter> (topspace T \\<inter> f -` X) =\n         W \\<inter> f -` X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: topspace_subtopology openin_subtopology openin_map_topology)"], ["proof (state)\nthis:\n  U \\<subseteq> f ` (topspace T \\<inter> f -` X)\n  openin T W\n  f -` U \\<inter> (topspace T \\<inter> f -` X) = W \\<inter> f -` X\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       openin (map_topology f (subtopology T (f -` X))) U \\<Longrightarrow>\n       openin (subtopology (map_topology f T) X)\n        (U \\<inter> (f ` topspace T \\<inter> X))\n 2. (\\<lambda>x. x) ` topspace (subtopology (map_topology f T) X)\n    \\<subseteq> topspace (map_topology f (subtopology T (f -` X)))", "have \"(f -` f ` W \\<inter> f -` X) \\<inter> topspace T = W \\<inter> topspace T \\<inter> f -` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f -` f ` W \\<inter> f -` X \\<inter> topspace T =\n    W \\<inter> topspace T \\<inter> f -` X", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xc.\n       \\<lbrakk>x \\<in> topspace T; f xc \\<in> X; f x = f xc;\n        xc \\<in> W\\<rbrakk>\n       \\<Longrightarrow> x \\<in> W", "by (metis Int_iff W(3) vimage_eq)"], ["proof (state)\nthis:\n  f -` f ` W \\<inter> f -` X \\<inter> topspace T =\n  W \\<inter> topspace T \\<inter> f -` X\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       openin (map_topology f (subtopology T (f -` X))) U \\<Longrightarrow>\n       openin (subtopology (map_topology f T) X)\n        (U \\<inter> (f ` topspace T \\<inter> X))\n 2. (\\<lambda>x. x) ` topspace (subtopology (map_topology f T) X)\n    \\<subseteq> topspace (map_topology f (subtopology T (f -` X)))", "also"], ["proof (state)\nthis:\n  f -` f ` W \\<inter> f -` X \\<inter> topspace T =\n  W \\<inter> topspace T \\<inter> f -` X\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       openin (map_topology f (subtopology T (f -` X))) U \\<Longrightarrow>\n       openin (subtopology (map_topology f T) X)\n        (U \\<inter> (f ` topspace T \\<inter> X))\n 2. (\\<lambda>x. x) ` topspace (subtopology (map_topology f T) X)\n    \\<subseteq> topspace (map_topology f (subtopology T (f -` X)))", "have \"openin T \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. openin T (W \\<inter> topspace T \\<inter> f -` X)", "by (auto intro!: W that)"], ["proof (state)\nthis:\n  openin T (W \\<inter> topspace T \\<inter> f -` X)\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       openin (map_topology f (subtopology T (f -` X))) U \\<Longrightarrow>\n       openin (subtopology (map_topology f T) X)\n        (U \\<inter> (f ` topspace T \\<inter> X))\n 2. (\\<lambda>x. x) ` topspace (subtopology (map_topology f T) X)\n    \\<subseteq> topspace (map_topology f (subtopology T (f -` X)))", "finally"], ["proof (chain)\npicking this:\n  openin T (f -` f ` W \\<inter> f -` X \\<inter> topspace T)", "show \"openin (subtopology (map_topology f T) X) (U \\<inter> (f ` topspace T \\<inter> X))\""], ["proof (prove)\nusing this:\n  openin T (f -` f ` W \\<inter> f -` X \\<inter> topspace T)\n\ngoal (1 subgoal):\n 1. openin (subtopology (map_topology f T) X)\n     (U \\<inter> (f ` topspace T \\<inter> X))", "using W"], ["proof (prove)\nusing this:\n  openin T (f -` f ` W \\<inter> f -` X \\<inter> topspace T)\n  U \\<subseteq> f ` (topspace T \\<inter> f -` X)\n  openin T W\n  f -` U \\<inter> (topspace T \\<inter> f -` X) = W \\<inter> f -` X\n\ngoal (1 subgoal):\n 1. openin (subtopology (map_topology f T) X)\n     (U \\<inter> (f ` topspace T \\<inter> X))", "unfolding topspace_subtopology topspace_map_topology openin_subtopology openin_map_topology"], ["proof (prove)\nusing this:\n  openin T (f -` f ` W \\<inter> f -` X \\<inter> topspace T)\n  U \\<subseteq> f ` (topspace T \\<inter> f -` X)\n  openin T W\n  f -` U \\<inter> (topspace T \\<inter> f -` X) = W \\<inter> f -` X\n\ngoal (1 subgoal):\n 1. \\<exists>Ta.\n       (Ta \\<subseteq> f ` topspace T \\<and>\n        openin T (f -` Ta \\<inter> topspace T)) \\<and>\n       U \\<inter> (f ` topspace T \\<inter> X) = Ta \\<inter> X", "by (intro exI[where x=\"(f ` W \\<inter> X)\"]) auto"], ["proof (state)\nthis:\n  openin (subtopology (map_topology f T) X)\n   (U \\<inter> (f ` topspace T \\<inter> X))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. x) ` topspace (subtopology (map_topology f T) X)\n    \\<subseteq> topspace (map_topology f (subtopology T (f -` X)))", "qed auto"], ["", "lemma subtopology_map_topology:\n  \"subtopology (map_topology f T) X = map_topology f (subtopology T (f -` X))\"\n  if \"openin T (f -` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtopology (map_topology f T) X =\n    map_topology f (subtopology T (f -` X))", "apply (rule antisym_finer_than)"], ["proof (prove)\ngoal (2 subgoals):\n 1. subtopology (map_topology f T) X finer_than\n    map_topology f (subtopology T (f -` X))\n 2. map_topology f (subtopology T (f -` X)) finer_than\n    subtopology (map_topology f T) X", "using sub_map_finer_than_commute[OF that] map_sub_finer_than_commute[of f T X]"], ["proof (prove)\nusing this:\n  subtopology (map_topology f T) X finer_than\n  map_topology f (subtopology T (f -` X))\n  map_topology f (subtopology T (f -` X)) finer_than\n  subtopology (map_topology f T) X\n\ngoal (2 subgoals):\n 1. subtopology (map_topology f T) X finer_than\n    map_topology f (subtopology T (f -` X))\n 2. map_topology f (subtopology T (f -` X)) finer_than\n    subtopology (map_topology f T) X", "by auto"], ["", "lemma quotient_map_map_topology:\n  \"quotient_map X (map_topology f X) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quotient_map X (map_topology f X) f", "by (auto simp: quotient_map_def openin_map_topology ac_simps)\n    (simp_all add: vimage_def Int_def)"], ["", "lemma topological_space_quotient: \"class.topological_space (openin (map_topology f euclidean))\"\n  if \"surj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.topological_space (openin (map_topology f euclidean))", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. openin (map_topology f euclidean) UNIV\n 2. \\<And>S T.\n       \\<lbrakk>openin (map_topology f euclidean) S;\n        openin (map_topology f euclidean) T\\<rbrakk>\n       \\<Longrightarrow> openin (map_topology f euclidean) (S \\<inter> T)\n 3. \\<And>K.\n       \\<forall>S\\<in>K.\n          openin (map_topology f euclidean) S \\<Longrightarrow>\n       openin (map_topology f euclidean) (\\<Union> K)", "apply (auto simp: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (map_topology f euclidean) UNIV", "using that"], ["proof (prove)\nusing this:\n  surj f\n\ngoal (1 subgoal):\n 1. openin (map_topology f euclidean) UNIV", "by (auto simp: openin_map_topology)"], ["", "lemma t2_space_quotient: \"class.t2_space (open::'b set \\<Rightarrow> bool)\"\n  if open_def: \"open = (openin (map_topology (p::'a::t2_space\\<Rightarrow>'b::topological_space) euclidean))\"\n    \"surj p\" and open_p: \"\\<And>X. open X \\<Longrightarrow> open (p ` X)\" and \"closed {(x, y). p x = p y}\" (is \"closed ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.t2_space open", "apply (rule class.t2_space.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.topological_space open\n 2. class.t2_space_axioms open", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.topological_space open", "by (unfold open_def, rule topological_space_quotient; fact)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.t2_space_axioms open", "proof standard"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "fix a b::'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "obtain x y where a_def: \"a = p x\" and b_def: \"b = p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>a = p x; b = p y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>surj p\\<close>"], ["proof (prove)\nusing this:\n  surj p\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>a = p x; b = p y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = p x\n  b = p y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "assume \"a \\<noteq> b\""], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "with \\<open>closed ?R\\<close>"], ["proof (chain)\npicking this:\n  closed {(x, y). p x = p y}\n  a \\<noteq> b", "have \"open (-?R)\" \"(x, y) \\<in> -?R\""], ["proof (prove)\nusing this:\n  closed {(x, y). p x = p y}\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. open (- {(x, y). p x = p y}) &&& (x, y) \\<in> - {(x, y). p x = p y}", "by (auto simp add: a_def b_def)"], ["proof (state)\nthis:\n  open (- {(x, y). p x = p y})\n  (x, y) \\<in> - {(x, y). p x = p y}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "from open_prod_elim[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>A B.\n      \\<lbrakk>open A; open B; (x, y) \\<in> A \\<times> B;\n       A \\<times> B \\<subseteq> - {(x, y). p x = p y}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain N\\<^sub>x N\\<^sub>y where \"open N\\<^sub>x\" \"open N\\<^sub>y\" \"(x, y) \\<in> N\\<^sub>x \\<times> N\\<^sub>y\" \"N\\<^sub>x \\<times> N\\<^sub>y \\<subseteq> -?R\""], ["proof (prove)\nusing this:\n  (\\<And>A B.\n      \\<lbrakk>open A; open B; (x, y) \\<in> A \\<times> B;\n       A \\<times> B \\<subseteq> - {(x, y). p x = p y}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>N\\<^sub>x N\\<^sub>y.\n        \\<lbrakk>open N\\<^sub>x; open N\\<^sub>y;\n         (x, y) \\<in> N\\<^sub>x \\<times> N\\<^sub>y;\n         N\\<^sub>x \\<times> N\\<^sub>y\n         \\<subseteq> - {(x, y). p x = p y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  open N\\<^sub>x\n  open N\\<^sub>y\n  (x, y) \\<in> N\\<^sub>x \\<times> N\\<^sub>y\n  N\\<^sub>x \\<times> N\\<^sub>y \\<subseteq> - {(x, y). p x = p y}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "then"], ["proof (chain)\npicking this:\n  open N\\<^sub>x\n  open N\\<^sub>y\n  (x, y) \\<in> N\\<^sub>x \\<times> N\\<^sub>y\n  N\\<^sub>x \\<times> N\\<^sub>y \\<subseteq> - {(x, y). p x = p y}", "have \"p ` N\\<^sub>x \\<inter> p ` N\\<^sub>y = {}\""], ["proof (prove)\nusing this:\n  open N\\<^sub>x\n  open N\\<^sub>y\n  (x, y) \\<in> N\\<^sub>x \\<times> N\\<^sub>y\n  N\\<^sub>x \\<times> N\\<^sub>y \\<subseteq> - {(x, y). p x = p y}\n\ngoal (1 subgoal):\n 1. p ` N\\<^sub>x \\<inter> p ` N\\<^sub>y = {}", "by auto"], ["proof (state)\nthis:\n  p ` N\\<^sub>x \\<inter> p ` N\\<^sub>y = {}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "moreover"], ["proof (state)\nthis:\n  p ` N\\<^sub>x \\<inter> p ` N\\<^sub>y = {}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "from \\<open>open N\\<^sub>x\\<close> \\<open>open N\\<^sub>y\\<close>"], ["proof (chain)\npicking this:\n  open N\\<^sub>x\n  open N\\<^sub>y", "have \"open (p ` N\\<^sub>x)\" \"open (p ` N\\<^sub>y)\""], ["proof (prove)\nusing this:\n  open N\\<^sub>x\n  open N\\<^sub>y\n\ngoal (1 subgoal):\n 1. open (p ` N\\<^sub>x) &&& open (p ` N\\<^sub>y)", "using open_p"], ["proof (prove)\nusing this:\n  open N\\<^sub>x\n  open N\\<^sub>y\n  open ?X \\<Longrightarrow> open (p ` ?X)\n\ngoal (1 subgoal):\n 1. open (p ` N\\<^sub>x) &&& open (p ` N\\<^sub>y)", "by blast+"], ["proof (state)\nthis:\n  open (p ` N\\<^sub>x)\n  open (p ` N\\<^sub>y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "moreover"], ["proof (state)\nthis:\n  open (p ` N\\<^sub>x)\n  open (p ` N\\<^sub>y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "have \"a \\<in> p ` N\\<^sub>x\" \"b \\<in> p ` N\\<^sub>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> p ` N\\<^sub>x &&& b \\<in> p ` N\\<^sub>y", "using \\<open>(x, y) \\<in> _ \\<times> _\\<close>"], ["proof (prove)\nusing this:\n  (x, y) \\<in> N\\<^sub>x \\<times> N\\<^sub>y\n\ngoal (1 subgoal):\n 1. a \\<in> p ` N\\<^sub>x &&& b \\<in> p ` N\\<^sub>y", "by (auto simp: a_def b_def)"], ["proof (state)\nthis:\n  a \\<in> p ` N\\<^sub>x\n  b \\<in> p ` N\\<^sub>y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "ultimately"], ["proof (chain)\npicking this:\n  p ` N\\<^sub>x \\<inter> p ` N\\<^sub>y = {}\n  open (p ` N\\<^sub>x)\n  open (p ` N\\<^sub>y)\n  a \\<in> p ` N\\<^sub>x\n  b \\<in> p ` N\\<^sub>y", "show \"\\<exists>U V. open U \\<and> open V \\<and> a \\<in> U \\<and> b \\<in> V \\<and> U \\<inter> V = {}\""], ["proof (prove)\nusing this:\n  p ` N\\<^sub>x \\<inter> p ` N\\<^sub>y = {}\n  open (p ` N\\<^sub>x)\n  open (p ` N\\<^sub>y)\n  a \\<in> p ` N\\<^sub>x\n  b \\<in> p ` N\\<^sub>y\n\ngoal (1 subgoal):\n 1. \\<exists>U V.\n       open U \\<and>\n       open V \\<and> a \\<in> U \\<and> b \\<in> V \\<and> U \\<inter> V = {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>U V.\n     open U \\<and>\n     open V \\<and> a \\<in> U \\<and> b \\<in> V \\<and> U \\<inter> V = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma second_countable_topology_quotient: \"class.second_countable_topology (open::'b set \\<Rightarrow> bool)\"\n  if open_def: \"open = (openin (map_topology (p::'a::second_countable_topology\\<Rightarrow>'b::topological_space) euclidean))\"\n    \"surj p\" and open_p: \"\\<And>X. open X \\<Longrightarrow> open (p ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.second_countable_topology open", "apply (rule class.second_countable_topology.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. class.topological_space open\n 2. class.second_countable_topology_axioms open", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.topological_space open", "by (unfold open_def, rule topological_space_quotient; fact)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.second_countable_topology_axioms open", "proof standard"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "have euclidean_def: \"euclidean = map_topology p euclidean\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean = map_topology p euclidean", "by (simp add: openin_inverse open_def)"], ["proof (state)\nthis:\n  euclidean = map_topology p euclidean\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "have continuous_on: \"continuous_on UNIV p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV p", "using continuous_map_iff_continuous2 continuous_on_map_topology euclidean_def"], ["proof (prove)\nusing this:\n  continuous_map euclidean euclidean ?g = continuous_on UNIV ?g\n  continuous_map ?T (map_topology ?f ?T) ?f\n  euclidean = map_topology p euclidean\n\ngoal (1 subgoal):\n 1. continuous_on UNIV p", "by fastforce"], ["proof (state)\nthis:\n  continuous_on UNIV p\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "from ex_countable_basis[where 'a='a]"], ["proof (chain)\npicking this:\n  \\<exists>B. countable B \\<and> topological_basis B", "obtain A::\"'a set set\" where \"countable A\" \"topological_basis A\""], ["proof (prove)\nusing this:\n  \\<exists>B. countable B \\<and> topological_basis B\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>countable A; topological_basis A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  countable A\n  topological_basis A\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "define B where \"B = (\\<lambda>X. p ` X) ` A\""], ["proof (state)\nthis:\n  B = (`) p ` A\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "have \"countable (B::'b set set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable B", "by (auto simp: B_def intro!: \\<open>countable A\\<close>)"], ["proof (state)\nthis:\n  countable B\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "moreover"], ["proof (state)\nthis:\n  countable B\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "have \"topological_basis B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. topological_basis B", "proof (rule topological_basisI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B'. B' \\<in> B \\<Longrightarrow> open B'\n 2. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "fix B'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B'. B' \\<in> B \\<Longrightarrow> open B'\n 2. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "assume \"B' \\<in> B\""], ["proof (state)\nthis:\n  B' \\<in> B\n\ngoal (2 subgoals):\n 1. \\<And>B'. B' \\<in> B \\<Longrightarrow> open B'\n 2. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "then"], ["proof (chain)\npicking this:\n  B' \\<in> B", "show \"open B'\""], ["proof (prove)\nusing this:\n  B' \\<in> B\n\ngoal (1 subgoal):\n 1. open B'", "using \\<open>topological_basis A\\<close>"], ["proof (prove)\nusing this:\n  B' \\<in> B\n  topological_basis A\n\ngoal (1 subgoal):\n 1. open B'", "by (auto simp: B_def topological_basis_open intro!: open_p)"], ["proof (state)\nthis:\n  open B'\n\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "fix x::'b and O'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "assume \"open O'\" \"x \\<in> O'\""], ["proof (state)\nthis:\n  open O'\n  x \\<in> O'\n\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "have \"open (p -` O')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (p -` O')", "using \\<open>open O'\\<close>"], ["proof (prove)\nusing this:\n  open O'\n\ngoal (1 subgoal):\n 1. open (p -` O')", "by (rule open_vimage) (auto simp: continuous_on)"], ["proof (state)\nthis:\n  open (p -` O')\n\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "obtain y where y: \"y \\<in> p -` {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> p -` {x} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>x \\<in> O'\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> O'\n\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> p -` {x} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto (metis UNIV_I open_def(2) rangeE)"], ["proof (state)\nthis:\n  y \\<in> p -` {x}\n\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "then"], ["proof (chain)\npicking this:\n  y \\<in> p -` {x}", "have \"y \\<in> p -` O'\""], ["proof (prove)\nusing this:\n  y \\<in> p -` {x}\n\ngoal (1 subgoal):\n 1. y \\<in> p -` O'", "using \\<open>x \\<in> O'\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> p -` {x}\n  x \\<in> O'\n\ngoal (1 subgoal):\n 1. y \\<in> p -` O'", "by auto"], ["proof (state)\nthis:\n  y \\<in> p -` O'\n\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "from topological_basisE[OF \\<open>topological_basis A\\<close> \\<open>open (p -` O')\\<close> this]"], ["proof (chain)\npicking this:\n  (\\<And>B'.\n      \\<lbrakk>B' \\<in> A; y \\<in> B'; B' \\<subseteq> p -` O'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain C where \"C \\<in> A\" \"y \\<in> C\" \"C \\<subseteq> p -` O'\""], ["proof (prove)\nusing this:\n  (\\<And>B'.\n      \\<lbrakk>B' \\<in> A; y \\<in> B'; B' \\<subseteq> p -` O'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> A; y \\<in> C; C \\<subseteq> p -` O'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  C \\<in> A\n  y \\<in> C\n  C \\<subseteq> p -` O'\n\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "let ?B' = \"p ` C\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "have \"?B' \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ` C \\<in> B", "using \\<open>C \\<in> A\\<close>"], ["proof (prove)\nusing this:\n  C \\<in> A\n\ngoal (1 subgoal):\n 1. p ` C \\<in> B", "by (auto simp: B_def)"], ["proof (state)\nthis:\n  p ` C \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "moreover"], ["proof (state)\nthis:\n  p ` C \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "have \"x \\<in> ?B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> p ` C", "using y \\<open>y \\<in> C\\<close> \\<open>x \\<in> O'\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> p -` {x}\n  y \\<in> C\n  x \\<in> O'\n\ngoal (1 subgoal):\n 1. x \\<in> p ` C", "by auto"], ["proof (state)\nthis:\n  x \\<in> p ` C\n\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "moreover"], ["proof (state)\nthis:\n  x \\<in> p ` C\n\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "have \"?B' \\<subseteq> O'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ` C \\<subseteq> O'", "using \\<open>C \\<subseteq> _\\<close>"], ["proof (prove)\nusing this:\n  C \\<subseteq> p -` O'\n\ngoal (1 subgoal):\n 1. p ` C \\<subseteq> O'", "by auto"], ["proof (state)\nthis:\n  p ` C \\<subseteq> O'\n\ngoal (1 subgoal):\n 1. \\<And>O' x.\n       \\<lbrakk>open O'; x \\<in> O'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>B.\n                            x \\<in> B' \\<and> B' \\<subseteq> O'", "ultimately"], ["proof (chain)\npicking this:\n  p ` C \\<in> B\n  x \\<in> p ` C\n  p ` C \\<subseteq> O'", "show \"\\<exists>B'\\<in>B. x \\<in> B' \\<and> B' \\<subseteq> O'\""], ["proof (prove)\nusing this:\n  p ` C \\<in> B\n  x \\<in> p ` C\n  p ` C \\<subseteq> O'\n\ngoal (1 subgoal):\n 1. \\<exists>B'\\<in>B. x \\<in> B' \\<and> B' \\<subseteq> O'", "by metis"], ["proof (state)\nthis:\n  \\<exists>B'\\<in>B. x \\<in> B' \\<and> B' \\<subseteq> O'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  topological_basis B\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "ultimately"], ["proof (chain)\npicking this:\n  countable B\n  topological_basis B", "show \"\\<exists>B::'b set set. countable B \\<and> open = generate_topology B\""], ["proof (prove)\nusing this:\n  countable B\n  topological_basis B\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "by (auto simp: topological_basis_imp_subbasis)"], ["proof (state)\nthis:\n  \\<exists>B. countable B \\<and> open = generate_topology B\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Closure\\<close>"], ["", "lemma closure_Union: \"closure (\\<Union>X) = (\\<Union>x\\<in>X. closure x)\" if \"finite X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (\\<Union> X) = \\<Union> (closure ` X)", "using that"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. closure (\\<Union> X) = \\<Union> (closure ` X)", "by (induction X) auto"], ["", "subsection \\<open>Compactness\\<close>"], ["", "lemma compact_if_closed_subset_of_compact:\n  \"compact S\" if \"closed S\" \"compact T\" \"S \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact S", "proof (rule compactI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>\\<forall>t\\<in>C. open t; S \\<subseteq> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C'\\<subseteq>C.\n                            finite C' \\<and> S \\<subseteq> \\<Union> C'", "fix UU"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>\\<forall>t\\<in>C. open t; S \\<subseteq> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C'\\<subseteq>C.\n                            finite C' \\<and> S \\<subseteq> \\<Union> C'", "assume UU: \"\\<forall>t\\<in>UU. open t\" \"S \\<subseteq> \\<Union>UU\""], ["proof (state)\nthis:\n  \\<forall>t\\<in>UU. open t\n  S \\<subseteq> \\<Union> UU\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>\\<forall>t\\<in>C. open t; S \\<subseteq> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C'\\<subseteq>C.\n                            finite C' \\<and> S \\<subseteq> \\<Union> C'", "have \"T \\<subseteq> \\<Union>(insert (- S) (UU))\" \"\\<And>B. B \\<in> insert (- S) UU \\<Longrightarrow> open B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<subseteq> \\<Union> (insert (- S) UU) &&&\n    (\\<And>B. B \\<in> insert (- S) UU \\<Longrightarrow> open B)", "using UU \\<open>S \\<subseteq> T\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>UU. open t\n  S \\<subseteq> \\<Union> UU\n  S \\<subseteq> T\n\ngoal (1 subgoal):\n 1. T \\<subseteq> \\<Union> (insert (- S) UU) &&&\n    (\\<And>B. B \\<in> insert (- S) UU \\<Longrightarrow> open B)", "by (auto simp: open_Compl \\<open>closed S\\<close>)"], ["proof (state)\nthis:\n  T \\<subseteq> \\<Union> (insert (- S) UU)\n  ?B \\<in> insert (- S) UU \\<Longrightarrow> open ?B\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>\\<forall>t\\<in>C. open t; S \\<subseteq> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C'\\<subseteq>C.\n                            finite C' \\<and> S \\<subseteq> \\<Union> C'", "from compactE[OF \\<open>compact T\\<close> this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>B.\n              B \\<in> insert (- S) UU \\<Longrightarrow>\n              B \\<in> insert (- S) UU;\n   \\<And>\\<T>'.\n      \\<lbrakk>\\<T>' \\<subseteq> insert (- S) UU; finite \\<T>';\n       T \\<subseteq> \\<Union> \\<T>'\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "obtain \\<T>' where \\<T>: \"\\<T>' \\<subseteq> insert (- S) UU\" \"finite \\<T>'\" \"T \\<subseteq> \\<Union>\\<T>'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>B.\n              B \\<in> insert (- S) UU \\<Longrightarrow>\n              B \\<in> insert (- S) UU;\n   \\<And>\\<T>'.\n      \\<lbrakk>\\<T>' \\<subseteq> insert (- S) UU; finite \\<T>';\n       T \\<subseteq> \\<Union> \\<T>'\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>\\<T>'.\n        \\<lbrakk>\\<T>' \\<subseteq> insert (- S) UU; finite \\<T>';\n         T \\<subseteq> \\<Union> \\<T>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<T>' \\<subseteq> insert (- S) UU\n  finite \\<T>'\n  T \\<subseteq> \\<Union> \\<T>'\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>\\<forall>t\\<in>C. open t; S \\<subseteq> \\<Union> C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C'\\<subseteq>C.\n                            finite C' \\<and> S \\<subseteq> \\<Union> C'", "show \"\\<exists>C'\\<subseteq>UU. finite C' \\<and> S \\<subseteq> \\<Union>C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C'\\<subseteq>UU. finite C' \\<and> S \\<subseteq> \\<Union> C'", "apply (rule exI[where x=\"\\<T>' - {-S}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T>' - {- S} \\<subseteq> UU \\<and>\n    finite (\\<T>' - {- S}) \\<and> S \\<subseteq> \\<Union> (\\<T>' - {- S})", "using \\<T> UU"], ["proof (prove)\nusing this:\n  \\<T>' \\<subseteq> insert (- S) UU\n  finite \\<T>'\n  T \\<subseteq> \\<Union> \\<T>'\n  \\<forall>t\\<in>UU. open t\n  S \\<subseteq> \\<Union> UU\n\ngoal (1 subgoal):\n 1. \\<T>' - {- S} \\<subseteq> UU \\<and>\n    finite (\\<T>' - {- S}) \\<and> S \\<subseteq> \\<Union> (\\<T>' - {- S})", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<T>' \\<subseteq> insert (- S) UU; finite \\<T>';\n        T \\<subseteq> \\<Union> \\<T>'; \\<forall>t\\<in>UU. open t;\n        S \\<subseteq> \\<Union> UU; x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>\\<T>' - {- S}. x \\<in> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<T>' \\<subseteq> insert (- S) UU; finite \\<T>';\n        T \\<subseteq> \\<Union> \\<T>'; \\<forall>t\\<in>UU. open t;\n        S \\<subseteq> \\<Union> UU; x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>\\<T>' - {- S}. x \\<in> X", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<T>' \\<subseteq> insert (- S) UU; finite \\<T>';\n        T \\<subseteq> \\<Union> \\<T>'; \\<forall>t\\<in>UU. open t;\n        S \\<subseteq> \\<Union> UU; x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>\\<T>' - {- S}. x \\<in> X", "assume \"x \\<in> S\""], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<T>' \\<subseteq> insert (- S) UU; finite \\<T>';\n        T \\<subseteq> \\<Union> \\<T>'; \\<forall>t\\<in>UU. open t;\n        S \\<subseteq> \\<Union> UU; x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>\\<T>' - {- S}. x \\<in> X", "with \\<T> \\<open>S \\<subseteq> T\\<close>"], ["proof (chain)\npicking this:\n  \\<T>' \\<subseteq> insert (- S) UU\n  finite \\<T>'\n  T \\<subseteq> \\<Union> \\<T>'\n  S \\<subseteq> T\n  x \\<in> S", "obtain U where \"x \\<in> U\" \"U \\<in> \\<T>'\""], ["proof (prove)\nusing this:\n  \\<T>' \\<subseteq> insert (- S) UU\n  finite \\<T>'\n  T \\<subseteq> \\<Union> \\<T>'\n  S \\<subseteq> T\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        \\<lbrakk>x \\<in> U; U \\<in> \\<T>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<T>"], ["proof (prove)\nusing this:\n  \\<T>' \\<subseteq> insert (- S) UU\n  finite \\<T>'\n  T \\<subseteq> \\<Union> \\<T>'\n  S \\<subseteq> T\n  x \\<in> S\n  \\<T>' \\<subseteq> insert (- S) UU\n  finite \\<T>'\n  T \\<subseteq> \\<Union> \\<T>'\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        \\<lbrakk>x \\<in> U; U \\<in> \\<T>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> U\n  U \\<in> \\<T>'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<T>' \\<subseteq> insert (- S) UU; finite \\<T>';\n        T \\<subseteq> \\<Union> \\<T>'; \\<forall>t\\<in>UU. open t;\n        S \\<subseteq> \\<Union> UU; x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X\\<in>\\<T>' - {- S}. x \\<in> X", "then"], ["proof (chain)\npicking this:\n  x \\<in> U\n  U \\<in> \\<T>'", "show \"\\<exists>X\\<in>\\<T>' - {- S}. x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> U\n  U \\<in> \\<T>'\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>\\<T>' - {- S}. x \\<in> X", "using \\<T> UU \\<open>x \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> U\n  U \\<in> \\<T>'\n  \\<T>' \\<subseteq> insert (- S) UU\n  finite \\<T>'\n  T \\<subseteq> \\<Union> \\<T>'\n  \\<forall>t\\<in>UU. open t\n  S \\<subseteq> \\<Union> UU\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>X\\<in>\\<T>' - {- S}. x \\<in> X", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> U; U \\<in> \\<T>'; \\<T>' \\<subseteq> insert (- S) UU;\n     finite \\<T>'; T \\<subseteq> \\<Union> \\<T>'; \\<forall>t\\<in>UU. open t;\n     S \\<subseteq> \\<Union> UU; x \\<in> S\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X\\<in>\\<T>' - {- S}. x \\<in> X", "apply (rule bexI[where x=U])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> U; U \\<in> \\<T>'; \\<T>' \\<subseteq> insert (- S) UU;\n     finite \\<T>'; T \\<subseteq> \\<Union> \\<T>'; \\<forall>t\\<in>UU. open t;\n     S \\<subseteq> \\<Union> UU; x \\<in> S\\<rbrakk>\n    \\<Longrightarrow> x \\<in> U\n 2. \\<lbrakk>x \\<in> U; U \\<in> \\<T>'; \\<T>' \\<subseteq> insert (- S) UU;\n     finite \\<T>'; T \\<subseteq> \\<Union> \\<T>'; \\<forall>t\\<in>UU. open t;\n     S \\<subseteq> \\<Union> UU; x \\<in> S\\<rbrakk>\n    \\<Longrightarrow> U \\<in> \\<T>' - {- S}", "by auto"], ["proof (state)\nthis:\n  \\<exists>X\\<in>\\<T>' - {- S}. x \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C'\\<subseteq>UU. finite C' \\<and> S \\<subseteq> \\<Union> C'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Locally finite\\<close>"], ["", "definition \"locally_finite_on X I U \\<longleftrightarrow> (\\<forall>p\\<in>X. \\<exists>N. p\\<in>N \\<and> open N \\<and> finite {i\\<in>I. U i \\<inter> N \\<noteq> {}})\""], ["", "lemmas locally_finite_onI = locally_finite_on_def[THEN iffD2, rule_format]"], ["", "lemma locally_finite_onE:\n  assumes \"locally_finite_on X I U\"\n  assumes \"p \\<in> X\"\n  obtains N where \"p \\<in> N\" \"open N\" \"finite {i\\<in>I. U i \\<inter> N \\<noteq> {}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>p \\<in> N; open N;\n         finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  locally_finite_on X I U\n  p \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>p \\<in> N; open N;\n         finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: locally_finite_on_def)"], ["", "lemma locally_finite_onD:\n  assumes \"locally_finite_on X I U\"\n  assumes \"p \\<in> X\"\n  shows \"finite {i\\<in>I. p \\<in> U i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i \\<in> I. p \\<in> U i}", "apply (rule locally_finite_onE[OF assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<lbrakk>p \\<in> N; open N;\n        finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n       \\<Longrightarrow> finite {i \\<in> I. p \\<in> U i}", "apply (rule finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>N.\n       \\<lbrakk>p \\<in> N; open N;\n        finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n       \\<Longrightarrow> {i \\<in> I. p \\<in> U i} \\<subseteq> ?B2 N\n 2. \\<And>N.\n       \\<lbrakk>p \\<in> N; open N;\n        finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n       \\<Longrightarrow> finite (?B2 N)", "by auto"], ["", "lemma locally_finite_on_open_coverI: \"locally_finite_on X I U\"\n  if fin: \"\\<And>j. j \\<in> I \\<Longrightarrow> finite {i\\<in>I. U i \\<inter> U j \\<noteq> {}}\"\n    and open_cover: \"X \\<subseteq> (\\<Union>i\\<in>I. U i)\" \"\\<And>i. i \\<in> I \\<Longrightarrow> open (U i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. locally_finite_on X I U", "proof (rule locally_finite_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> X \\<Longrightarrow>\n       \\<exists>N.\n          p \\<in> N \\<and>\n          open N \\<and> finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> X \\<Longrightarrow>\n       \\<exists>N.\n          p \\<in> N \\<and>\n          open N \\<and> finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}", "assume \"p \\<in> X\""], ["proof (state)\nthis:\n  p \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> X \\<Longrightarrow>\n       \\<exists>N.\n          p \\<in> N \\<and>\n          open N \\<and> finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}", "then"], ["proof (chain)\npicking this:\n  p \\<in> X", "obtain i where i: \"i \\<in> I\" \"p \\<in> U i\" \"open (U i)\""], ["proof (prove)\nusing this:\n  p \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> I; p \\<in> U i; open (U i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using open_cover"], ["proof (prove)\nusing this:\n  p \\<in> X\n  X \\<subseteq> \\<Union> (U ` I)\n  ?i \\<in> I \\<Longrightarrow> open (U ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> I; p \\<in> U i; open (U i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i \\<in> I\n  p \\<in> U i\n  open (U i)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> X \\<Longrightarrow>\n       \\<exists>N.\n          p \\<in> N \\<and>\n          open N \\<and> finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}", "show \"\\<exists>N. p \\<in> N \\<and> open N \\<and> finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       p \\<in> N \\<and>\n       open N \\<and> finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}", "by (intro exI[where x=\"U i\"] conjI i fin)"], ["proof (state)\nthis:\n  \\<exists>N.\n     p \\<in> N \\<and>\n     open N \\<and> finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma locally_finite_compactD:\n  \"finite {i\\<in>I. U i \\<inter> V \\<noteq> {}}\"\n  if lf: \"locally_finite_on X I U\"\n    and compact: \"compact V\"\n    and subset: \"V \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}", "have \"\\<exists>N. \\<forall>p \\<in> X. p \\<in> N p \\<and> open (N p) \\<and> finite {i\\<in>I. U i \\<inter> N p \\<noteq> {}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>p\\<in>X.\n          p \\<in> N p \\<and>\n          open (N p) \\<and> finite {i \\<in> I. U i \\<inter> N p \\<noteq> {}}", "by (rule bchoice) (auto elim!: locally_finite_onE[OF lf, rule_format])"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>p\\<in>X.\n        p \\<in> N p \\<and>\n        open (N p) \\<and> finite {i \\<in> I. U i \\<inter> N p \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}", "then"], ["proof (chain)\npicking this:\n  \\<exists>N.\n     \\<forall>p\\<in>X.\n        p \\<in> N p \\<and>\n        open (N p) \\<and> finite {i \\<in> I. U i \\<inter> N p \\<noteq> {}}", "obtain N where N: \"\\<And>p. p \\<in> X \\<Longrightarrow> p \\<in> N p\"\n    \"\\<And>p. p \\<in> X \\<Longrightarrow> open (N p)\"\n    \"\\<And>p. p \\<in> X \\<Longrightarrow> finite {i\\<in>I. U i \\<inter> N p \\<noteq> {}}\""], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>p\\<in>X.\n        p \\<in> N p \\<and>\n        open (N p) \\<and> finite {i \\<in> I. U i \\<inter> N p \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>\\<And>p. p \\<in> X \\<Longrightarrow> p \\<in> N p;\n         \\<And>p. p \\<in> X \\<Longrightarrow> open (N p);\n         \\<And>p.\n            p \\<in> X \\<Longrightarrow>\n            finite {i \\<in> I. U i \\<inter> N p \\<noteq> {}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ?p \\<in> X \\<Longrightarrow> ?p \\<in> N ?p\n  ?p \\<in> X \\<Longrightarrow> open (N ?p)\n  ?p \\<in> X \\<Longrightarrow>\n  finite {i \\<in> I. U i \\<inter> N ?p \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}", "have \"V \\<subseteq> (\\<Union>p\\<in>X. N p)\" \"\\<And>B. B \\<in> N ` X \\<Longrightarrow> open B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> \\<Union> (N ` X) &&&\n    (\\<And>B. B \\<in> N ` X \\<Longrightarrow> open B)", "using N subset"], ["proof (prove)\nusing this:\n  ?p \\<in> X \\<Longrightarrow> ?p \\<in> N ?p\n  ?p \\<in> X \\<Longrightarrow> open (N ?p)\n  ?p \\<in> X \\<Longrightarrow>\n  finite {i \\<in> I. U i \\<inter> N ?p \\<noteq> {}}\n  V \\<subseteq> X\n\ngoal (1 subgoal):\n 1. V \\<subseteq> \\<Union> (N ` X) &&&\n    (\\<And>B. B \\<in> N ` X \\<Longrightarrow> open B)", "by force+"], ["proof (state)\nthis:\n  V \\<subseteq> \\<Union> (N ` X)\n  ?B \\<in> N ` X \\<Longrightarrow> open ?B\n\ngoal (1 subgoal):\n 1. finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}", "from compactE[OF compact this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>B. B \\<in> N ` X \\<Longrightarrow> B \\<in> N ` X;\n   \\<And>\\<T>'.\n      \\<lbrakk>\\<T>' \\<subseteq> N ` X; finite \\<T>';\n       V \\<subseteq> \\<Union> \\<T>'\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "obtain C where C: \"C \\<subseteq> X\" \"finite C\" \"V \\<subseteq> \\<Union>(N ` C)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>B. B \\<in> N ` X \\<Longrightarrow> B \\<in> N ` X;\n   \\<And>\\<T>'.\n      \\<lbrakk>\\<T>' \\<subseteq> N ` X; finite \\<T>';\n       V \\<subseteq> \\<Union> \\<T>'\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<subseteq> X; finite C;\n         V \\<subseteq> \\<Union> (N ` C)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis finite_subset_image)"], ["proof (state)\nthis:\n  C \\<subseteq> X\n  finite C\n  V \\<subseteq> \\<Union> (N ` C)\n\ngoal (1 subgoal):\n 1. finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}", "then"], ["proof (chain)\npicking this:\n  C \\<subseteq> X\n  finite C\n  V \\<subseteq> \\<Union> (N ` C)", "have \"{i\\<in>I. U i \\<inter> V \\<noteq> {}} \\<subseteq> {i\\<in>I. U i \\<inter> \\<Union>(N ` C) \\<noteq> {}}\""], ["proof (prove)\nusing this:\n  C \\<subseteq> X\n  finite C\n  V \\<subseteq> \\<Union> (N ` C)\n\ngoal (1 subgoal):\n 1. {i \\<in> I. U i \\<inter> V \\<noteq> {}}\n    \\<subseteq> {i \\<in> I. U i \\<inter> \\<Union> (N ` C) \\<noteq> {}}", "by force"], ["proof (state)\nthis:\n  {i \\<in> I. U i \\<inter> V \\<noteq> {}}\n  \\<subseteq> {i \\<in> I. U i \\<inter> \\<Union> (N ` C) \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}", "also"], ["proof (state)\nthis:\n  {i \\<in> I. U i \\<inter> V \\<noteq> {}}\n  \\<subseteq> {i \\<in> I. U i \\<inter> \\<Union> (N ` C) \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}", "have \"\\<dots> \\<subseteq> (\\<Union>c\\<in>C. {i\\<in>I. U i \\<inter> N c \\<noteq> {}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i \\<in> I. U i \\<inter> \\<Union> (N ` C) \\<noteq> {}}\n    \\<subseteq> (\\<Union>c\\<in>C. {i \\<in> I. U i \\<inter> N c \\<noteq> {}})", "by force"], ["proof (state)\nthis:\n  {i \\<in> I. U i \\<inter> \\<Union> (N ` C) \\<noteq> {}}\n  \\<subseteq> (\\<Union>c\\<in>C. {i \\<in> I. U i \\<inter> N c \\<noteq> {}})\n\ngoal (1 subgoal):\n 1. finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}", "also"], ["proof (state)\nthis:\n  {i \\<in> I. U i \\<inter> \\<Union> (N ` C) \\<noteq> {}}\n  \\<subseteq> (\\<Union>c\\<in>C. {i \\<in> I. U i \\<inter> N c \\<noteq> {}})\n\ngoal (1 subgoal):\n 1. finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union>c\\<in>C. {i \\<in> I. U i \\<inter> N c \\<noteq> {}})", "apply (rule finite_Union)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ((\\<lambda>c. {i \\<in> I. U i \\<inter> N c \\<noteq> {}}) ` C)\n 2. \\<And>M.\n       M \\<in> (\\<lambda>c. {i \\<in> I. U i \\<inter> N c \\<noteq> {}}) `\n               C \\<Longrightarrow>\n       finite M", "using C"], ["proof (prove)\nusing this:\n  C \\<subseteq> X\n  finite C\n  V \\<subseteq> \\<Union> (N ` C)\n\ngoal (2 subgoals):\n 1. finite ((\\<lambda>c. {i \\<in> I. U i \\<inter> N c \\<noteq> {}}) ` C)\n 2. \\<And>M.\n       M \\<in> (\\<lambda>c. {i \\<in> I. U i \\<inter> N c \\<noteq> {}}) `\n               C \\<Longrightarrow>\n       finite M", "by (auto intro!: C N)"], ["proof (state)\nthis:\n  finite (\\<Union>c\\<in>C. {i \\<in> I. U i \\<inter> N c \\<noteq> {}})\n\ngoal (1 subgoal):\n 1. finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}", "finally (finite_subset)"], ["proof (chain)\npicking this:\n  finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}", "."], ["proof (state)\nthis:\n  finite {i \\<in> I. U i \\<inter> V \\<noteq> {}}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closure_Int_open_eq_empty: \"open S \\<Longrightarrow> (closure T \\<inter> S) = {} \\<longleftrightarrow> T \\<inter> S = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open S \\<Longrightarrow>\n    (closure T \\<inter> S = {}) = (T \\<inter> S = {})", "by (auto simp: open_Int_closure_eq_empty ac_simps)"], ["", "lemma locally_finite_on_subset:\n  assumes \"locally_finite_on X J U\"\n  assumes \"\\<And>i. i \\<in> I \\<Longrightarrow> V i \\<subseteq> U i\" \"I \\<subseteq> J\"\n  shows \"locally_finite_on X I V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. locally_finite_on X I V", "proof (rule locally_finite_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> X \\<Longrightarrow>\n       \\<exists>N.\n          p \\<in> N \\<and>\n          open N \\<and> finite {i \\<in> I. V i \\<inter> N \\<noteq> {}}", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> X \\<Longrightarrow>\n       \\<exists>N.\n          p \\<in> N \\<and>\n          open N \\<and> finite {i \\<in> I. V i \\<inter> N \\<noteq> {}}", "assume \"p \\<in> X\""], ["proof (state)\nthis:\n  p \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> X \\<Longrightarrow>\n       \\<exists>N.\n          p \\<in> N \\<and>\n          open N \\<and> finite {i \\<in> I. V i \\<inter> N \\<noteq> {}}", "from locally_finite_onE[OF assms(1) this]"], ["proof (chain)\npicking this:\n  (\\<And>N.\n      \\<lbrakk>p \\<in> N; open N;\n       finite {i \\<in> J. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain N where \"p \\<in> N\" \"open N\" \"finite {i \\<in> J. U i \\<inter> N \\<noteq> {}}\""], ["proof (prove)\nusing this:\n  (\\<And>N.\n      \\<lbrakk>p \\<in> N; open N;\n       finite {i \\<in> J. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>p \\<in> N; open N;\n         finite {i \\<in> J. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  p \\<in> N\n  open N\n  finite {i \\<in> J. U i \\<inter> N \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> X \\<Longrightarrow>\n       \\<exists>N.\n          p \\<in> N \\<and>\n          open N \\<and> finite {i \\<in> I. V i \\<inter> N \\<noteq> {}}", "then"], ["proof (chain)\npicking this:\n  p \\<in> N\n  open N\n  finite {i \\<in> J. U i \\<inter> N \\<noteq> {}}", "show \"\\<exists>N. p \\<in> N \\<and> open N \\<and> finite {i \\<in> I. V i \\<inter> N \\<noteq> {}}\""], ["proof (prove)\nusing this:\n  p \\<in> N\n  open N\n  finite {i \\<in> J. U i \\<inter> N \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       p \\<in> N \\<and>\n       open N \\<and> finite {i \\<in> I. V i \\<inter> N \\<noteq> {}}", "apply (intro exI[where x=N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> N; open N;\n     finite {i \\<in> J. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n    \\<Longrightarrow> p \\<in> N \\<and>\n                      open N \\<and>\n                      finite {i \\<in> I. V i \\<inter> N \\<noteq> {}}", "using assms"], ["proof (prove)\nusing this:\n  locally_finite_on X J U\n  ?i \\<in> I \\<Longrightarrow> V ?i \\<subseteq> U ?i\n  I \\<subseteq> J\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<in> N; open N;\n     finite {i \\<in> J. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n    \\<Longrightarrow> p \\<in> N \\<and>\n                      open N \\<and>\n                      finite {i \\<in> I. V i \\<inter> N \\<noteq> {}}", "by (auto elim!: finite_subset[rotated])"], ["proof (state)\nthis:\n  \\<exists>N.\n     p \\<in> N \\<and>\n     open N \\<and> finite {i \\<in> I. V i \\<inter> N \\<noteq> {}}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma locally_finite_on_closure:\n  \"locally_finite_on X I (\\<lambda>x. closure (U x))\"\n  if \"locally_finite_on X I U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. locally_finite_on X I (\\<lambda>x. closure (U x))", "proof (rule locally_finite_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> X \\<Longrightarrow>\n       \\<exists>N.\n          p \\<in> N \\<and>\n          open N \\<and>\n          finite {i \\<in> I. closure (U i) \\<inter> N \\<noteq> {}}", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> X \\<Longrightarrow>\n       \\<exists>N.\n          p \\<in> N \\<and>\n          open N \\<and>\n          finite {i \\<in> I. closure (U i) \\<inter> N \\<noteq> {}}", "assume \"p \\<in> X\""], ["proof (state)\nthis:\n  p \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> X \\<Longrightarrow>\n       \\<exists>N.\n          p \\<in> N \\<and>\n          open N \\<and>\n          finite {i \\<in> I. closure (U i) \\<inter> N \\<noteq> {}}", "from locally_finite_onE[OF that this]"], ["proof (chain)\npicking this:\n  (\\<And>N.\n      \\<lbrakk>p \\<in> N; open N;\n       finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain N\n    where \"p \\<in> N\" \"open N\" \"finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\""], ["proof (prove)\nusing this:\n  (\\<And>N.\n      \\<lbrakk>p \\<in> N; open N;\n       finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>p \\<in> N; open N;\n         finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  p \\<in> N\n  open N\n  finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       p \\<in> X \\<Longrightarrow>\n       \\<exists>N.\n          p \\<in> N \\<and>\n          open N \\<and>\n          finite {i \\<in> I. closure (U i) \\<inter> N \\<noteq> {}}", "then"], ["proof (chain)\npicking this:\n  p \\<in> N\n  open N\n  finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}", "show \"\\<exists>N. p \\<in> N \\<and> open N \\<and> finite {i \\<in> I. closure (U i) \\<inter> N \\<noteq> {}}\""], ["proof (prove)\nusing this:\n  p \\<in> N\n  open N\n  finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       p \\<in> N \\<and>\n       open N \\<and>\n       finite {i \\<in> I. closure (U i) \\<inter> N \\<noteq> {}}", "by (auto intro!: exI[where x=N] simp: closure_Int_open_eq_empty)"], ["proof (state)\nthis:\n  \\<exists>N.\n     p \\<in> N \\<and>\n     open N \\<and> finite {i \\<in> I. closure (U i) \\<inter> N \\<noteq> {}}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma locally_finite_on_closedin_Union_closure:\n  \"closedin (top_of_set X) (\\<Union>i\\<in>I. closure (U i))\"\n  if \"locally_finite_on X I U\" \"\\<And>i. i \\<in> I \\<Longrightarrow> closure (U i) \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closedin (top_of_set X) (\\<Union>i\\<in>I. closure (U i))", "unfolding closedin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>I. closure (U i))\n    \\<subseteq> topspace (top_of_set X) \\<and>\n    openin (top_of_set X)\n     (topspace (top_of_set X) - (\\<Union>i\\<in>I. closure (U i)))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>i \\<in> I; x \\<in> closure (U i)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> topspace (top_of_set X)\n 2. openin (top_of_set X)\n     (topspace (top_of_set X) - (\\<Union>i\\<in>I. closure (U i)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i_ \\<in> I; x_ \\<in> closure (U i_)\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> topspace (top_of_set X)", "using that(2)"], ["proof (prove)\nusing this:\n  ?i \\<in> I \\<Longrightarrow> closure (U ?i) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i_ \\<in> I; x_ \\<in> closure (U i_)\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> topspace (top_of_set X)", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (top_of_set X)\n     (topspace (top_of_set X) - (\\<Union>i\\<in>I. closure (U i)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (top_of_set X)\n     (topspace (top_of_set X) - (\\<Union>i\\<in>I. closure (U i)))", "apply (subst openin_subopen)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>topspace (top_of_set X) -\n                   (\\<Union>i\\<in>I. closure (U i)).\n       \\<exists>T.\n          openin (top_of_set X) T \\<and>\n          x \\<in> T \\<and>\n          T \\<subseteq> topspace (top_of_set X) -\n                        (\\<Union>i\\<in>I. closure (U i))", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X;\n        \\<forall>xa\\<in>I. x \\<notin> closure (U xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            openin (top_of_set X) T \\<and>\n                            x \\<in> T \\<and>\n                            T \\<subseteq> X -\n    (\\<Union>i\\<in>I. closure (U i))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X;\n        \\<forall>xa\\<in>I. x \\<notin> closure (U xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            openin (top_of_set X) T \\<and>\n                            x \\<in> T \\<and>\n                            T \\<subseteq> X -\n    (\\<Union>i\\<in>I. closure (U i))", "assume x: \"x \\<in> X\" \"\\<forall>i\\<in>I. x \\<notin> closure (U i)\""], ["proof (state)\nthis:\n  x \\<in> X\n  \\<forall>i\\<in>I. x \\<notin> closure (U i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X;\n        \\<forall>xa\\<in>I. x \\<notin> closure (U xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            openin (top_of_set X) T \\<and>\n                            x \\<in> T \\<and>\n                            T \\<subseteq> X -\n    (\\<Union>i\\<in>I. closure (U i))", "from locally_finite_onE[OF that(1) \\<open>x \\<in> X\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>N.\n      \\<lbrakk>x \\<in> N; open N;\n       finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain N where N: \"x \\<in> N\" \"open N\" \"finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\" (is \"finite ?I\")"], ["proof (prove)\nusing this:\n  (\\<And>N.\n      \\<lbrakk>x \\<in> N; open N;\n       finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>x \\<in> N; open N;\n         finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  x \\<in> N\n  open N\n  finite {i \\<in> I. U i \\<inter> N \\<noteq> {}}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X;\n        \\<forall>xa\\<in>I. x \\<notin> closure (U xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            openin (top_of_set X) T \\<and>\n                            x \\<in> T \\<and>\n                            T \\<subseteq> X -\n    (\\<Union>i\\<in>I. closure (U i))", "define N' where \"N' = N - (\\<Union>i \\<in> ?I. closure (U i))\""], ["proof (state)\nthis:\n  N' =\n  N - (\\<Union>i\\<in>{i \\<in> I. U i \\<inter> N \\<noteq> {}}. closure (U i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X;\n        \\<forall>xa\\<in>I. x \\<notin> closure (U xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            openin (top_of_set X) T \\<and>\n                            x \\<in> T \\<and>\n                            T \\<subseteq> X -\n    (\\<Union>i\\<in>I. closure (U i))", "have \"open N'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open N'", "by (auto simp: N'_def intro!: N)"], ["proof (state)\nthis:\n  open N'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X;\n        \\<forall>xa\\<in>I. x \\<notin> closure (U xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            openin (top_of_set X) T \\<and>\n                            x \\<in> T \\<and>\n                            T \\<subseteq> X -\n    (\\<Union>i\\<in>I. closure (U i))", "then"], ["proof (chain)\npicking this:\n  open N'", "have \"openin (top_of_set X) (X \\<inter> N')\""], ["proof (prove)\nusing this:\n  open N'\n\ngoal (1 subgoal):\n 1. openin (top_of_set X) (X \\<inter> N')", "by (rule openin_open_Int)"], ["proof (state)\nthis:\n  openin (top_of_set X) (X \\<inter> N')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X;\n        \\<forall>xa\\<in>I. x \\<notin> closure (U xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            openin (top_of_set X) T \\<and>\n                            x \\<in> T \\<and>\n                            T \\<subseteq> X -\n    (\\<Union>i\\<in>I. closure (U i))", "moreover"], ["proof (state)\nthis:\n  openin (top_of_set X) (X \\<inter> N')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X;\n        \\<forall>xa\\<in>I. x \\<notin> closure (U xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            openin (top_of_set X) T \\<and>\n                            x \\<in> T \\<and>\n                            T \\<subseteq> X -\n    (\\<Union>i\\<in>I. closure (U i))", "have \"x \\<in> X \\<inter> N'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<inter> N'", "using x"], ["proof (prove)\nusing this:\n  x \\<in> X\n  \\<forall>i\\<in>I. x \\<notin> closure (U i)\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<inter> N'", "by (auto simp: N'_def N)"], ["proof (state)\nthis:\n  x \\<in> X \\<inter> N'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X;\n        \\<forall>xa\\<in>I. x \\<notin> closure (U xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            openin (top_of_set X) T \\<and>\n                            x \\<in> T \\<and>\n                            T \\<subseteq> X -\n    (\\<Union>i\\<in>I. closure (U i))", "moreover"], ["proof (state)\nthis:\n  x \\<in> X \\<inter> N'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X;\n        \\<forall>xa\\<in>I. x \\<notin> closure (U xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            openin (top_of_set X) T \\<and>\n                            x \\<in> T \\<and>\n                            T \\<subseteq> X -\n    (\\<Union>i\\<in>I. closure (U i))", "have \"X \\<inter> N' \\<subseteq> X - (\\<Union>i\\<in>I. closure (U i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<inter> N' \\<subseteq> X - (\\<Union>i\\<in>I. closure (U i))", "using x that(2)"], ["proof (prove)\nusing this:\n  x \\<in> X\n  \\<forall>i\\<in>I. x \\<notin> closure (U i)\n  ?i \\<in> I \\<Longrightarrow> closure (U ?i) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. X \\<inter> N' \\<subseteq> X - (\\<Union>i\\<in>I. closure (U i))", "apply (auto simp: N'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa i.\n       \\<lbrakk>x \\<in> X; \\<forall>i\\<in>I. x \\<notin> closure (U i);\n        \\<And>i. i \\<in> I \\<Longrightarrow> closure (U i) \\<subseteq> X;\n        xa \\<in> X; xa \\<in> N;\n        \\<forall>x.\n           x \\<in> I \\<longrightarrow>\n           U x \\<inter> N = {} \\<or> xa \\<notin> closure (U x);\n        i \\<in> I; xa \\<in> closure (U i)\\<rbrakk>\n       \\<Longrightarrow> False", "by (meson N(2) closure_iff_nhds_not_empty dual_order.refl)"], ["proof (state)\nthis:\n  X \\<inter> N' \\<subseteq> X - (\\<Union>i\\<in>I. closure (U i))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> X;\n        \\<forall>xa\\<in>I. x \\<notin> closure (U xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T.\n                            openin (top_of_set X) T \\<and>\n                            x \\<in> T \\<and>\n                            T \\<subseteq> X -\n    (\\<Union>i\\<in>I. closure (U i))", "ultimately"], ["proof (chain)\npicking this:\n  openin (top_of_set X) (X \\<inter> N')\n  x \\<in> X \\<inter> N'\n  X \\<inter> N' \\<subseteq> X - (\\<Union>i\\<in>I. closure (U i))", "show \"\\<exists>T. openin (top_of_set X) T \\<and> x \\<in> T \\<and> T \\<subseteq> X - (\\<Union>i\\<in>I. closure (U i))\""], ["proof (prove)\nusing this:\n  openin (top_of_set X) (X \\<inter> N')\n  x \\<in> X \\<inter> N'\n  X \\<inter> N' \\<subseteq> X - (\\<Union>i\\<in>I. closure (U i))\n\ngoal (1 subgoal):\n 1. \\<exists>T.\n       openin (top_of_set X) T \\<and>\n       x \\<in> T \\<and> T \\<subseteq> X - (\\<Union>i\\<in>I. closure (U i))", "by auto"], ["proof (state)\nthis:\n  \\<exists>T.\n     openin (top_of_set X) T \\<and>\n     x \\<in> T \\<and> T \\<subseteq> X - (\\<Union>i\\<in>I. closure (U i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma closure_subtopology_minimal:\n  \"S \\<subseteq> T \\<Longrightarrow> closedin (top_of_set X) T \\<Longrightarrow> closure S \\<inter> X \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<subseteq> T; closedin (top_of_set X) T\\<rbrakk>\n    \\<Longrightarrow> closure S \\<inter> X \\<subseteq> T", "apply (auto simp: closedin_closed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Ta.\n       \\<lbrakk>x \\<in> closure S; x \\<in> X; closed Ta; T = X \\<inter> Ta;\n        S \\<subseteq> X; S \\<subseteq> Ta\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Ta", "using closure_minimal"], ["proof (prove)\nusing this:\n  \\<lbrakk>?S \\<subseteq> ?T; closed ?T\\<rbrakk>\n  \\<Longrightarrow> closure ?S \\<subseteq> ?T\n\ngoal (1 subgoal):\n 1. \\<And>x Ta.\n       \\<lbrakk>x \\<in> closure S; x \\<in> X; closed Ta; T = X \\<inter> Ta;\n        S \\<subseteq> X; S \\<subseteq> Ta\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Ta", "by blast"], ["", "lemma locally_finite_on_closure_Union:\n  \"(\\<Union>i\\<in>I. closure (U i)) = closure (\\<Union>i\\<in>I. (U i)) \\<inter> X\"\n  if \"locally_finite_on X I U\" \"\\<And>i. i \\<in> I \\<Longrightarrow> closure (U i) \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>I. closure (U i)) = closure (\\<Union> (U ` I)) \\<inter> X", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Union>i\\<in>I. closure (U i))\n    \\<subseteq> closure (\\<Union> (U ` I)) \\<inter> X\n 2. closure (\\<Union> (U ` I)) \\<inter> X\n    \\<subseteq> (\\<Union>i\\<in>I. closure (U i))", "show \"(\\<Union>i\\<in>I. closure (U i)) \\<subseteq> closure (\\<Union>i\\<in>I. U i) \\<inter> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>I. closure (U i))\n    \\<subseteq> closure (\\<Union> (U ` I)) \\<inter> X", "using that"], ["proof (prove)\nusing this:\n  locally_finite_on X I U\n  ?i \\<in> I \\<Longrightarrow> closure (U ?i) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>I. closure (U i))\n    \\<subseteq> closure (\\<Union> (U ` I)) \\<inter> X", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>locally_finite_on X I U;\n        \\<And>i. i \\<in> I \\<Longrightarrow> closure (U i) \\<subseteq> X;\n        i \\<in> I; x \\<in> closure (U i)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> closure (\\<Union> (U ` I))", "by (metis (no_types, lifting) SUP_le_iff closed_closure closure_minimal closure_subset subsetCE)"], ["proof (state)\nthis:\n  (\\<Union>i\\<in>I. closure (U i))\n  \\<subseteq> closure (\\<Union> (U ` I)) \\<inter> X\n\ngoal (1 subgoal):\n 1. closure (\\<Union> (U ` I)) \\<inter> X\n    \\<subseteq> (\\<Union>i\\<in>I. closure (U i))", "show \"closure (\\<Union>i\\<in>I. U i) \\<inter> X \\<subseteq> (\\<Union>i\\<in>I. closure (U i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (\\<Union> (U ` I)) \\<inter> X\n    \\<subseteq> (\\<Union>i\\<in>I. closure (U i))", "apply (rule closure_subtopology_minimal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Union> (U ` I) \\<subseteq> (\\<Union>i\\<in>I. closure (U i))\n 2. closedin (top_of_set X) (\\<Union>i\\<in>I. closure (U i))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. closedin (top_of_set X) (\\<Union>i\\<in>I. closure (U i))", "using that"], ["proof (prove)\nusing this:\n  locally_finite_on X I U\n  ?i \\<in> I \\<Longrightarrow> closure (U ?i) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. closedin (top_of_set X) (\\<Union>i\\<in>I. closure (U i))", "by (auto intro!: locally_finite_on_closedin_Union_closure)"], ["proof (state)\nthis:\n  closure (\\<Union> (U ` I)) \\<inter> X\n  \\<subseteq> (\\<Union>i\\<in>I. closure (U i))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Refinement of cover\\<close>"], ["", "definition refines :: \"'a set set \\<Rightarrow> 'a set set \\<Rightarrow> bool\" (infix \"refines\" 50)\n  where \"A refines B \\<longleftrightarrow> (\\<forall>s\\<in>A. (\\<exists>t. t \\<in> B \\<and> s \\<subseteq> t))\""], ["", "lemma refines_subset: \"x refines y\" if \"z refines y\" \"x \\<subseteq> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x refines y", "using that"], ["proof (prove)\nusing this:\n  z refines y\n  x \\<subseteq> z\n\ngoal (1 subgoal):\n 1. x refines y", "by (auto simp: refines_def)"], ["", "subsection \\<open>Functions as vector space\\<close>"], ["", "instantiation \"fun\" :: (type, scaleR) scaleR begin"], ["", "definition scaleR_fun :: \"real \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b\" where\n  \"scaleR_fun r f = (\\<lambda>x. r *\\<^sub>R f x)\""], ["", "lemma scaleR_fun_beta[simp]: \"(r *\\<^sub>R f) x = r *\\<^sub>R f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r *\\<^sub>R f) x = r *\\<^sub>R f x", "by (simp add: scaleR_fun_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, scaleR_class)", ".."], ["", "end"], ["", "instance \"fun\" :: (type, real_vector) real_vector"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, real_vector_class)", "by standard (auto simp: scaleR_fun_def algebra_simps)"], ["", "subsection \\<open>Additional lemmas\\<close>"], ["", "lemmas [simp del] = vimage_Un vimage_Int"], ["", "lemma finite_Collect_imageI: \"finite {U \\<in> f ` X. P U}\" if \"finite {x\\<in>X. P (f x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {U \\<in> f ` X. P U}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {U \\<in> f ` X. P U}", "have \"{d \\<in> f ` X. P d} \\<subseteq> f ` {c \\<in> X. P (f c)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {d \\<in> f ` X. P d} \\<subseteq> f ` {c \\<in> X. P (f c)}", "by blast"], ["proof (state)\nthis:\n  {d \\<in> f ` X. P d} \\<subseteq> f ` {c \\<in> X. P (f c)}\n\ngoal (1 subgoal):\n 1. finite {U \\<in> f ` X. P U}", "then"], ["proof (chain)\npicking this:\n  {d \\<in> f ` X. P d} \\<subseteq> f ` {c \\<in> X. P (f c)}", "show ?thesis"], ["proof (prove)\nusing this:\n  {d \\<in> f ` X. P d} \\<subseteq> f ` {c \\<in> X. P (f c)}\n\ngoal (1 subgoal):\n 1. finite {U \\<in> f ` X. P U}", "using finite_surj that"], ["proof (prove)\nusing this:\n  {d \\<in> f ` X. P d} \\<subseteq> f ` {c \\<in> X. P (f c)}\n  \\<lbrakk>finite ?A; ?B \\<subseteq> ?f ` ?A\\<rbrakk>\n  \\<Longrightarrow> finite ?B\n  finite {x \\<in> X. P (f x)}\n\ngoal (1 subgoal):\n 1. finite {U \\<in> f ` X. P U}", "by blast"], ["proof (state)\nthis:\n  finite {U \\<in> f ` X. P U}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma plus_compose: \"(x + y) \\<circ> f = (x \\<circ> f) + (y \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + y \\<circ> f = (x \\<circ> f) + (y \\<circ> f)", "by auto"], ["", "lemma mult_compose: \"(x * y) \\<circ> f = (x \\<circ> f) * (y \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<circ> f = (x \\<circ> f) * (y \\<circ> f)", "by auto"], ["", "lemma scaleR_compose: \"(c *\\<^sub>R x) \\<circ> f = c *\\<^sub>R (x \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>R x \\<circ> f = c *\\<^sub>R (x \\<circ> f)", "by (auto simp:)"], ["", "lemma image_scaleR_ball:\n  fixes a :: \"'a::real_normed_vector\"\n  shows \"c \\<noteq> 0 \\<Longrightarrow> (*\\<^sub>R) c ` ball a r = ball (c *\\<^sub>R a) (abs c *\\<^sub>R r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    (*\\<^sub>R) c ` ball a r =\n    ball (c *\\<^sub>R a) (\\<bar>c\\<bar> *\\<^sub>R r)", "proof (auto simp: mem_ball dist_norm, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>c \\<noteq> 0; norm (a - xa) < r\\<rbrakk>\n       \\<Longrightarrow> norm (c *\\<^sub>R a - c *\\<^sub>R xa)\n                         < \\<bar>c\\<bar> * r\n 2. \\<And>x.\n       \\<lbrakk>c \\<noteq> 0;\n        norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (*\\<^sub>R) c ` ball a r", "case (1 b)"], ["proof (state)\nthis:\n  c \\<noteq> 0\n  norm (a - b) < r\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>c \\<noteq> 0; norm (a - xa) < r\\<rbrakk>\n       \\<Longrightarrow> norm (c *\\<^sub>R a - c *\\<^sub>R xa)\n                         < \\<bar>c\\<bar> * r\n 2. \\<And>x.\n       \\<lbrakk>c \\<noteq> 0;\n        norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (*\\<^sub>R) c ` ball a r", "have \"norm (c *\\<^sub>R a - c *\\<^sub>R b)  = abs c * norm (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (c *\\<^sub>R a - c *\\<^sub>R b) = \\<bar>c\\<bar> * norm (a - b)", "by (auto simp: norm_scaleR[symmetric] algebra_simps simp del: norm_scaleR)"], ["proof (state)\nthis:\n  norm (c *\\<^sub>R a - c *\\<^sub>R b) = \\<bar>c\\<bar> * norm (a - b)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>c \\<noteq> 0; norm (a - xa) < r\\<rbrakk>\n       \\<Longrightarrow> norm (c *\\<^sub>R a - c *\\<^sub>R xa)\n                         < \\<bar>c\\<bar> * r\n 2. \\<And>x.\n       \\<lbrakk>c \\<noteq> 0;\n        norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (*\\<^sub>R) c ` ball a r", "also"], ["proof (state)\nthis:\n  norm (c *\\<^sub>R a - c *\\<^sub>R b) = \\<bar>c\\<bar> * norm (a - b)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>c \\<noteq> 0; norm (a - xa) < r\\<rbrakk>\n       \\<Longrightarrow> norm (c *\\<^sub>R a - c *\\<^sub>R xa)\n                         < \\<bar>c\\<bar> * r\n 2. \\<And>x.\n       \\<lbrakk>c \\<noteq> 0;\n        norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (*\\<^sub>R) c ` ball a r", "have \"\\<dots> < abs c * r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>c\\<bar> * norm (a - b) < \\<bar>c\\<bar> * r", "apply (rule mult_strict_left_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. norm (a - b) < r\n 2. 0 < \\<bar>c\\<bar>", "using 1"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  norm (a - b) < r\n\ngoal (2 subgoals):\n 1. norm (a - b) < r\n 2. 0 < \\<bar>c\\<bar>", "by auto"], ["proof (state)\nthis:\n  \\<bar>c\\<bar> * norm (a - b) < \\<bar>c\\<bar> * r\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>c \\<noteq> 0; norm (a - xa) < r\\<rbrakk>\n       \\<Longrightarrow> norm (c *\\<^sub>R a - c *\\<^sub>R xa)\n                         < \\<bar>c\\<bar> * r\n 2. \\<And>x.\n       \\<lbrakk>c \\<noteq> 0;\n        norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (*\\<^sub>R) c ` ball a r", "finally"], ["proof (chain)\npicking this:\n  norm (c *\\<^sub>R a - c *\\<^sub>R b) < \\<bar>c\\<bar> * r", "show ?case"], ["proof (prove)\nusing this:\n  norm (c *\\<^sub>R a - c *\\<^sub>R b) < \\<bar>c\\<bar> * r\n\ngoal (1 subgoal):\n 1. norm (c *\\<^sub>R a - c *\\<^sub>R b) < \\<bar>c\\<bar> * r", "."], ["proof (state)\nthis:\n  norm (c *\\<^sub>R a - c *\\<^sub>R b) < \\<bar>c\\<bar> * r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<noteq> 0;\n        norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (*\\<^sub>R) c ` ball a r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<noteq> 0;\n        norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (*\\<^sub>R) c ` ball a r", "case (2 x)"], ["proof (state)\nthis:\n  c \\<noteq> 0\n  norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<noteq> 0;\n        norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (*\\<^sub>R) c ` ball a r", "have \"norm (a - x /\\<^sub>R c) < r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (a - x /\\<^sub>R c) < r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm (a - x /\\<^sub>R c) < r", "have \"norm (a - x /\\<^sub>R c) = abs c *\\<^sub>R norm (a - x /\\<^sub>R c) /\\<^sub>R abs c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (a - x /\\<^sub>R c) =\n    \\<bar>c\\<bar> *\\<^sub>R norm (a - x /\\<^sub>R c) /\\<^sub>R \\<bar>c\\<bar>", "using 2"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\n\ngoal (1 subgoal):\n 1. norm (a - x /\\<^sub>R c) =\n    \\<bar>c\\<bar> *\\<^sub>R norm (a - x /\\<^sub>R c) /\\<^sub>R \\<bar>c\\<bar>", "by auto"], ["proof (state)\nthis:\n  norm (a - x /\\<^sub>R c) =\n  \\<bar>c\\<bar> *\\<^sub>R norm (a - x /\\<^sub>R c) /\\<^sub>R \\<bar>c\\<bar>\n\ngoal (1 subgoal):\n 1. norm (a - x /\\<^sub>R c) < r", "also"], ["proof (state)\nthis:\n  norm (a - x /\\<^sub>R c) =\n  \\<bar>c\\<bar> *\\<^sub>R norm (a - x /\\<^sub>R c) /\\<^sub>R \\<bar>c\\<bar>\n\ngoal (1 subgoal):\n 1. norm (a - x /\\<^sub>R c) < r", "have \"abs c *\\<^sub>R norm (a - x /\\<^sub>R c) = norm (c *\\<^sub>R a - x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>c\\<bar> *\\<^sub>R norm (a - x /\\<^sub>R c) =\n    norm (c *\\<^sub>R a - x)", "using 2"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\n\ngoal (1 subgoal):\n 1. \\<bar>c\\<bar> *\\<^sub>R norm (a - x /\\<^sub>R c) =\n    norm (c *\\<^sub>R a - x)", "by (auto simp: norm_scaleR[symmetric] algebra_simps simp del: norm_scaleR)"], ["proof (state)\nthis:\n  \\<bar>c\\<bar> *\\<^sub>R norm (a - x /\\<^sub>R c) =\n  norm (c *\\<^sub>R a - x)\n\ngoal (1 subgoal):\n 1. norm (a - x /\\<^sub>R c) < r", "also"], ["proof (state)\nthis:\n  \\<bar>c\\<bar> *\\<^sub>R norm (a - x /\\<^sub>R c) =\n  norm (c *\\<^sub>R a - x)\n\ngoal (1 subgoal):\n 1. norm (a - x /\\<^sub>R c) < r", "have \"\\<dots> < \\<bar>c\\<bar> * r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r", "by fact"], ["proof (state)\nthis:\n  norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\n\ngoal (1 subgoal):\n 1. norm (a - x /\\<^sub>R c) < r", "also"], ["proof (state)\nthis:\n  norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\n\ngoal (1 subgoal):\n 1. norm (a - x /\\<^sub>R c) < r", "have \"\\<bar>c\\<bar> * r /\\<^sub>R \\<bar>c\\<bar> = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>c\\<bar> * r /\\<^sub>R \\<bar>c\\<bar> = r", "using 2"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\n\ngoal (1 subgoal):\n 1. \\<bar>c\\<bar> * r /\\<^sub>R \\<bar>c\\<bar> = r", "by auto"], ["proof (state)\nthis:\n  \\<bar>c\\<bar> * r /\\<^sub>R \\<bar>c\\<bar> = r\n\ngoal (1 subgoal):\n 1. norm (a - x /\\<^sub>R c) < r", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x < y \\<Longrightarrow>\n      x /\\<^sub>R \\<bar>c\\<bar>\n      < y /\\<^sub>R \\<bar>c\\<bar>) \\<Longrightarrow>\n  norm (a - x /\\<^sub>R c) < r", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x < y \\<Longrightarrow>\n      x /\\<^sub>R \\<bar>c\\<bar>\n      < y /\\<^sub>R \\<bar>c\\<bar>) \\<Longrightarrow>\n  norm (a - x /\\<^sub>R c) < r\n\ngoal (1 subgoal):\n 1. norm (a - x /\\<^sub>R c) < r", "using 2"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x < y \\<Longrightarrow>\n      x /\\<^sub>R \\<bar>c\\<bar>\n      < y /\\<^sub>R \\<bar>c\\<bar>) \\<Longrightarrow>\n  norm (a - x /\\<^sub>R c) < r\n  c \\<noteq> 0\n  norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\n\ngoal (1 subgoal):\n 1. norm (a - x /\\<^sub>R c) < r", "by auto"], ["proof (state)\nthis:\n  norm (a - x /\\<^sub>R c) < r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm (a - x /\\<^sub>R c) < r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<noteq> 0;\n        norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (*\\<^sub>R) c ` ball a r", "then"], ["proof (chain)\npicking this:\n  norm (a - x /\\<^sub>R c) < r", "have xdc: \"x /\\<^sub>R c \\<in> ball a r\""], ["proof (prove)\nusing this:\n  norm (a - x /\\<^sub>R c) < r\n\ngoal (1 subgoal):\n 1. x /\\<^sub>R c \\<in> ball a r", "by (auto simp: mem_ball dist_norm)"], ["proof (state)\nthis:\n  x /\\<^sub>R c \\<in> ball a r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>c \\<noteq> 0;\n        norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (*\\<^sub>R) c ` ball a r", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (*\\<^sub>R) c ` ball a r", "apply (rule image_eqI[OF _ xdc])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = c *\\<^sub>R (x /\\<^sub>R c)", "using 2"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  norm (c *\\<^sub>R a - x) < \\<bar>c\\<bar> * r\n\ngoal (1 subgoal):\n 1. x = c *\\<^sub>R (x /\\<^sub>R c)", "by simp"], ["proof (state)\nthis:\n  x \\<in> (*\\<^sub>R) c ` ball a r\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Continuity\\<close>"], ["", "lemma continuous_within_topologicalE:\n  assumes \"continuous (at x within s) f\"\n    \"open B\" \"f x \\<in> B\"\n  obtains A where \"open A\" \"x \\<in> A\" \"\\<And>y. y \\<in> s \\<Longrightarrow> y \\<in> A \\<Longrightarrow> f y \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>open A; x \\<in> A;\n         \\<And>y.\n            \\<lbrakk>y \\<in> s; y \\<in> A\\<rbrakk>\n            \\<Longrightarrow> f y \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms continuous_within_topological"], ["proof (prove)\nusing this:\n  continuous (at x within s) f\n  open B\n  f x \\<in> B\n  continuous (at ?x within ?s) ?f =\n  (\\<forall>B.\n      open B \\<longrightarrow>\n      ?f ?x \\<in> B \\<longrightarrow>\n      (\\<exists>A.\n          open A \\<and>\n          ?x \\<in> A \\<and>\n          (\\<forall>y\\<in>?s. y \\<in> A \\<longrightarrow> ?f y \\<in> B)))\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>open A; x \\<in> A;\n         \\<And>y.\n            \\<lbrakk>y \\<in> s; y \\<in> A\\<rbrakk>\n            \\<Longrightarrow> f y \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["", "lemma continuous_within_topologicalE':\n  assumes \"continuous (at x) f\"\n    \"open B\" \"f x \\<in> B\"\n  obtains A where \"open A\" \"x \\<in> A\" \"f ` A \\<subseteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>open A; x \\<in> A; f ` A \\<subseteq> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms continuous_within_topologicalE[OF assms]"], ["proof (prove)\nusing this:\n  isCont f x\n  open B\n  f x \\<in> B\n  (\\<And>A.\n      \\<lbrakk>open A; x \\<in> A;\n       \\<And>y.\n          \\<lbrakk>y \\<in> UNIV; y \\<in> A\\<rbrakk>\n          \\<Longrightarrow> f y \\<in> B\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>open A; x \\<in> A; f ` A \\<subseteq> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis UNIV_I image_subsetI)"], ["", "lemma continuous_on_inverse: \"continuous_on S f \\<Longrightarrow> 0 \\<notin> f ` S \\<Longrightarrow> continuous_on S (\\<lambda>x. inverse (f x))\"\n  for f::\"_\\<Rightarrow>_::real_normed_div_algebra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>continuous_on S f; (0::'d) \\<notin> f ` S\\<rbrakk>\n    \\<Longrightarrow> continuous_on S (\\<lambda>x. inverse (f x))", "by (auto simp: continuous_on_def intro!: tendsto_inverse)"], ["", "subsection \\<open>@{term \"(has_derivative)\"}\\<close>"], ["", "lemma has_derivative_plus_fun[derivative_intros]:\n  \"(x + y has_derivative x' + y') (at a within A)\"\n  if [derivative_intros]:\n    \"(x has_derivative x') (at a within A)\"\n    \"(y has_derivative y') (at a within A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x + y has_derivative x' + y') (at a within A)", "by (auto simp: plus_fun_def intro!: derivative_eq_intros)"], ["", "lemma has_derivative_scaleR_fun[derivative_intros]:\n  \"(x *\\<^sub>R y has_derivative x *\\<^sub>R y') (at a within A)\"\n  if [derivative_intros]:\n    \"(y has_derivative y') (at a within A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x *\\<^sub>R y has_derivative x *\\<^sub>R y') (at a within A)", "by (auto simp: scaleR_fun_def intro!: derivative_eq_intros)"], ["", "lemma has_derivative_times_fun[derivative_intros]:\n  \"(x * y has_derivative (\\<lambda>h. x a * y' h + x' h * y a)) (at a within A)\"\n  if [derivative_intros]:\n    \"(x has_derivative x') (at a within A)\"\n    \"(y has_derivative y') (at a within A)\"\n  for x y::\"_\\<Rightarrow>'a::real_normed_algebra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y has_derivative (\\<lambda>h. x a * y' h + x' h * y a))\n     (at a within A)", "by (auto simp: times_fun_def intro!: derivative_eq_intros)"], ["", "lemma real_sqrt_has_derivative_generic:\n  \"x \\<noteq> 0 \\<Longrightarrow> (sqrt has_derivative (*) ((if x > 0 then 1 else -1) * inverse (sqrt x) / 2)) (at x within S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    (sqrt has_derivative\n     (*) ((if 0 < x then 1 else - 1) * inverse (sqrt x) / 2))\n     (at x within S)", "apply (rule has_derivative_at_withinI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    (sqrt has_derivative\n     (*) ((if 0 < x then 1 else - 1) * inverse (sqrt x) / 2))\n     (at x)", "using DERIV_real_sqrt_generic[of x \"(if x > 0 then 1 else -1) * inverse (sqrt x) / 2\"] at_within_open[of x \"UNIV - {0}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<noteq> 0;\n   0 < x \\<Longrightarrow>\n   (if 0 < x then 1 else - 1) * inverse (sqrt x) / 2 = inverse (sqrt x) / 2;\n   x < 0 \\<Longrightarrow>\n   (if 0 < x then 1 else - 1) * inverse (sqrt x) / 2 =\n   - inverse (sqrt x) / 2\\<rbrakk>\n  \\<Longrightarrow> (sqrt has_real_derivative\n                     (if 0 < x then 1 else - 1) * inverse (sqrt x) / 2)\n                     (at x)\n  \\<lbrakk>x \\<in> UNIV - {0}; open (UNIV - {0})\\<rbrakk>\n  \\<Longrightarrow> at x within UNIV - {0} = at x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    (sqrt has_derivative\n     (*) ((if 0 < x then 1 else - 1) * inverse (sqrt x) / 2))\n     (at x)", "by (auto simp: has_field_derivative_def open_delete ac_simps split: if_splits)"], ["", "lemma sqrt_has_derivative:\n  \"((\\<lambda>x. sqrt (f x)) has_derivative (\\<lambda>xa. (if 0 < f x then 1 else - 1) / (2 * sqrt (f x)) * f' xa)) (at x within S)\"\n  if \"(f has_derivative f') (at x within S)\" \"f x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sqrt (f x)) has_derivative\n     (\\<lambda>xa. (if 0 < f x then 1 else - 1) / (2 * sqrt (f x)) * f' xa))\n     (at x within S)", "by (rule has_derivative_eq_rhs[OF has_derivative_compose[OF that(1) real_sqrt_has_derivative_generic, OF that(2)]])\n    (auto simp: divide_simps)"], ["", "lemmas has_derivative_norm_compose[derivative_intros] = has_derivative_compose[OF _ has_derivative_norm]"], ["", "subsection \\<open>Differentiable\\<close>"], ["", "lemmas differentiable_on_empty[simp]"], ["", "lemma differentiable_transform_eventually: \"f differentiable (at x within X)\"\n  if \"g differentiable (at x within X)\"\n    \"f x = g x\"\n    \"\\<forall>\\<^sub>F x in (at x within X). f x = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f differentiable at x within X", "using that"], ["proof (prove)\nusing this:\n  g differentiable at x within X\n  f x = g x\n  \\<forall>\\<^sub>F x in at x within X. f x = g x\n\ngoal (1 subgoal):\n 1. f differentiable at x within X", "apply (auto simp: differentiable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D.\n       \\<lbrakk>f x = g x; \\<forall>\\<^sub>F x in at x within X. f x = g x;\n        (g has_derivative D) (at x within X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>D. (f has_derivative D) (at x within X)", "subgoal for D"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f x = g x; \\<forall>\\<^sub>F x in at x within X. f x = g x;\n     (g has_derivative D) (at x within X)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>D. (f has_derivative D) (at x within X)", "apply (rule exI[where x=D])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f x = g x; \\<forall>\\<^sub>F x in at x within X. f x = g x;\n     (g has_derivative D) (at x within X)\\<rbrakk>\n    \\<Longrightarrow> (f has_derivative D) (at x within X)", "apply (auto simp: has_derivative_within)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f x = g x; \\<forall>\\<^sub>F x in at x within X. f x = g x;\n     bounded_linear D;\n     ((\\<lambda>y.\n          (1 / norm (y - x)) *\\<^sub>R\n          (g y - (g x + D (y - x)))) \\<longlongrightarrow>\n      (0::'b))\n      (at x within X)\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>y.\n                           (1 / norm (y - x)) *\\<^sub>R\n                           (f y - (g x + D (y - x)))) \\<longlongrightarrow>\n                       (0::'b))\n                       (at x within X)", "by (simp add: eventually_mono Lim_transform_eventually)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma differentiable_within_eqI: \"f differentiable at x within X\"\n  if \"g differentiable at x within X\" \"\\<And>x. x \\<in> X \\<Longrightarrow> f x = g x\"\n    \"x \\<in> X\" \"open X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f differentiable at x within X", "apply (rule differentiable_transform_eventually)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?g differentiable at x within X\n 2. f x = ?g x\n 3. \\<forall>\\<^sub>F x in at x within X. f x = ?g x", "apply (rule that)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f x = g x\n 2. \\<forall>\\<^sub>F x in at x within X. f x = g x", "apply (auto simp: that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within X. f x = g x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within X. f x = g x", "have \"\\<forall>\\<^sub>F x in at x within X. x \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within X. x \\<in> X", "using \\<open>open X\\<close>"], ["proof (prove)\nusing this:\n  open X\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within X. x \\<in> X", "using eventually_at_topological"], ["proof (prove)\nusing this:\n  open X\n  eventually ?P (at ?a within ?s) =\n  (\\<exists>S.\n      open S \\<and>\n      ?a \\<in> S \\<and>\n      (\\<forall>x\\<in>S.\n          x \\<noteq> ?a \\<longrightarrow>\n          x \\<in> ?s \\<longrightarrow> ?P x))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within X. x \\<in> X", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x within X. x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within X. f x = g x", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at x within X. x \\<in> X", "show \" \\<forall>\\<^sub>F x in at x within X. f x = g x\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at x within X. x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at x within X. f x = g x", "by eventually_elim (auto simp: that)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at x within X. f x = g x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma differentiable_eqI: \"f differentiable at x\"\n  if \"g differentiable at x\" \"\\<And>x. x \\<in> X \\<Longrightarrow> f x = g x\" \"x \\<in> X\" \"open X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f differentiable at x", "using that"], ["proof (prove)\nusing this:\n  g differentiable at x\n  ?x \\<in> X \\<Longrightarrow> f ?x = g ?x\n  x \\<in> X\n  open X\n\ngoal (1 subgoal):\n 1. f differentiable at x", "unfolding at_within_open[OF that(3,4), symmetric]"], ["proof (prove)\nusing this:\n  g differentiable at x within X\n  ?x \\<in> X \\<Longrightarrow> f ?x = g ?x\n  x \\<in> X\n  open X\n\ngoal (1 subgoal):\n 1. f differentiable at x within X", "by (rule differentiable_within_eqI)"], ["", "lemma differentiable_on_eqI:\n  \"f differentiable_on S\"\n  if \"g differentiable_on S\" \"\\<And>x. x \\<in> S \\<Longrightarrow> f x = g x\" \"open S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f differentiable_on S", "using that differentiable_eqI[of g _ S f]"], ["proof (prove)\nusing this:\n  g differentiable_on S\n  ?x \\<in> S \\<Longrightarrow> f ?x = g ?x\n  open S\n  \\<lbrakk>g differentiable at ?x;\n   \\<And>x. x \\<in> S \\<Longrightarrow> f x = g x; ?x \\<in> S;\n   open S\\<rbrakk>\n  \\<Longrightarrow> f differentiable at ?x\n\ngoal (1 subgoal):\n 1. f differentiable_on S", "by (auto simp: differentiable_on_eq_differentiable_at)"], ["", "lemma differentiable_on_comp: \"(f o g) differentiable_on S\"\n  if \"g differentiable_on S\" \"f differentiable_on (g ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> g differentiable_on S", "using that"], ["proof (prove)\nusing this:\n  g differentiable_on S\n  f differentiable_on g ` S\n\ngoal (1 subgoal):\n 1. f \\<circ> g differentiable_on S", "by (auto simp: differentiable_on_def intro: differentiable_chain_within)"], ["", "lemma differentiable_on_comp2: \"(f o g) differentiable_on S\"\n  if  \"f differentiable_on T\" \"g differentiable_on S\" \"g ` S \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> g differentiable_on S", "apply (rule differentiable_on_comp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. g differentiable_on S\n 2. f differentiable_on g ` S", "apply (rule that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f differentiable_on g ` S", "apply (rule differentiable_on_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f differentiable_on ?t3\n 2. g ` S \\<subseteq> ?t3", "apply (rule that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. g ` S \\<subseteq> T", "apply (rule that)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas differentiable_on_compose2 = differentiable_on_comp2[unfolded o_def]"], ["", "lemma differentiable_on_openD: \"f differentiable at x\"\n  if \"f differentiable_on X\" \"open X\" \"x \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f differentiable at x", "using differentiable_on_eq_differentiable_at that"], ["proof (prove)\nusing this:\n  open ?s \\<Longrightarrow>\n  (?f differentiable_on ?s) = (\\<forall>x\\<in>?s. ?f differentiable at x)\n  f differentiable_on X\n  open X\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. f differentiable at x", "by blast"], ["", "lemma differentiable_on_add_fun[intro, simp]:\n  \"x differentiable_on UNIV \\<Longrightarrow> y differentiable_on UNIV \\<Longrightarrow> x + y differentiable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x differentiable_on UNIV; y differentiable_on UNIV\\<rbrakk>\n    \\<Longrightarrow> x + y differentiable_on UNIV", "by (auto simp: plus_fun_def)"], ["", "lemma differentiable_on_mult_fun[intro, simp]:\n  \"x differentiable_on UNIV \\<Longrightarrow> y differentiable_on UNIV \\<Longrightarrow> x * y differentiable_on UNIV\"\n  for x y::\"_\\<Rightarrow>'a::real_normed_algebra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x differentiable_on UNIV; y differentiable_on UNIV\\<rbrakk>\n    \\<Longrightarrow> x * y differentiable_on UNIV", "by (auto simp: times_fun_def)"], ["", "lemma differentiable_on_scaleR_fun[intro, simp]:\n  \"y differentiable_on UNIV \\<Longrightarrow> x *\\<^sub>R y differentiable_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y differentiable_on UNIV \\<Longrightarrow>\n    x *\\<^sub>R y differentiable_on UNIV", "by (auto simp: scaleR_fun_def)"], ["", "lemma sqrt_differentiable:\n  \"(\\<lambda>x. sqrt (f x)) differentiable (at x within S)\"\n  if \"f differentiable (at x within S)\" \"f x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. sqrt (f x)) differentiable at x within S", "using that"], ["proof (prove)\nusing this:\n  f differentiable at x within S\n  f x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. sqrt (f x)) differentiable at x within S", "using sqrt_has_derivative[of f _ x S]"], ["proof (prove)\nusing this:\n  f differentiable at x within S\n  f x \\<noteq> 0\n  \\<lbrakk>(f has_derivative ?f') (at x within S); f x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. sqrt (f x)) has_derivative\n                     (\\<lambda>xa.\n                         (if 0 < f x then 1 else - 1) / (2 * sqrt (f x)) *\n                         ?f' xa))\n                     (at x within S)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. sqrt (f x)) differentiable at x within S", "by (auto simp: differentiable_def)"], ["", "lemma sqrt_differentiable_on: \"(\\<lambda>x. sqrt (f x)) differentiable_on S\"\n  if \"f differentiable_on S\" \"0 \\<notin> f ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. sqrt (f x)) differentiable_on S", "using sqrt_differentiable[of f _ S] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>f differentiable at ?x within S; f ?x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. sqrt (f x)) differentiable at ?x within S\n  f differentiable_on S\n  0 \\<notin> f ` S\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. sqrt (f x)) differentiable_on S", "by (force simp: differentiable_on_def)"], ["", "lemma differentiable_on_inverse: \"f differentiable_on S \\<Longrightarrow> 0 \\<notin> f ` S \\<Longrightarrow> (\\<lambda>x. inverse (f x)) differentiable_on S\"\n  for f::\"_\\<Rightarrow>_::real_normed_field\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f differentiable_on S; (0::'d) \\<notin> f ` S\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. inverse (f x)) differentiable_on S", "by (auto simp: differentiable_on_def intro!: differentiable_inverse)"], ["", "lemma differentiable_on_openI:\n  \"f differentiable_on S\"\n  if \"open S\" \"\\<And>x. x \\<in> S \\<Longrightarrow> \\<exists>f'. (f has_derivative f') (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f differentiable_on S", "using that"], ["proof (prove)\nusing this:\n  open S\n  ?x \\<in> S \\<Longrightarrow> \\<exists>f'. (f has_derivative f') (at ?x)\n\ngoal (1 subgoal):\n 1. f differentiable_on S", "by (auto simp: differentiable_on_def at_within_open[where S=S] differentiable_def)"], ["", "lemmas differentiable_norm_compose_at = differentiable_compose[OF differentiable_norm_at]"], ["", "lemma differentiable_on_Pair:\n  \"f differentiable_on S \\<Longrightarrow> g differentiable_on S \\<Longrightarrow> (\\<lambda>x. (f x, g x)) differentiable_on S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f differentiable_on S; g differentiable_on S\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. (f x, g x)) differentiable_on S", "unfolding differentiable_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>S. f differentiable at x within S;\n     \\<forall>x\\<in>S. g differentiable at x within S\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>S.\n                         (\\<lambda>x. (f x, g x)) differentiable at x\n                         within S", "using differentiable_Pair[of f _ S g]"], ["proof (prove)\nusing this:\n  \\<lbrakk>f differentiable at ?x within S;\n   g differentiable at ?x within S\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. (f x, g x)) differentiable at ?x within S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>S. f differentiable at x within S;\n     \\<forall>x\\<in>S. g differentiable at x within S\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>S.\n                         (\\<lambda>x. (f x, g x)) differentiable at x\n                         within S", "by auto"], ["", "lemma differentiable_at_fst:\n  \"(\\<lambda>x. fst (f x)) differentiable at x within X\" if \"f differentiable at x within X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. fst (f x)) differentiable at x within X", "using that"], ["proof (prove)\nusing this:\n  f differentiable at x within X\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. fst (f x)) differentiable at x within X", "by (auto simp: differentiable_def dest!: has_derivative_fst)"], ["", "lemma differentiable_at_snd:\n  \"(\\<lambda>x. snd (f x)) differentiable at x within X\" if \"f differentiable at x within X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. snd (f x)) differentiable at x within X", "using that"], ["proof (prove)\nusing this:\n  f differentiable at x within X\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. snd (f x)) differentiable at x within X", "by (auto simp: differentiable_def dest!: has_derivative_snd)"], ["", "lemmas frechet_derivative_worksI = frechet_derivative_works[THEN iffD1]"], ["", "lemma sin_differentiable_at: \"(\\<lambda>x. sin (f x::real)) differentiable at x within X\"\n  if \"f differentiable at x within X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. sin (f x)) differentiable at x within X", "using differentiable_def has_derivative_sin that"], ["proof (prove)\nusing this:\n  (?f differentiable ?F) = (\\<exists>D. (?f has_derivative D) ?F)\n  (?g has_derivative ?g') (at ?x within ?s) \\<Longrightarrow>\n  ((\\<lambda>x. sin (?g x)) has_derivative\n   (\\<lambda>x. ?g' x * cos (?g ?x)))\n   (at ?x within ?s)\n  f differentiable at x within X\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. sin (f x)) differentiable at x within X", "by blast"], ["", "lemma cos_differentiable_at: \"(\\<lambda>x. cos (f x::real)) differentiable at x within X\"\n  if \"f differentiable at x within X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. cos (f x)) differentiable at x within X", "using differentiable_def has_derivative_cos that"], ["proof (prove)\nusing this:\n  (?f differentiable ?F) = (\\<exists>D. (?f has_derivative D) ?F)\n  (?g has_derivative ?g') (at ?x within ?s) \\<Longrightarrow>\n  ((\\<lambda>x. cos (?g x)) has_derivative\n   (\\<lambda>x. ?g' x * - sin (?g ?x)))\n   (at ?x within ?s)\n  f differentiable at x within X\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. cos (f x)) differentiable at x within X", "by blast"], ["", "subsection \\<open>Frechet derivative\\<close>"], ["", "lemmas frechet_derivative_transform_within_open_ext =\n  fun_cong[OF frechet_derivative_transform_within_open]"], ["", "lemmas frechet_derivative_at' = frechet_derivative_at[symmetric]"], ["", "lemma frechet_derivative_plus_fun:\n  \"x differentiable at a \\<Longrightarrow> y differentiable at a \\<Longrightarrow>\n  frechet_derivative (x + y) (at a) =\n    frechet_derivative x (at a) + frechet_derivative y (at a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x differentiable at a; y differentiable at a\\<rbrakk>\n    \\<Longrightarrow> frechet_derivative (x + y) (at a) =\n                      frechet_derivative x (at a) +\n                      frechet_derivative y (at a)", "by (rule frechet_derivative_at')\n    (auto intro!: derivative_eq_intros frechet_derivative_worksI)"], ["", "lemmas frechet_derivative_plus = frechet_derivative_plus_fun[unfolded plus_fun_def]"], ["", "lemma frechet_derivative_zero_fun: \"frechet_derivative 0 (at a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative 0 (at a) = 0", "by (auto simp: frechet_derivative_const zero_fun_def)"], ["", "lemma frechet_derivative_sin:\n  \"frechet_derivative (\\<lambda>x. sin (f x)) (at x) = (\\<lambda>xa. frechet_derivative f (at x) xa * cos (f x))\"\n  if \"f differentiable (at x)\"\n  for f::\"_\\<Rightarrow>real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative (\\<lambda>x. sin (f x)) (at x) =\n    (\\<lambda>xa. frechet_derivative f (at x) xa * cos (f x))", "by (rule frechet_derivative_at'[OF has_derivative_sin[OF frechet_derivative_worksI[OF that]]])"], ["", "lemma frechet_derivative_cos:\n  \"frechet_derivative (\\<lambda>x. cos (f x)) (at x) = (\\<lambda>xa. frechet_derivative f (at x) xa * - sin (f x))\"\n  if \"f differentiable (at x)\"\n  for f::\"_\\<Rightarrow>real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative (\\<lambda>x. cos (f x)) (at x) =\n    (\\<lambda>xa. frechet_derivative f (at x) xa * - sin (f x))", "by (rule frechet_derivative_at'[OF has_derivative_cos[OF frechet_derivative_worksI[OF that]]])"], ["", "lemma differentiable_sum_fun:\n  \"(\\<And>i. i \\<in> I \\<Longrightarrow> (f i differentiable at a)) \\<Longrightarrow> sum f I differentiable at a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> I \\<Longrightarrow>\n        f i differentiable at a) \\<Longrightarrow>\n    sum f I differentiable at a", "by (induction I rule: infinite_finite_induct) (auto simp: zero_fun_def plus_fun_def)"], ["", "lemma frechet_derivative_sum_fun:\n  \"(\\<And>i. i \\<in> I \\<Longrightarrow> (f i differentiable at a)) \\<Longrightarrow>\n  frechet_derivative (\\<Sum>i\\<in>I. f i) (at a) = (\\<Sum>i\\<in>I. frechet_derivative (f i) (at a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i \\<in> I \\<Longrightarrow>\n        f i differentiable at a) \\<Longrightarrow>\n    frechet_derivative (sum f I) (at a) =\n    (\\<Sum>i\\<in>I. frechet_derivative (f i) (at a))", "by (induction I rule: infinite_finite_induct)\n    (auto simp: frechet_derivative_zero_fun frechet_derivative_plus_fun differentiable_sum_fun)"], ["", "lemma sum_fun_def: \"(\\<Sum>i\\<in>I. f i) = (\\<lambda>x. \\<Sum>i\\<in>I. f i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f I = (\\<lambda>x. \\<Sum>i\\<in>I. f i x)", "by (induction I rule: infinite_finite_induct) auto"], ["", "lemmas frechet_derivative_sum = frechet_derivative_sum_fun[unfolded sum_fun_def]"], ["", "lemma frechet_derivative_times_fun:\n  \"f differentiable at a \\<Longrightarrow> g differentiable at a \\<Longrightarrow>\n  frechet_derivative (f * g) (at a) =\n  (\\<lambda>x. f a * frechet_derivative g (at a) x + frechet_derivative f (at a) x * g a)\"\n  for f g::\"_\\<Rightarrow>'a::real_normed_algebra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f differentiable at a; g differentiable at a\\<rbrakk>\n    \\<Longrightarrow> frechet_derivative (f * g) (at a) =\n                      (\\<lambda>x.\n                          f a * frechet_derivative g (at a) x +\n                          frechet_derivative f (at a) x * g a)", "by (rule frechet_derivative_at') (auto intro!: derivative_eq_intros frechet_derivative_worksI)"], ["", "lemmas frechet_derivative_times = frechet_derivative_times_fun[unfolded times_fun_def]"], ["", "lemma frechet_derivative_scaleR_fun:\n  \"y differentiable at a \\<Longrightarrow>\n  frechet_derivative (x *\\<^sub>R y) (at a) =\n    x *\\<^sub>R frechet_derivative y (at a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y differentiable at a \\<Longrightarrow>\n    frechet_derivative (x *\\<^sub>R y) (at a) =\n    x *\\<^sub>R frechet_derivative y (at a)", "by (rule frechet_derivative_at')\n    (auto intro!: derivative_eq_intros frechet_derivative_worksI)"], ["", "lemmas frechet_derivative_scaleR = frechet_derivative_scaleR_fun[unfolded scaleR_fun_def]"], ["", "lemma frechet_derivative_compose:\n  \"frechet_derivative (f o g) (at x) = frechet_derivative (f) (at (g x)) o frechet_derivative g (at x)\"\n  if \"g differentiable at x\" \"f differentiable at (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative (f \\<circ> g) (at x) =\n    frechet_derivative f (at (g x)) \\<circ> frechet_derivative g (at x)", "by (meson diff_chain_at frechet_derivative_at' frechet_derivative_works that)"], ["", "lemma frechet_derivative_compose_eucl:\n  \"frechet_derivative (f o g) (at x) =\n    (\\<lambda>v. \\<Sum>i\\<in>Basis. ((frechet_derivative g (at x) v) \\<bullet> i) *\\<^sub>R frechet_derivative f (at (g x)) i)\"\n  (is \"?l = ?r\")\n  if \"g differentiable at x\" \"f differentiable at (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative (f \\<circ> g) (at x) =\n    (\\<lambda>v.\n        \\<Sum>i\\<in>Basis.\n          (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n          frechet_derivative f (at (g x)) i)", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       frechet_derivative (f \\<circ> g) (at x) v =\n       (\\<Sum>i\\<in>Basis.\n          (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n          frechet_derivative f (at (g x)) i)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       frechet_derivative (f \\<circ> g) (at x) v =\n       (\\<Sum>i\\<in>Basis.\n          (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n          frechet_derivative f (at (g x)) i)", "interpret g: linear \"frechet_derivative g (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear (frechet_derivative g (at x))", "using that(1)"], ["proof (prove)\nusing this:\n  g differentiable at x\n\ngoal (1 subgoal):\n 1. linear (frechet_derivative g (at x))", "by (rule linear_frechet_derivative)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       frechet_derivative (f \\<circ> g) (at x) v =\n       (\\<Sum>i\\<in>Basis.\n          (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n          frechet_derivative f (at (g x)) i)", "interpret f: linear \"frechet_derivative f (at (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear (frechet_derivative f (at (g x)))", "using that(2)"], ["proof (prove)\nusing this:\n  f differentiable at (g x)\n\ngoal (1 subgoal):\n 1. linear (frechet_derivative f (at (g x)))", "by (rule linear_frechet_derivative)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       frechet_derivative (f \\<circ> g) (at x) v =\n       (\\<Sum>i\\<in>Basis.\n          (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n          frechet_derivative f (at (g x)) i)", "have \"frechet_derivative (f o g) (at x) v =\n    frechet_derivative f (at (g x)) (\\<Sum>i\\<in>Basis. (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative (f \\<circ> g) (at x) v =\n    frechet_derivative f (at (g x))\n     (\\<Sum>i\\<in>Basis.\n        (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R i)", "unfolding frechet_derivative_compose[OF that] o_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative f (at (g x)) (frechet_derivative g (at x) v) =\n    frechet_derivative f (at (g x))\n     (\\<Sum>i\\<in>Basis.\n        (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R i)", "by (simp add: euclidean_representation)"], ["proof (state)\nthis:\n  frechet_derivative (f \\<circ> g) (at x) v =\n  frechet_derivative f (at (g x))\n   (\\<Sum>i\\<in>Basis.\n      (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R i)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       frechet_derivative (f \\<circ> g) (at x) v =\n       (\\<Sum>i\\<in>Basis.\n          (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n          frechet_derivative f (at (g x)) i)", "also"], ["proof (state)\nthis:\n  frechet_derivative (f \\<circ> g) (at x) v =\n  frechet_derivative f (at (g x))\n   (\\<Sum>i\\<in>Basis.\n      (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R i)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       frechet_derivative (f \\<circ> g) (at x) v =\n       (\\<Sum>i\\<in>Basis.\n          (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n          frechet_derivative f (at (g x)) i)", "have \"\\<dots> = ?r v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative f (at (g x))\n     (\\<Sum>i\\<in>Basis.\n        (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R i) =\n    (\\<Sum>i\\<in>Basis.\n       (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n       frechet_derivative f (at (g x)) i)", "by (auto simp: g.sum g.scaleR f.sum f.scaleR)"], ["proof (state)\nthis:\n  frechet_derivative f (at (g x))\n   (\\<Sum>i\\<in>Basis.\n      (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R i) =\n  (\\<Sum>i\\<in>Basis.\n     (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n     frechet_derivative f (at (g x)) i)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       frechet_derivative (f \\<circ> g) (at x) v =\n       (\\<Sum>i\\<in>Basis.\n          (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n          frechet_derivative f (at (g x)) i)", "finally"], ["proof (chain)\npicking this:\n  frechet_derivative (f \\<circ> g) (at x) v =\n  (\\<Sum>i\\<in>Basis.\n     (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n     frechet_derivative f (at (g x)) i)", "show \"?l v = ?r v\""], ["proof (prove)\nusing this:\n  frechet_derivative (f \\<circ> g) (at x) v =\n  (\\<Sum>i\\<in>Basis.\n     (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n     frechet_derivative f (at (g x)) i)\n\ngoal (1 subgoal):\n 1. frechet_derivative (f \\<circ> g) (at x) v =\n    (\\<Sum>i\\<in>Basis.\n       (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n       frechet_derivative f (at (g x)) i)", "."], ["proof (state)\nthis:\n  frechet_derivative (f \\<circ> g) (at x) v =\n  (\\<Sum>i\\<in>Basis.\n     (frechet_derivative g (at x) v \\<bullet> i) *\\<^sub>R\n     frechet_derivative f (at (g x)) i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma frechet_derivative_works_on_open:\n  \"f differentiable_on X \\<Longrightarrow> open X \\<Longrightarrow> x \\<in> X \\<Longrightarrow>\n    (f has_derivative frechet_derivative f (at x)) (at x)\"\n  and frechet_derivative_works_on:\n  \"f differentiable_on X \\<Longrightarrow> x \\<in> X \\<Longrightarrow>\n    (f has_derivative frechet_derivative f (at x within X)) (at x within X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>f differentiable_on X; open X; x \\<in> X\\<rbrakk>\n     \\<Longrightarrow> (f has_derivative frechet_derivative f (at x))\n                        (at x)) &&&\n    (\\<lbrakk>f differentiable_on X; x \\<in> X\\<rbrakk>\n     \\<Longrightarrow> (f has_derivative\n                        frechet_derivative f (at x within X))\n                        (at x within X))", "by (auto simp: differentiable_onD differentiable_on_openD frechet_derivative_worksI)"], ["", "lemma frechet_derivative_inverse: \"frechet_derivative (\\<lambda>x. inverse (f x)) (at x) =\n    (\\<lambda>h. - 1 / (f x)\\<^sup>2 * frechet_derivative f (at x) h)\"\n  if \"f differentiable at x\" \"f x \\<noteq> 0\" for f::\"_\\<Rightarrow>_::real_normed_field\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative (\\<lambda>x. inverse (f x)) (at x) =\n    (\\<lambda>h. - (1::'d) / (f x)\\<^sup>2 * frechet_derivative f (at x) h)", "apply (rule frechet_derivative_at')"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse (f x)) has_derivative\n     (\\<lambda>h.\n         - (1::'d) / (f x)\\<^sup>2 * frechet_derivative f (at x) h))\n     (at x)", "using that"], ["proof (prove)\nusing this:\n  f differentiable at x\n  f x \\<noteq> (0::'d)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. inverse (f x)) has_derivative\n     (\\<lambda>h.\n         - (1::'d) / (f x)\\<^sup>2 * frechet_derivative f (at x) h))\n     (at x)", "by (auto intro!: derivative_eq_intros frechet_derivative_worksI\n      simp: divide_simps algebra_simps power2_eq_square)"], ["", "lemma frechet_derivative_sqrt: \"frechet_derivative (\\<lambda>x. sqrt (f x)) (at x) =\n  (\\<lambda>v. (if f x > 0 then 1 else -1) / (2 * sqrt (f x)) * frechet_derivative f (at x) v)\"\n  if \"f differentiable at x\" \"f x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative (\\<lambda>x. sqrt (f x)) (at x) =\n    (\\<lambda>v.\n        (if 0 < f x then 1 else - 1) / (2 * sqrt (f x)) *\n        frechet_derivative f (at x) v)", "apply (rule frechet_derivative_at')"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. sqrt (f x)) has_derivative\n     (\\<lambda>v.\n         (if 0 < f x then 1 else - 1) / (2 * sqrt (f x)) *\n         frechet_derivative f (at x) v))\n     (at x)", "apply (rule sqrt_has_derivative[THEN has_derivative_eq_rhs])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (f has_derivative ?f'3) (at x)\n 2. f x \\<noteq> 0\n 3. (\\<lambda>xa.\n        (if 0 < f x then 1 else - 1) / (2 * sqrt (f x)) * ?f'3 xa) =\n    (\\<lambda>v.\n        (if 0 < f x then 1 else - 1) / (2 * sqrt (f x)) *\n        frechet_derivative f (at x) v)", "by (auto intro!: frechet_derivative_worksI that simp: divide_simps)"], ["", "lemma frechet_derivative_norm: \"frechet_derivative (\\<lambda>x. norm (f x)) (at x) =\n    (\\<lambda>v. frechet_derivative f (at x) v \\<bullet> sgn (f x))\"\n  if \"f differentiable at x\" \"f x \\<noteq> 0\" \n  for f::\"_\\<Rightarrow>_::real_inner\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative (\\<lambda>x. norm (f x)) (at x) =\n    (\\<lambda>v. frechet_derivative f (at x) v \\<bullet> sgn (f x))", "apply (rule frechet_derivative_at')"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. norm (f x)) has_derivative\n     (\\<lambda>v. frechet_derivative f (at x) v \\<bullet> sgn (f x)))\n     (at x)", "by (auto intro!: derivative_eq_intros frechet_derivative_worksI that simp: divide_simps)"], ["", "lemma (in bounded_linear) frechet_derivative:\n  \"frechet_derivative f (at x) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative f (at x) = f", "apply (rule frechet_derivative_at')"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_derivative f) (at x)", "apply (rule has_derivative_eq_rhs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (f has_derivative ?f'2) (at x)\n 2. ?f'2 = f", "apply (rule has_derivative)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. x) has_derivative ?g'5) (at x)\n 2. (\\<lambda>x. f (?g'5 x)) = f", "by (auto intro!: derivative_eq_intros)"], ["", "bundle no_matrix_mult begin"], ["", "no_notation matrix_matrix_mult (infixl \"**\" 70)"], ["", "end"], ["", "lemma (in bounded_bilinear) frechet_derivative:\n  includes no_matrix_mult\n  shows\n    \"x differentiable at a \\<Longrightarrow> y differentiable at a \\<Longrightarrow>\n      frechet_derivative (\\<lambda>a. x a ** y a) (at a) =\n        (\\<lambda>h. x a ** frechet_derivative y (at a) h + frechet_derivative x (at a) h ** y a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x differentiable at a; y differentiable at a\\<rbrakk>\n    \\<Longrightarrow> frechet_derivative (\\<lambda>a. x a ** y a) (at a) =\n                      (\\<lambda>h.\n                          x a ** frechet_derivative y (at a) h +\n                          frechet_derivative x (at a) h ** y a)", "by (rule frechet_derivative_at') (auto intro!: FDERIV frechet_derivative_worksI)"], ["", "lemma frechet_derivative_divide: \"frechet_derivative (\\<lambda>x. f x / g x) (at x) =\n    (\\<lambda>h. frechet_derivative f (at x) h / (g x) -frechet_derivative g (at x) h * f x / (g x)\\<^sup>2)\"\n  if \"f differentiable at x\" \"g differentiable at x\" \"g x \\<noteq> 0\" for f::\"_\\<Rightarrow>_::real_normed_field\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative (\\<lambda>x. f x / g x) (at x) =\n    (\\<lambda>h.\n        frechet_derivative f (at x) h / g x -\n        frechet_derivative g (at x) h * f x / (g x)\\<^sup>2)", "using that"], ["proof (prove)\nusing this:\n  f differentiable at x\n  g differentiable at x\n  g x \\<noteq> (0::'d)\n\ngoal (1 subgoal):\n 1. frechet_derivative (\\<lambda>x. f x / g x) (at x) =\n    (\\<lambda>h.\n        frechet_derivative f (at x) h / g x -\n        frechet_derivative g (at x) h * f x / (g x)\\<^sup>2)", "by (auto simp: divide_inverse_commute bounded_bilinear.frechet_derivative[OF bounded_bilinear_mult]\n      frechet_derivative_inverse)"], ["", "lemma frechet_derivative_pair:\n  \"frechet_derivative (\\<lambda>x. (f x, g x)) (at x) = (\\<lambda>v. (frechet_derivative f (at x) v, frechet_derivative g (at x) v))\"\n  if \"f differentiable (at x)\" \"g differentiable (at x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative (\\<lambda>x. (f x, g x)) (at x) =\n    (\\<lambda>v.\n        (frechet_derivative f (at x) v, frechet_derivative g (at x) v))", "apply (rule frechet_derivative_at')"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (f x, g x)) has_derivative\n     (\\<lambda>v.\n         (frechet_derivative f (at x) v, frechet_derivative g (at x) v)))\n     (at x)", "apply (rule derivative_eq_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (f has_derivative ?f'3) (at x)\n 2. (g has_derivative ?g'3) (at x)\n 3. (\\<lambda>h. (?f'3 h, ?g'3 h)) =\n    (\\<lambda>v.\n        (frechet_derivative f (at x) v, frechet_derivative g (at x) v))", "apply (rule frechet_derivative_worksI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. f differentiable at x\n 2. (g has_derivative ?g'3) (at x)\n 3. (\\<lambda>h. (frechet_derivative f (at x) h, ?g'3 h)) =\n    (\\<lambda>v.\n        (frechet_derivative f (at x) v, frechet_derivative g (at x) v))", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. (g has_derivative ?g'3) (at x)\n 2. (\\<lambda>h. (frechet_derivative f (at x) h, ?g'3 h)) =\n    (\\<lambda>v.\n        (frechet_derivative f (at x) v, frechet_derivative g (at x) v))", "apply (rule frechet_derivative_worksI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. g differentiable at x\n 2. (\\<lambda>h.\n        (frechet_derivative f (at x) h, frechet_derivative g (at x) h)) =\n    (\\<lambda>v.\n        (frechet_derivative f (at x) v, frechet_derivative g (at x) v))", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>h.\n        (frechet_derivative f (at x) h, frechet_derivative g (at x) h)) =\n    (\\<lambda>v.\n        (frechet_derivative f (at x) v, frechet_derivative g (at x) v))", ".."], ["", "lemma frechet_derivative_fst:\n  \"frechet_derivative (\\<lambda>x. fst (f x)) (at x) = (\\<lambda>xa. fst (frechet_derivative f (at x) xa))\"\n  if \"(f differentiable at x)\"\n  for f::\"_\\<Rightarrow>(_::real_normed_vector \\<times> _::real_normed_vector)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative (\\<lambda>x. fst (f x)) (at x) =\n    (\\<lambda>xa. fst (frechet_derivative f (at x) xa))", "apply (rule frechet_derivative_at')"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. fst (f x)) has_derivative\n     (\\<lambda>xa. fst (frechet_derivative f (at x) xa)))\n     (at x)", "using that"], ["proof (prove)\nusing this:\n  f differentiable at x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. fst (f x)) has_derivative\n     (\\<lambda>xa. fst (frechet_derivative f (at x) xa)))\n     (at x)", "by (auto intro!: derivative_eq_intros frechet_derivative_worksI)"], ["", "lemma frechet_derivative_snd:\n  \"frechet_derivative (\\<lambda>x. snd (f x)) (at x) = (\\<lambda>xa. snd (frechet_derivative f (at x) xa))\"\n  if \"(f differentiable at x)\"\n  for f::\"_\\<Rightarrow>(_::real_normed_vector \\<times> _::real_normed_vector)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative (\\<lambda>x. snd (f x)) (at x) =\n    (\\<lambda>xa. snd (frechet_derivative f (at x) xa))", "apply (rule frechet_derivative_at')"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. snd (f x)) has_derivative\n     (\\<lambda>xa. snd (frechet_derivative f (at x) xa)))\n     (at x)", "using that"], ["proof (prove)\nusing this:\n  f differentiable at x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. snd (f x)) has_derivative\n     (\\<lambda>xa. snd (frechet_derivative f (at x) xa)))\n     (at x)", "by (auto intro!: derivative_eq_intros frechet_derivative_worksI)"], ["", "lemma frechet_derivative_eq_vector_derivative_1:\n  assumes \"f differentiable at t\"\n  shows \"frechet_derivative f (at t) 1 = vector_derivative f (at t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative f (at t) 1 = vector_derivative f (at t)", "apply (subst frechet_derivative_eq_vector_derivative)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f differentiable at t\n 2. 1 *\\<^sub>R vector_derivative f (at t) = vector_derivative f (at t)", "apply (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 *\\<^sub>R vector_derivative f (at t) = vector_derivative f (at t)", "by auto"], ["", "subsection \\<open>Linear algebra\\<close>"], ["", "lemma (in vector_space) dim_pos_finite_dimensional_vector_spaceE:\n  assumes \"dim (UNIV::'b set) > 0\"\n  obtains basis where \"finite_dimensional_vector_space scale basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>basis.\n        finite_dimensional_vector_space (*s) basis \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>basis.\n        finite_dimensional_vector_space (*s) basis \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  0 < local.dim UNIV", "obtain b where b: \"local.span b = local.span UNIV\" \"local.independent b\""], ["proof (prove)\nusing this:\n  0 < local.dim UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>local.span b = local.span UNIV;\n         local.independent b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: dim_def split: if_splits)"], ["proof (state)\nthis:\n  local.span b = local.span UNIV\n  local.independent b\n\ngoal (1 subgoal):\n 1. (\\<And>basis.\n        finite_dimensional_vector_space (*s) basis \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  local.span b = local.span UNIV\n  local.independent b", "have \"dim UNIV = card b\""], ["proof (prove)\nusing this:\n  local.span b = local.span UNIV\n  local.independent b\n\ngoal (1 subgoal):\n 1. local.dim UNIV = card b", "by (rule dim_eq_card)"], ["proof (state)\nthis:\n  local.dim UNIV = card b\n\ngoal (1 subgoal):\n 1. (\\<And>basis.\n        finite_dimensional_vector_space (*s) basis \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with assms"], ["proof (chain)\npicking this:\n  0 < local.dim UNIV\n  local.dim UNIV = card b", "have \"finite b\""], ["proof (prove)\nusing this:\n  0 < local.dim UNIV\n  local.dim UNIV = card b\n\ngoal (1 subgoal):\n 1. finite b", "by (auto simp: card_ge_0_finite)"], ["proof (state)\nthis:\n  finite b\n\ngoal (1 subgoal):\n 1. (\\<And>basis.\n        finite_dimensional_vector_space (*s) basis \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  finite b", "have \"finite_dimensional_vector_space scale b\""], ["proof (prove)\nusing this:\n  finite b\n\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space (*s) b", "by unfold_locales (auto simp: b)"], ["proof (state)\nthis:\n  finite_dimensional_vector_space (*s) b\n\ngoal (1 subgoal):\n 1. (\\<And>basis.\n        finite_dimensional_vector_space (*s) basis \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  finite_dimensional_vector_space (*s) b", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_dimensional_vector_space (*s) b\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "context vector_space_on begin"], ["", "context includes lifting_syntax assumes \"\\<exists>(Rep::'s \\<Rightarrow> 'b) (Abs::'b \\<Rightarrow> 's). type_definition Rep Abs S\" begin"], ["", "interpretation local_typedef_vector_space_on S scale \"TYPE('s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local_typedef_vector_space_on TYPE('s) S (*s)", "by unfold_locales fact"], ["", "lemmas_with [var_simplified explicit_ab_group_add,\n    unoverload_type 'd,\n    OF type.ab_group_add_axioms type_vector_space_on_with,\n    folded dim_S_def,\n    untransferred,\n    var_simplified implicit_ab_group_add]:\n    lt_dim_pos_finite_dimensional_vector_spaceE = vector_space.dim_pos_finite_dimensional_vector_spaceE"], ["", "end"], ["", "lemmas_with [cancel_type_definition,\n    OF S_ne,\n    folded subset_iff',\n    simplified pred_fun_def, folded finite_dimensional_vector_space_on_with,\n    simplified\\<comment>\\<open>too much?\\<close>]:\n    dim_pos_finite_dimensional_vector_spaceE = lt_dim_pos_finite_dimensional_vector_spaceE"], ["", "end"], ["", "subsection \\<open>Extensional function space\\<close>"], ["", "text \\<open>f is zero outside A. We use such functions to canonically represent\n  functions whose domain is A\\<close>"], ["", "definition extensional0 :: \"'a set \\<Rightarrow> ('a \\<Rightarrow> 'b::zero) \\<Rightarrow> bool\"\n  where \"extensional0 A f = (\\<forall>x. x \\<notin> A \\<longrightarrow> f x = 0)\""], ["", "lemma extensional0_0[intro, simp]: \"extensional0 X 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extensional0 X 0", "by (auto simp: extensional0_def)"], ["", "lemma extensional0_UNIV[intro, simp]: \"extensional0 UNIV f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extensional0 UNIV f", "by (auto simp: extensional0_def)"], ["", "lemma ext_extensional0:\n  \"f = g\" if \"extensional0 S f\" \"extensional0 S g\" \"\\<And>x. x \\<in> S \\<Longrightarrow> f x = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = g", "using that"], ["proof (prove)\nusing this:\n  extensional0 S f\n  extensional0 S g\n  ?x \\<in> S \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. f = g", "by (force simp: extensional0_def fun_eq_iff)"], ["", "lemma extensional0_add[intro, simp]:\n  \"extensional0 S f \\<Longrightarrow> extensional0 S g \\<Longrightarrow> extensional0 S (f + g::_\\<Rightarrow>'a::comm_monoid_add)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extensional0 S f; extensional0 S g\\<rbrakk>\n    \\<Longrightarrow> extensional0 S (f + g)", "by (auto simp: extensional0_def)"], ["", "lemma extensinoal0_mult[intro, simp]:\n  \"extensional0 S x \\<Longrightarrow> extensional0 S y \\<Longrightarrow> extensional0 S (x * y)\"\n  for x y::\"_\\<Rightarrow>'a::mult_zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extensional0 S x; extensional0 S y\\<rbrakk>\n    \\<Longrightarrow> extensional0 S (x * y)", "by (auto simp: extensional0_def)"], ["", "lemma extensional0_scaleR[intro, simp]: \"extensional0 S f \\<Longrightarrow> extensional0 S (c *\\<^sub>R f::_\\<Rightarrow>'a::real_vector)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extensional0 S f \\<Longrightarrow> extensional0 S (c *\\<^sub>R f)", "by (auto simp: extensional0_def)"], ["", "lemma extensional0_outside: \"x \\<notin> S \\<Longrightarrow> extensional0 S f \\<Longrightarrow> f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> S; extensional0 S f\\<rbrakk>\n    \\<Longrightarrow> f x = (0::'b)", "by (auto simp: extensional0_def)"], ["", "lemma subspace_extensional0: \"subspace (Collect (extensional0 X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace (Collect (extensional0 X))", "by (auto simp: subspace_def)"], ["", "text \\<open>Send the function f to its canonical representative as a function with domain A\\<close>"], ["", "definition restrict0 :: \"'a set \\<Rightarrow> ('a \\<Rightarrow> 'b::zero) \\<Rightarrow> 'a \\<Rightarrow> 'b\"\n  where \"restrict0 A f x = (if x \\<in> A then f x else 0)\""], ["", "lemma restrict0_UNIV[simp]: \"restrict0 UNIV = (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 UNIV = (\\<lambda>x. x)", "by (intro ext) (auto simp: restrict0_def)"], ["", "lemma extensional0_restrict0[intro, simp]: \"extensional0 A (restrict0 A f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extensional0 A (restrict0 A f)", "by (auto simp: extensional0_def restrict0_def)"], ["", "lemma restrict0_times: \"restrict0 A (x * y) = restrict0 A x * restrict0 A y\"\n  for x::\"'a\\<Rightarrow>'b::mult_zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 A (x * y) = restrict0 A x * restrict0 A y", "by (auto simp: restrict0_def[abs_def])"], ["", "lemma restrict0_apply_in[simp]: \"x \\<in> A \\<Longrightarrow> restrict0 A f x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow> restrict0 A f x = f x", "by (auto simp: restrict0_def)"], ["", "lemma restrict0_apply_out[simp]: \"x \\<notin> A \\<Longrightarrow> restrict0 A f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> A \\<Longrightarrow> restrict0 A f x = (0::'b)", "by (auto simp: restrict0_def)"], ["", "lemma restrict0_scaleR: \"restrict0 A (c *\\<^sub>R f::_\\<Rightarrow>'a::real_vector) = c *\\<^sub>R restrict0 A f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 A (c *\\<^sub>R f) = c *\\<^sub>R restrict0 A f", "by (auto simp: restrict0_def[abs_def])"], ["", "lemma restrict0_add: \"restrict0 A (f + g::_\\<Rightarrow>'a::real_vector) = restrict0 A f + restrict0 A g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 A (f + g) = restrict0 A f + restrict0 A g", "by (auto simp: restrict0_def[abs_def])"], ["", "lemma restrict0_restrict0: \"restrict0 X (restrict0 Y f) = restrict0 (X \\<inter> Y) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 X (restrict0 Y f) = restrict0 (X \\<inter> Y) f", "by (auto simp: restrict0_def)"], ["", "end"]]}