{"file_name": "/home/qj213/afp-2021-10-22/thys/Smooth_Manifolds/Projective_Space.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Smooth_Manifolds", "problem_names": ["lemma open_ne_zero: \"open {x::'a::t1_space. x \\<noteq> c}\"", "lemma open_nonzero_openin_transfer:\n  \"(rel_set (pcr_nonzero A) ===> (=)) (openin (top_of_set (Collect (Domainp (pcr_nonzero A))))) open\"\n  if \"is_equality A\"", "lemma scaleR_one_nonzero[simp]: \"1 *\\<^sub>R x = (x::_ nonzero)\"", "lemma scaleR_scaleR_nonzero[simp]: \"b \\<noteq> 0 \\<Longrightarrow> scaleR a (scaleR b x) = scaleR (a * b) (x::_ nonzero)\"", "lemma proj_rel_parametric: \"(pcr_nonzero A ===> pcr_nonzero A ===> (=)) proj_rel proj_rel\"\n  if [transfer_rule]: \" ((=) ===> pcr_nonzero A ===> pcr_nonzero A) (*\\<^sub>R) (*\\<^sub>R)\"\n    \"bi_unique A\"", "lemma surj_Proj: \"surj Proj\"", "lemma topspace_map_Proj: \"topspace (map_topology Proj euclidean) = UNIV\"", "lemma open_vimage_ProjI: \"open T \\<Longrightarrow> open (Proj -` T)\"", "lemma open_vimage_ProjD: \"open (Proj -` T) \\<Longrightarrow> open T\"", "lemma open_vimage_Proj_iff[simp]: \"open (Proj -` T) = open T\"", "lemma euclidean_proj_space_def: \"euclidean = map_topology Proj euclidean\"", "lemma continuous_on_proj_spaceI: \"continuous_on (S) f\" if \"continuous_on (Proj -` S) (f o Proj)\" \"open (S)\"\n  for f::\"_ proj_space \\<Rightarrow> _\"", "lemma saturate_eq: \"Proj -` Proj ` X = (\\<Union>c\\<in>UNIV-{0}. (*\\<^sub>R) c ` X)\"", "lemma open_scaling_nonzero: \"c \\<noteq> 0 \\<Longrightarrow> open s \\<Longrightarrow> open ((*\\<^sub>R) c ` s::'a::euclidean_space nonzero set)\"", "lemma Proj_open_map: \"open (Proj ` X)\" if \"open X\"", "lemma proj_rel_transfer[transfer_rule]:\n  \"(pcr_nonzero A ===> pcr_nonzero A ===> (=))  (\\<lambda>x a. \\<exists>c. a = sr c x \\<and> c \\<noteq> 0) proj_rel\"\n  if [transfer_rule]: \"((=) ===> pcr_nonzero A ===> pcr_nonzero A) sr (*\\<^sub>R)\"\n    \"bi_unique A\"", "lemma bool_aux: \"a \\<and> (a \\<longrightarrow> b) \\<longleftrightarrow> a \\<and> b\"", "lemma closed_proj_rel: \"closed {(x::'a::euclidean_space nonzero, y::'a nonzero). proj_rel x y}\"", "lemma closed_Proj_rel: \"closed {(x, y). Proj x = Proj y}\"", "lemma chart_last_nonzero_scaleR[simp]: \"c \\<noteq> 0 \\<Longrightarrow> chart_last_nonzero (c *\\<^sub>R n) = chart_last_nonzero n\"", "lemma open_chart_last_domain: \"open (Collect chart_last_domainP)\"", "lemma Proj_vimage_chart_last_domainP: \"Proj -` Collect chart_last_domainP = Collect (chart_last_domain_nonzeroP)\"", "lemma chart_last_continuous:\n  notes [transfer_rule] = open_nonzero_openin_transfer\n  shows \"continuous_on (Collect chart_last_domainP) chart_last\"", "lemma chart_last_inv_continuous:\n  notes [transfer_rule] = open_nonzero_openin_transfer\n  shows \"continuous_on UNIV chart_last_inv\"", "lemma proj_rel_iff: \"proj_rel a b \\<longleftrightarrow> (\\<exists>c\\<noteq>0. b = c *\\<^sub>R a)\"", "lemma chart_last_inverse: \"chart_last_inv (chart_last x) = x\" if \"chart_last_domainP x\"", "lemma chart_last_inv_inverse: \"chart_last (chart_last_inv x) = x\"", "lemma chart_last_domainP_chart_last_inv: \"chart_last_domainP (chart_last_inv x)\"", "lemma homeomorphism_chart_last:\n  \"homeomorphism (Collect chart_last_domainP) UNIV chart_last chart_last_inv\"", "lemma Proj_vimage_chart_basis_domainP:\n  \"Proj -` Collect (chart_basis_domainP b) = Collect (chart_basis_domain_nonzeroP b)\"", "lemma open_chart_basis_domain: \"open (Collect (chart_basis_domainP b))\"", "lemma chart_basis_continuous:\n  notes [transfer_rule] = open_nonzero_openin_transfer\n  shows \"continuous_on (Collect (chart_basis_domainP b)) (chart_basis b)\"", "lemma b_neq0: \"b \\<noteq> 0\"", "lemma chart_basis_inv_continuous:\n  notes [transfer_rule] = open_nonzero_openin_transfer\n  shows \"continuous_on UNIV chart_basis_inv\"", "lemma chart_basis_inv_inverse: \"chart_basis b (chart_basis_inv x) = x\"", "lemma chart_basis_inverse: \"chart_basis_inv (chart_basis b x) = x\" if \"chart_basis_domainP b x\"", "lemma chart_basis_domainP_chart_basis_inv: \"chart_basis_domainP b (chart_basis_inv x)\"", "lemma homeomorphism_chart_basis:\n  \"homeomorphism (Collect (chart_basis_domainP b)) UNIV (chart_basis b) chart_basis_inv\"", "lemma chart_last_basis_defined:\n  \"chart_last_domainP xa \\<Longrightarrow> chart_basis_domainP b xa \\<Longrightarrow> chart_last xa \\<bullet> b \\<noteq> 0\"", "lemma chart_basis_last_defined:\n  \"b \\<in> Basis \\<Longrightarrow> chart_last_domainP xa \\<Longrightarrow> chart_basis_domainP b xa \\<Longrightarrow> chart_basis b xa \\<bullet> b \\<noteq> 0\"", "lemma compat_last_chart: \"\\<infinity>-smooth_compat last_chart (basis_chart b)\"\n  if [transfer_rule]: \"b \\<in> Basis\"", "lemma smooth_on_basis_comp_inv: \"smooth_on {x. (x + (1 - x \\<bullet> a) *\\<^sub>R a) \\<bullet> b \\<noteq> 0} (chart_basis b \\<circ> chart_basis_inv a)\"\n  if [transfer_rule]: \"a \\<in> Basis\" \"b \\<in> Basis\"", "lemma chart_basis_basis_defined:\n  \"a \\<noteq> b \\<Longrightarrow> chart_basis_domainP a xa \\<Longrightarrow> chart_basis_domainP b xa \\<Longrightarrow> chart_basis a xa \\<bullet> b \\<noteq> 0\"\n  if \"a \\<in> Basis\" \"b \\<in> Basis\"", "lemma compat_basis_chart: \"\\<infinity>-smooth_compat (basis_chart a) (basis_chart b)\"\n  if [transfer_rule]: \"a \\<in> Basis\" \"b \\<in> Basis\"", "lemma c_manifold_proj_space: \"c_manifold charts_proj_space \\<infinity>\""], "translations": [["", "lemma open_ne_zero: \"open {x::'a::t1_space. x \\<noteq> c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open {x. x \\<noteq> c}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. open {x. x \\<noteq> c}", "have \"{x::'a. x \\<noteq> c} = UNIV - {c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x \\<noteq> c} = UNIV - {c}", "by auto"], ["proof (state)\nthis:\n  {x. x \\<noteq> c} = UNIV - {c}\n\ngoal (1 subgoal):\n 1. open {x. x \\<noteq> c}", "also"], ["proof (state)\nthis:\n  {x. x \\<noteq> c} = UNIV - {c}\n\ngoal (1 subgoal):\n 1. open {x. x \\<noteq> c}", "have \"open \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (UNIV - {c})", "by (rule open_delete; rule open_UNIV)"], ["proof (state)\nthis:\n  open (UNIV - {c})\n\ngoal (1 subgoal):\n 1. open {x. x \\<noteq> c}", "finally"], ["proof (chain)\npicking this:\n  open {x. x \\<noteq> c}", "show ?thesis"], ["proof (prove)\nusing this:\n  open {x. x \\<noteq> c}\n\ngoal (1 subgoal):\n 1. open {x. x \\<noteq> c}", "."], ["proof (state)\nthis:\n  open {x. x \\<noteq> c}\n\ngoal:\nNo subgoals!", "qed"], ["", "typedef (overloaded) 'a::euclidean_space nonzero = \"UNIV - {0::'a::euclidean_space}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV - {0::'a}", "by auto"], ["", "setup_lifting type_definition_nonzero"], ["", "instantiation nonzero :: (euclidean_space) topological_space\nbegin"], ["", "lift_definition open_nonzero::\"'a nonzero set \\<Rightarrow> bool\" is \"open::'a set \\<Rightarrow> bool\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nonzero, topological_space_class)", "apply standard"], ["proof (prove)\ngoal (3 subgoals):\n 1. open UNIV\n 2. \\<And>S T.\n       \\<lbrakk>open S; open T\\<rbrakk>\n       \\<Longrightarrow> open (S \\<inter> T)\n 3. \\<And>K. \\<forall>S\\<in>K. open S \\<Longrightarrow> open (\\<Union> K)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. open UNIV", "by transfer (auto simp: open_ne_zero)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S T.\n       \\<lbrakk>open S; open T\\<rbrakk>\n       \\<Longrightarrow> open (S \\<inter> T)\n 2. \\<And>K. \\<forall>S\\<in>K. open S \\<Longrightarrow> open (\\<Union> K)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>open S_; open T_\\<rbrakk>\n    \\<Longrightarrow> open (S_ \\<inter> T_)", "by transfer auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>K. \\<forall>S\\<in>K. open S \\<Longrightarrow> open (\\<Union> K)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S\\<in>K_. open S \\<Longrightarrow> open (\\<Union> K_)", "by transfer auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma open_nonzero_openin_transfer:\n  \"(rel_set (pcr_nonzero A) ===> (=)) (openin (top_of_set (Collect (Domainp (pcr_nonzero A))))) open\"\n  if \"is_equality A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (pcr_nonzero A) ===> (=))\n     (openin (top_of_set (Collect (Domainp (pcr_nonzero A))))) open", "unfolding is_equality_def[THEN iffD1, OF that]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (pcr_nonzero (=)) ===> (=))\n     (openin (top_of_set (Collect (Domainp (pcr_nonzero (=)))))) open", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_set (pcr_nonzero (=)) x y \\<Longrightarrow>\n       openin (top_of_set (Collect (Domainp (pcr_nonzero (=))))) x = open y", "fix X::\"'a set\" and Y::\"'a nonzero set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_set (pcr_nonzero (=)) x y \\<Longrightarrow>\n       openin (top_of_set (Collect (Domainp (pcr_nonzero (=))))) x = open y", "assume t[transfer_rule]: \"rel_set (pcr_nonzero (=)) X Y\""], ["proof (state)\nthis:\n  rel_set (pcr_nonzero (=)) X Y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_set (pcr_nonzero (=)) x y \\<Longrightarrow>\n       openin (top_of_set (Collect (Domainp (pcr_nonzero (=))))) x = open y", "show \"openin (top_of_set (Collect (Domainp (pcr_nonzero (=))))) X = open Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (top_of_set (Collect (Domainp (pcr_nonzero (=))))) X = open Y", "apply (auto simp: openin_subtopology)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>T.\n       \\<lbrakk>open T;\n        X = T \\<inter> Collect (Domainp (pcr_nonzero (=)))\\<rbrakk>\n       \\<Longrightarrow> open Y\n 2. open Y \\<Longrightarrow>\n    \\<exists>T.\n       open T \\<and> X = T \\<inter> Collect (Domainp (pcr_nonzero (=)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>open T_;\n     X = T_ \\<inter> Collect (Domainp (pcr_nonzero (=)))\\<rbrakk>\n    \\<Longrightarrow> open Y", "by transfer (auto simp: nonzero.domain_eq open_ne_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. open Y \\<Longrightarrow>\n    \\<exists>T.\n       open T \\<and> X = T \\<inter> Collect (Domainp (pcr_nonzero (=)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. open Y \\<Longrightarrow>\n    \\<exists>T.\n       open T \\<and> X = T \\<inter> Collect (Domainp (pcr_nonzero (=)))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. open X \\<Longrightarrow>\n    \\<exists>T.\n       open T \\<and> X = T \\<inter> Collect (Domainp (pcr_nonzero (=)))", "apply (rule exI[where x=X])"], ["proof (prove)\ngoal (1 subgoal):\n 1. open X \\<Longrightarrow>\n    open X \\<and> X = X \\<inter> Collect (Domainp (pcr_nonzero (=)))", "using t"], ["proof (prove)\nusing this:\n  rel_set (pcr_nonzero (=)) X Y\n\ngoal (1 subgoal):\n 1. open X \\<Longrightarrow>\n    open X \\<and> X = X \\<inter> Collect (Domainp (pcr_nonzero (=)))", "by (auto simp: rel_set_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  openin (top_of_set (Collect (Domainp (pcr_nonzero (=))))) X = open Y\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation nonzero :: (euclidean_space) scaleR\nbegin"], ["", "lift_definition scaleR_nonzero::\"real \\<Rightarrow> 'a nonzero \\<Rightarrow> 'a nonzero\" is \"\\<lambda>c x. if c = 0 then One else c *\\<^sub>R x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>real a.\n       a \\<in> UNIV - {0::'a} \\<Longrightarrow>\n       (if real = 0 then One else real *\\<^sub>R a) \\<in> UNIV - {0::'a}", "by auto"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nonzero, scaleR_class)", ".."], ["", "end"], ["", "instantiation nonzero :: (euclidean_space) plus\nbegin"], ["", "lift_definition plus_nonzero::\"'a nonzero \\<Rightarrow> 'a nonzero \\<Rightarrow> 'a nonzero\" is \"\\<lambda>x y. if x + y = 0 then One else x + y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> UNIV - {0::'a}; a2 \\<in> UNIV - {0::'a}\\<rbrakk>\n       \\<Longrightarrow> (if a1 + a2 = (0::'a) then One else a1 + a2)\n                         \\<in> UNIV - {0::'a}", "by auto"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nonzero, plus_class)", ".."], ["", "end"], ["", "instantiation nonzero :: (euclidean_space) minus\nbegin"], ["", "lift_definition minus_nonzero::\"'a nonzero \\<Rightarrow> 'a nonzero \\<Rightarrow> 'a nonzero\" is \"\\<lambda>x y. if x = y then One else x - y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>a1 \\<in> UNIV - {0::'a}; a2 \\<in> UNIV - {0::'a}\\<rbrakk>\n       \\<Longrightarrow> (if a1 = a2 then One else a1 - a2)\n                         \\<in> UNIV - {0::'a}", "by auto"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nonzero, minus_class)", ".."], ["", "end"], ["", "instantiation nonzero :: (euclidean_space) dist\nbegin"], ["", "lift_definition dist_nonzero::\"'a nonzero \\<Rightarrow> 'a nonzero \\<Rightarrow> real\" is dist"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nonzero, dist_class)", ".."], ["", "end"], ["", "instantiation nonzero :: (euclidean_space) norm\nbegin"], ["", "lift_definition norm_nonzero::\"'a nonzero \\<Rightarrow> real\" is norm"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nonzero, norm_class)", ".."], ["", "end"], ["", "instance nonzero :: (euclidean_space) t2_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nonzero, t2_space_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x \\<noteq> y \\<Longrightarrow>\n       \\<exists>U V.\n          open U \\<and>\n          open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV - {0::'a}; y \\<in> UNIV - {0::'a};\n        x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>U\\<in>{A.\n   \\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n                            \\<exists>V\\<in>{A.\n      \\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n                               open U \\<and>\n                               open V \\<and>\n                               x \\<in> U \\<and>\n                               y \\<in> V \\<and> U \\<inter> V = {}", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> UNIV - {0::'a}; y \\<in> UNIV - {0::'a};\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>U\\<in>{A.\n\\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n                         \\<exists>V\\<in>{A.\n   \\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n                            open U \\<and>\n                            open V \\<and>\n                            x \\<in> U \\<and>\n                            y \\<in> V \\<and> U \\<inter> V = {}", "using hausdorff[of x y]"], ["proof (prove)\nusing this:\n  x \\<noteq> y \\<Longrightarrow>\n  \\<exists>U V.\n     open U \\<and>\n     open V \\<and> x \\<in> U \\<and> y \\<in> V \\<and> U \\<inter> V = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> UNIV - {0::'a}; y \\<in> UNIV - {0::'a};\n     x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>U\\<in>{A.\n\\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n                         \\<exists>V\\<in>{A.\n   \\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n                            open U \\<and>\n                            open V \\<and>\n                            x \\<in> U \\<and>\n                            y \\<in> V \\<and> U \\<inter> V = {}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>U V.\n       \\<lbrakk>x \\<noteq> (0::'a); y \\<noteq> (0::'a); x \\<noteq> y;\n        open U; open V; x \\<in> U; y \\<in> V; U \\<inter> V = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>U.\n                            (\\<forall>x\\<in>U. x \\<noteq> (0::'a)) \\<and>\n                            open U \\<and>\n                            (\\<exists>V.\n                                (\\<forall>x\\<in>V.\n                                    x \\<noteq> (0::'a)) \\<and>\n                                open V \\<and>\n                                x \\<in> U \\<and>\n                                y \\<in> V \\<and> U \\<inter> V = {})", "subgoal for U V"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> (0::'a); y \\<noteq> (0::'a); x \\<noteq> y; open U;\n     open V; x \\<in> U; y \\<in> V; U \\<inter> V = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>U.\n                         (\\<forall>x\\<in>U. x \\<noteq> (0::'a)) \\<and>\n                         open U \\<and>\n                         (\\<exists>V.\n                             (\\<forall>x\\<in>V. x \\<noteq> (0::'a)) \\<and>\n                             open V \\<and>\n                             x \\<in> U \\<and>\n                             y \\<in> V \\<and> U \\<inter> V = {})", "apply (rule exI[where x=\"U - {0}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> (0::'a); y \\<noteq> (0::'a); x \\<noteq> y; open U;\n     open V; x \\<in> U; y \\<in> V; U \\<inter> V = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x\\<in>U - {0::'a}.\n                          x \\<noteq> (0::'a)) \\<and>\n                      open (U - {0::'a}) \\<and>\n                      (\\<exists>V.\n                          (\\<forall>x\\<in>V. x \\<noteq> (0::'a)) \\<and>\n                          open V \\<and>\n                          x \\<in> U - {0::'a} \\<and>\n                          y \\<in> V \\<and> (U - {0::'a}) \\<inter> V = {})", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> (0::'a); y \\<noteq> (0::'a); x \\<noteq> y; open U;\n     open V; x \\<in> U; y \\<in> V; U \\<inter> V = {}\\<rbrakk>\n    \\<Longrightarrow> open (U - {0::'a}) \\<and>\n                      (\\<exists>V.\n                          (\\<forall>x\\<in>V. x \\<noteq> (0::'a)) \\<and>\n                          open V \\<and>\n                          y \\<in> V \\<and> (U - {0::'a}) \\<inter> V = {})", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> (0::'a); y \\<noteq> (0::'a); x \\<noteq> y; open U;\n     open V; x \\<in> U; y \\<in> V; U \\<inter> V = {}\\<rbrakk>\n    \\<Longrightarrow> open (U - {0::'a})\n 2. \\<lbrakk>x \\<noteq> (0::'a); y \\<noteq> (0::'a); x \\<noteq> y; open U;\n     open V; x \\<in> U; y \\<in> V; U \\<inter> V = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>V.\n                         (\\<forall>x\\<in>V. x \\<noteq> (0::'a)) \\<and>\n                         open V \\<and>\n                         y \\<in> V \\<and> (U - {0::'a}) \\<inter> V = {}", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> (0::'a); y \\<noteq> (0::'a); x \\<noteq> y; open U;\n     open V; x \\<in> U; y \\<in> V; U \\<inter> V = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>V.\n                         (\\<forall>x\\<in>V. x \\<noteq> (0::'a)) \\<and>\n                         open V \\<and>\n                         y \\<in> V \\<and> (U - {0::'a}) \\<inter> V = {}\n 2. \\<lbrakk>x \\<noteq> (0::'a); y \\<noteq> (0::'a); x \\<noteq> y; open U;\n     open V; x \\<in> U; y \\<in> V; U \\<inter> V = {}\\<rbrakk>\n    \\<Longrightarrow> open (U - {0::'a})", "apply (rule exI[where x=\"V - {0}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> (0::'a); y \\<noteq> (0::'a); x \\<noteq> y; open U;\n     open V; x \\<in> U; y \\<in> V; U \\<inter> V = {}\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x\\<in>V - {0::'a}.\n                          x \\<noteq> (0::'a)) \\<and>\n                      open (V - {0::'a}) \\<and>\n                      y \\<in> V - {0::'a} \\<and>\n                      (U - {0::'a}) \\<inter> (V - {0::'a}) = {}\n 2. \\<lbrakk>x \\<noteq> (0::'a); y \\<noteq> (0::'a); x \\<noteq> y; open U;\n     open V; x \\<in> U; y \\<in> V; U \\<inter> V = {}\\<rbrakk>\n    \\<Longrightarrow> open (U - {0::'a})", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma scaleR_one_nonzero[simp]: \"1 *\\<^sub>R x = (x::_ nonzero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 *\\<^sub>R x = x", "by transfer auto"], ["", "lemma scaleR_scaleR_nonzero[simp]: \"b \\<noteq> 0 \\<Longrightarrow> scaleR a (scaleR b x) = scaleR (a * b) (x::_ nonzero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> 0 \\<Longrightarrow>\n    a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x", "by transfer auto"], ["", "instance nonzero :: (euclidean_space) second_countable_topology"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nonzero, second_countable_topology_class)", "proof standard"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "from ex_countable_basis[where 'a='a]"], ["proof (chain)\npicking this:\n  \\<exists>B. countable B \\<and> topological_basis B", "obtain A::\"'a set set\" where \"countable A\" \"topological_basis A\""], ["proof (prove)\nusing this:\n  \\<exists>B. countable B \\<and> topological_basis B\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>countable A; topological_basis A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  countable A\n  topological_basis A\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "define B where \"B = (\\<lambda>X. Abs_nonzero ` (X - {0})) ` A\""], ["proof (state)\nthis:\n  B = (\\<lambda>X. Abs_nonzero ` (X - {0::'a})) ` A\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "have [transfer_rule]: \"rel_set (rel_set (pcr_nonzero (=))) ((\\<lambda>X. X - {0})`A) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set (rel_set (pcr_nonzero (=))) ((\\<lambda>X. X - {0::'a}) ` A) B", "by (clarsimp simp: B_def rel_set_def pcr_nonzero_def OO_def cr_nonzero_def)\n      (metis Abs_nonzero_inverse Diff_iff UNIV_I singleton_iff)"], ["proof (state)\nthis:\n  rel_set (rel_set (pcr_nonzero (=))) ((\\<lambda>X. X - {0::'a}) ` A) B\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "from \\<open>topological_basis A\\<close>"], ["proof (chain)\npicking this:\n  topological_basis A", "have \"topological_basis B\""], ["proof (prove)\nusing this:\n  topological_basis A\n\ngoal (1 subgoal):\n 1. topological_basis B", "unfolding topological_basis_def"], ["proof (prove)\nusing this:\n  Ball A open \\<and>\n  (\\<forall>x.\n      open x \\<longrightarrow> (\\<exists>B'\\<subseteq>A. \\<Union> B' = x))\n\ngoal (1 subgoal):\n 1. Ball B open \\<and>\n    (\\<forall>x.\n        open x \\<longrightarrow> (\\<exists>B'\\<subseteq>B. \\<Union> B' = x))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball A open \\<and>\n    (\\<forall>x.\n        open x \\<longrightarrow>\n        (\\<exists>B'\\<subseteq>A. \\<Union> B' = x)) \\<Longrightarrow>\n    Ball ((\\<lambda>X. X - {0::'a}) ` A) open \\<and>\n    (\\<forall>x\\<in>{A. \\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n        open x \\<longrightarrow>\n        (\\<exists>B'\\<in>{A. \\<forall>A\\<in>A.\n                                \\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n            B' \\<subseteq> (\\<lambda>X. X - {0::'a}) ` A \\<and>\n            \\<Union> B' = x))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x X.\n       \\<lbrakk>Ball A open;\n        \\<forall>x.\n           open x \\<longrightarrow>\n           (\\<exists>B'\\<subseteq>A. \\<Union> B' = x);\n        X \\<in> A\\<rbrakk>\n       \\<Longrightarrow> open (X - {0::'a})\n 2. \\<And>x.\n       \\<lbrakk>Ball A open;\n        \\<forall>x.\n           open x \\<longrightarrow>\n           (\\<exists>B'\\<subseteq>A. \\<Union> B' = x);\n        \\<forall>x\\<in>x. x \\<in> UNIV - {0::'a}; open x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>{A.\n    \\<forall>A\\<in>A. \\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n                            B' \\<subseteq> (\\<lambda>X. X - {0::'a}) `\n     A \\<and>\n                            \\<Union> B' = x", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Ball A open;\n        \\<forall>x.\n           open x \\<longrightarrow>\n           (\\<exists>B'\\<subseteq>A. \\<Union> B' = x);\n        \\<forall>x\\<in>x. x \\<in> UNIV - {0::'a}; open x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'\\<in>{A.\n    \\<forall>A\\<in>A. \\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n                            B' \\<subseteq> (\\<lambda>X. X - {0::'a}) `\n     A \\<and>\n                            \\<Union> B' = x", "subgoal for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball A open;\n     \\<forall>x.\n        open x \\<longrightarrow> (\\<exists>B'\\<subseteq>A. \\<Union> B' = x);\n     \\<forall>x\\<in>X. x \\<in> UNIV - {0::'a}; open X\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B'\\<in>{A.\n \\<forall>A\\<in>A. \\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n                         B' \\<subseteq> (\\<lambda>X. X - {0::'a}) ` A \\<and>\n                         \\<Union> B' = X", "apply (drule spec[where x=X])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball A open; \\<forall>x\\<in>X. x \\<in> UNIV - {0::'a}; open X;\n     open X \\<longrightarrow>\n     (\\<exists>B'\\<subseteq>A. \\<Union> B' = X)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B'\\<in>{A.\n \\<forall>A\\<in>A. \\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n                         B' \\<subseteq> (\\<lambda>X. X - {0::'a}) ` A \\<and>\n                         \\<Union> B' = X", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B'.\n       \\<lbrakk>\\<forall>x\\<in>A. open x;\n        \\<forall>y\\<in>B'. \\<forall>x\\<in>y. x \\<noteq> (0::'a);\n        open (\\<Union> B'); B' \\<subseteq> A; X = \\<Union> B'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B'a.\n                            (\\<forall>A\\<in>B'a.\n                                \\<forall>x\\<in>A. x \\<noteq> (0::'a)) \\<and>\n                            B'a\n                            \\<subseteq> (\\<lambda>X. X - {0::'a}) ` A \\<and>\n                            \\<Union> B'a = \\<Union> B'", "subgoal for B'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>A. open x;\n     \\<forall>y\\<in>B'. \\<forall>x\\<in>y. x \\<noteq> (0::'a);\n     open (\\<Union> B'); B' \\<subseteq> A; X = \\<Union> B'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B'a.\n                         (\\<forall>A\\<in>B'a.\n                             \\<forall>x\\<in>A. x \\<noteq> (0::'a)) \\<and>\n                         B'a\n                         \\<subseteq> (\\<lambda>X. X - {0::'a}) ` A \\<and>\n                         \\<Union> B'a = \\<Union> B'", "apply (rule exI[where x=B'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>A. open x;\n     \\<forall>y\\<in>B'. \\<forall>x\\<in>y. x \\<noteq> (0::'a);\n     open (\\<Union> B'); B' \\<subseteq> A; X = \\<Union> B'\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>A\\<in>B'.\n                          \\<forall>x\\<in>A. x \\<noteq> (0::'a)) \\<and>\n                      B' \\<subseteq> (\\<lambda>X. X - {0::'a}) ` A \\<and>\n                      \\<Union> B' = \\<Union> B'", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  topological_basis B\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "then"], ["proof (chain)\npicking this:\n  topological_basis B", "show \"\\<exists>B::'a nonzero set set. countable B \\<and> open = generate_topology B\""], ["proof (prove)\nusing this:\n  topological_basis B\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "apply (intro exI[where x=B])"], ["proof (prove)\ngoal (1 subgoal):\n 1. topological_basis B \\<Longrightarrow>\n    countable B \\<and> open = generate_topology B", "by (auto simp add: B_def \\<open>countable A\\<close> topological_basis_imp_subbasis)"], ["proof (state)\nthis:\n  \\<exists>B. countable B \\<and> open = generate_topology B\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Quotient\\<close>"], ["", "inductive proj_rel :: \"'a::euclidean_space nonzero \\<Rightarrow> 'a nonzero \\<Rightarrow> bool\" for x where\n  \"c \\<noteq> 0 \\<Longrightarrow> proj_rel x (c *\\<^sub>R x)\""], ["", "lemma proj_rel_parametric: \"(pcr_nonzero A ===> pcr_nonzero A ===> (=)) proj_rel proj_rel\"\n  if [transfer_rule]: \" ((=) ===> pcr_nonzero A ===> pcr_nonzero A) (*\\<^sub>R) (*\\<^sub>R)\"\n    \"bi_unique A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_nonzero A ===> pcr_nonzero A ===> (=)) proj_rel proj_rel", "unfolding proj_rel.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_nonzero A ===> pcr_nonzero A ===> (=))\n     (\\<lambda>x a. \\<exists>c. a = c *\\<^sub>R x \\<and> c \\<noteq> 0)\n     (\\<lambda>x a. \\<exists>c. a = c *\\<^sub>R x \\<and> c \\<noteq> 0)", "by transfer_prover"], ["", "quotient_type (overloaded) 'a proj_space = \"('a::euclidean_space \\<times> real) nonzero\" /  proj_rel\n  morphisms rep_proj Proj\n    parametric proj_rel_parametric"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivp proj_rel", "proof (rule equivpI)"], ["proof (state)\ngoal (3 subgoals):\n 1. reflp proj_rel\n 2. symp proj_rel\n 3. transp proj_rel", "show \"reflp proj_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp proj_rel", "using proj_rel.intros[where c=1, simplified]"], ["proof (prove)\nusing this:\n  proj_rel ?x ?x\n\ngoal (1 subgoal):\n 1. reflp proj_rel", "by (auto simp: reflp_def)"], ["proof (state)\nthis:\n  reflp proj_rel\n\ngoal (2 subgoals):\n 1. symp proj_rel\n 2. transp proj_rel", "show \"symp proj_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symp proj_rel", "unfolding symp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. proj_rel x y \\<longrightarrow> proj_rel y x", "apply (auto elim!: proj_rel.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x c. c \\<noteq> 0 \\<Longrightarrow> proj_rel (c *\\<^sub>R x) x", "subgoal for x c"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow> proj_rel (c *\\<^sub>R x) x", "by (rule proj_rel.intros[of \"inverse c\" \"c *\\<^sub>R x\", simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  symp proj_rel\n\ngoal (1 subgoal):\n 1. transp proj_rel", "show \"transp proj_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp proj_rel", "unfolding transp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       proj_rel x y \\<longrightarrow>\n       proj_rel y z \\<longrightarrow> proj_rel x z", "by (auto elim!: proj_rel.cases intro!: proj_rel.intros)"], ["proof (state)\nthis:\n  transp proj_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma surj_Proj: \"surj Proj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj Proj", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> UNIV \\<Longrightarrow> Proj xa \\<in> UNIV\n 2. \\<And>x. x \\<in> UNIV \\<Longrightarrow> x \\<in> range Proj", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. xa_ \\<in> UNIV \\<Longrightarrow> Proj xa_ \\<in> UNIV", "by force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> x \\<in> range Proj", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> UNIV \\<Longrightarrow> x \\<in> range Proj", "by (induct x) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition proj_topology :: \"'a::euclidean_space proj_space topology\" where\n  \"proj_topology = map_topology Proj euclidean\""], ["", "instantiation proj_space :: (euclidean_space) topological_space\nbegin"], ["", "definition open_proj_space :: \"'a proj_space set \\<Rightarrow> bool\" where\n  \"open_proj_space = openin (map_topology Proj euclidean)\""], ["", "lemma topspace_map_Proj: \"topspace (map_topology Proj euclidean) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. topspace (map_topology Proj euclidean) = UNIV", "using surj_Proj"], ["proof (prove)\nusing this:\n  surj Proj\n\ngoal (1 subgoal):\n 1. topspace (map_topology Proj euclidean) = UNIV", "by auto"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a proj_space, topological_space_class)", "apply (rule class.Topological_Spaces.topological_space.of_class.intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.topological_space open", "unfolding open_proj_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.topological_space (openin (map_topology Proj euclidean))", "using surj_Proj"], ["proof (prove)\nusing this:\n  surj Proj\n\ngoal (1 subgoal):\n 1. class.topological_space (openin (map_topology Proj euclidean))", "by (rule topological_space_quotient)"], ["", "end"], ["", "lemma open_vimage_ProjI: \"open T \\<Longrightarrow> open (Proj -` T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open T \\<Longrightarrow> open (Proj -` T)", "by (metis inf_top.right_neutral open_openin open_proj_space_def openin_map_topology topspace_euclidean)"], ["", "lemma open_vimage_ProjD: \"open (Proj -` T) \\<Longrightarrow> open T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (Proj -` T) \\<Longrightarrow> open T", "by (metis inf_top.right_neutral open_openin open_proj_space_def openin_map_topology top.extremum topspace_euclidean topspace_map_Proj topspace_map_topology)"], ["", "lemma open_vimage_Proj_iff[simp]: \"open (Proj -` T) = open T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (Proj -` T) = open T", "by (auto simp: open_vimage_ProjI open_vimage_ProjD)"], ["", "lemma euclidean_proj_space_def: \"euclidean = map_topology Proj euclidean\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euclidean = map_topology Proj euclidean", "apply (auto simp: topology_eq_iff openin_map_topology)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> range Proj\n 2. \\<And>x xa.\n       \\<lbrakk>open x; xa \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> range Proj", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> range Proj", "by (induction x) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>open x; xa \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> range Proj", "subgoal for _ x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>open x_; x \\<in> x_\\<rbrakk>\n    \\<Longrightarrow> x \\<in> range Proj", "by (induction x) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma continuous_on_proj_spaceI: \"continuous_on (S) f\" if \"continuous_on (Proj -` S) (f o Proj)\" \"open (S)\"\n  for f::\"_ proj_space \\<Rightarrow> _\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on S f", "by (metis (no_types, hide_lams) continuous_on_open_vimage open_vimage_Proj_iff that vimage_Int vimage_comp)"], ["", "lemma saturate_eq: \"Proj -` Proj ` X = (\\<Union>c\\<in>UNIV-{0}. (*\\<^sub>R) c ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj -` Proj ` X = (\\<Union>c\\<in>UNIV - {0}. (*\\<^sub>R) c ` X)", "apply (auto simp: )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xb.\n       \\<lbrakk>Proj x = Proj xb; xb \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>UNIV - {0}.\n                            x \\<in> (*\\<^sub>R) xa ` X\n 2. \\<And>xa xb.\n       \\<lbrakk>xb \\<in> X;\n        Proj (xa *\\<^sub>R xb) \\<notin> Proj ` X\\<rbrakk>\n       \\<Longrightarrow> xa = 0", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Proj x = Proj y; y \\<in> X\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa\\<in>UNIV - {0}. x \\<in> (*\\<^sub>R) xa ` X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Proj x = Proj y; y \\<in> X\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa\\<in>UNIV - {0}. x \\<in> (*\\<^sub>R) xa ` X", "assume \"Proj x = Proj y\" \"y \\<in> X\""], ["proof (state)\nthis:\n  Proj x = Proj y\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Proj x = Proj y; y \\<in> X\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa\\<in>UNIV - {0}. x \\<in> (*\\<^sub>R) xa ` X", "then"], ["proof (chain)\npicking this:\n  Proj x = Proj y\n  y \\<in> X", "have \"proj_rel x y\""], ["proof (prove)\nusing this:\n  Proj x = Proj y\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. proj_rel x y", "using proj_space.abs_eq_iff"], ["proof (prove)\nusing this:\n  Proj x = Proj y\n  y \\<in> X\n  (Proj ?x = Proj ?y) = proj_rel ?x ?y\n\ngoal (1 subgoal):\n 1. proj_rel x y", "by auto"], ["proof (state)\nthis:\n  proj_rel x y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Proj x = Proj y; y \\<in> X\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa\\<in>UNIV - {0}. x \\<in> (*\\<^sub>R) xa ` X", "then"], ["proof (chain)\npicking this:\n  proj_rel x y", "show ?thesis"], ["proof (prove)\nusing this:\n  proj_rel x y\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>UNIV - {0}. x \\<in> (*\\<^sub>R) xa ` X", "using \\<open>y \\<in> X\\<close>"], ["proof (prove)\nusing this:\n  proj_rel x y\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>xa\\<in>UNIV - {0}. x \\<in> (*\\<^sub>R) xa ` X", "by (force elim!: proj_rel.cases intro!: bexI[where x=\"inverse c\" for c])"], ["proof (state)\nthis:\n  \\<exists>xa\\<in>UNIV - {0}. x \\<in> (*\\<^sub>R) xa ` X\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>xb \\<in> X;\n        Proj (xa *\\<^sub>R xb) \\<notin> Proj ` X\\<rbrakk>\n       \\<Longrightarrow> xa = 0", "subgoal for c x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X; Proj (c *\\<^sub>R x) \\<notin> Proj ` X\\<rbrakk>\n    \\<Longrightarrow> c = 0", "using proj_rel.intros[of c x]"], ["proof (prove)\nusing this:\n  c \\<noteq> 0 \\<Longrightarrow> proj_rel x (c *\\<^sub>R x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X; Proj (c *\\<^sub>R x) \\<notin> Proj ` X\\<rbrakk>\n    \\<Longrightarrow> c = 0", "by (metis imageI proj_space.abs_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma open_scaling_nonzero: \"c \\<noteq> 0 \\<Longrightarrow> open s \\<Longrightarrow> open ((*\\<^sub>R) c ` s::'a::euclidean_space nonzero set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<noteq> 0; open s\\<rbrakk>\n    \\<Longrightarrow> open ((*\\<^sub>R) c ` s)", "by transfer auto"], ["", "subsection \\<open>Proof of Hausdorff property\\<close>"], ["", "lemma Proj_open_map: \"open (Proj ` X)\" if \"open X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (Proj ` X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. open (Proj ` X)", "note saturate_eq[of X]"], ["proof (state)\nthis:\n  Proj -` Proj ` X = (\\<Union>c\\<in>UNIV - {0}. (*\\<^sub>R) c ` X)\n\ngoal (1 subgoal):\n 1. open (Proj ` X)", "also"], ["proof (state)\nthis:\n  Proj -` Proj ` X = (\\<Union>c\\<in>UNIV - {0}. (*\\<^sub>R) c ` X)\n\ngoal (1 subgoal):\n 1. open (Proj ` X)", "have \"open ((\\<Union>c\\<in>UNIV - {0}. (*\\<^sub>R) c ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (\\<Union>c\\<in>UNIV - {0}. (*\\<^sub>R) c ` X)", "apply (rule open_Union)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S\\<in>(\\<lambda>c. (*\\<^sub>R) c ` X) ` (UNIV - {0}). open S", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S.\n       S \\<in> (\\<lambda>c. (*\\<^sub>R) c ` X) `\n               (UNIV - {0}) \\<Longrightarrow>\n       open S", "apply (erule imageE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S c.\n       \\<lbrakk>S = (*\\<^sub>R) c ` X; c \\<in> UNIV - {0}\\<rbrakk>\n       \\<Longrightarrow> open S", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S c.\n       \\<lbrakk>S = (*\\<^sub>R) c ` X; c \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> open ((*\\<^sub>R) c ` X)", "apply (rule open_scaling_nonzero)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S c.\n       \\<lbrakk>S = (*\\<^sub>R) c ` X; c \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> c \\<noteq> 0\n 2. \\<And>S c.\n       \\<lbrakk>S = (*\\<^sub>R) c ` X; c \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> open X", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S c.\n       \\<lbrakk>S = (*\\<^sub>R) c ` X; c \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> open X", "apply (rule that)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  open (\\<Union>c\\<in>UNIV - {0}. (*\\<^sub>R) c ` X)\n\ngoal (1 subgoal):\n 1. open (Proj ` X)", "finally"], ["proof (chain)\npicking this:\n  open (Proj -` Proj ` X)", "show ?thesis"], ["proof (prove)\nusing this:\n  open (Proj -` Proj ` X)\n\ngoal (1 subgoal):\n 1. open (Proj ` X)", "by simp"], ["proof (state)\nthis:\n  open (Proj ` X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proj_rel_transfer[transfer_rule]:\n  \"(pcr_nonzero A ===> pcr_nonzero A ===> (=))  (\\<lambda>x a. \\<exists>c. a = sr c x \\<and> c \\<noteq> 0) proj_rel\"\n  if [transfer_rule]: \"((=) ===> pcr_nonzero A ===> pcr_nonzero A) sr (*\\<^sub>R)\"\n    \"bi_unique A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_nonzero A ===> pcr_nonzero A ===> (=))\n     (\\<lambda>x a. \\<exists>c. a = sr c x \\<and> c \\<noteq> 0) proj_rel", "unfolding proj_rel.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pcr_nonzero A ===> pcr_nonzero A ===> (=))\n     (\\<lambda>x a. \\<exists>c. a = sr c x \\<and> c \\<noteq> 0)\n     (\\<lambda>x a. \\<exists>c. a = c *\\<^sub>R x \\<and> c \\<noteq> 0)", "by (transfer_prover)"], ["", "lemma bool_aux: \"a \\<and> (a \\<longrightarrow> b) \\<longleftrightarrow> a \\<and> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<and> (a \\<longrightarrow> b)) = (a \\<and> b)", "by auto"], ["", "lemma closed_proj_rel: \"closed {(x::'a::euclidean_space nonzero, y::'a nonzero). proj_rel x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {(x, y). proj_rel x y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed {(x, y). proj_rel x y}", "have closed_proj_rel_euclidean:\n    \"\\<exists>A B. 0 \\<notin> A \\<and> 0 \\<notin> B \\<and> open A \\<and> open B \\<and> a \\<in> A \\<and> b \\<in> B \\<and>\n      A \\<times> B \\<subseteq> - {(x, y). (x, y) \\<noteq> 0 \\<and> (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}\"\n    if \"\\<And>c. c \\<noteq> 0 \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a\" \"a \\<noteq> 0\" \"b \\<noteq> 0\"\n    for a b::'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "proof -\\<comment> \\<open>explicitly constructing open ``cones'' that are disjoint\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "define a1 where \"a1 = a /\\<^sub>R norm a\""], ["proof (state)\nthis:\n  a1 = a /\\<^sub>R norm a\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "define b1 where \"b1 = b /\\<^sub>R norm b\""], ["proof (state)\nthis:\n  b1 = b /\\<^sub>R norm b\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "have norm_a1[simp]: \"norm a1 = 1\" and norm_b1[simp]: \"norm b1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm a1 = 1 &&& norm b1 = 1", "using that"], ["proof (prove)\nusing this:\n  ?c \\<noteq> 0 \\<Longrightarrow> b \\<noteq> ?c *\\<^sub>R a\n  a \\<noteq> (0::'a)\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. norm a1 = 1 &&& norm b1 = 1", "by (auto simp: a1_def b1_def divide_simps)"], ["proof (state)\nthis:\n  norm a1 = 1\n  norm b1 = 1\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "have a_alt_def: \"a = norm a *\\<^sub>R a1\" and b_alt_def: \"b = norm b *\\<^sub>R b1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = norm a *\\<^sub>R a1 &&& b = norm b *\\<^sub>R b1", "using that"], ["proof (prove)\nusing this:\n  ?c \\<noteq> 0 \\<Longrightarrow> b \\<noteq> ?c *\\<^sub>R a\n  a \\<noteq> (0::'a)\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. a = norm a *\\<^sub>R a1 &&& b = norm b *\\<^sub>R b1", "by (auto simp: a1_def b1_def)"], ["proof (state)\nthis:\n  a = norm a *\\<^sub>R a1\n  b = norm b *\\<^sub>R b1\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "have a1_neq_b1: \"a1 \\<noteq> b1\" \"a1 \\<noteq> -b1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a1 \\<noteq> b1 &&& a1 \\<noteq> - b1", "using that(1)[of \"norm b / norm a\"] that(2-)"], ["proof (prove)\nusing this:\n  norm b / norm a \\<noteq> 0 \\<Longrightarrow>\n  b \\<noteq> (norm b / norm a) *\\<^sub>R a\n  a \\<noteq> (0::'a)\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. a1 \\<noteq> b1 &&& a1 \\<noteq> - b1", "apply (auto simp: a1_def b1_def divide_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>b \\<noteq> (norm b / norm a) *\\<^sub>R a; a \\<noteq> (0::'a);\n     b \\<noteq> (0::'a);\n     (1 / norm a) *\\<^sub>R a = (1 / norm b) *\\<^sub>R b\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>b \\<noteq> (norm b / norm a) *\\<^sub>R a; a \\<noteq> (0::'a);\n     b \\<noteq> (0::'a);\n     (1 / norm a) *\\<^sub>R a = - ((1 / norm b) *\\<^sub>R b)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis divideR_right divide_inverse inverse_eq_divide norm_eq_zero scaleR_scaleR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<noteq> (norm b / norm a) *\\<^sub>R a; a \\<noteq> (0::'a);\n     b \\<noteq> (0::'a);\n     (1 / norm a) *\\<^sub>R a = - ((1 / norm b) *\\<^sub>R b)\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis (no_types, lifting) add.inverse_inverse b1_def b_alt_def inverse_eq_divide\n            scaleR_scaleR scale_eq_0_iff scale_minus_left that(1))"], ["proof (state)\nthis:\n  a1 \\<noteq> b1\n  a1 \\<noteq> - b1\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "define e where \"e = (1/2) * (min 1 (min (dist a1 b1) (dist (-a1) b1)))\""], ["proof (state)\nthis:\n  e = 1 / 2 * min 1 (min (dist a1 b1) (dist (- a1) b1))\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "have e_less: \"2 * e \\<le> dist a1 b1\" \"2 * e \\<le> dist (-a1) b1\" \"e < 1\"\n      and e_pos: \"0 < e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * e \\<le> dist a1 b1 &&& 2 * e \\<le> dist (- a1) b1 &&& e < 1) &&&\n    0 < e", "using that a1_neq_b1"], ["proof (prove)\nusing this:\n  ?c \\<noteq> 0 \\<Longrightarrow> b \\<noteq> ?c *\\<^sub>R a\n  a \\<noteq> (0::'a)\n  b \\<noteq> (0::'a)\n  a1 \\<noteq> b1\n  a1 \\<noteq> - b1\n\ngoal (1 subgoal):\n 1. (2 * e \\<le> dist a1 b1 &&& 2 * e \\<le> dist (- a1) b1 &&& e < 1) &&&\n    0 < e", "by (auto simp: e_def min_def)"], ["proof (state)\nthis:\n  2 * e \\<le> dist a1 b1\n  2 * e \\<le> dist (- a1) b1\n  e < 1\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "define A1 where \"A1 = ball a1 e \\<inter> {x. norm x = 1}\""], ["proof (state)\nthis:\n  A1 = ball a1 e \\<inter> {x. norm x = 1}\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "define B1 where \"B1 = ball b1 e \\<inter> {x. norm x = 1}\""], ["proof (state)\nthis:\n  B1 = ball b1 e \\<inter> {x. norm x = 1}\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "have disjoint: \"A1 \\<inter> B1 = {}\" \"uminus ` A1 \\<inter> B1 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1 \\<inter> B1 = {} &&& uminus ` A1 \\<inter> B1 = {}", "using e_less"], ["proof (prove)\nusing this:\n  2 * e \\<le> dist a1 b1\n  2 * e \\<le> dist (- a1) b1\n  e < 1\n\ngoal (1 subgoal):\n 1. A1 \\<inter> B1 = {} &&& uminus ` A1 \\<inter> B1 = {}", "apply (auto simp: A1_def B1_def mem_ball)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>2 * e \\<le> dist a1 b1; 2 * e \\<le> dist (- a1) b1; e < 1;\n        dist a1 x < e; dist b1 x < e; norm x = 1\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa.\n       \\<lbrakk>2 * e \\<le> dist a1 b1; 2 * e \\<le> dist (- a1) b1; e < 1;\n        dist b1 (- xa) < e; dist a1 xa < e; norm xa = 1\\<rbrakk>\n       \\<Longrightarrow> False", "apply (smt dist_commute dist_triangle)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>2 * e \\<le> dist a1 b1; 2 * e \\<le> dist (- a1) b1; e < 1;\n        dist b1 (- xa) < e; dist a1 xa < e; norm xa = 1\\<rbrakk>\n       \\<Longrightarrow> False", "by (smt add_uminus_conv_diff diff_self dist_0_norm dist_add_cancel dist_commute dist_norm dist_triangle)"], ["proof (state)\nthis:\n  A1 \\<inter> B1 = {}\n  uminus ` A1 \\<inter> B1 = {}\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "have norm_1: \"x \\<in> A1 \\<Longrightarrow> norm x = 1\"\n      \"x \\<in> B1 \\<Longrightarrow> norm x = 1\"\n      for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> A1 \\<Longrightarrow> norm x = 1) &&&\n    (x \\<in> B1 \\<Longrightarrow> norm x = 1)", "by (auto simp: A1_def B1_def)"], ["proof (state)\nthis:\n  ?x \\<in> A1 \\<Longrightarrow> norm ?x = 1\n  ?x \\<in> B1 \\<Longrightarrow> norm ?x = 1\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "define scales where \"scales X = {c *\\<^sub>R x |c x. c \\<noteq> 0 \\<and> x \\<in> X}\" for X::\"'a set\""], ["proof (state)\nthis:\n  scales ?X = {c *\\<^sub>R x |c x. c \\<noteq> 0 \\<and> x \\<in> ?X}\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "have scales_mem: \"c *\\<^sub>R x \\<in> (scales X) \\<longleftrightarrow> x \\<in> (scales X)\" if \"c \\<noteq> 0\" for c x X"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c *\\<^sub>R x \\<in> scales X) = (x \\<in> scales X)", "apply (auto simp: scales_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ca xa.\n       \\<lbrakk>c *\\<^sub>R x = ca *\\<^sub>R xa; ca \\<noteq> 0;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c xa.\n                            x = c *\\<^sub>R xa \\<and>\n                            c \\<noteq> 0 \\<and> xa \\<in> X\n 2. \\<And>ca xa.\n       \\<lbrakk>x = ca *\\<^sub>R xa; ca \\<noteq> 0; xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cb x.\n                            (c * ca) *\\<^sub>R xa = cb *\\<^sub>R x \\<and>\n                            cb \\<noteq> 0 \\<and> x \\<in> X", "apply (metis eq_vector_fraction_iff that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca xa.\n       \\<lbrakk>x = ca *\\<^sub>R xa; ca \\<noteq> 0; xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cb x.\n                            (c * ca) *\\<^sub>R xa = cb *\\<^sub>R x \\<and>\n                            cb \\<noteq> 0 \\<and> x \\<in> X", "apply (metis divisors_zero that)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?c \\<noteq> 0 \\<Longrightarrow>\n  (?c *\\<^sub>R ?x \\<in> scales ?X) = (?x \\<in> scales ?X)\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "define A where \"A = scales A1\""], ["proof (state)\nthis:\n  A = scales A1\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "define B where \"B = scales B1\""], ["proof (state)\nthis:\n  B = scales B1\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "from disjoint"], ["proof (chain)\npicking this:\n  A1 \\<inter> B1 = {}\n  uminus ` A1 \\<inter> B1 = {}", "have \"A \\<inter> B = {}\""], ["proof (prove)\nusing this:\n  A1 \\<inter> B1 = {}\n  uminus ` A1 \\<inter> B1 = {}\n\ngoal (1 subgoal):\n 1. A \\<inter> B = {}", "apply (auto simp: A_def B_def mem_ball scales_def, goal_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c ca xa xb.\n       \\<lbrakk>A1 \\<inter> B1 = {}; uminus ` A1 \\<inter> B1 = {};\n        c *\\<^sub>R xa = ca *\\<^sub>R xb; c \\<noteq> 0; xa \\<in> A1;\n        ca \\<noteq> 0; xb \\<in> B1\\<rbrakk>\n       \\<Longrightarrow> False", "by (smt disjoint_iff_not_equal imageI mult_cancel_right norm_1(1) norm_1(2) norm_scaleR\n          scaleR_left.minus scale_left_imp_eq scale_minus_right)"], ["proof (state)\nthis:\n  A \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "have \"0 \\<notin> A\" \"0 \\<notin> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<notin> A &&& (0::'a) \\<notin> B", "using e_less \\<open>a \\<noteq> 0\\<close> \\<open>b \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  2 * e \\<le> dist a1 b1\n  2 * e \\<le> dist (- a1) b1\n  e < 1\n  a \\<noteq> (0::'a)\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<notin> A &&& (0::'a) \\<notin> B", "by (auto simp: A_def B_def A1_def B1_def mem_ball a1_def b1_def scales_def)"], ["proof (state)\nthis:\n  (0::'a) \\<notin> A\n  (0::'a) \\<notin> B\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "moreover"], ["proof (state)\nthis:\n  (0::'a) \\<notin> A\n  (0::'a) \\<notin> B\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "let ?S = \"top_of_set {x. norm x = 1}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "have open_scales: \"open (scales X)\" if \"openin ?S X\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. open (scales X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. open (scales X)", "have X1: \"x \\<in> X \\<Longrightarrow> norm x = 1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> norm x = 1", "using that"], ["proof (prove)\nusing this:\n  openin (top_of_set {x. norm x = 1}) X\n\ngoal (1 subgoal):\n 1. x \\<in> X \\<Longrightarrow> norm x = 1", "by (auto simp: openin_subtopology)"], ["proof (state)\nthis:\n  ?x1 \\<in> X \\<Longrightarrow> norm ?x1 = 1\n\ngoal (1 subgoal):\n 1. open (scales X)", "have \"0 \\<notin> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<notin> X", "using that"], ["proof (prove)\nusing this:\n  openin (top_of_set {x. norm x = 1}) X\n\ngoal (1 subgoal):\n 1. (0::'a) \\<notin> X", "by (auto simp: openin_subtopology)"], ["proof (state)\nthis:\n  (0::'a) \\<notin> X\n\ngoal (1 subgoal):\n 1. open (scales X)", "have \"scales X = (\\<lambda>x. x /\\<^sub>R norm x) -` (X \\<union> uminus ` X) \\<inter> (topspace (top_of_set (UNIV - {0})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scales X =\n    (\\<lambda>x. x /\\<^sub>R norm x) -` (X \\<union> uminus ` X) \\<inter>\n    topspace (top_of_set (UNIV - {0::'a}))", "apply (auto simp: scales_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c xa.\n       \\<lbrakk>c \\<noteq> 0; xa \\<in> X;\n        (inverse \\<bar>c\\<bar> * inverse (norm xa) * c) *\\<^sub>R xa\n        \\<notin> uminus ` X\\<rbrakk>\n       \\<Longrightarrow> (inverse \\<bar>c\\<bar> * inverse (norm xa) *\n                          c) *\\<^sub>R\n                         xa\n                         \\<in> X\n 2. \\<And>c.\n       \\<lbrakk>c \\<noteq> 0; (0::'a) \\<in> X\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x.\n       \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c xa.\n                            x = c *\\<^sub>R xa \\<and>\n                            c \\<noteq> 0 \\<and> xa \\<in> X\n 4. \\<And>x xb.\n       \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x = - xb;\n        xb \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c xa.\n                            x = c *\\<^sub>R xa \\<and>\n                            c \\<noteq> 0 \\<and> xa \\<in> X", "subgoal for c x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<noteq> 0; x \\<in> X;\n     (inverse \\<bar>c\\<bar> * inverse (norm x) * c) *\\<^sub>R x\n     \\<notin> uminus ` X\\<rbrakk>\n    \\<Longrightarrow> (inverse \\<bar>c\\<bar> * inverse (norm x) *\n                       c) *\\<^sub>R\n                      x\n                      \\<in> X", "using \\<open>0 \\<notin> X\\<close>"], ["proof (prove)\nusing this:\n  (0::'a) \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<noteq> 0; x \\<in> X;\n     (inverse \\<bar>c\\<bar> * inverse (norm x) * c) *\\<^sub>R x\n     \\<notin> uminus ` X\\<rbrakk>\n    \\<Longrightarrow> (inverse \\<bar>c\\<bar> * inverse (norm x) *\n                       c) *\\<^sub>R\n                      x\n                      \\<in> X", "apply (cases \"c > 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c \\<noteq> 0; x \\<in> X;\n     (inverse \\<bar>c\\<bar> * inverse (norm x) * c) *\\<^sub>R x\n     \\<notin> uminus ` X;\n     (0::'a) \\<notin> X; 0 < c\\<rbrakk>\n    \\<Longrightarrow> (inverse \\<bar>c\\<bar> * inverse (norm x) *\n                       c) *\\<^sub>R\n                      x\n                      \\<in> X\n 2. \\<lbrakk>c \\<noteq> 0; x \\<in> X;\n     (inverse \\<bar>c\\<bar> * inverse (norm x) * c) *\\<^sub>R x\n     \\<notin> uminus ` X;\n     (0::'a) \\<notin> X; \\<not> 0 < c\\<rbrakk>\n    \\<Longrightarrow> (inverse \\<bar>c\\<bar> * inverse (norm x) *\n                       c) *\\<^sub>R\n                      x\n                      \\<in> X", "by (auto simp: X1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>c \\<noteq> 0; (0::'a) \\<in> X\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c xa.\n                            x = c *\\<^sub>R xa \\<and>\n                            c \\<noteq> 0 \\<and> xa \\<in> X\n 3. \\<And>x xb.\n       \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x = - xb;\n        xb \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c xa.\n                            x = c *\\<^sub>R xa \\<and>\n                            c \\<noteq> 0 \\<and> xa \\<in> X", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c_ \\<noteq> 0; (0::'a) \\<in> X\\<rbrakk> \\<Longrightarrow> False", "by (metis X1 norm_zero zero_neq_one)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c xa.\n                            x = c *\\<^sub>R xa \\<and>\n                            c \\<noteq> 0 \\<and> xa \\<in> X\n 2. \\<And>x xb.\n       \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x = - xb;\n        xb \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c xa.\n                            x = c *\\<^sub>R xa \\<and>\n                            c \\<noteq> 0 \\<and> xa \\<in> X", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c xa.\n                         x = c *\\<^sub>R xa \\<and>\n                         c \\<noteq> 0 \\<and> xa \\<in> X", "apply (rule exI[where x=\"norm x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa.\n                         x = norm x *\\<^sub>R xa \\<and>\n                         norm x \\<noteq> 0 \\<and> xa \\<in> X", "apply (rule exI[where x=\"x /\\<^sub>R norm x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> x = norm x *\\<^sub>R (x /\\<^sub>R norm x) \\<and>\n                      norm x \\<noteq> 0 \\<and> x /\\<^sub>R norm x \\<in> X", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xb.\n       \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x = - xb;\n        xb \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c xa.\n                            x = c *\\<^sub>R xa \\<and>\n                            c \\<noteq> 0 \\<and> xa \\<in> X", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x = - y;\n     y \\<in> X\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c xa.\n                         x = c *\\<^sub>R xa \\<and>\n                         c \\<noteq> 0 \\<and> xa \\<in> X", "apply (rule exI[where x=\"- norm x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x = - y;\n     y \\<in> X\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xa.\n                         x = - norm x *\\<^sub>R xa \\<and>\n                         - norm x \\<noteq> 0 \\<and> xa \\<in> X", "apply (rule exI[where x=y])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x = - y;\n     y \\<in> X\\<rbrakk>\n    \\<Longrightarrow> x = - norm x *\\<^sub>R y \\<and>\n                      - norm x \\<noteq> 0 \\<and> y \\<in> X", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> (0::'a); x /\\<^sub>R norm x = - y;\n     y \\<in> X\\<rbrakk>\n    \\<Longrightarrow> x = - (norm x *\\<^sub>R y)", "by (metis divideR_right norm_eq_zero scale_minus_right)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  scales X =\n  (\\<lambda>x. x /\\<^sub>R norm x) -` (X \\<union> uminus ` X) \\<inter>\n  topspace (top_of_set (UNIV - {0::'a}))\n\ngoal (1 subgoal):\n 1. open (scales X)", "also"], ["proof (state)\nthis:\n  scales X =\n  (\\<lambda>x. x /\\<^sub>R norm x) -` (X \\<union> uminus ` X) \\<inter>\n  topspace (top_of_set (UNIV - {0::'a}))\n\ngoal (1 subgoal):\n 1. open (scales X)", "have \"openin (top_of_set (UNIV - {0})) \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (top_of_set (UNIV - {0::'a}))\n     ((\\<lambda>x. x /\\<^sub>R norm x) -` (X \\<union> uminus ` X) \\<inter>\n      topspace (top_of_set (UNIV - {0::'a})))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. openin (top_of_set (UNIV - {0::'a}))\n     ((\\<lambda>x. x /\\<^sub>R norm x) -` (X \\<union> uminus ` X) \\<inter>\n      topspace (top_of_set (UNIV - {0::'a})))", "have *: \" {y. inverse (norm y) * norm y = 1} = UNIV - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. inverse (norm y) * norm y = 1} = UNIV - {0::'b}", "by auto"], ["proof (state)\nthis:\n  {y. inverse (norm y) * norm y = 1} = UNIV - {0::?'b2}\n\ngoal (1 subgoal):\n 1. openin (top_of_set (UNIV - {0::'a}))\n     ((\\<lambda>x. x /\\<^sub>R norm x) -` (X \\<union> uminus ` X) \\<inter>\n      topspace (top_of_set (UNIV - {0::'a})))", "from that"], ["proof (chain)\npicking this:\n  openin (top_of_set {x. norm x = 1}) X", "have \"openin ?S (uminus ` X)\""], ["proof (prove)\nusing this:\n  openin (top_of_set {x. norm x = 1}) X\n\ngoal (1 subgoal):\n 1. openin (top_of_set {x. norm x = 1}) (uminus ` X)", "apply (clarsimp simp: openin_subtopology)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>open T; X = T \\<inter> {x. norm x = 1}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ta.\n                            open Ta \\<and>\n                            uminus ` (T \\<inter> {x. norm x = 1}) =\n                            Ta \\<inter> {x. norm x = 1}", "by (auto simp: open_negations intro!: exI[where x=\"uminus ` T\" for T])"], ["proof (state)\nthis:\n  openin (top_of_set {x. norm x = 1}) (uminus ` X)\n\ngoal (1 subgoal):\n 1. openin (top_of_set (UNIV - {0::'a}))\n     ((\\<lambda>x. x /\\<^sub>R norm x) -` (X \\<union> uminus ` X) \\<inter>\n      topspace (top_of_set (UNIV - {0::'a})))", "then"], ["proof (chain)\npicking this:\n  openin (top_of_set {x. norm x = 1}) (uminus ` X)", "have \"openin ?S (X \\<union> uminus ` X)\""], ["proof (prove)\nusing this:\n  openin (top_of_set {x. norm x = 1}) (uminus ` X)\n\ngoal (1 subgoal):\n 1. openin (top_of_set {x. norm x = 1}) (X \\<union> uminus ` X)", "using \\<open>openin _ X\\<close>"], ["proof (prove)\nusing this:\n  openin (top_of_set {x. norm x = 1}) (uminus ` X)\n  openin (top_of_set {x. norm x = 1}) X\n\ngoal (1 subgoal):\n 1. openin (top_of_set {x. norm x = 1}) (X \\<union> uminus ` X)", "by auto"], ["proof (state)\nthis:\n  openin (top_of_set {x. norm x = 1}) (X \\<union> uminus ` X)\n\ngoal (1 subgoal):\n 1. openin (top_of_set (UNIV - {0::'a}))\n     ((\\<lambda>x. x /\\<^sub>R norm x) -` (X \\<union> uminus ` X) \\<inter>\n      topspace (top_of_set (UNIV - {0::'a})))", "from _ this"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  openin (top_of_set {x. norm x = 1}) (X \\<union> uminus ` X)", "show ?thesis"], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  openin (top_of_set {x. norm x = 1}) (X \\<union> uminus ` X)\n\ngoal (1 subgoal):\n 1. openin (top_of_set (UNIV - {0::'a}))\n     ((\\<lambda>x. x /\\<^sub>R norm x) -` (X \\<union> uminus ` X) \\<inter>\n      topspace (top_of_set (UNIV - {0::'a})))", "apply (rule continuous_map_open)"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_map (top_of_set (UNIV - {0::'a}))\n     (top_of_set {x. norm x = 1}) (\\<lambda>x. x /\\<^sub>R norm x)", "apply (auto simp: continuous_map_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>U.\n       openin (top_of_set {x. norm x = 1}) U \\<Longrightarrow>\n       openin (top_of_set (UNIV - {0::'a}))\n        {x. x \\<noteq> (0::'a) \\<and> x /\\<^sub>R norm x \\<in> U}", "apply (subst(asm) openin_subtopology)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>U.\n       \\<exists>T.\n          openin euclidean T \\<and>\n          U = T \\<inter> {x. norm x = 1} \\<Longrightarrow>\n       openin (top_of_set (UNIV - {0::'a}))\n        {x. x \\<noteq> (0::'a) \\<and> x /\\<^sub>R norm x \\<in> U}", "apply (auto simp: *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T.\n       open T \\<Longrightarrow>\n       openin (top_of_set (UNIV - {0::'a}))\n        {x. x \\<noteq> (0::'a) \\<and>\n            x /\\<^sub>R norm x \\<in> T \\<and> inverse (norm x) * norm x = 1}", "apply (subst openin_subtopology)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T.\n       open T \\<Longrightarrow>\n       \\<exists>Ta.\n          openin euclidean Ta \\<and>\n          {x. x \\<noteq> (0::'a) \\<and>\n              x /\\<^sub>R norm x \\<in> T \\<and>\n              inverse (norm x) * norm x = 1} =\n          Ta \\<inter> (UNIV - {0::'a})", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T.\n       open T \\<Longrightarrow>\n       \\<exists>Ta.\n          open Ta \\<and>\n          {x. x \\<noteq> (0::'a) \\<and>\n              x /\\<^sub>R norm x \\<in> T \\<and>\n              inverse (norm x) * norm x = 1} =\n          Ta \\<inter> (UNIV - {0::'a})", "subgoal for T"], ["proof (prove)\ngoal (1 subgoal):\n 1. open T \\<Longrightarrow>\n    \\<exists>Ta.\n       open Ta \\<and>\n       {x. x \\<noteq> (0::'a) \\<and>\n           x /\\<^sub>R norm x \\<in> T \\<and>\n           inverse (norm x) * norm x = 1} =\n       Ta \\<inter> (UNIV - {0::'a})", "apply (rule exI[where x=\"(\\<lambda>x. x /\\<^sub>R norm x) -` T \\<inter> UNIV - {0}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. open T \\<Longrightarrow>\n    open\n     ((\\<lambda>T. T /\\<^sub>R norm T) -` T \\<inter> UNIV - {0::'a}) \\<and>\n    {x. x \\<noteq> (0::'a) \\<and>\n        x /\\<^sub>R norm x \\<in> T \\<and> inverse (norm x) * norm x = 1} =\n    ((\\<lambda>T. T /\\<^sub>R norm T) -` T \\<inter> UNIV - {0::'a}) \\<inter>\n    (UNIV - {0::'a})", "apply (auto simp: Diff_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. open T \\<Longrightarrow>\n    open ((\\<lambda>T. T /\\<^sub>R norm T) -` T \\<inter> - {0::'a})", "apply (rule open_continuous_vimage)"], ["proof (prove)\ngoal (3 subgoals):\n 1. open T \\<Longrightarrow> open (- {0::'a})\n 2. open T \\<Longrightarrow>\n    continuous_on (- {0::'a}) (\\<lambda>T. T /\\<^sub>R norm T)\n 3. open T \\<Longrightarrow> open T", "by (auto intro!: continuous_intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  openin (top_of_set (UNIV - {0::'a}))\n   ((\\<lambda>x. x /\\<^sub>R norm x) -` (X \\<union> uminus ` X) \\<inter>\n    topspace (top_of_set (UNIV - {0::'a})))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  openin (top_of_set (UNIV - {0::'a}))\n   ((\\<lambda>x. x /\\<^sub>R norm x) -` (X \\<union> uminus ` X) \\<inter>\n    topspace (top_of_set (UNIV - {0::'a})))\n\ngoal (1 subgoal):\n 1. open (scales X)", "finally"], ["proof (chain)\npicking this:\n  openin (top_of_set (UNIV - {0::'a})) (scales X)", "show ?thesis"], ["proof (prove)\nusing this:\n  openin (top_of_set (UNIV - {0::'a})) (scales X)\n\ngoal (1 subgoal):\n 1. open (scales X)", "apply (subst (asm) openin_subtopology)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T.\n       openin euclidean T \\<and>\n       scales X = T \\<inter> (UNIV - {0::'a}) \\<Longrightarrow>\n    open (scales X)", "by clarsimp auto"], ["proof (state)\nthis:\n  open (scales X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  openin (top_of_set {x. norm x = 1}) ?X1 \\<Longrightarrow>\n  open (scales ?X1)\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "have \"openin ?S A1\" \"openin ?S B1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (top_of_set {x. norm x = 1}) A1 &&&\n    openin (top_of_set {x. norm x = 1}) B1", "by (auto simp: openin_subtopology A1_def B1_def)"], ["proof (state)\nthis:\n  openin (top_of_set {x. norm x = 1}) A1\n  openin (top_of_set {x. norm x = 1}) B1\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "from open_scales[OF this(1)] open_scales[OF this(2)]"], ["proof (chain)\npicking this:\n  open (scales A1)\n  open (scales B1)", "have \"open A\" \"open B\""], ["proof (prove)\nusing this:\n  open (scales A1)\n  open (scales B1)\n\ngoal (1 subgoal):\n 1. open A &&& open B", "by (simp_all add: A_def B_def)"], ["proof (state)\nthis:\n  open A\n  open B\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "moreover"], ["proof (state)\nthis:\n  open A\n  open B\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "have \"a \\<in> A\" \"b \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> A &&& b \\<in> B", "by (force simp: A_def B_def A1_def B1_def that e_pos scales_def intro: a_alt_def b_alt_def)+"], ["proof (state)\nthis:\n  a \\<in> A\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "moreover"], ["proof (state)\nthis:\n  a \\<in> A\n  b \\<in> B\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "have False if \"c *\\<^sub>R p \\<in> B\" \"p \\<in> A\" \"c \\<noteq> 0\" for p c"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using that \\<open>0 \\<notin> A\\<close> \\<open>0 \\<notin> B\\<close> \\<open>A \\<inter> B = {}\\<close>"], ["proof (prove)\nusing this:\n  c *\\<^sub>R p \\<in> B\n  p \\<in> A\n  c \\<noteq> 0\n  (0::'a) \\<notin> A\n  (0::'a) \\<notin> B\n  A \\<inter> B = {}\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: A_def B_def scales_mem)"], ["proof (state)\nthis:\n  \\<lbrakk>?c1 *\\<^sub>R ?p1 \\<in> B; ?p1 \\<in> A; ?c1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?c1 *\\<^sub>R ?p1 \\<in> B; ?p1 \\<in> A; ?c1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> False", "have \"A \\<times> B \\<subseteq> - {(x, y). (x, y) \\<noteq> 0 \\<and> (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?c1 *\\<^sub>R ?p1 \\<in> B; ?p1 \\<in> A; ?c1 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. A \\<times> B\n    \\<subseteq> - {(x, y).\n                   (x, y) \\<noteq> 0 \\<and>\n                   (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "by (auto simp: prod_eq_iff)"], ["proof (state)\nthis:\n  A \\<times> B\n  \\<subseteq> - {(x, y).\n                 (x, y) \\<noteq> 0 \\<and>\n                 (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "ultimately"], ["proof (chain)\npicking this:\n  (0::'a) \\<notin> A\n  (0::'a) \\<notin> B\n  open A\n  open B\n  a \\<in> A\n  b \\<in> B\n  A \\<times> B\n  \\<subseteq> - {(x, y).\n                 (x, y) \\<noteq> 0 \\<and>\n                 (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "show ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) \\<notin> A\n  (0::'a) \\<notin> B\n  open A\n  open B\n  a \\<in> A\n  b \\<in> B\n  A \\<times> B\n  \\<subseteq> - {(x, y).\n                 (x, y) \\<noteq> 0 \\<and>\n                 (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}\n\ngoal (1 subgoal):\n 1. \\<exists>A B.\n       (0::'a) \\<notin> A \\<and>\n       (0::'a) \\<notin> B \\<and>\n       open A \\<and>\n       open B \\<and>\n       a \\<in> A \\<and>\n       b \\<in> B \\<and>\n       A \\<times> B\n       \\<subseteq> - {(x, y).\n                      (x, y) \\<noteq> 0 \\<and>\n                      (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}", "by blast"], ["proof (state)\nthis:\n  \\<exists>A B.\n     (0::'a) \\<notin> A \\<and>\n     (0::'a) \\<notin> B \\<and>\n     open A \\<and>\n     open B \\<and>\n     a \\<in> A \\<and>\n     b \\<in> B \\<and>\n     A \\<times> B\n     \\<subseteq> - {(x, y).\n                    (x, y) \\<noteq> 0 \\<and>\n                    (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>c.\n              c \\<noteq> 0 \\<Longrightarrow> ?b \\<noteq> c *\\<^sub>R ?a;\n   ?a \\<noteq> (0::'a); ?b \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A B.\n                       (0::'a) \\<notin> A \\<and>\n                       (0::'a) \\<notin> B \\<and>\n                       open A \\<and>\n                       open B \\<and>\n                       ?a \\<in> A \\<and>\n                       ?b \\<in> B \\<and>\n                       A \\<times> B\n                       \\<subseteq> - {(x, y).\n(x, y) \\<noteq> 0 \\<and>\n(\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}\n\ngoal (1 subgoal):\n 1. closed {(x, y). proj_rel x y}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {(x, y). proj_rel x y}", "unfolding closed_def open_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>- {(x, y). proj_rel x y}.\n       \\<exists>A B.\n          open A \\<and>\n          open B \\<and>\n          x \\<in> A \\<times> B \\<and>\n          A \\<times> B \\<subseteq> - {(x, y). proj_rel x y}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>- {x. (case x of\n                          (x, a) \\<Rightarrow>\n                            \\<exists>c.\n                               a =\n                               (if c = 0 then One else c *\\<^sub>R x) \\<and>\n                               c \\<noteq> 0) \\<and>\n                         pred_prod (\\<lambda>x. x \\<in> UNIV - {0::'a})\n                          (\\<lambda>x. x \\<in> UNIV - {0::'a}) x} \\<inter>\n                   Collect\n                    (pred_prod (\\<lambda>x. x \\<in> UNIV - {0::'a})\n                      (\\<lambda>x. x \\<in> UNIV - {0::'a})).\n       \\<exists>A\\<in>{A. \\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n          \\<exists>B\\<in>{A. \\<forall>x\\<in>A. x \\<in> UNIV - {0::'a}}.\n             open A \\<and>\n             open B \\<and>\n             x \\<in> A \\<times> B \\<and>\n             A \\<times> B\n             \\<subseteq> - {x. (case x of\n                                (x, a) \\<Rightarrow>\n                                  \\<exists>c.\n                                     a =\n                                     (if c = 0 then One\nelse c *\\<^sub>R x) \\<and>\n                                     c \\<noteq> 0) \\<and>\n                               pred_prod\n                                (\\<lambda>x. x \\<in> UNIV - {0::'a})\n                                (\\<lambda>x. x \\<in> UNIV - {0::'a})\n                                x} \\<inter>\n                         Collect\n                          (pred_prod (\\<lambda>x. x \\<in> UNIV - {0::'a})\n                            (\\<lambda>x. x \\<in> UNIV - {0::'a}))", "apply (simp add: split_beta' bool_aux pred_prod.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>- {x. (\\<exists>c.\n                             c \\<noteq> 0 \\<and>\n                             snd x = c *\\<^sub>R fst x) \\<and>\n                         (\\<exists>a b.\n                             x = (a, b) \\<and>\n                             a \\<noteq> (0::'a) \\<and>\n                             b \\<noteq> (0::'a))} \\<inter>\n                   Collect\n                    (pred_prod (\\<lambda>x. x \\<noteq> (0::'a))\n                      (\\<lambda>x. x \\<noteq> (0::'a))).\n       \\<exists>A.\n          (\\<forall>x\\<in>A. x \\<noteq> (0::'a)) \\<and>\n          open A \\<and>\n          (\\<exists>B.\n              (\\<forall>x\\<in>B. x \\<noteq> (0::'a)) \\<and>\n              open B \\<and>\n              x \\<in> A \\<times> B \\<and>\n              A \\<times> B\n              \\<subseteq> - {x. (\\<exists>c.\n                                    c \\<noteq> 0 \\<and>\n                                    snd x = c *\\<^sub>R fst x) \\<and>\n                                (\\<exists>a b.\n                                    x = (a, b) \\<and>\n                                    a \\<noteq> (0::'a) \\<and>\n                                    b \\<noteq> (0::'a))} \\<and>\n              A \\<times> B\n              \\<subseteq> Collect\n                           (pred_prod (\\<lambda>x. x \\<noteq> (0::'a))\n                             (\\<lambda>x. x \\<noteq> (0::'a))))", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> - {x. (\\<exists>c.\n                         c \\<noteq> 0 \\<and>\n                         snd x = c *\\<^sub>R fst x) \\<and>\n                     (\\<exists>a b.\n                         x = (a, b) \\<and>\n                         a \\<noteq> (0::'a) \\<and>\n                         b \\<noteq> (0::'a))} \\<inter>\n               Collect\n                (pred_prod (\\<lambda>x. x \\<noteq> (0::'a))\n                  (\\<lambda>x. x \\<noteq> (0::'a))) \\<Longrightarrow>\n       \\<exists>A.\n          (\\<forall>x\\<in>A. x \\<noteq> (0::'a)) \\<and>\n          open A \\<and>\n          (\\<exists>B.\n              (\\<forall>x\\<in>B. x \\<noteq> (0::'a)) \\<and>\n              open B \\<and>\n              x \\<in> A \\<times> B \\<and>\n              A \\<times> B\n              \\<subseteq> - {x. (\\<exists>c.\n                                    c \\<noteq> 0 \\<and>\n                                    snd x = c *\\<^sub>R fst x) \\<and>\n                                (\\<exists>a b.\n                                    x = (a, b) \\<and>\n                                    a \\<noteq> (0::'a) \\<and>\n                                    b \\<noteq> (0::'a))} \\<and>\n              A \\<times> B\n              \\<subseteq> Collect\n                           (pred_prod (\\<lambda>x. x \\<noteq> (0::'a))\n                             (\\<lambda>x. x \\<noteq> (0::'a))))", "apply (clarsimp simp: pred_prod.simps[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n        a \\<noteq> (0::'a); b \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            (\\<forall>x\\<in>A. x \\<noteq> (0::'a)) \\<and>\n                            open A \\<and>\n                            (\\<exists>B.\n                                (\\<forall>x\\<in>B.\n                                    x \\<noteq> (0::'a)) \\<and>\n                                open B \\<and>\n                                a \\<in> A \\<and>\n                                b \\<in> B \\<and>\n                                A \\<times> B\n                                \\<subseteq> - {x.\n         (\\<exists>c. c \\<noteq> 0 \\<and> snd x = c *\\<^sub>R fst x) \\<and>\n         (\\<exists>a b.\n             x = (a, b) \\<and>\n             a \\<noteq> (0::'a) \\<and> b \\<noteq> (0::'a))} \\<and>\n                                A \\<times> B\n                                \\<subseteq> {a. a \\<noteq> (0::'a)} \\<times>\n      {b. b \\<noteq> (0::'a)})", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n     a \\<noteq> (0::'a); b \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         (\\<forall>x\\<in>A. x \\<noteq> (0::'a)) \\<and>\n                         open A \\<and>\n                         (\\<exists>B.\n                             (\\<forall>x\\<in>B. x \\<noteq> (0::'a)) \\<and>\n                             open B \\<and>\n                             a \\<in> A \\<and>\n                             b \\<in> B \\<and>\n                             A \\<times> B\n                             \\<subseteq> - {x.\n      (\\<exists>c. c \\<noteq> 0 \\<and> snd x = c *\\<^sub>R fst x) \\<and>\n      (\\<exists>a b.\n          x = (a, b) \\<and>\n          a \\<noteq> (0::'a) \\<and> b \\<noteq> (0::'a))} \\<and>\n                             A \\<times> B\n                             \\<subseteq> {a. a \\<noteq> (0::'a)} \\<times>\n   {b. b \\<noteq> (0::'a)})", "apply (subgoal_tac \"(\\<And>c. c \\<noteq> 0 \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n     a \\<noteq> (0::'a); b \\<noteq> (0::'a);\n     \\<And>c.\n        c \\<noteq> 0 \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         (\\<forall>x\\<in>A. x \\<noteq> (0::'a)) \\<and>\n                         open A \\<and>\n                         (\\<exists>B.\n                             (\\<forall>x\\<in>B. x \\<noteq> (0::'a)) \\<and>\n                             open B \\<and>\n                             a \\<in> A \\<and>\n                             b \\<in> B \\<and>\n                             A \\<times> B\n                             \\<subseteq> - {x.\n      (\\<exists>c. c \\<noteq> 0 \\<and> snd x = c *\\<^sub>R fst x) \\<and>\n      (\\<exists>a b.\n          x = (a, b) \\<and>\n          a \\<noteq> (0::'a) \\<and> b \\<noteq> (0::'a))} \\<and>\n                             A \\<times> B\n                             \\<subseteq> {a. a \\<noteq> (0::'a)} \\<times>\n   {b. b \\<noteq> (0::'a)})\n 2. \\<And>c.\n       \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n        a \\<noteq> (0::'a); b \\<noteq> (0::'a); c \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a", "using closed_proj_rel_euclidean[of b a]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>c. c \\<noteq> 0 \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a;\n   a \\<noteq> (0::'a); b \\<noteq> (0::'a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A B.\n                       (0::'a) \\<notin> A \\<and>\n                       (0::'a) \\<notin> B \\<and>\n                       open A \\<and>\n                       open B \\<and>\n                       a \\<in> A \\<and>\n                       b \\<in> B \\<and>\n                       A \\<times> B\n                       \\<subseteq> - {(x, y).\n(x, y) \\<noteq> 0 \\<and>\n(\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n     a \\<noteq> (0::'a); b \\<noteq> (0::'a);\n     \\<And>c.\n        c \\<noteq> 0 \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         (\\<forall>x\\<in>A. x \\<noteq> (0::'a)) \\<and>\n                         open A \\<and>\n                         (\\<exists>B.\n                             (\\<forall>x\\<in>B. x \\<noteq> (0::'a)) \\<and>\n                             open B \\<and>\n                             a \\<in> A \\<and>\n                             b \\<in> B \\<and>\n                             A \\<times> B\n                             \\<subseteq> - {x.\n      (\\<exists>c. c \\<noteq> 0 \\<and> snd x = c *\\<^sub>R fst x) \\<and>\n      (\\<exists>a b.\n          x = (a, b) \\<and>\n          a \\<noteq> (0::'a) \\<and> b \\<noteq> (0::'a))} \\<and>\n                             A \\<times> B\n                             \\<subseteq> {a. a \\<noteq> (0::'a)} \\<times>\n   {b. b \\<noteq> (0::'a)})\n 2. \\<And>c.\n       \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n        a \\<noteq> (0::'a); b \\<noteq> (0::'a); c \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A B.\n       \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n        a \\<noteq> (0::'a); b \\<noteq> (0::'a);\n        \\<And>c. c \\<noteq> 0 \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a;\n        (0::'a) \\<notin> A; (0::'a) \\<notin> B; open A; open B; a \\<in> A;\n        b \\<in> B;\n        A \\<times> B\n        \\<subseteq> - {(x, y).\n                       (x, y) \\<noteq> 0 \\<and>\n                       (\\<exists>c.\n                           c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            (\\<forall>x\\<in>A. x \\<noteq> (0::'a)) \\<and>\n                            open A \\<and>\n                            (\\<exists>B.\n                                (\\<forall>x\\<in>B.\n                                    x \\<noteq> (0::'a)) \\<and>\n                                open B \\<and>\n                                a \\<in> A \\<and>\n                                b \\<in> B \\<and>\n                                A \\<times> B\n                                \\<subseteq> - {x.\n         (\\<exists>c. c \\<noteq> 0 \\<and> snd x = c *\\<^sub>R fst x) \\<and>\n         (\\<exists>a b.\n             x = (a, b) \\<and>\n             a \\<noteq> (0::'a) \\<and> b \\<noteq> (0::'a))} \\<and>\n                                A \\<times> B\n                                \\<subseteq> {a. a \\<noteq> (0::'a)} \\<times>\n      {b. b \\<noteq> (0::'a)})\n 2. \\<And>c.\n       \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n        a \\<noteq> (0::'a); b \\<noteq> (0::'a); c \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a", "subgoal for A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n     a \\<noteq> (0::'a); b \\<noteq> (0::'a);\n     \\<And>c. c \\<noteq> 0 \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a;\n     (0::'a) \\<notin> A; (0::'a) \\<notin> B; open A; open B; a \\<in> A;\n     b \\<in> B;\n     A \\<times> B\n     \\<subseteq> - {(x, y).\n                    (x, y) \\<noteq> 0 \\<and>\n                    (\\<exists>c.\n                        c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A.\n                         (\\<forall>x\\<in>A. x \\<noteq> (0::'a)) \\<and>\n                         open A \\<and>\n                         (\\<exists>B.\n                             (\\<forall>x\\<in>B. x \\<noteq> (0::'a)) \\<and>\n                             open B \\<and>\n                             a \\<in> A \\<and>\n                             b \\<in> B \\<and>\n                             A \\<times> B\n                             \\<subseteq> - {x.\n      (\\<exists>c. c \\<noteq> 0 \\<and> snd x = c *\\<^sub>R fst x) \\<and>\n      (\\<exists>a b.\n          x = (a, b) \\<and>\n          a \\<noteq> (0::'a) \\<and> b \\<noteq> (0::'a))} \\<and>\n                             A \\<times> B\n                             \\<subseteq> {a. a \\<noteq> (0::'a)} \\<times>\n   {b. b \\<noteq> (0::'a)})", "apply (rule exI[where x=A])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n     a \\<noteq> (0::'a); b \\<noteq> (0::'a);\n     \\<And>c. c \\<noteq> 0 \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a;\n     (0::'a) \\<notin> A; (0::'a) \\<notin> B; open A; open B; a \\<in> A;\n     b \\<in> B;\n     A \\<times> B\n     \\<subseteq> - {(x, y).\n                    (x, y) \\<noteq> 0 \\<and>\n                    (\\<exists>c.\n                        c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)}\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x\\<in>A. x \\<noteq> (0::'a)) \\<and>\n                      open A \\<and>\n                      (\\<exists>B.\n                          (\\<forall>x\\<in>B. x \\<noteq> (0::'a)) \\<and>\n                          open B \\<and>\n                          a \\<in> A \\<and>\n                          b \\<in> B \\<and>\n                          A \\<times> B\n                          \\<subseteq> - {x.\n   (\\<exists>c. c \\<noteq> 0 \\<and> snd x = c *\\<^sub>R fst x) \\<and>\n   (\\<exists>a b.\n       x = (a, b) \\<and>\n       a \\<noteq> (0::'a) \\<and> b \\<noteq> (0::'a))} \\<and>\n                          A \\<times> B\n                          \\<subseteq> {a. a \\<noteq> (0::'a)} \\<times>\n{b. b \\<noteq> (0::'a)})", "apply (auto intro!: exI[where x=B])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c aa.\n       \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n        a \\<noteq> (0::'a); b \\<noteq> (0::'a);\n        \\<And>c. c \\<noteq> 0 \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a;\n        (0::'a) \\<notin> A; (0::'a) \\<notin> B; open A; open B; a \\<in> A;\n        b \\<in> B;\n        A \\<times> B\n        \\<subseteq> - {(x, y).\n                       (x, y) \\<noteq> 0 \\<and>\n                       (\\<exists>c. c \\<noteq> 0 \\<and> y = c *\\<^sub>R x)};\n        aa \\<in> A; c *\\<^sub>R aa \\<in> B; c \\<noteq> 0;\n        aa \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp: subset_iff prod_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c aa.\n       \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n        a \\<noteq> (0::'a); b \\<noteq> (0::'a);\n        \\<And>c. c \\<noteq> 0 \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a;\n        (0::'a) \\<notin> A; (0::'a) \\<notin> B; open A; open B; a \\<in> A;\n        b \\<in> B;\n        \\<forall>a b.\n           a \\<in> A \\<and> b \\<in> B \\<longrightarrow>\n           a = (0::'a) \\<and> b = (0::'a) \\<or>\n           (\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a);\n        aa \\<in> A; c *\\<^sub>R aa \\<in> B; c \\<noteq> 0;\n        aa \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n        a \\<noteq> (0::'a); b \\<noteq> (0::'a); c \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> c *\\<^sub>R a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c. c = 0 \\<or> b \\<noteq> c *\\<^sub>R a;\n     a \\<noteq> (0::'a); b \\<noteq> (0::'a); c_ \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> b \\<noteq> c_ *\\<^sub>R a", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  closed {(x, y). proj_rel x y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_Proj_rel: \"closed {(x, y). Proj x = Proj y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed {(x, y). Proj x = Proj y}", "using closed_proj_rel"], ["proof (prove)\nusing this:\n  closed {(x, y). proj_rel x y}\n\ngoal (1 subgoal):\n 1. closed {(x, y). Proj x = Proj y}", "by (smt Collect_cong case_prodE case_prodI2 prod.inject proj_space.abs_eq_iff)"], ["", "instance proj_space :: (euclidean_space) t2_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a proj_space, t2_space_class)", "apply (rule class.Topological_Spaces.t2_space.of_class.intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.t2_space open", "using open_proj_space_def surj_Proj Proj_open_map closed_Proj_rel"], ["proof (prove)\nusing this:\n  open = openin (map_topology Proj euclidean)\n  surj Proj\n  open ?X \\<Longrightarrow> open (Proj ` ?X)\n  closed {(x, y). Proj x = Proj y}\n\ngoal (1 subgoal):\n 1. class.t2_space open", "by (rule t2_space_quotient)"], ["", "instance proj_space :: (euclidean_space) second_countable_topology"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a proj_space, second_countable_topology_class)", "apply (rule class.Elementary_Topology.second_countable_topology.of_class.intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.second_countable_topology open", "using open_proj_space_def surj_Proj Proj_open_map"], ["proof (prove)\nusing this:\n  open = openin (map_topology Proj euclidean)\n  surj Proj\n  open ?X \\<Longrightarrow> open (Proj ` ?X)\n\ngoal (1 subgoal):\n 1. class.second_countable_topology open", "by (rule second_countable_topology_quotient)"], ["", "subsection \\<open>Charts\\<close>"], ["", "subsubsection \\<open>Chart for last coordinate\\<close>"], ["", "lift_definition chart_last_nonzero :: \"('a::euclidean_space \\<times> real) nonzero \\<Rightarrow> 'a\" is \"\\<lambda>(x,c). x /\\<^sub>R c\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma chart_last_nonzero_scaleR[simp]: \"c \\<noteq> 0 \\<Longrightarrow> chart_last_nonzero (c *\\<^sub>R n) = chart_last_nonzero n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    chart_last_nonzero (c *\\<^sub>R n) = chart_last_nonzero n", "by (transfer) auto"], ["", "lift_definition chart_last :: \"'a::euclidean_space proj_space \\<Rightarrow> 'a\" is chart_last_nonzero"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nonzero1 nonzero2.\n       proj_rel nonzero1 nonzero2 \\<Longrightarrow>\n       chart_last_nonzero nonzero1 = chart_last_nonzero nonzero2", "by (erule proj_rel.cases) auto"], ["", "lift_definition chart_last_inv_nonzero :: \"'a \\<Rightarrow> ('a::euclidean_space\\<times>real) nonzero\" is\n  \"\\<lambda>x. (x, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. (a, 1) \\<in> UNIV - {0}", "by (auto simp: zero_prod_def)"], ["", "lift_definition chart_last_inv :: \"'a \\<Rightarrow> 'a::euclidean_space proj_space\" is chart_last_inv_nonzero"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition chart_last_domain_nonzeroP :: \"('a::euclidean_space\\<times>real) nonzero \\<Rightarrow> bool\" is\n  \"\\<lambda>x. snd x \\<noteq> 0\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition chart_last_domainP :: \"'a::euclidean_space proj_space \\<Rightarrow> bool\" is chart_last_domain_nonzeroP"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nonzero1 nonzero2.\n       proj_rel nonzero1 nonzero2 \\<Longrightarrow>\n       chart_last_domain_nonzeroP nonzero1 =\n       chart_last_domain_nonzeroP nonzero2", "unfolding rel_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nonzero1 nonzero2.\n       proj_rel nonzero1 nonzero2 \\<Longrightarrow>\n       chart_last_domain_nonzeroP nonzero1 =\n       chart_last_domain_nonzeroP nonzero2", "by (safe elim!: proj_rel.cases; (transfer,simp))"], ["", "lemma open_chart_last_domain: \"open (Collect chart_last_domainP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (Collect chart_last_domainP)", "unfolding open_proj_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (map_topology Proj euclidean) (Collect chart_last_domainP)", "unfolding openin_map_topology"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect chart_last_domainP \\<subseteq> Proj ` topspace euclidean \\<and>\n    openin euclidean\n     (Proj -` Collect chart_last_domainP \\<inter> topspace euclidean)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. chart_last_domainP x \\<Longrightarrow> x \\<in> range Proj\n 2. open {y. chart_last_domainP (Proj y)}", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_last_domainP x \\<Longrightarrow> x \\<in> range Proj", "apply (induction x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       chart_last_domainP (Proj y) \\<Longrightarrow> Proj y \\<in> range Proj", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. open {y. chart_last_domainP (Proj y)}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. open {y. chart_last_domainP (Proj y)}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. open {y. chart_last_domain_nonzeroP y}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. open {x. snd x \\<noteq> 0 \\<and> x \\<in> UNIV - {0}}", "unfolding Collect_conj_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. open ({x. snd x \\<noteq> 0} \\<inter> {x. x \\<in> UNIV - {0}})", "apply (rule open_Int)"], ["proof (prove)\ngoal (2 subgoals):\n 1. open {x. snd x \\<noteq> 0}\n 2. open {x. x \\<in> UNIV - {0}}", "by (auto intro!: open_Collect_neq continuous_on_snd)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Proj_vimage_chart_last_domainP: \"Proj -` Collect chart_last_domainP = Collect (chart_last_domain_nonzeroP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj -` Collect chart_last_domainP = Collect chart_last_domain_nonzeroP", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       chart_last_domainP (Proj x) \\<Longrightarrow>\n       chart_last_domain_nonzeroP x\n 2. \\<And>x.\n       chart_last_domain_nonzeroP x \\<Longrightarrow>\n       x \\<in> Proj -` Collect chart_last_domainP", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_last_domainP (Proj x_) \\<Longrightarrow>\n    chart_last_domain_nonzeroP x_", "by transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       chart_last_domain_nonzeroP x \\<Longrightarrow>\n       x \\<in> Proj -` Collect chart_last_domainP", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_last_domain_nonzeroP x \\<Longrightarrow>\n    x \\<in> Proj -` Collect chart_last_domainP", "by auto transfer"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma chart_last_continuous:\n  notes [transfer_rule] = open_nonzero_openin_transfer\n  shows \"continuous_on (Collect chart_last_domainP) chart_last\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (Collect chart_last_domainP) chart_last", "apply (rule continuous_on_proj_spaceI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on (Proj -` Collect chart_last_domainP)\n     (chart_last \\<circ> Proj)\n 2. open (Collect chart_last_domainP)", "unfolding o_def chart_last.abs_eq Proj_vimage_chart_last_domainP"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on (Collect chart_last_domain_nonzeroP) chart_last_nonzero\n 2. open (Collect chart_last_domainP)", "apply transfer"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on\n     ({x. snd x \\<noteq> 0 \\<and> x \\<in> UNIV - {0}} \\<inter>\n      Collect (Domainp (pcr_nonzero (rel_prod (=) (=)))))\n     (\\<lambda>x. case x of (x, c) \\<Rightarrow> x /\\<^sub>R c)\n 2. open (Collect chart_last_domainP)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on\n     ({x. snd x \\<noteq> 0 \\<and> x \\<in> UNIV - {0}} \\<inter>\n      Collect (Domainp (pcr_nonzero (rel_prod (=) (=)))))\n     (\\<lambda>x. case x of (x, c) \\<Rightarrow> x /\\<^sub>R c)", "by (auto intro!: continuous_intros simp: split_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. open (Collect chart_last_domainP)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. open (Collect chart_last_domainP)", "by (rule open_chart_last_domain)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma chart_last_inv_continuous:\n  notes [transfer_rule] = open_nonzero_openin_transfer\n  shows \"continuous_on UNIV chart_last_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV chart_last_inv", "unfolding chart_last_inv_def map_fun_def comp_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV (Proj \\<circ> chart_last_inv_nonzero)", "apply (rule continuous_on_compose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on UNIV chart_last_inv_nonzero\n 2. continuous_on (range chart_last_inv_nonzero) Proj", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV chart_last_inv_nonzero", "by transfer (auto intro!: continuous_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (range chart_last_inv_nonzero) Proj", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (range chart_last_inv_nonzero) Proj", "by (metis continuous_on_open_vimage continuous_on_subset inf_top.right_neutral open_UNIV open_vimage_Proj_iff top_greatest)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma proj_rel_iff: \"proj_rel a b \\<longleftrightarrow> (\\<exists>c\\<noteq>0. b = c *\\<^sub>R a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_rel a b = (\\<exists>c. c \\<noteq> 0 \\<and> b = c *\\<^sub>R a)", "by (auto elim!: proj_rel.cases intro!: proj_rel.intros)"], ["", "lemma chart_last_inverse: \"chart_last_inv (chart_last x) = x\" if \"chart_last_domainP x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_last_inv (chart_last x) = x", "using that"], ["proof (prove)\nusing this:\n  chart_last_domainP x\n\ngoal (1 subgoal):\n 1. chart_last_inv (chart_last x) = x", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_last_domainP x \\<Longrightarrow> chart_last_inv (chart_last x) = x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       chart_last_domain_nonzeroP x \\<Longrightarrow>\n       proj_rel (chart_last_inv_nonzero (chart_last_nonzero x)) x", "unfolding proj_rel_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       chart_last_domain_nonzeroP x \\<Longrightarrow>\n       \\<exists>c.\n          c \\<noteq> 0 \\<and>\n          x = c *\\<^sub>R chart_last_inv_nonzero (chart_last_nonzero x)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV - {0}; snd x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            c \\<noteq> 0 \\<and>\n                            x =\n                            (if c = 0 then One\n                             else c *\\<^sub>R\n                                  (case x of\n                                   (x, c) \\<Rightarrow> x /\\<^sub>R c,\n                                   1))", "apply (simp add: split_beta prod_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       snd x \\<noteq> 0 \\<Longrightarrow>\n       \\<exists>c.\n          c \\<noteq> 0 \\<and>\n          (c \\<noteq> 0 \\<longrightarrow>\n           fst x = (c * inverse (snd x)) *\\<^sub>R fst x \\<and> snd x = c)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd x \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>c.\n       c \\<noteq> 0 \\<and>\n       (c \\<noteq> 0 \\<longrightarrow>\n        fst x = (c * inverse (snd x)) *\\<^sub>R fst x \\<and> snd x = c)", "by (rule exI[where x=\"snd x\"]) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma chart_last_inv_inverse: \"chart_last (chart_last_inv x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_last (chart_last_inv x) = x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. chart_last_nonzero (chart_last_inv_nonzero x) = x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (case (x, 1) of (x, c) \\<Rightarrow> x /\\<^sub>R c) = x", "by auto"], ["", "lemma chart_last_domainP_chart_last_inv: \"chart_last_domainP (chart_last_inv x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_last_domainP (chart_last_inv x)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. chart_last_domain_nonzeroP (chart_last_inv_nonzero x)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. snd (x, 1) \\<noteq> 0", "by auto"], ["", "lemma homeomorphism_chart_last:\n  \"homeomorphism (Collect chart_last_domainP) UNIV chart_last chart_last_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homeomorphism (Collect chart_last_domainP) UNIV chart_last\n     chart_last_inv", "apply (auto simp: homeomorphism_def chart_last_inverse chart_last_inv_inverse\n      chart_last_continuous chart_last_inv_continuous)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> chart_last ` Collect chart_last_domainP\n 2. \\<And>xa. chart_last_domainP (chart_last_inv xa)\n 3. \\<And>x.\n       chart_last_domainP x \\<Longrightarrow> x \\<in> range chart_last_inv", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> chart_last ` Collect chart_last_domainP", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> chart_last_nonzero ` Collect chart_last_domain_nonzeroP", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>(x, c). x /\\<^sub>R c) `\n               {x. snd x \\<noteq> 0 \\<and> x \\<in> UNIV - {0}}", "apply (auto simp: split_beta')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x. fst x /\\<^sub>R snd x) `\n               {x. snd x \\<noteq> 0 \\<and> x \\<noteq> 0}", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x. fst x /\\<^sub>R snd x) `\n            {x. snd x \\<noteq> 0 \\<and> x \\<noteq> 0}", "by (rule image_eqI[where x=\"(x, 1)\"]) (auto simp: prod_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa. chart_last_domainP (chart_last_inv xa)\n 2. \\<And>x.\n       chart_last_domainP x \\<Longrightarrow> x \\<in> range chart_last_inv", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_last_domainP (chart_last_inv xa_)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. chart_last_domain_nonzeroP (chart_last_inv_nonzero xa)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. snd (xa, 1) \\<noteq> 0", "by (auto simp: split_beta')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       chart_last_domainP x \\<Longrightarrow> x \\<in> range chart_last_inv", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_last_domainP x \\<Longrightarrow> x \\<in> range chart_last_inv", "by (rule image_eqI[where x=\"chart_last x\"]) (auto simp: chart_last_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lift_definition last_chart::\"('a::euclidean_space proj_space, 'a) chart\" is\n  \"(Collect chart_last_domainP, UNIV, chart_last, chart_last_inv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Collect chart_last_domainP, UNIV, chart_last, chart_last_inv)\n    \\<in> {(d, d', f, f').\n           open d \\<and> open d' \\<and> homeomorphism d d' f f'}", "using homeomorphism_chart_last open_chart_last_domain"], ["proof (prove)\nusing this:\n  homeomorphism (Collect chart_last_domainP) UNIV chart_last chart_last_inv\n  open (Collect chart_last_domainP)\n\ngoal (1 subgoal):\n 1. (Collect chart_last_domainP, UNIV, chart_last, chart_last_inv)\n    \\<in> {(d, d', f, f').\n           open d \\<and> open d' \\<and> homeomorphism d d' f f'}", "by auto"], ["", "subsubsection \\<open>Charts for first \\<open>DIM('a)\\<close> coordinates\\<close>"], ["", "lift_definition chart_basis_nonzero :: \"'a \\<Rightarrow> ('a::euclidean_space\\<times>real)nonzero \\<Rightarrow> 'a\" is\n  \"\\<lambda>b. \\<lambda>(x,c). (x + (c - x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R (x \\<bullet> b)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition chart_basis :: \"'a \\<Rightarrow> 'a::euclidean_space proj_space \\<Rightarrow> 'a\" is\n  chart_basis_nonzero"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a nonzero1 nonzero2.\n       proj_rel nonzero1 nonzero2 \\<Longrightarrow>\n       chart_basis_nonzero a nonzero1 = chart_basis_nonzero a nonzero2", "apply (erule proj_rel.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a nonzero1 nonzero2 c.\n       \\<lbrakk>nonzero2 = c *\\<^sub>R nonzero1; c \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> chart_basis_nonzero a nonzero1 =\n                         chart_basis_nonzero a nonzero2", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a nonzero1 nonzero2 c.\n       \\<lbrakk>nonzero1 \\<in> UNIV - {0}; nonzero2 \\<in> UNIV - {0};\n        nonzero2 = (if c = 0 then One else c *\\<^sub>R nonzero1);\n        c \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (case nonzero1 of\n                          (x, c) \\<Rightarrow>\n                            (x + (c - x \\<bullet> a) *\\<^sub>R a) /\\<^sub>R\n                            (x \\<bullet> a)) =\n                         (case nonzero2 of\n                          (x, c) \\<Rightarrow>\n                            (x + (c - x \\<bullet> a) *\\<^sub>R a) /\\<^sub>R\n                            (x \\<bullet> a))", "by (auto simp add: divide_simps algebra_simps)"], ["", "lift_definition chart_basis_domain_nonzeroP :: \"'a \\<Rightarrow> ('a::euclidean_space\\<times>real) nonzero \\<Rightarrow> bool\" is\n  \"\\<lambda>b (x, _). (x \\<bullet> b) \\<noteq> 0\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition chart_basis_domainP :: \"'a \\<Rightarrow> 'a::euclidean_space proj_space \\<Rightarrow> bool\" is chart_basis_domain_nonzeroP"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a nonzero1 nonzero2.\n       proj_rel nonzero1 nonzero2 \\<Longrightarrow>\n       chart_basis_domain_nonzeroP a nonzero1 =\n       chart_basis_domain_nonzeroP a nonzero2", "unfolding rel_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a nonzero1 nonzero2.\n       proj_rel nonzero1 nonzero2 \\<Longrightarrow>\n       chart_basis_domain_nonzeroP a nonzero1 =\n       chart_basis_domain_nonzeroP a nonzero2", "apply (safe elim!: proj_rel.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a nonzero1 nonzero2 c.\n       \\<lbrakk>c \\<noteq> 0;\n        chart_basis_domain_nonzeroP a nonzero1\\<rbrakk>\n       \\<Longrightarrow> chart_basis_domain_nonzeroP a\n                          (c *\\<^sub>R nonzero1)\n 2. \\<And>a nonzero1 nonzero2 c.\n       \\<lbrakk>c \\<noteq> 0;\n        chart_basis_domain_nonzeroP a (c *\\<^sub>R nonzero1)\\<rbrakk>\n       \\<Longrightarrow> chart_basis_domain_nonzeroP a nonzero1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c_ \\<noteq> 0;\n     chart_basis_domain_nonzeroP a_ nonzero1_\\<rbrakk>\n    \\<Longrightarrow> chart_basis_domain_nonzeroP a_\n                       (c_ *\\<^sub>R nonzero1_)", "by transfer auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a nonzero1 nonzero2 c.\n       \\<lbrakk>c \\<noteq> 0;\n        chart_basis_domain_nonzeroP a (c *\\<^sub>R nonzero1)\\<rbrakk>\n       \\<Longrightarrow> chart_basis_domain_nonzeroP a nonzero1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c_ \\<noteq> 0;\n     chart_basis_domain_nonzeroP a_ (c_ *\\<^sub>R nonzero1_)\\<rbrakk>\n    \\<Longrightarrow> chart_basis_domain_nonzeroP a_ nonzero1_", "by transfer auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Proj_vimage_chart_basis_domainP:\n  \"Proj -` Collect (chart_basis_domainP b) = Collect (chart_basis_domain_nonzeroP b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Proj -` Collect (chart_basis_domainP b) =\n    Collect (chart_basis_domain_nonzeroP b)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       chart_basis_domainP b (Proj x) \\<Longrightarrow>\n       chart_basis_domain_nonzeroP b x\n 2. \\<And>x.\n       chart_basis_domain_nonzeroP b x \\<Longrightarrow>\n       x \\<in> Proj -` Collect (chart_basis_domainP b)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_basis_domainP b (Proj x_) \\<Longrightarrow>\n    chart_basis_domain_nonzeroP b x_", "by transfer'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       chart_basis_domain_nonzeroP b x \\<Longrightarrow>\n       x \\<in> Proj -` Collect (chart_basis_domainP b)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_basis_domain_nonzeroP b x \\<Longrightarrow>\n    x \\<in> Proj -` Collect (chart_basis_domainP b)", "by auto transfer"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma open_chart_basis_domain: \"open (Collect (chart_basis_domainP b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (Collect (chart_basis_domainP b))", "unfolding open_proj_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. openin (map_topology Proj euclidean) (Collect (chart_basis_domainP b))", "unfolding openin_map_topology"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect (chart_basis_domainP b)\n    \\<subseteq> Proj ` topspace euclidean \\<and>\n    openin euclidean\n     (Proj -` Collect (chart_basis_domainP b) \\<inter> topspace euclidean)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. chart_basis_domainP b x \\<Longrightarrow> x \\<in> range Proj\n 2. open {y. chart_basis_domainP b (Proj y)}", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_basis_domainP b x \\<Longrightarrow> x \\<in> range Proj", "apply (induction x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       chart_basis_domainP b (Proj y) \\<Longrightarrow>\n       Proj y \\<in> range Proj", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. open {y. chart_basis_domainP b (Proj y)}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. open {y. chart_basis_domainP b (Proj y)}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. open (Collect (chart_basis_domain_nonzeroP b))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       open\n        {x. (case x of\n             (x, uu_) \\<Rightarrow> x \\<bullet> b \\<noteq> 0) \\<and>\n            x \\<in> UNIV - {0}}", "unfolding Collect_conj_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       open\n        ({x. case x of\n             (x, uu_) \\<Rightarrow> x \\<bullet> b \\<noteq> 0} \\<inter>\n         {x. x \\<in> UNIV - {0}})", "apply (rule open_Int)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       open {x. case x of (x, uu_) \\<Rightarrow> x \\<bullet> b \\<noteq> 0}\n 2. \\<And>b. open {x. x \\<in> UNIV - {0}}", "apply (auto intro!: open_Collect_neq continuous_on_fst continuous_on_inner simp: split_beta)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma chart_basis_continuous:\n  notes [transfer_rule] = open_nonzero_openin_transfer\n  shows \"continuous_on (Collect (chart_basis_domainP b)) (chart_basis b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (Collect (chart_basis_domainP b)) (chart_basis b)", "apply (rule continuous_on_proj_spaceI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on (Proj -` Collect (chart_basis_domainP b))\n     (chart_basis b \\<circ> Proj)\n 2. open (Collect (chart_basis_domainP b))", "unfolding o_def chart_basis.abs_eq Proj_vimage_chart_basis_domainP"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on (Collect (chart_basis_domain_nonzeroP b))\n     (chart_basis_nonzero b)\n 2. open (Collect (chart_basis_domainP b))", "apply transfer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       continuous_on\n        ({x. (case x of\n              (x, uu_) \\<Rightarrow> x \\<bullet> b \\<noteq> 0) \\<and>\n             x \\<in> UNIV - {0}} \\<inter>\n         Collect (Domainp (pcr_nonzero (rel_prod (=) (=)))))\n        (\\<lambda>(x, c).\n            (x + (c - x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R (x \\<bullet> b))\n 2. open (Collect (chart_basis_domainP b))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on\n     ({x. (case x of\n           (x, uu_) \\<Rightarrow> x \\<bullet> b_ \\<noteq> 0) \\<and>\n          x \\<in> UNIV - {0}} \\<inter>\n      Collect (Domainp (pcr_nonzero (rel_prod (=) (=)))))\n     (\\<lambda>(x, c).\n         (x + (c - x \\<bullet> b_) *\\<^sub>R b_) /\\<^sub>R (x \\<bullet> b_))", "by (auto intro!: continuous_intros simp: split_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. open (Collect (chart_basis_domainP b))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. open (Collect (chart_basis_domainP b))", "by (rule open_chart_basis_domain)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context\n  fixes b::\"'a::euclidean_space\"\n  assumes b: \"b \\<in> Basis\"\nbegin"], ["", "lemma b_neq0: \"b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a)", "using b"], ["proof (prove)\nusing this:\n  b \\<in> Basis\n\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a)", "by auto"], ["", "lift_definition chart_basis_inv_nonzero :: \"'a \\<Rightarrow> ('a::euclidean_space \\<times> real) nonzero\" is\n  \"\\<lambda>x. (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (a + (1 - a \\<bullet> b) *\\<^sub>R b, a \\<bullet> b) \\<in> UNIV - {0}", "apply (auto simp: zero_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a + b = (0::'a); a \\<bullet> b = 0\\<rbrakk>\n       \\<Longrightarrow> False", "using b_neq0"], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a + b = (0::'a); a \\<bullet> b = 0\\<rbrakk>\n       \\<Longrightarrow> False", "using eq_neg_iff_add_eq_0"], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n  (?a = - ?b) = (?a + ?b = (0::?'a))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a + b = (0::'a); a \\<bullet> b = 0\\<rbrakk>\n       \\<Longrightarrow> False", "by force"], ["", "lift_definition chart_basis_inv :: \"'a \\<Rightarrow> 'a::euclidean_space proj_space\" is\n  chart_basis_inv_nonzero"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma chart_basis_inv_continuous:\n  notes [transfer_rule] = open_nonzero_openin_transfer\n  shows \"continuous_on UNIV chart_basis_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV local.chart_basis_inv", "unfolding chart_basis_inv_def map_fun_def comp_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV (Proj \\<circ> local.chart_basis_inv_nonzero)", "apply (rule continuous_on_compose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on UNIV local.chart_basis_inv_nonzero\n 2. continuous_on (range local.chart_basis_inv_nonzero) Proj", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV local.chart_basis_inv_nonzero", "by transfer (auto intro!: continuous_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (range local.chart_basis_inv_nonzero) Proj", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (range local.chart_basis_inv_nonzero) Proj", "unfolding continuous_map_iff_continuous euclidean_proj_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (range local.chart_basis_inv_nonzero) Proj", "using continuous_on_open_invariant open_vimage_Proj_iff"], ["proof (prove)\nusing this:\n  continuous_on ?s ?f =\n  (\\<forall>B.\n      open B \\<longrightarrow>\n      (\\<exists>A. open A \\<and> A \\<inter> ?s = ?f -` B \\<inter> ?s))\n  open (Proj -` ?T) = open ?T\n\ngoal (1 subgoal):\n 1. continuous_on (range local.chart_basis_inv_nonzero) Proj", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma chart_basis_inv_inverse: \"chart_basis b (chart_basis_inv x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_basis b (local.chart_basis_inv x) = x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. chart_basis_nonzero b (local.chart_basis_inv_nonzero x) = x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b) of\n        (x, c) \\<Rightarrow>\n          (x + (c - x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R (x \\<bullet> b)) =\n       x", "using b_neq0 b"], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n  b \\<in> Basis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b) of\n        (x, c) \\<Rightarrow>\n          (x + (c - x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R (x \\<bullet> b)) =\n       x", "by (auto simp: algebra_simps divide_simps)"], ["", "lemma chart_basis_inverse: \"chart_basis_inv (chart_basis b x) = x\" if \"chart_basis_domainP b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.chart_basis_inv (chart_basis b x) = x", "using that"], ["proof (prove)\nusing this:\n  chart_basis_domainP b x\n\ngoal (1 subgoal):\n 1. local.chart_basis_inv (chart_basis b x) = x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       chart_basis_domain_nonzeroP b x \\<Longrightarrow>\n       proj_rel (local.chart_basis_inv_nonzero (chart_basis_nonzero b x)) x", "unfolding proj_rel_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       chart_basis_domain_nonzeroP b x \\<Longrightarrow>\n       \\<exists>c.\n          c \\<noteq> 0 \\<and>\n          x =\n          c *\\<^sub>R\n          local.chart_basis_inv_nonzero (chart_basis_nonzero b x)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV - {0};\n        case x of (x, uu_) \\<Rightarrow> x \\<bullet> b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            c \\<noteq> 0 \\<and>\n                            x =\n                            (if c = 0 then One\n                             else c *\\<^sub>R\n                                  ((case x of\n                                    (x, c) \\<Rightarrow>\n(x + (c - x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R (x \\<bullet> b)) +\n                                   (1 -\n                                    (case x of\n                                     (x, c) \\<Rightarrow>\n (x + (c - x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R (x \\<bullet> b)) \\<bullet>\n                                    b) *\\<^sub>R\n                                   b,\n                                   (case x of\n                                    (x, c) \\<Rightarrow>\n(x + (c - x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R (x \\<bullet> b)) \\<bullet>\n                                   b))", "apply (simp add: split_beta prod_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>fst x = (0::'a) \\<longrightarrow> snd x \\<noteq> 0;\n        fst x \\<bullet> b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c.\n                            c \\<noteq> 0 \\<and>\n                            (c \\<noteq> 0 \\<longrightarrow>\n                             fst x =\n                             c *\\<^sub>R\n                             ((fst x +\n                               (snd x - fst x \\<bullet> b) *\\<^sub>R\n                               b) /\\<^sub>R\n                              (fst x \\<bullet> b) +\n                              (1 -\n                               inverse (fst x \\<bullet> b) *\n                               ((fst x +\n                                 (snd x - fst x \\<bullet> b) *\\<^sub>R\n                                 b) \\<bullet>\n                                b)) *\\<^sub>R\n                              b) \\<and>\n                             snd x =\n                             c *\n                             (inverse (fst x \\<bullet> b) *\n                              ((fst x +\n                                (snd x - fst x \\<bullet> b) *\\<^sub>R\n                                b) \\<bullet>\n                               b)))", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst x = (0::'a) \\<longrightarrow> snd x \\<noteq> 0;\n     fst x \\<bullet> b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c.\n                         c \\<noteq> 0 \\<and>\n                         (c \\<noteq> 0 \\<longrightarrow>\n                          fst x =\n                          c *\\<^sub>R\n                          ((fst x +\n                            (snd x - fst x \\<bullet> b) *\\<^sub>R\n                            b) /\\<^sub>R\n                           (fst x \\<bullet> b) +\n                           (1 -\n                            inverse (fst x \\<bullet> b) *\n                            ((fst x +\n                              (snd x - fst x \\<bullet> b) *\\<^sub>R\n                              b) \\<bullet>\n                             b)) *\\<^sub>R\n                           b) \\<and>\n                          snd x =\n                          c *\n                          (inverse (fst x \\<bullet> b) *\n                           ((fst x +\n                             (snd x - fst x \\<bullet> b) *\\<^sub>R\n                             b) \\<bullet>\n                            b)))", "apply (rule exI[where x=\"fst x \\<bullet> b\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst x = (0::'a) \\<longrightarrow> snd x \\<noteq> 0;\n     fst x \\<bullet> b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fst x \\<bullet> b \\<noteq> 0 \\<and>\n                      (fst x \\<bullet> b \\<noteq> 0 \\<longrightarrow>\n                       fst x =\n                       (fst x \\<bullet> b) *\\<^sub>R\n                       ((fst x +\n                         (snd x - fst x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R\n                        (fst x \\<bullet> b) +\n                        (1 -\n                         inverse (fst x \\<bullet> b) *\n                         ((fst x +\n                           (snd x - fst x \\<bullet> b) *\\<^sub>R\n                           b) \\<bullet>\n                          b)) *\\<^sub>R\n                        b) \\<and>\n                       snd x =\n                       fst x \\<bullet> b *\n                       (inverse (fst x \\<bullet> b) *\n                        ((fst x +\n                          (snd x - fst x \\<bullet> b) *\\<^sub>R b) \\<bullet>\n                         b)))", "using b"], ["proof (prove)\nusing this:\n  b \\<in> Basis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst x = (0::'a) \\<longrightarrow> snd x \\<noteq> 0;\n     fst x \\<bullet> b \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> fst x \\<bullet> b \\<noteq> 0 \\<and>\n                      (fst x \\<bullet> b \\<noteq> 0 \\<longrightarrow>\n                       fst x =\n                       (fst x \\<bullet> b) *\\<^sub>R\n                       ((fst x +\n                         (snd x - fst x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R\n                        (fst x \\<bullet> b) +\n                        (1 -\n                         inverse (fst x \\<bullet> b) *\n                         ((fst x +\n                           (snd x - fst x \\<bullet> b) *\\<^sub>R\n                           b) \\<bullet>\n                          b)) *\\<^sub>R\n                        b) \\<and>\n                       snd x =\n                       fst x \\<bullet> b *\n                       (inverse (fst x \\<bullet> b) *\n                        ((fst x +\n                          (snd x - fst x \\<bullet> b) *\\<^sub>R b) \\<bullet>\n                         b)))", "by (simp add: algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma chart_basis_domainP_chart_basis_inv: \"chart_basis_domainP b (chart_basis_inv x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_basis_domainP b (local.chart_basis_inv x)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. chart_basis_domain_nonzeroP b (local.chart_basis_inv_nonzero x)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       case (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b) of\n       (x, uu_) \\<Rightarrow> x \\<bullet> b \\<noteq> 0", "by (use b in \\<open>auto simp: algebra_simps\\<close>)"], ["", "lemma homeomorphism_chart_basis:\n  \"homeomorphism (Collect (chart_basis_domainP b)) UNIV (chart_basis b) chart_basis_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homeomorphism (Collect (chart_basis_domainP b)) UNIV (chart_basis b)\n     local.chart_basis_inv", "apply (auto simp: homeomorphism_def chart_basis_inverse chart_basis_inv_inverse\n      chart_basis_continuous chart_basis_inv_continuous)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> chart_basis b ` Collect (chart_basis_domainP b)\n 2. \\<And>xa. chart_basis_domainP b (local.chart_basis_inv xa)\n 3. \\<And>x.\n       chart_basis_domainP b x \\<Longrightarrow>\n       x \\<in> range local.chart_basis_inv", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> chart_basis b ` Collect (chart_basis_domainP b)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> chart_basis_nonzero b `\n               Collect (chart_basis_domain_nonzeroP b)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>(x, c).\n                   (x + (c - x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R\n                   (x \\<bullet> b)) `\n               {x. (case x of\n                    (x, uu_) \\<Rightarrow> x \\<bullet> b \\<noteq> 0) \\<and>\n                   x \\<in> UNIV - {0}}", "apply (auto simp: split_beta')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>x.\n                   (fst x +\n                    (snd x - fst x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R\n                   (fst x \\<bullet> b)) `\n               {x. fst x \\<bullet> b \\<noteq> 0 \\<and> x \\<noteq> 0}", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>x.\n                (fst x + (snd x - fst x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R\n                (fst x \\<bullet> b)) `\n            {x. fst x \\<bullet> b \\<noteq> 0 \\<and> x \\<noteq> 0}", "apply (rule image_eqI[where x=\"(x + (1 - (x \\<bullet> b)) *\\<^sub>R b, x \\<bullet> b)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x =\n    (fst (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b) +\n     (snd (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b) -\n      fst (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b) \\<bullet>\n      b) *\\<^sub>R\n     b) /\\<^sub>R\n    (fst (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b) \\<bullet> b)\n 2. (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b)\n    \\<in> {x. fst x \\<bullet> b \\<noteq> 0 \\<and> x \\<noteq> 0}", "using b"], ["proof (prove)\nusing this:\n  b \\<in> Basis\n\ngoal (2 subgoals):\n 1. x =\n    (fst (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b) +\n     (snd (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b) -\n      fst (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b) \\<bullet>\n      b) *\\<^sub>R\n     b) /\\<^sub>R\n    (fst (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b) \\<bullet> b)\n 2. (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b)\n    \\<in> {x. fst x \\<bullet> b \\<noteq> 0 \\<and> x \\<noteq> 0}", "apply (auto simp add: algebra_simps divide_simps prod_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> Basis; b + x = (0::'a); x \\<bullet> b = 0\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis add.right_neutral b_neq0 inner_commute inner_eq_zero_iff inner_right_distrib inner_zero_right)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa. chart_basis_domainP b (local.chart_basis_inv xa)\n 2. \\<And>x.\n       chart_basis_domainP b x \\<Longrightarrow>\n       x \\<in> range local.chart_basis_inv", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_basis_domainP b (local.chart_basis_inv xa_)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       chart_basis_domain_nonzeroP b (local.chart_basis_inv_nonzero xa)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       case (xa + (1 - xa \\<bullet> b) *\\<^sub>R b, xa \\<bullet> b) of\n       (x, uu_) \\<Rightarrow> x \\<bullet> b \\<noteq> 0", "using b"], ["proof (prove)\nusing this:\n  b \\<in> Basis\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       case (xa + (1 - xa \\<bullet> b) *\\<^sub>R b, xa \\<bullet> b) of\n       (x, uu_) \\<Rightarrow> x \\<bullet> b \\<noteq> 0", "by (auto simp: split_beta' algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       chart_basis_domainP b x \\<Longrightarrow>\n       x \\<in> range local.chart_basis_inv", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. chart_basis_domainP b x \\<Longrightarrow>\n    x \\<in> range local.chart_basis_inv", "by (rule image_eqI[where x=\"chart_basis b x\"]) (auto simp: chart_basis_inverse)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lift_definition basis_chart::\"('a proj_space, 'a) chart\"\n  is \"(Collect (chart_basis_domainP b), UNIV, chart_basis b, chart_basis_inv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Collect (chart_basis_domainP b), UNIV, chart_basis b,\n     local.chart_basis_inv)\n    \\<in> {(d, d', f, f').\n           open d \\<and> open d' \\<and> homeomorphism d d' f f'}", "using homeomorphism_chart_basis"], ["proof (prove)\nusing this:\n  homeomorphism (Collect (chart_basis_domainP b)) UNIV (chart_basis b)\n   local.chart_basis_inv\n\ngoal (1 subgoal):\n 1. (Collect (chart_basis_domainP b), UNIV, chart_basis b,\n     local.chart_basis_inv)\n    \\<in> {(d, d', f, f').\n           open d \\<and> open d' \\<and> homeomorphism d d' f f'}", "by (auto simp: open_chart_basis_domain)"], ["", "end"], ["", "subsubsection \\<open>Atlas\\<close>"], ["", "definition \"charts_proj_space = insert last_chart (basis_chart ` Basis)\""], ["", "lemma chart_last_basis_defined:\n  \"chart_last_domainP xa \\<Longrightarrow> chart_basis_domainP b xa \\<Longrightarrow> chart_last xa \\<bullet> b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>chart_last_domainP xa; chart_basis_domainP b xa\\<rbrakk>\n    \\<Longrightarrow> chart_last xa \\<bullet> b \\<noteq> 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa b.\n       \\<lbrakk>chart_last_domain_nonzeroP xa;\n        chart_basis_domain_nonzeroP b xa\\<rbrakk>\n       \\<Longrightarrow> chart_last_nonzero xa \\<bullet> b \\<noteq> 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa b.\n       \\<lbrakk>xa \\<in> UNIV - {0}; snd xa \\<noteq> 0;\n        case xa of (x, uu_) \\<Rightarrow> x \\<bullet> b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (case xa of\n                          (x, c) \\<Rightarrow> x /\\<^sub>R c) \\<bullet>\n                         b \\<noteq>\n                         0", "by (auto simp: prod_eq_iff)"], ["", "lemma chart_basis_last_defined:\n  \"b \\<in> Basis \\<Longrightarrow> chart_last_domainP xa \\<Longrightarrow> chart_basis_domainP b xa \\<Longrightarrow> chart_basis b xa \\<bullet> b \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> Basis; chart_last_domainP xa;\n     chart_basis_domainP b xa\\<rbrakk>\n    \\<Longrightarrow> chart_basis b xa \\<bullet> b \\<noteq> 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b xa.\n       \\<lbrakk>b \\<in> Basis; chart_last_domain_nonzeroP xa;\n        chart_basis_domain_nonzeroP b xa\\<rbrakk>\n       \\<Longrightarrow> chart_basis_nonzero b xa \\<bullet> b \\<noteq> 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b xa.\n       \\<lbrakk>xa \\<in> UNIV - {0}; b \\<in> Basis; snd xa \\<noteq> 0;\n        case xa of (x, uu_) \\<Rightarrow> x \\<bullet> b \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> (case xa of\n                          (x, c) \\<Rightarrow>\n                            (x + (c - x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R\n                            (x \\<bullet> b)) \\<bullet>\n                         b \\<noteq>\n                         0", "by (auto simp: prod_eq_iff algebra_simps)"], ["", "lemma compat_last_chart: \"\\<infinity>-smooth_compat last_chart (basis_chart b)\"\n  if [transfer_rule]: \"b \\<in> Basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity>-smooth_compat last_chart (basis_chart b)", "unfolding smooth_compat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on\n     (apply_chart last_chart `\n      (domain last_chart \\<inter> domain (basis_chart b)))\n     (apply_chart (basis_chart b) \\<circ> inv_chart last_chart) \\<and>\n    smooth_on\n     (apply_chart (basis_chart b) `\n      (domain last_chart \\<inter> domain (basis_chart b)))\n     (apply_chart last_chart \\<circ> inv_chart (basis_chart b))", "proof (transfer; auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. smooth_on\n     (chart_last `\n      (Collect chart_last_domainP \\<inter> Collect (chart_basis_domainP b)))\n     (chart_basis b \\<circ> chart_last_inv)\n 2. smooth_on\n     (chart_basis b `\n      (Collect chart_last_domainP \\<inter> Collect (chart_basis_domainP b)))\n     (chart_last \\<circ> chart_basis_inv b)", "have \"smooth_on {x. x \\<bullet> b \\<noteq> 0} (chart_basis b \\<circ> chart_last_inv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on {x. x \\<bullet> b \\<noteq> 0}\n     (chart_basis b \\<circ> chart_last_inv)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on {x. x \\<bullet> b \\<noteq> 0}\n     (chart_basis_nonzero b \\<circ> chart_last_inv_nonzero)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on {x. x \\<bullet> b \\<noteq> 0}\n     ((\\<lambda>(x, c).\n          (x + (c - x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R\n          (x \\<bullet> b)) \\<circ>\n      (\\<lambda>x. (x, 1)))", "by (auto simp: o_def intro!: smooth_on_inverse smooth_on_scaleR smooth_on_inner smooth_on_add\n        smooth_on_minus open_Collect_neq continuous_intros)"], ["proof (state)\nthis:\n  smooth_on {x. x \\<bullet> b \\<noteq> 0}\n   (chart_basis b \\<circ> chart_last_inv)\n\ngoal (2 subgoals):\n 1. smooth_on\n     (chart_last `\n      (Collect chart_last_domainP \\<inter> Collect (chart_basis_domainP b)))\n     (chart_basis b \\<circ> chart_last_inv)\n 2. smooth_on\n     (chart_basis b `\n      (Collect chart_last_domainP \\<inter> Collect (chart_basis_domainP b)))\n     (chart_last \\<circ> chart_basis_inv b)", "then"], ["proof (chain)\npicking this:\n  smooth_on {x. x \\<bullet> b \\<noteq> 0}\n   (chart_basis b \\<circ> chart_last_inv)", "show \"smooth_on (chart_last ` (Collect chart_last_domainP \\<inter> Collect (chart_basis_domainP b))) (chart_basis b \\<circ> chart_last_inv)\""], ["proof (prove)\nusing this:\n  smooth_on {x. x \\<bullet> b \\<noteq> 0}\n   (chart_basis b \\<circ> chart_last_inv)\n\ngoal (1 subgoal):\n 1. smooth_on\n     (chart_last `\n      (Collect chart_last_domainP \\<inter> Collect (chart_basis_domainP b)))\n     (chart_basis b \\<circ> chart_last_inv)", "by (rule smooth_on_subset) (auto simp: chart_last_basis_defined)"], ["proof (state)\nthis:\n  smooth_on\n   (chart_last `\n    (Collect chart_last_domainP \\<inter> Collect (chart_basis_domainP b)))\n   (chart_basis b \\<circ> chart_last_inv)\n\ngoal (1 subgoal):\n 1. smooth_on\n     (chart_basis b `\n      (Collect chart_last_domainP \\<inter> Collect (chart_basis_domainP b)))\n     (chart_last \\<circ> chart_basis_inv b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. smooth_on\n     (chart_basis b `\n      (Collect chart_last_domainP \\<inter> Collect (chart_basis_domainP b)))\n     (chart_last \\<circ> chart_basis_inv b)", "have \"smooth_on {x. x \\<bullet> b \\<noteq> 0}  (chart_last \\<circ> chart_basis_inv b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on {x. x \\<bullet> b \\<noteq> 0}\n     (chart_last \\<circ> chart_basis_inv b)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on {x. x \\<bullet> b \\<noteq> 0}\n     (chart_last_nonzero \\<circ> chart_basis_inv_nonzero b)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on {x. x \\<bullet> b \\<noteq> 0}\n     ((\\<lambda>(x, c). x /\\<^sub>R c) \\<circ>\n      (\\<lambda>x. (x + (1 - x \\<bullet> b) *\\<^sub>R b, x \\<bullet> b)))", "by (auto simp: o_def intro!: smooth_on_add smooth_on_scaleR smooth_on_minus smooth_on_inverse \n        smooth_on_inner open_Collect_neq continuous_intros)"], ["proof (state)\nthis:\n  smooth_on {x. x \\<bullet> b \\<noteq> 0}\n   (chart_last \\<circ> chart_basis_inv b)\n\ngoal (1 subgoal):\n 1. smooth_on\n     (chart_basis b `\n      (Collect chart_last_domainP \\<inter> Collect (chart_basis_domainP b)))\n     (chart_last \\<circ> chart_basis_inv b)", "then"], ["proof (chain)\npicking this:\n  smooth_on {x. x \\<bullet> b \\<noteq> 0}\n   (chart_last \\<circ> chart_basis_inv b)", "show \"smooth_on (chart_basis b ` (Collect chart_last_domainP \\<inter> Collect (chart_basis_domainP b))) (chart_last \\<circ> chart_basis_inv b)\""], ["proof (prove)\nusing this:\n  smooth_on {x. x \\<bullet> b \\<noteq> 0}\n   (chart_last \\<circ> chart_basis_inv b)\n\ngoal (1 subgoal):\n 1. smooth_on\n     (chart_basis b `\n      (Collect chart_last_domainP \\<inter> Collect (chart_basis_domainP b)))\n     (chart_last \\<circ> chart_basis_inv b)", "by (rule smooth_on_subset) (auto simp: chart_basis_last_defined that)"], ["proof (state)\nthis:\n  smooth_on\n   (chart_basis b `\n    (Collect chart_last_domainP \\<inter> Collect (chart_basis_domainP b)))\n   (chart_last \\<circ> chart_basis_inv b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smooth_on_basis_comp_inv: \"smooth_on {x. (x + (1 - x \\<bullet> a) *\\<^sub>R a) \\<bullet> b \\<noteq> 0} (chart_basis b \\<circ> chart_basis_inv a)\"\n  if [transfer_rule]: \"a \\<in> Basis\" \"b \\<in> Basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on\n     {x. (x + (1 - x \\<bullet> a) *\\<^sub>R a) \\<bullet> b \\<noteq> 0}\n     (chart_basis b \\<circ> chart_basis_inv a)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on\n     {x. (x + (1 - x \\<bullet> a) *\\<^sub>R a) \\<bullet> b \\<noteq> 0}\n     (chart_basis_nonzero b \\<circ> chart_basis_inv_nonzero a)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. smooth_on\n     {x. (x + (1 - x \\<bullet> a) *\\<^sub>R a) \\<bullet> b \\<noteq> 0}\n     ((\\<lambda>(x, c).\n          (x + (c - x \\<bullet> b) *\\<^sub>R b) /\\<^sub>R\n          (x \\<bullet> b)) \\<circ>\n      (\\<lambda>x. (x + (1 - x \\<bullet> a) *\\<^sub>R a, x \\<bullet> a)))", "by (auto intro!: smooth_on_add smooth_on_scaleR smooth_on_minus smooth_on_inner smooth_on_inverse\n    smooth_on_mult open_Collect_neq continuous_intros simp: o_def algebra_simps inner_Basis)"], ["", "lemma chart_basis_basis_defined:\n  \"a \\<noteq> b \\<Longrightarrow> chart_basis_domainP a xa \\<Longrightarrow> chart_basis_domainP b xa \\<Longrightarrow> chart_basis a xa \\<bullet> b \\<noteq> 0\"\n  if \"a \\<in> Basis\" \"b \\<in> Basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; chart_basis_domainP a xa;\n     chart_basis_domainP b xa\\<rbrakk>\n    \\<Longrightarrow> chart_basis a xa \\<bullet> b \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  a \\<in> Basis\n  b \\<in> Basis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> b; chart_basis_domainP a xa;\n     chart_basis_domainP b xa\\<rbrakk>\n    \\<Longrightarrow> chart_basis a xa \\<bullet> b \\<noteq> 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b xa.\n       \\<lbrakk>a \\<noteq> b; chart_basis_domain_nonzeroP a xa;\n        chart_basis_domain_nonzeroP b xa; a \\<in> Basis;\n        b \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> chart_basis_nonzero a xa \\<bullet> b \\<noteq> 0", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b xa.\n       \\<lbrakk>xa \\<in> UNIV - {0}; a \\<noteq> b;\n        case xa of (x, uu_) \\<Rightarrow> x \\<bullet> a \\<noteq> 0;\n        case xa of (x, uu_) \\<Rightarrow> x \\<bullet> b \\<noteq> 0;\n        a \\<in> Basis; b \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> (case xa of\n                          (x, c) \\<Rightarrow>\n                            (x + (c - x \\<bullet> a) *\\<^sub>R a) /\\<^sub>R\n                            (x \\<bullet> a)) \\<bullet>\n                         b \\<noteq>\n                         0", "by (auto simp: algebra_simps inner_Basis prod_eq_iff)"], ["", "lemma compat_basis_chart: \"\\<infinity>-smooth_compat (basis_chart a) (basis_chart b)\"\n  if [transfer_rule]: \"a \\<in> Basis\" \"b \\<in> Basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity>-smooth_compat (basis_chart a) (basis_chart b)", "apply (cases \"a = b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    \\<infinity>-smooth_compat (basis_chart a) (basis_chart b)\n 2. a \\<noteq> b \\<Longrightarrow>\n    \\<infinity>-smooth_compat (basis_chart a) (basis_chart b)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b \\<Longrightarrow>\n    \\<infinity>-smooth_compat (basis_chart a) (basis_chart b)", "by (auto simp: smooth_compat_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    \\<infinity>-smooth_compat (basis_chart a) (basis_chart b)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    \\<infinity>-smooth_compat (basis_chart a) (basis_chart b)", "unfolding smooth_compat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    smooth_on\n     (apply_chart (basis_chart a) `\n      (domain (basis_chart a) \\<inter> domain (basis_chart b)))\n     (apply_chart (basis_chart b) \\<circ> inv_chart (basis_chart a)) \\<and>\n    smooth_on\n     (apply_chart (basis_chart b) `\n      (domain (basis_chart a) \\<inter> domain (basis_chart b)))\n     (apply_chart (basis_chart a) \\<circ> inv_chart (basis_chart b))", "apply (transfer; auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<noteq> b \\<Longrightarrow>\n    smooth_on\n     (chart_basis a `\n      (Collect (chart_basis_domainP a) \\<inter>\n       Collect (chart_basis_domainP b)))\n     (chart_basis b \\<circ> chart_basis_inv a)\n 2. a \\<noteq> b \\<Longrightarrow>\n    smooth_on\n     (chart_basis b `\n      (Collect (chart_basis_domainP a) \\<inter>\n       Collect (chart_basis_domainP b)))\n     (chart_basis a \\<circ> chart_basis_inv b)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    smooth_on\n     (chart_basis a `\n      (Collect (chart_basis_domainP a) \\<inter>\n       Collect (chart_basis_domainP b)))\n     (chart_basis b \\<circ> chart_basis_inv a)", "using smooth_on_basis_comp_inv[OF that]"], ["proof (prove)\nusing this:\n  smooth_on\n   {x. (x + (1 - x \\<bullet> a) *\\<^sub>R a) \\<bullet> b \\<noteq> 0}\n   (chart_basis b \\<circ> chart_basis_inv a)\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    smooth_on\n     (chart_basis a `\n      (Collect (chart_basis_domainP a) \\<inter>\n       Collect (chart_basis_domainP b)))\n     (chart_basis b \\<circ> chart_basis_inv a)", "apply (rule smooth_on_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    chart_basis a `\n    (Collect (chart_basis_domainP a) \\<inter>\n     Collect (chart_basis_domainP b))\n    \\<subseteq> {x. (x + (1 - x \\<bullet> a) *\\<^sub>R a) \\<bullet>\n                    b \\<noteq>\n                    0}", "by (auto simp: algebra_simps inner_Basis chart_basis_basis_defined that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    smooth_on\n     (chart_basis b `\n      (Collect (chart_basis_domainP a) \\<inter>\n       Collect (chart_basis_domainP b)))\n     (chart_basis a \\<circ> chart_basis_inv b)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    smooth_on\n     (chart_basis b `\n      (Collect (chart_basis_domainP a) \\<inter>\n       Collect (chart_basis_domainP b)))\n     (chart_basis a \\<circ> chart_basis_inv b)", "using smooth_on_basis_comp_inv[OF that(2,1)]"], ["proof (prove)\nusing this:\n  smooth_on\n   {x. (x + (1 - x \\<bullet> b) *\\<^sub>R b) \\<bullet> a \\<noteq> 0}\n   (chart_basis a \\<circ> chart_basis_inv b)\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    smooth_on\n     (chart_basis b `\n      (Collect (chart_basis_domainP a) \\<inter>\n       Collect (chart_basis_domainP b)))\n     (chart_basis a \\<circ> chart_basis_inv b)", "apply (rule smooth_on_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    chart_basis b `\n    (Collect (chart_basis_domainP a) \\<inter>\n     Collect (chart_basis_domainP b))\n    \\<subseteq> {x. (x + (1 - x \\<bullet> b) *\\<^sub>R b) \\<bullet>\n                    a \\<noteq>\n                    0}", "by (auto simp: algebra_simps inner_Basis chart_basis_basis_defined that)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma c_manifold_proj_space: \"c_manifold charts_proj_space \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c_manifold charts_proj_space \\<infinity>", "by standard\n    (auto simp: charts_proj_space_def smooth_compat_refl smooth_compat_commute compat_last_chart\n      compat_basis_chart)"], ["", "end"]]}