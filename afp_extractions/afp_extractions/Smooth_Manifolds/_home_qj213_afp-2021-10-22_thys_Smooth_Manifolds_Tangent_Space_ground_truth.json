{"file_name": "/home/qj213/afp-2021-10-22/thys/Smooth_Manifolds/Tangent_Space.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Smooth_Manifolds", "problem_names": ["lemma linear_imp_linear_on: \"linear_on A B scaleR scaleR f\" if \"linear f\"\n  \"subspace A\" \"subspace B\"", "lemma (in vector_space_pair_on)\n  linear_sum':\n    \"\\<forall>x. x \\<in> S1 \\<longrightarrow> f x \\<in> S2 \\<Longrightarrow>\n    \\<forall>x. x \\<in> S \\<longrightarrow> g x \\<in> S1 \\<Longrightarrow>\n    linear_on S1 S2 scale1 scale2 f \\<Longrightarrow>\n    f (sum g S) = (\\<Sum>a\\<in>S. f (g a))\"", "lemma dim_eq: \"local.dim X = real_vector.dim X\" if \"X \\<subseteq> S\"", "lemma diff_fun_spaceD: \"diff_fun k charts f\" if \"f \\<in> diff_fun_space\"", "lemma diff_fun_space_order_le: \"diff_fun_space \\<subseteq> c_manifold.diff_fun_space charts l\" if \"l \\<le> k\"", "lemma diff_fun_space_extensionalD:\n  \"g \\<in> diff_fun_space \\<Longrightarrow> extensional0 carrier g\"", "lemma diff_fun_space_eq: \"diff_fun_space = {f. diff_fun k charts f} \\<inter> {f. extensional0 carrier f}\"", "lemma subspace_diff_fun_space[intro, simp]:\n  \"subspace diff_fun_space\"", "lemma diff_fun_space_times: \"f * g \\<in> diff_fun_space\"\n  if \"f \\<in> diff_fun_space\" \"g \\<in> diff_fun_space\"", "lemma diff_fun_space_add: \"f + g \\<in> diff_fun_space\"\n  if \"f \\<in> diff_fun_space\" \"g \\<in> diff_fun_space\"", "lemma is_derivationI:\n  \"is_derivation X p\"\n  if \"linear_diff_fun X\"\n    \"\\<And>f g. f \\<in> diff_fun_space \\<Longrightarrow> g \\<in> diff_fun_space \\<Longrightarrow> X (f * g) = f p * X g + g p * X f\"", "lemma is_derivationD:\n  assumes \"is_derivation X p\"\n  shows is_derivation_linear_on: \"linear_diff_fun X\"\n    and is_derivation_derivation: \"\\<And>f g. f \\<in> diff_fun_space \\<Longrightarrow> g \\<in> diff_fun_space \\<Longrightarrow> X (f * g) = f p * X g + g p * X f\"", "lemma manifold_eucl_diff_fun_space_iff[simp]:\n  \"g \\<in> manifold_eucl.diff_fun_space k \\<longleftrightarrow> k-smooth_on UNIV g\"", "lemma tangent_space_eq: \"tangent_space p = {X. is_derivation X p} \\<inter> {X. extensional0 diff_fun_space X}\"", "lemma mem_tangent_space: \"X \\<in> tangent_space p \\<longleftrightarrow> is_derivation X p \\<and> extensional0 diff_fun_space X\"", "lemma tangent_spaceI:\n  \"X \\<in> tangent_space p\"\n  if\n    \"extensional0 diff_fun_space X\"\n    \"linear_diff_fun X\"\n    \"\\<And>f g. f \\<in> diff_fun_space \\<Longrightarrow> g \\<in> diff_fun_space \\<Longrightarrow> X (f * g) = f p * X g + g p * X f\"", "lemma tangent_spaceD:\n  assumes \"X \\<in> tangent_space p\"\n  shows tangent_space_linear_on: \"linear_diff_fun X\"\n    and tangent_space_restrict: \"extensional0 diff_fun_space X\"\n    and tangent_space_derivation: \"\\<And>f g. f \\<in> diff_fun_space \\<Longrightarrow> g \\<in> diff_fun_space \\<Longrightarrow> X (f * g) = f p * X g + g p * X f\"", "lemma is_derivation_0: \"is_derivation 0 p\"", "lemma is_derivation_add: \"is_derivation (x + y) p\"\n  if x: \"is_derivation x p\" and y: \"is_derivation y p\"", "lemma is_derivation_scaleR: \"is_derivation (c *\\<^sub>R x) p\"\n  if x: \"is_derivation x p\"", "lemma subspace_is_derivation: \"subspace {X. is_derivation X p}\"", "lemma subspace_tangent_space: \"subspace (tangent_space p)\"", "lemma tangent_space_dim_eq: \"tangent_space.dim p X = dim X\"\n  if \"X \\<subseteq> tangent_space p\"", "lemma restrict0_in_fun_space: \"restrict0 carrier f \\<in> diff_fun_space\"\n  if \"diff_fun k charts f\"", "lemma restrict0_const_diff_fun_space: \"restrict0 carrier (\\<lambda>x. c) \\<in> diff_fun_space\"", "lemma derivation_one_eq_zero: \"X (restrict0 carrier (\\<lambda>x. 1)) = 0\" (is \"X ?f1 = _\")\n  if \"X \\<in> tangent_space p\" \"p \\<in> carrier\"", "lemma derivation_const_eq_zero: \"X (restrict0 carrier (\\<lambda>x. c)) = 0\"\n  if \"X \\<in> tangent_space p\" \"p \\<in> carrier\"", "lemma derivation_times_eq_zeroI: \"X (f * g) = 0\" if X:\"X \\<in> tangent_space p\"\n  and d: \"f \\<in> diff_fun_space\" \"g \\<in> diff_fun_space\"\n  and z: \"f p = 0\" \"g p = 0\"", "lemma derivation_zero_localI: \"X f = 0\"\n  if \"open W\" \"p \\<in> W\" \"W \\<subseteq> carrier\"\n    \"X \\<in> tangent_space p\"\n    \"f \\<in> diff_fun_space\"\n    \"\\<And>x. x \\<in> W \\<Longrightarrow> f x = 0\"", "lemma derivation_eq_localI: \"X f = X g\"\n  if \"open U\" \"p \\<in> U\" \"U \\<subseteq> carrier\"\n    \"X \\<in> tangent_space p\"\n    \"f \\<in> diff_fun_space\"\n    \"g \\<in> diff_fun_space\"\n    \"\\<And>x. x \\<in> U \\<Longrightarrow> f x = g x\"", "lemma extensional_push_forward: \"extensional0 dest.diff_fun_space (push_forward X)\"", "lemma linear_push_forward: \"linear push_forward\"", "lemma restrict_compose_in_diff_fun_space:\n  \"x \\<in> dest.diff_fun_space \\<Longrightarrow> restrict0 src.carrier (x \\<circ> f) \\<in> src.diff_fun_space\"", "lemma linear_on_diff_fun_push_forward:\n  \"dest.linear_diff_fun (push_forward X)\"\n  if \"src.linear_diff_fun X\"", "lemma push_forward_is_derivation:\n  \"push_forward X (x * y) = x (f p) * push_forward X y + y (f p) * push_forward X x\"\n  (is \"?l = ?r\")\n  if deriv: \"\\<And>x y. x \\<in> src.diff_fun_space \\<Longrightarrow> y \\<in> src.diff_fun_space \\<Longrightarrow> X (x * y) = x p * X y + y p * X x\"\n    and dx: \"x \\<in> dest.diff_fun_space\"\n    and dy: \"y \\<in> dest.diff_fun_space\"\n    and p: \"p \\<in> src.carrier\"", "lemma push_forward_in_tangent_space:\n  \"push_forward ` (src.tangent_space p) \\<subseteq> dest.tangent_space (f p)\"\n  if \"p \\<in> src.carrier\"", "lemma push_forward_id:\n  \"diff.push_forward k charts charts f X = X\"\n  if \"\\<And>x. x \\<in> carrier \\<Longrightarrow> f x = x\"\n    \"X \\<in> tangent_space p\" \"p \\<in> carrier\"", "lemma push_forward_compose:\n  \"diff.push_forward k M2 M3 g (diff.push_forward k M1 M2 f X) = diff.push_forward k M1 M3 (g o f) X\"\n  if \"X \\<in> c_manifold.tangent_space M1 k p\" \"p \\<in> manifold.carrier M1\"\n    and df: \"diff k M1 M2 f\" and dg: \"diff k M2 M3 g\"", "lemma inv_push_forward_inverse: \"push_forward (inv.push_forward X) = X\"\n  if \"X \\<in> dest.tangent_space p\" \"p \\<in> dest.carrier\"", "lemma push_forward_inverse: \"inv.push_forward (push_forward X) = X\"\n  if \"X \\<in> src.tangent_space p\" \"p \\<in> src.carrier\"", "lemma bij_betw_push_forward:\n  \"bij_betw push_forward (src.tangent_space p) (dest.tangent_space (f p))\"\n  if p: \"p \\<in> src.carrier\"", "lemma dim_tangent_space_src_dest_eq: \"dim (src.tangent_space p) = dim (dest.tangent_space (f p))\"\n  if p: \"p \\<in> src.carrier\" and \"dim (dest.tangent_space (f p)) > 0\"", "lemma dim_tangent_space_src_dest_eq2: \"dim (src.tangent_space p) = dim (dest.tangent_space (f p))\"\n  if p: \"p \\<in> src.carrier\" and \"dim (src.tangent_space p) > 0\"", "lemma diff_inclusion: \"diff k (charts_submanifold S) charts (\\<lambda>x. x)\"", "lemma linear_on_push_forward_inclusion:\n  \"linear_on (sub.tangent_space p) (tangent_space p) scaleR scaleR inclusion.push_forward\"", "lemma extension_lemma_submanifoldE:\n  fixes f::\"'a\\<Rightarrow>'e::euclidean_space\"\n  assumes f: \"diff_fun k (charts_submanifold S) f\"\n    and B: \"closed B\" \"B \\<subseteq> sub.carrier\"\n  obtains f' where\n    \"diff_fun k charts f'\"\n    \"(\\<And>x. x \\<in> B \\<Longrightarrow> f' x = f x)\"\n    \"csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\"", "lemma inj_on_push_forward_inclusion: \"inj_on inclusion.push_forward (sub.tangent_space p)\"\n  if p: \"p \\<in> sub.carrier\"", "lemma surj_on_push_forward_inclusion:\n  \"inclusion.push_forward ` sub.tangent_space p \\<supseteq> tangent_space p\"\n  if p: \"p \\<in> sub.carrier\"", "lemma span_idem: \"span X = X\" if \"subspace X\"", "lemma dim_tangent_space: \"dim (tangent_space p) = dim (sub.tangent_space p)\"\n  if \"p \\<in> sub.carrier\" \"dim (sub.tangent_space p) > 0\"", "lemma dim_tangent_space2: \"dim (tangent_space p) = dim (sub.tangent_space p)\"\n  if \"p \\<in> sub.carrier\" \"dim (tangent_space p) > 0\"", "lemma extensional0_directional_derivative:\n  \"extensional0 (manifold_eucl.diff_fun_space k) (directional_derivative k a v)\"", "lemma extensional0_directional_derivative_le:\n  \"extensional0 (manifold_eucl.diff_fun_space k) (directional_derivative k' a v)\"\n  if \"k \\<le> k'\"", "lemma directional_derivative_add[simp]: \"directional_derivative k a (x + y) = directional_derivative k a x + directional_derivative k a y\"\n  and directional_derivative_scaleR[simp]: \"directional_derivative k a (c *\\<^sub>R x) = c *\\<^sub>R directional_derivative k a x\"\n  if \"k \\<noteq> 0\"", "lemma linear_directional_derivative: \"k \\<noteq> 0 \\<Longrightarrow> linear (directional_derivative k a)\"", "lemma frechet_derivative_inner[simp]:\n  \"frechet_derivative (\\<lambda>x. x \\<bullet> j) (at a) = (\\<lambda>x. x \\<bullet> j)\"", "lemma smooth_on_inner_const[simp]: \"k-smooth_on UNIV (\\<lambda>x. x \\<bullet> j)\"", "lemma directional_derivative_inner[simp]: \"directional_derivative k a x (\\<lambda>x. x \\<bullet> j) = x \\<bullet> j\"", "lemma sum_apply: \"sum f X i = sum (\\<lambda>x. f x i) X\"", "lemma inj_on_directional_derivative: \"inj_on (directional_derivative k a) S\" if \"k \\<noteq> 0\"", "lemma directional_derivative_eq_frechet_derivative:\n  \"directional_derivative k a v f = frechet_derivative f (at a) v\"\n  if \"k-smooth_on UNIV f\"", "lemma directional_derivative_linear_on_diff_fun_space:\n  \"k \\<noteq> 0 \\<Longrightarrow> manifold_eucl.linear_diff_fun k (directional_derivative k a x)\"", "lemma directional_derivative_is_derivation:\n  \"directional_derivative k a x (f * g) = f a * directional_derivative k a x g + g a * directional_derivative k a x f\"\n  if \"f \\<in> manifold_eucl.diff_fun_space k\" \"g \\<in> manifold_eucl.diff_fun_space k\" \"k \\<noteq> 0\"", "lemma directional_derivative_in_tangent_space[intro, simp]:\n  \"k \\<noteq> 0 \\<Longrightarrow> directional_derivative k a x \\<in> manifold_eucl.tangent_space k a\" for x", "lemma is_derivation_order_le:\n  \"is_derivation X p\"\n  if \"l \\<le> k\" \"c_manifold.is_derivation charts l X p\"", "lemma smooth_on_imp_differentiable_on: \"f differentiable_on S\"\n  if \"k-smooth_on S f\" \"k > 0\"", "lemma surj_directional_derivative:\n  \"range (directional_derivative k a) = manifold_eucl.tangent_space k a\"\n  if \"k = \\<infinity>\"", "lemma span_directional_derivative:\n  \"span (directional_derivative \\<infinity> a ` Basis) = manifold_eucl.tangent_space \\<infinity> a\"", "lemma directional_derivative_in_span:\n  \"directional_derivative \\<infinity> a x \\<in> span (directional_derivative \\<infinity> a ` Basis)\"", "lemma linear_on_directional_derivative:\n  \"k \\<noteq> 0 \\<Longrightarrow> linear_on UNIV (manifold_eucl.tangent_space k a) (*\\<^sub>R) (*\\<^sub>R) (directional_derivative k a)\"", "lemma independent_directional_derivative:\n  \"k \\<noteq> 0 \\<Longrightarrow> independent (directional_derivative k a ` Basis)\"", "lemma dim_eucl_tangent_space:\n  \"dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)\" for a::\"'a::euclidean_space\"", "lemma dim_tangent_space: \"dim (tangent_space p) = DIM('b)\" if p: \"p \\<in> carrier\" and smooth: \"k = \\<infinity>\""], "translations": [["", "lemma linear_imp_linear_on: \"linear_on A B scaleR scaleR f\" if \"linear f\"\n  \"subspace A\" \"subspace B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_on A B (*\\<^sub>R) (*\\<^sub>R) f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linear_on A B (*\\<^sub>R) (*\\<^sub>R) f", "interpret linear f"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear f", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. linear_on A B (*\\<^sub>R) (*\\<^sub>R) f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_on A B (*\\<^sub>R) (*\\<^sub>R) f", "using that"], ["proof (prove)\nusing this:\n  linear f\n  subspace A\n  subspace B\n\ngoal (1 subgoal):\n 1. linear_on A B (*\\<^sub>R) (*\\<^sub>R) f", "by unfold_locales (auto simp: add scaleR algebra_simps subspace_def)"], ["proof (state)\nthis:\n  linear_on A B (*\\<^sub>R) (*\\<^sub>R) f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in vector_space_pair_on)\n  linear_sum':\n    \"\\<forall>x. x \\<in> S1 \\<longrightarrow> f x \\<in> S2 \\<Longrightarrow>\n    \\<forall>x. x \\<in> S \\<longrightarrow> g x \\<in> S1 \\<Longrightarrow>\n    linear_on S1 S2 scale1 scale2 f \\<Longrightarrow>\n    f (sum g S) = (\\<Sum>a\\<in>S. f (g a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x. x \\<in> S1 \\<longrightarrow> f x \\<in> S2;\n     \\<forall>x. x \\<in> S \\<longrightarrow> g x \\<in> S1;\n     linear_on S1 S2 scale1 scale2 f\\<rbrakk>\n    \\<Longrightarrow> f (sum g S) = (\\<Sum>a\\<in>S. f (g a))", "using linear_sum[of f \"\\<lambda>x. if x \\<in> S then g x else 0\" S]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x. x \\<in> S1 \\<longrightarrow> f x \\<in> S2;\n   \\<forall>x. (if x \\<in> S then g x else (0::'b)) \\<in> S1;\n   linear_on S1 S2 scale1 scale2 f\\<rbrakk>\n  \\<Longrightarrow> f (\\<Sum>x\\<in>S. if x \\<in> S then g x else (0::'b)) =\n                    (\\<Sum>a\\<in>S. f (if a \\<in> S then g a else (0::'b)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x. x \\<in> S1 \\<longrightarrow> f x \\<in> S2;\n     \\<forall>x. x \\<in> S \\<longrightarrow> g x \\<in> S1;\n     linear_on S1 S2 scale1 scale2 f\\<rbrakk>\n    \\<Longrightarrow> f (sum g S) = (\\<Sum>a\\<in>S. f (g a))", "by (auto simp: if_distrib if_distribR m1.mem_zero cong: if_cong)"], ["", "subsection \\<open>Real vector (sub)spaces\\<close>"], ["", "locale real_vector_space_on = fixes S assumes subspace: \"subspace S\"\nbegin"], ["", "sublocale vector_space_on S scaleR\n  rewrites span_eq_real: \"local.span = real_vector.span\"\n    and dependent_eq_real: \"local.dependent = real_vector.dependent\"\n    and subspace_eq_real: \"local.subspace = real_vector.subspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vector_space_on S (*\\<^sub>R) &&&\n     module_on.span (*\\<^sub>R) = span) &&&\n    module_on.dependent (*\\<^sub>R) = dependent &&&\n    module_on.subspace (*\\<^sub>R) = subspace", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. vector_space_on S (*\\<^sub>R)\n 2. module_on.span (*\\<^sub>R) = span\n 3. module_on.dependent (*\\<^sub>R) = dependent\n 4. module_on.subspace (*\\<^sub>R) = subspace", "show \"vector_space_on S (*\\<^sub>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_space_on S (*\\<^sub>R)", "by unfold_locales (use subspace[unfolded subspace_def] in \\<open>auto simp: algebra_simps\\<close>)"], ["proof (state)\nthis:\n  vector_space_on S (*\\<^sub>R)\n\ngoal (3 subgoals):\n 1. module_on.span (*\\<^sub>R) = span\n 2. module_on.dependent (*\\<^sub>R) = dependent\n 3. module_on.subspace (*\\<^sub>R) = subspace", "then"], ["proof (chain)\npicking this:\n  vector_space_on S (*\\<^sub>R)", "interpret subspace: vector_space_on S scaleR"], ["proof (prove)\nusing this:\n  vector_space_on S (*\\<^sub>R)\n\ngoal (1 subgoal):\n 1. vector_space_on S (*\\<^sub>R)", "."], ["proof (state)\ngoal (3 subgoals):\n 1. subspace.span = span\n 2. subspace.dependent = dependent\n 3. subspace.subspace = subspace", "show 1: \"subspace.span = span\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace.span = span", "unfolding subspace.span_on_def span_explicit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b.\n        {\\<Sum>a\\<in>t. r a *\\<^sub>R a |t r.\n         finite t \\<and> t \\<subseteq> b}) =\n    (\\<lambda>b.\n        {\\<Sum>a\\<in>t. r a *\\<^sub>R a |t r.\n         finite t \\<and> t \\<subseteq> b})", "by auto"], ["proof (state)\nthis:\n  subspace.span = span\n\ngoal (2 subgoals):\n 1. subspace.dependent = dependent\n 2. subspace.subspace = subspace", "show 2: \"subspace.dependent = dependent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace.dependent = dependent", "unfolding subspace.dependent_on_def dependent_explicit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        \\<exists>t u.\n           finite t \\<and>\n           t \\<subseteq> s \\<and>\n           (\\<Sum>v\\<in>t. u v *\\<^sub>R v) = (0::'a) \\<and>\n           (\\<exists>v\\<in>t. u v \\<noteq> 0)) =\n    (\\<lambda>s.\n        \\<exists>t u.\n           finite t \\<and>\n           t \\<subseteq> s \\<and>\n           (\\<Sum>v\\<in>t. u v *\\<^sub>R v) = (0::'a) \\<and>\n           (\\<exists>v\\<in>t. u v \\<noteq> 0))", "by auto"], ["proof (state)\nthis:\n  subspace.dependent = dependent\n\ngoal (1 subgoal):\n 1. subspace.subspace = subspace", "show 3: \"subspace.subspace = subspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace.subspace = subspace", "unfolding subspace.subspace_on_def subspace_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>T.\n        (0::'a) \\<in> T \\<and>\n        (\\<forall>x\\<in>T. \\<forall>y\\<in>T. x + y \\<in> T) \\<and>\n        (\\<forall>c. \\<forall>x\\<in>T. c *\\<^sub>R x \\<in> T)) =\n    (\\<lambda>S.\n        (0::'a) \\<in> S \\<and>\n        (\\<forall>x\\<in>S. \\<forall>y\\<in>S. x + y \\<in> S) \\<and>\n        (\\<forall>c. \\<forall>x\\<in>S. c *\\<^sub>R x \\<in> S))", "by auto"], ["proof (state)\nthis:\n  subspace.subspace = subspace\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dim_eq: \"local.dim X = real_vector.dim X\" if \"X \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim X = ??.Real_Vector_Spaces.dim X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dim X = ??.Real_Vector_Spaces.dim X", "have *: \"b \\<subseteq> S \\<and> independent b \\<and> span b = span X \\<longleftrightarrow> independent b \\<and> span b = span X\"\n    for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<subseteq> S \\<and>\n     independent b \\<and>\n     ??.Real_Vector_Spaces.span b = ??.Real_Vector_Spaces.span X) =\n    (independent b \\<and>\n     ??.Real_Vector_Spaces.span b = ??.Real_Vector_Spaces.span X)", "using that"], ["proof (prove)\nusing this:\n  X \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (b \\<subseteq> S \\<and>\n     independent b \\<and>\n     ??.Real_Vector_Spaces.span b = ??.Real_Vector_Spaces.span X) =\n    (independent b \\<and>\n     ??.Real_Vector_Spaces.span b = ??.Real_Vector_Spaces.span X)", "by auto (metis local.subspace_UNIV real_vector.span_base real_vector.span_eq_iff real_vector.span_mono subsetCE)"], ["proof (state)\nthis:\n  (?b \\<subseteq> S \\<and>\n   independent ?b \\<and>\n   ??.Real_Vector_Spaces.span ?b = ??.Real_Vector_Spaces.span X) =\n  (independent ?b \\<and>\n   ??.Real_Vector_Spaces.span ?b = ??.Real_Vector_Spaces.span X)\n\ngoal (1 subgoal):\n 1. local.dim X = ??.Real_Vector_Spaces.dim X", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dim X = ??.Real_Vector_Spaces.dim X", "using that"], ["proof (prove)\nusing this:\n  X \\<subseteq> S\n\ngoal (1 subgoal):\n 1. local.dim X = ??.Real_Vector_Spaces.dim X", "unfolding local.dim_def real_vector.dim_def *"], ["proof (prove)\nusing this:\n  X \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (if \\<exists>b.\n           independent b \\<and>\n           ??.Real_Vector_Spaces.span b = ??.Real_Vector_Spaces.span X\n     then card\n           (SOME b.\n               independent b \\<and>\n               ??.Real_Vector_Spaces.span b = ??.Real_Vector_Spaces.span X)\n     else 0) =\n    (if \\<exists>b.\n           independent b \\<and>\n           ??.Real_Vector_Spaces.span b = ??.Real_Vector_Spaces.span X\n     then card\n           (SOME b.\n               independent b \\<and>\n               ??.Real_Vector_Spaces.span b = ??.Real_Vector_Spaces.span X)\n     else 0)", "by auto"], ["proof (state)\nthis:\n  local.dim X = ??.Real_Vector_Spaces.dim X\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale real_vector_space_pair_on = vs1: real_vector_space_on S + vs2: real_vector_space_on T for S T\nbegin"], ["", "sublocale vector_space_pair_on S T scaleR scaleR\n  rewrites span_eq_real1: \"module_on.span scaleR = vs1.span\"\n    and dependent_eq_real1: \"module_on.dependent scaleR = vs1.dependent\"\n    and subspace_eq_real1: \"module_on.subspace scaleR = vs1.subspace\"\n    and span_eq_real2: \"module_on.span scaleR = vs2.span\"\n    and dependent_eq_real2: \"module_on.dependent scaleR = vs2.dependent\"\n    and subspace_eq_real2: \"module_on.subspace scaleR = vs2.subspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vector_space_pair_on S T (*\\<^sub>R) (*\\<^sub>R) &&&\n     module_on.span (*\\<^sub>R) = span &&&\n     module_on.dependent (*\\<^sub>R) = dependent) &&&\n    (module_on.subspace (*\\<^sub>R) = subspace &&&\n     module_on.span (*\\<^sub>R) = span) &&&\n    module_on.dependent (*\\<^sub>R) = dependent &&&\n    module_on.subspace (*\\<^sub>R) = subspace", "by unfold_locales (simp_all add: vs1.span_eq_real vs1.dependent_eq_real vs1.subspace_eq_real\n      vs2.span_eq_real vs2.dependent_eq_real vs2.subspace_eq_real)"], ["", "end"], ["", "locale finite_dimensional_real_vector_space_on = real_vector_space_on S for S +\n  fixes basis :: \"'a set\"\n  assumes finite_dimensional_basis: \"finite basis\" \"\\<not> dependent basis\" \"span basis = S\" \"basis \\<subseteq> S\"\nbegin"], ["", "sublocale finite_dimensional_vector_space_on S scaleR basis\n  rewrites span_eq_real: \"local.span = real_vector.span\"\n    and dependent_eq_real: \"local.dependent = real_vector.dependent\"\n    and subspace_eq_real: \"local.subspace = real_vector.subspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite_dimensional_vector_space_on S (*\\<^sub>R) basis &&&\n     ??.Real_Vector_Spaces.span = ??.Real_Vector_Spaces.span) &&&\n    ??.Real_Vector_Spaces.dependent = ??.Real_Vector_Spaces.dependent &&&\n    ??.Real_Vector_Spaces.subspace = ??.Real_Vector_Spaces.subspace", "by unfold_locales (simp_all add: finite_dimensional_basis dependent_eq_real span_eq_real)"], ["", "end"], ["", "locale finite_dimensional_real_vector_space_pair_1_on =\n  vs1: finite_dimensional_real_vector_space_on S1 basis +\n  vs2: real_vector_space_on S2\n  for S1 S2 basis\nbegin"], ["", "sublocale finite_dimensional_vector_space_pair_1_on S1 S2 scaleR scaleR basis\n  rewrites span_eq_real1: \"module_on.span scaleR = vs1.span\"\n    and dependent_eq_real1: \"module_on.dependent scaleR = vs1.dependent\"\n    and subspace_eq_real1: \"module_on.subspace scaleR = vs1.subspace\"\n    and span_eq_real2: \"module_on.span scaleR = vs2.span\"\n    and dependent_eq_real2: \"module_on.dependent scaleR = vs2.dependent\"\n    and subspace_eq_real2: \"module_on.subspace scaleR = vs2.subspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite_dimensional_vector_space_pair_1_on S1 S2 (*\\<^sub>R) (*\\<^sub>R)\n      basis &&&\n     module_on.span (*\\<^sub>R) = span &&&\n     module_on.dependent (*\\<^sub>R) = dependent) &&&\n    (module_on.subspace (*\\<^sub>R) = subspace &&&\n     module_on.span (*\\<^sub>R) = span) &&&\n    module_on.dependent (*\\<^sub>R) = dependent &&&\n    module_on.subspace (*\\<^sub>R) = subspace", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. module_on.span (*\\<^sub>R) = span\n 2. module_on.dependent (*\\<^sub>R) = dependent\n 3. module_on.subspace (*\\<^sub>R) = subspace\n 4. module_on.span (*\\<^sub>R) = span\n 5. module_on.dependent (*\\<^sub>R) = dependent\n 6. module_on.subspace (*\\<^sub>R) = subspace", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.span (*\\<^sub>R) = span", "using real_vector_space_on.span_eq_real vs1.real_vector_space_on_axioms"], ["proof (prove)\nusing this:\n  real_vector_space_on ?S \\<Longrightarrow>\n  module_on.span (*\\<^sub>R) = span\n  real_vector_space_on S1\n\ngoal (1 subgoal):\n 1. module_on.span (*\\<^sub>R) = span", "by blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. module_on.dependent (*\\<^sub>R) = dependent\n 2. module_on.subspace (*\\<^sub>R) = subspace\n 3. module_on.span (*\\<^sub>R) = span\n 4. module_on.dependent (*\\<^sub>R) = dependent\n 5. module_on.subspace (*\\<^sub>R) = subspace", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.dependent (*\\<^sub>R) = dependent", "using real_vector_space_on.dependent_eq_real vs1.real_vector_space_on_axioms"], ["proof (prove)\nusing this:\n  real_vector_space_on ?S \\<Longrightarrow>\n  module_on.dependent (*\\<^sub>R) = dependent\n  real_vector_space_on S1\n\ngoal (1 subgoal):\n 1. module_on.dependent (*\\<^sub>R) = dependent", "by blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. module_on.subspace (*\\<^sub>R) = subspace\n 2. module_on.span (*\\<^sub>R) = span\n 3. module_on.dependent (*\\<^sub>R) = dependent\n 4. module_on.subspace (*\\<^sub>R) = subspace", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.subspace (*\\<^sub>R) = subspace", "using real_vector_space_on.subspace_eq_real vs1.real_vector_space_on_axioms"], ["proof (prove)\nusing this:\n  real_vector_space_on ?S \\<Longrightarrow>\n  module_on.subspace (*\\<^sub>R) = subspace\n  real_vector_space_on S1\n\ngoal (1 subgoal):\n 1. module_on.subspace (*\\<^sub>R) = subspace", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. module_on.span (*\\<^sub>R) = span\n 2. module_on.dependent (*\\<^sub>R) = dependent\n 3. module_on.subspace (*\\<^sub>R) = subspace", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.span (*\\<^sub>R) = span", "using real_vector_space_on.span_eq_real vs2.real_vector_space_on_axioms"], ["proof (prove)\nusing this:\n  real_vector_space_on ?S \\<Longrightarrow>\n  module_on.span (*\\<^sub>R) = span\n  real_vector_space_on S2\n\ngoal (1 subgoal):\n 1. module_on.span (*\\<^sub>R) = span", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. module_on.dependent (*\\<^sub>R) = dependent\n 2. module_on.subspace (*\\<^sub>R) = subspace", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.dependent (*\\<^sub>R) = dependent", "using real_vector_space_on.dependent_eq_real vs2.real_vector_space_on_axioms"], ["proof (prove)\nusing this:\n  real_vector_space_on ?S \\<Longrightarrow>\n  module_on.dependent (*\\<^sub>R) = dependent\n  real_vector_space_on S2\n\ngoal (1 subgoal):\n 1. module_on.dependent (*\\<^sub>R) = dependent", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.subspace (*\\<^sub>R) = subspace", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.subspace (*\\<^sub>R) = subspace", "using real_vector_space_on.subspace_eq_real vs2.real_vector_space_on_axioms"], ["proof (prove)\nusing this:\n  real_vector_space_on ?S \\<Longrightarrow>\n  module_on.subspace (*\\<^sub>R) = subspace\n  real_vector_space_on S2\n\ngoal (1 subgoal):\n 1. module_on.subspace (*\\<^sub>R) = subspace", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "locale finite_dimensional_real_vector_space_pair_on =\n  vs1: finite_dimensional_real_vector_space_on S1 Basis1 +\n  vs2: finite_dimensional_real_vector_space_on S2 Basis2 \n  for S1 S2 Basis1 Basis2\nbegin"], ["", "sublocale finite_dimensional_real_vector_space_pair_1_on S1 S2 Basis1"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_real_vector_space_pair_1_on S1 S2 Basis1", "by unfold_locales"], ["", "sublocale finite_dimensional_vector_space_pair_on S1 S2 scaleR scaleR Basis1 Basis2\n  rewrites \"module_on.span scaleR = vs1.span\"\n    and \"module_on.dependent scaleR = vs1.dependent\"\n    and \"module_on.subspace scaleR = vs1.subspace\"\n    and \"module_on.span scaleR = vs2.span\"\n    and \"module_on.dependent scaleR = vs2.dependent\"\n    and \"module_on.subspace scaleR = vs2.subspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite_dimensional_vector_space_pair_on S1 S2 (*\\<^sub>R) (*\\<^sub>R)\n      Basis1 Basis2 &&&\n     module_on.span (*\\<^sub>R) = span &&&\n     module_on.dependent (*\\<^sub>R) = dependent) &&&\n    (module_on.subspace (*\\<^sub>R) = subspace &&&\n     module_on.span (*\\<^sub>R) = span) &&&\n    module_on.dependent (*\\<^sub>R) = dependent &&&\n    module_on.subspace (*\\<^sub>R) = subspace", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. module_on.span (*\\<^sub>R) = span\n 2. module_on.dependent (*\\<^sub>R) = dependent\n 3. module_on.subspace (*\\<^sub>R) = subspace\n 4. module_on.span (*\\<^sub>R) = span\n 5. module_on.dependent (*\\<^sub>R) = dependent\n 6. module_on.subspace (*\\<^sub>R) = subspace", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.span (*\\<^sub>R) = span", "by (simp add:      span_eq_real1)"], ["proof (prove)\ngoal (5 subgoals):\n 1. module_on.dependent (*\\<^sub>R) = dependent\n 2. module_on.subspace (*\\<^sub>R) = subspace\n 3. module_on.span (*\\<^sub>R) = span\n 4. module_on.dependent (*\\<^sub>R) = dependent\n 5. module_on.subspace (*\\<^sub>R) = subspace", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.dependent (*\\<^sub>R) = dependent", "by (simp add: dependent_eq_real1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. module_on.subspace (*\\<^sub>R) = subspace\n 2. module_on.span (*\\<^sub>R) = span\n 3. module_on.dependent (*\\<^sub>R) = dependent\n 4. module_on.subspace (*\\<^sub>R) = subspace", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.subspace (*\\<^sub>R) = subspace", "by (simp add:  subspace_eq_real1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. module_on.span (*\\<^sub>R) = span\n 2. module_on.dependent (*\\<^sub>R) = dependent\n 3. module_on.subspace (*\\<^sub>R) = subspace", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.span (*\\<^sub>R) = span", "by (simp add:      span_eq_real2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. module_on.dependent (*\\<^sub>R) = dependent\n 2. module_on.subspace (*\\<^sub>R) = subspace", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.dependent (*\\<^sub>R) = dependent", "by (simp add: dependent_eq_real2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.subspace (*\\<^sub>R) = subspace", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on.subspace (*\\<^sub>R) = subspace", "by (simp add:  subspace_eq_real2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Derivations\\<close>"], ["", "context c_manifold begin"], ["", "text \\<open>Set of \\<open>C^k\\<close> differentiable functions on carrier, where the smooth structure\n   is given by charts. We assume \\<open>f\\<close> is zero outside carrier\\<close>"], ["", "definition diff_fun_space :: \"('a \\<Rightarrow> real) set\" where\n  \"diff_fun_space = {f. diff_fun k charts f \\<and> extensional0 carrier f}\""], ["", "lemma diff_fun_spaceD: \"diff_fun k charts f\" if \"f \\<in> diff_fun_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff_fun k charts f", "using that"], ["proof (prove)\nusing this:\n  f \\<in> diff_fun_space\n\ngoal (1 subgoal):\n 1. diff_fun k charts f", "by (auto simp: diff_fun_space_def)"], ["", "lemma diff_fun_space_order_le: \"diff_fun_space \\<subseteq> c_manifold.diff_fun_space charts l\" if \"l \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff_fun_space \\<subseteq> c_manifold.diff_fun_space charts l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. diff_fun_space \\<subseteq> c_manifold.diff_fun_space charts l", "interpret l: c_manifold charts l"], ["proof (prove)\ngoal (1 subgoal):\n 1. c_manifold charts l", "by (rule c_manifold_order_le) fact"], ["proof (state)\ngoal (1 subgoal):\n 1. diff_fun_space \\<subseteq> l.diff_fun_space", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. diff_fun_space \\<subseteq> l.diff_fun_space", "unfolding diff_fun_space_def l.diff_fun_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {f. diff_fun k charts f \\<and> extensional0 carrier f}\n    \\<subseteq> {f. diff_fun l charts f \\<and> extensional0 carrier f}", "using diff_fun.diff_fun_order_le[OF _ that]"], ["proof (prove)\nusing this:\n  diff_fun k ?charts ?f \\<Longrightarrow> diff_fun l ?charts ?f\n\ngoal (1 subgoal):\n 1. {f. diff_fun k charts f \\<and> extensional0 carrier f}\n    \\<subseteq> {f. diff_fun l charts f \\<and> extensional0 carrier f}", "by auto"], ["proof (state)\nthis:\n  diff_fun_space \\<subseteq> l.diff_fun_space\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diff_fun_space_extensionalD:\n  \"g \\<in> diff_fun_space \\<Longrightarrow> extensional0 carrier g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> diff_fun_space \\<Longrightarrow> extensional0 carrier g", "by (auto simp: diff_fun_space_def)"], ["", "lemma diff_fun_space_eq: \"diff_fun_space = {f. diff_fun k charts f} \\<inter> {f. extensional0 carrier f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff_fun_space =\n    {f. diff_fun k charts f} \\<inter> {f. extensional0 carrier f}", "by (auto simp: diff_fun_space_def)"], ["", "lemma subspace_diff_fun_space[intro, simp]:\n  \"subspace diff_fun_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace diff_fun_space", "unfolding diff_fun_space_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace\n     (Collect (diff_fun k charts) \\<inter> Collect (extensional0 carrier))", "by (intro subspace_inter subspace_Collect_diff_fun subspace_extensional0)"], ["", "lemma diff_fun_space_times: \"f * g \\<in> diff_fun_space\"\n  if \"f \\<in> diff_fun_space\" \"g \\<in> diff_fun_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f * g \\<in> diff_fun_space", "using that"], ["proof (prove)\nusing this:\n  f \\<in> diff_fun_space\n  g \\<in> diff_fun_space\n\ngoal (1 subgoal):\n 1. f * g \\<in> diff_fun_space", "by (auto simp: diff_fun_space_def intro!: diff_fun_times)"], ["", "lemma diff_fun_space_add: \"f + g \\<in> diff_fun_space\"\n  if \"f \\<in> diff_fun_space\" \"g \\<in> diff_fun_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f + g \\<in> diff_fun_space", "using that"], ["proof (prove)\nusing this:\n  f \\<in> diff_fun_space\n  g \\<in> diff_fun_space\n\ngoal (1 subgoal):\n 1. f + g \\<in> diff_fun_space", "by (auto simp: diff_fun_space_def intro!: diff_fun_add)"], ["", "text \\<open>Set of differentiable functions is a vector space\\<close>"], ["", "sublocale diff_fun_space: vector_space_pair_on diff_fun_space \"UNIV::real set\" scaleR scaleR"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_space_pair_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R)", "by unfold_locales\n    (use subspace_diff_fun_space[unfolded subspace_def] in\n      \\<open>auto simp: diff_fun_space_add algebra_simps scaleR_fun_def\\<close>)"], ["", "text \\<open>Linear functional from differentiable functions to real numbers\\<close>"], ["", "abbreviation \"linear_diff_fun \\<equiv> linear_on diff_fun_space (UNIV::real set) scaleR scaleR\""], ["", "text \\<open>\n   Definition of a derivation.\n\n   A linear functional \\<open>X\\<close> is a derivation if it additionally satisfies the property\n   \\<open>X (f * g) = f p * X g + g p * X f\\<close>. This is suppose to represent the product rule.\n\\<close>"], ["", "definition is_derivation :: \"(('a \\<Rightarrow> real) \\<Rightarrow> real) \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"is_derivation X p \\<longleftrightarrow> (linear_diff_fun X \\<and>\n    (\\<forall>f g. f \\<in> diff_fun_space \\<longrightarrow> g \\<in> diff_fun_space \\<longrightarrow> X (f * g) = f p * X g + g p * X f))\""], ["", "lemma is_derivationI:\n  \"is_derivation X p\"\n  if \"linear_diff_fun X\"\n    \"\\<And>f g. f \\<in> diff_fun_space \\<Longrightarrow> g \\<in> diff_fun_space \\<Longrightarrow> X (f * g) = f p * X g + g p * X f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_derivation X p", "using that"], ["proof (prove)\nusing this:\n  linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) X\n  \\<lbrakk>?f3 \\<in> diff_fun_space; ?g3 \\<in> diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> X (?f3 * ?g3) = ?f3 p * X ?g3 + ?g3 p * X ?f3\n\ngoal (1 subgoal):\n 1. is_derivation X p", "unfolding is_derivation_def"], ["proof (prove)\nusing this:\n  linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) X\n  \\<lbrakk>?f3 \\<in> diff_fun_space; ?g3 \\<in> diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> X (?f3 * ?g3) = ?f3 p * X ?g3 + ?g3 p * X ?f3\n\ngoal (1 subgoal):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) X \\<and>\n    (\\<forall>f g.\n        f \\<in> diff_fun_space \\<longrightarrow>\n        g \\<in> diff_fun_space \\<longrightarrow>\n        X (f * g) = f p * X g + g p * X f)", "by blast"], ["", "lemma is_derivationD:\n  assumes \"is_derivation X p\"\n  shows is_derivation_linear_on: \"linear_diff_fun X\"\n    and is_derivation_derivation: \"\\<And>f g. f \\<in> diff_fun_space \\<Longrightarrow> g \\<in> diff_fun_space \\<Longrightarrow> X (f * g) = f p * X g + g p * X f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) X &&&\n    (\\<And>f g.\n        \\<lbrakk>f \\<in> diff_fun_space; g \\<in> diff_fun_space\\<rbrakk>\n        \\<Longrightarrow> X (f * g) = f p * X g + g p * X f)", "using assms"], ["proof (prove)\nusing this:\n  is_derivation X p\n\ngoal (1 subgoal):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) X &&&\n    (\\<And>f g.\n        \\<lbrakk>f \\<in> diff_fun_space; g \\<in> diff_fun_space\\<rbrakk>\n        \\<Longrightarrow> X (f * g) = f p * X g + g p * X f)", "unfolding is_derivation_def"], ["proof (prove)\nusing this:\n  linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) X \\<and>\n  (\\<forall>f g.\n      f \\<in> diff_fun_space \\<longrightarrow>\n      g \\<in> diff_fun_space \\<longrightarrow>\n      X (f * g) = f p * X g + g p * X f)\n\ngoal (1 subgoal):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) X &&&\n    (\\<And>f g.\n        \\<lbrakk>f \\<in> diff_fun_space; g \\<in> diff_fun_space\\<rbrakk>\n        \\<Longrightarrow> X (f * g) = f p * X g + g p * X f)", "by blast+"], ["", "text \\<open>Differentiable functions on the Euclidean space\\<close>"], ["", "lemma manifold_eucl_diff_fun_space_iff[simp]:\n  \"g \\<in> manifold_eucl.diff_fun_space k \\<longleftrightarrow> k-smooth_on UNIV g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<in> manifold_eucl.diff_fun_space k) = k-smooth_on UNIV g", "by (auto simp: manifold_eucl.diff_fun_space_def differentiable_on_def\n      diff_fun_charts_euclI diff_fun_charts_euclD)"], ["", "subsection \\<open>Tangent space\\<close>"], ["", "text \\<open>\n  Definition of the tangent space.\n\n  The tangent space at a point p is defined to be the set of derivations. Note\n  we need to restrict the domain of the functional to differentiable functions.\n\\<close>"], ["", "definition tangent_space :: \"'a \\<Rightarrow> (('a \\<Rightarrow> real) \\<Rightarrow> real) set\" where\n  \"tangent_space p = {X. is_derivation X p \\<and> extensional0 diff_fun_space X}\""], ["", "lemma tangent_space_eq: \"tangent_space p = {X. is_derivation X p} \\<inter> {X. extensional0 diff_fun_space X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tangent_space p =\n    {X. is_derivation X p} \\<inter> {X. extensional0 diff_fun_space X}", "by (auto simp: tangent_space_def)"], ["", "lemma mem_tangent_space: \"X \\<in> tangent_space p \\<longleftrightarrow> is_derivation X p \\<and> extensional0 diff_fun_space X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<in> tangent_space p) =\n    (is_derivation X p \\<and> extensional0 diff_fun_space X)", "by (auto simp: tangent_space_def)"], ["", "lemma tangent_spaceI:\n  \"X \\<in> tangent_space p\"\n  if\n    \"extensional0 diff_fun_space X\"\n    \"linear_diff_fun X\"\n    \"\\<And>f g. f \\<in> diff_fun_space \\<Longrightarrow> g \\<in> diff_fun_space \\<Longrightarrow> X (f * g) = f p * X g + g p * X f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> tangent_space p", "using that"], ["proof (prove)\nusing this:\n  extensional0 diff_fun_space X\n  linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) X\n  \\<lbrakk>?f3 \\<in> diff_fun_space; ?g3 \\<in> diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> X (?f3 * ?g3) = ?f3 p * X ?g3 + ?g3 p * X ?f3\n\ngoal (1 subgoal):\n 1. X \\<in> tangent_space p", "unfolding tangent_space_def is_derivation_def"], ["proof (prove)\nusing this:\n  extensional0 diff_fun_space X\n  linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) X\n  \\<lbrakk>?f3 \\<in> diff_fun_space; ?g3 \\<in> diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> X (?f3 * ?g3) = ?f3 p * X ?g3 + ?g3 p * X ?f3\n\ngoal (1 subgoal):\n 1. X \\<in> {X. (linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R)\n                  X \\<and>\n                 (\\<forall>f g.\n                     f \\<in> diff_fun_space \\<longrightarrow>\n                     g \\<in> diff_fun_space \\<longrightarrow>\n                     X (f * g) = f p * X g + g p * X f)) \\<and>\n                extensional0 diff_fun_space X}", "by blast"], ["", "lemma tangent_spaceD:\n  assumes \"X \\<in> tangent_space p\"\n  shows tangent_space_linear_on: \"linear_diff_fun X\"\n    and tangent_space_restrict: \"extensional0 diff_fun_space X\"\n    and tangent_space_derivation: \"\\<And>f g. f \\<in> diff_fun_space \\<Longrightarrow> g \\<in> diff_fun_space \\<Longrightarrow> X (f * g) = f p * X g + g p * X f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) X &&&\n    extensional0 diff_fun_space X &&&\n    (\\<And>f g.\n        \\<lbrakk>f \\<in> diff_fun_space; g \\<in> diff_fun_space\\<rbrakk>\n        \\<Longrightarrow> X (f * g) = f p * X g + g p * X f)", "using assms"], ["proof (prove)\nusing this:\n  X \\<in> tangent_space p\n\ngoal (1 subgoal):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) X &&&\n    extensional0 diff_fun_space X &&&\n    (\\<And>f g.\n        \\<lbrakk>f \\<in> diff_fun_space; g \\<in> diff_fun_space\\<rbrakk>\n        \\<Longrightarrow> X (f * g) = f p * X g + g p * X f)", "unfolding tangent_space_def is_derivation_def"], ["proof (prove)\nusing this:\n  X \\<in> {X. (linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R)\n                X \\<and>\n               (\\<forall>f g.\n                   f \\<in> diff_fun_space \\<longrightarrow>\n                   g \\<in> diff_fun_space \\<longrightarrow>\n                   X (f * g) = f p * X g + g p * X f)) \\<and>\n              extensional0 diff_fun_space X}\n\ngoal (1 subgoal):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) X &&&\n    extensional0 diff_fun_space X &&&\n    (\\<And>f g.\n        \\<lbrakk>f \\<in> diff_fun_space; g \\<in> diff_fun_space\\<rbrakk>\n        \\<Longrightarrow> X (f * g) = f p * X g + g p * X f)", "by blast+"], ["", "lemma is_derivation_0: \"is_derivation 0 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_derivation 0 p", "by (simp add: is_derivation_def diff_fun_space.linear_zero zero_fun_def)"], ["", "lemma is_derivation_add: \"is_derivation (x + y) p\"\n  if x: \"is_derivation x p\" and y: \"is_derivation y p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_derivation (x + y) p", "apply (rule is_derivationI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) (x + y)\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> diff_fun_space; g \\<in> diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> (x + y) (f * g) = f p * (x + y) g + g p * (x + y) f", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) (x + y)", "using x y"], ["proof (prove)\nusing this:\n  is_derivation x p\n  is_derivation y p\n\ngoal (1 subgoal):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) (x + y)", "by (auto dest!: is_derivation_linear_on simp: diff_fun_space.linear_compose_add plus_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> diff_fun_space; g \\<in> diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> (x + y) (f * g) = f p * (x + y) g + g p * (x + y) f", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f_ \\<in> diff_fun_space; g_ \\<in> diff_fun_space\\<rbrakk>\n    \\<Longrightarrow> (x + y) (f_ * g_) =\n                      f_ p * (x + y) g_ + g_ p * (x + y) f_", "by (simp add: is_derivation_derivation[OF x] is_derivation_derivation[OF y] algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_derivation_scaleR: \"is_derivation (c *\\<^sub>R x) p\"\n  if x: \"is_derivation x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_derivation (c *\\<^sub>R x) p", "apply (rule is_derivationI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) (c *\\<^sub>R x)\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> diff_fun_space; g \\<in> diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> (c *\\<^sub>R x) (f * g) =\n                         f p * (c *\\<^sub>R x) g + g p * (c *\\<^sub>R x) f", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) (c *\\<^sub>R x)", "using x diff_fun_space.linear_compose_scale_right[of x c]"], ["proof (prove)\nusing this:\n  is_derivation x p\n  \\<lbrakk>\\<forall>xa.\n              xa \\<in> diff_fun_space \\<longrightarrow> x xa \\<in> UNIV;\n   linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) x\\<rbrakk>\n  \\<Longrightarrow> linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R)\n                     (\\<lambda>xa. c *\\<^sub>R x xa)\n\ngoal (1 subgoal):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) (c *\\<^sub>R x)", "by (auto dest!: is_derivation_linear_on simp:scaleR_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> diff_fun_space; g \\<in> diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> (c *\\<^sub>R x) (f * g) =\n                         f p * (c *\\<^sub>R x) g + g p * (c *\\<^sub>R x) f", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f_ \\<in> diff_fun_space; g_ \\<in> diff_fun_space\\<rbrakk>\n    \\<Longrightarrow> (c *\\<^sub>R x) (f_ * g_) =\n                      f_ p * (c *\\<^sub>R x) g_ + g_ p * (c *\\<^sub>R x) f_", "by (simp add: is_derivation_derivation[OF x] algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subspace_is_derivation: \"subspace {X. is_derivation X p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace {X. is_derivation X p}", "by (auto simp: subspace_def is_derivation_0 is_derivation_add is_derivation_scaleR)"], ["", "lemma subspace_tangent_space: \"subspace (tangent_space p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace (tangent_space p)", "unfolding tangent_space_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace\n     ({X. is_derivation X p} \\<inter> Collect (extensional0 diff_fun_space))", "by (simp add: subspace_inter subspace_is_derivation subspace_extensional0)"], ["", "sublocale tangent_space: real_vector_space_on \"tangent_space p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_vector_space_on (tangent_space p)", "by unfold_locales (rule subspace_tangent_space)"], ["", "lemma tangent_space_dim_eq: \"tangent_space.dim p X = dim X\"\n  if \"X \\<subseteq> tangent_space p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tangent_space.dim p X = dim X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tangent_space.dim p X = dim X", "have *: \"b \\<subseteq> tangent_space p \\<and> independent b \\<and> span b = span X \\<longleftrightarrow> independent b \\<and> span b = span X\"\n    for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<subseteq> tangent_space p \\<and>\n     independent b \\<and> span b = span X) =\n    (independent b \\<and> span b = span X)", "using that"], ["proof (prove)\nusing this:\n  X \\<subseteq> tangent_space p\n\ngoal (1 subgoal):\n 1. (b \\<subseteq> tangent_space p \\<and>\n     independent b \\<and> span b = span X) =\n    (independent b \\<and> span b = span X)", "by auto (metis (no_types, lifting) c_manifold.subspace_tangent_space c_manifold_axioms span_base span_eq_iff span_mono subsetCE)"], ["proof (state)\nthis:\n  (?b3 \\<subseteq> tangent_space p \\<and>\n   independent ?b3 \\<and> span ?b3 = span X) =\n  (independent ?b3 \\<and> span ?b3 = span X)\n\ngoal (1 subgoal):\n 1. tangent_space.dim p X = dim X", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. tangent_space.dim p X = dim X", "using that"], ["proof (prove)\nusing this:\n  X \\<subseteq> tangent_space p\n\ngoal (1 subgoal):\n 1. tangent_space.dim p X = dim X", "unfolding tangent_space.dim_def dim_def *"], ["proof (prove)\nusing this:\n  X \\<subseteq> tangent_space p\n\ngoal (1 subgoal):\n 1. (if \\<exists>b. independent b \\<and> span b = span X\n     then card (SOME b. independent b \\<and> span b = span X) else 0) =\n    (if \\<exists>b. independent b \\<and> span b = span X\n     then card (SOME b. independent b \\<and> span b = span X) else 0)", "by auto"], ["proof (state)\nthis:\n  tangent_space.dim p X = dim X\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>properties of derivations\\<close>"], ["", "lemma restrict0_in_fun_space: \"restrict0 carrier f \\<in> diff_fun_space\"\n  if \"diff_fun k charts f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 carrier f \\<in> diff_fun_space", "by (auto simp: diff_fun_space_def intro!: diff_fun.diff_fun_cong[OF that])"], ["", "lemma restrict0_const_diff_fun_space: \"restrict0 carrier (\\<lambda>x. c) \\<in> diff_fun_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 carrier (\\<lambda>x. c) \\<in> diff_fun_space", "by (rule restrict0_in_fun_space) (rule diff_fun_const)"], ["", "lemma derivation_one_eq_zero: \"X (restrict0 carrier (\\<lambda>x. 1)) = 0\" (is \"X ?f1 = _\")\n  if \"X \\<in> tangent_space p\" \"p \\<in> carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. 1)) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. 1)) = 0", "have \"X ?f1 = X (?f1 * ?f1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. 1)) =\n    X (restrict0 carrier (\\<lambda>x. 1) *\n       restrict0 carrier (\\<lambda>x. 1))", "by (simp add: restrict0_times[symmetric]) (simp add: times_fun_def)"], ["proof (state)\nthis:\n  X (restrict0 carrier (\\<lambda>x. 1)) =\n  X (restrict0 carrier (\\<lambda>x. 1) * restrict0 carrier (\\<lambda>x. 1))\n\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. 1)) = 0", "also"], ["proof (state)\nthis:\n  X (restrict0 carrier (\\<lambda>x. 1)) =\n  X (restrict0 carrier (\\<lambda>x. 1) * restrict0 carrier (\\<lambda>x. 1))\n\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. 1)) = 0", "have \"\\<dots> = 1 * X (restrict0 carrier (\\<lambda>x. 1)) + 1 * X (restrict0 carrier (\\<lambda>x. 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. 1) *\n       restrict0 carrier (\\<lambda>x. 1)) =\n    1 * X (restrict0 carrier (\\<lambda>x. 1)) +\n    1 * X (restrict0 carrier (\\<lambda>x. 1))", "apply (subst tangent_space_derivation[OF that(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. restrict0 carrier (\\<lambda>x. 1) \\<in> diff_fun_space\n 2. restrict0 carrier (\\<lambda>x. 1) p *\n    X (restrict0 carrier (\\<lambda>x. 1)) +\n    restrict0 carrier (\\<lambda>x. 1) p *\n    X (restrict0 carrier (\\<lambda>x. 1)) =\n    1 * X (restrict0 carrier (\\<lambda>x. 1)) +\n    1 * X (restrict0 carrier (\\<lambda>x. 1))", "apply (rule restrict0_const_diff_fun_space)"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 carrier (\\<lambda>x. 1) p *\n    X (restrict0 carrier (\\<lambda>x. 1)) +\n    restrict0 carrier (\\<lambda>x. 1) p *\n    X (restrict0 carrier (\\<lambda>x. 1)) =\n    1 * X (restrict0 carrier (\\<lambda>x. 1)) +\n    1 * X (restrict0 carrier (\\<lambda>x. 1))", "using that"], ["proof (prove)\nusing this:\n  X \\<in> tangent_space p\n  p \\<in> carrier\n\ngoal (1 subgoal):\n 1. restrict0 carrier (\\<lambda>x. 1) p *\n    X (restrict0 carrier (\\<lambda>x. 1)) +\n    restrict0 carrier (\\<lambda>x. 1) p *\n    X (restrict0 carrier (\\<lambda>x. 1)) =\n    1 * X (restrict0 carrier (\\<lambda>x. 1)) +\n    1 * X (restrict0 carrier (\\<lambda>x. 1))", "by simp"], ["proof (state)\nthis:\n  X (restrict0 carrier (\\<lambda>x. 1) *\n     restrict0 carrier (\\<lambda>x. 1)) =\n  1 * X (restrict0 carrier (\\<lambda>x. 1)) +\n  1 * X (restrict0 carrier (\\<lambda>x. 1))\n\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. 1)) = 0", "finally"], ["proof (chain)\npicking this:\n  X (restrict0 carrier (\\<lambda>x. 1)) =\n  1 * X (restrict0 carrier (\\<lambda>x. 1)) +\n  1 * X (restrict0 carrier (\\<lambda>x. 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  X (restrict0 carrier (\\<lambda>x. 1)) =\n  1 * X (restrict0 carrier (\\<lambda>x. 1)) +\n  1 * X (restrict0 carrier (\\<lambda>x. 1))\n\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. 1)) = 0", "by auto"], ["proof (state)\nthis:\n  X (restrict0 carrier (\\<lambda>x. 1)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derivation_const_eq_zero: \"X (restrict0 carrier (\\<lambda>x. c)) = 0\"\n  if \"X \\<in> tangent_space p\" \"p \\<in> carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. c)) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. c)) = 0", "note scaleR = diff_fun_space.linear_scale[OF _ _ tangent_space_linear_on[OF that(1)]]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x.\n              x \\<in> diff_fun_space \\<longrightarrow> X x \\<in> UNIV;\n   ?b \\<in> diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> X (?r *\\<^sub>R ?b) = ?r *\\<^sub>R X ?b\n\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. c)) = 0", "have \"X (c *\\<^sub>R (restrict0 carrier (\\<lambda>x. 1))) = c *\\<^sub>R X (restrict0 carrier (\\<lambda>x. 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (c *\\<^sub>R restrict0 carrier (\\<lambda>x. 1)) =\n    c *\\<^sub>R X (restrict0 carrier (\\<lambda>x. 1))", "by (rule scaleR) (auto intro!: restrict0_const_diff_fun_space)"], ["proof (state)\nthis:\n  X (c *\\<^sub>R restrict0 carrier (\\<lambda>x. 1)) =\n  c *\\<^sub>R X (restrict0 carrier (\\<lambda>x. 1))\n\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. c)) = 0", "also"], ["proof (state)\nthis:\n  X (c *\\<^sub>R restrict0 carrier (\\<lambda>x. 1)) =\n  c *\\<^sub>R X (restrict0 carrier (\\<lambda>x. 1))\n\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. c)) = 0", "note derivation_one_eq_zero[OF that]"], ["proof (state)\nthis:\n  X (restrict0 carrier (\\<lambda>x. 1)) = 0\n\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. c)) = 0", "also"], ["proof (state)\nthis:\n  X (restrict0 carrier (\\<lambda>x. 1)) = 0\n\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. c)) = 0", "note restrict0_scaleR[symmetric]"], ["proof (state)\nthis:\n  ?c *\\<^sub>R restrict0 ?A ?f = restrict0 ?A (?c *\\<^sub>R ?f)\n\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. c)) = 0", "finally"], ["proof (chain)\npicking this:\n  X (restrict0 carrier (c *\\<^sub>R (\\<lambda>a. 1))) = c *\\<^sub>R 0", "show ?thesis"], ["proof (prove)\nusing this:\n  X (restrict0 carrier (c *\\<^sub>R (\\<lambda>a. 1))) = c *\\<^sub>R 0\n\ngoal (1 subgoal):\n 1. X (restrict0 carrier (\\<lambda>x. c)) = 0", "by (auto simp: scaleR_fun_def)"], ["proof (state)\nthis:\n  X (restrict0 carrier (\\<lambda>x. c)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derivation_times_eq_zeroI: \"X (f * g) = 0\" if X:\"X \\<in> tangent_space p\"\n  and d: \"f \\<in> diff_fun_space\" \"g \\<in> diff_fun_space\"\n  and z: \"f p = 0\" \"g p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (f * g) = 0", "using tangent_space_derivation[OF X d]"], ["proof (prove)\nusing this:\n  X (f * g) = f p * X g + g p * X f\n\ngoal (1 subgoal):\n 1. X (f * g) = 0", "by (simp add: z)"], ["", "lemma derivation_zero_localI: \"X f = 0\"\n  if \"open W\" \"p \\<in> W\" \"W \\<subseteq> carrier\"\n    \"X \\<in> tangent_space p\"\n    \"f \\<in> diff_fun_space\"\n    \"\\<And>x. x \\<in> W \\<Longrightarrow> f x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X f = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. X f = 0", "define A where \"A = carrier - W\""], ["proof (state)\nthis:\n  A = carrier - W\n\ngoal (1 subgoal):\n 1. X f = 0", "have clA: \"closedin (top_of_set carrier) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closedin (top_of_set carrier) A", "using \\<open>open W\\<close>"], ["proof (prove)\nusing this:\n  open W\n\ngoal (1 subgoal):\n 1. closedin (top_of_set carrier) A", "apply (auto simp: A_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. open W \\<Longrightarrow> closedin (top_of_set carrier) (carrier - W)", "using closedin_def openin_open"], ["proof (prove)\nusing this:\n  closedin ?U ?S =\n  (?S \\<subseteq> topspace ?U \\<and> openin ?U (topspace ?U - ?S))\n  openin (top_of_set ?U) ?S = (\\<exists>T. open T \\<and> ?S = ?U \\<inter> T)\n\ngoal (1 subgoal):\n 1. open W \\<Longrightarrow> closedin (top_of_set carrier) (carrier - W)", "by fastforce"], ["proof (state)\nthis:\n  closedin (top_of_set carrier) A\n\ngoal (1 subgoal):\n 1. X f = 0", "have \\<open>A \\<subseteq> carrier\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> carrier", "by (auto simp: A_def)"], ["proof (state)\nthis:\n  A \\<subseteq> carrier\n\ngoal (1 subgoal):\n 1. X f = 0", "have d1: \"diff_fun_on A (\\<lambda>x. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff_fun_on A (\\<lambda>x. 1::'c)", "unfolding diff_fun_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>W.\n       A \\<subseteq> W \\<and>\n       W \\<subseteq> carrier \\<and>\n       open W \\<and>\n       (\\<exists>f'.\n           diff_fun k (charts_submanifold W) f' \\<and>\n           (\\<forall>x\\<in>A. (1::'c) = f' x))", "using \\<open>A \\<subseteq> carrier\\<close>"], ["proof (prove)\nusing this:\n  A \\<subseteq> carrier\n\ngoal (1 subgoal):\n 1. \\<exists>W.\n       A \\<subseteq> W \\<and>\n       W \\<subseteq> carrier \\<and>\n       open W \\<and>\n       (\\<exists>f'.\n           diff_fun k (charts_submanifold W) f' \\<and>\n           (\\<forall>x\\<in>A. (1::'c) = f' x))", "by (auto intro!:exI[where x=carrier] exI[where x=\"\\<lambda>x. 1\"] diff_fun_const)"], ["proof (state)\nthis:\n  diff_fun_on A (\\<lambda>x. 1::?'c4)\n\ngoal (1 subgoal):\n 1. X f = 0", "define U where \"U = carrier - {p}\""], ["proof (state)\nthis:\n  U = carrier - {p}\n\ngoal (1 subgoal):\n 1. X f = 0", "have \"open U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open U", "by (auto simp: U_def)"], ["proof (state)\nthis:\n  open U\n\ngoal (1 subgoal):\n 1. X f = 0", "have \"A \\<subseteq> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> U", "using that"], ["proof (prove)\nusing this:\n  open W\n  p \\<in> W\n  W \\<subseteq> carrier\n  X \\<in> tangent_space p\n  f \\<in> diff_fun_space\n  ?x3 \\<in> W \\<Longrightarrow> f ?x3 = 0\n\ngoal (1 subgoal):\n 1. A \\<subseteq> U", "by (auto simp: A_def U_def)"], ["proof (state)\nthis:\n  A \\<subseteq> U\n\ngoal (1 subgoal):\n 1. X f = 0", "have \"U \\<subseteq> carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> carrier", "by (auto simp: U_def)"], ["proof (state)\nthis:\n  U \\<subseteq> carrier\n\ngoal (1 subgoal):\n 1. X f = 0", "from extension_lemmaE[of A \"\\<lambda>x. 1\" U, OF clA d1 \\<open>A \\<subseteq> U\\<close> \\<open>U \\<subseteq> carrier\\<close> \\<open>open U\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>f'.\n      \\<lbrakk>diff_fun k charts f';\n       \\<And>x. x \\<in> A \\<Longrightarrow> f' x = (1::?'c4);\n       csupport_on carrier f' \\<inter> carrier \\<subseteq> U\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain u::\"'a\\<Rightarrow>real\" where u: \"diff_fun k charts u\" \"(\\<And>x. x \\<in> A \\<Longrightarrow> u x = 1)\" \"csupport_on carrier u \\<inter> carrier \\<subseteq> U\""], ["proof (prove)\nusing this:\n  (\\<And>f'.\n      \\<lbrakk>diff_fun k charts f';\n       \\<And>x. x \\<in> A \\<Longrightarrow> f' x = (1::?'c4);\n       csupport_on carrier f' \\<inter> carrier \\<subseteq> U\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>diff_fun k charts u;\n         \\<And>x. x \\<in> A \\<Longrightarrow> u x = 1;\n         csupport_on carrier u \\<inter> carrier \\<subseteq> U\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  diff_fun k charts u\n  ?x4 \\<in> A \\<Longrightarrow> u ?x4 = 1\n  csupport_on carrier u \\<inter> carrier \\<subseteq> U\n\ngoal (1 subgoal):\n 1. X f = 0", "have u_in_df: \"restrict0 carrier u \\<in> diff_fun_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 carrier u \\<in> diff_fun_space", "by (rule restrict0_in_fun_space) fact"], ["proof (state)\nthis:\n  restrict0 carrier u \\<in> diff_fun_space\n\ngoal (1 subgoal):\n 1. X f = 0", "have \"f p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f p = 0", "using that"], ["proof (prove)\nusing this:\n  open W\n  p \\<in> W\n  W \\<subseteq> carrier\n  X \\<in> tangent_space p\n  f \\<in> diff_fun_space\n  ?x3 \\<in> W \\<Longrightarrow> f ?x3 = 0\n\ngoal (1 subgoal):\n 1. f p = 0", "by auto"], ["proof (state)\nthis:\n  f p = 0\n\ngoal (1 subgoal):\n 1. X f = 0", "have \"p \\<notin> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> U", "by (auto simp: U_def)"], ["proof (state)\nthis:\n  p \\<notin> U\n\ngoal (1 subgoal):\n 1. X f = 0", "then"], ["proof (chain)\npicking this:\n  p \\<notin> U", "have \"restrict0 carrier u p = 0\""], ["proof (prove)\nusing this:\n  p \\<notin> U\n\ngoal (1 subgoal):\n 1. restrict0 carrier u p = 0", "using u(3)"], ["proof (prove)\nusing this:\n  p \\<notin> U\n  csupport_on carrier u \\<inter> carrier \\<subseteq> U\n\ngoal (1 subgoal):\n 1. restrict0 carrier u p = 0", "by (auto simp: restrict0_def) (meson IntI not_in_csupportD subsetCE)"], ["proof (state)\nthis:\n  restrict0 carrier u p = 0\n\ngoal (1 subgoal):\n 1. X f = 0", "have \"X (f * restrict0 carrier u) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (f * restrict0 carrier u) = 0", "using \\<open>X \\<in> tangent_space p\\<close> \\<open>f \\<in> diff_fun_space\\<close> u_in_df \\<open>f p = 0\\<close>"], ["proof (prove)\nusing this:\n  X \\<in> tangent_space p\n  f \\<in> diff_fun_space\n  restrict0 carrier u \\<in> diff_fun_space\n  f p = 0\n\ngoal (1 subgoal):\n 1. X (f * restrict0 carrier u) = 0", "by (rule derivation_times_eq_zeroI) fact"], ["proof (state)\nthis:\n  X (f * restrict0 carrier u) = 0\n\ngoal (1 subgoal):\n 1. X f = 0", "also"], ["proof (state)\nthis:\n  X (f * restrict0 carrier u) = 0\n\ngoal (1 subgoal):\n 1. X f = 0", "have \"f * restrict0 carrier u = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f * restrict0 carrier u = f", "proof (rule ext, cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. ?P2 x \\<Longrightarrow> (f * restrict0 carrier u) x = f x\n 2. \\<And>x.\n       \\<not> ?P2 x \\<Longrightarrow> (f * restrict0 carrier u) x = f x", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. ?P2 x \\<Longrightarrow> (f * restrict0 carrier u) x = f x\n 2. \\<And>x.\n       \\<not> ?P2 x \\<Longrightarrow> (f * restrict0 carrier u) x = f x", "assume \"x \\<in> W\""], ["proof (state)\nthis:\n  x \\<in> W\n\ngoal (2 subgoals):\n 1. \\<And>x. ?P2 x \\<Longrightarrow> (f * restrict0 carrier u) x = f x\n 2. \\<And>x.\n       \\<not> ?P2 x \\<Longrightarrow> (f * restrict0 carrier u) x = f x", "then"], ["proof (chain)\npicking this:\n  x \\<in> W", "show \"(f * restrict0 carrier u) x = f x\""], ["proof (prove)\nusing this:\n  x \\<in> W\n\ngoal (1 subgoal):\n 1. (f * restrict0 carrier u) x = f x", "by (auto simp: that)"], ["proof (state)\nthis:\n  (f * restrict0 carrier u) x = f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> W \\<Longrightarrow> (f * restrict0 carrier u) x = f x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> W \\<Longrightarrow> (f * restrict0 carrier u) x = f x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> W \\<Longrightarrow> (f * restrict0 carrier u) x = f x", "assume \"x \\<notin> W\""], ["proof (state)\nthis:\n  x \\<notin> W\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> W \\<Longrightarrow> (f * restrict0 carrier u) x = f x", "show \"(f * restrict0 carrier u) x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f * restrict0 carrier u) x = f x", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (f * restrict0 carrier u) x = f x\n 2. \\<not> ?P \\<Longrightarrow> (f * restrict0 carrier u) x = f x", "assume \"x \\<in> carrier\""], ["proof (state)\nthis:\n  x \\<in> carrier\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (f * restrict0 carrier u) x = f x\n 2. \\<not> ?P \\<Longrightarrow> (f * restrict0 carrier u) x = f x", "with \\<open>x \\<notin> W\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> W\n  x \\<in> carrier", "have \"x \\<in> A\""], ["proof (prove)\nusing this:\n  x \\<notin> W\n  x \\<in> carrier\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by (auto simp: A_def)"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (f * restrict0 carrier u) x = f x\n 2. \\<not> ?P \\<Longrightarrow> (f * restrict0 carrier u) x = f x", "then"], ["proof (chain)\npicking this:\n  x \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (f * restrict0 carrier u) x = f x", "using \\<open>x \\<in> carrier\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> A\n  x \\<in> carrier\n\ngoal (1 subgoal):\n 1. (f * restrict0 carrier u) x = f x", "by (auto simp: u)"], ["proof (state)\nthis:\n  (f * restrict0 carrier u) x = f x\n\ngoal (1 subgoal):\n 1. x \\<notin> carrier \\<Longrightarrow> (f * restrict0 carrier u) x = f x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> carrier \\<Longrightarrow> (f * restrict0 carrier u) x = f x", "assume \"x \\<notin> carrier\""], ["proof (state)\nthis:\n  x \\<notin> carrier\n\ngoal (1 subgoal):\n 1. x \\<notin> carrier \\<Longrightarrow> (f * restrict0 carrier u) x = f x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> carrier", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> carrier\n\ngoal (1 subgoal):\n 1. (f * restrict0 carrier u) x = f x", "using \\<open>f \\<in> diff_fun_space\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> carrier\n  f \\<in> diff_fun_space\n\ngoal (1 subgoal):\n 1. (f * restrict0 carrier u) x = f x", "by (auto dest!: diff_fun_space_extensionalD simp: extensional0_outside)"], ["proof (state)\nthis:\n  (f * restrict0 carrier u) x = f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f * restrict0 carrier u) x = f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f * restrict0 carrier u = f\n\ngoal (1 subgoal):\n 1. X f = 0", "finally"], ["proof (chain)\npicking this:\n  X f = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  X f = 0\n\ngoal (1 subgoal):\n 1. X f = 0", "."], ["proof (state)\nthis:\n  X f = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derivation_eq_localI: \"X f = X g\"\n  if \"open U\" \"p \\<in> U\" \"U \\<subseteq> carrier\"\n    \"X \\<in> tangent_space p\"\n    \"f \\<in> diff_fun_space\"\n    \"g \\<in> diff_fun_space\"\n    \"\\<And>x. x \\<in> U \\<Longrightarrow> f x = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X f = X g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. X f = X g", "note minus = diff_fun_space.linear_diff[OF _ _ _ tangent_space_linear_on[OF that(4)]]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x.\n              x \\<in> diff_fun_space \\<longrightarrow> X x \\<in> UNIV;\n   ?x \\<in> diff_fun_space; ?y \\<in> diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> X (?x - ?y) = X ?x - X ?y\n\ngoal (1 subgoal):\n 1. X f = X g", "have \"f - g \\<in> diff_fun_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f - g \\<in> diff_fun_space", "using subspace_diff_fun_space \\<open>f \\<in> _\\<close> \\<open>g \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  subspace diff_fun_space\n  f \\<in> diff_fun_space\n  g \\<in> diff_fun_space\n\ngoal (1 subgoal):\n 1. f - g \\<in> diff_fun_space", "by (rule subspace_diff)"], ["proof (state)\nthis:\n  f - g \\<in> diff_fun_space\n\ngoal (1 subgoal):\n 1. X f = X g", "have \"X f - X g = X (f - g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X f - X g = X (f - g)", "using that"], ["proof (prove)\nusing this:\n  open U\n  p \\<in> U\n  U \\<subseteq> carrier\n  X \\<in> tangent_space p\n  f \\<in> diff_fun_space\n  g \\<in> diff_fun_space\n  ?x3 \\<in> U \\<Longrightarrow> f ?x3 = g ?x3\n\ngoal (1 subgoal):\n 1. X f - X g = X (f - g)", "by (simp add: minus)"], ["proof (state)\nthis:\n  X f - X g = X (f - g)\n\ngoal (1 subgoal):\n 1. X f = X g", "also"], ["proof (state)\nthis:\n  X f - X g = X (f - g)\n\ngoal (1 subgoal):\n 1. X f = X g", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (f - g) = 0", "using \\<open>open U\\<close> \\<open>p \\<in> U\\<close> \\<open>U \\<subseteq> _\\<close> \\<open>X \\<in> _\\<close> \\<open>f - g \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  open U\n  p \\<in> U\n  U \\<subseteq> carrier\n  X \\<in> tangent_space p\n  f - g \\<in> diff_fun_space\n\ngoal (1 subgoal):\n 1. X (f - g) = 0", "by (rule derivation_zero_localI) (simp add: that)"], ["proof (state)\nthis:\n  X (f - g) = 0\n\ngoal (1 subgoal):\n 1. X f = X g", "finally"], ["proof (chain)\npicking this:\n  X f - X g = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  X f - X g = 0\n\ngoal (1 subgoal):\n 1. X f = X g", "by simp"], ["proof (state)\nthis:\n  X f = X g\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Push-forward on the tangent space\\<close>"], ["", "context diff begin"], ["", "text \\<open>\n  Push-forward on tangent spaces.\n\n  Given an element of the tangent space at src, considered as a functional \\<open>X\\<close>,\n  the push-forward of \\<open>X\\<close> is a functional at dest, mapping \\<open>g\\<close> to \\<open>X (g \\<circ> f)\\<close>.\n\\<close>"], ["", "definition push_forward :: \"(('a \\<Rightarrow> real) \\<Rightarrow> real) \\<Rightarrow> ('b \\<Rightarrow> real) \\<Rightarrow> real\" where\n  \"push_forward X = restrict0 dest.diff_fun_space (\\<lambda>g. X (restrict0 src.carrier (g \\<circ> f)))\""], ["", "lemma extensional_push_forward: \"extensional0 dest.diff_fun_space (push_forward X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extensional0 dest.diff_fun_space (push_forward X)", "by (auto simp: push_forward_def)"], ["", "lemma linear_push_forward: \"linear push_forward\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear push_forward", "by (auto simp: push_forward_def[abs_def] o_def restrict0_def intro!: linearI)"], ["", "text \\<open>Properties of push-forwards\\<close>"], ["", "lemma restrict_compose_in_diff_fun_space:\n  \"x \\<in> dest.diff_fun_space \\<Longrightarrow> restrict0 src.carrier (x \\<circ> f) \\<in> src.diff_fun_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dest.diff_fun_space \\<Longrightarrow>\n    restrict0 src.carrier (x \\<circ> f) \\<in> src.diff_fun_space", "apply (rule src.restrict0_in_fun_space)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dest.diff_fun_space \\<Longrightarrow>\n    diff_fun k charts1 (x \\<circ> f)", "apply (rule diff_fun_compose)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> dest.diff_fun_space \\<Longrightarrow> diff k charts1 ?M2.2 f\n 2. x \\<in> dest.diff_fun_space \\<Longrightarrow> diff_fun k ?M2.2 x", "apply (rule diff_axioms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dest.diff_fun_space \\<Longrightarrow> diff_fun k charts2 x", "apply (rule dest.diff_fun_spaceD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dest.diff_fun_space \\<Longrightarrow>\n    x \\<in> dest.diff_fun_space", "by assumption"], ["", "text \\<open>Push-forward of a linear functional is a linear\\<close>"], ["", "lemma linear_on_diff_fun_push_forward:\n  \"dest.linear_diff_fun (push_forward X)\"\n  if \"src.linear_diff_fun X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_on dest.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R)\n     (push_forward X)", "proof unfold_locales"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> dest.diff_fun_space;\n        b2 \\<in> dest.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> push_forward X (b1 + b2) =\n                         push_forward X b1 + push_forward X b2\n 2. \\<And>r b.\n       b \\<in> dest.diff_fun_space \\<Longrightarrow>\n       push_forward X (r *\\<^sub>R b) = r *\\<^sub>R push_forward X b", "note add = src.diff_fun_space.linear_add[OF _ _ _ that]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x.\n              x \\<in> src.diff_fun_space \\<longrightarrow> X x \\<in> UNIV;\n   ?b1.0 \\<in> src.diff_fun_space; ?b2.0 \\<in> src.diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> X (?b1.0 + ?b2.0) = X ?b1.0 + X ?b2.0\n\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> dest.diff_fun_space;\n        b2 \\<in> dest.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> push_forward X (b1 + b2) =\n                         push_forward X b1 + push_forward X b2\n 2. \\<And>r b.\n       b \\<in> dest.diff_fun_space \\<Longrightarrow>\n       push_forward X (r *\\<^sub>R b) = r *\\<^sub>R push_forward X b", "note scale = src.diff_fun_space.linear_scale[OF _ _ that]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x.\n              x \\<in> src.diff_fun_space \\<longrightarrow> X x \\<in> UNIV;\n   ?b \\<in> src.diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> X (?r *\\<^sub>R ?b) = ?r *\\<^sub>R X ?b\n\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> dest.diff_fun_space;\n        b2 \\<in> dest.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> push_forward X (b1 + b2) =\n                         push_forward X b1 + push_forward X b2\n 2. \\<And>r b.\n       b \\<in> dest.diff_fun_space \\<Longrightarrow>\n       push_forward X (r *\\<^sub>R b) = r *\\<^sub>R push_forward X b", "fix x y::\"'b \\<Rightarrow> real\" and c::real"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> dest.diff_fun_space;\n        b2 \\<in> dest.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> push_forward X (b1 + b2) =\n                         push_forward X b1 + push_forward X b2\n 2. \\<And>r b.\n       b \\<in> dest.diff_fun_space \\<Longrightarrow>\n       push_forward X (r *\\<^sub>R b) = r *\\<^sub>R push_forward X b", "assume dfx: \"x \\<in> dest.diff_fun_space\""], ["proof (state)\nthis:\n  x \\<in> dest.diff_fun_space\n\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> dest.diff_fun_space;\n        b2 \\<in> dest.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> push_forward X (b1 + b2) =\n                         push_forward X b1 + push_forward X b2\n 2. \\<And>r b.\n       b \\<in> dest.diff_fun_space \\<Longrightarrow>\n       push_forward X (r *\\<^sub>R b) = r *\\<^sub>R push_forward X b", "then"], ["proof (chain)\npicking this:\n  x \\<in> dest.diff_fun_space", "have dx: \"diff_fun k charts2 x\" and ex: \"extensional0 dest.carrier x\""], ["proof (prove)\nusing this:\n  x \\<in> dest.diff_fun_space\n\ngoal (1 subgoal):\n 1. diff_fun k charts2 x &&& extensional0 dest.carrier x", "by (auto simp: dest.diff_fun_space_def)"], ["proof (state)\nthis:\n  diff_fun k charts2 x\n  extensional0 dest.carrier x\n\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> dest.diff_fun_space;\n        b2 \\<in> dest.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> push_forward X (b1 + b2) =\n                         push_forward X b1 + push_forward X b2\n 2. \\<And>r b.\n       b \\<in> dest.diff_fun_space \\<Longrightarrow>\n       push_forward X (r *\\<^sub>R b) = r *\\<^sub>R push_forward X b", "show \"push_forward X (c *\\<^sub>R x) = c *\\<^sub>R push_forward X x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_forward X (c *\\<^sub>R x) = c *\\<^sub>R push_forward X x", "unfolding push_forward_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 dest.diff_fun_space\n     (\\<lambda>g. X (restrict0 src.carrier (g \\<circ> f))) (c *\\<^sub>R x) =\n    c *\\<^sub>R\n    restrict0 dest.diff_fun_space\n     (\\<lambda>g. X (restrict0 src.carrier (g \\<circ> f))) x", "using defined dfx"], ["proof (prove)\nusing this:\n  f ` src.carrier \\<subseteq> dest.carrier\n  x \\<in> dest.diff_fun_space\n\ngoal (1 subgoal):\n 1. restrict0 dest.diff_fun_space\n     (\\<lambda>g. X (restrict0 src.carrier (g \\<circ> f))) (c *\\<^sub>R x) =\n    c *\\<^sub>R\n    restrict0 dest.diff_fun_space\n     (\\<lambda>g. X (restrict0 src.carrier (g \\<circ> f))) x", "by (auto simp: subspace_mul scaleR_compose restrict0_scaleR\n        restrict_compose_in_diff_fun_space scale)"], ["proof (state)\nthis:\n  push_forward X (c *\\<^sub>R x) = c *\\<^sub>R push_forward X x\n\ngoal (1 subgoal):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> dest.diff_fun_space;\n        b2 \\<in> dest.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> push_forward X (b1 + b2) =\n                         push_forward X b1 + push_forward X b2", "assume dfy: \"y \\<in> dest.diff_fun_space\""], ["proof (state)\nthis:\n  y \\<in> dest.diff_fun_space\n\ngoal (1 subgoal):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> dest.diff_fun_space;\n        b2 \\<in> dest.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> push_forward X (b1 + b2) =\n                         push_forward X b1 + push_forward X b2", "then"], ["proof (chain)\npicking this:\n  y \\<in> dest.diff_fun_space", "have dy: \"diff_fun k charts2 y\" and ey: \"extensional0 dest.carrier y\""], ["proof (prove)\nusing this:\n  y \\<in> dest.diff_fun_space\n\ngoal (1 subgoal):\n 1. diff_fun k charts2 y &&& extensional0 dest.carrier y", "by (auto simp: dest.diff_fun_space_def)"], ["proof (state)\nthis:\n  diff_fun k charts2 y\n  extensional0 dest.carrier y\n\ngoal (1 subgoal):\n 1. \\<And>b1 b2.\n       \\<lbrakk>b1 \\<in> dest.diff_fun_space;\n        b2 \\<in> dest.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> push_forward X (b1 + b2) =\n                         push_forward X b1 + push_forward X b2", "show \"push_forward X (x + y) = push_forward X x + push_forward X y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_forward X (x + y) = push_forward X x + push_forward X y", "unfolding push_forward_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 dest.diff_fun_space\n     (\\<lambda>g. X (restrict0 src.carrier (g \\<circ> f))) (x + y) =\n    restrict0 dest.diff_fun_space\n     (\\<lambda>g. X (restrict0 src.carrier (g \\<circ> f))) x +\n    restrict0 dest.diff_fun_space\n     (\\<lambda>g. X (restrict0 src.carrier (g \\<circ> f))) y", "using defined dfy dfx"], ["proof (prove)\nusing this:\n  f ` src.carrier \\<subseteq> dest.carrier\n  y \\<in> dest.diff_fun_space\n  x \\<in> dest.diff_fun_space\n\ngoal (1 subgoal):\n 1. restrict0 dest.diff_fun_space\n     (\\<lambda>g. X (restrict0 src.carrier (g \\<circ> f))) (x + y) =\n    restrict0 dest.diff_fun_space\n     (\\<lambda>g. X (restrict0 src.carrier (g \\<circ> f))) x +\n    restrict0 dest.diff_fun_space\n     (\\<lambda>g. X (restrict0 src.carrier (g \\<circ> f))) y", "by (auto simp: subspace_add plus_compose restrict0_add restrict_compose_in_diff_fun_space add)"], ["proof (state)\nthis:\n  push_forward X (x + y) = push_forward X x + push_forward X y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Push-forward preserves the product rule\\<close>"], ["", "lemma push_forward_is_derivation:\n  \"push_forward X (x * y) = x (f p) * push_forward X y + y (f p) * push_forward X x\"\n  (is \"?l = ?r\")\n  if deriv: \"\\<And>x y. x \\<in> src.diff_fun_space \\<Longrightarrow> y \\<in> src.diff_fun_space \\<Longrightarrow> X (x * y) = x p * X y + y p * X x\"\n    and dx: \"x \\<in> dest.diff_fun_space\"\n    and dy: \"y \\<in> dest.diff_fun_space\"\n    and p: \"p \\<in> src.carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_forward X (x * y) =\n    x (f p) * push_forward X y + y (f p) * push_forward X x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. push_forward X (x * y) =\n    x (f p) * push_forward X y + y (f p) * push_forward X x", "have \"x * y \\<in> dest.diff_fun_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<in> dest.diff_fun_space", "using dx dy"], ["proof (prove)\nusing this:\n  x \\<in> dest.diff_fun_space\n  y \\<in> dest.diff_fun_space\n\ngoal (1 subgoal):\n 1. x * y \\<in> dest.diff_fun_space", "by (auto simp: dest.diff_fun_space_def dest.diff_fun_times)"], ["proof (state)\nthis:\n  x * y \\<in> dest.diff_fun_space\n\ngoal (1 subgoal):\n 1. push_forward X (x * y) =\n    x (f p) * push_forward X y + y (f p) * push_forward X x", "then"], ["proof (chain)\npicking this:\n  x * y \\<in> dest.diff_fun_space", "have \"?l = X (restrict0 src.carrier (x \\<circ> f) * restrict0 src.carrier (y \\<circ> f))\""], ["proof (prove)\nusing this:\n  x * y \\<in> dest.diff_fun_space\n\ngoal (1 subgoal):\n 1. push_forward X (x * y) =\n    X (restrict0 src.carrier (x \\<circ> f) *\n       restrict0 src.carrier (y \\<circ> f))", "by (simp add: push_forward_def mult_compose restrict0_times)"], ["proof (state)\nthis:\n  push_forward X (x * y) =\n  X (restrict0 src.carrier (x \\<circ> f) *\n     restrict0 src.carrier (y \\<circ> f))\n\ngoal (1 subgoal):\n 1. push_forward X (x * y) =\n    x (f p) * push_forward X y + y (f p) * push_forward X x", "also"], ["proof (state)\nthis:\n  push_forward X (x * y) =\n  X (restrict0 src.carrier (x \\<circ> f) *\n     restrict0 src.carrier (y \\<circ> f))\n\ngoal (1 subgoal):\n 1. push_forward X (x * y) =\n    x (f p) * push_forward X y + y (f p) * push_forward X x", "have \"\\<dots> = restrict0 src.carrier (x \\<circ> f) p * X (restrict0 src.carrier (y \\<circ> f)) +\n    restrict0 src.carrier (y \\<circ> f) p * X (restrict0 src.carrier (x \\<circ> f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (restrict0 src.carrier (x \\<circ> f) *\n       restrict0 src.carrier (y \\<circ> f)) =\n    restrict0 src.carrier (x \\<circ> f) p *\n    X (restrict0 src.carrier (y \\<circ> f)) +\n    restrict0 src.carrier (y \\<circ> f) p *\n    X (restrict0 src.carrier (x \\<circ> f))", "using dx dy"], ["proof (prove)\nusing this:\n  x \\<in> dest.diff_fun_space\n  y \\<in> dest.diff_fun_space\n\ngoal (1 subgoal):\n 1. X (restrict0 src.carrier (x \\<circ> f) *\n       restrict0 src.carrier (y \\<circ> f)) =\n    restrict0 src.carrier (x \\<circ> f) p *\n    X (restrict0 src.carrier (y \\<circ> f)) +\n    restrict0 src.carrier (y \\<circ> f) p *\n    X (restrict0 src.carrier (x \\<circ> f))", "by (simp add: deriv restrict_compose_in_diff_fun_space)"], ["proof (state)\nthis:\n  X (restrict0 src.carrier (x \\<circ> f) *\n     restrict0 src.carrier (y \\<circ> f)) =\n  restrict0 src.carrier (x \\<circ> f) p *\n  X (restrict0 src.carrier (y \\<circ> f)) +\n  restrict0 src.carrier (y \\<circ> f) p *\n  X (restrict0 src.carrier (x \\<circ> f))\n\ngoal (1 subgoal):\n 1. push_forward X (x * y) =\n    x (f p) * push_forward X y + y (f p) * push_forward X x", "also"], ["proof (state)\nthis:\n  X (restrict0 src.carrier (x \\<circ> f) *\n     restrict0 src.carrier (y \\<circ> f)) =\n  restrict0 src.carrier (x \\<circ> f) p *\n  X (restrict0 src.carrier (y \\<circ> f)) +\n  restrict0 src.carrier (y \\<circ> f) p *\n  X (restrict0 src.carrier (x \\<circ> f))\n\ngoal (1 subgoal):\n 1. push_forward X (x * y) =\n    x (f p) * push_forward X y + y (f p) * push_forward X x", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 src.carrier (x \\<circ> f) p *\n    X (restrict0 src.carrier (y \\<circ> f)) +\n    restrict0 src.carrier (y \\<circ> f) p *\n    X (restrict0 src.carrier (x \\<circ> f)) =\n    x (f p) * push_forward X y + y (f p) * push_forward X x", "using dx dy"], ["proof (prove)\nusing this:\n  x \\<in> dest.diff_fun_space\n  y \\<in> dest.diff_fun_space\n\ngoal (1 subgoal):\n 1. restrict0 src.carrier (x \\<circ> f) p *\n    X (restrict0 src.carrier (y \\<circ> f)) +\n    restrict0 src.carrier (y \\<circ> f) p *\n    X (restrict0 src.carrier (x \\<circ> f)) =\n    x (f p) * push_forward X y + y (f p) * push_forward X x", "by (simp add: push_forward_def p)"], ["proof (state)\nthis:\n  restrict0 src.carrier (x \\<circ> f) p *\n  X (restrict0 src.carrier (y \\<circ> f)) +\n  restrict0 src.carrier (y \\<circ> f) p *\n  X (restrict0 src.carrier (x \\<circ> f)) =\n  x (f p) * push_forward X y + y (f p) * push_forward X x\n\ngoal (1 subgoal):\n 1. push_forward X (x * y) =\n    x (f p) * push_forward X y + y (f p) * push_forward X x", "finally"], ["proof (chain)\npicking this:\n  push_forward X (x * y) =\n  x (f p) * push_forward X y + y (f p) * push_forward X x", "show ?thesis"], ["proof (prove)\nusing this:\n  push_forward X (x * y) =\n  x (f p) * push_forward X y + y (f p) * push_forward X x\n\ngoal (1 subgoal):\n 1. push_forward X (x * y) =\n    x (f p) * push_forward X y + y (f p) * push_forward X x", "."], ["proof (state)\nthis:\n  push_forward X (x * y) =\n  x (f p) * push_forward X y + y (f p) * push_forward X x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Combining, we show that the push-forward of a derivation is a derivation\\<close>"], ["", "lemma push_forward_in_tangent_space:\n  \"push_forward ` (src.tangent_space p) \\<subseteq> dest.tangent_space (f p)\"\n  if \"p \\<in> src.carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_forward ` src.tangent_space p \\<subseteq> dest.tangent_space (f p)", "unfolding src.is_derivation_def dest.is_derivation_def src.tangent_space_def dest.tangent_space_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_forward `\n    {X. (linear_on src.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) X \\<and>\n         (\\<forall>f g.\n             f \\<in> src.diff_fun_space \\<longrightarrow>\n             g \\<in> src.diff_fun_space \\<longrightarrow>\n             X (f * g) = f p * X g + g p * X f)) \\<and>\n        extensional0 src.diff_fun_space X}\n    \\<subseteq> {X. (linear_on dest.diff_fun_space UNIV (*\\<^sub>R)\n                      (*\\<^sub>R) X \\<and>\n                     (\\<forall>fa g.\n                         fa \\<in> dest.diff_fun_space \\<longrightarrow>\n                         g \\<in> dest.diff_fun_space \\<longrightarrow>\n                         X (fa * g) =\n                         fa (f p) * X g + g (f p) * X fa)) \\<and>\n                    extensional0 dest.diff_fun_space X}", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>extensional0 src.diff_fun_space xa;\n        linear_on src.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) xa;\n        \\<forall>f g.\n           f \\<in> src.diff_fun_space \\<longrightarrow>\n           g \\<in> src.diff_fun_space \\<longrightarrow>\n           xa (f * g) = f p * xa g + g p * xa f\\<rbrakk>\n       \\<Longrightarrow> linear_on dest.diff_fun_space UNIV (*\\<^sub>R)\n                          (*\\<^sub>R) (push_forward xa)\n 2. \\<And>x xa fa g.\n       \\<lbrakk>extensional0 src.diff_fun_space xa;\n        linear_on src.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) xa;\n        \\<forall>f g.\n           f \\<in> src.diff_fun_space \\<longrightarrow>\n           g \\<in> src.diff_fun_space \\<longrightarrow>\n           xa (f * g) = f p * xa g + g p * xa f;\n        fa \\<in> dest.diff_fun_space; g \\<in> dest.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> push_forward xa (fa * g) =\n                         fa (f p) * push_forward xa g +\n                         g (f p) * push_forward xa fa\n 3. \\<And>x xa.\n       \\<lbrakk>extensional0 src.diff_fun_space xa;\n        linear_on src.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) xa;\n        \\<forall>f g.\n           f \\<in> src.diff_fun_space \\<longrightarrow>\n           g \\<in> src.diff_fun_space \\<longrightarrow>\n           xa (f * g) = f p * xa g + g p * xa f\\<rbrakk>\n       \\<Longrightarrow> extensional0 dest.diff_fun_space (push_forward xa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extensional0 src.diff_fun_space xa_;\n     linear_on src.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) xa_;\n     \\<forall>f g.\n        f \\<in> src.diff_fun_space \\<longrightarrow>\n        g \\<in> src.diff_fun_space \\<longrightarrow>\n        xa_ (f * g) = f p * xa_ g + g p * xa_ f\\<rbrakk>\n    \\<Longrightarrow> linear_on dest.diff_fun_space UNIV (*\\<^sub>R)\n                       (*\\<^sub>R) (push_forward xa_)", "by (rule linear_on_diff_fun_push_forward)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa fa g.\n       \\<lbrakk>extensional0 src.diff_fun_space xa;\n        linear_on src.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) xa;\n        \\<forall>f g.\n           f \\<in> src.diff_fun_space \\<longrightarrow>\n           g \\<in> src.diff_fun_space \\<longrightarrow>\n           xa (f * g) = f p * xa g + g p * xa f;\n        fa \\<in> dest.diff_fun_space; g \\<in> dest.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> push_forward xa (fa * g) =\n                         fa (f p) * push_forward xa g +\n                         g (f p) * push_forward xa fa\n 2. \\<And>x xa.\n       \\<lbrakk>extensional0 src.diff_fun_space xa;\n        linear_on src.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) xa;\n        \\<forall>f g.\n           f \\<in> src.diff_fun_space \\<longrightarrow>\n           g \\<in> src.diff_fun_space \\<longrightarrow>\n           xa (f * g) = f p * xa g + g p * xa f\\<rbrakk>\n       \\<Longrightarrow> extensional0 dest.diff_fun_space (push_forward xa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extensional0 src.diff_fun_space xa_;\n     linear_on src.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) xa_;\n     \\<forall>f g.\n        f \\<in> src.diff_fun_space \\<longrightarrow>\n        g \\<in> src.diff_fun_space \\<longrightarrow>\n        xa_ (f * g) = f p * xa_ g + g p * xa_ f;\n     fa_ \\<in> dest.diff_fun_space; g_ \\<in> dest.diff_fun_space\\<rbrakk>\n    \\<Longrightarrow> push_forward xa_ (fa_ * g_) =\n                      fa_ (f p) * push_forward xa_ g_ +\n                      g_ (f p) * push_forward xa_ fa_", "by (blast intro: dest.diff_fun_spaceD that push_forward_is_derivation)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>extensional0 src.diff_fun_space xa;\n        linear_on src.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) xa;\n        \\<forall>f g.\n           f \\<in> src.diff_fun_space \\<longrightarrow>\n           g \\<in> src.diff_fun_space \\<longrightarrow>\n           xa (f * g) = f p * xa g + g p * xa f\\<rbrakk>\n       \\<Longrightarrow> extensional0 dest.diff_fun_space (push_forward xa)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extensional0 src.diff_fun_space xa_;\n     linear_on src.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) xa_;\n     \\<forall>f g.\n        f \\<in> src.diff_fun_space \\<longrightarrow>\n        g \\<in> src.diff_fun_space \\<longrightarrow>\n        xa_ (f * g) = f p * xa_ g + g p * xa_ f\\<rbrakk>\n    \\<Longrightarrow> extensional0 dest.diff_fun_space (push_forward xa_)", "by (simp add: push_forward_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>Functoriality of push-forward: identity\\<close>"], ["", "context c_manifold begin"], ["", "lemma push_forward_id:\n  \"diff.push_forward k charts charts f X = X\"\n  if \"\\<And>x. x \\<in> carrier \\<Longrightarrow> f x = x\"\n    \"X \\<in> tangent_space p\" \"p \\<in> carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff.push_forward k charts charts f X = X", "apply (subst diff.push_forward_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. diff k charts charts f\n 2. restrict0 diff_fun_space\n     (\\<lambda>g. X (restrict0 carrier (g \\<circ> f))) =\n    X", "apply (rule diff.diff_cong[where f=\"\\<lambda>x. x\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. diff k charts charts (\\<lambda>x. x)\n 2. \\<And>x. x \\<in> carrier \\<Longrightarrow> x = f x\n 3. restrict0 diff_fun_space\n     (\\<lambda>g. X (restrict0 carrier (g \\<circ> f))) =\n    X", "apply (rule diff_id)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> carrier \\<Longrightarrow> x = f x\n 2. restrict0 diff_fun_space\n     (\\<lambda>g. X (restrict0 carrier (g \\<circ> f))) =\n    X", "apply (rule that(1)[symmetric], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 diff_fun_space\n     (\\<lambda>g. X (restrict0 carrier (g \\<circ> f))) =\n    X", "apply (rule ext_extensional0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. extensional0 ?S8\n     (restrict0 diff_fun_space\n       (\\<lambda>g. X (restrict0 carrier (g \\<circ> f))))\n 2. extensional0 ?S8 X\n 3. \\<And>x.\n       x \\<in> ?S8 \\<Longrightarrow>\n       restrict0 diff_fun_space\n        (\\<lambda>g. X (restrict0 carrier (g \\<circ> f))) x =\n       X x", "apply (rule extensional0_restrict0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. extensional0 diff_fun_space X\n 2. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow>\n       restrict0 diff_fun_space\n        (\\<lambda>g. X (restrict0 carrier (g \\<circ> f))) x =\n       X x", "apply (rule tangent_space_restrict)"], ["proof (prove)\ngoal (2 subgoals):\n 1. X \\<in> tangent_space ?p13\n 2. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow>\n       restrict0 diff_fun_space\n        (\\<lambda>g. X (restrict0 carrier (g \\<circ> f))) x =\n       X x", "apply (rule that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow>\n       restrict0 diff_fun_space\n        (\\<lambda>g. X (restrict0 carrier (g \\<circ> f))) x =\n       X x", "apply (auto simp: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow>\n       X (restrict0 carrier (x \\<circ> f)) = X x", "apply (rule arg_cong[where f=X])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow>\n       restrict0 carrier (x \\<circ> f) = x", "apply (rule ext_extensional0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow>\n       extensional0 (?S17 x) (restrict0 carrier (x \\<circ> f))\n 2. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow> extensional0 (?S17 x) x\n 3. \\<And>x xa.\n       \\<lbrakk>x \\<in> diff_fun_space; xa \\<in> ?S17 x\\<rbrakk>\n       \\<Longrightarrow> restrict0 carrier (x \\<circ> f) xa = x xa", "apply (rule extensional0_restrict0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> diff_fun_space \\<Longrightarrow> extensional0 carrier x\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<in> diff_fun_space; xa \\<in> carrier\\<rbrakk>\n       \\<Longrightarrow> restrict0 carrier (x \\<circ> f) xa = x xa", "apply (rule diff_fun_space_extensionalD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> diff_fun_space; xa \\<in> carrier\\<rbrakk>\n       \\<Longrightarrow> restrict0 carrier (x \\<circ> f) xa = x xa", "apply (simp add: that)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text \\<open>Functoriality of push-forward: composition\\<close>"], ["", "lemma push_forward_compose:\n  \"diff.push_forward k M2 M3 g (diff.push_forward k M1 M2 f X) = diff.push_forward k M1 M3 (g o f) X\"\n  if \"X \\<in> c_manifold.tangent_space M1 k p\" \"p \\<in> manifold.carrier M1\"\n    and df: \"diff k M1 M2 f\" and dg: \"diff k M2 M3 g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff.push_forward k M2 M3 g (diff.push_forward k M1 M2 f X) =\n    diff.push_forward k M1 M3 (g \\<circ> f) X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. diff.push_forward k M2 M3 g (diff.push_forward k M1 M2 f X) =\n    diff.push_forward k M1 M3 (g \\<circ> f) X", "interpret d12: diff k M1 M2 f"], ["proof (prove)\ngoal (1 subgoal):\n 1. diff k M1 M2 f", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. diff.push_forward k M2 M3 g (d12.push_forward X) =\n    diff.push_forward k M1 M3 (g \\<circ> f) X", "interpret d23: diff k M2 M3 g"], ["proof (prove)\ngoal (1 subgoal):\n 1. diff k M2 M3 g", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. d23.push_forward (d12.push_forward X) =\n    diff.push_forward k M1 M3 (g \\<circ> f) X", "interpret d13: diff k M1 M3 \"g o f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff k M1 M3 (g \\<circ> f)", "by (rule diff_compose; fact)"], ["proof (state)\ngoal (1 subgoal):\n 1. d23.push_forward (d12.push_forward X) = d13.push_forward X", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. d23.push_forward (d12.push_forward X) = d13.push_forward X", "apply (rule ext_extensional0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. extensional0 ?S (d23.push_forward (d12.push_forward X))\n 2. extensional0 ?S (d13.push_forward X)\n 3. \\<And>x.\n       x \\<in> ?S \\<Longrightarrow>\n       d23.push_forward (d12.push_forward X) x = d13.push_forward X x", "apply (rule d23.extensional_push_forward)"], ["proof (prove)\ngoal (2 subgoals):\n 1. extensional0 d23.dest.diff_fun_space (d13.push_forward X)\n 2. \\<And>x.\n       x \\<in> d23.dest.diff_fun_space \\<Longrightarrow>\n       d23.push_forward (d12.push_forward X) x = d13.push_forward X x", "apply (rule d13.extensional_push_forward)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> d23.dest.diff_fun_space \\<Longrightarrow>\n       d23.push_forward (d12.push_forward X) x = d13.push_forward X x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> d23.dest.diff_fun_space \\<Longrightarrow>\n       d23.push_forward (d12.push_forward X) x = d13.push_forward X x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> d23.dest.diff_fun_space \\<Longrightarrow>\n       d23.push_forward (d12.push_forward X) x = d13.push_forward X x", "assume x: \"x \\<in> d23.dest.diff_fun_space\""], ["proof (state)\nthis:\n  x \\<in> d23.dest.diff_fun_space\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> d23.dest.diff_fun_space \\<Longrightarrow>\n       d23.push_forward (d12.push_forward X) x = d13.push_forward X x", "show \"d23.push_forward (d12.push_forward X) x = d13.push_forward X x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d23.push_forward (d12.push_forward X) x = d13.push_forward X x", "using x"], ["proof (prove)\nusing this:\n  x \\<in> d23.dest.diff_fun_space\n\ngoal (1 subgoal):\n 1. d23.push_forward (d12.push_forward X) x = d13.push_forward X x", "unfolding d12.push_forward_def d23.push_forward_def d13.push_forward_def"], ["proof (prove)\nusing this:\n  x \\<in> d23.dest.diff_fun_space\n\ngoal (1 subgoal):\n 1. restrict0 d23.dest.diff_fun_space\n     (\\<lambda>ga.\n         restrict0 d12.dest.diff_fun_space\n          (\\<lambda>g. X (restrict0 d12.src.carrier (g \\<circ> f)))\n          (restrict0 d12.dest.carrier (ga \\<circ> g)))\n     x =\n    restrict0 d23.dest.diff_fun_space\n     (\\<lambda>ga. X (restrict0 d12.src.carrier (ga \\<circ> (g \\<circ> f))))\n     x", "apply (simp add: d23.restrict_compose_in_diff_fun_space)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> d23.dest.diff_fun_space \\<Longrightarrow>\n    X (restrict0 d12.src.carrier\n        (restrict0 d12.dest.carrier (x \\<circ> g) \\<circ> f)) =\n    X (restrict0 d12.src.carrier (x \\<circ> (g \\<circ> f)))", "apply (rule arg_cong[where f=X])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> d23.dest.diff_fun_space \\<Longrightarrow>\n    restrict0 d12.src.carrier\n     (restrict0 d12.dest.carrier (x \\<circ> g) \\<circ> f) =\n    restrict0 d12.src.carrier (x \\<circ> (g \\<circ> f))", "apply (rule ext_extensional0[OF extensional0_restrict0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> d23.dest.diff_fun_space \\<Longrightarrow>\n    extensional0 d12.src.carrier\n     (restrict0 d12.src.carrier (x \\<circ> (g \\<circ> f)))\n 2. \\<And>xa.\n       \\<lbrakk>x \\<in> d23.dest.diff_fun_space;\n        xa \\<in> d12.src.carrier\\<rbrakk>\n       \\<Longrightarrow> restrict0 d12.src.carrier\n                          (restrict0 d12.dest.carrier (x \\<circ> g) \\<circ>\n                           f)\n                          xa =\n                         restrict0 d12.src.carrier (x \\<circ> (g \\<circ> f))\n                          xa", "apply (rule d12.src.diff_fun_space_extensionalD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> d23.dest.diff_fun_space \\<Longrightarrow>\n    restrict0 d12.src.carrier (x \\<circ> (g \\<circ> f))\n    \\<in> d12.src.diff_fun_space\n 2. \\<And>xa.\n       \\<lbrakk>x \\<in> d23.dest.diff_fun_space;\n        xa \\<in> d12.src.carrier\\<rbrakk>\n       \\<Longrightarrow> restrict0 d12.src.carrier\n                          (restrict0 d12.dest.carrier (x \\<circ> g) \\<circ>\n                           f)\n                          xa =\n                         restrict0 d12.src.carrier (x \\<circ> (g \\<circ> f))\n                          xa", "apply (rule d13.restrict_compose_in_diff_fun_space, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> d23.dest.diff_fun_space;\n        xa \\<in> d12.src.carrier\\<rbrakk>\n       \\<Longrightarrow> restrict0 d12.src.carrier\n                          (restrict0 d12.dest.carrier (x \\<circ> g) \\<circ>\n                           f)\n                          xa =\n                         restrict0 d12.src.carrier (x \\<circ> (g \\<circ> f))\n                          xa", "using d12.defined"], ["proof (prove)\nusing this:\n  f ` d12.src.carrier \\<subseteq> d12.dest.carrier\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> d23.dest.diff_fun_space;\n        xa \\<in> d12.src.carrier\\<rbrakk>\n       \\<Longrightarrow> restrict0 d12.src.carrier\n                          (restrict0 d12.dest.carrier (x \\<circ> g) \\<circ>\n                           f)\n                          xa =\n                         restrict0 d12.src.carrier (x \\<circ> (g \\<circ> f))\n                          xa", "by auto"], ["proof (state)\nthis:\n  d23.push_forward (d12.push_forward X) x = d13.push_forward X x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d23.push_forward (d12.push_forward X) = d13.push_forward X\n\ngoal:\nNo subgoals!", "qed"], ["", "context diffeomorphism begin"], ["", "text \\<open>If f is a diffeomorphism, then the push-forward \\<open>f*\\<close> is a bijection\\<close>"], ["", "lemma inv_push_forward_inverse: \"push_forward (inv.push_forward X) = X\"\n  if \"X \\<in> dest.tangent_space p\" \"p \\<in> dest.carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_forward (inv.push_forward X) = X", "apply (subst push_forward_compose[OF that inv.diff_axioms diff_axioms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. diff.push_forward k charts2 charts2 (f \\<circ> f') X = X", "apply (rule dest.push_forward_id[OF _ that])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> dest.carrier \\<Longrightarrow> (f \\<circ> f') x = x", "by auto"], ["", "lemma push_forward_inverse: \"inv.push_forward (push_forward X) = X\"\n  if \"X \\<in> src.tangent_space p\" \"p \\<in> src.carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv.push_forward (push_forward X) = X", "apply (subst push_forward_compose[OF that diff_axioms inv.diff_axioms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. diff.push_forward k charts1 charts1 (f' \\<circ> f) X = X", "apply (rule src.push_forward_id[OF _ that])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> src.carrier \\<Longrightarrow> (f' \\<circ> f) x = x", "by auto"], ["", "lemma bij_betw_push_forward:\n  \"bij_betw push_forward (src.tangent_space p) (dest.tangent_space (f p))\"\n  if p: \"p \\<in> src.carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw push_forward (src.tangent_space p) (dest.tangent_space (f p))", "proof (rule bij_betwI[where g=\"inv.push_forward\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. push_forward\n    \\<in> src.tangent_space p \\<rightarrow> dest.tangent_space (f p)\n 2. inv.push_forward\n    \\<in> dest.tangent_space (f p) \\<rightarrow> src.tangent_space p\n 3. \\<And>x.\n       x \\<in> src.tangent_space p \\<Longrightarrow>\n       inv.push_forward (push_forward x) = x\n 4. \\<And>y.\n       y \\<in> dest.tangent_space (f p) \\<Longrightarrow>\n       push_forward (inv.push_forward y) = y", "show \"push_forward \\<in> src.tangent_space p \\<rightarrow> dest.tangent_space (f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_forward\n    \\<in> src.tangent_space p \\<rightarrow> dest.tangent_space (f p)", "using push_forward_in_tangent_space[OF p]"], ["proof (prove)\nusing this:\n  push_forward ` src.tangent_space p \\<subseteq> dest.tangent_space (f p)\n\ngoal (1 subgoal):\n 1. push_forward\n    \\<in> src.tangent_space p \\<rightarrow> dest.tangent_space (f p)", "by auto"], ["proof (state)\nthis:\n  push_forward\n  \\<in> src.tangent_space p \\<rightarrow> dest.tangent_space (f p)\n\ngoal (3 subgoals):\n 1. inv.push_forward\n    \\<in> dest.tangent_space (f p) \\<rightarrow> src.tangent_space p\n 2. \\<And>x.\n       x \\<in> src.tangent_space p \\<Longrightarrow>\n       inv.push_forward (push_forward x) = x\n 3. \\<And>y.\n       y \\<in> dest.tangent_space (f p) \\<Longrightarrow>\n       push_forward (inv.push_forward y) = y", "show \"inv.push_forward \\<in> dest.tangent_space (f p) \\<rightarrow> src.tangent_space p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv.push_forward\n    \\<in> dest.tangent_space (f p) \\<rightarrow> src.tangent_space p", "using inv.push_forward_in_tangent_space[of \"f p\"] that defined"], ["proof (prove)\nusing this:\n  f p \\<in> dest.carrier \\<Longrightarrow>\n  inv.push_forward ` dest.tangent_space (f p)\n  \\<subseteq> src.tangent_space (f' (f p))\n  p \\<in> src.carrier\n  f ` src.carrier \\<subseteq> dest.carrier\n\ngoal (1 subgoal):\n 1. inv.push_forward\n    \\<in> dest.tangent_space (f p) \\<rightarrow> src.tangent_space p", "by auto"], ["proof (state)\nthis:\n  inv.push_forward\n  \\<in> dest.tangent_space (f p) \\<rightarrow> src.tangent_space p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> src.tangent_space p \\<Longrightarrow>\n       inv.push_forward (push_forward x) = x\n 2. \\<And>y.\n       y \\<in> dest.tangent_space (f p) \\<Longrightarrow>\n       push_forward (inv.push_forward y) = y", "show \"inv.push_forward (push_forward x) = x\" if \"x \\<in> src.tangent_space p\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv.push_forward (push_forward x) = x", "by (rule push_forward_inverse[OF that p])"], ["proof (state)\nthis:\n  ?x3 \\<in> src.tangent_space p \\<Longrightarrow>\n  inv.push_forward (push_forward ?x3) = ?x3\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> dest.tangent_space (f p) \\<Longrightarrow>\n       push_forward (inv.push_forward y) = y", "show \"push_forward (inv.push_forward y) = y\" if \"y \\<in> dest.tangent_space (f p)\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_forward (inv.push_forward y) = y", "apply (rule inv_push_forward_inverse[OF that])"], ["proof (prove)\ngoal (1 subgoal):\n 1. f p \\<in> dest.carrier", "using defined p"], ["proof (prove)\nusing this:\n  f ` src.carrier \\<subseteq> dest.carrier\n  p \\<in> src.carrier\n\ngoal (1 subgoal):\n 1. f p \\<in> dest.carrier", "by auto"], ["proof (state)\nthis:\n  ?y3 \\<in> dest.tangent_space (f p) \\<Longrightarrow>\n  push_forward (inv.push_forward ?y3) = ?y3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dim_tangent_space_src_dest_eq: \"dim (src.tangent_space p) = dim (dest.tangent_space (f p))\"\n  if p: \"p \\<in> src.carrier\" and \"dim (dest.tangent_space (f p)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "from dest.tangent_space.dim_pos_finite_dimensional_vector_spaceE[\n      unfolded dest.tangent_space_dim_eq[OF order_refl],\n      OF that(2)]"], ["proof (chain)\npicking this:\n  (\\<And>basis.\n      \\<lbrakk>basis \\<subseteq> dest.tangent_space (f p);\n       finite_dimensional_vector_space_on_with (dest.tangent_space (f p))\n        (+) (-) uminus 0 (*\\<^sub>R) basis\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain basis where \"basis \\<subseteq> dest.tangent_space (f p)\"\n    \"finite_dimensional_vector_space_on_with (dest.tangent_space (f p)) (+) (-) uminus 0 (*\\<^sub>R) basis\""], ["proof (prove)\nusing this:\n  (\\<And>basis.\n      \\<lbrakk>basis \\<subseteq> dest.tangent_space (f p);\n       finite_dimensional_vector_space_on_with (dest.tangent_space (f p))\n        (+) (-) uminus 0 (*\\<^sub>R) basis\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>basis.\n        \\<lbrakk>basis \\<subseteq> dest.tangent_space (f p);\n         finite_dimensional_vector_space_on_with (dest.tangent_space (f p))\n          (+) (-) uminus 0 (*\\<^sub>R) basis\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  basis \\<subseteq> dest.tangent_space (f p)\n  finite_dimensional_vector_space_on_with (dest.tangent_space (f p)) (+) (-)\n   uminus 0 (*\\<^sub>R) basis\n\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "then"], ["proof (chain)\npicking this:\n  basis \\<subseteq> dest.tangent_space (f p)\n  finite_dimensional_vector_space_on_with (dest.tangent_space (f p)) (+) (-)\n   uminus 0 (*\\<^sub>R) basis", "interpret finite_dimensional_vector_space_on \"(dest.tangent_space (f p))\" scaleR basis"], ["proof (prove)\nusing this:\n  basis \\<subseteq> dest.tangent_space (f p)\n  finite_dimensional_vector_space_on_with (dest.tangent_space (f p)) (+) (-)\n   uminus 0 (*\\<^sub>R) basis\n\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space_on (dest.tangent_space (f p))\n     (*\\<^sub>R) basis", "unfolding finite_dimensional_vector_space_on_with_def"], ["proof (prove)\nusing this:\n  basis \\<subseteq> dest.tangent_space (f p)\n  vector_space_on_with (dest.tangent_space (f p)) (+) (-) uminus 0\n   (*\\<^sub>R) \\<and>\n  finite basis \\<and>\n  \\<not> dependent_with (+) 0 (*\\<^sub>R) basis \\<and>\n  span_with (+) 0 (*\\<^sub>R) basis = dest.tangent_space (f p)\n\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space_on (dest.tangent_space (f p))\n     (*\\<^sub>R) basis", "by unfold_locales\n      (auto simp: implicit_ab_group_add dest.tangent_space.dependent_eq_real dest.tangent_space.span_eq_real)"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "interpret rev: finite_dimensional_vector_space_pair_1_on\n     \"dest.tangent_space (f p)\" \"src.tangent_space p\" scaleR scaleR basis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space_pair_1_on (dest.tangent_space (f p))\n     (src.tangent_space p) (*\\<^sub>R) (*\\<^sub>R) basis", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "from bij_betw_push_forward[OF p]"], ["proof (chain)\npicking this:\n  bij_betw push_forward (src.tangent_space p) (dest.tangent_space (f p))", "have \"inj_on push_forward (src.tangent_space p)\"\n    \"dest.tangent_space (f p) = push_forward ` src.tangent_space p\""], ["proof (prove)\nusing this:\n  bij_betw push_forward (src.tangent_space p) (dest.tangent_space (f p))\n\ngoal (1 subgoal):\n 1. inj_on push_forward (src.tangent_space p) &&&\n    dest.tangent_space (f p) = push_forward ` src.tangent_space p", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj_on push_forward (src.tangent_space p) \\<and>\n  push_forward ` src.tangent_space p = dest.tangent_space (f p)\n\ngoal (1 subgoal):\n 1. inj_on push_forward (src.tangent_space p) &&&\n    dest.tangent_space (f p) = push_forward ` src.tangent_space p", "by auto"], ["proof (state)\nthis:\n  inj_on push_forward (src.tangent_space p)\n  dest.tangent_space (f p) = push_forward ` src.tangent_space p\n\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "have \"dim (dest.tangent_space (f p)) = src.tangent_space.dim p (inv.push_forward ` dest.tangent_space (f p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (dest.tangent_space (f p)) =\n    src.tangent_space.dim p (inv.push_forward ` dest.tangent_space (f p))", "apply (rule rev.dim_image_eq[OF _ order_refl, of inv.push_forward, symmetric,\n        unfolded dest.tangent_space_dim_eq[OF order_refl]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x.\n       x \\<in> dest.tangent_space (f p) \\<longrightarrow>\n       inv.push_forward x \\<in> src.tangent_space p\n 2. linear_on (dest.tangent_space (f p)) (src.tangent_space p) (*\\<^sub>R)\n     (*\\<^sub>R) inv.push_forward\n 3. inj_on inv.push_forward\n     (module_on.span (*\\<^sub>R) (dest.tangent_space (f p)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> dest.tangent_space (f p) \\<longrightarrow>\n       inv.push_forward x \\<in> src.tangent_space p", "by (metis (no_types) contra_subsetD defined f_inv image_eqI inv.push_forward_in_tangent_space p)"], ["proof (prove)\ngoal (2 subgoals):\n 1. linear_on (dest.tangent_space (f p)) (src.tangent_space p) (*\\<^sub>R)\n     (*\\<^sub>R) inv.push_forward\n 2. inj_on inv.push_forward\n     (module_on.span (*\\<^sub>R) (dest.tangent_space (f p)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_on (dest.tangent_space (f p)) (src.tangent_space p) (*\\<^sub>R)\n     (*\\<^sub>R) inv.push_forward", "apply (rule linear_imp_linear_on)"], ["proof (prove)\ngoal (3 subgoals):\n 1. linear inv.push_forward\n 2. subspace (dest.tangent_space (f p))\n 3. subspace (src.tangent_space p)", "apply (rule inv.linear_push_forward)"], ["proof (prove)\ngoal (2 subgoals):\n 1. subspace (dest.tangent_space (f p))\n 2. subspace (src.tangent_space p)", "apply (rule dest.subspace_tangent_space)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace (src.tangent_space p)", "apply (rule src.subspace_tangent_space)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on inv.push_forward\n     (module_on.span (*\\<^sub>R) (dest.tangent_space (f p)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on inv.push_forward\n     (module_on.span (*\\<^sub>R) (dest.tangent_space (f p)))", "unfolding inj_on_def dest.tangent_space.span_eq_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>span (dest.tangent_space (f p)).\n       \\<forall>y\\<in>span (dest.tangent_space (f p)).\n          inv.push_forward x = inv.push_forward y \\<longrightarrow> x = y", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> span (dest.tangent_space (f p));\n        y \\<in> span (dest.tangent_space (f p));\n        inv.push_forward x = inv.push_forward y\\<rbrakk>\n       \\<Longrightarrow> x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> span (dest.tangent_space (f p));\n        y \\<in> span (dest.tangent_space (f p));\n        inv.push_forward x = inv.push_forward y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x :: \"('c \\<Rightarrow> real) \\<Rightarrow> real\" and y :: \"('c \\<Rightarrow> real) \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> span (dest.tangent_space (f p));\n        y \\<in> span (dest.tangent_space (f p));\n        inv.push_forward x = inv.push_forward y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume a1: \"y \\<in> span (dest.tangent_space (f p))\""], ["proof (state)\nthis:\n  y \\<in> span (dest.tangent_space (f p))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> span (dest.tangent_space (f p));\n        y \\<in> span (dest.tangent_space (f p));\n        inv.push_forward x = inv.push_forward y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume a2: \"x \\<in> span (dest.tangent_space (f p))\""], ["proof (state)\nthis:\n  x \\<in> span (dest.tangent_space (f p))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> span (dest.tangent_space (f p));\n        y \\<in> span (dest.tangent_space (f p));\n        inv.push_forward x = inv.push_forward y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume a3: \"inv.push_forward x = inv.push_forward y\""], ["proof (state)\nthis:\n  inv.push_forward x = inv.push_forward y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> span (dest.tangent_space (f p));\n        y \\<in> span (dest.tangent_space (f p));\n        inv.push_forward x = inv.push_forward y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"f p \\<in> dest.carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f p \\<in> dest.carrier", "by (meson contra_subsetD defined image_eqI p)"], ["proof (state)\nthis:\n  f p \\<in> dest.carrier\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> span (dest.tangent_space (f p));\n        y \\<in> span (dest.tangent_space (f p));\n        inv.push_forward x = inv.push_forward y\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  f p \\<in> dest.carrier", "show \"x = y\""], ["proof (prove)\nusing this:\n  f p \\<in> dest.carrier\n\ngoal (1 subgoal):\n 1. x = y", "using a3 a2 a1"], ["proof (prove)\nusing this:\n  f p \\<in> dest.carrier\n  inv.push_forward x = inv.push_forward y\n  x \\<in> span (dest.tangent_space (f p))\n  y \\<in> span (dest.tangent_space (f p))\n\ngoal (1 subgoal):\n 1. x = y", "by (metis (no_types) c_manifold.subspace_tangent_space c_manifolds_axioms c_manifolds_def inv_push_forward_inverse span_eq_iff)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dim (dest.tangent_space (f p)) =\n  src.tangent_space.dim p (inv.push_forward ` dest.tangent_space (f p))\n\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "also"], ["proof (state)\nthis:\n  dim (dest.tangent_space (f p)) =\n  src.tangent_space.dim p (inv.push_forward ` dest.tangent_space (f p))\n\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "have \"f p \\<in> dest.carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f p \\<in> dest.carrier", "using defined p"], ["proof (prove)\nusing this:\n  f ` src.carrier \\<subseteq> dest.carrier\n  p \\<in> src.carrier\n\ngoal (1 subgoal):\n 1. f p \\<in> dest.carrier", "by auto"], ["proof (state)\nthis:\n  f p \\<in> dest.carrier\n\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "then"], ["proof (chain)\npicking this:\n  f p \\<in> dest.carrier", "have \"inv.push_forward ` dest.tangent_space (f p) = src.tangent_space p\""], ["proof (prove)\nusing this:\n  f p \\<in> dest.carrier\n\ngoal (1 subgoal):\n 1. inv.push_forward ` dest.tangent_space (f p) = src.tangent_space p", "using inv.push_forward_in_tangent_space[of \"f p\"] that(1)"], ["proof (prove)\nusing this:\n  f p \\<in> dest.carrier\n  f p \\<in> dest.carrier \\<Longrightarrow>\n  inv.push_forward ` dest.tangent_space (f p)\n  \\<subseteq> src.tangent_space (f' (f p))\n  p \\<in> src.carrier\n\ngoal (1 subgoal):\n 1. inv.push_forward ` dest.tangent_space (f p) = src.tangent_space p", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>f p \\<in> dest.carrier;\n        inv.push_forward ` dest.tangent_space (f p)\n        \\<subseteq> src.tangent_space p;\n        p \\<in> src.carrier; x \\<in> src.tangent_space p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> inv.push_forward ` dest.tangent_space (f p)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f p \\<in> dest.carrier;\n     inv.push_forward ` dest.tangent_space (f p)\n     \\<subseteq> src.tangent_space p;\n     p \\<in> src.carrier; x \\<in> src.tangent_space p\\<rbrakk>\n    \\<Longrightarrow> x \\<in> inv.push_forward ` dest.tangent_space (f p)", "apply (rule image_eqI[where x=\"push_forward x\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>f p \\<in> dest.carrier;\n     inv.push_forward ` dest.tangent_space (f p)\n     \\<subseteq> src.tangent_space p;\n     p \\<in> src.carrier; x \\<in> src.tangent_space p\\<rbrakk>\n    \\<Longrightarrow> x = inv.push_forward (push_forward x)\n 2. \\<lbrakk>f p \\<in> dest.carrier;\n     inv.push_forward ` dest.tangent_space (f p)\n     \\<subseteq> src.tangent_space p;\n     p \\<in> src.carrier; x \\<in> src.tangent_space p\\<rbrakk>\n    \\<Longrightarrow> push_forward x \\<in> dest.tangent_space (f p)", "apply (auto simp: push_forward_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f p \\<in> dest.carrier;\n     inv.push_forward ` dest.tangent_space (f p)\n     \\<subseteq> src.tangent_space p;\n     p \\<in> src.carrier; x \\<in> src.tangent_space p\\<rbrakk>\n    \\<Longrightarrow> push_forward x \\<in> dest.tangent_space (f p)", "using \\<open>dest.tangent_space (f p) = push_forward ` src.tangent_space p\\<close>"], ["proof (prove)\nusing this:\n  dest.tangent_space (f p) = push_forward ` src.tangent_space p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f p \\<in> dest.carrier;\n     inv.push_forward ` dest.tangent_space (f p)\n     \\<subseteq> src.tangent_space p;\n     p \\<in> src.carrier; x \\<in> src.tangent_space p\\<rbrakk>\n    \\<Longrightarrow> push_forward x \\<in> dest.tangent_space (f p)", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inv.push_forward ` dest.tangent_space (f p) = src.tangent_space p\n\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "also"], ["proof (state)\nthis:\n  inv.push_forward ` dest.tangent_space (f p) = src.tangent_space p\n\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "have \"src.tangent_space.dim p \\<dots> = dim \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. src.tangent_space.dim p (src.tangent_space p) =\n    dim (src.tangent_space p)", "by (rule src.tangent_space_dim_eq) simp"], ["proof (state)\nthis:\n  src.tangent_space.dim p (src.tangent_space p) = dim (src.tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "finally"], ["proof (chain)\npicking this:\n  dim (dest.tangent_space (f p)) = dim (src.tangent_space p)", "show ?thesis"], ["proof (prove)\nusing this:\n  dim (dest.tangent_space (f p)) = dim (src.tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", ".."], ["proof (state)\nthis:\n  dim (src.tangent_space p) = dim (dest.tangent_space (f p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dim_tangent_space_src_dest_eq2: \"dim (src.tangent_space p) = dim (dest.tangent_space (f p))\"\n  if p: \"p \\<in> src.carrier\" and \"dim (src.tangent_space p) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "interpret rev: diffeomorphism k charts2 charts1 f' f"], ["proof (prove)\ngoal (1 subgoal):\n 1. Differentiable_Manifold.diffeomorphism k charts2 charts1 f' f", "by unfold_locales (auto simp: )"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "from that rev.dim_tangent_space_src_dest_eq[of \"f p\"]"], ["proof (chain)\npicking this:\n  p \\<in> src.carrier\n  0 < dim (src.tangent_space p)\n  \\<lbrakk>f p \\<in> dest.carrier;\n   0 < dim (src.tangent_space (f' (f p)))\\<rbrakk>\n  \\<Longrightarrow> dim (dest.tangent_space (f p)) =\n                    dim (src.tangent_space (f' (f p)))", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in> src.carrier\n  0 < dim (src.tangent_space p)\n  \\<lbrakk>f p \\<in> dest.carrier;\n   0 < dim (src.tangent_space (f' (f p)))\\<rbrakk>\n  \\<Longrightarrow> dim (dest.tangent_space (f p)) =\n                    dim (src.tangent_space (f' (f p)))\n\ngoal (1 subgoal):\n 1. dim (src.tangent_space p) = dim (dest.tangent_space (f p))", "by auto (metis contra_subsetD defined image_eqI)"], ["proof (state)\nthis:\n  dim (src.tangent_space p) = dim (dest.tangent_space (f p))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Smooth inclusion map\\<close>"], ["", "context submanifold begin"], ["", "lemma diff_inclusion: \"diff k (charts_submanifold S) charts (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff k (charts_submanifold S) charts (\\<lambda>x. x)", "using diff_id"], ["proof (prove)\nusing this:\n  diff k charts charts (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. diff k (charts_submanifold S) charts (\\<lambda>x. x)", "apply (rule diff.diff_submanifold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. open S", "unfolding charts_submanifold_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. open S", "using open_submanifold"], ["proof (prove)\nusing this:\n  open S\n\ngoal (1 subgoal):\n 1. open S", "by auto"], ["", "sublocale inclusion: diff k \"charts_submanifold S\" charts \"\\<lambda>x. x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff k (charts_submanifold S) charts (\\<lambda>x. x)", "by (rule diff_inclusion)"], ["", "lemma linear_on_push_forward_inclusion:\n  \"linear_on (sub.tangent_space p) (tangent_space p) scaleR scaleR inclusion.push_forward\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_on (sub.tangent_space p) (tangent_space p) (*\\<^sub>R)\n     (*\\<^sub>R) inclusion.push_forward", "apply (rule linear_imp_linear_on)"], ["proof (prove)\ngoal (3 subgoals):\n 1. linear inclusion.push_forward\n 2. subspace (sub.tangent_space p)\n 3. subspace (tangent_space p)", "apply (rule inclusion.linear_push_forward)"], ["proof (prove)\ngoal (2 subgoals):\n 1. subspace (sub.tangent_space p)\n 2. subspace (tangent_space p)", "apply (rule sub.subspace_tangent_space)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace (tangent_space p)", "apply (rule subspace_tangent_space)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Extension lemma: given a differentiable function on \\<open>S\\<close>, and a closed set \\<open>B \\<subseteq> S\\<close>,\n   there exists a function \\<open>f'\\<close> agreeing with \\<open>f\\<close> on \\<open>B\\<close>, such that the support\n   of \\<open>f'\\<close> is contained in \\<open>S.\\<close>\\<close>"], ["", "lemma extension_lemma_submanifoldE:\n  fixes f::\"'a\\<Rightarrow>'e::euclidean_space\"\n  assumes f: \"diff_fun k (charts_submanifold S) f\"\n    and B: \"closed B\" \"B \\<subseteq> sub.carrier\"\n  obtains f' where\n    \"diff_fun k charts f'\"\n    \"(\\<And>x. x \\<in> B \\<Longrightarrow> f' x = f x)\"\n    \"csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>diff_fun k charts f';\n         \\<And>x. x \\<in> B \\<Longrightarrow> f' x = f x;\n         csupport_on carrier f' \\<inter> carrier\n         \\<subseteq> sub.carrier\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>diff_fun k charts f';\n         \\<And>x. x \\<in> B \\<Longrightarrow> f' x = f x;\n         csupport_on carrier f' \\<inter> carrier\n         \\<subseteq> sub.carrier\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 1: \"closedin (top_of_set carrier) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closedin (top_of_set carrier) B", "using B"], ["proof (prove)\nusing this:\n  closed B\n  B \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. closedin (top_of_set carrier) B", "by (auto intro!: closed_subset)"], ["proof (state)\nthis:\n  closedin (top_of_set carrier) B\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>diff_fun k charts f';\n         \\<And>x. x \\<in> B \\<Longrightarrow> f' x = f x;\n         csupport_on carrier f' \\<inter> carrier\n         \\<subseteq> sub.carrier\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 2: \"diff_fun_on B f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff_fun_on B f", "proof (rule diff_fun_onI)"], ["proof (state)\ngoal (5 subgoals):\n 1. B \\<subseteq> ?W\n 2. ?W \\<subseteq> carrier\n 3. open ?W\n 4. diff_fun k (charts_submanifold ?W) ?f'\n 5. \\<And>x. x \\<in> B \\<Longrightarrow> f x = ?f' x", "show \"B \\<subseteq> sub.carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> sub.carrier", "by fact"], ["proof (state)\nthis:\n  B \\<subseteq> sub.carrier\n\ngoal (4 subgoals):\n 1. sub.carrier \\<subseteq> carrier\n 2. open sub.carrier\n 3. diff_fun k (charts_submanifold sub.carrier) ?f'\n 4. \\<And>x. x \\<in> B \\<Longrightarrow> f x = ?f' x", "show \"sub.carrier \\<subseteq> carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub.carrier \\<subseteq> carrier", "by auto"], ["proof (state)\nthis:\n  sub.carrier \\<subseteq> carrier\n\ngoal (3 subgoals):\n 1. open sub.carrier\n 2. diff_fun k (charts_submanifold sub.carrier) ?f'\n 3. \\<And>x. x \\<in> B \\<Longrightarrow> f x = ?f' x", "show \"open sub.carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open sub.carrier", "using open_submanifold"], ["proof (prove)\nusing this:\n  open S\n\ngoal (1 subgoal):\n 1. open sub.carrier", "by auto"], ["proof (state)\nthis:\n  open sub.carrier\n\ngoal (2 subgoals):\n 1. diff_fun k (charts_submanifold sub.carrier) ?f'\n 2. \\<And>x. x \\<in> B \\<Longrightarrow> f x = ?f' x", "have *: \"charts_submanifold sub.carrier = charts_submanifold S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. charts_submanifold sub.carrier = charts_submanifold S", "unfolding carrier_submanifold charts_submanifold_Int_carrier"], ["proof (prove)\ngoal (1 subgoal):\n 1. charts_submanifold S = charts_submanifold S", ".."], ["proof (state)\nthis:\n  charts_submanifold sub.carrier = charts_submanifold S\n\ngoal (2 subgoals):\n 1. diff_fun k (charts_submanifold sub.carrier) ?f'\n 2. \\<And>x. x \\<in> B \\<Longrightarrow> f x = ?f' x", "from f"], ["proof (chain)\npicking this:\n  diff_fun k (charts_submanifold S) f", "show \"diff_fun k (charts_submanifold sub.carrier) f\""], ["proof (prove)\nusing this:\n  diff_fun k (charts_submanifold S) f\n\ngoal (1 subgoal):\n 1. diff_fun k (charts_submanifold sub.carrier) f", "unfolding *"], ["proof (prove)\nusing this:\n  diff_fun k (charts_submanifold S) f\n\ngoal (1 subgoal):\n 1. diff_fun k (charts_submanifold S) f", "."], ["proof (state)\nthis:\n  diff_fun k (charts_submanifold sub.carrier) f\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> B \\<Longrightarrow> f x = f x", "qed simp"], ["proof (state)\nthis:\n  diff_fun_on B f\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>diff_fun k charts f';\n         \\<And>x. x \\<in> B \\<Longrightarrow> f' x = f x;\n         csupport_on carrier f' \\<inter> carrier\n         \\<subseteq> sub.carrier\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from extension_lemmaE[OF 1 2 \\<open>B \\<subseteq> sub.carrier\\<close>] open_submanifold"], ["proof (chain)\npicking this:\n  \\<lbrakk>sub.carrier \\<subseteq> carrier; open sub.carrier;\n   \\<And>f'.\n      \\<lbrakk>diff_fun k charts f';\n       \\<And>x. x \\<in> B \\<Longrightarrow> f' x = f x;\n       csupport_on carrier f' \\<inter> carrier\n       \\<subseteq> sub.carrier\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  open S", "obtain f' where f': \"diff_fun k charts f'\" \"(\\<And>x. x \\<in> B \\<Longrightarrow> f' x = f x)\"\n    \"csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sub.carrier \\<subseteq> carrier; open sub.carrier;\n   \\<And>f'.\n      \\<lbrakk>diff_fun k charts f';\n       \\<And>x. x \\<in> B \\<Longrightarrow> f' x = f x;\n       csupport_on carrier f' \\<inter> carrier\n       \\<subseteq> sub.carrier\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  open S\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>diff_fun k charts f';\n         \\<And>x. x \\<in> B \\<Longrightarrow> f' x = f x;\n         csupport_on carrier f' \\<inter> carrier\n         \\<subseteq> sub.carrier\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  diff_fun k charts f'\n  ?x3 \\<in> B \\<Longrightarrow> f' ?x3 = f ?x3\n  csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>diff_fun k charts f';\n         \\<And>x. x \\<in> B \\<Longrightarrow> f' x = f x;\n         csupport_on carrier f' \\<inter> carrier\n         \\<subseteq> sub.carrier\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  diff_fun k charts f'\n  ?x3 \\<in> B \\<Longrightarrow> f' ?x3 = f ?x3\n  csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier", "show ?thesis"], ["proof (prove)\nusing this:\n  diff_fun k charts f'\n  ?x3 \\<in> B \\<Longrightarrow> f' ?x3 = f ?x3\n  csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_push_forward_inclusion: \"inj_on inclusion.push_forward (sub.tangent_space p)\"\n  if p: \"p \\<in> sub.carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on inclusion.push_forward (sub.tangent_space p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on inclusion.push_forward (sub.tangent_space p)", "interpret sub: vector_space_pair_on \"sub.tangent_space p\" \"tangent_space p\" scaleR scaleR"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_space_pair_on (sub.tangent_space p) (tangent_space p) (*\\<^sub>R)\n     (*\\<^sub>R)", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on inclusion.push_forward (sub.tangent_space p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on inclusion.push_forward (sub.tangent_space p)", "proof (subst sub.linear_inj_iff_eq_0[OF _ linear_on_push_forward_inclusion], safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sub.tangent_space p \\<Longrightarrow>\n       inclusion.push_forward x \\<in> tangent_space p\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> sub.tangent_space p;\n        inclusion.push_forward x = 0\\<rbrakk>\n       \\<Longrightarrow> x = 0", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sub.tangent_space p \\<Longrightarrow>\n       inclusion.push_forward x \\<in> tangent_space p\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> sub.tangent_space p;\n        inclusion.push_forward x = 0\\<rbrakk>\n       \\<Longrightarrow> x = 0", "assume v: \"v \\<in> sub.tangent_space p\""], ["proof (state)\nthis:\n  v \\<in> sub.tangent_space p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> sub.tangent_space p \\<Longrightarrow>\n       inclusion.push_forward x \\<in> tangent_space p\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> sub.tangent_space p;\n        inclusion.push_forward x = 0\\<rbrakk>\n       \\<Longrightarrow> x = 0", "then"], ["proof (chain)\npicking this:\n  v \\<in> sub.tangent_space p", "show \"inclusion.push_forward v \\<in> tangent_space p\""], ["proof (prove)\nusing this:\n  v \\<in> sub.tangent_space p\n\ngoal (1 subgoal):\n 1. inclusion.push_forward v \\<in> tangent_space p", "using inclusion.push_forward_in_tangent_space[OF p]"], ["proof (prove)\nusing this:\n  v \\<in> sub.tangent_space p\n  inclusion.push_forward ` sub.tangent_space p \\<subseteq> tangent_space p\n\ngoal (1 subgoal):\n 1. inclusion.push_forward v \\<in> tangent_space p", "by auto"], ["proof (state)\nthis:\n  inclusion.push_forward v \\<in> tangent_space p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> sub.tangent_space p;\n        inclusion.push_forward x = 0\\<rbrakk>\n       \\<Longrightarrow> x = 0", "assume dv: \"inclusion.push_forward v = 0\""], ["proof (state)\nthis:\n  inclusion.push_forward v = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> sub.tangent_space p;\n        inclusion.push_forward x = 0\\<rbrakk>\n       \\<Longrightarrow> x = 0", "have \"extensional0 sub.diff_fun_space v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extensional0 sub.diff_fun_space v", "using v[THEN sub.tangent_space_restrict]"], ["proof (prove)\nusing this:\n  extensional0 sub.diff_fun_space v\n\ngoal (1 subgoal):\n 1. extensional0 sub.diff_fun_space v", "."], ["proof (state)\nthis:\n  extensional0 sub.diff_fun_space v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> sub.tangent_space p;\n        inclusion.push_forward x = 0\\<rbrakk>\n       \\<Longrightarrow> x = 0", "then"], ["proof (chain)\npicking this:\n  extensional0 sub.diff_fun_space v", "show \"v = 0\""], ["proof (prove)\nusing this:\n  extensional0 sub.diff_fun_space v\n\ngoal (1 subgoal):\n 1. v = 0", "proof (rule ext_extensional0)"], ["proof (state)\ngoal (2 subgoals):\n 1. extensional0 sub.diff_fun_space 0\n 2. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "show \"extensional0 sub.diff_fun_space (0:: ('a \\<Rightarrow> real) \\<Rightarrow> real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extensional0 sub.diff_fun_space 0", "by auto"], ["proof (state)\nthis:\n  extensional0 sub.diff_fun_space 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "assume f: \"f \\<in> sub.diff_fun_space\""], ["proof (state)\nthis:\n  f \\<in> sub.diff_fun_space\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "from sub.precompact_neighborhoodE[OF p]"], ["proof (chain)\npicking this:\n  (\\<And>C.\n      \\<lbrakk>p \\<in> C; open C; compact (closure C);\n       closure C \\<subseteq> sub.carrier\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain B where B: \"p \\<in> B\" \"open B\" \"compact (closure B)\" \"closure B \\<subseteq> sub.carrier\""], ["proof (prove)\nusing this:\n  (\\<And>C.\n      \\<lbrakk>p \\<in> C; open C; compact (closure C);\n       closure C \\<subseteq> sub.carrier\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>p \\<in> B; open B; compact (closure B);\n         closure B \\<subseteq> sub.carrier\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  p \\<in> B\n  open B\n  compact (closure B)\n  closure B \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "with extension_lemma_submanifoldE[of f \"closure B\", OF sub.diff_fun_spaceD[OF f]]"], ["proof (chain)\npicking this:\n  \\<lbrakk>closed (closure B); closure B \\<subseteq> sub.carrier;\n   \\<And>f'.\n      \\<lbrakk>diff_fun k charts f';\n       \\<And>x. x \\<in> closure B \\<Longrightarrow> f' x = f x;\n       csupport_on carrier f' \\<inter> carrier\n       \\<subseteq> sub.carrier\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  p \\<in> B\n  open B\n  compact (closure B)\n  closure B \\<subseteq> sub.carrier", "obtain f' where f': \"diff_fun k charts f'\"\n        \"(\\<And>x. x \\<in> closure B \\<Longrightarrow> f' x = f x)\"\n        \"csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\""], ["proof (prove)\nusing this:\n  \\<lbrakk>closed (closure B); closure B \\<subseteq> sub.carrier;\n   \\<And>f'.\n      \\<lbrakk>diff_fun k charts f';\n       \\<And>x. x \\<in> closure B \\<Longrightarrow> f' x = f x;\n       csupport_on carrier f' \\<inter> carrier\n       \\<subseteq> sub.carrier\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  p \\<in> B\n  open B\n  compact (closure B)\n  closure B \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>diff_fun k charts f';\n         \\<And>x. x \\<in> closure B \\<Longrightarrow> f' x = f x;\n         csupport_on carrier f' \\<inter> carrier\n         \\<subseteq> sub.carrier\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  diff_fun k charts f'\n  ?x3 \\<in> closure B \\<Longrightarrow> f' ?x3 = f ?x3\n  csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "have rf': \"restrict0 sub.carrier f' \\<in> sub.diff_fun_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 sub.carrier f' \\<in> sub.diff_fun_space", "apply (rule sub.restrict0_in_fun_space)"], ["proof (prove)\ngoal (1 subgoal):\n 1. diff_fun k (charts_submanifold S) f'", "apply (rule diff_fun.diff_fun_submanifold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. diff_fun k charts f'\n 2. open S", "apply (rule f')"], ["proof (prove)\ngoal (1 subgoal):\n 1. open S", "apply (rule open_submanifold)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  restrict0 sub.carrier f' \\<in> sub.diff_fun_space\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "have supp_f': \"support_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. support_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier", "using f'(3)"], ["proof (prove)\nusing this:\n  csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. support_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier", "by (auto simp: csupport_on_def)"], ["proof (state)\nthis:\n  support_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "from f'(1)"], ["proof (chain)\npicking this:\n  diff_fun k charts f'", "have df': \"diff_fun k charts (restrict0 sub.carrier f')\""], ["proof (prove)\nusing this:\n  diff_fun k charts f'\n\ngoal (1 subgoal):\n 1. diff_fun k charts (restrict0 sub.carrier f')", "apply (rule diff_fun.diff_fun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<Longrightarrow> f' x = restrict0 sub.carrier f' x", "using supp_f'"], ["proof (prove)\nusing this:\n  support_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<Longrightarrow> f' x = restrict0 sub.carrier f' x", "by (auto simp: restrict0_def support_on_def)"], ["proof (state)\nthis:\n  diff_fun k charts (restrict0 sub.carrier f')\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "have rf'_diff_fun: \"restrict0 sub.carrier f' \\<in> diff_fun_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 sub.carrier f' \\<in> diff_fun_space", "using f' df'"], ["proof (prove)\nusing this:\n  diff_fun k charts f'\n  ?x3 \\<in> closure B \\<Longrightarrow> f' ?x3 = f ?x3\n  csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\n  diff_fun k charts (restrict0 sub.carrier f')\n\ngoal (1 subgoal):\n 1. restrict0 sub.carrier f' \\<in> diff_fun_space", "by (auto simp: diff_fun_space_def extensional0_def)"], ["proof (state)\nthis:\n  restrict0 sub.carrier f' \\<in> diff_fun_space\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "have \"v f = v (restrict0 sub.carrier f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v f = v (restrict0 sub.carrier f')", "apply (rule sub.derivation_eq_localI[where X=v and U=\"B\" and p=p])"], ["proof (prove)\ngoal (7 subgoals):\n 1. open B\n 2. p \\<in> B\n 3. B \\<subseteq> sub.carrier\n 4. v \\<in> sub.tangent_space p\n 5. f \\<in> sub.diff_fun_space\n 6. restrict0 sub.carrier f' \\<in> sub.diff_fun_space\n 7. \\<And>x. x \\<in> B \\<Longrightarrow> f x = restrict0 sub.carrier f' x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. open B", "by (rule B)"], ["proof (prove)\ngoal (6 subgoals):\n 1. p \\<in> B\n 2. B \\<subseteq> sub.carrier\n 3. v \\<in> sub.tangent_space p\n 4. f \\<in> sub.diff_fun_space\n 5. restrict0 sub.carrier f' \\<in> sub.diff_fun_space\n 6. \\<And>x. x \\<in> B \\<Longrightarrow> f x = restrict0 sub.carrier f' x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> B", "by (rule B)"], ["proof (prove)\ngoal (5 subgoals):\n 1. B \\<subseteq> sub.carrier\n 2. v \\<in> sub.tangent_space p\n 3. f \\<in> sub.diff_fun_space\n 4. restrict0 sub.carrier f' \\<in> sub.diff_fun_space\n 5. \\<And>x. x \\<in> B \\<Longrightarrow> f x = restrict0 sub.carrier f' x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<subseteq> sub.carrier", "using B"], ["proof (prove)\nusing this:\n  p \\<in> B\n  open B\n  compact (closure B)\n  closure B \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. B \\<subseteq> sub.carrier", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. v \\<in> sub.tangent_space p\n 2. f \\<in> sub.diff_fun_space\n 3. restrict0 sub.carrier f' \\<in> sub.diff_fun_space\n 4. \\<And>x. x \\<in> B \\<Longrightarrow> f x = restrict0 sub.carrier f' x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> sub.tangent_space p", "by (rule v)"], ["proof (prove)\ngoal (3 subgoals):\n 1. f \\<in> sub.diff_fun_space\n 2. restrict0 sub.carrier f' \\<in> sub.diff_fun_space\n 3. \\<And>x. x \\<in> B \\<Longrightarrow> f x = restrict0 sub.carrier f' x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> sub.diff_fun_space", "by (rule f)"], ["proof (prove)\ngoal (2 subgoals):\n 1. restrict0 sub.carrier f' \\<in> sub.diff_fun_space\n 2. \\<And>x. x \\<in> B \\<Longrightarrow> f x = restrict0 sub.carrier f' x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 sub.carrier f' \\<in> sub.diff_fun_space", "by (rule rf')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> B \\<Longrightarrow> f x = restrict0 sub.carrier f' x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> B \\<Longrightarrow> f x_ = restrict0 sub.carrier f' x_", "using f' B"], ["proof (prove)\nusing this:\n  diff_fun k charts f'\n  ?x3 \\<in> closure B \\<Longrightarrow> f' ?x3 = f ?x3\n  csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\n  p \\<in> B\n  open B\n  compact (closure B)\n  closure B \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. x_ \\<in> B \\<Longrightarrow> f x_ = restrict0 sub.carrier f' x_", "by (auto simp: restrict0_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  v f = v (restrict0 sub.carrier f')\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "also"], ["proof (state)\nthis:\n  v f = v (restrict0 sub.carrier f')\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "have \"\\<dots> = inclusion.push_forward v (restrict0 sub.carrier f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v (restrict0 sub.carrier f') =\n    inclusion.push_forward v (restrict0 sub.carrier f')", "using rf' rf'_diff_fun"], ["proof (prove)\nusing this:\n  restrict0 sub.carrier f' \\<in> sub.diff_fun_space\n  restrict0 sub.carrier f' \\<in> diff_fun_space\n\ngoal (1 subgoal):\n 1. v (restrict0 sub.carrier f') =\n    inclusion.push_forward v (restrict0 sub.carrier f')", "by (auto simp: inclusion.push_forward_def o_def restrict0_restrict0)"], ["proof (state)\nthis:\n  v (restrict0 sub.carrier f') =\n  inclusion.push_forward v (restrict0 sub.carrier f')\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "also"], ["proof (state)\nthis:\n  v (restrict0 sub.carrier f') =\n  inclusion.push_forward v (restrict0 sub.carrier f')\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inclusion.push_forward v (restrict0 sub.carrier f') = 0", "by (simp add: dv)"], ["proof (state)\nthis:\n  inclusion.push_forward v (restrict0 sub.carrier f') = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> sub.diff_fun_space \\<Longrightarrow> v x = 0 x", "finally"], ["proof (chain)\npicking this:\n  v f = 0", "show \"v f = 0 f\""], ["proof (prove)\nusing this:\n  v f = 0\n\ngoal (1 subgoal):\n 1. v f = 0 f", "by auto"], ["proof (state)\nthis:\n  v f = 0 f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on inclusion.push_forward (sub.tangent_space p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma surj_on_push_forward_inclusion:\n  \"inclusion.push_forward ` sub.tangent_space p \\<supseteq> tangent_space p\"\n  if p: \"p \\<in> sub.carrier\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tangent_space p \\<subseteq> inclusion.push_forward ` sub.tangent_space p", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "assume w: \"w \\<in> tangent_space p\""], ["proof (state)\nthis:\n  w \\<in> tangent_space p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "from sub.precompact_neighborhoodE[OF p]"], ["proof (chain)\npicking this:\n  (\\<And>C.\n      \\<lbrakk>p \\<in> C; open C; compact (closure C);\n       closure C \\<subseteq> sub.carrier\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain B where B: \"p \\<in> B\" \"open B\" \"compact (closure B)\" \"closure B \\<subseteq> sub.carrier\""], ["proof (prove)\nusing this:\n  (\\<And>C.\n      \\<lbrakk>p \\<in> C; open C; compact (closure C);\n       closure C \\<subseteq> sub.carrier\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        \\<lbrakk>p \\<in> B; open B; compact (closure B);\n         closure B \\<subseteq> sub.carrier\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  p \\<in> B\n  open B\n  compact (closure B)\n  closure B \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "have w_eqI: \"w a = w b\" if \"a \\<in> diff_fun_space\" \"b \\<in> diff_fun_space\" and \"\\<And>x. x \\<in> B \\<Longrightarrow> a x = b x\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. w a = w b", "apply (rule derivation_eq_localI[where X=w and U=B and p=p])"], ["proof (prove)\ngoal (7 subgoals):\n 1. open B\n 2. p \\<in> B\n 3. B \\<subseteq> carrier\n 4. w \\<in> tangent_space p\n 5. a \\<in> diff_fun_space\n 6. b \\<in> diff_fun_space\n 7. \\<And>x. x \\<in> B \\<Longrightarrow> a x = b x", "using w B that"], ["proof (prove)\nusing this:\n  w \\<in> tangent_space p\n  p \\<in> B\n  open B\n  compact (closure B)\n  closure B \\<subseteq> sub.carrier\n  a \\<in> diff_fun_space\n  b \\<in> diff_fun_space\n  ?x3 \\<in> B \\<Longrightarrow> a ?x3 = b ?x3\n\ngoal (7 subgoals):\n 1. open B\n 2. p \\<in> B\n 3. B \\<subseteq> carrier\n 4. w \\<in> tangent_space p\n 5. a \\<in> diff_fun_space\n 6. b \\<in> diff_fun_space\n 7. \\<And>x. x \\<in> B \\<Longrightarrow> a x = b x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?a3 \\<in> diff_fun_space; ?b3 \\<in> diff_fun_space;\n   \\<And>x. x \\<in> B \\<Longrightarrow> ?a3 x = ?b3 x\\<rbrakk>\n  \\<Longrightarrow> w ?a3 = w ?b3\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "from tangent_space_linear_on[OF w]"], ["proof (chain)\npicking this:\n  linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) w", "have linear_w: \"linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) w\""], ["proof (prove)\nusing this:\n  linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) w\n\ngoal (1 subgoal):\n 1. linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) w", "."], ["proof (state)\nthis:\n  linear_on diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) w\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "note w_add = diff_fun_space.linear_add[OF _ _ _ linear_w]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x.\n              x \\<in> diff_fun_space \\<longrightarrow> w x \\<in> UNIV;\n   ?b1.0 \\<in> diff_fun_space; ?b2.0 \\<in> diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> w (?b1.0 + ?b2.0) = w ?b1.0 + w ?b2.0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "note w_scale = diff_fun_space.linear_scale[OF _ _ linear_w]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x.\n              x \\<in> diff_fun_space \\<longrightarrow> w x \\<in> UNIV;\n   ?b \\<in> diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> w (?r *\\<^sub>R ?b) = ?r *\\<^sub>R w ?b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "note subspaceI = sub.subspace_diff_fun_space[THEN subspace_add]\n    sub.subspace_diff_fun_space[THEN subspace_mul]\n    subspace_diff_fun_space[THEN subspace_add]\n    subspace_diff_fun_space[THEN subspace_mul]"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> sub.diff_fun_space; ?y \\<in> sub.diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<in> sub.diff_fun_space\n  ?x \\<in> sub.diff_fun_space \\<Longrightarrow>\n  ?c *\\<^sub>R ?x \\<in> sub.diff_fun_space\n  \\<lbrakk>?x \\<in> diff_fun_space; ?y \\<in> diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<in> diff_fun_space\n  ?x \\<in> diff_fun_space \\<Longrightarrow>\n  ?c *\\<^sub>R ?x \\<in> diff_fun_space\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "let ?P = \"\\<lambda>f f'. f' \\<in> diff_fun_space \\<and> (\\<forall>x\\<in>closure B. f x = f' x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "define extend where \"extend f = (SOME f'. ?P f f')\" for f"], ["proof (state)\nthis:\n  extend ?f =\n  (SOME f'.\n      f' \\<in> diff_fun_space \\<and>\n      (\\<forall>x\\<in>closure B. ?f x = f' x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "have ex: \"\\<exists>f'. ?P f f'\" if \"f \\<in> sub.diff_fun_space\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f'.\n       f' \\<in> diff_fun_space \\<and> (\\<forall>x\\<in>closure B. f x = f' x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f'.\n       f' \\<in> diff_fun_space \\<and> (\\<forall>x\\<in>closure B. f x = f' x)", "from that"], ["proof (chain)\npicking this:\n  f \\<in> sub.diff_fun_space", "have \"diff_fun k (charts_submanifold S) f\""], ["proof (prove)\nusing this:\n  f \\<in> sub.diff_fun_space\n\ngoal (1 subgoal):\n 1. diff_fun k (charts_submanifold S) f", "by (rule sub.diff_fun_spaceD)"], ["proof (state)\nthis:\n  diff_fun k (charts_submanifold S) f\n\ngoal (1 subgoal):\n 1. \\<exists>f'.\n       f' \\<in> diff_fun_space \\<and> (\\<forall>x\\<in>closure B. f x = f' x)", "from extension_lemma_submanifoldE[OF this closed_closure \\<open>closure B \\<subseteq> sub.carrier\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>f'.\n      \\<lbrakk>diff_fun k charts f';\n       \\<And>x. x \\<in> closure B \\<Longrightarrow> f' x = f x;\n       csupport_on carrier f' \\<inter> carrier\n       \\<subseteq> sub.carrier\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain f' where f': \"diff_fun k charts f'\" \"(\\<And>x. x \\<in> closure B \\<Longrightarrow> f' x = f x)\" \"csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\""], ["proof (prove)\nusing this:\n  (\\<And>f'.\n      \\<lbrakk>diff_fun k charts f';\n       \\<And>x. x \\<in> closure B \\<Longrightarrow> f' x = f x;\n       csupport_on carrier f' \\<inter> carrier\n       \\<subseteq> sub.carrier\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>f'.\n        \\<lbrakk>diff_fun k charts f';\n         \\<And>x. x \\<in> closure B \\<Longrightarrow> f' x = f x;\n         csupport_on carrier f' \\<inter> carrier\n         \\<subseteq> sub.carrier\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  diff_fun k charts f'\n  ?x3 \\<in> closure B \\<Longrightarrow> f' ?x3 = f ?x3\n  csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. \\<exists>f'.\n       f' \\<in> diff_fun_space \\<and> (\\<forall>x\\<in>closure B. f x = f' x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f'.\n       f' \\<in> diff_fun_space \\<and> (\\<forall>x\\<in>closure B. f x = f' x)", "apply (rule exI[where x=\"restrict0 carrier f'\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 carrier f' \\<in> diff_fun_space \\<and>\n    (\\<forall>x\\<in>closure B. f x = restrict0 carrier f' x)", "using f' B"], ["proof (prove)\nusing this:\n  diff_fun k charts f'\n  ?x3 \\<in> closure B \\<Longrightarrow> f' ?x3 = f ?x3\n  csupport_on carrier f' \\<inter> carrier \\<subseteq> sub.carrier\n  p \\<in> B\n  open B\n  compact (closure B)\n  closure B \\<subseteq> sub.carrier\n\ngoal (1 subgoal):\n 1. restrict0 carrier f' \\<in> diff_fun_space \\<and>\n    (\\<forall>x\\<in>closure B. f x = restrict0 carrier f' x)", "by (auto intro!: restrict0_in_fun_space)"], ["proof (state)\nthis:\n  \\<exists>f'.\n     f' \\<in> diff_fun_space \\<and> (\\<forall>x\\<in>closure B. f x = f' x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f3 \\<in> sub.diff_fun_space \\<Longrightarrow>\n  \\<exists>f'.\n     f' \\<in> diff_fun_space \\<and> (\\<forall>x\\<in>closure B. ?f3 x = f' x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "have extend: \"?P f (extend f)\" if \"f \\<in> sub.diff_fun_space\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend f \\<in> diff_fun_space \\<and>\n    (\\<forall>x\\<in>closure B. f x = extend f x)", "using ex[OF that]"], ["proof (prove)\nusing this:\n  \\<exists>f'.\n     f' \\<in> diff_fun_space \\<and> (\\<forall>x\\<in>closure B. f x = f' x)\n\ngoal (1 subgoal):\n 1. extend f \\<in> diff_fun_space \\<and>\n    (\\<forall>x\\<in>closure B. f x = extend f x)", "unfolding extend_def"], ["proof (prove)\nusing this:\n  \\<exists>f'.\n     f' \\<in> diff_fun_space \\<and> (\\<forall>x\\<in>closure B. f x = f' x)\n\ngoal (1 subgoal):\n 1. (SOME f'.\n        f' \\<in> diff_fun_space \\<and>\n        (\\<forall>x\\<in>closure B. f x = f' x))\n    \\<in> diff_fun_space \\<and>\n    (\\<forall>x\\<in>closure B.\n        f x =\n        (SOME f'.\n            f' \\<in> diff_fun_space \\<and>\n            (\\<forall>x\\<in>closure B. f x = f' x))\n         x)", "by (rule someI_ex)"], ["proof (state)\nthis:\n  ?f3 \\<in> sub.diff_fun_space \\<Longrightarrow>\n  extend ?f3 \\<in> diff_fun_space \\<and>\n  (\\<forall>x\\<in>closure B. ?f3 x = extend ?f3 x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "note extend = extend[THEN conjunct1] extend[THEN conjunct2, rule_format]"], ["proof (state)\nthis:\n  ?f4 \\<in> sub.diff_fun_space \\<Longrightarrow>\n  extend ?f4 \\<in> diff_fun_space\n  \\<lbrakk>?f \\<in> sub.diff_fun_space; ?x \\<in> closure B\\<rbrakk>\n  \\<Longrightarrow> ?f ?x = extend ?f ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "have extend2: \"f \\<in> sub.diff_fun_space \\<Longrightarrow> x \\<in> B \\<Longrightarrow> extend f x = f x\" for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> sub.diff_fun_space; x \\<in> B\\<rbrakk>\n    \\<Longrightarrow> extend f x = f x", "using extend"], ["proof (prove)\nusing this:\n  ?f4 \\<in> sub.diff_fun_space \\<Longrightarrow>\n  extend ?f4 \\<in> diff_fun_space\n  \\<lbrakk>?f \\<in> sub.diff_fun_space; ?x \\<in> closure B\\<rbrakk>\n  \\<Longrightarrow> ?f ?x = extend ?f ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> sub.diff_fun_space; x \\<in> B\\<rbrakk>\n    \\<Longrightarrow> extend f x = f x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?f3 \\<in> sub.diff_fun_space; ?x3 \\<in> B\\<rbrakk>\n  \\<Longrightarrow> extend ?f3 ?x3 = ?f3 ?x3\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "define v where \"v f = w (extend f)\" for f"], ["proof (state)\nthis:\n  v ?f = w (extend ?f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "have ext_w: \"extensional0 diff_fun_space w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extensional0 diff_fun_space w", "using w"], ["proof (prove)\nusing this:\n  w \\<in> tangent_space p\n\ngoal (1 subgoal):\n 1. extensional0 diff_fun_space w", "by (rule tangent_space_restrict)"], ["proof (state)\nthis:\n  extensional0 diff_fun_space w\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "have \"w = inclusion.push_forward (restrict0 sub.diff_fun_space v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = inclusion.push_forward (restrict0 sub.diff_fun_space v)", "unfolding inclusion.push_forward_def o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. w =\n    restrict0 diff_fun_space\n     (\\<lambda>g. restrict0 sub.diff_fun_space v (restrict0 sub.carrier g))", "using ext_w extensional0_restrict0"], ["proof (prove)\nusing this:\n  extensional0 diff_fun_space w\n  extensional0 ?A (restrict0 ?A ?f)\n\ngoal (1 subgoal):\n 1. w =\n    restrict0 diff_fun_space\n     (\\<lambda>g. restrict0 sub.diff_fun_space v (restrict0 sub.carrier g))", "proof (rule ext_extensional0)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow>\n       w x =\n       restrict0 diff_fun_space\n        (\\<lambda>g.\n            restrict0 sub.diff_fun_space v (restrict0 sub.carrier g))\n        x", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow>\n       w x =\n       restrict0 diff_fun_space\n        (\\<lambda>g.\n            restrict0 sub.diff_fun_space v (restrict0 sub.carrier g))\n        x", "assume g: \"g \\<in> diff_fun_space\""], ["proof (state)\nthis:\n  g \\<in> diff_fun_space\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow>\n       w x =\n       restrict0 diff_fun_space\n        (\\<lambda>g.\n            restrict0 sub.diff_fun_space v (restrict0 sub.carrier g))\n        x", "then"], ["proof (chain)\npicking this:\n  g \\<in> diff_fun_space", "have \"diff_fun k charts g\""], ["proof (prove)\nusing this:\n  g \\<in> diff_fun_space\n\ngoal (1 subgoal):\n 1. diff_fun k charts g", "by (rule diff_fun_spaceD)"], ["proof (state)\nthis:\n  diff_fun k charts g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow>\n       w x =\n       restrict0 diff_fun_space\n        (\\<lambda>g.\n            restrict0 sub.diff_fun_space v (restrict0 sub.carrier g))\n        x", "then"], ["proof (chain)\npicking this:\n  diff_fun k charts g", "have \"diff_fun k (charts_submanifold S) g\""], ["proof (prove)\nusing this:\n  diff_fun k charts g\n\ngoal (1 subgoal):\n 1. diff_fun k (charts_submanifold S) g", "using open_submanifold"], ["proof (prove)\nusing this:\n  diff_fun k charts g\n  open S\n\ngoal (1 subgoal):\n 1. diff_fun k (charts_submanifold S) g", "by (rule diff_fun.diff_fun_submanifold)"], ["proof (state)\nthis:\n  diff_fun k (charts_submanifold S) g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow>\n       w x =\n       restrict0 diff_fun_space\n        (\\<lambda>g.\n            restrict0 sub.diff_fun_space v (restrict0 sub.carrier g))\n        x", "have rgsd: \"restrict0 sub.carrier g \\<in> sub.diff_fun_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 sub.carrier g \\<in> sub.diff_fun_space", "by (rule sub.restrict0_in_fun_space) fact"], ["proof (state)\nthis:\n  restrict0 sub.carrier g \\<in> sub.diff_fun_space\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow>\n       w x =\n       restrict0 diff_fun_space\n        (\\<lambda>g.\n            restrict0 sub.diff_fun_space v (restrict0 sub.carrier g))\n        x", "have \"w g = v (restrict0 sub.carrier g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w g = v (restrict0 sub.carrier g)", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. w g = w (extend (restrict0 sub.carrier g))", "apply (rule w_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. g \\<in> diff_fun_space\n 2. extend (restrict0 sub.carrier g) \\<in> diff_fun_space\n 3. \\<And>x.\n       x \\<in> B \\<Longrightarrow> g x = extend (restrict0 sub.carrier g) x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<in> diff_fun_space", "by fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. extend (restrict0 sub.carrier g) \\<in> diff_fun_space\n 2. \\<And>x.\n       x \\<in> B \\<Longrightarrow> g x = extend (restrict0 sub.carrier g) x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend (restrict0 sub.carrier g) \\<in> diff_fun_space", "by (rule extend) fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Longrightarrow> g x = extend (restrict0 sub.carrier g) x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> B \\<Longrightarrow> g x = extend (restrict0 sub.carrier g) x", "using extend(2)[of \"restrict0 sub.carrier g\" x] B(4) rgsd"], ["proof (prove)\nusing this:\n  \\<lbrakk>restrict0 sub.carrier g \\<in> sub.diff_fun_space;\n   x \\<in> closure B\\<rbrakk>\n  \\<Longrightarrow> restrict0 sub.carrier g x =\n                    extend (restrict0 sub.carrier g) x\n  closure B \\<subseteq> sub.carrier\n  restrict0 sub.carrier g \\<in> sub.diff_fun_space\n\ngoal (1 subgoal):\n 1. x \\<in> B \\<Longrightarrow> g x = extend (restrict0 sub.carrier g) x", "by (auto simp: restrict0_def split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  w g = v (restrict0 sub.carrier g)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> diff_fun_space \\<Longrightarrow>\n       w x =\n       restrict0 diff_fun_space\n        (\\<lambda>g.\n            restrict0 sub.diff_fun_space v (restrict0 sub.carrier g))\n        x", "with g rgsd"], ["proof (chain)\npicking this:\n  g \\<in> diff_fun_space\n  restrict0 sub.carrier g \\<in> sub.diff_fun_space\n  w g = v (restrict0 sub.carrier g)", "show \"w g = restrict0 diff_fun_space (\\<lambda>g. restrict0 sub.diff_fun_space v (restrict0 sub.carrier g)) g\""], ["proof (prove)\nusing this:\n  g \\<in> diff_fun_space\n  restrict0 sub.carrier g \\<in> sub.diff_fun_space\n  w g = v (restrict0 sub.carrier g)\n\ngoal (1 subgoal):\n 1. w g =\n    restrict0 diff_fun_space\n     (\\<lambda>g. restrict0 sub.diff_fun_space v (restrict0 sub.carrier g))\n     g", "by auto"], ["proof (state)\nthis:\n  w g =\n  restrict0 diff_fun_space\n   (\\<lambda>g. restrict0 sub.diff_fun_space v (restrict0 sub.carrier g)) g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w = inclusion.push_forward (restrict0 sub.diff_fun_space v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "moreover"], ["proof (state)\nthis:\n  w = inclusion.push_forward (restrict0 sub.diff_fun_space v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "have \"restrict0 sub.diff_fun_space v \\<in> sub.tangent_space p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 sub.diff_fun_space v \\<in> sub.tangent_space p", "using extensional0_restrict0"], ["proof (prove)\nusing this:\n  extensional0 ?A (restrict0 ?A ?f)\n\ngoal (1 subgoal):\n 1. restrict0 sub.diff_fun_space v \\<in> sub.tangent_space p", "proof (rule sub.tangent_spaceI)"], ["proof (state)\ngoal (2 subgoals):\n 1. linear_on sub.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R)\n     (restrict0 sub.diff_fun_space v)\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "have \"v (x + y) = v x + v y\" if \"x \\<in> sub.diff_fun_space\" \"y \\<in> sub.diff_fun_space\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (x + y) = v x + v y", "using that"], ["proof (prove)\nusing this:\n  x \\<in> sub.diff_fun_space\n  y \\<in> sub.diff_fun_space\n\ngoal (1 subgoal):\n 1. v (x + y) = v x + v y", "unfolding v_def"], ["proof (prove)\nusing this:\n  x \\<in> sub.diff_fun_space\n  y \\<in> sub.diff_fun_space\n\ngoal (1 subgoal):\n 1. w (extend (x + y)) = w (extend x) + w (extend y)", "by (subst w_add[symmetric]) (auto intro!: w_eqI simp: extend2 subspaceI extend(1))"], ["proof (state)\nthis:\n  \\<lbrakk>?x3 \\<in> sub.diff_fun_space;\n   ?y3 \\<in> sub.diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> v (?x3 + ?y3) = v ?x3 + v ?y3\n\ngoal (2 subgoals):\n 1. linear_on sub.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R)\n     (restrict0 sub.diff_fun_space v)\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?x3 \\<in> sub.diff_fun_space;\n   ?y3 \\<in> sub.diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> v (?x3 + ?y3) = v ?x3 + v ?y3\n\ngoal (2 subgoals):\n 1. linear_on sub.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R)\n     (restrict0 sub.diff_fun_space v)\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "have \"v (c *\\<^sub>R x) = c *\\<^sub>R v x\" if \"x \\<in> sub.diff_fun_space\" for x c"], ["proof (prove)\ngoal (1 subgoal):\n 1. v (c *\\<^sub>R x) = c *\\<^sub>R v x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> sub.diff_fun_space\n\ngoal (1 subgoal):\n 1. v (c *\\<^sub>R x) = c *\\<^sub>R v x", "unfolding v_def"], ["proof (prove)\nusing this:\n  x \\<in> sub.diff_fun_space\n\ngoal (1 subgoal):\n 1. w (extend (c *\\<^sub>R x)) = c *\\<^sub>R w (extend x)", "by (subst w_scale[symmetric]) (auto intro!: w_eqI simp: extend2 subspaceI extend(1))"], ["proof (state)\nthis:\n  ?x3 \\<in> sub.diff_fun_space \\<Longrightarrow>\n  v (?c3 *\\<^sub>R ?x3) = ?c3 *\\<^sub>R v ?x3\n\ngoal (2 subgoals):\n 1. linear_on sub.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R)\n     (restrict0 sub.diff_fun_space v)\n 2. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x3 \\<in> sub.diff_fun_space;\n   ?y3 \\<in> sub.diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> v (?x3 + ?y3) = v ?x3 + v ?y3\n  ?x3 \\<in> sub.diff_fun_space \\<Longrightarrow>\n  v (?c3 *\\<^sub>R ?x3) = ?c3 *\\<^sub>R v ?x3", "show \"linear_on sub.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R) (restrict0 sub.diff_fun_space v)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 \\<in> sub.diff_fun_space;\n   ?y3 \\<in> sub.diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> v (?x3 + ?y3) = v ?x3 + v ?y3\n  ?x3 \\<in> sub.diff_fun_space \\<Longrightarrow>\n  v (?c3 *\\<^sub>R ?x3) = ?c3 *\\<^sub>R v ?x3\n\ngoal (1 subgoal):\n 1. linear_on sub.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R)\n     (restrict0 sub.diff_fun_space v)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>x \\<in> sub.diff_fun_space;\n                    y \\<in> sub.diff_fun_space\\<rbrakk>\n                   \\<Longrightarrow> v (x + y) = v x + v y;\n        \\<And>x c.\n           x \\<in> sub.diff_fun_space \\<Longrightarrow>\n           v (c *\\<^sub>R x) = c *\\<^sub>R v x;\n        b1 \\<in> sub.diff_fun_space; b2 \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (b1 + b2) =\n                         restrict0 sub.diff_fun_space v b1 +\n                         restrict0 sub.diff_fun_space v b2\n 2. \\<And>r b.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>x \\<in> sub.diff_fun_space;\n                    y \\<in> sub.diff_fun_space\\<rbrakk>\n                   \\<Longrightarrow> v (x + y) = v x + v y;\n        \\<And>x c.\n           x \\<in> sub.diff_fun_space \\<Longrightarrow>\n           v (c *\\<^sub>R x) = c *\\<^sub>R v x;\n        b \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (r *\\<^sub>R b) =\n                         r *\\<^sub>R restrict0 sub.diff_fun_space v b", "using sub.subspace_diff_fun_space[THEN subspace_add]\n        sub.subspace_diff_fun_space[THEN subspace_mul]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> sub.diff_fun_space; ?y \\<in> sub.diff_fun_space\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<in> sub.diff_fun_space\n  ?x \\<in> sub.diff_fun_space \\<Longrightarrow>\n  ?c *\\<^sub>R ?x \\<in> sub.diff_fun_space\n\ngoal (2 subgoals):\n 1. \\<And>b1 b2.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>x \\<in> sub.diff_fun_space;\n                    y \\<in> sub.diff_fun_space\\<rbrakk>\n                   \\<Longrightarrow> v (x + y) = v x + v y;\n        \\<And>x c.\n           x \\<in> sub.diff_fun_space \\<Longrightarrow>\n           v (c *\\<^sub>R x) = c *\\<^sub>R v x;\n        b1 \\<in> sub.diff_fun_space; b2 \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (b1 + b2) =\n                         restrict0 sub.diff_fun_space v b1 +\n                         restrict0 sub.diff_fun_space v b2\n 2. \\<And>r b.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>x \\<in> sub.diff_fun_space;\n                    y \\<in> sub.diff_fun_space\\<rbrakk>\n                   \\<Longrightarrow> v (x + y) = v x + v y;\n        \\<And>x c.\n           x \\<in> sub.diff_fun_space \\<Longrightarrow>\n           v (c *\\<^sub>R x) = c *\\<^sub>R v x;\n        b \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (r *\\<^sub>R b) =\n                         r *\\<^sub>R restrict0 sub.diff_fun_space v b", "by auto"], ["proof (state)\nthis:\n  linear_on sub.diff_fun_space UNIV (*\\<^sub>R) (*\\<^sub>R)\n   (restrict0 sub.diff_fun_space v)\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "fix f g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "assume f: \"f \\<in> sub.diff_fun_space\" and g: \"g \\<in> sub.diff_fun_space\""], ["proof (state)\nthis:\n  f \\<in> sub.diff_fun_space\n  g \\<in> sub.diff_fun_space\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "then"], ["proof (chain)\npicking this:\n  f \\<in> sub.diff_fun_space\n  g \\<in> sub.diff_fun_space", "have [simp]: \"f * g \\<in> sub.diff_fun_space\""], ["proof (prove)\nusing this:\n  f \\<in> sub.diff_fun_space\n  g \\<in> sub.diff_fun_space\n\ngoal (1 subgoal):\n 1. f * g \\<in> sub.diff_fun_space", "by (rule sub.diff_fun_space_times)"], ["proof (state)\nthis:\n  f * g \\<in> sub.diff_fun_space\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "have \"restrict0 sub.diff_fun_space v (f * g) = w (extend (f * g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 sub.diff_fun_space v (f * g) = w (extend (f * g))", "by (simp add: v_def)"], ["proof (state)\nthis:\n  restrict0 sub.diff_fun_space v (f * g) = w (extend (f * g))\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "also"], ["proof (state)\nthis:\n  restrict0 sub.diff_fun_space v (f * g) = w (extend (f * g))\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "have \"\\<dots> = w (extend f * extend g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w (extend (f * g)) = w (extend f * extend g)", "apply (rule w_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. extend (f * g) \\<in> diff_fun_space\n 2. extend f * extend g \\<in> diff_fun_space\n 3. \\<And>x.\n       x \\<in> B \\<Longrightarrow>\n       extend (f * g) x = (extend f * extend g) x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend (f * g) \\<in> diff_fun_space", "by (simp add: extend)"], ["proof (prove)\ngoal (2 subgoals):\n 1. extend f * extend g \\<in> diff_fun_space\n 2. \\<And>x.\n       x \\<in> B \\<Longrightarrow>\n       extend (f * g) x = (extend f * extend g) x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend f * extend g \\<in> diff_fun_space", "by (simp add: diff_fun_space_times extend f g)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> B \\<Longrightarrow>\n       extend (f * g) x = (extend f * extend g) x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> B \\<Longrightarrow>\n    extend (f * g) x_ = (extend f * extend g) x_", "using f g"], ["proof (prove)\nusing this:\n  f \\<in> sub.diff_fun_space\n  g \\<in> sub.diff_fun_space\n\ngoal (1 subgoal):\n 1. x_ \\<in> B \\<Longrightarrow>\n    extend (f * g) x_ = (extend f * extend g) x_", "by (auto simp: extend2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  w (extend (f * g)) = w (extend f * extend g)\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "also"], ["proof (state)\nthis:\n  w (extend (f * g)) = w (extend f * extend g)\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "have \"\\<dots> = extend f p * w (extend g) + extend g p * w (extend f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w (extend f * extend g) =\n    extend f p * w (extend g) + extend g p * w (extend f)", "apply (rule is_derivation_derivation)"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_derivation w p\n 2. extend f \\<in> diff_fun_space\n 3. extend g \\<in> diff_fun_space", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_derivation w p", "using w"], ["proof (prove)\nusing this:\n  w \\<in> tangent_space p\n\ngoal (1 subgoal):\n 1. is_derivation w p", "by (auto simp: tangent_space_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. extend f \\<in> diff_fun_space\n 2. extend g \\<in> diff_fun_space", "by (auto intro!: extend f g)"], ["proof (state)\nthis:\n  w (extend f * extend g) =\n  extend f p * w (extend g) + extend g p * w (extend f)\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "also"], ["proof (state)\nthis:\n  w (extend f * extend g) =\n  extend f p * w (extend g) + extend g p * w (extend f)\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "have \"\\<dots> = f p * restrict0 sub.diff_fun_space v g + g p * restrict0 sub.diff_fun_space v f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend f p * w (extend g) + extend g p * w (extend f) =\n    f p * restrict0 sub.diff_fun_space v g +\n    g p * restrict0 sub.diff_fun_space v f", "by (simp add: f g v_def extend2 \\<open>p \\<in> B\\<close>)"], ["proof (state)\nthis:\n  extend f p * w (extend g) + extend g p * w (extend f) =\n  f p * restrict0 sub.diff_fun_space v g +\n  g p * restrict0 sub.diff_fun_space v f\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>f \\<in> sub.diff_fun_space;\n        g \\<in> sub.diff_fun_space\\<rbrakk>\n       \\<Longrightarrow> restrict0 sub.diff_fun_space v (f * g) =\n                         f p * restrict0 sub.diff_fun_space v g +\n                         g p * restrict0 sub.diff_fun_space v f", "finally"], ["proof (chain)\npicking this:\n  restrict0 sub.diff_fun_space v (f * g) =\n  f p * restrict0 sub.diff_fun_space v g +\n  g p * restrict0 sub.diff_fun_space v f", "show \"restrict0 sub.diff_fun_space v (f * g) = f p * restrict0 sub.diff_fun_space v g + g p * restrict0 sub.diff_fun_space v f\""], ["proof (prove)\nusing this:\n  restrict0 sub.diff_fun_space v (f * g) =\n  f p * restrict0 sub.diff_fun_space v g +\n  g p * restrict0 sub.diff_fun_space v f\n\ngoal (1 subgoal):\n 1. restrict0 sub.diff_fun_space v (f * g) =\n    f p * restrict0 sub.diff_fun_space v g +\n    g p * restrict0 sub.diff_fun_space v f", "."], ["proof (state)\nthis:\n  restrict0 sub.diff_fun_space v (f * g) =\n  f p * restrict0 sub.diff_fun_space v g +\n  g p * restrict0 sub.diff_fun_space v f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict0 sub.diff_fun_space v \\<in> sub.tangent_space p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tangent_space p \\<Longrightarrow>\n       x \\<in> inclusion.push_forward ` sub.tangent_space p", "ultimately"], ["proof (chain)\npicking this:\n  w = inclusion.push_forward (restrict0 sub.diff_fun_space v)\n  restrict0 sub.diff_fun_space v \\<in> sub.tangent_space p", "show \"w \\<in> inclusion.push_forward ` sub.tangent_space p\""], ["proof (prove)\nusing this:\n  w = inclusion.push_forward (restrict0 sub.diff_fun_space v)\n  restrict0 sub.diff_fun_space v \\<in> sub.tangent_space p\n\ngoal (1 subgoal):\n 1. w \\<in> inclusion.push_forward ` sub.tangent_space p", ".."], ["proof (state)\nthis:\n  w \\<in> inclusion.push_forward ` sub.tangent_space p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Tangent space of submanifold\\<close>"], ["", "lemma span_idem: \"span X = X\" if \"subspace X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span X = X", "using that"], ["proof (prove)\nusing this:\n  subspace X\n\ngoal (1 subgoal):\n 1. span X = X", "by auto"], ["", "context submanifold begin"], ["", "lemma dim_tangent_space: \"dim (tangent_space p) = dim (sub.tangent_space p)\"\n  if \"p \\<in> sub.carrier\" \"dim (sub.tangent_space p) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "from that(2)"], ["proof (chain)\npicking this:\n  0 < dim (sub.tangent_space p)", "obtain basis where basis: \"independent basis\" \"span basis = span (sub.tangent_space p)\""], ["proof (prove)\nusing this:\n  0 < dim (sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. (\\<And>basis.\n        \\<lbrakk>independent basis;\n         span basis = span (sub.tangent_space p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: dim_def split: if_splits)"], ["proof (state)\nthis:\n  independent basis\n  span basis = span (sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "have basis_sub: \"basis \\<subseteq> sub.tangent_space p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis \\<subseteq> sub.tangent_space p", "using basis"], ["proof (prove)\nusing this:\n  independent basis\n  span basis = span (sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. basis \\<subseteq> sub.tangent_space p", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>independent basis; span basis = span (sub.tangent_space p);\n        x \\<in> basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> sub.tangent_space p", "by (metis basis(2) span_base span_eq_iff sub.subspace_tangent_space)"], ["proof (state)\nthis:\n  basis \\<subseteq> sub.tangent_space p\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "have \"dim (sub.tangent_space p) = card basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (sub.tangent_space p) = card basis", "apply (rule dim_unique[OF _ _ _ refl])"], ["proof (prove)\ngoal (3 subgoals):\n 1. basis \\<subseteq> sub.tangent_space p\n 2. sub.tangent_space p \\<subseteq> span basis\n 3. independent basis", "using basis span_base"], ["proof (prove)\nusing this:\n  independent basis\n  span basis = span (sub.tangent_space p)\n  ?a \\<in> ?S \\<Longrightarrow> ?a \\<in> span ?S\n\ngoal (3 subgoals):\n 1. basis \\<subseteq> sub.tangent_space p\n 2. sub.tangent_space p \\<subseteq> span basis\n 3. independent basis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>independent basis; span basis = span (sub.tangent_space p);\n        \\<And>a S. a \\<in> S \\<Longrightarrow> a \\<in> span S;\n        x \\<in> basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> sub.tangent_space p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>independent basis; span basis = span (sub.tangent_space p);\n        \\<And>a S. a \\<in> S \\<Longrightarrow> a \\<in> span S;\n        x \\<in> basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> sub.tangent_space p", "fix x :: \"('a \\<Rightarrow> real) \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>independent basis; span basis = span (sub.tangent_space p);\n        \\<And>a S. a \\<in> S \\<Longrightarrow> a \\<in> span S;\n        x \\<in> basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> sub.tangent_space p", "assume a1: \"x \\<in> basis\""], ["proof (state)\nthis:\n  x \\<in> basis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>independent basis; span basis = span (sub.tangent_space p);\n        \\<And>a S. a \\<in> S \\<Longrightarrow> a \\<in> span S;\n        x \\<in> basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> sub.tangent_space p", "have \"sub.tangent_space p = span basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub.tangent_space p = span basis", "by (metis basis(2) span_eq_iff sub.subspace_tangent_space)"], ["proof (state)\nthis:\n  sub.tangent_space p = span basis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>independent basis; span basis = span (sub.tangent_space p);\n        \\<And>a S. a \\<in> S \\<Longrightarrow> a \\<in> span S;\n        x \\<in> basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> sub.tangent_space p", "then"], ["proof (chain)\npicking this:\n  sub.tangent_space p = span basis", "show \"x \\<in> sub.tangent_space p\""], ["proof (prove)\nusing this:\n  sub.tangent_space p = span basis\n\ngoal (1 subgoal):\n 1. x \\<in> sub.tangent_space p", "using a1"], ["proof (prove)\nusing this:\n  sub.tangent_space p = span basis\n  x \\<in> basis\n\ngoal (1 subgoal):\n 1. x \\<in> sub.tangent_space p", "by (metis span_base)"], ["proof (state)\nthis:\n  x \\<in> sub.tangent_space p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dim (sub.tangent_space p) = card basis\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "with that"], ["proof (chain)\npicking this:\n  p \\<in> sub.carrier\n  0 < dim (sub.tangent_space p)\n  dim (sub.tangent_space p) = card basis", "have \"finite basis\""], ["proof (prove)\nusing this:\n  p \\<in> sub.carrier\n  0 < dim (sub.tangent_space p)\n  dim (sub.tangent_space p) = card basis\n\ngoal (1 subgoal):\n 1. finite basis", "using card_ge_0_finite"], ["proof (prove)\nusing this:\n  p \\<in> sub.carrier\n  0 < dim (sub.tangent_space p)\n  dim (sub.tangent_space p) = card basis\n  0 < card ?A \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite basis", "by auto"], ["proof (state)\nthis:\n  finite basis\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "interpret sub: finite_dimensional_vector_space_on \"sub.tangent_space p\" scaleR basis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space_on (sub.tangent_space p) (*\\<^sub>R)\n     basis", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite basis\n 2. \\<not> module_on.dependent (*\\<^sub>R) basis\n 3. module_on.span (*\\<^sub>R) basis = sub.tangent_space p\n 4. basis \\<subseteq> sub.tangent_space p", "unfolding tangent_space.dependent_eq_real tangent_space.span_eq_real"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite basis\n 2. independent basis\n 3. span basis = sub.tangent_space p\n 4. basis \\<subseteq> sub.tangent_space p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite basis", "by fact"], ["proof (prove)\ngoal (3 subgoals):\n 1. independent basis\n 2. span basis = sub.tangent_space p\n 3. basis \\<subseteq> sub.tangent_space p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. independent basis", "by fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. span basis = sub.tangent_space p\n 2. basis \\<subseteq> sub.tangent_space p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. span basis = sub.tangent_space p", "using basis"], ["proof (prove)\nusing this:\n  independent basis\n  span basis = span (sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. span basis = sub.tangent_space p", "by (simp add: sub.subspace_tangent_space)"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis \\<subseteq> sub.tangent_space p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis \\<subseteq> sub.tangent_space p", "by fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "interpret sub: finite_dimensional_vector_space_pair_1_on \"sub.tangent_space p\" \"tangent_space p\" scaleR scaleR basis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space_pair_1_on (sub.tangent_space p)\n     (tangent_space p) (*\\<^sub>R) (*\\<^sub>R) basis", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "have \"dim (tangent_space p) = tangent_space.dim p (tangent_space p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = tangent_space.dim p (tangent_space p)", "using order_refl"], ["proof (prove)\nusing this:\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = tangent_space.dim p (tangent_space p)", "by (rule tangent_space_dim_eq[symmetric])"], ["proof (state)\nthis:\n  dim (tangent_space p) = tangent_space.dim p (tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "also"], ["proof (state)\nthis:\n  dim (tangent_space p) = tangent_space.dim p (tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "have \"\\<dots> = tangent_space.dim p (inclusion.push_forward ` sub.tangent_space p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tangent_space.dim p (tangent_space p) =\n    tangent_space.dim p (inclusion.push_forward ` sub.tangent_space p)", "using surj_on_push_forward_inclusion[OF that(1)] inclusion.push_forward_in_tangent_space[OF that(1)]"], ["proof (prove)\nusing this:\n  tangent_space p \\<subseteq> inclusion.push_forward ` sub.tangent_space p\n  inclusion.push_forward ` sub.tangent_space p \\<subseteq> tangent_space p\n\ngoal (1 subgoal):\n 1. tangent_space.dim p (tangent_space p) =\n    tangent_space.dim p (inclusion.push_forward ` sub.tangent_space p)", "by auto"], ["proof (state)\nthis:\n  tangent_space.dim p (tangent_space p) =\n  tangent_space.dim p (inclusion.push_forward ` sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "also"], ["proof (state)\nthis:\n  tangent_space.dim p (tangent_space p) =\n  tangent_space.dim p (inclusion.push_forward ` sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "have \"tangent_space.dim p (inclusion.push_forward ` sub.tangent_space p) =\n    sub.tangent_space.dim p (sub.tangent_space p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tangent_space.dim p (inclusion.push_forward ` sub.tangent_space p) =\n    sub.tangent_space.dim p (sub.tangent_space p)", "apply (rule sub.dim_image_eq[of inclusion.push_forward, OF _ order_refl linear_on_push_forward_inclusion])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       x \\<in> sub.tangent_space p \\<longrightarrow>\n       inclusion.push_forward x \\<in> tangent_space p\n 2. inj_on inclusion.push_forward\n     (module_on.span (*\\<^sub>R) (sub.tangent_space p))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> sub.tangent_space p \\<longrightarrow>\n       inclusion.push_forward x \\<in> tangent_space p", "using inclusion.push_forward_in_tangent_space[of p] that"], ["proof (prove)\nusing this:\n  p \\<in> sub.carrier \\<Longrightarrow>\n  inclusion.push_forward ` sub.tangent_space p \\<subseteq> tangent_space p\n  p \\<in> sub.carrier\n  0 < dim (sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> sub.tangent_space p \\<longrightarrow>\n       inclusion.push_forward x \\<in> tangent_space p", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on inclusion.push_forward\n     (module_on.span (*\\<^sub>R) (sub.tangent_space p))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on inclusion.push_forward\n     (module_on.span (*\\<^sub>R) (sub.tangent_space p))", "unfolding tangent_space.span_eq_real span_idem[OF sub.subspace_tangent_space]"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on inclusion.push_forward (sub.tangent_space p)", "apply (rule inj_on_push_forward_inclusion)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> sub.carrier", "apply (rule that)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  tangent_space.dim p (inclusion.push_forward ` sub.tangent_space p) =\n  sub.tangent_space.dim p (sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "also"], ["proof (state)\nthis:\n  tangent_space.dim p (inclusion.push_forward ` sub.tangent_space p) =\n  sub.tangent_space.dim p (sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "have \"\\<dots> = dim (sub.tangent_space p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub.tangent_space.dim p (sub.tangent_space p) =\n    dim (sub.tangent_space p)", "using order_refl"], ["proof (prove)\nusing this:\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. sub.tangent_space.dim p (sub.tangent_space p) =\n    dim (sub.tangent_space p)", "by (rule sub.tangent_space_dim_eq)"], ["proof (state)\nthis:\n  sub.tangent_space.dim p (sub.tangent_space p) = dim (sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "finally"], ["proof (chain)\npicking this:\n  dim (tangent_space p) = dim (sub.tangent_space p)", "show ?thesis"], ["proof (prove)\nusing this:\n  dim (tangent_space p) = dim (sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "."], ["proof (state)\nthis:\n  dim (tangent_space p) = dim (sub.tangent_space p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dim_tangent_space2: \"dim (tangent_space p) = dim (sub.tangent_space p)\"\n  if \"p \\<in> sub.carrier\" \"dim (tangent_space p) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "from that(2)"], ["proof (chain)\npicking this:\n  0 < dim (tangent_space p)", "obtain basis where basis: \"independent basis\" \"span basis = span (tangent_space p)\""], ["proof (prove)\nusing this:\n  0 < dim (tangent_space p)\n\ngoal (1 subgoal):\n 1. (\\<And>basis.\n        \\<lbrakk>independent basis;\n         span basis = span (tangent_space p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: dim_def split: if_splits)"], ["proof (state)\nthis:\n  independent basis\n  span basis = span (tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "have basis_sub: \"basis \\<subseteq> tangent_space p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basis \\<subseteq> tangent_space p", "using basis"], ["proof (prove)\nusing this:\n  independent basis\n  span basis = span (tangent_space p)\n\ngoal (1 subgoal):\n 1. basis \\<subseteq> tangent_space p", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>independent basis; span basis = span (tangent_space p);\n        x \\<in> basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tangent_space p", "using c_manifold.subspace_tangent_space c_manifold_axioms span_base span_eq_iff"], ["proof (prove)\nusing this:\n  c_manifold ?charts ?k \\<Longrightarrow>\n  subspace (c_manifold.tangent_space ?charts ?k ?p)\n  c_manifold charts k\n  ?a \\<in> ?S \\<Longrightarrow> ?a \\<in> span ?S\n  (span ?s = ?s) = subspace ?s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>independent basis; span basis = span (tangent_space p);\n        x \\<in> basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tangent_space p", "by blast"], ["proof (state)\nthis:\n  basis \\<subseteq> tangent_space p\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "have \"dim (tangent_space p) = card basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = card basis", "apply (rule dim_unique[OF _ _ _ refl])"], ["proof (prove)\ngoal (3 subgoals):\n 1. basis \\<subseteq> tangent_space p\n 2. tangent_space p \\<subseteq> span basis\n 3. independent basis", "using basis span_base"], ["proof (prove)\nusing this:\n  independent basis\n  span basis = span (tangent_space p)\n  ?a \\<in> ?S \\<Longrightarrow> ?a \\<in> span ?S\n\ngoal (3 subgoals):\n 1. basis \\<subseteq> tangent_space p\n 2. tangent_space p \\<subseteq> span basis\n 3. independent basis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>independent basis; span basis = span (tangent_space p);\n        \\<And>a S. a \\<in> S \\<Longrightarrow> a \\<in> span S;\n        x \\<in> basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tangent_space p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>independent basis; span basis = span (tangent_space p);\n        \\<And>a S. a \\<in> S \\<Longrightarrow> a \\<in> span S;\n        x \\<in> basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tangent_space p", "fix x :: \"('a \\<Rightarrow> real) \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>independent basis; span basis = span (tangent_space p);\n        \\<And>a S. a \\<in> S \\<Longrightarrow> a \\<in> span S;\n        x \\<in> basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tangent_space p", "assume a1: \"x \\<in> basis\""], ["proof (state)\nthis:\n  x \\<in> basis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>independent basis; span basis = span (tangent_space p);\n        \\<And>a S. a \\<in> S \\<Longrightarrow> a \\<in> span S;\n        x \\<in> basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tangent_space p", "have \"tangent_space p = span basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tangent_space p = span basis", "by (metis basis(2) span_eq_iff subspace_tangent_space)"], ["proof (state)\nthis:\n  tangent_space p = span basis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>independent basis; span basis = span (tangent_space p);\n        \\<And>a S. a \\<in> S \\<Longrightarrow> a \\<in> span S;\n        x \\<in> basis\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tangent_space p", "then"], ["proof (chain)\npicking this:\n  tangent_space p = span basis", "show \"x \\<in> tangent_space p\""], ["proof (prove)\nusing this:\n  tangent_space p = span basis\n\ngoal (1 subgoal):\n 1. x \\<in> tangent_space p", "using a1"], ["proof (prove)\nusing this:\n  tangent_space p = span basis\n  x \\<in> basis\n\ngoal (1 subgoal):\n 1. x \\<in> tangent_space p", "by (metis span_base)"], ["proof (state)\nthis:\n  x \\<in> tangent_space p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dim (tangent_space p) = card basis\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "with that"], ["proof (chain)\npicking this:\n  p \\<in> sub.carrier\n  0 < dim (tangent_space p)\n  dim (tangent_space p) = card basis", "have \"finite basis\""], ["proof (prove)\nusing this:\n  p \\<in> sub.carrier\n  0 < dim (tangent_space p)\n  dim (tangent_space p) = card basis\n\ngoal (1 subgoal):\n 1. finite basis", "using card_ge_0_finite"], ["proof (prove)\nusing this:\n  p \\<in> sub.carrier\n  0 < dim (tangent_space p)\n  dim (tangent_space p) = card basis\n  0 < card ?A \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite basis", "by auto"], ["proof (state)\nthis:\n  finite basis\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "interpret sub: finite_dimensional_vector_space_on \"tangent_space p\" scaleR basis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space_on (tangent_space p) (*\\<^sub>R) basis", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite basis\n 2. \\<not> module_on.dependent (*\\<^sub>R) basis\n 3. module_on.span (*\\<^sub>R) basis = tangent_space p\n 4. basis \\<subseteq> tangent_space p", "unfolding tangent_space.dependent_eq_real tangent_space.span_eq_real"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite basis\n 2. independent basis\n 3. span basis = tangent_space p\n 4. basis \\<subseteq> tangent_space p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite basis", "by fact"], ["proof (prove)\ngoal (3 subgoals):\n 1. independent basis\n 2. span basis = tangent_space p\n 3. basis \\<subseteq> tangent_space p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. independent basis", "by fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. span basis = tangent_space p\n 2. basis \\<subseteq> tangent_space p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. span basis = tangent_space p", "using basis"], ["proof (prove)\nusing this:\n  independent basis\n  span basis = span (tangent_space p)\n\ngoal (1 subgoal):\n 1. span basis = tangent_space p", "by (simp add: subspace_tangent_space)"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis \\<subseteq> tangent_space p", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. basis \\<subseteq> tangent_space p", "by fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "interpret vector_space_pair_on \"sub.tangent_space p\" \"tangent_space p\" scaleR scaleR"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector_space_pair_on (sub.tangent_space p) (tangent_space p) (*\\<^sub>R)\n     (*\\<^sub>R)", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "interpret finite_dimensional_vector_space_pair_1_on \"tangent_space p\" \"sub.tangent_space p\" scaleR scaleR basis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_vector_space_pair_1_on (tangent_space p)\n     (sub.tangent_space p) (*\\<^sub>R) (*\\<^sub>R) basis", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "from linear_injective_left_inverse[OF _ linear_on_push_forward_inclusion inj_on_push_forward_inclusion[OF \\<open>p \\<in> sub.carrier\\<close>]]\n    inclusion.push_forward_in_tangent_space[OF \\<open>p \\<in> sub.carrier\\<close>]"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in> sub.tangent_space p \\<longrightarrow>\n     inclusion.push_forward x \\<in> tangent_space p \\<Longrightarrow>\n  \\<exists>g.\n     (\\<forall>x.\n         x \\<in> tangent_space p \\<longrightarrow>\n         g x \\<in> sub.tangent_space p) \\<and>\n     linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R)\n      (*\\<^sub>R) g \\<and>\n     (\\<forall>x\\<in>sub.tangent_space p. g (inclusion.push_forward x) = x)\n  inclusion.push_forward ` sub.tangent_space p \\<subseteq> tangent_space p", "obtain g where g: \"\\<And>x. x \\<in> tangent_space p \\<Longrightarrow> g x \\<in> sub.tangent_space p\"\n    \"linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R) (*\\<^sub>R) g\"\n    \"\\<And>x. x \\<in> sub.tangent_space p \\<Longrightarrow> g (inclusion.push_forward x) = x\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> sub.tangent_space p \\<longrightarrow>\n     inclusion.push_forward x \\<in> tangent_space p \\<Longrightarrow>\n  \\<exists>g.\n     (\\<forall>x.\n         x \\<in> tangent_space p \\<longrightarrow>\n         g x \\<in> sub.tangent_space p) \\<and>\n     linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R)\n      (*\\<^sub>R) g \\<and>\n     (\\<forall>x\\<in>sub.tangent_space p. g (inclusion.push_forward x) = x)\n  inclusion.push_forward ` sub.tangent_space p \\<subseteq> tangent_space p\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>\\<And>x.\n                    x \\<in> tangent_space p \\<Longrightarrow>\n                    g x \\<in> sub.tangent_space p;\n         linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R)\n          (*\\<^sub>R) g;\n         \\<And>x.\n            x \\<in> sub.tangent_space p \\<Longrightarrow>\n            g (inclusion.push_forward x) = x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: subset_eq)"], ["proof (state)\nthis:\n  ?x3 \\<in> tangent_space p \\<Longrightarrow>\n  g ?x3 \\<in> sub.tangent_space p\n  linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R) (*\\<^sub>R)\n   g\n  ?x3 \\<in> sub.tangent_space p \\<Longrightarrow>\n  g (inclusion.push_forward ?x3) = ?x3\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "have inj_on_g: \"inj_on g (tangent_space p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on g (tangent_space p)", "using inj_on_push_forward_inclusion[OF \\<open>p \\<in> sub.carrier\\<close>] g"], ["proof (prove)\nusing this:\n  inj_on inclusion.push_forward (sub.tangent_space p)\n  ?x3 \\<in> tangent_space p \\<Longrightarrow>\n  g ?x3 \\<in> sub.tangent_space p\n  linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R) (*\\<^sub>R)\n   g\n  ?x3 \\<in> sub.tangent_space p \\<Longrightarrow>\n  g (inclusion.push_forward ?x3) = ?x3\n\ngoal (1 subgoal):\n 1. inj_on g (tangent_space p)", "apply (auto simp: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>x\\<in>sub.tangent_space p.\n                   \\<forall>y\\<in>sub.tangent_space p.\n                      inclusion.push_forward x =\n                      inclusion.push_forward y \\<longrightarrow>\n                      x = y;\n        \\<And>x.\n           x \\<in> tangent_space p \\<Longrightarrow>\n           g x \\<in> sub.tangent_space p;\n        linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R)\n         (*\\<^sub>R) g;\n        \\<And>x.\n           x \\<in> sub.tangent_space p \\<Longrightarrow>\n           g (inclusion.push_forward x) = x;\n        x \\<in> tangent_space p; y \\<in> tangent_space p; g x = g y\\<rbrakk>\n       \\<Longrightarrow> x = y", "by (metis (no_types, lifting) \\<open>inclusion.push_forward ` sub.tangent_space p \\<subseteq> tangent_space p\\<close>\n        imageE subset_antisym surj_on_push_forward_inclusion that(1))"], ["proof (state)\nthis:\n  inj_on g (tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "have \"dim (tangent_space p) = tangent_space.dim p (tangent_space p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = tangent_space.dim p (tangent_space p)", "using order_refl"], ["proof (prove)\nusing this:\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = tangent_space.dim p (tangent_space p)", "by (rule tangent_space.dim_eq[symmetric])"], ["proof (state)\nthis:\n  dim (tangent_space p) = tangent_space.dim p (tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "also"], ["proof (state)\nthis:\n  dim (tangent_space p) = tangent_space.dim p (tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "have \"\\<dots> = sub.tangent_space.dim p (g ` tangent_space p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tangent_space.dim p (tangent_space p) =\n    sub.tangent_space.dim p (g ` tangent_space p)", "apply (rule dim_image_eq[OF _ order_refl, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x.\n       x \\<in> tangent_space p \\<longrightarrow>\n       g x \\<in> sub.tangent_space p\n 2. linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R)\n     (*\\<^sub>R) g\n 3. inj_on g (module_on.span (*\\<^sub>R) (tangent_space p))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> tangent_space p \\<longrightarrow>\n       g x \\<in> sub.tangent_space p", "using g"], ["proof (prove)\nusing this:\n  ?x3 \\<in> tangent_space p \\<Longrightarrow>\n  g ?x3 \\<in> sub.tangent_space p\n  linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R) (*\\<^sub>R)\n   g\n  ?x3 \\<in> sub.tangent_space p \\<Longrightarrow>\n  g (inclusion.push_forward ?x3) = ?x3\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> tangent_space p \\<longrightarrow>\n       g x \\<in> sub.tangent_space p", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R)\n     (*\\<^sub>R) g\n 2. inj_on g (module_on.span (*\\<^sub>R) (tangent_space p))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R)\n     (*\\<^sub>R) g", "using g"], ["proof (prove)\nusing this:\n  ?x3 \\<in> tangent_space p \\<Longrightarrow>\n  g ?x3 \\<in> sub.tangent_space p\n  linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R) (*\\<^sub>R)\n   g\n  ?x3 \\<in> sub.tangent_space p \\<Longrightarrow>\n  g (inclusion.push_forward ?x3) = ?x3\n\ngoal (1 subgoal):\n 1. linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R)\n     (*\\<^sub>R) g", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on g (module_on.span (*\\<^sub>R) (tangent_space p))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on g (module_on.span (*\\<^sub>R) (tangent_space p))", "using inj_on_g"], ["proof (prove)\nusing this:\n  inj_on g (tangent_space p)\n\ngoal (1 subgoal):\n 1. inj_on g (module_on.span (*\\<^sub>R) (tangent_space p))", "by (auto simp: tangent_space.span_eq_real span_idem subspace_tangent_space)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  tangent_space.dim p (tangent_space p) =\n  sub.tangent_space.dim p (g ` tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "also"], ["proof (state)\nthis:\n  tangent_space.dim p (tangent_space p) =\n  sub.tangent_space.dim p (g ` tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "have \"g ` tangent_space p = sub.tangent_space p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g ` tangent_space p = sub.tangent_space p", "using g inj_on_g"], ["proof (prove)\nusing this:\n  ?x3 \\<in> tangent_space p \\<Longrightarrow>\n  g ?x3 \\<in> sub.tangent_space p\n  linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R) (*\\<^sub>R)\n   g\n  ?x3 \\<in> sub.tangent_space p \\<Longrightarrow>\n  g (inclusion.push_forward ?x3) = ?x3\n  inj_on g (tangent_space p)\n\ngoal (1 subgoal):\n 1. g ` tangent_space p = sub.tangent_space p", "using inj_on_push_forward_inclusion[OF \\<open>p \\<in> sub.carrier\\<close>] g"], ["proof (prove)\nusing this:\n  ?x3 \\<in> tangent_space p \\<Longrightarrow>\n  g ?x3 \\<in> sub.tangent_space p\n  linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R) (*\\<^sub>R)\n   g\n  ?x3 \\<in> sub.tangent_space p \\<Longrightarrow>\n  g (inclusion.push_forward ?x3) = ?x3\n  inj_on g (tangent_space p)\n  inj_on inclusion.push_forward (sub.tangent_space p)\n  ?x3 \\<in> tangent_space p \\<Longrightarrow>\n  g ?x3 \\<in> sub.tangent_space p\n  linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R) (*\\<^sub>R)\n   g\n  ?x3 \\<in> sub.tangent_space p \\<Longrightarrow>\n  g (inclusion.push_forward ?x3) = ?x3\n\ngoal (1 subgoal):\n 1. g ` tangent_space p = sub.tangent_space p", "apply (auto simp: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>tangent_space p.\n                   \\<forall>y\\<in>tangent_space p.\n                      g x = g y \\<longrightarrow> x = y;\n        \\<forall>x\\<in>sub.tangent_space p.\n           \\<forall>y\\<in>sub.tangent_space p.\n              inclusion.push_forward x =\n              inclusion.push_forward y \\<longrightarrow>\n              x = y;\n        \\<And>x.\n           x \\<in> tangent_space p \\<Longrightarrow>\n           g x \\<in> sub.tangent_space p;\n        linear_on (tangent_space p) (sub.tangent_space p) (*\\<^sub>R)\n         (*\\<^sub>R) g;\n        \\<And>x.\n           x \\<in> sub.tangent_space p \\<Longrightarrow>\n           g (inclusion.push_forward x) = x;\n        x \\<in> sub.tangent_space p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> g ` tangent_space p", "by (metis (no_types, lifting) \\<open>inclusion.push_forward ` sub.tangent_space p \\<subseteq> tangent_space p\\<close>\n        contra_subsetD image_eqI)"], ["proof (state)\nthis:\n  g ` tangent_space p = sub.tangent_space p\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "also"], ["proof (state)\nthis:\n  g ` tangent_space p = sub.tangent_space p\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "have \"sub.tangent_space.dim p \\<dots> = dim \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub.tangent_space.dim p (sub.tangent_space p) =\n    dim (sub.tangent_space p)", "using order_refl"], ["proof (prove)\nusing this:\n  ?x \\<le> ?x\n\ngoal (1 subgoal):\n 1. sub.tangent_space.dim p (sub.tangent_space p) =\n    dim (sub.tangent_space p)", "by (rule sub.tangent_space_dim_eq)"], ["proof (state)\nthis:\n  sub.tangent_space.dim p (sub.tangent_space p) = dim (sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "finally"], ["proof (chain)\npicking this:\n  dim (tangent_space p) = dim (sub.tangent_space p)", "show ?thesis"], ["proof (prove)\nusing this:\n  dim (tangent_space p) = dim (sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = dim (sub.tangent_space p)", "."], ["proof (state)\nthis:\n  dim (tangent_space p) = dim (sub.tangent_space p)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Directional derivatives\\<close>"], ["", "text \\<open>When the manifold is the Euclidean space, The Frechet derivative\n   at a in the direction of v is an element of the tangent space at a.\\<close>"], ["", "definition directional_derivative::\"enat \\<Rightarrow> 'a \\<Rightarrow> 'a::euclidean_space \\<Rightarrow>\n  ('a \\<Rightarrow> real) \\<Rightarrow> real\" where\n  \"directional_derivative k a v = restrict0 (manifold_eucl.diff_fun_space k) (\\<lambda>f. frechet_derivative f (at a) v)\""], ["", "lemma extensional0_directional_derivative:\n  \"extensional0 (manifold_eucl.diff_fun_space k) (directional_derivative k a v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extensional0 (manifold_eucl.diff_fun_space k)\n     (directional_derivative k a v)", "unfolding directional_derivative_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. extensional0 (manifold_eucl.diff_fun_space k)\n     (restrict0 (manifold_eucl.diff_fun_space k)\n       (\\<lambda>f. frechet_derivative f (at a) v))", "by simp"], ["", "lemma extensional0_directional_derivative_le:\n  \"extensional0 (manifold_eucl.diff_fun_space k) (directional_derivative k' a v)\"\n  if \"k \\<le> k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extensional0 (manifold_eucl.diff_fun_space k)\n     (directional_derivative k' a v)", "using that"], ["proof (prove)\nusing this:\n  k \\<le> k'\n\ngoal (1 subgoal):\n 1. extensional0 (manifold_eucl.diff_fun_space k)\n     (directional_derivative k' a v)", "unfolding directional_derivative_def"], ["proof (prove)\nusing this:\n  k \\<le> k'\n\ngoal (1 subgoal):\n 1. extensional0 (manifold_eucl.diff_fun_space k)\n     (restrict0 (manifold_eucl.diff_fun_space k')\n       (\\<lambda>f. frechet_derivative f (at a) v))", "by (auto simp: extensional0_def restrict0_def manifold_eucl.diff_fun_space_def\n      dest!: diff_fun.diff_fun_order_le[OF _ that])"], ["", "lemma directional_derivative_add[simp]: \"directional_derivative k a (x + y) = directional_derivative k a x + directional_derivative k a y\"\n  and directional_derivative_scaleR[simp]: \"directional_derivative k a (c *\\<^sub>R x) = c *\\<^sub>R directional_derivative k a x\"\n  if \"k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directional_derivative k a (x + y) =\n    directional_derivative k a x + directional_derivative k a y &&&\n    directional_derivative k a (c *\\<^sub>R x) =\n    c *\\<^sub>R directional_derivative k a x", "using that"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. directional_derivative k a (x + y) =\n    directional_derivative k a x + directional_derivative k a y &&&\n    directional_derivative k a (c *\\<^sub>R x) =\n    c *\\<^sub>R directional_derivative k a x", "by (auto simp: directional_derivative_def restrict0_def[abs_def] fun_eq_iff\n      differentiable_on_def linear_iff that\n      dest!: linear_frechet_derivative spec[where x=a] smooth_on_imp_differentiable_on)"], ["", "lemma linear_directional_derivative: \"k \\<noteq> 0 \\<Longrightarrow> linear (directional_derivative k a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> linear (directional_derivative k a)", "by unfold_locales simp_all"], ["", "lemma frechet_derivative_inner[simp]:\n  \"frechet_derivative (\\<lambda>x. x \\<bullet> j) (at a) = (\\<lambda>x. x \\<bullet> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frechet_derivative (\\<lambda>x. x \\<bullet> j) (at a) =\n    (\\<lambda>x. x \\<bullet> j)", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x \\<bullet> j) =\n    frechet_derivative (\\<lambda>x. x \\<bullet> j) (at a)", "apply (rule frechet_derivative_at)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. x \\<bullet> j) has_derivative (\\<lambda>x. x \\<bullet> j))\n     (at a)", "by (auto intro!: derivative_eq_intros)"], ["", "lemma smooth_on_inner_const[simp]: \"k-smooth_on UNIV (\\<lambda>x. x \\<bullet> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k-smooth_on UNIV (\\<lambda>x. x \\<bullet> j)", "by (auto intro!: smooth_on_inner)"], ["", "lemma directional_derivative_inner[simp]: \"directional_derivative k a x (\\<lambda>x. x \\<bullet> j) = x \\<bullet> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directional_derivative k a x (\\<lambda>x. x \\<bullet> j) = x \\<bullet> j", "unfolding directional_derivative_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict0 (manifold_eucl.diff_fun_space k)\n     (\\<lambda>f. frechet_derivative f (at a) x)\n     (\\<lambda>x. x \\<bullet> j) =\n    x \\<bullet> j", "by (auto simp: restrict0_def differentiable_on_def)"], ["", "lemma sum_apply: \"sum f X i = sum (\\<lambda>x. f x i) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f X i = (\\<Sum>x\\<in>X. f x i)", "by (induction rule: infinite_finite_induct) auto"], ["", "lemma inj_on_directional_derivative: \"inj_on (directional_derivative k a) S\" if \"k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (directional_derivative k a) S", "apply (rule inj_on_subset[OF _ subset_UNIV])"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (directional_derivative k a)", "unfolding linear_injective_0[OF linear_directional_derivative[OF that]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       directional_derivative k a x = 0 \\<longrightarrow> x = (0::'a)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. directional_derivative k a x = 0 \\<Longrightarrow> x = (0::'a)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. directional_derivative k a x = 0 \\<Longrightarrow> x = (0::'a)", "assume 0: \"directional_derivative k a v = 0\""], ["proof (state)\nthis:\n  directional_derivative k a v = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. directional_derivative k a x = 0 \\<Longrightarrow> x = (0::'a)", "interpret linear \"directional_derivative k a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear (directional_derivative k a)", "using that"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. linear (directional_derivative k a)", "by (rule linear_directional_derivative)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. directional_derivative k a x = 0 \\<Longrightarrow> x = (0::'a)", "show \"v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = (0::'a)", "proof (rule euclidean_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow> v \\<bullet> b = (0::'a) \\<bullet> b", "fix j::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow> v \\<bullet> b = (0::'a) \\<bullet> b", "assume \"j \\<in> Basis\""], ["proof (state)\nthis:\n  j \\<in> Basis\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow> v \\<bullet> b = (0::'a) \\<bullet> b", "have \"0 = directional_derivative k a v (\\<lambda>x. x \\<bullet> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = directional_derivative k a v (\\<lambda>x. x \\<bullet> j)", "using 0"], ["proof (prove)\nusing this:\n  directional_derivative k a v = 0\n\ngoal (1 subgoal):\n 1. 0 = directional_derivative k a v (\\<lambda>x. x \\<bullet> j)", "by simp"], ["proof (state)\nthis:\n  0 = directional_derivative k a v (\\<lambda>x. x \\<bullet> j)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow> v \\<bullet> b = (0::'a) \\<bullet> b", "also"], ["proof (state)\nthis:\n  0 = directional_derivative k a v (\\<lambda>x. x \\<bullet> j)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow> v \\<bullet> b = (0::'a) \\<bullet> b", "have \"\\<dots> = directional_derivative k a (\\<Sum>i\\<in>Basis. (v \\<bullet> i) *\\<^sub>R i) (\\<lambda>x. x \\<bullet> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directional_derivative k a v (\\<lambda>x. x \\<bullet> j) =\n    directional_derivative k a\n     (\\<Sum>i\\<in>Basis. (v \\<bullet> i) *\\<^sub>R i)\n     (\\<lambda>x. x \\<bullet> j)", "by (simp add: euclidean_representation)"], ["proof (state)\nthis:\n  directional_derivative k a v (\\<lambda>x. x \\<bullet> j) =\n  directional_derivative k a\n   (\\<Sum>i\\<in>Basis. (v \\<bullet> i) *\\<^sub>R i)\n   (\\<lambda>x. x \\<bullet> j)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow> v \\<bullet> b = (0::'a) \\<bullet> b", "also"], ["proof (state)\nthis:\n  directional_derivative k a v (\\<lambda>x. x \\<bullet> j) =\n  directional_derivative k a\n   (\\<Sum>i\\<in>Basis. (v \\<bullet> i) *\\<^sub>R i)\n   (\\<lambda>x. x \\<bullet> j)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow> v \\<bullet> b = (0::'a) \\<bullet> b", "have \"\\<dots> = (\\<Sum>i\\<in>Basis. (v \\<bullet> i) * frechet_derivative (\\<lambda>x. x \\<bullet> j) (at a) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directional_derivative k a\n     (\\<Sum>i\\<in>Basis. (v \\<bullet> i) *\\<^sub>R i)\n     (\\<lambda>x. x \\<bullet> j) =\n    (\\<Sum>i\\<in>Basis.\n       v \\<bullet> i *\n       frechet_derivative (\\<lambda>x. x \\<bullet> j) (at a) i)", "unfolding sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>aa\\<in>Basis.\n       directional_derivative k a ((v \\<bullet> aa) *\\<^sub>R aa))\n     (\\<lambda>x. x \\<bullet> j) =\n    (\\<Sum>i\\<in>Basis.\n       v \\<bullet> i *\n       frechet_derivative (\\<lambda>x. x \\<bullet> j) (at a) i)", "by (auto simp: sum_apply intro!: sum.cong)"], ["proof (state)\nthis:\n  directional_derivative k a\n   (\\<Sum>i\\<in>Basis. (v \\<bullet> i) *\\<^sub>R i)\n   (\\<lambda>x. x \\<bullet> j) =\n  (\\<Sum>i\\<in>Basis.\n     v \\<bullet> i *\n     frechet_derivative (\\<lambda>x. x \\<bullet> j) (at a) i)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow> v \\<bullet> b = (0::'a) \\<bullet> b", "also"], ["proof (state)\nthis:\n  directional_derivative k a\n   (\\<Sum>i\\<in>Basis. (v \\<bullet> i) *\\<^sub>R i)\n   (\\<lambda>x. x \\<bullet> j) =\n  (\\<Sum>i\\<in>Basis.\n     v \\<bullet> i *\n     frechet_derivative (\\<lambda>x. x \\<bullet> j) (at a) i)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow> v \\<bullet> b = (0::'a) \\<bullet> b", "have \"\\<dots> = (v \\<bullet> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>Basis.\n       v \\<bullet> i *\n       frechet_derivative (\\<lambda>x. x \\<bullet> j) (at a) i) =\n    v \\<bullet> j", "using \\<open>j \\<in> Basis\\<close>"], ["proof (prove)\nusing this:\n  j \\<in> Basis\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>Basis.\n       v \\<bullet> i *\n       frechet_derivative (\\<lambda>x. x \\<bullet> j) (at a) i) =\n    v \\<bullet> j", "by (auto simp: inner_Basis if_distrib cong: if_cong)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>Basis.\n     v \\<bullet> i *\n     frechet_derivative (\\<lambda>x. x \\<bullet> j) (at a) i) =\n  v \\<bullet> j\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> Basis \\<Longrightarrow> v \\<bullet> b = (0::'a) \\<bullet> b", "finally"], ["proof (chain)\npicking this:\n  0 = v \\<bullet> j", "show \"v \\<bullet> j = 0 \\<bullet> j\""], ["proof (prove)\nusing this:\n  0 = v \\<bullet> j\n\ngoal (1 subgoal):\n 1. v \\<bullet> j = (0::'a) \\<bullet> j", "by simp"], ["proof (state)\nthis:\n  v \\<bullet> j = (0::'a) \\<bullet> j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma directional_derivative_eq_frechet_derivative:\n  \"directional_derivative k a v f = frechet_derivative f (at a) v\"\n  if \"k-smooth_on UNIV f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directional_derivative k a v f = frechet_derivative f (at a) v", "using that"], ["proof (prove)\nusing this:\n  k-smooth_on UNIV f\n\ngoal (1 subgoal):\n 1. directional_derivative k a v f = frechet_derivative f (at a) v", "by (auto simp: directional_derivative_def)"], ["", "lemma directional_derivative_linear_on_diff_fun_space:\n  \"k \\<noteq> 0 \\<Longrightarrow> manifold_eucl.linear_diff_fun k (directional_derivative k a x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    linear_on (manifold_eucl.diff_fun_space k) UNIV (*\\<^sub>R) (*\\<^sub>R)\n     (directional_derivative k a x)", "by unfold_locales\n    (auto simp: directional_derivative_eq_frechet_derivative differentiable_onD\n      smooth_on_add_fun smooth_on_scaleR_fun\n      frechet_derivative_plus_fun frechet_derivative_scaleR_fun)"], ["", "lemma directional_derivative_is_derivation:\n  \"directional_derivative k a x (f * g) = f a * directional_derivative k a x g + g a * directional_derivative k a x f\"\n  if \"f \\<in> manifold_eucl.diff_fun_space k\" \"g \\<in> manifold_eucl.diff_fun_space k\" \"k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directional_derivative k a x (f * g) =\n    f a * directional_derivative k a x g +\n    g a * directional_derivative k a x f", "using that"], ["proof (prove)\nusing this:\n  f \\<in> manifold_eucl.diff_fun_space k\n  g \\<in> manifold_eucl.diff_fun_space k\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. directional_derivative k a x (f * g) =\n    f a * directional_derivative k a x g +\n    g a * directional_derivative k a x f", "by (auto simp: directional_derivative_eq_frechet_derivative smooth_on_times_fun\n      frechet_derivative_times_fun differentiable_onD)"], ["", "lemma directional_derivative_in_tangent_space[intro, simp]:\n  \"k \\<noteq> 0 \\<Longrightarrow> directional_derivative k a x \\<in> manifold_eucl.tangent_space k a\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    directional_derivative k a x \\<in> manifold_eucl.tangent_space k a", "apply (rule manifold_eucl.tangent_spaceI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    extensional0 (manifold_eucl.diff_fun_space k)\n     (directional_derivative k a x)\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    linear_on (manifold_eucl.diff_fun_space k) UNIV (*\\<^sub>R) (*\\<^sub>R)\n     (directional_derivative k a x)\n 3. \\<And>f g.\n       \\<lbrakk>k \\<noteq> 0; f \\<in> manifold_eucl.diff_fun_space k;\n        g \\<in> manifold_eucl.diff_fun_space k\\<rbrakk>\n       \\<Longrightarrow> directional_derivative k a x (f * g) =\n                         f a * directional_derivative k a x g +\n                         g a * directional_derivative k a x f", "apply (rule extensional0_directional_derivative)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    linear_on (manifold_eucl.diff_fun_space k) UNIV (*\\<^sub>R) (*\\<^sub>R)\n     (directional_derivative k a x)\n 2. \\<And>f g.\n       \\<lbrakk>k \\<noteq> 0; f \\<in> manifold_eucl.diff_fun_space k;\n        g \\<in> manifold_eucl.diff_fun_space k\\<rbrakk>\n       \\<Longrightarrow> directional_derivative k a x (f * g) =\n                         f a * directional_derivative k a x g +\n                         g a * directional_derivative k a x f", "apply (rule directional_derivative_linear_on_diff_fun_space)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k \\<noteq> 0 \\<Longrightarrow> k \\<noteq> 0\n 2. \\<And>f g.\n       \\<lbrakk>k \\<noteq> 0; f \\<in> manifold_eucl.diff_fun_space k;\n        g \\<in> manifold_eucl.diff_fun_space k\\<rbrakk>\n       \\<Longrightarrow> directional_derivative k a x (f * g) =\n                         f a * directional_derivative k a x g +\n                         g a * directional_derivative k a x f", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>k \\<noteq> 0; f \\<in> manifold_eucl.diff_fun_space k;\n        g \\<in> manifold_eucl.diff_fun_space k\\<rbrakk>\n       \\<Longrightarrow> directional_derivative k a x (f * g) =\n                         f a * directional_derivative k a x g +\n                         g a * directional_derivative k a x f", "by (rule directional_derivative_is_derivation)"], ["", "context c_manifold begin"], ["", "lemma is_derivation_order_le:\n  \"is_derivation X p\"\n  if \"l \\<le> k\" \"c_manifold.is_derivation charts l X p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_derivation X p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_derivation X p", "interpret l: c_manifold charts l"], ["proof (prove)\ngoal (1 subgoal):\n 1. c_manifold charts l", "by (rule c_manifold_order_le) fact"], ["proof (state)\ngoal (1 subgoal):\n 1. is_derivation X p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_derivation X p", "using that(2) subspace_diff_fun_space"], ["proof (prove)\nusing this:\n  l.is_derivation X p\n  subspace diff_fun_space\n\ngoal (1 subgoal):\n 1. is_derivation X p", "using diff_fun_space_order_le[OF that(1)]"], ["proof (prove)\nusing this:\n  l.is_derivation X p\n  subspace diff_fun_space\n  diff_fun_space \\<subseteq> l.diff_fun_space\n\ngoal (1 subgoal):\n 1. is_derivation X p", "by (auto simp: is_derivation_def l.is_derivation_def linear_on_def module_hom_on_def\n        module_hom_on_axioms_def module_on_def subspace_def\n        subset_iff)"], ["proof (state)\nthis:\n  is_derivation X p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma smooth_on_imp_differentiable_on: \"f differentiable_on S\"\n  if \"k-smooth_on S f\" \"k > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f differentiable_on S", "using that"], ["proof (prove)\nusing this:\n  k-smooth_on S f\n  0 < k\n\ngoal (1 subgoal):\n 1. f differentiable_on S", "by auto"], ["", "text\\<open>\n  Key result: for the Euclidean space, the Frechet derivatives are the\n  only elements of the tangent space.\n\n  This result only holds for smooth manifolds, not for \\<open>C^k\\<close> differentiable\n  manifolds. Smoothness is used at a key point in the proof.\n\\<close>"], ["", "lemma surj_directional_derivative:\n  \"range (directional_derivative k a) = manifold_eucl.tangent_space k a\"\n  if \"k = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (directional_derivative k a) = manifold_eucl.tangent_space k a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. range (directional_derivative k a) = manifold_eucl.tangent_space k a", "have \"k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  k = \\<infinity>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. range (directional_derivative k a) = manifold_eucl.tangent_space k a", "have \"X \\<in> range (directional_derivative k a)\" if \"X \\<in> manifold_eucl.tangent_space k a\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> range (directional_derivative k a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<in> range (directional_derivative k a)", "define v where \"v i = X (\\<lambda>x. (x - a) \\<bullet> i)\" for i"], ["proof (state)\nthis:\n  v ?i = X (\\<lambda>x. (x - a) \\<bullet> ?i)\n\ngoal (1 subgoal):\n 1. X \\<in> range (directional_derivative k a)", "have linear_X: \"manifold_eucl.linear_diff_fun k X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_on (manifold_eucl.diff_fun_space k) UNIV (*\\<^sub>R) (*\\<^sub>R)\n     X", "by (rule manifold_eucl.tangent_space_linear_on) fact"], ["proof (state)\nthis:\n  linear_on (manifold_eucl.diff_fun_space k) UNIV (*\\<^sub>R) (*\\<^sub>R) X\n\ngoal (1 subgoal):\n 1. X \\<in> range (directional_derivative k a)", "note X_sum = manifold_eucl.diff_fun_space.linear_sum'[OF _ _ linear_X]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x.\n              x \\<in> manifold_eucl.diff_fun_space k \\<longrightarrow>\n              X x \\<in> UNIV;\n   \\<forall>x.\n      x \\<in> ?S \\<longrightarrow>\n      ?g x \\<in> manifold_eucl.diff_fun_space k\\<rbrakk>\n  \\<Longrightarrow> X (sum ?g ?S) = (\\<Sum>a\\<in>?S. X (?g a))\n\ngoal (1 subgoal):\n 1. X \\<in> range (directional_derivative k a)", "note X_add = manifold_eucl.diff_fun_space.linear_add[OF _ _ _ linear_X]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x.\n              x \\<in> manifold_eucl.diff_fun_space k \\<longrightarrow>\n              X x \\<in> UNIV;\n   ?b1.0 \\<in> manifold_eucl.diff_fun_space k;\n   ?b2.0 \\<in> manifold_eucl.diff_fun_space k\\<rbrakk>\n  \\<Longrightarrow> X (?b1.0 + ?b2.0) = X ?b1.0 + X ?b2.0\n\ngoal (1 subgoal):\n 1. X \\<in> range (directional_derivative k a)", "note X_scale = manifold_eucl.diff_fun_space.linear_scale[OF _ _ linear_X]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x.\n              x \\<in> manifold_eucl.diff_fun_space k \\<longrightarrow>\n              X x \\<in> UNIV;\n   ?b \\<in> manifold_eucl.diff_fun_space k\\<rbrakk>\n  \\<Longrightarrow> X (?r *\\<^sub>R ?b) = ?r *\\<^sub>R X ?b\n\ngoal (1 subgoal):\n 1. X \\<in> range (directional_derivative k a)", "have \"X = directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i)", "apply (rule ext_extensional0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. extensional0 ?S X\n 2. extensional0 ?S\n     (directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i))\n 3. \\<And>x.\n       x \\<in> ?S \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "using that"], ["proof (prove)\nusing this:\n  X \\<in> manifold_eucl.tangent_space k a\n\ngoal (3 subgoals):\n 1. extensional0 ?S X\n 2. extensional0 ?S\n     (directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i))\n 3. \\<And>x.\n       x \\<in> ?S \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "apply (rule manifold_eucl.tangent_space_restrict)"], ["proof (prove)\ngoal (2 subgoals):\n 1. extensional0 (manifold_eucl.diff_fun_space k)\n     (directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i))\n 2. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "apply (rule extensional0_directional_derivative)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "fix f::\"'a \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "assume f: \"f \\<in> manifold_eucl.diff_fun_space k\""], ["proof (state)\nthis:\n  f \\<in> manifold_eucl.diff_fun_space k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "then"], ["proof (chain)\npicking this:\n  f \\<in> manifold_eucl.diff_fun_space k", "have \"smooth_on UNIV f\""], ["proof (prove)\nusing this:\n  f \\<in> manifold_eucl.diff_fun_space k\n\ngoal (1 subgoal):\n 1. smooth_on UNIV f", "using \\<open>k = \\<infinity>\\<close>"], ["proof (prove)\nusing this:\n  f \\<in> manifold_eucl.diff_fun_space k\n  k = \\<infinity>\n\ngoal (1 subgoal):\n 1. smooth_on UNIV f", "by simp"], ["proof (state)\nthis:\n  smooth_on UNIV f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "from smooth_on_Taylor2E[OF this, of a]"], ["proof (chain)\npicking this:\n  (\\<And>g.\n      \\<lbrakk>\\<And>Y.\n                  f Y =\n                  f a + frechet_derivative f (at a) (Y - a) +\n                  (\\<Sum>i\\<in>Basis.\n                     \\<Sum>j\\<in>Basis.\n                       (Y - a) \\<bullet> j * ((Y - a) \\<bullet> i) *\n                       g i j Y);\n       \\<And>i j.\n          \\<lbrakk>i \\<in> Basis; j \\<in> Basis\\<rbrakk>\n          \\<Longrightarrow> smooth_on UNIV (g i j)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain g where f_exp:\n        \"\\<And>x. f x = f a + frechet_derivative f (at a) (x - a) +\n          (\\<Sum>i\\<in>Basis. \\<Sum>j\\<in>Basis. (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x)\"\n        and g: \"\\<And>i j. i \\<in> Basis \\<Longrightarrow> j \\<in> Basis \\<Longrightarrow> smooth_on UNIV (g i j)\""], ["proof (prove)\nusing this:\n  (\\<And>g.\n      \\<lbrakk>\\<And>Y.\n                  f Y =\n                  f a + frechet_derivative f (at a) (Y - a) +\n                  (\\<Sum>i\\<in>Basis.\n                     \\<Sum>j\\<in>Basis.\n                       (Y - a) \\<bullet> j * ((Y - a) \\<bullet> i) *\n                       g i j Y);\n       \\<And>i j.\n          \\<lbrakk>i \\<in> Basis; j \\<in> Basis\\<rbrakk>\n          \\<Longrightarrow> smooth_on UNIV (g i j)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>\\<And>x.\n                    f x =\n                    f a + frechet_derivative f (at a) (x - a) +\n                    (\\<Sum>i\\<in>Basis.\n                       \\<Sum>j\\<in>Basis.\n                         (x - a) \\<bullet> j * ((x - a) \\<bullet> i) *\n                         g i j x);\n         \\<And>i j.\n            \\<lbrakk>i \\<in> Basis; j \\<in> Basis\\<rbrakk>\n            \\<Longrightarrow> smooth_on UNIV (g i j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f ?x =\n  f a + frechet_derivative f (at a) (?x - a) +\n  (\\<Sum>i\\<in>Basis.\n     \\<Sum>j\\<in>Basis.\n       (?x - a) \\<bullet> j * ((?x - a) \\<bullet> i) * g i j ?x)\n  \\<lbrakk>?i \\<in> Basis; ?j \\<in> Basis\\<rbrakk>\n  \\<Longrightarrow> smooth_on UNIV (g ?i ?j)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "note [simp] = \\<open>k = _\\<close>"], ["proof (state)\nthis:\n  k = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "have *: \"X (\\<lambda>x. \\<Sum>i\\<in>Basis. \\<Sum>j\\<in>Basis. (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (\\<lambda>x.\n          \\<Sum>i\\<in>Basis.\n            \\<Sum>j\\<in>Basis.\n              (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x) =\n    0", "thm X_sum[unfolded sum_fun_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. X (\\<lambda>x.\n          \\<Sum>i\\<in>Basis.\n            \\<Sum>j\\<in>Basis.\n              (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x) =\n    0", "apply (subst X_sum[unfolded sum_fun_def], safe)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x \\<in> UNIV\n 2. \\<And>x.\n       x \\<in> Basis \\<Longrightarrow>\n       (\\<lambda>xa.\n           \\<Sum>j\\<in>Basis.\n             (xa - a) \\<bullet> j * ((xa - a) \\<bullet> x) * g x j xa)\n       \\<in> manifold_eucl.diff_fun_space k\n 3. (\\<Sum>aa\\<in>Basis.\n       X (\\<lambda>x.\n             \\<Sum>j\\<in>Basis.\n               (x - a) \\<bullet> j * ((x - a) \\<bullet> aa) * g aa j x)) =\n    0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n    X x_ \\<in> UNIV", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Basis \\<Longrightarrow>\n       (\\<lambda>xa.\n           \\<Sum>j\\<in>Basis.\n             (xa - a) \\<bullet> j * ((xa - a) \\<bullet> x) * g x j xa)\n       \\<in> manifold_eucl.diff_fun_space k\n 2. (\\<Sum>aa\\<in>Basis.\n       X (\\<lambda>x.\n             \\<Sum>j\\<in>Basis.\n               (x - a) \\<bullet> j * ((x - a) \\<bullet> aa) * g aa j x)) =\n    0", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> Basis \\<Longrightarrow>\n    (\\<lambda>x.\n        \\<Sum>j\\<in>Basis.\n          (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x)\n    \\<in> manifold_eucl.diff_fun_space k", "by (auto intro!: smooth_on_sum smooth_on_mult smooth_on_inner smooth_on_minus simp: g)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>aa\\<in>Basis.\n       X (\\<lambda>x.\n             \\<Sum>j\\<in>Basis.\n               (x - a) \\<bullet> j * ((x - a) \\<bullet> aa) * g aa j x)) =\n    0", "apply (intro sum.neutral ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Basis \\<Longrightarrow>\n       X (\\<lambda>xa.\n             \\<Sum>j\\<in>Basis.\n               (xa - a) \\<bullet> j * ((xa - a) \\<bullet> x) * g x j xa) =\n       0", "apply (subst X_sum[unfolded sum_fun_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> Basis \\<Longrightarrow>\n       \\<forall>x.\n          x \\<in> manifold_eucl.diff_fun_space k \\<longrightarrow>\n          X x \\<in> UNIV\n 2. \\<And>x.\n       x \\<in> Basis \\<Longrightarrow>\n       \\<forall>xa.\n          xa \\<in> Basis \\<longrightarrow>\n          (\\<lambda>xb.\n              (xb - a) \\<bullet> xa * ((xb - a) \\<bullet> x) * g x xa xb)\n          \\<in> manifold_eucl.diff_fun_space k\n 3. \\<And>x.\n       x \\<in> Basis \\<Longrightarrow>\n       (\\<Sum>aa\\<in>Basis.\n          X (\\<lambda>xa.\n                (xa - a) \\<bullet> aa * ((xa - a) \\<bullet> x) *\n                g x aa xa)) =\n       0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> Basis \\<Longrightarrow>\n    \\<forall>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<longrightarrow>\n       X x \\<in> UNIV", "by (auto intro!: smooth_on_mult smooth_on_inner smooth_on_minus g)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Basis \\<Longrightarrow>\n       \\<forall>xa.\n          xa \\<in> Basis \\<longrightarrow>\n          (\\<lambda>xb.\n              (xb - a) \\<bullet> xa * ((xb - a) \\<bullet> x) * g x xa xb)\n          \\<in> manifold_eucl.diff_fun_space k\n 2. \\<And>x.\n       x \\<in> Basis \\<Longrightarrow>\n       (\\<Sum>aa\\<in>Basis.\n          X (\\<lambda>xa.\n                (xa - a) \\<bullet> aa * ((xa - a) \\<bullet> x) *\n                g x aa xa)) =\n       0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> Basis \\<Longrightarrow>\n    \\<forall>xa.\n       xa \\<in> Basis \\<longrightarrow>\n       (\\<lambda>xb.\n           (xb - a) \\<bullet> xa * ((xb - a) \\<bullet> x_) * g x_ xa xb)\n       \\<in> manifold_eucl.diff_fun_space k", "by (auto intro!: smooth_on_mult smooth_on_inner smooth_on_minus g)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Basis \\<Longrightarrow>\n       (\\<Sum>aa\\<in>Basis.\n          X (\\<lambda>xa.\n                (xa - a) \\<bullet> aa * ((xa - a) \\<bullet> x) *\n                g x aa xa)) =\n       0", "proof (intro sum.neutral ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> Basis; xa \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> X (\\<lambda>xb.\n                               (xb - a) \\<bullet> xa *\n                               ((xb - a) \\<bullet> x) *\n                               g x xa xb) =\n                         0", "fix i j::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> Basis; xa \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> X (\\<lambda>xb.\n                               (xb - a) \\<bullet> xa *\n                               ((xb - a) \\<bullet> x) *\n                               g x xa xb) =\n                         0", "assume ij: \"i \\<in> Basis\" \"j \\<in> Basis\""], ["proof (state)\nthis:\n  i \\<in> Basis\n  j \\<in> Basis\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> Basis; xa \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> X (\\<lambda>xb.\n                               (xb - a) \\<bullet> xa *\n                               ((xb - a) \\<bullet> x) *\n                               g x xa xb) =\n                         0", "have \"X (\\<lambda>xb. (xb - a) \\<bullet> j * ((xb - a) \\<bullet> i) * g i j xb) =\n          X ((\\<lambda>xb. (xb - a) \\<bullet> j) * (\\<lambda>xb. ((xb - a) \\<bullet> i) * g i j xb))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (\\<lambda>xb.\n          (xb - a) \\<bullet> j * ((xb - a) \\<bullet> i) * g i j xb) =\n    X ((\\<lambda>xb. (xb - a) \\<bullet> j) *\n       (\\<lambda>xb. (xb - a) \\<bullet> i * g i j xb))", "by (auto simp: times_fun_def ac_simps)"], ["proof (state)\nthis:\n  X (\\<lambda>xb.\n        (xb - a) \\<bullet> j * ((xb - a) \\<bullet> i) * g i j xb) =\n  X ((\\<lambda>xb. (xb - a) \\<bullet> j) *\n     (\\<lambda>xb. (xb - a) \\<bullet> i * g i j xb))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> Basis; xa \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> X (\\<lambda>xb.\n                               (xb - a) \\<bullet> xa *\n                               ((xb - a) \\<bullet> x) *\n                               g x xa xb) =\n                         0", "also"], ["proof (state)\nthis:\n  X (\\<lambda>xb.\n        (xb - a) \\<bullet> j * ((xb - a) \\<bullet> i) * g i j xb) =\n  X ((\\<lambda>xb. (xb - a) \\<bullet> j) *\n     (\\<lambda>xb. (xb - a) \\<bullet> i * g i j xb))\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> Basis; xa \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> X (\\<lambda>xb.\n                               (xb - a) \\<bullet> xa *\n                               ((xb - a) \\<bullet> x) *\n                               g x xa xb) =\n                         0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X ((\\<lambda>xb. (xb - a) \\<bullet> j) *\n       (\\<lambda>xb. (xb - a) \\<bullet> i * g i j xb)) =\n    0", "apply (rule manifold_eucl.derivation_times_eq_zeroI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. X \\<in> manifold_eucl.tangent_space ?k ?p\n 2. (\\<lambda>b. (b - a) \\<bullet> j) \\<in> manifold_eucl.diff_fun_space ?k\n 3. (\\<lambda>b. (b - a) \\<bullet> i * g i j b)\n    \\<in> manifold_eucl.diff_fun_space ?k\n 4. (?p - a) \\<bullet> j = 0\n 5. (?p - a) \\<bullet> i * g i j ?p = 0", "apply fact"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<lambda>b. (b - a) \\<bullet> j) \\<in> manifold_eucl.diff_fun_space k\n 2. (\\<lambda>b. (b - a) \\<bullet> i * g i j b)\n    \\<in> manifold_eucl.diff_fun_space k\n 3. (a - a) \\<bullet> j = 0\n 4. (a - a) \\<bullet> i * g i j a = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. (b - a) \\<bullet> j) \\<in> manifold_eucl.diff_fun_space k", "by (auto intro!: smooth_on_sum smooth_on_mult smooth_on_inner smooth_on_minus)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>b. (b - a) \\<bullet> i * g i j b)\n    \\<in> manifold_eucl.diff_fun_space k\n 2. (a - a) \\<bullet> j = 0\n 3. (a - a) \\<bullet> i * g i j a = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. (b - a) \\<bullet> i * g i j b)\n    \\<in> manifold_eucl.diff_fun_space k", "by (auto intro!: smooth_on_mult smooth_on_inner smooth_on_minus g ij)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (a - a) \\<bullet> j = 0\n 2. (a - a) \\<bullet> i * g i j a = 0", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  X ((\\<lambda>xb. (xb - a) \\<bullet> j) *\n     (\\<lambda>xb. (xb - a) \\<bullet> i * g i j xb)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> Basis; xa \\<in> Basis\\<rbrakk>\n       \\<Longrightarrow> X (\\<lambda>xb.\n                               (xb - a) \\<bullet> xa *\n                               ((xb - a) \\<bullet> x) *\n                               g x xa xb) =\n                         0", "finally"], ["proof (chain)\npicking this:\n  X (\\<lambda>xb.\n        (xb - a) \\<bullet> j * ((xb - a) \\<bullet> i) * g i j xb) =\n  0", "show \"X (\\<lambda>xb. (xb - a) \\<bullet> j * ((xb - a) \\<bullet> i) * g i j xb) = 0\""], ["proof (prove)\nusing this:\n  X (\\<lambda>xb.\n        (xb - a) \\<bullet> j * ((xb - a) \\<bullet> i) * g i j xb) =\n  0\n\ngoal (1 subgoal):\n 1. X (\\<lambda>xb.\n          (xb - a) \\<bullet> j * ((xb - a) \\<bullet> i) * g i j xb) =\n    0", "by simp"], ["proof (state)\nthis:\n  X (\\<lambda>xb.\n        (xb - a) \\<bullet> j * ((xb - a) \\<bullet> i) * g i j xb) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  X (\\<lambda>x.\n        \\<Sum>i\\<in>Basis.\n          \\<Sum>j\\<in>Basis.\n            (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "from f"], ["proof (chain)\npicking this:\n  f \\<in> manifold_eucl.diff_fun_space k", "have \"smooth_on UNIV f\""], ["proof (prove)\nusing this:\n  f \\<in> manifold_eucl.diff_fun_space k\n\ngoal (1 subgoal):\n 1. smooth_on UNIV f", "by (auto )"], ["proof (state)\nthis:\n  smooth_on UNIV f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "have \"f differentiable at a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f differentiable at a", "apply (rule differentiable_onD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. f differentiable_on UNIV\n 2. a \\<in> UNIV", "apply (rule smooth_on_imp_differentiable_on)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?k3-smooth_on UNIV f\n 2. 0 < ?k3\n 3. a \\<in> UNIV", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < \\<infinity>\n 2. a \\<in> UNIV", "by auto"], ["proof (state)\nthis:\n  f differentiable at a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "interpret Df: linear \"frechet_derivative f (at a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear (frechet_derivative f (at a))", "apply (rule linear_frechet_derivative)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f differentiable at a", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "have X_mult_right: \"k-smooth_on UNIV xx \\<Longrightarrow> X (\\<lambda>x. xx x * cc) = X xx * cc\" for xx cc"], ["proof (prove)\ngoal (1 subgoal):\n 1. k-smooth_on UNIV xx \\<Longrightarrow>\n    X (\\<lambda>x. xx x * cc) = X xx * cc", "using X_scale[unfolded scaleR_fun_def, simplified, of xx cc]"], ["proof (prove)\nusing this:\n  smooth_on UNIV xx \\<Longrightarrow> X (\\<lambda>x. cc * xx x) = cc * X xx\n\ngoal (1 subgoal):\n 1. k-smooth_on UNIV xx \\<Longrightarrow>\n    X (\\<lambda>x. xx x * cc) = X xx * cc", "by (auto simp: ac_simps)"], ["proof (state)\nthis:\n  k-smooth_on UNIV ?xx \\<Longrightarrow>\n  X (\\<lambda>x. ?xx x * ?cc) = X ?xx * ?cc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "have blf: \"bounded_linear (frechet_derivative f (at a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear (frechet_derivative f (at a))", "apply (rule has_derivative_bounded_linear)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f has_derivative frechet_derivative f (at a)) ?F", "apply (rule frechet_derivative_worksI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. f differentiable at a", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bounded_linear (frechet_derivative f (at a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "note smooth_on_frechet = smooth_on_compose[OF bounded_linear.smooth_on[OF blf], unfolded o_def, OF _ _ open_UNIV subset_UNIV]"], ["proof (state)\nthis:\n  \\<lbrakk>?k-smooth_on ?S ?g; open ?S\\<rbrakk>\n  \\<Longrightarrow> ?k-smooth_on ?S\n                     (\\<lambda>x. frechet_derivative f (at a) (?g x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "have **: \"X (\\<lambda>x. frechet_derivative f (at a) (x - a)) = frechet_derivative f (at a) (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X (\\<lambda>x. frechet_derivative f (at a) (x - a)) =\n    frechet_derivative f (at a) (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i)", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. X (\\<lambda>x. frechet_derivative f (at a) (x - a)) =\n    frechet_derivative f (at a)\n     (\\<Sum>i\\<in>Basis. X (\\<lambda>x. (x - a) \\<bullet> i) *\\<^sub>R i)", "apply (subst frechet_derivative_componentwise)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. f differentiable at a\n 2. X (\\<lambda>x.\n          \\<Sum>i\\<in>Basis.\n            (x - a) \\<bullet> i * frechet_derivative f (at a) i) =\n    frechet_derivative f (at a)\n     (\\<Sum>i\\<in>Basis. X (\\<lambda>x. (x - a) \\<bullet> i) *\\<^sub>R i)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. f differentiable at a", "by fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. X (\\<lambda>x.\n          \\<Sum>i\\<in>Basis.\n            (x - a) \\<bullet> i * frechet_derivative f (at a) i) =\n    frechet_derivative f (at a)\n     (\\<Sum>i\\<in>Basis. X (\\<lambda>x. (x - a) \\<bullet> i) *\\<^sub>R i)", "apply (subst X_sum[unfolded sum_fun_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<longrightarrow>\n       X x \\<in> UNIV\n 2. \\<forall>x.\n       x \\<in> Basis \\<longrightarrow>\n       (\\<lambda>xa. (xa - a) \\<bullet> x * frechet_derivative f (at a) x)\n       \\<in> manifold_eucl.diff_fun_space k\n 3. (\\<Sum>aa\\<in>Basis.\n       X (\\<lambda>x.\n             (x - a) \\<bullet> aa * frechet_derivative f (at a) aa)) =\n    frechet_derivative f (at a)\n     (\\<Sum>i\\<in>Basis. X (\\<lambda>x. (x - a) \\<bullet> i) *\\<^sub>R i)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<longrightarrow>\n       X x \\<in> UNIV", "by (auto intro!: smooth_on_sum smooth_on_mult smooth_on_inner smooth_on_minus)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       x \\<in> Basis \\<longrightarrow>\n       (\\<lambda>xa. (xa - a) \\<bullet> x * frechet_derivative f (at a) x)\n       \\<in> manifold_eucl.diff_fun_space k\n 2. (\\<Sum>aa\\<in>Basis.\n       X (\\<lambda>x.\n             (x - a) \\<bullet> aa * frechet_derivative f (at a) aa)) =\n    frechet_derivative f (at a)\n     (\\<Sum>i\\<in>Basis. X (\\<lambda>x. (x - a) \\<bullet> i) *\\<^sub>R i)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> Basis \\<longrightarrow>\n       (\\<lambda>xa. (xa - a) \\<bullet> x * frechet_derivative f (at a) x)\n       \\<in> manifold_eucl.diff_fun_space k", "by (auto intro!: smooth_on_frechet smooth_on_minus smooth_on_mult smooth_on_inner)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>aa\\<in>Basis.\n       X (\\<lambda>x.\n             (x - a) \\<bullet> aa * frechet_derivative f (at a) aa)) =\n    frechet_derivative f (at a)\n     (\\<Sum>i\\<in>Basis. X (\\<lambda>x. (x - a) \\<bullet> i) *\\<^sub>R i)", "apply (subst X_mult_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa. k-smooth_on UNIV (\\<lambda>x. (x - a) \\<bullet> aa)\n 2. (\\<Sum>aa\\<in>Basis.\n       X (\\<lambda>x. (x - a) \\<bullet> aa) *\n       frechet_derivative f (at a) aa) =\n    frechet_derivative f (at a)\n     (\\<Sum>i\\<in>Basis. X (\\<lambda>x. (x - a) \\<bullet> i) *\\<^sub>R i)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. k-smooth_on UNIV (\\<lambda>x. (x - a) \\<bullet> aa_)", "by (auto intro!: smooth_on_sum smooth_on_mult smooth_on_inner smooth_on_minus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>aa\\<in>Basis.\n       X (\\<lambda>x. (x - a) \\<bullet> aa) *\n       frechet_derivative f (at a) aa) =\n    frechet_derivative f (at a)\n     (\\<Sum>i\\<in>Basis. X (\\<lambda>x. (x - a) \\<bullet> i) *\\<^sub>R i)", "apply (subst Df.sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>aa\\<in>Basis.\n       X (\\<lambda>x. (x - a) \\<bullet> aa) *\n       frechet_derivative f (at a) aa) =\n    (\\<Sum>aa\\<in>Basis.\n       frechet_derivative f (at a)\n        (X (\\<lambda>x. (x - a) \\<bullet> aa) *\\<^sub>R aa))", "apply (rule sum.cong, rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Basis \\<Longrightarrow>\n       X (\\<lambda>xa. (xa - a) \\<bullet> x) *\n       frechet_derivative f (at a) x =\n       frechet_derivative f (at a)\n        (X (\\<lambda>xa. (xa - a) \\<bullet> x) *\\<^sub>R x)", "apply (subst Df.scaleR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Basis \\<Longrightarrow>\n       X (\\<lambda>xa. (xa - a) \\<bullet> x) *\n       frechet_derivative f (at a) x =\n       X (\\<lambda>xa. (xa - a) \\<bullet> x) *\\<^sub>R\n       frechet_derivative f (at a) x", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  X (\\<lambda>x. frechet_derivative f (at a) (x - a)) =\n  frechet_derivative f (at a) (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<Longrightarrow>\n       X x =\n       directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) x", "show \"X f = directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X f = directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "apply (subst f_exp[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. X (\\<lambda>x.\n          f a + frechet_derivative f (at a) (x - a) +\n          (\\<Sum>i\\<in>Basis.\n             \\<Sum>j\\<in>Basis.\n               (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x)) =\n    directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "apply (subst X_add[unfolded plus_fun_def])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<longrightarrow>\n       X x \\<in> UNIV\n 2. (\\<lambda>x. f a + frechet_derivative f (at a) (x - a))\n    \\<in> manifold_eucl.diff_fun_space k\n 3. (\\<lambda>x.\n        \\<Sum>i\\<in>Basis.\n          \\<Sum>j\\<in>Basis.\n            (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x)\n    \\<in> manifold_eucl.diff_fun_space k\n 4. X (\\<lambda>x. f a + frechet_derivative f (at a) (x - a)) +\n    X (\\<lambda>x.\n          \\<Sum>i\\<in>Basis.\n            \\<Sum>j\\<in>Basis.\n              (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x) =\n    directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<longrightarrow>\n       X x \\<in> UNIV", "by simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>x. f a + frechet_derivative f (at a) (x - a))\n    \\<in> manifold_eucl.diff_fun_space k\n 2. (\\<lambda>x.\n        \\<Sum>i\\<in>Basis.\n          \\<Sum>j\\<in>Basis.\n            (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x)\n    \\<in> manifold_eucl.diff_fun_space k\n 3. X (\\<lambda>x. f a + frechet_derivative f (at a) (x - a)) +\n    X (\\<lambda>x.\n          \\<Sum>i\\<in>Basis.\n            \\<Sum>j\\<in>Basis.\n              (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x) =\n    directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f a + frechet_derivative f (at a) (x - a))\n    \\<in> manifold_eucl.diff_fun_space k", "by (auto intro!: smooth_on_add smooth_on_frechet smooth_on_minus)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x.\n        \\<Sum>i\\<in>Basis.\n          \\<Sum>j\\<in>Basis.\n            (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x)\n    \\<in> manifold_eucl.diff_fun_space k\n 2. X (\\<lambda>x. f a + frechet_derivative f (at a) (x - a)) +\n    X (\\<lambda>x.\n          \\<Sum>i\\<in>Basis.\n            \\<Sum>j\\<in>Basis.\n              (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x) =\n    directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<Sum>i\\<in>Basis.\n          \\<Sum>j\\<in>Basis.\n            (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x)\n    \\<in> manifold_eucl.diff_fun_space k", "by (auto intro!: smooth_on_add smooth_on_sum smooth_on_mult smooth_on_inner g smooth_on_minus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. X (\\<lambda>x. f a + frechet_derivative f (at a) (x - a)) +\n    X (\\<lambda>x.\n          \\<Sum>i\\<in>Basis.\n            \\<Sum>j\\<in>Basis.\n              (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x) =\n    directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "apply (subst X_add[unfolded plus_fun_def])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<longrightarrow>\n       X x \\<in> UNIV\n 2. (\\<lambda>x. f a) \\<in> manifold_eucl.diff_fun_space k\n 3. (\\<lambda>x. frechet_derivative f (at a) (x - a))\n    \\<in> manifold_eucl.diff_fun_space k\n 4. X (\\<lambda>x. f a) +\n    X (\\<lambda>x. frechet_derivative f (at a) (x - a)) +\n    X (\\<lambda>x.\n          \\<Sum>i\\<in>Basis.\n            \\<Sum>j\\<in>Basis.\n              (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x) =\n    directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> manifold_eucl.diff_fun_space k \\<longrightarrow>\n       X x \\<in> UNIV", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>x. f a) \\<in> manifold_eucl.diff_fun_space k\n 2. (\\<lambda>x. frechet_derivative f (at a) (x - a))\n    \\<in> manifold_eucl.diff_fun_space k\n 3. X (\\<lambda>x. f a) +\n    X (\\<lambda>x. frechet_derivative f (at a) (x - a)) +\n    X (\\<lambda>x.\n          \\<Sum>i\\<in>Basis.\n            \\<Sum>j\\<in>Basis.\n              (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x) =\n    directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f a) \\<in> manifold_eucl.diff_fun_space k", "by (auto intro!: smooth_on_add smooth_on_frechet smooth_on_minus)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x. frechet_derivative f (at a) (x - a))\n    \\<in> manifold_eucl.diff_fun_space k\n 2. X (\\<lambda>x. f a) +\n    X (\\<lambda>x. frechet_derivative f (at a) (x - a)) +\n    X (\\<lambda>x.\n          \\<Sum>i\\<in>Basis.\n            \\<Sum>j\\<in>Basis.\n              (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x) =\n    directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. frechet_derivative f (at a) (x - a))\n    \\<in> manifold_eucl.diff_fun_space k", "by (auto intro!: smooth_on_frechet smooth_on_minus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. X (\\<lambda>x. f a) +\n    X (\\<lambda>x. frechet_derivative f (at a) (x - a)) +\n    X (\\<lambda>x.\n          \\<Sum>i\\<in>Basis.\n            \\<Sum>j\\<in>Basis.\n              (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x) =\n    directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "apply (subst manifold_eucl.derivation_const_eq_zero[where c=\"f a\" and X=X, simplified], fact)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + X (\\<lambda>x. frechet_derivative f (at a) (x - a)) +\n    X (\\<lambda>x.\n          \\<Sum>i\\<in>Basis.\n            \\<Sum>j\\<in>Basis.\n              (x - a) \\<bullet> j * ((x - a) \\<bullet> i) * g i j x) =\n    directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "apply (subst *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + X (\\<lambda>x. frechet_derivative f (at a) (x - a)) + 0 =\n    directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. X (\\<lambda>x. frechet_derivative f (at a) (x - a)) =\n    directional_derivative \\<infinity> a\n     (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "using f"], ["proof (prove)\nusing this:\n  f \\<in> manifold_eucl.diff_fun_space k\n\ngoal (1 subgoal):\n 1. X (\\<lambda>x. frechet_derivative f (at a) (x - a)) =\n    directional_derivative \\<infinity> a\n     (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f", "by (simp add: directional_derivative_def **)"], ["proof (state)\nthis:\n  X f = directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i) f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  X = directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i)\n\ngoal (1 subgoal):\n 1. X \\<in> range (directional_derivative k a)", "then"], ["proof (chain)\npicking this:\n  X = directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i)", "show ?thesis"], ["proof (prove)\nusing this:\n  X = directional_derivative k a (\\<Sum>i\\<in>Basis. v i *\\<^sub>R i)\n\ngoal (1 subgoal):\n 1. X \\<in> range (directional_derivative k a)", "by (rule image_eqI) simp"], ["proof (state)\nthis:\n  X \\<in> range (directional_derivative k a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?X \\<in> manifold_eucl.tangent_space k a \\<Longrightarrow>\n  ?X \\<in> range (directional_derivative k a)\n\ngoal (1 subgoal):\n 1. range (directional_derivative k a) = manifold_eucl.tangent_space k a", "with directional_derivative_in_tangent_space[OF \\<open>k \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  directional_derivative k ?a ?x \\<in> manifold_eucl.tangent_space k ?a\n  ?X \\<in> manifold_eucl.tangent_space k a \\<Longrightarrow>\n  ?X \\<in> range (directional_derivative k a)", "show ?thesis"], ["proof (prove)\nusing this:\n  directional_derivative k ?a ?x \\<in> manifold_eucl.tangent_space k ?a\n  ?X \\<in> manifold_eucl.tangent_space k a \\<Longrightarrow>\n  ?X \\<in> range (directional_derivative k a)\n\ngoal (1 subgoal):\n 1. range (directional_derivative k a) = manifold_eucl.tangent_space k a", "by auto"], ["proof (state)\nthis:\n  range (directional_derivative k a) = manifold_eucl.tangent_space k a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma span_directional_derivative:\n  \"span (directional_derivative \\<infinity> a ` Basis) = manifold_eucl.tangent_space \\<infinity> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (directional_derivative \\<infinity> a ` Basis) =\n    manifold_eucl.tangent_space \\<infinity> a", "by (subst span_linear_image)\n    (simp_all add: linear_directional_derivative surj_directional_derivative)"], ["", "lemma directional_derivative_in_span:\n  \"directional_derivative \\<infinity> a x \\<in> span (directional_derivative \\<infinity> a ` Basis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. directional_derivative \\<infinity> a x\n    \\<in> span (directional_derivative \\<infinity> a ` Basis)", "unfolding span_directional_derivative"], ["proof (prove)\ngoal (1 subgoal):\n 1. directional_derivative \\<infinity> a x\n    \\<in> manifold_eucl.tangent_space \\<infinity> a", "using surj_directional_derivative"], ["proof (prove)\nusing this:\n  ?k = \\<infinity> \\<Longrightarrow>\n  range (directional_derivative ?k ?a) = manifold_eucl.tangent_space ?k ?a\n\ngoal (1 subgoal):\n 1. directional_derivative \\<infinity> a x\n    \\<in> manifold_eucl.tangent_space \\<infinity> a", "by blast"], ["", "lemma linear_on_directional_derivative:\n  \"k \\<noteq> 0 \\<Longrightarrow> linear_on UNIV (manifold_eucl.tangent_space k a) (*\\<^sub>R) (*\\<^sub>R) (directional_derivative k a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    linear_on UNIV (manifold_eucl.tangent_space k a) (*\\<^sub>R) (*\\<^sub>R)\n     (directional_derivative k a)", "apply (rule linear_imp_linear_on)"], ["proof (prove)\ngoal (3 subgoals):\n 1. k \\<noteq> 0 \\<Longrightarrow> linear (directional_derivative k a)\n 2. k \\<noteq> 0 \\<Longrightarrow> subspace UNIV\n 3. k \\<noteq> 0 \\<Longrightarrow>\n    subspace (manifold_eucl.tangent_space k a)", "apply (rule linear_directional_derivative)"], ["proof (prove)\ngoal (3 subgoals):\n 1. k \\<noteq> 0 \\<Longrightarrow> k \\<noteq> 0\n 2. k \\<noteq> 0 \\<Longrightarrow> subspace UNIV\n 3. k \\<noteq> 0 \\<Longrightarrow>\n    subspace (manifold_eucl.tangent_space k a)", "by (auto simp: manifold_eucl.subspace_tangent_space)"], ["", "text \\<open>The directional derivatives at Basis forms a basis of the tangent space at a\\<close>"], ["", "interpretation manifold_eucl: finite_dimensional_real_vector_space_on\n  \"manifold_eucl.tangent_space \\<infinity> a\" \"directional_derivative \\<infinity> a ` Basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_real_vector_space_on\n     (manifold_eucl.tangent_space \\<infinity> a)\n     (directional_derivative \\<infinity> a ` Basis)", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (directional_derivative \\<infinity> a ` Basis)\n 2. independent (directional_derivative \\<infinity> a ` Basis)\n 3. span (directional_derivative \\<infinity> a ` Basis) =\n    manifold_eucl.tangent_space \\<infinity> a\n 4. directional_derivative \\<infinity> a ` Basis\n    \\<subseteq> manifold_eucl.tangent_space \\<infinity> a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (directional_derivative \\<infinity> a ` Basis)", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. independent (directional_derivative \\<infinity> a ` Basis)\n 2. span (directional_derivative \\<infinity> a ` Basis) =\n    manifold_eucl.tangent_space \\<infinity> a\n 3. directional_derivative \\<infinity> a ` Basis\n    \\<subseteq> manifold_eucl.tangent_space \\<infinity> a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. independent (directional_derivative \\<infinity> a ` Basis)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. dependent\n     (directional_derivative \\<infinity> a ` Basis) \\<Longrightarrow>\n    False", "assume 4: \"manifold_eucl.tangent_space.dependent (directional_derivative \\<infinity> a ` Basis)\""], ["proof (state)\nthis:\n  dependent (directional_derivative \\<infinity> a ` Basis)\n\ngoal (1 subgoal):\n 1. dependent\n     (directional_derivative \\<infinity> a ` Basis) \\<Longrightarrow>\n    False", "interpret rvo: real_vector_space_pair_on\n       \"UNIV::'a set\"\n       \"manifold_eucl.tangent_space \\<infinity> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_vector_space_pair_on UNIV\n     (manifold_eucl.tangent_space \\<infinity> a)", "by unfold_locales simp"], ["proof (state)\ngoal (1 subgoal):\n 1. dependent\n     (directional_derivative \\<infinity> a ` Basis) \\<Longrightarrow>\n    False", "have 1: \"\\<forall>x. x \\<in> UNIV \\<longrightarrow> directional_derivative \\<infinity> a x \\<in> manifold_eucl.tangent_space \\<infinity> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> UNIV \\<longrightarrow>\n       directional_derivative \\<infinity> a x\n       \\<in> manifold_eucl.tangent_space \\<infinity> a", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in> UNIV \\<longrightarrow>\n     directional_derivative \\<infinity> a x\n     \\<in> manifold_eucl.tangent_space \\<infinity> a\n\ngoal (1 subgoal):\n 1. dependent\n     (directional_derivative \\<infinity> a ` Basis) \\<Longrightarrow>\n    False", "have 2: \"Basis \\<subseteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Basis \\<subseteq> UNIV", "by auto"], ["proof (state)\nthis:\n  Basis \\<subseteq> UNIV\n\ngoal (1 subgoal):\n 1. dependent\n     (directional_derivative \\<infinity> a ` Basis) \\<Longrightarrow>\n    False", "have 5: \"inj_on (directional_derivative \\<infinity> a) (span Basis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (directional_derivative \\<infinity> a) (span Basis)", "by (rule inj_on_directional_derivative) simp_all"], ["proof (state)\nthis:\n  inj_on (directional_derivative \\<infinity> a) (span Basis)\n\ngoal (1 subgoal):\n 1. dependent\n     (directional_derivative \\<infinity> a ` Basis) \\<Longrightarrow>\n    False", "from rvo.linear_dependent_inj_imageD[OF 1 2 linear_on_directional_derivative 4 5]"], ["proof (chain)\npicking this:\n  \\<infinity> \\<noteq> 0 \\<Longrightarrow> dependent Basis", "show False"], ["proof (prove)\nusing this:\n  \\<infinity> \\<noteq> 0 \\<Longrightarrow> dependent Basis\n\ngoal (1 subgoal):\n 1. False", "using independent_Basis"], ["proof (prove)\nusing this:\n  \\<infinity> \\<noteq> 0 \\<Longrightarrow> dependent Basis\n  independent Basis\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (2 subgoals):\n 1. span (directional_derivative \\<infinity> a ` Basis) =\n    manifold_eucl.tangent_space \\<infinity> a\n 2. directional_derivative \\<infinity> a ` Basis\n    \\<subseteq> manifold_eucl.tangent_space \\<infinity> a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. span (directional_derivative \\<infinity> a ` Basis) =\n    manifold_eucl.tangent_space \\<infinity> a", "by (simp add: span_directional_derivative)"], ["proof (prove)\ngoal (1 subgoal):\n 1. directional_derivative \\<infinity> a ` Basis\n    \\<subseteq> manifold_eucl.tangent_space \\<infinity> a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. directional_derivative \\<infinity> a ` Basis\n    \\<subseteq> manifold_eucl.tangent_space \\<infinity> a", "using surj_directional_derivative[of \\<infinity> a]"], ["proof (prove)\nusing this:\n  \\<infinity> = \\<infinity> \\<Longrightarrow>\n  range (directional_derivative \\<infinity> a) =\n  manifold_eucl.tangent_space \\<infinity> a\n\ngoal (1 subgoal):\n 1. directional_derivative \\<infinity> a ` Basis\n    \\<subseteq> manifold_eucl.tangent_space \\<infinity> a", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma independent_directional_derivative:\n  \"k \\<noteq> 0 \\<Longrightarrow> independent (directional_derivative k a ` Basis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    independent (directional_derivative k a ` Basis)", "by (rule linear_independent_injective_image)\n    (auto simp: independent_Basis linear_directional_derivative inj_on_directional_derivative)"], ["", "subsection \\<open>Dimension\\<close>"], ["", "text \\<open>For the Euclidean space, the dimension of the tangent space\n   equals the dimension of the original space.\\<close>"], ["", "lemma dim_eucl_tangent_space:\n  \"dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)\" for a::\"'a::euclidean_space\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)", "interpret finite_dimensional_real_vector_space_pair_on\n    \"UNIV::'a set\"\n    \"manifold_eucl.tangent_space \\<infinity> a\"\n    Basis \"directional_derivative \\<infinity> a ` Basis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_dimensional_real_vector_space_pair_on UNIV\n     (manifold_eucl.tangent_space \\<infinity> a) Basis\n     (directional_derivative \\<infinity> a ` Basis)", "by unfold_locales (auto simp: independent_Basis)"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)", "have \"manifold_eucl.tangent_space.dim \\<infinity> a (manifold_eucl.tangent_space \\<infinity> a) = manifold_eucl.tangent_space.dim \\<infinity> a (range (directional_derivative \\<infinity> a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. manifold_eucl.tangent_space.dim \\<infinity> a\n     (manifold_eucl.tangent_space \\<infinity> a) =\n    manifold_eucl.tangent_space.dim \\<infinity> a\n     (range (directional_derivative \\<infinity> a))", "by (simp add: surj_directional_derivative)"], ["proof (state)\nthis:\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (manifold_eucl.tangent_space \\<infinity> a) =\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (range (directional_derivative \\<infinity> a))\n\ngoal (1 subgoal):\n 1. dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)", "also"], ["proof (state)\nthis:\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (manifold_eucl.tangent_space \\<infinity> a) =\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (range (directional_derivative \\<infinity> a))\n\ngoal (1 subgoal):\n 1. dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)", "have \"\\<dots> = vs1.dim (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. manifold_eucl.tangent_space.dim \\<infinity> a\n     (range (directional_derivative \\<infinity> a)) =\n    vs1.dim UNIV", "by (rule dim_image_eq)\n       (auto simp: linear_on_directional_derivative inj_on_directional_derivative)"], ["proof (state)\nthis:\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (range (directional_derivative \\<infinity> a)) =\n  vs1.dim UNIV\n\ngoal (1 subgoal):\n 1. dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)", "also"], ["proof (state)\nthis:\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (range (directional_derivative \\<infinity> a)) =\n  vs1.dim UNIV\n\ngoal (1 subgoal):\n 1. dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)", "have \"\\<dots> = DIM('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs1.dim UNIV = DIM('a)", "by (simp add: vs1.dim_UNIV)"], ["proof (state)\nthis:\n  vs1.dim UNIV = DIM('a)\n\ngoal (1 subgoal):\n 1. dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)", "finally"], ["proof (chain)\npicking this:\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (manifold_eucl.tangent_space \\<infinity> a) =\n  DIM('a)", "have *: \"DIM('a) = manifold_eucl.tangent_space.dim \\<infinity> a (manifold_eucl.tangent_space \\<infinity> a)\""], ["proof (prove)\nusing this:\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (manifold_eucl.tangent_space \\<infinity> a) =\n  DIM('a)\n\ngoal (1 subgoal):\n 1. DIM('a) =\n    manifold_eucl.tangent_space.dim \\<infinity> a\n     (manifold_eucl.tangent_space \\<infinity> a)", ".."], ["proof (state)\nthis:\n  DIM('a) =\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (manifold_eucl.tangent_space \\<infinity> a)\n\ngoal (1 subgoal):\n 1. dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)", "also"], ["proof (state)\nthis:\n  DIM('a) =\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (manifold_eucl.tangent_space \\<infinity> a)\n\ngoal (1 subgoal):\n 1. dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)", "have \"\\<dots> = dim (manifold_eucl.tangent_space \\<infinity> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. manifold_eucl.tangent_space.dim \\<infinity> a\n     (manifold_eucl.tangent_space \\<infinity> a) =\n    dim (manifold_eucl.tangent_space \\<infinity> a)", "using manifold_eucl.basis_subset _ independent_directional_derivative"], ["proof (prove)\nusing this:\n  directional_derivative \\<infinity> ?a ` Basis\n  \\<subseteq> manifold_eucl.tangent_space \\<infinity> ?a\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  ?k \\<noteq> 0 \\<Longrightarrow>\n  independent (directional_derivative ?k ?a ` Basis)\n\ngoal (1 subgoal):\n 1. manifold_eucl.tangent_space.dim \\<infinity> a\n     (manifold_eucl.tangent_space \\<infinity> a) =\n    dim (manifold_eucl.tangent_space \\<infinity> a)", "proof (rule dim_unique[symmetric])"], ["proof (state)\ngoal (3 subgoals):\n 1. manifold_eucl.tangent_space \\<infinity> a\n    \\<subseteq> span (directional_derivative \\<infinity> a ` Basis)\n 2. \\<infinity> \\<noteq> 0\n 3. card (directional_derivative \\<infinity> a ` Basis) =\n    manifold_eucl.tangent_space.dim \\<infinity> a\n     (manifold_eucl.tangent_space \\<infinity> a)", "show \"manifold_eucl.tangent_space \\<infinity> a \\<subseteq> span (directional_derivative \\<infinity> a ` Basis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. manifold_eucl.tangent_space \\<infinity> a\n    \\<subseteq> span (directional_derivative \\<infinity> a ` Basis)", "by (simp add: span_directional_derivative)"], ["proof (state)\nthis:\n  manifold_eucl.tangent_space \\<infinity> a\n  \\<subseteq> span (directional_derivative \\<infinity> a ` Basis)\n\ngoal (2 subgoals):\n 1. \\<infinity> \\<noteq> 0\n 2. card (directional_derivative \\<infinity> a ` Basis) =\n    manifold_eucl.tangent_space.dim \\<infinity> a\n     (manifold_eucl.tangent_space \\<infinity> a)", "have \"card (directional_derivative \\<infinity> a ` Basis) = DIM('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (directional_derivative \\<infinity> a ` Basis) = DIM('a)", "apply (rule card_image)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (directional_derivative \\<infinity> a) Basis", "by (rule inj_on_directional_derivative) simp"], ["proof (state)\nthis:\n  card (directional_derivative \\<infinity> a ` Basis) = DIM('a)\n\ngoal (2 subgoals):\n 1. \\<infinity> \\<noteq> 0\n 2. card (directional_derivative \\<infinity> a ` Basis) =\n    manifold_eucl.tangent_space.dim \\<infinity> a\n     (manifold_eucl.tangent_space \\<infinity> a)", "also"], ["proof (state)\nthis:\n  card (directional_derivative \\<infinity> a ` Basis) = DIM('a)\n\ngoal (2 subgoals):\n 1. \\<infinity> \\<noteq> 0\n 2. card (directional_derivative \\<infinity> a ` Basis) =\n    manifold_eucl.tangent_space.dim \\<infinity> a\n     (manifold_eucl.tangent_space \\<infinity> a)", "note *"], ["proof (state)\nthis:\n  DIM('a) =\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (manifold_eucl.tangent_space \\<infinity> a)\n\ngoal (2 subgoals):\n 1. \\<infinity> \\<noteq> 0\n 2. card (directional_derivative \\<infinity> a ` Basis) =\n    manifold_eucl.tangent_space.dim \\<infinity> a\n     (manifold_eucl.tangent_space \\<infinity> a)", "finally"], ["proof (chain)\npicking this:\n  card (directional_derivative \\<infinity> a ` Basis) =\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (manifold_eucl.tangent_space \\<infinity> a)", "show \"card (directional_derivative \\<infinity> a ` Basis) =\n      manifold_eucl.tangent_space.dim \\<infinity> a (manifold_eucl.tangent_space \\<infinity> a)\""], ["proof (prove)\nusing this:\n  card (directional_derivative \\<infinity> a ` Basis) =\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (manifold_eucl.tangent_space \\<infinity> a)\n\ngoal (1 subgoal):\n 1. card (directional_derivative \\<infinity> a ` Basis) =\n    manifold_eucl.tangent_space.dim \\<infinity> a\n     (manifold_eucl.tangent_space \\<infinity> a)", "."], ["proof (state)\nthis:\n  card (directional_derivative \\<infinity> a ` Basis) =\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (manifold_eucl.tangent_space \\<infinity> a)\n\ngoal (1 subgoal):\n 1. \\<infinity> \\<noteq> 0", "qed simp"], ["proof (state)\nthis:\n  manifold_eucl.tangent_space.dim \\<infinity> a\n   (manifold_eucl.tangent_space \\<infinity> a) =\n  dim (manifold_eucl.tangent_space \\<infinity> a)\n\ngoal (1 subgoal):\n 1. dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)", "finally"], ["proof (chain)\npicking this:\n  DIM('a) = dim (manifold_eucl.tangent_space \\<infinity> a)", "show ?thesis"], ["proof (prove)\nusing this:\n  DIM('a) = dim (manifold_eucl.tangent_space \\<infinity> a)\n\ngoal (1 subgoal):\n 1. dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)", ".."], ["proof (state)\nthis:\n  dim (manifold_eucl.tangent_space \\<infinity> a) = DIM('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "context c_manifold begin"], ["", "text \\<open>For a general manifold, the dimension of the tangent space at point p\n   equals the dimension of the manifold.\\<close>"], ["", "lemma dim_tangent_space: \"dim (tangent_space p) = DIM('b)\" if p: \"p \\<in> carrier\" and smooth: \"k = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "from carrierE[OF p]"], ["proof (chain)\npicking this:\n  (\\<And>c.\n      \\<lbrakk>c \\<in> charts; p \\<in> domain c\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain c where \"c \\<in> charts\" \"p \\<in> domain c\""], ["proof (prove)\nusing this:\n  (\\<And>c.\n      \\<lbrakk>c \\<in> charts; p \\<in> domain c\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> charts; p \\<in> domain c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  c \\<in> charts\n  p \\<in> domain c\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "interpret a: submanifold charts k \"domain c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. submanifold charts k (domain c)", "by unfold_locales simp"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "let ?a = \"charts_submanifold (domain c)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "let ?b = \"manifold_eucl.charts_submanifold (codomain c)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "interpret a: diff k ?a ?b c"], ["proof (prove)\ngoal (1 subgoal):\n 1. diff k (charts_submanifold (domain c))\n     (manifold_eucl.dest.charts_submanifold (codomain c)) (apply_chart c)", "apply (rule diff.diff_submanifold2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. diff k (charts_submanifold (domain c)) charts_eucl (apply_chart c)\n 2. open (codomain c)\n 3. apply_chart c ` a.sub.carrier \\<subseteq> codomain c", "apply (rule diff_apply_chart)"], ["proof (prove)\ngoal (3 subgoals):\n 1. c \\<in> atlas\n 2. open (codomain c)\n 3. apply_chart c ` a.sub.carrier \\<subseteq> codomain c", "using \\<open>c \\<in> charts\\<close>"], ["proof (prove)\nusing this:\n  c \\<in> charts\n\ngoal (3 subgoals):\n 1. c \\<in> atlas\n 2. open (codomain c)\n 3. apply_chart c ` a.sub.carrier \\<subseteq> codomain c", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "interpret b: diff k ?b ?a \"inv_chart c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff k (manifold_eucl.dest.charts_submanifold (codomain c))\n     (charts_submanifold (domain c)) (inv_chart c)", "apply (rule diff.diff_submanifold2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. diff k (manifold_eucl.dest.charts_submanifold (codomain c)) charts\n     (inv_chart c)\n 2. open (domain c)\n 3. inv_chart c ` a.dest.carrier \\<subseteq> domain c", "apply (rule diff_inv_chart)"], ["proof (prove)\ngoal (3 subgoals):\n 1. c \\<in> atlas\n 2. open (domain c)\n 3. inv_chart c ` a.dest.carrier \\<subseteq> domain c", "using \\<open>c \\<in> charts\\<close>"], ["proof (prove)\nusing this:\n  c \\<in> charts\n\ngoal (3 subgoals):\n 1. c \\<in> atlas\n 2. open (domain c)\n 3. inv_chart c ` a.dest.carrier \\<subseteq> domain c", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>c \\<in> charts; xa \\<in> a.dest.carrier\\<rbrakk>\n       \\<Longrightarrow> inv_chart c xa \\<in> domain c", "by (metis Int_iff a.dest.carrierE domain_restrict_chart image_empty image_insert\n        inv_chart_in_domain manifold_eucl.dest.charts_submanifold_def open_codomain singletonD)"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "interpret b: submanifold charts_eucl k \"codomain c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. submanifold charts_eucl k (codomain c)", "by unfold_locales simp"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "interpret diffeomorphism k \"?a\" \"?b\" \"c\" \"inv_chart c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Differentiable_Manifold.diffeomorphism k (charts_submanifold (domain c))\n     (manifold_eucl.dest.charts_submanifold (codomain c)) (apply_chart c)\n     (inv_chart c)", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "have *: \"DIM('b) = dim (a.dest.tangent_space (c p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DIM('b) = dim (a.dest.tangent_space (apply_chart c p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DIM('b) = dim (a.dest.tangent_space (apply_chart c p))", "have *: \"DIM('b) = dim (manifold_eucl.tangent_space k (c p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DIM('b) = dim (manifold_eucl.dest.tangent_space (apply_chart c p))", "unfolding smooth dim_eucl_tangent_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. DIM('b) = DIM('b)", ".."], ["proof (state)\nthis:\n  DIM('b) = dim (manifold_eucl.dest.tangent_space (apply_chart c p))\n\ngoal (1 subgoal):\n 1. DIM('b) = dim (a.dest.tangent_space (apply_chart c p))", "also"], ["proof (state)\nthis:\n  DIM('b) = dim (manifold_eucl.dest.tangent_space (apply_chart c p))\n\ngoal (1 subgoal):\n 1. DIM('b) = dim (a.dest.tangent_space (apply_chart c p))", "have \"\\<dots> = dim (a.dest.tangent_space (c p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (manifold_eucl.dest.tangent_space (apply_chart c p)) =\n    dim (a.dest.tangent_space (apply_chart c p))", "apply (rule b.dim_tangent_space2[of \"c p\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. apply_chart c p \\<in> a.dest.carrier\n 2. 0 < dim (manifold_eucl.dest.tangent_space (apply_chart c p))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_chart c p \\<in> a.dest.carrier", "using \\<open>p \\<in> domain c\\<close> that"], ["proof (prove)\nusing this:\n  p \\<in> domain c\n  p \\<in> carrier\n  k = \\<infinity>\n\ngoal (1 subgoal):\n 1. apply_chart c p \\<in> a.dest.carrier", "by (auto simp: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < dim (manifold_eucl.dest.tangent_space (apply_chart c p))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < dim (manifold_eucl.dest.tangent_space (apply_chart c p))", "unfolding *[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < DIM('b)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dim (manifold_eucl.dest.tangent_space (apply_chart c p)) =\n  dim (a.dest.tangent_space (apply_chart c p))\n\ngoal (1 subgoal):\n 1. DIM('b) = dim (a.dest.tangent_space (apply_chart c p))", "finally"], ["proof (chain)\npicking this:\n  DIM('b) = dim (a.dest.tangent_space (apply_chart c p))", "show ?thesis"], ["proof (prove)\nusing this:\n  DIM('b) = dim (a.dest.tangent_space (apply_chart c p))\n\ngoal (1 subgoal):\n 1. DIM('b) = dim (a.dest.tangent_space (apply_chart c p))", "."], ["proof (state)\nthis:\n  DIM('b) = dim (a.dest.tangent_space (apply_chart c p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DIM('b) = dim (a.dest.tangent_space (apply_chart c p))\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "also"], ["proof (state)\nthis:\n  DIM('b) = dim (a.dest.tangent_space (apply_chart c p))\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "have **: \"\\<dots> = dim (a.sub.tangent_space p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (a.dest.tangent_space (apply_chart c p)) =\n    dim (a.sub.tangent_space p)", "apply (rule dim_tangent_space_src_dest_eq[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<in> a.sub.carrier\n 2. 0 < dim (a.dest.tangent_space (apply_chart c p))", "unfolding *[symmetric]"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<in> a.sub.carrier\n 2. 0 < DIM('b)", "using \\<open>p \\<in> domain c\\<close> that"], ["proof (prove)\nusing this:\n  p \\<in> domain c\n  p \\<in> carrier\n  k = \\<infinity>\n\ngoal (2 subgoals):\n 1. p \\<in> a.sub.carrier\n 2. 0 < DIM('b)", "by auto"], ["proof (state)\nthis:\n  dim (a.dest.tangent_space (apply_chart c p)) = dim (a.sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "also"], ["proof (state)\nthis:\n  dim (a.dest.tangent_space (apply_chart c p)) = dim (a.sub.tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "have \"\\<dots> = dim (tangent_space p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim (a.sub.tangent_space p) = dim (tangent_space p)", "apply (rule a.dim_tangent_space[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<in> a.sub.carrier\n 2. 0 < dim (a.sub.tangent_space p)", "unfolding *[symmetric] **[symmetric]"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<in> a.sub.carrier\n 2. 0 < DIM('b)", "using \\<open>p \\<in> domain c\\<close> that"], ["proof (prove)\nusing this:\n  p \\<in> domain c\n  p \\<in> carrier\n  k = \\<infinity>\n\ngoal (2 subgoals):\n 1. p \\<in> a.sub.carrier\n 2. 0 < DIM('b)", "by auto"], ["proof (state)\nthis:\n  dim (a.sub.tangent_space p) = dim (tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", "finally"], ["proof (chain)\npicking this:\n  DIM('b) = dim (tangent_space p)", "show ?thesis"], ["proof (prove)\nusing this:\n  DIM('b) = dim (tangent_space p)\n\ngoal (1 subgoal):\n 1. dim (tangent_space p) = DIM('b)", ".."], ["proof (state)\nthis:\n  dim (tangent_space p) = DIM('b)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}