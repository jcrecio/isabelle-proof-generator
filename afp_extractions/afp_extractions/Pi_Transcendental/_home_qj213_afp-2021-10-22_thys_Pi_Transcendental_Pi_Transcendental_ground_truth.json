{"file_name": "/home/qj213/afp-2021-10-22/thys/Pi_Transcendental/Pi_Transcendental.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pi_Transcendental", "problem_names": ["lemma ring_homomorphism_to_poly [intro]: \"ring_homomorphism (\\<lambda>i. [:i:])\"", "lemma (in ring_closed) coeff_power_closed:\n  \"(\\<And>m. coeff p m \\<in> A) \\<Longrightarrow> coeff (p ^ n) m \\<in> A\"", "lemma (in ring_closed) coeff_prod_closed:\n  \"(\\<And>x m. x \\<in> X \\<Longrightarrow> coeff (f x) m \\<in> A) \\<Longrightarrow> coeff (prod f X) m \\<in> A\"", "lemma map_of_rat_of_int_poly [simp]: \"map_poly of_rat (of_int_poly p) = of_int_poly p\"", "lemma ratpoly_to_intpoly:\n  assumes \"\\<forall>i. poly.coeff p i \\<in> \\<rat>\"\n  obtains q c where \"c \\<noteq> 0\" \"p = Polynomial.smult (inverse (of_nat c)) (of_int_poly q)\"", "lemma symmetric_mpoly_symmetric_sum:\n  assumes \"\\<And>\\<pi>. \\<pi> permutes A \\<Longrightarrow> g \\<pi> permutes X\"\n  assumes \"\\<And>x \\<pi>. x \\<in> X \\<Longrightarrow> \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> (f x) = f (g \\<pi> x)\"\n  shows \"symmetric_mpoly A (\\<Sum>x\\<in>X. f x)\"", "lemma symmetric_mpoly_symmetric_prod:\n  assumes \"g permutes X\"\n  assumes \"\\<And>x \\<pi>. x \\<in> X \\<Longrightarrow> \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> (f x) = f (g x)\"\n  shows \"symmetric_mpoly A (\\<Prod>x\\<in>X. f x)\"", "lemma transcendental_i_pi: \"\\<not>algebraic (\\<i> * pi)\"", "theorem transcendental_pi: \"\\<not>algebraic pi\""], "translations": [["", "lemma ring_homomorphism_to_poly [intro]: \"ring_homomorphism (\\<lambda>i. [:i:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_homomorphism (\\<lambda>i. [:i:])", "by standard auto"], ["", "lemma (in ring_closed) coeff_power_closed:\n  \"(\\<And>m. coeff p m \\<in> A) \\<Longrightarrow> coeff (p ^ n) m \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m. MPoly_Type.coeff p m \\<in> A) \\<Longrightarrow>\n    MPoly_Type.coeff (p ^ n) m \\<in> A", "by (induction n arbitrary: m)\n     (auto simp: mpoly_coeff_1 coeff_mpoly_times intro!: prod_fun_closed)"], ["", "lemma (in ring_closed) coeff_prod_closed:\n  \"(\\<And>x m. x \\<in> X \\<Longrightarrow> coeff (f x) m \\<in> A) \\<Longrightarrow> coeff (prod f X) m \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x m.\n        x \\<in> X \\<Longrightarrow>\n        MPoly_Type.coeff (f x) m \\<in> A) \\<Longrightarrow>\n    MPoly_Type.coeff (prod f X) m \\<in> A", "by (induction X arbitrary: m rule: infinite_finite_induct)\n     (auto simp: mpoly_coeff_1 coeff_mpoly_times intro!: prod_fun_closed)"], ["", "lemma map_of_rat_of_int_poly [simp]: \"map_poly of_rat (of_int_poly p) = of_int_poly p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly of_rat (of_int_poly p) = of_int_poly p", "by (intro poly_eqI) (auto simp: coeff_map_poly)"], ["", "text \\<open>\n  Given a polynomial with rational coefficients, we can obtain an integer polynomial that\n  differs from it only by a nonzero constant by clearing the denominators.\n\\<close>"], ["", "lemma ratpoly_to_intpoly:\n  assumes \"\\<forall>i. poly.coeff p i \\<in> \\<rat>\"\n  obtains q c where \"c \\<noteq> 0\" \"p = Polynomial.smult (inverse (of_nat c)) (of_int_poly q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c q.\n        \\<lbrakk>c \\<noteq> 0;\n         p = Polynomial.smult (inverse (of_nat c)) (of_int_poly q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "with that[of 1 0]"], ["proof (chain)\npicking this:\n  \\<lbrakk>1 \\<noteq> 0;\n   p = Polynomial.smult (inverse (of_nat 1)) (of_int_poly 0)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 \\<noteq> 0;\n   p = Polynomial.smult (inverse (of_nat 1)) (of_int_poly 0)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  p = 0\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>i. poly.coeff p i \\<in> \\<rat>", "obtain p' where p': \"p = map_poly of_rat p'\""], ["proof (prove)\nusing this:\n  \\<forall>i. poly.coeff p i \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p = map_poly of_rat p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ratpolyE"], ["proof (prove)\nusing this:\n  \\<forall>i. poly.coeff p i \\<in> \\<rat>\n  \\<lbrakk>\\<forall>i. poly.coeff ?p i \\<in> \\<rat>;\n   \\<And>q. ?p = map_poly of_rat q \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p = map_poly of_rat p' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = map_poly of_rat p'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "define c where \"c = Lcm ((nat \\<circ> snd \\<circ> quotient_of \\<circ> poly.coeff p') ` {..Polynomial.degree p'})\""], ["proof (state)\nthis:\n  c =\n  Lcm ((nat \\<circ> snd \\<circ> quotient_of \\<circ> poly.coeff p') `\n       {..Polynomial.degree p'})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<not>snd (quotient_of x) \\<le> 0\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> snd (quotient_of x) \\<le> 0", "using quotient_of_denom_pos[of x, OF surjective_pairing]"], ["proof (prove)\nusing this:\n  0 < snd (quotient_of x)\n\ngoal (1 subgoal):\n 1. \\<not> snd (quotient_of x) \\<le> 0", "by auto"], ["proof (state)\nthis:\n  \\<not> snd (quotient_of ?x) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"c \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> snd (quotient_of ?x) \\<le> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "by (auto simp: c_def)"], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "define q where \"q = Polynomial.smult (of_nat c) p'\""], ["proof (state)\nthis:\n  q = Polynomial.smult (rat_of_nat c) p'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"poly.coeff q i \\<in> \\<int>\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff q i \\<in> \\<int>", "proof (cases \"i > Polynomial.degree p'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Polynomial.degree p' < i \\<Longrightarrow> poly.coeff q i \\<in> \\<int>\n 2. \\<not> Polynomial.degree p' < i \\<Longrightarrow>\n    poly.coeff q i \\<in> \\<int>", "case False"], ["proof (state)\nthis:\n  \\<not> Polynomial.degree p' < i\n\ngoal (2 subgoals):\n 1. Polynomial.degree p' < i \\<Longrightarrow> poly.coeff q i \\<in> \\<int>\n 2. \\<not> Polynomial.degree p' < i \\<Longrightarrow>\n    poly.coeff q i \\<in> \\<int>", "define m n \n      where \"m = fst (quotient_of (poly.coeff p' i))\"\n        and \"n = nat (snd (quotient_of (poly.coeff p' i)))\""], ["proof (state)\nthis:\n  m = fst (quotient_of (poly.coeff p' i))\n  n = nat (snd (quotient_of (poly.coeff p' i)))\n\ngoal (2 subgoals):\n 1. Polynomial.degree p' < i \\<Longrightarrow> poly.coeff q i \\<in> \\<int>\n 2. \\<not> Polynomial.degree p' < i \\<Longrightarrow>\n    poly.coeff q i \\<in> \\<int>", "have mn: \"n > 0\" \"poly.coeff p' i = of_int m / of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n &&& poly.coeff p' i = rat_of_int m / rat_of_nat n", "using quotient_of_denom_pos[of \"poly.coeff p' i\", OF surjective_pairing]\n            quotient_of_div[of \"poly.coeff p' i\", OF surjective_pairing]"], ["proof (prove)\nusing this:\n  0 < snd (quotient_of (poly.coeff p' i))\n  poly.coeff p' i =\n  rat_of_int (fst (quotient_of (poly.coeff p' i))) /\n  rat_of_int (snd (quotient_of (poly.coeff p' i)))\n\ngoal (1 subgoal):\n 1. 0 < n &&& poly.coeff p' i = rat_of_int m / rat_of_nat n", "by (auto simp: m_def n_def)"], ["proof (state)\nthis:\n  0 < n\n  poly.coeff p' i = rat_of_int m / rat_of_nat n\n\ngoal (2 subgoals):\n 1. Polynomial.degree p' < i \\<Longrightarrow> poly.coeff q i \\<in> \\<int>\n 2. \\<not> Polynomial.degree p' < i \\<Longrightarrow>\n    poly.coeff q i \\<in> \\<int>", "from False"], ["proof (chain)\npicking this:\n  \\<not> Polynomial.degree p' < i", "have \"n dvd c\""], ["proof (prove)\nusing this:\n  \\<not> Polynomial.degree p' < i\n\ngoal (1 subgoal):\n 1. n dvd c", "unfolding c_def"], ["proof (prove)\nusing this:\n  \\<not> Polynomial.degree p' < i\n\ngoal (1 subgoal):\n 1. n dvd\n    Lcm ((nat \\<circ> snd \\<circ> quotient_of \\<circ> poly.coeff p') `\n         {..Polynomial.degree p'})", "by (intro dvd_Lcm) (auto simp: c_def n_def o_def not_less)"], ["proof (state)\nthis:\n  n dvd c\n\ngoal (2 subgoals):\n 1. Polynomial.degree p' < i \\<Longrightarrow> poly.coeff q i \\<in> \\<int>\n 2. \\<not> Polynomial.degree p' < i \\<Longrightarrow>\n    poly.coeff q i \\<in> \\<int>", "hence \"of_nat c * (of_int m / of_nat n) = (of_nat (c div n) * of_int m :: rat)\""], ["proof (prove)\nusing this:\n  n dvd c\n\ngoal (1 subgoal):\n 1. rat_of_nat c * (rat_of_int m / rat_of_nat n) =\n    rat_of_nat (c div n) * rat_of_int m", "by (auto simp: of_nat_div)"], ["proof (state)\nthis:\n  rat_of_nat c * (rat_of_int m / rat_of_nat n) =\n  rat_of_nat (c div n) * rat_of_int m\n\ngoal (2 subgoals):\n 1. Polynomial.degree p' < i \\<Longrightarrow> poly.coeff q i \\<in> \\<int>\n 2. \\<not> Polynomial.degree p' < i \\<Longrightarrow>\n    poly.coeff q i \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  rat_of_nat c * (rat_of_int m / rat_of_nat n) =\n  rat_of_nat (c div n) * rat_of_int m\n\ngoal (2 subgoals):\n 1. Polynomial.degree p' < i \\<Longrightarrow> poly.coeff q i \\<in> \\<int>\n 2. \\<not> Polynomial.degree p' < i \\<Longrightarrow>\n    poly.coeff q i \\<in> \\<int>", "have \"\\<dots> \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (c div n) * rat_of_int m \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  rat_of_nat (c div n) * rat_of_int m \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. Polynomial.degree p' < i \\<Longrightarrow> poly.coeff q i \\<in> \\<int>\n 2. \\<not> Polynomial.degree p' < i \\<Longrightarrow>\n    poly.coeff q i \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  rat_of_nat c * (rat_of_int m / rat_of_nat n) \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_of_nat c * (rat_of_int m / rat_of_nat n) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. poly.coeff q i \\<in> \\<int>", "using mn"], ["proof (prove)\nusing this:\n  rat_of_nat c * (rat_of_int m / rat_of_nat n) \\<in> \\<int>\n  0 < n\n  poly.coeff p' i = rat_of_int m / rat_of_nat n\n\ngoal (1 subgoal):\n 1. poly.coeff q i \\<in> \\<int>", "by (auto simp: q_def)"], ["proof (state)\nthis:\n  poly.coeff q i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. Polynomial.degree p' < i \\<Longrightarrow> poly.coeff q i \\<in> \\<int>", "qed (auto simp: q_def coeff_eq_0)"], ["proof (state)\nthis:\n  poly.coeff q ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "with int_polyE"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>n. poly.coeff ?p n \\<in> \\<int>;\n   \\<And>p'. ?p = of_int_poly p' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  poly.coeff q ?i \\<in> \\<int>", "obtain q' where q': \"q = of_int_poly q'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>n. poly.coeff ?p n \\<in> \\<int>;\n   \\<And>p'. ?p = of_int_poly p' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  poly.coeff q ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        q = of_int_poly q' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q = of_int_poly q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  q = of_int_poly q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"p = Polynomial.smult (inverse (of_nat c)) (map_poly of_rat (of_int_poly q'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\n    Polynomial.smult (inverse (of_nat c)) (map_poly of_rat (of_int_poly q'))", "unfolding smult_conv_map_poly q'[symmetric] p'"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly of_rat p' =\n    map_poly ((*) (inverse (of_nat c))) (map_poly of_rat q)", "using \\<open>c \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map_poly of_rat p' =\n    map_poly ((*) (inverse (of_nat c))) (map_poly of_rat q)", "by (intro poly_eqI) (auto simp: coeff_map_poly q_def of_rat_mult)"], ["proof (state)\nthis:\n  p =\n  Polynomial.smult (inverse (of_nat c)) (map_poly of_rat (of_int_poly q'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>c q.\n                \\<lbrakk>c \\<noteq> 0;\n                 p =\n                 Polynomial.smult (inverse (of_nat c))\n                  (of_int_poly q)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     p \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  q = of_int_poly q'\n  p =\n  Polynomial.smult (inverse (of_nat c)) (map_poly of_rat (of_int_poly q'))", "show ?thesis"], ["proof (prove)\nusing this:\n  q = of_int_poly q'\n  p =\n  Polynomial.smult (inverse (of_nat c)) (map_poly of_rat (of_int_poly q'))\n\ngoal (1 subgoal):\n 1. thesis", "using q' p' \\<open>c \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  q = of_int_poly q'\n  p =\n  Polynomial.smult (inverse (of_nat c)) (map_poly of_rat (of_int_poly q'))\n  q = of_int_poly q'\n  p = map_poly of_rat p'\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro!: that[of c q'])"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma symmetric_mpoly_symmetric_sum:\n  assumes \"\\<And>\\<pi>. \\<pi> permutes A \\<Longrightarrow> g \\<pi> permutes X\"\n  assumes \"\\<And>x \\<pi>. x \\<in> X \\<Longrightarrow> \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> (f x) = f (g \\<pi> x)\"\n  shows \"symmetric_mpoly A (\\<Sum>x\\<in>X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A (sum f X)", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes A \\<longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "fix \\<pi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "assume \\<pi>: \"\\<pi> permutes A\""], ["proof (state)\nthis:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "have \"mpoly_map_vars \\<pi> (sum f X) = (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (sum f X) =\n    (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x))", "by simp"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (sum f X) =\n  (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "also"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (sum f X) =\n  (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "have \"\\<dots> = (\\<Sum>x\\<in>X. f (g \\<pi> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x)) =\n    (\\<Sum>x\\<in>X. f (g \\<pi> x))", "by (intro sum.cong assms \\<pi> refl)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x)) =\n  (\\<Sum>x\\<in>X. f (g \\<pi> x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. mpoly_map_vars \\<pi> (f x)) =\n  (\\<Sum>x\\<in>X. f (g \\<pi> x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "have \"\\<dots> = (\\<Sum>x\\<in>g \\<pi>`X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. f (g \\<pi> x)) = sum f (g \\<pi> ` X)", "using assms(1)[OF \\<pi>]"], ["proof (prove)\nusing this:\n  g \\<pi> permutes X\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. f (g \\<pi> x)) = sum f (g \\<pi> ` X)", "by (subst sum.reindex) (auto simp: permutes_inj_on)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. f (g \\<pi> x)) = sum f (g \\<pi> ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. f (g \\<pi> x)) = sum f (g \\<pi> ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "have \"g \\<pi> ` X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<pi> ` X = X", "using assms(1)[OF \\<pi>]"], ["proof (prove)\nusing this:\n  g \\<pi> permutes X\n\ngoal (1 subgoal):\n 1. g \\<pi> ` X = X", "by (simp add: permutes_image)"], ["proof (state)\nthis:\n  g \\<pi> ` X = X\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (sum f X) = sum f X", "finally"], ["proof (chain)\npicking this:\n  mpoly_map_vars \\<pi> (sum f X) = sum f X", "show \"mpoly_map_vars \\<pi> (sum f X) = sum f X\""], ["proof (prove)\nusing this:\n  mpoly_map_vars \\<pi> (sum f X) = sum f X\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (sum f X) = sum f X", "."], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (sum f X) = sum f X\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: The version of this theorem in the AFP is to weak and should be replaced by this one. *)"], ["", "lemma symmetric_mpoly_symmetric_prod:\n  assumes \"g permutes X\"\n  assumes \"\\<And>x \\<pi>. x \\<in> X \\<Longrightarrow> \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> (f x) = f (g x)\"\n  shows \"symmetric_mpoly A (\\<Prod>x\\<in>X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A (prod f X)", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes A \\<longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "fix \\<pi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "assume \\<pi>: \"\\<pi> permutes A\""], ["proof (state)\nthis:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "have \"mpoly_map_vars \\<pi> (prod f X) = (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (prod f X) =\n    (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x))", "by simp"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (prod f X) =\n  (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "also"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (prod f X) =\n  (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "have \"\\<dots> = (\\<Prod>x\\<in>X. f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x)) = (\\<Prod>x\\<in>X. f (g x))", "by (intro prod.cong assms \\<pi> refl)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x)) = (\\<Prod>x\\<in>X. f (g x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x)) = (\\<Prod>x\\<in>X. f (g x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "have \"\\<dots> = (\\<Prod>x\\<in>g`X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>X. f (g x)) = prod f (g ` X)", "using assms"], ["proof (prove)\nusing this:\n  g permutes X\n  \\<lbrakk>?x \\<in> X; ?\\<pi> permutes A\\<rbrakk>\n  \\<Longrightarrow> mpoly_map_vars ?\\<pi> (f ?x) = f (g ?x)\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>X. f (g x)) = prod f (g ` X)", "by (subst prod.reindex) (auto simp: permutes_inj_on)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X. f (g x)) = prod f (g ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X. f (g x)) = prod f (g ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "have \"g ` X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g ` X = X", "using assms"], ["proof (prove)\nusing this:\n  g permutes X\n  \\<lbrakk>?x \\<in> X; ?\\<pi> permutes A\\<rbrakk>\n  \\<Longrightarrow> mpoly_map_vars ?\\<pi> (f ?x) = f (g ?x)\n\ngoal (1 subgoal):\n 1. g ` X = X", "by (simp add: permutes_image)"], ["proof (state)\nthis:\n  g ` X = X\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "finally"], ["proof (chain)\npicking this:\n  mpoly_map_vars \\<pi> (prod f X) = prod f X", "show \"mpoly_map_vars \\<pi> (prod f X) = prod f X\""], ["proof (prove)\nusing this:\n  mpoly_map_vars \\<pi> (prod f X) = prod f X\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (prod f X) = prod f X", "."], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (prod f X) = prod f X\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We now prove the transcendence of $i\\pi$, from which the transcendence of $\\pi$ will follow\n  as a trivial corollary. The first proof of this was given by von Lindemann~\\cite{lindemann_pi82}.\n  The central ingredient is the fundamental theorem of symmetric functions.\n\n  The proof can, by now, be considered folklore and one can easily find many similar variants of\n  it, but we mostly follows the nice exposition given by Niven~\\cite{niven_pi39}.\n\n  An independent previous formalisation in Coq that uses the same basic techniques was given by\n  Bernard et al.~\\cite{bernard_pi16}. They later also formalised the much stronger\n  Lindemann--Weierstra{\\ss} theorem~\\cite{bernard_lw17}.\n\\<close>"], ["", "lemma transcendental_i_pi: \"\\<not>algebraic (\\<i> * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (\\<i> * complex_of_real pi)", "proof\n  \\<comment> \\<open>Suppose $i\\pi$ were algebraic.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "assume \"algebraic (\\<i> * pi)\"\n  \\<comment> \\<open>We obtain some nonzero integer polynomial that has $i\\pi$ as a root. We can assume\n      w.\\,l.\\,o.\\,g.\\ that the constant coefficient of this polynomial is nonzero.\\<close>"], ["proof (state)\nthis:\n  algebraic (\\<i> * complex_of_real pi)\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  algebraic (\\<i> * complex_of_real pi)", "obtain p\n    where p: \"poly (of_int_poly p) (\\<i> * pi) = 0\" \"p \\<noteq> 0\" \"poly.coeff p 0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  algebraic (\\<i> * complex_of_real pi)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>poly (of_int_poly p) (\\<i> * complex_of_real pi) = 0;\n         p \\<noteq> 0; poly.coeff p 0 \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim algebraicE'_nonzero) auto"], ["proof (state)\nthis:\n  poly (of_int_poly p) (\\<i> * complex_of_real pi) = 0\n  p \\<noteq> 0\n  poly.coeff p 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "define n where \"n = Polynomial.degree p\"\n\n  \\<comment> \\<open>We define the sequence of the roots of this polynomial:\\<close>"], ["proof (state)\nthis:\n  n = Polynomial.degree p\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "obtain root where \"Polynomial.smult (Polynomial.lead_coeff (of_int_poly p))\n                       (\\<Prod>i<n. [:-root i :: complex, 1:]) = of_int_poly p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>root.\n        Polynomial.smult (Polynomial.lead_coeff (of_int_poly p))\n         (\\<Prod>i<n. [:- root i, 1:]) =\n        of_int_poly p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using complex_poly_decompose'[of \"of_int_poly p\"]"], ["proof (prove)\nusing this:\n  (\\<And>root.\n      Polynomial.smult (Polynomial.lead_coeff (of_int_poly p))\n       (\\<Prod>i<Polynomial.degree (of_int_poly p). [:- root i, 1:]) =\n      of_int_poly p \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        Polynomial.smult (Polynomial.lead_coeff (of_int_poly p))\n         (\\<Prod>i<n. [:- root i, 1:]) =\n        of_int_poly p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding n_def"], ["proof (prove)\nusing this:\n  (\\<And>root.\n      Polynomial.smult (Polynomial.lead_coeff (of_int_poly p))\n       (\\<Prod>i<Polynomial.degree (of_int_poly p). [:- root i, 1:]) =\n      of_int_poly p \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        Polynomial.smult (Polynomial.lead_coeff (of_int_poly p))\n         (\\<Prod>i<Polynomial.degree p. [:- root i, 1:]) =\n        of_int_poly p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Polynomial.smult (Polynomial.lead_coeff (of_int_poly p))\n   (\\<Prod>i<n. [:- root i, 1:]) =\n  of_int_poly p\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "note root = this [symmetric]\n\n  \\<comment> \\<open>We note that $i\\pi$ is, of course, among these roots.\\<close>"], ["proof (state)\nthis:\n  of_int_poly p =\n  Polynomial.smult (Polynomial.lead_coeff (of_int_poly p))\n   (\\<Prod>i<n. [:- root i, 1:])\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "from p and root"], ["proof (chain)\npicking this:\n  poly (of_int_poly p) (\\<i> * complex_of_real pi) = 0\n  p \\<noteq> 0\n  poly.coeff p 0 \\<noteq> 0\n  of_int_poly p =\n  Polynomial.smult (Polynomial.lead_coeff (of_int_poly p))\n   (\\<Prod>i<n. [:- root i, 1:])", "obtain idx where idx: \"idx < n\" \"root idx = \\<i> * pi\""], ["proof (prove)\nusing this:\n  poly (of_int_poly p) (\\<i> * complex_of_real pi) = 0\n  p \\<noteq> 0\n  poly.coeff p 0 \\<noteq> 0\n  of_int_poly p =\n  Polynomial.smult (Polynomial.lead_coeff (of_int_poly p))\n   (\\<Prod>i<n. [:- root i, 1:])\n\ngoal (1 subgoal):\n 1. (\\<And>idx.\n        \\<lbrakk>idx < n; root idx = \\<i> * complex_of_real pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: poly_prod)\n\n  \\<comment> \\<open>We now define a new polynomial \\<open>P'\\<close>, whose roots are all numbers that arise as a\n      sum of any subset of roots of \\<open>p\\<close>. We also count all those subsets that sum up to 0\n      and call their number \\<open>A\\<close>.\\<close>"], ["proof (state)\nthis:\n  idx < n\n  root idx = \\<i> * complex_of_real pi\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "define root' where \"root' = (\\<lambda>X. (\\<Sum>j\\<in>X. root j))\""], ["proof (state)\nthis:\n  root' = sum root\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "define P where \"P = (\\<lambda>i. \\<Prod>X | X \\<subseteq> {..<n} \\<and> card X = i. [:-root' X, 1:])\""], ["proof (state)\nthis:\n  P =\n  (\\<lambda>i.\n      \\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = i}.\n        [:- root' X, 1:])\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "define P' where \"P' = (\\<Prod>i\\<in>{0<..n}. P i)\""], ["proof (state)\nthis:\n  P' = prod P {0<..n}\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "define A where \"A = card {X\\<in>Pow {..<n}. root' X = 0}\""], ["proof (state)\nthis:\n  A = card {X \\<in> Pow {..<n}. root' X = 0}\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have [simp]: \"P' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' \\<noteq> 0", "by (auto simp: P'_def P_def)\n\n  \\<comment> \\<open>We give the name \\<open>Roots'\\<close> to those subsets that do not sum to zero and note that there\n      is at least one, namely $\\{i\\pi\\}$.\\<close>"], ["proof (state)\nthis:\n  P' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "define Roots' where \"Roots' = {X. X \\<subseteq> {..<n} \\<and> root' X \\<noteq> 0}\""], ["proof (state)\nthis:\n  Roots' = {X. X \\<subseteq> {..<n} \\<and> root' X \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have [intro]: \"finite Roots'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Roots'", "by (auto simp: Roots'_def)"], ["proof (state)\nthis:\n  finite Roots'\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"{idx} \\<in> Roots'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {idx} \\<in> Roots'", "using idx"], ["proof (prove)\nusing this:\n  idx < n\n  root idx = \\<i> * complex_of_real pi\n\ngoal (1 subgoal):\n 1. {idx} \\<in> Roots'", "by (auto simp: Roots'_def root'_def)"], ["proof (state)\nthis:\n  {idx} \\<in> Roots'\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "hence \"Roots' \\<noteq> {}\""], ["proof (prove)\nusing this:\n  {idx} \\<in> Roots'\n\ngoal (1 subgoal):\n 1. Roots' \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Roots' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "hence card_Roots': \"card Roots' > 0\""], ["proof (prove)\nusing this:\n  Roots' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < card Roots'", "by (auto simp: card_eq_0_iff)"], ["proof (state)\nthis:\n  0 < card Roots'\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have P'_altdef: \"P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:-root' X, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])", "have \"P' = (\\<Prod>(i, X)\\<in>(SIGMA x:{0<..n}. {X. X \\<subseteq> {..<n} \\<and> card X = x}). [:- root' X, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' =\n    (\\<Prod>(i, X)\n            \\<in>(SIGMA x:{0<..n}.\n                     {X. X \\<subseteq> {..<n} \\<and> card X = x}).\n       [:- root' X, 1:])", "unfolding P'_def P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>{0<..n}.\n       \\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = i}.\n         [:- root' X, 1:]) =\n    (\\<Prod>(i, X)\n            \\<in>(SIGMA x:{0<..n}.\n                     {X. X \\<subseteq> {..<n} \\<and> card X = x}).\n       [:- root' X, 1:])", "by (subst prod.Sigma) auto"], ["proof (state)\nthis:\n  P' =\n  (\\<Prod>(i, X)\n          \\<in>(SIGMA x:{0<..n}.\n                   {X. X \\<subseteq> {..<n} \\<and> card X = x}).\n     [:- root' X, 1:])\n\ngoal (1 subgoal):\n 1. P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])", "also"], ["proof (state)\nthis:\n  P' =\n  (\\<Prod>(i, X)\n          \\<in>(SIGMA x:{0<..n}.\n                   {X. X \\<subseteq> {..<n} \\<and> card X = x}).\n     [:- root' X, 1:])\n\ngoal (1 subgoal):\n 1. P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])", "have \"\\<dots> = (\\<Prod>X\\<in>Pow{..<n} - {{}}. [:- root' X, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(i, X)\n            \\<in>(SIGMA x:{0<..n}.\n                     {X. X \\<subseteq> {..<n} \\<and> card X = x}).\n       [:- root' X, 1:]) =\n    (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])", "using card_mono[of \"{..<n}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {..<n}; ?A \\<subseteq> {..<n}\\<rbrakk>\n  \\<Longrightarrow> card ?A \\<le> card {..<n}\n\ngoal (1 subgoal):\n 1. (\\<Prod>(i, X)\n            \\<in>(SIGMA x:{0<..n}.\n                     {X. X \\<subseteq> {..<n} \\<and> card X = x}).\n       [:- root' X, 1:]) =\n    (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])", "by (intro prod.reindex_bij_witness[of _ \"\\<lambda>X. (card X, X)\" \"\\<lambda>(_, X). X\"])\n         (auto simp: case_prod_unfold card_gt_0_iff intro: finite_subset[of _ \"{..<n}\"])"], ["proof (state)\nthis:\n  (\\<Prod>(i, X)\n          \\<in>(SIGMA x:{0<..n}.\n                   {X. X \\<subseteq> {..<n} \\<and> card X = x}).\n     [:- root' X, 1:]) =\n  (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])\n\ngoal (1 subgoal):\n 1. P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])", "finally"], ["proof (chain)\npicking this:\n  P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])", "show ?thesis"], ["proof (prove)\nusing this:\n  P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])\n\ngoal (1 subgoal):\n 1. P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])", "."], ["proof (state)\nthis:\n  P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Clearly, @{term A} is nonzero, since the empty set sums to 0.\\<close>"], ["proof (state)\nthis:\n  P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"A > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < A", "have \"{} \\<in> {X\\<in>Pow {..<n}. root' X = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<in> {X \\<in> Pow {..<n}. root' X = 0}", "by (auto simp: root'_def)"], ["proof (state)\nthis:\n  {} \\<in> {X \\<in> Pow {..<n}. root' X = 0}\n\ngoal (1 subgoal):\n 1. 0 < A", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} \\<in> {X \\<in> Pow {..<n}. root' X = 0}\n\ngoal (1 subgoal):\n 1. 0 < A", "by (auto simp: A_def card_gt_0_iff)"], ["proof (state)\nthis:\n  0 < A\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Since $e^{i\\pi} + 1 = 0$, we know the following:\\<close>"], ["proof (state)\nthis:\n  0 < A\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"0 = (\\<Prod>i<n. exp (root i) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = (\\<Prod>i<n. exp (root i) + 1)", "using idx"], ["proof (prove)\nusing this:\n  idx < n\n  root idx = \\<i> * complex_of_real pi\n\ngoal (1 subgoal):\n 1. 0 = (\\<Prod>i<n. exp (root i) + 1)", "by force\n  \\<comment> \\<open>We rearrange this product of sums into a sum of products and collect all summands that are\n      1 into a separate sum, which we call @{term A}:\\<close>"], ["proof (state)\nthis:\n  0 = (\\<Prod>i<n. exp (root i) + 1)\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  0 = (\\<Prod>i<n. exp (root i) + 1)\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>X\\<in>Pow {..<n}. \\<Prod>i\\<in>X. exp (root i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n. exp (root i) + 1) =\n    sum (prod (\\<lambda>i. exp (root i))) (Pow {..<n})", "by (subst prod_add) auto"], ["proof (state)\nthis:\n  (\\<Prod>i<n. exp (root i) + 1) =\n  sum (prod (\\<lambda>i. exp (root i))) (Pow {..<n})\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Prod>i<n. exp (root i) + 1) =\n  sum (prod (\\<lambda>i. exp (root i))) (Pow {..<n})\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>X\\<in>Pow {..<n}. exp (root' X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (prod (\\<lambda>i. exp (root i))) (Pow {..<n}) =\n    (\\<Sum>X\\<in>Pow {..<n}. exp (root' X))", "by (intro sum.cong refl, subst exp_sum [symmetric])\n       (auto simp: root'_def intro: finite_subset[of _ \"{..<n}\"])"], ["proof (state)\nthis:\n  sum (prod (\\<lambda>i. exp (root i))) (Pow {..<n}) =\n  (\\<Sum>X\\<in>Pow {..<n}. exp (root' X))\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  sum (prod (\\<lambda>i. exp (root i))) (Pow {..<n}) =\n  (\\<Sum>X\\<in>Pow {..<n}. exp (root' X))\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"Pow {..<n} = {X\\<in>Pow {..<n}. root' X \\<noteq> 0} \\<union> {X\\<in>Pow {..<n}. root' X = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pow {..<n} =\n    {X \\<in> Pow {..<n}. root' X \\<noteq> 0} \\<union>\n    {X \\<in> Pow {..<n}. root' X = 0}", "by auto"], ["proof (state)\nthis:\n  Pow {..<n} =\n  {X \\<in> Pow {..<n}. root' X \\<noteq> 0} \\<union>\n  {X \\<in> Pow {..<n}. root' X = 0}\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Pow {..<n} =\n  {X \\<in> Pow {..<n}. root' X \\<noteq> 0} \\<union>\n  {X \\<in> Pow {..<n}. root' X = 0}\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"(\\<Sum>X\\<in>\\<dots>. exp (root' X)) = (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X \\<noteq> 0. exp (root' X)) +\n                                       (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X = 0. exp (root' X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>{X \\<in> Pow {..<n}. root' X \\<noteq> 0} \\<union>\n                 {X \\<in> Pow {..<n}. root' X = 0}.\n       exp (root' X)) =\n    (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X \\<noteq> 0.\n       exp (root' X)) +\n    (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X = 0. exp (root' X))", "by (subst sum.union_disjoint) auto"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>{X \\<in> Pow {..<n}. root' X \\<noteq> 0} \\<union>\n               {X \\<in> Pow {..<n}. root' X = 0}.\n     exp (root' X)) =\n  (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X \\<noteq> 0.\n     exp (root' X)) +\n  (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X = 0. exp (root' X))\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>{X \\<in> Pow {..<n}. root' X \\<noteq> 0} \\<union>\n               {X \\<in> Pow {..<n}. root' X = 0}.\n     exp (root' X)) =\n  (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X \\<noteq> 0.\n     exp (root' X)) +\n  (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X = 0. exp (root' X))\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"(\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X = 0. exp (root' X)) = of_nat A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X = 0. exp (root' X)) =\n    of_nat A", "by (simp add: A_def)\n  \\<comment> \\<open>Finally, we obtain the fact that the sum of $\\exp(u)$ with $u$ ranging over all the non-zero\n      roots of @{term P'} is a negative integer.\\<close>"], ["proof (state)\nthis:\n  (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X = 0. exp (root' X)) =\n  of_nat A\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  0 =\n  (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X \\<noteq> 0.\n     exp (root' X)) +\n  of_nat A", "have eq: \"(\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X \\<noteq> 0. exp (root' X)) = -of_nat A\""], ["proof (prove)\nusing this:\n  0 =\n  (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X \\<noteq> 0.\n     exp (root' X)) +\n  of_nat A\n\ngoal (1 subgoal):\n 1. (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X \\<noteq> 0.\n       exp (root' X)) =\n    - of_nat A", "by (simp add: add_eq_0_iff2)\n\n  \\<comment> \\<open>Next, we show that \\<open>P'\\<close> is a rational polynomial since it can be written as a symmetric\n      polynomial expression (with rational coefficients) in the roots of \\<open>p\\<close>.\\<close>"], ["proof (state)\nthis:\n  (\\<Sum>X | X \\<subseteq> {..<n} \\<and> root' X \\<noteq> 0.\n     exp (root' X)) =\n  - of_nat A\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "define ratpolys where \"ratpolys = {p::complex poly. \\<forall>i. poly.coeff p i \\<in> \\<rat>}\""], ["proof (state)\nthis:\n  ratpolys = {p. \\<forall>i. poly.coeff p i \\<in> \\<rat>}\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have ratpolysI: \"p \\<in> ratpolys\" if \"\\<And>i. poly.coeff p i \\<in> \\<rat>\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> ratpolys", "using that"], ["proof (prove)\nusing this:\n  poly.coeff p ?i \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. p \\<in> ratpolys", "by (auto simp: ratpolys_def)"], ["proof (state)\nthis:\n  (\\<And>i. poly.coeff ?p i \\<in> \\<rat>) \\<Longrightarrow>\n  ?p \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"P' \\<in> ratpolys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' \\<in> ratpolys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P' \\<in> ratpolys", "define Pmv :: \"nat \\<Rightarrow> complex poly mpoly\"\n      where \"Pmv = (\\<lambda>i. \\<Prod>X | X \\<subseteq> {..<n} \\<and> card X = i. Const ([:0,1:]) -\n                          (\\<Sum>i\\<in>X. monom (Poly_Mapping.single i 1) 1))\""], ["proof (state)\nthis:\n  Pmv =\n  (\\<lambda>i.\n      \\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = i}.\n        Const [:0, 1:] -\n        (\\<Sum>i\\<in>X. MPoly_Type.monom (Poly_Mapping.single i 1) 1))\n\ngoal (1 subgoal):\n 1. P' \\<in> ratpolys", "define P'mv where \"P'mv = (\\<Prod>i\\<in>{0<..n}. Pmv i)\""], ["proof (state)\nthis:\n  P'mv = prod Pmv {0<..n}\n\ngoal (1 subgoal):\n 1. P' \\<in> ratpolys", "have \"insertion (\\<lambda>i. [:root i:]) P'mv \\<in> ratpolys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>i. [:root i:]) P'mv \\<in> ratpolys", "proof (rule symmetric_poly_of_roots_in_subring[where l = \"\\<lambda>x. [:x:]\"])"], ["proof (state)\ngoal (10 subgoals):\n 1. ring_closed ratpolys\n 2. \\<forall>m. MPoly_Type.coeff P'mv m \\<in> ratpolys\n 3. ring_homomorphism (\\<lambda>i. [:i:])\n 4. finite ?A\n 5. symmetric_mpoly ?A P'mv\n 6. vars P'mv \\<subseteq> ?A\n 7. ?cinv * [:?c:] = 1\n 8. ?cinv \\<in> ratpolys\n 9. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- root i, 1:])\n 10. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "show \"ring_closed ratpolys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_closed ratpolys", "by standard (auto simp: ratpolys_def coeff_mult)"], ["proof (state)\nthis:\n  ring_closed ratpolys\n\ngoal (9 subgoals):\n 1. \\<forall>m. MPoly_Type.coeff P'mv m \\<in> ratpolys\n 2. ring_homomorphism (\\<lambda>i. [:i:])\n 3. finite ?A\n 4. symmetric_mpoly ?A P'mv\n 5. vars P'mv \\<subseteq> ?A\n 6. ?cinv * [:?c:] = 1\n 7. ?cinv \\<in> ratpolys\n 8. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- root i, 1:])\n 9. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "then"], ["proof (chain)\npicking this:\n  ring_closed ratpolys", "interpret ring_closed ratpolys"], ["proof (prove)\nusing this:\n  ring_closed ratpolys\n\ngoal (1 subgoal):\n 1. ring_closed ratpolys", "."], ["proof (state)\ngoal (9 subgoals):\n 1. \\<forall>m. MPoly_Type.coeff P'mv m \\<in> ratpolys\n 2. ring_homomorphism (\\<lambda>i. [:i:])\n 3. finite ?A\n 4. symmetric_mpoly ?A P'mv\n 5. vars P'mv \\<subseteq> ?A\n 6. ?cinv * [:?c:] = 1\n 7. ?cinv \\<in> ratpolys\n 8. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- root i, 1:])\n 9. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "show \"\\<forall>m. coeff P'mv m \\<in> ratpolys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m. MPoly_Type.coeff P'mv m \\<in> ratpolys", "by (auto simp: P'mv_def Pmv_def coeff_monom when_def mpoly_coeff_Const coeff_pCons' ratpolysI\n                 intro!: coeff_prod_closed minus_closed sum_closed uminus_closed)"], ["proof (state)\nthis:\n  \\<forall>m. MPoly_Type.coeff P'mv m \\<in> ratpolys\n\ngoal (8 subgoals):\n 1. ring_homomorphism (\\<lambda>i. [:i:])\n 2. finite ?A\n 3. symmetric_mpoly ?A P'mv\n 4. vars P'mv \\<subseteq> ?A\n 5. ?cinv * [:?c:] = 1\n 6. ?cinv \\<in> ratpolys\n 7. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- root i, 1:])\n 8. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "show \"\\<forall>i. [:poly.coeff (of_int_poly p) i:] \\<in> ratpolys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. [:poly.coeff (of_int_poly p) i:] \\<in> ratpolys", "by (intro ratpolysI allI) (auto simp: coeff_pCons')"], ["proof (state)\nthis:\n  \\<forall>i. [:poly.coeff (of_int_poly p) i:] \\<in> ratpolys\n\ngoal (7 subgoals):\n 1. ring_homomorphism (\\<lambda>i. [:i:])\n 2. finite ?A\n 3. symmetric_mpoly ?A P'mv\n 4. vars P'mv \\<subseteq> ?A\n 5. ?cinv * [:?c:] = 1\n 6. ?cinv \\<in> ratpolys\n 7. of_int_poly p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- root i, 1:])", "show \"[:inverse (of_int (Polynomial.lead_coeff p)):] *\n              [:of_int (Polynomial.lead_coeff p) :: complex:] = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:inverse (of_int (Polynomial.lead_coeff p)):] *\n    [:of_int (Polynomial.lead_coeff p):] =\n    1", "using \\<open>p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [:inverse (of_int (Polynomial.lead_coeff p)):] *\n    [:of_int (Polynomial.lead_coeff p):] =\n    1", "by (auto intro!: poly_eqI simp: field_simps)"], ["proof (state)\nthis:\n  [:inverse (of_int (Polynomial.lead_coeff p)):] *\n  [:of_int (Polynomial.lead_coeff p):] =\n  1\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>i. [:i:])\n 2. finite ?A\n 3. symmetric_mpoly ?A P'mv\n 4. vars P'mv \\<subseteq> ?A\n 5. [:inverse (of_int (Polynomial.lead_coeff p)):] \\<in> ratpolys\n 6. of_int_poly p =\n    Polynomial.smult (of_int (Polynomial.lead_coeff p))\n     (\\<Prod>i\\<in>?A. [:- root i, 1:])", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>i. [:i:])\n 2. finite ?A\n 3. symmetric_mpoly ?A P'mv\n 4. vars P'mv \\<subseteq> ?A\n 5. [:inverse (of_int (Polynomial.lead_coeff p)):] \\<in> ratpolys\n 6. of_int_poly p =\n    Polynomial.smult (of_int (Polynomial.lead_coeff p))\n     (\\<Prod>i\\<in>?A. [:- root i, 1:])", "have \"symmetric_mpoly {..<n} (Pmv k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly {..<n} (Pmv k)", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes {..<n} \\<longrightarrow>\n       mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "fix \\<pi> :: \"nat \\<Rightarrow> nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "assume \\<pi>: \"\\<pi> permutes {..<n}\""], ["proof (state)\nthis:\n  \\<pi> permutes {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "hence \"mpoly_map_vars \\<pi> (Pmv k) =\n                 (\\<Prod>X | X \\<subseteq> {..<n} \\<and> card X = k. Const [:0, 1:] -\n                    (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single (\\<pi> x) (Suc 0)) 1))\""], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<n}\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (Pmv k) =\n    (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n       Const [:0, 1:] -\n       (\\<Sum>x\\<in>X.\n          MPoly_Type.monom (Poly_Mapping.single (\\<pi> x) (Suc 0)) 1))", "by (simp add: Pmv_def permutes_bij)"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (Pmv k) =\n  (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n     Const [:0, 1:] -\n     (\\<Sum>x\\<in>X.\n        MPoly_Type.monom (Poly_Mapping.single (\\<pi> x) (Suc 0)) 1))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "also"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (Pmv k) =\n  (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n     Const [:0, 1:] -\n     (\\<Sum>x\\<in>X.\n        MPoly_Type.monom (Poly_Mapping.single (\\<pi> x) (Suc 0)) 1))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "have \"\\<dots> = (\\<Prod>X | X \\<subseteq> {..<n} \\<and> card X = k. Const [:0, 1:] -\n                          (\\<Sum>x\\<in>\\<pi>`X. MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n       Const [:0, 1:] -\n       (\\<Sum>x\\<in>X.\n          MPoly_Type.monom (Poly_Mapping.single (\\<pi> x) (Suc 0)) 1)) =\n    (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n       Const [:0, 1:] -\n       (\\<Sum>x\\<in>\\<pi> ` X.\n          MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1))", "using \\<pi>"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<n}\n\ngoal (1 subgoal):\n 1. (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n       Const [:0, 1:] -\n       (\\<Sum>x\\<in>X.\n          MPoly_Type.monom (Poly_Mapping.single (\\<pi> x) (Suc 0)) 1)) =\n    (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n       Const [:0, 1:] -\n       (\\<Sum>x\\<in>\\<pi> ` X.\n          MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1))", "by (subst sum.reindex) (auto simp: permutes_inj_on)"], ["proof (state)\nthis:\n  (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n     Const [:0, 1:] -\n     (\\<Sum>x\\<in>X.\n        MPoly_Type.monom (Poly_Mapping.single (\\<pi> x) (Suc 0)) 1)) =\n  (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n     Const [:0, 1:] -\n     (\\<Sum>x\\<in>\\<pi> ` X.\n        MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "also"], ["proof (state)\nthis:\n  (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n     Const [:0, 1:] -\n     (\\<Sum>x\\<in>X.\n        MPoly_Type.monom (Poly_Mapping.single (\\<pi> x) (Suc 0)) 1)) =\n  (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n     Const [:0, 1:] -\n     (\\<Sum>x\\<in>\\<pi> ` X.\n        MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "have \"\\<dots> = (\\<Prod>X \\<in> (\\<lambda>X. \\<pi>`X)`{X. X \\<subseteq> {..<n} \\<and> card X = k}. Const [:0, 1:] -\n                          (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n       Const [:0, 1:] -\n       (\\<Sum>x\\<in>\\<pi> ` X.\n          MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1)) =\n    (\\<Prod>X\\<in>(`) \\<pi> ` {X. X \\<subseteq> {..<n} \\<and> card X = k}.\n       Const [:0, 1:] -\n       (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1))", "by (subst prod.reindex) (auto intro!: inj_on_image permutes_inj_on[OF \\<pi>])"], ["proof (state)\nthis:\n  (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n     Const [:0, 1:] -\n     (\\<Sum>x\\<in>\\<pi> ` X.\n        MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1)) =\n  (\\<Prod>X\\<in>(`) \\<pi> ` {X. X \\<subseteq> {..<n} \\<and> card X = k}.\n     Const [:0, 1:] -\n     (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "also"], ["proof (state)\nthis:\n  (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n     Const [:0, 1:] -\n     (\\<Sum>x\\<in>\\<pi> ` X.\n        MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1)) =\n  (\\<Prod>X\\<in>(`) \\<pi> ` {X. X \\<subseteq> {..<n} \\<and> card X = k}.\n     Const [:0, 1:] -\n     (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "have \"(\\<lambda>X. \\<pi>`X)`{X. X \\<subseteq> {..<n} \\<and> card X = k} = {X. X \\<subseteq> \\<pi> ` {..<n} \\<and> card X = k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (`) \\<pi> ` {X. X \\<subseteq> {..<n} \\<and> card X = k} =\n    {X. X \\<subseteq> \\<pi> ` {..<n} \\<and> card X = k}", "using \\<pi>"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<n}\n\ngoal (1 subgoal):\n 1. (`) \\<pi> ` {X. X \\<subseteq> {..<n} \\<and> card X = k} =\n    {X. X \\<subseteq> \\<pi> ` {..<n} \\<and> card X = k}", "by (subst image_image_fixed_card_subset) (auto simp: permutes_inj_on)"], ["proof (state)\nthis:\n  (`) \\<pi> ` {X. X \\<subseteq> {..<n} \\<and> card X = k} =\n  {X. X \\<subseteq> \\<pi> ` {..<n} \\<and> card X = k}\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "also"], ["proof (state)\nthis:\n  (`) \\<pi> ` {X. X \\<subseteq> {..<n} \\<and> card X = k} =\n  {X. X \\<subseteq> \\<pi> ` {..<n} \\<and> card X = k}\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "have \"\\<pi> ` {..<n} = {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> ` {..<n} = {..<n}", "by (intro permutes_image \\<pi>)"], ["proof (state)\nthis:\n  \\<pi> ` {..<n} = {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "finally"], ["proof (chain)\npicking this:\n  mpoly_map_vars \\<pi> (Pmv k) =\n  (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n     Const [:0, 1:] -\n     (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1))", "show \"mpoly_map_vars \\<pi> (Pmv k) = Pmv k\""], ["proof (prove)\nusing this:\n  mpoly_map_vars \\<pi> (Pmv k) =\n  (\\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = k}.\n     Const [:0, 1:] -\n     (\\<Sum>x\\<in>X. MPoly_Type.monom (Poly_Mapping.single x (Suc 0)) 1))\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (Pmv k) = Pmv k", "by (simp add: Pmv_def)"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (Pmv k) = Pmv k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  symmetric_mpoly {..<n} (Pmv ?k)\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>i. [:i:])\n 2. finite ?A\n 3. symmetric_mpoly ?A P'mv\n 4. vars P'mv \\<subseteq> ?A\n 5. [:inverse (of_int (Polynomial.lead_coeff p)):] \\<in> ratpolys\n 6. of_int_poly p =\n    Polynomial.smult (of_int (Polynomial.lead_coeff p))\n     (\\<Prod>i\\<in>?A. [:- root i, 1:])", "thus \"symmetric_mpoly {..<n} P'mv\""], ["proof (prove)\nusing this:\n  symmetric_mpoly {..<n} (Pmv ?k)\n\ngoal (1 subgoal):\n 1. symmetric_mpoly {..<n} P'mv", "unfolding P'mv_def"], ["proof (prove)\nusing this:\n  symmetric_mpoly {..<n} (Pmv ?k)\n\ngoal (1 subgoal):\n 1. symmetric_mpoly {..<n} (prod Pmv {0<..n})", "by (intro symmetric_mpoly_prod) auto"], ["proof (state)\nthis:\n  symmetric_mpoly {..<n} P'mv\n\ngoal (5 subgoals):\n 1. ring_homomorphism (\\<lambda>i. [:i:])\n 2. finite {..<n}\n 3. vars P'mv \\<subseteq> {..<n}\n 4. [:inverse (of_int (Polynomial.lead_coeff p)):] \\<in> ratpolys\n 5. of_int_poly p =\n    Polynomial.smult (of_int (Polynomial.lead_coeff p))\n     (\\<Prod>i<n. [:- root i, 1:])", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. ring_homomorphism (\\<lambda>i. [:i:])\n 2. finite {..<n}\n 3. vars P'mv \\<subseteq> {..<n}\n 4. [:inverse (of_int (Polynomial.lead_coeff p)):] \\<in> ratpolys\n 5. of_int_poly p =\n    Polynomial.smult (of_int (Polynomial.lead_coeff p))\n     (\\<Prod>i<n. [:- root i, 1:])", "show vars_P'mv: \"vars P'mv \\<subseteq> {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars P'mv \\<subseteq> {..<n}", "unfolding P'mv_def Pmv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars\n     (\\<Prod>i\\<in>{0<..n}.\n        \\<Prod>X\\<in>{X. X \\<subseteq> {..<n} \\<and> card X = i}.\n          Const [:0, 1:] -\n          (\\<Sum>i\\<in>X. MPoly_Type.monom (Poly_Mapping.single i 1) 1))\n    \\<subseteq> {..<n}", "by (intro order.trans[OF vars_prod] UN_least order.trans[OF vars_diff]\n                   Un_least order.trans[OF vars_sum] order.trans[OF vars_monom_subset]) auto"], ["proof (state)\nthis:\n  vars P'mv \\<subseteq> {..<n}\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>i. [:i:])\n 2. finite {..<n}\n 3. [:inverse (of_int (Polynomial.lead_coeff p)):] \\<in> ratpolys\n 4. of_int_poly p =\n    Polynomial.smult (of_int (Polynomial.lead_coeff p))\n     (\\<Prod>i<n. [:- root i, 1:])", "qed (insert root, auto intro!: ratpolysI simp: coeff_pCons')"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. [:root i:]) P'mv \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. P' \\<in> ratpolys", "also"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. [:root i:]) P'mv \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. P' \\<in> ratpolys", "have \"insertion (\\<lambda>i. [:root i:]) (Pmv k) = P k\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>i. [:root i:]) (Pmv k) = P k", "by (simp add: Pmv_def insertion_prod insertion_diff insertion_sum root'_def P_def\n                    sum_to_poly del: insertion_monom)"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. [:root i:]) (Pmv ?k) = P ?k\n\ngoal (1 subgoal):\n 1. P' \\<in> ratpolys", "(* TODO: insertion_monom should not be a simp rule *)"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. [:root i:]) (Pmv ?k) = P ?k\n\ngoal (1 subgoal):\n 1. P' \\<in> ratpolys", "hence \"insertion (\\<lambda>i. [:root i:]) P'mv = P'\""], ["proof (prove)\nusing this:\n  insertion (\\<lambda>i. [:root i:]) (Pmv ?k) = P ?k\n\ngoal (1 subgoal):\n 1. insertion (\\<lambda>i. [:root i:]) P'mv = P'", "by (simp add: P'mv_def insertion_prod P'_def)"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. [:root i:]) P'mv = P'\n\ngoal (1 subgoal):\n 1. P' \\<in> ratpolys", "finally"], ["proof (chain)\npicking this:\n  P' \\<in> ratpolys", "show \"P' \\<in> ratpolys\""], ["proof (prove)\nusing this:\n  P' \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. P' \\<in> ratpolys", "."], ["proof (state)\nthis:\n  P' \\<in> ratpolys\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>We clear the denominators and remove all powers of $X$ from @{term P'} to obtain a new\n      integer polynomial \\<open>Q\\<close>.\\<close>"], ["proof (state)\nthis:\n  P' \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "define Q' where \"Q' = (\\<Prod>X\\<in>Roots'. [:- root' X, 1:])\""], ["proof (state)\nthis:\n  Q' = (\\<Prod>X\\<in>Roots'. [:- root' X, 1:])\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"P' = (\\<Prod>X\\<in>Pow {..<n}-{{}}. [:-root' X, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])", "by (simp add: P'_altdef)"], ["proof (state)\nthis:\n  P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  P' = (\\<Prod>X\\<in>Pow {..<n} - {{}}. [:- root' X, 1:])\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"Pow {..<n}-{{}} = Roots' \\<union>\n               {X. X \\<in> Pow {..<n} - {{}} \\<and> root' X = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pow {..<n} - {{}} =\n    Roots' \\<union> {X \\<in> Pow {..<n} - {{}}. root' X = 0}", "by (auto simp: root'_def Roots'_def)"], ["proof (state)\nthis:\n  Pow {..<n} - {{}} =\n  Roots' \\<union> {X \\<in> Pow {..<n} - {{}}. root' X = 0}\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Pow {..<n} - {{}} =\n  Roots' \\<union> {X \\<in> Pow {..<n} - {{}}. root' X = 0}\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"(\\<Prod>X\\<in>\\<dots>. [:-root' X, 1:]) =\n               Q' * [:0, 1:] ^ card {X. X \\<subseteq> {..<n} \\<and> X \\<noteq> {} \\<and> root' X = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>X\\<in>Roots' \\<union> {X \\<in> Pow {..<n} - {{}}. root' X = 0}.\n       [:- root' X, 1:]) =\n    Q' *\n    [:0, 1:] ^\n    card {X. X \\<subseteq> {..<n} \\<and> X \\<noteq> {} \\<and> root' X = 0}", "by (subst prod.union_disjoint) (auto simp: Q'_def Roots'_def)"], ["proof (state)\nthis:\n  (\\<Prod>X\\<in>Roots' \\<union> {X \\<in> Pow {..<n} - {{}}. root' X = 0}.\n     [:- root' X, 1:]) =\n  Q' *\n  [:0, 1:] ^\n  card {X. X \\<subseteq> {..<n} \\<and> X \\<noteq> {} \\<and> root' X = 0}\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Prod>X\\<in>Roots' \\<union> {X \\<in> Pow {..<n} - {{}}. root' X = 0}.\n     [:- root' X, 1:]) =\n  Q' *\n  [:0, 1:] ^\n  card {X. X \\<subseteq> {..<n} \\<and> X \\<noteq> {} \\<and> root' X = 0}\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"{X. X \\<subseteq> {..<n} \\<and> X \\<noteq> {} \\<and> root' X = 0} = {X. X \\<subseteq> {..<n} \\<and> root' X = 0} - {{}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {X. X \\<subseteq> {..<n} \\<and> X \\<noteq> {} \\<and> root' X = 0} =\n    {X. X \\<subseteq> {..<n} \\<and> root' X = 0} - {{}}", "by auto"], ["proof (state)\nthis:\n  {X. X \\<subseteq> {..<n} \\<and> X \\<noteq> {} \\<and> root' X = 0} =\n  {X. X \\<subseteq> {..<n} \\<and> root' X = 0} - {{}}\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  {X. X \\<subseteq> {..<n} \\<and> X \\<noteq> {} \\<and> root' X = 0} =\n  {X. X \\<subseteq> {..<n} \\<and> root' X = 0} - {{}}\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"card \\<dots> = A - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({X. X \\<subseteq> {..<n} \\<and> root' X = 0} - {{}}) = A - 1", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({X. X \\<subseteq> {..<n} \\<and> root' X = 0} - {{}}) =\n    card {X \\<in> Pow {..<n}. root' X = 0} - 1", "by (subst card_Diff_singleton) (auto simp: root'_def)"], ["proof (state)\nthis:\n  card ({X. X \\<subseteq> {..<n} \\<and> root' X = 0} - {{}}) = A - 1\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  P' = Q' * [:0, 1:] ^ (A - 1)", "have Q': \"P' = Polynomial.monom 1 (A - 1) * Q'\""], ["proof (prove)\nusing this:\n  P' = Q' * [:0, 1:] ^ (A - 1)\n\ngoal (1 subgoal):\n 1. P' = Polynomial.monom 1 (A - 1) * Q'", "by (simp add: Polynomial.monom_altdef)"], ["proof (state)\nthis:\n  P' = Polynomial.monom 1 (A - 1) * Q'\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have degree_Q': \"Polynomial.degree P' = Polynomial.degree Q' + (A - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.degree P' = Polynomial.degree Q' + (A - 1)", "by (subst Q')\n       (auto simp: Q'_def Roots'_def degree_mult_eq Polynomial.degree_monom_eq degree_prod_eq)"], ["proof (state)\nthis:\n  Polynomial.degree P' = Polynomial.degree Q' + (A - 1)\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"\\<forall>i. poly.coeff Q' i \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. poly.coeff Q' i \\<in> \\<rat>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. poly.coeff Q' i \\<in> \\<rat>", "fix i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. poly.coeff Q' i \\<in> \\<rat>", "have \"poly.coeff Q' i = Polynomial.coeff P' (i + (A - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff Q' i = poly.coeff P' (i + (A - 1))", "by (simp add: Q' Polynomial.coeff_monom_mult)"], ["proof (state)\nthis:\n  poly.coeff Q' i = poly.coeff P' (i + (A - 1))\n\ngoal (1 subgoal):\n 1. \\<And>i. poly.coeff Q' i \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  poly.coeff Q' i = poly.coeff P' (i + (A - 1))\n\ngoal (1 subgoal):\n 1. \\<And>i. poly.coeff Q' i \\<in> \\<rat>", "have \"\\<dots> \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff P' (i + (A - 1)) \\<in> \\<rat>", "using \\<open>P' \\<in> ratpolys\\<close>"], ["proof (prove)\nusing this:\n  P' \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. poly.coeff P' (i + (A - 1)) \\<in> \\<rat>", "by (auto simp: ratpolys_def)"], ["proof (state)\nthis:\n  poly.coeff P' (i + (A - 1)) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. \\<And>i. poly.coeff Q' i \\<in> \\<rat>", "finally"], ["proof (chain)\npicking this:\n  poly.coeff Q' i \\<in> \\<rat>", "show \"poly.coeff Q' i \\<in> \\<rat>\""], ["proof (prove)\nusing this:\n  poly.coeff Q' i \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. poly.coeff Q' i \\<in> \\<rat>", "."], ["proof (state)\nthis:\n  poly.coeff Q' i \\<in> \\<rat>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i. poly.coeff Q' i \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "from ratpoly_to_intpoly[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>q c.\n      \\<lbrakk>c \\<noteq> 0;\n       Q' = Polynomial.smult (inverse (of_nat c)) (of_int_poly q)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain c Q\n    where [simp]: \"c \\<noteq> 0\" and Q: \"Q' = Polynomial.smult (inverse (of_nat c)) (of_int_poly Q)\""], ["proof (prove)\nusing this:\n  (\\<And>q c.\n      \\<lbrakk>c \\<noteq> 0;\n       Q' = Polynomial.smult (inverse (of_nat c)) (of_int_poly q)\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c Q.\n        \\<lbrakk>c \\<noteq> 0;\n         Q' = Polynomial.smult (inverse (of_nat c)) (of_int_poly Q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  c \\<noteq> 0\n  Q' = Polynomial.smult (inverse (of_nat c)) (of_int_poly Q)\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have [simp]: \"Q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<noteq> 0", "using Q Q'"], ["proof (prove)\nusing this:\n  Q' = Polynomial.smult (inverse (of_nat c)) (of_int_poly Q)\n  P' = Polynomial.monom 1 (A - 1) * Q'\n\ngoal (1 subgoal):\n 1. Q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have Q': \"of_int_poly Q = Polynomial.smult (of_nat c) Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly Q = Polynomial.smult (of_nat c) Q'", "using Q"], ["proof (prove)\nusing this:\n  Q' = Polynomial.smult (inverse (of_nat c)) (of_int_poly Q)\n\ngoal (1 subgoal):\n 1. of_int_poly Q = Polynomial.smult (of_nat c) Q'", "by simp"], ["proof (state)\nthis:\n  of_int_poly Q = Polynomial.smult (of_nat c) Q'\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have degree_Q: \"Polynomial.degree Q = Polynomial.degree Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.degree Q = Polynomial.degree Q'", "by (subst Q) auto"], ["proof (state)\nthis:\n  Polynomial.degree Q = Polynomial.degree Q'\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"Polynomial.lead_coeff (of_int_poly Q :: complex poly) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.lead_coeff (of_int_poly Q) = of_nat c", "by (subst Q') (simp_all add: degree_Q Q'_def lead_coeff_prod)"], ["proof (state)\nthis:\n  Polynomial.lead_coeff (of_int_poly Q) = of_nat c\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "hence lead_coeff_Q: \"Polynomial.lead_coeff Q = int c\""], ["proof (prove)\nusing this:\n  Polynomial.lead_coeff (of_int_poly Q) = of_nat c\n\ngoal (1 subgoal):\n 1. Polynomial.lead_coeff Q = int c", "using of_int_eq_iff[of \"Polynomial.lead_coeff Q\" \"of_nat c\"]"], ["proof (prove)\nusing this:\n  Polynomial.lead_coeff (of_int_poly Q) = of_nat c\n  (of_int (Polynomial.lead_coeff Q) = of_int (int c)) =\n  (Polynomial.lead_coeff Q = int c)\n\ngoal (1 subgoal):\n 1. Polynomial.lead_coeff Q = int c", "by (auto simp del: of_int_eq_iff)"], ["proof (state)\nthis:\n  Polynomial.lead_coeff Q = int c\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have Q_decompose: \"of_int_poly Q =\n               Polynomial.smult (of_nat c) (\\<Prod>X\\<in>Roots'. [:- root' X, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly Q =\n    Polynomial.smult (of_nat c) (\\<Prod>X\\<in>Roots'. [:- root' X, 1:])", "by (subst Q') (auto simp: Q'_def lead_coeff_Q)"], ["proof (state)\nthis:\n  of_int_poly Q =\n  Polynomial.smult (of_nat c) (\\<Prod>X\\<in>Roots'. [:- root' X, 1:])\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"poly (of_int_poly Q) (\\<i> * pi) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (of_int_poly Q) (\\<i> * complex_of_real pi) = 0", "using \\<open>{idx} \\<in> Roots'\\<close> \\<open>finite Roots'\\<close> idx"], ["proof (prove)\nusing this:\n  {idx} \\<in> Roots'\n  finite Roots'\n  idx < n\n  root idx = \\<i> * complex_of_real pi\n\ngoal (1 subgoal):\n 1. poly (of_int_poly Q) (\\<i> * complex_of_real pi) = 0", "by (force simp: root'_def Q_decompose poly_prod)"], ["proof (state)\nthis:\n  poly (of_int_poly Q) (\\<i> * complex_of_real pi) = 0\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have degree_Q: \"Polynomial.degree (of_int_poly Q :: complex poly) = card Roots'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.degree (of_int_poly Q) = card Roots'", "by (subst Q') (auto simp: Q'_def degree_prod_eq)"], ["proof (state)\nthis:\n  Polynomial.degree (of_int_poly Q) = card Roots'\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"poly (of_int_poly Q) (0 :: complex) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (of_int_poly Q) 0 \\<noteq> 0", "by (subst Q') (auto simp: Q'_def Roots'_def poly_prod)"], ["proof (state)\nthis:\n  poly (of_int_poly Q) 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "hence [simp]: \"poly Q 0 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  poly (of_int_poly Q) 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly Q 0 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  poly Q 0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have [simp]: \"poly (of_int_poly Q) (root' Y) = 0\" if \"Y \\<in> Roots'\" for Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (of_int_poly Q) (root' Y) = 0", "using that \\<open>finite Roots'\\<close>"], ["proof (prove)\nusing this:\n  Y \\<in> Roots'\n  finite Roots'\n\ngoal (1 subgoal):\n 1. poly (of_int_poly Q) (root' Y) = 0", "by (auto simp: Q' Q'_def poly_prod)\n\n  \\<comment> \\<open>We find some closed ball that contains all the roots of @{term Q}.\\<close>"], ["proof (state)\nthis:\n  ?Y \\<in> Roots' \\<Longrightarrow> poly (of_int_poly Q) (root' ?Y) = 0\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "define r where \"r = Polynomial.degree Q\""], ["proof (state)\nthis:\n  r = Polynomial.degree Q\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"r > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r", "using degree_Q card_Roots'"], ["proof (prove)\nusing this:\n  Polynomial.degree (of_int_poly Q) = card Roots'\n  0 < card Roots'\n\ngoal (1 subgoal):\n 1. 0 < r", "by (auto simp: r_def)"], ["proof (state)\nthis:\n  0 < r\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "define Radius where \"Radius = Max ((\\<lambda>Y. norm (root' Y)) ` Roots')\""], ["proof (state)\nthis:\n  Radius = (MAX Y\\<in>Roots'. cmod (root' Y))\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have Radius: \"norm (root' Y) \\<le> Radius\" if \"Y \\<in> Roots'\" for Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (root' Y) \\<le> Radius", "using \\<open>finite Roots'\\<close> that"], ["proof (prove)\nusing this:\n  finite Roots'\n  Y \\<in> Roots'\n\ngoal (1 subgoal):\n 1. cmod (root' Y) \\<le> Radius", "by (auto simp: Radius_def)"], ["proof (state)\nthis:\n  ?Y \\<in> Roots' \\<Longrightarrow> cmod (root' ?Y) \\<le> Radius\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "from Radius[of \"{idx}\"]"], ["proof (chain)\npicking this:\n  {idx} \\<in> Roots' \\<Longrightarrow> cmod (root' {idx}) \\<le> Radius", "have \"Radius \\<ge> pi\""], ["proof (prove)\nusing this:\n  {idx} \\<in> Roots' \\<Longrightarrow> cmod (root' {idx}) \\<le> Radius\n\ngoal (1 subgoal):\n 1. pi \\<le> Radius", "using idx"], ["proof (prove)\nusing this:\n  {idx} \\<in> Roots' \\<Longrightarrow> cmod (root' {idx}) \\<le> Radius\n  idx < n\n  root idx = \\<i> * complex_of_real pi\n\ngoal (1 subgoal):\n 1. pi \\<le> Radius", "by (auto simp: Roots'_def norm_mult root'_def)"], ["proof (state)\nthis:\n  pi \\<le> Radius\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "hence Radius_nonneg: \"Radius \\<ge> 0\" and \"Radius > 0\""], ["proof (prove)\nusing this:\n  pi \\<le> Radius\n\ngoal (1 subgoal):\n 1. 0 \\<le> Radius &&& 0 < Radius", "using pi_gt3"], ["proof (prove)\nusing this:\n  pi \\<le> Radius\n  3 < pi\n\ngoal (1 subgoal):\n 1. 0 \\<le> Radius &&& 0 < Radius", "by linarith+\n\n  \\<comment> \\<open>Since this ball is compact, @{term Q} is bounded on it. We obtain such a bound.\\<close>"], ["proof (state)\nthis:\n  0 \\<le> Radius\n  0 < Radius\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"compact (poly (of_int_poly Q :: complex poly) ` cball 0 Radius)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact (poly (of_int_poly Q) ` cball 0 Radius)", "by (intro compact_continuous_image continuous_intros) auto"], ["proof (state)\nthis:\n  compact (poly (of_int_poly Q) ` cball 0 Radius)\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  compact (poly (of_int_poly Q) ` cball 0 Radius)", "obtain Q_ub\n    where Q_ub: \"Q_ub > 0\" \n                \"\\<And>u :: complex. u \\<in> cball 0 Radius \\<Longrightarrow> norm (poly (of_int_poly Q) u) \\<le> Q_ub\""], ["proof (prove)\nusing this:\n  compact (poly (of_int_poly Q) ` cball 0 Radius)\n\ngoal (1 subgoal):\n 1. (\\<And>Q_ub.\n        \\<lbrakk>0 < Q_ub;\n         \\<And>u.\n            u \\<in> cball 0 Radius \\<Longrightarrow>\n            cmod (poly (of_int_poly Q) u) \\<le> Q_ub\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: compact_imp_bounded simp: bounded_pos cball_def)\n\n  \\<comment> \\<open>Using this, define another upper bound that we will need later.\\<close>"], ["proof (state)\nthis:\n  0 < Q_ub\n  ?u \\<in> cball 0 Radius \\<Longrightarrow>\n  cmod (poly (of_int_poly Q) ?u) \\<le> Q_ub\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "define fp_ub\n    where \"fp_ub = (\\<lambda>p. \\<bar>c\\<bar> ^ (r * p - 1) / fact (p - 1) * (Radius ^ (p - 1) * Q_ub ^ p))\""], ["proof (state)\nthis:\n  fp_ub =\n  (\\<lambda>p.\n      real_of_int (\\<bar>int c\\<bar> ^ (r * p - 1)) / fact (p - 1) *\n      (Radius ^ (p - 1) * Q_ub ^ p))\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have fp_ub_nonneg: \"fp_ub p \\<ge> 0\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> fp_ub p", "unfolding fp_ub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_int (\\<bar>int c\\<bar> ^ (r * p - 1)) / fact (p - 1) *\n            (Radius ^ (p - 1) * Q_ub ^ p)", "using \\<open>Radius \\<ge> 0\\<close> Q_ub"], ["proof (prove)\nusing this:\n  0 \\<le> Radius\n  0 < Q_ub\n  ?u \\<in> cball 0 Radius \\<Longrightarrow>\n  cmod (poly (of_int_poly Q) ?u) \\<le> Q_ub\n\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_int (\\<bar>int c\\<bar> ^ (r * p - 1)) / fact (p - 1) *\n            (Radius ^ (p - 1) * Q_ub ^ p)", "by (intro mult_nonneg_nonneg divide_nonneg_pos zero_le_power) auto"], ["proof (state)\nthis:\n  0 \\<le> fp_ub ?p\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "define C where \"C = card Roots' * Radius * exp Radius\"\n\n  \\<comment> \\<open>We will now show that any sufficiently large prime number leads to\n      \\<open>C * fp_ub p \\<ge> 1\\<close>, from which we will then derive a contradiction.\\<close>"], ["proof (state)\nthis:\n  C = real (card Roots') * Radius * exp Radius\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "define primes_at_top where \"primes_at_top = inf_class.inf sequentially (principal {p. prime p})\""], ["proof (state)\nthis:\n  primes_at_top = inf sequentially (principal {p. prime p})\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"eventually (\\<lambda>p. \\<forall>x\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. p > x) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially.\n       \\<forall>x\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. x < p", "by (intro eventually_ball_finite ballI eventually_gt_at_top) auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in sequentially.\n     \\<forall>x\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. x < p\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "hence \"eventually (\\<lambda>p. \\<forall>x\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. p > x) primes_at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in sequentially.\n     \\<forall>x\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. x < p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in primes_at_top.\n       \\<forall>x\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. x < p", "unfolding primes_at_top_def eventually_inf_principal"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in sequentially.\n     \\<forall>x\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. x < p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially.\n       x \\<in> Collect prime \\<longrightarrow>\n       (\\<forall>xa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. xa < x)", "by eventually_elim auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in primes_at_top.\n     \\<forall>x\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. x < p\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in primes_at_top.\n     \\<forall>x\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. x < p\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"eventually (\\<lambda>p. prime p) primes_at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eventually prime primes_at_top", "by (auto simp: primes_at_top_def eventually_inf_principal)"], ["proof (state)\nthis:\n  eventually prime primes_at_top\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F p in primes_at_top.\n     \\<forall>x\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. x < p\n  eventually prime primes_at_top", "have \"eventually (\\<lambda>p. C * fp_ub p \\<ge> 1) primes_at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in primes_at_top.\n     \\<forall>x\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. x < p\n  eventually prime primes_at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in primes_at_top. 1 \\<le> C * fp_ub p", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "case (elim p)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. p < p\n  prime p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "hence p: \"prime p\" \"p > nat \\<bar>poly Q 0\\<bar>\" \"p > c\" \"p > A\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. p < p\n  prime p\n\ngoal (1 subgoal):\n 1. (prime p &&& nat \\<bar>poly Q 0\\<bar> < p) &&& c < p &&& A < p", "by auto"], ["proof (state)\nthis:\n  prime p\n  nat \\<bar>poly Q 0\\<bar> < p\n  c < p\n  A < p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "hence \"p > 1\""], ["proof (prove)\nusing this:\n  prime p\n  nat \\<bar>poly Q 0\\<bar> < p\n  c < p\n  A < p\n\ngoal (1 subgoal):\n 1. 1 < p", "by (auto dest: prime_gt_1_nat)\n\n    \\<comment> \\<open>We define the polynomial $f(X) = \\frac{c^s}{(p-1)!} X^{p-1} Q(X)^p$, where $c$ is\n        the leading coefficient of $Q$. We also define $F(X)$ to be the sum of all its\n        derivatives.\\<close>"], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "define s where \"s = r * p - 1\""], ["proof (state)\nthis:\n  s = r * p - 1\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "define fp :: \"complex poly\"\n      where \"fp = Polynomial.smult (of_nat c ^ s / fact (p - 1))\n                    (Polynomial.monom 1 (p - 1) * of_int_poly Q ^ p)\""], ["proof (state)\nthis:\n  fp =\n  Polynomial.smult (of_nat c ^ s / fact (p - 1))\n   (Polynomial.monom 1 (p - 1) * of_int_poly Q ^ p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "define Fp where \"Fp = (\\<Sum>i\\<le>s+p. (pderiv ^^ i) fp)\""], ["proof (state)\nthis:\n  Fp = (\\<Sum>i\\<le>s + p. (pderiv ^^ i) fp)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "define f F where \"f = poly fp\" and \"F = poly Fp\""], ["proof (state)\nthis:\n  f = poly fp\n  F = poly Fp\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "have degree_fp: \"Polynomial.degree fp = s + p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.degree fp = s + p", "using degree_Q card_Roots' \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  Polynomial.degree (of_int_poly Q) = card Roots'\n  0 < card Roots'\n  1 < p\n\ngoal (1 subgoal):\n 1. Polynomial.degree fp = s + p", "by (simp add: fp_def s_def degree_mult_eq degree_monom_eq\n                    degree_power_eq r_def algebra_simps)\n\n    \\<comment> \\<open>Using the same argument as in the case of the transcendence of $e$, we now \n        consider the function\n        \\[I(u) := e^u F(0) - F(u) = u \\int\\limits_0^1 e^{(1-t)x} f(tx)\\,\\textrm{d}t\\]\n        whose absolute value can be bounded with a standard ``maximum times length'' estimate\n        using our upper bound on $f$. All of this can be reused from the proof for $e$, so\n        there is not much to do here. In particular, we will look at $\\sum I(x_i)$ with the\n        $x_i$ ranging over the roots of $Q$ and bound this sum in two different ways.\\<close>"], ["proof (state)\nthis:\n  Polynomial.degree fp = s + p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "interpret lindemann_weierstrass_aux fp"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "have I_altdef: \"I = (\\<lambda>u. exp u * F 0 - F u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I = (\\<lambda>u. exp u * F 0 - F u)", "by (intro ext) (simp add: I_def degree_fp F_def Fp_def poly_sum)\n\n    \\<comment> \\<open>We show that @{term fp_ub} is indeed an upper bound for $f$.\\<close>"], ["proof (state)\nthis:\n  I = (\\<lambda>u. exp u * F 0 - F u)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "have fp_ub:  \"norm (poly fp u) \\<le> fp_ub p\" if \"u \\<in> cball 0 Radius\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (poly fp u) \\<le> fp_ub p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (poly fp u) \\<le> fp_ub p", "have \"norm (poly fp u) = \\<bar>c\\<bar> ^ (r * p - 1) / fact (p - 1) * (norm u ^ (p - 1) *\n                                 norm (poly (of_int_poly Q) u) ^ p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (poly fp u) =\n    real_of_int (\\<bar>int c\\<bar> ^ (r * p - 1)) / fact (p - 1) *\n    (cmod u ^ (p - 1) * cmod (poly (of_int_poly Q) u) ^ p)", "by (simp add: fp_def f_def s_def norm_mult poly_monom norm_divide norm_power)"], ["proof (state)\nthis:\n  cmod (poly fp u) =\n  real_of_int (\\<bar>int c\\<bar> ^ (r * p - 1)) / fact (p - 1) *\n  (cmod u ^ (p - 1) * cmod (poly (of_int_poly Q) u) ^ p)\n\ngoal (1 subgoal):\n 1. cmod (poly fp u) \\<le> fp_ub p", "also"], ["proof (state)\nthis:\n  cmod (poly fp u) =\n  real_of_int (\\<bar>int c\\<bar> ^ (r * p - 1)) / fact (p - 1) *\n  (cmod u ^ (p - 1) * cmod (poly (of_int_poly Q) u) ^ p)\n\ngoal (1 subgoal):\n 1. cmod (poly fp u) \\<le> fp_ub p", "have \"\\<dots> \\<le> fp_ub p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (\\<bar>int c\\<bar> ^ (r * p - 1)) / fact (p - 1) *\n    (cmod u ^ (p - 1) * cmod (poly (of_int_poly Q) u) ^ p)\n    \\<le> fp_ub p", "unfolding fp_ub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (\\<bar>int c\\<bar> ^ (r * p - 1)) / fact (p - 1) *\n    (cmod u ^ (p - 1) * cmod (poly (of_int_poly Q) u) ^ p)\n    \\<le> real_of_int (\\<bar>int c\\<bar> ^ (r * p - 1)) / fact (p - 1) *\n          (Radius ^ (p - 1) * Q_ub ^ p)", "using that Q_ub \\<open>Radius \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> cball 0 Radius\n  0 < Q_ub\n  ?u \\<in> cball 0 Radius \\<Longrightarrow>\n  cmod (poly (of_int_poly Q) ?u) \\<le> Q_ub\n  0 \\<le> Radius\n\ngoal (1 subgoal):\n 1. real_of_int (\\<bar>int c\\<bar> ^ (r * p - 1)) / fact (p - 1) *\n    (cmod u ^ (p - 1) * cmod (poly (of_int_poly Q) u) ^ p)\n    \\<le> real_of_int (\\<bar>int c\\<bar> ^ (r * p - 1)) / fact (p - 1) *\n          (Radius ^ (p - 1) * Q_ub ^ p)", "by (intro mult_left_mono[OF mult_mono] power_mono zero_le_power) auto"], ["proof (state)\nthis:\n  real_of_int (\\<bar>int c\\<bar> ^ (r * p - 1)) / fact (p - 1) *\n  (cmod u ^ (p - 1) * cmod (poly (of_int_poly Q) u) ^ p)\n  \\<le> fp_ub p\n\ngoal (1 subgoal):\n 1. cmod (poly fp u) \\<le> fp_ub p", "finally"], ["proof (chain)\npicking this:\n  cmod (poly fp u) \\<le> fp_ub p", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (poly fp u) \\<le> fp_ub p\n\ngoal (1 subgoal):\n 1. cmod (poly fp u) \\<le> fp_ub p", "."], ["proof (state)\nthis:\n  cmod (poly fp u) \\<le> fp_ub p\n\ngoal:\nNo subgoals!", "qed    \n\n    \\<comment> \\<open>We now show that the following sum is an integer multiple of $p$. This argument again\n        uses the fundamental theorem of symmetric functions, exploiting that the inner sums are\n        symmetric over the roots of $Q$.\\<close>"], ["proof (state)\nthis:\n  ?u \\<in> cball 0 Radius \\<Longrightarrow> cmod (poly fp ?u) \\<le> fp_ub p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "have \"(\\<Sum>i=p..s+p. \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) / p \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = p..s + p.\n        \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) /\n    of_nat p\n    \\<in> \\<int>", "proof (subst sum_divide_distrib, intro Ints_sum[of \"{a..b}\" for a b])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "assume i: \"i \\<in> {p..s+p}\""], ["proof (state)\nthis:\n  i \\<in> {p..s + p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "then"], ["proof (chain)\npicking this:\n  i \\<in> {p..s + p}", "obtain roots' where roots': \"distinct roots'\" \"set roots' = Roots'\""], ["proof (prove)\nusing this:\n  i \\<in> {p..s + p}\n\ngoal (1 subgoal):\n 1. (\\<And>roots'.\n        \\<lbrakk>distinct roots'; set roots' = Roots'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using finite_distinct_list \\<open>finite Roots'\\<close>"], ["proof (prove)\nusing this:\n  i \\<in> {p..s + p}\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A \\<and> distinct xs\n  finite Roots'\n\ngoal (1 subgoal):\n 1. (\\<And>roots'.\n        \\<lbrakk>distinct roots'; set roots' = Roots'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  distinct roots'\n  set roots' = Roots'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "define l where \"l = length roots'\""], ["proof (state)\nthis:\n  l = length roots'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "define fp' where \"fp' = (pderiv ^^ i) fp\""], ["proof (state)\nthis:\n  fp' = (pderiv ^^ i) fp\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "define d where \"d = Polynomial.degree fp'\"\n      \\<comment> \\<open>We define a multivariate polynomial for the inner sum $\\sum f(x_i)/p$ in order\n          to show that it is indeed a symmetric function over the $x_i$.\\<close>"], ["proof (state)\nthis:\n  d = Polynomial.degree fp'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "define R where \"R = (smult (1 / of_nat p) (\\<Sum>k\\<le>d. \\<Sum>i<l. smult (poly.coeff fp' k)\n                             (monom (Poly_Mapping.single i k) (1 / of_int (c ^ k)))) :: complex mpoly)\"\n\n      \\<comment> \\<open>The $j$-th coefficient of the $i$-th derivative of $f$ are integer multiples\n          of $c^j p$ since $i \\geq p$.\\<close>"], ["proof (state)\nthis:\n  R =\n  MPoly_Type.smult (1 / of_nat p)\n   (\\<Sum>k\\<le>d.\n       \\<Sum>i<l.\n          MPoly_Type.smult (poly.coeff fp' k)\n           (MPoly_Type.monom (Poly_Mapping.single i k)\n             (1 / of_int (int (c ^ k)))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "have integer: \"poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>\" if \"j \\<le> d\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>", "define fp'' where \"fp'' = Polynomial.monom 1 (p - 1) * Q ^ p\""], ["proof (state)\nthis:\n  fp'' = Polynomial.monom 1 (p - 1) * Q ^ p\n\ngoal (1 subgoal):\n 1. poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>", "define x\n          where \"x = c ^ s * poly.coeff ((pderiv ^^ i) (Polynomial.monom 1 (p - 1) * Q ^ p)) j\""], ["proof (state)\nthis:\n  x =\n  int (c ^ s) *\n  poly.coeff ((pderiv ^^ i) (Polynomial.monom 1 (p - 1) * Q ^ p)) j\n\ngoal (1 subgoal):\n 1. poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>", "have \"[:fact p:] dvd ([:fact i:] :: int poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:fact p:] dvd [:fact i:]", "using i"], ["proof (prove)\nusing this:\n  i \\<in> {p..s + p}\n\ngoal (1 subgoal):\n 1. [:fact p:] dvd [:fact i:]", "by (auto intro: fact_dvd)"], ["proof (state)\nthis:\n  [:fact p:] dvd [:fact i:]\n\ngoal (1 subgoal):\n 1. poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  [:fact p:] dvd [:fact i:]\n\ngoal (1 subgoal):\n 1. poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>", "have \"[:fact i:] dvd ((pderiv ^^ i) (Polynomial.monom 1 (p - 1) * Q ^ p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:fact i:] dvd (pderiv ^^ i) (Polynomial.monom 1 (p - 1) * Q ^ p)", "by (rule fact_dvd_higher_pderiv)"], ["proof (state)\nthis:\n  [:fact i:] dvd (pderiv ^^ i) (Polynomial.monom 1 (p - 1) * Q ^ p)\n\ngoal (1 subgoal):\n 1. poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  [:fact p:] dvd (pderiv ^^ i) (Polynomial.monom 1 (p - 1) * Q ^ p)", "have \"c ^ j * fact p dvd x\""], ["proof (prove)\nusing this:\n  [:fact p:] dvd (pderiv ^^ i) (Polynomial.monom 1 (p - 1) * Q ^ p)\n\ngoal (1 subgoal):\n 1. int (c ^ j * fact p) dvd x", "unfolding x_def of_nat_mult"], ["proof (prove)\nusing this:\n  [:fact p:] dvd (pderiv ^^ i) (Polynomial.monom 1 (p - 1) * Q ^ p)\n\ngoal (1 subgoal):\n 1. int (c ^ j) * int (fact p) dvd\n    int (c ^ s) *\n    poly.coeff ((pderiv ^^ i) (Polynomial.monom 1 (p - 1) * Q ^ p)) j", "using that i"], ["proof (prove)\nusing this:\n  [:fact p:] dvd (pderiv ^^ i) (Polynomial.monom 1 (p - 1) * Q ^ p)\n  j \\<le> d\n  i \\<in> {p..s + p}\n\ngoal (1 subgoal):\n 1. int (c ^ j) * int (fact p) dvd\n    int (c ^ s) *\n    poly.coeff ((pderiv ^^ i) (Polynomial.monom 1 (p - 1) * Q ^ p)) j", "by (intro mult_dvd_mono)\n             (auto intro!: le_imp_power_dvd simp: s_def d_def fp'_def degree_higher_pderiv degree_fp)"], ["proof (state)\nthis:\n  int (c ^ j * fact p) dvd x\n\ngoal (1 subgoal):\n 1. poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>", "hence \"of_int x / (of_int (c ^ j * fact p) :: complex) \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  int (c ^ j * fact p) dvd x\n\ngoal (1 subgoal):\n 1. of_int x / of_int (int (c ^ j * fact p)) \\<in> \\<int>", "by (intro of_int_divide_in_Ints) auto"], ["proof (state)\nthis:\n  of_int x / of_int (int (c ^ j * fact p)) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  of_int x / of_int (int (c ^ j * fact p)) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>", "have \"of_int x / (of_int (c ^ j * fact p) :: complex) =\n                     poly.coeff fp' j / (of_nat c ^ j * of_nat p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int x / of_int (int (c ^ j * fact p)) =\n    poly.coeff fp' j / (of_nat c ^ j * of_nat p)", "using \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. of_int x / of_int (int (c ^ j * fact p)) =\n    poly.coeff fp' j / (of_nat c ^ j * of_nat p)", "by (auto simp: fact_reduce[of p] fp'_def fp_def higher_pderiv_smult x_def field_simps\n                   simp flip: coeff_of_int_poly higher_pderiv_of_int_poly)"], ["proof (state)\nthis:\n  of_int x / of_int (int (c ^ j * fact p)) =\n  poly.coeff fp' j / (of_nat c ^ j * of_nat p)\n\ngoal (1 subgoal):\n 1. poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>", "."], ["proof (state)\nthis:\n  poly.coeff fp' j / (of_nat c ^ j * of_nat p) \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed\n\n      \\<comment> \\<open>Evaluating $R$ yields is an integer since it is symmetric.\\<close>"], ["proof (state)\nthis:\n  ?j \\<le> d \\<Longrightarrow>\n  poly.coeff fp' ?j / (of_nat c ^ ?j * of_nat p) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "have \"insertion (\\<lambda>i. c * root' (roots' ! i)) R \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>i. of_nat c * root' (roots' ! i)) R \\<in> \\<int>", "proof (intro symmetric_poly_of_roots_in_subring_monic allI)"], ["proof (state)\ngoal (8 subgoals):\n 1. ring_closed \\<int>\n 2. \\<And>m. MPoly_Type.coeff R m \\<in> \\<int>\n 3. ring_homomorphism (\\<lambda>a. a)\n 4. finite ?A\n 5. symmetric_mpoly ?A R\n 6. vars R \\<subseteq> ?A\n 7. ?p = (\\<Prod>i\\<in>?A. [:- (of_nat c * root' (roots' ! i)), 1:])\n 8. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "define Q' where \"Q' = of_int_poly Q \\<circ>\\<^sub>p [:0, 1 / of_nat c :: complex:]\""], ["proof (state)\nthis:\n  Q' = of_int_poly Q \\<circ>\\<^sub>p [:0, 1 / of_nat c:]\n\ngoal (8 subgoals):\n 1. ring_closed \\<int>\n 2. \\<And>m. MPoly_Type.coeff R m \\<in> \\<int>\n 3. ring_homomorphism (\\<lambda>a. a)\n 4. finite ?A\n 5. symmetric_mpoly ?A R\n 6. vars R \\<subseteq> ?A\n 7. ?p = (\\<Prod>i\\<in>?A. [:- (of_nat c * root' (roots' ! i)), 1:])\n 8. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "show \"symmetric_mpoly {..<l} R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly {..<l} R", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly {..<l}\n     (MPoly_Type.smult (1 / of_nat p)\n       (\\<Sum>k\\<le>d.\n           \\<Sum>i<l.\n              MPoly_Type.smult (poly.coeff fp' k)\n               (MPoly_Type.monom (Poly_Mapping.single i k)\n                 (1 / of_int (int (c ^ k))))))", "by (intro symmetric_mpoly_smult symmetric_mpoly_sum[of \"{..d}\"] symmetric_mpoly_symmetric_sum)\n             (simp_all add: mpoly_map_vars_monom permutes_bij permutep_single bij_imp_bij_inv permutes_inv_inv)"], ["proof (state)\nthis:\n  symmetric_mpoly {..<l} R\n\ngoal (7 subgoals):\n 1. ring_closed \\<int>\n 2. \\<And>m. MPoly_Type.coeff R m \\<in> \\<int>\n 3. ring_homomorphism (\\<lambda>a. a)\n 4. finite {..<l}\n 5. vars R \\<subseteq> {..<l}\n 6. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 7. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "show \"MPoly_Type.coeff R m \\<in> \\<int>\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff R m \\<in> \\<int>", "unfolding R_def coeff_sum coeff_smult sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<le>d.\n        \\<Sum>na<l.\n           1 / of_nat p *\n           (poly.coeff fp' n *\n            MPoly_Type.coeff\n             (MPoly_Type.monom (Poly_Mapping.single na n)\n               (1 / of_int (int (c ^ n))))\n             m))\n    \\<in> \\<int>", "using integer"], ["proof (prove)\nusing this:\n  ?j \\<le> d \\<Longrightarrow>\n  poly.coeff fp' ?j / (of_nat c ^ ?j * of_nat p) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<le>d.\n        \\<Sum>na<l.\n           1 / of_nat p *\n           (poly.coeff fp' n *\n            MPoly_Type.coeff\n             (MPoly_Type.monom (Poly_Mapping.single na n)\n               (1 / of_int (int (c ^ n))))\n             m))\n    \\<in> \\<int>", "by (auto simp: R_def coeff_monom when_def intro!: Ints_sum)"], ["proof (state)\nthis:\n  MPoly_Type.coeff R ?m \\<in> \\<int>\n\ngoal (6 subgoals):\n 1. ring_closed \\<int>\n 2. ring_homomorphism (\\<lambda>a. a)\n 3. finite {..<l}\n 4. vars R \\<subseteq> {..<l}\n 5. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 6. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "show \"vars R \\<subseteq> {..<l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars R \\<subseteq> {..<l}", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars\n     (MPoly_Type.smult (1 / of_nat p)\n       (\\<Sum>k\\<le>d.\n           \\<Sum>i<l.\n              MPoly_Type.smult (poly.coeff fp' k)\n               (MPoly_Type.monom (Poly_Mapping.single i k)\n                 (1 / of_int (int (c ^ k))))))\n    \\<subseteq> {..<l}", "by (intro order.trans[OF vars_smult] order.trans[OF vars_sum] UN_least\n                    order.trans[OF vars_monom_subset]) auto"], ["proof (state)\nthis:\n  vars R \\<subseteq> {..<l}\n\ngoal (5 subgoals):\n 1. ring_closed \\<int>\n 2. ring_homomorphism (\\<lambda>a. a)\n 3. finite {..<l}\n 4. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 5. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "show \"ring_closed \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_closed \\<int>", "by standard auto"], ["proof (state)\nthis:\n  ring_closed \\<int>\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 4. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "have \"(\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:]) =\n                (\\<Prod>Y\\<leftarrow>roots'. [:- (of_nat c * root' Y), 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:]) =\n    (\\<Prod>Y\\<leftarrow>roots'. [:- (of_nat c * root' Y), 1:])", "by (subst prod_list_prod_nth) (auto simp: atLeast0LessThan l_def)"], ["proof (state)\nthis:\n  (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:]) =\n  (\\<Prod>Y\\<leftarrow>roots'. [:- (of_nat c * root' Y), 1:])\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 4. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:]) =\n  (\\<Prod>Y\\<leftarrow>roots'. [:- (of_nat c * root' Y), 1:])\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 4. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "have \"\\<dots> = (\\<Prod>Y\\<in>Roots'. [:- (of_nat c * root' Y), 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>Y\\<leftarrow>roots'. [:- (of_nat c * root' Y), 1:]) =\n    (\\<Prod>Y\\<in>Roots'. [:- (of_nat c * root' Y), 1:])", "using roots'"], ["proof (prove)\nusing this:\n  distinct roots'\n  set roots' = Roots'\n\ngoal (1 subgoal):\n 1. (\\<Prod>Y\\<leftarrow>roots'. [:- (of_nat c * root' Y), 1:]) =\n    (\\<Prod>Y\\<in>Roots'. [:- (of_nat c * root' Y), 1:])", "by (subst prod.distinct_set_conv_list [symmetric]) auto"], ["proof (state)\nthis:\n  (\\<Prod>Y\\<leftarrow>roots'. [:- (of_nat c * root' Y), 1:]) =\n  (\\<Prod>Y\\<in>Roots'. [:- (of_nat c * root' Y), 1:])\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 4. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Prod>Y\\<leftarrow>roots'. [:- (of_nat c * root' Y), 1:]) =\n  (\\<Prod>Y\\<in>Roots'. [:- (of_nat c * root' Y), 1:])\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 4. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "have \"\\<dots> = (\\<Prod>Y\\<in>Roots'. Polynomial.smult (of_nat c) ([:-root' Y, 1:])) \\<circ>\\<^sub>p [:0, 1 / c:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>Y\\<in>Roots'. [:- (of_nat c * root' Y), 1:]) =\n    (\\<Prod>Y\\<in>Roots'.\n       Polynomial.smult (of_nat c) [:- root' Y, 1:]) \\<circ>\\<^sub>p\n    [:0, complex_of_real (1 / real c):]", "by (simp add: pcompose_prod pcompose_pCons)"], ["proof (state)\nthis:\n  (\\<Prod>Y\\<in>Roots'. [:- (of_nat c * root' Y), 1:]) =\n  (\\<Prod>Y\\<in>Roots'.\n     Polynomial.smult (of_nat c) [:- root' Y, 1:]) \\<circ>\\<^sub>p\n  [:0, complex_of_real (1 / real c):]\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 4. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Prod>Y\\<in>Roots'. [:- (of_nat c * root' Y), 1:]) =\n  (\\<Prod>Y\\<in>Roots'.\n     Polynomial.smult (of_nat c) [:- root' Y, 1:]) \\<circ>\\<^sub>p\n  [:0, complex_of_real (1 / real c):]\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 4. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "have \"(\\<Prod>Y\\<in>Roots'. Polynomial.smult (of_nat c) ([:-root' Y, 1:])) =\n                     Polynomial.smult (of_nat c ^ card Roots') (\\<Prod>Y\\<in>Roots'. [:-root' Y, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>Y\\<in>Roots'. Polynomial.smult (of_nat c) [:- root' Y, 1:]) =\n    Polynomial.smult (of_nat c ^ card Roots')\n     (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:])", "by (subst prod_smult) auto"], ["proof (state)\nthis:\n  (\\<Prod>Y\\<in>Roots'. Polynomial.smult (of_nat c) [:- root' Y, 1:]) =\n  Polynomial.smult (of_nat c ^ card Roots')\n   (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:])\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 4. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Prod>Y\\<in>Roots'. Polynomial.smult (of_nat c) [:- root' Y, 1:]) =\n  Polynomial.smult (of_nat c ^ card Roots')\n   (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:])\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 4. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "have \"\\<dots> = Polynomial.smult (of_nat c ^ (card Roots' - 1))\n                          (Polynomial.smult c (\\<Prod>Y\\<in>Roots'. [:-root' Y, 1:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (of_nat c ^ card Roots')\n     (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:]) =\n    Polynomial.smult (of_nat c ^ (card Roots' - 1))\n     (Polynomial.smult (of_nat c) (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:]))", "using \\<open>finite Roots'\\<close> and \\<open>Roots' \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  finite Roots'\n  Roots' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_nat c ^ card Roots')\n     (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:]) =\n    Polynomial.smult (of_nat c ^ (card Roots' - 1))\n     (Polynomial.smult (of_nat c) (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:]))", "by (subst power_diff) (auto simp: Suc_le_eq card_gt_0_iff)"], ["proof (state)\nthis:\n  Polynomial.smult (of_nat c ^ card Roots')\n   (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:]) =\n  Polynomial.smult (of_nat c ^ (card Roots' - 1))\n   (Polynomial.smult (of_nat c) (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:]))\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 4. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  Polynomial.smult (of_nat c ^ card Roots')\n   (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:]) =\n  Polynomial.smult (of_nat c ^ (card Roots' - 1))\n   (Polynomial.smult (of_nat c) (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:]))\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 4. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "have \"Polynomial.smult c (\\<Prod>Y\\<in>Roots'. [:-root' Y, 1:]) = of_int_poly Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (of_nat c) (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:]) =\n    of_int_poly Q", "using Q_decompose"], ["proof (prove)\nusing this:\n  of_int_poly Q =\n  Polynomial.smult (of_nat c) (\\<Prod>X\\<in>Roots'. [:- root' X, 1:])\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_nat c) (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:]) =\n    of_int_poly Q", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult (of_nat c) (\\<Prod>Y\\<in>Roots'. [:- root' Y, 1:]) =\n  of_int_poly Q\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. ?p = (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n 4. \\<And>i. poly.coeff ?p i \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:]) =\n  Polynomial.smult (of_nat c ^ (card Roots' - 1))\n   (of_int_poly Q) \\<circ>\\<^sub>p\n  [:0, complex_of_real (1 / real c):]", "show \"Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q' =\n                        (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\""], ["proof (prove)\nusing this:\n  (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:]) =\n  Polynomial.smult (of_nat c ^ (card Roots' - 1))\n   (of_int_poly Q) \\<circ>\\<^sub>p\n  [:0, complex_of_real (1 / real c):]\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q' =\n    (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])", "by (simp add: pcompose_smult Q'_def)"], ["proof (state)\nthis:\n  Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q' =\n  (\\<Prod>i<l. [:- (of_nat c * root' (roots' ! i)), 1:])\n\ngoal (3 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. \\<And>i.\n       poly.coeff\n        (Polynomial.smult (of_nat c ^ (card Roots' - 1))\n          (of_int_poly Q \\<circ>\\<^sub>p [:0, 1 / of_nat c:]))\n        i\n       \\<in> \\<int>", "fix i :: nat"], ["proof (state)\ngoal (3 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}\n 3. \\<And>i.\n       poly.coeff\n        (Polynomial.smult (of_nat c ^ (card Roots' - 1))\n          (of_int_poly Q \\<circ>\\<^sub>p [:0, 1 / of_nat c:]))\n        i\n       \\<in> \\<int>", "show \"poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "proof (cases i \"Polynomial.degree Q\" rule: linorder_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. i < Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>\n 2. i = Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>\n 3. Polynomial.degree Q < i \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "case greater"], ["proof (state)\nthis:\n  Polynomial.degree Q < i\n\ngoal (3 subgoals):\n 1. i < Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>\n 2. i = Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>\n 3. Polynomial.degree Q < i \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "thus ?thesis"], ["proof (prove)\nusing this:\n  Polynomial.degree Q < i\n\ngoal (1 subgoal):\n 1. poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "by (auto simp: Q'_def coeff_pcompose_linear coeff_eq_0)"], ["proof (state)\nthis:\n  poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n  \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. i < Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>\n 2. i = Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i < Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>\n 2. i = Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "case equal"], ["proof (state)\nthis:\n  i = Polynomial.degree Q\n\ngoal (2 subgoals):\n 1. i < Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>\n 2. i = Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = Polynomial.degree Q\n\ngoal (1 subgoal):\n 1. poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "using \\<open>Roots' \\<noteq> {}\\<close> degree_Q card_Roots' lead_coeff_Q"], ["proof (prove)\nusing this:\n  i = Polynomial.degree Q\n  Roots' \\<noteq> {}\n  Polynomial.degree (of_int_poly Q) = card Roots'\n  0 < card Roots'\n  Polynomial.lead_coeff Q = int c\n\ngoal (1 subgoal):\n 1. poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "by (auto simp: Q'_def coeff_pcompose_linear lead_coeff_Q power_divide power_diff)"], ["proof (state)\nthis:\n  poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. i < Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i < Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "case less"], ["proof (state)\nthis:\n  i < Polynomial.degree Q\n\ngoal (1 subgoal):\n 1. i < Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "have \"poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i =\n                  of_int (poly.coeff Q i) * (of_int (c ^ (card Roots' - 1)) / of_int (c ^ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i =\n    of_int (poly.coeff Q i) *\n    (of_int (int (c ^ (card Roots' - 1))) / of_int (int (c ^ i)))", "by (auto simp: Q'_def coeff_pcompose_linear power_divide)"], ["proof (state)\nthis:\n  poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i =\n  of_int (poly.coeff Q i) *\n  (of_int (int (c ^ (card Roots' - 1))) / of_int (int (c ^ i)))\n\ngoal (1 subgoal):\n 1. i < Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i =\n  of_int (poly.coeff Q i) *\n  (of_int (int (c ^ (card Roots' - 1))) / of_int (int (c ^ i)))\n\ngoal (1 subgoal):\n 1. i < Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "have \"\\<dots> \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (poly.coeff Q i) *\n    (of_int (int (c ^ (card Roots' - 1))) / of_int (int (c ^ i)))\n    \\<in> \\<int>", "using less degree_Q"], ["proof (prove)\nusing this:\n  i < Polynomial.degree Q\n  Polynomial.degree (of_int_poly Q) = card Roots'\n\ngoal (1 subgoal):\n 1. of_int (poly.coeff Q i) *\n    (of_int (int (c ^ (card Roots' - 1))) / of_int (int (c ^ i)))\n    \\<in> \\<int>", "by (intro Ints_mult of_int_divide_in_Ints) (auto intro!: le_imp_power_dvd)"], ["proof (state)\nthis:\n  of_int (poly.coeff Q i) *\n  (of_int (int (c ^ (card Roots' - 1))) / of_int (int (c ^ i)))\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. i < Polynomial.degree Q \\<Longrightarrow>\n    poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n  \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n    \\<in> \\<int>", "."], ["proof (state)\nthis:\n  poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n  \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly.coeff (Polynomial.smult (of_nat c ^ (card Roots' - 1)) Q') i\n  \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<l}", "qed auto\n      \\<comment> \\<open>Moreover, by definition, evaluating @{term R} gives us $\\sum f(x_i)/p$.\\<close>"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. of_nat c * root' (roots' ! i)) R \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. of_nat c * root' (roots' ! i)) R \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "have \"insertion (\\<lambda>i. c * root' (roots' ! i)) R =\n                   (\\<Sum>Y\\<leftarrow>roots'. poly fp' (root' Y)) / of_nat p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>i. of_nat c * root' (roots' ! i)) R =\n    (\\<Sum>Y\\<leftarrow>roots'. poly fp' (root' Y)) / of_nat p", "by (simp add: insertion_sum R_def poly_altdef d_def sum_list_sum_nth atLeast0LessThan\n                    l_def power_mult_distrib algebra_simps \n                    sum.swap[of _ \"{..Polynomial.degree fp'}\"] del: insertion_monom)"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. of_nat c * root' (roots' ! i)) R =\n  (\\<Sum>Y\\<leftarrow>roots'. poly fp' (root' Y)) / of_nat p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. of_nat c * root' (roots' ! i)) R =\n  (\\<Sum>Y\\<leftarrow>roots'. poly fp' (root' Y)) / of_nat p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "have \"\\<dots> = (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) / of_nat p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<leftarrow>roots'. poly fp' (root' Y)) / of_nat p =\n    (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) / of_nat p", "using roots'"], ["proof (prove)\nusing this:\n  distinct roots'\n  set roots' = Roots'\n\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<leftarrow>roots'. poly fp' (root' Y)) / of_nat p =\n    (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) / of_nat p", "by (subst sum_list_distinct_conv_sum_set) (auto simp: fp'_def poly_pcompose)"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<leftarrow>roots'. poly fp' (root' Y)) / of_nat p =\n  (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) / of_nat p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ x) fp) (root' Y)) / of_nat p\n       \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) / of_nat p\n  \\<in> \\<int>", "show \"\\<dots> \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) / of_nat p\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) / of_nat p\n    \\<in> \\<int>", "."], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) / of_nat p\n  \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = p..s + p.\n      \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) /\n  of_nat p\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>i = p..s + p.\n      \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) /\n  of_nat p\n  \\<in> \\<int>", "obtain K where K: \"(\\<Sum>i=p..s+p. \\<Sum>Y\\<in>Roots'. \n                               poly ((pderiv ^^ i) fp) (root' Y)) = of_int K * p\""], ["proof (prove)\nusing this:\n  (\\<Sum>i = p..s + p.\n      \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) /\n  of_nat p\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        (\\<Sum>i = p..s + p.\n            \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) =\n        of_int (of_int K * int p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i = p..s + p.\n      \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) /\n  of_nat p\n  \\<in> \\<int>\n  1 < p\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        (\\<Sum>i = p..s + p.\n            \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) =\n        of_int (of_int K * int p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: Ints_cases simp: field_simps)\n\n    \\<comment> \\<open>Next, we show that $F(0)$ is an integer and coprime to $p$.\\<close>"], ["proof (state)\nthis:\n  (\\<Sum>i = p..s + p.\n      \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) =\n  of_int (of_int K * int p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "obtain F0 :: int where F0: \"F 0 = of_int F0\" \"coprime (int p) F0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(\\<Sum>i=p..s + p. poly ((pderiv ^^ i) fp) 0) / of_nat p \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = p..s + p. poly ((pderiv ^^ i) fp) 0) / of_nat p \\<in> \\<int>", "unfolding sum_divide_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n = p..s + p. poly ((pderiv ^^ n) fp) 0 / of_nat p) \\<in> \\<int>", "proof (intro Ints_sum)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ x) fp) 0 / of_nat p \\<in> \\<int>", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ x) fp) 0 / of_nat p \\<in> \\<int>", "assume i: \"i \\<in> {p..s+p}\""], ["proof (state)\nthis:\n  i \\<in> {p..s + p}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ x) fp) 0 / of_nat p \\<in> \\<int>", "hence \"fact p dvd poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p)) 0\""], ["proof (prove)\nusing this:\n  i \\<in> {p..s + p}\n\ngoal (1 subgoal):\n 1. fact p dvd poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p)) 0", "by (intro fact_dvd_poly_higher_pderiv_aux') auto"], ["proof (state)\nthis:\n  fact p dvd poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p)) 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ x) fp) 0 / of_nat p \\<in> \\<int>", "then"], ["proof (chain)\npicking this:\n  fact p dvd poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p)) 0", "obtain k where k: \"poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p)) 0 = k * fact p\""], ["proof (prove)\nusing this:\n  fact p dvd poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p)) 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p)) 0 =\n        k * fact p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p)) 0 = k * fact p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ x) fp) 0 / of_nat p \\<in> \\<int>", "have \"(pderiv ^^ i) fp = Polynomial.smult (of_nat c ^ s / fact (p - 1))\n                (of_int_poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ i) fp =\n    Polynomial.smult (of_nat c ^ s / fact (p - 1))\n     (of_int_poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p)))", "by (simp add: fp_def higher_pderiv_smult Polynomial.monom_altdef\n                   flip: higher_pderiv_of_int_poly)"], ["proof (state)\nthis:\n  (pderiv ^^ i) fp =\n  Polynomial.smult (of_nat c ^ s / fact (p - 1))\n   (of_int_poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ x) fp) 0 / of_nat p \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (pderiv ^^ i) fp =\n  Polynomial.smult (of_nat c ^ s / fact (p - 1))\n   (of_int_poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ x) fp) 0 / of_nat p \\<in> \\<int>", "have \"poly \\<dots> 0 / of_nat p = of_int (c ^ s * k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     (Polynomial.smult (of_nat c ^ s / fact (p - 1))\n       (of_int_poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p))))\n     0 /\n    of_nat p =\n    of_int (int (c ^ s) * k)", "using k \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p)) 0 = k * fact p\n  1 < p\n\ngoal (1 subgoal):\n 1. poly\n     (Polynomial.smult (of_nat c ^ s / fact (p - 1))\n       (of_int_poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p))))\n     0 /\n    of_nat p =\n    of_int (int (c ^ s) * k)", "by (simp add: fact_reduce[of p])"], ["proof (state)\nthis:\n  poly\n   (Polynomial.smult (of_nat c ^ s / fact (p - 1))\n     (of_int_poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p))))\n   0 /\n  of_nat p =\n  of_int (int (c ^ s) * k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ x) fp) 0 / of_nat p \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  poly\n   (Polynomial.smult (of_nat c ^ s / fact (p - 1))\n     (of_int_poly ((pderiv ^^ i) ([:0, 1:] ^ (p - 1) * Q ^ p))))\n   0 /\n  of_nat p =\n  of_int (int (c ^ s) * k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ x) fp) 0 / of_nat p \\<in> \\<int>", "have \"\\<dots> \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (int (c ^ s) * k) \\<in> \\<int>", "by simp"], ["proof (state)\nthis:\n  of_int (int (c ^ s) * k) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ x) fp) 0 / of_nat p \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  poly ((pderiv ^^ i) fp) 0 / of_nat p \\<in> \\<int>", "show \"poly ((pderiv ^^ i) fp) 0 / of_nat p \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  poly ((pderiv ^^ i) fp) 0 / of_nat p \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ i) fp) 0 / of_nat p \\<in> \\<int>", "."], ["proof (state)\nthis:\n  poly ((pderiv ^^ i) fp) 0 / of_nat p \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i = p..s + p. poly ((pderiv ^^ i) fp) 0) / of_nat p \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>i = p..s + p. poly ((pderiv ^^ i) fp) 0) / of_nat p \\<in> \\<int>", "obtain S where S: \"(\\<Sum>i=p..s + p. poly ((pderiv ^^ i) fp) 0) = of_int S * p\""], ["proof (prove)\nusing this:\n  (\\<Sum>i = p..s + p. poly ((pderiv ^^ i) fp) 0) / of_nat p \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        (\\<Sum>i = p..s + p. poly ((pderiv ^^ i) fp) 0) =\n        of_int (of_int S * int p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i = p..s + p. poly ((pderiv ^^ i) fp) 0) / of_nat p \\<in> \\<int>\n  1 < p\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        (\\<Sum>i = p..s + p. poly ((pderiv ^^ i) fp) 0) =\n        of_int (of_int S * int p) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: Ints_cases simp: field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>i = p..s + p. poly ((pderiv ^^ i) fp) 0) =\n  of_int (of_int S * int p)\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"F 0 = (\\<Sum>i\\<le>s + p. poly ((pderiv ^^ i) fp) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F 0 = (\\<Sum>i\\<le>s + p. poly ((pderiv ^^ i) fp) 0)", "by (auto simp: F_def Fp_def poly_sum)"], ["proof (state)\nthis:\n  F 0 = (\\<Sum>i\\<le>s + p. poly ((pderiv ^^ i) fp) 0)\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  F 0 = (\\<Sum>i\\<le>s + p. poly ((pderiv ^^ i) fp) 0)\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = (\\<Sum>i\\<in>insert (p - 1) {p..s + p}. poly ((pderiv ^^ i) fp) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>s + p. poly ((pderiv ^^ i) fp) 0) =\n    (\\<Sum>i\\<in>insert (p - 1) {p..s + p}. poly ((pderiv ^^ i) fp) 0)", "proof (intro sum.mono_neutral_right ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {..s + p}\n 2. insert (p - 1) {p..s + p} \\<subseteq> {..s + p}\n 3. \\<And>i.\n       i \\<in> {..s + p} - insert (p - 1) {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ i) fp) 0 = 0", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {..s + p}\n 2. insert (p - 1) {p..s + p} \\<subseteq> {..s + p}\n 3. \\<And>i.\n       i \\<in> {..s + p} - insert (p - 1) {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ i) fp) 0 = 0", "assume i: \"i \\<in> {..s + p} - insert (p - 1) {p..s + p}\""], ["proof (state)\nthis:\n  i \\<in> {..s + p} - insert (p - 1) {p..s + p}\n\ngoal (3 subgoals):\n 1. finite {..s + p}\n 2. insert (p - 1) {p..s + p} \\<subseteq> {..s + p}\n 3. \\<And>i.\n       i \\<in> {..s + p} - insert (p - 1) {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ i) fp) 0 = 0", "hence \"i < p - 1\""], ["proof (prove)\nusing this:\n  i \\<in> {..s + p} - insert (p - 1) {p..s + p}\n\ngoal (1 subgoal):\n 1. i < p - 1", "by auto"], ["proof (state)\nthis:\n  i < p - 1\n\ngoal (3 subgoals):\n 1. finite {..s + p}\n 2. insert (p - 1) {p..s + p} \\<subseteq> {..s + p}\n 3. \\<And>i.\n       i \\<in> {..s + p} - insert (p - 1) {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ i) fp) 0 = 0", "have \"Polynomial.monom 1 (p - 1) dvd fp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.monom 1 (p - 1) dvd fp", "by (auto simp: fp_def intro: dvd_smult)"], ["proof (state)\nthis:\n  Polynomial.monom 1 (p - 1) dvd fp\n\ngoal (3 subgoals):\n 1. finite {..s + p}\n 2. insert (p - 1) {p..s + p} \\<subseteq> {..s + p}\n 3. \\<And>i.\n       i \\<in> {..s + p} - insert (p - 1) {p..s + p} \\<Longrightarrow>\n       poly ((pderiv ^^ i) fp) 0 = 0", "with i"], ["proof (chain)\npicking this:\n  i \\<in> {..s + p} - insert (p - 1) {p..s + p}\n  Polynomial.monom 1 (p - 1) dvd fp", "show \"poly ((pderiv ^^ i) fp) 0 = 0\""], ["proof (prove)\nusing this:\n  i \\<in> {..s + p} - insert (p - 1) {p..s + p}\n  Polynomial.monom 1 (p - 1) dvd fp\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ i) fp) 0 = 0", "by (intro poly_higher_pderiv_aux1'[of _ \"p - 1\"]) (auto simp: Polynomial.monom_altdef)"], ["proof (state)\nthis:\n  poly ((pderiv ^^ i) fp) 0 = 0\n\ngoal (2 subgoals):\n 1. finite {..s + p}\n 2. insert (p - 1) {p..s + p} \\<subseteq> {..s + p}", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>s + p. poly ((pderiv ^^ i) fp) 0) =\n  (\\<Sum>i\\<in>insert (p - 1) {p..s + p}. poly ((pderiv ^^ i) fp) 0)\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>s + p. poly ((pderiv ^^ i) fp) 0) =\n  (\\<Sum>i\\<in>insert (p - 1) {p..s + p}. poly ((pderiv ^^ i) fp) 0)\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = poly ((pderiv ^^ (p - 1)) fp) 0 + of_int S * of_nat p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>insert (p - 1) {p..s + p}. poly ((pderiv ^^ i) fp) 0) =\n    poly ((pderiv ^^ (p - 1)) fp) 0 + of_int S * of_nat p", "using \\<open>p > 1\\<close> S"], ["proof (prove)\nusing this:\n  1 < p\n  (\\<Sum>i = p..s + p. poly ((pderiv ^^ i) fp) 0) =\n  of_int (of_int S * int p)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>insert (p - 1) {p..s + p}. poly ((pderiv ^^ i) fp) 0) =\n    poly ((pderiv ^^ (p - 1)) fp) 0 + of_int S * of_nat p", "by (subst sum.insert) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert (p - 1) {p..s + p}. poly ((pderiv ^^ i) fp) 0) =\n  poly ((pderiv ^^ (p - 1)) fp) 0 + of_int S * of_nat p\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>insert (p - 1) {p..s + p}. poly ((pderiv ^^ i) fp) 0) =\n  poly ((pderiv ^^ (p - 1)) fp) 0 + of_int S * of_nat p\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly ((pderiv ^^ (p - 1)) fp) 0 = of_int (c ^ s * poly Q 0 ^ p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ (p - 1)) fp) 0 = of_int (int (c ^ s) * poly Q 0 ^ p)", "using poly_higher_pderiv_aux2[of \"p - 1\" 0 \"of_int_poly Q ^ p :: complex poly\"]"], ["proof (prove)\nusing this:\n  poly ((pderiv ^^ (p - 1)) ([:- 0, 1:] ^ (p - 1) * of_int_poly Q ^ p)) 0 =\n  fact (p - 1) * poly (of_int_poly Q ^ p) 0\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ (p - 1)) fp) 0 = of_int (int (c ^ s) * poly Q 0 ^ p)", "by (simp add: fp_def higher_pderiv_smult Polynomial.monom_altdef)"], ["proof (state)\nthis:\n  poly ((pderiv ^^ (p - 1)) fp) 0 = of_int (int (c ^ s) * poly Q 0 ^ p)\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  F 0 = of_int (int (c ^ s) * poly Q 0 ^ p) + of_int S * of_nat p", "have \"F 0 = of_int (S * int p + c ^ s * poly Q 0 ^ p)\""], ["proof (prove)\nusing this:\n  F 0 = of_int (int (c ^ s) * poly Q 0 ^ p) + of_int S * of_nat p\n\ngoal (1 subgoal):\n 1. F 0 = of_int (S * int p + int (c ^ s) * poly Q 0 ^ p)", "by simp"], ["proof (state)\nthis:\n  F 0 = of_int (S * int p + int (c ^ s) * poly Q 0 ^ p)\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  F 0 = of_int (S * int p + int (c ^ s) * poly Q 0 ^ p)\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"coprime p c\" \"coprime (int p) (poly Q 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime p c &&& coprime (int p) (poly Q 0)", "using p"], ["proof (prove)\nusing this:\n  prime p\n  nat \\<bar>poly Q 0\\<bar> < p\n  c < p\n  A < p\n\ngoal (1 subgoal):\n 1. coprime p c &&& coprime (int p) (poly Q 0)", "by (auto intro!: prime_imp_coprime dest: dvd_imp_le_int[rotated])"], ["proof (state)\nthis:\n  coprime p c\n  coprime (int p) (poly Q 0)\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"coprime (int p) (c ^ s * poly Q 0 ^ p)\""], ["proof (prove)\nusing this:\n  coprime p c\n  coprime (int p) (poly Q 0)\n\ngoal (1 subgoal):\n 1. coprime (int p) (int (c ^ s) * poly Q 0 ^ p)", "by auto"], ["proof (state)\nthis:\n  coprime (int p) (int (c ^ s) * poly Q 0 ^ p)\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"coprime (int p) (S * int p + c ^ s * poly Q 0 ^ p)\""], ["proof (prove)\nusing this:\n  coprime (int p) (int (c ^ s) * poly Q 0 ^ p)\n\ngoal (1 subgoal):\n 1. coprime (int p) (S * int p + int (c ^ s) * poly Q 0 ^ p)", "unfolding coprime_iff_gcd_eq_1 gcd_add_mult"], ["proof (prove)\nusing this:\n  gcd (int p) (int (c ^ s) * poly Q 0 ^ p) = 1\n\ngoal (1 subgoal):\n 1. gcd (int p) (int (c ^ s) * poly Q 0 ^ p) = 1", "by auto"], ["proof (state)\nthis:\n  coprime (int p) (S * int p + int (c ^ s) * poly Q 0 ^ p)\n\ngoal (1 subgoal):\n 1. (\\<And>F0.\n        \\<lbrakk>F 0 = of_int F0; coprime (int p) F0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  F 0 = of_int (S * int p + int (c ^ s) * poly Q 0 ^ p)\n  coprime (int p) (S * int p + int (c ^ s) * poly Q 0 ^ p)", "show ?thesis"], ["proof (prove)\nusing this:\n  F 0 = of_int (S * int p + int (c ^ s) * poly Q 0 ^ p)\n  coprime (int p) (S * int p + int (c ^ s) * poly Q 0 ^ p)\n\ngoal (1 subgoal):\n 1. thesis", "using that[of \"S * int p + c ^ s * poly Q 0 ^ p\"]"], ["proof (prove)\nusing this:\n  F 0 = of_int (S * int p + int (c ^ s) * poly Q 0 ^ p)\n  coprime (int p) (S * int p + int (c ^ s) * poly Q 0 ^ p)\n  \\<lbrakk>F 0 = of_int (S * int p + int (c ^ s) * poly Q 0 ^ p);\n   coprime (int p) (S * int p + int (c ^ s) * poly Q 0 ^ p)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed\n\n    \\<comment> \\<open>Putting everything together, we have shown that $\\sum I(x_i)$ is an integer coprime\n        to $p$, and therefore a nonzero integer, and therefore has an absolute value of at least 1.\\<close>"], ["proof (state)\nthis:\n  F 0 = of_int F0\n  coprime (int p) F0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "have \"(\\<Sum>Y\\<in>Roots'. I (root' Y)) = F 0 * (\\<Sum>Y\\<in>Roots'. exp (root' Y)) - (\\<Sum>Y\\<in>Roots'. F (root' Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<in>Roots'. I (root' Y)) =\n    F 0 * (\\<Sum>Y\\<in>Roots'. exp (root' Y)) -\n    (\\<Sum>Y\\<in>Roots'. F (root' Y))", "by (simp add: I_altdef sum_subtractf sum_distrib_left sum_distrib_right algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots'. I (root' Y)) =\n  F 0 * (\\<Sum>Y\\<in>Roots'. exp (root' Y)) -\n  (\\<Sum>Y\\<in>Roots'. F (root' Y))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "also"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots'. I (root' Y)) =\n  F 0 * (\\<Sum>Y\\<in>Roots'. exp (root' Y)) -\n  (\\<Sum>Y\\<in>Roots'. F (root' Y))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "have \"\\<dots> = -(of_int (F0 * int A) +\n                      (\\<Sum>i\\<le>s+p. \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F 0 * (\\<Sum>Y\\<in>Roots'. exp (root' Y)) -\n    (\\<Sum>Y\\<in>Roots'. F (root' Y)) =\n    - (of_int (F0 * int A) +\n       (\\<Sum>i\\<le>s + p.\n           \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)))", "using F0"], ["proof (prove)\nusing this:\n  F 0 = of_int F0\n  coprime (int p) F0\n\ngoal (1 subgoal):\n 1. F 0 * (\\<Sum>Y\\<in>Roots'. exp (root' Y)) -\n    (\\<Sum>Y\\<in>Roots'. F (root' Y)) =\n    - (of_int (F0 * int A) +\n       (\\<Sum>i\\<le>s + p.\n           \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)))", "by (simp add: Roots'_def eq F_def Fp_def poly_sum sum.swap[of _ \"{..s+p}\"])"], ["proof (state)\nthis:\n  F 0 * (\\<Sum>Y\\<in>Roots'. exp (root' Y)) -\n  (\\<Sum>Y\\<in>Roots'. F (root' Y)) =\n  - (of_int (F0 * int A) +\n     (\\<Sum>i\\<le>s + p.\n         \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "also"], ["proof (state)\nthis:\n  F 0 * (\\<Sum>Y\\<in>Roots'. exp (root' Y)) -\n  (\\<Sum>Y\\<in>Roots'. F (root' Y)) =\n  - (of_int (F0 * int A) +\n     (\\<Sum>i\\<le>s + p.\n         \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "have \"(\\<Sum>i\\<le>s+p. \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) =\n                 (\\<Sum>i=p..s+p. \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>s + p.\n        \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) =\n    (\\<Sum>i = p..s + p.\n        \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y))", "proof (intro sum.mono_neutral_right ballI sum.neutral)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {..s + p}\n 2. {p..s + p} \\<subseteq> {..s + p}\n 3. \\<And>i x.\n       \\<lbrakk>i \\<in> {..s + p} - {p..s + p}; x \\<in> Roots'\\<rbrakk>\n       \\<Longrightarrow> poly ((pderiv ^^ i) fp) (root' x) = 0", "fix i Y"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {..s + p}\n 2. {p..s + p} \\<subseteq> {..s + p}\n 3. \\<And>i x.\n       \\<lbrakk>i \\<in> {..s + p} - {p..s + p}; x \\<in> Roots'\\<rbrakk>\n       \\<Longrightarrow> poly ((pderiv ^^ i) fp) (root' x) = 0", "assume i: \"i \\<in> {..s+p} - {p..s+p}\" and Y: \"Y \\<in> Roots'\""], ["proof (state)\nthis:\n  i \\<in> {..s + p} - {p..s + p}\n  Y \\<in> Roots'\n\ngoal (3 subgoals):\n 1. finite {..s + p}\n 2. {p..s + p} \\<subseteq> {..s + p}\n 3. \\<And>i x.\n       \\<lbrakk>i \\<in> {..s + p} - {p..s + p}; x \\<in> Roots'\\<rbrakk>\n       \\<Longrightarrow> poly ((pderiv ^^ i) fp) (root' x) = 0", "have \"[:-root' Y, 1:] ^ p dvd of_int_poly Q ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- root' Y, 1:] ^ p dvd of_int_poly Q ^ p", "by (intro dvd_power_same) (auto simp: dvd_iff_poly_eq_0 Y)"], ["proof (state)\nthis:\n  [:- root' Y, 1:] ^ p dvd of_int_poly Q ^ p\n\ngoal (3 subgoals):\n 1. finite {..s + p}\n 2. {p..s + p} \\<subseteq> {..s + p}\n 3. \\<And>i x.\n       \\<lbrakk>i \\<in> {..s + p} - {p..s + p}; x \\<in> Roots'\\<rbrakk>\n       \\<Longrightarrow> poly ((pderiv ^^ i) fp) (root' x) = 0", "hence \"[:-root' Y, 1:] ^ p dvd fp\""], ["proof (prove)\nusing this:\n  [:- root' Y, 1:] ^ p dvd of_int_poly Q ^ p\n\ngoal (1 subgoal):\n 1. [:- root' Y, 1:] ^ p dvd fp", "by (auto simp: fp_def intro!: dvd_smult)"], ["proof (state)\nthis:\n  [:- root' Y, 1:] ^ p dvd fp\n\ngoal (3 subgoals):\n 1. finite {..s + p}\n 2. {p..s + p} \\<subseteq> {..s + p}\n 3. \\<And>i x.\n       \\<lbrakk>i \\<in> {..s + p} - {p..s + p}; x \\<in> Roots'\\<rbrakk>\n       \\<Longrightarrow> poly ((pderiv ^^ i) fp) (root' x) = 0", "thus \"poly ((pderiv ^^ i) fp) (root' Y) = 0\""], ["proof (prove)\nusing this:\n  [:- root' Y, 1:] ^ p dvd fp\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ i) fp) (root' Y) = 0", "using i"], ["proof (prove)\nusing this:\n  [:- root' Y, 1:] ^ p dvd fp\n  i \\<in> {..s + p} - {p..s + p}\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ i) fp) (root' Y) = 0", "by (intro poly_higher_pderiv_aux1') auto"], ["proof (state)\nthis:\n  poly ((pderiv ^^ i) fp) (root' Y) = 0\n\ngoal (2 subgoals):\n 1. finite {..s + p}\n 2. {p..s + p} \\<subseteq> {..s + p}", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>s + p.\n      \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) =\n  (\\<Sum>i = p..s + p.\n      \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>s + p.\n      \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) =\n  (\\<Sum>i = p..s + p.\n      \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "have \"\\<dots> = of_int (K * int p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = p..s + p.\n        \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) =\n    of_int (K * int p)", "using K"], ["proof (prove)\nusing this:\n  (\\<Sum>i = p..s + p.\n      \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) =\n  of_int (of_int K * int p)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = p..s + p.\n        \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) =\n    of_int (K * int p)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i = p..s + p.\n      \\<Sum>Y\\<in>Roots'. poly ((pderiv ^^ i) fp) (root' Y)) =\n  of_int (K * int p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>Y\\<in>Roots'. I (root' Y)) =\n  - (of_int (F0 * int A) + of_int (K * int p))", "have \"(\\<Sum>Y\\<in>Roots'. I (root' Y)) = -of_int (K * int p + F0 * int A)\""], ["proof (prove)\nusing this:\n  (\\<Sum>Y\\<in>Roots'. I (root' Y)) =\n  - (of_int (F0 * int A) + of_int (K * int p))\n\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<in>Roots'. I (root' Y)) = - of_int (K * int p + F0 * int A)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots'. I (root' Y)) = - of_int (K * int p + F0 * int A)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots'. I (root' Y)) = - of_int (K * int p + F0 * int A)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "have \"coprime p A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime p A", "using p \\<open>A > 0\\<close>"], ["proof (prove)\nusing this:\n  prime p\n  nat \\<bar>poly Q 0\\<bar> < p\n  c < p\n  A < p\n  0 < A\n\ngoal (1 subgoal):\n 1. coprime p A", "by (intro prime_imp_coprime) (auto dest!: dvd_imp_le)"], ["proof (state)\nthis:\n  coprime p A\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "hence \"coprime (int p) (F0 * int A)\""], ["proof (prove)\nusing this:\n  coprime p A\n\ngoal (1 subgoal):\n 1. coprime (int p) (F0 * int A)", "using F0"], ["proof (prove)\nusing this:\n  coprime p A\n  F 0 = of_int F0\n  coprime (int p) F0\n\ngoal (1 subgoal):\n 1. coprime (int p) (F0 * int A)", "by auto"], ["proof (state)\nthis:\n  coprime (int p) (F0 * int A)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "hence \"coprime (int p) (K * int p + F0 * int A)\""], ["proof (prove)\nusing this:\n  coprime (int p) (F0 * int A)\n\ngoal (1 subgoal):\n 1. coprime (int p) (K * int p + F0 * int A)", "using F0"], ["proof (prove)\nusing this:\n  coprime (int p) (F0 * int A)\n  F 0 = of_int F0\n  coprime (int p) F0\n\ngoal (1 subgoal):\n 1. coprime (int p) (K * int p + F0 * int A)", "unfolding coprime_iff_gcd_eq_1 gcd_add_mult"], ["proof (prove)\nusing this:\n  gcd (int p) (F0 * int A) = 1\n  F 0 = of_int F0\n  gcd (int p) F0 = 1\n\ngoal (1 subgoal):\n 1. gcd (int p) (F0 * int A) = 1", "by auto"], ["proof (state)\nthis:\n  coprime (int p) (K * int p + F0 * int A)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "hence \"K * int p + F0 * int A \\<noteq> 0\""], ["proof (prove)\nusing this:\n  coprime (int p) (K * int p + F0 * int A)\n\ngoal (1 subgoal):\n 1. K * int p + F0 * int A \\<noteq> 0", "using p"], ["proof (prove)\nusing this:\n  coprime (int p) (K * int p + F0 * int A)\n  prime p\n  nat \\<bar>poly Q 0\\<bar> < p\n  c < p\n  A < p\n\ngoal (1 subgoal):\n 1. K * int p + F0 * int A \\<noteq> 0", "by (intro notI) auto"], ["proof (state)\nthis:\n  K * int p + F0 * int A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "hence \"norm (-of_int (K * int p + F0 * int A) :: complex) \\<ge> 1\""], ["proof (prove)\nusing this:\n  K * int p + F0 * int A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> cmod (- of_int (K * int p + F0 * int A))", "unfolding norm_minus_cancel norm_of_int"], ["proof (prove)\nusing this:\n  K * int p + F0 * int A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> \\<bar>real_of_int (K * int p + F0 * int A)\\<bar>", "by linarith"], ["proof (state)\nthis:\n  1 \\<le> cmod (- of_int (K * int p + F0 * int A))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>Y\\<in>Roots'. I (root' Y)) = - of_int (K * int p + F0 * int A)\n  1 \\<le> cmod (- of_int (K * int p + F0 * int A))", "have \"1 \\<le> norm (\\<Sum>Y\\<in>Roots'. I (root' Y))\""], ["proof (prove)\nusing this:\n  (\\<Sum>Y\\<in>Roots'. I (root' Y)) = - of_int (K * int p + F0 * int A)\n  1 \\<le> cmod (- of_int (K * int p + F0 * int A))\n\ngoal (1 subgoal):\n 1. 1 \\<le> cmod (\\<Sum>Y\\<in>Roots'. I (root' Y))", "by metis\n\n    \\<comment> \\<open>The M--L bound on the integral gives us an upper bound:\\<close>"], ["proof (state)\nthis:\n  1 \\<le> cmod (\\<Sum>Y\\<in>Roots'. I (root' Y))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "also"], ["proof (state)\nthis:\n  1 \\<le> cmod (\\<Sum>Y\\<in>Roots'. I (root' Y))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "have \"norm (\\<Sum>Y\\<in>Roots'. I (root' Y)) \\<le>\n                 (\\<Sum>Y\\<in>Roots'. norm (root' Y) * exp (norm (root' Y)) * fp_ub p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<Sum>Y\\<in>Roots'. I (root' Y))\n    \\<le> (\\<Sum>Y\\<in>Roots'.\n             cmod (root' Y) * exp (cmod (root' Y)) * fp_ub p)", "proof (intro sum_norm_le lindemann_weierstrass_integral_bound fp_ub fp_ub_nonneg)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>x \\<in> Roots'; t \\<in> closed_segment 0 (root' x)\\<rbrakk>\n       \\<Longrightarrow> t \\<in> cball 0 Radius", "fix Y u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>x \\<in> Roots'; t \\<in> closed_segment 0 (root' x)\\<rbrakk>\n       \\<Longrightarrow> t \\<in> cball 0 Radius", "assume *: \"Y \\<in> Roots'\" \"u \\<in> closed_segment 0 (root' Y)\""], ["proof (state)\nthis:\n  Y \\<in> Roots'\n  u \\<in> closed_segment 0 (root' Y)\n\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>x \\<in> Roots'; t \\<in> closed_segment 0 (root' x)\\<rbrakk>\n       \\<Longrightarrow> t \\<in> cball 0 Radius", "hence \"closed_segment 0 (root' Y) \\<subseteq> cball 0 Radius\""], ["proof (prove)\nusing this:\n  Y \\<in> Roots'\n  u \\<in> closed_segment 0 (root' Y)\n\ngoal (1 subgoal):\n 1. closed_segment 0 (root' Y) \\<subseteq> cball 0 Radius", "using \\<open>Radius \\<ge> 0\\<close> Radius[of Y]"], ["proof (prove)\nusing this:\n  Y \\<in> Roots'\n  u \\<in> closed_segment 0 (root' Y)\n  0 \\<le> Radius\n  Y \\<in> Roots' \\<Longrightarrow> cmod (root' Y) \\<le> Radius\n\ngoal (1 subgoal):\n 1. closed_segment 0 (root' Y) \\<subseteq> cball 0 Radius", "by (intro closed_segment_subset) auto"], ["proof (state)\nthis:\n  closed_segment 0 (root' Y) \\<subseteq> cball 0 Radius\n\ngoal (1 subgoal):\n 1. \\<And>x t.\n       \\<lbrakk>x \\<in> Roots'; t \\<in> closed_segment 0 (root' x)\\<rbrakk>\n       \\<Longrightarrow> t \\<in> cball 0 Radius", "with *"], ["proof (chain)\npicking this:\n  Y \\<in> Roots'\n  u \\<in> closed_segment 0 (root' Y)\n  closed_segment 0 (root' Y) \\<subseteq> cball 0 Radius", "show \"u \\<in> cball 0 Radius\""], ["proof (prove)\nusing this:\n  Y \\<in> Roots'\n  u \\<in> closed_segment 0 (root' Y)\n  closed_segment 0 (root' Y) \\<subseteq> cball 0 Radius\n\ngoal (1 subgoal):\n 1. u \\<in> cball 0 Radius", "by auto"], ["proof (state)\nthis:\n  u \\<in> cball 0 Radius\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cmod (\\<Sum>Y\\<in>Roots'. I (root' Y))\n  \\<le> (\\<Sum>Y\\<in>Roots'.\n           cmod (root' Y) * exp (cmod (root' Y)) * fp_ub p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "also"], ["proof (state)\nthis:\n  cmod (\\<Sum>Y\\<in>Roots'. I (root' Y))\n  \\<le> (\\<Sum>Y\\<in>Roots'.\n           cmod (root' Y) * exp (cmod (root' Y)) * fp_ub p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "have \"\\<dots> \\<le> (\\<Sum>Y\\<in>Roots'. Radius * exp (Radius) * fp_ub p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<in>Roots'. cmod (root' Y) * exp (cmod (root' Y)) * fp_ub p)\n    \\<le> (\\<Sum>Y\\<in>Roots'. Radius * exp Radius * fp_ub p)", "using Radius"], ["proof (prove)\nusing this:\n  ?Y \\<in> Roots' \\<Longrightarrow> cmod (root' ?Y) \\<le> Radius\n\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<in>Roots'. cmod (root' Y) * exp (cmod (root' Y)) * fp_ub p)\n    \\<le> (\\<Sum>Y\\<in>Roots'. Radius * exp Radius * fp_ub p)", "by (intro sum_mono mult_right_mono mult_mono fp_ub_nonneg \\<open>Radius \\<ge> 0\\<close>) auto"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots'. cmod (root' Y) * exp (cmod (root' Y)) * fp_ub p)\n  \\<le> (\\<Sum>Y\\<in>Roots'. Radius * exp Radius * fp_ub p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "also"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots'. cmod (root' Y) * exp (cmod (root' Y)) * fp_ub p)\n  \\<le> (\\<Sum>Y\\<in>Roots'. Radius * exp Radius * fp_ub p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "have \"\\<dots> = C * fp_ub p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<in>Roots'. Radius * exp Radius * fp_ub p) = C * fp_ub p", "by (simp add: C_def)"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots'. Radius * exp Radius * fp_ub p) = C * fp_ub p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>pa\\<in>{nat \\<bar>poly Q 0\\<bar>, c, A}. pa < p;\n        prime p\\<rbrakk>\n       \\<Longrightarrow> 1 \\<le> C * fp_ub p", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> C * fp_ub p", "show \"1 \\<le> C * fp_ub p\""], ["proof (prove)\nusing this:\n  1 \\<le> C * fp_ub p\n\ngoal (1 subgoal):\n 1. 1 \\<le> C * fp_ub p", "."], ["proof (state)\nthis:\n  1 \\<le> C * fp_ub p\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>It now only remains to show that this inequality is inconsistent for large $p$.\n      This is obvious, since the upper bound is an exponential divided by a factorial and \n      therefore clearly tends to zero.\\<close>"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in primes_at_top. 1 \\<le> C * fp_ub p\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"(\\<lambda>p. C * fp_ub p) \\<in> \\<Theta>(\\<lambda>p. (C / (Radius * \\<bar>c\\<bar>)) * (p / 2 ^ p) *\n                                     ((2 * \\<bar>c\\<bar> ^ r * Radius * Q_ub) ^ p / fact p))\"\n    (is \"_ \\<in> \\<Theta>(?f)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p. C * fp_ub p)\n    \\<in> \\<Theta>(\\<lambda>p.\n                      C / (Radius * real_of_int \\<bar>int c\\<bar>) *\n                      (real p / 2 ^ p) *\n                      ((real_of_int (2 * \\<bar>int c\\<bar> ^ r) * Radius *\n                        Q_ub) ^\n                       p /\n                       fact p))", "using degree_Q card_Roots' \\<open>Radius > 0\\<close>"], ["proof (prove)\nusing this:\n  Polynomial.degree (of_int_poly Q) = card Roots'\n  0 < card Roots'\n  0 < Radius\n\ngoal (1 subgoal):\n 1. (\\<lambda>p. C * fp_ub p)\n    \\<in> \\<Theta>(\\<lambda>p.\n                      C / (Radius * real_of_int \\<bar>int c\\<bar>) *\n                      (real p / 2 ^ p) *\n                      ((real_of_int (2 * \\<bar>int c\\<bar> ^ r) * Radius *\n                        Q_ub) ^\n                       p /\n                       fact p))", "by (intro bigthetaI_cong eventually_mono[OF eventually_gt_at_top[of 0]])\n       (auto simp: fact_reduce power_mult [symmetric] r_def\n                   fp_ub_def power_diff power_mult_distrib)"], ["proof (state)\nthis:\n  (\\<lambda>p. C * fp_ub p)\n  \\<in> \\<Theta>(\\<lambda>p.\n                    C / (Radius * real_of_int \\<bar>int c\\<bar>) *\n                    (real p / 2 ^ p) *\n                    ((real_of_int (2 * \\<bar>int c\\<bar> ^ r) * Radius *\n                      Q_ub) ^\n                     p /\n                     fact p))\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<lambda>p. C * fp_ub p)\n  \\<in> \\<Theta>(\\<lambda>p.\n                    C / (Radius * real_of_int \\<bar>int c\\<bar>) *\n                    (real p / 2 ^ p) *\n                    ((real_of_int (2 * \\<bar>int c\\<bar> ^ r) * Radius *\n                      Q_ub) ^\n                     p /\n                     fact p))\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"?f \\<in> o(\\<lambda>p. 1 * 1 * 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p.\n        C / (Radius * real_of_int \\<bar>int c\\<bar>) * (real p / 2 ^ p) *\n        ((real_of_int (2 * \\<bar>int c\\<bar> ^ r) * Radius * Q_ub) ^ p /\n         fact p))\n    \\<in> o(\\<lambda>p. 1 * 1 * 1)", "proof (intro landau_o.big_small_mult landau_o.big_mult)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>x. C / (Radius * real_of_int \\<bar>int c\\<bar>))\n    \\<in> O(\\<lambda>x. 1)\n 2. (\\<lambda>x. real x / 2 ^ x) \\<in> O(\\<lambda>x. 1)\n 3. (\\<lambda>x.\n        (real_of_int (2 * \\<bar>int c\\<bar> ^ r) * Radius * Q_ub) ^ x /\n        fact x)\n    \\<in> o(\\<lambda>x. 1)", "have \"(\\<lambda>x. (real_of_int (2 * \\<bar>c\\<bar> ^ r) * Radius * Q_ub) ^ x / fact x) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (real_of_int (2 * \\<bar>int c\\<bar> ^ r) * Radius * Q_ub) ^ x /\n        fact x)\n    \\<longlonglongrightarrow> 0", "by (intro power_over_fact_tendsto_0)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      (real_of_int (2 * \\<bar>int c\\<bar> ^ r) * Radius * Q_ub) ^ x /\n      fact x)\n  \\<longlonglongrightarrow> 0\n\ngoal (3 subgoals):\n 1. (\\<lambda>x. C / (Radius * real_of_int \\<bar>int c\\<bar>))\n    \\<in> O(\\<lambda>x. 1)\n 2. (\\<lambda>x. real x / 2 ^ x) \\<in> O(\\<lambda>x. 1)\n 3. (\\<lambda>x.\n        (real_of_int (2 * \\<bar>int c\\<bar> ^ r) * Radius * Q_ub) ^ x /\n        fact x)\n    \\<in> o(\\<lambda>x. 1)", "thus \"(\\<lambda>x. (real_of_int (2 * \\<bar>c\\<bar> ^ r) * Radius * Q_ub) ^ x / fact x) \\<in> o(\\<lambda>x. 1)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      (real_of_int (2 * \\<bar>int c\\<bar> ^ r) * Radius * Q_ub) ^ x /\n      fact x)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (real_of_int (2 * \\<bar>int c\\<bar> ^ r) * Radius * Q_ub) ^ x /\n        fact x)\n    \\<in> o(\\<lambda>x. 1)", "by (intro smalloI_tendsto) auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      (real_of_int (2 * \\<bar>int c\\<bar> ^ r) * Radius * Q_ub) ^ x /\n      fact x)\n  \\<in> o(\\<lambda>x. 1)\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. C / (Radius * real_of_int \\<bar>int c\\<bar>))\n    \\<in> O(\\<lambda>x. 1)\n 2. (\\<lambda>x. real x / 2 ^ x) \\<in> O(\\<lambda>x. 1)", "qed real_asymp+"], ["proof (state)\nthis:\n  (\\<lambda>p.\n      C / (Radius * real_of_int \\<bar>int c\\<bar>) * (real p / 2 ^ p) *\n      ((real_of_int (2 * \\<bar>int c\\<bar> ^ r) * Radius * Q_ub) ^ p /\n       fact p))\n  \\<in> o(\\<lambda>p. 1 * 1 * 1)\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>p. C * fp_ub p) \\<in> o(\\<lambda>p. 1 * 1 * 1)", "have \"(\\<lambda>p. C * fp_ub p) \\<in> o(\\<lambda>_. 1)\""], ["proof (prove)\nusing this:\n  (\\<lambda>p. C * fp_ub p) \\<in> o(\\<lambda>p. 1 * 1 * 1)\n\ngoal (1 subgoal):\n 1. (\\<lambda>p. C * fp_ub p) \\<in> o(\\<lambda>_. 1)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>p. C * fp_ub p) \\<in> o(\\<lambda>_. 1)\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "from smalloD_tendsto[OF this]"], ["proof (chain)\npicking this:\n  (\\<lambda>x. C * fp_ub x / 1) \\<longlonglongrightarrow> 0", "have \"(\\<lambda>p. C * fp_ub p) \\<longlonglongrightarrow> 0\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. C * fp_ub x / 1) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>p. C * fp_ub p) \\<longlonglongrightarrow> 0", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>p. C * fp_ub p) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "hence \"eventually (\\<lambda>p. C * fp_ub p < 1) at_top\""], ["proof (prove)\nusing this:\n  (\\<lambda>p. C * fp_ub p) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially. C * fp_ub p < 1", "by (intro order_tendstoD) auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in sequentially. C * fp_ub p < 1\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "hence \"eventually (\\<lambda>p. C * fp_ub p < 1) primes_at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in sequentially. C * fp_ub p < 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in primes_at_top. C * fp_ub p < 1", "unfolding primes_at_top_def eventually_inf_principal"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in sequentially. C * fp_ub p < 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially.\n       x \\<in> Collect prime \\<longrightarrow> C * fp_ub x < 1", "by eventually_elim auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in primes_at_top. C * fp_ub p < 1\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in primes_at_top. C * fp_ub p < 1\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "note \\<open>eventually (\\<lambda>p. C * fp_ub p \\<ge> 1) primes_at_top\\<close>\n  \\<comment> \\<open>We therefore have a contradiction for any sufficiently large prime.\\<close>"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in primes_at_top. 1 \\<le> C * fp_ub p\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F p in primes_at_top. C * fp_ub p < 1\n  \\<forall>\\<^sub>F p in primes_at_top. 1 \\<le> C * fp_ub p", "have \"eventually (\\<lambda>p. False) primes_at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in primes_at_top. C * fp_ub p < 1\n  \\<forall>\\<^sub>F p in primes_at_top. 1 \\<le> C * fp_ub p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in primes_at_top. False", "by eventually_elim auto\n\n  \\<comment> \\<open>Since sufficiently large primes always exist, this concludes the theorem.\\<close>"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in primes_at_top. False\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in primes_at_top. False\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "have \"frequently (\\<lambda>p. prime p) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frequently prime sequentially", "using primes_infinite"], ["proof (prove)\nusing this:\n  infinite {p. prime p}\n\ngoal (1 subgoal):\n 1. frequently prime sequentially", "by (simp add: cofinite_eq_sequentially[symmetric] Inf_many_def)"], ["proof (state)\nthis:\n  frequently prime sequentially\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * complex_of_real pi) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F p in primes_at_top. False\n  frequently prime sequentially", "show False"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in primes_at_top. False\n  frequently prime sequentially\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: frequently_def eventually_inf_principal primes_at_top_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem transcendental_pi: \"\\<not>algebraic pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic pi", "using transcendental_i_pi"], ["proof (prove)\nusing this:\n  \\<not> algebraic (\\<i> * complex_of_real pi)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic pi", "by (simp add: algebraic_times_i_iff)"], ["", "end"]]}