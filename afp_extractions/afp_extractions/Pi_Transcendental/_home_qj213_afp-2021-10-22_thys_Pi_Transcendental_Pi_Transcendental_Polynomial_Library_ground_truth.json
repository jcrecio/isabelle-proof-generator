{"file_name": "/home/qj213/afp-2021-10-22/thys/Pi_Transcendental/Pi_Transcendental_Polynomial_Library.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pi_Transcendental", "problem_names": ["lemma Ints_sum: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> \\<int>) \\<Longrightarrow> sum f A \\<in> \\<int>\"", "lemma Ints_prod: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> \\<int>) \\<Longrightarrow> prod f A \\<in> \\<int>\"", "lemma sum_in_Rats [intro]: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> \\<rat>) \\<Longrightarrow> sum f A \\<in> \\<rat>\"", "lemma prod_in_Rats [intro]: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> \\<rat>) \\<Longrightarrow> prod f A \\<in> \\<rat>\"", "lemma poly_cnj: \"cnj (poly p z) = poly (map_poly cnj p) (cnj z)\"", "lemma poly_cnj_real:\n  assumes \"\\<And>n. poly.coeff p n \\<in> \\<real>\"\n  shows   \"cnj (poly p z) = poly p (cnj z)\"", "lemma real_poly_cnj_root_iff:\n  assumes \"\\<And>n. poly.coeff p n \\<in> \\<real>\"\n  shows   \"poly p (cnj z) = 0 \\<longleftrightarrow> poly p z = 0\"", "lemma coeff_pcompose_linear:\n  fixes p :: \"'a :: comm_semiring_1 poly\"\n  shows \"coeff (pcompose p [:0, c:]) i = c ^ i * coeff p i\"", "lemma coeff_pCons': \"poly.coeff (pCons c p) n = (if n = 0 then c else poly.coeff p (n - 1))\"", "lemma prod_smult: \"(\\<Prod>x\\<in>A. Polynomial.smult (c x) (p x)) = Polynomial.smult (prod c A) (prod p A)\"", "lemma degree_higher_pderiv: \"Polynomial.degree ((pderiv ^^ n) p) = Polynomial.degree p - n\"\n  for p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors,semiring_char_0} poly\"", "lemma sum_to_poly: \"(\\<Sum>x\\<in>A. [:f x:]) = [:\\<Sum>x\\<in>A. f x:]\"", "lemma diff_to_poly: \"[:c:] - [:d:] = [:c - d:]\"", "lemma mult_to_poly: \"[:c:] * [:d:] = [:c * d:]\"", "lemma prod_to_poly: \"(\\<Prod>x\\<in>A. [:f x:]) = [:\\<Prod>x\\<in>A. f x:]\"", "lemma coeff_mult_0: \"poly.coeff (p * q) 0 = poly.coeff p 0 * poly.coeff q 0\"", "lemma card_poly_roots_bound:\n  fixes p :: \"'a::{comm_ring_1,ring_no_zero_divisors} poly\"\n  assumes \"p \\<noteq> 0\"\n  shows   \"card {x. poly p x = 0} \\<le> degree p\"", "lemma poly_eqI_degree:\n  fixes p q :: \"'a :: {comm_ring_1, ring_no_zero_divisors} poly\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> poly p x = poly q x\"\n  assumes \"card A > degree p\" \"card A > degree q\"\n  shows   \"p = q\"", "lemma poly_root_order_induct [case_names 0 no_roots root]:\n  fixes p :: \"'a :: idom poly\"\n  assumes \"P 0\" \"\\<And>p. (\\<And>x. poly p x \\<noteq> 0) \\<Longrightarrow> P p\" \n          \"\\<And>p x n. n > 0 \\<Longrightarrow> poly p x \\<noteq> 0 \\<Longrightarrow> P p \\<Longrightarrow> P ([:-x, 1:] ^ n * p)\"\n  shows   \"P p\"", "lemma complex_poly_decompose:\n  \"smult (lead_coeff p) (\\<Prod>z|poly p z = 0. [:-z, 1:] ^ order z p) = (p :: complex poly)\"", "lemma order_pos_iff: \"p \\<noteq> 0 \\<Longrightarrow> order a p > 0 \\<longleftrightarrow> poly p a = 0\"", "lemma poly_roots_mset_0 [simp]: \"poly_roots_mset 0 = {#}\"", "lemma count_poly_roots_mset [simp]:\n  \"p \\<noteq> 0 \\<Longrightarrow> count (poly_roots_mset p) a = order a p\"", "lemma set_count_poly_roots_mset [simp]:\n   \"p \\<noteq> 0 \\<Longrightarrow> set_mset (poly_roots_mset p) = {x. poly p x = 0}\"", "lemma image_prod_mset_multiplicity:\n  \"prod_mset (image_mset f M) = prod (\\<lambda>x. f x ^ count M x) (set_mset M)\"", "lemma complex_poly_decompose_multiset:\n  \"smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:-x, 1:]) = (p :: complex poly)\"", "lemma (in monoid_add) prod_list_prod_nth:\n  \"prod_list xs = (\\<Prod>i=0..<length xs. xs ! i)\"", "lemma prod_zero_iff': \"finite A \\<Longrightarrow> prod f A = 0 \\<longleftrightarrow> (\\<exists>x\\<in>A. f x = 0)\"\n  for f :: \"'a \\<Rightarrow> 'b :: {comm_semiring_1, semiring_no_zero_divisors}\"", "lemma degree_prod_eq: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0) \\<Longrightarrow> degree (prod f A) = (\\<Sum>x\\<in>A. degree (f x))\"\n  for f :: \"'a \\<Rightarrow> 'b::{comm_semiring_1, semiring_no_zero_divisors} poly\"", "lemma lead_coeff_prod: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0) \\<Longrightarrow> lead_coeff (prod f A) = (\\<Prod>x\\<in>A. lead_coeff (f x))\"\n  for f :: \"'a \\<Rightarrow> 'b :: {comm_semiring_1, semiring_no_zero_divisors} poly\"", "lemma complex_poly_decompose':\n  obtains root where \"smult (lead_coeff p) (\\<Prod>i<degree p. [:-root i, 1:]) = (p :: complex poly)\"", "lemma rsquarefree_root_order:\n  assumes \"rsquarefree p\" \"poly p z = 0\" \"p \\<noteq> 0\"\n  shows   \"order z p = 1\"", "lemma complex_poly_decompose_rsquarefree:\n  assumes \"rsquarefree p\"\n  shows   \"smult (lead_coeff p) (\\<Prod>z|poly p z = 0. [:-z, 1:]) = (p :: complex poly)\"", "lemma pcompose_conjugates_integer:\n  assumes \"\\<And>i. poly.coeff p i \\<in> \\<int>\"\n  shows   \"poly.coeff (pcompose p [:0, \\<i>:] * pcompose p [:0, -\\<i>:]) i \\<in> \\<int>\"", "lemma algebraic_times_i:\n  assumes \"algebraic x\"\n  shows   \"algebraic (\\<i> * x)\" \"algebraic (-\\<i> * x)\"", "lemma algebraic_times_i_iff: \"algebraic (\\<i> * x) \\<longleftrightarrow> algebraic x\"", "lemma ratpolyE:\n  assumes \"\\<forall>i. poly.coeff p i \\<in> \\<rat>\"\n  obtains q where \"p = map_poly of_rat q\""], "translations": [["", "lemma Ints_sum: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> \\<int>) \\<Longrightarrow> sum f A \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> A \\<Longrightarrow> f x \\<in> \\<int>) \\<Longrightarrow>\n    sum f A \\<in> \\<int>", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma Ints_prod: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> \\<int>) \\<Longrightarrow> prod f A \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> A \\<Longrightarrow> f x \\<in> \\<int>) \\<Longrightarrow>\n    prod f A \\<in> \\<int>", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma sum_in_Rats [intro]: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> \\<rat>) \\<Longrightarrow> sum f A \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> A \\<Longrightarrow> f x \\<in> \\<rat>) \\<Longrightarrow>\n    sum f A \\<in> \\<rat>", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma prod_in_Rats [intro]: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> \\<rat>) \\<Longrightarrow> prod f A \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> A \\<Longrightarrow> f x \\<in> \\<rat>) \\<Longrightarrow>\n    prod f A \\<in> \\<rat>", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma poly_cnj: \"cnj (poly p z) = poly (map_poly cnj p) (cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (poly p z) = poly (map_poly cnj p) (cnj z)", "by (simp add: poly_altdef degree_map_poly coeff_map_poly)"], ["", "lemma poly_cnj_real:\n  assumes \"\\<And>n. poly.coeff p n \\<in> \\<real>\"\n  shows   \"cnj (poly p z) = poly p (cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (poly p z) = poly p (cnj z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnj (poly p z) = poly p (cnj z)", "from assms"], ["proof (chain)\npicking this:\n  coeff p ?n \\<in> \\<real>", "have \"map_poly cnj p = p\""], ["proof (prove)\nusing this:\n  coeff p ?n \\<in> \\<real>\n\ngoal (1 subgoal):\n 1. map_poly cnj p = p", "by (intro poly_eqI) (auto simp: coeff_map_poly Reals_cnj_iff)"], ["proof (state)\nthis:\n  map_poly cnj p = p\n\ngoal (1 subgoal):\n 1. cnj (poly p z) = poly p (cnj z)", "with poly_cnj[of p z]"], ["proof (chain)\npicking this:\n  cnj (poly p z) = poly (map_poly cnj p) (cnj z)\n  map_poly cnj p = p", "show ?thesis"], ["proof (prove)\nusing this:\n  cnj (poly p z) = poly (map_poly cnj p) (cnj z)\n  map_poly cnj p = p\n\ngoal (1 subgoal):\n 1. cnj (poly p z) = poly p (cnj z)", "by simp"], ["proof (state)\nthis:\n  cnj (poly p z) = poly p (cnj z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma real_poly_cnj_root_iff:\n  assumes \"\\<And>n. poly.coeff p n \\<in> \\<real>\"\n  shows   \"poly p (cnj z) = 0 \\<longleftrightarrow> poly p z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p (cnj z) = 0) = (poly p z = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (poly p (cnj z) = 0) = (poly p z = 0)", "have \"poly p (cnj z) = cnj (poly p z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p (cnj z) = cnj (poly p z)", "by (simp add: poly_cnj_real assms)"], ["proof (state)\nthis:\n  poly p (cnj z) = cnj (poly p z)\n\ngoal (1 subgoal):\n 1. (poly p (cnj z) = 0) = (poly p z = 0)", "also"], ["proof (state)\nthis:\n  poly p (cnj z) = cnj (poly p z)\n\ngoal (1 subgoal):\n 1. (poly p (cnj z) = 0) = (poly p z = 0)", "have \"\\<dots> = 0 \\<longleftrightarrow> poly p z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cnj (poly p z) = 0) = (poly p z = 0)", "by simp"], ["proof (state)\nthis:\n  (cnj (poly p z) = 0) = (poly p z = 0)\n\ngoal (1 subgoal):\n 1. (poly p (cnj z) = 0) = (poly p z = 0)", "finally"], ["proof (chain)\npicking this:\n  (poly p (cnj z) = 0) = (poly p z = 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (poly p (cnj z) = 0) = (poly p z = 0)\n\ngoal (1 subgoal):\n 1. (poly p (cnj z) = 0) = (poly p z = 0)", "."], ["proof (state)\nthis:\n  (poly p (cnj z) = 0) = (poly p z = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_pcompose_linear:\n  fixes p :: \"'a :: comm_semiring_1 poly\"\n  shows \"coeff (pcompose p [:0, c:]) i = c ^ i * coeff p i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0::'a, c:]) i = c ^ i * coeff p i", "by (induction p arbitrary: i) (auto simp: pcompose_pCons coeff_pCons mult_ac split: nat.splits)"], ["", "lemma coeff_pCons': \"poly.coeff (pCons c p) n = (if n = 0 then c else poly.coeff p (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (pCons c p) n = (if n = 0 then c else coeff p (n - 1))", "by transfer'(auto split: nat.splits)"], ["", "lemma prod_smult: \"(\\<Prod>x\\<in>A. Polynomial.smult (c x) (p x)) = Polynomial.smult (prod c A) (prod p A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>A. smult (c x) (p x)) = smult (prod c A) (prod p A)", "by (induction A rule: infinite_finite_induct) (auto simp: mult_ac)"], ["", "lemma degree_higher_pderiv: \"Polynomial.degree ((pderiv ^^ n) p) = Polynomial.degree p - n\"\n  for p :: \"'a::{comm_semiring_1,semiring_no_zero_divisors,semiring_char_0} poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree ((pderiv ^^ n) p) = degree p - n", "by (induction n) (auto simp: degree_pderiv)"], ["", "lemma sum_to_poly: \"(\\<Sum>x\\<in>A. [:f x:]) = [:\\<Sum>x\\<in>A. f x:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. [:f x:]) = [:sum f A:]", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma diff_to_poly: \"[:c:] - [:d:] = [:c - d:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:c:] - [:d:] = [:c - d:]", "by (simp add: poly_eq_iff mult_ac)"], ["", "lemma mult_to_poly: \"[:c:] * [:d:] = [:c * d:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:c:] * [:d:] = [:c * d:]", "by (simp add: poly_eq_iff mult_ac)"], ["", "lemma prod_to_poly: \"(\\<Prod>x\\<in>A. [:f x:]) = [:\\<Prod>x\\<in>A. f x:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>A. [:f x:]) = [:prod f A:]", "by (induction A rule: infinite_finite_induct) (auto simp: mult_to_poly mult_ac)"], ["", "lemma coeff_mult_0: \"poly.coeff (p * q) 0 = poly.coeff p 0 * poly.coeff q 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p * q) 0 = coeff p 0 * coeff q 0", "by (simp add: coeff_mult)"], ["", "lemma card_poly_roots_bound:\n  fixes p :: \"'a::{comm_ring_1,ring_no_zero_divisors} poly\"\n  assumes \"p \\<noteq> 0\"\n  shows   \"card {x. poly p x = 0} \\<le> degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "proof (induction \"degree p\" arbitrary: p rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; pa \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> card {x. poly pa x = (0::'a)}\n                                     \\<le> degree pa;\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card {x. poly p x = (0::'a)} \\<le> degree p", "case (less p)"], ["proof (state)\nthis:\n  \\<lbrakk>degree ?p < degree p; ?p \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> card {x. poly ?p x = (0::'a)} \\<le> degree ?p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>degree pa < degree p; pa \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> card {x. poly pa x = (0::'a)}\n                                     \\<le> degree pa;\n        p \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> card {x. poly p x = (0::'a)} \\<le> degree p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "proof (cases \"\\<exists>x. poly p x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "case False"], ["proof (state)\nthis:\n  \\<nexists>x. poly p x = (0::'a)\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "hence \"{x. poly p x = 0} = {}\""], ["proof (prove)\nusing this:\n  \\<nexists>x. poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. {x. poly p x = (0::'a)} = {}", "by blast"], ["proof (state)\nthis:\n  {x. poly p x = (0::'a)} = {}\n\ngoal (2 subgoals):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p\n 2. \\<nexists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "thus ?thesis"], ["proof (prove)\nusing this:\n  {x. poly p x = (0::'a)} = {}\n\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "by simp"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} \\<le> degree p\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "case True"], ["proof (state)\nthis:\n  \\<exists>x. poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. poly p x = (0::'a)", "obtain x where x: \"poly p x = 0\""], ["proof (prove)\nusing this:\n  \\<exists>x. poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>x. poly p x = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "hence \"[:-x, 1:] dvd p\""], ["proof (prove)\nusing this:\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] dvd p", "by (subst (asm) poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  [:- x, 1::'a:] dvd p\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "then"], ["proof (chain)\npicking this:\n  [:- x, 1::'a:] dvd p", "obtain q where q: \"p = [:-x, 1:] * q\""], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = [:- x, 1::'a:] * q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: dvd_def)"], ["proof (state)\nthis:\n  p = [:- x, 1::'a:] * q\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "with \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  p = [:- x, 1::'a:] * q", "have [simp]: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p = [:- x, 1::'a:] * q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "have deg: \"degree p = Suc (degree q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = Suc (degree q)", "by (subst q, subst degree_mult_eq) auto"], ["proof (state)\nthis:\n  degree p = Suc (degree q)\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "have \"card {x. poly p x = 0} \\<le> card (insert x {x. poly q x = 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)}\n    \\<le> card (insert x {x. poly q x = (0::'a)})", "by (intro card_mono) (auto intro: poly_roots_finite simp: q)"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} \\<le> card (insert x {x. poly q x = (0::'a)})\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "also"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} \\<le> card (insert x {x. poly q x = (0::'a)})\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "have \"\\<dots> \\<le> Suc (card {x. poly q x = 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (insert x {x. poly q x = (0::'a)})\n    \\<le> Suc (card {x. poly q x = (0::'a)})", "by (rule card_insert_le_m1) auto"], ["proof (state)\nthis:\n  card (insert x {x. poly q x = (0::'a)})\n  \\<le> Suc (card {x. poly q x = (0::'a)})\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "also"], ["proof (state)\nthis:\n  card (insert x {x. poly q x = (0::'a)})\n  \\<le> Suc (card {x. poly q x = (0::'a)})\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "from deg"], ["proof (chain)\npicking this:\n  degree p = Suc (degree q)", "have  \"card {x. poly q x = 0} \\<le> degree q\""], ["proof (prove)\nusing this:\n  degree p = Suc (degree q)\n\ngoal (1 subgoal):\n 1. card {x. poly q x = (0::'a)} \\<le> degree q", "using \\<open>p \\<noteq> 0\\<close> and q"], ["proof (prove)\nusing this:\n  degree p = Suc (degree q)\n  p \\<noteq> 0\n  p = [:- x, 1::'a:] * q\n\ngoal (1 subgoal):\n 1. card {x. poly q x = (0::'a)} \\<le> degree q", "by (intro less) auto"], ["proof (state)\nthis:\n  card {x. poly q x = (0::'a)} \\<le> degree q\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "also"], ["proof (state)\nthis:\n  card {x. poly q x = (0::'a)} \\<le> degree q\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "have \"Suc \\<dots> = degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (degree q) = degree p", "by (simp add: deg)"], ["proof (state)\nthis:\n  Suc (degree q) = degree p\n\ngoal (1 subgoal):\n 1. \\<exists>x. poly p x = (0::'a) \\<Longrightarrow>\n    card {x. poly p x = (0::'a)} \\<le> degree p", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> Suc x \\<le> Suc y) \\<Longrightarrow>\n  card {x. poly p x = (0::'a)} \\<le> degree p", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> Suc x \\<le> Suc y) \\<Longrightarrow>\n  card {x. poly p x = (0::'a)} \\<le> degree p\n\ngoal (1 subgoal):\n 1. card {x. poly p x = (0::'a)} \\<le> degree p", "by - simp_all"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} \\<le> degree p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card {x. poly p x = (0::'a)} \\<le> degree p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_eqI_degree:\n  fixes p q :: \"'a :: {comm_ring_1, ring_no_zero_divisors} poly\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> poly p x = poly q x\"\n  assumes \"card A > degree p\" \"card A > degree q\"\n  shows   \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "assume neq: \"p \\<noteq> q\""], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "have \"degree (p - q) \\<le> max (degree p) (degree q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (p - q) \\<le> max (degree p) (degree q)", "by (rule degree_diff_le_max)"], ["proof (state)\nthis:\n  degree (p - q) \\<le> max (degree p) (degree q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (p - q) \\<le> max (degree p) (degree q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  ?x \\<in> A \\<Longrightarrow> poly p ?x = poly q ?x\n  degree p < card A\n  degree q < card A", "have \"\\<dots> < card A\""], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> poly p ?x = poly q ?x\n  degree p < card A\n  degree q < card A\n\ngoal (1 subgoal):\n 1. max (degree p) (degree q) < card A", "by linarith"], ["proof (state)\nthis:\n  max (degree p) (degree q) < card A\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  max (degree p) (degree q) < card A\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "have \"\\<dots> \\<le> card {x. poly (p - q) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card A \\<le> card {x. poly (p - q) x = (0::'a)}", "using neq and assms"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  ?x \\<in> A \\<Longrightarrow> poly p ?x = poly q ?x\n  degree p < card A\n  degree q < card A\n\ngoal (1 subgoal):\n 1. card A \\<le> card {x. poly (p - q) x = (0::'a)}", "by (intro card_mono poly_roots_finite) auto"], ["proof (state)\nthis:\n  card A \\<le> card {x. poly (p - q) x = (0::'a)}\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  degree (p - q) < card {x. poly (p - q) x = (0::'a)}", "have \"degree (p - q) < card {x. poly (p - q) x = 0}\""], ["proof (prove)\nusing this:\n  degree (p - q) < card {x. poly (p - q) x = (0::'a)}\n\ngoal (1 subgoal):\n 1. degree (p - q) < card {x. poly (p - q) x = (0::'a)}", "."], ["proof (state)\nthis:\n  degree (p - q) < card {x. poly (p - q) x = (0::'a)}\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  degree (p - q) < card {x. poly (p - q) x = (0::'a)}\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "have \"degree (p - q) \\<ge> card {x. poly (p - q) x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {x. poly (p - q) x = (0::'a)} \\<le> degree (p - q)", "using neq"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. card {x. poly (p - q) x = (0::'a)} \\<le> degree (p - q)", "by (intro card_poly_roots_bound) auto"], ["proof (state)\nthis:\n  card {x. poly (p - q) x = (0::'a)} \\<le> degree (p - q)\n\ngoal (1 subgoal):\n 1. p \\<noteq> q \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  degree (p - q) < card {x. poly (p - q) x = (0::'a)}\n  card {x. poly (p - q) x = (0::'a)} \\<le> degree (p - q)", "show False"], ["proof (prove)\nusing this:\n  degree (p - q) < card {x. poly (p - q) x = (0::'a)}\n  card {x. poly (p - q) x = (0::'a)} \\<le> degree (p - q)\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_root_order_induct [case_names 0 no_roots root]:\n  fixes p :: \"'a :: idom poly\"\n  assumes \"P 0\" \"\\<And>p. (\\<And>x. poly p x \\<noteq> 0) \\<Longrightarrow> P p\" \n          \"\\<And>p x n. n > 0 \\<Longrightarrow> poly p x \\<noteq> 0 \\<Longrightarrow> P p \\<Longrightarrow> P ([:-x, 1:] ^ n * p)\"\n  shows   \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof (induction \"degree p\" arbitrary: p rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> P pa) \\<Longrightarrow>\n       P p", "case (less p)"], ["proof (state)\nthis:\n  degree ?p < degree p \\<Longrightarrow> P ?p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> P pa) \\<Longrightarrow>\n       P p", "consider \"p = 0\" | \"p \\<noteq> 0\" \"\\<exists>x. poly p x = 0\" | \"\\<And>x. poly p x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = 0 \\<Longrightarrow> thesis;\n     \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>p = 0 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>pa.\n           degree pa < degree p \\<Longrightarrow> P pa) \\<Longrightarrow>\n       P p", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>p = 0 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P p", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p\n 3. (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> P p", "case 3"], ["proof (state)\nthis:\n  poly p ?x \\<noteq> (0::'a)\n\ngoal (3 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p\n 3. (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> P p", "with assms(2)[of p]"], ["proof (chain)\npicking this:\n  (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> P p\n  poly p ?x \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x. poly p x \\<noteq> (0::'a)) \\<Longrightarrow> P p\n  poly p ?x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. P p", "by simp"], ["proof (state)\nthis:\n  P p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "case 2"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  \\<exists>x. poly p x = (0::'a)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  \\<exists>x. poly p x = (0::'a)", "obtain x where x: \"poly p x = 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  \\<exists>x. poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>x. poly p x = (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly p x = (0::'a)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "have \"[:-x, 1:] ^ order x p dvd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] ^ order x p dvd p", "by (intro order_1)"], ["proof (state)\nthis:\n  [:- x, 1::'a:] ^ order x p dvd p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  [:- x, 1::'a:] ^ order x p dvd p", "obtain q where q: \"p = [:-x, 1:] ^ order x p * q\""], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] ^ order x p dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = [:- x, 1::'a:] ^ order x p * q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: dvd_def)"], ["proof (state)\nthis:\n  p = [:- x, 1::'a:] ^ order x p * q\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "with 2"], ["proof (chain)\npicking this:\n  p \\<noteq> 0\n  \\<exists>x. poly p x = (0::'a)\n  p = [:- x, 1::'a:] ^ order x p * q", "have [simp]: \"q \\<noteq> 0\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  \\<exists>x. poly p x = (0::'a)\n  p = [:- x, 1::'a:] ^ order x p * q\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "have order_pos: \"order x p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order x p", "using \\<open>p \\<noteq> 0\\<close> and x"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  poly p x = (0::'a)\n\ngoal (1 subgoal):\n 1. 0 < order x p", "by (auto simp: order_root)"], ["proof (state)\nthis:\n  0 < order x p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "have \"order x p = order x p + order x q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x p = order x p + order x q", "by (subst q, subst order_mult) (auto simp: order_power_n_n)"], ["proof (state)\nthis:\n  order x p = order x p + order x q\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "hence [simp]: \"order x q = 0\""], ["proof (prove)\nusing this:\n  order x p = order x p + order x q\n\ngoal (1 subgoal):\n 1. order x q = 0", "by simp"], ["proof (state)\nthis:\n  order x q = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "have deg: \"degree p = order x p + degree q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = order x p + degree q", "by (subst q, subst degree_mult_eq) (auto simp: degree_power_eq)"], ["proof (state)\nthis:\n  degree p = order x p + degree q\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "with order_pos"], ["proof (chain)\npicking this:\n  0 < order x p\n  degree p = order x p + degree q", "have \"degree q < degree p\""], ["proof (prove)\nusing this:\n  0 < order x p\n  degree p = order x p + degree q\n\ngoal (1 subgoal):\n 1. degree q < degree p", "by simp"], ["proof (state)\nthis:\n  degree q < degree p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "hence \"P q\""], ["proof (prove)\nusing this:\n  degree q < degree p\n\ngoal (1 subgoal):\n 1. P q", "by (rule less)"], ["proof (state)\nthis:\n  P q\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "with order_pos"], ["proof (chain)\npicking this:\n  0 < order x p\n  P q", "have \"P ([:-x, 1:] ^ order x p * q)\""], ["proof (prove)\nusing this:\n  0 < order x p\n  P q\n\ngoal (1 subgoal):\n 1. P ([:- x, 1::'a:] ^ order x p * q)", "by (intro assms(3)) (auto simp: order_root)"], ["proof (state)\nthis:\n  P ([:- x, 1::'a:] ^ order x p * q)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> P p\n 2. \\<lbrakk>p \\<noteq> 0; \\<exists>x. poly p x = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> P p", "with q"], ["proof (chain)\npicking this:\n  p = [:- x, 1::'a:] ^ order x p * q\n  P ([:- x, 1::'a:] ^ order x p * q)", "show ?thesis"], ["proof (prove)\nusing this:\n  p = [:- x, 1::'a:] ^ order x p * q\n  P ([:- x, 1::'a:] ^ order x p * q)\n\ngoal (1 subgoal):\n 1. P p", "by simp"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> P p", "qed (simp_all add: assms(1))"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complex_poly_decompose:\n  \"smult (lead_coeff p) (\\<Prod>z|poly p z = 0. [:-z, 1:] ^ order z p) = (p :: complex poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "proof (induction p rule: poly_root_order_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p.\n       (\\<And>x. poly p x \\<noteq> 0) \\<Longrightarrow>\n       smult (lead_coeff p)\n        (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n       p\n 3. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "case (no_roots p)"], ["proof (state)\nthis:\n  poly p ?x \\<noteq> 0\n\ngoal (3 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p.\n       (\\<And>x. poly p x \\<noteq> 0) \\<Longrightarrow>\n       smult (lead_coeff p)\n        (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n       p\n 3. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "proof (cases \"degree p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "case False"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "hence \"\\<not>constant (poly p)\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> constant (poly p)", "by (subst constant_degree)"], ["proof (state)\nthis:\n  \\<not> constant (poly p)\n\ngoal (2 subgoals):\n 1. degree p = 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p\n 2. degree p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "with fundamental_theorem_of_algebra and no_roots"], ["proof (chain)\npicking this:\n  \\<not> constant (poly ?p) \\<Longrightarrow> \\<exists>z. poly ?p z = 0\n  poly p ?x \\<noteq> 0\n  \\<not> constant (poly p)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> constant (poly ?p) \\<Longrightarrow> \\<exists>z. poly ?p z = 0\n  poly p ?x \\<noteq> 0\n  \\<not> constant (poly p)\n\ngoal (1 subgoal):\n 1. smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "by blast"], ["proof (state)\nthis:\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (1 subgoal):\n 1. degree p = 0 \\<Longrightarrow>\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "qed (auto elim!: degree_eq_zeroE)"], ["proof (state)\nthis:\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "case (root p x n)"], ["proof (state)\nthis:\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "from root"], ["proof (chain)\npicking this:\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p", "have *: \"{z. poly ([:- x, 1:] ^ n * p) z = 0} = insert x {z. poly p z = 0}\""], ["proof (prove)\nusing this:\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (1 subgoal):\n 1. {z. poly ([:- x, 1:] ^ n * p) z = 0} = insert x {z. poly p z = 0}", "by auto"], ["proof (state)\nthis:\n  {z. poly ([:- x, 1:] ^ n * p) z = 0} = insert x {z. poly p z = 0}\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "have \"smult (lead_coeff ([:-x, 1:] ^ n * p)) \n           (\\<Prod>z|poly ([:-x,1:] ^ n * p) z = 0. [:-z, 1:] ^ order z ([:- x, 1:] ^ n * p)) = \n        [:- x, 1:] ^ order x ([:- x, 1:] ^ n * p) * \n          smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (lead_coeff ([:- x, 1:] ^ n * p))\n     (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n        [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n    [:- x, 1:] ^ order x ([:- x, 1:] ^ n * p) *\n    smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}.\n        [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p))", "by (subst *, subst prod.insert) \n       (insert root, auto intro: poly_roots_finite simp: mult_ac lead_coeff_mult lead_coeff_power)"], ["proof (state)\nthis:\n  smult (lead_coeff ([:- x, 1:] ^ n * p))\n   (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  [:- x, 1:] ^ order x ([:- x, 1:] ^ n * p) *\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p))\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "also"], ["proof (state)\nthis:\n  smult (lead_coeff ([:- x, 1:] ^ n * p))\n   (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  [:- x, 1:] ^ order x ([:- x, 1:] ^ n * p) *\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p))\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "have \"order x ([:- x, 1:] ^ n * p) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x ([:- x, 1:] ^ n * p) = n", "using root"], ["proof (prove)\nusing this:\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (1 subgoal):\n 1. order x ([:- x, 1:] ^ n * p) = n", "by (subst order_mult) (auto simp: order_power_n_n order_0I)"], ["proof (state)\nthis:\n  order x ([:- x, 1:] ^ n * p) = n\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "also"], ["proof (state)\nthis:\n  order x ([:- x, 1:] ^ n * p) = n\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "have \"(\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n               (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>z\\<in>{z. poly p z = 0}.\n       [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n    (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p)", "proof (intro prod.cong refl, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {z. poly p z = 0} \\<Longrightarrow>\n       [:- xa, 1:] ^ order xa ([:- x, 1:] ^ n * p) =\n       [:- xa, 1:] ^ order xa p", "case (1 y)"], ["proof (state)\nthis:\n  y \\<in> {z. poly p z = 0}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {z. poly p z = 0} \\<Longrightarrow>\n       [:- xa, 1:] ^ order xa ([:- x, 1:] ^ n * p) =\n       [:- xa, 1:] ^ order xa p", "with root"], ["proof (chain)\npicking this:\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n  y \\<in> {z. poly p z = 0}", "have \"order y ([:-x,1:] ^ n) = 0\""], ["proof (prove)\nusing this:\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n  y \\<in> {z. poly p z = 0}\n\ngoal (1 subgoal):\n 1. order y ([:- x, 1:] ^ n) = 0", "by (intro order_0I) auto"], ["proof (state)\nthis:\n  order y ([:- x, 1:] ^ n) = 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {z. poly p z = 0} \\<Longrightarrow>\n       [:- xa, 1:] ^ order xa ([:- x, 1:] ^ n * p) =\n       [:- xa, 1:] ^ order xa p", "thus ?case"], ["proof (prove)\nusing this:\n  order y ([:- x, 1:] ^ n) = 0\n\ngoal (1 subgoal):\n 1. [:- y, 1:] ^ order y ([:- x, 1:] ^ n * p) = [:- y, 1:] ^ order y p", "using root"], ["proof (prove)\nusing this:\n  order y ([:- x, 1:] ^ n) = 0\n  0 < n\n  poly p x \\<noteq> 0\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (1 subgoal):\n 1. [:- y, 1:] ^ order y ([:- x, 1:] ^ n * p) = [:- y, 1:] ^ order y p", "by (subst order_mult) auto"], ["proof (state)\nthis:\n  [:- y, 1:] ^ order y ([:- x, 1:] ^ n * p) = [:- y, 1:] ^ order y p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>z\\<in>{z. poly p z = 0}.\n     [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p)\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "also"], ["proof (state)\nthis:\n  (\\<Prod>z\\<in>{z. poly p z = 0}.\n     [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p)\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "note root.IH"], ["proof (state)\nthis:\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (2 subgoals):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0\n 2. \\<And>p x n.\n       \\<lbrakk>0 < n; poly p x \\<noteq> 0;\n        smult (lead_coeff p)\n         (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n        p\\<rbrakk>\n       \\<Longrightarrow> smult (lead_coeff ([:- x, 1:] ^ n * p))\n                          (\\<Prod>z\\<in>{z.\n   poly ([:- x, 1:] ^ n * p) z = 0}.\n                             [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n                         [:- x, 1:] ^ n * p", "finally"], ["proof (chain)\npicking this:\n  smult (lead_coeff ([:- x, 1:] ^ n * p))\n   (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  [:- x, 1:] ^ n * p", "show ?case"], ["proof (prove)\nusing this:\n  smult (lead_coeff ([:- x, 1:] ^ n * p))\n   (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  [:- x, 1:] ^ n * p\n\ngoal (1 subgoal):\n 1. smult (lead_coeff ([:- x, 1:] ^ n * p))\n     (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n        [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n    [:- x, 1:] ^ n * p", "."], ["proof (state)\nthis:\n  smult (lead_coeff ([:- x, 1:] ^ n * p))\n   (\\<Prod>z\\<in>{z. poly ([:- x, 1:] ^ n * p) z = 0}.\n      [:- z, 1:] ^ order z ([:- x, 1:] ^ n * p)) =\n  [:- x, 1:] ^ n * p\n\ngoal (1 subgoal):\n 1. smult (lead_coeff 0)\n     (\\<Prod>z\\<in>{z. poly 0 z = 0}. [:- z, 1:] ^ order z 0) =\n    0", "qed simp_all"], ["", "lemma order_pos_iff: \"p \\<noteq> 0 \\<Longrightarrow> order a p > 0 \\<longleftrightarrow> poly p a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> (0 < order a p) = (poly p a = (0::'a))", "using order_root[of p a]"], ["proof (prove)\nusing this:\n  (poly p a = (0::'a)) = (p = 0 \\<or> order a p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> (0 < order a p) = (poly p a = (0::'a))", "by auto"], ["", "lift_definition poly_roots_mset :: \"('a :: idom) poly \\<Rightarrow> 'a multiset\" is\n  \"\\<lambda>p x. if p = 0 then 0 else Polynomial.order x p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>poly.\n       (\\<lambda>x. if poly = 0 then 0 else order x poly) \\<in> multiset", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>poly.\n       (\\<lambda>x. if poly = 0 then 0 else order x poly) \\<in> multiset", "fix p :: \"'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>poly.\n       (\\<lambda>x. if poly = 0 then 0 else order x poly) \\<in> multiset", "show \"(\\<lambda>x. if p = 0 then 0 else order x p) \\<in> multiset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if p = 0 then 0 else order x p) \\<in> multiset", "by (cases \"p = 0\")\n       (auto simp: multiset_def order_pos_iff intro: finite_subset[OF _ poly_roots_finite[of p]])"], ["proof (state)\nthis:\n  (\\<lambda>x. if p = 0 then 0 else order x p) \\<in> multiset\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_roots_mset_0 [simp]: \"poly_roots_mset 0 = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots_mset 0 = {#}", "by transfer' auto"], ["", "lemma count_poly_roots_mset [simp]:\n  \"p \\<noteq> 0 \\<Longrightarrow> count (poly_roots_mset p) a = order a p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow> count (poly_roots_mset p) a = order a p", "by transfer' auto"], ["", "lemma set_count_poly_roots_mset [simp]:\n   \"p \\<noteq> 0 \\<Longrightarrow> set_mset (poly_roots_mset p) = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    set_mset (poly_roots_mset p) = {x. poly p x = (0::'a)}", "by (auto simp: set_mset_def order_pos_iff)"], ["", "lemma image_prod_mset_multiplicity:\n  \"prod_mset (image_mset f M) = prod (\\<lambda>x. f x ^ count M x) (set_mset M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (image_mset f M) =\n    (\\<Prod>x\\<in>set_mset M. f x ^ count M x)", "proof (induction M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Prod>\\<^sub># (image_mset f {#}) =\n    (\\<Prod>x\\<in>set_mset {#}. f x ^ count {#} x)\n 2. \\<And>x M.\n       \\<Prod>\\<^sub># (image_mset f M) =\n       (\\<Prod>x\\<in>set_mset M. f x ^ count M x) \\<Longrightarrow>\n       \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n       (\\<Prod>xa\\<in>set_mset (add_mset x M).\n          f xa ^ count (add_mset x M) xa)", "case (add x M)"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (image_mset f M) =\n  (\\<Prod>x\\<in>set_mset M. f x ^ count M x)\n\ngoal (2 subgoals):\n 1. \\<Prod>\\<^sub># (image_mset f {#}) =\n    (\\<Prod>x\\<in>set_mset {#}. f x ^ count {#} x)\n 2. \\<And>x M.\n       \\<Prod>\\<^sub># (image_mset f M) =\n       (\\<Prod>x\\<in>set_mset M. f x ^ count M x) \\<Longrightarrow>\n       \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n       (\\<Prod>xa\\<in>set_mset (add_mset x M).\n          f xa ^ count (add_mset x M) xa)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "proof (cases \"x \\<in> set_mset M\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)\n 2. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "case True"], ["proof (state)\nthis:\n  x \\<in># M\n\ngoal (2 subgoals):\n 1. x \\<in># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)\n 2. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "have \"(\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) = \n            (\\<Prod>y\\<in>set_mset M. (if y = x then f x else 1) * f y ^ count M y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) =\n    (\\<Prod>y\\<in>set_mset M.\n       (if y = x then f x else (1::'a)) * f y ^ count M y)", "using True add"], ["proof (prove)\nusing this:\n  x \\<in># M\n  \\<Prod>\\<^sub># (image_mset f M) =\n  (\\<Prod>x\\<in>set_mset M. f x ^ count M x)\n\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) =\n    (\\<Prod>y\\<in>set_mset M.\n       (if y = x then f x else (1::'a)) * f y ^ count M y)", "by (intro prod.cong) auto"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) =\n  (\\<Prod>y\\<in>set_mset M.\n     (if y = x then f x else (1::'a)) * f y ^ count M y)\n\ngoal (2 subgoals):\n 1. x \\<in># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)\n 2. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "also"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) =\n  (\\<Prod>y\\<in>set_mset M.\n     (if y = x then f x else (1::'a)) * f y ^ count M y)\n\ngoal (2 subgoals):\n 1. x \\<in># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)\n 2. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "have \"\\<dots> = f x * (\\<Prod>y\\<in>set_mset M. f y ^ count M y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>set_mset M.\n       (if y = x then f x else (1::'a)) * f y ^ count M y) =\n    f x * (\\<Prod>y\\<in>set_mset M. f y ^ count M y)", "using True"], ["proof (prove)\nusing this:\n  x \\<in># M\n\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>set_mset M.\n       (if y = x then f x else (1::'a)) * f y ^ count M y) =\n    f x * (\\<Prod>y\\<in>set_mset M. f y ^ count M y)", "by (subst prod.distrib) auto"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>set_mset M.\n     (if y = x then f x else (1::'a)) * f y ^ count M y) =\n  f x * (\\<Prod>y\\<in>set_mset M. f y ^ count M y)\n\ngoal (2 subgoals):\n 1. x \\<in># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)\n 2. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "also"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>set_mset M.\n     (if y = x then f x else (1::'a)) * f y ^ count M y) =\n  f x * (\\<Prod>y\\<in>set_mset M. f y ^ count M y)\n\ngoal (2 subgoals):\n 1. x \\<in># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)\n 2. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "note add.IH [symmetric]"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>set_mset M. f x ^ count M x) =\n  \\<Prod>\\<^sub># (image_mset f M)\n\ngoal (2 subgoals):\n 1. x \\<in># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)\n 2. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) =\n  f x * \\<Prod>\\<^sub># (image_mset f M)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) =\n  f x * \\<Prod>\\<^sub># (image_mset f M)\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "using True"], ["proof (prove)\nusing this:\n  (\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) =\n  f x * \\<Prod>\\<^sub># (image_mset f M)\n  x \\<in># M\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "by simp"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n  (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)\n\ngoal (1 subgoal):\n 1. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "case False"], ["proof (state)\nthis:\n  x \\<notin># M\n\ngoal (1 subgoal):\n 1. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "hence \"(\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) =\n              f x * (\\<Prod>y\\<in>set_mset M. f y ^ count (add_mset x M) y)\""], ["proof (prove)\nusing this:\n  x \\<notin># M\n\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) =\n    f x * (\\<Prod>y\\<in>set_mset M. f y ^ count (add_mset x M) y)", "by (auto simp: not_in_iff)"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) =\n  f x * (\\<Prod>y\\<in>set_mset M. f y ^ count (add_mset x M) y)\n\ngoal (1 subgoal):\n 1. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "also"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) =\n  f x * (\\<Prod>y\\<in>set_mset M. f y ^ count (add_mset x M) y)\n\ngoal (1 subgoal):\n 1. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "have \"(\\<Prod>y\\<in>set_mset M. f y ^ count (add_mset x M) y) = \n                 (\\<Prod>y\\<in>set_mset M. f y ^ count M y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>set_mset M. f y ^ count (add_mset x M) y) =\n    (\\<Prod>y\\<in>set_mset M. f y ^ count M y)", "using False"], ["proof (prove)\nusing this:\n  x \\<notin># M\n\ngoal (1 subgoal):\n 1. (\\<Prod>y\\<in>set_mset M. f y ^ count (add_mset x M) y) =\n    (\\<Prod>y\\<in>set_mset M. f y ^ count M y)", "by (intro prod.cong) auto"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>set_mset M. f y ^ count (add_mset x M) y) =\n  (\\<Prod>y\\<in>set_mset M. f y ^ count M y)\n\ngoal (1 subgoal):\n 1. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "also"], ["proof (state)\nthis:\n  (\\<Prod>y\\<in>set_mset M. f y ^ count (add_mset x M) y) =\n  (\\<Prod>y\\<in>set_mset M. f y ^ count M y)\n\ngoal (1 subgoal):\n 1. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "note add.IH [symmetric]"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>set_mset M. f x ^ count M x) =\n  \\<Prod>\\<^sub># (image_mset f M)\n\ngoal (1 subgoal):\n 1. x \\<notin># M \\<Longrightarrow>\n    \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) =\n  f x * \\<Prod>\\<^sub># (image_mset f M)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Prod>y\\<in>set_mset (add_mset x M). f y ^ count (add_mset x M) y) =\n  f x * \\<Prod>\\<^sub># (image_mset f M)\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n    (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)", "by simp"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n  (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (image_mset f (add_mset x M)) =\n  (\\<Prod>xa\\<in>set_mset (add_mset x M). f xa ^ count (add_mset x M) xa)\n\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (image_mset f {#}) =\n    (\\<Prod>x\\<in>set_mset {#}. f x ^ count {#} x)", "qed auto"], ["", "lemma complex_poly_decompose_multiset:\n  \"smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:-x, 1:]) = (p :: complex poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p", "hence \"(\\<Prod>x\\<in>#poly_roots_mset p. [:-x, 1:]) = (\\<Prod>x | poly p x = 0. [:-x, 1:] ^ order x p)\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) =\n    (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ order x p)", "by (subst image_prod_mset_multiplicity) simp_all"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) =\n  (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ order x p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) =\n  (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ order x p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p", "have \"smult (lead_coeff p) \\<dots> = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (lead_coeff p)\n     (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ order x p) =\n    p", "by (rule complex_poly_decompose)"], ["proof (state)\nthis:\n  smult (lead_coeff p)\n   (\\<Prod>x\\<in>{x. poly p x = 0}. [:- x, 1:] ^ order x p) =\n  p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p", "finally"], ["proof (chain)\npicking this:\n  smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p", "show ?thesis"], ["proof (prove)\nusing this:\n  smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p\n\ngoal (1 subgoal):\n 1. smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p", "."], ["proof (state)\nthis:\n  smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) = p", "qed auto"], ["", "lemma (in monoid_add) prod_list_prod_nth:\n  \"prod_list xs = (\\<Prod>i=0..<length xs. xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list xs = prod ((!) xs) {0..<length xs}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_list xs = prod ((!) xs) {0..<length xs}", "have \"xs = map (\\<lambda>i. xs ! i) [0..<length xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = map ((!) xs) [0..<length xs]", "by (simp add: map_nth)"], ["proof (state)\nthis:\n  xs = map ((!) xs) [0..<length xs]\n\ngoal (1 subgoal):\n 1. prod_list xs = prod ((!) xs) {0..<length xs}", "also"], ["proof (state)\nthis:\n  xs = map ((!) xs) [0..<length xs]\n\ngoal (1 subgoal):\n 1. prod_list xs = prod ((!) xs) {0..<length xs}", "have \"prod_list \\<dots> = (\\<Prod>i=0..<length xs. xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (map ((!) xs) [0..<length xs]) = prod ((!) xs) {0..<length xs}", "by (subst prod.distinct_set_conv_list [symmetric]) auto"], ["proof (state)\nthis:\n  prod_list (map ((!) xs) [0..<length xs]) = prod ((!) xs) {0..<length xs}\n\ngoal (1 subgoal):\n 1. prod_list xs = prod ((!) xs) {0..<length xs}", "finally"], ["proof (chain)\npicking this:\n  prod_list xs = prod ((!) xs) {0..<length xs}", "show ?thesis"], ["proof (prove)\nusing this:\n  prod_list xs = prod ((!) xs) {0..<length xs}\n\ngoal (1 subgoal):\n 1. prod_list xs = prod ((!) xs) {0..<length xs}", "."], ["proof (state)\nthis:\n  prod_list xs = prod ((!) xs) {0..<length xs}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_zero_iff': \"finite A \\<Longrightarrow> prod f A = 0 \\<longleftrightarrow> (\\<exists>x\\<in>A. f x = 0)\"\n  for f :: \"'a \\<Rightarrow> 'b :: {comm_semiring_1, semiring_no_zero_divisors}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    (prod f A = (0::'b)) = (\\<exists>x\\<in>A. f x = (0::'b))", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma degree_prod_eq: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0) \\<Longrightarrow> degree (prod f A) = (\\<Sum>x\\<in>A. degree (f x))\"\n  for f :: \"'a \\<Rightarrow> 'b::{comm_semiring_1, semiring_no_zero_divisors} poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0) \\<Longrightarrow>\n    degree (prod f A) = (\\<Sum>x\\<in>A. degree (f x))", "by (induction A rule: infinite_finite_induct) (auto simp: degree_mult_eq prod_zero_iff')"], ["", "lemma lead_coeff_prod: \"(\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0) \\<Longrightarrow> lead_coeff (prod f A) = (\\<Prod>x\\<in>A. lead_coeff (f x))\"\n  for f :: \"'a \\<Rightarrow> 'b :: {comm_semiring_1, semiring_no_zero_divisors} poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<noteq> 0) \\<Longrightarrow>\n    lead_coeff (prod f A) = (\\<Prod>x\\<in>A. lead_coeff (f x))", "by (induction A rule: infinite_finite_induct) (auto simp: lead_coeff_mult prod_zero_iff')"], ["", "lemma complex_poly_decompose':\n  obtains root where \"smult (lead_coeff p) (\\<Prod>i<degree p. [:-root i, 1:]) = (p :: complex poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>root.\n        smult (lead_coeff p) (\\<Prod>i<degree p. [:- root i, 1:]) =\n        p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>root.\n        smult (lead_coeff p) (\\<Prod>i<degree p. [:- root i, 1:]) =\n        p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain roots where roots: \"mset roots = poly_roots_mset p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>roots.\n        mset roots = poly_roots_mset p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_mset"], ["proof (prove)\nusing this:\n  \\<exists>xs. mset xs = ?X\n\ngoal (1 subgoal):\n 1. (\\<And>roots.\n        mset roots = poly_roots_mset p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  mset roots = poly_roots_mset p\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        smult (lead_coeff p) (\\<Prod>i<degree p. [:- root i, 1:]) =\n        p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"p = smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:-x, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:])", "by (rule complex_poly_decompose_multiset [symmetric])"], ["proof (state)\nthis:\n  p = smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        smult (lead_coeff p) (\\<Prod>i<degree p. [:- root i, 1:]) =\n        p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  p = smult (lead_coeff p) (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        smult (lead_coeff p) (\\<Prod>i<degree p. [:- root i, 1:]) =\n        p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"(\\<Prod>x\\<in>#poly_roots_mset p. [:-x, 1:]) = (\\<Prod>x\\<leftarrow>roots. [:-x, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) =\n    (\\<Prod>x\\<leftarrow>roots. [:- x, 1:])", "by (subst prod_mset_prod_list [symmetric]) (simp add: roots)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) =\n  (\\<Prod>x\\<leftarrow>roots. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        smult (lead_coeff p) (\\<Prod>i<degree p. [:- root i, 1:]) =\n        p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>#poly_roots_mset p. [:- x, 1:]) =\n  (\\<Prod>x\\<leftarrow>roots. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        smult (lead_coeff p) (\\<Prod>i<degree p. [:- root i, 1:]) =\n        p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = (\\<Prod>i<length roots. [:-roots ! i, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<leftarrow>roots. [:- x, 1:]) =\n    (\\<Prod>i<length roots. [:- roots ! i, 1:])", "by (subst prod_list_prod_nth) (auto simp: atLeast0LessThan)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<leftarrow>roots. [:- x, 1:]) =\n  (\\<Prod>i<length roots. [:- roots ! i, 1:])\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        smult (lead_coeff p) (\\<Prod>i<degree p. [:- root i, 1:]) =\n        p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  p = smult (lead_coeff p) (\\<Prod>i<length roots. [:- roots ! i, 1:])", "have eq: \"p = smult (lead_coeff p) (\\<Prod>i<length roots. [:-roots ! i, 1:])\""], ["proof (prove)\nusing this:\n  p = smult (lead_coeff p) (\\<Prod>i<length roots. [:- roots ! i, 1:])\n\ngoal (1 subgoal):\n 1. p = smult (lead_coeff p) (\\<Prod>i<length roots. [:- roots ! i, 1:])", "."], ["proof (state)\nthis:\n  p = smult (lead_coeff p) (\\<Prod>i<length roots. [:- roots ! i, 1:])\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        smult (lead_coeff p) (\\<Prod>i<degree p. [:- root i, 1:]) =\n        p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  p = smult (lead_coeff p) (\\<Prod>i<length roots. [:- roots ! i, 1:])\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        smult (lead_coeff p) (\\<Prod>i<degree p. [:- root i, 1:]) =\n        p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have [simp]: \"degree p = length roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = length roots", "using roots"], ["proof (prove)\nusing this:\n  mset roots = poly_roots_mset p\n\ngoal (1 subgoal):\n 1. degree p = length roots", "by (subst eq) (auto simp: degree_prod_eq)"], ["proof (state)\nthis:\n  degree p = length roots\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        smult (lead_coeff p) (\\<Prod>i<degree p. [:- root i, 1:]) =\n        p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  p =\n  smult (coeff p (length roots)) (\\<Prod>i<length roots. [:- roots ! i, 1:])", "show ?thesis"], ["proof (prove)\nusing this:\n  p =\n  smult (coeff p (length roots)) (\\<Prod>i<length roots. [:- roots ! i, 1:])\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of \"\\<lambda>i. roots ! i\"]) auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rsquarefree_root_order:\n  assumes \"rsquarefree p\" \"poly p z = 0\" \"p \\<noteq> 0\"\n  shows   \"order z p = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order z p = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. order z p = 1", "from assms"], ["proof (chain)\npicking this:\n  rsquarefree p\n  poly p z = (0::'a)\n  p \\<noteq> 0", "have \"order z p \\<in> {0, 1}\""], ["proof (prove)\nusing this:\n  rsquarefree p\n  poly p z = (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. order z p \\<in> {0, 1}", "by (auto simp: rsquarefree_def)"], ["proof (state)\nthis:\n  order z p \\<in> {0, 1}\n\ngoal (1 subgoal):\n 1. order z p = 1", "moreover"], ["proof (state)\nthis:\n  order z p \\<in> {0, 1}\n\ngoal (1 subgoal):\n 1. order z p = 1", "from assms"], ["proof (chain)\npicking this:\n  rsquarefree p\n  poly p z = (0::'a)\n  p \\<noteq> 0", "have \"order z p > 0\""], ["proof (prove)\nusing this:\n  rsquarefree p\n  poly p z = (0::'a)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < order z p", "by (auto simp: order_root)"], ["proof (state)\nthis:\n  0 < order z p\n\ngoal (1 subgoal):\n 1. order z p = 1", "ultimately"], ["proof (chain)\npicking this:\n  order z p \\<in> {0, 1}\n  0 < order z p", "show \"order z p = 1\""], ["proof (prove)\nusing this:\n  order z p \\<in> {0, 1}\n  0 < order z p\n\ngoal (1 subgoal):\n 1. order z p = 1", "by auto"], ["proof (state)\nthis:\n  order z p = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma complex_poly_decompose_rsquarefree:\n  assumes \"rsquarefree p\"\n  shows   \"smult (lead_coeff p) (\\<Prod>z|poly p z = 0. [:-z, 1:]) = (p :: complex poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p", "have \"(\\<Prod>z|poly p z = 0. [:-z, 1:]) = (\\<Prod>z|poly p z = 0. [:-z, 1:] ^ order z p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) =\n    (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p)", "using assms False"], ["proof (prove)\nusing this:\n  rsquarefree p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) =\n    (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p)", "by (intro prod.cong) (auto simp: rsquarefree_root_order)"], ["proof (state)\nthis:\n  (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) =\n  (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p", "also"], ["proof (state)\nthis:\n  (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) =\n  (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p", "have \"smult (lead_coeff p) \\<dots> = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smult (lead_coeff p)\n     (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n    p", "by (rule complex_poly_decompose)"], ["proof (state)\nthis:\n  smult (lead_coeff p)\n   (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:] ^ order z p) =\n  p\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p", "finally"], ["proof (chain)\npicking this:\n  smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p", "show ?thesis"], ["proof (prove)\nusing this:\n  smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p\n\ngoal (1 subgoal):\n 1. smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p", "."], ["proof (state)\nthis:\n  smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    smult (lead_coeff p) (\\<Prod>z\\<in>{z. poly p z = 0}. [:- z, 1:]) = p", "qed auto"], ["", "lemma pcompose_conjugates_integer:\n  assumes \"\\<And>i. poly.coeff p i \\<in> \\<int>\"\n  shows   \"poly.coeff (pcompose p [:0, \\<i>:] * pcompose p [:0, -\\<i>:]) i \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "let ?c = \"\\<lambda>i. poly.coeff p i :: complex\""], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "have \"poly.coeff (pcompose p [:0, \\<i>:] * pcompose p [:0, -\\<i>:]) i =\n          \\<i> ^ i * (\\<Sum>k\\<le>i. (-1) ^ (i - k) * ?c k * ?c (i - k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i =\n    \\<i> ^ i *\n    (\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k))", "unfolding coeff_mult sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<le>i.\n        coeff (p \\<circ>\\<^sub>p [:0, \\<i>:]) ia *\n        coeff (p \\<circ>\\<^sub>p [:0, - \\<i>:]) (i - ia)) =\n    (\\<Sum>n\\<le>i.\n        \\<i> ^ i * ((- 1) ^ (i - n) * coeff p n * coeff p (i - n)))", "by (intro sum.cong) (auto simp: coeff_mult coeff_pcompose_linear power_minus' \n                                    power_diff field_simps intro!: Ints_sum)"], ["proof (state)\nthis:\n  coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n   i =\n  \\<i> ^ i * (\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k))\n\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n   i =\n  \\<i> ^ i * (\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k))\n\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "have \"(\\<Sum>k\\<le>i. (-1) ^ (i - k) * ?c k * ?c (i - k)) =\n          (\\<Sum>k\\<le>i. (-1) ^ k * ?c k * ?c (i - k))\" (is \"?S1 = ?S2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k)) =\n    (\\<Sum>k\\<le>i. (- 1) ^ k * coeff p k * coeff p (i - k))", "by (intro sum.reindex_bij_witness[of _ \"\\<lambda>k. i - k\" \"\\<lambda>k. i - k\"]) (auto simp: mult_ac)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k)) =\n  (\\<Sum>k\\<le>i. (- 1) ^ k * coeff p k * coeff p (i - k))\n\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "hence \"?S1 = (?S1 + ?S2) / 2\""], ["proof (prove)\nusing this:\n  (\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k)) =\n  (\\<Sum>k\\<le>i. (- 1) ^ k * coeff p k * coeff p (i - k))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k)) =\n    ((\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k)) +\n     (\\<Sum>k\\<le>i. (- 1) ^ k * coeff p k * coeff p (i - k))) /\n    2", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k)) =\n  ((\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k)) +\n   (\\<Sum>k\\<le>i. (- 1) ^ k * coeff p k * coeff p (i - k))) /\n  2\n\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k)) =\n  ((\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k)) +\n   (\\<Sum>k\\<le>i. (- 1) ^ k * coeff p k * coeff p (i - k))) /\n  2\n\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "have \"\\<dots> = (\\<Sum>k\\<le>i. ((-1) ^ k + (-1) ^ (i - k)) / 2 * ?c k * ?c (i - k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k)) +\n     (\\<Sum>k\\<le>i. (- 1) ^ k * coeff p k * coeff p (i - k))) /\n    2 =\n    (\\<Sum>k\\<le>i.\n        ((- 1) ^ k + (- 1) ^ (i - k)) / 2 * coeff p k * coeff p (i - k))", "by (simp add: ring_distribs sum.distrib sum_divide_distrib [symmetric])"], ["proof (state)\nthis:\n  ((\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k)) +\n   (\\<Sum>k\\<le>i. (- 1) ^ k * coeff p k * coeff p (i - k))) /\n  2 =\n  (\\<Sum>k\\<le>i.\n      ((- 1) ^ k + (- 1) ^ (i - k)) / 2 * coeff p k * coeff p (i - k))\n\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  ((\\<Sum>k\\<le>i. (- 1) ^ (i - k) * coeff p k * coeff p (i - k)) +\n   (\\<Sum>k\\<le>i. (- 1) ^ k * coeff p k * coeff p (i - k))) /\n  2 =\n  (\\<Sum>k\\<le>i.\n      ((- 1) ^ k + (- 1) ^ (i - k)) / 2 * coeff p k * coeff p (i - k))\n\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "have \"\\<dots> = (\\<Sum>k\\<le>i. (1 + (-1) ^ i) / 2 * (-1) ^ k * ?c k * ?c (i - k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<le>i.\n        ((- 1) ^ k + (- 1) ^ (i - k)) / 2 * coeff p k * coeff p (i - k)) =\n    (\\<Sum>k\\<le>i.\n        (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))", "by (intro sum.cong) (auto simp: power_add power_diff field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>i.\n      ((- 1) ^ k + (- 1) ^ (i - k)) / 2 * coeff p k * coeff p (i - k)) =\n  (\\<Sum>k\\<le>i.\n      (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  (\\<Sum>k\\<le>i.\n      ((- 1) ^ k + (- 1) ^ (i - k)) / 2 * coeff p k * coeff p (i - k)) =\n  (\\<Sum>k\\<le>i.\n      (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "have \"\\<i> ^ i * \\<dots> \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> ^ i *\n    (\\<Sum>k\\<le>i.\n        (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n    \\<in> \\<int>", "proof (cases \"even i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. even i \\<Longrightarrow>\n    \\<i> ^ i *\n    (\\<Sum>k\\<le>i.\n        (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n    \\<in> \\<int>\n 2. odd i \\<Longrightarrow>\n    \\<i> ^ i *\n    (\\<Sum>k\\<le>i.\n        (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n    \\<in> \\<int>", "case True"], ["proof (state)\nthis:\n  even i\n\ngoal (2 subgoals):\n 1. even i \\<Longrightarrow>\n    \\<i> ^ i *\n    (\\<Sum>k\\<le>i.\n        (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n    \\<in> \\<int>\n 2. odd i \\<Longrightarrow>\n    \\<i> ^ i *\n    (\\<Sum>k\\<le>i.\n        (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n    \\<in> \\<int>", "thus ?thesis"], ["proof (prove)\nusing this:\n  even i\n\ngoal (1 subgoal):\n 1. \\<i> ^ i *\n    (\\<Sum>k\\<le>i.\n        (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n    \\<in> \\<int>", "by (intro Ints_mult Ints_sum assms) (auto elim!: evenE simp: power_mult)"], ["proof (state)\nthis:\n  \\<i> ^ i *\n  (\\<Sum>k\\<le>i.\n      (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. odd i \\<Longrightarrow>\n    \\<i> ^ i *\n    (\\<Sum>k\\<le>i.\n        (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n    \\<in> \\<int>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. odd i \\<Longrightarrow>\n    \\<i> ^ i *\n    (\\<Sum>k\\<le>i.\n        (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n    \\<in> \\<int>", "case False"], ["proof (state)\nthis:\n  odd i\n\ngoal (1 subgoal):\n 1. odd i \\<Longrightarrow>\n    \\<i> ^ i *\n    (\\<Sum>k\\<le>i.\n        (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n    \\<in> \\<int>", "hence \"1 + (-1) ^ i = (0 :: complex)\""], ["proof (prove)\nusing this:\n  odd i\n\ngoal (1 subgoal):\n 1. 1 + (- 1) ^ i = 0", "by (auto elim!: oddE simp: power_mult)"], ["proof (state)\nthis:\n  1 + (- 1) ^ i = 0\n\ngoal (1 subgoal):\n 1. odd i \\<Longrightarrow>\n    \\<i> ^ i *\n    (\\<Sum>k\\<le>i.\n        (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n    \\<in> \\<int>", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 + (- 1) ^ i = 0\n\ngoal (1 subgoal):\n 1. \\<i> ^ i *\n    (\\<Sum>k\\<le>i.\n        (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n    \\<in> \\<int>", "by simp"], ["proof (state)\nthis:\n  \\<i> ^ i *\n  (\\<Sum>k\\<le>i.\n      (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n  \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<i> ^ i *\n  (\\<Sum>k\\<le>i.\n      (1 + (- 1) ^ i) / 2 * (- 1) ^ k * coeff p k * coeff p (i - k))\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:]) i\n  \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:]) i\n  \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:])\n     i\n    \\<in> \\<int>", "."], ["proof (state)\nthis:\n  coeff (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:]) i\n  \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraic_times_i:\n  assumes \"algebraic x\"\n  shows   \"algebraic (\\<i> * x)\" \"algebraic (-\\<i> * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (\\<i> * x) &&& algebraic (- \\<i> * x)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. algebraic (\\<i> * x)\n 2. algebraic (- \\<i> * x)", "from assms"], ["proof (chain)\npicking this:\n  algebraic x", "obtain p where p: \"poly p x = 0\" \"\\<forall>i. coeff p i \\<in> \\<int>\" \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  algebraic x\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>poly p x = 0; \\<forall>i. coeff p i \\<in> \\<int>;\n         p \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: algebraicE)"], ["proof (state)\nthis:\n  poly p x = 0\n  \\<forall>i. coeff p i \\<in> \\<int>\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. algebraic (\\<i> * x)\n 2. algebraic (- \\<i> * x)", "define p' where \"p' = pcompose p [:0, \\<i>:] * pcompose p [:0, -\\<i>:]\""], ["proof (state)\nthis:\n  p' = p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:]\n\ngoal (2 subgoals):\n 1. algebraic (\\<i> * x)\n 2. algebraic (- \\<i> * x)", "have p': \"poly p' (\\<i> * x) = 0\" \"poly p' (-\\<i> * x) = 0\" \"p' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p' (\\<i> * x) = 0 &&& poly p' (- \\<i> * x) = 0 &&& p' \\<noteq> 0", "by (auto simp: p'_def poly_pcompose algebra_simps p dest: pcompose_eq_0)"], ["proof (state)\nthis:\n  poly p' (\\<i> * x) = 0\n  poly p' (- \\<i> * x) = 0\n  p' \\<noteq> 0\n\ngoal (2 subgoals):\n 1. algebraic (\\<i> * x)\n 2. algebraic (- \\<i> * x)", "moreover"], ["proof (state)\nthis:\n  poly p' (\\<i> * x) = 0\n  poly p' (- \\<i> * x) = 0\n  p' \\<noteq> 0\n\ngoal (2 subgoals):\n 1. algebraic (\\<i> * x)\n 2. algebraic (- \\<i> * x)", "have \"\\<forall>i. poly.coeff p' i \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. coeff p' i \\<in> \\<int>", "using p"], ["proof (prove)\nusing this:\n  poly p x = 0\n  \\<forall>i. coeff p i \\<in> \\<int>\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>i. coeff p' i \\<in> \\<int>", "unfolding p'_def"], ["proof (prove)\nusing this:\n  poly p x = 0\n  \\<forall>i. coeff p i \\<in> \\<int>\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       coeff\n        (p \\<circ>\\<^sub>p [:0, \\<i>:] * p \\<circ>\\<^sub>p [:0, - \\<i>:]) i\n       \\<in> \\<int>", "by (intro allI pcompose_conjugates_integer) auto"], ["proof (state)\nthis:\n  \\<forall>i. coeff p' i \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. algebraic (\\<i> * x)\n 2. algebraic (- \\<i> * x)", "ultimately"], ["proof (chain)\npicking this:\n  poly p' (\\<i> * x) = 0\n  poly p' (- \\<i> * x) = 0\n  p' \\<noteq> 0\n  \\<forall>i. coeff p' i \\<in> \\<int>", "show \"algebraic (\\<i> * x)\" \"algebraic (-\\<i> * x)\""], ["proof (prove)\nusing this:\n  poly p' (\\<i> * x) = 0\n  poly p' (- \\<i> * x) = 0\n  p' \\<noteq> 0\n  \\<forall>i. coeff p' i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * x) &&& algebraic (- \\<i> * x)", "by (intro algebraicI[of p']; simp)+"], ["proof (state)\nthis:\n  algebraic (\\<i> * x)\n  algebraic (- \\<i> * x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraic_times_i_iff: \"algebraic (\\<i> * x) \\<longleftrightarrow> algebraic x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (\\<i> * x) = algebraic x", "using algebraic_times_i[of x] algebraic_times_i[of \"\\<i> * x\"]"], ["proof (prove)\nusing this:\n  algebraic x \\<Longrightarrow> algebraic (\\<i> * x)\n  algebraic x \\<Longrightarrow> algebraic (- \\<i> * x)\n  algebraic (\\<i> * x) \\<Longrightarrow> algebraic (\\<i> * (\\<i> * x))\n  algebraic (\\<i> * x) \\<Longrightarrow> algebraic (- \\<i> * (\\<i> * x))\n\ngoal (1 subgoal):\n 1. algebraic (\\<i> * x) = algebraic x", "by auto"], ["", "lemma ratpolyE:\n  assumes \"\\<forall>i. poly.coeff p i \\<in> \\<rat>\"\n  obtains q where \"p = map_poly of_rat q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = map_poly of_rat q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = map_poly of_rat q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall>i\\<in>{..Polynomial.degree p}. \\<exists>x. poly.coeff p i = of_rat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{..degree p}. \\<exists>x. coeff p i = of_rat x", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i. coeff p i \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{..degree p}. \\<exists>x. coeff p i = of_rat x", "by (auto simp: Rats_def)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{..degree p}. \\<exists>x. coeff p i = of_rat x\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = map_poly of_rat q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from bchoice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f. \\<forall>x\\<in>{..degree p}. coeff p x = of_rat (f x)", "obtain f\n    where f: \"\\<And>i. i \\<le> Polynomial.degree p \\<Longrightarrow> poly.coeff p i = of_rat (f i)\""], ["proof (prove)\nusing this:\n  \\<exists>f. \\<forall>x\\<in>{..degree p}. coeff p x = of_rat (f x)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        (\\<And>i.\n            i \\<le> degree p \\<Longrightarrow>\n            coeff p i = of_rat (f i)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ?i \\<le> degree p \\<Longrightarrow> coeff p ?i = of_rat (f ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = map_poly of_rat q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define q where \"q = Poly (map f [0..<Suc (Polynomial.degree p)])\""], ["proof (state)\nthis:\n  q = Poly (map f [0..<Suc (degree p)])\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = map_poly of_rat q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"p = map_poly of_rat q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = map_poly of_rat q", "by (intro poly_eqI) \n       (auto simp: coeff_map_poly q_def nth_default_def f coeff_eq_0 simp del: upt_Suc)"], ["proof (state)\nthis:\n  p = map_poly of_rat q\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        p = map_poly of_rat q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with that"], ["proof (chain)\npicking this:\n  p = map_poly of_rat ?q \\<Longrightarrow> thesis\n  p = map_poly of_rat q", "show ?thesis"], ["proof (prove)\nusing this:\n  p = map_poly of_rat ?q \\<Longrightarrow> thesis\n  p = map_poly of_rat q\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}