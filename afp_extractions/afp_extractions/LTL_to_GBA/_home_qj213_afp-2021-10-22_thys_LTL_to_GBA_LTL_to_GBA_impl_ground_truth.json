{"file_name": "/home/qj213/afp-2021-10-22/thys/LTL_to_GBA/LTL_to_GBA_impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LTL_to_GBA", "problem_names": ["lemmas ltlr_rel_induct[induct set] \n  = ltlr_rel.induct[simplified relAPP_def[of ltlr_rel, symmetric]]", "lemmas ltlr_rel_cases[cases set] \n  = ltlr_rel.cases[simplified relAPP_def[of ltlr_rel, symmetric]]", "lemmas ltlr_rel_intros \n  = ltlr_rel.intros[simplified relAPP_def[of ltlr_rel, symmetric]]", "lemma ltlr_rel_sv[relator_props]: \n  assumes SV: \"single_valued R\"  \n  shows \"single_valued (\\<langle>R\\<rangle>ltlr_rel)\"", "lemma ltlr_rel_id[relator_props]: \"\\<lbrakk> R = Id \\<rbrakk> \\<Longrightarrow> \\<langle>R\\<rangle>ltlr_rel = Id\"", "lemma ltlr_rel_id_simp[simp]:  \"\\<langle>Id\\<rangle>ltlr_rel = Id\"", "lemmas [autoref_rel_intf] = REL_INTFI[of ltlr_rel i_ltlr]", "lemma ltlr_con_param[param, autoref_rules]:\n  \"(True_ltlr, True_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(False_ltlr, False_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(Prop_ltlr, Prop_ltlr) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(Nprop_ltlr, Nprop_ltlr) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(And_ltlr, And_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(Or_ltlr, Or_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(Next_ltlr, Next_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(Until_ltlr, Until_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(Release_ltlr, Release_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\"", "lemma case_ltlr_param[param, autoref_rules]: \n  \"(case_ltlr,case_ltlr) \\<in> Rv \\<rightarrow> Rv \\<rightarrow> (R \\<rightarrow> Rv)\n                \\<rightarrow> (R \\<rightarrow> Rv)\n                  \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv)\n                    \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv)\n                      \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv)\n                        \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv)\n                          \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv) \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv\"", "lemma rec_ltlr_param[param, autoref_rules]: \n  \"(rec_ltlr,rec_ltlr) \\<in> Rv \\<rightarrow> Rv \\<rightarrow> (R \\<rightarrow> Rv)\n                \\<rightarrow> (R \\<rightarrow> Rv)\n                  \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv \\<rightarrow> Rv)\n                    \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv \\<rightarrow> Rv)\n                      \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv)\n                        \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv \\<rightarrow> Rv)\n                          \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv \\<rightarrow> Rv)\n                            \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv\"", "lemma case_ltlr_mono[refine_mono]: \n  assumes \"\\<phi> = True_ltlr \\<Longrightarrow> a\\<le>a'\"\n  assumes \"\\<phi> = False_ltlr \\<Longrightarrow> b\\<le>b'\"\n  assumes \"\\<And>p. \\<phi> = Prop_ltlr p \\<Longrightarrow> c p\\<le>c' p\"\n  assumes \"\\<And>p. \\<phi> = Nprop_ltlr p \\<Longrightarrow> d p\\<le>d' p\"\n  assumes \"\\<And>\\<mu> \\<nu>. \\<phi> = And_ltlr \\<mu> \\<nu> \\<Longrightarrow> e \\<mu> \\<nu>\\<le>e' \\<mu> \\<nu>\"\n  assumes \"\\<And>\\<mu> \\<nu>. \\<phi> = Or_ltlr \\<mu> \\<nu> \\<Longrightarrow> f \\<mu> \\<nu>\\<le>f' \\<mu> \\<nu>\"\n  assumes \"\\<And>\\<mu>. \\<phi> = Next_ltlr \\<mu> \\<Longrightarrow> g \\<mu>\\<le>g' \\<mu>\"\n  assumes \"\\<And>\\<mu> \\<nu>. \\<phi> = Until_ltlr \\<mu> \\<nu> \\<Longrightarrow> h \\<mu> \\<nu>\\<le>h' \\<mu> \\<nu>\"\n  assumes \"\\<And>\\<mu> \\<nu>. \\<phi> = Release_ltlr \\<mu> \\<nu> \\<Longrightarrow> i \\<mu> \\<nu>\\<le>i' \\<mu> \\<nu>\"\n  shows \"case_ltlr a b c d e f g h i \\<phi> \\<le> case_ltlr a' b' c' d' e' f' g' h' i' \\<phi>\"", "lemma ltlr_eq_autoref[autoref_rules]:\n  assumes EQP: \"(eq,(=)) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel\"\n  shows \"(ltlr_eq eq, (=)) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> bool_rel\"", "lemma ltlr_dflt_cmp[autoref_rules_raw]: \n  assumes \"PREFER_id R\"\n  shows\n  \"(dflt_cmp (\\<le>) (<), dflt_cmp (\\<le>) (<)) \n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> comp_res_rel\"", "lemma case_ltlr_gtransfer:\n  assumes\n  \"\\<gamma> ai \\<le> a\"\n  \"\\<gamma> bi \\<le> b\"\n  \"\\<And>a. \\<gamma> (ci a) \\<le> c a\"\n  \"\\<And>a. \\<gamma> (di a) \\<le> d a\"\n  \"\\<And>ltlr1 ltlr2. \\<gamma> (ei ltlr1 ltlr2) \\<le> e ltlr1 ltlr2\"\n  \"\\<And>ltlr1 ltlr2. \\<gamma> (fi ltlr1 ltlr2) \\<le> f ltlr1 ltlr2\"\n  \"\\<And>ltlr. \\<gamma> (gi ltlr) \\<le> g ltlr\"\n  \"\\<And>ltlr1 ltlr2. \\<gamma> (hi ltlr1 ltlr2) \\<le> h ltlr1 ltlr2\"\n  \"\\<And>ltlr1 ltlr2. \\<gamma> (iiv ltlr1 ltlr2) \\<le> i ltlr1 ltlr2\"\n  shows \"\\<gamma> (case_ltlr ai bi ci di ei fi gi hi iiv \\<phi>) \n    \\<le> (case_ltlr a b c d e f g h i \\<phi>)\"", "lemmas [refine_transfer] \n  = case_ltlr_gtransfer[where \\<gamma>=nres_of] case_ltlr_gtransfer[where \\<gamma>=RETURN]", "lemma [refine_transfer]:\n  assumes \n  \"ai \\<noteq> dSUCCEED\"\n  \"bi \\<noteq> dSUCCEED\"\n  \"\\<And>a. ci a \\<noteq> dSUCCEED\"\n  \"\\<And>a. di a \\<noteq> dSUCCEED\"\n  \"\\<And>ltlr1 ltlr2. ei ltlr1 ltlr2 \\<noteq> dSUCCEED\"\n  \"\\<And>ltlr1 ltlr2. fi ltlr1 ltlr2 \\<noteq> dSUCCEED\"\n  \"\\<And>ltlr. gi ltlr \\<noteq> dSUCCEED\"\n  \"\\<And>ltlr1 ltlr2. hi ltlr1 ltlr2 \\<noteq> dSUCCEED\"\n  \"\\<And>ltlr1 ltlr2. iiv ltlr1 ltlr2 \\<noteq> dSUCCEED\"\n  shows \"case_ltlr ai bi ci di ei fi gi hi iiv \\<phi> \\<noteq> dSUCCEED\"", "lemma node_rel_def: \"\\<langle>Re,R\\<rangle>node_rel = {( \n  \\<lparr> name_impl = namei, \n    incoming_impl = inci, \n    new_impl = newi,\n    old_impl = oldi,\n    next_impl = nexti,\n    \\<dots> = morei\n  \\<rparr>, \n  \\<lparr> name = name,\n    incoming = inc,\n    new=new,\n    old=old,\n    next = next,\n    \\<dots> = more\n  \\<rparr> ) | namei name inci inc newi new oldi old nexti next morei more. \n    (namei,name)\\<in>node_name_rel \n  \\<and> (inci,inc)\\<in>\\<langle>node_name_rel\\<rangle>dflt_rs_rel  \n  \\<and> (newi,new)\\<in>\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\n  \\<and> (oldi,old)\\<in>\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\n  \\<and> (nexti,next)\\<in>\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\n  \\<and> (morei,more)\\<in>Re\n  }\"", "lemma node_rel_sv[relator_props]: \n  \"single_valued Re \\<Longrightarrow> single_valued R \\<Longrightarrow> single_valued (\\<langle>Re,R\\<rangle>node_rel)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of node_rel i_node]", "lemma [autoref_rules]: \"(node_impl_ext, node_ext) \\<in> \n  node_name_rel \n  \\<rightarrow> \\<langle>node_name_rel\\<rangle>dflt_rs_rel \n  \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \n  \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \n  \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \n  \\<rightarrow> Re \n  \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\"", "lemma [autoref_rules]: \n  \"(node_impl.name_impl_update,node.name_update) \n  \\<in> (node_name_rel \\<rightarrow> node_name_rel) \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\"\n  \"(node_impl.incoming_impl_update,node.incoming_update) \n  \\<in> (\\<langle>node_name_rel\\<rangle>dflt_rs_rel \\<rightarrow> \\<langle>node_name_rel\\<rangle>dflt_rs_rel) \n    \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel \n    \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\"\n  \"(node_impl.new_impl_update,node.new_update) \n  \\<in> (\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\"\n  \"(node_impl.old_impl_update,node.old_update) \n  \\<in> (\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\"\n  \"(node_impl.next_impl_update,node.next_update) \n  \\<in> (\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\"\n  \"(node_impl.more_update,node.more_update) \n  \\<in> (Re \\<rightarrow> Re) \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\"", "lemma [autoref_rules]:\n  \"(node_impl.name_impl,node.name)\\<in>\\<langle>Re,R\\<rangle>node_rel \\<rightarrow> node_name_rel\"\n  \"(node_impl.incoming_impl,node.incoming)\n  \\<in> \\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>node_name_rel\\<rangle>dflt_rs_rel\"\n  \"(node_impl.new_impl,node.new)\\<in>\\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\"\n  \"(node_impl.old_impl,node.old)\\<in>\\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\"\n  \"(node_impl.next_impl,node.next)\\<in>\\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\"\n  \"(node_impl.more, node.more)\\<in>\\<langle>Re,R\\<rangle>node_rel \\<rightarrow> Re\"", "lemma expand_aimpl_refine:\n  fixes n_ns :: \"('a node \\<times> _)\"\n  defines \"R \\<equiv> Id \\<inter> {(_,(n,ns)). \\<forall>n'\\<in>ns. n > name n'}\"\n  defines \"R' \\<equiv> Id \\<inter> {(_,(n,ns)). \\<forall>n'\\<in>ns. name n > name n'}\"\n  assumes [refine]: \"(n_ns',n_ns)\\<in>R'\"\n  shows \"expand_aimpl n_ns' \\<le> \\<Down>R (expand\\<^sub>T n_ns)\"", "lemma create_graph_aimpl_refine: \"create_graph_aimpl \\<phi> \\<le> \\<Down>Id (create_graph\\<^sub>T \\<phi>)\"", "lemma create_name_gba_alt: \"create_name_gba \\<phi> = do {\n  nds \\<leftarrow> create_graph\\<^sub>T \\<phi>;\n  ASSERT (nds_invars nds);\n  RETURN (gba_rename_ext (\\<lambda>_. ()) name (create_gba_from_nodes \\<phi> nds))\n  }\"", "lemma build_succ_aux1:\n  assumes [simp]: \"finite nds\"\n  assumes [simp]: \"\\<And>q. q\\<in>nds \\<Longrightarrow> finite (incoming q)\"\n  shows \"build_succ nds \\<le> SPEC (\\<lambda>r. r = (\\<lambda>qn. \n  dflt_None_set {qn'. \\<exists>q'. \n    q'\\<in>nds \\<and> qn' = name q' \\<and> qn\\<in>incoming q' \\<and> qn\\<noteq>expand_init \n  }))\"", "lemma build_succ_aux2:\n  assumes NINIT: \"expand_init \\<notin> name`nds\"\n  assumes CL: \"\\<And>nd. nd\\<in>nds \\<Longrightarrow> incoming nd \\<subseteq> insert expand_init (name`nds)\"\n  shows\n  \"(\\<lambda>qn. dflt_None_set \n    {qn'. \\<exists>q'. q'\\<in>nds \\<and> qn' = name q' \\<and> qn\\<in>incoming q' \\<and> qn\\<noteq>expand_init }) \n  = (\\<lambda>qn. dflt_None_set (succ_of_E \n       (rename_E name {(q, q'). q \\<in> nds \\<and> q' \\<in> nds \\<and> name q \\<in> incoming q'}) qn))\" \n  (is \"(\\<lambda>qn. dflt_None_set (?L qn)) = (\\<lambda>qn. dflt_None_set (?R qn))\")", "lemma build_succ_correct:\n  assumes NINIT: \"expand_init \\<notin> name`nds\"\n  assumes FIN: \"finite nds\"\n  assumes CL: \"\\<And>nd. nd\\<in>nds \\<Longrightarrow> incoming nd \\<subseteq> insert expand_init (name`nds)\"\n  shows \"build_succ nds \\<le> SPEC (\\<lambda>r. \n    E_of_succ (\\<lambda>qn. the_default {} (r qn)) \n    = rename_E (\\<lambda>u. name u) {(q, q'). q \\<in> nds \\<and> q' \\<in> nds \\<and> name q \\<in> incoming q'})\"", "lemma until_frmlsr_correct: \n  \"until_frmlsr \\<phi> = {(\\<mu>, \\<eta>). Until_ltlr \\<mu> \\<eta> \\<in> subfrmlsr \\<phi>}\"", "lemma build_F_correct: \"build_F nds \\<phi> = \n  {name ` A |A. \\<exists>\\<mu> \\<eta>. A = {q \\<in> nds. Until_ltlr \\<mu> \\<eta> \\<in> old q \\<longrightarrow> \\<eta> \\<in> old q} \\<and>\n                     Until_ltlr \\<mu> \\<eta> \\<in> subfrmlsr \\<phi>}\"", "lemma pn_props_correct: \n  assumes [simp]: \"finite ps\"\n  shows \"pn_props ps \\<le> SPEC(\\<lambda>r. r = \n  ({p. Prop_ltlr p \\<in> ps}, {p. Nprop_ltlr p \\<in> ps}))\"", "lemma pn_map_correct: \n  assumes [simp]: \"finite nds\"\n  assumes FIN': \"\\<And>nd. nd\\<in>nds \\<Longrightarrow> finite (old nd)\"\n  assumes INJ: \"inj_on name nds\"\n  shows \"pn_map nds \\<le> SPEC (\\<lambda>r. \\<forall>qn. \n    case r qn of \n      None \\<Rightarrow> qn \\<notin> name`nds\n    | Some (P,N) \\<Rightarrow> qn \\<in> name`nds \n      \\<and> P = {p. Prop_ltlr p \\<in> old (the_inv_into nds name qn)}\n      \\<and> N = {p. Nprop_ltlr p \\<in> old (the_inv_into nds name qn)}\n  )\"", "lemma cr_rename_gba_refine:\n  assumes INV: \"nds_invars nds\"\n  assumes REL[simplified]: \"(nds',nds)\\<in>Id\" \"(\\<phi>',\\<phi>)\\<in>Id\"\n  shows \"cr_rename_gba nds' \\<phi>' \n  \\<le> \\<Down>Id (RETURN (gba_rename_ext (\\<lambda>_. ()) name (create_gba_from_nodes \\<phi> nds)))\"", "lemma create_name_gba_aimpl_refine: \n  \"create_name_gba_aimpl \\<phi> \\<le> \\<Down>Id (create_name_gba \\<phi>)\"", "lemmas [autoref_rules] = until_frmlsr_impl.refine[OF PREFER_id_D]", "lemmas [autoref_rules] = build_succ_impl.refine", "lemmas [refine_transfer] = build_succ_code.refine", "lemmas [autoref_rules] = build_F_impl.refine[OF PREFER_id_D]", "lemma pn_map_impl_autoref[autoref_rules]: \n  assumes \"PREFER_id R\"\n  shows \"(pn_map_impl,pn_map) \\<in> \n    \\<langle>\\<langle>Rm,R\\<rangle>node_rel\\<rangle>list_set_rel \n    \\<rightarrow> \\<langle>\\<langle>nat_rel,\\<langle>R\\<rangle>list_set_rel \\<times>\\<^sub>r \\<langle>R\\<rangle>list_set_rel\\<rangle>iam_map_rel\\<rangle>nres_rel\"", "lemmas [refine_transfer] = pn_map_code.refine", "lemma cr_rename_gba_autoref[autoref_rules]:\n  assumes \"PREFER_id R\"\n  shows \"(cr_rename_gba_impl, cr_rename_gba) \\<in> \n    \\<langle>\\<langle>Rm, R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n    \\<langle>gbav_impl_rel_ext unit_rel nat_rel (\\<langle>R\\<rangle>fun_set_rel)\\<rangle>nres_rel\"", "lemmas [refine_transfer] = cr_rename_gba_code.refine", "lemma ls_nds_rel_def: \"\\<langle>R\\<rangle>ls_nds_rel = \\<langle>R\\<rangle>list_set_rel \\<inter> {(_,s). inj_on name s}\"", "lemmas [autoref_rel_intf] = REL_INTFI[of ls_nds_rel i_set]", "lemma ls_nds_rel_sv[relator_props]: \n  assumes \"single_valued R\" \n  shows \"single_valued (\\<langle>R\\<rangle>ls_nds_rel)\"", "lemma lsnds_empty_autoref[autoref_rules]:\n  assumes \"PREFER_id R\"\n  shows \"([],{})\\<in>\\<langle>R\\<rangle>ls_nds_rel\"", "lemma lsnds_insert_autoref[autoref_rules]:\n  assumes \"SIDE_PRECOND (name n \\<notin> name`ns)\"\n  assumes \"(n',n)\\<in>R\"\n  assumes \"(ns',ns)\\<in>\\<langle>R\\<rangle>ls_nds_rel\"\n  shows \"(n'#ns',(OP insert ::: R \\<rightarrow> \\<langle>R\\<rangle>ls_nds_rel \\<rightarrow> \\<langle>R\\<rangle>ls_nds_rel)$n$ns)\n   \\<in> \\<langle>R\\<rangle>ls_nds_rel\"", "lemma ls_nds_image_autoref_aux:\n  assumes [autoref_rules]: \"(fi,f) \\<in> Ra \\<rightarrow> Rb\"\n  assumes \"(l,s) \\<in> \\<langle>Ra\\<rangle>ls_nds_rel\"\n  assumes [simp]: \"\\<forall>x. name (f x) = name x\"\n  shows \"(map fi l, f`s) \\<in> \\<langle>Rb\\<rangle>ls_nds_rel\"", "lemma ls_nds_image_autoref[autoref_rules]:\n  assumes \"(fi,f) \\<in> Ra \\<rightarrow> Rb\"\n  assumes \"SIDE_PRECOND (\\<forall>x. name (f x) = name x)\"\n  shows \"(map fi, (OP (`) ::: (Ra\\<rightarrow>Rb) \\<rightarrow> \\<langle>Ra\\<rangle>ls_nds_rel \\<rightarrow> \\<langle>Rb\\<rangle>ls_nds_rel)$f) \n    \\<in> \\<langle>Ra\\<rangle>ls_nds_rel \\<rightarrow> \\<langle>Rb\\<rangle>ls_nds_rel\"", "lemma list_set_autoref_to_list[autoref_ga_rules]: \n  shows \"is_set_to_sorted_list (\\<lambda>_ _. True) R ls_nds_rel id\"", "lemma [autoref_itype]:\n  \"upd_incoming \n    ::\\<^sub>i \\<langle>Im, I\\<rangle>\\<^sub>ii_node \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Im', I\\<rangle>\\<^sub>ii_node\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Im', I\\<rangle>\\<^sub>ii_node\\<rangle>\\<^sub>ii_set\"", "lemmas [autoref_rules] = upd_incoming_impl.refine[OF PREFER_D[of REL_IS_ID]]", "lemma [autoref_itype]: \"expand\\<^sub>T \n  ::\\<^sub>i \\<langle>\\<langle>i_unit, I\\<rangle>\\<^sub>ii_node, \\<langle>\\<langle>i_unit, I\\<rangle>\\<^sub>ii_node\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_prod \n  \\<rightarrow>\\<^sub>i \\<langle>\\<langle>i_nat,\\<langle>\\<langle>i_unit, I\\<rangle>\\<^sub>ii_node\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres\"", "lemma expand_autoref[autoref_rules]:\n  assumes ID: \"PREFER_id R\"\n  assumes A: \"(n_ns', n_ns) \n    \\<in> \\<langle>unit_rel,R\\<rangle>node_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,R\\<rangle>node_rel\\<rangle>list_set_rel\"\n  assumes B: \"SIDE_PRECOND (\n    let (n,ns)=n_ns in inj_on name ns \\<and> (\\<forall>n'\\<in>ns. name n > name n')\n  )\"\n  shows \"(expand_impl n_ns', \n    (OP expand_aimpl\n    ::: \\<langle>unit_rel,R\\<rangle>node_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,R\\<rangle>node_rel\\<rangle>list_set_rel \n    \\<rightarrow> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel)$n_ns) \n  \\<in> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel\"", "lemmas [refine_transfer] = expand_code.refine", "lemmas [autoref_rules] = create_graph_impl.refine[OF PREFER_id_D]", "lemmas [refine_transfer] = create_graph_code.refine", "lemma create_name_gba_autoref[autoref_rules]:\n  assumes \"PREFER_id R\"\n  shows\n  \"(create_name_gba_impl, create_name_gba)\n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>gbav_impl_rel_ext unit_rel nat_rel (\\<langle>R\\<rangle>fun_set_rel)\\<rangle>nres_rel\" \n  (is \"_:_\\<rightarrow>\\<langle>?R\\<rangle>nres_rel\")", "lemmas [refine_transfer] = create_name_gba_code.refine", "lemmas [autoref_rules] = create_name_igba_impl.refine[OF PREFER_id_D]", "lemmas [refine_transfer] = create_name_igba_code.refine"], "translations": [["", "lemmas ltlr_rel_induct[induct set] \n  = ltlr_rel.induct[simplified relAPP_def[of ltlr_rel, symmetric]]"], ["", "lemmas ltlr_rel_cases[cases set] \n  = ltlr_rel.cases[simplified relAPP_def[of ltlr_rel, symmetric]]"], ["", "lemmas ltlr_rel_intros \n  = ltlr_rel.intros[simplified relAPP_def[of ltlr_rel, symmetric]]"], ["", "inductive_simps ltlr_rel_left_simps[simplified relAPP_def[of ltlr_rel, symmetric]]: \n  \"(True_ltlr,z) \\<in> ltlr_rel R\"\n  \"(False_ltlr,z) \\<in> ltlr_rel R\"\n  \"(Prop_ltlr p, z) \\<in> ltlr_rel R\"\n  \"(Nprop_ltlr p, z) \\<in> ltlr_rel R\"\n  \"(And_ltlr a b, z) \\<in> ltlr_rel R\"\n  \"(Or_ltlr a b, z) \\<in> ltlr_rel R\"\n  \"(Next_ltlr a, z) \\<in> ltlr_rel R\"\n  \"(Until_ltlr a b, z) \\<in> ltlr_rel R\"\n  \"(Release_ltlr a b, z) \\<in> ltlr_rel R\""], ["", "lemma ltlr_rel_sv[relator_props]: \n  assumes SV: \"single_valued R\"  \n  shows \"single_valued (\\<langle>R\\<rangle>ltlr_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (\\<langle>R\\<rangle>ltlr_rel)", "proof (intro single_valuedI allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (x, z) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> y = z", "fix x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (x, z) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> y = z", "assume \"(x, y) \\<in> \\<langle>R\\<rangle>ltlr_rel\" \"(x, z) \\<in> \\<langle>R\\<rangle>ltlr_rel\""], ["proof (state)\nthis:\n  (x, y) \\<in> \\<langle>R\\<rangle>ltlr_rel\n  (x, z) \\<in> \\<langle>R\\<rangle>ltlr_rel\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>(x, y) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (x, z) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> y = z", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> \\<langle>R\\<rangle>ltlr_rel\n  (x, z) \\<in> \\<langle>R\\<rangle>ltlr_rel", "show \"y=z\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> \\<langle>R\\<rangle>ltlr_rel\n  (x, z) \\<in> \\<langle>R\\<rangle>ltlr_rel\n\ngoal (1 subgoal):\n 1. y = z", "apply (induction arbitrary: z)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>z.\n       (true\\<^sub>r, z) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n       true\\<^sub>r = z\n 2. \\<And>z.\n       (false\\<^sub>r, z)\n       \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n       false\\<^sub>r = z\n 3. \\<And>a a' z.\n       \\<lbrakk>(a, a') \\<in> R;\n        (prop\\<^sub>r(a), z) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> prop\\<^sub>r(a') = z\n 4. \\<And>a a' z.\n       \\<lbrakk>(a, a') \\<in> R;\n        (nprop\\<^sub>r(a), z) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> nprop\\<^sub>r(a') = z\n 5. \\<And>a a' b b' z.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>z.\n           (a, z) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           a' = z;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>z.\n           (b, z) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           b' = z;\n        (a and\\<^sub>r b, z) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> a' and\\<^sub>r b' = z\n 6. \\<And>a a' b b' z.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>z.\n           (a, z) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           a' = z;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>z.\n           (b, z) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           b' = z;\n        (a or\\<^sub>r b, z) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> a' or\\<^sub>r b' = z\n 7. \\<And>a a' z.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>z.\n           (a, z) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           a' = z;\n        (X\\<^sub>r a, z) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> X\\<^sub>r a' = z\n 8. \\<And>a a' b b' z.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>z.\n           (a, z) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           a' = z;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>z.\n           (b, z) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           b' = z;\n        (a U\\<^sub>r b, z) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> a' U\\<^sub>r b' = z\n 9. \\<And>a a' b b' z.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>z.\n           (a, z) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           a' = z;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>z.\n           (b, z) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           b' = z;\n        (a R\\<^sub>r b, z) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> a' R\\<^sub>r b' = z", "apply (simp (no_asm_use) only: ltlr_rel_left_simps \n      | blast intro: single_valuedD[OF SV])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y = z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltlr_rel_id[relator_props]: \"\\<lbrakk> R = Id \\<rbrakk> \\<Longrightarrow> \\<langle>R\\<rangle>ltlr_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R = Id \\<Longrightarrow> \\<langle>R\\<rangle>ltlr_rel = Id", "proof (intro equalityI subsetI, clarsimp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>R = Id; (a, b) \\<in> \\<langle>Id\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>b.\n       R = Id \\<Longrightarrow> (b, b) \\<in> \\<langle>Id\\<rangle>ltlr_rel", "fix a b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>R = Id; (a, b) \\<in> \\<langle>Id\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>b.\n       R = Id \\<Longrightarrow> (b, b) \\<in> \\<langle>Id\\<rangle>ltlr_rel", "assume \"(a,b)\\<in>\\<langle>Id\\<rangle>ltlr_rel\""], ["proof (state)\nthis:\n  (a, b) \\<in> \\<langle>Id\\<rangle>ltlr_rel\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>R = Id; (a, b) \\<in> \\<langle>Id\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>b.\n       R = Id \\<Longrightarrow> (b, b) \\<in> \\<langle>Id\\<rangle>ltlr_rel", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> \\<langle>Id\\<rangle>ltlr_rel", "show \"a=b\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> \\<langle>Id\\<rangle>ltlr_rel\n\ngoal (1 subgoal):\n 1. a = b", "by induction auto"], ["proof (state)\nthis:\n  a = b\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       R = Id \\<Longrightarrow> (b, b) \\<in> \\<langle>Id\\<rangle>ltlr_rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       R = Id \\<Longrightarrow> (b, b) \\<in> \\<langle>Id\\<rangle>ltlr_rel", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       R = Id \\<Longrightarrow> (b, b) \\<in> \\<langle>Id\\<rangle>ltlr_rel", "show \"(a,a)\\<in>\\<langle>Id\\<rangle>ltlr_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, a) \\<in> \\<langle>Id\\<rangle>ltlr_rel", "by (induction a) (auto intro: ltlr_rel_intros)"], ["proof (state)\nthis:\n  (a, a) \\<in> \\<langle>Id\\<rangle>ltlr_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltlr_rel_id_simp[simp]:  \"\\<langle>Id\\<rangle>ltlr_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id\\<rangle>ltlr_rel = Id", "by (rule ltlr_rel_id) simp"], ["", "consts i_ltlr :: \"interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of ltlr_rel i_ltlr]"], ["", "thm ltlr_rel_intros[no_vars]"], ["", "lemma ltlr_con_param[param, autoref_rules]:\n  \"(True_ltlr, True_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(False_ltlr, False_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(Prop_ltlr, Prop_ltlr) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(Nprop_ltlr, Nprop_ltlr) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(And_ltlr, And_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(Or_ltlr, Or_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(Next_ltlr, Next_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(Until_ltlr, Until_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\"\n  \"(Release_ltlr, Release_ltlr) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((true\\<^sub>r, true\\<^sub>r) \\<in> \\<langle>R\\<rangle>ltlr_rel &&&\n      (false\\<^sub>r, false\\<^sub>r) \\<in> \\<langle>R\\<rangle>ltlr_rel) &&&\n     (Prop_ltlr, Prop_ltlr)\n     \\<in> R \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel &&&\n     (Nprop_ltlr, Nprop_ltlr)\n     \\<in> R \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel) &&&\n    ((And_ltlr, And_ltlr)\n     \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           \\<langle>R\\<rangle>ltlr_rel &&&\n     (Or_ltlr, Or_ltlr)\n     \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           \\<langle>R\\<rangle>ltlr_rel) &&&\n    (Next_ltlr, Next_ltlr)\n    \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel &&&\n    (Until_ltlr, Until_ltlr)\n    \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel &&&\n    (Release_ltlr, Release_ltlr)\n    \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel", "by (auto intro: ltlr_rel_intros)"], ["", "lemma case_ltlr_param[param, autoref_rules]: \n  \"(case_ltlr,case_ltlr) \\<in> Rv \\<rightarrow> Rv \\<rightarrow> (R \\<rightarrow> Rv)\n                \\<rightarrow> (R \\<rightarrow> Rv)\n                  \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv)\n                    \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv)\n                      \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv)\n                        \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv)\n                          \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv) \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case_ltlr, case_ltlr)\n    \\<in> Rv \\<rightarrow>\n          Rv \\<rightarrow>\n          (R \\<rightarrow> Rv) \\<rightarrow>\n          (R \\<rightarrow> Rv) \\<rightarrow>\n          (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv) \\<rightarrow>\n          (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv) \\<rightarrow>\n          (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv) \\<rightarrow>\n          (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv) \\<rightarrow>\n          (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv) \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h ai\n       a'i.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (case ai of true\\<^sub>r \\<Rightarrow> a\n                          | false\\<^sub>r \\<Rightarrow> aa\n                          | prop\\<^sub>r(x) \\<Rightarrow> ab x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> ac x\n                          | x and\\<^sub>r xa \\<Rightarrow> ad x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> ae x xa\n                          | X\\<^sub>r x \\<Rightarrow> af x\n                          | x U\\<^sub>r xa \\<Rightarrow> ag x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> ah x xa,\n                          case a'i of true\\<^sub>r \\<Rightarrow> a'\n                          | false\\<^sub>r \\<Rightarrow> a'a\n                          | prop\\<^sub>r(x) \\<Rightarrow> a'b x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> a'c x\n                          | x and\\<^sub>r xa \\<Rightarrow> a'd x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> a'e x xa\n                          | X\\<^sub>r x \\<Rightarrow> a'f x\n                          | x U\\<^sub>r xa \\<Rightarrow> a'g x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> a'h x xa)\n                         \\<in> Rv", "apply (case_tac ai, simp_all add: ltlr_rel_left_simps)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h ai\n       a'i x3.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        \\<exists>a'. a'i = prop\\<^sub>r(a') \\<and> (x3, a') \\<in> R;\n        ai = prop\\<^sub>r(x3)\\<rbrakk>\n       \\<Longrightarrow> (ab x3,\n                          case a'i of true\\<^sub>r \\<Rightarrow> a'\n                          | false\\<^sub>r \\<Rightarrow> a'a\n                          | prop\\<^sub>r(x) \\<Rightarrow> a'b x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> a'c x\n                          | x and\\<^sub>r xa \\<Rightarrow> a'd x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> a'e x xa\n                          | X\\<^sub>r x \\<Rightarrow> a'f x\n                          | x U\\<^sub>r xa \\<Rightarrow> a'g x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> a'h x xa)\n                         \\<in> Rv\n 2. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h ai\n       a'i x4.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        \\<exists>a'. a'i = nprop\\<^sub>r(a') \\<and> (x4, a') \\<in> R;\n        ai = nprop\\<^sub>r(x4)\\<rbrakk>\n       \\<Longrightarrow> (ac x4,\n                          case a'i of true\\<^sub>r \\<Rightarrow> a'\n                          | false\\<^sub>r \\<Rightarrow> a'a\n                          | prop\\<^sub>r(x) \\<Rightarrow> a'b x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> a'c x\n                          | x and\\<^sub>r xa \\<Rightarrow> a'd x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> a'e x xa\n                          | X\\<^sub>r x \\<Rightarrow> a'f x\n                          | x U\\<^sub>r xa \\<Rightarrow> a'g x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> a'h x xa)\n                         \\<in> Rv\n 3. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h ai\n       a'i x51 x52.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        \\<exists>a' b'.\n           a'i = a' and\\<^sub>r b' \\<and>\n           (x51, a') \\<in> \\<langle>R\\<rangle>ltlr_rel \\<and>\n           (x52, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        ai = x51 and\\<^sub>r x52\\<rbrakk>\n       \\<Longrightarrow> (ad x51 x52,\n                          case a'i of true\\<^sub>r \\<Rightarrow> a'\n                          | false\\<^sub>r \\<Rightarrow> a'a\n                          | prop\\<^sub>r(x) \\<Rightarrow> a'b x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> a'c x\n                          | x and\\<^sub>r xa \\<Rightarrow> a'd x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> a'e x xa\n                          | X\\<^sub>r x \\<Rightarrow> a'f x\n                          | x U\\<^sub>r xa \\<Rightarrow> a'g x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> a'h x xa)\n                         \\<in> Rv\n 4. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h ai\n       a'i x61 x62.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        \\<exists>a' b'.\n           a'i = a' or\\<^sub>r b' \\<and>\n           (x61, a') \\<in> \\<langle>R\\<rangle>ltlr_rel \\<and>\n           (x62, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        ai = x61 or\\<^sub>r x62\\<rbrakk>\n       \\<Longrightarrow> (ae x61 x62,\n                          case a'i of true\\<^sub>r \\<Rightarrow> a'\n                          | false\\<^sub>r \\<Rightarrow> a'a\n                          | prop\\<^sub>r(x) \\<Rightarrow> a'b x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> a'c x\n                          | x and\\<^sub>r xa \\<Rightarrow> a'd x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> a'e x xa\n                          | X\\<^sub>r x \\<Rightarrow> a'f x\n                          | x U\\<^sub>r xa \\<Rightarrow> a'g x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> a'h x xa)\n                         \\<in> Rv\n 5. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h ai\n       a'i x7.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        \\<exists>a'.\n           a'i = X\\<^sub>r a' \\<and>\n           (x7, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        ai = X\\<^sub>r x7\\<rbrakk>\n       \\<Longrightarrow> (af x7,\n                          case a'i of true\\<^sub>r \\<Rightarrow> a'\n                          | false\\<^sub>r \\<Rightarrow> a'a\n                          | prop\\<^sub>r(x) \\<Rightarrow> a'b x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> a'c x\n                          | x and\\<^sub>r xa \\<Rightarrow> a'd x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> a'e x xa\n                          | X\\<^sub>r x \\<Rightarrow> a'f x\n                          | x U\\<^sub>r xa \\<Rightarrow> a'g x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> a'h x xa)\n                         \\<in> Rv\n 6. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h ai\n       a'i x81 x82.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        \\<exists>a' b'.\n           a'i = a' U\\<^sub>r b' \\<and>\n           (x81, a') \\<in> \\<langle>R\\<rangle>ltlr_rel \\<and>\n           (x82, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        ai = x81 U\\<^sub>r x82\\<rbrakk>\n       \\<Longrightarrow> (ag x81 x82,\n                          case a'i of true\\<^sub>r \\<Rightarrow> a'\n                          | false\\<^sub>r \\<Rightarrow> a'a\n                          | prop\\<^sub>r(x) \\<Rightarrow> a'b x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> a'c x\n                          | x and\\<^sub>r xa \\<Rightarrow> a'd x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> a'e x xa\n                          | X\\<^sub>r x \\<Rightarrow> a'f x\n                          | x U\\<^sub>r xa \\<Rightarrow> a'g x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> a'h x xa)\n                         \\<in> Rv\n 7. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h ai\n       a'i x91 x92.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        \\<exists>a' b'.\n           a'i = a' R\\<^sub>r b' \\<and>\n           (x91, a') \\<in> \\<langle>R\\<rangle>ltlr_rel \\<and>\n           (x92, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        ai = x91 R\\<^sub>r x92\\<rbrakk>\n       \\<Longrightarrow> (ah x91 x92,\n                          case a'i of true\\<^sub>r \\<Rightarrow> a'\n                          | false\\<^sub>r \\<Rightarrow> a'a\n                          | prop\\<^sub>r(x) \\<Rightarrow> a'b x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> a'c x\n                          | x and\\<^sub>r xa \\<Rightarrow> a'd x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> a'e x xa\n                          | X\\<^sub>r x \\<Rightarrow> a'f x\n                          | x U\\<^sub>r xa \\<Rightarrow> a'g x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> a'h x xa)\n                         \\<in> Rv", "apply (clarsimp_all)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h x3\n       a'j.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (x3, a'j) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (ab x3, a'b a'j) \\<in> Rv\n 2. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h x4\n       a'j.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (x4, a'j) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (ac x4, a'c a'j) \\<in> Rv\n 3. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h x51\n       x52 a'j b'.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (x51, a'j) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (x52, b') \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ad x51 x52, a'd a'j b') \\<in> Rv\n 4. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h x61\n       x62 a'j b'.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (x61, a'j) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (x62, b') \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ae x61 x62, a'e a'j b') \\<in> Rv\n 5. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h x7\n       a'j.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (x7, a'j) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (af x7, a'f a'j) \\<in> Rv\n 6. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h x81\n       x82 a'j b'.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (x81, a'j) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (x82, b') \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ag x81 x82, a'g a'j b') \\<in> Rv\n 7. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h x91\n       x92 a'j b'.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (af, a'f) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv;\n        (x91, a'j) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (x92, b') \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ah x91 x92, a'h a'j b') \\<in> Rv", "apply parametricity+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rec_ltlr_param[param, autoref_rules]: \n  \"(rec_ltlr,rec_ltlr) \\<in> Rv \\<rightarrow> Rv \\<rightarrow> (R \\<rightarrow> Rv)\n                \\<rightarrow> (R \\<rightarrow> Rv)\n                  \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv \\<rightarrow> Rv)\n                    \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv \\<rightarrow> Rv)\n                      \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv)\n                        \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv \\<rightarrow> Rv)\n                          \\<rightarrow> (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv \\<rightarrow> Rv)\n                            \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_ltlr, rec_ltlr)\n    \\<in> Rv \\<rightarrow>\n          Rv \\<rightarrow>\n          (R \\<rightarrow> Rv) \\<rightarrow>\n          (R \\<rightarrow> Rv) \\<rightarrow>\n          (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           Rv \\<rightarrow> Rv \\<rightarrow> Rv) \\<rightarrow>\n          (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           Rv \\<rightarrow> Rv \\<rightarrow> Rv) \\<rightarrow>\n          (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           Rv \\<rightarrow> Rv) \\<rightarrow>\n          (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           Rv \\<rightarrow> Rv \\<rightarrow> Rv) \\<rightarrow>\n          (\\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n           Rv \\<rightarrow> Rv \\<rightarrow> Rv) \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv", "proof (clarsimp, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h ai\n       a'i.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (af, a'f)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_ltlr a aa ab ac ad ae af ag ah ai,\n                          rec_ltlr a' a'a a'b a'c a'd a'e a'f a'g a'h a'i)\n                         \\<in> Rv", "case prems: 1"], ["proof (state)\nthis:\n  (a_, a'_) \\<in> Rv\n  (aa_, a'a_) \\<in> Rv\n  (ab_, a'b_) \\<in> R \\<rightarrow> Rv\n  (ac_, a'c_) \\<in> R \\<rightarrow> Rv\n  (ad_, a'd_)\n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        Rv \\<rightarrow> Rv \\<rightarrow> Rv\n  (ae_, a'e_)\n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        Rv \\<rightarrow> Rv \\<rightarrow> Rv\n  (af_, a'f_)\n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv\n  (ag_, a'g_)\n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        Rv \\<rightarrow> Rv \\<rightarrow> Rv\n  (ah_, a'h_)\n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        Rv \\<rightarrow> Rv \\<rightarrow> Rv\n  (ai_, a'i_) \\<in> \\<langle>R\\<rangle>ltlr_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b ac a'c ad a'd ae a'e af a'f ag a'g ah a'h ai\n       a'i.\n       \\<lbrakk>(a, a') \\<in> Rv; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> R \\<rightarrow> Rv;\n        (ac, a'c) \\<in> R \\<rightarrow> Rv;\n        (ad, a'd)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ae, a'e)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (af, a'f)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ag, a'g)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ah, a'h)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_ltlr a aa ab ac ad ae af ag ah ai,\n                          rec_ltlr a' a'a a'b a'c a'd a'e a'f a'g a'h a'i)\n                         \\<in> Rv", "from prems(10)"], ["proof (chain)\npicking this:\n  (ai_, a'i_) \\<in> \\<langle>R\\<rangle>ltlr_rel", "show ?case"], ["proof (prove)\nusing this:\n  (ai_, a'i_) \\<in> \\<langle>R\\<rangle>ltlr_rel\n\ngoal (1 subgoal):\n 1. (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai_,\n     rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i_)\n    \\<in> Rv", "apply (induction)"], ["proof (prove)\ngoal (9 subgoals):\n 1. (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ true\\<^sub>r,\n     rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ true\\<^sub>r)\n    \\<in> Rv\n 2. (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ false\\<^sub>r,\n     rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ false\\<^sub>r)\n    \\<in> Rv\n 3. \\<And>ai a'i.\n       (ai, a'i) \\<in> R \\<Longrightarrow>\n       (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ prop\\<^sub>r(ai),\n        rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_\n         prop\\<^sub>r(a'i))\n       \\<in> Rv\n 4. \\<And>ai a'i.\n       (ai, a'i) \\<in> R \\<Longrightarrow>\n       (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ nprop\\<^sub>r(ai),\n        rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_\n         nprop\\<^sub>r(a'i))\n       \\<in> Rv\n 5. \\<And>ai a'i b b'.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ b')\n        \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_\n                           (ai and\\<^sub>r b),\n                          rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                           a'h_ (a'i and\\<^sub>r b'))\n                         \\<in> Rv\n 6. \\<And>ai a'i b b'.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ b')\n        \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_\n                           (ai or\\<^sub>r b),\n                          rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                           a'h_ (a'i or\\<^sub>r b'))\n                         \\<in> Rv\n 7. \\<And>ai a'i.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_\n                           (X\\<^sub>r ai),\n                          rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                           a'h_ (X\\<^sub>r a'i))\n                         \\<in> Rv\n 8. \\<And>ai a'i b b'.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ b')\n        \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_\n                           (ai U\\<^sub>r b),\n                          rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                           a'h_ (a'i U\\<^sub>r b'))\n                         \\<in> Rv\n 9. \\<And>ai a'i b b'.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ b')\n        \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_\n                           (ai R\\<^sub>r b),\n                          rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                           a'h_ (a'i R\\<^sub>r b'))\n                         \\<in> Rv", "using prems(1-9)"], ["proof (prove)\nusing this:\n  (a_, a'_) \\<in> Rv\n  (aa_, a'a_) \\<in> Rv\n  (ab_, a'b_) \\<in> R \\<rightarrow> Rv\n  (ac_, a'c_) \\<in> R \\<rightarrow> Rv\n  (ad_, a'd_)\n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        Rv \\<rightarrow> Rv \\<rightarrow> Rv\n  (ae_, a'e_)\n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        Rv \\<rightarrow> Rv \\<rightarrow> Rv\n  (af_, a'f_)\n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv\n  (ag_, a'g_)\n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        Rv \\<rightarrow> Rv \\<rightarrow> Rv\n  (ah_, a'h_)\n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        Rv \\<rightarrow> Rv \\<rightarrow> Rv\n\ngoal (9 subgoals):\n 1. (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ true\\<^sub>r,\n     rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ true\\<^sub>r)\n    \\<in> Rv\n 2. (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ false\\<^sub>r,\n     rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ false\\<^sub>r)\n    \\<in> Rv\n 3. \\<And>ai a'i.\n       (ai, a'i) \\<in> R \\<Longrightarrow>\n       (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ prop\\<^sub>r(ai),\n        rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_\n         prop\\<^sub>r(a'i))\n       \\<in> Rv\n 4. \\<And>ai a'i.\n       (ai, a'i) \\<in> R \\<Longrightarrow>\n       (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ nprop\\<^sub>r(ai),\n        rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_\n         nprop\\<^sub>r(a'i))\n       \\<in> Rv\n 5. \\<And>ai a'i b b'.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ b')\n        \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_\n                           (ai and\\<^sub>r b),\n                          rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                           a'h_ (a'i and\\<^sub>r b'))\n                         \\<in> Rv\n 6. \\<And>ai a'i b b'.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ b')\n        \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_\n                           (ai or\\<^sub>r b),\n                          rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                           a'h_ (a'i or\\<^sub>r b'))\n                         \\<in> Rv\n 7. \\<And>ai a'i.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_\n                           (X\\<^sub>r ai),\n                          rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                           a'h_ (X\\<^sub>r a'i))\n                         \\<in> Rv\n 8. \\<And>ai a'i b b'.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ b')\n        \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_\n                           (ai U\\<^sub>r b),\n                          rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                           a'h_ (a'i U\\<^sub>r b'))\n                         \\<in> Rv\n 9. \\<And>ai a'i b b'.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ b')\n        \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_\n                           (ai R\\<^sub>r b),\n                          rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                           a'h_ (a'i R\\<^sub>r b'))\n                         \\<in> Rv", "apply simp_all"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>ai a'i.\n       \\<lbrakk>(ai, a'i) \\<in> R; (a_, a'_) \\<in> Rv; (aa_, a'a_) \\<in> Rv;\n        (ab_, a'b_) \\<in> R \\<rightarrow> Rv;\n        (ac_, a'c_) \\<in> R \\<rightarrow> Rv;\n        (ad_, a'd_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ae_, a'e_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (af_, a'f_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ag_, a'g_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ah_, a'h_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> (ab_ ai, a'b_ a'i) \\<in> Rv\n 2. \\<And>ai a'i.\n       \\<lbrakk>(ai, a'i) \\<in> R; (a_, a'_) \\<in> Rv; (aa_, a'a_) \\<in> Rv;\n        (ab_, a'b_) \\<in> R \\<rightarrow> Rv;\n        (ac_, a'c_) \\<in> R \\<rightarrow> Rv;\n        (ad_, a'd_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ae_, a'e_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (af_, a'f_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ag_, a'g_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ah_, a'h_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> (ac_ ai, a'c_ a'i) \\<in> Rv\n 3. \\<And>ai a'i b b'.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ b')\n        \\<in> Rv;\n        (a_, a'_) \\<in> Rv; (aa_, a'a_) \\<in> Rv;\n        (ab_, a'b_) \\<in> R \\<rightarrow> Rv;\n        (ac_, a'c_) \\<in> R \\<rightarrow> Rv;\n        (ad_, a'd_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ae_, a'e_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (af_, a'f_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ag_, a'g_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ah_, a'h_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> (ad_ ai b\n                           (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai)\n                           (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b),\n                          a'd_ a'i b'\n                           (rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                             a'h_ a'i)\n                           (rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                             a'h_ b'))\n                         \\<in> Rv\n 4. \\<And>ai a'i b b'.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ b')\n        \\<in> Rv;\n        (a_, a'_) \\<in> Rv; (aa_, a'a_) \\<in> Rv;\n        (ab_, a'b_) \\<in> R \\<rightarrow> Rv;\n        (ac_, a'c_) \\<in> R \\<rightarrow> Rv;\n        (ad_, a'd_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ae_, a'e_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (af_, a'f_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ag_, a'g_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ah_, a'h_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> (ae_ ai b\n                           (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai)\n                           (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b),\n                          a'e_ a'i b'\n                           (rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                             a'h_ a'i)\n                           (rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                             a'h_ b'))\n                         \\<in> Rv\n 5. \\<And>ai a'i.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv;\n        (a_, a'_) \\<in> Rv; (aa_, a'a_) \\<in> Rv;\n        (ab_, a'b_) \\<in> R \\<rightarrow> Rv;\n        (ac_, a'c_) \\<in> R \\<rightarrow> Rv;\n        (ad_, a'd_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ae_, a'e_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (af_, a'f_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ag_, a'g_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ah_, a'h_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> (af_ ai\n                           (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai),\n                          a'f_ a'i\n                           (rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                             a'h_ a'i))\n                         \\<in> Rv\n 6. \\<And>ai a'i b b'.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ b')\n        \\<in> Rv;\n        (a_, a'_) \\<in> Rv; (aa_, a'a_) \\<in> Rv;\n        (ab_, a'b_) \\<in> R \\<rightarrow> Rv;\n        (ac_, a'c_) \\<in> R \\<rightarrow> Rv;\n        (ad_, a'd_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ae_, a'e_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (af_, a'f_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ag_, a'g_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ah_, a'h_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> (ag_ ai b\n                           (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai)\n                           (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b),\n                          a'g_ a'i b'\n                           (rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                             a'h_ a'i)\n                           (rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                             a'h_ b'))\n                         \\<in> Rv\n 7. \\<And>ai a'i b b'.\n       \\<lbrakk>(ai, a'i) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i)\n        \\<in> Rv;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b,\n         rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ b')\n        \\<in> Rv;\n        (a_, a'_) \\<in> Rv; (aa_, a'a_) \\<in> Rv;\n        (ab_, a'b_) \\<in> R \\<rightarrow> Rv;\n        (ac_, a'c_) \\<in> R \\<rightarrow> Rv;\n        (ad_, a'd_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ae_, a'e_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (af_, a'f_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ag_, a'g_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv;\n        (ah_, a'h_)\n        \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n              Rv \\<rightarrow> Rv \\<rightarrow> Rv\\<rbrakk>\n       \\<Longrightarrow> (ah_ ai b\n                           (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai)\n                           (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ b),\n                          a'h_ a'i b'\n                           (rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                             a'h_ a'i)\n                           (rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_\n                             a'h_ b'))\n                         \\<in> Rv", "apply parametricity+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (rec_ltlr a_ aa_ ab_ ac_ ad_ ae_ af_ ag_ ah_ ai_,\n   rec_ltlr a'_ a'a_ a'b_ a'c_ a'd_ a'e_ a'f_ a'g_ a'h_ a'i_)\n  \\<in> Rv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma case_ltlr_mono[refine_mono]: \n  assumes \"\\<phi> = True_ltlr \\<Longrightarrow> a\\<le>a'\"\n  assumes \"\\<phi> = False_ltlr \\<Longrightarrow> b\\<le>b'\"\n  assumes \"\\<And>p. \\<phi> = Prop_ltlr p \\<Longrightarrow> c p\\<le>c' p\"\n  assumes \"\\<And>p. \\<phi> = Nprop_ltlr p \\<Longrightarrow> d p\\<le>d' p\"\n  assumes \"\\<And>\\<mu> \\<nu>. \\<phi> = And_ltlr \\<mu> \\<nu> \\<Longrightarrow> e \\<mu> \\<nu>\\<le>e' \\<mu> \\<nu>\"\n  assumes \"\\<And>\\<mu> \\<nu>. \\<phi> = Or_ltlr \\<mu> \\<nu> \\<Longrightarrow> f \\<mu> \\<nu>\\<le>f' \\<mu> \\<nu>\"\n  assumes \"\\<And>\\<mu>. \\<phi> = Next_ltlr \\<mu> \\<Longrightarrow> g \\<mu>\\<le>g' \\<mu>\"\n  assumes \"\\<And>\\<mu> \\<nu>. \\<phi> = Until_ltlr \\<mu> \\<nu> \\<Longrightarrow> h \\<mu> \\<nu>\\<le>h' \\<mu> \\<nu>\"\n  assumes \"\\<And>\\<mu> \\<nu>. \\<phi> = Release_ltlr \\<mu> \\<nu> \\<Longrightarrow> i \\<mu> \\<nu>\\<le>i' \\<mu> \\<nu>\"\n  shows \"case_ltlr a b c d e f g h i \\<phi> \\<le> case_ltlr a' b' c' d' e' f' g' h' i' \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n     | false\\<^sub>r \\<Rightarrow> b | prop\\<^sub>r(x) \\<Rightarrow> c x\n     | nprop\\<^sub>r(x) \\<Rightarrow> d x\n     | x and\\<^sub>r xa \\<Rightarrow> e x xa\n     | x or\\<^sub>r xa \\<Rightarrow> f x xa | X\\<^sub>r x \\<Rightarrow> g x\n     | x U\\<^sub>r xa \\<Rightarrow> h x xa\n     | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n    \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a'\n           | false\\<^sub>r \\<Rightarrow> b'\n           | prop\\<^sub>r(x) \\<Rightarrow> c' x\n           | nprop\\<^sub>r(x) \\<Rightarrow> d' x\n           | x and\\<^sub>r xa \\<Rightarrow> e' x xa\n           | x or\\<^sub>r xa \\<Rightarrow> f' x xa\n           | X\\<^sub>r x \\<Rightarrow> g' x\n           | x U\\<^sub>r xa \\<Rightarrow> h' x xa\n           | x R\\<^sub>r xa \\<Rightarrow> i' x xa)", "using assms"], ["proof (prove)\nusing this:\n  \\<phi> = true\\<^sub>r \\<Longrightarrow> a \\<le> a'\n  \\<phi> = false\\<^sub>r \\<Longrightarrow> b \\<le> b'\n  \\<phi> = prop\\<^sub>r(?p) \\<Longrightarrow> c ?p \\<le> c' ?p\n  \\<phi> = nprop\\<^sub>r(?p) \\<Longrightarrow> d ?p \\<le> d' ?p\n  \\<phi> = ?\\<mu> and\\<^sub>r ?\\<nu> \\<Longrightarrow>\n  e ?\\<mu> ?\\<nu> \\<le> e' ?\\<mu> ?\\<nu>\n  \\<phi> = ?\\<mu> or\\<^sub>r ?\\<nu> \\<Longrightarrow>\n  f ?\\<mu> ?\\<nu> \\<le> f' ?\\<mu> ?\\<nu>\n  \\<phi> = X\\<^sub>r ?\\<mu> \\<Longrightarrow> g ?\\<mu> \\<le> g' ?\\<mu>\n  \\<phi> = ?\\<mu> U\\<^sub>r ?\\<nu> \\<Longrightarrow>\n  h ?\\<mu> ?\\<nu> \\<le> h' ?\\<mu> ?\\<nu>\n  \\<phi> = ?\\<mu> R\\<^sub>r ?\\<nu> \\<Longrightarrow>\n  i ?\\<mu> ?\\<nu> \\<le> i' ?\\<mu> ?\\<nu>\n\ngoal (1 subgoal):\n 1. (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n     | false\\<^sub>r \\<Rightarrow> b | prop\\<^sub>r(x) \\<Rightarrow> c x\n     | nprop\\<^sub>r(x) \\<Rightarrow> d x\n     | x and\\<^sub>r xa \\<Rightarrow> e x xa\n     | x or\\<^sub>r xa \\<Rightarrow> f x xa | X\\<^sub>r x \\<Rightarrow> g x\n     | x U\\<^sub>r xa \\<Rightarrow> h x xa\n     | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n    \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a'\n           | false\\<^sub>r \\<Rightarrow> b'\n           | prop\\<^sub>r(x) \\<Rightarrow> c' x\n           | nprop\\<^sub>r(x) \\<Rightarrow> d' x\n           | x and\\<^sub>r xa \\<Rightarrow> e' x xa\n           | x or\\<^sub>r xa \\<Rightarrow> f' x xa\n           | X\\<^sub>r x \\<Rightarrow> g' x\n           | x U\\<^sub>r xa \\<Rightarrow> h' x xa\n           | x R\\<^sub>r xa \\<Rightarrow> i' x xa)", "apply (cases \\<phi>)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<phi> = true\\<^sub>r \\<Longrightarrow> a \\<le> a';\n     \\<phi> = false\\<^sub>r \\<Longrightarrow> b \\<le> b';\n     \\<And>p. \\<phi> = prop\\<^sub>r(p) \\<Longrightarrow> c p \\<le> c' p;\n     \\<And>p. \\<phi> = nprop\\<^sub>r(p) \\<Longrightarrow> d p \\<le> d' p;\n     \\<And>\\<mu> \\<nu>.\n        \\<phi> = \\<mu> and\\<^sub>r \\<nu> \\<Longrightarrow>\n        e \\<mu> \\<nu> \\<le> e' \\<mu> \\<nu>;\n     \\<And>\\<mu> \\<nu>.\n        \\<phi> = \\<mu> or\\<^sub>r \\<nu> \\<Longrightarrow>\n        f \\<mu> \\<nu> \\<le> f' \\<mu> \\<nu>;\n     \\<And>\\<mu>.\n        \\<phi> = X\\<^sub>r \\<mu> \\<Longrightarrow> g \\<mu> \\<le> g' \\<mu>;\n     \\<And>\\<mu> \\<nu>.\n        \\<phi> = \\<mu> U\\<^sub>r \\<nu> \\<Longrightarrow>\n        h \\<mu> \\<nu> \\<le> h' \\<mu> \\<nu>;\n     \\<And>\\<mu> \\<nu>.\n        \\<phi> = \\<mu> R\\<^sub>r \\<nu> \\<Longrightarrow>\n        i \\<mu> \\<nu> \\<le> i' \\<mu> \\<nu>;\n     \\<phi> = true\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n                       | false\\<^sub>r \\<Rightarrow> b\n                       | prop\\<^sub>r(x) \\<Rightarrow> c x\n                       | nprop\\<^sub>r(x) \\<Rightarrow> d x\n                       | x and\\<^sub>r xa \\<Rightarrow> e x xa\n                       | x or\\<^sub>r xa \\<Rightarrow> f x xa\n                       | X\\<^sub>r x \\<Rightarrow> g x\n                       | x U\\<^sub>r xa \\<Rightarrow> h x xa\n                       | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n                      \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a'\n                             | false\\<^sub>r \\<Rightarrow> b'\n                             | prop\\<^sub>r(x) \\<Rightarrow> c' x\n                             | nprop\\<^sub>r(x) \\<Rightarrow> d' x\n                             | x and\\<^sub>r xa \\<Rightarrow> e' x xa\n                             | x or\\<^sub>r xa \\<Rightarrow> f' x xa\n                             | X\\<^sub>r x \\<Rightarrow> g' x\n                             | x U\\<^sub>r xa \\<Rightarrow> h' x xa\n                             | x R\\<^sub>r xa \\<Rightarrow> i' x xa)\n 2. \\<lbrakk>\\<phi> = true\\<^sub>r \\<Longrightarrow> a \\<le> a';\n     \\<phi> = false\\<^sub>r \\<Longrightarrow> b \\<le> b';\n     \\<And>p. \\<phi> = prop\\<^sub>r(p) \\<Longrightarrow> c p \\<le> c' p;\n     \\<And>p. \\<phi> = nprop\\<^sub>r(p) \\<Longrightarrow> d p \\<le> d' p;\n     \\<And>\\<mu> \\<nu>.\n        \\<phi> = \\<mu> and\\<^sub>r \\<nu> \\<Longrightarrow>\n        e \\<mu> \\<nu> \\<le> e' \\<mu> \\<nu>;\n     \\<And>\\<mu> \\<nu>.\n        \\<phi> = \\<mu> or\\<^sub>r \\<nu> \\<Longrightarrow>\n        f \\<mu> \\<nu> \\<le> f' \\<mu> \\<nu>;\n     \\<And>\\<mu>.\n        \\<phi> = X\\<^sub>r \\<mu> \\<Longrightarrow> g \\<mu> \\<le> g' \\<mu>;\n     \\<And>\\<mu> \\<nu>.\n        \\<phi> = \\<mu> U\\<^sub>r \\<nu> \\<Longrightarrow>\n        h \\<mu> \\<nu> \\<le> h' \\<mu> \\<nu>;\n     \\<And>\\<mu> \\<nu>.\n        \\<phi> = \\<mu> R\\<^sub>r \\<nu> \\<Longrightarrow>\n        i \\<mu> \\<nu> \\<le> i' \\<mu> \\<nu>;\n     \\<phi> = false\\<^sub>r\\<rbrakk>\n    \\<Longrightarrow> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n                       | false\\<^sub>r \\<Rightarrow> b\n                       | prop\\<^sub>r(x) \\<Rightarrow> c x\n                       | nprop\\<^sub>r(x) \\<Rightarrow> d x\n                       | x and\\<^sub>r xa \\<Rightarrow> e x xa\n                       | x or\\<^sub>r xa \\<Rightarrow> f x xa\n                       | X\\<^sub>r x \\<Rightarrow> g x\n                       | x U\\<^sub>r xa \\<Rightarrow> h x xa\n                       | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n                      \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a'\n                             | false\\<^sub>r \\<Rightarrow> b'\n                             | prop\\<^sub>r(x) \\<Rightarrow> c' x\n                             | nprop\\<^sub>r(x) \\<Rightarrow> d' x\n                             | x and\\<^sub>r xa \\<Rightarrow> e' x xa\n                             | x or\\<^sub>r xa \\<Rightarrow> f' x xa\n                             | X\\<^sub>r x \\<Rightarrow> g' x\n                             | x U\\<^sub>r xa \\<Rightarrow> h' x xa\n                             | x R\\<^sub>r xa \\<Rightarrow> i' x xa)\n 3. \\<And>x3.\n       \\<lbrakk>\\<phi> = true\\<^sub>r \\<Longrightarrow> a \\<le> a';\n        \\<phi> = false\\<^sub>r \\<Longrightarrow> b \\<le> b';\n        \\<And>p. \\<phi> = prop\\<^sub>r(p) \\<Longrightarrow> c p \\<le> c' p;\n        \\<And>p. \\<phi> = nprop\\<^sub>r(p) \\<Longrightarrow> d p \\<le> d' p;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> and\\<^sub>r \\<nu> \\<Longrightarrow>\n           e \\<mu> \\<nu> \\<le> e' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> or\\<^sub>r \\<nu> \\<Longrightarrow>\n           f \\<mu> \\<nu> \\<le> f' \\<mu> \\<nu>;\n        \\<And>\\<mu>.\n           \\<phi> = X\\<^sub>r \\<mu> \\<Longrightarrow>\n           g \\<mu> \\<le> g' \\<mu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> U\\<^sub>r \\<nu> \\<Longrightarrow>\n           h \\<mu> \\<nu> \\<le> h' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> R\\<^sub>r \\<nu> \\<Longrightarrow>\n           i \\<mu> \\<nu> \\<le> i' \\<mu> \\<nu>;\n        \\<phi> = prop\\<^sub>r(x3)\\<rbrakk>\n       \\<Longrightarrow> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n                          | false\\<^sub>r \\<Rightarrow> b\n                          | prop\\<^sub>r(x) \\<Rightarrow> c x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> d x\n                          | x and\\<^sub>r xa \\<Rightarrow> e x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> f x xa\n                          | X\\<^sub>r x \\<Rightarrow> g x\n                          | x U\\<^sub>r xa \\<Rightarrow> h x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n                         \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a'\n                                | false\\<^sub>r \\<Rightarrow> b'\n                                | prop\\<^sub>r(x) \\<Rightarrow> c' x\n                                | nprop\\<^sub>r(x) \\<Rightarrow> d' x\n                                | x and\\<^sub>r xa \\<Rightarrow> e' x xa\n                                | x or\\<^sub>r xa \\<Rightarrow> f' x xa\n                                | X\\<^sub>r x \\<Rightarrow> g' x\n                                | x U\\<^sub>r xa \\<Rightarrow> h' x xa\n                                | x R\\<^sub>r xa \\<Rightarrow> i' x xa)\n 4. \\<And>x4.\n       \\<lbrakk>\\<phi> = true\\<^sub>r \\<Longrightarrow> a \\<le> a';\n        \\<phi> = false\\<^sub>r \\<Longrightarrow> b \\<le> b';\n        \\<And>p. \\<phi> = prop\\<^sub>r(p) \\<Longrightarrow> c p \\<le> c' p;\n        \\<And>p. \\<phi> = nprop\\<^sub>r(p) \\<Longrightarrow> d p \\<le> d' p;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> and\\<^sub>r \\<nu> \\<Longrightarrow>\n           e \\<mu> \\<nu> \\<le> e' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> or\\<^sub>r \\<nu> \\<Longrightarrow>\n           f \\<mu> \\<nu> \\<le> f' \\<mu> \\<nu>;\n        \\<And>\\<mu>.\n           \\<phi> = X\\<^sub>r \\<mu> \\<Longrightarrow>\n           g \\<mu> \\<le> g' \\<mu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> U\\<^sub>r \\<nu> \\<Longrightarrow>\n           h \\<mu> \\<nu> \\<le> h' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> R\\<^sub>r \\<nu> \\<Longrightarrow>\n           i \\<mu> \\<nu> \\<le> i' \\<mu> \\<nu>;\n        \\<phi> = nprop\\<^sub>r(x4)\\<rbrakk>\n       \\<Longrightarrow> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n                          | false\\<^sub>r \\<Rightarrow> b\n                          | prop\\<^sub>r(x) \\<Rightarrow> c x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> d x\n                          | x and\\<^sub>r xa \\<Rightarrow> e x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> f x xa\n                          | X\\<^sub>r x \\<Rightarrow> g x\n                          | x U\\<^sub>r xa \\<Rightarrow> h x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n                         \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a'\n                                | false\\<^sub>r \\<Rightarrow> b'\n                                | prop\\<^sub>r(x) \\<Rightarrow> c' x\n                                | nprop\\<^sub>r(x) \\<Rightarrow> d' x\n                                | x and\\<^sub>r xa \\<Rightarrow> e' x xa\n                                | x or\\<^sub>r xa \\<Rightarrow> f' x xa\n                                | X\\<^sub>r x \\<Rightarrow> g' x\n                                | x U\\<^sub>r xa \\<Rightarrow> h' x xa\n                                | x R\\<^sub>r xa \\<Rightarrow> i' x xa)\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<phi> = true\\<^sub>r \\<Longrightarrow> a \\<le> a';\n        \\<phi> = false\\<^sub>r \\<Longrightarrow> b \\<le> b';\n        \\<And>p. \\<phi> = prop\\<^sub>r(p) \\<Longrightarrow> c p \\<le> c' p;\n        \\<And>p. \\<phi> = nprop\\<^sub>r(p) \\<Longrightarrow> d p \\<le> d' p;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> and\\<^sub>r \\<nu> \\<Longrightarrow>\n           e \\<mu> \\<nu> \\<le> e' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> or\\<^sub>r \\<nu> \\<Longrightarrow>\n           f \\<mu> \\<nu> \\<le> f' \\<mu> \\<nu>;\n        \\<And>\\<mu>.\n           \\<phi> = X\\<^sub>r \\<mu> \\<Longrightarrow>\n           g \\<mu> \\<le> g' \\<mu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> U\\<^sub>r \\<nu> \\<Longrightarrow>\n           h \\<mu> \\<nu> \\<le> h' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> R\\<^sub>r \\<nu> \\<Longrightarrow>\n           i \\<mu> \\<nu> \\<le> i' \\<mu> \\<nu>;\n        \\<phi> = x51 and\\<^sub>r x52\\<rbrakk>\n       \\<Longrightarrow> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n                          | false\\<^sub>r \\<Rightarrow> b\n                          | prop\\<^sub>r(x) \\<Rightarrow> c x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> d x\n                          | x and\\<^sub>r xa \\<Rightarrow> e x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> f x xa\n                          | X\\<^sub>r x \\<Rightarrow> g x\n                          | x U\\<^sub>r xa \\<Rightarrow> h x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n                         \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a'\n                                | false\\<^sub>r \\<Rightarrow> b'\n                                | prop\\<^sub>r(x) \\<Rightarrow> c' x\n                                | nprop\\<^sub>r(x) \\<Rightarrow> d' x\n                                | x and\\<^sub>r xa \\<Rightarrow> e' x xa\n                                | x or\\<^sub>r xa \\<Rightarrow> f' x xa\n                                | X\\<^sub>r x \\<Rightarrow> g' x\n                                | x U\\<^sub>r xa \\<Rightarrow> h' x xa\n                                | x R\\<^sub>r xa \\<Rightarrow> i' x xa)\n 6. \\<And>x61 x62.\n       \\<lbrakk>\\<phi> = true\\<^sub>r \\<Longrightarrow> a \\<le> a';\n        \\<phi> = false\\<^sub>r \\<Longrightarrow> b \\<le> b';\n        \\<And>p. \\<phi> = prop\\<^sub>r(p) \\<Longrightarrow> c p \\<le> c' p;\n        \\<And>p. \\<phi> = nprop\\<^sub>r(p) \\<Longrightarrow> d p \\<le> d' p;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> and\\<^sub>r \\<nu> \\<Longrightarrow>\n           e \\<mu> \\<nu> \\<le> e' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> or\\<^sub>r \\<nu> \\<Longrightarrow>\n           f \\<mu> \\<nu> \\<le> f' \\<mu> \\<nu>;\n        \\<And>\\<mu>.\n           \\<phi> = X\\<^sub>r \\<mu> \\<Longrightarrow>\n           g \\<mu> \\<le> g' \\<mu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> U\\<^sub>r \\<nu> \\<Longrightarrow>\n           h \\<mu> \\<nu> \\<le> h' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> R\\<^sub>r \\<nu> \\<Longrightarrow>\n           i \\<mu> \\<nu> \\<le> i' \\<mu> \\<nu>;\n        \\<phi> = x61 or\\<^sub>r x62\\<rbrakk>\n       \\<Longrightarrow> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n                          | false\\<^sub>r \\<Rightarrow> b\n                          | prop\\<^sub>r(x) \\<Rightarrow> c x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> d x\n                          | x and\\<^sub>r xa \\<Rightarrow> e x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> f x xa\n                          | X\\<^sub>r x \\<Rightarrow> g x\n                          | x U\\<^sub>r xa \\<Rightarrow> h x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n                         \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a'\n                                | false\\<^sub>r \\<Rightarrow> b'\n                                | prop\\<^sub>r(x) \\<Rightarrow> c' x\n                                | nprop\\<^sub>r(x) \\<Rightarrow> d' x\n                                | x and\\<^sub>r xa \\<Rightarrow> e' x xa\n                                | x or\\<^sub>r xa \\<Rightarrow> f' x xa\n                                | X\\<^sub>r x \\<Rightarrow> g' x\n                                | x U\\<^sub>r xa \\<Rightarrow> h' x xa\n                                | x R\\<^sub>r xa \\<Rightarrow> i' x xa)\n 7. \\<And>x7.\n       \\<lbrakk>\\<phi> = true\\<^sub>r \\<Longrightarrow> a \\<le> a';\n        \\<phi> = false\\<^sub>r \\<Longrightarrow> b \\<le> b';\n        \\<And>p. \\<phi> = prop\\<^sub>r(p) \\<Longrightarrow> c p \\<le> c' p;\n        \\<And>p. \\<phi> = nprop\\<^sub>r(p) \\<Longrightarrow> d p \\<le> d' p;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> and\\<^sub>r \\<nu> \\<Longrightarrow>\n           e \\<mu> \\<nu> \\<le> e' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> or\\<^sub>r \\<nu> \\<Longrightarrow>\n           f \\<mu> \\<nu> \\<le> f' \\<mu> \\<nu>;\n        \\<And>\\<mu>.\n           \\<phi> = X\\<^sub>r \\<mu> \\<Longrightarrow>\n           g \\<mu> \\<le> g' \\<mu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> U\\<^sub>r \\<nu> \\<Longrightarrow>\n           h \\<mu> \\<nu> \\<le> h' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> R\\<^sub>r \\<nu> \\<Longrightarrow>\n           i \\<mu> \\<nu> \\<le> i' \\<mu> \\<nu>;\n        \\<phi> = X\\<^sub>r x7\\<rbrakk>\n       \\<Longrightarrow> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n                          | false\\<^sub>r \\<Rightarrow> b\n                          | prop\\<^sub>r(x) \\<Rightarrow> c x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> d x\n                          | x and\\<^sub>r xa \\<Rightarrow> e x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> f x xa\n                          | X\\<^sub>r x \\<Rightarrow> g x\n                          | x U\\<^sub>r xa \\<Rightarrow> h x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n                         \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a'\n                                | false\\<^sub>r \\<Rightarrow> b'\n                                | prop\\<^sub>r(x) \\<Rightarrow> c' x\n                                | nprop\\<^sub>r(x) \\<Rightarrow> d' x\n                                | x and\\<^sub>r xa \\<Rightarrow> e' x xa\n                                | x or\\<^sub>r xa \\<Rightarrow> f' x xa\n                                | X\\<^sub>r x \\<Rightarrow> g' x\n                                | x U\\<^sub>r xa \\<Rightarrow> h' x xa\n                                | x R\\<^sub>r xa \\<Rightarrow> i' x xa)\n 8. \\<And>x81 x82.\n       \\<lbrakk>\\<phi> = true\\<^sub>r \\<Longrightarrow> a \\<le> a';\n        \\<phi> = false\\<^sub>r \\<Longrightarrow> b \\<le> b';\n        \\<And>p. \\<phi> = prop\\<^sub>r(p) \\<Longrightarrow> c p \\<le> c' p;\n        \\<And>p. \\<phi> = nprop\\<^sub>r(p) \\<Longrightarrow> d p \\<le> d' p;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> and\\<^sub>r \\<nu> \\<Longrightarrow>\n           e \\<mu> \\<nu> \\<le> e' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> or\\<^sub>r \\<nu> \\<Longrightarrow>\n           f \\<mu> \\<nu> \\<le> f' \\<mu> \\<nu>;\n        \\<And>\\<mu>.\n           \\<phi> = X\\<^sub>r \\<mu> \\<Longrightarrow>\n           g \\<mu> \\<le> g' \\<mu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> U\\<^sub>r \\<nu> \\<Longrightarrow>\n           h \\<mu> \\<nu> \\<le> h' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> R\\<^sub>r \\<nu> \\<Longrightarrow>\n           i \\<mu> \\<nu> \\<le> i' \\<mu> \\<nu>;\n        \\<phi> = x81 U\\<^sub>r x82\\<rbrakk>\n       \\<Longrightarrow> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n                          | false\\<^sub>r \\<Rightarrow> b\n                          | prop\\<^sub>r(x) \\<Rightarrow> c x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> d x\n                          | x and\\<^sub>r xa \\<Rightarrow> e x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> f x xa\n                          | X\\<^sub>r x \\<Rightarrow> g x\n                          | x U\\<^sub>r xa \\<Rightarrow> h x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n                         \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a'\n                                | false\\<^sub>r \\<Rightarrow> b'\n                                | prop\\<^sub>r(x) \\<Rightarrow> c' x\n                                | nprop\\<^sub>r(x) \\<Rightarrow> d' x\n                                | x and\\<^sub>r xa \\<Rightarrow> e' x xa\n                                | x or\\<^sub>r xa \\<Rightarrow> f' x xa\n                                | X\\<^sub>r x \\<Rightarrow> g' x\n                                | x U\\<^sub>r xa \\<Rightarrow> h' x xa\n                                | x R\\<^sub>r xa \\<Rightarrow> i' x xa)\n 9. \\<And>x91 x92.\n       \\<lbrakk>\\<phi> = true\\<^sub>r \\<Longrightarrow> a \\<le> a';\n        \\<phi> = false\\<^sub>r \\<Longrightarrow> b \\<le> b';\n        \\<And>p. \\<phi> = prop\\<^sub>r(p) \\<Longrightarrow> c p \\<le> c' p;\n        \\<And>p. \\<phi> = nprop\\<^sub>r(p) \\<Longrightarrow> d p \\<le> d' p;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> and\\<^sub>r \\<nu> \\<Longrightarrow>\n           e \\<mu> \\<nu> \\<le> e' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> or\\<^sub>r \\<nu> \\<Longrightarrow>\n           f \\<mu> \\<nu> \\<le> f' \\<mu> \\<nu>;\n        \\<And>\\<mu>.\n           \\<phi> = X\\<^sub>r \\<mu> \\<Longrightarrow>\n           g \\<mu> \\<le> g' \\<mu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> U\\<^sub>r \\<nu> \\<Longrightarrow>\n           h \\<mu> \\<nu> \\<le> h' \\<mu> \\<nu>;\n        \\<And>\\<mu> \\<nu>.\n           \\<phi> = \\<mu> R\\<^sub>r \\<nu> \\<Longrightarrow>\n           i \\<mu> \\<nu> \\<le> i' \\<mu> \\<nu>;\n        \\<phi> = x91 R\\<^sub>r x92\\<rbrakk>\n       \\<Longrightarrow> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n                          | false\\<^sub>r \\<Rightarrow> b\n                          | prop\\<^sub>r(x) \\<Rightarrow> c x\n                          | nprop\\<^sub>r(x) \\<Rightarrow> d x\n                          | x and\\<^sub>r xa \\<Rightarrow> e x xa\n                          | x or\\<^sub>r xa \\<Rightarrow> f x xa\n                          | X\\<^sub>r x \\<Rightarrow> g x\n                          | x U\\<^sub>r xa \\<Rightarrow> h x xa\n                          | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n                         \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a'\n                                | false\\<^sub>r \\<Rightarrow> b'\n                                | prop\\<^sub>r(x) \\<Rightarrow> c' x\n                                | nprop\\<^sub>r(x) \\<Rightarrow> d' x\n                                | x and\\<^sub>r xa \\<Rightarrow> e' x xa\n                                | x or\\<^sub>r xa \\<Rightarrow> f' x xa\n                                | X\\<^sub>r x \\<Rightarrow> g' x\n                                | x U\\<^sub>r xa \\<Rightarrow> h' x xa\n                                | x R\\<^sub>r xa \\<Rightarrow> i' x xa)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec ltlr_eq where\n  \"ltlr_eq eq True_ltlr f \\<longleftrightarrow> (case f of True_ltlr \\<Rightarrow> True | _ \\<Rightarrow> False)\"\n| \"ltlr_eq eq False_ltlr f \\<longleftrightarrow> (case f of False_ltlr \\<Rightarrow> True | _ \\<Rightarrow> False)\"\n| \"ltlr_eq eq (Prop_ltlr p) f \\<longleftrightarrow> (case f of Prop_ltlr p' \\<Rightarrow> eq p p' | _ \\<Rightarrow> False)\"\n| \"ltlr_eq eq (Nprop_ltlr p) f \\<longleftrightarrow> (case f of Nprop_ltlr p' \\<Rightarrow> eq p p' | _ \\<Rightarrow> False)\"\n| \"ltlr_eq eq (And_ltlr \\<mu> \\<nu>) f \n  \\<longleftrightarrow> (case f of And_ltlr \\<mu>' \\<nu>' \\<Rightarrow> ltlr_eq eq \\<mu> \\<mu>' \\<and> ltlr_eq eq \\<nu> \\<nu>' | _ \\<Rightarrow> False)\"\n| \"ltlr_eq eq (Or_ltlr \\<mu> \\<nu>) f \n  \\<longleftrightarrow> (case f of Or_ltlr \\<mu>' \\<nu>' \\<Rightarrow> ltlr_eq eq \\<mu> \\<mu>' \\<and> ltlr_eq eq \\<nu> \\<nu>' | _ \\<Rightarrow> False)\"\n| \"ltlr_eq eq (Next_ltlr \\<phi>) f \n  \\<longleftrightarrow> (case f of Next_ltlr \\<phi>' \\<Rightarrow> ltlr_eq eq \\<phi> \\<phi>' | _ \\<Rightarrow> False)\"\n| \"ltlr_eq eq (Until_ltlr \\<mu> \\<nu>) f \n  \\<longleftrightarrow> (case f of Until_ltlr \\<mu>' \\<nu>' \\<Rightarrow> ltlr_eq eq \\<mu> \\<mu>' \\<and> ltlr_eq eq \\<nu> \\<nu>' | _ \\<Rightarrow> False)\"\n| \"ltlr_eq eq (Release_ltlr \\<mu> \\<nu>) f \n  \\<longleftrightarrow> (case f of \n    Release_ltlr \\<mu>' \\<nu>' \\<Rightarrow> ltlr_eq eq \\<mu> \\<mu>' \\<and> ltlr_eq eq \\<nu> \\<nu>' \n  | _ \\<Rightarrow> False)\""], ["", "lemma ltlr_eq_autoref[autoref_rules]:\n  assumes EQP: \"(eq,(=)) \\<in> R \\<rightarrow> R \\<rightarrow> bool_rel\"\n  shows \"(ltlr_eq eq, (=)) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ltlr_eq eq, (=))\n    \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> bool_rel", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (aa, a'a) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq a aa, a' = a'a) \\<in> bool_rel", "fix \\<mu>' \\<mu> \\<nu>' \\<nu>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (aa, a'a) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq a aa, a' = a'a) \\<in> bool_rel", "assume \"(\\<mu>',\\<mu>)\\<in>\\<langle>R\\<rangle>ltlr_rel\" and \"(\\<nu>',\\<nu>)\\<in>\\<langle>R\\<rangle>ltlr_rel\""], ["proof (state)\nthis:\n  (\\<mu>', \\<mu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\n  (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (aa, a'a) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq a aa, a' = a'a) \\<in> bool_rel", "then"], ["proof (chain)\npicking this:\n  (\\<mu>', \\<mu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\n  (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel", "show \"(ltlr_eq eq \\<mu>' \\<nu>', \\<mu>=\\<nu>)\\<in>bool_rel\""], ["proof (prove)\nusing this:\n  (\\<mu>', \\<mu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\n  (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\n\ngoal (1 subgoal):\n 1. (ltlr_eq eq \\<mu>' \\<nu>', \\<mu> = \\<nu>) \\<in> bool_rel", "apply (induction arbitrary: \\<nu>' \\<nu>)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>\\<nu>' \\<nu>.\n       (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n       (ltlr_eq eq true\\<^sub>r \\<nu>', true\\<^sub>r = \\<nu>) \\<in> bool_rel\n 2. \\<And>\\<nu>' \\<nu>.\n       (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n       (ltlr_eq eq false\\<^sub>r \\<nu>', false\\<^sub>r = \\<nu>)\n       \\<in> bool_rel\n 3. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> R;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq prop\\<^sub>r(a) \\<nu>',\n                          prop\\<^sub>r(a') = \\<nu>)\n                         \\<in> bool_rel\n 4. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> R;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq nprop\\<^sub>r(a) \\<nu>',\n                          nprop\\<^sub>r(a') = \\<nu>)\n                         \\<in> bool_rel\n 5. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a and\\<^sub>r b) \\<nu>',\n                          a' and\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 6. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a or\\<^sub>r b) \\<nu>',\n                          a' or\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 7. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (X\\<^sub>r a) \\<nu>',\n                          X\\<^sub>r a' = \\<nu>)\n                         \\<in> bool_rel\n 8. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a U\\<^sub>r b) \\<nu>',\n                          a' U\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 9. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (erule ltlr_rel_cases, simp_all) []"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>\\<nu>' \\<nu>.\n       (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n       (ltlr_eq eq false\\<^sub>r \\<nu>', false\\<^sub>r = \\<nu>)\n       \\<in> bool_rel\n 2. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> R;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq prop\\<^sub>r(a) \\<nu>',\n                          prop\\<^sub>r(a') = \\<nu>)\n                         \\<in> bool_rel\n 3. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> R;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq nprop\\<^sub>r(a) \\<nu>',\n                          nprop\\<^sub>r(a') = \\<nu>)\n                         \\<in> bool_rel\n 4. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a and\\<^sub>r b) \\<nu>',\n                          a' and\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 5. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a or\\<^sub>r b) \\<nu>',\n                          a' or\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 6. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (X\\<^sub>r a) \\<nu>',\n                          X\\<^sub>r a' = \\<nu>)\n                         \\<in> bool_rel\n 7. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a U\\<^sub>r b) \\<nu>',\n                          a' U\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 8. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (erule ltlr_rel_cases, simp_all) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> R;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq prop\\<^sub>r(a) \\<nu>',\n                          prop\\<^sub>r(a') = \\<nu>)\n                         \\<in> bool_rel\n 2. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> R;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq nprop\\<^sub>r(a) \\<nu>',\n                          nprop\\<^sub>r(a') = \\<nu>)\n                         \\<in> bool_rel\n 3. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a and\\<^sub>r b) \\<nu>',\n                          a' and\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 4. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a or\\<^sub>r b) \\<nu>',\n                          a' or\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 5. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (X\\<^sub>r a) \\<nu>',\n                          X\\<^sub>r a' = \\<nu>)\n                         \\<in> bool_rel\n 6. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a U\\<^sub>r b) \\<nu>',\n                          a' U\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 7. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (erule ltlr_rel_cases, \n      simp_all add: EQP[THEN fun_relD, THEN fun_relD, THEN IdD]) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> R;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq nprop\\<^sub>r(a) \\<nu>',\n                          nprop\\<^sub>r(a') = \\<nu>)\n                         \\<in> bool_rel\n 2. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a and\\<^sub>r b) \\<nu>',\n                          a' and\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 3. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a or\\<^sub>r b) \\<nu>',\n                          a' or\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 4. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (X\\<^sub>r a) \\<nu>',\n                          X\\<^sub>r a' = \\<nu>)\n                         \\<in> bool_rel\n 5. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a U\\<^sub>r b) \\<nu>',\n                          a' U\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 6. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (erule ltlr_rel_cases, \n      simp_all add: EQP[THEN fun_relD, THEN fun_relD, THEN IdD]) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a and\\<^sub>r b) \\<nu>',\n                          a' and\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 2. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a or\\<^sub>r b) \\<nu>',\n                          a' or\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 3. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (X\\<^sub>r a) \\<nu>',\n                          X\\<^sub>r a' = \\<nu>)\n                         \\<in> bool_rel\n 4. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a U\\<^sub>r b) \\<nu>',\n                          a' U\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 5. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (rotate_tac -1)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a and\\<^sub>r b) \\<nu>',\n                          a' and\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 2. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a or\\<^sub>r b) \\<nu>',\n                          a' or\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 3. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (X\\<^sub>r a) \\<nu>',\n                          X\\<^sub>r a' = \\<nu>)\n                         \\<in> bool_rel\n 4. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a U\\<^sub>r b) \\<nu>',\n                          a' U\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 5. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (erule ltlr_rel_cases, simp_all) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a or\\<^sub>r b) \\<nu>',\n                          a' or\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 2. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (X\\<^sub>r a) \\<nu>',\n                          X\\<^sub>r a' = \\<nu>)\n                         \\<in> bool_rel\n 3. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a U\\<^sub>r b) \\<nu>',\n                          a' U\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 4. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (rotate_tac -1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a or\\<^sub>r b) \\<nu>',\n                          a' or\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 2. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (X\\<^sub>r a) \\<nu>',\n                          X\\<^sub>r a' = \\<nu>)\n                         \\<in> bool_rel\n 3. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a U\\<^sub>r b) \\<nu>',\n                          a' U\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 4. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (erule ltlr_rel_cases, simp_all) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (X\\<^sub>r a) \\<nu>',\n                          X\\<^sub>r a' = \\<nu>)\n                         \\<in> bool_rel\n 2. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a U\\<^sub>r b) \\<nu>',\n                          a' U\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 3. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (rotate_tac -1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' \\<nu>' \\<nu>.\n       \\<lbrakk>(\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (X\\<^sub>r a) \\<nu>',\n                          X\\<^sub>r a' = \\<nu>)\n                         \\<in> bool_rel\n 2. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a U\\<^sub>r b) \\<nu>',\n                          a' U\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 3. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (erule ltlr_rel_cases, simp_all) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a U\\<^sub>r b) \\<nu>',\n                          a' U\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 2. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a U\\<^sub>r b) \\<nu>',\n                          a' U\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel\n 2. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (erule ltlr_rel_cases, simp_all) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel;\n        (\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' b b' \\<nu>' \\<nu>.\n       \\<lbrakk>(\\<nu>', \\<nu>) \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        (a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq a \\<nu>', a' = \\<nu>) \\<in> bool_rel;\n        (b, b') \\<in> \\<langle>R\\<rangle>ltlr_rel;\n        \\<And>\\<nu>' \\<nu>.\n           (\\<nu>', \\<nu>)\n           \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n           (ltlr_eq eq b \\<nu>', b' = \\<nu>) \\<in> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (ltlr_eq eq (a R\\<^sub>r b) \\<nu>',\n                          a' R\\<^sub>r b' = \\<nu>)\n                         \\<in> bool_rel", "apply (erule ltlr_rel_cases, simp_all) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (ltlr_eq eq \\<mu>' \\<nu>', \\<mu> = \\<nu>) \\<in> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ltlr_dflt_cmp[autoref_rules_raw]: \n  assumes \"PREFER_id R\"\n  shows\n  \"(dflt_cmp (\\<le>) (<), dflt_cmp (\\<le>) (<)) \n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> comp_res_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dflt_cmp (\\<le>) (<), dflt_cmp (\\<le>) (<))\n    \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> comp_res_rel", "using assms"], ["proof (prove)\nusing this:\n  PREFER_id R\n\ngoal (1 subgoal):\n 1. (dflt_cmp (\\<le>) (<), dflt_cmp (\\<le>) (<))\n    \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> comp_res_rel", "by simp"], ["", "type_synonym\n  node_name_impl = node_name"], ["", "abbreviation (input) \"node_name_rel \\<equiv> Id :: (node_name_impl\\<times>node_name) set\""], ["", "lemma case_ltlr_gtransfer:\n  assumes\n  \"\\<gamma> ai \\<le> a\"\n  \"\\<gamma> bi \\<le> b\"\n  \"\\<And>a. \\<gamma> (ci a) \\<le> c a\"\n  \"\\<And>a. \\<gamma> (di a) \\<le> d a\"\n  \"\\<And>ltlr1 ltlr2. \\<gamma> (ei ltlr1 ltlr2) \\<le> e ltlr1 ltlr2\"\n  \"\\<And>ltlr1 ltlr2. \\<gamma> (fi ltlr1 ltlr2) \\<le> f ltlr1 ltlr2\"\n  \"\\<And>ltlr. \\<gamma> (gi ltlr) \\<le> g ltlr\"\n  \"\\<And>ltlr1 ltlr2. \\<gamma> (hi ltlr1 ltlr2) \\<le> h ltlr1 ltlr2\"\n  \"\\<And>ltlr1 ltlr2. \\<gamma> (iiv ltlr1 ltlr2) \\<le> i ltlr1 ltlr2\"\n  shows \"\\<gamma> (case_ltlr ai bi ci di ei fi gi hi iiv \\<phi>) \n    \\<le> (case_ltlr a b c d e f g h i \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<gamma>\n     (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n      | false\\<^sub>r \\<Rightarrow> bi | prop\\<^sub>r(x) \\<Rightarrow> ci x\n      | nprop\\<^sub>r(x) \\<Rightarrow> di x\n      | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n      | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n      | X\\<^sub>r x \\<Rightarrow> gi x\n      | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n      | x R\\<^sub>r xa \\<Rightarrow> iiv x xa)\n    \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n           | false\\<^sub>r \\<Rightarrow> b\n           | prop\\<^sub>r(x) \\<Rightarrow> c x\n           | nprop\\<^sub>r(x) \\<Rightarrow> d x\n           | x and\\<^sub>r xa \\<Rightarrow> e x xa\n           | x or\\<^sub>r xa \\<Rightarrow> f x xa\n           | X\\<^sub>r x \\<Rightarrow> g x\n           | x U\\<^sub>r xa \\<Rightarrow> h x xa\n           | x R\\<^sub>r xa \\<Rightarrow> i x xa)", "apply (cases \\<phi>)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<phi> = true\\<^sub>r \\<Longrightarrow>\n    \\<gamma>\n     (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n      | false\\<^sub>r \\<Rightarrow> bi | prop\\<^sub>r(x) \\<Rightarrow> ci x\n      | nprop\\<^sub>r(x) \\<Rightarrow> di x\n      | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n      | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n      | X\\<^sub>r x \\<Rightarrow> gi x\n      | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n      | x R\\<^sub>r xa \\<Rightarrow> iiv x xa)\n    \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n           | false\\<^sub>r \\<Rightarrow> b\n           | prop\\<^sub>r(x) \\<Rightarrow> c x\n           | nprop\\<^sub>r(x) \\<Rightarrow> d x\n           | x and\\<^sub>r xa \\<Rightarrow> e x xa\n           | x or\\<^sub>r xa \\<Rightarrow> f x xa\n           | X\\<^sub>r x \\<Rightarrow> g x\n           | x U\\<^sub>r xa \\<Rightarrow> h x xa\n           | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n 2. \\<phi> = false\\<^sub>r \\<Longrightarrow>\n    \\<gamma>\n     (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n      | false\\<^sub>r \\<Rightarrow> bi | prop\\<^sub>r(x) \\<Rightarrow> ci x\n      | nprop\\<^sub>r(x) \\<Rightarrow> di x\n      | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n      | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n      | X\\<^sub>r x \\<Rightarrow> gi x\n      | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n      | x R\\<^sub>r xa \\<Rightarrow> iiv x xa)\n    \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n           | false\\<^sub>r \\<Rightarrow> b\n           | prop\\<^sub>r(x) \\<Rightarrow> c x\n           | nprop\\<^sub>r(x) \\<Rightarrow> d x\n           | x and\\<^sub>r xa \\<Rightarrow> e x xa\n           | x or\\<^sub>r xa \\<Rightarrow> f x xa\n           | X\\<^sub>r x \\<Rightarrow> g x\n           | x U\\<^sub>r xa \\<Rightarrow> h x xa\n           | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n 3. \\<And>x3.\n       \\<phi> = prop\\<^sub>r(x3) \\<Longrightarrow>\n       \\<gamma>\n        (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n         | false\\<^sub>r \\<Rightarrow> bi\n         | prop\\<^sub>r(x) \\<Rightarrow> ci x\n         | nprop\\<^sub>r(x) \\<Rightarrow> di x\n         | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n         | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n         | X\\<^sub>r x \\<Rightarrow> gi x\n         | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n         | x R\\<^sub>r xa \\<Rightarrow> iiv x xa)\n       \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n              | false\\<^sub>r \\<Rightarrow> b\n              | prop\\<^sub>r(x) \\<Rightarrow> c x\n              | nprop\\<^sub>r(x) \\<Rightarrow> d x\n              | x and\\<^sub>r xa \\<Rightarrow> e x xa\n              | x or\\<^sub>r xa \\<Rightarrow> f x xa\n              | X\\<^sub>r x \\<Rightarrow> g x\n              | x U\\<^sub>r xa \\<Rightarrow> h x xa\n              | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n 4. \\<And>x4.\n       \\<phi> = nprop\\<^sub>r(x4) \\<Longrightarrow>\n       \\<gamma>\n        (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n         | false\\<^sub>r \\<Rightarrow> bi\n         | prop\\<^sub>r(x) \\<Rightarrow> ci x\n         | nprop\\<^sub>r(x) \\<Rightarrow> di x\n         | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n         | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n         | X\\<^sub>r x \\<Rightarrow> gi x\n         | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n         | x R\\<^sub>r xa \\<Rightarrow> iiv x xa)\n       \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n              | false\\<^sub>r \\<Rightarrow> b\n              | prop\\<^sub>r(x) \\<Rightarrow> c x\n              | nprop\\<^sub>r(x) \\<Rightarrow> d x\n              | x and\\<^sub>r xa \\<Rightarrow> e x xa\n              | x or\\<^sub>r xa \\<Rightarrow> f x xa\n              | X\\<^sub>r x \\<Rightarrow> g x\n              | x U\\<^sub>r xa \\<Rightarrow> h x xa\n              | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n 5. \\<And>x51 x52.\n       \\<phi> = x51 and\\<^sub>r x52 \\<Longrightarrow>\n       \\<gamma>\n        (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n         | false\\<^sub>r \\<Rightarrow> bi\n         | prop\\<^sub>r(x) \\<Rightarrow> ci x\n         | nprop\\<^sub>r(x) \\<Rightarrow> di x\n         | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n         | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n         | X\\<^sub>r x \\<Rightarrow> gi x\n         | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n         | x R\\<^sub>r xa \\<Rightarrow> iiv x xa)\n       \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n              | false\\<^sub>r \\<Rightarrow> b\n              | prop\\<^sub>r(x) \\<Rightarrow> c x\n              | nprop\\<^sub>r(x) \\<Rightarrow> d x\n              | x and\\<^sub>r xa \\<Rightarrow> e x xa\n              | x or\\<^sub>r xa \\<Rightarrow> f x xa\n              | X\\<^sub>r x \\<Rightarrow> g x\n              | x U\\<^sub>r xa \\<Rightarrow> h x xa\n              | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n 6. \\<And>x61 x62.\n       \\<phi> = x61 or\\<^sub>r x62 \\<Longrightarrow>\n       \\<gamma>\n        (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n         | false\\<^sub>r \\<Rightarrow> bi\n         | prop\\<^sub>r(x) \\<Rightarrow> ci x\n         | nprop\\<^sub>r(x) \\<Rightarrow> di x\n         | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n         | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n         | X\\<^sub>r x \\<Rightarrow> gi x\n         | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n         | x R\\<^sub>r xa \\<Rightarrow> iiv x xa)\n       \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n              | false\\<^sub>r \\<Rightarrow> b\n              | prop\\<^sub>r(x) \\<Rightarrow> c x\n              | nprop\\<^sub>r(x) \\<Rightarrow> d x\n              | x and\\<^sub>r xa \\<Rightarrow> e x xa\n              | x or\\<^sub>r xa \\<Rightarrow> f x xa\n              | X\\<^sub>r x \\<Rightarrow> g x\n              | x U\\<^sub>r xa \\<Rightarrow> h x xa\n              | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n 7. \\<And>x7.\n       \\<phi> = X\\<^sub>r x7 \\<Longrightarrow>\n       \\<gamma>\n        (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n         | false\\<^sub>r \\<Rightarrow> bi\n         | prop\\<^sub>r(x) \\<Rightarrow> ci x\n         | nprop\\<^sub>r(x) \\<Rightarrow> di x\n         | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n         | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n         | X\\<^sub>r x \\<Rightarrow> gi x\n         | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n         | x R\\<^sub>r xa \\<Rightarrow> iiv x xa)\n       \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n              | false\\<^sub>r \\<Rightarrow> b\n              | prop\\<^sub>r(x) \\<Rightarrow> c x\n              | nprop\\<^sub>r(x) \\<Rightarrow> d x\n              | x and\\<^sub>r xa \\<Rightarrow> e x xa\n              | x or\\<^sub>r xa \\<Rightarrow> f x xa\n              | X\\<^sub>r x \\<Rightarrow> g x\n              | x U\\<^sub>r xa \\<Rightarrow> h x xa\n              | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n 8. \\<And>x81 x82.\n       \\<phi> = x81 U\\<^sub>r x82 \\<Longrightarrow>\n       \\<gamma>\n        (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n         | false\\<^sub>r \\<Rightarrow> bi\n         | prop\\<^sub>r(x) \\<Rightarrow> ci x\n         | nprop\\<^sub>r(x) \\<Rightarrow> di x\n         | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n         | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n         | X\\<^sub>r x \\<Rightarrow> gi x\n         | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n         | x R\\<^sub>r xa \\<Rightarrow> iiv x xa)\n       \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n              | false\\<^sub>r \\<Rightarrow> b\n              | prop\\<^sub>r(x) \\<Rightarrow> c x\n              | nprop\\<^sub>r(x) \\<Rightarrow> d x\n              | x and\\<^sub>r xa \\<Rightarrow> e x xa\n              | x or\\<^sub>r xa \\<Rightarrow> f x xa\n              | X\\<^sub>r x \\<Rightarrow> g x\n              | x U\\<^sub>r xa \\<Rightarrow> h x xa\n              | x R\\<^sub>r xa \\<Rightarrow> i x xa)\n 9. \\<And>x91 x92.\n       \\<phi> = x91 R\\<^sub>r x92 \\<Longrightarrow>\n       \\<gamma>\n        (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n         | false\\<^sub>r \\<Rightarrow> bi\n         | prop\\<^sub>r(x) \\<Rightarrow> ci x\n         | nprop\\<^sub>r(x) \\<Rightarrow> di x\n         | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n         | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n         | X\\<^sub>r x \\<Rightarrow> gi x\n         | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n         | x R\\<^sub>r xa \\<Rightarrow> iiv x xa)\n       \\<le> (case \\<phi> of true\\<^sub>r \\<Rightarrow> a\n              | false\\<^sub>r \\<Rightarrow> b\n              | prop\\<^sub>r(x) \\<Rightarrow> c x\n              | nprop\\<^sub>r(x) \\<Rightarrow> d x\n              | x and\\<^sub>r xa \\<Rightarrow> e x xa\n              | x or\\<^sub>r xa \\<Rightarrow> f x xa\n              | X\\<^sub>r x \\<Rightarrow> g x\n              | x U\\<^sub>r xa \\<Rightarrow> h x xa\n              | x R\\<^sub>r xa \\<Rightarrow> i x xa)", "apply (auto intro: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [refine_transfer] \n  = case_ltlr_gtransfer[where \\<gamma>=nres_of] case_ltlr_gtransfer[where \\<gamma>=RETURN]"], ["", "lemma [refine_transfer]:\n  assumes \n  \"ai \\<noteq> dSUCCEED\"\n  \"bi \\<noteq> dSUCCEED\"\n  \"\\<And>a. ci a \\<noteq> dSUCCEED\"\n  \"\\<And>a. di a \\<noteq> dSUCCEED\"\n  \"\\<And>ltlr1 ltlr2. ei ltlr1 ltlr2 \\<noteq> dSUCCEED\"\n  \"\\<And>ltlr1 ltlr2. fi ltlr1 ltlr2 \\<noteq> dSUCCEED\"\n  \"\\<And>ltlr. gi ltlr \\<noteq> dSUCCEED\"\n  \"\\<And>ltlr1 ltlr2. hi ltlr1 ltlr2 \\<noteq> dSUCCEED\"\n  \"\\<And>ltlr1 ltlr2. iiv ltlr1 ltlr2 \\<noteq> dSUCCEED\"\n  shows \"case_ltlr ai bi ci di ei fi gi hi iiv \\<phi> \\<noteq> dSUCCEED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n     | false\\<^sub>r \\<Rightarrow> bi | prop\\<^sub>r(x) \\<Rightarrow> ci x\n     | nprop\\<^sub>r(x) \\<Rightarrow> di x\n     | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n     | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n     | X\\<^sub>r x \\<Rightarrow> gi x | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n     | x R\\<^sub>r xa \\<Rightarrow> iiv x xa) \\<noteq>\n    dSUCCEED", "apply (cases \\<phi>)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<phi> = true\\<^sub>r \\<Longrightarrow>\n    (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n     | false\\<^sub>r \\<Rightarrow> bi | prop\\<^sub>r(x) \\<Rightarrow> ci x\n     | nprop\\<^sub>r(x) \\<Rightarrow> di x\n     | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n     | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n     | X\\<^sub>r x \\<Rightarrow> gi x | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n     | x R\\<^sub>r xa \\<Rightarrow> iiv x xa) \\<noteq>\n    dSUCCEED\n 2. \\<phi> = false\\<^sub>r \\<Longrightarrow>\n    (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n     | false\\<^sub>r \\<Rightarrow> bi | prop\\<^sub>r(x) \\<Rightarrow> ci x\n     | nprop\\<^sub>r(x) \\<Rightarrow> di x\n     | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n     | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n     | X\\<^sub>r x \\<Rightarrow> gi x | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n     | x R\\<^sub>r xa \\<Rightarrow> iiv x xa) \\<noteq>\n    dSUCCEED\n 3. \\<And>x3.\n       \\<phi> = prop\\<^sub>r(x3) \\<Longrightarrow>\n       (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n        | false\\<^sub>r \\<Rightarrow> bi\n        | prop\\<^sub>r(x) \\<Rightarrow> ci x\n        | nprop\\<^sub>r(x) \\<Rightarrow> di x\n        | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n        | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n        | X\\<^sub>r x \\<Rightarrow> gi x\n        | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n        | x R\\<^sub>r xa \\<Rightarrow> iiv x xa) \\<noteq>\n       dSUCCEED\n 4. \\<And>x4.\n       \\<phi> = nprop\\<^sub>r(x4) \\<Longrightarrow>\n       (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n        | false\\<^sub>r \\<Rightarrow> bi\n        | prop\\<^sub>r(x) \\<Rightarrow> ci x\n        | nprop\\<^sub>r(x) \\<Rightarrow> di x\n        | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n        | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n        | X\\<^sub>r x \\<Rightarrow> gi x\n        | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n        | x R\\<^sub>r xa \\<Rightarrow> iiv x xa) \\<noteq>\n       dSUCCEED\n 5. \\<And>x51 x52.\n       \\<phi> = x51 and\\<^sub>r x52 \\<Longrightarrow>\n       (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n        | false\\<^sub>r \\<Rightarrow> bi\n        | prop\\<^sub>r(x) \\<Rightarrow> ci x\n        | nprop\\<^sub>r(x) \\<Rightarrow> di x\n        | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n        | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n        | X\\<^sub>r x \\<Rightarrow> gi x\n        | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n        | x R\\<^sub>r xa \\<Rightarrow> iiv x xa) \\<noteq>\n       dSUCCEED\n 6. \\<And>x61 x62.\n       \\<phi> = x61 or\\<^sub>r x62 \\<Longrightarrow>\n       (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n        | false\\<^sub>r \\<Rightarrow> bi\n        | prop\\<^sub>r(x) \\<Rightarrow> ci x\n        | nprop\\<^sub>r(x) \\<Rightarrow> di x\n        | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n        | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n        | X\\<^sub>r x \\<Rightarrow> gi x\n        | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n        | x R\\<^sub>r xa \\<Rightarrow> iiv x xa) \\<noteq>\n       dSUCCEED\n 7. \\<And>x7.\n       \\<phi> = X\\<^sub>r x7 \\<Longrightarrow>\n       (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n        | false\\<^sub>r \\<Rightarrow> bi\n        | prop\\<^sub>r(x) \\<Rightarrow> ci x\n        | nprop\\<^sub>r(x) \\<Rightarrow> di x\n        | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n        | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n        | X\\<^sub>r x \\<Rightarrow> gi x\n        | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n        | x R\\<^sub>r xa \\<Rightarrow> iiv x xa) \\<noteq>\n       dSUCCEED\n 8. \\<And>x81 x82.\n       \\<phi> = x81 U\\<^sub>r x82 \\<Longrightarrow>\n       (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n        | false\\<^sub>r \\<Rightarrow> bi\n        | prop\\<^sub>r(x) \\<Rightarrow> ci x\n        | nprop\\<^sub>r(x) \\<Rightarrow> di x\n        | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n        | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n        | X\\<^sub>r x \\<Rightarrow> gi x\n        | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n        | x R\\<^sub>r xa \\<Rightarrow> iiv x xa) \\<noteq>\n       dSUCCEED\n 9. \\<And>x91 x92.\n       \\<phi> = x91 R\\<^sub>r x92 \\<Longrightarrow>\n       (case \\<phi> of true\\<^sub>r \\<Rightarrow> ai\n        | false\\<^sub>r \\<Rightarrow> bi\n        | prop\\<^sub>r(x) \\<Rightarrow> ci x\n        | nprop\\<^sub>r(x) \\<Rightarrow> di x\n        | x and\\<^sub>r xa \\<Rightarrow> ei x xa\n        | x or\\<^sub>r xa \\<Rightarrow> fi x xa\n        | X\\<^sub>r x \\<Rightarrow> gi x\n        | x U\\<^sub>r xa \\<Rightarrow> hi x xa\n        | x R\\<^sub>r xa \\<Rightarrow> iiv x xa) \\<noteq>\n       dSUCCEED", "apply (simp_all add: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Nodes\\<close>"], ["", "record 'a node_impl =\n  name_impl   :: node_name_impl\n  incoming_impl :: \"(node_name_impl,unit) RBT_Impl.rbt\"\n  new_impl :: \"'a frml list\"\n  old_impl :: \"'a frml list\"\n  next_impl :: \"'a frml list\""], ["", "definition node_rel where node_rel_def_internal: \"node_rel Re R \\<equiv> {( \n  \\<lparr> name_impl = namei, \n    incoming_impl = inci, \n    new_impl = newi,\n    old_impl = oldi,\n    next_impl = nexti,\n    \\<dots> = morei\n  \\<rparr>, \n  \\<lparr> name = name,\n    incoming = inc,\n    new=new,\n    old=old,\n    next = next,\n    \\<dots> = more\n  \\<rparr> ) | namei name inci inc newi new oldi old nexti next morei more. \n    (namei,name)\\<in>node_name_rel \n  \\<and> (inci,inc)\\<in>\\<langle>node_name_rel\\<rangle>dflt_rs_rel \n  \\<and> (newi,new)\\<in>\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\n  \\<and> (oldi,old)\\<in>\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\n  \\<and> (nexti,next)\\<in>\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\n  \\<and> (morei,more)\\<in>Re\n  }\""], ["", "lemma node_rel_def: \"\\<langle>Re,R\\<rangle>node_rel = {( \n  \\<lparr> name_impl = namei, \n    incoming_impl = inci, \n    new_impl = newi,\n    old_impl = oldi,\n    next_impl = nexti,\n    \\<dots> = morei\n  \\<rparr>, \n  \\<lparr> name = name,\n    incoming = inc,\n    new=new,\n    old=old,\n    next = next,\n    \\<dots> = more\n  \\<rparr> ) | namei name inci inc newi new oldi old nexti next morei more. \n    (namei,name)\\<in>node_name_rel \n  \\<and> (inci,inc)\\<in>\\<langle>node_name_rel\\<rangle>dflt_rs_rel  \n  \\<and> (newi,new)\\<in>\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\n  \\<and> (oldi,old)\\<in>\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\n  \\<and> (nexti,next)\\<in>\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\n  \\<and> (morei,more)\\<in>Re\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Re, R\\<rangle>node_rel =\n    {(\\<lparr>name_impl = namei, incoming_impl = inci, new_impl = newi,\n         old_impl = oldi, next_impl = nexti, \\<dots> = morei\\<rparr>,\n      \\<lparr>name = name, incoming = inc, new = new, old = old,\n         next = next, \\<dots> = more\\<rparr>) |\n     namei name inci inc newi new oldi old nexti next morei more.\n     (namei, name) \\<in> nat_rel \\<and>\n     (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n     (newi, new)\n     \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n     (oldi, old)\n     \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n     (nexti, next)\n     \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n     (morei, more) \\<in> Re}", "by (simp add: node_rel_def_internal relAPP_def)"], ["", "lemma node_rel_sv[relator_props]: \n  \"single_valued Re \\<Longrightarrow> single_valued R \\<Longrightarrow> single_valued (\\<langle>Re,R\\<rangle>node_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Re; single_valued R\\<rbrakk>\n    \\<Longrightarrow> single_valued (\\<langle>Re, R\\<rangle>node_rel)", "apply (rule single_valuedI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued Re; single_valued R;\n        (x, y) \\<in> \\<langle>Re, R\\<rangle>node_rel;\n        (x, z) \\<in> \\<langle>Re, R\\<rangle>node_rel\\<rbrakk>\n       \\<Longrightarrow> y = z", "apply (simp add: node_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued Re; single_valued R;\n        \\<exists>namei inci inc newi new oldi old nexti next morei.\n           x =\n           \\<lparr>name_impl = namei, incoming_impl = inci, new_impl = newi,\n              old_impl = oldi, next_impl = nexti,\n              \\<dots> = morei\\<rparr> \\<and>\n           (\\<exists>more.\n               y =\n               \\<lparr>name = namei, incoming = inc, new = new, old = old,\n                  next = next, \\<dots> = more\\<rparr> \\<and>\n               (inci, inc)\n               \\<in> \\<langle>nat_rel\\<rangle>map2set_rel\n         (rbt_map_rel (<)) \\<and>\n               (newi, new)\n               \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n               (oldi, old)\n               \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n               (nexti, next)\n               \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n               (morei, more) \\<in> Re);\n        \\<exists>namei inci inc newi new oldi old nexti next morei.\n           x =\n           \\<lparr>name_impl = namei, incoming_impl = inci, new_impl = newi,\n              old_impl = oldi, next_impl = nexti,\n              \\<dots> = morei\\<rparr> \\<and>\n           (\\<exists>more.\n               z =\n               \\<lparr>name = namei, incoming = inc, new = new, old = old,\n                  next = next, \\<dots> = more\\<rparr> \\<and>\n               (inci, inc)\n               \\<in> \\<langle>nat_rel\\<rangle>map2set_rel\n         (rbt_map_rel (<)) \\<and>\n               (newi, new)\n               \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n               (oldi, old)\n               \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n               (nexti, next)\n               \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n               (morei, more) \\<in> Re)\\<rbrakk>\n       \\<Longrightarrow> y = z", "apply (auto \n    dest: single_valuedD lss.rel_sv[OF ltlr_rel_sv] map2set_rel_sv[OF ahm_rel_sv] \n    dest: single_valuedD[\n      OF map2set_rel_sv[OF rbt_map_rel_sv[OF single_valued_Id single_valued_Id]]\n    ])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "consts i_node :: \"interface \\<Rightarrow> interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of node_rel i_node]"], ["", "lemma [autoref_rules]: \"(node_impl_ext, node_ext) \\<in> \n  node_name_rel \n  \\<rightarrow> \\<langle>node_name_rel\\<rangle>dflt_rs_rel \n  \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \n  \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \n  \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \n  \\<rightarrow> Re \n  \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (node_impl_ext, node_ext)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow>\n          Re \\<rightarrow> \\<langle>Re, R\\<rangle>node_rel", "unfolding node_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (node_impl_ext, node_ext)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow>\n          Re \\<rightarrow>\n          {(\\<lparr>name_impl = namei, incoming_impl = inci,\n               new_impl = newi, old_impl = oldi, next_impl = nexti,\n               \\<dots> = morei\\<rparr>,\n            \\<lparr>name = name, incoming = inc, new = new, old = old,\n               next = next, \\<dots> = more\\<rparr>) |\n           namei name inci inc newi new oldi old nexti next morei more.\n           (namei, name) \\<in> nat_rel \\<and>\n           (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n           (newi, new)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (oldi, old)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (nexti, next)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (morei, more) \\<in> Re}", "by auto"], ["", "lemma [autoref_rules]: \n  \"(node_impl.name_impl_update,node.name_update) \n  \\<in> (node_name_rel \\<rightarrow> node_name_rel) \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\"\n  \"(node_impl.incoming_impl_update,node.incoming_update) \n  \\<in> (\\<langle>node_name_rel\\<rangle>dflt_rs_rel \\<rightarrow> \\<langle>node_name_rel\\<rangle>dflt_rs_rel) \n    \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel \n    \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\"\n  \"(node_impl.new_impl_update,node.new_update) \n  \\<in> (\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\"\n  \"(node_impl.old_impl_update,node.old_update) \n  \\<in> (\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\"\n  \"(node_impl.next_impl_update,node.next_update) \n  \\<in> (\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\"\n  \"(node_impl.more_update,node.more_update) \n  \\<in> (Re \\<rightarrow> Re) \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,R\\<rangle>node_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((name_impl_update, name_update)\n     \\<in> (nat_rel \\<rightarrow> nat_rel) \\<rightarrow>\n           \\<langle>Re, R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,\n           R\\<rangle>node_rel &&&\n     (incoming_impl_update, incoming_update)\n     \\<in> (\\<langle>nat_rel\\<rangle>dflt_rs_rel \\<rightarrow>\n            \\<langle>nat_rel\\<rangle>dflt_rs_rel) \\<rightarrow>\n           \\<langle>Re, R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,\n           R\\<rangle>node_rel &&&\n     (new_impl_update, new_update)\n     \\<in> (\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow>\n            \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) \\<rightarrow>\n           \\<langle>Re, R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,\n           R\\<rangle>node_rel) &&&\n    (old_impl_update, old_update)\n    \\<in> (\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow>\n           \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) \\<rightarrow>\n          \\<langle>Re, R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,\n          R\\<rangle>node_rel &&&\n    (next_impl_update, next_update)\n    \\<in> (\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow>\n           \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) \\<rightarrow>\n          \\<langle>Re, R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,\n          R\\<rangle>node_rel &&&\n    (node_impl.more_update, node.more_update)\n    \\<in> (Re \\<rightarrow> Re) \\<rightarrow>\n          \\<langle>Re, R\\<rangle>node_rel \\<rightarrow> \\<langle>Re,\n          R\\<rangle>node_rel", "unfolding node_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((name_impl_update, name_update)\n     \\<in> (nat_rel \\<rightarrow> nat_rel) \\<rightarrow>\n           {(\\<lparr>name_impl = namei, incoming_impl = inci,\n                new_impl = newi, old_impl = oldi, next_impl = nexti,\n                \\<dots> = morei\\<rparr>,\n             \\<lparr>name = name, incoming = inc, new = new, old = old,\n                next = next, \\<dots> = more\\<rparr>) |\n            namei name inci inc newi new oldi old nexti next morei more.\n            (namei, name) \\<in> nat_rel \\<and>\n            (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n            (newi, new)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (oldi, old)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (nexti, next)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (morei, more) \\<in> Re} \\<rightarrow>\n           {(\\<lparr>name_impl = namei, incoming_impl = inci,\n                new_impl = newi, old_impl = oldi, next_impl = nexti,\n                \\<dots> = morei\\<rparr>,\n             \\<lparr>name = name, incoming = inc, new = new, old = old,\n                next = next, \\<dots> = more\\<rparr>) |\n            namei name inci inc newi new oldi old nexti next morei more.\n            (namei, name) \\<in> nat_rel \\<and>\n            (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n            (newi, new)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (oldi, old)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (nexti, next)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (morei, more) \\<in> Re} &&&\n     (incoming_impl_update, incoming_update)\n     \\<in> (\\<langle>nat_rel\\<rangle>dflt_rs_rel \\<rightarrow>\n            \\<langle>nat_rel\\<rangle>dflt_rs_rel) \\<rightarrow>\n           {(\\<lparr>name_impl = namei, incoming_impl = inci,\n                new_impl = newi, old_impl = oldi, next_impl = nexti,\n                \\<dots> = morei\\<rparr>,\n             \\<lparr>name = name, incoming = inc, new = new, old = old,\n                next = next, \\<dots> = more\\<rparr>) |\n            namei name inci inc newi new oldi old nexti next morei more.\n            (namei, name) \\<in> nat_rel \\<and>\n            (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n            (newi, new)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (oldi, old)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (nexti, next)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (morei, more) \\<in> Re} \\<rightarrow>\n           {(\\<lparr>name_impl = namei, incoming_impl = inci,\n                new_impl = newi, old_impl = oldi, next_impl = nexti,\n                \\<dots> = morei\\<rparr>,\n             \\<lparr>name = name, incoming = inc, new = new, old = old,\n                next = next, \\<dots> = more\\<rparr>) |\n            namei name inci inc newi new oldi old nexti next morei more.\n            (namei, name) \\<in> nat_rel \\<and>\n            (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n            (newi, new)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (oldi, old)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (nexti, next)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (morei, more) \\<in> Re} &&&\n     (new_impl_update, new_update)\n     \\<in> (\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow>\n            \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) \\<rightarrow>\n           {(\\<lparr>name_impl = namei, incoming_impl = inci,\n                new_impl = newi, old_impl = oldi, next_impl = nexti,\n                \\<dots> = morei\\<rparr>,\n             \\<lparr>name = name, incoming = inc, new = new, old = old,\n                next = next, \\<dots> = more\\<rparr>) |\n            namei name inci inc newi new oldi old nexti next morei more.\n            (namei, name) \\<in> nat_rel \\<and>\n            (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n            (newi, new)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (oldi, old)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (nexti, next)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (morei, more) \\<in> Re} \\<rightarrow>\n           {(\\<lparr>name_impl = namei, incoming_impl = inci,\n                new_impl = newi, old_impl = oldi, next_impl = nexti,\n                \\<dots> = morei\\<rparr>,\n             \\<lparr>name = name, incoming = inc, new = new, old = old,\n                next = next, \\<dots> = more\\<rparr>) |\n            namei name inci inc newi new oldi old nexti next morei more.\n            (namei, name) \\<in> nat_rel \\<and>\n            (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n            (newi, new)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (oldi, old)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (nexti, next)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (morei, more) \\<in> Re}) &&&\n    (old_impl_update, old_update)\n    \\<in> (\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow>\n           \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) \\<rightarrow>\n          {(\\<lparr>name_impl = namei, incoming_impl = inci,\n               new_impl = newi, old_impl = oldi, next_impl = nexti,\n               \\<dots> = morei\\<rparr>,\n            \\<lparr>name = name, incoming = inc, new = new, old = old,\n               next = next, \\<dots> = more\\<rparr>) |\n           namei name inci inc newi new oldi old nexti next morei more.\n           (namei, name) \\<in> nat_rel \\<and>\n           (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n           (newi, new)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (oldi, old)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (nexti, next)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (morei, more) \\<in> Re} \\<rightarrow>\n          {(\\<lparr>name_impl = namei, incoming_impl = inci,\n               new_impl = newi, old_impl = oldi, next_impl = nexti,\n               \\<dots> = morei\\<rparr>,\n            \\<lparr>name = name, incoming = inc, new = new, old = old,\n               next = next, \\<dots> = more\\<rparr>) |\n           namei name inci inc newi new oldi old nexti next morei more.\n           (namei, name) \\<in> nat_rel \\<and>\n           (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n           (newi, new)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (oldi, old)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (nexti, next)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (morei, more) \\<in> Re} &&&\n    (next_impl_update, next_update)\n    \\<in> (\\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<rightarrow>\n           \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) \\<rightarrow>\n          {(\\<lparr>name_impl = namei, incoming_impl = inci,\n               new_impl = newi, old_impl = oldi, next_impl = nexti,\n               \\<dots> = morei\\<rparr>,\n            \\<lparr>name = name, incoming = inc, new = new, old = old,\n               next = next, \\<dots> = more\\<rparr>) |\n           namei name inci inc newi new oldi old nexti next morei more.\n           (namei, name) \\<in> nat_rel \\<and>\n           (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n           (newi, new)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (oldi, old)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (nexti, next)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (morei, more) \\<in> Re} \\<rightarrow>\n          {(\\<lparr>name_impl = namei, incoming_impl = inci,\n               new_impl = newi, old_impl = oldi, next_impl = nexti,\n               \\<dots> = morei\\<rparr>,\n            \\<lparr>name = name, incoming = inc, new = new, old = old,\n               next = next, \\<dots> = more\\<rparr>) |\n           namei name inci inc newi new oldi old nexti next morei more.\n           (namei, name) \\<in> nat_rel \\<and>\n           (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n           (newi, new)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (oldi, old)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (nexti, next)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (morei, more) \\<in> Re} &&&\n    (node_impl.more_update, node.more_update)\n    \\<in> (Re \\<rightarrow> Re) \\<rightarrow>\n          {(\\<lparr>name_impl = namei, incoming_impl = inci,\n               new_impl = newi, old_impl = oldi, next_impl = nexti,\n               \\<dots> = morei\\<rparr>,\n            \\<lparr>name = name, incoming = inc, new = new, old = old,\n               next = next, \\<dots> = more\\<rparr>) |\n           namei name inci inc newi new oldi old nexti next morei more.\n           (namei, name) \\<in> nat_rel \\<and>\n           (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n           (newi, new)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (oldi, old)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (nexti, next)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (morei, more) \\<in> Re} \\<rightarrow>\n          {(\\<lparr>name_impl = namei, incoming_impl = inci,\n               new_impl = newi, old_impl = oldi, next_impl = nexti,\n               \\<dots> = morei\\<rparr>,\n            \\<lparr>name = name, incoming = inc, new = new, old = old,\n               next = next, \\<dots> = more\\<rparr>) |\n           namei name inci inc newi new oldi old nexti next morei more.\n           (namei, name) \\<in> nat_rel \\<and>\n           (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n           (newi, new)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (oldi, old)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (nexti, next)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (morei, more) \\<in> Re}", "by (auto dest: fun_relD)"], ["", "term name"], ["", "lemma [autoref_rules]:\n  \"(node_impl.name_impl,node.name)\\<in>\\<langle>Re,R\\<rangle>node_rel \\<rightarrow> node_name_rel\"\n  \"(node_impl.incoming_impl,node.incoming)\n  \\<in> \\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>node_name_rel\\<rangle>dflt_rs_rel\"\n  \"(node_impl.new_impl,node.new)\\<in>\\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\"\n  \"(node_impl.old_impl,node.old)\\<in>\\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\"\n  \"(node_impl.next_impl,node.next)\\<in>\\<langle>Re,R\\<rangle>node_rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel\"\n  \"(node_impl.more, node.more)\\<in>\\<langle>Re,R\\<rangle>node_rel \\<rightarrow> Re\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((name_impl, name)\n     \\<in> \\<langle>Re, R\\<rangle>node_rel \\<rightarrow> nat_rel &&&\n     (incoming_impl, incoming)\n     \\<in> \\<langle>Re, R\\<rangle>node_rel \\<rightarrow>\n           \\<langle>nat_rel\\<rangle>dflt_rs_rel &&&\n     (new_impl, new)\n     \\<in> \\<langle>Re, R\\<rangle>node_rel \\<rightarrow>\n           \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) &&&\n    (old_impl, old)\n    \\<in> \\<langle>Re, R\\<rangle>node_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel &&&\n    (next_impl, next)\n    \\<in> \\<langle>Re, R\\<rangle>node_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel &&&\n    (node_impl.more, node.more)\n    \\<in> \\<langle>Re, R\\<rangle>node_rel \\<rightarrow> Re", "unfolding node_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((name_impl, name)\n     \\<in> {(\\<lparr>name_impl = namei, incoming_impl = inci,\n                new_impl = newi, old_impl = oldi, next_impl = nexti,\n                \\<dots> = morei\\<rparr>,\n             \\<lparr>name = name, incoming = inc, new = new, old = old,\n                next = next, \\<dots> = more\\<rparr>) |\n            namei name inci inc newi new oldi old nexti next morei more.\n            (namei, name) \\<in> nat_rel \\<and>\n            (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n            (newi, new)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (oldi, old)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (nexti, next)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (morei, more) \\<in> Re} \\<rightarrow>\n           nat_rel &&&\n     (incoming_impl, incoming)\n     \\<in> {(\\<lparr>name_impl = namei, incoming_impl = inci,\n                new_impl = newi, old_impl = oldi, next_impl = nexti,\n                \\<dots> = morei\\<rparr>,\n             \\<lparr>name = name, incoming = inc, new = new, old = old,\n                next = next, \\<dots> = more\\<rparr>) |\n            namei name inci inc newi new oldi old nexti next morei more.\n            (namei, name) \\<in> nat_rel \\<and>\n            (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n            (newi, new)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (oldi, old)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (nexti, next)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (morei, more) \\<in> Re} \\<rightarrow>\n           \\<langle>nat_rel\\<rangle>dflt_rs_rel &&&\n     (new_impl, new)\n     \\<in> {(\\<lparr>name_impl = namei, incoming_impl = inci,\n                new_impl = newi, old_impl = oldi, next_impl = nexti,\n                \\<dots> = morei\\<rparr>,\n             \\<lparr>name = name, incoming = inc, new = new, old = old,\n                next = next, \\<dots> = more\\<rparr>) |\n            namei name inci inc newi new oldi old nexti next morei more.\n            (namei, name) \\<in> nat_rel \\<and>\n            (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n            (newi, new)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (oldi, old)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (nexti, next)\n            \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n            (morei, more) \\<in> Re} \\<rightarrow>\n           \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel) &&&\n    (old_impl, old)\n    \\<in> {(\\<lparr>name_impl = namei, incoming_impl = inci,\n               new_impl = newi, old_impl = oldi, next_impl = nexti,\n               \\<dots> = morei\\<rparr>,\n            \\<lparr>name = name, incoming = inc, new = new, old = old,\n               next = next, \\<dots> = more\\<rparr>) |\n           namei name inci inc newi new oldi old nexti next morei more.\n           (namei, name) \\<in> nat_rel \\<and>\n           (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n           (newi, new)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (oldi, old)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (nexti, next)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (morei, more) \\<in> Re} \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel &&&\n    (next_impl, next)\n    \\<in> {(\\<lparr>name_impl = namei, incoming_impl = inci,\n               new_impl = newi, old_impl = oldi, next_impl = nexti,\n               \\<dots> = morei\\<rparr>,\n            \\<lparr>name = name, incoming = inc, new = new, old = old,\n               next = next, \\<dots> = more\\<rparr>) |\n           namei name inci inc newi new oldi old nexti next morei more.\n           (namei, name) \\<in> nat_rel \\<and>\n           (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n           (newi, new)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (oldi, old)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (nexti, next)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (morei, more) \\<in> Re} \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel &&&\n    (node_impl.more, node.more)\n    \\<in> {(\\<lparr>name_impl = namei, incoming_impl = inci,\n               new_impl = newi, old_impl = oldi, next_impl = nexti,\n               \\<dots> = morei\\<rparr>,\n            \\<lparr>name = name, incoming = inc, new = new, old = old,\n               next = next, \\<dots> = more\\<rparr>) |\n           namei name inci inc newi new oldi old nexti next morei more.\n           (namei, name) \\<in> nat_rel \\<and>\n           (inci, inc) \\<in> \\<langle>nat_rel\\<rangle>dflt_rs_rel \\<and>\n           (newi, new)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (oldi, old)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (nexti, next)\n           \\<in> \\<langle>\\<langle>R\\<rangle>ltlr_rel\\<rangle>lss.rel \\<and>\n           (morei, more) \\<in> Re} \\<rightarrow>\n          Re", "by auto"], ["", "subsection \\<open>Massaging the Abstract Algorithm\\<close>"], ["", "text \\<open>\n  In a first step, we do some refinement steps on the abstract data structures,\n  with the goal to make the algorithm more efficient.\n\\<close>"], ["", "subsubsection \\<open>Creation of the Nodes\\<close>"], ["", "text \\<open>\n  In the expand-algorithm, we replace nested conditionals by case-distinctions,\n  and slightly stratify the code.\n\\<close>"], ["", "abbreviation (input) \"expand2 exp n ns \\<phi> n1 nx1 n2 \\<equiv> do {\n    (nm, nds) \\<leftarrow> exp (\n      n\\<lparr> \n        new := insert n1 (new n), \n        old := insert \\<phi> (old n), \n        next := nx1 \\<union> next n \\<rparr>, \n      ns);\n    exp (n\\<lparr> name := nm, new := n2 \\<union> new n, old := {\\<phi>} \\<union> old n \\<rparr>, nds)\n  }\""], ["", "definition \"expand_aimpl \\<equiv> REC\\<^sub>T (\\<lambda>expand (n,ns). \n      if new n = {} then ( \n        if (\\<exists>n'\\<in>ns. old n' = old n \\<and> next n' = next n) then \n          RETURN (name n, upd_incoming n ns)\n        else do {\n          ASSERT (n \\<notin> ns);\n          ASSERT (name n \\<notin> name`ns);\n          expand (\\<lparr> \n            name=expand_new_name (name n), \n            incoming={name n}, \n            new=next n, \n            old={}, \n            next={} \\<rparr>, \n            insert n ns)\n        }\n      ) else do { \n        \\<phi> \\<leftarrow> SPEC (\\<lambda>x. x\\<in>(new n));\n        let n = n\\<lparr> new := new n - {\\<phi>} \\<rparr>;\n        case \\<phi> of\n          prop\\<^sub>r(q) \\<Rightarrow> \n            if nprop\\<^sub>r(q)\\<in>old n then RETURN (name n, ns)\n            else expand (n\\<lparr> old := {\\<phi>} \\<union> old n \\<rparr>, ns)\n        | nprop\\<^sub>r(q) \\<Rightarrow> \n            if prop\\<^sub>r(q)\\<in>old n then RETURN (name n, ns)\n            else expand (n\\<lparr> old := {\\<phi>} \\<union> old n \\<rparr>, ns)\n        | true\\<^sub>r \\<Rightarrow> expand (n\\<lparr> old := {\\<phi>} \\<union> old n \\<rparr>, ns)\n        | false\\<^sub>r \\<Rightarrow> RETURN (name n, ns)\n        | \\<nu> and\\<^sub>r \\<mu> \\<Rightarrow> expand (n\\<lparr> \n            new := insert \\<nu> (insert \\<mu> (new n)), \n            old := {\\<phi>} \\<union> old n, \n            next := next n \\<rparr>, ns)\n        | X\\<^sub>r \\<nu> \\<Rightarrow> expand \n            (n\\<lparr> new := new n, old := {\\<phi>} \\<union> old n, next := insert \\<nu> (next n) \\<rparr>, ns)\n        | \\<mu> or\\<^sub>r \\<nu> \\<Rightarrow> expand2 expand n ns \\<phi> \\<mu> {} {\\<nu>}\n        | \\<mu> U\\<^sub>r \\<nu> \\<Rightarrow> expand2 expand n ns \\<phi> \\<mu> {\\<phi>} {\\<nu>}\n        | \\<mu> R\\<^sub>r \\<nu> \\<Rightarrow> expand2 expand n ns \\<phi> \\<nu> {\\<phi>} {\\<mu>,\\<nu>}\n        \\<^cancel>\\<open>| _ \\<Rightarrow> do {\n          (nm, nds) \\<leftarrow> expand (\n            n\\<lparr> \n              new := new1 \\<phi> \\<union> new n, \n              old := {\\<phi>} \\<union> old n, \n              next := next1 \\<phi> \\<union> next n \\<rparr>,\n            ns);\n          expand (n\\<lparr> name := nm, new := new2 \\<phi> \\<union> new n, old := {\\<phi>} \\<union> old n \\<rparr>, nds)\n        }\\<close>\n      }\n     )\""], ["", "lemma expand_aimpl_refine:\n  fixes n_ns :: \"('a node \\<times> _)\"\n  defines \"R \\<equiv> Id \\<inter> {(_,(n,ns)). \\<forall>n'\\<in>ns. n > name n'}\"\n  defines \"R' \\<equiv> Id \\<inter> {(_,(n,ns)). \\<forall>n'\\<in>ns. name n > name n'}\"\n  assumes [refine]: \"(n_ns',n_ns)\\<in>R'\"\n  shows \"expand_aimpl n_ns' \\<le> \\<Down>R (expand\\<^sub>T n_ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expand_aimpl n_ns' \\<le> \\<Down> R (expand\\<^sub>T n_ns)", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. expand_aimpl n_ns' \\<le> \\<Down> R (expand\\<^sub>T n_ns)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. expand_aimpl n_ns' \\<le> \\<Down> R (expand\\<^sub>T n_ns)", "have [relator_props]: \"single_valued R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R", "by (auto simp add: R_def intro: single_valuedI)"], ["proof (state)\nthis:\n  single_valued R\n\ngoal (1 subgoal):\n 1. expand_aimpl n_ns' \\<le> \\<Down> R (expand\\<^sub>T n_ns)", "have [relator_props]: \"single_valued R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R'", "by (auto simp add: R'_def intro: single_valuedI)"], ["proof (state)\nthis:\n  single_valued R'\n\ngoal (1 subgoal):\n 1. expand_aimpl n_ns' \\<le> \\<Down> R (expand\\<^sub>T n_ns)", "{"], ["proof (state)\nthis:\n  single_valued R'\n\ngoal (1 subgoal):\n 1. expand_aimpl n_ns' \\<le> \\<Down> R (expand\\<^sub>T n_ns)", "fix n :: \"'a node\" and ns and n' ns'"], ["proof (state)\ngoal (1 subgoal):\n 1. expand_aimpl n_ns' \\<le> \\<Down> R (expand\\<^sub>T n_ns)", "assume \"((n', ns'), (n, ns)) \\<in> R'\""], ["proof (state)\nthis:\n  ((n', ns'), n, ns) \\<in> R'\n\ngoal (1 subgoal):\n 1. expand_aimpl n_ns' \\<le> \\<Down> R (expand\\<^sub>T n_ns)", "then"], ["proof (chain)\npicking this:\n  ((n', ns'), n, ns) \\<in> R'", "have \"(RETURN (name n', ns') \\<le> \\<Down> R (RETURN (name n, ns)))\""], ["proof (prove)\nusing this:\n  ((n', ns'), n, ns) \\<in> R'\n\ngoal (1 subgoal):\n 1. RETURN (name n', ns') \\<le> \\<Down> R (RETURN (name n, ns))", "by (auto simp: R_def R'_def pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  RETURN (name n', ns') \\<le> \\<Down> R (RETURN (name n, ns))\n\ngoal (1 subgoal):\n 1. expand_aimpl n_ns' \\<le> \\<Down> R (expand\\<^sub>T n_ns)", "}"], ["proof (state)\nthis:\n  ((?n'2, ?ns'2), ?n2, ?ns2) \\<in> R' \\<Longrightarrow>\n  RETURN (name ?n'2, ?ns'2) \\<le> \\<Down> R (RETURN (name ?n2, ?ns2))\n\ngoal (1 subgoal):\n 1. expand_aimpl n_ns' \\<le> \\<Down> R (expand\\<^sub>T n_ns)", "note aux = this"], ["proof (state)\nthis:\n  ((?n'2, ?ns'2), ?n2, ?ns2) \\<in> R' \\<Longrightarrow>\n  RETURN (name ?n'2, ?ns'2) \\<le> \\<Down> R (RETURN (name ?n2, ?ns2))\n\ngoal (1 subgoal):\n 1. expand_aimpl n_ns' \\<le> \\<Down> R (expand\\<^sub>T n_ns)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. expand_aimpl n_ns' \\<le> \\<Down> R (expand\\<^sub>T n_ns)", "unfolding expand_aimpl_def expand\\<^sub>T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>expand (n, ns).\n         if new n = {}\n         then if \\<exists>n'\\<in>ns. old n' = old n \\<and> next n' = next n\n              then RETURN (name n, upd_incoming n ns)\n              else ASSERT (n \\<notin> ns) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (name n \\<notin> name ` ns) \\<bind>\n                       (\\<lambda>_.\n                           expand\n                            (\\<lparr>name = expand_new_name (name n),\n                                incoming = {name n}, new = next n, old = {},\n                                next = {}\\<rparr>,\n                             insert n ns)))\n         else SPEC (\\<lambda>x. x \\<in> new n) \\<bind>\n              (\\<lambda>\\<phi>.\n                  let n = n\\<lparr>new := new n - {\\<phi>}\\<rparr>\n                  in case \\<phi> of\n                     true\\<^sub>r \\<Rightarrow>\n                       expand\n                        (n\\<lparr>old := {\\<phi>} \\<union> old n\\<rparr>,\n                         ns)\n                     | false\\<^sub>r \\<Rightarrow> RETURN (name n, ns)\n                     | prop\\<^sub>r(q) \\<Rightarrow>\n                         if nprop\\<^sub>r(q) \\<in> old n\n                         then RETURN (name n, ns)\n                         else expand\n                               (n\\<lparr>old :=\n     {\\<phi>} \\<union> old n\\<rparr>,\n                                ns)\n                     | nprop\\<^sub>r(q) \\<Rightarrow>\n                         if prop\\<^sub>r(q) \\<in> old n\n                         then RETURN (name n, ns)\n                         else expand\n                               (n\\<lparr>old :=\n     {\\<phi>} \\<union> old n\\<rparr>,\n                                ns)\n                     | \\<nu> and\\<^sub>r \\<mu> \\<Rightarrow>\n                         expand\n                          (n\\<lparr>new :=\ninsert \\<nu> (insert \\<mu> (new n)),\n                               old := {\\<phi>} \\<union> old n,\n                               next := next n\\<rparr>,\n                           ns)\n                     | \\<mu> or\\<^sub>r \\<nu> \\<Rightarrow>\n                         expand\n                          (n\\<lparr>new := insert \\<mu> (new n),\n                               old := insert \\<phi> (old n),\n                               next := {} \\<union> next n\\<rparr>,\n                           ns) \\<bind>\n                         (\\<lambda>(nm, nds).\n                             expand\n                              (n\\<lparr>name := nm,\n                                   new := {\\<nu>} \\<union> new n,\n                                   old := {\\<phi>} \\<union> old n\\<rparr>,\n                               nds))\n                     | X\\<^sub>r \\<nu> \\<Rightarrow>\n                         expand\n                          (n\\<lparr>new := new n,\n                               old := {\\<phi>} \\<union> old n,\n                               next := insert \\<nu> (next n)\\<rparr>,\n                           ns)\n                     | \\<mu> U\\<^sub>r \\<nu> \\<Rightarrow>\n                         expand\n                          (n\\<lparr>new := insert \\<mu> (new n),\n                               old := insert \\<phi> (old n),\n                               next := {\\<phi>} \\<union> next n\\<rparr>,\n                           ns) \\<bind>\n                         (\\<lambda>(nm, nds).\n                             expand\n                              (n\\<lparr>name := nm,\n                                   new := {\\<nu>} \\<union> new n,\n                                   old := {\\<phi>} \\<union> old n\\<rparr>,\n                               nds))\n                     | \\<mu> R\\<^sub>r \\<nu> \\<Rightarrow>\n                         expand\n                          (n\\<lparr>new := insert \\<nu> (new n),\n                               old := insert \\<phi> (old n),\n                               next := {\\<phi>} \\<union> next n\\<rparr>,\n                           ns) \\<bind>\n                         (\\<lambda>(nm, nds).\n                             expand\n                              (n\\<lparr>name := nm,\n                                   new := {\\<mu>, \\<nu>} \\<union> new n,\n                                   old := {\\<phi>} \\<union> old n\\<rparr>,\n                               nds))))\n     n_ns'\n    \\<le> \\<Down> R\n           (REC\\<^sub>T\n             (\\<lambda>expand (n, ns).\n                 if new n = {}\n                 then if \\<exists>n'\\<in>ns.\n                            old n' = old n \\<and> next n' = next n\n                      then RETURN (name n, upd_incoming n ns)\n                      else expand\n                            (\\<lparr>name = expand_new_name (name n),\n                                incoming = {name n}, new = next n, old = {},\n                                next = {}\\<rparr>,\n                             {n} \\<union> ns)\n                 else SPEC (\\<lambda>x. x \\<in> new n) \\<bind>\n                      (\\<lambda>\\<phi>.\n                          let n = n\\<lparr>new := new n - {\\<phi>}\\<rparr>\n                          in if \\<exists>q.\n                                   \\<phi> = prop\\<^sub>r(q) \\<or>\n                                   \\<phi> = nprop\\<^sub>r(q)\n                             then if not\\<^sub>r \\<phi> \\<in> old n\n                                  then RETURN (name n, ns)\n                                  else expand\n  (n\\<lparr>old := {\\<phi>} \\<union> old n\\<rparr>, ns)\n                             else if \\<phi> = true\\<^sub>r\n                                  then expand\n  (n\\<lparr>old := {\\<phi>} \\<union> old n\\<rparr>, ns)\n                                  else if \\<phi> = false\\<^sub>r\n then RETURN (name n, ns)\n else if \\<exists>\\<nu> \\<mu>.\n            \\<phi> = \\<nu> and\\<^sub>r \\<mu> \\<or> \\<phi> = X\\<^sub>r \\<nu>\n      then expand\n            (n\\<lparr>new := new1 \\<phi> \\<union> new n,\n                 old := {\\<phi>} \\<union> old n,\n                 next := next1 \\<phi> \\<union> next n\\<rparr>,\n             ns)\n      else expand\n            (n\\<lparr>new := new1 \\<phi> \\<union> new n,\n                 old := {\\<phi>} \\<union> old n,\n                 next := next1 \\<phi> \\<union> next n\\<rparr>,\n             ns) \\<bind>\n           (\\<lambda>(nm, nds).\n               expand\n                (n\\<lparr>name := nm, new := new2 \\<phi> \\<union> new n,\n                     old := {\\<phi>} \\<union> old n\\<rparr>,\n                 nds))))\n             n_ns)", "apply refine_rcg"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>expand expanda x x' x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> R' \\<Longrightarrow>\n                   expand x \\<le> \\<Down> R (expanda x');\n        (x, x') \\<in> R'; x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (new x1a = {}) = (new x1 = {})\nA total of 8 subgoals...", "apply (simp add: R_def R'_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>expand expanda x x' x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> R' \\<Longrightarrow>\n                   expand x \\<le> \\<Down> R (expanda x');\n        (x, x') \\<in> R'; x' = (x1, x2); x = (x1a, x2a); new x1a = {};\n        new x1 = {}\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n'\\<in>x2a.\n                             old n' = old x1a \\<and> next n' = next x1a) =\n                         (\\<exists>n'\\<in>x2.\n                             old n' = old x1 \\<and> next n' = next x1)\nA total of 7 subgoals...", "apply (simp add: R_def R'_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>expand expanda x x' x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> R' \\<Longrightarrow>\n                   expand x \\<le> \\<Down> R (expanda x');\n        (x, x') \\<in> R'; x' = (x1, x2); x = (x1a, x2a); new x1a = {};\n        new x1 = {};\n        \\<exists>n'\\<in>x2a. old n' = old x1a \\<and> next n' = next x1a;\n        \\<exists>n'\\<in>x2.\n           old n' = old x1 \\<and> next n' = next x1\\<rbrakk>\n       \\<Longrightarrow> ((name x1a, upd_incoming x1a x2a), name x1,\n                          upd_incoming x1 x2)\n                         \\<in> R\nA total of 6 subgoals...", "apply (auto simp add: R_def R'_def upd_incoming_def) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>expand expanda x x' x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> R' \\<Longrightarrow>\n                   expand x \\<le> \\<Down> R (expanda x');\n        (x, x') \\<in> R'; x' = (x1, x2); x = (x1a, x2a); new x1a = {};\n        new x1 = {};\n        \\<not> (\\<exists>n'\\<in>x2a.\n                   old n' = old x1a \\<and> next n' = next x1a);\n        \\<not> (\\<exists>n'\\<in>x2.\n                   old n' = old x1 \\<and> next n' = next x1)\\<rbrakk>\n       \\<Longrightarrow> x1a \\<notin> x2a\nA total of 5 subgoals...", "apply (auto simp add: R_def R'_def upd_incoming_def) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>expand expanda x x' x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> R' \\<Longrightarrow>\n                   expand x \\<le> \\<Down> R (expanda x');\n        (x, x') \\<in> R'; x' = (x1, x2); x = (x1a, x2a); new x1a = {};\n        new x1 = {};\n        \\<not> (\\<exists>n'\\<in>x2a.\n                   old n' = old x1a \\<and> next n' = next x1a);\n        \\<not> (\\<exists>n'\\<in>x2.\n                   old n' = old x1 \\<and> next n' = next x1);\n        x1a \\<notin> x2a\\<rbrakk>\n       \\<Longrightarrow> name x1a \\<notin> name ` x2a\nA total of 4 subgoals...", "apply (auto simp add: R_def R'_def upd_incoming_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>expand expanda x x' x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> R' \\<Longrightarrow>\n                   expand x \\<le> \\<Down> R (expanda x');\n        (x, x') \\<in> R'; x' = (x1, x2); x = (x1a, x2a); new x1a = {};\n        new x1 = {};\n        \\<not> (\\<exists>n'\\<in>x2a.\n                   old n' = old x1a \\<and> next n' = next x1a);\n        \\<not> (\\<exists>n'\\<in>x2.\n                   old n' = old x1 \\<and> next n' = next x1);\n        x1a \\<notin> x2a; name x1a \\<notin> name ` x2a\\<rbrakk>\n       \\<Longrightarrow> expand\n                          (\\<lparr>name = expand_new_name (name x1a),\n                              incoming = {name x1a}, new = next x1a,\n                              old = {}, next = {}\\<rparr>,\n                           insert x1a x2a)\n                         \\<le> \\<Down> R\n                                (expanda\n                                  (\\<lparr>name = expand_new_name (name x1),\nincoming = {name x1}, new = next x1, old = {}, next = {}\\<rparr>,\n                                   {x1} \\<union> x2))\nA total of 3 subgoals...", "apply rprems"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>expand expanda x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x') \\<in> R'; x' = (x1, x2); x = (x1a, x2a);\n        new x1a = {}; new x1 = {};\n        \\<not> (\\<exists>n'\\<in>x2a.\n                   old n' = old x1a \\<and> next n' = next x1a);\n        \\<not> (\\<exists>n'\\<in>x2.\n                   old n' = old x1 \\<and> next n' = next x1);\n        x1a \\<notin> x2a; name x1a \\<notin> name ` x2a\\<rbrakk>\n       \\<Longrightarrow> ((\\<lparr>name = expand_new_name (name x1a),\n                              incoming = {name x1a}, new = next x1a,\n                              old = {}, next = {}\\<rparr>,\n                           insert x1a x2a),\n                          \\<lparr>name = expand_new_name (name x1),\n                             incoming = {name x1}, new = next x1, old = {},\n                             next = {}\\<rparr>,\n                          {x1} \\<union> x2)\n                         \\<in> R'\nA total of 3 subgoals...", "apply (auto simp: R'_def expand_new_name_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>expand expanda x x' x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> R' \\<Longrightarrow>\n                   expand x \\<le> \\<Down> R (expanda x');\n        (x, x') \\<in> R'; x' = (x1, x2); x = (x1a, x2a);\n        new x1a \\<noteq> {}; new x1 \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> SPEC (\\<lambda>x. x \\<in> new x1a)\n                         \\<le> SPEC (\\<lambda>x. x \\<in> new x1)\nA total of 2 subgoals...", "apply (simp add: R'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>expand expanda x x' x1 x2 x1a x2a \\<phi> \\<phi>'.\n       \\<lbrakk>\\<And>x x'.\n                   (x, x') \\<in> R' \\<Longrightarrow>\n                   expand x \\<le> \\<Down> R (expanda x');\n        (x, x') \\<in> R'; x' = (x1, x2); x = (x1a, x2a);\n        new x1a \\<noteq> {}; new x1 \\<noteq> {}; (\\<phi>, \\<phi>') \\<in> Id;\n        \\<phi> \\<in> {x. x \\<in> new x1a};\n        \\<phi>' \\<in> {x. x \\<in> new x1}\\<rbrakk>\n       \\<Longrightarrow> (case \\<phi> of\n                          true\\<^sub>r \\<Rightarrow>\n                            expand\n                             (x1a\\<lparr>new := new x1a - {\\<phi>},\n                                    old :=\n{\\<phi>} \\<union>\nold (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)\\<rparr>,\n                              x2a)\n                          | false\\<^sub>r \\<Rightarrow>\n                              RETURN\n                               (name\n                                 (x1a\\<lparr>new :=\n         new x1a - {\\<phi>}\\<rparr>),\n                                x2a)\n                          | prop\\<^sub>r(q) \\<Rightarrow>\n                              if nprop\\<^sub>r(q)\n                                 \\<in> old\n  (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)\n                              then RETURN\n                                    (name\n(x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>),\n                                     x2a)\n                              else expand\n                                    (x1a\\<lparr>new := new x1a - {\\<phi>},\n     old :=\n       {\\<phi>} \\<union>\n       old (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)\\<rparr>,\n                                     x2a)\n                          | nprop\\<^sub>r(q) \\<Rightarrow>\n                              if prop\\<^sub>r(q)\n                                 \\<in> old\n  (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)\n                              then RETURN\n                                    (name\n(x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>),\n                                     x2a)\n                              else expand\n                                    (x1a\\<lparr>new := new x1a - {\\<phi>},\n     old :=\n       {\\<phi>} \\<union>\n       old (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)\\<rparr>,\n                                     x2a)\n                          | \\<nu> and\\<^sub>r \\<mu> \\<Rightarrow>\n                              expand\n                               (x1a\\<lparr>new := new x1a - {\\<phi>},\nnew :=\n  insert \\<nu>\n   (insert \\<mu> (new (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>))),\nold := {\\<phi>} \\<union> old (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>),\nnext := next (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)\\<rparr>,\n                                x2a)\n                          | \\<mu> or\\<^sub>r \\<nu> \\<Rightarrow>\n                              expand\n                               (x1a\\<lparr>new := new x1a - {\\<phi>},\nnew := insert \\<mu> (new (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)),\nold := insert \\<phi> (old (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)),\nnext :=\n  {} \\<union> next (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)\\<rparr>,\n                                x2a) \\<bind>\n                              (\\<lambda>(nm, nds).\n                                  expand\n                                   (x1a\\<lparr>new := new x1a - {\\<phi>},\n    name := nm,\n    new :=\n      {\\<nu>} \\<union> new (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>),\n    old :=\n      {\\<phi>} \\<union>\n      old (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)\\<rparr>,\n                                    nds))\n                          | X\\<^sub>r \\<nu> \\<Rightarrow>\n                              expand\n                               (x1a\\<lparr>new := new x1a - {\\<phi>},\nnew := new (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>),\nold := {\\<phi>} \\<union> old (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>),\nnext :=\n  insert \\<nu>\n   (next (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>))\\<rparr>,\n                                x2a)\n                          | \\<mu> U\\<^sub>r \\<nu> \\<Rightarrow>\n                              expand\n                               (x1a\\<lparr>new := new x1a - {\\<phi>},\nnew := insert \\<mu> (new (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)),\nold := insert \\<phi> (old (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)),\nnext :=\n  {\\<phi>} \\<union>\n  next (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)\\<rparr>,\n                                x2a) \\<bind>\n                              (\\<lambda>(nm, nds).\n                                  expand\n                                   (x1a\\<lparr>new := new x1a - {\\<phi>},\n    name := nm,\n    new :=\n      {\\<nu>} \\<union> new (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>),\n    old :=\n      {\\<phi>} \\<union>\n      old (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)\\<rparr>,\n                                    nds))\n                          | \\<mu> R\\<^sub>r \\<nu> \\<Rightarrow>\n                              expand\n                               (x1a\\<lparr>new := new x1a - {\\<phi>},\nnew := insert \\<nu> (new (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)),\nold := insert \\<phi> (old (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)),\nnext :=\n  {\\<phi>} \\<union>\n  next (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)\\<rparr>,\n                                x2a) \\<bind>\n                              (\\<lambda>(nm, nds).\n                                  expand\n                                   (x1a\\<lparr>new := new x1a - {\\<phi>},\n    name := nm,\n    new :=\n      {\\<mu>, \\<nu>} \\<union>\n      new (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>),\n    old :=\n      {\\<phi>} \\<union>\n      old (x1a\\<lparr>new := new x1a - {\\<phi>}\\<rparr>)\\<rparr>,\n                                    nds)))\n                         \\<le> \\<Down> R\n                                (if \\<exists>q.\n \\<phi>' = prop\\<^sub>r(q) \\<or> \\<phi>' = nprop\\<^sub>r(q)\n                                 then if not\\<^sub>r \\<phi>'\n   \\<in> old (x1\\<lparr>new := new x1 - {\\<phi>'}\\<rparr>)\nthen RETURN (name (x1\\<lparr>new := new x1 - {\\<phi>'}\\<rparr>), x2)\nelse expanda\n      (x1\\<lparr>new := new x1 - {\\<phi>'},\n            old :=\n              {\\<phi>'} \\<union>\n              old (x1\\<lparr>new := new x1 - {\\<phi>'}\\<rparr>)\\<rparr>,\n       x2)\n                                 else if \\<phi>' = true\\<^sub>r\nthen expanda\n      (x1\\<lparr>new := new x1 - {\\<phi>'},\n            old :=\n              {\\<phi>'} \\<union>\n              old (x1\\<lparr>new := new x1 - {\\<phi>'}\\<rparr>)\\<rparr>,\n       x2)\nelse if \\<phi>' = false\\<^sub>r\n     then RETURN (name (x1\\<lparr>new := new x1 - {\\<phi>'}\\<rparr>), x2)\n     else if \\<exists>\\<nu> \\<mu>.\n                \\<phi>' = \\<nu> and\\<^sub>r \\<mu> \\<or>\n                \\<phi>' = X\\<^sub>r \\<nu>\n          then expanda\n                (x1\\<lparr>new := new x1 - {\\<phi>'},\n                      new :=\n                        new1 \\<phi>' \\<union>\n                        new (x1\\<lparr>new := new x1 - {\\<phi>'}\\<rparr>),\n                      old :=\n                        {\\<phi>'} \\<union>\n                        old (x1\\<lparr>new := new x1 - {\\<phi>'}\\<rparr>),\n                      next :=\n                        next1 \\<phi>' \\<union>\n                        next\n                         (x1\\<lparr>new :=\nnew x1 - {\\<phi>'}\\<rparr>)\\<rparr>,\n                 x2)\n          else expanda\n                (x1\\<lparr>new := new x1 - {\\<phi>'},\n                      new :=\n                        new1 \\<phi>' \\<union>\n                        new (x1\\<lparr>new := new x1 - {\\<phi>'}\\<rparr>),\n                      old :=\n                        {\\<phi>'} \\<union>\n                        old (x1\\<lparr>new := new x1 - {\\<phi>'}\\<rparr>),\n                      next :=\n                        next1 \\<phi>' \\<union>\n                        next\n                         (x1\\<lparr>new :=\nnew x1 - {\\<phi>'}\\<rparr>)\\<rparr>,\n                 x2) \\<bind>\n               (\\<lambda>(nm, nds).\n                   expanda\n                    (x1\\<lparr>new := new x1 - {\\<phi>'}, name := nm,\n                          new :=\n                            new2 \\<phi>' \\<union>\n                            new (x1\\<lparr>new :=\n       new x1 - {\\<phi>'}\\<rparr>),\n                          old :=\n                            {\\<phi>'} \\<union>\n                            old (x1\\<lparr>new :=\n       new x1 - {\\<phi>'}\\<rparr>)\\<rparr>,\n                     nds)))", "apply (auto split: ltlr.split) []"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; true\\<^sub>r \\<in> new x1a;\n        true\\<^sub>r \\<in> new x1; x \\<in> new x1a; xa \\<in> new x1\\<rbrakk>\n       \\<Longrightarrow> expand\n                          (x1a\\<lparr>new := new x1a - {true\\<^sub>r},\n                                 old :=\n                                   insert true\\<^sub>r (old x1a)\\<rparr>,\n                           x2a)\n                         \\<le> \\<Down> R\n                                (expanda\n                                  (x1\\<lparr>new := new x1 - {true\\<^sub>r},\n  old := insert true\\<^sub>r (old x1)\\<rparr>,\n                                   x2))\nA total of 15 subgoals...", "apply (fastforce simp: R_def R'_def) []"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; false\\<^sub>r \\<in> new x1a;\n        false\\<^sub>r \\<in> new x1; x \\<in> new x1a;\n        xa \\<in> new x1\\<rbrakk>\n       \\<Longrightarrow> ((name x1a, x2a), name x1, x2) \\<in> R\nA total of 14 subgoals...", "apply (fastforce simp: R_def R'_def) []"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa x3.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; prop\\<^sub>r(x3) \\<in> new x1a;\n        prop\\<^sub>r(x3) \\<in> new x1; x \\<in> new x1a; xa \\<in> new x1;\n        nprop\\<^sub>r(x3) \\<in> old x1a;\n        nprop\\<^sub>r(x3) \\<in> old x1\\<rbrakk>\n       \\<Longrightarrow> ((name x1a, x2a), name x1, x2) \\<in> R\nA total of 13 subgoals...", "apply (auto simp: R_def R'_def) []"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa x3.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; prop\\<^sub>r(x3) \\<in> new x1a;\n        prop\\<^sub>r(x3) \\<in> new x1; x \\<in> new x1a; xa \\<in> new x1;\n        nprop\\<^sub>r(x3) \\<in> old x1a;\n        nprop\\<^sub>r(x3) \\<notin> old x1\\<rbrakk>\n       \\<Longrightarrow> RETURN (name x1a, x2a)\n                         \\<le> \\<Down> R\n                                (expanda\n                                  (x1\\<lparr>new :=\n         new x1 - {prop\\<^sub>r(x3)},\n  old := insert prop\\<^sub>r(x3) (old x1)\\<rparr>,\n                                   x2))\nA total of 12 subgoals...", "apply (auto simp: R_def R'_def) []"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa x3.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; prop\\<^sub>r(x3) \\<in> new x1a;\n        prop\\<^sub>r(x3) \\<in> new x1; x \\<in> new x1a; xa \\<in> new x1;\n        nprop\\<^sub>r(x3) \\<notin> old x1a;\n        nprop\\<^sub>r(x3) \\<in> old x1\\<rbrakk>\n       \\<Longrightarrow> expand\n                          (x1a\\<lparr>new := new x1a - {prop\\<^sub>r(x3)},\n                                 old :=\n                                   insert prop\\<^sub>r(x3)\n                                    (old x1a)\\<rparr>,\n                           x2a)\n                         \\<le> \\<Down> R (RETURN (name x1, x2))\nA total of 11 subgoals...", "apply (auto simp: R_def R'_def) []"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa x3.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; prop\\<^sub>r(x3) \\<in> new x1a;\n        prop\\<^sub>r(x3) \\<in> new x1; x \\<in> new x1a; xa \\<in> new x1;\n        nprop\\<^sub>r(x3) \\<notin> old x1a;\n        nprop\\<^sub>r(x3) \\<notin> old x1\\<rbrakk>\n       \\<Longrightarrow> expand\n                          (x1a\\<lparr>new := new x1a - {prop\\<^sub>r(x3)},\n                                 old :=\n                                   insert prop\\<^sub>r(x3)\n                                    (old x1a)\\<rparr>,\n                           x2a)\n                         \\<le> \\<Down> R\n                                (expanda\n                                  (x1\\<lparr>new :=\n         new x1 - {prop\\<^sub>r(x3)},\n  old := insert prop\\<^sub>r(x3) (old x1)\\<rparr>,\n                                   x2))\nA total of 10 subgoals...", "apply (auto simp: R_def R'_def) []"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa x4.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; nprop\\<^sub>r(x4) \\<in> new x1a;\n        nprop\\<^sub>r(x4) \\<in> new x1; x \\<in> new x1a; xa \\<in> new x1;\n        prop\\<^sub>r(x4) \\<in> old x1a;\n        prop\\<^sub>r(x4) \\<in> old x1\\<rbrakk>\n       \\<Longrightarrow> ((name x1a, x2a), name x1, x2) \\<in> R\nA total of 9 subgoals...", "apply (auto simp: R_def R'_def) []"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa x4.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; nprop\\<^sub>r(x4) \\<in> new x1a;\n        nprop\\<^sub>r(x4) \\<in> new x1; x \\<in> new x1a; xa \\<in> new x1;\n        prop\\<^sub>r(x4) \\<in> old x1a;\n        prop\\<^sub>r(x4) \\<notin> old x1\\<rbrakk>\n       \\<Longrightarrow> RETURN (name x1a, x2a)\n                         \\<le> \\<Down> R\n                                (expanda\n                                  (x1\\<lparr>new :=\n         new x1 - {nprop\\<^sub>r(x4)},\n  old := insert nprop\\<^sub>r(x4) (old x1)\\<rparr>,\n                                   x2))\nA total of 8 subgoals...", "apply (auto simp: R_def R'_def) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa x4.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; nprop\\<^sub>r(x4) \\<in> new x1a;\n        nprop\\<^sub>r(x4) \\<in> new x1; x \\<in> new x1a; xa \\<in> new x1;\n        prop\\<^sub>r(x4) \\<notin> old x1a;\n        prop\\<^sub>r(x4) \\<in> old x1\\<rbrakk>\n       \\<Longrightarrow> expand\n                          (x1a\\<lparr>new := new x1a - {nprop\\<^sub>r(x4)},\n                                 old :=\n                                   insert nprop\\<^sub>r(x4)\n                                    (old x1a)\\<rparr>,\n                           x2a)\n                         \\<le> \\<Down> R (RETURN (name x1, x2))\nA total of 7 subgoals...", "apply (auto simp: R_def R'_def) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa x4.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; nprop\\<^sub>r(x4) \\<in> new x1a;\n        nprop\\<^sub>r(x4) \\<in> new x1; x \\<in> new x1a; xa \\<in> new x1;\n        prop\\<^sub>r(x4) \\<notin> old x1a;\n        prop\\<^sub>r(x4) \\<notin> old x1\\<rbrakk>\n       \\<Longrightarrow> expand\n                          (x1a\\<lparr>new := new x1a - {nprop\\<^sub>r(x4)},\n                                 old :=\n                                   insert nprop\\<^sub>r(x4)\n                                    (old x1a)\\<rparr>,\n                           x2a)\n                         \\<le> \\<Down> R\n                                (expanda\n                                  (x1\\<lparr>new :=\n         new x1 - {nprop\\<^sub>r(x4)},\n  old := insert nprop\\<^sub>r(x4) (old x1)\\<rparr>,\n                                   x2))\nA total of 6 subgoals...", "apply (auto simp: R_def R'_def) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa x51 x52.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; x51 and\\<^sub>r x52 \\<in> new x1a;\n        x51 and\\<^sub>r x52 \\<in> new x1; x \\<in> new x1a;\n        xa \\<in> new x1\\<rbrakk>\n       \\<Longrightarrow> expand\n                          (x1a\\<lparr>new :=\n  insert x51 (insert x52 (new x1a - {x51 and\\<^sub>r x52})),\n                                 old :=\n                                   insert (x51 and\\<^sub>r x52)\n                                    (old x1a)\\<rparr>,\n                           x2a)\n                         \\<le> \\<Down> R\n                                (expanda\n                                  (x1\\<lparr>new :=\n         insert x51 (insert x52 (new x1 - {x51 and\\<^sub>r x52})),\n  old := insert (x51 and\\<^sub>r x52) (old x1)\\<rparr>,\n                                   x2))\nA total of 5 subgoals...", "apply (auto simp: R_def R'_def) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa x61 x62.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; x61 or\\<^sub>r x62 \\<in> new x1a;\n        x61 or\\<^sub>r x62 \\<in> new x1; x \\<in> new x1a;\n        xa \\<in> new x1\\<rbrakk>\n       \\<Longrightarrow> expand\n                          (x1a\\<lparr>new :=\n  insert x61 (new x1a - {x61 or\\<^sub>r x62}),\n                                 old :=\n                                   insert (x61 or\\<^sub>r x62)\n                                    (old x1a)\\<rparr>,\n                           x2a) \\<bind>\n                         (\\<lambda>(nm, nds).\n                             expand\n                              (x1a\\<lparr>name := nm,\n                                     new :=\n insert x62 (new x1a - {x61 or\\<^sub>r x62}),\n                                     old :=\n insert (x61 or\\<^sub>r x62) (old x1a)\\<rparr>,\n                               nds))\n                         \\<le> \\<Down> R\n                                (expanda\n                                  (x1\\<lparr>new :=\n         insert x61 (new x1 - {x61 or\\<^sub>r x62}),\n  old := insert (x61 or\\<^sub>r x62) (old x1)\\<rparr>,\n                                   x2) \\<bind>\n                                 (\\<lambda>(nm, nds).\n                                     expanda\n(x1\\<lparr>name := nm, new := insert x62 (new x1 - {x61 or\\<^sub>r x62}),\n      old := insert (x61 or\\<^sub>r x62) (old x1)\\<rparr>,\n nds)))\nA total of 4 subgoals...", "apply (refine_rcg, rprems, (fastforce simp: R_def R'_def)+) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa x7.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; X\\<^sub>r x7 \\<in> new x1a;\n        X\\<^sub>r x7 \\<in> new x1; x \\<in> new x1a; xa \\<in> new x1\\<rbrakk>\n       \\<Longrightarrow> expand\n                          (x1a\\<lparr>new := new x1a - {X\\<^sub>r x7},\n                                 old := insert (X\\<^sub>r x7) (old x1a),\n                                 next := insert x7 (next x1a)\\<rparr>,\n                           x2a)\n                         \\<le> \\<Down> R\n                                (expanda\n                                  (x1\\<lparr>new := new x1 - {X\\<^sub>r x7},\n  old := insert (X\\<^sub>r x7) (old x1),\n  next := insert x7 (next x1)\\<rparr>,\n                                   x2))\nA total of 3 subgoals...", "apply (fastforce simp: R'_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa x81 x82.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; x81 U\\<^sub>r x82 \\<in> new x1a;\n        x81 U\\<^sub>r x82 \\<in> new x1; x \\<in> new x1a;\n        xa \\<in> new x1\\<rbrakk>\n       \\<Longrightarrow> expand\n                          (x1a\\<lparr>new :=\n  insert x81 (new x1a - {x81 U\\<^sub>r x82}),\n                                 old :=\n                                   insert (x81 U\\<^sub>r x82) (old x1a),\n                                 next :=\n                                   insert (x81 U\\<^sub>r x82)\n                                    (next x1a)\\<rparr>,\n                           x2a) \\<bind>\n                         (\\<lambda>(nm, nds).\n                             expand\n                              (x1a\\<lparr>name := nm,\n                                     new :=\n insert x82 (new x1a - {x81 U\\<^sub>r x82}),\n                                     old :=\n insert (x81 U\\<^sub>r x82) (old x1a)\\<rparr>,\n                               nds))\n                         \\<le> \\<Down> R\n                                (expanda\n                                  (x1\\<lparr>new :=\n         insert x81 (new x1 - {x81 U\\<^sub>r x82}),\n  old := insert (x81 U\\<^sub>r x82) (old x1),\n  next := insert (x81 U\\<^sub>r x82) (next x1)\\<rparr>,\n                                   x2) \\<bind>\n                                 (\\<lambda>(nm, nds).\n                                     expanda\n(x1\\<lparr>name := nm, new := insert x82 (new x1 - {x81 U\\<^sub>r x82}),\n      old := insert (x81 U\\<^sub>r x82) (old x1)\\<rparr>,\n nds)))\nA total of 2 subgoals...", "apply (refine_rcg, rprems, (fastforce simp: R_def R'_def)+) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>expand expanda x1 x2 x1a x2a x xa x91 x92.\n       \\<lbrakk>\\<And>a b aa ba.\n                   ((a, b), aa, ba) \\<in> R' \\<Longrightarrow>\n                   expand (a, b) \\<le> \\<Down> R (expanda (aa, ba));\n        ((x1a, x2a), x1, x2) \\<in> R'; x91 R\\<^sub>r x92 \\<in> new x1a;\n        x91 R\\<^sub>r x92 \\<in> new x1; x \\<in> new x1a;\n        xa \\<in> new x1\\<rbrakk>\n       \\<Longrightarrow> expand\n                          (x1a\\<lparr>new :=\n  insert x92 (new x1a - {x91 R\\<^sub>r x92}),\n                                 old :=\n                                   insert (x91 R\\<^sub>r x92) (old x1a),\n                                 next :=\n                                   insert (x91 R\\<^sub>r x92)\n                                    (next x1a)\\<rparr>,\n                           x2a) \\<bind>\n                         (\\<lambda>(nm, nds).\n                             expand\n                              (x1a\\<lparr>name := nm,\n                                     new :=\n insert x91 (insert x92 (new x1a - {x91 R\\<^sub>r x92})),\n                                     old :=\n insert (x91 R\\<^sub>r x92) (old x1a)\\<rparr>,\n                               nds))\n                         \\<le> \\<Down> R\n                                (expanda\n                                  (x1\\<lparr>new :=\n         insert x92 (new x1 - {x91 R\\<^sub>r x92}),\n  old := insert (x91 R\\<^sub>r x92) (old x1),\n  next := insert (x91 R\\<^sub>r x92) (next x1)\\<rparr>,\n                                   x2) \\<bind>\n                                 (\\<lambda>(nm, nds).\n                                     expanda\n(x1\\<lparr>name := nm,\n      new := insert x91 (insert x92 (new x1 - {x91 R\\<^sub>r x92})),\n      old := insert (x91 R\\<^sub>r x92) (old x1)\\<rparr>,\n nds)))", "apply (refine_rcg, rprems, (fastforce simp: R_def R'_def)+) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  expand_aimpl n_ns' \\<le> \\<Down> R (expand\\<^sub>T n_ns)\n\ngoal:\nNo subgoals!", "qed"], ["", "thm create_graph_def"], ["", "definition \"create_graph_aimpl \\<phi> = do {\n  (_, nds) \\<leftarrow>\n  expand_aimpl\n   (\\<lparr>name = expand_new_name expand_init, incoming = {expand_init},\n       new = {\\<phi>}, old = {}, next = {}\\<rparr>,\n    {});\n  RETURN nds\n}\""], ["", "lemma create_graph_aimpl_refine: \"create_graph_aimpl \\<phi> \\<le> \\<Down>Id (create_graph\\<^sub>T \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. create_graph_aimpl \\<phi> \\<le> \\<Down> Id (create_graph\\<^sub>T \\<phi>)", "unfolding create_graph_aimpl_def create_graph\\<^sub>T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expand_aimpl\n     (\\<lparr>name = expand_new_name expand_init, incoming = {expand_init},\n         new = {\\<phi>}, old = {}, next = {}\\<rparr>,\n      {}) \\<bind>\n    (\\<lambda>(uu_, y). RETURN y)\n    \\<le> \\<Down> Id\n           (expand\\<^sub>T\n             (\\<lparr>name = expand_new_name expand_init,\n                 incoming = {expand_init}, new = {\\<phi>}, old = {},\n                 next = {}\\<rparr>,\n              {}) \\<bind>\n            (\\<lambda>(uu_, nds). RETURN nds))", "apply (refine_rcg expand_aimpl_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((\\<lparr>name = expand_new_name expand_init, incoming = {expand_init},\n         new = {\\<phi>}, old = {}, next = {}\\<rparr>,\n      {}),\n     \\<lparr>name = expand_new_name expand_init, incoming = {expand_init},\n        new = {\\<phi>}, old = {}, next = {}\\<rparr>,\n     {})\n    \\<in> Id \\<inter> {(uu_, n, ns). \\<forall>n'\\<in>ns. name n' < name n}\n 2. \\<And>x x' x1 x2 x1a x2a.\n       \\<lbrakk>(x, x')\n                \\<in> Id \\<inter>\n                      {(uu_, n, ns). \\<forall>n'\\<in>ns. name n' < n};\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> Id", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Creation of GBA from Nodes\\<close>"], ["", "text \\<open>\n  We summarize creation of the GBA and renaming of the nodes into one step\n\\<close>"], ["", "lemma create_name_gba_alt: \"create_name_gba \\<phi> = do {\n  nds \\<leftarrow> create_graph\\<^sub>T \\<phi>;\n  ASSERT (nds_invars nds);\n  RETURN (gba_rename_ext (\\<lambda>_. ()) name (create_gba_from_nodes \\<phi> nds))\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. create_name_gba \\<phi> =\n    create_graph\\<^sub>T \\<phi> \\<bind>\n    (\\<lambda>nds.\n        ASSERT (nds_invars nds) \\<bind>\n        (\\<lambda>_.\n            RETURN (gba_rename name (create_gba_from_nodes \\<phi> nds))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. create_name_gba \\<phi> =\n    create_graph\\<^sub>T \\<phi> \\<bind>\n    (\\<lambda>nds.\n        ASSERT (nds_invars nds) \\<bind>\n        (\\<lambda>_.\n            RETURN (gba_rename name (create_gba_from_nodes \\<phi> nds))))", "have [simp]: \"\\<And>nds. g_V (create_gba_from_nodes \\<phi> nds) = nds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nds. g_V (create_gba_from_nodes \\<phi> nds) = nds", "by (auto simp: create_gba_from_nodes_def)"], ["proof (state)\nthis:\n  g_V (create_gba_from_nodes \\<phi> ?nds) = ?nds\n\ngoal (1 subgoal):\n 1. create_name_gba \\<phi> =\n    create_graph\\<^sub>T \\<phi> \\<bind>\n    (\\<lambda>nds.\n        ASSERT (nds_invars nds) \\<bind>\n        (\\<lambda>_.\n            RETURN (gba_rename name (create_gba_from_nodes \\<phi> nds))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. create_name_gba \\<phi> =\n    create_graph\\<^sub>T \\<phi> \\<bind>\n    (\\<lambda>nds.\n        ASSERT (nds_invars nds) \\<bind>\n        (\\<lambda>_.\n            RETURN (gba_rename name (create_gba_from_nodes \\<phi> nds))))", "unfolding create_name_gba_def create_gba_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. create_graph\\<^sub>T \\<phi> \\<bind>\n    (\\<lambda>nds. RETURN (create_gba_from_nodes \\<phi> nds)) \\<bind>\n    (\\<lambda>G.\n        ASSERT (nds_invars (g_V G)) \\<bind>\n        (\\<lambda>_. RETURN (gba_rename name G))) =\n    create_graph\\<^sub>T \\<phi> \\<bind>\n    (\\<lambda>nds.\n        ASSERT (nds_invars nds) \\<bind>\n        (\\<lambda>_.\n            RETURN (gba_rename name (create_gba_from_nodes \\<phi> nds))))", "by simp"], ["proof (state)\nthis:\n  create_name_gba \\<phi> =\n  create_graph\\<^sub>T \\<phi> \\<bind>\n  (\\<lambda>nds.\n      ASSERT (nds_invars nds) \\<bind>\n      (\\<lambda>_.\n          RETURN (gba_rename name (create_gba_from_nodes \\<phi> nds))))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the following, we implement the componenents of the\n  renamed GBA separately.\n\\<close>"], ["", "text \\<open>\\paragraph{Successor Function}\\<close>"], ["", "definition \"build_succ nds = \n  FOREACH \n    nds (\\<lambda>q' s.\n    FOREACH\n      (incoming q') (\\<lambda>qn s. \n        if qn=expand_init then \n          RETURN s \n        else \n          RETURN (s(qn \\<mapsto> insert (name q') (the_default {} (s qn))))\n    ) s\n  ) Map.empty\""], ["", "lemma build_succ_aux1:\n  assumes [simp]: \"finite nds\"\n  assumes [simp]: \"\\<And>q. q\\<in>nds \\<Longrightarrow> finite (incoming q)\"\n  shows \"build_succ nds \\<le> SPEC (\\<lambda>r. r = (\\<lambda>qn. \n  dflt_None_set {qn'. \\<exists>q'. \n    q'\\<in>nds \\<and> qn' = name q' \\<and> qn\\<in>incoming q' \\<and> qn\\<noteq>expand_init \n  }))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build_succ nds\n    \\<le> SPEC\n           (\\<lambda>r.\n               r =\n               (\\<lambda>qn.\n                   dflt_None_set\n                    {qn'.\n                     \\<exists>q'.\n                        q' \\<in> nds \\<and>\n                        qn' = name q' \\<and>\n                        qn \\<in> incoming q' \\<and>\n                        qn \\<noteq> expand_init}))", "unfolding build_succ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH nds\n     (\\<lambda>q'.\n         FOREACH (incoming q')\n          (\\<lambda>qn s.\n              if qn = expand_init then RETURN s\n              else RETURN\n                    (s(qn \\<mapsto>\n                     insert (name q') (the_default {} (s qn))))))\n     Map.empty\n    \\<le> SPEC\n           (\\<lambda>r.\n               r =\n               (\\<lambda>qn.\n                   dflt_None_set\n                    {qn'.\n                     \\<exists>q'.\n                        q' \\<in> nds \\<and>\n                        qn' = name q' \\<and>\n                        qn \\<in> incoming q' \\<and>\n                        qn \\<noteq> expand_init}))", "apply (refine_rcg refine_vcg \n    FOREACH_rule[where\n      I=\"\\<lambda>it s. s = (\\<lambda>qn. dflt_None_set {qn'. \\<exists>q'. q'\\<in>nds-it \\<and> qn' = name q' \n    \\<and> qn\\<in>incoming q' \\<and> qn\\<noteq>expand_init })\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite nds\n 2. Map.empty =\n    (\\<lambda>qn.\n        dflt_None_set\n         {qn'.\n          \\<exists>q'.\n             q' \\<in> nds - nds \\<and>\n             qn' = name q' \\<and>\n             qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init})\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> nds;\n        \\<sigma> =\n        (\\<lambda>qn.\n            dflt_None_set\n             {qn'.\n              \\<exists>q'.\n                 q' \\<in> nds - it \\<and>\n                 qn' = name q' \\<and>\n                 qn \\<in> incoming q' \\<and>\n                 qn \\<noteq> expand_init})\\<rbrakk>\n       \\<Longrightarrow> FOREACH (incoming x)\n                          (\\<lambda>qn s.\n                              if qn = expand_init then RETURN s\n                              else RETURN\n                                    (s(qn \\<mapsto>\n                                     insert (name x)\n(the_default {} (s qn)))))\n                          \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s =\n                                    (\\<lambda>qn.\n  dflt_None_set\n   {qn'.\n    \\<exists>q'.\n       q' \\<in> nds - (it - {x}) \\<and>\n       qn' = name q' \\<and>\n       qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}))\n 4. \\<And>\\<sigma>.\n       \\<sigma> =\n       (\\<lambda>qn.\n           dflt_None_set\n            {qn'.\n             \\<exists>q'.\n                q' \\<in> nds - {} \\<and>\n                qn' = name q' \\<and>\n                qn \\<in> incoming q' \\<and>\n                qn \\<noteq> expand_init}) \\<Longrightarrow>\n       \\<sigma> =\n       (\\<lambda>qn.\n           dflt_None_set\n            {qn'.\n             \\<exists>q'.\n                q' \\<in> nds \\<and>\n                qn' = name q' \\<and>\n                qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init})", "apply (simp_all add: dflt_None_set_def) [2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> nds;\n        \\<sigma> =\n        (\\<lambda>qn.\n            dflt_None_set\n             {qn'.\n              \\<exists>q'.\n                 q' \\<in> nds - it \\<and>\n                 qn' = name q' \\<and>\n                 qn \\<in> incoming q' \\<and>\n                 qn \\<noteq> expand_init})\\<rbrakk>\n       \\<Longrightarrow> FOREACH (incoming x)\n                          (\\<lambda>qn s.\n                              if qn = expand_init then RETURN s\n                              else RETURN\n                                    (s(qn \\<mapsto>\n                                     insert (name x)\n(the_default {} (s qn)))))\n                          \\<sigma>\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s =\n                                    (\\<lambda>qn.\n  dflt_None_set\n   {qn'.\n    \\<exists>q'.\n       q' \\<in> nds - (it - {x}) \\<and>\n       qn' = name q' \\<and>\n       qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}))\n 2. \\<And>\\<sigma>.\n       \\<sigma> =\n       (\\<lambda>qn.\n           dflt_None_set\n            {qn'.\n             \\<exists>q'.\n                q' \\<in> nds - {} \\<and>\n                qn' = name q' \\<and>\n                qn \\<in> incoming q' \\<and>\n                qn \\<noteq> expand_init}) \\<Longrightarrow>\n       \\<sigma> =\n       (\\<lambda>qn.\n           dflt_None_set\n            {qn'.\n             \\<exists>q'.\n                q' \\<in> nds \\<and>\n                qn' = name q' \\<and>\n                qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init})", "apply (rename_tac q' it s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q' it s.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            dflt_None_set\n             {qn'.\n              \\<exists>q'.\n                 q' \\<in> nds - it \\<and>\n                 qn' = name q' \\<and>\n                 qn \\<in> incoming q' \\<and>\n                 qn \\<noteq> expand_init})\\<rbrakk>\n       \\<Longrightarrow> FOREACH (incoming q')\n                          (\\<lambda>qn s.\n                              if qn = expand_init then RETURN s\n                              else RETURN\n                                    (s(qn \\<mapsto>\n                                     insert (name q')\n(the_default {} (s qn)))))\n                          s\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s =\n                                    (\\<lambda>qn.\n  dflt_None_set\n   {qn'.\n    \\<exists>q'a.\n       q'a \\<in> nds - (it - {q'}) \\<and>\n       qn' = name q'a \\<and>\n       qn \\<in> incoming q'a \\<and> qn \\<noteq> expand_init}))\n 2. \\<And>\\<sigma>.\n       \\<sigma> =\n       (\\<lambda>qn.\n           dflt_None_set\n            {qn'.\n             \\<exists>q'.\n                q' \\<in> nds - {} \\<and>\n                qn' = name q' \\<and>\n                qn \\<in> incoming q' \\<and>\n                qn \\<noteq> expand_init}) \\<Longrightarrow>\n       \\<sigma> =\n       (\\<lambda>qn.\n           dflt_None_set\n            {qn'.\n             \\<exists>q'.\n                q' \\<in> nds \\<and>\n                qn' = name q' \\<and>\n                qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init})", "apply (rule_tac I=\"\\<lambda>it2 s. s = \n    (\\<lambda>qn. dflt_None_set (\n      {qn'. \\<exists>q'. q'\\<in>nds-it \\<and> qn' = name q' \\<and> qn\\<in>incoming q' \\<and> qn\\<noteq>expand_init } \\<union> \n      {qn' . qn'=name q' \\<and> qn\\<in>incoming q' - it2 \\<and> qn\\<noteq>expand_init} ))\" \n    in FOREACH_rule)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>q' it s.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            dflt_None_set\n             {qn'.\n              \\<exists>q'.\n                 q' \\<in> nds - it \\<and>\n                 qn' = name q' \\<and>\n                 qn \\<in> incoming q' \\<and>\n                 qn \\<noteq> expand_init})\\<rbrakk>\n       \\<Longrightarrow> finite (incoming q')\n 2. \\<And>q' it s.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            dflt_None_set\n             {qn'.\n              \\<exists>q'.\n                 q' \\<in> nds - it \\<and>\n                 qn' = name q' \\<and>\n                 qn \\<in> incoming q' \\<and>\n                 qn \\<noteq> expand_init})\\<rbrakk>\n       \\<Longrightarrow> s =\n                         (\\<lambda>qn.\n                             dflt_None_set\n                              ({qn'.\n                                \\<exists>q'.\n                                   q' \\<in> nds - it \\<and>\n                                   qn' = name q' \\<and>\n                                   qn \\<in> incoming q' \\<and>\n                                   qn \\<noteq> expand_init} \\<union>\n                               {qn'.\n                                qn' = name q' \\<and>\n                                qn \\<in> incoming q' - incoming q' \\<and>\n                                qn \\<noteq> expand_init}))\n 3. \\<And>q' it s x ita \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            dflt_None_set\n             {qn'.\n              \\<exists>q'.\n                 q' \\<in> nds - it \\<and>\n                 qn' = name q' \\<and>\n                 qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        x \\<in> ita; ita \\<subseteq> incoming q';\n        \\<sigma> =\n        (\\<lambda>qn.\n            dflt_None_set\n             ({qn'.\n               \\<exists>q'.\n                  q' \\<in> nds - it \\<and>\n                  qn' = name q' \\<and>\n                  qn \\<in> incoming q' \\<and>\n                  qn \\<noteq> expand_init} \\<union>\n              {qn'.\n               qn' = name q' \\<and>\n               qn \\<in> incoming q' - ita \\<and>\n               qn \\<noteq> expand_init}))\\<rbrakk>\n       \\<Longrightarrow> (if x = expand_init then RETURN \\<sigma>\n                          else RETURN\n                                (\\<sigma>(x \\<mapsto>\n                                 insert (name q')\n                                  (the_default {} (\\<sigma> x)))))\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s =\n                                    (\\<lambda>qn.\n  dflt_None_set\n   ({qn'.\n     \\<exists>q'.\n        q' \\<in> nds - it \\<and>\n        qn' = name q' \\<and>\n        qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n    {qn'.\n     qn' = name q' \\<and>\n     qn \\<in> incoming q' - (ita - {x}) \\<and> qn \\<noteq> expand_init})))\n 4. \\<And>q' it s \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            dflt_None_set\n             {qn'.\n              \\<exists>q'.\n                 q' \\<in> nds - it \\<and>\n                 qn' = name q' \\<and>\n                 qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        \\<sigma> =\n        (\\<lambda>qn.\n            dflt_None_set\n             ({qn'.\n               \\<exists>q'.\n                  q' \\<in> nds - it \\<and>\n                  qn' = name q' \\<and>\n                  qn \\<in> incoming q' \\<and>\n                  qn \\<noteq> expand_init} \\<union>\n              {qn'.\n               qn' = name q' \\<and>\n               qn \\<in> incoming q' - {} \\<and>\n               qn \\<noteq> expand_init}))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> =\n                         (\\<lambda>qn.\n                             dflt_None_set\n                              {qn'.\n                               \\<exists>q'a.\n                                  q'a \\<in> nds - (it - {q'}) \\<and>\n                                  qn' = name q'a \\<and>\n                                  qn \\<in> incoming q'a \\<and>\n                                  qn \\<noteq> expand_init})\n 5. \\<And>\\<sigma>.\n       \\<sigma> =\n       (\\<lambda>qn.\n           dflt_None_set\n            {qn'.\n             \\<exists>q'.\n                q' \\<in> nds - {} \\<and>\n                qn' = name q' \\<and>\n                qn \\<in> incoming q' \\<and>\n                qn \\<noteq> expand_init}) \\<Longrightarrow>\n       \\<sigma> =\n       (\\<lambda>qn.\n           dflt_None_set\n            {qn'.\n             \\<exists>q'.\n                q' \\<in> nds \\<and>\n                qn' = name q' \\<and>\n                qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init})", "apply auto []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>q' it s.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            dflt_None_set\n             {qn'.\n              \\<exists>q'.\n                 q' \\<in> nds - it \\<and>\n                 qn' = name q' \\<and>\n                 qn \\<in> incoming q' \\<and>\n                 qn \\<noteq> expand_init})\\<rbrakk>\n       \\<Longrightarrow> s =\n                         (\\<lambda>qn.\n                             dflt_None_set\n                              ({qn'.\n                                \\<exists>q'.\n                                   q' \\<in> nds - it \\<and>\n                                   qn' = name q' \\<and>\n                                   qn \\<in> incoming q' \\<and>\n                                   qn \\<noteq> expand_init} \\<union>\n                               {qn'.\n                                qn' = name q' \\<and>\n                                qn \\<in> incoming q' - incoming q' \\<and>\n                                qn \\<noteq> expand_init}))\n 2. \\<And>q' it s x ita \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            dflt_None_set\n             {qn'.\n              \\<exists>q'.\n                 q' \\<in> nds - it \\<and>\n                 qn' = name q' \\<and>\n                 qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        x \\<in> ita; ita \\<subseteq> incoming q';\n        \\<sigma> =\n        (\\<lambda>qn.\n            dflt_None_set\n             ({qn'.\n               \\<exists>q'.\n                  q' \\<in> nds - it \\<and>\n                  qn' = name q' \\<and>\n                  qn \\<in> incoming q' \\<and>\n                  qn \\<noteq> expand_init} \\<union>\n              {qn'.\n               qn' = name q' \\<and>\n               qn \\<in> incoming q' - ita \\<and>\n               qn \\<noteq> expand_init}))\\<rbrakk>\n       \\<Longrightarrow> (if x = expand_init then RETURN \\<sigma>\n                          else RETURN\n                                (\\<sigma>(x \\<mapsto>\n                                 insert (name q')\n                                  (the_default {} (\\<sigma> x)))))\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s =\n                                    (\\<lambda>qn.\n  dflt_None_set\n   ({qn'.\n     \\<exists>q'.\n        q' \\<in> nds - it \\<and>\n        qn' = name q' \\<and>\n        qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n    {qn'.\n     qn' = name q' \\<and>\n     qn \\<in> incoming q' - (ita - {x}) \\<and> qn \\<noteq> expand_init})))\n 3. \\<And>q' it s \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            dflt_None_set\n             {qn'.\n              \\<exists>q'.\n                 q' \\<in> nds - it \\<and>\n                 qn' = name q' \\<and>\n                 qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        \\<sigma> =\n        (\\<lambda>qn.\n            dflt_None_set\n             ({qn'.\n               \\<exists>q'.\n                  q' \\<in> nds - it \\<and>\n                  qn' = name q' \\<and>\n                  qn \\<in> incoming q' \\<and>\n                  qn \\<noteq> expand_init} \\<union>\n              {qn'.\n               qn' = name q' \\<and>\n               qn \\<in> incoming q' - {} \\<and>\n               qn \\<noteq> expand_init}))\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> =\n                         (\\<lambda>qn.\n                             dflt_None_set\n                              {qn'.\n                               \\<exists>q'a.\n                                  q'a \\<in> nds - (it - {q'}) \\<and>\n                                  qn' = name q'a \\<and>\n                                  qn \\<in> incoming q'a \\<and>\n                                  qn \\<noteq> expand_init})\n 4. \\<And>\\<sigma>.\n       \\<sigma> =\n       (\\<lambda>qn.\n           dflt_None_set\n            {qn'.\n             \\<exists>q'.\n                q' \\<in> nds - {} \\<and>\n                qn' = name q' \\<and>\n                qn \\<in> incoming q' \\<and>\n                qn \\<noteq> expand_init}) \\<Longrightarrow>\n       \\<sigma> =\n       (\\<lambda>qn.\n           dflt_None_set\n            {qn'.\n             \\<exists>q'.\n                q' \\<in> nds \\<and>\n                qn' = name q' \\<and>\n                qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init})", "apply (simp_all add: dflt_None_set_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q' it s x ita \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            if \\<forall>q'.\n                  qn \\<in> incoming q' \\<longrightarrow>\n                  q' \\<in> nds \\<longrightarrow>\n                  q' \\<in> it \\<or> qn = expand_init\n            then None\n            else Some\n                  {qn'.\n                   \\<exists>q'.\n                      q' \\<in> nds \\<and>\n                      q' \\<notin> it \\<and>\n                      qn' = name q' \\<and>\n                      qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        x \\<in> ita; ita \\<subseteq> incoming q';\n        \\<sigma> =\n        (\\<lambda>qn.\n            if (\\<forall>q'.\n                   qn \\<in> incoming q' \\<longrightarrow>\n                   q' \\<in> nds \\<longrightarrow>\n                   q' \\<in> it \\<or> qn = expand_init) \\<and>\n               (qn \\<in> incoming q' \\<longrightarrow>\n                qn \\<in> ita \\<or> qn = expand_init)\n            then None\n            else Some\n                  ({qn'.\n                    \\<exists>q'.\n                       q' \\<in> nds \\<and>\n                       q' \\<notin> it \\<and>\n                       qn' = name q' \\<and>\n                       qn \\<in> incoming q' \\<and>\n                       qn \\<noteq> expand_init} \\<union>\n                   {qn'.\n                    qn' = name q' \\<and>\n                    qn \\<in> incoming q' \\<and>\n                    qn \\<notin> ita \\<and>\n                    qn \\<noteq> expand_init}))\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>q'.\n                              x \\<in> incoming q' \\<longrightarrow>\n                              q' \\<in> nds \\<longrightarrow>\n                              q' \\<in> it) \\<longrightarrow>\n                          (x = expand_init \\<longrightarrow>\n                           (\\<lambda>qn.\n                               if (\\<forall>q'.\nqn \\<in> incoming q' \\<longrightarrow>\nq' \\<in> nds \\<longrightarrow> q' \\<in> it \\<or> qn = expand_init) \\<and>\n                                  (qn \\<in> incoming q' \\<longrightarrow>\n                                   qn \\<in> ita \\<or> qn = expand_init)\n                               then None\n                               else Some\n                                     ({qn'.\n \\<exists>q'.\n    q' \\<in> nds \\<and>\n    q' \\<notin> it \\<and>\n    qn' = name q' \\<and>\n    qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n{qn'.\n qn' = name q' \\<and>\n qn \\<in> incoming q' \\<and>\n qn \\<notin> ita \\<and> qn \\<noteq> expand_init})) =\n                           (\\<lambda>qn.\n                               if (\\<forall>q'.\nqn \\<in> incoming q' \\<longrightarrow>\nq' \\<in> nds \\<longrightarrow> q' \\<in> it \\<or> qn = expand_init) \\<and>\n                                  (qn \\<in> incoming q' \\<longrightarrow>\n                                   qn \\<in> ita \\<and>\n                                   qn \\<noteq> expand_init \\<or>\n                                   qn = expand_init)\n                               then None\n                               else Some\n                                     ({qn'.\n \\<exists>q'.\n    q' \\<in> nds \\<and>\n    q' \\<notin> it \\<and>\n    qn' = name q' \\<and>\n    qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n{qn'.\n qn' = name q' \\<and>\n qn \\<in> incoming q' \\<and>\n (qn \\<in> ita \\<longrightarrow> qn = x) \\<and>\n qn \\<noteq> expand_init}))) \\<and>\n                          (x \\<noteq> expand_init \\<longrightarrow>\n                           (\\<lambda>qn.\n                               if (\\<forall>q'.\nqn \\<in> incoming q' \\<longrightarrow>\nq' \\<in> nds \\<longrightarrow> q' \\<in> it \\<or> qn = expand_init) \\<and>\n                                  (qn \\<in> incoming q' \\<longrightarrow>\n                                   qn \\<in> ita \\<or> qn = expand_init)\n                               then None\n                               else Some\n                                     ({qn'.\n \\<exists>q'.\n    q' \\<in> nds \\<and>\n    q' \\<notin> it \\<and>\n    qn' = name q' \\<and>\n    qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n{qn'.\n qn' = name q' \\<and>\n qn \\<in> incoming q' \\<and>\n qn \\<notin> ita \\<and> qn \\<noteq> expand_init}))\n                           (x \\<mapsto> {name q'}) =\n                           (\\<lambda>qn.\n                               if (\\<forall>q'.\nqn \\<in> incoming q' \\<longrightarrow>\nq' \\<in> nds \\<longrightarrow> q' \\<in> it \\<or> qn = expand_init) \\<and>\n                                  (qn \\<in> incoming q' \\<longrightarrow>\n                                   qn \\<in> ita \\<and> qn \\<noteq> x \\<or>\n                                   qn = expand_init)\n                               then None\n                               else Some\n                                     ({qn'.\n \\<exists>q'.\n    q' \\<in> nds \\<and>\n    q' \\<notin> it \\<and>\n    qn' = name q' \\<and>\n    qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n{qn'.\n qn' = name q' \\<and>\n qn \\<in> incoming q' \\<and>\n (qn \\<in> ita \\<longrightarrow> qn = x) \\<and>\n qn \\<noteq> expand_init})))) \\<and>\n                         ((\\<exists>q'.\n                              x \\<in> incoming q' \\<and>\n                              q' \\<in> nds \\<and>\n                              q' \\<notin> it) \\<longrightarrow>\n                          (x = expand_init \\<longrightarrow>\n                           (\\<lambda>qn.\n                               if (\\<forall>q'.\nqn \\<in> incoming q' \\<longrightarrow>\nq' \\<in> nds \\<longrightarrow> q' \\<in> it \\<or> qn = expand_init) \\<and>\n                                  (qn \\<in> incoming q' \\<longrightarrow>\n                                   qn \\<in> ita \\<or> qn = expand_init)\n                               then None\n                               else Some\n                                     ({qn'.\n \\<exists>q'.\n    q' \\<in> nds \\<and>\n    q' \\<notin> it \\<and>\n    qn' = name q' \\<and>\n    qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n{qn'.\n qn' = name q' \\<and>\n qn \\<in> incoming q' \\<and>\n qn \\<notin> ita \\<and> qn \\<noteq> expand_init})) =\n                           (\\<lambda>qn.\n                               if (\\<forall>q'.\nqn \\<in> incoming q' \\<longrightarrow>\nq' \\<in> nds \\<longrightarrow> q' \\<in> it \\<or> qn = expand_init) \\<and>\n                                  (qn \\<in> incoming q' \\<longrightarrow>\n                                   qn \\<in> ita \\<and>\n                                   qn \\<noteq> expand_init \\<or>\n                                   qn = expand_init)\n                               then None\n                               else Some\n                                     ({qn'.\n \\<exists>q'.\n    q' \\<in> nds \\<and>\n    q' \\<notin> it \\<and>\n    qn' = name q' \\<and>\n    qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n{qn'.\n qn' = name q' \\<and>\n qn \\<in> incoming q' \\<and>\n (qn \\<in> ita \\<longrightarrow> qn = x) \\<and>\n qn \\<noteq> expand_init}))) \\<and>\n                          (x \\<noteq> expand_init \\<longrightarrow>\n                           (\\<lambda>qn.\n                               if (\\<forall>q'.\nqn \\<in> incoming q' \\<longrightarrow>\nq' \\<in> nds \\<longrightarrow> q' \\<in> it \\<or> qn = expand_init) \\<and>\n                                  (qn \\<in> incoming q' \\<longrightarrow>\n                                   qn \\<in> ita \\<or> qn = expand_init)\n                               then None\n                               else Some\n                                     ({qn'.\n \\<exists>q'.\n    q' \\<in> nds \\<and>\n    q' \\<notin> it \\<and>\n    qn' = name q' \\<and>\n    qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n{qn'.\n qn' = name q' \\<and>\n qn \\<in> incoming q' \\<and>\n qn \\<notin> ita \\<and> qn \\<noteq> expand_init}))\n                           (x \\<mapsto>\n                           insert (name q')\n                            {qn'.\n                             \\<exists>q'.\n                                q' \\<in> nds \\<and>\n                                q' \\<notin> it \\<and>\n                                qn' = name q' \\<and> x \\<in> incoming q'}) =\n                           (\\<lambda>qn.\n                               if (\\<forall>q'.\nqn \\<in> incoming q' \\<longrightarrow>\nq' \\<in> nds \\<longrightarrow> q' \\<in> it \\<or> qn = expand_init) \\<and>\n                                  (qn \\<in> incoming q' \\<longrightarrow>\n                                   qn \\<in> ita \\<and> qn \\<noteq> x \\<or>\n                                   qn = expand_init)\n                               then None\n                               else Some\n                                     ({qn'.\n \\<exists>q'.\n    q' \\<in> nds \\<and>\n    q' \\<notin> it \\<and>\n    qn' = name q' \\<and>\n    qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n{qn'.\n qn' = name q' \\<and>\n qn \\<in> incoming q' \\<and>\n (qn \\<in> ita \\<longrightarrow> qn = x) \\<and> qn \\<noteq> expand_init}))))\n 2. \\<And>q' it s \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            if \\<forall>q'.\n                  qn \\<in> incoming q' \\<longrightarrow>\n                  q' \\<in> nds \\<longrightarrow>\n                  q' \\<in> it \\<or> qn = expand_init\n            then None\n            else Some\n                  {qn'.\n                   \\<exists>q'.\n                      q' \\<in> nds \\<and>\n                      q' \\<notin> it \\<and>\n                      qn' = name q' \\<and>\n                      qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        \\<sigma> =\n        (\\<lambda>qn.\n            if (\\<forall>q'.\n                   qn \\<in> incoming q' \\<longrightarrow>\n                   q' \\<in> nds \\<longrightarrow>\n                   q' \\<in> it \\<or> qn = expand_init) \\<and>\n               (qn \\<in> incoming q' \\<longrightarrow> qn = expand_init)\n            then None\n            else Some\n                  ({qn'.\n                    \\<exists>q'.\n                       q' \\<in> nds \\<and>\n                       q' \\<notin> it \\<and>\n                       qn' = name q' \\<and>\n                       qn \\<in> incoming q' \\<and>\n                       qn \\<noteq> expand_init} \\<union>\n                   {qn'.\n                    qn' = name q' \\<and>\n                    qn \\<in> incoming q' \\<and>\n                    qn \\<noteq> expand_init}))\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     qn \\<noteq> expand_init})) =\n                         (\\<lambda>qn.\n                             if \\<forall>q'a.\n                                   qn \\<in> incoming q'a \\<longrightarrow>\n                                   q'a \\<in> nds \\<longrightarrow>\n                                   q'a \\<in> it \\<and> q'a \\<noteq> q' \\<or>\n                                   qn = expand_init\n                             then None\n                             else Some\n                                   {qn'.\n                                    \\<exists>q'a.\n q'a \\<in> nds \\<and>\n (q'a \\<in> it \\<longrightarrow> q'a = q') \\<and>\n qn' = name q'a \\<and>\n qn \\<in> incoming q'a \\<and> qn \\<noteq> expand_init})", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>q' it s x ita \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            if \\<forall>q'.\n                  qn \\<in> incoming q' \\<longrightarrow>\n                  q' \\<in> nds \\<longrightarrow>\n                  q' \\<in> it \\<or> qn = expand_init\n            then None\n            else Some\n                  {qn'.\n                   \\<exists>q'.\n                      q' \\<in> nds \\<and>\n                      q' \\<notin> it \\<and>\n                      qn' = name q' \\<and>\n                      qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        x \\<in> ita; ita \\<subseteq> incoming q';\n        \\<sigma> =\n        (\\<lambda>qn.\n            if (\\<forall>q'.\n                   qn \\<in> incoming q' \\<longrightarrow>\n                   q' \\<in> nds \\<longrightarrow>\n                   q' \\<in> it \\<or> qn = expand_init) \\<and>\n               (qn \\<in> incoming q' \\<longrightarrow>\n                qn \\<in> ita \\<or> qn = expand_init)\n            then None\n            else Some\n                  ({qn'.\n                    \\<exists>q'.\n                       q' \\<in> nds \\<and>\n                       q' \\<notin> it \\<and>\n                       qn' = name q' \\<and>\n                       qn \\<in> incoming q' \\<and>\n                       qn \\<noteq> expand_init} \\<union>\n                   {qn'.\n                    qn' = name q' \\<and>\n                    qn \\<in> incoming q' \\<and>\n                    qn \\<notin> ita \\<and> qn \\<noteq> expand_init}));\n        \\<forall>q'.\n           x \\<in> incoming q' \\<longrightarrow>\n           q' \\<in> nds \\<longrightarrow> q' \\<in> it;\n        x = expand_init\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<or> qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     qn \\<notin> ita \\<and>\n                                     qn \\<noteq> expand_init})) =\n                         (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<and>\n                                 qn \\<noteq> expand_init \\<or>\n                                 qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     (qn \\<in> ita \\<longrightarrow>\nqn = x) \\<and>\n                                     qn \\<noteq> expand_init}))\n 2. \\<And>q' it s x ita \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            if \\<forall>q'.\n                  qn \\<in> incoming q' \\<longrightarrow>\n                  q' \\<in> nds \\<longrightarrow>\n                  q' \\<in> it \\<or> qn = expand_init\n            then None\n            else Some\n                  {qn'.\n                   \\<exists>q'.\n                      q' \\<in> nds \\<and>\n                      q' \\<notin> it \\<and>\n                      qn' = name q' \\<and>\n                      qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        x \\<in> ita; ita \\<subseteq> incoming q';\n        \\<sigma> =\n        (\\<lambda>qn.\n            if (\\<forall>q'.\n                   qn \\<in> incoming q' \\<longrightarrow>\n                   q' \\<in> nds \\<longrightarrow>\n                   q' \\<in> it \\<or> qn = expand_init) \\<and>\n               (qn \\<in> incoming q' \\<longrightarrow>\n                qn \\<in> ita \\<or> qn = expand_init)\n            then None\n            else Some\n                  ({qn'.\n                    \\<exists>q'.\n                       q' \\<in> nds \\<and>\n                       q' \\<notin> it \\<and>\n                       qn' = name q' \\<and>\n                       qn \\<in> incoming q' \\<and>\n                       qn \\<noteq> expand_init} \\<union>\n                   {qn'.\n                    qn' = name q' \\<and>\n                    qn \\<in> incoming q' \\<and>\n                    qn \\<notin> ita \\<and> qn \\<noteq> expand_init}));\n        \\<forall>q'.\n           x \\<in> incoming q' \\<longrightarrow>\n           q' \\<in> nds \\<longrightarrow> q' \\<in> it;\n        x \\<noteq> expand_init\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<or> qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     qn \\<notin> ita \\<and>\n                                     qn \\<noteq> expand_init}))\n                         (x \\<mapsto> {name q'}) =\n                         (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<and> qn \\<noteq> x \\<or>\n                                 qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     (qn \\<in> ita \\<longrightarrow>\nqn = x) \\<and>\n                                     qn \\<noteq> expand_init}))\n 3. \\<And>q' it s x ita \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            if \\<forall>q'.\n                  qn \\<in> incoming q' \\<longrightarrow>\n                  q' \\<in> nds \\<longrightarrow>\n                  q' \\<in> it \\<or> qn = expand_init\n            then None\n            else Some\n                  {qn'.\n                   \\<exists>q'.\n                      q' \\<in> nds \\<and>\n                      q' \\<notin> it \\<and>\n                      qn' = name q' \\<and>\n                      qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        x \\<in> ita; ita \\<subseteq> incoming q';\n        \\<sigma> =\n        (\\<lambda>qn.\n            if (\\<forall>q'.\n                   qn \\<in> incoming q' \\<longrightarrow>\n                   q' \\<in> nds \\<longrightarrow>\n                   q' \\<in> it \\<or> qn = expand_init) \\<and>\n               (qn \\<in> incoming q' \\<longrightarrow>\n                qn \\<in> ita \\<or> qn = expand_init)\n            then None\n            else Some\n                  ({qn'.\n                    \\<exists>q'.\n                       q' \\<in> nds \\<and>\n                       q' \\<notin> it \\<and>\n                       qn' = name q' \\<and>\n                       qn \\<in> incoming q' \\<and>\n                       qn \\<noteq> expand_init} \\<union>\n                   {qn'.\n                    qn' = name q' \\<and>\n                    qn \\<in> incoming q' \\<and>\n                    qn \\<notin> ita \\<and> qn \\<noteq> expand_init}));\n        \\<exists>q'.\n           x \\<in> incoming q' \\<and> q' \\<in> nds \\<and> q' \\<notin> it;\n        x = expand_init\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<or> qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     qn \\<notin> ita \\<and>\n                                     qn \\<noteq> expand_init})) =\n                         (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<and>\n                                 qn \\<noteq> expand_init \\<or>\n                                 qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     (qn \\<in> ita \\<longrightarrow>\nqn = x) \\<and>\n                                     qn \\<noteq> expand_init}))\n 4. \\<And>q' it s x ita \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            if \\<forall>q'.\n                  qn \\<in> incoming q' \\<longrightarrow>\n                  q' \\<in> nds \\<longrightarrow>\n                  q' \\<in> it \\<or> qn = expand_init\n            then None\n            else Some\n                  {qn'.\n                   \\<exists>q'.\n                      q' \\<in> nds \\<and>\n                      q' \\<notin> it \\<and>\n                      qn' = name q' \\<and>\n                      qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        x \\<in> ita; ita \\<subseteq> incoming q';\n        \\<sigma> =\n        (\\<lambda>qn.\n            if (\\<forall>q'.\n                   qn \\<in> incoming q' \\<longrightarrow>\n                   q' \\<in> nds \\<longrightarrow>\n                   q' \\<in> it \\<or> qn = expand_init) \\<and>\n               (qn \\<in> incoming q' \\<longrightarrow>\n                qn \\<in> ita \\<or> qn = expand_init)\n            then None\n            else Some\n                  ({qn'.\n                    \\<exists>q'.\n                       q' \\<in> nds \\<and>\n                       q' \\<notin> it \\<and>\n                       qn' = name q' \\<and>\n                       qn \\<in> incoming q' \\<and>\n                       qn \\<noteq> expand_init} \\<union>\n                   {qn'.\n                    qn' = name q' \\<and>\n                    qn \\<in> incoming q' \\<and>\n                    qn \\<notin> ita \\<and> qn \\<noteq> expand_init}));\n        \\<exists>q'.\n           x \\<in> incoming q' \\<and> q' \\<in> nds \\<and> q' \\<notin> it;\n        x \\<noteq> expand_init\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<or> qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     qn \\<notin> ita \\<and>\n                                     qn \\<noteq> expand_init}))\n                         (x \\<mapsto>\n                         insert (name q')\n                          {qn'.\n                           \\<exists>q'.\n                              q' \\<in> nds \\<and>\n                              q' \\<notin> it \\<and>\n                              qn' = name q' \\<and> x \\<in> incoming q'}) =\n                         (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<and> qn \\<noteq> x \\<or>\n                                 qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     (qn \\<in> ita \\<longrightarrow>\nqn = x) \\<and>\n                                     qn \\<noteq> expand_init}))\n 5. \\<And>q' it s \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            if \\<forall>q'.\n                  qn \\<in> incoming q' \\<longrightarrow>\n                  q' \\<in> nds \\<longrightarrow>\n                  q' \\<in> it \\<or> qn = expand_init\n            then None\n            else Some\n                  {qn'.\n                   \\<exists>q'.\n                      q' \\<in> nds \\<and>\n                      q' \\<notin> it \\<and>\n                      qn' = name q' \\<and>\n                      qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        \\<sigma> =\n        (\\<lambda>qn.\n            if (\\<forall>q'.\n                   qn \\<in> incoming q' \\<longrightarrow>\n                   q' \\<in> nds \\<longrightarrow>\n                   q' \\<in> it \\<or> qn = expand_init) \\<and>\n               (qn \\<in> incoming q' \\<longrightarrow> qn = expand_init)\n            then None\n            else Some\n                  ({qn'.\n                    \\<exists>q'.\n                       q' \\<in> nds \\<and>\n                       q' \\<notin> it \\<and>\n                       qn' = name q' \\<and>\n                       qn \\<in> incoming q' \\<and>\n                       qn \\<noteq> expand_init} \\<union>\n                   {qn'.\n                    qn' = name q' \\<and>\n                    qn \\<in> incoming q' \\<and>\n                    qn \\<noteq> expand_init}))\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     qn \\<noteq> expand_init})) =\n                         (\\<lambda>qn.\n                             if \\<forall>q'a.\n                                   qn \\<in> incoming q'a \\<longrightarrow>\n                                   q'a \\<in> nds \\<longrightarrow>\n                                   q'a \\<in> it \\<and> q'a \\<noteq> q' \\<or>\n                                   qn = expand_init\n                             then None\n                             else Some\n                                   {qn'.\n                                    \\<exists>q'a.\n q'a \\<in> nds \\<and>\n (q'a \\<in> it \\<longrightarrow> q'a = q') \\<and>\n qn' = name q'a \\<and>\n qn \\<in> incoming q'a \\<and> qn \\<noteq> expand_init})", "apply (auto simp: dflt_None_set_def intro!: ext) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>q' it s x ita \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            if \\<forall>q'.\n                  qn \\<in> incoming q' \\<longrightarrow>\n                  q' \\<in> nds \\<longrightarrow>\n                  q' \\<in> it \\<or> qn = expand_init\n            then None\n            else Some\n                  {qn'.\n                   \\<exists>q'.\n                      q' \\<in> nds \\<and>\n                      q' \\<notin> it \\<and>\n                      qn' = name q' \\<and>\n                      qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        x \\<in> ita; ita \\<subseteq> incoming q';\n        \\<sigma> =\n        (\\<lambda>qn.\n            if (\\<forall>q'.\n                   qn \\<in> incoming q' \\<longrightarrow>\n                   q' \\<in> nds \\<longrightarrow>\n                   q' \\<in> it \\<or> qn = expand_init) \\<and>\n               (qn \\<in> incoming q' \\<longrightarrow>\n                qn \\<in> ita \\<or> qn = expand_init)\n            then None\n            else Some\n                  ({qn'.\n                    \\<exists>q'.\n                       q' \\<in> nds \\<and>\n                       q' \\<notin> it \\<and>\n                       qn' = name q' \\<and>\n                       qn \\<in> incoming q' \\<and>\n                       qn \\<noteq> expand_init} \\<union>\n                   {qn'.\n                    qn' = name q' \\<and>\n                    qn \\<in> incoming q' \\<and>\n                    qn \\<notin> ita \\<and> qn \\<noteq> expand_init}));\n        \\<forall>q'.\n           x \\<in> incoming q' \\<longrightarrow>\n           q' \\<in> nds \\<longrightarrow> q' \\<in> it;\n        x \\<noteq> expand_init\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<or> qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     qn \\<notin> ita \\<and>\n                                     qn \\<noteq> expand_init}))\n                         (x \\<mapsto> {name q'}) =\n                         (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<and> qn \\<noteq> x \\<or>\n                                 qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     (qn \\<in> ita \\<longrightarrow>\nqn = x) \\<and>\n                                     qn \\<noteq> expand_init}))\n 2. \\<And>q' it s x ita \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            if \\<forall>q'.\n                  qn \\<in> incoming q' \\<longrightarrow>\n                  q' \\<in> nds \\<longrightarrow>\n                  q' \\<in> it \\<or> qn = expand_init\n            then None\n            else Some\n                  {qn'.\n                   \\<exists>q'.\n                      q' \\<in> nds \\<and>\n                      q' \\<notin> it \\<and>\n                      qn' = name q' \\<and>\n                      qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        x \\<in> ita; ita \\<subseteq> incoming q';\n        \\<sigma> =\n        (\\<lambda>qn.\n            if (\\<forall>q'.\n                   qn \\<in> incoming q' \\<longrightarrow>\n                   q' \\<in> nds \\<longrightarrow>\n                   q' \\<in> it \\<or> qn = expand_init) \\<and>\n               (qn \\<in> incoming q' \\<longrightarrow>\n                qn \\<in> ita \\<or> qn = expand_init)\n            then None\n            else Some\n                  ({qn'.\n                    \\<exists>q'.\n                       q' \\<in> nds \\<and>\n                       q' \\<notin> it \\<and>\n                       qn' = name q' \\<and>\n                       qn \\<in> incoming q' \\<and>\n                       qn \\<noteq> expand_init} \\<union>\n                   {qn'.\n                    qn' = name q' \\<and>\n                    qn \\<in> incoming q' \\<and>\n                    qn \\<notin> ita \\<and> qn \\<noteq> expand_init}));\n        \\<exists>q'.\n           x \\<in> incoming q' \\<and> q' \\<in> nds \\<and> q' \\<notin> it;\n        x = expand_init\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<or> qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     qn \\<notin> ita \\<and>\n                                     qn \\<noteq> expand_init})) =\n                         (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<and>\n                                 qn \\<noteq> expand_init \\<or>\n                                 qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     (qn \\<in> ita \\<longrightarrow>\nqn = x) \\<and>\n                                     qn \\<noteq> expand_init}))\n 3. \\<And>q' it s x ita \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            if \\<forall>q'.\n                  qn \\<in> incoming q' \\<longrightarrow>\n                  q' \\<in> nds \\<longrightarrow>\n                  q' \\<in> it \\<or> qn = expand_init\n            then None\n            else Some\n                  {qn'.\n                   \\<exists>q'.\n                      q' \\<in> nds \\<and>\n                      q' \\<notin> it \\<and>\n                      qn' = name q' \\<and>\n                      qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        x \\<in> ita; ita \\<subseteq> incoming q';\n        \\<sigma> =\n        (\\<lambda>qn.\n            if (\\<forall>q'.\n                   qn \\<in> incoming q' \\<longrightarrow>\n                   q' \\<in> nds \\<longrightarrow>\n                   q' \\<in> it \\<or> qn = expand_init) \\<and>\n               (qn \\<in> incoming q' \\<longrightarrow>\n                qn \\<in> ita \\<or> qn = expand_init)\n            then None\n            else Some\n                  ({qn'.\n                    \\<exists>q'.\n                       q' \\<in> nds \\<and>\n                       q' \\<notin> it \\<and>\n                       qn' = name q' \\<and>\n                       qn \\<in> incoming q' \\<and>\n                       qn \\<noteq> expand_init} \\<union>\n                   {qn'.\n                    qn' = name q' \\<and>\n                    qn \\<in> incoming q' \\<and>\n                    qn \\<notin> ita \\<and> qn \\<noteq> expand_init}));\n        \\<exists>q'.\n           x \\<in> incoming q' \\<and> q' \\<in> nds \\<and> q' \\<notin> it;\n        x \\<noteq> expand_init\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<or> qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     qn \\<notin> ita \\<and>\n                                     qn \\<noteq> expand_init}))\n                         (x \\<mapsto>\n                         insert (name q')\n                          {qn'.\n                           \\<exists>q'.\n                              q' \\<in> nds \\<and>\n                              q' \\<notin> it \\<and>\n                              qn' = name q' \\<and> x \\<in> incoming q'}) =\n                         (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn \\<in> ita \\<and> qn \\<noteq> x \\<or>\n                                 qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     (qn \\<in> ita \\<longrightarrow>\nqn = x) \\<and>\n                                     qn \\<noteq> expand_init}))\n 4. \\<And>q' it s \\<sigma>.\n       \\<lbrakk>q' \\<in> it; it \\<subseteq> nds;\n        s =\n        (\\<lambda>qn.\n            if \\<forall>q'.\n                  qn \\<in> incoming q' \\<longrightarrow>\n                  q' \\<in> nds \\<longrightarrow>\n                  q' \\<in> it \\<or> qn = expand_init\n            then None\n            else Some\n                  {qn'.\n                   \\<exists>q'.\n                      q' \\<in> nds \\<and>\n                      q' \\<notin> it \\<and>\n                      qn' = name q' \\<and>\n                      qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init});\n        \\<sigma> =\n        (\\<lambda>qn.\n            if (\\<forall>q'.\n                   qn \\<in> incoming q' \\<longrightarrow>\n                   q' \\<in> nds \\<longrightarrow>\n                   q' \\<in> it \\<or> qn = expand_init) \\<and>\n               (qn \\<in> incoming q' \\<longrightarrow> qn = expand_init)\n            then None\n            else Some\n                  ({qn'.\n                    \\<exists>q'.\n                       q' \\<in> nds \\<and>\n                       q' \\<notin> it \\<and>\n                       qn' = name q' \\<and>\n                       qn \\<in> incoming q' \\<and>\n                       qn \\<noteq> expand_init} \\<union>\n                   {qn'.\n                    qn' = name q' \\<and>\n                    qn \\<in> incoming q' \\<and>\n                    qn \\<noteq> expand_init}))\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>qn.\n                             if (\\<forall>q'.\n                                    qn \\<in> incoming q' \\<longrightarrow>\n                                    q' \\<in> nds \\<longrightarrow>\n                                    q' \\<in> it \\<or>\n                                    qn = expand_init) \\<and>\n                                (qn \\<in> incoming q' \\<longrightarrow>\n                                 qn = expand_init)\n                             then None\n                             else Some\n                                   ({qn'.\n                                     \\<exists>q'.\n  q' \\<in> nds \\<and>\n  q' \\<notin> it \\<and>\n  qn' = name q' \\<and>\n  qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} \\<union>\n                                    {qn'.\n                                     qn' = name q' \\<and>\n                                     qn \\<in> incoming q' \\<and>\n                                     qn \\<noteq> expand_init})) =\n                         (\\<lambda>qn.\n                             if \\<forall>q'a.\n                                   qn \\<in> incoming q'a \\<longrightarrow>\n                                   q'a \\<in> nds \\<longrightarrow>\n                                   q'a \\<in> it \\<and> q'a \\<noteq> q' \\<or>\n                                   qn = expand_init\n                             then None\n                             else Some\n                                   {qn'.\n                                    \\<exists>q'a.\n q'a \\<in> nds \\<and>\n (q'a \\<in> it \\<longrightarrow> q'a = q') \\<and>\n qn' = name q'a \\<and>\n qn \\<in> incoming q'a \\<and> qn \\<noteq> expand_init})", "apply (rule ext, (auto) [])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma build_succ_aux2:\n  assumes NINIT: \"expand_init \\<notin> name`nds\"\n  assumes CL: \"\\<And>nd. nd\\<in>nds \\<Longrightarrow> incoming nd \\<subseteq> insert expand_init (name`nds)\"\n  shows\n  \"(\\<lambda>qn. dflt_None_set \n    {qn'. \\<exists>q'. q'\\<in>nds \\<and> qn' = name q' \\<and> qn\\<in>incoming q' \\<and> qn\\<noteq>expand_init }) \n  = (\\<lambda>qn. dflt_None_set (succ_of_E \n       (rename_E name {(q, q'). q \\<in> nds \\<and> q' \\<in> nds \\<and> name q \\<in> incoming q'}) qn))\" \n  (is \"(\\<lambda>qn. dflt_None_set (?L qn)) = (\\<lambda>qn. dflt_None_set (?R qn))\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>qn.\n        dflt_None_set\n         {qn'.\n          \\<exists>q'.\n             q' \\<in> nds \\<and>\n             qn' = name q' \\<and>\n             qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}) =\n    (\\<lambda>qn.\n        dflt_None_set\n         (succ_of_E\n           (rename_E name\n             {(q, q').\n              q \\<in> nds \\<and>\n              q' \\<in> nds \\<and> name q \\<in> incoming q'})\n           qn))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>qn.\n       dflt_None_set\n        {qn'.\n         \\<exists>q'.\n            q' \\<in> nds \\<and>\n            qn' = name q' \\<and>\n            qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} =\n       dflt_None_set\n        (succ_of_E\n          (rename_E name\n            {(q, q').\n             q \\<in> nds \\<and>\n             q' \\<in> nds \\<and> name q \\<in> incoming q'})\n          qn)", "apply (fo_rule arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>qn.\n       {qn'.\n        \\<exists>q'.\n           q' \\<in> nds \\<and>\n           qn' = name q' \\<and>\n           qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init} =\n       succ_of_E\n        (rename_E name\n          {(q, q').\n           q \\<in> nds \\<and> q' \\<in> nds \\<and> name q \\<in> incoming q'})\n        qn", "proof (intro ext equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qn x.\n       x \\<in> {qn'.\n                \\<exists>q'.\n                   q' \\<in> nds \\<and>\n                   qn' = name q' \\<and>\n                   qn \\<in> incoming q' \\<and>\n                   qn \\<noteq> expand_init} \\<Longrightarrow>\n       x \\<in> succ_of_E\n                (rename_E name\n                  {(q, q').\n                   q \\<in> nds \\<and>\n                   q' \\<in> nds \\<and> name q \\<in> incoming q'})\n                qn\n 2. \\<And>qn x.\n       x \\<in> succ_of_E\n                (rename_E name\n                  {(q, q').\n                   q \\<in> nds \\<and>\n                   q' \\<in> nds \\<and> name q \\<in> incoming q'})\n                qn \\<Longrightarrow>\n       x \\<in> {qn'.\n                \\<exists>q'.\n                   q' \\<in> nds \\<and>\n                   qn' = name q' \\<and>\n                   qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}", "fix qn x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>qn x.\n       x \\<in> {qn'.\n                \\<exists>q'.\n                   q' \\<in> nds \\<and>\n                   qn' = name q' \\<and>\n                   qn \\<in> incoming q' \\<and>\n                   qn \\<noteq> expand_init} \\<Longrightarrow>\n       x \\<in> succ_of_E\n                (rename_E name\n                  {(q, q').\n                   q \\<in> nds \\<and>\n                   q' \\<in> nds \\<and> name q \\<in> incoming q'})\n                qn\n 2. \\<And>qn x.\n       x \\<in> succ_of_E\n                (rename_E name\n                  {(q, q').\n                   q \\<in> nds \\<and>\n                   q' \\<in> nds \\<and> name q \\<in> incoming q'})\n                qn \\<Longrightarrow>\n       x \\<in> {qn'.\n                \\<exists>q'.\n                   q' \\<in> nds \\<and>\n                   qn' = name q' \\<and>\n                   qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}", "assume \"x\\<in>?R qn\""], ["proof (state)\nthis:\n  x \\<in> succ_of_E\n           (rename_E name\n             {(q, q').\n              q \\<in> nds \\<and>\n              q' \\<in> nds \\<and> name q \\<in> incoming q'})\n           qn\n\ngoal (2 subgoals):\n 1. \\<And>qn x.\n       x \\<in> {qn'.\n                \\<exists>q'.\n                   q' \\<in> nds \\<and>\n                   qn' = name q' \\<and>\n                   qn \\<in> incoming q' \\<and>\n                   qn \\<noteq> expand_init} \\<Longrightarrow>\n       x \\<in> succ_of_E\n                (rename_E name\n                  {(q, q').\n                   q \\<in> nds \\<and>\n                   q' \\<in> nds \\<and> name q \\<in> incoming q'})\n                qn\n 2. \\<And>qn x.\n       x \\<in> succ_of_E\n                (rename_E name\n                  {(q, q').\n                   q \\<in> nds \\<and>\n                   q' \\<in> nds \\<and> name q \\<in> incoming q'})\n                qn \\<Longrightarrow>\n       x \\<in> {qn'.\n                \\<exists>q'.\n                   q' \\<in> nds \\<and>\n                   qn' = name q' \\<and>\n                   qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}", "then"], ["proof (chain)\npicking this:\n  x \\<in> succ_of_E\n           (rename_E name\n             {(q, q').\n              q \\<in> nds \\<and>\n              q' \\<in> nds \\<and> name q \\<in> incoming q'})\n           qn", "show \"x\\<in>?L qn\""], ["proof (prove)\nusing this:\n  x \\<in> succ_of_E\n           (rename_E name\n             {(q, q').\n              q \\<in> nds \\<and>\n              q' \\<in> nds \\<and> name q \\<in> incoming q'})\n           qn\n\ngoal (1 subgoal):\n 1. x \\<in> {qn'.\n             \\<exists>q'.\n                q' \\<in> nds \\<and>\n                qn' = name q' \\<and>\n                qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}", "using NINIT"], ["proof (prove)\nusing this:\n  x \\<in> succ_of_E\n           (rename_E name\n             {(q, q').\n              q \\<in> nds \\<and>\n              q' \\<in> nds \\<and> name q \\<in> incoming q'})\n           qn\n  expand_init \\<notin> name ` nds\n\ngoal (1 subgoal):\n 1. x \\<in> {qn'.\n             \\<exists>q'.\n                q' \\<in> nds \\<and>\n                qn' = name q' \\<and>\n                qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}", "by (force simp: succ_of_E_def)"], ["proof (state)\nthis:\n  x \\<in> {qn'.\n           \\<exists>q'.\n              q' \\<in> nds \\<and>\n              qn' = name q' \\<and>\n              qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}\n\ngoal (1 subgoal):\n 1. \\<And>qn x.\n       x \\<in> {qn'.\n                \\<exists>q'.\n                   q' \\<in> nds \\<and>\n                   qn' = name q' \\<and>\n                   qn \\<in> incoming q' \\<and>\n                   qn \\<noteq> expand_init} \\<Longrightarrow>\n       x \\<in> succ_of_E\n                (rename_E name\n                  {(q, q').\n                   q \\<in> nds \\<and>\n                   q' \\<in> nds \\<and> name q \\<in> incoming q'})\n                qn", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qn x.\n       x \\<in> {qn'.\n                \\<exists>q'.\n                   q' \\<in> nds \\<and>\n                   qn' = name q' \\<and>\n                   qn \\<in> incoming q' \\<and>\n                   qn \\<noteq> expand_init} \\<Longrightarrow>\n       x \\<in> succ_of_E\n                (rename_E name\n                  {(q, q').\n                   q \\<in> nds \\<and>\n                   q' \\<in> nds \\<and> name q \\<in> incoming q'})\n                qn", "fix qn x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qn x.\n       x \\<in> {qn'.\n                \\<exists>q'.\n                   q' \\<in> nds \\<and>\n                   qn' = name q' \\<and>\n                   qn \\<in> incoming q' \\<and>\n                   qn \\<noteq> expand_init} \\<Longrightarrow>\n       x \\<in> succ_of_E\n                (rename_E name\n                  {(q, q').\n                   q \\<in> nds \\<and>\n                   q' \\<in> nds \\<and> name q \\<in> incoming q'})\n                qn", "assume XL: \"x\\<in>?L qn\""], ["proof (state)\nthis:\n  x \\<in> {qn'.\n           \\<exists>q'.\n              q' \\<in> nds \\<and>\n              qn' = name q' \\<and>\n              qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}\n\ngoal (1 subgoal):\n 1. \\<And>qn x.\n       x \\<in> {qn'.\n                \\<exists>q'.\n                   q' \\<in> nds \\<and>\n                   qn' = name q' \\<and>\n                   qn \\<in> incoming q' \\<and>\n                   qn \\<noteq> expand_init} \\<Longrightarrow>\n       x \\<in> succ_of_E\n                (rename_E name\n                  {(q, q').\n                   q \\<in> nds \\<and>\n                   q' \\<in> nds \\<and> name q \\<in> incoming q'})\n                qn", "show \"x\\<in>?R qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn", "proof (cases \"qn = expand_init\")"], ["proof (state)\ngoal (2 subgoals):\n 1. qn = expand_init \\<Longrightarrow>\n    x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn\n 2. qn \\<noteq> expand_init \\<Longrightarrow>\n    x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn", "case False"], ["proof (state)\nthis:\n  qn \\<noteq> expand_init\n\ngoal (2 subgoals):\n 1. qn = expand_init \\<Longrightarrow>\n    x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn\n 2. qn \\<noteq> expand_init \\<Longrightarrow>\n    x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn", "from XL"], ["proof (chain)\npicking this:\n  x \\<in> {qn'.\n           \\<exists>q'.\n              q' \\<in> nds \\<and>\n              qn' = name q' \\<and>\n              qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}", "obtain q' where \n      A: \"q'\\<in>nds\" \"qn\\<in>incoming q'\" \n      and [simp]: \"x=name q'\""], ["proof (prove)\nusing this:\n  x \\<in> {qn'.\n           \\<exists>q'.\n              q' \\<in> nds \\<and>\n              qn' = name q' \\<and>\n              qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>q' \\<in> nds; qn \\<in> incoming q'; x = name q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q' \\<in> nds\n  qn \\<in> incoming q'\n  x = name q'\n\ngoal (2 subgoals):\n 1. qn = expand_init \\<Longrightarrow>\n    x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn\n 2. qn \\<noteq> expand_init \\<Longrightarrow>\n    x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn", "from False"], ["proof (chain)\npicking this:\n  qn \\<noteq> expand_init", "obtain q where B: \"q\\<in>nds\" and [simp]: \"qn = name q\""], ["proof (prove)\nusing this:\n  qn \\<noteq> expand_init\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> nds; qn = name q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using CL A"], ["proof (prove)\nusing this:\n  qn \\<noteq> expand_init\n  ?nd \\<in> nds \\<Longrightarrow>\n  incoming ?nd \\<subseteq> insert expand_init (name ` nds)\n  q' \\<in> nds\n  qn \\<in> incoming q'\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> nds; qn = name q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> nds\n  qn = name q\n\ngoal (2 subgoals):\n 1. qn = expand_init \\<Longrightarrow>\n    x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn\n 2. qn \\<noteq> expand_init \\<Longrightarrow>\n    x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn", "from A B"], ["proof (chain)\npicking this:\n  q' \\<in> nds\n  qn \\<in> incoming q'\n  q \\<in> nds", "show \"x\\<in>?R qn\""], ["proof (prove)\nusing this:\n  q' \\<in> nds\n  qn \\<in> incoming q'\n  q \\<in> nds\n\ngoal (1 subgoal):\n 1. x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn", "by (auto simp: succ_of_E_def image_def)"], ["proof (state)\nthis:\n  x \\<in> succ_of_E\n           (rename_E name\n             {(q, q').\n              q \\<in> nds \\<and>\n              q' \\<in> nds \\<and> name q \\<in> incoming q'})\n           qn\n\ngoal (1 subgoal):\n 1. qn = expand_init \\<Longrightarrow>\n    x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. qn = expand_init \\<Longrightarrow>\n    x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn", "case [simp]: True"], ["proof (state)\nthis:\n  qn = expand_init\n\ngoal (1 subgoal):\n 1. qn = expand_init \\<Longrightarrow>\n    x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn", "from XL"], ["proof (chain)\npicking this:\n  x \\<in> {qn'.\n           \\<exists>q'.\n              q' \\<in> nds \\<and>\n              qn' = name q' \\<and>\n              qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}", "show \"x\\<in>?R qn\""], ["proof (prove)\nusing this:\n  x \\<in> {qn'.\n           \\<exists>q'.\n              q' \\<in> nds \\<and>\n              qn' = name q' \\<and>\n              qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}\n\ngoal (1 subgoal):\n 1. x \\<in> succ_of_E\n             (rename_E name\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'})\n             qn", "by simp"], ["proof (state)\nthis:\n  x \\<in> succ_of_E\n           (rename_E name\n             {(q, q').\n              q \\<in> nds \\<and>\n              q' \\<in> nds \\<and> name q \\<in> incoming q'})\n           qn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> succ_of_E\n           (rename_E name\n             {(q, q').\n              q \\<in> nds \\<and>\n              q' \\<in> nds \\<and> name q \\<in> incoming q'})\n           qn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma build_succ_correct:\n  assumes NINIT: \"expand_init \\<notin> name`nds\"\n  assumes FIN: \"finite nds\"\n  assumes CL: \"\\<And>nd. nd\\<in>nds \\<Longrightarrow> incoming nd \\<subseteq> insert expand_init (name`nds)\"\n  shows \"build_succ nds \\<le> SPEC (\\<lambda>r. \n    E_of_succ (\\<lambda>qn. the_default {} (r qn)) \n    = rename_E (\\<lambda>u. name u) {(q, q'). q \\<in> nds \\<and> q' \\<in> nds \\<and> name q \\<in> incoming q'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build_succ nds\n    \\<le> SPEC\n           (\\<lambda>r.\n               E_of_succ (\\<lambda>qn. the_default {} (r qn)) =\n               rename_E name\n                {(q, q').\n                 q \\<in> nds \\<and>\n                 q' \\<in> nds \\<and> name q \\<in> incoming q'})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. build_succ nds\n    \\<le> SPEC\n           (\\<lambda>r.\n               E_of_succ (\\<lambda>qn. the_default {} (r qn)) =\n               rename_E name\n                {(q, q').\n                 q \\<in> nds \\<and>\n                 q' \\<in> nds \\<and> name q \\<in> incoming q'})", "from FIN CL"], ["proof (chain)\npicking this:\n  finite nds\n  ?nd \\<in> nds \\<Longrightarrow>\n  incoming ?nd \\<subseteq> insert expand_init (name ` nds)", "have FIN': \"\\<And>q. q\\<in>nds \\<Longrightarrow> finite (incoming q)\""], ["proof (prove)\nusing this:\n  finite nds\n  ?nd \\<in> nds \\<Longrightarrow>\n  incoming ?nd \\<subseteq> insert expand_init (name ` nds)\n\ngoal (1 subgoal):\n 1. \\<And>q. q \\<in> nds \\<Longrightarrow> finite (incoming q)", "by (metis finite_imageI finite_insert infinite_super)"], ["proof (state)\nthis:\n  ?q \\<in> nds \\<Longrightarrow> finite (incoming ?q)\n\ngoal (1 subgoal):\n 1. build_succ nds\n    \\<le> SPEC\n           (\\<lambda>r.\n               E_of_succ (\\<lambda>qn. the_default {} (r qn)) =\n               rename_E name\n                {(q, q').\n                 q \\<in> nds \\<and>\n                 q' \\<in> nds \\<and> name q \\<in> incoming q'})", "note build_succ_aux1[OF FIN FIN']"], ["proof (state)\nthis:\n  (\\<And>q. q \\<in> nds \\<Longrightarrow> q \\<in> nds) \\<Longrightarrow>\n  build_succ nds\n  \\<le> SPEC\n         (\\<lambda>r.\n             r =\n             (\\<lambda>qn.\n                 dflt_None_set\n                  {qn'.\n                   \\<exists>q'.\n                      q' \\<in> nds \\<and>\n                      qn' = name q' \\<and>\n                      qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}))\n\ngoal (1 subgoal):\n 1. build_succ nds\n    \\<le> SPEC\n           (\\<lambda>r.\n               E_of_succ (\\<lambda>qn. the_default {} (r qn)) =\n               rename_E name\n                {(q, q').\n                 q \\<in> nds \\<and>\n                 q' \\<in> nds \\<and> name q \\<in> incoming q'})", "also"], ["proof (state)\nthis:\n  (\\<And>q. q \\<in> nds \\<Longrightarrow> q \\<in> nds) \\<Longrightarrow>\n  build_succ nds\n  \\<le> SPEC\n         (\\<lambda>r.\n             r =\n             (\\<lambda>qn.\n                 dflt_None_set\n                  {qn'.\n                   \\<exists>q'.\n                      q' \\<in> nds \\<and>\n                      qn' = name q' \\<and>\n                      qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}))\n\ngoal (1 subgoal):\n 1. build_succ nds\n    \\<le> SPEC\n           (\\<lambda>r.\n               E_of_succ (\\<lambda>qn. the_default {} (r qn)) =\n               rename_E name\n                {(q, q').\n                 q \\<in> nds \\<and>\n                 q' \\<in> nds \\<and> name q \\<in> incoming q'})", "note build_succ_aux2[OF NINIT CL]"], ["proof (state)\nthis:\n  (\\<And>nd. nd \\<in> nds \\<Longrightarrow> nd \\<in> nds) \\<Longrightarrow>\n  (\\<lambda>qn.\n      dflt_None_set\n       {qn'.\n        \\<exists>q'.\n           q' \\<in> nds \\<and>\n           qn' = name q' \\<and>\n           qn \\<in> incoming q' \\<and> qn \\<noteq> expand_init}) =\n  (\\<lambda>qn.\n      dflt_None_set\n       (succ_of_E\n         (rename_E name\n           {(q, q').\n            q \\<in> nds \\<and>\n            q' \\<in> nds \\<and> name q \\<in> incoming q'})\n         qn))\n\ngoal (1 subgoal):\n 1. build_succ nds\n    \\<le> SPEC\n           (\\<lambda>r.\n               E_of_succ (\\<lambda>qn. the_default {} (r qn)) =\n               rename_E name\n                {(q, q').\n                 q \\<in> nds \\<and>\n                 q' \\<in> nds \\<and> name q \\<in> incoming q'})", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>q. q \\<in> nds \\<Longrightarrow> q \\<in> nds;\n   \\<And>nd. nd \\<in> nds \\<Longrightarrow> nd \\<in> nds\\<rbrakk>\n  \\<Longrightarrow> build_succ nds\n                    \\<le> SPEC\n                           (\\<lambda>r.\n                               r =\n                               (\\<lambda>qn.\n                                   dflt_None_set\n                                    (succ_of_E\n(rename_E name\n  {(q, q').\n   q \\<in> nds \\<and> q' \\<in> nds \\<and> name q \\<in> incoming q'})\nqn)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>q. q \\<in> nds \\<Longrightarrow> q \\<in> nds;\n   \\<And>nd. nd \\<in> nds \\<Longrightarrow> nd \\<in> nds\\<rbrakk>\n  \\<Longrightarrow> build_succ nds\n                    \\<le> SPEC\n                           (\\<lambda>r.\n                               r =\n                               (\\<lambda>qn.\n                                   dflt_None_set\n                                    (succ_of_E\n(rename_E name\n  {(q, q').\n   q \\<in> nds \\<and> q' \\<in> nds \\<and> name q \\<in> incoming q'})\nqn)))\n\ngoal (1 subgoal):\n 1. build_succ nds\n    \\<le> SPEC\n           (\\<lambda>r.\n               E_of_succ (\\<lambda>qn. the_default {} (r qn)) =\n               rename_E name\n                {(q, q').\n                 q \\<in> nds \\<and>\n                 q' \\<in> nds \\<and> name q \\<in> incoming q'})", "by (rule order_trans) auto"], ["proof (state)\nthis:\n  build_succ nds\n  \\<le> SPEC\n         (\\<lambda>r.\n             E_of_succ (\\<lambda>qn. the_default {} (r qn)) =\n             rename_E name\n              {(q, q').\n               q \\<in> nds \\<and>\n               q' \\<in> nds \\<and> name q \\<in> incoming q'})\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\\paragraph{ Accepting Sets}\\<close>"], ["", "primrec until_frmlsr :: \"'a frml \\<Rightarrow> ('a frml \\<times> 'a frml) set\" where\n  \"until_frmlsr (\\<mu> and\\<^sub>r \\<psi>) = (until_frmlsr \\<mu>) \\<union> (until_frmlsr \\<psi>)\"\n| \"until_frmlsr (X\\<^sub>r \\<mu>) = until_frmlsr \\<mu>\"\n| \"until_frmlsr (\\<mu> U\\<^sub>r \\<psi>) = insert (\\<mu>, \\<psi>) ((until_frmlsr \\<mu>) \\<union> (until_frmlsr \\<psi>))\"\n| \"until_frmlsr (\\<mu> R\\<^sub>r \\<psi>) = (until_frmlsr \\<mu>) \\<union> (until_frmlsr \\<psi>)\"\n| \"until_frmlsr (\\<mu> or\\<^sub>r \\<psi>) = (until_frmlsr \\<mu>) \\<union> (until_frmlsr \\<psi>)\"\n| \"until_frmlsr (true\\<^sub>r) = {}\"\n| \"until_frmlsr (false\\<^sub>r) = {}\"\n| \"until_frmlsr (prop\\<^sub>r(_)) = {}\"\n| \"until_frmlsr (nprop\\<^sub>r(_)) = {}\""], ["", "lemma until_frmlsr_correct: \n  \"until_frmlsr \\<phi> = {(\\<mu>, \\<eta>). Until_ltlr \\<mu> \\<eta> \\<in> subfrmlsr \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. until_frmlsr \\<phi> =\n    {(\\<mu>, \\<eta>). \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}", "by (induct \\<phi>) auto"], ["", "definition \"build_F nds \\<phi> \n  \\<equiv> (\\<lambda>(\\<mu>,\\<eta>). name ` {q \\<in> nds. (Until_ltlr \\<mu> \\<eta> \\<in> old q \\<longrightarrow> \\<eta> \\<in> old q)}) `\n    until_frmlsr \\<phi>\""], ["", "lemma build_F_correct: \"build_F nds \\<phi> = \n  {name ` A |A. \\<exists>\\<mu> \\<eta>. A = {q \\<in> nds. Until_ltlr \\<mu> \\<eta> \\<in> old q \\<longrightarrow> \\<eta> \\<in> old q} \\<and>\n                     Until_ltlr \\<mu> \\<eta> \\<in> subfrmlsr \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. build_F nds \\<phi> =\n    {name ` A |A.\n     \\<exists>\\<mu> \\<eta>.\n        A =\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q} \\<and>\n        \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. build_F nds \\<phi> =\n    {name ` A |A.\n     \\<exists>\\<mu> \\<eta>.\n        A =\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q} \\<and>\n        \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}", "have \"{name ` A |A. \\<exists>\\<mu> \\<eta>. A = {q \\<in> nds. Until_ltlr \\<mu> \\<eta> \\<in> old q \\<longrightarrow> \\<eta> \\<in> old q} \\<and>\n                     Until_ltlr \\<mu> \\<eta> \\<in> subfrmlsr \\<phi>}\n    = (\\<lambda>(\\<mu>,\\<eta>). name`{q\\<in>nds. Until_ltlr \\<mu> \\<eta> \\<in> old q \\<longrightarrow> \\<eta> \\<in> old q}) \n      ` {(\\<mu>, \\<eta>). Until_ltlr \\<mu> \\<eta> \\<in> subfrmlsr \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {name ` A |A.\n     \\<exists>\\<mu> \\<eta>.\n        A =\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q} \\<and>\n        \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>} =\n    (\\<lambda>(\\<mu>, \\<eta>).\n        name `\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q}) `\n    {(\\<mu>, \\<eta>). \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}", "by auto"], ["proof (state)\nthis:\n  {name ` A |A.\n   \\<exists>\\<mu> \\<eta>.\n      A =\n      {q \\<in> nds.\n       \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n       \\<eta> \\<in> old q} \\<and>\n      \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>} =\n  (\\<lambda>(\\<mu>, \\<eta>).\n      name `\n      {q \\<in> nds.\n       \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n       \\<eta> \\<in> old q}) `\n  {(\\<mu>, \\<eta>). \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}\n\ngoal (1 subgoal):\n 1. build_F nds \\<phi> =\n    {name ` A |A.\n     \\<exists>\\<mu> \\<eta>.\n        A =\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q} \\<and>\n        \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}", "also"], ["proof (state)\nthis:\n  {name ` A |A.\n   \\<exists>\\<mu> \\<eta>.\n      A =\n      {q \\<in> nds.\n       \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n       \\<eta> \\<in> old q} \\<and>\n      \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>} =\n  (\\<lambda>(\\<mu>, \\<eta>).\n      name `\n      {q \\<in> nds.\n       \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n       \\<eta> \\<in> old q}) `\n  {(\\<mu>, \\<eta>). \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}\n\ngoal (1 subgoal):\n 1. build_F nds \\<phi> =\n    {name ` A |A.\n     \\<exists>\\<mu> \\<eta>.\n        A =\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q} \\<and>\n        \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}", "have \"\\<dots> = (\\<lambda>(\\<mu>,\\<eta>). name`{q\\<in>nds. Until_ltlr \\<mu> \\<eta> \\<in> old q \\<longrightarrow> \\<eta> \\<in> old q}) \n      ` until_frmlsr \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(\\<mu>, \\<eta>).\n        name `\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q}) `\n    {(\\<mu>, \\<eta>). \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>} =\n    (\\<lambda>(\\<mu>, \\<eta>).\n        name `\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q}) `\n    until_frmlsr \\<phi>", "unfolding until_frmlsr_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(\\<mu>, \\<eta>).\n        name `\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q}) `\n    {(\\<mu>, \\<eta>). \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>} =\n    (\\<lambda>(\\<mu>, \\<eta>).\n        name `\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q}) `\n    {(\\<mu>, \\<eta>). \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}", ".."], ["proof (state)\nthis:\n  (\\<lambda>(\\<mu>, \\<eta>).\n      name `\n      {q \\<in> nds.\n       \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n       \\<eta> \\<in> old q}) `\n  {(\\<mu>, \\<eta>). \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>} =\n  (\\<lambda>(\\<mu>, \\<eta>).\n      name `\n      {q \\<in> nds.\n       \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n       \\<eta> \\<in> old q}) `\n  until_frmlsr \\<phi>\n\ngoal (1 subgoal):\n 1. build_F nds \\<phi> =\n    {name ` A |A.\n     \\<exists>\\<mu> \\<eta>.\n        A =\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q} \\<and>\n        \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}", "finally"], ["proof (chain)\npicking this:\n  {name ` A |A.\n   \\<exists>\\<mu> \\<eta>.\n      A =\n      {q \\<in> nds.\n       \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n       \\<eta> \\<in> old q} \\<and>\n      \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>} =\n  (\\<lambda>(\\<mu>, \\<eta>).\n      name `\n      {q \\<in> nds.\n       \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n       \\<eta> \\<in> old q}) `\n  until_frmlsr \\<phi>", "show ?thesis"], ["proof (prove)\nusing this:\n  {name ` A |A.\n   \\<exists>\\<mu> \\<eta>.\n      A =\n      {q \\<in> nds.\n       \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n       \\<eta> \\<in> old q} \\<and>\n      \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>} =\n  (\\<lambda>(\\<mu>, \\<eta>).\n      name `\n      {q \\<in> nds.\n       \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n       \\<eta> \\<in> old q}) `\n  until_frmlsr \\<phi>\n\ngoal (1 subgoal):\n 1. build_F nds \\<phi> =\n    {name ` A |A.\n     \\<exists>\\<mu> \\<eta>.\n        A =\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q} \\<and>\n        \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}", "unfolding build_F_def"], ["proof (prove)\nusing this:\n  {name ` A |A.\n   \\<exists>\\<mu> \\<eta>.\n      A =\n      {q \\<in> nds.\n       \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n       \\<eta> \\<in> old q} \\<and>\n      \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>} =\n  (\\<lambda>(\\<mu>, \\<eta>).\n      name `\n      {q \\<in> nds.\n       \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n       \\<eta> \\<in> old q}) `\n  until_frmlsr \\<phi>\n\ngoal (1 subgoal):\n 1. (\\<lambda>(\\<mu>, \\<eta>).\n        name `\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q}) `\n    until_frmlsr \\<phi> =\n    {name ` A |A.\n     \\<exists>\\<mu> \\<eta>.\n        A =\n        {q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q} \\<and>\n        \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}", "by simp"], ["proof (state)\nthis:\n  build_F nds \\<phi> =\n  {name ` A |A.\n   \\<exists>\\<mu> \\<eta>.\n      A =\n      {q \\<in> nds.\n       \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n       \\<eta> \\<in> old q} \\<and>\n      \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\\paragraph{ Labeling Function }\\<close>"], ["", "definition \"pn_props ps \\<equiv> FOREACHi \n  (\\<lambda>it (P,N). P = {p. Prop_ltlr p \\<in> ps - it} \\<and> N = {p. Nprop_ltlr p \\<in> ps - it}) \n  ps (\\<lambda>p (P,N). \n    case p of Prop_ltlr p \\<Rightarrow> RETURN (insert p P,N)\n    | Nprop_ltlr p \\<Rightarrow> RETURN (P, insert p N)\n    | _ \\<Rightarrow> RETURN (P,N)\n  ) ({},{})\""], ["", "lemma pn_props_correct: \n  assumes [simp]: \"finite ps\"\n  shows \"pn_props ps \\<le> SPEC(\\<lambda>r. r = \n  ({p. Prop_ltlr p \\<in> ps}, {p. Nprop_ltlr p \\<in> ps}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pn_props ps\n    \\<le> SPEC\n           (\\<lambda>r.\n               r =\n               ({p. prop\\<^sub>r(p) \\<in> ps},\n                {p. nprop\\<^sub>r(p) \\<in> ps}))", "unfolding pn_props_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^bsup>\\<lambda>it (P, N).\n                      P = {p. prop\\<^sub>r(p) \\<in> ps - it} \\<and>\n                      N = {p. nprop\\<^sub>r(p) \\<in> ps - it}\\<^esup>\n     ps (\\<lambda>p (P, N).\n            case p of prop\\<^sub>r(p) \\<Rightarrow> RETURN (insert p P, N)\n            | nprop\\<^sub>r(p) \\<Rightarrow> RETURN (P, insert p N)\n            | _ \\<Rightarrow> RETURN (P, N))\n     ({}, {})\n    \\<le> SPEC\n           (\\<lambda>r.\n               r =\n               ({p. prop\\<^sub>r(p) \\<in> ps},\n                {p. nprop\\<^sub>r(p) \\<in> ps}))", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite ps\n 2. \\<And>x1 x2.\n       ({}, {}) = (x1, x2) \\<Longrightarrow>\n       x1 = {p. prop\\<^sub>r(p) \\<in> ps - ps}\n 3. \\<And>x1 x2.\n       ({}, {}) = (x1, x2) \\<Longrightarrow>\n       x2 = {p. nprop\\<^sub>r(p) \\<in> ps - ps}\n 4. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> ps;\n        case \\<sigma> of\n        (P, N) \\<Rightarrow>\n          P = {p. prop\\<^sub>r(p) \\<in> ps - it} \\<and>\n          N = {p. nprop\\<^sub>r(p) \\<in> ps - it};\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          prop\\<^sub>r(p) \\<Rightarrow>\n                            RETURN (insert p a, b)\n                          | nprop\\<^sub>r(p) \\<Rightarrow>\n                              RETURN (a, insert p b)\n                          | _ \\<Rightarrow> RETURN (a, b))\n                         \\<le> SPEC\n                                (\\<lambda>(P, N).\n                                    P =\n                                    {p. prop\\<^sub>r(p)\n  \\<in> ps - (it - {x})} \\<and>\n                                    N =\n                                    {p. nprop\\<^sub>r(p)\n  \\<in> ps - (it - {x})})\n 5. \\<And>\\<sigma>.\n       case \\<sigma> of\n       (P, N) \\<Rightarrow>\n         P = {p. prop\\<^sub>r(p) \\<in> ps - {}} \\<and>\n         N = {p. nprop\\<^sub>r(p) \\<in> ps - {}} \\<Longrightarrow>\n       \\<sigma> =\n       ({p. prop\\<^sub>r(p) \\<in> ps}, {p. nprop\\<^sub>r(p) \\<in> ps})", "apply (auto split: ltlr.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"pn_map nds \\<equiv> FOREACH nds \n  (\\<lambda>nd m. do {\n    PN \\<leftarrow> pn_props (old nd);\n    RETURN (m(name nd \\<mapsto> PN))\n  }) Map.empty\""], ["", "lemma pn_map_correct: \n  assumes [simp]: \"finite nds\"\n  assumes FIN': \"\\<And>nd. nd\\<in>nds \\<Longrightarrow> finite (old nd)\"\n  assumes INJ: \"inj_on name nds\"\n  shows \"pn_map nds \\<le> SPEC (\\<lambda>r. \\<forall>qn. \n    case r qn of \n      None \\<Rightarrow> qn \\<notin> name`nds\n    | Some (P,N) \\<Rightarrow> qn \\<in> name`nds \n      \\<and> P = {p. Prop_ltlr p \\<in> old (the_inv_into nds name qn)}\n      \\<and> N = {p. Nprop_ltlr p \\<in> old (the_inv_into nds name qn)}\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pn_map nds\n    \\<le> SPEC\n           (\\<lambda>r.\n               \\<forall>qn.\n                  case r qn of None \\<Rightarrow> qn \\<notin> name ` nds\n                  | Some (P, N) \\<Rightarrow>\n                      qn \\<in> name ` nds \\<and>\n                      P =\n                      {p. prop\\<^sub>r(p)\n                          \\<in> old (the_inv_into nds name qn)} \\<and>\n                      N =\n                      {p. nprop\\<^sub>r(p)\n                          \\<in> old (the_inv_into nds name qn)})", "unfolding pn_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH nds\n     (\\<lambda>nd m.\n         pn_props (old nd) \\<bind>\n         (\\<lambda>PN. RETURN (m(name nd \\<mapsto> PN))))\n     Map.empty\n    \\<le> SPEC\n           (\\<lambda>r.\n               \\<forall>qn.\n                  case r qn of None \\<Rightarrow> qn \\<notin> name ` nds\n                  | Some (P, N) \\<Rightarrow>\n                      qn \\<in> name ` nds \\<and>\n                      P =\n                      {p. prop\\<^sub>r(p)\n                          \\<in> old (the_inv_into nds name qn)} \\<and>\n                      N =\n                      {p. nprop\\<^sub>r(p)\n                          \\<in> old (the_inv_into nds name qn)})", "apply (refine_rcg refine_vcg\n    FOREACH_rule[where I=\"\\<lambda>it r. \\<forall>qn. \n      case r qn of \n        None \\<Rightarrow> qn \\<notin> name`(nds - it)\n      | Some (P,N) \\<Rightarrow> qn \\<in> name`(nds - it)\n        \\<and> P = {p. Prop_ltlr p \\<in> old (the_inv_into nds name qn)}\n        \\<and> N = {p. Nprop_ltlr p \\<in> old (the_inv_into nds name qn)}\"]\n    order_trans[OF pn_props_correct]\n  )"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite nds\n 2. \\<And>qn.\n       case None of None \\<Rightarrow> qn \\<notin> name ` (nds - nds)\n       | Some a \\<Rightarrow>\n           \\<forall>x1 x2.\n              a = (x1, x2) \\<longrightarrow>\n              qn \\<in> name ` (nds - nds) \\<and>\n              x1 =\n              {p. prop\\<^sub>r(p)\n                  \\<in> old (the_inv_into nds name qn)} \\<and>\n              x2 =\n              {p. nprop\\<^sub>r(p) \\<in> old (the_inv_into nds name qn)}\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> nds;\n        \\<forall>qn.\n           case \\<sigma> qn of\n           None \\<Rightarrow> qn \\<notin> name ` (nds - it)\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` (nds - it) \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)}\\<rbrakk>\n       \\<Longrightarrow> finite (old x)\n 4. \\<And>x it \\<sigma> xa qn.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> nds;\n        \\<forall>qn.\n           case \\<sigma> qn of\n           None \\<Rightarrow> qn \\<notin> name ` (nds - it)\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` (nds - it) \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p) \\<in> old (the_inv_into nds name qn)};\n        xa =\n        ({p. prop\\<^sub>r(p) \\<in> old x},\n         {p. nprop\\<^sub>r(p) \\<in> old x})\\<rbrakk>\n       \\<Longrightarrow> case (\\<sigma>(name x \\<mapsto> xa)) qn of\n                         None \\<Rightarrow>\n                           qn \\<notin> name ` (nds - (it - {x}))\n                         | Some a \\<Rightarrow>\n                             \\<forall>x1 x2.\n                                a = (x1, x2) \\<longrightarrow>\n                                qn \\<in> name ` (nds - (it - {x})) \\<and>\n                                x1 =\n                                {p. prop\\<^sub>r(p)\n                                    \\<in> old\n     (the_inv_into nds name qn)} \\<and>\n                                x2 =\n                                {p. nprop\\<^sub>r(p)\n                                    \\<in> old (the_inv_into nds name qn)}\n 5. \\<And>\\<sigma> qn.\n       \\<forall>qn.\n          case \\<sigma> qn of\n          None \\<Rightarrow> qn \\<notin> name ` (nds - {})\n          | Some (P, N) \\<Rightarrow>\n              qn \\<in> name ` (nds - {}) \\<and>\n              P =\n              {p. prop\\<^sub>r(p)\n                  \\<in> old (the_inv_into nds name qn)} \\<and>\n              N =\n              {p. nprop\\<^sub>r(p)\n                  \\<in> old (the_inv_into nds name qn)} \\<Longrightarrow>\n       case \\<sigma> qn of None \\<Rightarrow> qn \\<notin> name ` nds\n       | Some a \\<Rightarrow>\n           \\<forall>x1 x2.\n              a = (x1, x2) \\<longrightarrow>\n              qn \\<in> name ` nds \\<and>\n              x1 =\n              {p. prop\\<^sub>r(p)\n                  \\<in> old (the_inv_into nds name qn)} \\<and>\n              x2 =\n              {p. nprop\\<^sub>r(p) \\<in> old (the_inv_into nds name qn)}", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> nds;\n        \\<forall>qn.\n           case \\<sigma> qn of\n           None \\<Rightarrow> qn \\<notin> name ` (nds - it)\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` (nds - it) \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)}\\<rbrakk>\n       \\<Longrightarrow> finite (old x)\n 2. \\<And>x it \\<sigma> xa qn.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> nds;\n        \\<forall>qn.\n           case \\<sigma> qn of\n           None \\<Rightarrow> qn \\<notin> name ` (nds - it)\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` (nds - it) \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p) \\<in> old (the_inv_into nds name qn)};\n        xa =\n        ({p. prop\\<^sub>r(p) \\<in> old x},\n         {p. nprop\\<^sub>r(p) \\<in> old x})\\<rbrakk>\n       \\<Longrightarrow> (qn = name x \\<longrightarrow>\n                          name x \\<in> name ` (nds - (it - {x})) \\<and>\n                          {p. prop\\<^sub>r(p) \\<in> old x} =\n                          {p. prop\\<^sub>r(p)\n                              \\<in> old (the_inv_into nds name\n    (name x))} \\<and>\n                          {p. nprop\\<^sub>r(p) \\<in> old x} =\n                          {p. nprop\\<^sub>r(p)\n                              \\<in> old (the_inv_into nds name\n    (name x))}) \\<and>\n                         (qn \\<noteq> name x \\<longrightarrow>\n                          (case \\<sigma> qn of\n                           None \\<Rightarrow>\n                             qn \\<notin> name ` (nds - (it - {x}))\n                           | Some a \\<Rightarrow>\n                               \\<forall>x1 x2.\n                                  a = (x1, x2) \\<longrightarrow>\n                                  qn \\<in> name ` (nds - (it - {x})) \\<and>\n                                  x1 =\n                                  {p. prop\\<^sub>r(p)\n\\<in> old (the_inv_into nds name qn)} \\<and>\n                                  x2 =\n                                  {p. nprop\\<^sub>r(p)\n\\<in> old (the_inv_into nds name qn)}))\n 3. \\<And>\\<sigma> qn.\n       \\<forall>qn.\n          case \\<sigma> qn of\n          None \\<Rightarrow> qn \\<notin> name ` (nds - {})\n          | Some (P, N) \\<Rightarrow>\n              qn \\<in> name ` (nds - {}) \\<and>\n              P =\n              {p. prop\\<^sub>r(p)\n                  \\<in> old (the_inv_into nds name qn)} \\<and>\n              N =\n              {p. nprop\\<^sub>r(p)\n                  \\<in> old (the_inv_into nds name qn)} \\<Longrightarrow>\n       case \\<sigma> qn of None \\<Rightarrow> qn \\<notin> name ` nds\n       | Some a \\<Rightarrow>\n           \\<forall>x1 x2.\n              a = (x1, x2) \\<longrightarrow>\n              qn \\<in> name ` nds \\<and>\n              x1 =\n              {p. prop\\<^sub>r(p)\n                  \\<in> old (the_inv_into nds name qn)} \\<and>\n              x2 =\n              {p. nprop\\<^sub>r(p) \\<in> old (the_inv_into nds name qn)}", "apply (blast dest: subsetD[THEN FIN']) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma> xa qn.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> nds;\n        \\<forall>qn.\n           case \\<sigma> qn of\n           None \\<Rightarrow> qn \\<notin> name ` (nds - it)\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` (nds - it) \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p) \\<in> old (the_inv_into nds name qn)};\n        xa =\n        ({p. prop\\<^sub>r(p) \\<in> old x},\n         {p. nprop\\<^sub>r(p) \\<in> old x})\\<rbrakk>\n       \\<Longrightarrow> (qn = name x \\<longrightarrow>\n                          name x \\<in> name ` (nds - (it - {x})) \\<and>\n                          {p. prop\\<^sub>r(p) \\<in> old x} =\n                          {p. prop\\<^sub>r(p)\n                              \\<in> old (the_inv_into nds name\n    (name x))} \\<and>\n                          {p. nprop\\<^sub>r(p) \\<in> old x} =\n                          {p. nprop\\<^sub>r(p)\n                              \\<in> old (the_inv_into nds name\n    (name x))}) \\<and>\n                         (qn \\<noteq> name x \\<longrightarrow>\n                          (case \\<sigma> qn of\n                           None \\<Rightarrow>\n                             qn \\<notin> name ` (nds - (it - {x}))\n                           | Some a \\<Rightarrow>\n                               \\<forall>x1 x2.\n                                  a = (x1, x2) \\<longrightarrow>\n                                  qn \\<in> name ` (nds - (it - {x})) \\<and>\n                                  x1 =\n                                  {p. prop\\<^sub>r(p)\n\\<in> old (the_inv_into nds name qn)} \\<and>\n                                  x2 =\n                                  {p. nprop\\<^sub>r(p)\n\\<in> old (the_inv_into nds name qn)}))\n 2. \\<And>\\<sigma> qn.\n       \\<forall>qn.\n          case \\<sigma> qn of\n          None \\<Rightarrow> qn \\<notin> name ` (nds - {})\n          | Some (P, N) \\<Rightarrow>\n              qn \\<in> name ` (nds - {}) \\<and>\n              P =\n              {p. prop\\<^sub>r(p)\n                  \\<in> old (the_inv_into nds name qn)} \\<and>\n              N =\n              {p. nprop\\<^sub>r(p)\n                  \\<in> old (the_inv_into nds name qn)} \\<Longrightarrow>\n       case \\<sigma> qn of None \\<Rightarrow> qn \\<notin> name ` nds\n       | Some a \\<Rightarrow>\n           \\<forall>x1 x2.\n              a = (x1, x2) \\<longrightarrow>\n              qn \\<in> name ` nds \\<and>\n              x1 =\n              {p. prop\\<^sub>r(p)\n                  \\<in> old (the_inv_into nds name qn)} \\<and>\n              x2 =\n              {p. nprop\\<^sub>r(p) \\<in> old (the_inv_into nds name qn)}", "apply (force \n    split: option.splits \n    simp: the_inv_into_f_f[OF INJ] it_step_insert_iff) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> qn.\n       \\<forall>qn.\n          case \\<sigma> qn of\n          None \\<Rightarrow> qn \\<notin> name ` (nds - {})\n          | Some (P, N) \\<Rightarrow>\n              qn \\<in> name ` (nds - {}) \\<and>\n              P =\n              {p. prop\\<^sub>r(p)\n                  \\<in> old (the_inv_into nds name qn)} \\<and>\n              N =\n              {p. nprop\\<^sub>r(p)\n                  \\<in> old (the_inv_into nds name qn)} \\<Longrightarrow>\n       case \\<sigma> qn of None \\<Rightarrow> qn \\<notin> name ` nds\n       | Some a \\<Rightarrow>\n           \\<forall>x1 x2.\n              a = (x1, x2) \\<longrightarrow>\n              qn \\<in> name ` nds \\<and>\n              x1 =\n              {p. prop\\<^sub>r(p)\n                  \\<in> old (the_inv_into nds name qn)} \\<and>\n              x2 =\n              {p. nprop\\<^sub>r(p) \\<in> old (the_inv_into nds name qn)}", "apply (fastforce split: option.splits) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\\paragraph{ Assembling the Implementation }\\<close>"], ["", "definition \"cr_rename_gba nds \\<phi> \\<equiv> do {\n  let V = name ` nds;\n  let V0 = name ` {q \\<in> nds. expand_init \\<in> incoming q};\n  succmap \\<leftarrow> build_succ nds;\n  let E = E_of_succ (the_default {} o succmap);\n  let F = build_F nds \\<phi>;\n  pnm \\<leftarrow> pn_map nds;\n  let L = (\\<lambda>qn l. case pnm qn of \n      None \\<Rightarrow> False \n    | Some (P,N) \\<Rightarrow> (\\<forall>p\\<in>P. p\\<in>(l:::\\<^sub>r\\<langle>Id\\<rangle>fun_set_rel)) \\<and> (\\<forall>p\\<in>N. p\\<notin>l)\n  );\n  RETURN (\\<lparr> g_V = V, g_E=E, g_V0=V0, gbg_F = F, gba_L = L \\<rparr>)\n}\""], ["", "lemma cr_rename_gba_refine:\n  assumes INV: \"nds_invars nds\"\n  assumes REL[simplified]: \"(nds',nds)\\<in>Id\" \"(\\<phi>',\\<phi>)\\<in>Id\"\n  shows \"cr_rename_gba nds' \\<phi>' \n  \\<le> \\<Down>Id (RETURN (gba_rename_ext (\\<lambda>_. ()) name (create_gba_from_nodes \\<phi> nds)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_rename_gba nds' \\<phi>'\n    \\<le> \\<Down> Id\n           (RETURN (gba_rename name (create_gba_from_nodes \\<phi> nds)))", "unfolding RETURN_SPEC_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_rename_gba nds' \\<phi>'\n    \\<le> \\<Down> Id\n           (SPEC\n             (\\<lambda>x.\n                 x = gba_rename name (create_gba_from_nodes \\<phi> nds)))", "proof (rule Id_SPEC_refine)"], ["proof (state)\ngoal (1 subgoal):\n 1. cr_rename_gba nds' \\<phi>'\n    \\<le> SPEC\n           (\\<lambda>x.\n               x = gba_rename name (create_gba_from_nodes \\<phi> nds))", "from INV"], ["proof (chain)\npicking this:\n  nds_invars nds", "have\n    NINIT: \"expand_init \\<notin> name`nds\"\n    and FIN: \"finite nds\"\n    and FIN': \"\\<And>nd. nd\\<in>nds \\<Longrightarrow> finite (old nd)\"\n    and CL: \"\\<And>nd. nd\\<in>nds \\<Longrightarrow> incoming nd \\<subseteq> insert expand_init (name`nds)\"\n    and INJ: \"inj_on name nds\""], ["proof (prove)\nusing this:\n  nds_invars nds\n\ngoal (1 subgoal):\n 1. (expand_init \\<notin> name ` nds &&& finite nds) &&&\n    (\\<And>nd. nd \\<in> nds \\<Longrightarrow> finite (old nd)) &&&\n    (\\<And>nd.\n        nd \\<in> nds \\<Longrightarrow>\n        incoming nd \\<subseteq> insert expand_init (name ` nds)) &&&\n    inj_on name nds", "unfolding nds_invars_def"], ["proof (prove)\nusing this:\n  inj_on name nds \\<and>\n  finite nds \\<and>\n  expand_init \\<notin> name ` nds \\<and>\n  (\\<forall>nd\\<in>nds.\n      finite (old nd) \\<and>\n      incoming nd \\<subseteq> insert expand_init (name ` nds))\n\ngoal (1 subgoal):\n 1. (expand_init \\<notin> name ` nds &&& finite nds) &&&\n    (\\<And>nd. nd \\<in> nds \\<Longrightarrow> finite (old nd)) &&&\n    (\\<And>nd.\n        nd \\<in> nds \\<Longrightarrow>\n        incoming nd \\<subseteq> insert expand_init (name ` nds)) &&&\n    inj_on name nds", "by auto"], ["proof (state)\nthis:\n  expand_init \\<notin> name ` nds\n  finite nds\n  ?nd \\<in> nds \\<Longrightarrow> finite (old ?nd)\n  ?nd \\<in> nds \\<Longrightarrow>\n  incoming ?nd \\<subseteq> insert expand_init (name ` nds)\n  inj_on name nds\n\ngoal (1 subgoal):\n 1. cr_rename_gba nds' \\<phi>'\n    \\<le> SPEC\n           (\\<lambda>x.\n               x = gba_rename name (create_gba_from_nodes \\<phi> nds))", "show \"cr_rename_gba nds' \\<phi>'\n    \\<le> SPEC (\\<lambda>x. x = gba_rename_ext (\\<lambda>_. ()) name (create_gba_from_nodes \\<phi> nds))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_rename_gba nds' \\<phi>'\n    \\<le> SPEC\n           (\\<lambda>x.\n               x = gba_rename name (create_gba_from_nodes \\<phi> nds))", "unfolding REL"], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_rename_gba nds \\<phi>\n    \\<le> SPEC\n           (\\<lambda>x.\n               x = gba_rename name (create_gba_from_nodes \\<phi> nds))", "unfolding cr_rename_gba_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let V = name ` nds;\n         V0 = name ` {q \\<in> nds. expand_init \\<in> incoming q}\n     in build_succ nds \\<bind>\n        (\\<lambda>succmap.\n            let E = E_of_succ (the_default {} \\<circ> succmap);\n                F = build_F nds \\<phi>\n            in pn_map nds \\<bind>\n               (\\<lambda>pnm.\n                   let L = \\<lambda>qn l.\n                              case pnm qn of None \\<Rightarrow> False\n                              | Some (P, N) \\<Rightarrow>\n                                  (\\<forall>p\\<in>P.\np \\<in> (l ::: \\<langle>Id\\<rangle>fun_set_rel)) \\<and>\n                                  (\\<forall>p\\<in>N. p \\<notin> l)\n                   in RETURN\n                       \\<lparr>g_V = V, g_E = E, g_V0 = V0, gbg_F = F,\n                          gba_L = L\\<rparr>)))\n    \\<le> SPEC\n           (\\<lambda>x.\n               x = gba_rename name (create_gba_from_nodes \\<phi> nds))", "apply (refine_rcg refine_vcg\n      order_trans[OF build_succ_correct[OF NINIT FIN CL]]\n      order_trans[OF pn_map_correct[OF FIN FIN' INJ]]\n    )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>E_of_succ (\\<lambda>qn. the_default {} (x qn)) =\n                rename_E name\n                 {(q, q').\n                  q \\<in> nds \\<and>\n                  q' \\<in> nds \\<and> name q \\<in> incoming q'};\n        \\<forall>qn.\n           case xa qn of None \\<Rightarrow> qn \\<notin> name ` nds\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` nds \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)}\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>g_V = name ` nds,\n                            g_E = E_of_succ (the_default {} \\<circ> x),\n                            g_V0 =\n                              name `\n                              {q \\<in> nds. expand_init \\<in> incoming q},\n                            gbg_F = build_F nds \\<phi>,\n                            gba_L =\n                              \\<lambda>qn l.\n                                 case xa qn of None \\<Rightarrow> False\n                                 | Some (P, N) \\<Rightarrow>\n                                     (\\<forall>p\\<in>P.\n   p \\<in> (l ::: \\<langle>Id\\<rangle>fun_set_rel)) \\<and>\n                                     (\\<forall>p\\<in>N.\n   p \\<notin> l)\\<rparr> =\n                         gba_rename name (create_gba_from_nodes \\<phi> nds)", "unfolding gba_rename_ecnv_def gb_rename_ecnv_def \n      fr_rename_ext_def create_gba_from_nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>E_of_succ (\\<lambda>qn. the_default {} (x qn)) =\n                rename_E name\n                 {(q, q').\n                  q \\<in> nds \\<and>\n                  q' \\<in> nds \\<and> name q \\<in> incoming q'};\n        \\<forall>qn.\n           case xa qn of None \\<Rightarrow> qn \\<notin> name ` nds\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` nds \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)}\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>g_V = name ` nds,\n                            g_E = E_of_succ (the_default {} \\<circ> x),\n                            g_V0 =\n                              name `\n                              {q \\<in> nds. expand_init \\<in> incoming q},\n                            gbg_F = build_F nds \\<phi>,\n                            gba_L =\n                              \\<lambda>qn l.\n                                 case xa qn of None \\<Rightarrow> False\n                                 | Some (P, N) \\<Rightarrow>\n                                     (\\<forall>p\\<in>P.\n   p \\<in> (l ::: \\<langle>Id\\<rangle>fun_set_rel)) \\<and>\n                                     (\\<forall>p\\<in>N.\n   p \\<notin> l)\\<rparr> =\n                         \\<lparr>g_V =\n                                   name `\n                                   g_V \\<lparr>g_V = nds,\n    g_E =\n      {(q, q').\n       q \\<in> nds \\<and> q' \\<in> nds \\<and> name q \\<in> incoming q'},\n    g_V0 = {q \\<in> nds. expand_init \\<in> incoming q},\n    gbg_F =\n      {{q \\<in> nds.\n        \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n        \\<eta> \\<in> old q} |\n       \\<mu> \\<eta>. \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>},\n    gba_L =\n      \\<lambda>q l.\n         q \\<in> nds \\<and>\n         {p. prop\\<^sub>r(p) \\<in> old q} \\<subseteq> l \\<and>\n         {p. nprop\\<^sub>r(p) \\<in> old q} \\<inter> l = {}\\<rparr>,\n                            g_E =\n                              rename_E name\n                               (g_E \\<lparr>g_V = nds,\n g_E =\n   {(q, q').\n    q \\<in> nds \\<and> q' \\<in> nds \\<and> name q \\<in> incoming q'},\n g_V0 = {q \\<in> nds. expand_init \\<in> incoming q},\n gbg_F =\n   {{q \\<in> nds.\n     \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n     \\<eta> \\<in> old q} |\n    \\<mu> \\<eta>. \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>},\n gba_L =\n   \\<lambda>q l.\n      q \\<in> nds \\<and>\n      {p. prop\\<^sub>r(p) \\<in> old q} \\<subseteq> l \\<and>\n      {p. nprop\\<^sub>r(p) \\<in> old q} \\<inter> l = {}\\<rparr>),\n                            g_V0 =\n                              name `\n                              g_V0\n                               \\<lparr>g_V = nds,\n                                  g_E =\n                                    {(q, q').\n                                     q \\<in> nds \\<and>\n                                     q' \\<in> nds \\<and>\n                                     name q \\<in> incoming q'},\n                                  g_V0 =\n                                    {q \\<in> nds.\n                                     expand_init \\<in> incoming q},\n                                  gbg_F =\n                                    {{q \\<in> nds.\n\\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow> \\<eta> \\<in> old q} |\n                                     \\<mu> \\<eta>.\n                                     \\<mu> U\\<^sub>r \\<eta>\n                                     \\<in> subfrmlsr \\<phi>},\n                                  gba_L =\n                                    \\<lambda>q l.\n q \\<in> nds \\<and>\n {p. prop\\<^sub>r(p) \\<in> old q} \\<subseteq> l \\<and>\n {p. nprop\\<^sub>r(p) \\<in> old q} \\<inter> l = {}\\<rparr>,\n                            gbg_F =\n                              {name ` A |A.\n                               A \\<in> gbg_F\n  \\<lparr>g_V = nds,\n     g_E =\n       {(q, q').\n        q \\<in> nds \\<and> q' \\<in> nds \\<and> name q \\<in> incoming q'},\n     g_V0 = {q \\<in> nds. expand_init \\<in> incoming q},\n     gbg_F =\n       {{q \\<in> nds.\n         \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n         \\<eta> \\<in> old q} |\n        \\<mu> \\<eta>. \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>},\n     gba_L =\n       \\<lambda>q l.\n          q \\<in> nds \\<and>\n          {p. prop\\<^sub>r(p) \\<in> old q} \\<subseteq> l \\<and>\n          {p. nprop\\<^sub>r(p) \\<in> old q} \\<inter> l = {}\\<rparr>},\n                            gba_L =\n                              \\<lambda>q l.\n                                 if q \\<in> name `\n      g_V \\<lparr>g_V = nds,\n             g_E =\n               {(q, q').\n                q \\<in> nds \\<and>\n                q' \\<in> nds \\<and> name q \\<in> incoming q'},\n             g_V0 = {q \\<in> nds. expand_init \\<in> incoming q},\n             gbg_F =\n               {{q \\<in> nds.\n                 \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n                 \\<eta> \\<in> old q} |\n                \\<mu> \\<eta>.\n                \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>},\n             gba_L =\n               \\<lambda>q l.\n                  q \\<in> nds \\<and>\n                  {p. prop\\<^sub>r(p) \\<in> old q} \\<subseteq> l \\<and>\n                  {p. nprop\\<^sub>r(p) \\<in> old q} \\<inter> l = {}\\<rparr>\n                                 then gba_L\n \\<lparr>g_V = nds,\n    g_E =\n      {(q, q').\n       q \\<in> nds \\<and> q' \\<in> nds \\<and> name q \\<in> incoming q'},\n    g_V0 = {q \\<in> nds. expand_init \\<in> incoming q},\n    gbg_F =\n      {{q \\<in> nds.\n        \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n        \\<eta> \\<in> old q} |\n       \\<mu> \\<eta>. \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>},\n    gba_L =\n      \\<lambda>q l.\n         q \\<in> nds \\<and>\n         {p. prop\\<^sub>r(p) \\<in> old q} \\<subseteq> l \\<and>\n         {p. nprop\\<^sub>r(p) \\<in> old q} \\<inter> l = {}\\<rparr>\n (the_inv_into\n   (g_V \\<lparr>g_V = nds,\n           g_E =\n             {(q, q').\n              q \\<in> nds \\<and>\n              q' \\<in> nds \\<and> name q \\<in> incoming q'},\n           g_V0 = {q \\<in> nds. expand_init \\<in> incoming q},\n           gbg_F =\n             {{q \\<in> nds.\n               \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n               \\<eta> \\<in> old q} |\n              \\<mu> \\<eta>. \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>},\n           gba_L =\n             \\<lambda>q l.\n                q \\<in> nds \\<and>\n                {p. prop\\<^sub>r(p) \\<in> old q} \\<subseteq> l \\<and>\n                {p. nprop\\<^sub>r(p) \\<in> old q} \\<inter> l = {}\\<rparr>)\n   name q)\n l\n                                 else False\\<rparr>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>E_of_succ (\\<lambda>qn. the_default {} (x qn)) =\n                rename_E name\n                 {(q, q').\n                  q \\<in> nds \\<and>\n                  q' \\<in> nds \\<and> name q \\<in> incoming q'};\n        \\<forall>qn.\n           case xa qn of None \\<Rightarrow> qn \\<notin> name ` nds\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` nds \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)}\\<rbrakk>\n       \\<Longrightarrow> E_of_succ (the_default {} \\<circ> x) =\n                         rename_E name\n                          {(q, q').\n                           q \\<in> nds \\<and>\n                           q' \\<in> nds \\<and>\n                           name q \\<in> incoming q'} \\<and>\n                         build_F nds \\<phi> =\n                         {name ` A |A.\n                          \\<exists>\\<mu> \\<eta>.\n                             A =\n                             {q \\<in> nds.\n                              \\<mu> U\\<^sub>r \\<eta>\n                              \\<in> old q \\<longrightarrow>\n                              \\<eta> \\<in> old q} \\<and>\n                             \\<mu> U\\<^sub>r \\<eta>\n                             \\<in> subfrmlsr \\<phi>} \\<and>\n                         (\\<lambda>qn l.\n                             case xa qn of None \\<Rightarrow> False\n                             | Some (P, N) \\<Rightarrow>\n                                 (\\<forall>p\\<in>P.\n                                     p \\<in> (l :::\n        \\<langle>Id\\<rangle>fun_set_rel)) \\<and>\n                                 (\\<forall>p\\<in>N. p \\<notin> l)) =\n                         (\\<lambda>q l.\n                             q \\<in> name ` nds \\<and>\n                             the_inv_into nds name q \\<in> nds \\<and>\n                             {p. prop\\<^sub>r(p)\n                                 \\<in> old (the_inv_into nds name q)}\n                             \\<subseteq> l \\<and>\n                             {p. nprop\\<^sub>r(p)\n                                 \\<in> old\n  (the_inv_into nds name q)} \\<inter>\n                             l =\n                             {})", "apply (intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>E_of_succ (\\<lambda>qn. the_default {} (x qn)) =\n                rename_E name\n                 {(q, q').\n                  q \\<in> nds \\<and>\n                  q' \\<in> nds \\<and> name q \\<in> incoming q'};\n        \\<forall>qn.\n           case xa qn of None \\<Rightarrow> qn \\<notin> name ` nds\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` nds \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)}\\<rbrakk>\n       \\<Longrightarrow> E_of_succ (the_default {} \\<circ> x) =\n                         rename_E name\n                          {(q, q').\n                           q \\<in> nds \\<and>\n                           q' \\<in> nds \\<and> name q \\<in> incoming q'}\n 2. \\<And>x xa.\n       \\<lbrakk>E_of_succ (\\<lambda>qn. the_default {} (x qn)) =\n                rename_E name\n                 {(q, q').\n                  q \\<in> nds \\<and>\n                  q' \\<in> nds \\<and> name q \\<in> incoming q'};\n        \\<forall>qn.\n           case xa qn of None \\<Rightarrow> qn \\<notin> name ` nds\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` nds \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)}\\<rbrakk>\n       \\<Longrightarrow> build_F nds \\<phi> =\n                         {name ` A |A.\n                          \\<exists>\\<mu> \\<eta>.\n                             A =\n                             {q \\<in> nds.\n                              \\<mu> U\\<^sub>r \\<eta>\n                              \\<in> old q \\<longrightarrow>\n                              \\<eta> \\<in> old q} \\<and>\n                             \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}\n 3. \\<And>x xa.\n       \\<lbrakk>E_of_succ (\\<lambda>qn. the_default {} (x qn)) =\n                rename_E name\n                 {(q, q').\n                  q \\<in> nds \\<and>\n                  q' \\<in> nds \\<and> name q \\<in> incoming q'};\n        \\<forall>qn.\n           case xa qn of None \\<Rightarrow> qn \\<notin> name ` nds\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` nds \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)}\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>qn l.\n                             case xa qn of None \\<Rightarrow> False\n                             | Some (P, N) \\<Rightarrow>\n                                 (\\<forall>p\\<in>P.\n                                     p \\<in> (l :::\n        \\<langle>Id\\<rangle>fun_set_rel)) \\<and>\n                                 (\\<forall>p\\<in>N. p \\<notin> l)) =\n                         (\\<lambda>q l.\n                             q \\<in> name ` nds \\<and>\n                             the_inv_into nds name q \\<in> nds \\<and>\n                             {p. prop\\<^sub>r(p)\n                                 \\<in> old (the_inv_into nds name q)}\n                             \\<subseteq> l \\<and>\n                             {p. nprop\\<^sub>r(p)\n                                 \\<in> old\n  (the_inv_into nds name q)} \\<inter>\n                             l =\n                             {})", "apply (simp add: comp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>E_of_succ (\\<lambda>qn. the_default {} (x qn)) =\n                rename_E name\n                 {(q, q').\n                  q \\<in> nds \\<and>\n                  q' \\<in> nds \\<and> name q \\<in> incoming q'};\n        \\<forall>qn.\n           case xa qn of None \\<Rightarrow> qn \\<notin> name ` nds\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` nds \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)}\\<rbrakk>\n       \\<Longrightarrow> build_F nds \\<phi> =\n                         {name ` A |A.\n                          \\<exists>\\<mu> \\<eta>.\n                             A =\n                             {q \\<in> nds.\n                              \\<mu> U\\<^sub>r \\<eta>\n                              \\<in> old q \\<longrightarrow>\n                              \\<eta> \\<in> old q} \\<and>\n                             \\<mu> U\\<^sub>r \\<eta> \\<in> subfrmlsr \\<phi>}\n 2. \\<And>x xa.\n       \\<lbrakk>E_of_succ (\\<lambda>qn. the_default {} (x qn)) =\n                rename_E name\n                 {(q, q').\n                  q \\<in> nds \\<and>\n                  q' \\<in> nds \\<and> name q \\<in> incoming q'};\n        \\<forall>qn.\n           case xa qn of None \\<Rightarrow> qn \\<notin> name ` nds\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` nds \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)}\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>qn l.\n                             case xa qn of None \\<Rightarrow> False\n                             | Some (P, N) \\<Rightarrow>\n                                 (\\<forall>p\\<in>P.\n                                     p \\<in> (l :::\n        \\<langle>Id\\<rangle>fun_set_rel)) \\<and>\n                                 (\\<forall>p\\<in>N. p \\<notin> l)) =\n                         (\\<lambda>q l.\n                             q \\<in> name ` nds \\<and>\n                             the_inv_into nds name q \\<in> nds \\<and>\n                             {p. prop\\<^sub>r(p)\n                                 \\<in> old (the_inv_into nds name q)}\n                             \\<subseteq> l \\<and>\n                             {p. nprop\\<^sub>r(p)\n                                 \\<in> old\n  (the_inv_into nds name q)} \\<inter>\n                             l =\n                             {})", "apply (simp add: build_F_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>E_of_succ (\\<lambda>qn. the_default {} (x qn)) =\n                rename_E name\n                 {(q, q').\n                  q \\<in> nds \\<and>\n                  q' \\<in> nds \\<and> name q \\<in> incoming q'};\n        \\<forall>qn.\n           case xa qn of None \\<Rightarrow> qn \\<notin> name ` nds\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` nds \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)}\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>qn l.\n                             case xa qn of None \\<Rightarrow> False\n                             | Some (P, N) \\<Rightarrow>\n                                 (\\<forall>p\\<in>P.\n                                     p \\<in> (l :::\n        \\<langle>Id\\<rangle>fun_set_rel)) \\<and>\n                                 (\\<forall>p\\<in>N. p \\<notin> l)) =\n                         (\\<lambda>q l.\n                             q \\<in> name ` nds \\<and>\n                             the_inv_into nds name q \\<in> nds \\<and>\n                             {p. prop\\<^sub>r(p)\n                                 \\<in> old (the_inv_into nds name q)}\n                             \\<subseteq> l \\<and>\n                             {p. nprop\\<^sub>r(p)\n                                 \\<in> old\n  (the_inv_into nds name q)} \\<inter>\n                             l =\n                             {})", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa qn l.\n       \\<lbrakk>E_of_succ (\\<lambda>qn. the_default {} (x qn)) =\n                rename_E name\n                 {(q, q').\n                  q \\<in> nds \\<and>\n                  q' \\<in> nds \\<and> name q \\<in> incoming q'};\n        \\<forall>qn.\n           case xa qn of None \\<Rightarrow> qn \\<notin> name ` nds\n           | Some (P, N) \\<Rightarrow>\n               qn \\<in> name ` nds \\<and>\n               P =\n               {p. prop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)} \\<and>\n               N =\n               {p. nprop\\<^sub>r(p)\n                   \\<in> old (the_inv_into nds name qn)}\\<rbrakk>\n       \\<Longrightarrow> (case xa qn of None \\<Rightarrow> False\n                          | Some (P, N) \\<Rightarrow>\n                              (\\<forall>p\\<in>P.\n                                  p \\<in> (l :::\n     \\<langle>Id\\<rangle>fun_set_rel)) \\<and>\n                              (\\<forall>p\\<in>N. p \\<notin> l)) =\n                         (qn \\<in> name ` nds \\<and>\n                          the_inv_into nds name qn \\<in> nds \\<and>\n                          {p. prop\\<^sub>r(p)\n                              \\<in> old (the_inv_into nds name qn)}\n                          \\<subseteq> l \\<and>\n                          {p. nprop\\<^sub>r(p)\n                              \\<in> old (the_inv_into nds name qn)} \\<inter>\n                          l =\n                          {})", "apply (drule_tac x=qn in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa qn l.\n       \\<lbrakk>E_of_succ (\\<lambda>qn. the_default {} (x qn)) =\n                rename_E name\n                 {(q, q').\n                  q \\<in> nds \\<and>\n                  q' \\<in> nds \\<and> name q \\<in> incoming q'};\n        case xa qn of None \\<Rightarrow> qn \\<notin> name ` nds\n        | Some (P, N) \\<Rightarrow>\n            qn \\<in> name ` nds \\<and>\n            P =\n            {p. prop\\<^sub>r(p) \\<in> old (the_inv_into nds name qn)} \\<and>\n            N =\n            {p. nprop\\<^sub>r(p)\n                \\<in> old (the_inv_into nds name qn)}\\<rbrakk>\n       \\<Longrightarrow> (case xa qn of None \\<Rightarrow> False\n                          | Some (P, N) \\<Rightarrow>\n                              (\\<forall>p\\<in>P.\n                                  p \\<in> (l :::\n     \\<langle>Id\\<rangle>fun_set_rel)) \\<and>\n                              (\\<forall>p\\<in>N. p \\<notin> l)) =\n                         (qn \\<in> name ` nds \\<and>\n                          the_inv_into nds name qn \\<in> nds \\<and>\n                          {p. prop\\<^sub>r(p)\n                              \\<in> old (the_inv_into nds name qn)}\n                          \\<subseteq> l \\<and>\n                          {p. nprop\\<^sub>r(p)\n                              \\<in> old (the_inv_into nds name qn)} \\<inter>\n                          l =\n                          {})", "apply (auto simp: the_inv_into_f_f[OF INJ] split: option.split prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cr_rename_gba nds' \\<phi>'\n  \\<le> SPEC\n         (\\<lambda>x.\n             x = gba_rename name (create_gba_from_nodes \\<phi> nds))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"create_name_gba_aimpl \\<phi> \\<equiv> do {\n  nds \\<leftarrow> create_graph_aimpl \\<phi>;\n  ASSERT (nds_invars nds);\n  cr_rename_gba nds \\<phi>\n}\""], ["", "lemma create_name_gba_aimpl_refine: \n  \"create_name_gba_aimpl \\<phi> \\<le> \\<Down>Id (create_name_gba \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. create_name_gba_aimpl \\<phi> \\<le> \\<Down> Id (create_name_gba \\<phi>)", "unfolding create_name_gba_aimpl_def create_name_gba_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. create_graph_aimpl \\<phi> \\<bind>\n    (\\<lambda>nds.\n        ASSERT (nds_invars nds) \\<bind>\n        (\\<lambda>_. cr_rename_gba nds \\<phi>))\n    \\<le> \\<Down> Id\n           (create_graph\\<^sub>T \\<phi> \\<bind>\n            (\\<lambda>nds.\n                ASSERT (nds_invars nds) \\<bind>\n                (\\<lambda>_.\n                    RETURN\n                     (gba_rename name (create_gba_from_nodes \\<phi> nds)))))", "apply (refine_rcg create_graph_aimpl_refine cr_rename_gba_refine)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nds ndsa.\n       \\<lbrakk>(nds, ndsa) \\<in> Id; nds_invars ndsa\\<rbrakk>\n       \\<Longrightarrow> nds_invars nds\n 2. \\<And>nds ndsa.\n       \\<lbrakk>(nds, ndsa) \\<in> Id; nds_invars ndsa;\n        nds_invars nds\\<rbrakk>\n       \\<Longrightarrow> (\\<phi>, \\<phi>) \\<in> Id", "by auto"], ["", "subsection \\<open>Refinement to Efficient Data Structures\\<close>"], ["", "subsubsection \\<open>Creation of GBA from Nodes\\<close>"], ["", "schematic_goal until_frmlsr_impl_aux:\n  assumes [relator_props, simp]: \"R=Id\"\n  shows \"(?c,until_frmlsr) \n  \\<in> \\<langle>(R::(_\\<times>_::linorder) set)\\<rangle>ltlr_rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>ltlr_rel \\<times>\\<^sub>r \\<langle>R\\<rangle>ltlr_rel\\<rangle>dflt_rs_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, until_frmlsr)\n    \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>ltlr_rel \\<times>\\<^sub>r\n                   \\<langle>R\\<rangle>ltlr_rel\\<rangle>dflt_rs_rel", "unfolding until_frmlsr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     rec_ltlr {} {} (\\<lambda>_. {}) (\\<lambda>_. {})\n      (\\<lambda>\\<mu> \\<psi>. (\\<union>))\n      (\\<lambda>\\<mu> \\<psi>. (\\<union>)) (\\<lambda>\\<mu> \\<mu>'. \\<mu>')\n      (\\<lambda>\\<mu> \\<psi> \\<mu>' \\<psi>'.\n          insert (\\<mu>, \\<psi>) (\\<mu>' \\<union> \\<psi>'))\n      (\\<lambda>\\<mu> \\<psi>. (\\<union>)))\n    \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>ltlr_rel \\<times>\\<^sub>r\n                   \\<langle>R\\<rangle>ltlr_rel\\<rangle>dflt_rs_rel", "apply (autoref (keep_goal, trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition until_frmlsr_impl uses until_frmlsr_impl_aux"], ["", "lemmas [autoref_rules] = until_frmlsr_impl.refine[OF PREFER_id_D]"], ["", "schematic_goal build_succ_impl_aux:\n  shows \"(?c,build_succ) \\<in> \n    \\<langle>\\<langle>Rm,R\\<rangle>node_rel\\<rangle>list_set_rel \n    \\<rightarrow> \\<langle>\\<langle>nat_rel,\\<langle>nat_rel\\<rangle>list_set_rel\\<rangle>iam_map_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, build_succ)\n    \\<in> \\<langle>\\<langle>Rm,\n          R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel,\n          \\<langle>nat_rel\\<rangle>list_set_rel\\<rangle>iam_map_rel\\<rangle>nres_rel", "unfolding build_succ_def[abs_def] expand_init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>nds.\n        FOREACH nds\n         (\\<lambda>q'.\n             FOREACH (incoming q')\n              (\\<lambda>qn s.\n                  if qn = 0 then RETURN s\n                  else RETURN\n                        (s(qn \\<mapsto>\n                         insert (name q') (the_default {} (s qn))))))\n         Map.empty)\n    \\<in> \\<langle>\\<langle>Rm,\n          R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel,\n          \\<langle>nat_rel\\<rangle>list_set_rel\\<rangle>iam_map_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>nds.\n        FOREACH nds\n         (\\<lambda>q'.\n             FOREACH (incoming q')\n              (\\<lambda>qn s.\n                  if qn = 0 then RETURN s\n                  else RETURN\n                        (s(qn \\<mapsto>\n                         insert (name q') (the_default {} (s qn))))))\n         Map.empty)\n    \\<in> \\<langle>\\<langle>Rm,\n          R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel,\n          \\<langle>nat_rel\\<rangle>list_set_rel\\<rangle>iam_map_rel\\<rangle>nres_rel", "apply (autoref (keep_goal, trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition build_succ_impl uses build_succ_impl_aux"], ["", "lemmas [autoref_rules] = build_succ_impl.refine"], ["", "(* TODO: Post-processing should be on by default! *)"], ["", "schematic_goal build_succ_code_aux: \"RETURN ?c \\<le> build_succ_impl x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> build_succ_impl x", "unfolding build_succ_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> LIST_FOREACH' (RETURN (id x)) Impl_Array_Map.iam_invar\n           (\\<lambda>xa.\n               LIST_FOREACH'\n                (RETURN\n                  (it_to_list\n                    ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>))\n                      foldli rbt_to_list)\n                    (incoming_impl xa)))\n                Impl_Array_Map.iam_invar\n                (\\<lambda>xc xd.\n                    if xc = 0 then RETURN xd\n                    else RETURN\n                          (Impl_Array_Map.iam_update xc\n                            (glist_insert (=) (name_impl xa)\n                              (the_default []\n                                (Impl_Array_Map.iam_lookup xc xd)))\n                            xd)))\n           (Impl_Array_Map.iam_empty ())", "apply (refine_transfer (post))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition build_succ_code uses build_succ_code_aux"], ["", "lemmas [refine_transfer] = build_succ_code.refine"], ["", "schematic_goal build_F_impl_aux:\n  assumes [relator_props]:  \"R = Id\"\n  shows \"(?c,build_F) \\<in> \n    \\<langle>\\<langle>Rm,R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>\\<langle>nat_rel\\<rangle>list_set_rel\\<rangle>list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, build_F)\n    \\<in> \\<langle>\\<langle>Rm,\n          R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>list_set_rel\\<rangle>list_set_rel", "unfolding build_F_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>nds \\<phi>.\n        (\\<lambda>(\\<mu>, \\<eta>).\n            name `\n            {q \\<in> nds.\n             \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n             \\<eta> \\<in> old q}) `\n        until_frmlsr \\<phi>)\n    \\<in> \\<langle>\\<langle>Rm,\n          R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>list_set_rel\\<rangle>list_set_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>nds \\<phi>.\n        (\\<lambda>(\\<mu>, \\<eta>).\n            name `\n            {q \\<in> nds.\n             \\<mu> U\\<^sub>r \\<eta> \\<in> old q \\<longrightarrow>\n             \\<eta> \\<in> old q}) `\n        until_frmlsr \\<phi>)\n    \\<in> \\<langle>\\<langle>Rm,\n          R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>list_set_rel\\<rangle>list_set_rel", "apply (autoref (keep_goal, trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition build_F_impl uses build_F_impl_aux"], ["", "lemmas [autoref_rules] = build_F_impl.refine[OF PREFER_id_D]"], ["", "schematic_goal pn_map_impl_aux:\n  shows \"(?c,pn_map) \\<in> \n    \\<langle>\\<langle>Rm,Id\\<rangle>node_rel\\<rangle>list_set_rel \n    \\<rightarrow> \\<langle>\\<langle>nat_rel,\\<langle>Id\\<rangle>list_set_rel \\<times>\\<^sub>r \\<langle>Id\\<rangle>list_set_rel\\<rangle>iam_map_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, pn_map)\n    \\<in> \\<langle>\\<langle>Rm,\n          Id\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel,\n          \\<langle>Id\\<rangle>list_set_rel \\<times>\\<^sub>r\n          \\<langle>Id\\<rangle>list_set_rel\\<rangle>iam_map_rel\\<rangle>nres_rel", "unfolding pn_map_def[abs_def] pn_props_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>nds.\n        FOREACH nds\n         (\\<lambda>nd m.\n             FOREACH\\<^bsup>\\<lambda>it (P, N).\n                               P =\n                               {p. prop\\<^sub>r(p) \\<in> old nd - it} \\<and>\n                               N =\n                               {p. nprop\\<^sub>r(p)\n                                   \\<in> old nd - it}\\<^esup>\n              (old nd)\n              (\\<lambda>p (P, N).\n                  case p of\n                  prop\\<^sub>r(p) \\<Rightarrow> RETURN (insert p P, N)\n                  | nprop\\<^sub>r(p) \\<Rightarrow> RETURN (P, insert p N)\n                  | _ \\<Rightarrow> RETURN (P, N))\n              ({}, {}) \\<bind>\n             (\\<lambda>PN. RETURN (m(name nd \\<mapsto> PN))))\n         Map.empty)\n    \\<in> \\<langle>\\<langle>Rm,\n          Id\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel,\n          \\<langle>Id\\<rangle>list_set_rel \\<times>\\<^sub>r\n          \\<langle>Id\\<rangle>list_set_rel\\<rangle>iam_map_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>nds.\n        FOREACH nds\n         (\\<lambda>nd m.\n             FOREACH\\<^bsup>\\<lambda>it (P, N).\n                               P =\n                               {p. prop\\<^sub>r(p) \\<in> old nd - it} \\<and>\n                               N =\n                               {p. nprop\\<^sub>r(p)\n                                   \\<in> old nd - it}\\<^esup>\n              (old nd)\n              (\\<lambda>p (P, N).\n                  case p of\n                  prop\\<^sub>r(p) \\<Rightarrow> RETURN (insert p P, N)\n                  | nprop\\<^sub>r(p) \\<Rightarrow> RETURN (P, insert p N)\n                  | _ \\<Rightarrow> RETURN (P, N))\n              ({}, {}) \\<bind>\n             (\\<lambda>PN. RETURN (m(name nd \\<mapsto> PN))))\n         Map.empty)\n    \\<in> \\<langle>\\<langle>Rm,\n          Id\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel,\n          \\<langle>Id\\<rangle>list_set_rel \\<times>\\<^sub>r\n          \\<langle>Id\\<rangle>list_set_rel\\<rangle>iam_map_rel\\<rangle>nres_rel", "apply (autoref (keep_goal, trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition pn_map_impl uses pn_map_impl_aux"], ["", "lemma pn_map_impl_autoref[autoref_rules]: \n  assumes \"PREFER_id R\"\n  shows \"(pn_map_impl,pn_map) \\<in> \n    \\<langle>\\<langle>Rm,R\\<rangle>node_rel\\<rangle>list_set_rel \n    \\<rightarrow> \\<langle>\\<langle>nat_rel,\\<langle>R\\<rangle>list_set_rel \\<times>\\<^sub>r \\<langle>R\\<rangle>list_set_rel\\<rangle>iam_map_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pn_map_impl, pn_map)\n    \\<in> \\<langle>\\<langle>Rm,\n          R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel,\n          \\<langle>R\\<rangle>list_set_rel \\<times>\\<^sub>r\n          \\<langle>R\\<rangle>list_set_rel\\<rangle>iam_map_rel\\<rangle>nres_rel", "using assms pn_map_impl.refine"], ["proof (prove)\nusing this:\n  PREFER_id R\n  (pn_map_impl, pn_map)\n  \\<in> \\<langle>\\<langle>?Rm,\n        Id\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n        \\<langle>\\<langle>nat_rel,\n        \\<langle>Id\\<rangle>list_set_rel \\<times>\\<^sub>r\n        \\<langle>Id\\<rangle>list_set_rel\\<rangle>iam_map_rel\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (pn_map_impl, pn_map)\n    \\<in> \\<langle>\\<langle>Rm,\n          R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel,\n          \\<langle>R\\<rangle>list_set_rel \\<times>\\<^sub>r\n          \\<langle>R\\<rangle>list_set_rel\\<rangle>iam_map_rel\\<rangle>nres_rel", "by simp"], ["", "schematic_goal pn_map_code_aux: \"RETURN ?c \\<le> pn_map_impl x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> pn_map_impl x", "unfolding pn_map_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> LIST_FOREACH' (RETURN (id x)) Impl_Array_Map.iam_invar\n           (\\<lambda>xa xb.\n               LIST_FOREACH'\n                (RETURN (it_to_list lss.iteratei (old_impl xa)))\n                (\\<lambda>xc. True)\n                (\\<lambda>xc (xd, xe).\n                    case xc of\n                    prop\\<^sub>r(xf) \\<Rightarrow>\n                      RETURN (glist_insert (=) xf xd, xe)\n                    | nprop\\<^sub>r(xf) \\<Rightarrow>\n                        RETURN (xd, glist_insert (=) xf xe)\n                    | _ \\<Rightarrow> RETURN (xd, xe))\n                ([], []) \\<bind>\n               (\\<lambda>xc.\n                   RETURN (Impl_Array_Map.iam_update (name_impl xa) xc xb)))\n           (Impl_Array_Map.iam_empty ())", "apply (refine_transfer (post))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition pn_map_code uses pn_map_code_aux"], ["", "lemmas [refine_transfer] = pn_map_code.refine"], ["", "schematic_goal cr_rename_gba_impl_aux:\n  assumes ID[relator_props]: \"R=Id\"\n  notes [autoref_tyrel del] = tyrel_dflt_linorder_set\n  notes [autoref_tyrel] = ty_REL[of \"\\<langle>nat_rel\\<rangle>list_set_rel\"]\n  shows \"(?c,cr_rename_gba) \\<in> \n    \\<langle>\\<langle>Rm,R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> (?R::(?'c \\<times> _) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, cr_rename_gba)\n    \\<in> \\<langle>\\<langle>Rm,\n          R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> ?R", "unfolding ID"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, cr_rename_gba)\n    \\<in> \\<langle>\\<langle>Rm,\n          Id\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>Id\\<rangle>ltlr_rel \\<rightarrow> ?R", "unfolding cr_rename_gba_def[abs_def] expand_init_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>nds \\<phi>.\n        let V = name ` nds; V0 = name ` {q \\<in> nds. 0 \\<in> incoming q}\n        in build_succ nds \\<bind>\n           (\\<lambda>succmap.\n               let E = E_of_succ (\\<lambda>x. the_default {} (succmap x));\n                   F = build_F nds \\<phi>\n               in pn_map nds \\<bind>\n                  (\\<lambda>pnm.\n                      let L = \\<lambda>qn l.\n                                 case pnm qn of None \\<Rightarrow> False\n                                 | Some (P, N) \\<Rightarrow>\n                                     (\\<forall>p\\<in>P.\n   p \\<in> (l ::: \\<langle>Id\\<rangle>fun_set_rel)) \\<and>\n                                     (\\<forall>p\\<in>N. p \\<notin> l)\n                      in RETURN\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0, gbg_F = F,\n                             gba_L = L\\<rparr>)))\n    \\<in> \\<langle>\\<langle>Rm,\n          Id\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>Id\\<rangle>ltlr_rel \\<rightarrow> ?R", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>nds \\<phi>.\n        let V = name ` nds; V0 = name ` {q \\<in> nds. 0 \\<in> incoming q}\n        in build_succ nds \\<bind>\n           (\\<lambda>succmap.\n               let E = E_of_succ (\\<lambda>x. the_default {} (succmap x));\n                   F = build_F nds \\<phi>\n               in pn_map nds \\<bind>\n                  (\\<lambda>pnm.\n                      let L = \\<lambda>qn l.\n                                 case pnm qn of None \\<Rightarrow> False\n                                 | Some (P, N) \\<Rightarrow>\n                                     (\\<forall>p\\<in>P.\n   p \\<in> (l ::: \\<langle>Id\\<rangle>fun_set_rel)) \\<and>\n                                     (\\<forall>p\\<in>N. p \\<notin> l)\n                      in RETURN\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0, gbg_F = F,\n                             gba_L = L\\<rparr>)))\n    \\<in> \\<langle>\\<langle>Rm,\n          Id\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>Id\\<rangle>ltlr_rel \\<rightarrow> ?R", "apply (autoref (keep_goal, trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition cr_rename_gba_impl uses cr_rename_gba_impl_aux"], ["", "thm cr_rename_gba_impl.refine"], ["", "lemma cr_rename_gba_autoref[autoref_rules]:\n  assumes \"PREFER_id R\"\n  shows \"(cr_rename_gba_impl, cr_rename_gba) \\<in> \n    \\<langle>\\<langle>Rm, R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n    \\<langle>gbav_impl_rel_ext unit_rel nat_rel (\\<langle>R\\<rangle>fun_set_rel)\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_rename_gba_impl, cr_rename_gba)\n    \\<in> \\<langle>\\<langle>Rm,\n          R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>gbav_impl_rel_ext unit_rel nat_rel\n                    (\\<langle>R\\<rangle>fun_set_rel)\\<rangle>nres_rel", "using assms cr_rename_gba_impl.refine[of R Rm]"], ["proof (prove)\nusing this:\n  PREFER_id R\n  R = Id \\<Longrightarrow>\n  (cr_rename_gba_impl, cr_rename_gba)\n  \\<in> \\<langle>\\<langle>Rm,\n        R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n        \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n        \\<langle>gbav_impl_rel_ext unit_rel nat_rel\n                  (\\<langle>Id\\<rangle>fun_set_rel)\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (cr_rename_gba_impl, cr_rename_gba)\n    \\<in> \\<langle>\\<langle>Rm,\n          R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>gbav_impl_rel_ext unit_rel nat_rel\n                    (\\<langle>R\\<rangle>fun_set_rel)\\<rangle>nres_rel", "by simp"], ["", "schematic_goal cr_rename_gba_code_aux: \"RETURN ?c \\<le> cr_rename_gba_impl x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> cr_rename_gba_impl x y", "unfolding cr_rename_gba_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> (let y' = gen_image (\\<lambda>x. foldli (id x)) []\n                     (glist_insert (=)) name_impl x;\n               y'a =\n                 gen_image (\\<lambda>x. foldli (id x)) [] (glist_insert (=))\n                  name_impl\n                  (filter\n                    (\\<lambda>xb.\n                        map2set_memb (\\<lambda>k t. rbt_lookup t k) 0\n                         (incoming_impl xb))\n                    x)\n           in build_succ_impl x \\<bind>\n              (\\<lambda>xb.\n                  let y'b =\n                        \\<lambda>xc.\n                           the_default [] (Impl_Array_Map.iam_lookup xc xb);\n                      y'c = build_F_impl x y\n                  in pn_map_impl x \\<bind>\n                     (\\<lambda>xc.\n                         let y'd =\n                               \\<lambda>xd xe.\n                                  case Impl_Array_Map.iam_lookup xd xc of\n                                  None \\<Rightarrow> False\n                                  | Some (xf, xg) \\<Rightarrow>\nGen_Set.gen_ball (\\<lambda>x. foldli (id x)) xf xe \\<and>\nGen_Set.gen_ball (\\<lambda>x. foldli (id x)) xg (\\<lambda>xh. \\<not> xe xh)\n                         in RETURN\n                             \\<lparr>gi_V = y', gi_E = y'b, gi_V0 = y'a,\n                                gbgi_F = y'c, gbai_L = y'd\\<rparr>)))", "apply (refine_transfer (post))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition cr_rename_gba_code uses cr_rename_gba_code_aux"], ["", "lemmas [refine_transfer] = cr_rename_gba_code.refine"], ["", "subsubsection \\<open>Creation of Graph\\<close>"], ["", "text \\<open>\n  The implementation of the node-set. The relation enforces that there are no\n  different nodes with the same name. This effectively establishes an additional\n  invariant, made explicit by an assertion in the refined program. This invariant\n  allows for a more efficient implementation.\n\\<close>"], ["", "definition ls_nds_rel_def_internal: \n  \"ls_nds_rel R \\<equiv> \\<langle>R\\<rangle>list_set_rel \\<inter> {(_,s). inj_on name s}\""], ["", "lemma ls_nds_rel_def: \"\\<langle>R\\<rangle>ls_nds_rel = \\<langle>R\\<rangle>list_set_rel \\<inter> {(_,s). inj_on name s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>ls_nds_rel =\n    \\<langle>R\\<rangle>list_set_rel \\<inter> {(uu_, s). inj_on name s}", "by (simp add: relAPP_def ls_nds_rel_def_internal)"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of ls_nds_rel i_set]"], ["", "lemma ls_nds_rel_sv[relator_props]: \n  assumes \"single_valued R\" \n  shows \"single_valued (\\<langle>R\\<rangle>ls_nds_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (\\<langle>R\\<rangle>ls_nds_rel)", "using list_set_rel_sv[OF assms]"], ["proof (prove)\nusing this:\n  single_valued (\\<langle>R\\<rangle>list_set_rel)\n\ngoal (1 subgoal):\n 1. single_valued (\\<langle>R\\<rangle>ls_nds_rel)", "unfolding ls_nds_rel_def"], ["proof (prove)\nusing this:\n  single_valued (\\<langle>R\\<rangle>list_set_rel)\n\ngoal (1 subgoal):\n 1. single_valued\n     (\\<langle>R\\<rangle>list_set_rel \\<inter> {(uu_, y). inj_on name y})", "by (metis inf.cobounded1 single_valued_subset)"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lsnds_empty_autoref[autoref_rules]:\n  assumes \"PREFER_id R\"\n  shows \"([],{})\\<in>\\<langle>R\\<rangle>ls_nds_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], {}) \\<in> \\<langle>R\\<rangle>ls_nds_rel", "using assms"], ["proof (prove)\nusing this:\n  PREFER_id R\n\ngoal (1 subgoal):\n 1. ([], {}) \\<in> \\<langle>R\\<rangle>ls_nds_rel", "apply (simp add: ls_nds_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. R = Id \\<Longrightarrow> ([], {}) \\<in> \\<langle>Id\\<rangle>list_set_rel", "by autoref"], ["", "lemma lsnds_insert_autoref[autoref_rules]:\n  assumes \"SIDE_PRECOND (name n \\<notin> name`ns)\"\n  assumes \"(n',n)\\<in>R\"\n  assumes \"(ns',ns)\\<in>\\<langle>R\\<rangle>ls_nds_rel\"\n  shows \"(n'#ns',(OP insert ::: R \\<rightarrow> \\<langle>R\\<rangle>ls_nds_rel \\<rightarrow> \\<langle>R\\<rangle>ls_nds_rel)$n$ns)\n   \\<in> \\<langle>R\\<rangle>ls_nds_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n' # ns',\n     (OP insert :::\n      R \\<rightarrow>\n      \\<langle>R\\<rangle>ls_nds_rel \\<rightarrow>\n      \\<langle>R\\<rangle>ls_nds_rel) $\n     n $\n     ns)\n    \\<in> \\<langle>R\\<rangle>ls_nds_rel", "using assms"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (name n \\<notin> name ` ns)\n  (n', n) \\<in> R\n  (ns', ns) \\<in> \\<langle>R\\<rangle>ls_nds_rel\n\ngoal (1 subgoal):\n 1. (n' # ns',\n     (OP insert :::\n      R \\<rightarrow>\n      \\<langle>R\\<rangle>ls_nds_rel \\<rightarrow>\n      \\<langle>R\\<rangle>ls_nds_rel) $\n     n $\n     ns)\n    \\<in> \\<langle>R\\<rangle>ls_nds_rel", "unfolding ls_nds_rel_def"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (name n \\<notin> name ` ns)\n  (n', n) \\<in> R\n  (ns', ns)\n  \\<in> \\<langle>R\\<rangle>list_set_rel \\<inter> {(uu_, y). inj_on name y}\n\ngoal (1 subgoal):\n 1. (n' # ns',\n     (OP insert :::\n      R \\<rightarrow>\n      \\<langle>R\\<rangle>list_set_rel \\<inter>\n      {(uu_, y). inj_on name y} \\<rightarrow>\n      \\<langle>R\\<rangle>list_set_rel \\<inter> {(uu_, y). inj_on name y}) $\n     n $\n     ns)\n    \\<in> \\<langle>R\\<rangle>list_set_rel \\<inter> {(uu_, y). inj_on name y}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>name n \\<notin> name ` ns; (n', n) \\<in> R;\n     (ns', ns) \\<in> \\<langle>R\\<rangle>list_set_rel \\<and>\n     inj_on name ns\\<rbrakk>\n    \\<Longrightarrow> (n' # ns', insert n ns)\n                      \\<in> \\<langle>R\\<rangle>list_set_rel \\<and>\n                      name n \\<notin> name ` (ns - {n})", "proof (elim conjE, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>name n \\<notin> name ` ns; (n', n) \\<in> R;\n     (ns', ns) \\<in> \\<langle>R\\<rangle>list_set_rel;\n     inj_on name ns\\<rbrakk>\n    \\<Longrightarrow> (n' # ns', insert n ns)\n                      \\<in> \\<langle>R\\<rangle>list_set_rel\n 2. \\<lbrakk>name n \\<notin> name ` ns; (n', n) \\<in> R;\n     (ns', ns) \\<in> \\<langle>R\\<rangle>list_set_rel;\n     inj_on name ns\\<rbrakk>\n    \\<Longrightarrow> name n \\<notin> name ` (ns - {n})", "assume [autoref_rules]: \"(n', n) \\<in> R\" \"(ns', ns) \\<in> \\<langle>R\\<rangle>list_set_rel\""], ["proof (state)\nthis:\n  (n', n) \\<in> R\n  (ns', ns) \\<in> \\<langle>R\\<rangle>list_set_rel\n\ngoal (2 subgoals):\n 1. \\<lbrakk>name n \\<notin> name ` ns; (n', n) \\<in> R;\n     (ns', ns) \\<in> \\<langle>R\\<rangle>list_set_rel;\n     inj_on name ns\\<rbrakk>\n    \\<Longrightarrow> (n' # ns', insert n ns)\n                      \\<in> \\<langle>R\\<rangle>list_set_rel\n 2. \\<lbrakk>name n \\<notin> name ` ns; (n', n) \\<in> R;\n     (ns', ns) \\<in> \\<langle>R\\<rangle>list_set_rel;\n     inj_on name ns\\<rbrakk>\n    \\<Longrightarrow> name n \\<notin> name ` (ns - {n})", "assume \"name n \\<notin> name ` ns\"\n    and \"inj_on name ns\""], ["proof (state)\nthis:\n  name n \\<notin> name ` ns\n  inj_on name ns\n\ngoal (2 subgoals):\n 1. \\<lbrakk>name n \\<notin> name ` ns; (n', n) \\<in> R;\n     (ns', ns) \\<in> \\<langle>R\\<rangle>list_set_rel;\n     inj_on name ns\\<rbrakk>\n    \\<Longrightarrow> (n' # ns', insert n ns)\n                      \\<in> \\<langle>R\\<rangle>list_set_rel\n 2. \\<lbrakk>name n \\<notin> name ` ns; (n', n) \\<in> R;\n     (ns', ns) \\<in> \\<langle>R\\<rangle>list_set_rel;\n     inj_on name ns\\<rbrakk>\n    \\<Longrightarrow> name n \\<notin> name ` (ns - {n})", "then"], ["proof (chain)\npicking this:\n  name n \\<notin> name ` ns\n  inj_on name ns", "have \"n \\<notin> ns\""], ["proof (prove)\nusing this:\n  name n \\<notin> name ` ns\n  inj_on name ns\n\ngoal (1 subgoal):\n 1. n \\<notin> ns", "by (auto)"], ["proof (state)\nthis:\n  n \\<notin> ns\n\ngoal (2 subgoals):\n 1. \\<lbrakk>name n \\<notin> name ` ns; (n', n) \\<in> R;\n     (ns', ns) \\<in> \\<langle>R\\<rangle>list_set_rel;\n     inj_on name ns\\<rbrakk>\n    \\<Longrightarrow> (n' # ns', insert n ns)\n                      \\<in> \\<langle>R\\<rangle>list_set_rel\n 2. \\<lbrakk>name n \\<notin> name ` ns; (n', n) \\<in> R;\n     (ns', ns) \\<in> \\<langle>R\\<rangle>list_set_rel;\n     inj_on name ns\\<rbrakk>\n    \\<Longrightarrow> name n \\<notin> name ` (ns - {n})", "then"], ["proof (chain)\npicking this:\n  n \\<notin> ns", "show \"(n' # ns', insert n ns) \\<in> \\<langle>R\\<rangle>list_set_rel\""], ["proof (prove)\nusing this:\n  n \\<notin> ns\n\ngoal (1 subgoal):\n 1. (n' # ns', insert n ns) \\<in> \\<langle>R\\<rangle>list_set_rel", "by autoref"], ["proof (state)\nthis:\n  (n' # ns', insert n ns) \\<in> \\<langle>R\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>name n \\<notin> name ` ns; (n', n) \\<in> R;\n     (ns', ns) \\<in> \\<langle>R\\<rangle>list_set_rel;\n     inj_on name ns\\<rbrakk>\n    \\<Longrightarrow> name n \\<notin> name ` (ns - {n})", "qed auto"], ["", "lemma ls_nds_image_autoref_aux:\n  assumes [autoref_rules]: \"(fi,f) \\<in> Ra \\<rightarrow> Rb\"\n  assumes \"(l,s) \\<in> \\<langle>Ra\\<rangle>ls_nds_rel\"\n  assumes [simp]: \"\\<forall>x. name (f x) = name x\"\n  shows \"(map fi l, f`s) \\<in> \\<langle>Rb\\<rangle>ls_nds_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>ls_nds_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>ls_nds_rel", "from assms"], ["proof (chain)\npicking this:\n  (fi, f) \\<in> Ra \\<rightarrow> Rb\n  (l, s) \\<in> \\<langle>Ra\\<rangle>ls_nds_rel\n  \\<forall>x. name (f x) = name x", "have \n    [autoref_rules]: \"(l,s)\\<in>\\<langle>Ra\\<rangle>list_set_rel\" \n      and INJ: \"(inj_on name s)\""], ["proof (prove)\nusing this:\n  (fi, f) \\<in> Ra \\<rightarrow> Rb\n  (l, s) \\<in> \\<langle>Ra\\<rangle>ls_nds_rel\n  \\<forall>x. name (f x) = name x\n\ngoal (1 subgoal):\n 1. (l, s) \\<in> \\<langle>Ra\\<rangle>list_set_rel &&& inj_on name s", "by (auto simp add: ls_nds_rel_def)"], ["proof (state)\nthis:\n  (l, s) \\<in> \\<langle>Ra\\<rangle>list_set_rel\n  inj_on name s\n\ngoal (1 subgoal):\n 1. (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>ls_nds_rel", "have [simp]: \"inj_on f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f s", "by (rule inj_onI) (metis INJ assms(3) inj_on_eq_iff)"], ["proof (state)\nthis:\n  inj_on f s\n\ngoal (1 subgoal):\n 1. (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>ls_nds_rel", "have \"(map fi l, f`s) \\<in> \\<langle>Rb\\<rangle>list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>list_set_rel", "by (autoref (keep_goal))"], ["proof (state)\nthis:\n  (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>ls_nds_rel", "moreover"], ["proof (state)\nthis:\n  (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>ls_nds_rel", "have \"inj_on name (f`s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on name (f ` s)", "apply (rule inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> f ` s; y \\<in> f ` s; name x = name y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (auto simp: image_iff dest: inj_onD[OF INJ])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inj_on name (f ` s)\n\ngoal (1 subgoal):\n 1. (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>ls_nds_rel", "ultimately"], ["proof (chain)\npicking this:\n  (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>list_set_rel\n  inj_on name (f ` s)", "show ?thesis"], ["proof (prove)\nusing this:\n  (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>list_set_rel\n  inj_on name (f ` s)\n\ngoal (1 subgoal):\n 1. (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>ls_nds_rel", "by (auto simp: ls_nds_rel_def)"], ["proof (state)\nthis:\n  (map fi l, f ` s) \\<in> \\<langle>Rb\\<rangle>ls_nds_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ls_nds_image_autoref[autoref_rules]:\n  assumes \"(fi,f) \\<in> Ra \\<rightarrow> Rb\"\n  assumes \"SIDE_PRECOND (\\<forall>x. name (f x) = name x)\"\n  shows \"(map fi, (OP (`) ::: (Ra\\<rightarrow>Rb) \\<rightarrow> \\<langle>Ra\\<rangle>ls_nds_rel \\<rightarrow> \\<langle>Rb\\<rangle>ls_nds_rel)$f) \n    \\<in> \\<langle>Ra\\<rangle>ls_nds_rel \\<rightarrow> \\<langle>Rb\\<rangle>ls_nds_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map fi,\n     (OP (`) :::\n      (Ra \\<rightarrow> Rb) \\<rightarrow>\n      \\<langle>Ra\\<rangle>ls_nds_rel \\<rightarrow>\n      \\<langle>Rb\\<rangle>ls_nds_rel) $\n     f)\n    \\<in> \\<langle>Ra\\<rangle>ls_nds_rel \\<rightarrow>\n          \\<langle>Rb\\<rangle>ls_nds_rel", "using assms"], ["proof (prove)\nusing this:\n  (fi, f) \\<in> Ra \\<rightarrow> Rb\n  SIDE_PRECOND (\\<forall>x. name (f x) = name x)\n\ngoal (1 subgoal):\n 1. (map fi,\n     (OP (`) :::\n      (Ra \\<rightarrow> Rb) \\<rightarrow>\n      \\<langle>Ra\\<rangle>ls_nds_rel \\<rightarrow>\n      \\<langle>Rb\\<rangle>ls_nds_rel) $\n     f)\n    \\<in> \\<langle>Ra\\<rangle>ls_nds_rel \\<rightarrow>\n          \\<langle>Rb\\<rangle>ls_nds_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  (fi, f) \\<in> Ra \\<rightarrow> Rb\n  \\<forall>x. name (f x) = name x\n\ngoal (1 subgoal):\n 1. (map fi, (`) f)\n    \\<in> \\<langle>Ra\\<rangle>ls_nds_rel \\<rightarrow>\n          \\<langle>Rb\\<rangle>ls_nds_rel", "using ls_nds_image_autoref_aux"], ["proof (prove)\nusing this:\n  (fi, f) \\<in> Ra \\<rightarrow> Rb\n  \\<forall>x. name (f x) = name x\n  \\<lbrakk>(?fi, ?f) \\<in> ?Ra \\<rightarrow> ?Rb;\n   (?l, ?s) \\<in> \\<langle>?Ra\\<rangle>ls_nds_rel;\n   \\<forall>x. name (?f x) = name x\\<rbrakk>\n  \\<Longrightarrow> (map ?fi ?l, ?f ` ?s)\n                    \\<in> \\<langle>?Rb\\<rangle>ls_nds_rel\n\ngoal (1 subgoal):\n 1. (map fi, (`) f)\n    \\<in> \\<langle>Ra\\<rangle>ls_nds_rel \\<rightarrow>\n          \\<langle>Rb\\<rangle>ls_nds_rel", "by blast"], ["", "lemma list_set_autoref_to_list[autoref_ga_rules]: \n  shows \"is_set_to_sorted_list (\\<lambda>_ _. True) R ls_nds_rel id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_set_to_sorted_list (\\<lambda>_ _. True) R ls_nds_rel id", "unfolding is_set_to_list_def is_set_to_sorted_list_def ls_nds_rel_def\n    it_to_sorted_list_def list_set_rel_def br_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (s, s')\n       \\<in> \\<langle>R\\<rangle>list_rel O\n             {(c, a). a = set c \\<and> distinct c} \\<inter>\n             {(uu_, y). inj_on name y} \\<longrightarrow>\n       (\\<exists>l'.\n           (id s, l') \\<in> \\<langle>R\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> SPEC\n                  (\\<lambda>l.\n                      distinct l \\<and>\n                      s' = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l))", "by auto"], ["", "end"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_itype]:\n  \"upd_incoming \n    ::\\<^sub>i \\<langle>Im, I\\<rangle>\\<^sub>ii_node \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Im', I\\<rangle>\\<^sub>ii_node\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Im', I\\<rangle>\\<^sub>ii_node\\<rangle>\\<^sub>ii_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upd_incoming ::\\<^sub>i\n    \\<langle>Im, I\\<rangle>\\<^sub>ii_node \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>Im',\n    I\\<rangle>\\<^sub>ii_node\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>Im', I\\<rangle>\\<^sub>ii_node\\<rangle>\\<^sub>ii_set", "by simp"], ["", "end"], ["", "term upd_incoming"], ["", "schematic_goal upd_incoming_impl_aux:\n  assumes \"REL_IS_ID R\"\n  shows \"(?c, upd_incoming)\\<in>\\<langle>Rm1,R\\<rangle>node_rel \n  \\<rightarrow> \\<langle>\\<langle>Rm2,R\\<rangle>node_rel\\<rangle>ls_nds_rel \n  \\<rightarrow> \\<langle>\\<langle>Rm2,R\\<rangle>node_rel\\<rangle>ls_nds_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, upd_incoming)\n    \\<in> \\<langle>Rm1, R\\<rangle>node_rel \\<rightarrow>\n          \\<langle>\\<langle>Rm2,\n          R\\<rangle>node_rel\\<rangle>ls_nds_rel \\<rightarrow>\n          \\<langle>\\<langle>Rm2, R\\<rangle>node_rel\\<rangle>ls_nds_rel", "using assms"], ["proof (prove)\nusing this:\n  REL_IS_ID R\n\ngoal (1 subgoal):\n 1. (?c, upd_incoming)\n    \\<in> \\<langle>Rm1, R\\<rangle>node_rel \\<rightarrow>\n          \\<langle>\\<langle>Rm2,\n          R\\<rangle>node_rel\\<rangle>ls_nds_rel \\<rightarrow>\n          \\<langle>\\<langle>Rm2, R\\<rangle>node_rel\\<rangle>ls_nds_rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. R = Id \\<Longrightarrow>\n    (?c, upd_incoming)\n    \\<in> \\<langle>Rm1, Id\\<rangle>node_rel \\<rightarrow>\n          \\<langle>\\<langle>Rm2,\n          Id\\<rangle>node_rel\\<rangle>ls_nds_rel \\<rightarrow>\n          \\<langle>\\<langle>Rm2, Id\\<rangle>node_rel\\<rangle>ls_nds_rel", "unfolding upd_incoming_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. R = Id \\<Longrightarrow>\n    (?c, \\<lambda>n. (`) (upd_incoming_f n))\n    \\<in> \\<langle>Rm1, Id\\<rangle>node_rel \\<rightarrow>\n          \\<langle>\\<langle>Rm2,\n          Id\\<rangle>node_rel\\<rangle>ls_nds_rel \\<rightarrow>\n          \\<langle>\\<langle>Rm2, Id\\<rangle>node_rel\\<rangle>ls_nds_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. R = Id \\<Longrightarrow>\n    (?c, \\<lambda>n. (`) (upd_incoming_f n))\n    \\<in> \\<langle>Rm1, Id\\<rangle>node_rel \\<rightarrow>\n          \\<langle>\\<langle>Rm2,\n          Id\\<rangle>node_rel\\<rangle>ls_nds_rel \\<rightarrow>\n          \\<langle>\\<langle>Rm2, Id\\<rangle>node_rel\\<rangle>ls_nds_rel", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition upd_incoming_impl uses upd_incoming_impl_aux"], ["", "lemmas [autoref_rules] = upd_incoming_impl.refine[OF PREFER_D[of REL_IS_ID]]"], ["", "schematic_goal expand_impl_aux: \"(?c, expand_aimpl) \\<in> \n  \\<langle>unit_rel,Id\\<rangle>node_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,Id\\<rangle>node_rel\\<rangle>ls_nds_rel \n  \\<rightarrow> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,Id\\<rangle>node_rel\\<rangle>ls_nds_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, expand_aimpl)\n    \\<in> \\<langle>unit_rel, Id\\<rangle>node_rel \\<times>\\<^sub>r\n          \\<langle>\\<langle>unit_rel,\n          Id\\<rangle>node_rel\\<rangle>ls_nds_rel \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n                   Id\\<rangle>node_rel\\<rangle>ls_nds_rel\\<rangle>nres_rel", "unfolding expand_aimpl_def[abs_def] expand_new_name_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     REC\\<^sub>T\n      (\\<lambda>expand (n, ns).\n          if new n = {}\n          then if \\<exists>n'\\<in>ns. old n' = old n \\<and> next n' = next n\n               then RETURN (name n, upd_incoming n ns)\n               else ASSERT (n \\<notin> ns) \\<bind>\n                    (\\<lambda>_.\n                        ASSERT (name n \\<notin> name ` ns) \\<bind>\n                        (\\<lambda>_.\n                            expand\n                             (\\<lparr>name = Suc (name n),\n                                 incoming = {name n}, new = next n,\n                                 old = {}, next = {}\\<rparr>,\n                              insert n ns)))\n          else SPEC (\\<lambda>x. x \\<in> new n) \\<bind>\n               (\\<lambda>\\<phi>.\n                   let n = n\\<lparr>new := new n - {\\<phi>}\\<rparr>\n                   in case \\<phi> of\n                      true\\<^sub>r \\<Rightarrow>\n                        expand\n                         (n\\<lparr>old := {\\<phi>} \\<union> old n\\<rparr>,\n                          ns)\n                      | false\\<^sub>r \\<Rightarrow> RETURN (name n, ns)\n                      | prop\\<^sub>r(q) \\<Rightarrow>\n                          if nprop\\<^sub>r(q) \\<in> old n\n                          then RETURN (name n, ns)\n                          else expand\n                                (n\\<lparr>old :=\n      {\\<phi>} \\<union> old n\\<rparr>,\n                                 ns)\n                      | nprop\\<^sub>r(q) \\<Rightarrow>\n                          if prop\\<^sub>r(q) \\<in> old n\n                          then RETURN (name n, ns)\n                          else expand\n                                (n\\<lparr>old :=\n      {\\<phi>} \\<union> old n\\<rparr>,\n                                 ns)\n                      | \\<nu> and\\<^sub>r \\<mu> \\<Rightarrow>\n                          expand\n                           (n\\<lparr>new :=\n insert \\<nu> (insert \\<mu> (new n)),\n                                old := {\\<phi>} \\<union> old n,\n                                next := next n\\<rparr>,\n                            ns)\n                      | \\<mu> or\\<^sub>r \\<nu> \\<Rightarrow>\n                          expand\n                           (n\\<lparr>new := insert \\<mu> (new n),\n                                old := insert \\<phi> (old n),\n                                next := {} \\<union> next n\\<rparr>,\n                            ns) \\<bind>\n                          (\\<lambda>(nm, nds).\n                              expand\n                               (n\\<lparr>name := nm,\n                                    new := {\\<nu>} \\<union> new n,\n                                    old := {\\<phi>} \\<union> old n\\<rparr>,\n                                nds))\n                      | X\\<^sub>r \\<nu> \\<Rightarrow>\n                          expand\n                           (n\\<lparr>new := new n,\n                                old := {\\<phi>} \\<union> old n,\n                                next := insert \\<nu> (next n)\\<rparr>,\n                            ns)\n                      | \\<mu> U\\<^sub>r \\<nu> \\<Rightarrow>\n                          expand\n                           (n\\<lparr>new := insert \\<mu> (new n),\n                                old := insert \\<phi> (old n),\n                                next := {\\<phi>} \\<union> next n\\<rparr>,\n                            ns) \\<bind>\n                          (\\<lambda>(nm, nds).\n                              expand\n                               (n\\<lparr>name := nm,\n                                    new := {\\<nu>} \\<union> new n,\n                                    old := {\\<phi>} \\<union> old n\\<rparr>,\n                                nds))\n                      | \\<mu> R\\<^sub>r \\<nu> \\<Rightarrow>\n                          expand\n                           (n\\<lparr>new := insert \\<nu> (new n),\n                                old := insert \\<phi> (old n),\n                                next := {\\<phi>} \\<union> next n\\<rparr>,\n                            ns) \\<bind>\n                          (\\<lambda>(nm, nds).\n                              expand\n                               (n\\<lparr>name := nm,\n                                    new := {\\<mu>, \\<nu>} \\<union> new n,\n                                    old := {\\<phi>} \\<union> old n\\<rparr>,\n                                nds)))))\n    \\<in> \\<langle>unit_rel, Id\\<rangle>node_rel \\<times>\\<^sub>r\n          \\<langle>\\<langle>unit_rel,\n          Id\\<rangle>node_rel\\<rangle>ls_nds_rel \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n                   Id\\<rangle>node_rel\\<rangle>ls_nds_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id, autoref_trace_intf_unif]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     REC\\<^sub>T\n      (\\<lambda>expand (n, ns).\n          if new n = {}\n          then if \\<exists>n'\\<in>ns. old n' = old n \\<and> next n' = next n\n               then RETURN (name n, upd_incoming n ns)\n               else ASSERT (n \\<notin> ns) \\<bind>\n                    (\\<lambda>_.\n                        ASSERT (name n \\<notin> name ` ns) \\<bind>\n                        (\\<lambda>_.\n                            expand\n                             (\\<lparr>name = Suc (name n),\n                                 incoming = {name n}, new = next n,\n                                 old = {}, next = {}\\<rparr>,\n                              insert n ns)))\n          else SPEC (\\<lambda>x. x \\<in> new n) \\<bind>\n               (\\<lambda>\\<phi>.\n                   let n = n\\<lparr>new := new n - {\\<phi>}\\<rparr>\n                   in case \\<phi> of\n                      true\\<^sub>r \\<Rightarrow>\n                        expand\n                         (n\\<lparr>old := {\\<phi>} \\<union> old n\\<rparr>,\n                          ns)\n                      | false\\<^sub>r \\<Rightarrow> RETURN (name n, ns)\n                      | prop\\<^sub>r(q) \\<Rightarrow>\n                          if nprop\\<^sub>r(q) \\<in> old n\n                          then RETURN (name n, ns)\n                          else expand\n                                (n\\<lparr>old :=\n      {\\<phi>} \\<union> old n\\<rparr>,\n                                 ns)\n                      | nprop\\<^sub>r(q) \\<Rightarrow>\n                          if prop\\<^sub>r(q) \\<in> old n\n                          then RETURN (name n, ns)\n                          else expand\n                                (n\\<lparr>old :=\n      {\\<phi>} \\<union> old n\\<rparr>,\n                                 ns)\n                      | \\<nu> and\\<^sub>r \\<mu> \\<Rightarrow>\n                          expand\n                           (n\\<lparr>new :=\n insert \\<nu> (insert \\<mu> (new n)),\n                                old := {\\<phi>} \\<union> old n,\n                                next := next n\\<rparr>,\n                            ns)\n                      | \\<mu> or\\<^sub>r \\<nu> \\<Rightarrow>\n                          expand\n                           (n\\<lparr>new := insert \\<mu> (new n),\n                                old := insert \\<phi> (old n),\n                                next := {} \\<union> next n\\<rparr>,\n                            ns) \\<bind>\n                          (\\<lambda>(nm, nds).\n                              expand\n                               (n\\<lparr>name := nm,\n                                    new := {\\<nu>} \\<union> new n,\n                                    old := {\\<phi>} \\<union> old n\\<rparr>,\n                                nds))\n                      | X\\<^sub>r \\<nu> \\<Rightarrow>\n                          expand\n                           (n\\<lparr>new := new n,\n                                old := {\\<phi>} \\<union> old n,\n                                next := insert \\<nu> (next n)\\<rparr>,\n                            ns)\n                      | \\<mu> U\\<^sub>r \\<nu> \\<Rightarrow>\n                          expand\n                           (n\\<lparr>new := insert \\<mu> (new n),\n                                old := insert \\<phi> (old n),\n                                next := {\\<phi>} \\<union> next n\\<rparr>,\n                            ns) \\<bind>\n                          (\\<lambda>(nm, nds).\n                              expand\n                               (n\\<lparr>name := nm,\n                                    new := {\\<nu>} \\<union> new n,\n                                    old := {\\<phi>} \\<union> old n\\<rparr>,\n                                nds))\n                      | \\<mu> R\\<^sub>r \\<nu> \\<Rightarrow>\n                          expand\n                           (n\\<lparr>new := insert \\<nu> (new n),\n                                old := insert \\<phi> (old n),\n                                next := {\\<phi>} \\<union> next n\\<rparr>,\n                            ns) \\<bind>\n                          (\\<lambda>(nm, nds).\n                              expand\n                               (n\\<lparr>name := nm,\n                                    new := {\\<mu>, \\<nu>} \\<union> new n,\n                                    old := {\\<phi>} \\<union> old n\\<rparr>,\n                                nds)))))\n    \\<in> \\<langle>unit_rel, Id\\<rangle>node_rel \\<times>\\<^sub>r\n          \\<langle>\\<langle>unit_rel,\n          Id\\<rangle>node_rel\\<rangle>ls_nds_rel \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n                   Id\\<rangle>node_rel\\<rangle>ls_nds_rel\\<rangle>nres_rel", "apply (autoref (trace,keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition expand_impl uses expand_impl_aux"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_itype]: \"expand\\<^sub>T \n  ::\\<^sub>i \\<langle>\\<langle>i_unit, I\\<rangle>\\<^sub>ii_node, \\<langle>\\<langle>i_unit, I\\<rangle>\\<^sub>ii_node\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_prod \n  \\<rightarrow>\\<^sub>i \\<langle>\\<langle>i_nat,\\<langle>\\<langle>i_unit, I\\<rangle>\\<^sub>ii_node\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expand\\<^sub>T ::\\<^sub>i\n    \\<langle>\\<langle>i_unit, I\\<rangle>\\<^sub>ii_node,\n    \\<langle>\\<langle>i_unit,\n    I\\<rangle>\\<^sub>ii_node\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>i_nat, \\<langle>\\<langle>i_unit,\n    I\\<rangle>\\<^sub>ii_node\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres", "by simp"], ["", "lemma expand_autoref[autoref_rules]:\n  assumes ID: \"PREFER_id R\"\n  assumes A: \"(n_ns', n_ns) \n    \\<in> \\<langle>unit_rel,R\\<rangle>node_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,R\\<rangle>node_rel\\<rangle>list_set_rel\"\n  assumes B: \"SIDE_PRECOND (\n    let (n,ns)=n_ns in inj_on name ns \\<and> (\\<forall>n'\\<in>ns. name n > name n')\n  )\"\n  shows \"(expand_impl n_ns', \n    (OP expand_aimpl\n    ::: \\<langle>unit_rel,R\\<rangle>node_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,R\\<rangle>node_rel\\<rangle>list_set_rel \n    \\<rightarrow> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel)$n_ns) \n  \\<in> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (expand_impl n_ns',\n     (OP expand_aimpl :::\n      \\<langle>unit_rel, R\\<rangle>node_rel \\<times>\\<^sub>r\n      \\<langle>\\<langle>unit_rel,\n      R\\<rangle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n      \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n               R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel) $\n     n_ns)\n    \\<in> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n                   R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. (expand_impl n_ns', expand_aimpl n_ns)\n    \\<in> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n                   R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel", "from ID A B"], ["proof (chain)\npicking this:\n  PREFER_id R\n  (n_ns', n_ns)\n  \\<in> \\<langle>unit_rel, R\\<rangle>node_rel \\<times>\\<^sub>r\n        \\<langle>\\<langle>unit_rel, R\\<rangle>node_rel\\<rangle>list_set_rel\n  SIDE_PRECOND\n   (let (n, ns) = n_ns\n    in inj_on name ns \\<and> (\\<forall>n'\\<in>ns. name n' < name n))", "have \n    1: \"(n_ns, n_ns) \\<in> Id \\<inter> {(_,(n,ns)). \\<forall>n'\\<in>ns. name n > name n'}\"\n    and 2: \"(n_ns', n_ns) \n      \\<in> \\<langle>unit_rel,Id\\<rangle>node_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,Id\\<rangle>node_rel\\<rangle>ls_nds_rel\""], ["proof (prove)\nusing this:\n  PREFER_id R\n  (n_ns', n_ns)\n  \\<in> \\<langle>unit_rel, R\\<rangle>node_rel \\<times>\\<^sub>r\n        \\<langle>\\<langle>unit_rel, R\\<rangle>node_rel\\<rangle>list_set_rel\n  SIDE_PRECOND\n   (let (n, ns) = n_ns\n    in inj_on name ns \\<and> (\\<forall>n'\\<in>ns. name n' < name n))\n\ngoal (1 subgoal):\n 1. (n_ns, n_ns)\n    \\<in> Id \\<inter>\n          {(uu_, n, ns). \\<forall>n'\\<in>ns. name n' < name n} &&&\n    (n_ns', n_ns)\n    \\<in> \\<langle>unit_rel, Id\\<rangle>node_rel \\<times>\\<^sub>r\n          \\<langle>\\<langle>unit_rel, Id\\<rangle>node_rel\\<rangle>ls_nds_rel", "unfolding ls_nds_rel_def"], ["proof (prove)\nusing this:\n  PREFER_id R\n  (n_ns', n_ns)\n  \\<in> \\<langle>unit_rel, R\\<rangle>node_rel \\<times>\\<^sub>r\n        \\<langle>\\<langle>unit_rel, R\\<rangle>node_rel\\<rangle>list_set_rel\n  SIDE_PRECOND\n   (let (n, ns) = n_ns\n    in inj_on name ns \\<and> (\\<forall>n'\\<in>ns. name n' < name n))\n\ngoal (1 subgoal):\n 1. (n_ns, n_ns)\n    \\<in> Id \\<inter>\n          {(uu_, n, ns). \\<forall>n'\\<in>ns. name n' < name n} &&&\n    (n_ns', n_ns)\n    \\<in> \\<langle>unit_rel, Id\\<rangle>node_rel \\<times>\\<^sub>r\n          \\<langle>\\<langle>unit_rel,\n          Id\\<rangle>node_rel\\<rangle>list_set_rel \\<inter>\n          {(uu_, y). inj_on name y}", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>PREFER_id R;\n     (n_ns', n_ns)\n     \\<in> \\<langle>unit_rel, R\\<rangle>node_rel \\<times>\\<^sub>r\n           \\<langle>\\<langle>unit_rel,\n           R\\<rangle>node_rel\\<rangle>list_set_rel;\n     SIDE_PRECOND\n      (let (n, ns) = n_ns\n       in inj_on name ns \\<and>\n          (\\<forall>n'\\<in>ns. name n' < name n))\\<rbrakk>\n    \\<Longrightarrow> (n_ns, n_ns)\n                      \\<in> Id \\<inter>\n                            {(uu_, n, ns).\n                             \\<forall>n'\\<in>ns. name n' < name n}\n 2. \\<lbrakk>PREFER_id R;\n     (n_ns', n_ns)\n     \\<in> \\<langle>unit_rel, R\\<rangle>node_rel \\<times>\\<^sub>r\n           \\<langle>\\<langle>unit_rel,\n           R\\<rangle>node_rel\\<rangle>list_set_rel;\n     SIDE_PRECOND\n      (let (n, ns) = n_ns\n       in inj_on name ns \\<and>\n          (\\<forall>n'\\<in>ns. name n' < name n))\\<rbrakk>\n    \\<Longrightarrow> (n_ns', n_ns)\n                      \\<in> \\<langle>unit_rel,\n                            Id\\<rangle>node_rel \\<times>\\<^sub>r\n                            \\<langle>\\<langle>unit_rel,\n                            Id\\<rangle>node_rel\\<rangle>list_set_rel \\<inter>\n                            {(uu_, y). inj_on name y}", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PREFER_id R;\n     (n_ns', n_ns)\n     \\<in> \\<langle>unit_rel, R\\<rangle>node_rel \\<times>\\<^sub>r\n           \\<langle>\\<langle>unit_rel,\n           R\\<rangle>node_rel\\<rangle>list_set_rel;\n     SIDE_PRECOND\n      (let (n, ns) = n_ns\n       in inj_on name ns \\<and>\n          (\\<forall>n'\\<in>ns. name n' < name n))\\<rbrakk>\n    \\<Longrightarrow> (n_ns', n_ns)\n                      \\<in> \\<langle>unit_rel,\n                            Id\\<rangle>node_rel \\<times>\\<^sub>r\n                            \\<langle>\\<langle>unit_rel,\n                            Id\\<rangle>node_rel\\<rangle>list_set_rel \\<inter>\n                            {(uu_, y). inj_on name y}", "apply (cases n_ns')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>PREFER_id R;\n        (n_ns', n_ns)\n        \\<in> \\<langle>unit_rel, R\\<rangle>node_rel \\<times>\\<^sub>r\n              \\<langle>\\<langle>unit_rel,\n              R\\<rangle>node_rel\\<rangle>list_set_rel;\n        SIDE_PRECOND\n         (let (n, ns) = n_ns\n          in inj_on name ns \\<and> (\\<forall>n'\\<in>ns. name n' < name n));\n        n_ns' = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (n_ns', n_ns)\n                         \\<in> \\<langle>unit_rel,\n                               Id\\<rangle>node_rel \\<times>\\<^sub>r\n                               \\<langle>\\<langle>unit_rel,\n                               Id\\<rangle>node_rel\\<rangle>list_set_rel \\<inter>\n                               {(uu_, y). inj_on name y}", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (n_ns, n_ns)\n  \\<in> Id \\<inter> {(uu_, n, ns). \\<forall>n'\\<in>ns. name n' < name n}\n  (n_ns', n_ns)\n  \\<in> \\<langle>unit_rel, Id\\<rangle>node_rel \\<times>\\<^sub>r\n        \\<langle>\\<langle>unit_rel, Id\\<rangle>node_rel\\<rangle>ls_nds_rel\n\ngoal (1 subgoal):\n 1. (expand_impl n_ns', expand_aimpl n_ns)\n    \\<in> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n                   R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel", "have [simp]: \"single_valued (nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel, Id\\<rangle>node_rel\\<rangle>list_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued\n     (nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n      Id\\<rangle>node_rel\\<rangle>list_set_rel)", "by tagged_solver"], ["proof (state)\nthis:\n  single_valued\n   (nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n    Id\\<rangle>node_rel\\<rangle>list_set_rel)\n\ngoal (1 subgoal):\n 1. (expand_impl n_ns', expand_aimpl n_ns)\n    \\<in> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n                   R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel", "have [relator_props]: \"\\<And>R. single_valued (Id \\<inter> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>R. single_valued (Id \\<inter> R)", "by (metis IntE single_valuedD single_valuedI single_valued_Id)"], ["proof (state)\nthis:\n  single_valued (Id \\<inter> ?R1)\n\ngoal (1 subgoal):\n 1. (expand_impl n_ns', expand_aimpl n_ns)\n    \\<in> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n                   R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel", "have [simp]: \"single_valued ((nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel, Id\\<rangle>node_rel\\<rangle>ls_nds_rel) O\n                          (Id \\<inter> {(_, n, ns). \\<forall>n'\\<in>ns. name n' < n}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued\n     ((nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n       Id\\<rangle>node_rel\\<rangle>ls_nds_rel) O\n      (Id \\<inter> {(uu_, n, ns). \\<forall>n'\\<in>ns. name n' < n}))", "by (tagged_solver)"], ["proof (state)\nthis:\n  single_valued\n   ((nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n     Id\\<rangle>node_rel\\<rangle>ls_nds_rel) O\n    (Id \\<inter> {(uu_, n, ns). \\<forall>n'\\<in>ns. name n' < n}))\n\ngoal (1 subgoal):\n 1. (expand_impl n_ns', expand_aimpl n_ns)\n    \\<in> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n                   R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel", "from expand_impl.refine[THEN fun_relD, OF 2, THEN nres_relD]"], ["proof (chain)\npicking this:\n  expand_impl n_ns'\n  \\<le> \\<Down>\n         (nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n          Id\\<rangle>node_rel\\<rangle>ls_nds_rel)\n         (expand_aimpl n_ns)", "show \"(expand_impl n_ns', expand_aimpl n_ns)\n    \\<in> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel, R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel\""], ["proof (prove)\nusing this:\n  expand_impl n_ns'\n  \\<le> \\<Down>\n         (nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n          Id\\<rangle>node_rel\\<rangle>ls_nds_rel)\n         (expand_aimpl n_ns)\n\ngoal (1 subgoal):\n 1. (expand_impl n_ns', expand_aimpl n_ns)\n    \\<in> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n                   R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. expand_impl n_ns'\n    \\<le> \\<Down>\n           (nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n            Id\\<rangle>node_rel\\<rangle>ls_nds_rel)\n           (expand_aimpl n_ns) \\<Longrightarrow>\n    (expand_impl n_ns', expand_aimpl n_ns)\n    \\<in> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n                   R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel", "apply (rule nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. expand_impl n_ns'\n    \\<le> \\<Down>\n           (nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n            Id\\<rangle>node_rel\\<rangle>ls_nds_rel)\n           (expand_aimpl n_ns) \\<Longrightarrow>\n    expand_impl n_ns'\n    \\<le> \\<Down>\n           (nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n            R\\<rangle>node_rel\\<rangle>list_set_rel)\n           (expand_aimpl n_ns)", "using ID"], ["proof (prove)\nusing this:\n  PREFER_id R\n\ngoal (1 subgoal):\n 1. expand_impl n_ns'\n    \\<le> \\<Down>\n           (nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n            Id\\<rangle>node_rel\\<rangle>ls_nds_rel)\n           (expand_aimpl n_ns) \\<Longrightarrow>\n    expand_impl n_ns'\n    \\<le> \\<Down>\n           (nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n            R\\<rangle>node_rel\\<rangle>list_set_rel)\n           (expand_aimpl n_ns)", "apply (simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail (expand_aimpl n_ns) \\<longrightarrow>\n             nofail (expand_impl n_ns') \\<and>\n             (\\<forall>a b.\n                 inres (expand_impl n_ns') (a, b) \\<longrightarrow>\n                 (\\<exists>ba.\n                     (b, ba) \\<in> \\<langle>\\<langle>unit_rel,\n                     Id\\<rangle>node_rel\\<rangle>ls_nds_rel \\<and>\n                     inres (expand_aimpl n_ns) (a, ba)));\n     R = Id\\<rbrakk>\n    \\<Longrightarrow> nofail (expand_aimpl n_ns) \\<longrightarrow>\n                      (\\<forall>a b.\n                          inres (expand_impl n_ns') (a, b) \\<longrightarrow>\n                          (\\<exists>ba.\n                              (b, ba) \\<in> \\<langle>\\<langle>unit_rel,\n                              Id\\<rangle>node_rel\\<rangle>list_set_rel \\<and>\n                              inres (expand_aimpl n_ns) (a, ba)))", "apply (fastforce simp: ls_nds_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (expand_impl n_ns', expand_aimpl n_ns)\n  \\<in> \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>\\<langle>unit_rel,\n                 R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "schematic_goal expand_code_aux: \"RETURN ?c \\<le> expand_impl n_ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> expand_impl n_ns", "unfolding expand_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> REC\\<^sub>T\n           (\\<lambda>x (xa, xb).\n               if lss.isEmpty (new_impl xa)\n               then if Gen_Set.gen_bex (\\<lambda>x. foldli (id x)) xb\n                        (\\<lambda>xc.\n                            lss.equal (old_impl xc) (old_impl xa) \\<and>\n                            lss.equal (next_impl xc) (next_impl xa))\n                    then RETURN (name_impl xa, upd_incoming_impl xa xb)\n                    else x (\\<lparr>name_impl = Suc (name_impl xa),\n                               incoming_impl =\n                                 map2set_insert rbt_insert (name_impl xa)\n                                  rbt.Empty,\n                               new_impl = next_impl xa,\n                               old_impl = lss.empty (),\n                               next_impl = lss.empty ()\\<rparr>,\n                            xa # xb)\n               else RETURN\n                     (the (lss.sel (new_impl xa)\n                            (\\<lambda>_. True))) \\<bind>\n                    (\\<lambda>xc.\n                        let y' = xa\n                              \\<lparr>new_impl :=\n  lss.delete xc (new_impl xa)\\<rparr>\n                        in case xc of\n                           true\\<^sub>r \\<Rightarrow>\n                             x (y'\\<lparr>old_impl :=\n      lss.union (lss.ins_dj xc (lss.empty ())) (old_impl y')\\<rparr>,\n                                xb)\n                           | false\\<^sub>r \\<Rightarrow>\n                               RETURN (name_impl y', xb)\n                           | prop\\<^sub>r(xd) \\<Rightarrow>\n                               if lss.memb nprop\\<^sub>r(xd) (old_impl y')\n                               then RETURN (name_impl y', xb)\n                               else x (y'\n \\<lparr>old_impl :=\n           lss.union (lss.ins_dj xc (lss.empty ())) (old_impl y')\\<rparr>,\n xb)\n                           | nprop\\<^sub>r(xd) \\<Rightarrow>\n                               if lss.memb prop\\<^sub>r(xd) (old_impl y')\n                               then RETURN (name_impl y', xb)\n                               else x (y'\n \\<lparr>old_impl :=\n           lss.union (lss.ins_dj xc (lss.empty ())) (old_impl y')\\<rparr>,\n xb)\n                           | xd and\\<^sub>r xe \\<Rightarrow>\n                               x (y'\\<lparr>new_impl :=\n        lss.ins xd (lss.ins xe (new_impl y')),\n old_impl := lss.union (lss.ins_dj xc (lss.empty ())) (old_impl y'),\n next_impl := next_impl y'\\<rparr>,\n                                  xb)\n                           | xd or\\<^sub>r xe \\<Rightarrow>\n                               x (y'\\<lparr>new_impl :=\n        lss.ins xd (new_impl y'),\n old_impl := lss.ins xc (old_impl y'),\n next_impl := lss.union_dj (lss.empty ()) (next_impl y')\\<rparr>,\n                                  xb) \\<bind>\n                               (\\<lambda>(xf, xg).\n                                   x (y'\n\\<lparr>name_impl := xf,\n   new_impl := lss.union (lss.ins_dj xe (lss.empty ())) (new_impl y'),\n   old_impl :=\n     lss.union (lss.ins_dj xc (lss.empty ())) (old_impl y')\\<rparr>,\nxg))\n                           | X\\<^sub>r xd \\<Rightarrow>\n                               x (y'\\<lparr>new_impl := new_impl y',\n old_impl := lss.union (lss.ins_dj xc (lss.empty ())) (old_impl y'),\n next_impl := lss.ins xd (next_impl y')\\<rparr>,\n                                  xb)\n                           | xd U\\<^sub>r xe \\<Rightarrow>\n                               x (y'\\<lparr>new_impl :=\n        lss.ins xd (new_impl y'),\n old_impl := lss.ins xc (old_impl y'),\n next_impl :=\n   lss.union (lss.ins_dj xc (lss.empty ())) (next_impl y')\\<rparr>,\n                                  xb) \\<bind>\n                               (\\<lambda>(xf, xg).\n                                   x (y'\n\\<lparr>name_impl := xf,\n   new_impl := lss.union (lss.ins_dj xe (lss.empty ())) (new_impl y'),\n   old_impl :=\n     lss.union (lss.ins_dj xc (lss.empty ())) (old_impl y')\\<rparr>,\nxg))\n                           | xd R\\<^sub>r xe \\<Rightarrow>\n                               x (y'\\<lparr>new_impl :=\n        lss.ins xe (new_impl y'),\n old_impl := lss.ins xc (old_impl y'),\n next_impl :=\n   lss.union (lss.ins_dj xc (lss.empty ())) (next_impl y')\\<rparr>,\n                                  xb) \\<bind>\n                               (\\<lambda>(xf, xg).\n                                   x (y'\n\\<lparr>name_impl := xf,\n   new_impl :=\n     lss.union (lss.ins xd (lss.ins_dj xe (lss.empty ()))) (new_impl y'),\n   old_impl :=\n     lss.union (lss.ins_dj xc (lss.empty ())) (old_impl y')\\<rparr>,\nxg))))\n           n_ns", "by (refine_transfer the_resI)"], ["", "concrete_definition expand_code uses expand_code_aux"], ["", "prepare_code_thms expand_code_def"], ["", "lemmas [refine_transfer] = expand_code.refine"], ["", "schematic_goal create_graph_impl_aux: \n  assumes ID: \"R=Id\"\n  shows \"(?c, create_graph_aimpl) \n    \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>\\<langle>\\<langle>unit_rel,R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, create_graph_aimpl)\n    \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>unit_rel,\n          R\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel", "unfolding ID"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, create_graph_aimpl)\n    \\<in> \\<langle>Id\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>unit_rel,\n          Id\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel", "unfolding create_graph_aimpl_def[abs_def] expand_init_def expand_new_name_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>\\<phi>.\n        expand_aimpl\n         (\\<lparr>name = Suc 0, incoming = {0}, new = {\\<phi>}, old = {},\n             next = {}\\<rparr>,\n          {}) \\<bind>\n        (\\<lambda>(uu_, y). RETURN y))\n    \\<in> \\<langle>Id\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>unit_rel,\n          Id\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>\\<phi>.\n        expand_aimpl\n         (\\<lparr>name = Suc 0, incoming = {0}, new = {\\<phi>}, old = {},\n             next = {}\\<rparr>,\n          {}) \\<bind>\n        (\\<lambda>(uu_, y). RETURN y))\n    \\<in> \\<langle>Id\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>unit_rel,\n          Id\\<rangle>node_rel\\<rangle>list_set_rel\\<rangle>nres_rel", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition create_graph_impl uses create_graph_impl_aux"], ["", "lemmas [autoref_rules] = create_graph_impl.refine[OF PREFER_id_D]"], ["", "schematic_goal create_graph_code_aux: \"RETURN ?c \\<le> create_graph_impl \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> create_graph_impl \\<phi>", "unfolding create_graph_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> expand_impl\n           (\\<lparr>name_impl = Suc 0,\n               incoming_impl = map2set_insert rbt_insert 0 rbt.Empty,\n               new_impl = lss.ins_dj \\<phi> (lss.empty ()),\n               old_impl = lss.empty (), next_impl = lss.empty ()\\<rparr>,\n            []) \\<bind>\n          (\\<lambda>(xa, y). RETURN y)", "by refine_transfer"], ["", "concrete_definition create_graph_code uses create_graph_code_aux"], ["", "lemmas [refine_transfer] = create_graph_code.refine"], ["", "schematic_goal create_name_gba_impl_aux: \n  \"(?c, (create_name_gba_aimpl:: 'a::linorder ltlr \\<Rightarrow> _)) \n  \\<in> \\<langle>Id\\<rangle>ltlr_rel \\<rightarrow> (?R::(?'c\\<times>_) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, create_name_gba_aimpl)\n    \\<in> \\<langle>Id\\<rangle>ltlr_rel \\<rightarrow> ?R", "unfolding create_name_gba_aimpl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>\\<phi>.\n        create_graph_aimpl \\<phi> \\<bind>\n        (\\<lambda>nds.\n            ASSERT (nds_invars nds) \\<bind>\n            (\\<lambda>_. cr_rename_gba nds \\<phi>)))\n    \\<in> \\<langle>Id\\<rangle>ltlr_rel \\<rightarrow> ?R", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>\\<phi>.\n        create_graph_aimpl \\<phi> \\<bind>\n        (\\<lambda>nds.\n            ASSERT (nds_invars nds) \\<bind>\n            (\\<lambda>_. cr_rename_gba nds \\<phi>)))\n    \\<in> \\<langle>Id\\<rangle>ltlr_rel \\<rightarrow> ?R", "apply (autoref (keep_goal, trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition create_name_gba_impl uses create_name_gba_impl_aux"], ["", "lemma create_name_gba_autoref[autoref_rules]:\n  assumes \"PREFER_id R\"\n  shows\n  \"(create_name_gba_impl, create_name_gba)\n  \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>gbav_impl_rel_ext unit_rel nat_rel (\\<langle>R\\<rangle>fun_set_rel)\\<rangle>nres_rel\" \n  (is \"_:_\\<rightarrow>\\<langle>?R\\<rangle>nres_rel\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (create_name_gba_impl, create_name_gba)\n    \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>gbav_impl_rel_ext unit_rel nat_rel\n                    (\\<langle>R\\<rangle>fun_set_rel)\\<rangle>nres_rel", "proof (intro fun_relI nres_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n       create_name_gba_impl a\n       \\<le> \\<Down>\n              (gbav_impl_rel_ext unit_rel nat_rel\n                (\\<langle>R\\<rangle>fun_set_rel))\n              (create_name_gba a')", "fix \\<phi> \\<phi>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n       create_name_gba_impl a\n       \\<le> \\<Down>\n              (gbav_impl_rel_ext unit_rel nat_rel\n                (\\<langle>R\\<rangle>fun_set_rel))\n              (create_name_gba a')", "assume A: \"(\\<phi>,\\<phi>')\\<in>\\<langle>R\\<rangle>ltlr_rel\""], ["proof (state)\nthis:\n  (\\<phi>, \\<phi>') \\<in> \\<langle>R\\<rangle>ltlr_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n       create_name_gba_impl a\n       \\<le> \\<Down>\n              (gbav_impl_rel_ext unit_rel nat_rel\n                (\\<langle>R\\<rangle>fun_set_rel))\n              (create_name_gba a')", "from assms"], ["proof (chain)\npicking this:\n  PREFER_id R", "have RID[simp]: \"R=Id\""], ["proof (prove)\nusing this:\n  PREFER_id R\n\ngoal (1 subgoal):\n 1. R = Id", "by simp"], ["proof (state)\nthis:\n  R = Id\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n       create_name_gba_impl a\n       \\<le> \\<Down>\n              (gbav_impl_rel_ext unit_rel nat_rel\n                (\\<langle>R\\<rangle>fun_set_rel))\n              (create_name_gba a')", "note create_name_gba_impl.refine[THEN fun_relD,THEN nres_relD, OF A[unfolded RID]]"], ["proof (state)\nthis:\n  create_name_gba_impl \\<phi>\n  \\<le> \\<Down>\n         (gbav_impl_rel_ext unit_rel nat_rel\n           (\\<langle>Id\\<rangle>fun_set_rel))\n         (create_name_gba_aimpl \\<phi>')\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n       create_name_gba_impl a\n       \\<le> \\<Down>\n              (gbav_impl_rel_ext unit_rel nat_rel\n                (\\<langle>R\\<rangle>fun_set_rel))\n              (create_name_gba a')", "also"], ["proof (state)\nthis:\n  create_name_gba_impl \\<phi>\n  \\<le> \\<Down>\n         (gbav_impl_rel_ext unit_rel nat_rel\n           (\\<langle>Id\\<rangle>fun_set_rel))\n         (create_name_gba_aimpl \\<phi>')\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n       create_name_gba_impl a\n       \\<le> \\<Down>\n              (gbav_impl_rel_ext unit_rel nat_rel\n                (\\<langle>R\\<rangle>fun_set_rel))\n              (create_name_gba a')", "note create_name_gba_aimpl_refine"], ["proof (state)\nthis:\n  create_name_gba_aimpl ?\\<phi> \\<le> \\<Down> Id (create_name_gba ?\\<phi>)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>R\\<rangle>ltlr_rel \\<Longrightarrow>\n       create_name_gba_impl a\n       \\<le> \\<Down>\n              (gbav_impl_rel_ext unit_rel nat_rel\n                (\\<langle>R\\<rangle>fun_set_rel))\n              (create_name_gba a')", "finally"], ["proof (chain)\npicking this:\n  create_name_gba_impl \\<phi>\n  \\<le> \\<Down>\n         (gbav_impl_rel_ext unit_rel nat_rel\n           (\\<langle>Id\\<rangle>fun_set_rel))\n         (create_name_gba \\<phi>')", "show \"create_name_gba_impl \\<phi> \\<le> \\<Down> ?R (create_name_gba \\<phi>')\""], ["proof (prove)\nusing this:\n  create_name_gba_impl \\<phi>\n  \\<le> \\<Down>\n         (gbav_impl_rel_ext unit_rel nat_rel\n           (\\<langle>Id\\<rangle>fun_set_rel))\n         (create_name_gba \\<phi>')\n\ngoal (1 subgoal):\n 1. create_name_gba_impl \\<phi>\n    \\<le> \\<Down>\n           (gbav_impl_rel_ext unit_rel nat_rel\n             (\\<langle>R\\<rangle>fun_set_rel))\n           (create_name_gba \\<phi>')", "by simp"], ["proof (state)\nthis:\n  create_name_gba_impl \\<phi>\n  \\<le> \\<Down>\n         (gbav_impl_rel_ext unit_rel nat_rel\n           (\\<langle>R\\<rangle>fun_set_rel))\n         (create_name_gba \\<phi>')\n\ngoal:\nNo subgoals!", "qed"], ["", "schematic_goal create_name_gba_code_aux: \"RETURN ?c \\<le> create_name_gba_impl \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> create_name_gba_impl \\<phi>", "unfolding create_name_gba_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> create_graph_impl \\<phi> \\<bind>\n          (\\<lambda>xa. cr_rename_gba_impl xa \\<phi>)", "by (refine_transfer (post))"], ["", "concrete_definition create_name_gba_code uses create_name_gba_code_aux"], ["", "lemmas [refine_transfer] = create_name_gba_code.refine"], ["", "schematic_goal create_name_igba_impl_aux: \n  assumes RID: \"R=Id\"\n  shows \"(?c,create_name_igba)\\<in>\n  \\<langle>R\\<rangle>ltlr_rel \\<rightarrow> \\<langle>igbav_impl_rel_ext unit_rel nat_rel (\\<langle>R\\<rangle>fun_set_rel)\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, create_name_igba)\n    \\<in> \\<langle>R\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>igbav_impl_rel_ext unit_rel nat_rel\n                    (\\<langle>R\\<rangle>fun_set_rel)\\<rangle>nres_rel", "unfolding RID"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, create_name_igba)\n    \\<in> \\<langle>Id\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>igbav_impl_rel_ext unit_rel nat_rel\n                    (\\<langle>Id\\<rangle>fun_set_rel)\\<rangle>nres_rel", "unfolding create_name_igba_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>\\<phi>.\n        create_name_gba \\<phi> \\<bind>\n        (\\<lambda>A.\n            gba_to_idx A \\<bind>\n            (\\<lambda>A'.\n                stat_set_data_nres (card (g_V A)) (card (g_V0 A'))\n                 (igbg_num_acc A') \\<bind>\n                (\\<lambda>_. RETURN A'))))\n    \\<in> \\<langle>Id\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>igbav_impl_rel_ext unit_rel nat_rel\n                    (\\<langle>Id\\<rangle>fun_set_rel)\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>\\<phi>.\n        create_name_gba \\<phi> \\<bind>\n        (\\<lambda>A.\n            gba_to_idx A \\<bind>\n            (\\<lambda>A'.\n                stat_set_data_nres (card (g_V A)) (card (g_V0 A'))\n                 (igbg_num_acc A') \\<bind>\n                (\\<lambda>_. RETURN A'))))\n    \\<in> \\<langle>Id\\<rangle>ltlr_rel \\<rightarrow>\n          \\<langle>igbav_impl_rel_ext unit_rel nat_rel\n                    (\\<langle>Id\\<rangle>fun_set_rel)\\<rangle>nres_rel", "apply (autoref (trace, keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition create_name_igba_impl uses create_name_igba_impl_aux"], ["", "lemmas [autoref_rules] = create_name_igba_impl.refine[OF PREFER_id_D]"], ["", "schematic_goal create_name_igba_code_aux: \"RETURN ?c \\<le> create_name_igba_impl \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> create_name_igba_impl \\<phi>", "unfolding create_name_igba_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> create_name_gba_impl \\<phi> \\<bind>\n          (\\<lambda>xa.\n              gba_to_idx_ext_impl (def_hashmap_size TYPE(nat)) (=)\n               bounded_hashcode_nat (\\<lambda>xb. ()) xa \\<bind>\n              (\\<lambda>xb.\n                  stat_set_data_nres\n                   (gen_card (\\<lambda>x. foldli (id x)) (gi_V xa))\n                   (gen_card (\\<lambda>x. foldli (id x)) (gi_V0 xb))\n                   (igbgi_num_acc xb) \\<bind>\n                  (\\<lambda>xc. RETURN xb)))", "by (refine_transfer (post))"], ["", "concrete_definition create_name_igba_code uses create_name_igba_code_aux"], ["", "lemmas [refine_transfer] = create_name_igba_code.refine"], ["", "export_code create_name_igba_code checking SML"], ["", "end"]]}