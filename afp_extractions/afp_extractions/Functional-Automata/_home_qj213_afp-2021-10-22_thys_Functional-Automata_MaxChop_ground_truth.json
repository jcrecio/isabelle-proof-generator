{"file_name": "/home/qj213/afp-2021-10-22/thys/Functional-Automata/MaxChop.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Functional-Automata", "problem_names": ["lemma chop_rule: \"reducing splitf \\<Longrightarrow>\n  chop splitf xs = (let (pre, post) = splitf xs\n                    in if pre = [] then ([], xs)\n                       else let (xss, zs) = chop splitf post\n                            in (pre # xss,zs))\"", "lemma reducing_maxsplit: \"reducing(\\<lambda>qs. maxsplit P ([],qs) [] qs)\"", "lemma is_maxsplitter_reducing:\n \"is_maxsplitter P splitf \\<Longrightarrow> reducing splitf\"", "lemma chop_concat[rule_format]: \"is_maxsplitter P splitf \\<Longrightarrow>\n  (\\<forall>yss zs. chop splitf xs = (yss,zs) \\<longrightarrow> xs = concat yss @ zs)\"", "lemma chop_nonempty: \"is_maxsplitter P splitf \\<Longrightarrow>\n  \\<forall>yss zs. chop splitf xs = (yss,zs) \\<longrightarrow> (\\<forall>ys \\<in> set yss. ys \\<noteq> [])\"", "lemma is_maxchopper_chop:\n assumes prem: \"is_maxsplitter P splitf\" shows \"is_maxchopper P (chop splitf)\""], "translations": [["", "lemma chop_rule: \"reducing splitf \\<Longrightarrow>\n  chop splitf xs = (let (pre, post) = splitf xs\n                    in if pre = [] then ([], xs)\n                       else let (xss, zs) = chop splitf post\n                            in (pre # xss,zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reducing splitf \\<Longrightarrow>\n    chop splitf xs =\n    (let (pre, post) = splitf xs\n     in if pre = [] then ([], xs)\n        else let (xss, zs) = chop splitf post in (pre # xss, zs))", "apply (simp add: chop.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. reducing splitf \\<Longrightarrow>\n    (let pp = splitf xs\n     in if fst pp = [] then ([], xs)\n        else let qq = chop splitf (snd pp) in (fst pp # fst qq, snd qq)) =\n    (case splitf xs of\n     (pre, post) \\<Rightarrow>\n       if pre = [] then ([], xs)\n       else let (xss, y) = chop splitf post in (pre # xss, y))", "apply (simp add: Let_def split: prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reducing_maxsplit: \"reducing(\\<lambda>qs. maxsplit P ([],qs) [] qs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reducing (\\<lambda>qs. maxsplit P ([], qs) [] qs)", "by (simp add: reducing_def maxsplit_eq)"], ["", "lemma is_maxsplitter_reducing:\n \"is_maxsplitter P splitf \\<Longrightarrow> reducing splitf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_maxsplitter P splitf \\<Longrightarrow> reducing splitf", "by(simp add:is_maxsplitter_def reducing_def)"], ["", "lemma chop_concat[rule_format]: \"is_maxsplitter P splitf \\<Longrightarrow>\n  (\\<forall>yss zs. chop splitf xs = (yss,zs) \\<longrightarrow> xs = concat yss @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_maxsplitter P splitf \\<Longrightarrow>\n    \\<forall>yss zs.\n       chop splitf xs = (yss, zs) \\<longrightarrow> xs = concat yss @ zs", "apply (induct xs rule:length_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   is_maxsplitter P splitf \\<longrightarrow>\n                   (\\<forall>yss zs.\n                       chop splitf ys = (yss, zs) \\<longrightarrow>\n                       ys = concat yss @ zs);\n        is_maxsplitter P splitf\\<rbrakk>\n       \\<Longrightarrow> \\<forall>yss zs.\n                            chop splitf xs = (yss, zs) \\<longrightarrow>\n                            xs = concat yss @ zs", "apply (simp (no_asm_simp) split del: if_split\n            add: chop_rule[OF is_maxsplitter_reducing])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   is_maxsplitter P splitf \\<longrightarrow>\n                   (\\<forall>yss zs.\n                       chop splitf ys = (yss, zs) \\<longrightarrow>\n                       ys = concat yss @ zs);\n        is_maxsplitter P splitf\\<rbrakk>\n       \\<Longrightarrow> \\<forall>yss zs.\n                            (case splitf xs of\n                             (pre, post) \\<Rightarrow>\n                               if pre = [] then ([], xs)\n                               else let (xss, y) = chop splitf post\n                                    in (pre # xss, y)) =\n                            (yss, zs) \\<longrightarrow>\n                            xs = concat yss @ zs", "apply (simp add: Let_def is_maxsplitter_def split: prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma chop_nonempty: \"is_maxsplitter P splitf \\<Longrightarrow>\n  \\<forall>yss zs. chop splitf xs = (yss,zs) \\<longrightarrow> (\\<forall>ys \\<in> set yss. ys \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_maxsplitter P splitf \\<Longrightarrow>\n    \\<forall>yss zs.\n       chop splitf xs = (yss, zs) \\<longrightarrow>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> [])", "apply (induct xs rule:length_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   is_maxsplitter P splitf \\<longrightarrow>\n                   (\\<forall>yss zs.\n                       chop splitf ys = (yss, zs) \\<longrightarrow>\n                       (\\<forall>ys\\<in>set yss. ys \\<noteq> []));\n        is_maxsplitter P splitf\\<rbrakk>\n       \\<Longrightarrow> \\<forall>yss zs.\n                            chop splitf xs = (yss, zs) \\<longrightarrow>\n                            (\\<forall>ys\\<in>set yss. ys \\<noteq> [])", "apply (simp (no_asm_simp) add: chop_rule is_maxsplitter_reducing)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   is_maxsplitter P splitf \\<longrightarrow>\n                   (\\<forall>yss zs.\n                       chop splitf ys = (yss, zs) \\<longrightarrow>\n                       (\\<forall>ys\\<in>set yss. ys \\<noteq> []));\n        is_maxsplitter P splitf\\<rbrakk>\n       \\<Longrightarrow> \\<forall>yss.\n                            (\\<exists>zs.\n                                (case splitf xs of\n                                 (pre, post) \\<Rightarrow>\n                                   if pre = [] then ([], xs)\n                                   else let (xss, y) = chop splitf post\n  in (pre # xss, y)) =\n                                (yss, zs)) \\<longrightarrow>\n                            (\\<forall>ys\\<in>set yss. ys \\<noteq> [])", "apply (simp add: Let_def is_maxsplitter_def split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>yss.\n                       (\\<exists>zs.\n                           chop splitf ys = (yss, zs)) \\<longrightarrow>\n                       (\\<forall>ys\\<in>set yss. ys \\<noteq> []));\n        \\<forall>xs ps qs.\n           (splitf xs = (ps, qs)) =\n           (xs = ps @ qs \\<and> is_maxpref P ps xs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x1.\n                            x1 \\<noteq> [] \\<longrightarrow>\n                            (\\<forall>x2 x1a.\n                                (\\<exists>x2a.\n                                    chop splitf x2 =\n                                    (x1a, x2a)) \\<longrightarrow>\n                                xs = x1 @ x2 \\<and>\n                                is_maxpref P x1 xs \\<longrightarrow>\n                                (\\<forall>ys\\<in>set x1a. ys \\<noteq> []))", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs x1 x2 x1a.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>yss.\n                       (\\<exists>zs.\n                           chop splitf ys = (yss, zs)) \\<longrightarrow>\n                       (\\<forall>ys\\<in>set yss. ys \\<noteq> []));\n        \\<forall>xs ps qs.\n           (splitf xs = (ps, qs)) =\n           (xs = ps @ qs \\<and> is_maxpref P ps xs);\n        x1 \\<noteq> []; \\<exists>x2a. chop splitf x2 = (x1a, x2a);\n        xs = x1 @ x2 \\<and> is_maxpref P x1 xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ys\\<in>set x1a. ys \\<noteq> []", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs x1 x2 x1a ys.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>yss.\n                       (\\<exists>zs.\n                           chop splitf ys = (yss, zs)) \\<longrightarrow>\n                       (\\<forall>ys\\<in>set yss. ys \\<noteq> []));\n        \\<forall>xs ps qs.\n           (splitf xs = (ps, qs)) =\n           (xs = ps @ qs \\<and> is_maxpref P ps xs);\n        x1 \\<noteq> []; \\<exists>x2a. chop splitf x2 = (x1a, x2a);\n        xs = x1 @ x2 \\<and> is_maxpref P x1 xs; ys \\<in> set x1a\\<rbrakk>\n       \\<Longrightarrow> ys \\<noteq> []", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs x1 x2 x1a ys x2a.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>yss.\n                       (\\<exists>zs.\n                           chop splitf ys = (yss, zs)) \\<longrightarrow>\n                       (\\<forall>ys\\<in>set yss. ys \\<noteq> []));\n        \\<forall>xs ps qs.\n           (splitf xs = (ps, qs)) =\n           (xs = ps @ qs \\<and> is_maxpref P ps xs);\n        x1 \\<noteq> []; xs = x1 @ x2 \\<and> is_maxpref P x1 xs;\n        ys \\<in> set x1a; chop splitf x2 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ys \\<noteq> []", "apply (erule allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs x1 x2 x1a ys x2a.\n       \\<lbrakk>\\<forall>xs ps qs.\n                   (splitf xs = (ps, qs)) =\n                   (xs = ps @ qs \\<and> is_maxpref P ps xs);\n        x1 \\<noteq> []; xs = x1 @ x2 \\<and> is_maxpref P x1 xs;\n        ys \\<in> set x1a; chop splitf x2 = (x1a, x2a);\n        length (?ys43 xs x1 x2 x1a ys x2a) < length xs \\<longrightarrow>\n        (\\<forall>yss.\n            (\\<exists>zs.\n                chop splitf (?ys43 xs x1 x2 x1a ys x2a) =\n                (yss, zs)) \\<longrightarrow>\n            (\\<forall>ys\\<in>set yss. ys \\<noteq> []))\\<rbrakk>\n       \\<Longrightarrow> ys \\<noteq> []", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_maxchopper_chop:\n assumes prem: \"is_maxsplitter P splitf\" shows \"is_maxchopper P (chop splitf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_maxchopper P (chop splitf)", "apply(unfold is_maxchopper_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs zs yss.\n       (chop splitf xs = (yss, zs)) =\n       (xs = concat yss @ zs \\<and>\n        (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n        (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n         | us # uss \\<Rightarrow>\n             is_maxpref P us xs \\<and>\n             chop splitf (concat uss @ zs) = (uss, zs)))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs zs yss.\n       (chop splitf xs = (yss, zs)) =\n       (xs = concat yss @ zs \\<and>\n        (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n        (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n         | us # uss \\<Rightarrow>\n             is_maxpref P us xs \\<and>\n             chop splitf (concat uss @ zs) = (uss, zs)))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs zs yss.\n       chop splitf xs = (yss, zs) \\<Longrightarrow>\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs))\n 2. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs zs yss.\n       chop splitf xs = (yss, zs) \\<Longrightarrow> xs = concat yss @ zs\n 2. \\<And>xs zs yss.\n       chop splitf xs = (yss, zs) \\<Longrightarrow>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs))\n 3. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply (erule chop_concat[OF prem])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs zs yss.\n       chop splitf xs = (yss, zs) \\<Longrightarrow>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs))\n 2. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs zs yss.\n       chop splitf xs = (yss, zs) \\<Longrightarrow>\n       \\<forall>ys\\<in>set yss. ys \\<noteq> []\n 2. \\<And>xs zs yss.\n       chop splitf xs = (yss, zs) \\<Longrightarrow>\n       case yss of [] \\<Rightarrow> is_maxpref P [] xs\n       | us # uss \\<Rightarrow>\n           is_maxpref P us xs \\<and>\n           chop splitf (concat uss @ zs) = (uss, zs)\n 3. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply (erule prem[THEN chop_nonempty[THEN spec, THEN spec, THEN mp]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs zs yss.\n       chop splitf xs = (yss, zs) \\<Longrightarrow>\n       case yss of [] \\<Rightarrow> is_maxpref P [] xs\n       | us # uss \\<Rightarrow>\n           is_maxpref P us xs \\<and>\n           chop splitf (concat uss @ zs) = (uss, zs)\n 2. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply (erule rev_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs zs yss.\n       chop splitf xs = (yss, zs) \\<longrightarrow>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs))\n 2. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply (subst prem[THEN is_maxsplitter_reducing[THEN chop_rule]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs zs yss.\n       (let (pre, post) = splitf xs\n        in if pre = [] then ([], xs)\n           else let (xss, y) = chop splitf post in (pre # xss, y)) =\n       (yss, zs) \\<longrightarrow>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs))\n 2. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply (simp add: Let_def prem[simplified is_maxsplitter_def]\n             split: prod.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs zs yss.\n       \\<forall>x1 x2 x1a x2a.\n          chop splitf x2 = (x1a, x2a) \\<longrightarrow>\n          (x1 = [] \\<longrightarrow>\n           xs = x2 \\<and> is_maxpref P [] xs \\<longrightarrow>\n           [] = yss \\<and> x2 = zs \\<longrightarrow>\n           is_maxpref P [] zs) \\<and>\n          (x1 \\<noteq> [] \\<longrightarrow>\n           xs = x1 @ x2 \\<and> is_maxpref P x1 xs \\<longrightarrow>\n           x1 # x1a = yss \\<and> x2a = zs \\<longrightarrow>\n           (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n            | us # uss \\<Rightarrow>\n                is_maxpref P us xs \\<and>\n                chop splitf (concat uss @ zs) = (uss, zs)))\n 2. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs zs yss x1 x2 x1a x2a.\n       chop splitf x2 = (x1a, x2a) \\<Longrightarrow>\n       (x1 = [] \\<longrightarrow>\n        xs = x2 \\<and> is_maxpref P [] xs \\<longrightarrow>\n        [] = yss \\<and> x2 = zs \\<longrightarrow> is_maxpref P [] zs) \\<and>\n       (x1 \\<noteq> [] \\<longrightarrow>\n        xs = x1 @ x2 \\<and> is_maxpref P x1 xs \\<longrightarrow>\n        x1 # x1a = yss \\<and> x2a = zs \\<longrightarrow>\n        (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n         | us # uss \\<Rightarrow>\n             is_maxpref P us xs \\<and>\n             chop splitf (concat uss @ zs) = (uss, zs)))\n 2. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs zs yss x1 x2 x1a x2a.\n       chop splitf x2 = (x1a, x2a) \\<Longrightarrow>\n       x1 = [] \\<longrightarrow>\n       xs = x2 \\<and> is_maxpref P [] xs \\<longrightarrow>\n       [] = yss \\<and> x2 = zs \\<longrightarrow> is_maxpref P [] zs\n 2. \\<And>xs zs yss x1 x2 x1a x2a.\n       chop splitf x2 = (x1a, x2a) \\<Longrightarrow>\n       x1 \\<noteq> [] \\<longrightarrow>\n       xs = x1 @ x2 \\<and> is_maxpref P x1 xs \\<longrightarrow>\n       x1 # x1a = yss \\<and> x2a = zs \\<longrightarrow>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs))\n 3. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply (clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs zs yss x1 x2 x1a x2a.\n       chop splitf x2 = (x1a, x2a) \\<Longrightarrow>\n       x1 \\<noteq> [] \\<longrightarrow>\n       xs = x1 @ x2 \\<and> is_maxpref P x1 xs \\<longrightarrow>\n       x1 # x1a = yss \\<and> x2a = zs \\<longrightarrow>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs))\n 2. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply (clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs zs yss x1 x2 x1a x2a.\n       \\<lbrakk>chop splitf x2 = (x1a, zs); x1 \\<noteq> [];\n        is_maxpref P x1 (x1 @ x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 # x1a of\n                         [] \\<Rightarrow> is_maxpref P [] (x1 @ x2)\n                         | us # uss \\<Rightarrow>\n                             is_maxpref P us (x1 @ x2) \\<and>\n                             chop splitf (concat uss @ zs) = (uss, zs)\n 2. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zs x1 x2 x1a.\n       \\<lbrakk>chop splitf x2 = (x1a, zs); x1 \\<noteq> [];\n        is_maxpref P x1 (x1 @ x2)\\<rbrakk>\n       \\<Longrightarrow> chop splitf (concat x1a @ zs) = (x1a, zs)\n 2. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply (frule chop_concat[OF prem])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zs x1 x2 x1a.\n       \\<lbrakk>chop splitf x2 = (x1a, zs); x1 \\<noteq> [];\n        is_maxpref P x1 (x1 @ x2); x2 = concat x1a @ zs\\<rbrakk>\n       \\<Longrightarrow> chop splitf (concat x1a @ zs) = (x1a, zs)\n 2. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply (clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       chop splitf xs = (yss, zs)", "apply (subst prem[THEN is_maxsplitter_reducing, THEN chop_rule])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs zs yss.\n       xs = concat yss @ zs \\<and>\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] xs\n        | us # uss \\<Rightarrow>\n            is_maxpref P us xs \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       (let (pre, post) = splitf xs\n        in if pre = [] then ([], xs)\n           else let (xss, y) = chop splitf post in (pre # xss, y)) =\n       (yss, zs)", "apply (simp add: Let_def prem[simplified is_maxsplitter_def]\n             split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs yss.\n       (\\<forall>ys\\<in>set yss. ys \\<noteq> []) \\<and>\n       (case yss of [] \\<Rightarrow> is_maxpref P [] (concat yss @ zs)\n        | us # uss \\<Rightarrow>\n            is_maxpref P us (concat yss @ zs) \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs)) \\<Longrightarrow>\n       \\<forall>x1 x2 x1a x2a.\n          chop splitf x2 = (x1a, x2a) \\<longrightarrow>\n          (x1 = [] \\<longrightarrow>\n           concat yss @ zs = x2 \\<and>\n           is_maxpref P [] (concat yss @ zs) \\<longrightarrow>\n           [] = yss \\<and> x2 = zs) \\<and>\n          (x1 \\<noteq> [] \\<longrightarrow>\n           concat yss @ zs = x1 @ x2 \\<and>\n           is_maxpref P x1 (concat yss @ zs) \\<longrightarrow>\n           x1 # x1a = yss \\<and> x2a = zs)", "apply (clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs yss x1 x2 x1a x2a.\n       \\<lbrakk>\\<forall>ys\\<in>set yss. ys \\<noteq> [];\n        case yss of [] \\<Rightarrow> is_maxpref P [] (concat yss @ zs)\n        | us # uss \\<Rightarrow>\n            is_maxpref P us (concat yss @ zs) \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs);\n        chop splitf x2 = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x1 = [] \\<longrightarrow>\n                          concat yss @ zs = x2 \\<and>\n                          is_maxpref P []\n                           (concat yss @ zs) \\<longrightarrow>\n                          [] = yss \\<and> x2 = zs) \\<and>\n                         (x1 \\<noteq> [] \\<longrightarrow>\n                          concat yss @ zs = x1 @ x2 \\<and>\n                          is_maxpref P x1\n                           (concat yss @ zs) \\<longrightarrow>\n                          x1 # x1a = yss \\<and> x2a = zs)", "apply (rename_tac xs1 ys1 xss1 ys)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs yss xs1 ys1 xss1 ys.\n       \\<lbrakk>\\<forall>ys\\<in>set yss. ys \\<noteq> [];\n        case yss of [] \\<Rightarrow> is_maxpref P [] (concat yss @ zs)\n        | us # uss \\<Rightarrow>\n            is_maxpref P us (concat yss @ zs) \\<and>\n            chop splitf (concat uss @ zs) = (uss, zs);\n        chop splitf ys1 = (xss1, ys)\\<rbrakk>\n       \\<Longrightarrow> (xs1 = [] \\<longrightarrow>\n                          concat yss @ zs = ys1 \\<and>\n                          is_maxpref P []\n                           (concat yss @ zs) \\<longrightarrow>\n                          [] = yss \\<and> ys1 = zs) \\<and>\n                         (xs1 \\<noteq> [] \\<longrightarrow>\n                          concat yss @ zs = xs1 @ ys1 \\<and>\n                          is_maxpref P xs1\n                           (concat yss @ zs) \\<longrightarrow>\n                          xs1 # xss1 = yss \\<and> ys = zs)", "apply (simp split: list.split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zs yss xs1 ys1 xss1 ys.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys); yss = [];\n        is_maxpref P [] zs\\<rbrakk>\n       \\<Longrightarrow> xs1 \\<noteq> [] \\<longrightarrow>\n                         zs = xs1 @ ys1 \\<longrightarrow>\n                         \\<not> is_maxpref P xs1 (xs1 @ ys1)\n 2. \\<And>zs yss xs1 ys1 xss1 ys x21 x22.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys);\n        x21 \\<noteq> [] \\<and> (\\<forall>ys\\<in>set x22. ys \\<noteq> []);\n        yss = x21 # x22;\n        is_maxpref P x21 (x21 @ concat x22 @ zs) \\<and>\n        chop splitf (concat x22 @ zs) = (x22, zs)\\<rbrakk>\n       \\<Longrightarrow> (xs1 = [] \\<longrightarrow>\n                          x21 @ concat x22 @ zs = ys1 \\<longrightarrow>\n                          \\<not> is_maxpref P [] ys1) \\<and>\n                         (xs1 \\<noteq> [] \\<longrightarrow>\n                          x21 @ concat x22 @ zs = xs1 @ ys1 \\<and>\n                          is_maxpref P xs1\n                           (x21 @ concat x22 @ zs) \\<longrightarrow>\n                          xs1 = x21 \\<and> xss1 = x22 \\<and> ys = zs)", "apply (simp add: is_maxpref_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zs yss xs1 ys1 xss1 ys.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys); yss = [];\n        \\<forall>zsa.\n           prefix zsa zs \\<and> P zsa \\<longrightarrow> zsa = []\\<rbrakk>\n       \\<Longrightarrow> xs1 \\<noteq> [] \\<longrightarrow>\n                         zs = xs1 @ ys1 \\<longrightarrow>\n                         P xs1 \\<longrightarrow>\n                         (\\<exists>zs.\n                             prefix zs (xs1 @ ys1) \\<and>\n                             P zs \\<and> \\<not> prefix zs xs1)\n 2. \\<And>zs yss xs1 ys1 xss1 ys x21 x22.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys);\n        x21 \\<noteq> [] \\<and> (\\<forall>ys\\<in>set x22. ys \\<noteq> []);\n        yss = x21 # x22;\n        is_maxpref P x21 (x21 @ concat x22 @ zs) \\<and>\n        chop splitf (concat x22 @ zs) = (x22, zs)\\<rbrakk>\n       \\<Longrightarrow> (xs1 = [] \\<longrightarrow>\n                          x21 @ concat x22 @ zs = ys1 \\<longrightarrow>\n                          \\<not> is_maxpref P [] ys1) \\<and>\n                         (xs1 \\<noteq> [] \\<longrightarrow>\n                          x21 @ concat x22 @ zs = xs1 @ ys1 \\<and>\n                          is_maxpref P xs1\n                           (x21 @ concat x22 @ zs) \\<longrightarrow>\n                          xs1 = x21 \\<and> xss1 = x22 \\<and> ys = zs)", "apply (blast intro: prefix_append[THEN iffD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs yss xs1 ys1 xss1 ys x21 x22.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys);\n        x21 \\<noteq> [] \\<and> (\\<forall>ys\\<in>set x22. ys \\<noteq> []);\n        yss = x21 # x22;\n        is_maxpref P x21 (x21 @ concat x22 @ zs) \\<and>\n        chop splitf (concat x22 @ zs) = (x22, zs)\\<rbrakk>\n       \\<Longrightarrow> (xs1 = [] \\<longrightarrow>\n                          x21 @ concat x22 @ zs = ys1 \\<longrightarrow>\n                          \\<not> is_maxpref P [] ys1) \\<and>\n                         (xs1 \\<noteq> [] \\<longrightarrow>\n                          x21 @ concat x22 @ zs = xs1 @ ys1 \\<and>\n                          is_maxpref P xs1\n                           (x21 @ concat x22 @ zs) \\<longrightarrow>\n                          xs1 = x21 \\<and> xss1 = x22 \\<and> ys = zs)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zs yss xs1 ys1 xss1 ys x21 x22.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys);\n        x21 \\<noteq> [] \\<and> (\\<forall>ys\\<in>set x22. ys \\<noteq> []);\n        yss = x21 # x22;\n        is_maxpref P x21 (x21 @ concat x22 @ zs) \\<and>\n        chop splitf (concat x22 @ zs) = (x22, zs)\\<rbrakk>\n       \\<Longrightarrow> xs1 = [] \\<longrightarrow>\n                         x21 @ concat x22 @ zs = ys1 \\<longrightarrow>\n                         \\<not> is_maxpref P [] ys1\n 2. \\<And>zs yss xs1 ys1 xss1 ys x21 x22.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys);\n        x21 \\<noteq> [] \\<and> (\\<forall>ys\\<in>set x22. ys \\<noteq> []);\n        yss = x21 # x22;\n        is_maxpref P x21 (x21 @ concat x22 @ zs) \\<and>\n        chop splitf (concat x22 @ zs) = (x22, zs)\\<rbrakk>\n       \\<Longrightarrow> xs1 \\<noteq> [] \\<longrightarrow>\n                         x21 @ concat x22 @ zs = xs1 @ ys1 \\<and>\n                         is_maxpref P xs1\n                          (x21 @ concat x22 @ zs) \\<longrightarrow>\n                         xs1 = x21 \\<and> xss1 = x22 \\<and> ys = zs", "apply (clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zs yss xs1 ys1 xss1 ys x21 x22.\n       \\<lbrakk>chop splitf (x21 @ concat x22 @ zs) = (xss1, ys);\n        x21 \\<noteq> []; \\<forall>ys\\<in>set x22. ys \\<noteq> [];\n        is_maxpref P x21 (x21 @ concat x22 @ zs);\n        chop splitf (concat x22 @ zs) = (x22, zs);\n        is_maxpref P [] (x21 @ concat x22 @ zs)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>zs yss xs1 ys1 xss1 ys x21 x22.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys);\n        x21 \\<noteq> [] \\<and> (\\<forall>ys\\<in>set x22. ys \\<noteq> []);\n        yss = x21 # x22;\n        is_maxpref P x21 (x21 @ concat x22 @ zs) \\<and>\n        chop splitf (concat x22 @ zs) = (x22, zs)\\<rbrakk>\n       \\<Longrightarrow> xs1 \\<noteq> [] \\<longrightarrow>\n                         x21 @ concat x22 @ zs = xs1 @ ys1 \\<and>\n                         is_maxpref P xs1\n                          (x21 @ concat x22 @ zs) \\<longrightarrow>\n                         xs1 = x21 \\<and> xss1 = x22 \\<and> ys = zs", "apply (simp (no_asm_use) add: is_maxpref_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zs xss1 ys x21 x22.\n       \\<lbrakk>chop splitf (x21 @ concat x22 @ zs) = (xss1, ys);\n        x21 \\<noteq> []; \\<forall>ys\\<in>set x22. ys \\<noteq> [];\n        (x21 = [] \\<or> P x21) \\<and>\n        (\\<forall>zsa.\n            prefix zsa (x21 @ concat x22 @ zs) \\<and>\n            P zsa \\<longrightarrow>\n            prefix zsa x21);\n        chop splitf (concat x22 @ zs) = (x22, zs);\n        \\<forall>zsa.\n           prefix zsa (x21 @ concat x22 @ zs) \\<and> P zsa \\<longrightarrow>\n           zsa = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>zs yss xs1 ys1 xss1 ys x21 x22.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys);\n        x21 \\<noteq> [] \\<and> (\\<forall>ys\\<in>set x22. ys \\<noteq> []);\n        yss = x21 # x22;\n        is_maxpref P x21 (x21 @ concat x22 @ zs) \\<and>\n        chop splitf (concat x22 @ zs) = (x22, zs)\\<rbrakk>\n       \\<Longrightarrow> xs1 \\<noteq> [] \\<longrightarrow>\n                         x21 @ concat x22 @ zs = xs1 @ ys1 \\<and>\n                         is_maxpref P xs1\n                          (x21 @ concat x22 @ zs) \\<longrightarrow>\n                         xs1 = x21 \\<and> xss1 = x22 \\<and> ys = zs", "apply (blast intro: prefix_append[THEN iffD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs yss xs1 ys1 xss1 ys x21 x22.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys);\n        x21 \\<noteq> [] \\<and> (\\<forall>ys\\<in>set x22. ys \\<noteq> []);\n        yss = x21 # x22;\n        is_maxpref P x21 (x21 @ concat x22 @ zs) \\<and>\n        chop splitf (concat x22 @ zs) = (x22, zs)\\<rbrakk>\n       \\<Longrightarrow> xs1 \\<noteq> [] \\<longrightarrow>\n                         x21 @ concat x22 @ zs = xs1 @ ys1 \\<and>\n                         is_maxpref P xs1\n                          (x21 @ concat x22 @ zs) \\<longrightarrow>\n                         xs1 = x21 \\<and> xss1 = x22 \\<and> ys = zs", "apply (clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs yss xs1 ys1 xss1 ys x21 x22.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys); x21 \\<noteq> [];\n        \\<forall>ys\\<in>set x22. ys \\<noteq> [];\n        is_maxpref P x21 (x21 @ concat x22 @ zs);\n        chop splitf (concat x22 @ zs) = (x22, zs); xs1 \\<noteq> [];\n        x21 @ concat x22 @ zs = xs1 @ ys1;\n        is_maxpref P xs1 (x21 @ concat x22 @ zs)\\<rbrakk>\n       \\<Longrightarrow> xs1 = x21 \\<and> xss1 = x22 \\<and> ys = zs", "apply (rename_tac us uss)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs yss xs1 ys1 xss1 ys us uss.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys); us \\<noteq> [];\n        \\<forall>ys\\<in>set uss. ys \\<noteq> [];\n        is_maxpref P us (us @ concat uss @ zs);\n        chop splitf (concat uss @ zs) = (uss, zs); xs1 \\<noteq> [];\n        us @ concat uss @ zs = xs1 @ ys1;\n        is_maxpref P xs1 (us @ concat uss @ zs)\\<rbrakk>\n       \\<Longrightarrow> xs1 = us \\<and> xss1 = uss \\<and> ys = zs", "apply (subgoal_tac \"xs1=us\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>zs yss xs1 ys1 xss1 ys us uss.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys); us \\<noteq> [];\n        \\<forall>ys\\<in>set uss. ys \\<noteq> [];\n        is_maxpref P us (us @ concat uss @ zs);\n        chop splitf (concat uss @ zs) = (uss, zs); xs1 \\<noteq> [];\n        us @ concat uss @ zs = xs1 @ ys1;\n        is_maxpref P xs1 (us @ concat uss @ zs); xs1 = us\\<rbrakk>\n       \\<Longrightarrow> xs1 = us \\<and> xss1 = uss \\<and> ys = zs\n 2. \\<And>zs yss xs1 ys1 xss1 ys us uss.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys); us \\<noteq> [];\n        \\<forall>ys\\<in>set uss. ys \\<noteq> [];\n        is_maxpref P us (us @ concat uss @ zs);\n        chop splitf (concat uss @ zs) = (uss, zs); xs1 \\<noteq> [];\n        us @ concat uss @ zs = xs1 @ ys1;\n        is_maxpref P xs1 (us @ concat uss @ zs)\\<rbrakk>\n       \\<Longrightarrow> xs1 = us", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs yss xs1 ys1 xss1 ys us uss.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys); us \\<noteq> [];\n        \\<forall>ys\\<in>set uss. ys \\<noteq> [];\n        is_maxpref P us (us @ concat uss @ zs);\n        chop splitf (concat uss @ zs) = (uss, zs); xs1 \\<noteq> [];\n        us @ concat uss @ zs = xs1 @ ys1;\n        is_maxpref P xs1 (us @ concat uss @ zs)\\<rbrakk>\n       \\<Longrightarrow> xs1 = us", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs xs1 ys1 xss1 ys us uss.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys); us \\<noteq> [];\n        \\<forall>ys\\<in>set uss. ys \\<noteq> [];\n        is_maxpref P us (xs1 @ ys1);\n        chop splitf (concat uss @ zs) = (uss, zs); xs1 \\<noteq> [];\n        us @ concat uss @ zs = xs1 @ ys1;\n        is_maxpref P xs1 (xs1 @ ys1)\\<rbrakk>\n       \\<Longrightarrow> xs1 = us", "apply (simp (no_asm_use) add: is_maxpref_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>zs xs1 ys1 xss1 ys us uss.\n       \\<lbrakk>chop splitf ys1 = (xss1, ys); us \\<noteq> [];\n        \\<forall>ys\\<in>set uss. ys \\<noteq> [];\n        prefix us (xs1 @ ys1) \\<and>\n        (us = [] \\<or> P us) \\<and>\n        (\\<forall>zs.\n            prefix zs (xs1 @ ys1) \\<and> P zs \\<longrightarrow>\n            prefix zs us);\n        chop splitf (concat uss @ zs) = (uss, zs); xs1 \\<noteq> [];\n        us @ concat uss @ zs = xs1 @ ys1;\n        (xs1 = [] \\<or> P xs1) \\<and>\n        (\\<forall>zs.\n            prefix zs (xs1 @ ys1) \\<and> P zs \\<longrightarrow>\n            prefix zs xs1)\\<rbrakk>\n       \\<Longrightarrow> xs1 = us", "apply (blast intro: prefix_append[THEN iffD2] prefix_order.antisym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}