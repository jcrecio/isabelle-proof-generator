{"file_name": "/home/qj213/afp-2021-10-22/thys/Pairing_Heap/Pairing_Heap_List1.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pairing_Heap", "problem_names": ["lemma pass12_merge_pairs: \"pass\\<^sub>2 (pass\\<^sub>1 hs) = merge_pairs hs\"", "lemma pheap_merge: \"pheap h1 \\<Longrightarrow> pheap h2 \\<Longrightarrow> pheap (merge h1 h2)\"", "lemma pheap_merge_pairs: \"\\<forall>h \\<in> set hs. pheap h \\<Longrightarrow> pheap (merge_pairs hs)\"", "lemma pheap_insert: \"pheap h \\<Longrightarrow> pheap (insert x h)\"", "lemma pheap_del_min: \"pheap h \\<Longrightarrow> pheap (del_min h)\"", "lemma mset_heap_empty_iff: \"mset_heap h = {#} \\<longleftrightarrow> h = Empty\"", "lemma get_min_in: \"h \\<noteq> Empty \\<Longrightarrow> get_min h \\<in># mset_heap(h)\"", "lemma get_min_min: \"\\<lbrakk> h \\<noteq> Empty; pheap h; x \\<in># mset_heap(h) \\<rbrakk> \\<Longrightarrow> get_min h \\<le> x\"", "lemma get_min: \"\\<lbrakk> pheap h;  h \\<noteq> Empty \\<rbrakk> \\<Longrightarrow> get_min h = Min_mset (mset_heap h)\"", "lemma mset_merge: \"mset_heap (merge h1 h2) = mset_heap h1 + mset_heap h2\"", "lemma mset_insert: \"mset_heap (insert a h) = {#a#} + mset_heap h\"", "lemma mset_merge_pairs: \"mset_heap (merge_pairs hs) = sum_mset(image_mset mset_heap(mset hs))\"", "lemma mset_del_min: \"h \\<noteq> Empty \\<Longrightarrow>\n  mset_heap (del_min h) = mset_heap h - {#get_min h#}\""], "translations": [["", "lemma pass12_merge_pairs: \"pass\\<^sub>2 (pass\\<^sub>1 hs) = merge_pairs hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pass\\<^sub>2 (pass\\<^sub>1 hs) = merge_pairs hs", "by (induction hs rule: merge_pairs.induct) (auto split: option.split)"], ["", "declare pass12_merge_pairs[code_unfold]"], ["", "subsubsection \\<open>Invariants\\<close>"], ["", "fun mset_heap :: \"'a heap \\<Rightarrow>'a multiset\" where\n\"mset_heap Empty = {#}\" |\n\"mset_heap (Hp x hs) = {#x#} + sum_mset(mset(map mset_heap hs))\""], ["", "fun pheap :: \"('a :: linorder) heap \\<Rightarrow> bool\" where\n\"pheap Empty = True\" |\n\"pheap (Hp x hs) = (\\<forall>h \\<in> set hs. (\\<forall>y \\<in># mset_heap h. x \\<le> y) \\<and> pheap h)\""], ["", "lemma pheap_merge: \"pheap h1 \\<Longrightarrow> pheap h2 \\<Longrightarrow> pheap (merge h1 h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pheap h1; pheap h2\\<rbrakk>\n    \\<Longrightarrow> pheap (merge h1 h2)", "by (induction h1 h2 rule: merge.induct) fastforce+"], ["", "lemma pheap_merge_pairs: \"\\<forall>h \\<in> set hs. pheap h \\<Longrightarrow> pheap (merge_pairs hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h\\<in>set hs. pheap h \\<Longrightarrow> pheap (merge_pairs hs)", "by (induction hs rule: merge_pairs.induct)(auto simp: pheap_merge)"], ["", "lemma pheap_insert: \"pheap h \\<Longrightarrow> pheap (insert x h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pheap h \\<Longrightarrow> pheap (insert x h)", "by (auto simp: pheap_merge)"], ["", "(*\nlemma pheap_pass1: \"\\<forall>h \\<in> set hs. pheap h \\<Longrightarrow> \\<forall>h \\<in> set (pass\\<^sub>1 hs). pheap h\"\nby(induction hs rule: pass\\<^sub>1.induct) (auto simp: pheap_merge)\n\nlemma pheap_pass2: \"\\<forall>h \\<in> set hs. pheap h \\<Longrightarrow> pheap (pass\\<^sub>2 hs)\"\nby (induction hs)(auto simp: pheap_merge)\n*)"], ["", "lemma pheap_del_min: \"pheap h \\<Longrightarrow> pheap (del_min h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pheap h \\<Longrightarrow> pheap (del_min h)", "by(cases h) (auto simp: pass12_merge_pairs pheap_merge_pairs)"], ["", "subsubsection \\<open>Functional Correctness\\<close>"], ["", "lemma mset_heap_empty_iff: \"mset_heap h = {#} \\<longleftrightarrow> h = Empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset_heap h = {#}) = (h = Empty)", "by (cases h) auto"], ["", "lemma get_min_in: \"h \\<noteq> Empty \\<Longrightarrow> get_min h \\<in># mset_heap(h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<noteq> Empty \\<Longrightarrow> get_min h \\<in># mset_heap h", "by(induction rule: get_min.induct)(auto)"], ["", "lemma get_min_min: \"\\<lbrakk> h \\<noteq> Empty; pheap h; x \\<in># mset_heap(h) \\<rbrakk> \\<Longrightarrow> get_min h \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<noteq> Empty; pheap h; x \\<in># mset_heap h\\<rbrakk>\n    \\<Longrightarrow> get_min h \\<le> x", "by(induction h rule: get_min.induct)(auto)"], ["", "lemma get_min: \"\\<lbrakk> pheap h;  h \\<noteq> Empty \\<rbrakk> \\<Longrightarrow> get_min h = Min_mset (mset_heap h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pheap h; h \\<noteq> Empty\\<rbrakk>\n    \\<Longrightarrow> get_min h = Min_mset (mset_heap h)", "by (metis Min_eqI finite_set_mset get_min_in get_min_min )"], ["", "lemma mset_merge: \"mset_heap (merge h1 h2) = mset_heap h1 + mset_heap h2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_heap (merge h1 h2) = mset_heap h1 + mset_heap h2", "by(induction h1 h2 rule: merge.induct)(auto simp: add_ac)"], ["", "lemma mset_insert: \"mset_heap (insert a h) = {#a#} + mset_heap h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_heap (insert a h) = {#a#} + mset_heap h", "by(cases h) (auto simp add: mset_merge insert_def add_ac)"], ["", "lemma mset_merge_pairs: \"mset_heap (merge_pairs hs) = sum_mset(image_mset mset_heap(mset hs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_heap (merge_pairs hs) =\n    \\<Sum>\\<^sub># (image_mset mset_heap (mset hs))", "by(induction hs rule: merge_pairs.induct)(auto simp: mset_merge)"], ["", "lemma mset_del_min: \"h \\<noteq> Empty \\<Longrightarrow>\n  mset_heap (del_min h) = mset_heap h - {#get_min h#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<noteq> Empty \\<Longrightarrow>\n    mset_heap (del_min h) = mset_heap h - {#get_min h#}", "by(cases h) (auto simp: pass12_merge_pairs mset_merge_pairs)"], ["", "text \\<open>Last step: prove all axioms of the priority queue specification:\\<close>"], ["", "interpretation pairing: Priority_Queue_Merge\nwhere empty = Empty and is_empty = \"\\<lambda>h. h = Empty\"\nand merge = merge and insert = insert\nand del_min = del_min and get_min = get_min\nand invar = pheap and mset = mset_heap"], ["proof (prove)\ngoal (1 subgoal):\n 1. Priority_Queue_Merge (\\<lambda>h. h = Empty) insert get_min del_min\n     pheap mset_heap Empty merge", "proof(standard, goal_cases)"], ["proof (state)\ngoal (10 subgoals):\n 1. mset_heap Empty = {#}\n 2. \\<And>q. pheap q \\<Longrightarrow> (q = Empty) = (mset_heap q = {#})\n 3. \\<And>q x.\n       pheap q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 6. pheap Empty\n 7. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 8. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 9. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 10. \\<And>q1 q2.\n        \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n        \\<Longrightarrow> pheap (merge q1 q2)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. mset_heap Empty = {#}\n 2. \\<And>q. pheap q \\<Longrightarrow> (q = Empty) = (mset_heap q = {#})\n 3. \\<And>q x.\n       pheap q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 6. pheap Empty\n 7. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 8. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 9. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 10. \\<And>q1 q2.\n        \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n        \\<Longrightarrow> pheap (merge q1 q2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_heap Empty = {#}", "by simp"], ["proof (state)\nthis:\n  mset_heap Empty = {#}\n\ngoal (9 subgoals):\n 1. \\<And>q. pheap q \\<Longrightarrow> (q = Empty) = (mset_heap q = {#})\n 2. \\<And>q x.\n       pheap q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 5. pheap Empty\n 6. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 8. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 9. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>q. pheap q \\<Longrightarrow> (q = Empty) = (mset_heap q = {#})\n 2. \\<And>q x.\n       pheap q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 5. pheap Empty\n 6. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 8. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 9. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "case (2 q)"], ["proof (state)\nthis:\n  pheap q\n\ngoal (9 subgoals):\n 1. \\<And>q. pheap q \\<Longrightarrow> (q = Empty) = (mset_heap q = {#})\n 2. \\<And>q x.\n       pheap q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 5. pheap Empty\n 6. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 8. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 9. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (q = Empty) = (mset_heap q = {#})", "by (cases q) auto"], ["proof (state)\nthis:\n  (q = Empty) = (mset_heap q = {#})\n\ngoal (8 subgoals):\n 1. \\<And>q x.\n       pheap q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 4. pheap Empty\n 5. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 7. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 8. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>q x.\n       pheap q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 4. pheap Empty\n 5. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 7. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 8. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "case 3"], ["proof (state)\nthis:\n  pheap q_\n\ngoal (8 subgoals):\n 1. \\<And>q x.\n       pheap q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 4. pheap Empty\n 5. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 7. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 8. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_heap (insert x_ q_) = mset_heap q_ + {#x_#}", "by(simp add: mset_insert mset_merge)"], ["proof (state)\nthis:\n  mset_heap (insert x_ q_) = mset_heap q_ + {#x_#}\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 3. pheap Empty\n 4. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 6. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 7. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 3. pheap Empty\n 4. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 6. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 7. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "case 4"], ["proof (state)\nthis:\n  pheap q_\n  mset_heap q_ \\<noteq> {#}\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 3. pheap Empty\n 4. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 6. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 7. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  pheap q_\n  mset_heap q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. mset_heap (del_min q_) = mset_heap q_ - {#get_min q_#}", "by(simp add: mset_del_min mset_heap_empty_iff)"], ["proof (state)\nthis:\n  mset_heap (del_min q_) = mset_heap q_ - {#get_min q_#}\n\ngoal (6 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 2. pheap Empty\n 3. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 5. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 6. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 2. pheap Empty\n 3. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 5. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 6. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "case 5"], ["proof (state)\nthis:\n  pheap q_\n  mset_heap q_ \\<noteq> {#}\n\ngoal (6 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 2. pheap Empty\n 3. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 5. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 6. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  pheap q_\n  mset_heap q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. get_min q_ = Min_mset (mset_heap q_)", "using get_min mset_heap.simps(1)"], ["proof (prove)\nusing this:\n  pheap q_\n  mset_heap q_ \\<noteq> {#}\n  \\<lbrakk>pheap ?h; ?h \\<noteq> Empty\\<rbrakk>\n  \\<Longrightarrow> get_min ?h = Min_mset (mset_heap ?h)\n  mset_heap Empty = {#}\n\ngoal (1 subgoal):\n 1. get_min q_ = Min_mset (mset_heap q_)", "by blast"], ["proof (state)\nthis:\n  get_min q_ = Min_mset (mset_heap q_)\n\ngoal (5 subgoals):\n 1. pheap Empty\n 2. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 4. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 5. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. pheap Empty\n 2. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 4. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 5. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. pheap Empty\n 2. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 4. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 5. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pheap Empty", "by(simp)"], ["proof (state)\nthis:\n  pheap Empty\n\ngoal (4 subgoals):\n 1. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 3. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 4. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 3. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 4. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "case 7"], ["proof (state)\nthis:\n  pheap q_\n\ngoal (4 subgoals):\n 1. \\<And>q x. pheap q \\<Longrightarrow> pheap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 3. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 4. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  pheap q_\n\ngoal (1 subgoal):\n 1. pheap (insert x_ q_)", "by(rule pheap_insert)"], ["proof (state)\nthis:\n  pheap (insert x_ q_)\n\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 2. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 3. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 2. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 3. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "case 8"], ["proof (state)\nthis:\n  pheap q_\n  mset_heap q_ \\<noteq> {#}\n\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>pheap q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> pheap (del_min q)\n 2. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 3. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  pheap q_\n  mset_heap q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. pheap (del_min q_)", "by (simp add: pheap_del_min)"], ["proof (state)\nthis:\n  pheap (del_min q_)\n\ngoal (2 subgoals):\n 1. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 2. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 2. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "case 9"], ["proof (state)\nthis:\n  pheap q1_\n  pheap q2_\n\ngoal (2 subgoals):\n 1. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 2. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  pheap q1_\n  pheap q2_\n\ngoal (1 subgoal):\n 1. mset_heap (merge q1_ q2_) = mset_heap q1_ + mset_heap q2_", "by (simp add: mset_merge)"], ["proof (state)\nthis:\n  mset_heap (merge q1_ q2_) = mset_heap q1_ + mset_heap q2_\n\ngoal (1 subgoal):\n 1. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "case 10"], ["proof (state)\nthis:\n  pheap q1_\n  pheap q2_\n\ngoal (1 subgoal):\n 1. \\<And>q1 q2.\n       \\<lbrakk>pheap q1; pheap q2\\<rbrakk>\n       \\<Longrightarrow> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  pheap q1_\n  pheap q2_\n\ngoal (1 subgoal):\n 1. pheap (merge q1_ q2_)", "by (simp add: pheap_merge)"], ["proof (state)\nthis:\n  pheap (merge q1_ q2_)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}