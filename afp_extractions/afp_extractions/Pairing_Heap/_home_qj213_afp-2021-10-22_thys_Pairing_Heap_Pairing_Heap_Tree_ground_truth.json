{"file_name": "/home/qj213/afp-2021-10-22/thys/Pairing_Heap/Pairing_Heap_Tree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pairing_Heap", "problem_names": ["lemma link_struct: \"\\<exists>l a. link (Node hsx x (Node hsy y hs)) = Node l a hs\"", "lemma pass\\<^sub>1_struct: \"\\<exists>l a r. pass\\<^sub>1 (Node hs1 x hs) = Node l a r\"", "lemma pass\\<^sub>2_struct: \"\\<exists>l a. pass\\<^sub>2 (Node hs1 x hs) = Node l a Leaf\"", "lemma is_root_merge:\n  \"is_root h1 \\<Longrightarrow> is_root h2 \\<Longrightarrow> is_root (merge h1 h2)\"", "lemma is_root_insert: \"is_root h \\<Longrightarrow> is_root (insert x h)\"", "lemma is_root_del_min:\n  assumes \"is_root h\" shows \"is_root (del_min h)\"", "lemma pheap_merge:\n  \"\\<lbrakk> is_root h1; is_root h2; pheap h1; pheap h2 \\<rbrakk> \\<Longrightarrow> pheap (merge h1 h2)\"", "lemma pheap_insert: \"is_root h \\<Longrightarrow> pheap h \\<Longrightarrow> pheap (insert x h)\"", "lemma pheap_link: \"t \\<noteq> Leaf \\<Longrightarrow> pheap t \\<Longrightarrow> pheap (link t)\"", "lemma pheap_pass1: \"pheap h \\<Longrightarrow> pheap (pass\\<^sub>1 h)\"", "lemma pheap_pass2: \"pheap h \\<Longrightarrow> pheap (pass\\<^sub>2 h)\"", "lemma pheap_del_min: \"is_root h \\<Longrightarrow> pheap h \\<Longrightarrow> pheap (del_min h)\"", "lemma get_min_in:\n  \"h \\<noteq> Leaf \\<Longrightarrow> get_min h \\<in> set_tree h\"", "lemma get_min_min: \"\\<lbrakk> is_root h; pheap h; x \\<in> set_tree h \\<rbrakk> \\<Longrightarrow> get_min h \\<le> x\"", "lemma mset_link: \"mset_tree (link t) = mset_tree t\"", "lemma mset_pass\\<^sub>1: \"mset_tree (pass\\<^sub>1 h) = mset_tree h\"", "lemma mset_pass\\<^sub>2: \"mset_tree (pass\\<^sub>2 h) = mset_tree h\"", "lemma mset_merge: \"\\<lbrakk> is_root h1; is_root h2 \\<rbrakk>\n \\<Longrightarrow>  mset_tree (merge h1 h2) = mset_tree h1 + mset_tree h2\"", "lemma mset_del_min: \"\\<lbrakk> is_root h; t \\<noteq> Leaf \\<rbrakk> \\<Longrightarrow>\n  mset_tree (del_min h) = mset_tree h - {#get_min h#}\""], "translations": [["", "lemma link_struct: \"\\<exists>l a. link (Node hsx x (Node hsy y hs)) = Node l a hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l a.\n       link \\<langle>hsx, x, \\<langle>hsy, y, hs\\<rangle>\\<rangle> =\n       \\<langle>l, a, hs\\<rangle>", "by simp"], ["", "lemma pass\\<^sub>1_struct: \"\\<exists>l a r. pass\\<^sub>1 (Node hs1 x hs) = Node l a r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l a r.\n       pass\\<^sub>1 \\<langle>hs1, x, hs\\<rangle> = \\<langle>l, a, r\\<rangle>", "by (cases hs) simp_all"], ["", "lemma pass\\<^sub>2_struct: \"\\<exists>l a. pass\\<^sub>2 (Node hs1 x hs) = Node l a Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l a.\n       pass\\<^sub>2 \\<langle>hs1, x, hs\\<rangle> =\n       \\<langle>l, a, \\<langle>\\<rangle>\\<rangle>", "by(induction hs arbitrary: hs1 x rule: pass\\<^sub>2.induct) (auto, metis link_struct)"], ["", "lemma is_root_merge:\n  \"is_root h1 \\<Longrightarrow> is_root h2 \\<Longrightarrow> is_root (merge h1 h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_root h1; is_root h2\\<rbrakk>\n    \\<Longrightarrow> is_root (merge h1 h2)", "by (simp split: tree.splits)"], ["", "lemma is_root_insert: \"is_root h \\<Longrightarrow> is_root (insert x h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_root h \\<Longrightarrow> is_root (Pairing_Heap_Tree.insert x h)", "by (simp split: tree.splits)"], ["", "lemma is_root_del_min:\n  assumes \"is_root h\" shows \"is_root (del_min h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_root (del_min h)", "proof (cases h)"], ["proof (state)\ngoal (2 subgoals):\n 1. h = \\<langle>\\<rangle> \\<Longrightarrow> is_root (del_min h)\n 2. \\<And>x21 x22 x23.\n       h = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       is_root (del_min h)", "case [simp]: (Node lx x rx)"], ["proof (state)\nthis:\n  h = \\<langle>lx, x, rx\\<rangle>\n\ngoal (2 subgoals):\n 1. h = \\<langle>\\<rangle> \\<Longrightarrow> is_root (del_min h)\n 2. \\<And>x21 x22 x23.\n       h = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       is_root (del_min h)", "have \"rx = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rx = \\<langle>\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  is_root h\n\ngoal (1 subgoal):\n 1. rx = \\<langle>\\<rangle>", "by simp"], ["proof (state)\nthis:\n  rx = \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. h = \\<langle>\\<rangle> \\<Longrightarrow> is_root (del_min h)\n 2. \\<And>x21 x22 x23.\n       h = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       is_root (del_min h)", "thus ?thesis"], ["proof (prove)\nusing this:\n  rx = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. is_root (del_min h)", "proof (cases lx)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>rx = \\<langle>\\<rangle>; lx = \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> is_root (del_min h)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rx = \\<langle>\\<rangle>;\n        lx = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min h)", "case (Node ly y ry)"], ["proof (state)\nthis:\n  lx = \\<langle>ly, y, ry\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rx = \\<langle>\\<rangle>; lx = \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> is_root (del_min h)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rx = \\<langle>\\<rangle>;\n        lx = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min h)", "then"], ["proof (chain)\npicking this:\n  lx = \\<langle>ly, y, ry\\<rangle>", "obtain la a ra where \"pass\\<^sub>1 lx = Node a la ra\""], ["proof (prove)\nusing this:\n  lx = \\<langle>ly, y, ry\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>a la ra.\n        pass\\<^sub>1 lx = \\<langle>a, la, ra\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using pass\\<^sub>1_struct"], ["proof (prove)\nusing this:\n  lx = \\<langle>ly, y, ry\\<rangle>\n  \\<exists>l a r.\n     pass\\<^sub>1 \\<langle>?hs1.0, ?x, ?hs\\<rangle> =\n     \\<langle>l, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>a la ra.\n        pass\\<^sub>1 lx = \\<langle>a, la, ra\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pass\\<^sub>1 lx = \\<langle>a, la, ra\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rx = \\<langle>\\<rangle>; lx = \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> is_root (del_min h)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rx = \\<langle>\\<rangle>;\n        lx = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min h)", "moreover"], ["proof (state)\nthis:\n  pass\\<^sub>1 lx = \\<langle>a, la, ra\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rx = \\<langle>\\<rangle>; lx = \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> is_root (del_min h)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rx = \\<langle>\\<rangle>;\n        lx = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min h)", "obtain lb b where \"pass\\<^sub>2 \\<dots> = Node b lb Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b lb.\n        pass\\<^sub>2 \\<langle>a, la, ra\\<rangle> =\n        \\<langle>b, lb, \\<langle>\\<rangle>\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using pass\\<^sub>2_struct"], ["proof (prove)\nusing this:\n  \\<exists>l a.\n     pass\\<^sub>2 \\<langle>?hs1.0, ?x, ?hs\\<rangle> =\n     \\<langle>l, a, \\<langle>\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>b lb.\n        pass\\<^sub>2 \\<langle>a, la, ra\\<rangle> =\n        \\<langle>b, lb, \\<langle>\\<rangle>\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pass\\<^sub>2 \\<langle>a, la, ra\\<rangle> =\n  \\<langle>b, lb, \\<langle>\\<rangle>\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>rx = \\<langle>\\<rangle>; lx = \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> is_root (del_min h)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rx = \\<langle>\\<rangle>;\n        lx = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min h)", "ultimately"], ["proof (chain)\npicking this:\n  pass\\<^sub>1 lx = \\<langle>a, la, ra\\<rangle>\n  pass\\<^sub>2 \\<langle>a, la, ra\\<rangle> =\n  \\<langle>b, lb, \\<langle>\\<rangle>\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  pass\\<^sub>1 lx = \\<langle>a, la, ra\\<rangle>\n  pass\\<^sub>2 \\<langle>a, la, ra\\<rangle> =\n  \\<langle>b, lb, \\<langle>\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. is_root (del_min h)", "using assms"], ["proof (prove)\nusing this:\n  pass\\<^sub>1 lx = \\<langle>a, la, ra\\<rangle>\n  pass\\<^sub>2 \\<langle>a, la, ra\\<rangle> =\n  \\<langle>b, lb, \\<langle>\\<rangle>\\<rangle>\n  is_root h\n\ngoal (1 subgoal):\n 1. is_root (del_min h)", "by simp"], ["proof (state)\nthis:\n  is_root (del_min h)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rx = \\<langle>\\<rangle>; lx = \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> is_root (del_min h)", "qed simp"], ["proof (state)\nthis:\n  is_root (del_min h)\n\ngoal (1 subgoal):\n 1. h = \\<langle>\\<rangle> \\<Longrightarrow> is_root (del_min h)", "qed simp"], ["", "lemma pheap_merge:\n  \"\\<lbrakk> is_root h1; is_root h2; pheap h1; pheap h2 \\<rbrakk> \\<Longrightarrow> pheap (merge h1 h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_root h1; is_root h2; pheap h1; pheap h2\\<rbrakk>\n    \\<Longrightarrow> pheap (merge h1 h2)", "by (auto split: tree.splits)"], ["", "lemma pheap_insert: \"is_root h \\<Longrightarrow> pheap h \\<Longrightarrow> pheap (insert x h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_root h; pheap h\\<rbrakk>\n    \\<Longrightarrow> pheap (Pairing_Heap_Tree.insert x h)", "by (auto split: tree.splits)"], ["", "lemma pheap_link: \"t \\<noteq> Leaf \\<Longrightarrow> pheap t \\<Longrightarrow> pheap (link t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<noteq> \\<langle>\\<rangle>; pheap t\\<rbrakk>\n    \\<Longrightarrow> pheap (link t)", "by(induction t rule: link.induct)(auto)"], ["", "lemma pheap_pass1: \"pheap h \\<Longrightarrow> pheap (pass\\<^sub>1 h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pheap h \\<Longrightarrow> pheap (pass\\<^sub>1 h)", "by(induction h rule: pass\\<^sub>1.induct) (auto)"], ["", "lemma pheap_pass2: \"pheap h \\<Longrightarrow> pheap (pass\\<^sub>2 h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pheap h \\<Longrightarrow> pheap (pass\\<^sub>2 h)", "by (induction h)(auto simp: pheap_link)"], ["", "lemma pheap_del_min: \"is_root h \\<Longrightarrow> pheap h \\<Longrightarrow> pheap (del_min h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_root h; pheap h\\<rbrakk> \\<Longrightarrow> pheap (del_min h)", "by (auto simp: pheap_pass1 pheap_pass2 split: tree.splits)"], ["", "subsubsection \\<open>Functional Correctness\\<close>"], ["", "lemma get_min_in:\n  \"h \\<noteq> Leaf \\<Longrightarrow> get_min h \\<in> set_tree h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    get_min h \\<in> set_tree h", "by(auto simp add: neq_Leaf_iff)"], ["", "lemma get_min_min: \"\\<lbrakk> is_root h; pheap h; x \\<in> set_tree h \\<rbrakk> \\<Longrightarrow> get_min h \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_root h; pheap h; x \\<in> set_tree h\\<rbrakk>\n    \\<Longrightarrow> get_min h \\<le> x", "by(auto split: tree.splits)"], ["", "lemma mset_link: \"mset_tree (link t) = mset_tree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (link t) = mset_tree t", "by(cases t rule: link.cases)(auto simp: add_ac)"], ["", "lemma mset_pass\\<^sub>1: \"mset_tree (pass\\<^sub>1 h) = mset_tree h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (pass\\<^sub>1 h) = mset_tree h", "by (induction h rule: pass\\<^sub>1.induct) auto"], ["", "lemma mset_pass\\<^sub>2: \"mset_tree (pass\\<^sub>2 h) = mset_tree h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (pass\\<^sub>2 h) = mset_tree h", "by (induction h rule: pass\\<^sub>2.induct) (auto simp: mset_link)"], ["", "lemma mset_merge: \"\\<lbrakk> is_root h1; is_root h2 \\<rbrakk>\n \\<Longrightarrow>  mset_tree (merge h1 h2) = mset_tree h1 + mset_tree h2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_root h1; is_root h2\\<rbrakk>\n    \\<Longrightarrow> mset_tree (merge h1 h2) = mset_tree h1 + mset_tree h2", "by (induction h1 h2 rule: merge.induct) (auto simp add: ac_simps)"], ["", "(*\nlemma mset_merge_pairs: \"mset_tree (merge_pairs h) = mset_tree h\"\nby(induction h rule: merge_pairs.induct)(auto simp: mset_link add_ac)\n*)"], ["", "lemma mset_del_min: \"\\<lbrakk> is_root h; t \\<noteq> Leaf \\<rbrakk> \\<Longrightarrow>\n  mset_tree (del_min h) = mset_tree h - {#get_min h#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_root h; t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> mset_tree (del_min h) = mset_tree h - {#get_min h#}", "by(induction h rule: del_min.induct)(auto simp: mset_pass\\<^sub>1 mset_pass\\<^sub>2)"], ["", "text \\<open>Last step: prove all axioms of the priority queue specification:\\<close>"], ["", "interpretation pairing: Priority_Queue_Merge\nwhere empty = Leaf and is_empty = \"\\<lambda>h. h = Leaf\"\nand merge = merge and insert = insert\nand del_min = del_min and get_min = get_min\nand invar = \"\\<lambda>h. is_root h \\<and> pheap h\" and mset = mset_tree"], ["proof (prove)\ngoal (1 subgoal):\n 1. Priority_Queue_Merge (\\<lambda>h. h = \\<langle>\\<rangle>)\n     Pairing_Heap_Tree.insert get_min del_min\n     (\\<lambda>h. is_root h \\<and> pheap h) mset_tree \\<langle>\\<rangle>\n     merge", "proof(standard, goal_cases)"], ["proof (state)\ngoal (10 subgoals):\n 1. mset_tree \\<langle>\\<rangle> = {#}\n 2. \\<And>q.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 3. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       mset_tree (Pairing_Heap_Tree.insert x q) = mset_tree q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 6. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 7. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 8. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 9. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 10. \\<And>q1 q2.\n        \\<lbrakk>is_root q1 \\<and> pheap q1;\n         is_root q2 \\<and> pheap q2\\<rbrakk>\n        \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. mset_tree \\<langle>\\<rangle> = {#}\n 2. \\<And>q.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 3. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       mset_tree (Pairing_Heap_Tree.insert x q) = mset_tree q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 6. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 7. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 8. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 9. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 10. \\<And>q1 q2.\n        \\<lbrakk>is_root q1 \\<and> pheap q1;\n         is_root q2 \\<and> pheap q2\\<rbrakk>\n        \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree \\<langle>\\<rangle> = {#}", "by simp"], ["proof (state)\nthis:\n  mset_tree \\<langle>\\<rangle> = {#}\n\ngoal (9 subgoals):\n 1. \\<And>q.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       mset_tree (Pairing_Heap_Tree.insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 7. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 8. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 9. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>q.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       mset_tree (Pairing_Heap_Tree.insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 7. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 8. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 9. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "case (2 q)"], ["proof (state)\nthis:\n  is_root q \\<and> pheap q\n\ngoal (9 subgoals):\n 1. \\<And>q.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       mset_tree (Pairing_Heap_Tree.insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 7. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 8. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 9. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (q = \\<langle>\\<rangle>) = (mset_tree q = {#})", "by (cases q) auto"], ["proof (state)\nthis:\n  (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n\ngoal (8 subgoals):\n 1. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       mset_tree (Pairing_Heap_Tree.insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 6. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 7. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 8. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       mset_tree (Pairing_Heap_Tree.insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 6. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 7. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 8. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "case 3"], ["proof (state)\nthis:\n  is_root q_ \\<and> pheap q_\n\ngoal (8 subgoals):\n 1. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       mset_tree (Pairing_Heap_Tree.insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 6. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 7. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 8. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  is_root q_ \\<and> pheap q_\n\ngoal (1 subgoal):\n 1. mset_tree (Pairing_Heap_Tree.insert x_ q_) = mset_tree q_ + {#x_#}", "by(simp add: mset_merge)"], ["proof (state)\nthis:\n  mset_tree (Pairing_Heap_Tree.insert x_ q_) = mset_tree q_ + {#x_#}\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 5. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 6. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 7. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 5. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 6. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 7. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "case 4"], ["proof (state)\nthis:\n  is_root q_ \\<and> pheap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 5. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 6. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 7. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  is_root q_ \\<and> pheap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. mset_tree (del_min q_) = mset_tree q_ - {#get_min q_#}", "by(simp add: mset_del_min)"], ["proof (state)\nthis:\n  mset_tree (del_min q_) = mset_tree q_ - {#get_min q_#}\n\ngoal (6 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 4. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 5. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 6. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 4. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 5. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 6. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "case 5"], ["proof (state)\nthis:\n  is_root q_ \\<and> pheap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (6 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 4. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 5. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 6. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  is_root q_ \\<and> pheap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. get_min q_ = Min_mset (mset_tree q_)", "by(simp add: eq_Min_iff get_min_in get_min_min)"], ["proof (state)\nthis:\n  get_min q_ = Min_mset (mset_tree q_)\n\ngoal (5 subgoals):\n 1. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 3. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 4. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 5. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 3. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 4. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 5. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 3. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 4. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 5. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>", "by(simp)"], ["proof (state)\nthis:\n  is_root \\<langle>\\<rangle> \\<and> pheap \\<langle>\\<rangle>\n\ngoal (4 subgoals):\n 1. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 2. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 3. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 4. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 2. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 3. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 4. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "case 7"], ["proof (state)\nthis:\n  is_root q_ \\<and> pheap q_\n\ngoal (4 subgoals):\n 1. \\<And>q x.\n       is_root q \\<and> pheap q \\<Longrightarrow>\n       is_root (Pairing_Heap_Tree.insert x q) \\<and>\n       pheap (Pairing_Heap_Tree.insert x q)\n 2. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 3. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 4. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  is_root q_ \\<and> pheap q_\n\ngoal (1 subgoal):\n 1. is_root (Pairing_Heap_Tree.insert x_ q_) \\<and>\n    pheap (Pairing_Heap_Tree.insert x_ q_)", "using is_root_insert pheap_insert"], ["proof (prove)\nusing this:\n  is_root q_ \\<and> pheap q_\n  is_root ?h \\<Longrightarrow> is_root (Pairing_Heap_Tree.insert ?x ?h)\n  \\<lbrakk>is_root ?h; pheap ?h\\<rbrakk>\n  \\<Longrightarrow> pheap (Pairing_Heap_Tree.insert ?x ?h)\n\ngoal (1 subgoal):\n 1. is_root (Pairing_Heap_Tree.insert x_ q_) \\<and>\n    pheap (Pairing_Heap_Tree.insert x_ q_)", "by blast"], ["proof (state)\nthis:\n  is_root (Pairing_Heap_Tree.insert x_ q_) \\<and>\n  pheap (Pairing_Heap_Tree.insert x_ q_)\n\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 2. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 3. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 2. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 3. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "case 8"], ["proof (state)\nthis:\n  is_root q_ \\<and> pheap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>is_root q \\<and> pheap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> is_root (del_min q) \\<and> pheap (del_min q)\n 2. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 3. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  is_root q_ \\<and> pheap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. is_root (del_min q_) \\<and> pheap (del_min q_)", "using is_root_del_min pheap_del_min"], ["proof (prove)\nusing this:\n  is_root q_ \\<and> pheap q_\n  mset_tree q_ \\<noteq> {#}\n  is_root ?h \\<Longrightarrow> is_root (del_min ?h)\n  \\<lbrakk>is_root ?h; pheap ?h\\<rbrakk>\n  \\<Longrightarrow> pheap (del_min ?h)\n\ngoal (1 subgoal):\n 1. is_root (del_min q_) \\<and> pheap (del_min q_)", "by blast"], ["proof (state)\nthis:\n  is_root (del_min q_) \\<and> pheap (del_min q_)\n\ngoal (2 subgoals):\n 1. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 2. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 2. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "case 9"], ["proof (state)\nthis:\n  is_root q1_ \\<and> pheap q1_\n  is_root q2_ \\<and> pheap q2_\n\ngoal (2 subgoals):\n 1. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> mset_tree (merge q1 q2) =\n                         mset_tree q1 + mset_tree q2\n 2. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  is_root q1_ \\<and> pheap q1_\n  is_root q2_ \\<and> pheap q2_\n\ngoal (1 subgoal):\n 1. mset_tree (merge q1_ q2_) = mset_tree q1_ + mset_tree q2_", "by (simp add: mset_merge)"], ["proof (state)\nthis:\n  mset_tree (merge q1_ q2_) = mset_tree q1_ + mset_tree q2_\n\ngoal (1 subgoal):\n 1. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "case 10"], ["proof (state)\nthis:\n  is_root q1_ \\<and> pheap q1_\n  is_root q2_ \\<and> pheap q2_\n\ngoal (1 subgoal):\n 1. \\<And>q1 q2.\n       \\<lbrakk>is_root q1 \\<and> pheap q1;\n        is_root q2 \\<and> pheap q2\\<rbrakk>\n       \\<Longrightarrow> is_root (merge q1 q2) \\<and> pheap (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  is_root q1_ \\<and> pheap q1_\n  is_root q2_ \\<and> pheap q2_\n\ngoal (1 subgoal):\n 1. is_root (merge q1_ q2_) \\<and> pheap (merge q1_ q2_)", "using is_root_merge pheap_merge"], ["proof (prove)\nusing this:\n  is_root q1_ \\<and> pheap q1_\n  is_root q2_ \\<and> pheap q2_\n  \\<lbrakk>is_root ?h1.0; is_root ?h2.0\\<rbrakk>\n  \\<Longrightarrow> is_root (merge ?h1.0 ?h2.0)\n  \\<lbrakk>is_root ?h1.0; is_root ?h2.0; pheap ?h1.0; pheap ?h2.0\\<rbrakk>\n  \\<Longrightarrow> pheap (merge ?h1.0 ?h2.0)\n\ngoal (1 subgoal):\n 1. is_root (merge q1_ q2_) \\<and> pheap (merge q1_ q2_)", "by blast"], ["proof (state)\nthis:\n  is_root (merge q1_ q2_) \\<and> pheap (merge q1_ q2_)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}