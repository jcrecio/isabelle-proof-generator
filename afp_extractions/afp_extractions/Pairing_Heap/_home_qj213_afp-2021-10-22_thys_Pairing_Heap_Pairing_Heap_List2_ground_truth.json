{"file_name": "/home/qj213/afp-2021-10-22/thys/Pairing_Heap/Pairing_Heap_List2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pairing_Heap", "problem_names": ["lemma merge_None[simp]: \"merge None h = h\"", "lemma pass12_merge_pairs: \"pass\\<^sub>2 (pass\\<^sub>1 hs) = merge_pairs hs\"", "lemma php_link: \"php h1 \\<Longrightarrow> php h2 \\<Longrightarrow> php (link h1 h2)\"", "lemma invar_merge:\n  \"\\<lbrakk> invar h1; invar h2 \\<rbrakk> \\<Longrightarrow> invar (merge h1 h2)\"", "lemma invar_insert: \"invar h \\<Longrightarrow> invar (insert x h)\"", "lemma invar_pass1: \"\\<forall>h \\<in> set hs. php h \\<Longrightarrow> \\<forall>h \\<in> set (pass\\<^sub>1 hs). php h\"", "lemma invar_pass2: \"\\<forall>h \\<in> set hs. php h \\<Longrightarrow> invar (pass\\<^sub>2 hs)\"", "lemma invar_Some: \"invar(Some h) = php h\"", "lemma invar_del_min: \"invar h \\<Longrightarrow> invar (del_min h)\"", "lemma set_mset_mset_hp: \"set_mset (mset_hp h) = set_hp h\"", "lemma mset_hp_empty[simp]: \"mset_hp hp \\<noteq> {#}\"", "lemma mset_heap_Some: \"mset_heap(Some hp) = mset_hp hp\"", "lemma mset_heap_empty: \"mset_heap h = {#} \\<longleftrightarrow> h = None\"", "lemma get_min_in:\n  \"h \\<noteq> None \\<Longrightarrow> get_min h \\<in> set_hp(the h)\"", "lemma get_min_min: \"\\<lbrakk> h \\<noteq> None; invar h; x \\<in> set_hp(the h) \\<rbrakk> \\<Longrightarrow> get_min h \\<le> x\"", "lemma mset_link: \"mset_hp (link h1 h2) = mset_hp h1 + mset_hp h2\"", "lemma mset_merge: \"mset_heap (merge h1 h2) = mset_heap h1 + mset_heap h2\"", "lemma mset_insert: \"mset_heap (insert a h) = {#a#} + mset_heap h\"", "lemma mset_merge_pairs: \"mset_heap (merge_pairs hs) = sum_mset(image_mset mset_hp (mset hs))\"", "lemma mset_del_min: \"h \\<noteq> None \\<Longrightarrow>\n  mset_heap (del_min h) = mset_heap h - {#get_min h#}\""], "translations": [["", "lemma merge_None[simp]: \"merge None h = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge None h = h", "by(cases h)auto"], ["", "fun insert :: \"('a::linorder) \\<Rightarrow> 'a heap \\<Rightarrow> 'a heap\" where\n\"insert x None = Some(Hp x [])\" |\n\"insert x (Some h) = Some(link (Hp x []) h)\""], ["", "fun pass\\<^sub>1 :: \"('a::linorder) hp list \\<Rightarrow> 'a hp list\" where\n  \"pass\\<^sub>1 [] = []\"\n| \"pass\\<^sub>1 [h] = [h]\" \n| \"pass\\<^sub>1 (h1#h2#hs) = link h1 h2 # pass\\<^sub>1 hs\""], ["", "fun pass\\<^sub>2 :: \"('a::linorder) hp list \\<Rightarrow> 'a heap\" where\n  \"pass\\<^sub>2 [] = None\"\n| \"pass\\<^sub>2 (h#hs) = Some(case pass\\<^sub>2 hs of None \\<Rightarrow> h | Some h' \\<Rightarrow> link h h')\""], ["", "fun merge_pairs :: \"('a::linorder) hp list \\<Rightarrow> 'a heap\" where\n  \"merge_pairs [] = None\"\n| \"merge_pairs [h] = Some h\" \n| \"merge_pairs (h1 # h2 # hs) =\n  Some(let h12 = link h1 h2 in case merge_pairs hs of None \\<Rightarrow> h12 | Some h \\<Rightarrow> link h12 h)\""], ["", "fun del_min :: \"('a::linorder) heap \\<Rightarrow> 'a heap\" where\n  \"del_min None = None\"\n| \"del_min (Some(Hp x hs)) = pass\\<^sub>2 (pass\\<^sub>1 hs)\""], ["", "subsection \\<open>Correctness Proofs\\<close>"], ["", "text \\<open>An optimization:\\<close>"], ["", "lemma pass12_merge_pairs: \"pass\\<^sub>2 (pass\\<^sub>1 hs) = merge_pairs hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pass\\<^sub>2 (pass\\<^sub>1 hs) = merge_pairs hs", "by (induction hs rule: merge_pairs.induct) (auto split: option.split)"], ["", "declare pass12_merge_pairs[code_unfold]"], ["", "subsubsection \\<open>Invariants\\<close>"], ["", "fun php :: \"('a::linorder) hp \\<Rightarrow> bool\" where\n\"php (Hp x hs) = (\\<forall>h \\<in> set hs. (\\<forall>y \\<in> set_hp h. x \\<le> y) \\<and> php h)\""], ["", "definition invar :: \"('a::linorder) heap \\<Rightarrow> bool\" where\n\"invar ho = (case ho of None \\<Rightarrow> True | Some h \\<Rightarrow> php h)\""], ["", "lemma php_link: \"php h1 \\<Longrightarrow> php h2 \\<Longrightarrow> php (link h1 h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>php h1; php h2\\<rbrakk> \\<Longrightarrow> php (link h1 h2)", "by (induction h1 h2 rule: link.induct) fastforce+"], ["", "lemma invar_merge:\n  \"\\<lbrakk> invar h1; invar h2 \\<rbrakk> \\<Longrightarrow> invar (merge h1 h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar h1; invar h2\\<rbrakk>\n    \\<Longrightarrow> invar (merge h1 h2)", "by (auto simp: php_link invar_def split: option.splits)"], ["", "lemma invar_insert: \"invar h \\<Longrightarrow> invar (insert x h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar h \\<Longrightarrow> invar (insert x h)", "by (auto simp: php_link invar_def split: option.splits)"], ["", "lemma invar_pass1: \"\\<forall>h \\<in> set hs. php h \\<Longrightarrow> \\<forall>h \\<in> set (pass\\<^sub>1 hs). php h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h\\<in>set hs. php h \\<Longrightarrow>\n    \\<forall>h\\<in>set (pass\\<^sub>1 hs). php h", "by(induction hs rule: pass\\<^sub>1.induct) (auto simp: php_link)"], ["", "lemma invar_pass2: \"\\<forall>h \\<in> set hs. php h \\<Longrightarrow> invar (pass\\<^sub>2 hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>h\\<in>set hs. php h \\<Longrightarrow> invar (pass\\<^sub>2 hs)", "by (induction hs)(auto simp: php_link invar_def split: option.splits)"], ["", "lemma invar_Some: \"invar(Some h) = php h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (Some h) = php h", "by(simp add: invar_def)"], ["", "lemma invar_del_min: \"invar h \\<Longrightarrow> invar (del_min h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar h \\<Longrightarrow> invar (del_min h)", "by(induction h rule: del_min.induct)\n  (auto simp: invar_Some intro!: invar_pass1 invar_pass2)"], ["", "subsubsection \\<open>Functional Correctness\\<close>"], ["", "fun mset_hp :: \"'a hp \\<Rightarrow>'a multiset\" where\n\"mset_hp (Hp x hs) = {#x#} + sum_mset(mset(map mset_hp hs))\""], ["", "definition mset_heap :: \"'a heap \\<Rightarrow>'a multiset\" where\n\"mset_heap ho = (case ho of None \\<Rightarrow> {#} | Some h \\<Rightarrow> mset_hp h)\""], ["", "lemma set_mset_mset_hp: \"set_mset (mset_hp h) = set_hp h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (mset_hp h) = set_hp h", "by(induction h) auto"], ["", "lemma mset_hp_empty[simp]: \"mset_hp hp \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_hp hp \\<noteq> {#}", "by (cases hp) auto"], ["", "lemma mset_heap_Some: \"mset_heap(Some hp) = mset_hp hp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_heap (Some hp) = mset_hp hp", "by(simp add: mset_heap_def)"], ["", "lemma mset_heap_empty: \"mset_heap h = {#} \\<longleftrightarrow> h = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset_heap h = {#}) = (h = None)", "by (cases h) (auto simp add: mset_heap_def)"], ["", "lemma get_min_in:\n  \"h \\<noteq> None \\<Longrightarrow> get_min h \\<in> set_hp(the h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<noteq> None \\<Longrightarrow> get_min h \\<in> set_hp (the h)", "by(induction rule: get_min.induct)(auto)"], ["", "lemma get_min_min: \"\\<lbrakk> h \\<noteq> None; invar h; x \\<in> set_hp(the h) \\<rbrakk> \\<Longrightarrow> get_min h \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<noteq> None; invar h; x \\<in> set_hp (the h)\\<rbrakk>\n    \\<Longrightarrow> get_min h \\<le> x", "by(induction h rule: get_min.induct)(auto simp: invar_def)"], ["", "lemma mset_link: \"mset_hp (link h1 h2) = mset_hp h1 + mset_hp h2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_hp (link h1 h2) = mset_hp h1 + mset_hp h2", "by(induction h1 h2 rule: link.induct)(auto simp: add_ac)"], ["", "lemma mset_merge: \"mset_heap (merge h1 h2) = mset_heap h1 + mset_heap h2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_heap (merge h1 h2) = mset_heap h1 + mset_heap h2", "by (induction h1 h2 rule: merge.induct)\n   (auto simp add: mset_heap_def mset_link ac_simps)"], ["", "lemma mset_insert: \"mset_heap (insert a h) = {#a#} + mset_heap h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_heap (insert a h) = {#a#} + mset_heap h", "by(cases h) (auto simp add: mset_link mset_heap_def insert_def)"], ["", "lemma mset_merge_pairs: \"mset_heap (merge_pairs hs) = sum_mset(image_mset mset_hp (mset hs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_heap (merge_pairs hs) =\n    \\<Sum>\\<^sub># (image_mset mset_hp (mset hs))", "by(induction hs rule: merge_pairs.induct)\n  (auto simp: mset_merge mset_link mset_heap_def Let_def split: option.split)"], ["", "lemma mset_del_min: \"h \\<noteq> None \\<Longrightarrow>\n  mset_heap (del_min h) = mset_heap h - {#get_min h#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<noteq> None \\<Longrightarrow>\n    mset_heap (del_min h) = mset_heap h - {#get_min h#}", "by(induction h rule: del_min.induct)\n  (auto simp: mset_heap_Some pass12_merge_pairs mset_merge_pairs)"], ["", "text \\<open>Last step: prove all axioms of the priority queue specification:\\<close>"], ["", "interpretation pairing: Priority_Queue_Merge\nwhere empty = None and is_empty = \"\\<lambda>h. h = None\"\nand merge = merge and insert = insert\nand del_min = del_min and get_min = get_min\nand invar = invar and mset = mset_heap"], ["proof (prove)\ngoal (1 subgoal):\n 1. Priority_Queue_Merge (\\<lambda>h. h = None) insert get_min del_min invar\n     mset_heap None merge", "proof(standard, goal_cases)"], ["proof (state)\ngoal (10 subgoals):\n 1. mset_heap None = {#}\n 2. \\<And>q. invar q \\<Longrightarrow> (q = None) = (mset_heap q = {#})\n 3. \\<And>q x.\n       invar q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 6. invar None\n 7. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 8. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 9. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 10. \\<And>q1 q2.\n        \\<lbrakk>invar q1; invar q2\\<rbrakk>\n        \\<Longrightarrow> invar (merge q1 q2)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. mset_heap None = {#}\n 2. \\<And>q. invar q \\<Longrightarrow> (q = None) = (mset_heap q = {#})\n 3. \\<And>q x.\n       invar q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 6. invar None\n 7. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 8. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 9. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 10. \\<And>q1 q2.\n        \\<lbrakk>invar q1; invar q2\\<rbrakk>\n        \\<Longrightarrow> invar (merge q1 q2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_heap None = {#}", "by(simp add: mset_heap_def)"], ["proof (state)\nthis:\n  mset_heap None = {#}\n\ngoal (9 subgoals):\n 1. \\<And>q. invar q \\<Longrightarrow> (q = None) = (mset_heap q = {#})\n 2. \\<And>q x.\n       invar q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 5. invar None\n 6. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 8. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 9. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>q. invar q \\<Longrightarrow> (q = None) = (mset_heap q = {#})\n 2. \\<And>q x.\n       invar q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 5. invar None\n 6. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 8. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 9. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "case (2 q)"], ["proof (state)\nthis:\n  invar q\n\ngoal (9 subgoals):\n 1. \\<And>q. invar q \\<Longrightarrow> (q = None) = (mset_heap q = {#})\n 2. \\<And>q x.\n       invar q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 5. invar None\n 6. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 8. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 9. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  invar q\n\ngoal (1 subgoal):\n 1. (q = None) = (mset_heap q = {#})", "by(auto simp add: mset_heap_def split: option.split)"], ["proof (state)\nthis:\n  (q = None) = (mset_heap q = {#})\n\ngoal (8 subgoals):\n 1. \\<And>q x.\n       invar q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 4. invar None\n 5. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 7. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 8. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>q x.\n       invar q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 4. invar None\n 5. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 7. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 8. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "case 3"], ["proof (state)\nthis:\n  invar q_\n\ngoal (8 subgoals):\n 1. \\<And>q x.\n       invar q \\<Longrightarrow>\n       mset_heap (insert x q) = mset_heap q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 4. invar None\n 5. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 7. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 8. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_heap (insert x_ q_) = mset_heap q_ + {#x_#}", "by(simp add: mset_insert mset_merge)"], ["proof (state)\nthis:\n  mset_heap (insert x_ q_) = mset_heap q_ + {#x_#}\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 3. invar None\n 4. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 6. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 7. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 3. invar None\n 4. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 6. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 7. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "case 4"], ["proof (state)\nthis:\n  invar q_\n  mset_heap q_ \\<noteq> {#}\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_heap (del_min q) = mset_heap q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 3. invar None\n 4. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 6. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 7. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  invar q_\n  mset_heap q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. mset_heap (del_min q_) = mset_heap q_ - {#get_min q_#}", "by(simp add: mset_del_min mset_heap_empty)"], ["proof (state)\nthis:\n  mset_heap (del_min q_) = mset_heap q_ - {#get_min q_#}\n\ngoal (6 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 2. invar None\n 3. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 5. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 6. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 2. invar None\n 3. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 5. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 6. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "case (5 q)"], ["proof (state)\nthis:\n  invar q\n  mset_heap q \\<noteq> {#}\n\ngoal (6 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_heap q)\n 2. invar None\n 3. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 5. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 6. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  invar q\n  mset_heap q \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. get_min q = Min_mset (mset_heap q)", "using get_min_in[of q]"], ["proof (prove)\nusing this:\n  invar q\n  mset_heap q \\<noteq> {#}\n  q \\<noteq> None \\<Longrightarrow> get_min q \\<in> set_hp (the q)\n\ngoal (1 subgoal):\n 1. get_min q = Min_mset (mset_heap q)", "by(auto simp add: eq_Min_iff get_min_min mset_heap_empty mset_heap_Some set_mset_mset_hp)"], ["proof (state)\nthis:\n  get_min q = Min_mset (mset_heap q)\n\ngoal (5 subgoals):\n 1. invar None\n 2. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 4. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 5. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. invar None\n 2. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 4. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 5. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. invar None\n 2. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 4. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 5. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar None", "by (simp add: invar_def)"], ["proof (state)\nthis:\n  invar None\n\ngoal (4 subgoals):\n 1. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 3. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 4. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 3. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 4. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "case 7"], ["proof (state)\nthis:\n  invar q_\n\ngoal (4 subgoals):\n 1. \\<And>q x. invar q \\<Longrightarrow> invar (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 3. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 4. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  invar q_\n\ngoal (1 subgoal):\n 1. invar (insert x_ q_)", "by(rule invar_insert)"], ["proof (state)\nthis:\n  invar (insert x_ q_)\n\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 2. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 3. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 2. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 3. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "case 8"], ["proof (state)\nthis:\n  invar q_\n  mset_heap q_ \\<noteq> {#}\n\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>invar q; mset_heap q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> invar (del_min q)\n 2. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 3. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  invar q_\n  mset_heap q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. invar (del_min q_)", "by (simp add: invar_del_min)"], ["proof (state)\nthis:\n  invar (del_min q_)\n\ngoal (2 subgoals):\n 1. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 2. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 2. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "case 9"], ["proof (state)\nthis:\n  invar q1_\n  invar q2_\n\ngoal (2 subgoals):\n 1. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> mset_heap (merge q1 q2) =\n                         mset_heap q1 + mset_heap q2\n 2. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  invar q1_\n  invar q2_\n\ngoal (1 subgoal):\n 1. mset_heap (merge q1_ q2_) = mset_heap q1_ + mset_heap q2_", "by (simp add: mset_merge)"], ["proof (state)\nthis:\n  mset_heap (merge q1_ q2_) = mset_heap q1_ + mset_heap q2_\n\ngoal (1 subgoal):\n 1. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "case 10"], ["proof (state)\nthis:\n  invar q1_\n  invar q2_\n\ngoal (1 subgoal):\n 1. \\<And>q1 q2.\n       \\<lbrakk>invar q1; invar q2\\<rbrakk>\n       \\<Longrightarrow> invar (merge q1 q2)", "thus ?case"], ["proof (prove)\nusing this:\n  invar q1_\n  invar q2_\n\ngoal (1 subgoal):\n 1. invar (merge q1_ q2_)", "by (simp add: invar_merge)"], ["proof (state)\nthis:\n  invar (merge q1_ q2_)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}