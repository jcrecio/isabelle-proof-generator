{"file_name": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals/McCarthy_91.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals", "problem_names": ["lemma funpow_rec: \"f ^^ n = (if n = 0 then id else f \\<circ> f ^^ (n - 1))\""], "translations": [["", "lemma funpow_rec: \"f ^^ n = (if n = 0 then id else f \\<circ> f ^^ (n - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ^^ n = (if n = 0 then id else f \\<circ> f ^^ (n - 1))", "by (induct n) auto"], ["", "text \\<open>\nThe \\<open>f\\<close> function captures the semantics of McCarthy's 91 function. The\n\\<open>g\\<close> function is a tail-recursive implementation of the function, whose\ntermination is established using the multiset order. The definitions follow\nDershowitz and Manna.\n\\<close>"], ["", "definition f :: \"int \\<Rightarrow> int\" where\n  \"f x = (if x > 100 then x - 10 else 91)\""], ["", "definition \\<tau> :: \"nat \\<Rightarrow> int \\<Rightarrow> int multiset\" where\n  \"\\<tau> n z = mset (map (\\<lambda>i. (f ^^ nat i) z) [0..int n - 1])\""], ["", "function g :: \"nat \\<Rightarrow> int \\<Rightarrow> int\" where\n  \"g n z = (if n = 0 then z else if z > 100 then g (n - 1) (z - 10) else g (n + 1) (z + 11))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>n z. x = (n, z) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>n z na za.\n       (n, z) = (na, za) \\<Longrightarrow>\n       (if n = 0 then z\n        else if 100 < z then g_sumC (n - 1, z - 10)\n             else g_sumC (n + 1, z + 11)) =\n       (if na = 0 then za\n        else if 100 < za then g_sumC (na - 1, za - 10)\n             else g_sumC (na + 1, za + 11))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All g_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All g_dom", "define lt :: \"(int \\<times> int) set\" where\n    \"lt = {(a, b). b < a \\<and> a \\<le> 111}\""], ["proof (state)\nthis:\n  lt = {(a, b). b < a \\<and> a \\<le> 111}\n\ngoal (1 subgoal):\n 1. All g_dom", "have lt_trans: \"trans lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans lt", "unfolding trans_def lt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       (x, y) \\<in> {(a, b). b < a \\<and> a \\<le> 111} \\<longrightarrow>\n       (y, z) \\<in> {(a, b). b < a \\<and> a \\<le> 111} \\<longrightarrow>\n       (x, z) \\<in> {(a, b). b < a \\<and> a \\<le> 111}", "by simp"], ["proof (state)\nthis:\n  trans lt\n\ngoal (1 subgoal):\n 1. All g_dom", "have lt_irrefl: \"irrefl lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irrefl lt", "unfolding irrefl_def lt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. (a, a) \\<notin> {(a, b). b < a \\<and> a \\<le> 111}", "by simp"], ["proof (state)\nthis:\n  irrefl lt\n\ngoal (1 subgoal):\n 1. All g_dom", "let ?LT = \"mult lt\""], ["proof (state)\ngoal (1 subgoal):\n 1. All g_dom", "let ?T = \"\\<lambda>(n, z). \\<tau> n z\""], ["proof (state)\ngoal (1 subgoal):\n 1. All g_dom", "let ?R = \"inv_image ?LT ?T\""], ["proof (state)\ngoal (1 subgoal):\n 1. All g_dom", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. All g_dom", "proof (relation ?R)"], ["proof (state)\ngoal (3 subgoals):\n 1. wf (inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z))\n 2. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n - 1, z - 10), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)\n 3. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "show \"wf ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z))", "by (auto simp: lt_def intro!: wf_inv_image[OF wf_mult]\n        wf_subset[OF wf_measure[of \"\\<lambda>z. nat (111 - z)\"]])"], ["proof (state)\nthis:\n  wf (inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z))\n\ngoal (2 subgoals):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n - 1, z - 10), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n - 1, z - 10), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "fix n :: nat and z :: int"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n - 1, z - 10), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "assume n_ne_0: \"n \\<noteq> 0\""], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n - 1, z - 10), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "{"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n - 1, z - 10), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "assume z_gt_100: \"z > 100\""], ["proof (state)\nthis:\n  100 < z\n\ngoal (2 subgoals):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n - 1, z - 10), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "have \"map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n        map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "using n_ne_0"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "proof (induct n rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> map (\\<lambda>i. (f ^^ nat i) (z - 10))\n[0..int y - 2] =\n                                     map (\\<lambda>i. (f ^^ nat i) z)\n[1..int y - 1];\n        x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. (f ^^ nat i) (z - 10))\n                          [0..int x - 2] =\n                         map (\\<lambda>i. (f ^^ nat i) z) [1..int x - 1]", "case (less n)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n; ?y \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>i. (f ^^ nat i) (z - 10))\n                     [0..int ?y - 2] =\n                    map (\\<lambda>i. (f ^^ nat i) z) [1..int ?y - 1]\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> map (\\<lambda>i. (f ^^ nat i) (z - 10))\n[0..int y - 2] =\n                                     map (\\<lambda>i. (f ^^ nat i) z)\n[1..int y - 1];\n        x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. (f ^^ nat i) (z - 10))\n                          [0..int x - 2] =\n                         map (\\<lambda>i. (f ^^ nat i) z) [1..int x - 1]", "note ih = this(1) and n_ne_0 = this(2)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n; ?y \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>i. (f ^^ nat i) (z - 10))\n                     [0..int ?y - 2] =\n                    map (\\<lambda>i. (f ^^ nat i) z) [1..int ?y - 1]\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> map (\\<lambda>i. (f ^^ nat i) (z - 10))\n[0..int y - 2] =\n                                     map (\\<lambda>i. (f ^^ nat i) z)\n[1..int y - 1];\n        x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i. (f ^^ nat i) (z - 10))\n                          [0..int x - 2] =\n                         map (\\<lambda>i. (f ^^ nat i) z) [1..int x - 1]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "proof (cases \"n = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "case True"], ["proof (state)\nthis:\n  n = 1\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 1\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n  map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "hence n_ge_2: \"n \\<ge> 2\""], ["proof (prove)\nusing this:\n  n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 2 \\<le> n", "using n_ne_0"], ["proof (prove)\nusing this:\n  n \\<noteq> 1\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> n", "by simp"], ["proof (state)\nthis:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "have\n            split_l: \"[0..int n - 2] = [0..int (n - 1) - 2] @ [int n - 2]\" and\n            split_r: \"[1..int n - 1] = [1..int (n - 1) - 1] @ [int n - 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..int n - 2] = [0..int (n - 1) - 2] @ [int n - 2] &&&\n    [1..int n - 1] = [1..int (n - 1) - 1] @ [int n - 1]", "using n_ge_2"], ["proof (prove)\nusing this:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. [0..int n - 2] = [0..int (n - 1) - 2] @ [int n - 2] &&&\n    [1..int n - 1] = [1..int (n - 1) - 1] @ [int n - 1]", "by (induct n) (auto simp: upto_rec2)"], ["proof (state)\nthis:\n  [0..int n - 2] = [0..int (n - 1) - 2] @ [int n - 2]\n  [1..int n - 1] = [1..int (n - 1) - 1] @ [int n - 1]\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "have f_repeat: \"(f ^^ (n - 2)) (z - 10) = (f ^^ (n - 1)) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ^^ (n - 2)) (z - 10) = (f ^^ (n - 1)) z", "using z_gt_100 n_ge_2"], ["proof (prove)\nusing this:\n  100 < z\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. (f ^^ (n - 2)) (z - 10) = (f ^^ (n - 1)) z", "by (induct n, simp) (rename_tac m; case_tac m; simp add: f_def)+"], ["proof (state)\nthis:\n  (f ^^ (n - 2)) (z - 10) = (f ^^ (n - 1)) z\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "using n_ge_2"], ["proof (prove)\nusing this:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "by (auto intro!: ih simp: split_l split_r f_repeat nat_diff_distrib')"], ["proof (state)\nthis:\n  map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n  map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n  map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n  map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\n\ngoal (2 subgoals):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n - 1, z - 10), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "hence image_mset_eq: \"{#(f ^^ nat i) (z - 10). i \\<in># mset [0..int n - 2]#} =\n        {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}\""], ["proof (prove)\nusing this:\n  map (\\<lambda>i. (f ^^ nat i) (z - 10)) [0..int n - 2] =\n  map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\n\ngoal (1 subgoal):\n 1. {#(f ^^ nat i) (z - 10). i \\<in># mset [0..int n - 2]#} =\n    {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}", "by (fold mset_map) (intro arg_cong[of _ _ mset])"], ["proof (state)\nthis:\n  {#(f ^^ nat i) (z - 10). i \\<in># mset [0..int n - 2]#} =\n  {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}\n\ngoal (2 subgoals):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n - 1, z - 10), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "have mset_eq_add_0_mset: \"mset [0..int n - 1] = add_mset 0 (mset [1..int n - 1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset [0..int n - 1] = add_mset 0 (mset [1..int n - 1])", "using n_ne_0"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. mset [0..int n - 1] = add_mset 0 (mset [1..int n - 1])", "by (induct n) (auto simp: upto.simps)"], ["proof (state)\nthis:\n  mset [0..int n - 1] = add_mset 0 (mset [1..int n - 1])\n\ngoal (2 subgoals):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n - 1, z - 10), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "have nm1m1: \"int (n - 1) - 1 = int n - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (n - 1) - 1 = int n - 2", "using n_ne_0"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int (n - 1) - 1 = int n - 2", "by simp"], ["proof (state)\nthis:\n  int (n - 1) - 1 = int n - 2\n\ngoal (2 subgoals):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n - 1, z - 10), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "show \"((n - 1, z - 10), (n, z)) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((n - 1, z - 10), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "by (auto simp: image_mset_eq mset_eq_add_0_mset nm1m1 \\<tau>_def simp del: One_nat_def\n          intro: subset_implies_mult image_mset_subset_mono)"], ["proof (state)\nthis:\n  ((n - 1, z - 10), n, z)\n  \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n\ngoal (1 subgoal):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "}"], ["proof (state)\nthis:\n  100 < z \\<Longrightarrow>\n  ((n - 1, z - 10), n, z)\n  \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n\ngoal (1 subgoal):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "{"], ["proof (state)\nthis:\n  100 < z \\<Longrightarrow>\n  ((n - 1, z - 10), n, z)\n  \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n\ngoal (1 subgoal):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "assume z_le_100: \"\\<not> z > 100\""], ["proof (state)\nthis:\n  \\<not> 100 < z\n\ngoal (1 subgoal):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "have map_eq: \"map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n        map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "using n_ne_0"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "proof (induct n rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> map (\\<lambda>x. (f ^^ nat x) (z + 11))\n[2..int y] =\n                                     map (\\<lambda>i. (f ^^ nat i) z)\n[1..int y - 1];\n        x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>x. (f ^^ nat x) (z + 11))\n                          [2..int x] =\n                         map (\\<lambda>i. (f ^^ nat i) z) [1..int x - 1]", "case (less n)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n; ?y \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int ?y] =\n                    map (\\<lambda>i. (f ^^ nat i) z) [1..int ?y - 1]\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> map (\\<lambda>x. (f ^^ nat x) (z + 11))\n[2..int y] =\n                                     map (\\<lambda>i. (f ^^ nat i) z)\n[1..int y - 1];\n        x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>x. (f ^^ nat x) (z + 11))\n                          [2..int x] =\n                         map (\\<lambda>i. (f ^^ nat i) z) [1..int x - 1]", "note ih = this(1) and n_ne_0 = this(2)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n; ?y \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int ?y] =\n                    map (\\<lambda>i. (f ^^ nat i) z) [1..int ?y - 1]\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; y \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> map (\\<lambda>x. (f ^^ nat x) (z + 11))\n[2..int y] =\n                                     map (\\<lambda>i. (f ^^ nat i) z)\n[1..int y - 1];\n        x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>x. (f ^^ nat x) (z + 11))\n                          [2..int x] =\n                         map (\\<lambda>i. (f ^^ nat i) z) [1..int x - 1]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "proof (cases \"n = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "case True"], ["proof (state)\nthis:\n  n = 1\n\ngoal (2 subgoals):\n 1. n = 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\n 2. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 1\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n  map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "hence n_ge_2: \"n \\<ge> 2\""], ["proof (prove)\nusing this:\n  n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 2 \\<le> n", "using n_ne_0"], ["proof (prove)\nusing this:\n  n \\<noteq> 1\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> n", "by simp"], ["proof (state)\nthis:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "have\n            split_l: \"[2..int n] = [2..int (n - 1)] @ [int n]\" and\n            split_r: \"[1..int n - 1] = [1..int (n - 1) - 1] @ [int n - 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [2..int n] = [2..int (n - 1)] @ [int n] &&&\n    [1..int n - 1] = [1..int (n - 1) - 1] @ [int n - 1]", "using n_ge_2"], ["proof (prove)\nusing this:\n  2 \\<le> n\n\ngoal (1 subgoal):\n 1. [2..int n] = [2..int (n - 1)] @ [int n] &&&\n    [1..int n - 1] = [1..int (n - 1) - 1] @ [int n - 1]", "by (induct n) (auto simp: upto_rec2)"], ["proof (state)\nthis:\n  [2..int n] = [2..int (n - 1)] @ [int n]\n  [1..int n - 1] = [1..int (n - 1) - 1] @ [int n - 1]\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "from z_le_100"], ["proof (chain)\npicking this:\n  \\<not> 100 < z", "have f_f_z_11: \"f (f (z + 11)) = f z\""], ["proof (prove)\nusing this:\n  \\<not> 100 < z\n\ngoal (1 subgoal):\n 1. f (f (z + 11)) = f z", "by (simp add: f_def)"], ["proof (state)\nthis:\n  f (f (z + 11)) = f z\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "moreover"], ["proof (state)\nthis:\n  f (f (z + 11)) = f z\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "define m where \"m = n - 2\""], ["proof (state)\nthis:\n  m = n - 2\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "with n_ge_2"], ["proof (chain)\npicking this:\n  2 \\<le> n\n  m = n - 2", "have \"n = m + 2\""], ["proof (prove)\nusing this:\n  2 \\<le> n\n  m = n - 2\n\ngoal (1 subgoal):\n 1. n = m + 2", "by simp"], ["proof (state)\nthis:\n  n = m + 2\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "ultimately"], ["proof (chain)\npicking this:\n  f (f (z + 11)) = f z\n  n = m + 2", "have f_repeat: \"(f ^^ n) (z + 11) = (f ^^ (n - 1)) z\""], ["proof (prove)\nusing this:\n  f (f (z + 11)) = f z\n  n = m + 2\n\ngoal (1 subgoal):\n 1. (f ^^ n) (z + 11) = (f ^^ (n - 1)) z", "by (simp add: funpow_Suc_right del: funpow.simps)"], ["proof (state)\nthis:\n  (f ^^ n) (z + 11) = (f ^^ (n - 1)) z\n\ngoal (1 subgoal):\n 1. n \\<noteq> 1 \\<Longrightarrow>\n    map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "with n_ge_2"], ["proof (chain)\npicking this:\n  2 \\<le> n\n  (f ^^ n) (z + 11) = (f ^^ (n - 1)) z", "show ?thesis"], ["proof (prove)\nusing this:\n  2 \\<le> n\n  (f ^^ n) (z + 11) = (f ^^ (n - 1)) z\n\ngoal (1 subgoal):\n 1. map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n    map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]", "by (auto intro: ih [of \"nat (int n - 1)\"]\n              simp: less.hyps split_l split_r nat_add_distrib nat_diff_distrib)"], ["proof (state)\nthis:\n  map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n  map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n  map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>x. (f ^^ nat x) (z + 11)) [2..int n] =\n  map (\\<lambda>i. (f ^^ nat i) z) [1..int n - 1]\n\ngoal (1 subgoal):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "have \"[0..int n] = [0..1] @ [2..int n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [0..int n] = [0..1] @ [2..int n]", "using n_ne_0"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [0..int n] = [0..1] @ [2..int n]", "by (simp add: upto_rec1)"], ["proof (state)\nthis:\n  [0..int n] = [0..1] @ [2..int n]\n\ngoal (1 subgoal):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "hence \"{#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n        {#(f ^^ nat x) (z + 11). x \\<in># mset [0..1]#}\n        + {#(f ^^ nat x) (z + 11). x \\<in># mset [2..int n]#}\""], ["proof (prove)\nusing this:\n  [0..int n] = [0..1] @ [2..int n]\n\ngoal (1 subgoal):\n 1. {#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n    {#(f ^^ nat x) (z + 11). x \\<in># mset [0..1]#} +\n    {#(f ^^ nat x) (z + 11). x \\<in># mset [2..int n]#}", "by auto"], ["proof (state)\nthis:\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [0..1]#} +\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [2..int n]#}\n\ngoal (1 subgoal):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "hence factor_out_first_two: \"{#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n        {#z + 11, f (z + 11)#} + {#(f ^^ nat x) (z + 11). x \\<in># mset [2..int n]#}\""], ["proof (prove)\nusing this:\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [0..1]#} +\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [2..int n]#}\n\ngoal (1 subgoal):\n 1. {#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n    {#z + 11, f (z + 11)#} +\n    {#(f ^^ nat x) (z + 11). x \\<in># mset [2..int n]#}", "by (auto simp: upto_rec1)"], ["proof (state)\nthis:\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n  {#z + 11, f (z + 11)#} +\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [2..int n]#}\n\ngoal (1 subgoal):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "let ?etc1 = \"{#(f ^^ nat i) (z + 11). i \\<in># mset [2..int n]#}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "let ?etc2 = \"{#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n z.\n       \\<lbrakk>n \\<noteq> 0; \\<not> 100 < z\\<rbrakk>\n       \\<Longrightarrow> ((n + 1, z + 11), n, z)\n                         \\<in> inv_image (mult lt)\n                                (\\<lambda>(n, z). \\<tau> n z)", "show \"((n + 1, z + 11), (n, z)) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "proof (cases \"z \\<ge> 90\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "case z_ge_90: True"], ["proof (state)\nthis:\n  90 \\<le> z\n\ngoal (2 subgoals):\n 1. 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "have \"{#z + 11, f (z + 11)#} + ?etc1 = {#z + 11, z + 1#} + ?etc2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#z + 11, f (z + 11)#} +\n    {#(f ^^ nat i) (z + 11). i \\<in># mset [2..int n]#} =\n    {#z + 11, z + 1#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}", "using z_ge_90"], ["proof (prove)\nusing this:\n  90 \\<le> z\n\ngoal (1 subgoal):\n 1. {#z + 11, f (z + 11)#} +\n    {#(f ^^ nat i) (z + 11). i \\<in># mset [2..int n]#} =\n    {#z + 11, z + 1#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}", "by (auto intro!: arg_cong2[of _ _ _ _ add_mset] simp: map_eq f_def mset_map[symmetric]\n            simp del: mset_map)"], ["proof (state)\nthis:\n  {#z + 11, f (z + 11)#} +\n  {#(f ^^ nat i) (z + 11). i \\<in># mset [2..int n]#} =\n  {#z + 11, z + 1#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}\n\ngoal (2 subgoals):\n 1. 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "hence image_mset_eq: \"{#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n          {#z + 11, z + 1#} + ?etc2\""], ["proof (prove)\nusing this:\n  {#z + 11, f (z + 11)#} +\n  {#(f ^^ nat i) (z + 11). i \\<in># mset [2..int n]#} =\n  {#z + 11, z + 1#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}\n\ngoal (1 subgoal):\n 1. {#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n    {#z + 11, z + 1#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}", "using factor_out_first_two"], ["proof (prove)\nusing this:\n  {#z + 11, f (z + 11)#} +\n  {#(f ^^ nat i) (z + 11). i \\<in># mset [2..int n]#} =\n  {#z + 11, z + 1#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n  {#z + 11, f (z + 11)#} +\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [2..int n]#}\n\ngoal (1 subgoal):\n 1. {#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n    {#z + 11, z + 1#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}", "by presburger"], ["proof (state)\nthis:\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n  {#z + 11, z + 1#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}\n\ngoal (2 subgoals):\n 1. 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "have \"({#z + 11, z + 1#}, {#z#}) \\<in> mult1 lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#z + 11, z + 1#}, {#z#}) \\<in> mult1 lt", "using z_le_100 z_ge_90"], ["proof (prove)\nusing this:\n  \\<not> 100 < z\n  90 \\<le> z\n\ngoal (1 subgoal):\n 1. ({#z + 11, z + 1#}, {#z#}) \\<in> mult1 lt", "by (auto intro!: mult1I simp: lt_def)"], ["proof (state)\nthis:\n  ({#z + 11, z + 1#}, {#z#}) \\<in> mult1 lt\n\ngoal (2 subgoals):\n 1. 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "hence \"({#z + 11, z + 1#}, {#z#}) \\<in> mult lt\""], ["proof (prove)\nusing this:\n  ({#z + 11, z + 1#}, {#z#}) \\<in> mult1 lt\n\ngoal (1 subgoal):\n 1. ({#z + 11, z + 1#}, {#z#}) \\<in> mult lt", "unfolding mult_def"], ["proof (prove)\nusing this:\n  ({#z + 11, z + 1#}, {#z#}) \\<in> mult1 lt\n\ngoal (1 subgoal):\n 1. ({#z + 11, z + 1#}, {#z#}) \\<in> (mult1 lt)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  ({#z + 11, z + 1#}, {#z#}) \\<in> mult lt\n\ngoal (2 subgoals):\n 1. 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "hence \"({#z + 11, z + 1#} + ?etc2, {#z#} + ?etc2) \\<in> mult lt\""], ["proof (prove)\nusing this:\n  ({#z + 11, z + 1#}, {#z#}) \\<in> mult lt\n\ngoal (1 subgoal):\n 1. ({#z + 11, z + 1#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#},\n     {#z#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#})\n    \\<in> mult lt", "by (rule mult_cancel[THEN iffD2, OF lt_trans lt_irrefl])"], ["proof (state)\nthis:\n  ({#z + 11, z + 1#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#},\n   {#z#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#})\n  \\<in> mult lt\n\ngoal (2 subgoals):\n 1. 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n 2. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ({#z + 11, z + 1#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#},\n   {#z#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#})\n  \\<in> mult lt\n\ngoal (1 subgoal):\n 1. ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "using n_ne_0"], ["proof (prove)\nusing this:\n  ({#z + 11, z + 1#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#},\n   {#z#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#})\n  \\<in> mult lt\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "by (auto simp: image_mset_eq \\<tau>_def upto_rec1[of 0 \"int n - 1\"])"], ["proof (state)\nthis:\n  ((n + 1, z + 11), n, z)\n  \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n\ngoal (1 subgoal):\n 1. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "case z_lt_90: False"], ["proof (state)\nthis:\n  \\<not> 90 \\<le> z\n\ngoal (1 subgoal):\n 1. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "have \"{#z + 11, f (z + 11)#} + ?etc1 = {#z + 11, 91#} + ?etc2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#z + 11, f (z + 11)#} +\n    {#(f ^^ nat i) (z + 11). i \\<in># mset [2..int n]#} =\n    {#z + 11, 91#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}", "using z_lt_90"], ["proof (prove)\nusing this:\n  \\<not> 90 \\<le> z\n\ngoal (1 subgoal):\n 1. {#z + 11, f (z + 11)#} +\n    {#(f ^^ nat i) (z + 11). i \\<in># mset [2..int n]#} =\n    {#z + 11, 91#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}", "by (auto intro!: arg_cong2[of _ _ _ _ add_mset] simp: map_eq f_def mset_map[symmetric]\n            simp del: mset_map)"], ["proof (state)\nthis:\n  {#z + 11, f (z + 11)#} +\n  {#(f ^^ nat i) (z + 11). i \\<in># mset [2..int n]#} =\n  {#z + 11, 91#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}\n\ngoal (1 subgoal):\n 1. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "hence image_mset_eq: \"{#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n          {#z + 11, 91#} + ?etc2\""], ["proof (prove)\nusing this:\n  {#z + 11, f (z + 11)#} +\n  {#(f ^^ nat i) (z + 11). i \\<in># mset [2..int n]#} =\n  {#z + 11, 91#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}\n\ngoal (1 subgoal):\n 1. {#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n    {#z + 11, 91#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}", "using factor_out_first_two"], ["proof (prove)\nusing this:\n  {#z + 11, f (z + 11)#} +\n  {#(f ^^ nat i) (z + 11). i \\<in># mset [2..int n]#} =\n  {#z + 11, 91#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n  {#z + 11, f (z + 11)#} +\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [2..int n]#}\n\ngoal (1 subgoal):\n 1. {#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n    {#z + 11, 91#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}", "by presburger"], ["proof (state)\nthis:\n  {#(f ^^ nat x) (z + 11). x \\<in># mset [0..int n]#} =\n  {#z + 11, 91#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#}\n\ngoal (1 subgoal):\n 1. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "have \"({#z + 11, 91#}, {#z#}) \\<in> mult1 lt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#z + 11, 91#}, {#z#}) \\<in> mult1 lt", "using z_le_100 z_lt_90"], ["proof (prove)\nusing this:\n  \\<not> 100 < z\n  \\<not> 90 \\<le> z\n\ngoal (1 subgoal):\n 1. ({#z + 11, 91#}, {#z#}) \\<in> mult1 lt", "by (auto intro!: mult1I simp: lt_def)"], ["proof (state)\nthis:\n  ({#z + 11, 91#}, {#z#}) \\<in> mult1 lt\n\ngoal (1 subgoal):\n 1. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "hence \"({#z + 11, 91#}, {#z#}) \\<in> mult lt\""], ["proof (prove)\nusing this:\n  ({#z + 11, 91#}, {#z#}) \\<in> mult1 lt\n\ngoal (1 subgoal):\n 1. ({#z + 11, 91#}, {#z#}) \\<in> mult lt", "unfolding mult_def"], ["proof (prove)\nusing this:\n  ({#z + 11, 91#}, {#z#}) \\<in> mult1 lt\n\ngoal (1 subgoal):\n 1. ({#z + 11, 91#}, {#z#}) \\<in> (mult1 lt)\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  ({#z + 11, 91#}, {#z#}) \\<in> mult lt\n\ngoal (1 subgoal):\n 1. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "hence \"({#z + 11, 91#} + ?etc2, {#z#} + ?etc2) \\<in> mult lt\""], ["proof (prove)\nusing this:\n  ({#z + 11, 91#}, {#z#}) \\<in> mult lt\n\ngoal (1 subgoal):\n 1. ({#z + 11, 91#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#},\n     {#z#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#})\n    \\<in> mult lt", "by (rule mult_cancel[THEN iffD2, OF lt_trans lt_irrefl])"], ["proof (state)\nthis:\n  ({#z + 11, 91#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#},\n   {#z#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#})\n  \\<in> mult lt\n\ngoal (1 subgoal):\n 1. \\<not> 90 \\<le> z \\<Longrightarrow>\n    ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ({#z + 11, 91#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#},\n   {#z#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#})\n  \\<in> mult lt\n\ngoal (1 subgoal):\n 1. ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "using n_ne_0"], ["proof (prove)\nusing this:\n  ({#z + 11, 91#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#},\n   {#z#} + {#(f ^^ nat i) z. i \\<in># mset [1..int n - 1]#})\n  \\<in> mult lt\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. ((n + 1, z + 11), n, z)\n    \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)", "by (auto simp: image_mset_eq \\<tau>_def upto_rec1[of 0 \"int n - 1\"])"], ["proof (state)\nthis:\n  ((n + 1, z + 11), n, z)\n  \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((n + 1, z + 11), n, z)\n  \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<not> 100 < z \\<Longrightarrow>\n  ((n + 1, z + 11), n, z)\n  \\<in> inv_image (mult lt) (\\<lambda>(n, z). \\<tau> n z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  All g_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "declare g.simps [simp del]"], ["", "end"]]}