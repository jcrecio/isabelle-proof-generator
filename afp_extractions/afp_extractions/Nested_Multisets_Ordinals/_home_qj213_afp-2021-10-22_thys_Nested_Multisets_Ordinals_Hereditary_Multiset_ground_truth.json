{"file_name": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals/Hereditary_Multiset.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals", "problem_names": ["lemma hmsetmset_inject[simp]: \"hmsetmset A = hmsetmset B \\<longleftrightarrow> A = B\"", "lemma type_definition_hmultiset: \"type_definition Rep_hmultiset Abs_hmultiset {X. no_elem X}\"", "lemma HMSet_alt: \"HMSet = Abs_hmultiset o MSet o image_mset Rep_hmultiset\"", "lemma HMSet_transfer[transfer_rule]: \"rel_fun (rel_mset pcr_hmultiset) pcr_hmultiset MSet HMSet\"", "lemma less_HMSet_iff_less_multiset_ext\\<^sub>D\\<^sub>M: \"HMSet M < HMSet N \\<longleftrightarrow> less_multiset_ext\\<^sub>D\\<^sub>M (<) M N\"", "lemma hmsetmset_less[simp]: \"hmsetmset M < hmsetmset N \\<longleftrightarrow> M < N\"", "lemma hmsetmset_le[simp]: \"hmsetmset M \\<le> hmsetmset N \\<longleftrightarrow> M \\<le> N\"", "lemma wf_less_hmultiset: \"wf {(X :: hmultiset, Y :: hmultiset). X < Y}\"", "lemma HMSet_less[simp]: \"HMSet M < HMSet N \\<longleftrightarrow> M < N\"", "lemma HMSet_le[simp]: \"HMSet M \\<le> HMSet N \\<longleftrightarrow> M \\<le> N\"", "lemma mem_imp_less_HMSet: \"k \\<in># L \\<Longrightarrow> k < HMSet L\"", "lemma mem_hmsetmset_imp_less: \"M \\<in># hmsetmset N \\<Longrightarrow> M < N\"", "lemma hmsetmset_empty_iff[simp]: \"hmsetmset n = {#} \\<longleftrightarrow> n = 0\"", "lemma hmsetmset_0[simp]: \"hmsetmset 0 = {#}\"", "lemma\n  HMSet_eq_0_iff[simp]: \"HMSet m = 0 \\<longleftrightarrow> m = {#}\" and\n  zero_eq_HMSet[simp]: \"0 = HMSet m \\<longleftrightarrow> m = {#}\"", "lemma HMSet_plus: \"HMSet (A + B) = HMSet A + HMSet B\"", "lemma HMSet_diff: \"HMSet (A - B) = HMSet A - HMSet B\"", "lemma hmsetmset_plus: \"hmsetmset (M + N) = hmsetmset M + hmsetmset N\"", "lemma hmsetmset_diff: \"hmsetmset (M - N) = hmsetmset M - hmsetmset N\"", "lemma diff_diff_add_hmset[simp]: \"a - b - c = a - (b + c)\" for a b c :: hmultiset", "lemma le_minus_plus_same_hmset: \"m \\<le> m - n + n\" for m n :: hmultiset", "lemma zero_le_hmset[simp]: \"0 \\<le> M\" for M :: hmultiset", "lemma\n  le_add1_hmset: \"n \\<le> n + m\" and\n  le_add2_hmset: \"n \\<le> m + n\" for n :: hmultiset", "lemma le_zero_eq_hmset[simp]: \"M \\<le> 0 \\<longleftrightarrow> M = 0\" for M :: hmultiset", "lemma not_less_zero_hmset[simp]: \"\\<not> M < 0\" for M :: hmultiset", "lemma not_gr_zero_hmset[simp]: \"\\<not> 0 < M \\<longleftrightarrow> M = 0\" for M :: hmultiset", "lemma zero_less_iff_neq_zero_hmset: \"0 < M \\<longleftrightarrow> M \\<noteq> 0\" for M :: hmultiset", "lemma zero_less_HMSet_iff[simp]: \"0 < HMSet M \\<longleftrightarrow> M \\<noteq> {#}\"", "lemma gr_zeroI_hmset: \"(M = 0 \\<Longrightarrow> False) \\<Longrightarrow> 0 < M\" for M :: hmultiset", "lemma gr_implies_not_zero_hmset: \"M < N \\<Longrightarrow> N \\<noteq> 0\" for M N :: hmultiset", "lemma add_eq_0_iff_both_eq_0_hmset[simp]: \"M + N = 0 \\<longleftrightarrow> M = 0 \\<and> N = 0\" for M N :: hmultiset", "lemma trans_less_add1_hmset: \"i < j \\<Longrightarrow> i < j + m\" for i j m :: hmultiset", "lemma trans_less_add2_hmset: \"i < j \\<Longrightarrow> i < m + j\" for i j m :: hmultiset", "lemma trans_le_add1_hmset: \"i \\<le> j \\<Longrightarrow> i \\<le> j + m\" for i j m :: hmultiset", "lemma trans_le_add2_hmset: \"i \\<le> j \\<Longrightarrow> i \\<le> m + j\" for i j m :: hmultiset", "lemma diff_le_self_hmset: \"m - n \\<le> m\" for m n :: hmultiset"], "translations": [["", "lemma hmsetmset_inject[simp]: \"hmsetmset A = hmsetmset B \\<longleftrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hmsetmset A = hmsetmset B) = (A = B)", "by (blast intro: hmultiset.expand)"], ["", "primrec Rep_hmultiset :: \"hmultiset \\<Rightarrow> unit nmultiset\" where\n  \"Rep_hmultiset (HMSet M) = MSet (image_mset Rep_hmultiset M)\""], ["", "primrec (nonexhaustive) Abs_hmultiset :: \"unit nmultiset \\<Rightarrow> hmultiset\" where\n  \"Abs_hmultiset (MSet M) = HMSet (image_mset Abs_hmultiset M)\""], ["", "lemma type_definition_hmultiset: \"type_definition Rep_hmultiset Abs_hmultiset {X. no_elem X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_definition Hereditary_Multiset.Rep_hmultiset\n     Hereditary_Multiset.Abs_hmultiset {X. no_elem X}", "proof (unfold_locales, unfold mem_Collect_eq)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. no_elem (Hereditary_Multiset.Rep_hmultiset x)\n 2. \\<And>x.\n       Hereditary_Multiset.Abs_hmultiset\n        (Hereditary_Multiset.Rep_hmultiset x) =\n       x\n 3. \\<And>y.\n       no_elem y \\<Longrightarrow>\n       Hereditary_Multiset.Rep_hmultiset\n        (Hereditary_Multiset.Abs_hmultiset y) =\n       y", "fix X"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. no_elem (Hereditary_Multiset.Rep_hmultiset x)\n 2. \\<And>x.\n       Hereditary_Multiset.Abs_hmultiset\n        (Hereditary_Multiset.Rep_hmultiset x) =\n       x\n 3. \\<And>y.\n       no_elem y \\<Longrightarrow>\n       Hereditary_Multiset.Rep_hmultiset\n        (Hereditary_Multiset.Abs_hmultiset y) =\n       y", "show \"no_elem (Rep_hmultiset X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_elem (Hereditary_Multiset.Rep_hmultiset X)", "by (induct X) (auto intro!: no_elem.intros)"], ["proof (state)\nthis:\n  no_elem (Hereditary_Multiset.Rep_hmultiset X)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       Hereditary_Multiset.Abs_hmultiset\n        (Hereditary_Multiset.Rep_hmultiset x) =\n       x\n 2. \\<And>y.\n       no_elem y \\<Longrightarrow>\n       Hereditary_Multiset.Rep_hmultiset\n        (Hereditary_Multiset.Abs_hmultiset y) =\n       y", "show \"Abs_hmultiset (Rep_hmultiset X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hereditary_Multiset.Abs_hmultiset\n     (Hereditary_Multiset.Rep_hmultiset X) =\n    X", "by (induct X) auto"], ["proof (state)\nthis:\n  Hereditary_Multiset.Abs_hmultiset (Hereditary_Multiset.Rep_hmultiset X) =\n  X\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       no_elem y \\<Longrightarrow>\n       Hereditary_Multiset.Rep_hmultiset\n        (Hereditary_Multiset.Abs_hmultiset y) =\n       y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       no_elem y \\<Longrightarrow>\n       Hereditary_Multiset.Rep_hmultiset\n        (Hereditary_Multiset.Abs_hmultiset y) =\n       y", "fix Y :: \"unit nmultiset\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       no_elem y \\<Longrightarrow>\n       Hereditary_Multiset.Rep_hmultiset\n        (Hereditary_Multiset.Abs_hmultiset y) =\n       y", "assume \"no_elem Y\""], ["proof (state)\nthis:\n  no_elem Y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       no_elem y \\<Longrightarrow>\n       Hereditary_Multiset.Rep_hmultiset\n        (Hereditary_Multiset.Abs_hmultiset y) =\n       y", "thus \"Rep_hmultiset (Abs_hmultiset Y) = Y\""], ["proof (prove)\nusing this:\n  no_elem Y\n\ngoal (1 subgoal):\n 1. Hereditary_Multiset.Rep_hmultiset\n     (Hereditary_Multiset.Abs_hmultiset Y) =\n    Y", "by (induct Y rule: no_elem.induct) auto"], ["proof (state)\nthis:\n  Hereditary_Multiset.Rep_hmultiset (Hereditary_Multiset.Abs_hmultiset Y) =\n  Y\n\ngoal:\nNo subgoals!", "qed"], ["", "setup_lifting type_definition_hmultiset"], ["", "lemma HMSet_alt: \"HMSet = Abs_hmultiset o MSet o image_mset Rep_hmultiset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMSet =\n    Hereditary_Multiset.Abs_hmultiset \\<circ> MSet \\<circ>\n    image_mset Hereditary_Multiset.Rep_hmultiset", "by (auto simp: type_definition.Rep_inverse[OF type_definition_hmultiset])"], ["", "lemma HMSet_transfer[transfer_rule]: \"rel_fun (rel_mset pcr_hmultiset) pcr_hmultiset MSet HMSet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_mset pcr_hmultiset) pcr_hmultiset MSet HMSet", "unfolding HMSet_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_mset pcr_hmultiset) pcr_hmultiset MSet\n     (Hereditary_Multiset.Abs_hmultiset \\<circ> MSet \\<circ>\n      image_mset Hereditary_Multiset.Rep_hmultiset)", "by (force simp: rel_fun_def multiset.in_rel nmultiset.rel_eq\n    pcr_hmultiset_def cr_hmultiset_def\n    type_definition.Rep_inverse[OF type_definition_hmultiset] intro!: multiset.map_cong)"], ["", "subsection \\<open>Restriction of Dershowitz and Manna's Nested Multiset Order\\<close>"], ["", "instantiation hmultiset :: linorder\nbegin"], ["", "lift_definition less_hmultiset :: \"hmultiset \\<Rightarrow> hmultiset \\<Rightarrow> bool\" is \"(<)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_eq_hmultiset :: \"hmultiset \\<Rightarrow> hmultiset \\<Rightarrow> bool\" is \"(\\<le>)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, linorder_class)", "by (intro_classes; transfer) auto"], ["", "end"], ["", "lemma less_HMSet_iff_less_multiset_ext\\<^sub>D\\<^sub>M: \"HMSet M < HMSet N \\<longleftrightarrow> less_multiset_ext\\<^sub>D\\<^sub>M (<) M N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMSet M < HMSet N) = less_multiset_ext\\<^sub>D\\<^sub>M (<) M N", "unfolding less_multiset_ext\\<^sub>D\\<^sub>M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMSet M < HMSet N) =\n    (\\<exists>X Y.\n        X \\<noteq> {#} \\<and>\n        X \\<subseteq># N \\<and>\n        M = N - X + Y \\<and>\n        (\\<forall>k.\n            k \\<in># Y \\<longrightarrow>\n            (\\<exists>a. a \\<in># X \\<and> k < a)))", "proof (transfer, unfold less_nmultiset.simps less_multiset_ext\\<^sub>D\\<^sub>M_def, safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        X \\<noteq> {#}; X \\<subseteq># N;\n        \\<forall>k.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a. a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa\\<in>Collect (pred_mset no_elem).\n                            \\<exists>Ya\\<in>Collect (pred_mset no_elem).\n                               Xa \\<noteq> {#} \\<and>\n                               filter_mset no_elem Xa \\<subseteq>#\n                               filter_mset no_elem N \\<and>\n                               N - X + Y = N - Xa + Ya \\<and>\n                               (\\<forall>k\\<in>Collect no_elem.\n                                   k \\<in># Ya \\<longrightarrow>\n                                   (\\<exists>a\\<in>Collect no_elem.\n a \\<in># Xa \\<and> k < a))\n 2. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        pred_mset no_elem X; pred_mset no_elem Y; X \\<noteq> {#};\n        filter_mset no_elem X \\<subseteq># filter_mset no_elem N;\n        \\<forall>k\\<in>Collect no_elem.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a\\<in>Collect no_elem.\n               a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa Ya.\n                            Xa \\<noteq> {#} \\<and>\n                            Xa \\<subseteq># N \\<and>\n                            N - X + Y = N - Xa + Ya \\<and>\n                            (\\<forall>k.\n                                k \\<in># Ya \\<longrightarrow>\n                                (\\<exists>a. a \\<in># Xa \\<and> k < a))", "fix M N :: \"unit nmultiset multiset\" and X Y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        X \\<noteq> {#}; X \\<subseteq># N;\n        \\<forall>k.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a. a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa\\<in>Collect (pred_mset no_elem).\n                            \\<exists>Ya\\<in>Collect (pred_mset no_elem).\n                               Xa \\<noteq> {#} \\<and>\n                               filter_mset no_elem Xa \\<subseteq>#\n                               filter_mset no_elem N \\<and>\n                               N - X + Y = N - Xa + Ya \\<and>\n                               (\\<forall>k\\<in>Collect no_elem.\n                                   k \\<in># Ya \\<longrightarrow>\n                                   (\\<exists>a\\<in>Collect no_elem.\n a \\<in># Xa \\<and> k < a))\n 2. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        pred_mset no_elem X; pred_mset no_elem Y; X \\<noteq> {#};\n        filter_mset no_elem X \\<subseteq># filter_mset no_elem N;\n        \\<forall>k\\<in>Collect no_elem.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a\\<in>Collect no_elem.\n               a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa Ya.\n                            Xa \\<noteq> {#} \\<and>\n                            Xa \\<subseteq># N \\<and>\n                            N - X + Y = N - Xa + Ya \\<and>\n                            (\\<forall>k.\n                                k \\<in># Ya \\<longrightarrow>\n                                (\\<exists>a. a \\<in># Xa \\<and> k < a))", "assume *: \"pred_mset no_elem (N - X + Y)\" \"pred_mset no_elem N\" \"X \\<noteq> {#}\"\n    \"X \\<subseteq># N\" \"\\<forall>k. k \\<in># Y \\<longrightarrow> (\\<exists>a. a \\<in># X \\<and> k < a)\""], ["proof (state)\nthis:\n  pred_mset no_elem (N - X + Y)\n  pred_mset no_elem N\n  X \\<noteq> {#}\n  X \\<subseteq># N\n  \\<forall>k.\n     k \\<in># Y \\<longrightarrow> (\\<exists>a. a \\<in># X \\<and> k < a)\n\ngoal (2 subgoals):\n 1. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        X \\<noteq> {#}; X \\<subseteq># N;\n        \\<forall>k.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a. a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa\\<in>Collect (pred_mset no_elem).\n                            \\<exists>Ya\\<in>Collect (pred_mset no_elem).\n                               Xa \\<noteq> {#} \\<and>\n                               filter_mset no_elem Xa \\<subseteq>#\n                               filter_mset no_elem N \\<and>\n                               N - X + Y = N - Xa + Ya \\<and>\n                               (\\<forall>k\\<in>Collect no_elem.\n                                   k \\<in># Ya \\<longrightarrow>\n                                   (\\<exists>a\\<in>Collect no_elem.\n a \\<in># Xa \\<and> k < a))\n 2. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        pred_mset no_elem X; pred_mset no_elem Y; X \\<noteq> {#};\n        filter_mset no_elem X \\<subseteq># filter_mset no_elem N;\n        \\<forall>k\\<in>Collect no_elem.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a\\<in>Collect no_elem.\n               a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa Ya.\n                            Xa \\<noteq> {#} \\<and>\n                            Xa \\<subseteq># N \\<and>\n                            N - X + Y = N - Xa + Ya \\<and>\n                            (\\<forall>k.\n                                k \\<in># Ya \\<longrightarrow>\n                                (\\<exists>a. a \\<in># Xa \\<and> k < a))", "then"], ["proof (chain)\npicking this:\n  pred_mset no_elem (N - X + Y)\n  pred_mset no_elem N\n  X \\<noteq> {#}\n  X \\<subseteq># N\n  \\<forall>k.\n     k \\<in># Y \\<longrightarrow> (\\<exists>a. a \\<in># X \\<and> k < a)", "have \"X \\<in> Collect (pred_mset no_elem)\""], ["proof (prove)\nusing this:\n  pred_mset no_elem (N - X + Y)\n  pred_mset no_elem N\n  X \\<noteq> {#}\n  X \\<subseteq># N\n  \\<forall>k.\n     k \\<in># Y \\<longrightarrow> (\\<exists>a. a \\<in># X \\<and> k < a)\n\ngoal (1 subgoal):\n 1. X \\<in> Collect (pred_mset no_elem)", "unfolding multiset.pred_set mem_Collect_eq"], ["proof (prove)\nusing this:\n  Multiset.Ball (N - X + Y) no_elem\n  Multiset.Ball N no_elem\n  X \\<noteq> {#}\n  X \\<subseteq># N\n  \\<forall>k.\n     k \\<in># Y \\<longrightarrow> (\\<exists>a. a \\<in># X \\<and> k < a)\n\ngoal (1 subgoal):\n 1. Multiset.Ball X no_elem", "by (metis rev_subsetD set_mset_mono)"], ["proof (state)\nthis:\n  X \\<in> Collect (pred_mset no_elem)\n\ngoal (2 subgoals):\n 1. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        X \\<noteq> {#}; X \\<subseteq># N;\n        \\<forall>k.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a. a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa\\<in>Collect (pred_mset no_elem).\n                            \\<exists>Ya\\<in>Collect (pred_mset no_elem).\n                               Xa \\<noteq> {#} \\<and>\n                               filter_mset no_elem Xa \\<subseteq>#\n                               filter_mset no_elem N \\<and>\n                               N - X + Y = N - Xa + Ya \\<and>\n                               (\\<forall>k\\<in>Collect no_elem.\n                                   k \\<in># Ya \\<longrightarrow>\n                                   (\\<exists>a\\<in>Collect no_elem.\n a \\<in># Xa \\<and> k < a))\n 2. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        pred_mset no_elem X; pred_mset no_elem Y; X \\<noteq> {#};\n        filter_mset no_elem X \\<subseteq># filter_mset no_elem N;\n        \\<forall>k\\<in>Collect no_elem.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a\\<in>Collect no_elem.\n               a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa Ya.\n                            Xa \\<noteq> {#} \\<and>\n                            Xa \\<subseteq># N \\<and>\n                            N - X + Y = N - Xa + Ya \\<and>\n                            (\\<forall>k.\n                                k \\<in># Ya \\<longrightarrow>\n                                (\\<exists>a. a \\<in># Xa \\<and> k < a))", "from *(1)"], ["proof (chain)\npicking this:\n  pred_mset no_elem (N - X + Y)", "have \"Y \\<in> Collect (pred_mset no_elem)\""], ["proof (prove)\nusing this:\n  pred_mset no_elem (N - X + Y)\n\ngoal (1 subgoal):\n 1. Y \\<in> Collect (pred_mset no_elem)", "unfolding multiset.pred_set mem_Collect_eq"], ["proof (prove)\nusing this:\n  Multiset.Ball (N - X + Y) no_elem\n\ngoal (1 subgoal):\n 1. Multiset.Ball Y no_elem", "by (metis add_diff_cancel_left' in_diffD)"], ["proof (state)\nthis:\n  Y \\<in> Collect (pred_mset no_elem)\n\ngoal (2 subgoals):\n 1. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        X \\<noteq> {#}; X \\<subseteq># N;\n        \\<forall>k.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a. a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa\\<in>Collect (pred_mset no_elem).\n                            \\<exists>Ya\\<in>Collect (pred_mset no_elem).\n                               Xa \\<noteq> {#} \\<and>\n                               filter_mset no_elem Xa \\<subseteq>#\n                               filter_mset no_elem N \\<and>\n                               N - X + Y = N - Xa + Ya \\<and>\n                               (\\<forall>k\\<in>Collect no_elem.\n                                   k \\<in># Ya \\<longrightarrow>\n                                   (\\<exists>a\\<in>Collect no_elem.\n a \\<in># Xa \\<and> k < a))\n 2. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        pred_mset no_elem X; pred_mset no_elem Y; X \\<noteq> {#};\n        filter_mset no_elem X \\<subseteq># filter_mset no_elem N;\n        \\<forall>k\\<in>Collect no_elem.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a\\<in>Collect no_elem.\n               a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa Ya.\n                            Xa \\<noteq> {#} \\<and>\n                            Xa \\<subseteq># N \\<and>\n                            N - X + Y = N - Xa + Ya \\<and>\n                            (\\<forall>k.\n                                k \\<in># Ya \\<longrightarrow>\n                                (\\<exists>a. a \\<in># Xa \\<and> k < a))", "show\n    \"\\<exists>X'\\<in>Collect (pred_mset no_elem). \\<exists>Y'\\<in>Collect (pred_mset no_elem).\n      X' \\<noteq> {#} \\<and> filter_mset no_elem X' \\<subseteq># filter_mset no_elem N \\<and> N - X + Y = N - X' + Y' \\<and>\n      (\\<forall>k\\<in>Collect no_elem. k \\<in># Y' \\<longrightarrow> (\\<exists>a\\<in>Collect no_elem. a \\<in># X' \\<and> k < a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X'\\<in>Collect (pred_mset no_elem).\n       \\<exists>Y'\\<in>Collect (pred_mset no_elem).\n          X' \\<noteq> {#} \\<and>\n          filter_mset no_elem X' \\<subseteq># filter_mset no_elem N \\<and>\n          N - X + Y = N - X' + Y' \\<and>\n          (\\<forall>k\\<in>Collect no_elem.\n              k \\<in># Y' \\<longrightarrow>\n              (\\<exists>a\\<in>Collect no_elem. a \\<in># X' \\<and> k < a))", "by (rule bexI[OF _ \\<open>X \\<in> Collect (pred_mset no_elem)\\<close>],\n        rule bexI[OF _ \\<open>Y \\<in> Collect (pred_mset no_elem)\\<close>])\n      (insert *; force simp: set_mset_diff multiset.pred_set multiset_filter_mono)"], ["proof (state)\nthis:\n  \\<exists>X'\\<in>Collect (pred_mset no_elem).\n     \\<exists>Y'\\<in>Collect (pred_mset no_elem).\n        X' \\<noteq> {#} \\<and>\n        filter_mset no_elem X' \\<subseteq># filter_mset no_elem N \\<and>\n        N - X + Y = N - X' + Y' \\<and>\n        (\\<forall>k\\<in>Collect no_elem.\n            k \\<in># Y' \\<longrightarrow>\n            (\\<exists>a\\<in>Collect no_elem. a \\<in># X' \\<and> k < a))\n\ngoal (1 subgoal):\n 1. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        pred_mset no_elem X; pred_mset no_elem Y; X \\<noteq> {#};\n        filter_mset no_elem X \\<subseteq># filter_mset no_elem N;\n        \\<forall>k\\<in>Collect no_elem.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a\\<in>Collect no_elem.\n               a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa Ya.\n                            Xa \\<noteq> {#} \\<and>\n                            Xa \\<subseteq># N \\<and>\n                            N - X + Y = N - Xa + Ya \\<and>\n                            (\\<forall>k.\n                                k \\<in># Ya \\<longrightarrow>\n                                (\\<exists>a. a \\<in># Xa \\<and> k < a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        pred_mset no_elem X; pred_mset no_elem Y; X \\<noteq> {#};\n        filter_mset no_elem X \\<subseteq># filter_mset no_elem N;\n        \\<forall>k\\<in>Collect no_elem.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a\\<in>Collect no_elem.\n               a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa Ya.\n                            Xa \\<noteq> {#} \\<and>\n                            Xa \\<subseteq># N \\<and>\n                            N - X + Y = N - Xa + Ya \\<and>\n                            (\\<forall>k.\n                                k \\<in># Ya \\<longrightarrow>\n                                (\\<exists>a. a \\<in># Xa \\<and> k < a))", "fix M N :: \"unit nmultiset multiset\" and X Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        pred_mset no_elem X; pred_mset no_elem Y; X \\<noteq> {#};\n        filter_mset no_elem X \\<subseteq># filter_mset no_elem N;\n        \\<forall>k\\<in>Collect no_elem.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a\\<in>Collect no_elem.\n               a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa Ya.\n                            Xa \\<noteq> {#} \\<and>\n                            Xa \\<subseteq># N \\<and>\n                            N - X + Y = N - Xa + Ya \\<and>\n                            (\\<forall>k.\n                                k \\<in># Ya \\<longrightarrow>\n                                (\\<exists>a. a \\<in># Xa \\<and> k < a))", "assume *:\n    \"pred_mset no_elem (N - X + Y)\" \"pred_mset no_elem N\" \"pred_mset no_elem X\" \"pred_mset no_elem Y\"\n    \"X \\<noteq> {#}\" \"filter_mset no_elem X \\<subseteq># filter_mset no_elem N\"\n    \"\\<forall>k\\<in>Collect no_elem.  k \\<in># Y \\<longrightarrow> (\\<exists>a\\<in>Collect no_elem. a \\<in># X \\<and> k < a)\""], ["proof (state)\nthis:\n  pred_mset no_elem (N - X + Y)\n  pred_mset no_elem N\n  pred_mset no_elem X\n  pred_mset no_elem Y\n  X \\<noteq> {#}\n  filter_mset no_elem X \\<subseteq># filter_mset no_elem N\n  \\<forall>k\\<in>Collect no_elem.\n     k \\<in># Y \\<longrightarrow>\n     (\\<exists>a\\<in>Collect no_elem. a \\<in># X \\<and> k < a)\n\ngoal (1 subgoal):\n 1. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        pred_mset no_elem X; pred_mset no_elem Y; X \\<noteq> {#};\n        filter_mset no_elem X \\<subseteq># filter_mset no_elem N;\n        \\<forall>k\\<in>Collect no_elem.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a\\<in>Collect no_elem.\n               a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa Ya.\n                            Xa \\<noteq> {#} \\<and>\n                            Xa \\<subseteq># N \\<and>\n                            N - X + Y = N - Xa + Ya \\<and>\n                            (\\<forall>k.\n                                k \\<in># Ya \\<longrightarrow>\n                                (\\<exists>a. a \\<in># Xa \\<and> k < a))", "then"], ["proof (chain)\npicking this:\n  pred_mset no_elem (N - X + Y)\n  pred_mset no_elem N\n  pred_mset no_elem X\n  pred_mset no_elem Y\n  X \\<noteq> {#}\n  filter_mset no_elem X \\<subseteq># filter_mset no_elem N\n  \\<forall>k\\<in>Collect no_elem.\n     k \\<in># Y \\<longrightarrow>\n     (\\<exists>a\\<in>Collect no_elem. a \\<in># X \\<and> k < a)", "have [simp]: \"filter_mset no_elem X = X\" \"filter_mset no_elem N = N\""], ["proof (prove)\nusing this:\n  pred_mset no_elem (N - X + Y)\n  pred_mset no_elem N\n  pred_mset no_elem X\n  pred_mset no_elem Y\n  X \\<noteq> {#}\n  filter_mset no_elem X \\<subseteq># filter_mset no_elem N\n  \\<forall>k\\<in>Collect no_elem.\n     k \\<in># Y \\<longrightarrow>\n     (\\<exists>a\\<in>Collect no_elem. a \\<in># X \\<and> k < a)\n\ngoal (1 subgoal):\n 1. filter_mset no_elem X = X &&& filter_mset no_elem N = N", "unfolding filter_mset_eq_conv"], ["proof (prove)\nusing this:\n  pred_mset no_elem (N - X + Y)\n  pred_mset no_elem N\n  pred_mset no_elem X\n  pred_mset no_elem Y\n  X \\<noteq> {#}\n  filter_mset no_elem X \\<subseteq># filter_mset no_elem N\n  \\<forall>k\\<in>Collect no_elem.\n     k \\<in># Y \\<longrightarrow>\n     (\\<exists>a\\<in>Collect no_elem. a \\<in># X \\<and> k < a)\n\ngoal (1 subgoal):\n 1. X \\<subseteq># X \\<and>\n    Multiset.Ball X no_elem \\<and>\n    (\\<forall>a\\<in>#X - X. \\<not> no_elem a) &&&\n    N \\<subseteq># N \\<and>\n    Multiset.Ball N no_elem \\<and> (\\<forall>a\\<in>#N - N. \\<not> no_elem a)", "by (auto simp: multiset.pred_set)"], ["proof (state)\nthis:\n  filter_mset no_elem X = X\n  filter_mset no_elem N = N\n\ngoal (1 subgoal):\n 1. \\<And>M N X Y.\n       \\<lbrakk>pred_mset no_elem (N - X + Y); pred_mset no_elem N;\n        pred_mset no_elem X; pred_mset no_elem Y; X \\<noteq> {#};\n        filter_mset no_elem X \\<subseteq># filter_mset no_elem N;\n        \\<forall>k\\<in>Collect no_elem.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a\\<in>Collect no_elem.\n               a \\<in># X \\<and> k < a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Xa Ya.\n                            Xa \\<noteq> {#} \\<and>\n                            Xa \\<subseteq># N \\<and>\n                            N - X + Y = N - Xa + Ya \\<and>\n                            (\\<forall>k.\n                                k \\<in># Ya \\<longrightarrow>\n                                (\\<exists>a. a \\<in># Xa \\<and> k < a))", "show\n    \"\\<exists>X' Y'. X' \\<noteq> {#} \\<and> X' \\<subseteq># N \\<and>  N - X + Y = N - X' + Y' \\<and>\n     (\\<forall>k. k \\<in># Y' \\<longrightarrow> (\\<exists>a. a \\<in># X' \\<and> k < a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X' Y'.\n       X' \\<noteq> {#} \\<and>\n       X' \\<subseteq># N \\<and>\n       N - X + Y = N - X' + Y' \\<and>\n       (\\<forall>k.\n           k \\<in># Y' \\<longrightarrow>\n           (\\<exists>a. a \\<in># X' \\<and> k < a))", "by (rule exI[of _ X], rule exI[of _ Y]) (insert *; auto simp: multiset.pred_set)"], ["proof (state)\nthis:\n  \\<exists>X' Y'.\n     X' \\<noteq> {#} \\<and>\n     X' \\<subseteq># N \\<and>\n     N - X + Y = N - X' + Y' \\<and>\n     (\\<forall>k.\n         k \\<in># Y' \\<longrightarrow>\n         (\\<exists>a. a \\<in># X' \\<and> k < a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hmsetmset_less[simp]: \"hmsetmset M < hmsetmset N \\<longleftrightarrow> M < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hmsetmset M < hmsetmset N) = (M < N)", "by (cases M, cases N, simp add: less_multiset_ext\\<^sub>D\\<^sub>M_less less_HMSet_iff_less_multiset_ext\\<^sub>D\\<^sub>M)"], ["", "lemma hmsetmset_le[simp]: \"hmsetmset M \\<le> hmsetmset N \\<longleftrightarrow> M \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hmsetmset M \\<le> hmsetmset N) = (M \\<le> N)", "unfolding le_less hmsetmset_less"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M < N \\<or> hmsetmset M = hmsetmset N) = (M < N \\<or> M = N)", "by (metis hmultiset.collapse)"], ["", "lemma wf_less_hmultiset: \"wf {(X :: hmultiset, Y :: hmultiset). X < Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(X, Y). X < Y}", "unfolding wf_eq_minimal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Q x.\n       x \\<in> Q \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y.\n              (y, z) \\<in> {(x, y). x < y} \\<longrightarrow> y \\<notin> Q)", "by transfer (insert wf_less_nmultiset[unfolded wf_eq_minimal], fast)"], ["", "instance hmultiset :: wellorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, wellorder_class)", "using wf_less_hmultiset"], ["proof (prove)\nusing this:\n  wf {(X, Y). X < Y}\n\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, wellorder_class)", "unfolding wf_def mem_Collect_eq prod.case"], ["proof (prove)\nusing this:\n  \\<forall>P.\n     (\\<forall>x.\n         (\\<forall>y<x. P y) \\<longrightarrow> P x) \\<longrightarrow>\n     All P\n\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, wellorder_class)", "by intro_classes metis"], ["", "lemma HMSet_less[simp]: \"HMSet M < HMSet N \\<longleftrightarrow> M < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMSet M < HMSet N) = (M < N)", "by (simp add: less_HMSet_iff_less_multiset_ext\\<^sub>D\\<^sub>M less_multiset_ext\\<^sub>D\\<^sub>M_less)"], ["", "lemma HMSet_le[simp]: \"HMSet M \\<le> HMSet N \\<longleftrightarrow> M \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMSet M \\<le> HMSet N) = (M \\<le> N)", "by (simp add: hmsetmset_le[symmetric])"], ["", "lemma mem_imp_less_HMSet: \"k \\<in># L \\<Longrightarrow> k < HMSet L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in># L \\<Longrightarrow> k < HMSet L", "by (induct k arbitrary: L) (auto intro: ex_gt_imp_less_multiset)"], ["", "lemma mem_hmsetmset_imp_less: \"M \\<in># hmsetmset N \\<Longrightarrow> M < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in># hmsetmset N \\<Longrightarrow> M < N", "using mem_imp_less_HMSet"], ["proof (prove)\nusing this:\n  ?k \\<in># ?L \\<Longrightarrow> ?k < HMSet ?L\n\ngoal (1 subgoal):\n 1. M \\<in># hmsetmset N \\<Longrightarrow> M < N", "by force"], ["", "subsection \\<open>Disjoint Union and Truncated Difference\\<close>"], ["", "instantiation hmultiset :: cancel_comm_monoid_add\nbegin"], ["", "definition zero_hmultiset :: hmultiset where\n  \"0 = HMSet {#}\""], ["", "lemma hmsetmset_empty_iff[simp]: \"hmsetmset n = {#} \\<longleftrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hmsetmset n = {#}) = (n = 0)", "unfolding zero_hmultiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hmsetmset n = {#}) = (n = HMSet {#})", "by (cases n) simp"], ["", "lemma hmsetmset_0[simp]: \"hmsetmset 0 = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset 0 = {#}", "by simp"], ["", "lemma\n  HMSet_eq_0_iff[simp]: \"HMSet m = 0 \\<longleftrightarrow> m = {#}\" and\n  zero_eq_HMSet[simp]: \"0 = HMSet m \\<longleftrightarrow> m = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMSet m = 0) = (m = {#}) &&& (0 = HMSet m) = (m = {#})", "by (cases m) (auto simp: zero_hmultiset_def)"], ["", "definition plus_hmultiset :: \"hmultiset \\<Rightarrow> hmultiset \\<Rightarrow> hmultiset\" where\n  \"A + B = HMSet (hmsetmset A + hmsetmset B)\""], ["", "definition minus_hmultiset :: \"hmultiset \\<Rightarrow> hmultiset \\<Rightarrow> hmultiset\" where\n  \"A - B = HMSet (hmsetmset A - hmsetmset B)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, cancel_comm_monoid_add_class)", "by intro_classes (auto simp: zero_hmultiset_def plus_hmultiset_def minus_hmultiset_def)"], ["", "end"], ["", "lemma HMSet_plus: \"HMSet (A + B) = HMSet A + HMSet B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMSet (A + B) = HMSet A + HMSet B", "by (simp add: plus_hmultiset_def)"], ["", "lemma HMSet_diff: \"HMSet (A - B) = HMSet A - HMSet B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMSet (A - B) = HMSet A - HMSet B", "by (simp add: minus_hmultiset_def)"], ["", "lemma hmsetmset_plus: \"hmsetmset (M + N) = hmsetmset M + hmsetmset N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset (M + N) = hmsetmset M + hmsetmset N", "by (simp add: plus_hmultiset_def)"], ["", "lemma hmsetmset_diff: \"hmsetmset (M - N) = hmsetmset M - hmsetmset N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset (M - N) = hmsetmset M - hmsetmset N", "by (simp add: minus_hmultiset_def)"], ["", "lemma diff_diff_add_hmset[simp]: \"a - b - c = a - (b + c)\" for a b c :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. a - b - c = a - (b + c)", "by (fact diff_diff_add)"], ["", "instance hmultiset :: comm_monoid_diff"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, comm_monoid_diff_class)", "by intro_classes (auto simp: zero_hmultiset_def minus_hmultiset_def)"], ["", "simproc_setup hmseteq_cancel\n  (\"(l::hmultiset) + m = n\" | \"(l::hmultiset) = m + n\") =\n  \\<open>fn phi => Cancel_Simprocs.eq_cancel\\<close>"], ["", "simproc_setup hmsetdiff_cancel\n  (\"((l::hmultiset) + m) - n\" | \"(l::hmultiset) - (m + n)\") =\n  \\<open>fn phi => Cancel_Simprocs.diff_cancel\\<close>"], ["", "simproc_setup hmsetless_cancel\n  (\"(l::hmultiset) + m < n\" | \"(l::hmultiset) < m + n\") =\n  \\<open>fn phi => Cancel_Simprocs.less_cancel\\<close>"], ["", "simproc_setup hmsetless_eq_cancel\n  (\"(l::hmultiset) + m \\<le> n\" | \"(l::hmultiset) \\<le> m + n\") =\n  \\<open>fn phi => Cancel_Simprocs.less_eq_cancel\\<close>"], ["", "instance hmultiset :: ordered_cancel_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, ordered_cancel_comm_monoid_add_class)", "by intro_classes (simp del: hmsetmset_less add: plus_hmultiset_def order_le_less\n    hmsetmset_less[symmetric] less_multiset_ext\\<^sub>D\\<^sub>M_less)"], ["", "instance hmultiset :: ordered_ab_semigroup_add_imp_le"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, ordered_ab_semigroup_add_imp_le_class)", "by intro_classes (simp add: plus_hmultiset_def order_le_less less_multiset_ext\\<^sub>D\\<^sub>M_less)"], ["", "instantiation hmultiset :: order_bot\nbegin"], ["", "definition bot_hmultiset :: hmultiset where\n  \"bot_hmultiset = 0\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, order_bot_class)", "proof (intro_classes, unfold bot_hmultiset_def zero_hmultiset_def, transfer, goal_cases bot_least)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. no_elem x \\<Longrightarrow> MSet {#} \\<le> x", "case (bot_least x)"], ["proof (state)\nthis:\n  no_elem x\n\ngoal (1 subgoal):\n 1. \\<And>x. no_elem x \\<Longrightarrow> MSet {#} \\<le> x", "thus ?case"], ["proof (prove)\nusing this:\n  no_elem x\n\ngoal (1 subgoal):\n 1. MSet {#} \\<le> x", "by (induct x rule: no_elem.induct) (auto simp: less_eq_nmultiset_def less_multiset_ext\\<^sub>D\\<^sub>M_less)"], ["proof (state)\nthis:\n  MSet {#} \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instance hmultiset :: no_top"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, no_top_class)", "proof (intro_classes, goal_cases gt_ex)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>y. x < y", "case (gt_ex a)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>y. x < y", "have \"a < a + HMSet {#0#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < a + HMSet {#0#}", "by (simp add: zero_hmultiset_def)"], ["proof (state)\nthis:\n  a < a + HMSet {#0#}\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>y. x < y", "thus ?case"], ["proof (prove)\nusing this:\n  a < a + HMSet {#0#}\n\ngoal (1 subgoal):\n 1. \\<exists>y. a < y", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>y. a < y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_minus_plus_same_hmset: \"m \\<le> m - n + n\" for m n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> m - n + n", "proof (cases m n rule: hmultiset.exhaust[case_product hmultiset.exhaust])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> m \\<le> m - n + n", "case (HMSet_HMSet m0 n0)"], ["proof (state)\nthis:\n  m = HMSet m0\n  n = HMSet n0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> m \\<le> m - n + n", "note m = this(1) and n = this(2)"], ["proof (state)\nthis:\n  m = HMSet m0\n  n = HMSet n0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> m \\<le> m - n + n", "{"], ["proof (state)\nthis:\n  m = HMSet m0\n  n = HMSet n0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> m \\<le> m - n + n", "assume \"n0 \\<subseteq># m0\""], ["proof (state)\nthis:\n  n0 \\<subseteq># m0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> m \\<le> m - n + n", "hence \"m0 = m0 - n0 + n0\""], ["proof (prove)\nusing this:\n  n0 \\<subseteq># m0\n\ngoal (1 subgoal):\n 1. m0 = m0 - n0 + n0", "by simp"], ["proof (state)\nthis:\n  m0 = m0 - n0 + n0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> m \\<le> m - n + n", "}"], ["proof (state)\nthis:\n  n0 \\<subseteq># m0 \\<Longrightarrow> m0 = m0 - n0 + n0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> m \\<le> m - n + n", "moreover"], ["proof (state)\nthis:\n  n0 \\<subseteq># m0 \\<Longrightarrow> m0 = m0 - n0 + n0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> m \\<le> m - n + n", "{"], ["proof (state)\nthis:\n  n0 \\<subseteq># m0 \\<Longrightarrow> m0 = m0 - n0 + n0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> m \\<le> m - n + n", "assume \"\\<not> n0 \\<subseteq># m0\""], ["proof (state)\nthis:\n  \\<not> n0 \\<subseteq># m0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> m \\<le> m - n + n", "hence \"m0 \\<subset># m0 - n0 + n0\""], ["proof (prove)\nusing this:\n  \\<not> n0 \\<subseteq># m0\n\ngoal (1 subgoal):\n 1. m0 \\<subset># m0 - n0 + n0", "by (metis mset_subset_eq_add_right subset_eq_diff_conv subset_mset.dual_order.refl\n        subset_mset_def)"], ["proof (state)\nthis:\n  m0 \\<subset># m0 - n0 + n0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> m \\<le> m - n + n", "hence \"m0 < m0 - n0 + n0\""], ["proof (prove)\nusing this:\n  m0 \\<subset># m0 - n0 + n0\n\ngoal (1 subgoal):\n 1. m0 < m0 - n0 + n0", "by (rule subset_imp_less_mset)"], ["proof (state)\nthis:\n  m0 < m0 - n0 + n0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> m \\<le> m - n + n", "}"], ["proof (state)\nthis:\n  \\<not> n0 \\<subseteq># m0 \\<Longrightarrow> m0 < m0 - n0 + n0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> m \\<le> m - n + n", "ultimately"], ["proof (chain)\npicking this:\n  n0 \\<subseteq># m0 \\<Longrightarrow> m0 = m0 - n0 + n0\n  \\<not> n0 \\<subseteq># m0 \\<Longrightarrow> m0 < m0 - n0 + n0", "show ?thesis"], ["proof (prove)\nusing this:\n  n0 \\<subseteq># m0 \\<Longrightarrow> m0 = m0 - n0 + n0\n  \\<not> n0 \\<subseteq># m0 \\<Longrightarrow> m0 < m0 - n0 + n0\n\ngoal (1 subgoal):\n 1. m \\<le> m - n + n", "by (simp (no_asm) add: m n order_le_less plus_hmultiset_def minus_hmultiset_def) blast"], ["proof (state)\nthis:\n  m \\<le> m - n + n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Infimum and Supremum\\<close>"], ["", "instantiation hmultiset :: distrib_lattice\nbegin"], ["", "definition inf_hmultiset :: \"hmultiset \\<Rightarrow> hmultiset \\<Rightarrow> hmultiset\" where\n  \"inf_hmultiset A B = (if A < B then A else B)\""], ["", "definition sup_hmultiset :: \"hmultiset \\<Rightarrow> hmultiset \\<Rightarrow> hmultiset\" where\n  \"sup_hmultiset A B = (if B > A then B else A)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, distrib_lattice_class)", "by intro_classes (auto simp: inf_hmultiset_def sup_hmultiset_def)"], ["", "end"], ["", "subsection \\<open>Inequalities\\<close>"], ["", "lemma zero_le_hmset[simp]: \"0 \\<le> M\" for M :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> M", "by (simp add: order_le_less) (metis hmsetmset_less le_multiset_empty_left hmsetmset_empty_iff)"], ["", "lemma\n  le_add1_hmset: \"n \\<le> n + m\" and\n  le_add2_hmset: \"n \\<le> m + n\" for n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> n + m &&& n \\<le> m + n", "by simp+"], ["", "lemma le_zero_eq_hmset[simp]: \"M \\<le> 0 \\<longleftrightarrow> M = 0\" for M :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M \\<le> 0) = (M = 0)", "by (simp add: dual_order.antisym)"], ["", "lemma not_less_zero_hmset[simp]: \"\\<not> M < 0\" for M :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> M < 0", "using not_le zero_le_hmset"], ["proof (prove)\nusing this:\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n  0 \\<le> ?M\n\ngoal (1 subgoal):\n 1. \\<not> M < 0", "by blast"], ["", "lemma not_gr_zero_hmset[simp]: \"\\<not> 0 < M \\<longleftrightarrow> M = 0\" for M :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> 0 < M) = (M = 0)", "using neqE not_less_zero_hmset"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<noteq> ?y; ?x < ?y \\<Longrightarrow> ?R;\n   ?y < ?x \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  \\<not> ?M < 0\n\ngoal (1 subgoal):\n 1. (\\<not> 0 < M) = (M = 0)", "by blast"], ["", "lemma zero_less_iff_neq_zero_hmset: \"0 < M \\<longleftrightarrow> M \\<noteq> 0\" for M :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < M) = (M \\<noteq> 0)", "using not_gr_zero_hmset"], ["proof (prove)\nusing this:\n  (\\<not> 0 < ?M) = (?M = 0)\n\ngoal (1 subgoal):\n 1. (0 < M) = (M \\<noteq> 0)", "by blast"], ["", "lemma zero_less_HMSet_iff[simp]: \"0 < HMSet M \\<longleftrightarrow> M \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < HMSet M) = (M \\<noteq> {#})", "by (simp only: zero_less_iff_neq_zero_hmset HMSet_eq_0_iff)"], ["", "lemma gr_zeroI_hmset: \"(M = 0 \\<Longrightarrow> False) \\<Longrightarrow> 0 < M\" for M :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M = 0 \\<Longrightarrow> False) \\<Longrightarrow> 0 < M", "using not_gr_zero_hmset"], ["proof (prove)\nusing this:\n  (\\<not> 0 < ?M) = (?M = 0)\n\ngoal (1 subgoal):\n 1. (M = 0 \\<Longrightarrow> False) \\<Longrightarrow> 0 < M", "by blast"], ["", "lemma gr_implies_not_zero_hmset: \"M < N \\<Longrightarrow> N \\<noteq> 0\" for M N :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. M < N \\<Longrightarrow> N \\<noteq> 0", "by auto"], ["", "lemma add_eq_0_iff_both_eq_0_hmset[simp]: \"M + N = 0 \\<longleftrightarrow> M = 0 \\<and> N = 0\" for M N :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M + N = 0) = (M = 0 \\<and> N = 0)", "by (intro add_nonneg_eq_0_iff zero_le_hmset)"], ["", "lemma trans_less_add1_hmset: \"i < j \\<Longrightarrow> i < j + m\" for i j m :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> i < j + m", "by (metis add_increasing2 leD le_less not_gr_zero_hmset)"], ["", "lemma trans_less_add2_hmset: \"i < j \\<Longrightarrow> i < m + j\" for i j m :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> i < m + j", "by (simp add: add.commute trans_less_add1_hmset)"], ["", "lemma trans_le_add1_hmset: \"i \\<le> j \\<Longrightarrow> i \\<le> j + m\" for i j m :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> i \\<le> j + m", "by (simp add: add_increasing2)"], ["", "lemma trans_le_add2_hmset: \"i \\<le> j \\<Longrightarrow> i \\<le> m + j\" for i j m :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> i \\<le> m + j", "by (simp add: add_increasing)"], ["", "lemma diff_le_self_hmset: \"m - n \\<le> m\" for m n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. m - n \\<le> m", "by (metis add.commute add.right_neutral diff_add_zero diff_diff_add_hmset\n    le_minus_plus_same_hmset)"], ["", "end"]]}