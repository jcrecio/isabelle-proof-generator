{"file_name": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals/Signed_Multiset.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals", "problem_names": ["lemma zcount_inject: \"zcount M = zcount N \\<longleftrightarrow> M = N\"", "lemma zmultiset_eq_iff: \"M = N \\<longleftrightarrow> (\\<forall>a. zcount M a = zcount N a)\"", "lemma zmultiset_eqI: \"(\\<And>x. zcount A x = zcount B x) \\<Longrightarrow> A = B\"", "lemma zcount_uminus[simp]: \"zcount (- A) x = - zcount A x\"", "lemma zcount_empty[simp]: \"zcount {#}\\<^sub>z a = 0\"", "lemma zcount_add_zmset[simp]:\n  \"zcount (add_zmset b A) a = (if b = a then zcount A a + 1 else zcount A a)\"", "lemma zcount_single: \"zcount {#b#}\\<^sub>z a = (if b = a then 1 else 0)\"", "lemma add_add_same_iff_zmset[simp]: \"add_zmset a A = add_zmset a B \\<longleftrightarrow> A = B\"", "lemma add_zmset_commute: \"add_zmset x (add_zmset y M) = add_zmset y (add_zmset x M)\"", "lemma\n  singleton_ne_empty_zmset[simp]: \"{#x#}\\<^sub>z \\<noteq> {#}\\<^sub>z\" and\n  empty_ne_singleton_zmset[simp]: \"{#}\\<^sub>z \\<noteq> {#x#}\\<^sub>z\"", "lemma\n  singleton_ne_uminus_singleton_zmset[simp]: \"{#x#}\\<^sub>z \\<noteq> - {#y#}\\<^sub>z\" and\n  uminus_singleton_ne_singleton_zmset[simp]: \"- {#x#}\\<^sub>z \\<noteq> {#y#}\\<^sub>z\"", "lemma zcount_eq_zero_iff: \"zcount M x = 0 \\<longleftrightarrow> x \\<notin>#\\<^sub>z M\"", "lemma not_in_iff_zmset: \"x \\<notin>#\\<^sub>z M \\<longleftrightarrow> zcount M x = 0\"", "lemma zcount_ne_zero_iff[simp]: \"zcount M x \\<noteq> 0 \\<longleftrightarrow> x \\<in>#\\<^sub>z M\"", "lemma zcount_inI:\n  assumes \"zcount M x = 0 \\<Longrightarrow> False\"\n  shows \"x \\<in>#\\<^sub>z M\"", "lemma set_zmset_empty[simp]: \"set_zmset {#}\\<^sub>z = {}\"", "lemma set_zmset_single: \"set_zmset {#b#}\\<^sub>z = {b}\"", "lemma set_zmset_eq_empty_iff[simp]: \"set_zmset M = {} \\<longleftrightarrow> M = {#}\\<^sub>z\"", "lemma finite_count_ne: \"finite {x. count M x \\<noteq> count N x}\"", "lemma finite_set_zmset[iff]: \"finite (set_zmset M)\"", "lemma zmultiset_nonemptyE[elim]:\n  assumes \"A \\<noteq> {#}\\<^sub>z\"\n  obtains x where \"x \\<in>#\\<^sub>z A\"", "lemma zcount_union[simp]: \"zcount (M + N) a = zcount M a + zcount N a\"", "lemma union_add_left_zmset[simp]: \"add_zmset a A + B = add_zmset a (A + B)\"", "lemma union_zmset_add_zmset_right[simp]: \"A + add_zmset a B = add_zmset a (A + B)\"", "lemma add_zmset_add_single: \\<open>add_zmset a A = A + {#a#}\\<^sub>z\\<close>", "lemma zcount_diff[simp]: \"zcount (M - N) a = zcount M a - zcount N a\"", "lemma add_zmset_diff_bothsides: \\<open>add_zmset a M - add_zmset a A = M - A\\<close>", "lemma in_diff_zcount: \"a \\<in>#\\<^sub>z M - N \\<longleftrightarrow> zcount N a \\<noteq> zcount M a\"", "lemma diff_add_zmset:\n  fixes M N Q :: \"'a zmultiset\"\n  shows \"M - (N + Q) = M - N - Q\"", "lemma insert_Diff_zmset[simp]: \"add_zmset x (M - {#x#}\\<^sub>z) = M\"", "lemma diff_union_swap_zmset: \"add_zmset b (M - {#a#}\\<^sub>z) = add_zmset b M - {#a#}\\<^sub>z\"", "lemma diff_add_zmset_swap[simp]: \"add_zmset b M - A = add_zmset b (M - A)\"", "lemma diff_diff_add_zmset[simp]: \"(M :: 'a zmultiset) - N - P = M - (N + P)\"", "lemma zmset_add[elim?]:\n  obtains B where \"A = add_zmset a B\"", "lemma single_eq_single_zmset[simp]: \"{#a#}\\<^sub>z = {#b#}\\<^sub>z \\<longleftrightarrow> a = b\"", "lemma multi_self_add_other_not_self_zmset[simp]: \"M = add_zmset x M \\<longleftrightarrow> False\"", "lemma add_zmset_remove_trivial: \\<open>add_zmset x M - {#x#}\\<^sub>z = M\\<close>", "lemma diff_single_eq_union_zmset: \"M - {#x#}\\<^sub>z = N \\<longleftrightarrow> M = add_zmset x N\"", "lemma union_single_eq_diff_zmset: \"add_zmset x M = N \\<Longrightarrow> M = N - {#x#}\\<^sub>z\"", "lemma add_zmset_eq_conv_diff:\n  \"add_zmset a M = add_zmset b N \\<longleftrightarrow>\n   M = N \\<and> a = b \\<or> M = add_zmset b (N - {#a#}\\<^sub>z) \\<and> N = add_zmset a (M - {#b#}\\<^sub>z)\"", "lemma add_zmset_eq_conv_ex:\n  \"(add_zmset a M = add_zmset b N) =\n    (M = N \\<and> a = b \\<or> (\\<exists>K. M = add_zmset b K \\<and> N = add_zmset a K))\"", "lemma multi_member_split: \"\\<exists>A. M = add_zmset x A\"", "lemma zmset_of_inject[simp]: \"zmset_of M = zmset_of N \\<longleftrightarrow> M = N\"", "lemma zmset_of_empty[simp]: \"zmset_of {#} = {#}\\<^sub>z\"", "lemma zmset_of_add_mset[simp]: \"zmset_of (add_mset x M) = add_zmset x (zmset_of M)\"", "lemma zcount_of_mset[simp]: \"zcount (zmset_of M) x = int (count M x)\"", "lemma zmset_of_plus: \"zmset_of (M + N) = zmset_of M + zmset_of N\"", "lemma\n  zmset_of_inverse[simp]: \"mset_pos (zmset_of M) = M\" and\n  minus_zmset_of_inverse[simp]: \"mset_neg (- zmset_of M) = M\"", "lemma neg_zmset_pos[simp]: \"mset_neg (zmset_of M) = {#}\"", "lemma\n  count_mset_pos[simp]: \"count (mset_pos M) x = nat (zcount M x)\" and\n  count_mset_neg[simp]: \"count (mset_neg M) x = nat (- zcount M x)\"", "lemma\n  mset_pos_empty[simp]: \"mset_pos {#}\\<^sub>z = {#}\" and\n  mset_neg_empty[simp]: \"mset_neg {#}\\<^sub>z = {#}\"", "lemma\n  mset_pos_singleton[simp]: \"mset_pos {#x#}\\<^sub>z = {#x#}\" and\n  mset_neg_singleton[simp]: \"mset_neg {#x#}\\<^sub>z = {#}\"", "lemma\n  mset_pos_neg_partition: \"M = zmset_of (mset_pos M) - zmset_of (mset_neg M)\" and\n  mset_pos_as_neg: \"zmset_of (mset_pos M) = zmset_of (mset_neg M) + M\" and\n  mset_neg_as_pos: \"zmset_of (mset_neg M) = zmset_of (mset_pos M) - M\"", "lemma mset_pos_uminus[simp]: \"mset_pos (- A) = mset_neg A\"", "lemma mset_neg_uminus[simp]: \"mset_neg (- A) = mset_pos A\"", "lemma mset_pos_plus[simp]:\n  \"mset_pos (A + B) = (mset_pos A - mset_neg B) + (mset_pos B - mset_neg A)\"", "lemma mset_neg_plus[simp]:\n  \"mset_neg (A + B) = (mset_neg A - mset_pos B) + (mset_neg B - mset_pos A)\"", "lemma mset_pos_diff[simp]:\n  \"mset_pos (A - B) = (mset_pos A - mset_pos B) + (mset_neg B - mset_neg A)\"", "lemma mset_neg_diff[simp]:\n  \"mset_neg (A - B) = (mset_neg A - mset_neg B) + (mset_pos B - mset_pos A)\"", "lemma mset_pos_neg_dual:\n  \"mset_pos a + mset_pos b + (mset_neg a - mset_pos b) + (mset_neg b - mset_pos a) =\n   mset_neg a + mset_neg b + (mset_pos a - mset_neg b) + (mset_pos b - mset_neg a)\"", "lemma decompose_zmset_of2:\n  obtains A B C where\n    \"M = zmset_of A + C\" and\n    \"N = zmset_of B + C\"", "lemma zmset_subset_eqI: \"(\\<And>a. zcount A a \\<le> zcount B a) \\<Longrightarrow> A \\<subseteq>#\\<^sub>z B\"", "lemma zmset_subset_eq_zcount: \"A \\<subseteq>#\\<^sub>z B \\<Longrightarrow> zcount A a \\<le> zcount B a\"", "lemma zmset_subset_eq_add_zmset_cancel: \\<open>add_zmset a A \\<subseteq>#\\<^sub>z add_zmset a B \\<longleftrightarrow> A \\<subseteq>#\\<^sub>z B\\<close>", "lemma zmset_subset_eq_zmultiset_union_diff_commute:\n  \"A - B + C = A + C - B\" for A B C :: \"'a zmultiset\"", "lemma zmset_subset_eq_insertD: \"add_zmset x A \\<subseteq>#\\<^sub>z B \\<Longrightarrow> A \\<subset>#\\<^sub>z B\"", "lemma zmset_subset_insertD: \"add_zmset x A \\<subset>#\\<^sub>z B \\<Longrightarrow> A \\<subset>#\\<^sub>z B\"", "lemma subset_eq_diff_conv_zmset: \"A - C \\<subseteq>#\\<^sub>z B \\<longleftrightarrow> A \\<subseteq>#\\<^sub>z B + C\"", "lemma multi_psub_of_add_self_zmset[simp]: \"A \\<subset>#\\<^sub>z add_zmset x A\"", "lemma multi_psub_self_zmset: \"A \\<subset>#\\<^sub>z A = False\"", "lemma zmset_subset_add_zmset[simp]: \"add_zmset x N \\<subset>#\\<^sub>z add_zmset x M \\<longleftrightarrow> N \\<subset>#\\<^sub>z M\"", "lemma zmset_of_subseteq_iff[simp]: \"zmset_of M \\<subseteq>#\\<^sub>z zmset_of N \\<longleftrightarrow> M \\<subseteq># N\"", "lemma zmset_of_subset_iff[simp]: \"zmset_of M \\<subset>#\\<^sub>z zmset_of N \\<longleftrightarrow> M \\<subset># N\"", "lemma\n  mset_pos_supset: \"A \\<subseteq>#\\<^sub>z zmset_of (mset_pos A)\" and\n  mset_neg_supset: \"- A \\<subseteq>#\\<^sub>z zmset_of (mset_neg A)\"", "lemma subset_mset_zmsetE:\n  assumes \"M \\<subset>#\\<^sub>z N\"\n  obtains A B C where\n    \"M = zmset_of A + C\" and \"N = zmset_of B + C\" and \"A \\<subset># B\"", "lemma subseteq_mset_zmsetE:\n  assumes \"M \\<subseteq>#\\<^sub>z N\"\n  obtains A B C where\n    \"M = zmset_of A + C\" and \"N = zmset_of B + C\" and \"A \\<subseteq># B\"", "lemma replicate_zmset_0[simp]: \"replicate_zmset 0 x = {#}\\<^sub>z\"", "lemma replicate_zmset_Suc[simp]: \"replicate_zmset (Suc n) x = add_zmset x (replicate_zmset n x)\"", "lemma count_replicate_zmset[simp]:\n  \"zcount (replicate_zmset n x) y = (if y = x then of_nat n else 0)\"", "lemma count_repeat_zmset[simp]: \"zcount (repeat_zmset i A) a = of_nat i * zcount A a\"", "lemma repeat_zmset_right[simp]: \"repeat_zmset a (repeat_zmset b A) = repeat_zmset (a * b) A\"", "lemma left_diff_repeat_zmset_distrib':\n  \\<open>i \\<ge> j \\<Longrightarrow> repeat_zmset (i - j) u = repeat_zmset i u - repeat_zmset j u\\<close>", "lemma left_add_mult_distrib_zmset:\n  \"repeat_zmset i u + (repeat_zmset j u + k) = repeat_zmset (i+j) u + k\"", "lemma repeat_zmset_distrib: \"repeat_zmset (m + n) A = repeat_zmset m A + repeat_zmset n A\"", "lemma repeat_zmset_distrib2[simp]:\n  \"repeat_zmset n (A + B) = repeat_zmset n A + repeat_zmset n B\"", "lemma repeat_zmset_replicate_zmset[simp]: \"repeat_zmset n {#a#}\\<^sub>z = replicate_zmset n a\"", "lemma repeat_zmset_distrib_add_zmset[simp]:\n  \"repeat_zmset n (add_zmset a A) = replicate_zmset n a + repeat_zmset n A\"", "lemma repeat_zmset_empty[simp]: \"repeat_zmset n {#}\\<^sub>z = {#}\\<^sub>z\"", "lemma count_filter_zmset[simp]:\n  \"zcount (filter_zmset P M) a = (if P a then zcount M a else 0)\"", "lemma filter_empty_zmset[simp]: \"filter_zmset P {#}\\<^sub>z = {#}\\<^sub>z\"", "lemma filter_single_zmset: \"filter_zmset P {#x#}\\<^sub>z = (if P x then {#x#}\\<^sub>z else {#}\\<^sub>z)\"", "lemma filter_union_zmset[simp]: \"filter_zmset P (M + N) = filter_zmset P M + filter_zmset P N\"", "lemma filter_diff_zmset[simp]: \"filter_zmset P (M - N) = filter_zmset P M - filter_zmset P N\"", "lemma filter_add_zmset[simp]:\n  \"filter_zmset P (add_zmset x A) =\n   (if P x then add_zmset x (filter_zmset P A) else filter_zmset P A)\"", "lemma zmultiset_filter_mono:\n  assumes \"A \\<subseteq>#\\<^sub>z B\"\n  shows \"filter_zmset f A \\<subseteq>#\\<^sub>z filter_zmset f B\"", "lemma filter_filter_zmset: \"filter_zmset P (filter_zmset Q M) = {#x \\<in>#\\<^sub>z M. Q x \\<and> P x#}\"", "lemma\n  filter_zmset_True[simp]: \"{#y \\<in>#\\<^sub>z M. True#} = M\" and\n  filter_zmset_False[simp]: \"{#y \\<in>#\\<^sub>z M. False#} = {#}\\<^sub>z\"", "lemma multi_drop_mem_not_eq_zmset: \"B - {#c#}\\<^sub>z \\<noteq> B\"", "lemma zmultiset_partition: \"M = {#x \\<in>#\\<^sub>z M. P x #} + {#x \\<in>#\\<^sub>z M. \\<not> P x#}\"", "lemma not_lt_iff_ge_zmset: \"\\<not> x < y \\<longleftrightarrow> x \\<ge> y\" for x y :: \"'a zmultiset\"", "lemma zmset_of_less: \"zmset_of M < zmset_of N \\<longleftrightarrow> M < N\"", "lemma zmset_of_le: \"zmset_of M \\<le> zmset_of N \\<longleftrightarrow> M \\<le> N\"", "lemma uminus_add_conv_diff_mset[cancelation_simproc_pre]: \\<open>-a + b = b - a\\<close> for a :: \\<open>'a zmultiset\\<close>", "lemma uminus_add_add_uminus[cancelation_simproc_pre]: \\<open>b -a + c = b + c - a\\<close> for a :: \\<open>'a zmultiset\\<close>", "lemma add_zmset_eq_add_NO_MATCH[cancelation_simproc_pre]:\n  \\<open>NO_MATCH {#}\\<^sub>z H \\<Longrightarrow> add_zmset a H = {#a#}\\<^sub>z + H\\<close>", "lemma repeat_zmset_iterate_add: \\<open>repeat_zmset n M = iterate_add n M\\<close>", "lemma zmset_subseteq_add_iff1:\n  \\<open>j \\<le> i \\<Longrightarrow> (repeat_zmset i u + m \\<subseteq>#\\<^sub>z repeat_zmset j u + n) = (repeat_zmset (i - j) u + m \\<subseteq>#\\<^sub>z n)\\<close>", "lemma zmset_subseteq_add_iff2:\n  \\<open>i \\<le> j \\<Longrightarrow> (repeat_zmset i u + m \\<subseteq>#\\<^sub>z repeat_zmset j u + n) = (m \\<subseteq>#\\<^sub>z repeat_zmset (j - i) u + n)\\<close>", "lemma zmset_subset_add_iff1:\n  \\<open>j \\<le> i \\<Longrightarrow> (repeat_zmset i u + m \\<subset>#\\<^sub>z repeat_zmset j u + n) = (repeat_zmset (i - j) u + m \\<subset>#\\<^sub>z n)\\<close>", "lemma zmset_subset_add_iff2:\n  \\<open>i \\<le> j \\<Longrightarrow> (repeat_zmset i u + m \\<subset>#\\<^sub>z repeat_zmset j u + n) = (m \\<subset>#\\<^sub>z repeat_zmset (j - i) u + n)\\<close>", "lemma less_mset_zmsetE:\n  assumes \"M < N\"\n  obtains A B C where\n    \"M = zmset_of A + C\" and \"N = zmset_of B + C\" and \"A < B\"", "lemma less_eq_mset_zmsetE:\n  assumes \"M \\<le> N\"\n  obtains A B C where\n    \"M = zmset_of A + C\" and \"N = zmset_of B + C\" and \"A \\<le> B\"", "lemma subset_eq_imp_le_zmset: \"M \\<subseteq>#\\<^sub>z N \\<Longrightarrow> M \\<le> N\"", "lemma subset_imp_less_zmset: \"M \\<subset>#\\<^sub>z N \\<Longrightarrow> M < N\"", "lemma lt_imp_ex_zcount_lt:\n  assumes m_lt_n: \"M < N\"\n  shows \"\\<exists>y. zcount M y < zcount N y\""], "translations": [["", "lemma zcount_inject: \"zcount M = zcount N \\<longleftrightarrow> M = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zcount M = zcount N) = (M = N)", "by transfer (auto simp del: of_nat_add simp: equiv_zmset_def fun_eq_iff multiset_eq_iff\n    diff_eq_eq diff_add_eq eq_diff_eq of_nat_add[symmetric])"], ["", "lemma zmultiset_eq_iff: \"M = N \\<longleftrightarrow> (\\<forall>a. zcount M a = zcount N a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M = N) = (\\<forall>a. zcount M a = zcount N a)", "by (simp only: zcount_inject[symmetric] fun_eq_iff)"], ["", "lemma zmultiset_eqI: \"(\\<And>x. zcount A x = zcount B x) \\<Longrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. zcount A x = zcount B x) \\<Longrightarrow> A = B", "using zmultiset_eq_iff"], ["proof (prove)\nusing this:\n  (?M = ?N) = (\\<forall>a. zcount ?M a = zcount ?N a)\n\ngoal (1 subgoal):\n 1. (\\<And>x. zcount A x = zcount B x) \\<Longrightarrow> A = B", "by auto"], ["", "lemma zcount_uminus[simp]: \"zcount (- A) x = - zcount A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (- A) x = - zcount A x", "by transfer auto"], ["", "lift_definition add_zmset :: \"'a \\<Rightarrow> 'a zmultiset \\<Rightarrow> 'a zmultiset\" is\n  \"\\<lambda>x (Mp, Mn). (add_mset x Mp, Mn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a prod1 prod2.\n       equiv_zmset prod1 prod2 \\<Longrightarrow>\n       equiv_zmset (case prod1 of (Mp, x) \\<Rightarrow> (add_mset a Mp, x))\n        (case prod2 of (Mp, x) \\<Rightarrow> (add_mset a Mp, x))", "by (auto simp: equiv_zmset_def)"], ["", "syntax\n  \"_zmultiset\" :: \"args \\<Rightarrow> 'a zmultiset\" (\"{#(_)#}\\<^sub>z\")"], ["", "translations\n  \"{#x, xs#}\\<^sub>z\" == \"CONST add_zmset x {#xs#}\\<^sub>z\"\n  \"{#x#}\\<^sub>z\" == \"CONST add_zmset x {#}\\<^sub>z\""], ["", "lemma zcount_empty[simp]: \"zcount {#}\\<^sub>z a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount {#}\\<^sub>z a = 0", "by transfer auto"], ["", "lemma zcount_add_zmset[simp]:\n  \"zcount (add_zmset b A) a = (if b = a then zcount A a + 1 else zcount A a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (add_zmset b A) a =\n    (if b = a then zcount A a + 1 else zcount A a)", "by transfer auto"], ["", "lemma zcount_single: \"zcount {#b#}\\<^sub>z a = (if b = a then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount {#b#}\\<^sub>z a = (if b = a then 1 else 0)", "by simp"], ["", "lemma add_add_same_iff_zmset[simp]: \"add_zmset a A = add_zmset a B \\<longleftrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (add_zmset a A = add_zmset a B) = (A = B)", "by (auto simp: zmultiset_eq_iff)"], ["", "lemma add_zmset_commute: \"add_zmset x (add_zmset y M) = add_zmset y (add_zmset x M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_zmset x (add_zmset y M) = add_zmset y (add_zmset x M)", "by (auto simp: zmultiset_eq_iff)"], ["", "lemma\n  singleton_ne_empty_zmset[simp]: \"{#x#}\\<^sub>z \\<noteq> {#}\\<^sub>z\" and\n  empty_ne_singleton_zmset[simp]: \"{#}\\<^sub>z \\<noteq> {#x#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#x#}\\<^sub>z \\<noteq> {#}\\<^sub>z &&&\n    {#}\\<^sub>z \\<noteq> {#x#}\\<^sub>z", "by (auto dest!: arg_cong2[of _ _ x _ zcount])"], ["", "lemma\n  singleton_ne_uminus_singleton_zmset[simp]: \"{#x#}\\<^sub>z \\<noteq> - {#y#}\\<^sub>z\" and\n  uminus_singleton_ne_singleton_zmset[simp]: \"- {#x#}\\<^sub>z \\<noteq> {#y#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#x#}\\<^sub>z \\<noteq> - {#y#}\\<^sub>z &&&\n    - {#x#}\\<^sub>z \\<noteq> {#y#}\\<^sub>z", "by (auto dest!: arg_cong2[of _ _ x x zcount] split: if_splits)"], ["", "subsubsection \\<open>Conversion to Set and Membership\\<close>"], ["", "definition set_zmset :: \"'a zmultiset \\<Rightarrow> 'a set\" where\n  \"set_zmset M = {x. zcount M x \\<noteq> 0}\""], ["", "abbreviation elem_zmset :: \"'a \\<Rightarrow> 'a zmultiset \\<Rightarrow> bool\" where\n  \"elem_zmset a M \\<equiv> a \\<in> set_zmset M\""], ["", "notation\n  elem_zmset (\"'(\\<in>#\\<^sub>z')\") and\n  elem_zmset (\"(_/ \\<in>#\\<^sub>z _)\" [51, 51] 50)"], ["", "notation (ASCII)\n  elem_zmset (\"'(:#z')\") and\n  elem_zmset (\"(_/ :#z _)\" [51, 51] 50)"], ["", "abbreviation not_elem_zmset :: \"'a \\<Rightarrow> 'a zmultiset \\<Rightarrow> bool\" where\n  \"not_elem_zmset a M \\<equiv> a \\<notin> set_zmset M\""], ["", "notation\n  not_elem_zmset (\"'(\\<notin>#\\<^sub>z')\") and\n  not_elem_zmset (\"(_/ \\<notin>#\\<^sub>z _)\" [51, 51] 50)"], ["", "notation (ASCII)\n  not_elem_zmset (\"'(~:#z')\") and\n  not_elem_zmset (\"(_/ ~:#z _)\" [51, 51] 50)"], ["", "context\nbegin"], ["", "qualified"], ["", "abbreviation Ball :: \"'a zmultiset \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"Ball M \\<equiv> Set.Ball (set_zmset M)\""], ["", "qualified"], ["", "abbreviation Bex :: \"'a zmultiset \\<Rightarrow> ('a \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"Bex M \\<equiv> Set.Bex (set_zmset M)\""], ["", "end"], ["", "syntax\n  \"_ZMBall\" :: \"pttrn \\<Rightarrow> 'a set \\<Rightarrow> bool \\<Rightarrow> bool\" (\"(3\\<forall>_\\<in>#\\<^sub>z_./ _)\" [0, 0, 10] 10)\n  \"_ZMBex\" :: \"pttrn \\<Rightarrow> 'a set \\<Rightarrow> bool \\<Rightarrow> bool\" (\"(3\\<exists>_\\<in>#\\<^sub>z_./ _)\" [0, 0, 10] 10)"], ["", "syntax (ASCII)\n  \"_ZMBall\" :: \"pttrn \\<Rightarrow> 'a set \\<Rightarrow> bool \\<Rightarrow> bool\" (\"(3\\<forall>_:#\\<^sub>z_./ _)\" [0, 0, 10] 10)\n  \"_ZMBex\" :: \"pttrn \\<Rightarrow> 'a set \\<Rightarrow> bool \\<Rightarrow> bool\" (\"(3\\<exists>_:#\\<^sub>z_./ _)\" [0, 0, 10] 10)"], ["", "translations\n  \"\\<forall>x\\<in>#\\<^sub>zA. P\" \\<rightleftharpoons> \"CONST Signed_Multiset.Ball A (\\<lambda>x. P)\"\n  \"\\<exists>x\\<in>#\\<^sub>zA. P\" \\<rightleftharpoons> \"CONST Signed_Multiset.Bex A (\\<lambda>x. P)\""], ["", "lemma zcount_eq_zero_iff: \"zcount M x = 0 \\<longleftrightarrow> x \\<notin>#\\<^sub>z M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zcount M x = 0) = (x \\<notin>#\\<^sub>z M)", "by (auto simp add: set_zmset_def)"], ["", "lemma not_in_iff_zmset: \"x \\<notin>#\\<^sub>z M \\<longleftrightarrow> zcount M x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<notin>#\\<^sub>z M) = (zcount M x = 0)", "by (auto simp add: zcount_eq_zero_iff)"], ["", "lemma zcount_ne_zero_iff[simp]: \"zcount M x \\<noteq> 0 \\<longleftrightarrow> x \\<in>#\\<^sub>z M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zcount M x \\<noteq> 0) = (x \\<in>#\\<^sub>z M)", "by (auto simp add: set_zmset_def)"], ["", "lemma zcount_inI:\n  assumes \"zcount M x = 0 \\<Longrightarrow> False\"\n  shows \"x \\<in>#\\<^sub>z M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in>#\\<^sub>z M", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin>#\\<^sub>z M \\<Longrightarrow> False", "assume \"x \\<notin>#\\<^sub>z M\""], ["proof (state)\nthis:\n  x \\<notin>#\\<^sub>z M\n\ngoal (1 subgoal):\n 1. x \\<notin>#\\<^sub>z M \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  zcount M x = 0 \\<Longrightarrow> False\n  x \\<notin>#\\<^sub>z M", "show False"], ["proof (prove)\nusing this:\n  zcount M x = 0 \\<Longrightarrow> False\n  x \\<notin>#\\<^sub>z M\n\ngoal (1 subgoal):\n 1. False", "by (simp add: not_in_iff_zmset)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_zmset_empty[simp]: \"set_zmset {#}\\<^sub>z = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_zmset {#}\\<^sub>z = {}", "by (simp add: set_zmset_def)"], ["", "lemma set_zmset_single: \"set_zmset {#b#}\\<^sub>z = {b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_zmset {#b#}\\<^sub>z = {b}", "by (simp add: set_zmset_def)"], ["", "lemma set_zmset_eq_empty_iff[simp]: \"set_zmset M = {} \\<longleftrightarrow> M = {#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_zmset M = {}) = (M = {#}\\<^sub>z)", "by (auto simp add: zmultiset_eq_iff zcount_eq_zero_iff)"], ["", "lemma finite_count_ne: \"finite {x. count M x \\<noteq> count N x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. count M x \\<noteq> count N x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {x. count M x \\<noteq> count N x}", "have \"{x. count M x \\<noteq> count N x} \\<subseteq> set_mset M \\<union> set_mset N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. count M x \\<noteq> count N x}\n    \\<subseteq> set_mset M \\<union> set_mset N", "by (auto simp: not_in_iff)"], ["proof (state)\nthis:\n  {x. count M x \\<noteq> count N x}\n  \\<subseteq> set_mset M \\<union> set_mset N\n\ngoal (1 subgoal):\n 1. finite {x. count M x \\<noteq> count N x}", "moreover"], ["proof (state)\nthis:\n  {x. count M x \\<noteq> count N x}\n  \\<subseteq> set_mset M \\<union> set_mset N\n\ngoal (1 subgoal):\n 1. finite {x. count M x \\<noteq> count N x}", "have \"finite (set_mset M \\<union> set_mset N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_mset M \\<union> set_mset N)", "by (rule finite_UnI[OF finite_set_mset finite_set_mset])"], ["proof (state)\nthis:\n  finite (set_mset M \\<union> set_mset N)\n\ngoal (1 subgoal):\n 1. finite {x. count M x \\<noteq> count N x}", "ultimately"], ["proof (chain)\npicking this:\n  {x. count M x \\<noteq> count N x}\n  \\<subseteq> set_mset M \\<union> set_mset N\n  finite (set_mset M \\<union> set_mset N)", "show ?thesis"], ["proof (prove)\nusing this:\n  {x. count M x \\<noteq> count N x}\n  \\<subseteq> set_mset M \\<union> set_mset N\n  finite (set_mset M \\<union> set_mset N)\n\ngoal (1 subgoal):\n 1. finite {x. count M x \\<noteq> count N x}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite {x. count M x \\<noteq> count N x}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_set_zmset[iff]: \"finite (set_zmset M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set_zmset M)", "unfolding set_zmset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. zcount M x \\<noteq> 0}", "by transfer (auto intro: finite_count_ne)"], ["", "lemma zmultiset_nonemptyE[elim]:\n  assumes \"A \\<noteq> {#}\\<^sub>z\"\n  obtains x where \"x \\<in>#\\<^sub>z A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in>#\\<^sub>z A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in>#\\<^sub>z A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>x. x \\<in>#\\<^sub>z A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in>#\\<^sub>z A", "by (rule ccontr) (insert assms, auto)"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in>#\\<^sub>z A\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in>#\\<^sub>z A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with that"], ["proof (chain)\npicking this:\n  ?x \\<in>#\\<^sub>z A \\<Longrightarrow> thesis\n  \\<exists>x. x \\<in>#\\<^sub>z A", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in>#\\<^sub>z A \\<Longrightarrow> thesis\n  \\<exists>x. x \\<in>#\\<^sub>z A\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Union\\<close>"], ["", "lemma zcount_union[simp]: \"zcount (M + N) a = zcount M a + zcount N a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (M + N) a = zcount M a + zcount N a", "by transfer auto"], ["", "lemma union_add_left_zmset[simp]: \"add_zmset a A + B = add_zmset a (A + B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_zmset a A + B = add_zmset a (A + B)", "by (auto simp: zmultiset_eq_iff)"], ["", "lemma union_zmset_add_zmset_right[simp]: \"A + add_zmset a B = add_zmset a (A + B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A + add_zmset a B = add_zmset a (A + B)", "by (auto simp: zmultiset_eq_iff)"], ["", "lemma add_zmset_add_single: \\<open>add_zmset a A = A + {#a#}\\<^sub>z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. add_zmset a A = A + {#a#}\\<^sub>z", "by (subst union_zmset_add_zmset_right, subst add.comm_neutral) (rule refl)"], ["", "subsubsection \\<open>Difference\\<close>"], ["", "lemma zcount_diff[simp]: \"zcount (M - N) a = zcount M a - zcount N a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (M - N) a = zcount M a - zcount N a", "by transfer auto"], ["", "lemma add_zmset_diff_bothsides: \\<open>add_zmset a M - add_zmset a A = M - A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. add_zmset a M - add_zmset a A = M - A", "by (auto simp: zmultiset_eq_iff)"], ["", "lemma in_diff_zcount: \"a \\<in>#\\<^sub>z M - N \\<longleftrightarrow> zcount N a \\<noteq> zcount M a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in>#\\<^sub>z M - N) = (zcount N a \\<noteq> zcount M a)", "by (fastforce simp: set_zmset_def)"], ["", "lemma diff_add_zmset:\n  fixes M N Q :: \"'a zmultiset\"\n  shows \"M - (N + Q) = M - N - Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M - (N + Q) = M - N - Q", "by (rule sym) (fact diff_diff_add)"], ["", "lemma insert_Diff_zmset[simp]: \"add_zmset x (M - {#x#}\\<^sub>z) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_zmset x (M - {#x#}\\<^sub>z) = M", "by (clarsimp simp: zmultiset_eq_iff)"], ["", "lemma diff_union_swap_zmset: \"add_zmset b (M - {#a#}\\<^sub>z) = add_zmset b M - {#a#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_zmset b (M - {#a#}\\<^sub>z) = add_zmset b M - {#a#}\\<^sub>z", "by (auto simp add: zmultiset_eq_iff)"], ["", "lemma diff_add_zmset_swap[simp]: \"add_zmset b M - A = add_zmset b (M - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_zmset b M - A = add_zmset b (M - A)", "by (auto simp add: zmultiset_eq_iff)"], ["", "lemma diff_diff_add_zmset[simp]: \"(M :: 'a zmultiset) - N - P = M - (N + P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M - N - P = M - (N + P)", "by (rule diff_diff_add)"], ["", "lemma zmset_add[elim?]:\n  obtains B where \"A = add_zmset a B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B. A = add_zmset a B \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>B. A = add_zmset a B \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"A = add_zmset a (A - {#a#}\\<^sub>z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = add_zmset a (A - {#a#}\\<^sub>z)", "by simp"], ["proof (state)\nthis:\n  A = add_zmset a (A - {#a#}\\<^sub>z)\n\ngoal (1 subgoal):\n 1. (\\<And>B. A = add_zmset a B \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with that"], ["proof (chain)\npicking this:\n  A = add_zmset a ?B \\<Longrightarrow> thesis\n  A = add_zmset a (A - {#a#}\\<^sub>z)", "show thesis"], ["proof (prove)\nusing this:\n  A = add_zmset a ?B \\<Longrightarrow> thesis\n  A = add_zmset a (A - {#a#}\\<^sub>z)\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Equality of Signed Multisets\\<close>"], ["", "lemma single_eq_single_zmset[simp]: \"{#a#}\\<^sub>z = {#b#}\\<^sub>z \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#a#}\\<^sub>z = {#b#}\\<^sub>z) = (a = b)", "by (auto simp add: zmultiset_eq_iff)"], ["", "lemma multi_self_add_other_not_self_zmset[simp]: \"M = add_zmset x M \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M = add_zmset x M) = False", "by (auto simp add: zmultiset_eq_iff)"], ["", "lemma add_zmset_remove_trivial: \\<open>add_zmset x M - {#x#}\\<^sub>z = M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. add_zmset x M - {#x#}\\<^sub>z = M", "by simp"], ["", "lemma diff_single_eq_union_zmset: \"M - {#x#}\\<^sub>z = N \\<longleftrightarrow> M = add_zmset x N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M - {#x#}\\<^sub>z = N) = (M = add_zmset x N)", "by auto"], ["", "lemma union_single_eq_diff_zmset: \"add_zmset x M = N \\<Longrightarrow> M = N - {#x#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_zmset x M = N \\<Longrightarrow> M = N - {#x#}\\<^sub>z", "unfolding add_zmset_add_single[of _ M]"], ["proof (prove)\ngoal (1 subgoal):\n 1. M + {#x#}\\<^sub>z = N \\<Longrightarrow> M = N - {#x#}\\<^sub>z", "by (fact add_implies_diff)"], ["", "lemma add_zmset_eq_conv_diff:\n  \"add_zmset a M = add_zmset b N \\<longleftrightarrow>\n   M = N \\<and> a = b \\<or> M = add_zmset b (N - {#a#}\\<^sub>z) \\<and> N = add_zmset a (M - {#b#}\\<^sub>z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (add_zmset a M = add_zmset b N) =\n    (M = N \\<and> a = b \\<or>\n     M = add_zmset b (N - {#a#}\\<^sub>z) \\<and>\n     N = add_zmset a (M - {#b#}\\<^sub>z))", "by (simp add: zmultiset_eq_iff) fastforce"], ["", "lemma add_zmset_eq_conv_ex:\n  \"(add_zmset a M = add_zmset b N) =\n    (M = N \\<and> a = b \\<or> (\\<exists>K. M = add_zmset b K \\<and> N = add_zmset a K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (add_zmset a M = add_zmset b N) =\n    (M = N \\<and> a = b \\<or>\n     (\\<exists>K. M = add_zmset b K \\<and> N = add_zmset a K))", "by (auto simp add: add_zmset_eq_conv_diff)"], ["", "lemma multi_member_split: \"\\<exists>A. M = add_zmset x A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A. M = add_zmset x A", "by (rule exI[where x = \"M - {#x#}\\<^sub>z\"]) simp"], ["", "subsection \\<open>Conversions from and to Multisets\\<close>"], ["", "lift_definition zmset_of :: \"'a multiset \\<Rightarrow> 'a zmultiset\" is \"\\<lambda>f. (Abs_multiset f, {#})\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma zmset_of_inject[simp]: \"zmset_of M = zmset_of N \\<longleftrightarrow> M = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zmset_of M = zmset_of N) = (M = N)", "by (simp add: zmset_of_def, transfer, auto simp: equiv_zmset_def)"], ["", "lemma zmset_of_empty[simp]: \"zmset_of {#} = {#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zmset_of {#} = {#}\\<^sub>z", "by (simp add: zmset_of_def zero_zmultiset_def)"], ["", "lemma zmset_of_add_mset[simp]: \"zmset_of (add_mset x M) = add_zmset x (zmset_of M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zmset_of (add_mset x M) = add_zmset x (zmset_of M)", "by transfer (auto simp: equiv_zmset_def add_mset_def cong: if_cong)"], ["", "lemma zcount_of_mset[simp]: \"zcount (zmset_of M) x = int (count M x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (zmset_of M) x = int (count M x)", "by (induct M) auto"], ["", "lemma zmset_of_plus: \"zmset_of (M + N) = zmset_of M + zmset_of N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zmset_of (M + N) = zmset_of M + zmset_of N", "by (transfer, auto simp: equiv_zmset_def eq_onp_same_args plus_multiset.abs_eq)+"], ["", "lift_definition mset_pos :: \"'a zmultiset \\<Rightarrow> 'a multiset\" is \"\\<lambda>(Mp, Mn). count (Mp - Mn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       equiv_zmset prod1 prod2 \\<Longrightarrow>\n       (case prod1 of (Mp, Mn) \\<Rightarrow> count (Mp - Mn))\n       \\<in> multiset \\<and>\n       (case prod1 of (Mp, Mn) \\<Rightarrow> count (Mp - Mn)) =\n       (case prod2 of (Mp, Mn) \\<Rightarrow> count (Mp - Mn))", "by (clarsimp simp: equiv_zmset_def intro!: arg_cong[of _ _ count])\n    (metis add.commute add_diff_cancel_right)"], ["", "lift_definition mset_neg :: \"'a zmultiset \\<Rightarrow> 'a multiset\" is \"\\<lambda>(Mp, Mn). count (Mn - Mp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2.\n       equiv_zmset prod1 prod2 \\<Longrightarrow>\n       (case prod1 of (Mp, Mn) \\<Rightarrow> count (Mn - Mp))\n       \\<in> multiset \\<and>\n       (case prod1 of (Mp, Mn) \\<Rightarrow> count (Mn - Mp)) =\n       (case prod2 of (Mp, Mn) \\<Rightarrow> count (Mn - Mp))", "by (clarsimp simp: equiv_zmset_def intro!: arg_cong[of _ _ count])\n    (metis add.commute add_diff_cancel_right)"], ["", "lemma\n  zmset_of_inverse[simp]: \"mset_pos (zmset_of M) = M\" and\n  minus_zmset_of_inverse[simp]: \"mset_neg (- zmset_of M) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_pos (zmset_of M) = M &&& mset_neg (- zmset_of M) = M", "by (transfer, simp)+"], ["", "lemma neg_zmset_pos[simp]: \"mset_neg (zmset_of M) = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_neg (zmset_of M) = {#}", "by (rule zmset_of_inject[THEN iffD1], simp, transfer, auto simp: equiv_zmset_def)+"], ["", "lemma\n  count_mset_pos[simp]: \"count (mset_pos M) x = nat (zcount M x)\" and\n  count_mset_neg[simp]: \"count (mset_neg M) x = nat (- zcount M x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (mset_pos M) x = nat (zcount M x) &&&\n    count (mset_neg M) x = nat (- zcount M x)", "by (transfer; auto)+"], ["", "lemma\n  mset_pos_empty[simp]: \"mset_pos {#}\\<^sub>z = {#}\" and\n  mset_neg_empty[simp]: \"mset_neg {#}\\<^sub>z = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_pos {#}\\<^sub>z = {#} &&& mset_neg {#}\\<^sub>z = {#}", "by (rule multiset_eqI, simp)+"], ["", "lemma\n  mset_pos_singleton[simp]: \"mset_pos {#x#}\\<^sub>z = {#x#}\" and\n  mset_neg_singleton[simp]: \"mset_neg {#x#}\\<^sub>z = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_pos {#x#}\\<^sub>z = {#x#} &&& mset_neg {#x#}\\<^sub>z = {#}", "by (rule multiset_eqI, simp)+"], ["", "lemma\n  mset_pos_neg_partition: \"M = zmset_of (mset_pos M) - zmset_of (mset_neg M)\" and\n  mset_pos_as_neg: \"zmset_of (mset_pos M) = zmset_of (mset_neg M) + M\" and\n  mset_neg_as_pos: \"zmset_of (mset_neg M) = zmset_of (mset_pos M) - M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = zmset_of (mset_pos M) - zmset_of (mset_neg M) &&&\n    zmset_of (mset_pos M) = zmset_of (mset_neg M) + M &&&\n    zmset_of (mset_neg M) = zmset_of (mset_pos M) - M", "by (rule zmultiset_eqI, simp)+"], ["", "lemma mset_pos_uminus[simp]: \"mset_pos (- A) = mset_neg A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_pos (- A) = mset_neg A", "by (rule multiset_eqI) simp"], ["", "lemma mset_neg_uminus[simp]: \"mset_neg (- A) = mset_pos A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_neg (- A) = mset_pos A", "by (rule multiset_eqI) simp"], ["", "lemma mset_pos_plus[simp]:\n  \"mset_pos (A + B) = (mset_pos A - mset_neg B) + (mset_pos B - mset_neg A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_pos (A + B) = mset_pos A - mset_neg B + (mset_pos B - mset_neg A)", "by (rule multiset_eqI) simp"], ["", "lemma mset_neg_plus[simp]:\n  \"mset_neg (A + B) = (mset_neg A - mset_pos B) + (mset_neg B - mset_pos A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_neg (A + B) = mset_neg A - mset_pos B + (mset_neg B - mset_pos A)", "by (rule multiset_eqI) simp"], ["", "lemma mset_pos_diff[simp]:\n  \"mset_pos (A - B) = (mset_pos A - mset_pos B) + (mset_neg B - mset_neg A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_pos (A - B) = mset_pos A - mset_pos B + (mset_neg B - mset_neg A)", "by (rule mset_pos_plus[of A \"- B\", simplified])"], ["", "lemma mset_neg_diff[simp]:\n  \"mset_neg (A - B) = (mset_neg A - mset_neg B) + (mset_pos B - mset_pos A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_neg (A - B) = mset_neg A - mset_neg B + (mset_pos B - mset_pos A)", "by (rule mset_neg_plus[of A \"- B\", simplified])"], ["", "lemma mset_pos_neg_dual:\n  \"mset_pos a + mset_pos b + (mset_neg a - mset_pos b) + (mset_neg b - mset_pos a) =\n   mset_neg a + mset_neg b + (mset_pos a - mset_neg b) + (mset_pos b - mset_neg a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_pos a + mset_pos b + (mset_neg a - mset_pos b) +\n    (mset_neg b - mset_pos a) =\n    mset_neg a + mset_neg b + (mset_pos a - mset_neg b) +\n    (mset_pos b - mset_neg a)", "using [[linarith_split_limit = 20]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_pos a + mset_pos b + (mset_neg a - mset_pos b) +\n    (mset_neg b - mset_pos a) =\n    mset_neg a + mset_neg b + (mset_pos a - mset_neg b) +\n    (mset_pos b - mset_neg a)", "by (rule multiset_eqI) simp"], ["", "lemma decompose_zmset_of2:\n  obtains A B C where\n    \"M = zmset_of A + C\" and\n    \"N = zmset_of B + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    M = zmset_of ?A2 + ?C2\n 2. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    N = zmset_of ?B2 + ?C2", "let ?A = \"zmset_of (mset_pos M + mset_neg N)\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    M = zmset_of ?A2 + ?C2\n 2. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    N = zmset_of ?B2 + ?C2", "let ?B = \"zmset_of (mset_pos N + mset_neg M)\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    M = zmset_of ?A2 + ?C2\n 2. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    N = zmset_of ?B2 + ?C2", "let ?C = \"- (zmset_of (mset_neg M) + zmset_of (mset_neg N))\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    M = zmset_of ?A2 + ?C2\n 2. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    N = zmset_of ?B2 + ?C2", "show \"M = ?A + ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M =\n    zmset_of (mset_pos M + mset_neg N) +\n    - (zmset_of (mset_neg M) + zmset_of (mset_neg N))", "by (simp add: zmset_of_plus mset_pos_neg_partition)"], ["proof (state)\nthis:\n  M =\n  zmset_of (mset_pos M + mset_neg N) +\n  - (zmset_of (mset_neg M) + zmset_of (mset_neg N))\n\ngoal (1 subgoal):\n 1. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    N = zmset_of ?B2 + - (zmset_of (mset_neg M) + zmset_of (mset_neg N))", "show \"N = ?B + ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N =\n    zmset_of (mset_pos N + mset_neg M) +\n    - (zmset_of (mset_neg M) + zmset_of (mset_neg N))", "by (simp add: zmset_of_plus diff_add_zmset mset_pos_neg_partition)"], ["proof (state)\nthis:\n  N =\n  zmset_of (mset_pos N + mset_neg M) +\n  - (zmset_of (mset_neg M) + zmset_of (mset_neg N))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Pointwise Ordering Induced by @{const zcount}\\<close>"], ["", "definition subseteq_zmset :: \"'a zmultiset \\<Rightarrow> 'a zmultiset \\<Rightarrow> bool\" (infix \"\\<subseteq>#\\<^sub>z\" 50) where\n  \"A \\<subseteq>#\\<^sub>z B \\<longleftrightarrow> (\\<forall>a. zcount A a \\<le> zcount B a)\""], ["", "definition subset_zmset :: \"'a zmultiset \\<Rightarrow> 'a zmultiset \\<Rightarrow> bool\" (infix \"\\<subset>#\\<^sub>z\" 50) where\n  \"A \\<subset>#\\<^sub>z B \\<longleftrightarrow> A \\<subseteq>#\\<^sub>z B \\<and> A \\<noteq> B\""], ["", "abbreviation (input)\n  supseteq_zmset :: \"'a zmultiset \\<Rightarrow> 'a zmultiset \\<Rightarrow> bool\" (infix \"\\<supseteq>#\\<^sub>z\" 50)\nwhere\n  \"supseteq_zmset A B \\<equiv> B \\<subseteq>#\\<^sub>z A\""], ["", "abbreviation (input)\n  supset_zmset :: \"'a zmultiset \\<Rightarrow> 'a zmultiset \\<Rightarrow> bool\" (infix \"\\<supset>#\\<^sub>z\" 50)\nwhere\n  \"supset_zmset A B \\<equiv> B \\<subset>#\\<^sub>z A\""], ["", "notation (input)\n  subseteq_zmset (infix \"\\<subseteq>#\\<^sub>z\" 50) and\n  supseteq_zmset (infix \"\\<supseteq>#\\<^sub>z\" 50)"], ["", "notation (ASCII)\n  subseteq_zmset (infix \"\\<subseteq>#\\<^sub>z\" 50) and\n  subset_zmset (infix \"\\<subset>#\\<^sub>z\" 50) and\n  supseteq_zmset (infix \"\\<supseteq>#\\<^sub>z\" 50) and\n  supset_zmset (infix \">#\\<^sub>z\" 50)"], ["", "interpretation subset_zmset: ordered_ab_semigroup_add_imp_le \"(+)\" \"(-)\" \"(\\<subseteq>#\\<^sub>z)\" \"(\\<subset>#\\<^sub>z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ordered_ab_semigroup_add_imp_le (+) (-) (\\<subseteq>#\\<^sub>z)\n     (\\<subset>#\\<^sub>z)", "by unfold_locales (auto simp add: subset_zmset_def subseteq_zmset_def zmultiset_eq_iff\n    intro: order_trans antisym)"], ["", "interpretation subset_zmset:\n  ordered_ab_semigroup_monoid_add_imp_le \"(+)\" 0 \"(-)\" \"(\\<subseteq>#\\<^sub>z)\" \"(\\<subset>#\\<^sub>z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ordered_ab_semigroup_monoid_add_imp_le (+) {#}\\<^sub>z (-)\n     (\\<subseteq>#\\<^sub>z) (\\<subset>#\\<^sub>z)", "by unfold_locales"], ["", "lemma zmset_subset_eqI: \"(\\<And>a. zcount A a \\<le> zcount B a) \\<Longrightarrow> A \\<subseteq>#\\<^sub>z B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. zcount A a \\<le> zcount B a) \\<Longrightarrow>\n    A \\<subseteq>#\\<^sub>z B", "by (simp add: subseteq_zmset_def)"], ["", "lemma zmset_subset_eq_zcount: \"A \\<subseteq>#\\<^sub>z B \\<Longrightarrow> zcount A a \\<le> zcount B a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq>#\\<^sub>z B \\<Longrightarrow> zcount A a \\<le> zcount B a", "by (simp add: subseteq_zmset_def)"], ["", "lemma zmset_subset_eq_add_zmset_cancel: \\<open>add_zmset a A \\<subseteq>#\\<^sub>z add_zmset a B \\<longleftrightarrow> A \\<subseteq>#\\<^sub>z B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (add_zmset a A \\<subseteq>#\\<^sub>z add_zmset a B) =\n    (A \\<subseteq>#\\<^sub>z B)", "unfolding add_zmset_add_single[of _ A] add_zmset_add_single[of _ B]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A + {#a#}\\<^sub>z \\<subseteq>#\\<^sub>z B + {#a#}\\<^sub>z) =\n    (A \\<subseteq>#\\<^sub>z B)", "by (rule subset_zmset.add_le_cancel_right)"], ["", "lemma zmset_subset_eq_zmultiset_union_diff_commute:\n  \"A - B + C = A + C - B\" for A B C :: \"'a zmultiset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - B + C = A + C - B", "by (simp add: add.commute add_diff_eq)"], ["", "lemma zmset_subset_eq_insertD: \"add_zmset x A \\<subseteq>#\\<^sub>z B \\<Longrightarrow> A \\<subset>#\\<^sub>z B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_zmset x A \\<subseteq>#\\<^sub>z B \\<Longrightarrow>\n    A \\<subset>#\\<^sub>z B", "unfolding subset_zmset_def subseteq_zmset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. zcount (add_zmset x A) a \\<le> zcount B a \\<Longrightarrow>\n    (\\<forall>a. zcount A a \\<le> zcount B a) \\<and> A \\<noteq> B", "by (metis (no_types) add.commute add_le_same_cancel2 zcount_add_zmset dual_order.trans le_cases\n    le_numeral_extra(2))"], ["", "lemma zmset_subset_insertD: \"add_zmset x A \\<subset>#\\<^sub>z B \\<Longrightarrow> A \\<subset>#\\<^sub>z B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_zmset x A \\<subset>#\\<^sub>z B \\<Longrightarrow>\n    A \\<subset>#\\<^sub>z B", "by (rule zmset_subset_eq_insertD) (rule subset_zmset.less_imp_le)"], ["", "lemma subset_eq_diff_conv_zmset: \"A - C \\<subseteq>#\\<^sub>z B \\<longleftrightarrow> A \\<subseteq>#\\<^sub>z B + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - C \\<subseteq>#\\<^sub>z B) = (A \\<subseteq>#\\<^sub>z B + C)", "by (simp add: subseteq_zmset_def ordered_ab_group_add_class.diff_le_eq)"], ["", "lemma multi_psub_of_add_self_zmset[simp]: \"A \\<subset>#\\<^sub>z add_zmset x A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subset>#\\<^sub>z add_zmset x A", "by (auto simp: subset_zmset_def subseteq_zmset_def)"], ["", "lemma multi_psub_self_zmset: \"A \\<subset>#\\<^sub>z A = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<subset>#\\<^sub>z A) = False", "by simp"], ["", "lemma zmset_subset_add_zmset[simp]: \"add_zmset x N \\<subset>#\\<^sub>z add_zmset x M \\<longleftrightarrow> N \\<subset>#\\<^sub>z M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (add_zmset x N \\<subset>#\\<^sub>z add_zmset x M) =\n    (N \\<subset>#\\<^sub>z M)", "unfolding add_zmset_add_single[of _ N] add_zmset_add_single[of _ M]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (N + {#x#}\\<^sub>z \\<subset>#\\<^sub>z M + {#x#}\\<^sub>z) =\n    (N \\<subset>#\\<^sub>z M)", "by (fact subset_zmset.add_less_cancel_right)"], ["", "lemma zmset_of_subseteq_iff[simp]: \"zmset_of M \\<subseteq>#\\<^sub>z zmset_of N \\<longleftrightarrow> M \\<subseteq># N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zmset_of M \\<subseteq>#\\<^sub>z zmset_of N) = (M \\<subseteq># N)", "by (simp add: subseteq_zmset_def subseteq_mset_def)"], ["", "lemma zmset_of_subset_iff[simp]: \"zmset_of M \\<subset>#\\<^sub>z zmset_of N \\<longleftrightarrow> M \\<subset># N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zmset_of M \\<subset>#\\<^sub>z zmset_of N) = (M \\<subset># N)", "by (simp add: subset_zmset_def subset_mset_def)"], ["", "lemma\n  mset_pos_supset: \"A \\<subseteq>#\\<^sub>z zmset_of (mset_pos A)\" and\n  mset_neg_supset: \"- A \\<subseteq>#\\<^sub>z zmset_of (mset_neg A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq>#\\<^sub>z zmset_of (mset_pos A) &&&\n    - A \\<subseteq>#\\<^sub>z zmset_of (mset_neg A)", "by (auto intro: zmset_subset_eqI)"], ["", "lemma subset_mset_zmsetE:\n  assumes \"M \\<subset>#\\<^sub>z N\"\n  obtains A B C where\n    \"M = zmset_of A + C\" and \"N = zmset_of B + C\" and \"A \\<subset># B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C;\n         A \\<subset># B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis assms decompose_zmset_of2 subset_zmset.add_less_cancel_right zmset_of_subset_iff)"], ["", "lemma subseteq_mset_zmsetE:\n  assumes \"M \\<subseteq>#\\<^sub>z N\"\n  obtains A B C where\n    \"M = zmset_of A + C\" and \"N = zmset_of B + C\" and \"A \\<subseteq># B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C;\n         A \\<subseteq># B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis assms add.commute add.right_neutral subset_mset.order_refl subset_mset_def\n    subset_mset_zmsetE subset_zmset_def zmset_of_empty)"], ["", "subsubsection \\<open>Subset is an Order\\<close>"], ["", "interpretation subset_zmset: order \"(\\<subseteq>#\\<^sub>z)\" \"(\\<subset>#\\<^sub>z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.order (\\<subseteq>#\\<^sub>z) (\\<subset>#\\<^sub>z)", "by unfold_locales"], ["", "subsection \\<open>Replicate and Repeat Operations\\<close>"], ["", "definition replicate_zmset :: \"nat \\<Rightarrow> 'a \\<Rightarrow> 'a zmultiset\" where\n  \"replicate_zmset n x = (add_zmset x ^^ n) {#}\\<^sub>z\""], ["", "lemma replicate_zmset_0[simp]: \"replicate_zmset 0 x = {#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate_zmset 0 x = {#}\\<^sub>z", "unfolding replicate_zmset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (add_zmset x ^^ 0) {#}\\<^sub>z = {#}\\<^sub>z", "by simp"], ["", "lemma replicate_zmset_Suc[simp]: \"replicate_zmset (Suc n) x = add_zmset x (replicate_zmset n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate_zmset (Suc n) x = add_zmset x (replicate_zmset n x)", "unfolding replicate_zmset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (add_zmset x ^^ Suc n) {#}\\<^sub>z =\n    add_zmset x ((add_zmset x ^^ n) {#}\\<^sub>z)", "by (induct n) (auto intro: add.commute)"], ["", "lemma count_replicate_zmset[simp]:\n  \"zcount (replicate_zmset n x) y = (if y = x then of_nat n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (replicate_zmset n x) y = (if y = x then int n else 0)", "unfolding replicate_zmset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount ((add_zmset x ^^ n) {#}\\<^sub>z) y = (if y = x then int n else 0)", "by (induct n) auto"], ["", "fun repeat_zmset :: \"nat \\<Rightarrow> 'a zmultiset \\<Rightarrow> 'a zmultiset\" where\n  \"repeat_zmset 0 _ = {#}\\<^sub>z\" |\n  \"repeat_zmset (Suc n) A = A + repeat_zmset n A\""], ["", "lemma count_repeat_zmset[simp]: \"zcount (repeat_zmset i A) a = of_nat i * zcount A a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (repeat_zmset i A) a = int i * zcount A a", "by (induct i) (auto simp: semiring_normalization_rules(3))"], ["", "lemma repeat_zmset_right[simp]: \"repeat_zmset a (repeat_zmset b A) = repeat_zmset (a * b) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat_zmset a (repeat_zmset b A) = repeat_zmset (a * b) A", "by (auto simp: zmultiset_eq_iff left_diff_distrib')"], ["", "lemma left_diff_repeat_zmset_distrib':\n  \\<open>i \\<ge> j \\<Longrightarrow> repeat_zmset (i - j) u = repeat_zmset i u - repeat_zmset j u\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> i \\<Longrightarrow>\n    repeat_zmset (i - j) u = repeat_zmset i u - repeat_zmset j u", "by (auto simp: zmultiset_eq_iff int_distrib(3) of_nat_diff)"], ["", "lemma left_add_mult_distrib_zmset:\n  \"repeat_zmset i u + (repeat_zmset j u + k) = repeat_zmset (i+j) u + k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat_zmset i u + (repeat_zmset j u + k) = repeat_zmset (i + j) u + k", "by (auto simp: zmultiset_eq_iff add_mult_distrib int_distrib(1))"], ["", "lemma repeat_zmset_distrib: \"repeat_zmset (m + n) A = repeat_zmset m A + repeat_zmset n A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat_zmset (m + n) A = repeat_zmset m A + repeat_zmset n A", "by (auto simp: zmultiset_eq_iff Nat.add_mult_distrib int_distrib(1))"], ["", "lemma repeat_zmset_distrib2[simp]:\n  \"repeat_zmset n (A + B) = repeat_zmset n A + repeat_zmset n B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat_zmset n (A + B) = repeat_zmset n A + repeat_zmset n B", "by (auto simp: zmultiset_eq_iff add_mult_distrib2 int_distrib(2))"], ["", "lemma repeat_zmset_replicate_zmset[simp]: \"repeat_zmset n {#a#}\\<^sub>z = replicate_zmset n a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat_zmset n {#a#}\\<^sub>z = replicate_zmset n a", "by (auto simp: zmultiset_eq_iff)"], ["", "lemma repeat_zmset_distrib_add_zmset[simp]:\n  \"repeat_zmset n (add_zmset a A) = replicate_zmset n a + repeat_zmset n A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat_zmset n (add_zmset a A) = replicate_zmset n a + repeat_zmset n A", "by (auto simp: zmultiset_eq_iff int_distrib(2))"], ["", "lemma repeat_zmset_empty[simp]: \"repeat_zmset n {#}\\<^sub>z = {#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat_zmset n {#}\\<^sub>z = {#}\\<^sub>z", "by (induct n) simp_all"], ["", "subsubsection \\<open>Filter (with Comprehension Syntax)\\<close>"], ["", "lift_definition filter_zmset :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a zmultiset \\<Rightarrow> 'a zmultiset\" is\n  \"\\<lambda>P (Mp, Mn). (filter_mset P Mp, filter_mset P Mn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun prod1 prod2.\n       equiv_zmset prod1 prod2 \\<Longrightarrow>\n       equiv_zmset\n        (case prod1 of\n         (Mp, Mn) \\<Rightarrow> (filter_mset fun Mp, filter_mset fun Mn))\n        (case prod2 of\n         (Mp, Mn) \\<Rightarrow> (filter_mset fun Mp, filter_mset fun Mn))", "by (auto simp del: filter_union_mset simp: equiv_zmset_def filter_union_mset[symmetric])"], ["", "syntax (ASCII)\n  \"_ZMCollect\" :: \"pttrn \\<Rightarrow> 'a zmultiset \\<Rightarrow> bool \\<Rightarrow> 'a zmultiset\" (\"(1{#_ :#z _./ _#})\")"], ["", "syntax\n  \"_ZMCollect\" :: \"pttrn \\<Rightarrow> 'a zmultiset \\<Rightarrow> bool \\<Rightarrow> 'a zmultiset\" (\"(1{#_ \\<in>#\\<^sub>z _./ _#})\")"], ["", "translations\n  \"{#x \\<in>#\\<^sub>z M. P#}\" == \"CONST filter_zmset (\\<lambda>x. P) M\""], ["", "lemma count_filter_zmset[simp]:\n  \"zcount (filter_zmset P M) a = (if P a then zcount M a else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zcount (filter_zmset P M) a = (if P a then zcount M a else 0)", "by transfer auto"], ["", "lemma filter_empty_zmset[simp]: \"filter_zmset P {#}\\<^sub>z = {#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_zmset P {#}\\<^sub>z = {#}\\<^sub>z", "by (rule zmultiset_eqI) simp"], ["", "lemma filter_single_zmset: \"filter_zmset P {#x#}\\<^sub>z = (if P x then {#x#}\\<^sub>z else {#}\\<^sub>z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_zmset P {#x#}\\<^sub>z =\n    (if P x then {#x#}\\<^sub>z else {#}\\<^sub>z)", "by (rule zmultiset_eqI) simp"], ["", "lemma filter_union_zmset[simp]: \"filter_zmset P (M + N) = filter_zmset P M + filter_zmset P N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_zmset P (M + N) = filter_zmset P M + filter_zmset P N", "by (rule zmultiset_eqI) simp"], ["", "lemma filter_diff_zmset[simp]: \"filter_zmset P (M - N) = filter_zmset P M - filter_zmset P N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_zmset P (M - N) = filter_zmset P M - filter_zmset P N", "by (rule zmultiset_eqI) simp"], ["", "lemma filter_add_zmset[simp]:\n  \"filter_zmset P (add_zmset x A) =\n   (if P x then add_zmset x (filter_zmset P A) else filter_zmset P A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_zmset P (add_zmset x A) =\n    (if P x then add_zmset x (filter_zmset P A) else filter_zmset P A)", "by (auto simp: zmultiset_eq_iff)"], ["", "lemma zmultiset_filter_mono:\n  assumes \"A \\<subseteq>#\\<^sub>z B\"\n  shows \"filter_zmset f A \\<subseteq>#\\<^sub>z filter_zmset f B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_zmset f A \\<subseteq>#\\<^sub>z filter_zmset f B", "using assms"], ["proof (prove)\nusing this:\n  A \\<subseteq>#\\<^sub>z B\n\ngoal (1 subgoal):\n 1. filter_zmset f A \\<subseteq>#\\<^sub>z filter_zmset f B", "by (simp add: subseteq_zmset_def)"], ["", "lemma filter_filter_zmset: \"filter_zmset P (filter_zmset Q M) = {#x \\<in>#\\<^sub>z M. Q x \\<and> P x#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_zmset P (filter_zmset Q M) =\n    {#x \\<in>#\\<^sub>z M. Q x \\<and> P x#}", "by (auto simp: zmultiset_eq_iff)"], ["", "lemma\n  filter_zmset_True[simp]: \"{#y \\<in>#\\<^sub>z M. True#} = M\" and\n  filter_zmset_False[simp]: \"{#y \\<in>#\\<^sub>z M. False#} = {#}\\<^sub>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#y \\<in>#\\<^sub>z M. True#} = M &&&\n    {#y \\<in>#\\<^sub>z M. False#} = {#}\\<^sub>z", "by (auto simp: zmultiset_eq_iff)"], ["", "subsection \\<open>Uncategorized\\<close>"], ["", "lemma multi_drop_mem_not_eq_zmset: \"B - {#c#}\\<^sub>z \\<noteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B - {#c#}\\<^sub>z \\<noteq> B", "by (simp add: diff_single_eq_union_zmset)"], ["", "lemma zmultiset_partition: \"M = {#x \\<in>#\\<^sub>z M. P x #} + {#x \\<in>#\\<^sub>z M. \\<not> P x#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = filter_zmset P M + {#x \\<in>#\\<^sub>z M. \\<not> P x#}", "by (subst zmultiset_eq_iff) auto"], ["", "subsection \\<open>Image\\<close>"], ["", "definition image_zmset :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a zmultiset \\<Rightarrow> 'b zmultiset\" where\n  \"image_zmset f M =\n   zmset_of (fold_mset (add_mset \\<circ> f) {#} (mset_pos M)) -\n   zmset_of (fold_mset (add_mset \\<circ> f) {#} (mset_neg M))\""], ["", "subsection \\<open>Multiset Order\\<close>"], ["", "instantiation zmultiset :: (preorder) order\nbegin"], ["", "lift_definition less_zmultiset :: \"'a zmultiset \\<Rightarrow> 'a zmultiset \\<Rightarrow> bool\" is\n  \"\\<lambda>(Mp, Mn) (Np, Nn). Mp + Nn < Mn + Np\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prod1 prod2 prod3 prod4.\n       \\<lbrakk>equiv_zmset prod1 prod2; equiv_zmset prod3 prod4\\<rbrakk>\n       \\<Longrightarrow> (case prod1 of\n                          (Mp, Mn) \\<Rightarrow>\n                            \\<lambda>(Np, Nn). Mp + Nn < Mn + Np)\n                          prod3 =\n                         (case prod2 of\n                          (Mp, Mn) \\<Rightarrow>\n                            \\<lambda>(Np, Nn). Mp + Nn < Mn + Np)\n                          prod4", "proof (clarsimp simp: equiv_zmset_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "fix A1 B2 B1 A2 C1 D2 D1 C2 :: \"'a multiset\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "assume\n    ab: \"A1 + A2 = B1 + B2\" and\n    cd: \"C1 + C2 = D1 + D2\""], ["proof (state)\nthis:\n  A1 + A2 = B1 + B2\n  C1 + C2 = D1 + D2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "have \"A1 + D2 < B2 + C1 \\<longleftrightarrow> A1 + A2 + D2 < A2 + B2 + C1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A1 + D2 < B2 + C1) = (A1 + A2 + D2 < A2 + B2 + C1)", "by simp"], ["proof (state)\nthis:\n  (A1 + D2 < B2 + C1) = (A1 + A2 + D2 < A2 + B2 + C1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "also"], ["proof (state)\nthis:\n  (A1 + D2 < B2 + C1) = (A1 + A2 + D2 < A2 + B2 + C1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "have \"\\<dots> \\<longleftrightarrow> B1 + B2 + D2 < A2 + B2 + C1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A1 + A2 + D2 < A2 + B2 + C1) = (B1 + B2 + D2 < A2 + B2 + C1)", "unfolding ab"], ["proof (prove)\ngoal (1 subgoal):\n 1. (B1 + B2 + D2 < A2 + B2 + C1) = (B1 + B2 + D2 < A2 + B2 + C1)", "by (rule refl)"], ["proof (state)\nthis:\n  (A1 + A2 + D2 < A2 + B2 + C1) = (B1 + B2 + D2 < A2 + B2 + C1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "also"], ["proof (state)\nthis:\n  (A1 + A2 + D2 < A2 + B2 + C1) = (B1 + B2 + D2 < A2 + B2 + C1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "have \"\\<dots> \\<longleftrightarrow> B1 + D2 < A2 + C1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B1 + B2 + D2 < A2 + B2 + C1) = (B1 + D2 < A2 + C1)", "by simp"], ["proof (state)\nthis:\n  (B1 + B2 + D2 < A2 + B2 + C1) = (B1 + D2 < A2 + C1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "also"], ["proof (state)\nthis:\n  (B1 + B2 + D2 < A2 + B2 + C1) = (B1 + D2 < A2 + C1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "have \"\\<dots> \\<longleftrightarrow> B1 + D1 + D2 < A2 + C1 + D1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B1 + D2 < A2 + C1) = (B1 + D1 + D2 < A2 + C1 + D1)", "by simp"], ["proof (state)\nthis:\n  (B1 + D2 < A2 + C1) = (B1 + D1 + D2 < A2 + C1 + D1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "also"], ["proof (state)\nthis:\n  (B1 + D2 < A2 + C1) = (B1 + D1 + D2 < A2 + C1 + D1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "have \"\\<dots> \\<longleftrightarrow> B1 + C1 + C2 < A2 + C1 + D1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B1 + D1 + D2 < A2 + C1 + D1) = (B1 + C1 + C2 < A2 + C1 + D1)", "using cd"], ["proof (prove)\nusing this:\n  C1 + C2 = D1 + D2\n\ngoal (1 subgoal):\n 1. (B1 + D1 + D2 < A2 + C1 + D1) = (B1 + C1 + C2 < A2 + C1 + D1)", "by (simp add: add.assoc)"], ["proof (state)\nthis:\n  (B1 + D1 + D2 < A2 + C1 + D1) = (B1 + C1 + C2 < A2 + C1 + D1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "also"], ["proof (state)\nthis:\n  (B1 + D1 + D2 < A2 + C1 + D1) = (B1 + C1 + C2 < A2 + C1 + D1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "have \"\\<dots> \\<longleftrightarrow> B1 + C2 < A2 + D1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B1 + C1 + C2 < A2 + C1 + D1) = (B1 + C2 < A2 + D1)", "by simp"], ["proof (state)\nthis:\n  (B1 + C1 + C2 < A2 + C1 + D1) = (B1 + C2 < A2 + D1)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb ac bc.\n       \\<lbrakk>a + ba = aa + b; ab + bc = ac + bb\\<rbrakk>\n       \\<Longrightarrow> (a + bb < b + ab) = (aa + bc < ba + ac)", "finally"], ["proof (chain)\npicking this:\n  (A1 + D2 < B2 + C1) = (B1 + C2 < A2 + D1)", "show \"A1 + D2 < B2 + C1 \\<longleftrightarrow> B1 + C2 < A2 + D1\""], ["proof (prove)\nusing this:\n  (A1 + D2 < B2 + C1) = (B1 + C2 < A2 + D1)\n\ngoal (1 subgoal):\n 1. (A1 + D2 < B2 + C1) = (B1 + C2 < A2 + D1)", "by assumption"], ["proof (state)\nthis:\n  (A1 + D2 < B2 + C1) = (B1 + C2 < A2 + D1)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition less_eq_zmultiset :: \"'a zmultiset \\<Rightarrow> 'a zmultiset \\<Rightarrow> bool\" where\n  \"less_eq_zmultiset M' M \\<longleftrightarrow> M' < M \\<or> M' = M\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a zmultiset, order_class)", "proof ((intro_classes; unfold less_eq_zmultiset_def; transfer),\n    auto simp: equiv_zmset_def union_commute)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 4. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "fix A1 B1 D C B2 A2 :: \"'a multiset\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 4. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "assume ab: \"A1 + A2 \\<noteq> B1 + B2\""], ["proof (state)\nthis:\n  A1 + A2 \\<noteq> B1 + B2\n\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 4. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "{"], ["proof (state)\nthis:\n  A1 + A2 \\<noteq> B1 + B2\n\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 4. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "assume ab1: \"A1 + C < B1 + D\""], ["proof (state)\nthis:\n  A1 + C < B1 + D\n\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 4. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "{"], ["proof (state)\nthis:\n  A1 + C < B1 + D\n\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 4. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "assume ab2: \"D + A2 < C + B2\""], ["proof (state)\nthis:\n  D + A2 < C + B2\n\ngoal (4 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 4. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "show \"A1 + A2 < B1 + B2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "have f1: \"\\<And>m. D + A2 + m < C + B2 + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m. D + A2 + m < C + B2 + m", "using ab2 add_less_cancel_right"], ["proof (prove)\nusing this:\n  D + A2 < C + B2\n  (?a + ?c < ?b + ?c) = (?a < ?b)\n\ngoal (1 subgoal):\n 1. \\<And>m. D + A2 + m < C + B2 + m", "by blast"], ["proof (state)\nthis:\n  D + A2 + ?m < C + B2 + ?m\n\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "have \"\\<And>m. C + (A1 + m) < D + (B1 + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m. C + (A1 + m) < D + (B1 + m)", "by (simp add: ab1 add.commute)"], ["proof (state)\nthis:\n  C + (A1 + ?m) < D + (B1 + ?m)\n\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "then"], ["proof (chain)\npicking this:\n  C + (A1 + ?m) < D + (B1 + ?m)", "have \"D + (A2 + A1) < D + (B1 + B2)\""], ["proof (prove)\nusing this:\n  C + (A1 + ?m) < D + (B1 + ?m)\n\ngoal (1 subgoal):\n 1. D + (A2 + A1) < D + (B1 + B2)", "using f1"], ["proof (prove)\nusing this:\n  C + (A1 + ?m) < D + (B1 + ?m)\n  D + A2 + ?m < C + B2 + ?m\n\ngoal (1 subgoal):\n 1. D + (A2 + A1) < D + (B1 + B2)", "by (metis add.assoc add.commute mset_le_trans)"], ["proof (state)\nthis:\n  D + (A2 + A1) < D + (B1 + B2)\n\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "then"], ["proof (chain)\npicking this:\n  D + (A2 + A1) < D + (B1 + B2)", "show ?thesis"], ["proof (prove)\nusing this:\n  D + (A2 + A1) < D + (B1 + B2)\n\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  A1 + A2 < B1 + B2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A1 + A2 < B1 + B2\n\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "}"], ["proof (state)\nthis:\n  D + A2 < C + B2 \\<Longrightarrow> A1 + A2 < B1 + B2\n\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "{"], ["proof (state)\nthis:\n  D + A2 < C + B2 \\<Longrightarrow> A1 + A2 < B1 + B2\n\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "assume ab2: \"D + A2 = C + B2\""], ["proof (state)\nthis:\n  D + A2 = C + B2\n\ngoal (3 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba < b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 3. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "show \"A1 + A2 < B1 + B2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "have \"\\<And>m. C + A1 + m < D + B1 + m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m. C + A1 + m < D + B1 + m", "by (simp add: ab1 add.commute)"], ["proof (state)\nthis:\n  C + A1 + ?m < D + B1 + ?m\n\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "then"], ["proof (chain)\npicking this:\n  C + A1 + ?m < D + B1 + ?m", "have \"D + (A2 + A1) < D + (B1 + B2)\""], ["proof (prove)\nusing this:\n  C + A1 + ?m < D + B1 + ?m\n\ngoal (1 subgoal):\n 1. D + (A2 + A1) < D + (B1 + B2)", "by (metis (no_types) ab2 add.assoc add.commute)"], ["proof (state)\nthis:\n  D + (A2 + A1) < D + (B1 + B2)\n\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "then"], ["proof (chain)\npicking this:\n  D + (A2 + A1) < D + (B1 + B2)", "show ?thesis"], ["proof (prove)\nusing this:\n  D + (A2 + A1) < D + (B1 + B2)\n\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  A1 + A2 < B1 + B2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A1 + A2 < B1 + B2\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "}"], ["proof (state)\nthis:\n  D + A2 = C + B2 \\<Longrightarrow> A1 + A2 < B1 + B2\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "}"], ["proof (state)\nthis:\n  \\<lbrakk>A1 + C < B1 + D; D + A2 = C + B2\\<rbrakk>\n  \\<Longrightarrow> A1 + A2 < B1 + B2\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "{"], ["proof (state)\nthis:\n  \\<lbrakk>A1 + C < B1 + D; D + A2 = C + B2\\<rbrakk>\n  \\<Longrightarrow> A1 + A2 < B1 + B2\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "assume ab1: \"A1 + C = B1 + D\""], ["proof (state)\nthis:\n  A1 + C = B1 + D\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "{"], ["proof (state)\nthis:\n  A1 + C = B1 + D\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "assume ab2: \"D + A2 < C + B2\""], ["proof (state)\nthis:\n  D + A2 < C + B2\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb < ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "show \"A1 + A2 < B1 + B2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "have \"A1 + (D + A2) < B1 + (D + B2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A1 + (D + A2) < B1 + (D + B2)", "by (metis (no_types) ab1 ab2 add.assoc add_less_cancel_left)"], ["proof (state)\nthis:\n  A1 + (D + A2) < B1 + (D + B2)\n\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "then"], ["proof (chain)\npicking this:\n  A1 + (D + A2) < B1 + (D + B2)", "show ?thesis"], ["proof (prove)\nusing this:\n  A1 + (D + A2) < B1 + (D + B2)\n\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "by simp"], ["proof (state)\nthis:\n  A1 + A2 < B1 + B2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A1 + A2 < B1 + B2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "}"], ["proof (state)\nthis:\n  D + A2 < C + B2 \\<Longrightarrow> A1 + A2 < B1 + B2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "{"], ["proof (state)\nthis:\n  D + A2 < C + B2 \\<Longrightarrow> A1 + A2 < B1 + B2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "assume ab2: \"D + A2 = C + B2\""], ["proof (state)\nthis:\n  D + A2 = C + B2\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "have False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "by (metis (no_types) ab ab1 ab2 add.assoc add.commute add_diff_cancel_right')"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>a + bb \\<noteq> b + ab; a + ba = b + aa;\n        aa + bb = ba + ab\\<rbrakk>\n       \\<Longrightarrow> a + bb < b + ab", "thus \"A1 + A2 < B1 + B2\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. A1 + A2 < B1 + B2", "by sat"], ["proof (state)\nthis:\n  A1 + A2 < B1 + B2\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  D + A2 = C + B2 \\<Longrightarrow> A1 + A2 < B1 + B2\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>A1 + C = B1 + D; D + A2 = C + B2\\<rbrakk>\n  \\<Longrightarrow> A1 + A2 < B1 + B2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instance zmultiset :: (preorder) ordered_cancel_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a zmultiset, ordered_cancel_comm_monoid_add_class)", "by (intro_classes, unfold less_eq_zmultiset_def, transfer, auto simp: equiv_zmset_def)"], ["", "instance zmultiset :: (preorder) ordered_ab_group_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a zmultiset, ordered_ab_group_add_class)", "by (intro_classes; transfer; auto simp: equiv_zmset_def)"], ["", "instantiation zmultiset :: (linorder) distrib_lattice\nbegin"], ["", "definition inf_zmultiset :: \"'a zmultiset \\<Rightarrow> 'a zmultiset \\<Rightarrow> 'a zmultiset\" where\n  \"inf_zmultiset A B = (if A < B then A else B)\""], ["", "definition sup_zmultiset :: \"'a zmultiset \\<Rightarrow> 'a zmultiset \\<Rightarrow> 'a zmultiset\" where\n  \"sup_zmultiset A B = (if B > A then B else A)\""], ["", "lemma not_lt_iff_ge_zmset: \"\\<not> x < y \\<longleftrightarrow> x \\<ge> y\" for x y :: \"'a zmultiset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> x < y) = (y \\<le> x)", "by (unfold less_eq_zmultiset_def, transfer, auto simp: equiv_zmset_def algebra_simps)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a zmultiset, distrib_lattice_class)", "by intro_classes (auto simp: less_eq_zmultiset_def inf_zmultiset_def sup_zmultiset_def\n    dest!: not_lt_iff_ge_zmset[THEN iffD1])"], ["", "end"], ["", "lemma zmset_of_less: \"zmset_of M < zmset_of N \\<longleftrightarrow> M < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zmset_of M < zmset_of N) = (M < N)", "by (clarsimp simp: zmset_of_def, transfer, simp)+"], ["", "lemma zmset_of_le: \"zmset_of M \\<le> zmset_of N \\<longleftrightarrow> M \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zmset_of M \\<le> zmset_of N) = (M \\<le> N)", "by (simp_all add: less_eq_zmultiset_def zmset_of_def; transfer; auto simp: equiv_zmset_def)"], ["", "instance zmultiset :: (preorder) ordered_ab_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a zmultiset, ordered_ab_semigroup_add_class)", "by (intro_classes, unfold less_eq_zmultiset_def, transfer, auto simp: equiv_zmset_def)"], ["", "lemma uminus_add_conv_diff_mset[cancelation_simproc_pre]: \\<open>-a + b = b - a\\<close> for a :: \\<open>'a zmultiset\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. - a + b = b - a", "by (simp add: add.commute)"], ["", "lemma uminus_add_add_uminus[cancelation_simproc_pre]: \\<open>b -a + c = b + c - a\\<close> for a :: \\<open>'a zmultiset\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. b - a + c = b + c - a", "by (simp add: uminus_add_conv_diff_mset zmset_subset_eq_zmultiset_union_diff_commute)"], ["", "lemma add_zmset_eq_add_NO_MATCH[cancelation_simproc_pre]:\n  \\<open>NO_MATCH {#}\\<^sub>z H \\<Longrightarrow> add_zmset a H = {#a#}\\<^sub>z + H\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. NO_MATCH {#}\\<^sub>z H \\<Longrightarrow>\n    add_zmset a H = {#a#}\\<^sub>z + H", "by auto"], ["", "lemma repeat_zmset_iterate_add: \\<open>repeat_zmset n M = iterate_add n M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat_zmset n M = iterate_add n M", "unfolding iterate_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat_zmset n M = ((+) M ^^ n) {#}\\<^sub>z", "by (induction n) auto"], ["", "declare repeat_zmset_iterate_add[cancelation_simproc_pre]"], ["", "declare repeat_zmset_iterate_add[symmetric, cancelation_simproc_post]"], ["", "simproc_setup zmseteq_cancel_numerals\n  (\"(l::'a zmultiset) + m = n\" | \"(l::'a zmultiset) = m + n\" |\n   \"add_zmset a m = n\" | \"m = add_zmset a n\" |\n   \"replicate_zmset p a = n\" | \"m = replicate_zmset p a\" |\n   \"repeat_zmset p m = n\" | \"m = repeat_zmset p m\") =\n  \\<open>fn phi => Cancel_Simprocs.eq_cancel\\<close>"], ["", "lemma zmset_subseteq_add_iff1:\n  \\<open>j \\<le> i \\<Longrightarrow> (repeat_zmset i u + m \\<subseteq>#\\<^sub>z repeat_zmset j u + n) = (repeat_zmset (i - j) u + m \\<subseteq>#\\<^sub>z n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> i \\<Longrightarrow>\n    (repeat_zmset i u + m \\<subseteq>#\\<^sub>z repeat_zmset j u + n) =\n    (repeat_zmset (i - j) u + m \\<subseteq>#\\<^sub>z n)", "by (simp add: add.commute add_diff_eq left_diff_repeat_zmset_distrib' subset_eq_diff_conv_zmset)"], ["", "lemma zmset_subseteq_add_iff2:\n  \\<open>i \\<le> j \\<Longrightarrow> (repeat_zmset i u + m \\<subseteq>#\\<^sub>z repeat_zmset j u + n) = (m \\<subseteq>#\\<^sub>z repeat_zmset (j - i) u + n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    (repeat_zmset i u + m \\<subseteq>#\\<^sub>z repeat_zmset j u + n) =\n    (m \\<subseteq>#\\<^sub>z repeat_zmset (j - i) u + n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    (repeat_zmset i u + m \\<subseteq>#\\<^sub>z repeat_zmset j u + n) =\n    (m \\<subseteq>#\\<^sub>z repeat_zmset (j - i) u + n)", "assume \"i \\<le> j\""], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    (repeat_zmset i u + m \\<subseteq>#\\<^sub>z repeat_zmset j u + n) =\n    (m \\<subseteq>#\\<^sub>z repeat_zmset (j - i) u + n)", "then"], ["proof (chain)\npicking this:\n  i \\<le> j", "have \"\\<And>z. repeat_zmset j (z::'a zmultiset) - repeat_zmset i z = repeat_zmset (j - i) z\""], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>z. repeat_zmset j z - repeat_zmset i z = repeat_zmset (j - i) z", "by (simp add: left_diff_repeat_zmset_distrib')"], ["proof (state)\nthis:\n  repeat_zmset j ?z - repeat_zmset i ?z = repeat_zmset (j - i) ?z\n\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    (repeat_zmset i u + m \\<subseteq>#\\<^sub>z repeat_zmset j u + n) =\n    (m \\<subseteq>#\\<^sub>z repeat_zmset (j - i) u + n)", "then"], ["proof (chain)\npicking this:\n  repeat_zmset j ?z - repeat_zmset i ?z = repeat_zmset (j - i) ?z", "show ?thesis"], ["proof (prove)\nusing this:\n  repeat_zmset j ?z - repeat_zmset i ?z = repeat_zmset (j - i) ?z\n\ngoal (1 subgoal):\n 1. (repeat_zmset i u + m \\<subseteq>#\\<^sub>z repeat_zmset j u + n) =\n    (m \\<subseteq>#\\<^sub>z repeat_zmset (j - i) u + n)", "by (metis add.commute diff_diff_eq2 subset_eq_diff_conv_zmset)"], ["proof (state)\nthis:\n  (repeat_zmset i u + m \\<subseteq>#\\<^sub>z repeat_zmset j u + n) =\n  (m \\<subseteq>#\\<^sub>z repeat_zmset (j - i) u + n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zmset_subset_add_iff1:\n  \\<open>j \\<le> i \\<Longrightarrow> (repeat_zmset i u + m \\<subset>#\\<^sub>z repeat_zmset j u + n) = (repeat_zmset (i - j) u + m \\<subset>#\\<^sub>z n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> i \\<Longrightarrow>\n    (repeat_zmset i u + m \\<subset>#\\<^sub>z repeat_zmset j u + n) =\n    (repeat_zmset (i - j) u + m \\<subset>#\\<^sub>z n)", "by (simp add: subset_zmset.less_le_not_le zmset_subseteq_add_iff1 zmset_subseteq_add_iff2)"], ["", "lemma zmset_subset_add_iff2:\n  \\<open>i \\<le> j \\<Longrightarrow> (repeat_zmset i u + m \\<subset>#\\<^sub>z repeat_zmset j u + n) = (m \\<subset>#\\<^sub>z repeat_zmset (j - i) u + n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    (repeat_zmset i u + m \\<subset>#\\<^sub>z repeat_zmset j u + n) =\n    (m \\<subset>#\\<^sub>z repeat_zmset (j - i) u + n)", "by (simp add: subset_zmset.less_le_not_le zmset_subseteq_add_iff1 zmset_subseteq_add_iff2)"], ["", "ML_file \\<open>zmultiset_simprocs.ML\\<close>"], ["", "simproc_setup zmsetsubset_cancel\n  (\"(l::'a zmultiset) + m \\<subset>#\\<^sub>z n\" | \"(l::'a zmultiset) \\<subset>#\\<^sub>z m + n\" |\n   \"add_zmset a m \\<subset>#\\<^sub>z n\" | \"m \\<subset>#\\<^sub>z add_zmset a n\" |\n   \"replicate_zmset p a \\<subset>#\\<^sub>z n\" | \"m \\<subset>#\\<^sub>z replicate_zmset p a\" |\n   \"repeat_zmset p m \\<subset>#\\<^sub>z n\" | \"m \\<subset>#\\<^sub>z repeat_zmset p m\") =\n  \\<open>fn phi => ZMultiset_Simprocs.subset_cancel_zmsets\\<close>"], ["", "simproc_setup zmsetsubseteq_cancel\n  (\"(l::'a zmultiset) + m \\<subseteq>#\\<^sub>z n\" | \"(l::'a zmultiset) \\<subseteq>#\\<^sub>z m + n\" |\n   \"add_zmset a m \\<subseteq>#\\<^sub>z n\" | \"m \\<subseteq>#\\<^sub>z add_zmset a n\" |\n   \"replicate_zmset p a \\<subseteq>#\\<^sub>z n\" | \"m \\<subseteq>#\\<^sub>z replicate_zmset p a\" |\n   \"repeat_zmset p m \\<subseteq>#\\<^sub>z n\" | \"m \\<subseteq>#\\<^sub>z repeat_zmset p m\") =\n  \\<open>fn phi => ZMultiset_Simprocs.subseteq_cancel_zmsets\\<close>"], ["", "instance zmultiset :: (preorder) ordered_ab_semigroup_add_imp_le"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a zmultiset, ordered_ab_semigroup_add_imp_le_class)", "by (intro_classes; unfold less_eq_zmultiset_def; transfer; auto)"], ["", "simproc_setup zmsetless_cancel\n  (\"(l::'a::preorder zmultiset) + m < n\" | \"(l::'a zmultiset) < m + n\" |\n   \"add_zmset a m < n\" | \"m < add_zmset a n\" |\n   \"replicate_zmset p a < n\" | \"m < replicate_zmset p a\" |\n   \"repeat_zmset p m < n\" | \"m < repeat_zmset p m\") =\n  \\<open>fn phi => Cancel_Simprocs.less_cancel\\<close>"], ["", "simproc_setup zmsetless_eq_cancel\n  (\"(l::'a::preorder zmultiset) + m \\<le> n\" | \"(l::'a zmultiset) \\<le> m + n\" |\n   \"add_zmset a m \\<le> n\" | \"m \\<le> add_zmset a n\" |\n   \"replicate_zmset p a \\<le> n\" | \"m \\<le> replicate_zmset p a\" |\n   \"repeat_zmset p m \\<le> n\" | \"m \\<le> repeat_zmset p m\") =\n  \\<open>fn phi => Cancel_Simprocs.less_eq_cancel\\<close>"], ["", "simproc_setup zmsetdiff_cancel\n  (\"n + (l::'a zmultiset)\" | \"(l::'a zmultiset) - m\" |\n   \"add_zmset a m - n\" | \"m - add_zmset a n\" |\n   \"replicate_zmset p r - n\" | \"m - replicate_zmset p r\" |\n   \"repeat_zmset p m - n\" | \"m - repeat_zmset p m\") =\n  \\<open>fn phi => Cancel_Simprocs.diff_cancel\\<close>"], ["", "instance zmultiset :: (linorder) linordered_cancel_ab_semigroup_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a zmultiset, linordered_cancel_ab_semigroup_add_class)", "by (intro_classes, unfold less_eq_zmultiset_def, transfer, auto simp: equiv_zmset_def add.commute)"], ["", "lemma less_mset_zmsetE:\n  assumes \"M < N\"\n  obtains A B C where\n    \"M = zmset_of A + C\" and \"N = zmset_of B + C\" and \"A < B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C; A < B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add_less_imp_less_right assms decompose_zmset_of2 zmset_of_less)"], ["", "lemma less_eq_mset_zmsetE:\n  assumes \"M \\<le> N\"\n  obtains A B C where\n    \"M = zmset_of A + C\" and \"N = zmset_of B + C\" and \"A \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A C B.\n        \\<lbrakk>M = zmset_of A + C; N = zmset_of B + C; A \\<le> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis add.commute add.right_neutral assms le_neq_trans less_imp_le less_mset_zmsetE order_refl\n    zmset_of_empty)"], ["", "lemma subset_eq_imp_le_zmset: \"M \\<subseteq>#\\<^sub>z N \\<Longrightarrow> M \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<subseteq>#\\<^sub>z N \\<Longrightarrow> M \\<le> N", "by (metis (no_types) add_mono_thms_linordered_semiring(3) subset_eq_imp_le_multiset\n    subseteq_mset_zmsetE zmset_of_le)"], ["", "lemma subset_imp_less_zmset: \"M \\<subset>#\\<^sub>z N \\<Longrightarrow> M < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<subset>#\\<^sub>z N \\<Longrightarrow> M < N", "by (metis le_neq_trans subset_eq_imp_le_zmset subset_zmset_def)"], ["", "lemma lt_imp_ex_zcount_lt:\n  assumes m_lt_n: \"M < N\"\n  shows \"\\<exists>y. zcount M y < zcount N y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. zcount M y < zcount N y", "proof (rule ccontr, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<not> zcount M y < zcount N y \\<Longrightarrow> False", "assume \"\\<forall>y. \\<not> zcount M y < zcount N y\""], ["proof (state)\nthis:\n  \\<forall>y. \\<not> zcount M y < zcount N y\n\ngoal (1 subgoal):\n 1. \\<forall>y. \\<not> zcount M y < zcount N y \\<Longrightarrow> False", "hence \"\\<forall>y. zcount M y \\<ge> zcount N y\""], ["proof (prove)\nusing this:\n  \\<forall>y. \\<not> zcount M y < zcount N y\n\ngoal (1 subgoal):\n 1. \\<forall>y. zcount N y \\<le> zcount M y", "by (simp add: leI)"], ["proof (state)\nthis:\n  \\<forall>y. zcount N y \\<le> zcount M y\n\ngoal (1 subgoal):\n 1. \\<forall>y. \\<not> zcount M y < zcount N y \\<Longrightarrow> False", "hence \"M \\<supseteq>#\\<^sub>z N\""], ["proof (prove)\nusing this:\n  \\<forall>y. zcount N y \\<le> zcount M y\n\ngoal (1 subgoal):\n 1. N \\<subseteq>#\\<^sub>z M", "by (simp add: zmset_subset_eqI)"], ["proof (state)\nthis:\n  N \\<subseteq>#\\<^sub>z M\n\ngoal (1 subgoal):\n 1. \\<forall>y. \\<not> zcount M y < zcount N y \\<Longrightarrow> False", "hence \"M \\<ge> N\""], ["proof (prove)\nusing this:\n  N \\<subseteq>#\\<^sub>z M\n\ngoal (1 subgoal):\n 1. N \\<le> M", "by (simp add: subset_eq_imp_le_zmset)"], ["proof (state)\nthis:\n  N \\<le> M\n\ngoal (1 subgoal):\n 1. \\<forall>y. \\<not> zcount M y < zcount N y \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  N \\<le> M\n\ngoal (1 subgoal):\n 1. False", "using m_lt_n"], ["proof (prove)\nusing this:\n  N \\<le> M\n  M < N\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "instance zmultiset :: (preorder) no_top"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a zmultiset, no_top_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>y. x < y", "fix M :: \\<open>'a zmultiset\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>y. x < y", "obtain a :: 'a where True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (True \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fast"], ["proof (state)\nthis:\n  True\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>y. x < y", "let ?M = \\<open>zmset_of (mset_pos M) + zmset_of (mset_neg M)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>y. x < y", "have \\<open>M < add_zmset a ?M + ?M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. M < add_zmset a (zmset_of (mset_pos M) + zmset_of (mset_neg M)) +\n        (zmset_of (mset_pos M) + zmset_of (mset_neg M))", "by (subst mset_pos_neg_partition)\n      (auto simp: subset_zmset_def subseteq_zmset_def zmultiset_eq_iff\n        intro!: subset_imp_less_zmset)"], ["proof (state)\nthis:\n  M < add_zmset a (zmset_of (mset_pos M) + zmset_of (mset_neg M)) +\n      (zmset_of (mset_pos M) + zmset_of (mset_neg M))\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>y. x < y", "then"], ["proof (chain)\npicking this:\n  M < add_zmset a (zmset_of (mset_pos M) + zmset_of (mset_neg M)) +\n      (zmset_of (mset_pos M) + zmset_of (mset_neg M))", "show \\<open>\\<exists>N. M < N\\<close>"], ["proof (prove)\nusing this:\n  M < add_zmset a (zmset_of (mset_pos M) + zmset_of (mset_neg M)) +\n      (zmset_of (mset_pos M) + zmset_of (mset_neg M))\n\ngoal (1 subgoal):\n 1. \\<exists>N. M < N", "by blast"], ["proof (state)\nthis:\n  \\<exists>N. M < N\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}