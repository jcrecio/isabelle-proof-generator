{"file_name": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals/Multiset_More.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals", "problem_names": ["lemma subset_mset_imp_subset_add_mset: \"A \\<subseteq># B \\<Longrightarrow> A \\<subseteq># add_mset x B\"", "lemma subset_add_mset_notin_subset_mset: \\<open>A \\<subseteq># add_mset b B \\<Longrightarrow> b \\<notin># A \\<Longrightarrow> A \\<subseteq># B\\<close>", "lemma subset_msetE: \"\\<lbrakk>A \\<subset># B; \\<lbrakk>A \\<subseteq># B; \\<not> B \\<subseteq># A\\<rbrakk> \\<Longrightarrow> R\\<rbrakk> \\<Longrightarrow> R\"", "lemma Diff_triv_mset: \"M \\<inter># N = {#} \\<Longrightarrow> M - N = M\"", "lemma diff_intersect_sym_diff: \"(A - B) \\<inter># (B - A) = {#}\"", "lemma subseq_mset_subseteq_mset: \"subseq xs ys \\<Longrightarrow> mset xs \\<subseteq># mset ys\"", "lemma count_image_mset_ge_count: \"count (image_mset f A) (f b) \\<ge> count A b\"", "lemma count_image_mset_inj:\n  assumes \\<open>inj f\\<close>\n  shows \\<open>count (image_mset f M) (f x) = count M x\\<close>", "lemma count_image_mset_le_count_inj_on:\n  \"inj_on f (set_mset M) \\<Longrightarrow> count (image_mset f M) y \\<le> count M (inv_into (set_mset M) f y)\"", "lemma mset_filter_compl: \"mset (filter p xs) + mset (filter (Not \\<circ> p) xs) = mset xs\"", "lemma filter_mset_eq: \"filter_mset ((=) L) A = replicate_mset (count A L) L\"", "lemma filter_mset_cong[fundef_cong]:\n  assumes \"M = M'\" \"\\<And>a. a \\<in># M \\<Longrightarrow> P a = Q a\"\n  shows \"filter_mset P M = filter_mset Q M\"", "lemma image_mset_filter_swap: \"image_mset f {# x \\<in># M. P (f x)#} = {# x \\<in># image_mset f M. P x#}\"", "lemma image_mset_cong2:\n  \"(\\<And>x. x \\<in># M \\<Longrightarrow> f x = g x) \\<Longrightarrow> M = N \\<Longrightarrow> image_mset f M = image_mset g N\"", "lemma filter_mset_empty_conv: \\<open>(filter_mset P M = {#}) = (\\<forall>L\\<in>#M. \\<not> P L)\\<close>", "lemma multiset_filter_mono2: \\<open>filter_mset P A \\<subseteq># filter_mset Q A \\<longleftrightarrow> (\\<forall>a\\<in>#A. P a \\<longrightarrow> Q a)\\<close>", "lemma image_filter_cong:\n  assumes \\<open>\\<And>C. C \\<in># M \\<Longrightarrow> P C \\<Longrightarrow> f C = g C\\<close>\n  shows \\<open>{#f C. C \\<in># {#C \\<in># M. P C#}#} = {#g C | C\\<in># M. P C#}\\<close>", "lemma image_mset_filter_swap2: \\<open>{#C \\<in># {#P x. x \\<in># D#}. Q C #} = {#P x. x \\<in># {#C| C \\<in># D. Q (P C)#}#}\\<close>", "lemma filter_mset_empty_if_finite_and_filter_set_empty:\n  assumes\n    \"{x \\<in> X. P x} = {}\" and\n    \"finite X\"\n  shows \"{#x \\<in># mset_set X. P x#} = {#}\"", "lemma sum_image_mset_sum_map[simp]: \"sum_mset (image_mset f (mset xs)) = sum_list (map f xs)\"", "lemma sum_image_mset_mono:\n  fixes f :: \"'a \\<Rightarrow> 'b::canonically_ordered_monoid_add\"\n  assumes sub: \"A \\<subseteq># B\"\n  shows \"(\\<Sum>m \\<in># A. f m) \\<le> (\\<Sum>m \\<in># B. f m)\"", "lemma sum_image_mset_mono_mem:\n  \"n \\<in># M \\<Longrightarrow> f n \\<le> (\\<Sum>m \\<in># M. f m)\" for f :: \"'a \\<Rightarrow> 'b::canonically_ordered_monoid_add\"", "lemma count_sum_mset_if_1_0: \\<open>count M a = (\\<Sum>x\\<in>#M. if x = a then 1 else 0)\\<close>", "lemma sum_mset_dvd:\n  fixes k :: \"'a::comm_semiring_1_cancel\"\n  assumes \"\\<forall>m \\<in># M. k dvd f m\"\n  shows \"k dvd (\\<Sum>m \\<in># M. f m)\"", "lemma sum_mset_distrib_div_if_dvd:\n  fixes k :: \"'a::unique_euclidean_semiring\"\n  assumes \"\\<forall>m \\<in># M. k dvd f m\"\n  shows \"(\\<Sum>m \\<in># M. f m) div k = (\\<Sum>m \\<in># M. f m div k)\"", "lemma set_mset_minus_replicate_mset[simp]:\n  \"n \\<ge> count A a \\<Longrightarrow> set_mset (A - replicate_mset n a) = set_mset A - {a}\"\n  \"n < count A a \\<Longrightarrow> set_mset (A - replicate_mset n a) = set_mset A\"", "lemma mset_removeAll[simp, code]: \"removeAll_mset C (mset L) = mset (removeAll C L)\"", "lemma removeAll_mset_filter_mset: \"removeAll_mset C M = filter_mset ((\\<noteq>) C) M\"", "lemma removeAll_subseteq_remove1_mset: \"removeAll_mset x M \\<subseteq># remove1_mset x M\"", "lemma in_remove1_mset_neq:\n  assumes ab: \"a \\<noteq> b\"\n  shows \"a \\<in># remove1_mset b C \\<longleftrightarrow> a \\<in># C\"", "lemma size_mset_removeAll_mset_le_iff: \"size (removeAll_mset x M) < size M \\<longleftrightarrow> x \\<in># M\"", "lemma size_remove1_mset_If: \\<open>size (remove1_mset x M) = size M - (if x \\<in># M then 1 else 0)\\<close>", "lemma size_mset_remove1_mset_le_iff: \"size (remove1_mset x M) < size M \\<longleftrightarrow> x \\<in># M\"", "lemma remove_1_mset_id_iff_notin: \"remove1_mset a M = M \\<longleftrightarrow> a \\<notin># M\"", "lemma id_remove_1_mset_iff_notin: \"M = remove1_mset a M \\<longleftrightarrow> a \\<notin># M\"", "lemma remove1_mset_eqE:\n  \"remove1_mset L x1 = M \\<Longrightarrow>\n    (L \\<in># x1 \\<Longrightarrow> x1 = M + {#L#} \\<Longrightarrow> P) \\<Longrightarrow>\n    (L \\<notin># x1 \\<Longrightarrow> x1 = M \\<Longrightarrow> P) \\<Longrightarrow>\n  P\"", "lemma image_filter_ne_mset[simp]:\n  \"image_mset f {#x \\<in># M. f x \\<noteq> y#} = removeAll_mset y (image_mset f M)\"", "lemma image_mset_remove1_mset_if:\n  \"image_mset f (remove1_mset a M) =\n   (if a \\<in># M then remove1_mset (f a) (image_mset f M) else image_mset f M)\"", "lemma filter_mset_neq: \"{#x \\<in># M. x \\<noteq> y#} = removeAll_mset y M\"", "lemma filter_mset_neq_cond: \"{#x \\<in># M. P x \\<and> x \\<noteq> y#} = removeAll_mset y {# x\\<in>#M. P x#}\"", "lemma remove1_mset_add_mset_If:\n  \"remove1_mset L (add_mset L' C) = (if L = L' then C else remove1_mset L C + {#L'#})\"", "lemma minus_remove1_mset_if:\n  \"A - remove1_mset b B = (if b \\<in># B \\<and> b \\<in># A \\<and> count A b \\<ge> count B b then {#b#} + (A - B) else A - B)\"", "lemma add_mset_eq_add_mset_ne:\n  \"a \\<noteq> b \\<Longrightarrow> add_mset a A = add_mset b B \\<longleftrightarrow> a \\<in># B \\<and> b \\<in># A \\<and> A = add_mset b (B - {#a#})\"", "lemma add_mset_eq_add_mset: \\<open>add_mset a M = add_mset b M' \\<longleftrightarrow>\n  (a = b \\<and> M = M') \\<or> (a \\<noteq> b \\<and> b \\<in># M \\<and> add_mset a (M - {#b#}) = M')\\<close>", "lemma add_mset_remove_trivial_iff: \\<open>N = add_mset a (N - {#b#}) \\<longleftrightarrow> a \\<in># N \\<and> a = b\\<close>", "lemma trivial_add_mset_remove_iff: \\<open>add_mset a (N - {#b#}) = N \\<longleftrightarrow> a \\<in># N \\<and> a = b\\<close>", "lemma remove1_single_empty_iff[simp]: \\<open>remove1_mset L {#L'#} = {#} \\<longleftrightarrow> L = L'\\<close>", "lemma add_mset_less_imp_less_remove1_mset:\n  assumes xM_lt_N: \"add_mset x M < N\"\n  shows \"M < remove1_mset x N\"", "lemma replicate_mset_minus_replicate_mset_same[simp]:\n  \"replicate_mset m x - replicate_mset n x = replicate_mset (m - n) x\"", "lemma replicate_mset_subset_iff_lt[simp]: \"replicate_mset m x \\<subset># replicate_mset n x \\<longleftrightarrow> m < n\"", "lemma replicate_mset_subseteq_iff_le[simp]: \"replicate_mset m x \\<subseteq># replicate_mset n x \\<longleftrightarrow> m \\<le> n\"", "lemma replicate_mset_lt_iff_lt[simp]: \"replicate_mset m x < replicate_mset n x \\<longleftrightarrow> m < n\"", "lemma replicate_mset_le_iff_le[simp]: \"replicate_mset m x \\<le> replicate_mset n x \\<longleftrightarrow> m \\<le> n\"", "lemma replicate_mset_eq_iff[simp]:\n  \"replicate_mset m x = replicate_mset n y \\<longleftrightarrow> m = n \\<and> (m \\<noteq> 0 \\<longrightarrow> x = y)\"", "lemma replicate_mset_plus: \"replicate_mset (a + b) C = replicate_mset a C + replicate_mset b C\"", "lemma mset_replicate_replicate_mset: \"mset (replicate n L) = replicate_mset n L\"", "lemma set_mset_single_iff_replicate_mset: \"set_mset U = {a} \\<longleftrightarrow> (\\<exists>n > 0. U = replicate_mset n a)\"", "lemma ex_replicate_mset_if_all_elems_eq:\n  assumes \"\\<forall>x \\<in># M. x = y\"\n  shows \"\\<exists>n. M = replicate_mset n y\"", "lemma count_mset_set_if: \"count (mset_set A) a = (if a \\<in> A \\<and> finite A then 1 else 0)\"", "lemma mset_set_set_mset_empty_mempty[iff]: \"mset_set (set_mset D) = {#} \\<longleftrightarrow> D = {#}\"", "lemma count_mset_set_le_one: \"count (mset_set A) x \\<le> 1\"", "lemma mset_set_set_mset_subseteq[simp]: \"mset_set (set_mset A) \\<subseteq># A\"", "lemma mset_sorted_list_of_set[simp]: \"mset (sorted_list_of_set A) = mset_set A\"", "lemma sorted_sorted_list_of_multiset[simp]:\n  \"sorted (sorted_list_of_multiset (M :: 'a::linorder multiset))\"", "lemma mset_take_subseteq: \"mset (take n xs) \\<subseteq># mset xs\"", "lemma sorted_list_of_multiset_eq_Nil[simp]: \"sorted_list_of_multiset M = [] \\<longleftrightarrow> M = {#}\"", "lemma set_mset_remdups_mset[simp]: \\<open>set_mset (remdups_mset A) = set_mset A\\<close>", "lemma count_remdups_mset_eq_1: \"a \\<in># remdups_mset A \\<longleftrightarrow> count (remdups_mset A) a = 1\"", "lemma remdups_mset_empty[simp]: \"remdups_mset {#} = {#}\"", "lemma remdups_mset_singleton[simp]: \"remdups_mset {#a#} = {#a#}\"", "lemma remdups_mset_eq_empty[iff]: \"remdups_mset D = {#} \\<longleftrightarrow> D = {#}\"", "lemma remdups_mset_singleton_sum[simp]:\n  \"remdups_mset (add_mset a A) = (if a \\<in># A then remdups_mset A else add_mset a (remdups_mset A))\"", "lemma mset_remdups_remdups_mset[simp]: \"mset (remdups D) = remdups_mset (mset D)\"", "lemma distinct_mset_count_less_1: \"distinct_mset S \\<longleftrightarrow> (\\<forall>a. count S a \\<le> 1)\"", "lemma distinct_mset_empty[simp]: \"distinct_mset {#}\"", "lemma distinct_mset_singleton: \"distinct_mset {#a#}\"", "lemma distinct_mset_union:\n  assumes dist: \"distinct_mset (A + B)\"\n  shows \"distinct_mset A\"", "lemma distinct_mset_minus[simp]: \"distinct_mset A \\<Longrightarrow> distinct_mset (A - B)\"", "lemma count_remdups_mset_If: \\<open>count (remdups_mset A) a = (if a \\<in># A then 1 else 0)\\<close>", "lemma distinct_mset_rempdups_union_mset:\n  assumes \"distinct_mset A\" and \"distinct_mset B\"\n  shows \"A \\<union># B = remdups_mset (A + B)\"", "lemma distinct_mset_add_mset[simp]: \"distinct_mset (add_mset a L) \\<longleftrightarrow> a \\<notin># L \\<and> distinct_mset L\"", "lemma distinct_mset_size_eq_card: \"distinct_mset C \\<Longrightarrow> size C = card (set_mset C)\"", "lemma distinct_mset_add:\n  \"distinct_mset (L + L') \\<longleftrightarrow> distinct_mset L \\<and> distinct_mset L' \\<and> L \\<inter># L' = {#}\"", "lemma distinct_mset_set_mset_ident[simp]: \"distinct_mset M \\<Longrightarrow> mset_set (set_mset M) = M\"", "lemma distinct_finite_set_mset_subseteq_iff[iff]:\n  assumes \"distinct_mset M\" \"finite N\"\n  shows \"set_mset M \\<subseteq> N \\<longleftrightarrow> M \\<subseteq># mset_set N\"", "lemma distinct_mem_diff_mset:\n  assumes dist: \"distinct_mset M\" and mem: \"x \\<in> set_mset (M - N)\"\n  shows \"x \\<notin> set_mset N\"", "lemma distinct_set_mset_eq:\n  assumes \"distinct_mset M\" \"distinct_mset N\" \"set_mset M = set_mset N\"\n  shows \"M = N\"", "lemma distinct_mset_union_mset[simp]:\n  \\<open>distinct_mset (D \\<union># C) \\<longleftrightarrow> distinct_mset D \\<and> distinct_mset C\\<close>", "lemma distinct_mset_inter_mset:\n  \"distinct_mset C \\<Longrightarrow> distinct_mset (C \\<inter># D)\"\n  \"distinct_mset D \\<Longrightarrow> distinct_mset (C \\<inter># D)\"", "lemma distinct_mset_remove1_All: \"distinct_mset C \\<Longrightarrow> remove1_mset L C = removeAll_mset L C\"", "lemma distinct_mset_size_2: \"distinct_mset {#a, b#} \\<longleftrightarrow> a \\<noteq> b\"", "lemma distinct_mset_filter: \"distinct_mset M \\<Longrightarrow> distinct_mset {# L \\<in># M. P L#}\"", "lemma distinct_mset_mset_distinct[simp]: \\<open>distinct_mset (mset xs) = distinct xs\\<close>", "lemma distinct_image_mset_inj:\n  \\<open>inj_on f (set_mset M) \\<Longrightarrow> distinct_mset (image_mset f M) \\<longleftrightarrow> distinct_mset M\\<close>", "lemma repeat_mset_compower: \"repeat_mset n A = (((+) A) ^^ n) {#}\"", "lemma repeat_mset_prod: \"repeat_mset (m * n) A = (((+) (repeat_mset n A)) ^^ m) {#}\"", "lemma Times_mset_Times: \"set_mset (A \\<times># B) = set_mset A \\<times> set_mset B\"", "lemma Sigma_msetI [intro!]: \"\\<lbrakk>a \\<in># A; b \\<in># B a\\<rbrakk> \\<Longrightarrow> (a, b) \\<in># Sigma_mset A B\"", "lemma Sigma_msetE[elim!]: \"\\<lbrakk>c \\<in># Sigma_mset A B; \\<And>x y. \\<lbrakk>x \\<in># A; y \\<in># B x; c = (x, y)\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma Sigma_msetD1: \"(a, b) \\<in># Sigma_mset A B \\<Longrightarrow> a \\<in># A\"", "lemma Sigma_msetD2: \"(a, b) \\<in># Sigma_mset A B \\<Longrightarrow> b \\<in># B a\"", "lemma Sigma_msetE2: \"\\<lbrakk>(a, b) \\<in># Sigma_mset A B; \\<lbrakk>a \\<in># A; b \\<in># B a\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\"", "lemma Sigma_mset_cong:\n  \"\\<lbrakk>A = B; \\<And>x. x \\<in># B \\<Longrightarrow> C x = D x\\<rbrakk> \\<Longrightarrow> (SIGMAMSET x \\<in># A. C x) = (SIGMAMSET x \\<in># B. D x)\"", "lemma count_sum_mset: \"count (\\<Sum>\\<^sub># M) b = (\\<Sum>P \\<in># M. count P b)\"", "lemma Sigma_mset_plus_distrib1[simp]: \"Sigma_mset (A + B) C = Sigma_mset A C + Sigma_mset B C\"", "lemma Sigma_mset_plus_distrib2[simp]:\n  \"Sigma_mset A (\\<lambda>i. B i + C i) = Sigma_mset A B + Sigma_mset A C\"", "lemma Times_mset_single_left: \"{#a#} \\<times># B = image_mset (Pair a) B\"", "lemma Times_mset_single_right: \"A \\<times># {#b#} = image_mset (\\<lambda>a. Pair a b) A\"", "lemma Times_mset_single_single[simp]: \"{#a#} \\<times># {#b#} = {#(a, b)#}\"", "lemma count_image_mset_Pair:\n  \"count (image_mset (Pair a) B) (x, b) = (if x = a then count B b else 0)\"", "lemma count_Sigma_mset: \"count (Sigma_mset A B) (a, b) = count A a * count (B a) b\"", "lemma Sigma_mset_empty1[simp]: \"Sigma_mset {#} B = {#}\"", "lemma Sigma_mset_empty2[simp]: \"A \\<times># {#} = {#}\"", "lemma Sigma_mset_mono:\n  assumes \"A \\<subseteq># C\" and \"\\<And>x. x \\<in># A \\<Longrightarrow> B x \\<subseteq># D x\"\n  shows \"Sigma_mset A B \\<subseteq># Sigma_mset C D\"", "lemma mem_Sigma_mset_iff[iff]: \"((a,b) \\<in># Sigma_mset A B) = (a \\<in># A \\<and> b \\<in># B a)\"", "lemma mem_Times_mset_iff: \"x \\<in># A \\<times># B \\<longleftrightarrow> fst x \\<in># A \\<and> snd x \\<in># B\"", "lemma Sigma_mset_empty_iff: \"(SIGMAMSET i\\<in>#I. X i) = {#} \\<longleftrightarrow> (\\<forall>i\\<in>#I. X i = {#})\"", "lemma Times_mset_subset_mset_cancel1: \"x \\<in># A \\<Longrightarrow> (A \\<times># B \\<subseteq># A \\<times># C) = (B \\<subseteq># C)\"", "lemma Times_mset_subset_mset_cancel2: \"x \\<in># C \\<Longrightarrow> (A \\<times># C \\<subseteq># B \\<times># C) = (A \\<subseteq># B)\"", "lemma Times_mset_eq_cancel2: \"x \\<in># C \\<Longrightarrow> (A \\<times># C = B \\<times># C) = (A = B)\"", "lemma split_paired_Ball_mset_Sigma_mset[simp]:\n  \"(\\<forall>z\\<in>#Sigma_mset A B. P z) \\<longleftrightarrow> (\\<forall>x\\<in>#A. \\<forall>y\\<in>#B x. P (x, y))\"", "lemma split_paired_Bex_mset_Sigma_mset[simp]:\n  \"(\\<exists>z\\<in>#Sigma_mset A B. P z) \\<longleftrightarrow> (\\<exists>x\\<in>#A. \\<exists>y\\<in>#B x. P (x, y))\"", "lemma sum_mset_if_eq_constant:\n  \"(\\<Sum>x\\<in>#M. if a = x then (f x) else 0) = (((+) (f a)) ^^ (count M a)) 0\"", "lemma iterate_op_plus: \"(((+) k) ^^ m) 0 = k * m\"", "lemma untion_image_mset_Pair_distribute:\n  \"\\<Sum>\\<^sub>#{#image_mset (Pair x) (C x). x \\<in># J - I#} =\n   \\<Sum>\\<^sub># {#image_mset (Pair x) (C x). x \\<in># J#} - \\<Sum>\\<^sub>#{#image_mset (Pair x) (C x). x \\<in># I#}\"", "lemma Sigma_mset_Un_distrib1: \"Sigma_mset (I \\<union># J) C = Sigma_mset I C \\<union># Sigma_mset J C\"", "lemma Sigma_mset_Un_distrib2: \"(SIGMAMSET i\\<in>#I. A i \\<union># B i) = Sigma_mset I A \\<union># Sigma_mset I B\"", "lemma Sigma_mset_Int_distrib1: \"Sigma_mset (I \\<inter># J) C = Sigma_mset I C \\<inter># Sigma_mset J C\"", "lemma Sigma_mset_Int_distrib2: \"(SIGMAMSET i\\<in>#I. A i \\<inter># B i) = Sigma_mset I A \\<inter># Sigma_mset I B\"", "lemma Sigma_mset_Diff_distrib1: \"Sigma_mset (I - J) C = Sigma_mset I C - Sigma_mset J C\"", "lemma Sigma_mset_Diff_distrib2: \"(SIGMAMSET i\\<in>#I. A i - B i) = Sigma_mset I A - Sigma_mset I B\"", "lemma Sigma_mset_Union: \"Sigma_mset (\\<Sum>\\<^sub>#X) B = (\\<Sum>\\<^sub># (image_mset (\\<lambda>A. Sigma_mset A B) X))\"", "lemma Times_mset_Un_distrib1: \"(A \\<union># B) \\<times># C = A \\<times># C \\<union># B \\<times># C\"", "lemma Times_mset_Int_distrib1: \"(A \\<inter># B) \\<times># C = A \\<times># C \\<inter># B \\<times># C\"", "lemma Times_mset_Diff_distrib1: \"(A - B) \\<times># C = A \\<times># C - B \\<times># C\"", "lemma Times_mset_empty[simp]: \"A \\<times># B = {#} \\<longleftrightarrow> A = {#} \\<or> B = {#}\"", "lemma Times_insert_left: \"A \\<times># add_mset x B = A \\<times># B + image_mset (\\<lambda>a. Pair a x) A\"", "lemma Times_insert_right: \"add_mset a A \\<times># B = A \\<times># B + image_mset (Pair a) B\"", "lemma fst_image_mset_times_mset [simp]:\n  \"image_mset fst (A \\<times># B) = (if B = {#} then {#} else repeat_mset (size B) A)\"", "lemma snd_image_mset_times_mset [simp]:\n  \"image_mset snd (A \\<times># B) = (if A = {#} then {#} else repeat_mset (size A) B)\"", "lemma product_swap_mset: \"image_mset prod.swap (A \\<times># B) = B \\<times># A\"", "lemma member_product_mset: \"x \\<in># product_mset A B \\<longleftrightarrow> x \\<in># A \\<times># B\"", "lemma count_Sigma_mset_abs_def: \"count (Sigma_mset A B) = (\\<lambda>(a, b) \\<Rightarrow> count A a * count (B a) b)\"", "lemma Times_mset_image_mset1: \"image_mset f A \\<times># B = image_mset (\\<lambda>(a, b). (f a, b)) (A \\<times># B)\"", "lemma Times_mset_image_mset2: \"A \\<times># image_mset f B = image_mset (\\<lambda>(a, b). (a, f b)) (A \\<times># B)\"", "lemma sum_le_singleton: \"A \\<subseteq> {x} \\<Longrightarrow> sum f A = (if x \\<in> A then f x else 0)\"", "lemma Times_mset_assoc: \"(A \\<times># B) \\<times># C = image_mset (\\<lambda>(a, b, c). ((a, b), c)) (A \\<times># B \\<times># C)\"", "lemma plus_multiset_transfer[transfer_rule]:\n  \"(rel_fun (rel_mset R) (rel_fun (rel_mset R) (rel_mset R))) (+) (+)\"", "lemma minus_multiset_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique R\"\n  shows \"(rel_fun (rel_mset R) (rel_fun (rel_mset R) (rel_mset R))) (-) (-)\"", "lemma count_transfer[transfer_rule]:\n  assumes \"bi_unique R\"\n  shows \"(rel_fun (rel_mset R) (rel_fun R (=))) count count\"", "lemma subseteq_multiset_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique R\" \"right_total R\"\n  shows \"(rel_fun (rel_mset R) (rel_fun (rel_mset R) (=)))\n    (\\<lambda>M N. filter_mset (Domainp R) M \\<subseteq># filter_mset (Domainp R) N) (\\<subseteq>#)\"", "lemma sum_mset_transfer[transfer_rule]:\n  \"R 0 0 \\<Longrightarrow> rel_fun R (rel_fun R R) (+) (+) \\<Longrightarrow> (rel_fun (rel_mset R) R) sum_mset sum_mset\"", "lemma Sigma_mset_transfer[transfer_rule]:\n  \"(rel_fun (rel_mset R) (rel_fun (rel_fun R (rel_mset S)) (rel_mset (rel_prod R S))))\n     Sigma_mset Sigma_mset\"", "lemma range_image_mset:\n  assumes \"set_mset Ds \\<subseteq> range f\"\n  shows \"Ds \\<in> range (image_mset f)\"", "lemma length_sorted_list_of_multiset[simp]: \"length (sorted_list_of_multiset A) = size A\"", "lemma list_of_mset_exi: \"\\<exists>l. m = mset l\"", "lemma mset_list_of_mset[simp]: \"mset (list_of_mset m) = m\"", "lemma length_list_of_mset[simp]: \"length (list_of_mset A) = size A\"", "lemma range_mset_map:\n  assumes \"set_mset Ds \\<subseteq> range f\"\n  shows \"Ds \\<in> range (\\<lambda>Cl. mset (map f Cl))\"", "lemma list_of_mset_empty[iff]: \"list_of_mset m = [] \\<longleftrightarrow> m = {#}\"", "lemma in_mset_conv_nth: \"(x \\<in># mset xs) = (\\<exists>i<length xs. xs ! i = x)\"", "lemma in_mset_sum_list:\n  assumes \"L \\<in># LL\"\n  assumes \"LL \\<in> set Ci\"\n  shows \"L \\<in># sum_list Ci\"", "lemma in_mset_sum_list2:\n  assumes \"L \\<in># sum_list Ci\"\n  obtains LL where\n    \"LL \\<in> set Ci\"\n    \"L \\<in># LL\"", "lemma in_mset_sum_list_iff: \"a \\<in># sum_list \\<A> \\<longleftrightarrow> (\\<exists>A \\<in> set \\<A>. a \\<in># A)\"", "lemma subseteq_list_Union_mset:\n  assumes \"length Ci = n\"\n  assumes \"length CAi = n\"\n  assumes \"\\<forall>i<n.  Ci ! i \\<subseteq># CAi ! i \"\n  shows \"\\<Sum>\\<^sub># (mset Ci) \\<subseteq># \\<Sum>\\<^sub># (mset CAi)\"", "lemma subseteq_mset_size_eql: \"X \\<subseteq># Y \\<Longrightarrow> size Y = size X \\<Longrightarrow> X = Y\"", "lemma image_mset_of_subset_list:\n  assumes \"image_mset \\<eta> C' = mset lC\"\n  shows \"\\<exists>qC'. map \\<eta> qC' = lC \\<and> mset qC' = C'\"", "lemma image_mset_of_subset:\n  assumes \"A \\<subseteq># image_mset \\<eta> C'\"\n  shows \"\\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'\"", "lemma all_the_same: \"\\<forall>x \\<in># X. x = y \\<Longrightarrow> card (set_mset X) \\<le> Suc 0\"", "lemma Melem_subseteq_Union_mset[simp]:\n  assumes \"x \\<in># T\"\n  shows \"x \\<subseteq># \\<Sum>\\<^sub>#T\"", "lemma Melem_subset_eq_sum_list[simp]:\n  assumes \"x \\<in># mset T\"\n  shows \"x \\<subseteq># sum_list T\"", "lemma less_subset_eq_Union_mset[simp]:\n  assumes \"i < length CAi\"\n  shows \"CAi ! i \\<subseteq># \\<Sum>\\<^sub>#(mset CAi)\"", "lemma less_subset_eq_sum_list[simp]:\n  assumes \"i < length CAi\"\n  shows \"CAi ! i \\<subseteq># sum_list CAi\"", "lemma less_multiset_doubletons:\n  assumes\n    \"y < t \\<or> y < s\"  \n    \"x < t \\<or> x < s\" \n  shows \n    \"{#y, x#} < {#t, s#}\""], "translations": [["", "lemma subset_mset_imp_subset_add_mset: \"A \\<subseteq># B \\<Longrightarrow> A \\<subseteq># add_mset x B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq># B \\<Longrightarrow> A \\<subseteq># add_mset x B", "by (metis add_mset_diff_bothsides diff_subset_eq_self multiset_inter_def subset_mset.inf.absorb2)"], ["", "lemma subset_add_mset_notin_subset_mset: \\<open>A \\<subseteq># add_mset b B \\<Longrightarrow> b \\<notin># A \\<Longrightarrow> A \\<subseteq># B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq># add_mset b B; b \\<notin># A\\<rbrakk>\n    \\<Longrightarrow> A \\<subseteq># B", "by (simp add: subset_mset.le_iff_sup)"], ["", "lemma subset_msetE: \"\\<lbrakk>A \\<subset># B; \\<lbrakk>A \\<subseteq># B; \\<not> B \\<subseteq># A\\<rbrakk> \\<Longrightarrow> R\\<rbrakk> \\<Longrightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subset># B;\n     \\<lbrakk>A \\<subseteq># B; \\<not> B \\<subseteq># A\\<rbrakk>\n     \\<Longrightarrow> R\\<rbrakk>\n    \\<Longrightarrow> R", "by (simp add: subset_mset.less_le_not_le)"], ["", "lemma Diff_triv_mset: \"M \\<inter># N = {#} \\<Longrightarrow> M - N = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<inter># N = {#} \\<Longrightarrow> M - N = M", "by (metis diff_intersect_left_idem diff_zero)"], ["", "lemma diff_intersect_sym_diff: \"(A - B) \\<inter># (B - A) = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - B) \\<inter># (B - A) = {#}", "unfolding multiset_inter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A - B - (A - B - (B - A)) = {#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A - B - (A - B - (B - A)) = {#}", "have \"A - (B - (B - A)) = A - B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - (B - (B - A)) = A - B", "by (metis diff_intersect_right_idem multiset_inter_def)"], ["proof (state)\nthis:\n  A - (B - (B - A)) = A - B\n\ngoal (1 subgoal):\n 1. A - B - (A - B - (B - A)) = {#}", "then"], ["proof (chain)\npicking this:\n  A - (B - (B - A)) = A - B", "show \"A - B - (A - B - (B - A)) = {#}\""], ["proof (prove)\nusing this:\n  A - (B - (B - A)) = A - B\n\ngoal (1 subgoal):\n 1. A - B - (A - B - (B - A)) = {#}", "by (metis diff_add diff_cancel diff_subset_eq_self subset_mset.diff_add)"], ["proof (state)\nthis:\n  A - B - (A - B - (B - A)) = {#}\n\ngoal:\nNo subgoals!", "qed"], ["", "declare subset_msetE [elim!]"], ["", "lemma subseq_mset_subseteq_mset: \"subseq xs ys \\<Longrightarrow> mset xs \\<subseteq># mset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq xs ys \\<Longrightarrow> mset xs \\<subseteq># mset ys", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. subseq [] ys \\<Longrightarrow> mset [] \\<subseteq># mset ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   subseq xs ys \\<Longrightarrow>\n                   mset xs \\<subseteq># mset ys;\n        subseq (a # xs) ys\\<rbrakk>\n       \\<Longrightarrow> mset (a # xs) \\<subseteq># mset ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  subseq xs ?ys \\<Longrightarrow> mset xs \\<subseteq># mset ?ys\n  subseq (x # xs) ys\n\ngoal (2 subgoals):\n 1. \\<And>ys. subseq [] ys \\<Longrightarrow> mset [] \\<subseteq># mset ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   subseq xs ys \\<Longrightarrow>\n                   mset xs \\<subseteq># mset ys;\n        subseq (a # xs) ys\\<rbrakk>\n       \\<Longrightarrow> mset (a # xs) \\<subseteq># mset ys", "note Outer_Cons = this"], ["proof (state)\nthis:\n  subseq xs ?ys \\<Longrightarrow> mset xs \\<subseteq># mset ?ys\n  subseq (x # xs) ys\n\ngoal (2 subgoals):\n 1. \\<And>ys. subseq [] ys \\<Longrightarrow> mset [] \\<subseteq># mset ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   subseq xs ys \\<Longrightarrow>\n                   mset xs \\<subseteq># mset ys;\n        subseq (a # xs) ys\\<rbrakk>\n       \\<Longrightarrow> mset (a # xs) \\<subseteq># mset ys", "then"], ["proof (chain)\npicking this:\n  subseq xs ?ys \\<Longrightarrow> mset xs \\<subseteq># mset ?ys\n  subseq (x # xs) ys", "show ?case"], ["proof (prove)\nusing this:\n  subseq xs ?ys \\<Longrightarrow> mset xs \\<subseteq># mset ?ys\n  subseq (x # xs) ys\n\ngoal (1 subgoal):\n 1. mset (x # xs) \\<subseteq># mset ys", "proof (induct ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys.\n                subseq xs ys \\<Longrightarrow> mset xs \\<subseteq># mset ys;\n     subseq (x # xs) []\\<rbrakk>\n    \\<Longrightarrow> mset (x # xs) \\<subseteq># mset []\n 2. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>\\<And>ys.\n                            subseq xs ys \\<Longrightarrow>\n                            mset xs \\<subseteq># mset ys;\n                 subseq (x # xs) ys\\<rbrakk>\n                \\<Longrightarrow> mset (x # xs) \\<subseteq># mset ys;\n        \\<And>ys.\n           subseq xs ys \\<Longrightarrow> mset xs \\<subseteq># mset ys;\n        subseq (x # xs) (a # ys)\\<rbrakk>\n       \\<Longrightarrow> mset (x # xs) \\<subseteq># mset (a # ys)", "case (Cons y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>ys.\n              subseq xs ys \\<Longrightarrow> mset xs \\<subseteq># mset ys;\n   subseq (x # xs) ys\\<rbrakk>\n  \\<Longrightarrow> mset (x # xs) \\<subseteq># mset ys\n  subseq xs ?ys \\<Longrightarrow> mset xs \\<subseteq># mset ?ys\n  subseq (x # xs) (y # ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys.\n                subseq xs ys \\<Longrightarrow> mset xs \\<subseteq># mset ys;\n     subseq (x # xs) []\\<rbrakk>\n    \\<Longrightarrow> mset (x # xs) \\<subseteq># mset []\n 2. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>\\<And>ys.\n                            subseq xs ys \\<Longrightarrow>\n                            mset xs \\<subseteq># mset ys;\n                 subseq (x # xs) ys\\<rbrakk>\n                \\<Longrightarrow> mset (x # xs) \\<subseteq># mset ys;\n        \\<And>ys.\n           subseq xs ys \\<Longrightarrow> mset xs \\<subseteq># mset ys;\n        subseq (x # xs) (a # ys)\\<rbrakk>\n       \\<Longrightarrow> mset (x # xs) \\<subseteq># mset (a # ys)", "have \"subseq xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq xs ys", "by (metis Cons.prems(2) subseq_Cons' subseq_Cons2_iff)"], ["proof (state)\nthis:\n  subseq xs ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys.\n                subseq xs ys \\<Longrightarrow> mset xs \\<subseteq># mset ys;\n     subseq (x # xs) []\\<rbrakk>\n    \\<Longrightarrow> mset (x # xs) \\<subseteq># mset []\n 2. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>\\<And>ys.\n                            subseq xs ys \\<Longrightarrow>\n                            mset xs \\<subseteq># mset ys;\n                 subseq (x # xs) ys\\<rbrakk>\n                \\<Longrightarrow> mset (x # xs) \\<subseteq># mset ys;\n        \\<And>ys.\n           subseq xs ys \\<Longrightarrow> mset xs \\<subseteq># mset ys;\n        subseq (x # xs) (a # ys)\\<rbrakk>\n       \\<Longrightarrow> mset (x # xs) \\<subseteq># mset (a # ys)", "then"], ["proof (chain)\npicking this:\n  subseq xs ys", "show ?case"], ["proof (prove)\nusing this:\n  subseq xs ys\n\ngoal (1 subgoal):\n 1. mset (x # xs) \\<subseteq># mset (y # ys)", "using Cons"], ["proof (prove)\nusing this:\n  subseq xs ys\n  \\<lbrakk>\\<And>ys.\n              subseq xs ys \\<Longrightarrow> mset xs \\<subseteq># mset ys;\n   subseq (x # xs) ys\\<rbrakk>\n  \\<Longrightarrow> mset (x # xs) \\<subseteq># mset ys\n  subseq xs ?ys \\<Longrightarrow> mset xs \\<subseteq># mset ?ys\n  subseq (x # xs) (y # ys)\n\ngoal (1 subgoal):\n 1. mset (x # xs) \\<subseteq># mset (y # ys)", "by (metis mset.simps(2) mset_subset_eq_add_mset_cancel subseq_Cons2_iff\n          subset_mset_imp_subset_add_mset)"], ["proof (state)\nthis:\n  mset (x # xs) \\<subseteq># mset (y # ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys.\n                subseq xs ys \\<Longrightarrow> mset xs \\<subseteq># mset ys;\n     subseq (x # xs) []\\<rbrakk>\n    \\<Longrightarrow> mset (x # xs) \\<subseteq># mset []", "qed simp"], ["proof (state)\nthis:\n  mset (x # xs) \\<subseteq># mset ys\n\ngoal (1 subgoal):\n 1. \\<And>ys. subseq [] ys \\<Longrightarrow> mset [] \\<subseteq># mset ys", "qed simp"], ["", "subsection \\<open>Lemmas about Filter and Image\\<close>"], ["", "lemma count_image_mset_ge_count: \"count (image_mset f A) (f b) \\<ge> count A b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count A b \\<le> count (image_mset f A) (f b)", "by (induction A) auto"], ["", "lemma count_image_mset_inj:\n  assumes \\<open>inj f\\<close>\n  shows \\<open>count (image_mset f M) (f x) = count M x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. count (image_mset f M) (f x) = count M x", "by (induct M) (use assms in \\<open>auto simp: inj_on_def\\<close>)"], ["", "lemma count_image_mset_le_count_inj_on:\n  \"inj_on f (set_mset M) \\<Longrightarrow> count (image_mset f M) y \\<le> count M (inv_into (set_mset M) f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (set_mset M) \\<Longrightarrow>\n    count (image_mset f M) y \\<le> count M (inv_into (set_mset M) f y)", "proof (induct M)"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on f (set_mset {#}) \\<Longrightarrow>\n    count (image_mset f {#}) y \\<le> count {#} (inv_into (set_mset {#}) f y)\n 2. \\<And>x M.\n       \\<lbrakk>inj_on f (set_mset M) \\<Longrightarrow>\n                count (image_mset f M) y\n                \\<le> count M (inv_into (set_mset M) f y);\n        inj_on f (set_mset (add_mset x M))\\<rbrakk>\n       \\<Longrightarrow> count (image_mset f (add_mset x M)) y\n                         \\<le> count (add_mset x M)\n                                (inv_into (set_mset (add_mset x M)) f y)", "case (add x M)"], ["proof (state)\nthis:\n  inj_on f (set_mset M) \\<Longrightarrow>\n  count (image_mset f M) y \\<le> count M (inv_into (set_mset M) f y)\n  inj_on f (set_mset (add_mset x M))\n\ngoal (2 subgoals):\n 1. inj_on f (set_mset {#}) \\<Longrightarrow>\n    count (image_mset f {#}) y \\<le> count {#} (inv_into (set_mset {#}) f y)\n 2. \\<And>x M.\n       \\<lbrakk>inj_on f (set_mset M) \\<Longrightarrow>\n                count (image_mset f M) y\n                \\<le> count M (inv_into (set_mset M) f y);\n        inj_on f (set_mset (add_mset x M))\\<rbrakk>\n       \\<Longrightarrow> count (image_mset f (add_mset x M)) y\n                         \\<le> count (add_mset x M)\n                                (inv_into (set_mset (add_mset x M)) f y)", "note ih = this(1) and inj_xM = this(2)"], ["proof (state)\nthis:\n  inj_on f (set_mset M) \\<Longrightarrow>\n  count (image_mset f M) y \\<le> count M (inv_into (set_mset M) f y)\n  inj_on f (set_mset (add_mset x M))\n\ngoal (2 subgoals):\n 1. inj_on f (set_mset {#}) \\<Longrightarrow>\n    count (image_mset f {#}) y \\<le> count {#} (inv_into (set_mset {#}) f y)\n 2. \\<And>x M.\n       \\<lbrakk>inj_on f (set_mset M) \\<Longrightarrow>\n                count (image_mset f M) y\n                \\<le> count M (inv_into (set_mset M) f y);\n        inj_on f (set_mset (add_mset x M))\\<rbrakk>\n       \\<Longrightarrow> count (image_mset f (add_mset x M)) y\n                         \\<le> count (add_mset x M)\n                                (inv_into (set_mset (add_mset x M)) f y)", "have inj_M: \"inj_on f (set_mset M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (set_mset M)", "using inj_xM"], ["proof (prove)\nusing this:\n  inj_on f (set_mset (add_mset x M))\n\ngoal (1 subgoal):\n 1. inj_on f (set_mset M)", "by simp"], ["proof (state)\nthis:\n  inj_on f (set_mset M)\n\ngoal (2 subgoals):\n 1. inj_on f (set_mset {#}) \\<Longrightarrow>\n    count (image_mset f {#}) y \\<le> count {#} (inv_into (set_mset {#}) f y)\n 2. \\<And>x M.\n       \\<lbrakk>inj_on f (set_mset M) \\<Longrightarrow>\n                count (image_mset f M) y\n                \\<le> count M (inv_into (set_mset M) f y);\n        inj_on f (set_mset (add_mset x M))\\<rbrakk>\n       \\<Longrightarrow> count (image_mset f (add_mset x M)) y\n                         \\<le> count (add_mset x M)\n                                (inv_into (set_mset (add_mset x M)) f y)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "proof (cases \"x \\<in># M\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in># M \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n 2. x \\<notin># M \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "case x_in_M: True"], ["proof (state)\nthis:\n  x \\<in># M\n\ngoal (2 subgoals):\n 1. x \\<in># M \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n 2. x \\<notin># M \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "proof (cases \"y = f x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n 2. y \\<noteq> f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "case y_eq_fx: True"], ["proof (state)\nthis:\n  y = f x\n\ngoal (2 subgoals):\n 1. y = f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n 2. y \\<noteq> f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "using x_in_M ih[OF inj_M]"], ["proof (prove)\nusing this:\n  x \\<in># M\n  count (image_mset f M) y \\<le> count M (inv_into (set_mset M) f y)\n\ngoal (1 subgoal):\n 1. count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "unfolding y_eq_fx"], ["proof (prove)\nusing this:\n  x \\<in># M\n  count (image_mset f M) (f x) \\<le> count M (inv_into (set_mset M) f (f x))\n\ngoal (1 subgoal):\n 1. count (image_mset f (add_mset x M)) (f x)\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f (f x))", "by (simp add: inj_M insert_absorb)"], ["proof (state)\nthis:\n  count (image_mset f (add_mset x M)) y\n  \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n\ngoal (1 subgoal):\n 1. y \\<noteq> f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "case y_ne_fx: False"], ["proof (state)\nthis:\n  y \\<noteq> f x\n\ngoal (1 subgoal):\n 1. y \\<noteq> f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "using x_in_M ih[OF inj_M] y_ne_fx insert_absorb"], ["proof (prove)\nusing this:\n  x \\<in># M\n  count (image_mset f M) y \\<le> count M (inv_into (set_mset M) f y)\n  y \\<noteq> f x\n  ?a \\<in> ?A \\<Longrightarrow> insert ?a ?A = ?A\n\ngoal (1 subgoal):\n 1. count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "by fastforce"], ["proof (state)\nthis:\n  count (image_mset f (add_mset x M)) y\n  \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count (image_mset f (add_mset x M)) y\n  \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n\ngoal (1 subgoal):\n 1. x \\<notin># M \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin># M \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "case x_ni_M: False"], ["proof (state)\nthis:\n  x \\<notin># M\n\ngoal (1 subgoal):\n 1. x \\<notin># M \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "proof (cases \"y = f x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n 2. y \\<noteq> f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "case y_eq_fx: True"], ["proof (state)\nthis:\n  y = f x\n\ngoal (2 subgoals):\n 1. y = f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n 2. y \\<noteq> f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "have \"f x \\<notin># image_mset f M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<notin># image_mset f M", "using x_ni_M inj_xM"], ["proof (prove)\nusing this:\n  x \\<notin># M\n  inj_on f (set_mset (add_mset x M))\n\ngoal (1 subgoal):\n 1. f x \\<notin># image_mset f M", "by force"], ["proof (state)\nthis:\n  f x \\<notin># image_mset f M\n\ngoal (2 subgoals):\n 1. y = f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n 2. y \\<noteq> f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f x \\<notin># image_mset f M\n\ngoal (1 subgoal):\n 1. count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "unfolding y_eq_fx"], ["proof (prove)\nusing this:\n  f x \\<notin># image_mset f M\n\ngoal (1 subgoal):\n 1. count (image_mset f (add_mset x M)) (f x)\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f (f x))", "by (metis (no_types) inj_xM count_add_mset count_greater_eq_Suc_zero_iff count_inI\n          image_mset_add_mset inv_into_f_f union_single_eq_member)"], ["proof (state)\nthis:\n  count (image_mset f (add_mset x M)) y\n  \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n\ngoal (1 subgoal):\n 1. y \\<noteq> f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "case y_ne_fx: False"], ["proof (state)\nthis:\n  y \\<noteq> f x\n\ngoal (1 subgoal):\n 1. y \\<noteq> f x \\<Longrightarrow>\n    count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. count (image_mset f (add_mset x M)) y\n    \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> count (image_mset f (add_mset x M)) y\n           \\<le> count (add_mset x M)\n                  (inv_into (set_mset (add_mset x M)) f y) \\<Longrightarrow>\n    False", "assume neg_conj: \"\\<not> count (image_mset f (add_mset x M)) y\n          \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\""], ["proof (state)\nthis:\n  \\<not> count (image_mset f (add_mset x M)) y\n         \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n\ngoal (1 subgoal):\n 1. \\<not> count (image_mset f (add_mset x M)) y\n           \\<le> count (add_mset x M)\n                  (inv_into (set_mset (add_mset x M)) f y) \\<Longrightarrow>\n    False", "have cnt_y: \"count (add_mset (f x) (image_mset f M)) y = count (image_mset f M) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (add_mset (f x) (image_mset f M)) y = count (image_mset f M) y", "using y_ne_fx"], ["proof (prove)\nusing this:\n  y \\<noteq> f x\n\ngoal (1 subgoal):\n 1. count (add_mset (f x) (image_mset f M)) y = count (image_mset f M) y", "by simp"], ["proof (state)\nthis:\n  count (add_mset (f x) (image_mset f M)) y = count (image_mset f M) y\n\ngoal (1 subgoal):\n 1. \\<not> count (image_mset f (add_mset x M)) y\n           \\<le> count (add_mset x M)\n                  (inv_into (set_mset (add_mset x M)) f y) \\<Longrightarrow>\n    False", "have \"inv_into (set_mset M) f y \\<in># add_mset x M \\<Longrightarrow>\n          inv_into (set_mset (add_mset x M)) f (f (inv_into (set_mset M) f y)) =\n          inv_into (set_mset M) f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into (set_mset M) f y \\<in># add_mset x M \\<Longrightarrow>\n    inv_into (set_mset (add_mset x M)) f (f (inv_into (set_mset M) f y)) =\n    inv_into (set_mset M) f y", "by (meson inj_xM inv_into_f_f)"], ["proof (state)\nthis:\n  inv_into (set_mset M) f y \\<in># add_mset x M \\<Longrightarrow>\n  inv_into (set_mset (add_mset x M)) f (f (inv_into (set_mset M) f y)) =\n  inv_into (set_mset M) f y\n\ngoal (1 subgoal):\n 1. \\<not> count (image_mset f (add_mset x M)) y\n           \\<le> count (add_mset x M)\n                  (inv_into (set_mset (add_mset x M)) f y) \\<Longrightarrow>\n    False", "hence \"0 < count (image_mset f (add_mset x M)) y \\<Longrightarrow>\n          count M (inv_into (set_mset M) f y) = 0 \\<or> x = inv_into (set_mset M) f y\""], ["proof (prove)\nusing this:\n  inv_into (set_mset M) f y \\<in># add_mset x M \\<Longrightarrow>\n  inv_into (set_mset (add_mset x M)) f (f (inv_into (set_mset M) f y)) =\n  inv_into (set_mset M) f y\n\ngoal (1 subgoal):\n 1. 0 < count (image_mset f (add_mset x M)) y \\<Longrightarrow>\n    count M (inv_into (set_mset M) f y) = 0 \\<or>\n    x = inv_into (set_mset M) f y", "using neg_conj cnt_y ih[OF inj_M]"], ["proof (prove)\nusing this:\n  inv_into (set_mset M) f y \\<in># add_mset x M \\<Longrightarrow>\n  inv_into (set_mset (add_mset x M)) f (f (inv_into (set_mset M) f y)) =\n  inv_into (set_mset M) f y\n  \\<not> count (image_mset f (add_mset x M)) y\n         \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n  count (add_mset (f x) (image_mset f M)) y = count (image_mset f M) y\n  count (image_mset f M) y \\<le> count M (inv_into (set_mset M) f y)\n\ngoal (1 subgoal):\n 1. 0 < count (image_mset f (add_mset x M)) y \\<Longrightarrow>\n    count M (inv_into (set_mset M) f y) = 0 \\<or>\n    x = inv_into (set_mset M) f y", "by (metis (no_types) count_add_mset count_greater_zero_iff count_inI f_inv_into_f\n            image_mset_add_mset set_image_mset)"], ["proof (state)\nthis:\n  0 < count (image_mset f (add_mset x M)) y \\<Longrightarrow>\n  count M (inv_into (set_mset M) f y) = 0 \\<or>\n  x = inv_into (set_mset M) f y\n\ngoal (1 subgoal):\n 1. \\<not> count (image_mset f (add_mset x M)) y\n           \\<le> count (add_mset x M)\n                  (inv_into (set_mset (add_mset x M)) f y) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  0 < count (image_mset f (add_mset x M)) y \\<Longrightarrow>\n  count M (inv_into (set_mset M) f y) = 0 \\<or>\n  x = inv_into (set_mset M) f y\n\ngoal (1 subgoal):\n 1. False", "using neg_conj cnt_y x_ni_M ih[OF inj_M]"], ["proof (prove)\nusing this:\n  0 < count (image_mset f (add_mset x M)) y \\<Longrightarrow>\n  count M (inv_into (set_mset M) f y) = 0 \\<or>\n  x = inv_into (set_mset M) f y\n  \\<not> count (image_mset f (add_mset x M)) y\n         \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n  count (add_mset (f x) (image_mset f M)) y = count (image_mset f M) y\n  x \\<notin># M\n  count (image_mset f M) y \\<le> count M (inv_into (set_mset M) f y)\n\ngoal (1 subgoal):\n 1. False", "by (metis (no_types) count_greater_zero_iff count_inI eq_iff image_mset_add_mset\n            less_imp_le)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count (image_mset f (add_mset x M)) y\n  \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count (image_mset f (add_mset x M)) y\n  \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  count (image_mset f (add_mset x M)) y\n  \\<le> count (add_mset x M) (inv_into (set_mset (add_mset x M)) f y)\n\ngoal (1 subgoal):\n 1. inj_on f (set_mset {#}) \\<Longrightarrow>\n    count (image_mset f {#}) y \\<le> count {#} (inv_into (set_mset {#}) f y)", "qed simp"], ["", "lemma mset_filter_compl: \"mset (filter p xs) + mset (filter (Not \\<circ> p) xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (filter p xs) + mset (filter (Not \\<circ> p) xs) = mset xs", "by (induction xs) (auto simp: ac_simps)"], ["", "text \\<open>Near duplicate of @{thm [source] filter_eq_replicate_mset}: @{thm filter_eq_replicate_mset}.\\<close>"], ["", "lemma filter_mset_eq: \"filter_mset ((=) L) A = replicate_mset (count A L) L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset ((=) L) A = replicate_mset (count A L) L", "by (auto simp: multiset_eq_iff)"], ["", "lemma filter_mset_cong[fundef_cong]:\n  assumes \"M = M'\" \"\\<And>a. a \\<in># M \\<Longrightarrow> P a = Q a\"\n  shows \"filter_mset P M = filter_mset Q M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P M = filter_mset Q M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter_mset P M = filter_mset Q M", "have \"M - filter_mset Q M = filter_mset (\\<lambda>a. \\<not>Q a) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M - filter_mset Q M = {#a \\<in># M. \\<not> Q a#}", "by (metis multiset_partition add_diff_cancel_left')"], ["proof (state)\nthis:\n  M - filter_mset Q M = {#a \\<in># M. \\<not> Q a#}\n\ngoal (1 subgoal):\n 1. filter_mset P M = filter_mset Q M", "then"], ["proof (chain)\npicking this:\n  M - filter_mset Q M = {#a \\<in># M. \\<not> Q a#}", "show ?thesis"], ["proof (prove)\nusing this:\n  M - filter_mset Q M = {#a \\<in># M. \\<not> Q a#}\n\ngoal (1 subgoal):\n 1. filter_mset P M = filter_mset Q M", "by (auto simp: filter_mset_eq_conv assms)"], ["proof (state)\nthis:\n  filter_mset P M = filter_mset Q M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_mset_filter_swap: \"image_mset f {# x \\<in># M. P (f x)#} = {# x \\<in># image_mset f M. P x#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset f {#x \\<in># M. P (f x)#} = filter_mset P (image_mset f M)", "by (induction M) auto"], ["", "lemma image_mset_cong2:\n  \"(\\<And>x. x \\<in># M \\<Longrightarrow> f x = g x) \\<Longrightarrow> M = N \\<Longrightarrow> image_mset f M = image_mset g N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in># M \\<Longrightarrow> f x = g x; M = N\\<rbrakk>\n    \\<Longrightarrow> image_mset f M = image_mset g N", "by (hypsubst, rule image_mset_cong)"], ["", "lemma filter_mset_empty_conv: \\<open>(filter_mset P M = {#}) = (\\<forall>L\\<in>#M. \\<not> P L)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (filter_mset P M = {#}) = (\\<forall>L\\<in>#M. \\<not> P L)", "by (induction M) auto"], ["", "lemma multiset_filter_mono2: \\<open>filter_mset P A \\<subseteq># filter_mset Q A \\<longleftrightarrow> (\\<forall>a\\<in>#A. P a \\<longrightarrow> Q a)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (filter_mset P A \\<subseteq># filter_mset Q A) =\n    (\\<forall>a\\<in>#A. P a \\<longrightarrow> Q a)", "by (induction A) (auto intro: subset_mset.order.trans)"], ["", "lemma image_filter_cong:\n  assumes \\<open>\\<And>C. C \\<in># M \\<Longrightarrow> P C \\<Longrightarrow> f C = g C\\<close>\n  shows \\<open>{#f C. C \\<in># {#C \\<in># M. P C#}#} = {#g C | C\\<in># M. P C#}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset f (filter_mset P M) = image_mset g (filter_mset P M)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?C \\<in># M; P ?C\\<rbrakk> \\<Longrightarrow> f ?C = g ?C\n\ngoal (1 subgoal):\n 1. image_mset f (filter_mset P M) = image_mset g (filter_mset P M)", "by (induction M) auto"], ["", "lemma image_mset_filter_swap2: \\<open>{#C \\<in># {#P x. x \\<in># D#}. Q C #} = {#P x. x \\<in># {#C| C \\<in># D. Q (P C)#}#}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset Q (image_mset P D) =\n    image_mset P {#C. C \\<in># {#C \\<in># D. Q (P C)#}#}", "by (simp add: image_mset_filter_swap)"], ["", "declare image_mset_cong2 [cong]"], ["", "lemma filter_mset_empty_if_finite_and_filter_set_empty:\n  assumes\n    \"{x \\<in> X. P x} = {}\" and\n    \"finite X\"\n  shows \"{#x \\<in># mset_set X. P x#} = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_mset P (mset_set X) = {#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. filter_mset P (mset_set X) = {#}", "have empty_empty: \"\\<And>Y. set_mset Y = {} \\<Longrightarrow> Y = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y. set_mset Y = {} \\<Longrightarrow> Y = {#}", "by auto"], ["proof (state)\nthis:\n  set_mset ?Y = {} \\<Longrightarrow> ?Y = {#}\n\ngoal (1 subgoal):\n 1. filter_mset P (mset_set X) = {#}", "from assms"], ["proof (chain)\npicking this:\n  {x \\<in> X. P x} = {}\n  finite X", "have \"set_mset {#x \\<in># mset_set X. P x#} = {}\""], ["proof (prove)\nusing this:\n  {x \\<in> X. P x} = {}\n  finite X\n\ngoal (1 subgoal):\n 1. set_mset (filter_mset P (mset_set X)) = {}", "by auto"], ["proof (state)\nthis:\n  set_mset (filter_mset P (mset_set X)) = {}\n\ngoal (1 subgoal):\n 1. filter_mset P (mset_set X) = {#}", "then"], ["proof (chain)\npicking this:\n  set_mset (filter_mset P (mset_set X)) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  set_mset (filter_mset P (mset_set X)) = {}\n\ngoal (1 subgoal):\n 1. filter_mset P (mset_set X) = {#}", "by (rule empty_empty)"], ["proof (state)\nthis:\n  filter_mset P (mset_set X) = {#}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lemmas about Sum\\<close>"], ["", "lemma sum_image_mset_sum_map[simp]: \"sum_mset (image_mset f (mset xs)) = sum_list (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset f (mset xs)) = sum_list (map f xs)", "by (metis mset_map sum_mset_sum_list)"], ["", "lemma sum_image_mset_mono:\n  fixes f :: \"'a \\<Rightarrow> 'b::canonically_ordered_monoid_add\"\n  assumes sub: \"A \\<subseteq># B\"\n  shows \"(\\<Sum>m \\<in># A. f m) \\<le> (\\<Sum>m \\<in># B. f m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset f A) \\<le> \\<Sum>\\<^sub># (image_mset f B)", "by (metis image_mset_union le_iff_add sub subset_mset.add_diff_inverse sum_mset.union)"], ["", "lemma sum_image_mset_mono_mem:\n  \"n \\<in># M \\<Longrightarrow> f n \\<le> (\\<Sum>m \\<in># M. f m)\" for f :: \"'a \\<Rightarrow> 'b::canonically_ordered_monoid_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in># M \\<Longrightarrow> f n \\<le> \\<Sum>\\<^sub># (image_mset f M)", "using le_iff_add multi_member_split"], ["proof (prove)\nusing this:\n  (?a \\<le> ?b) = (\\<exists>c. ?b = ?a + c)\n  ?x \\<in># ?M \\<Longrightarrow> \\<exists>A. ?M = add_mset ?x A\n\ngoal (1 subgoal):\n 1. n \\<in># M \\<Longrightarrow> f n \\<le> \\<Sum>\\<^sub># (image_mset f M)", "by fastforce"], ["", "lemma count_sum_mset_if_1_0: \\<open>count M a = (\\<Sum>x\\<in>#M. if x = a then 1 else 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. count M a = (\\<Sum>x\\<in>#M. if x = a then 1 else 0)", "by (induction M) auto"], ["", "lemma sum_mset_dvd:\n  fixes k :: \"'a::comm_semiring_1_cancel\"\n  assumes \"\\<forall>m \\<in># M. k dvd f m\"\n  shows \"k dvd (\\<Sum>m \\<in># M. f m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k dvd \\<Sum>\\<^sub># (image_mset f M)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>#M. k dvd f m\n\ngoal (1 subgoal):\n 1. k dvd \\<Sum>\\<^sub># (image_mset f M)", "by (induct M) auto"], ["", "lemma sum_mset_distrib_div_if_dvd:\n  fixes k :: \"'a::unique_euclidean_semiring\"\n  assumes \"\\<forall>m \\<in># M. k dvd f m\"\n  shows \"(\\<Sum>m \\<in># M. f m) div k = (\\<Sum>m \\<in># M. f m div k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset f M) div k = (\\<Sum>m\\<in>#M. f m div k)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>#M. k dvd f m\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset f M) div k = (\\<Sum>m\\<in>#M. f m div k)", "by (induct M) (auto simp: div_plus_div_distrib_dvd_left)"], ["", "subsection \\<open>Lemmas about Remove\\<close>"], ["", "lemma set_mset_minus_replicate_mset[simp]:\n  \"n \\<ge> count A a \\<Longrightarrow> set_mset (A - replicate_mset n a) = set_mset A - {a}\"\n  \"n < count A a \\<Longrightarrow> set_mset (A - replicate_mset n a) = set_mset A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (count A a \\<le> n \\<Longrightarrow>\n     set_mset (A - replicate_mset n a) = set_mset A - {a}) &&&\n    (n < count A a \\<Longrightarrow>\n     set_mset (A - replicate_mset n a) = set_mset A)", "unfolding set_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (count A a \\<le> n \\<Longrightarrow>\n     {x. 0 < count (A - replicate_mset n a) x} =\n     {x. 0 < count A x} - {a}) &&&\n    (n < count A a \\<Longrightarrow>\n     {x. 0 < count (A - replicate_mset n a) x} = {x. 0 < count A x})", "by (auto split: if_split simp: not_in_iff)"], ["", "abbreviation removeAll_mset :: \"'a \\<Rightarrow> 'a multiset \\<Rightarrow> 'a multiset\" where\n  \"removeAll_mset C M \\<equiv> M - replicate_mset (count M C) C\""], ["", "lemma mset_removeAll[simp, code]: \"removeAll_mset C (mset L) = mset (removeAll C L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeAll_mset C (mset L) = mset (removeAll C L)", "by (induction L) (auto simp: ac_simps multiset_eq_iff split: if_split_asm)"], ["", "lemma removeAll_mset_filter_mset: \"removeAll_mset C M = filter_mset ((\\<noteq>) C) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeAll_mset C M = filter_mset ((\\<noteq>) C) M", "by (induction M) (auto simp: ac_simps multiset_eq_iff)"], ["", "abbreviation remove1_mset :: \"'a \\<Rightarrow> 'a multiset \\<Rightarrow> 'a multiset\" where\n  \"remove1_mset C M \\<equiv> M - {#C#}\""], ["", "lemma removeAll_subseteq_remove1_mset: \"removeAll_mset x M \\<subseteq># remove1_mset x M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. removeAll_mset x M \\<subseteq># remove1_mset x M", "by (auto simp: subseteq_mset_def)"], ["", "lemma in_remove1_mset_neq:\n  assumes ab: \"a \\<noteq> b\"\n  shows \"a \\<in># remove1_mset b C \\<longleftrightarrow> a \\<in># C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in># remove1_mset b C) = (a \\<in># C)", "by (metis assms diff_single_trivial in_diffD insert_DiffM insert_noteq_member)"], ["", "lemma size_mset_removeAll_mset_le_iff: \"size (removeAll_mset x M) < size M \\<longleftrightarrow> x \\<in># M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (size (removeAll_mset x M) < size M) = (x \\<in># M)", "by (auto intro: count_inI mset_subset_size simp: subset_mset_def multiset_eq_iff)"], ["", "lemma size_remove1_mset_If: \\<open>size (remove1_mset x M) = size M - (if x \\<in># M then 1 else 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. size (remove1_mset x M) = size M - (if x \\<in># M then 1 else 0)", "by (auto simp: size_Diff_subset_Int)"], ["", "lemma size_mset_remove1_mset_le_iff: \"size (remove1_mset x M) < size M \\<longleftrightarrow> x \\<in># M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (size (remove1_mset x M) < size M) = (x \\<in># M)", "using less_irrefl"], ["proof (prove)\nusing this:\n  \\<not> ?x < ?x\n\ngoal (1 subgoal):\n 1. (size (remove1_mset x M) < size M) = (x \\<in># M)", "by (fastforce intro!: mset_subset_size elim: in_countE simp: subset_mset_def multiset_eq_iff)"], ["", "lemma remove_1_mset_id_iff_notin: \"remove1_mset a M = M \\<longleftrightarrow> a \\<notin># M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (remove1_mset a M = M) = (a \\<notin># M)", "by (meson diff_single_trivial multi_drop_mem_not_eq)"], ["", "lemma id_remove_1_mset_iff_notin: \"M = remove1_mset a M \\<longleftrightarrow> a \\<notin># M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M = remove1_mset a M) = (a \\<notin># M)", "using remove_1_mset_id_iff_notin"], ["proof (prove)\nusing this:\n  (remove1_mset ?a ?M = ?M) = (?a \\<notin># ?M)\n\ngoal (1 subgoal):\n 1. (M = remove1_mset a M) = (a \\<notin># M)", "by metis"], ["", "lemma remove1_mset_eqE:\n  \"remove1_mset L x1 = M \\<Longrightarrow>\n    (L \\<in># x1 \\<Longrightarrow> x1 = M + {#L#} \\<Longrightarrow> P) \\<Longrightarrow>\n    (L \\<notin># x1 \\<Longrightarrow> x1 = M \\<Longrightarrow> P) \\<Longrightarrow>\n  P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>remove1_mset L x1 = M;\n     \\<lbrakk>L \\<in># x1; x1 = M + {#L#}\\<rbrakk> \\<Longrightarrow> P;\n     \\<lbrakk>L \\<notin># x1; x1 = M\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (cases \"L \\<in># x1\") auto"], ["", "lemma image_filter_ne_mset[simp]:\n  \"image_mset f {#x \\<in># M. f x \\<noteq> y#} = removeAll_mset y (image_mset f M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset f {#x \\<in># M. f x \\<noteq> y#} =\n    removeAll_mset y (image_mset f M)", "by (induction M) simp_all"], ["", "lemma image_mset_remove1_mset_if:\n  \"image_mset f (remove1_mset a M) =\n   (if a \\<in># M then remove1_mset (f a) (image_mset f M) else image_mset f M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset f (remove1_mset a M) =\n    (if a \\<in># M then remove1_mset (f a) (image_mset f M)\n     else image_mset f M)", "by (auto simp: image_mset_Diff)"], ["", "lemma filter_mset_neq: \"{#x \\<in># M. x \\<noteq> y#} = removeAll_mset y M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#x \\<in># M. x \\<noteq> y#} = removeAll_mset y M", "by (metis add_diff_cancel_left' filter_eq_replicate_mset multiset_partition)"], ["", "lemma filter_mset_neq_cond: \"{#x \\<in># M. P x \\<and> x \\<noteq> y#} = removeAll_mset y {# x\\<in>#M. P x#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#x \\<in># M. P x \\<and> x \\<noteq> y#} =\n    removeAll_mset y (filter_mset P M)", "by (metis filter_filter_mset filter_mset_neq)"], ["", "lemma remove1_mset_add_mset_If:\n  \"remove1_mset L (add_mset L' C) = (if L = L' then C else remove1_mset L C + {#L'#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove1_mset L (add_mset L' C) =\n    (if L = L' then C else remove1_mset L C + {#L'#})", "by (auto simp: multiset_eq_iff)"], ["", "lemma minus_remove1_mset_if:\n  \"A - remove1_mset b B = (if b \\<in># B \\<and> b \\<in># A \\<and> count A b \\<ge> count B b then {#b#} + (A - B) else A - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - remove1_mset b B =\n    (if b \\<in># B \\<and> b \\<in># A \\<and> count B b \\<le> count A b\n     then {#b#} + (A - B) else A - B)", "by (auto simp: multiset_eq_iff count_greater_zero_iff[symmetric]\n    simp del: count_greater_zero_iff)"], ["", "lemma add_mset_eq_add_mset_ne:\n  \"a \\<noteq> b \\<Longrightarrow> add_mset a A = add_mset b B \\<longleftrightarrow> a \\<in># B \\<and> b \\<in># A \\<and> A = add_mset b (B - {#a#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    (add_mset a A = add_mset b B) =\n    (a \\<in># B \\<and> b \\<in># A \\<and> A = add_mset b (remove1_mset a B))", "by (metis (no_types, lifting) diff_single_eq_union diff_union_swap multi_self_add_other_not_self\n    remove_1_mset_id_iff_notin union_single_eq_diff)"], ["", "lemma add_mset_eq_add_mset: \\<open>add_mset a M = add_mset b M' \\<longleftrightarrow>\n  (a = b \\<and> M = M') \\<or> (a \\<noteq> b \\<and> b \\<in># M \\<and> add_mset a (M - {#b#}) = M')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (add_mset a M = add_mset b M') =\n    (a = b \\<and> M = M' \\<or>\n     a \\<noteq> b \\<and>\n     b \\<in># M \\<and> add_mset a (remove1_mset b M) = M')", "by (metis add_mset_eq_add_mset_ne add_mset_remove_trivial union_single_eq_member)"], ["", "(* TODO move to Multiset: could replace add_mset_remove_trivial_eq? *)"], ["", "lemma add_mset_remove_trivial_iff: \\<open>N = add_mset a (N - {#b#}) \\<longleftrightarrow> a \\<in># N \\<and> a = b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (N = add_mset a (remove1_mset b N)) = (a \\<in># N \\<and> a = b)", "by (metis add_left_cancel add_mset_remove_trivial insert_DiffM2 single_eq_single\n      size_mset_remove1_mset_le_iff union_single_eq_member)"], ["", "lemma trivial_add_mset_remove_iff: \\<open>add_mset a (N - {#b#}) = N \\<longleftrightarrow> a \\<in># N \\<and> a = b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (add_mset a (remove1_mset b N) = N) = (a \\<in># N \\<and> a = b)", "by (subst eq_commute) (fact add_mset_remove_trivial_iff)"], ["", "lemma remove1_single_empty_iff[simp]: \\<open>remove1_mset L {#L'#} = {#} \\<longleftrightarrow> L = L'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (remove1_mset L {#L'#} = {#}) = (L = L')", "using add_mset_remove_trivial_iff"], ["proof (prove)\nusing this:\n  (?N = add_mset ?a (remove1_mset ?b ?N)) = (?a \\<in># ?N \\<and> ?a = ?b)\n\ngoal (1 subgoal):\n 1. (remove1_mset L {#L'#} = {#}) = (L = L')", "by fastforce"], ["", "lemma add_mset_less_imp_less_remove1_mset:\n  assumes xM_lt_N: \"add_mset x M < N\"\n  shows \"M < remove1_mset x N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M < remove1_mset x N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M < remove1_mset x N", "have \"M < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M < N", "using assms le_multiset_right_total mset_le_trans"], ["proof (prove)\nusing this:\n  add_mset x M < N\n  ?M < add_mset ?x ?M\n  \\<lbrakk>?K < ?M; ?M < ?N\\<rbrakk> \\<Longrightarrow> ?K < ?N\n\ngoal (1 subgoal):\n 1. M < N", "by blast"], ["proof (state)\nthis:\n  M < N\n\ngoal (1 subgoal):\n 1. M < remove1_mset x N", "then"], ["proof (chain)\npicking this:\n  M < N", "show ?thesis"], ["proof (prove)\nusing this:\n  M < N\n\ngoal (1 subgoal):\n 1. M < remove1_mset x N", "by (metis add_less_cancel_right add_mset_add_single diff_single_trivial insert_DiffM2 xM_lt_N)"], ["proof (state)\nthis:\n  M < remove1_mset x N\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lemmas about Replicate\\<close>"], ["", "lemma replicate_mset_minus_replicate_mset_same[simp]:\n  \"replicate_mset m x - replicate_mset n x = replicate_mset (m - n) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate_mset m x - replicate_mset n x = replicate_mset (m - n) x", "by (induct m arbitrary: n, simp, metis left_diff_repeat_mset_distrib' repeat_mset_replicate_mset)"], ["", "lemma replicate_mset_subset_iff_lt[simp]: \"replicate_mset m x \\<subset># replicate_mset n x \\<longleftrightarrow> m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate_mset m x \\<subset># replicate_mset n x) = (m < n)", "by (induct n m rule: diff_induct) (auto intro: subset_mset.gr_zeroI)"], ["", "lemma replicate_mset_subseteq_iff_le[simp]: \"replicate_mset m x \\<subseteq># replicate_mset n x \\<longleftrightarrow> m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate_mset m x \\<subseteq># replicate_mset n x) = (m \\<le> n)", "by (induct n m rule: diff_induct) auto"], ["", "lemma replicate_mset_lt_iff_lt[simp]: \"replicate_mset m x < replicate_mset n x \\<longleftrightarrow> m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate_mset m x < replicate_mset n x) = (m < n)", "by (induct n m rule: diff_induct) (auto intro: subset_mset.gr_zeroI gr_zeroI)"], ["", "lemma replicate_mset_le_iff_le[simp]: \"replicate_mset m x \\<le> replicate_mset n x \\<longleftrightarrow> m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate_mset m x \\<le> replicate_mset n x) = (m \\<le> n)", "by (induct n m rule: diff_induct) auto"], ["", "lemma replicate_mset_eq_iff[simp]:\n  \"replicate_mset m x = replicate_mset n y \\<longleftrightarrow> m = n \\<and> (m \\<noteq> 0 \\<longrightarrow> x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate_mset m x = replicate_mset n y) =\n    (m = n \\<and> (m \\<noteq> 0 \\<longrightarrow> x = y))", "by (cases m; cases n; simp)\n    (metis in_replicate_mset insert_noteq_member size_replicate_mset union_single_eq_diff)"], ["", "lemma replicate_mset_plus: \"replicate_mset (a + b) C = replicate_mset a C + replicate_mset b C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate_mset (a + b) C = replicate_mset a C + replicate_mset b C", "by (induct a) (auto simp: ac_simps)"], ["", "lemma mset_replicate_replicate_mset: \"mset (replicate n L) = replicate_mset n L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (replicate n L) = replicate_mset n L", "by (induction n) auto"], ["", "lemma set_mset_single_iff_replicate_mset: \"set_mset U = {a} \\<longleftrightarrow> (\\<exists>n > 0. U = replicate_mset n a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_mset U = {a}) = (\\<exists>n>0. U = replicate_mset n a)", "by (rule, metis count_greater_zero_iff count_replicate_mset insertI1 multi_count_eq singletonD\n    zero_less_iff_neq_zero, force)"], ["", "lemma ex_replicate_mset_if_all_elems_eq:\n  assumes \"\\<forall>x \\<in># M. x = y\"\n  shows \"\\<exists>n. M = replicate_mset n y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. M = replicate_mset n y", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>#M. x = y\n\ngoal (1 subgoal):\n 1. \\<exists>n. M = replicate_mset n y", "by (metis count_replicate_mset mem_Collect_eq multiset_eqI neq0_conv set_mset_def)"], ["", "subsection \\<open>Multiset and Set Conversions\\<close>"], ["", "lemma count_mset_set_if: \"count (mset_set A) a = (if a \\<in> A \\<and> finite A then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (mset_set A) a = (if a \\<in> A \\<and> finite A then 1 else 0)", "by auto"], ["", "lemma mset_set_set_mset_empty_mempty[iff]: \"mset_set (set_mset D) = {#} \\<longleftrightarrow> D = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset_set (set_mset D) = {#}) = (D = {#})", "by (simp add: mset_set_empty_iff)"], ["", "lemma count_mset_set_le_one: \"count (mset_set A) x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (mset_set A) x \\<le> 1", "by (simp add: count_mset_set_if)"], ["", "lemma mset_set_set_mset_subseteq[simp]: \"mset_set (set_mset A) \\<subseteq># A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_set (set_mset A) \\<subseteq># A", "by (simp add: mset_set_set_mset_msubset)"], ["", "lemma mset_sorted_list_of_set[simp]: \"mset (sorted_list_of_set A) = mset_set A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (sorted_list_of_set A) = mset_set A", "by (metis mset_sorted_list_of_multiset sorted_list_of_mset_set)"], ["", "lemma sorted_sorted_list_of_multiset[simp]:\n  \"sorted (sorted_list_of_multiset (M :: 'a::linorder multiset))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (sorted_list_of_multiset M)", "by (metis mset_sorted_list_of_multiset sorted_list_of_multiset_mset sorted_sort)"], ["", "lemma mset_take_subseteq: \"mset (take n xs) \\<subseteq># mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (take n xs) \\<subseteq># mset xs", "apply (induct xs arbitrary: n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n. mset (take n []) \\<subseteq># mset []\n 2. \\<And>a xs n.\n       (\\<And>n. mset (take n xs) \\<subseteq># mset xs) \\<Longrightarrow>\n       mset (take n (a # xs)) \\<subseteq># mset (a # xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       (\\<And>n. mset (take n xs) \\<subseteq># mset xs) \\<Longrightarrow>\n       mset (take n (a # xs)) \\<subseteq># mset (a # xs)", "by (case_tac n) simp_all"], ["", "lemma sorted_list_of_multiset_eq_Nil[simp]: \"sorted_list_of_multiset M = [] \\<longleftrightarrow> M = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sorted_list_of_multiset M = []) = (M = {#})", "by (metis mset_sorted_list_of_multiset sorted_list_of_multiset_empty)"], ["", "subsection \\<open>Duplicate Removal\\<close>"], ["", "(* TODO: use abbreviation? *)"], ["", "definition remdups_mset :: \"'v multiset \\<Rightarrow> 'v multiset\" where\n  \"remdups_mset S = mset_set (set_mset S)\""], ["", "lemma set_mset_remdups_mset[simp]: \\<open>set_mset (remdups_mset A) = set_mset A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (remdups_mset A) = set_mset A", "unfolding remdups_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (mset_set (set_mset A)) = set_mset A", "by auto"], ["", "lemma count_remdups_mset_eq_1: \"a \\<in># remdups_mset A \\<longleftrightarrow> count (remdups_mset A) a = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in># remdups_mset A) = (count (remdups_mset A) a = 1)", "unfolding remdups_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in># mset_set (set_mset A)) = (count (mset_set (set_mset A)) a = 1)", "by (auto simp: count_eq_zero_iff intro: count_inI)"], ["", "lemma remdups_mset_empty[simp]: \"remdups_mset {#} = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups_mset {#} = {#}", "unfolding remdups_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_set (set_mset {#}) = {#}", "by auto"], ["", "lemma remdups_mset_singleton[simp]: \"remdups_mset {#a#} = {#a#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups_mset {#a#} = {#a#}", "unfolding remdups_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_set (set_mset {#a#}) = {#a#}", "by auto"], ["", "lemma remdups_mset_eq_empty[iff]: \"remdups_mset D = {#} \\<longleftrightarrow> D = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (remdups_mset D = {#}) = (D = {#})", "unfolding remdups_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mset_set (set_mset D) = {#}) = (D = {#})", "by blast"], ["", "lemma remdups_mset_singleton_sum[simp]:\n  \"remdups_mset (add_mset a A) = (if a \\<in># A then remdups_mset A else add_mset a (remdups_mset A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups_mset (add_mset a A) =\n    (if a \\<in># A then remdups_mset A else add_mset a (remdups_mset A))", "unfolding remdups_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_set (set_mset (add_mset a A)) =\n    (if a \\<in># A then mset_set (set_mset A)\n     else add_mset a (mset_set (set_mset A)))", "by (simp_all add: insert_absorb)"], ["", "lemma mset_remdups_remdups_mset[simp]: \"mset (remdups D) = remdups_mset (mset D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (remdups D) = remdups_mset (mset D)", "by (induction D) (auto simp add: ac_simps)"], ["", "declare mset_remdups_remdups_mset[symmetric, code]"], ["", "definition distinct_mset :: \"'a multiset \\<Rightarrow> bool\" where\n  \"distinct_mset S \\<longleftrightarrow> (\\<forall>a. a \\<in># S \\<longrightarrow> count S a = 1)\""], ["", "lemma distinct_mset_count_less_1: \"distinct_mset S \\<longleftrightarrow> (\\<forall>a. count S a \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset S = (\\<forall>a. count S a \\<le> 1)", "using eq_iff nat_le_linear"], ["proof (prove)\nusing this:\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n  ?m \\<le> ?n \\<or> ?n \\<le> ?m\n\ngoal (1 subgoal):\n 1. distinct_mset S = (\\<forall>a. count S a \\<le> 1)", "unfolding distinct_mset_def"], ["proof (prove)\nusing this:\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n  ?m \\<le> ?n \\<or> ?n \\<le> ?m\n\ngoal (1 subgoal):\n 1. (\\<forall>a. a \\<in># S \\<longrightarrow> count S a = 1) =\n    (\\<forall>a. count S a \\<le> 1)", "by fastforce"], ["", "lemma distinct_mset_empty[simp]: \"distinct_mset {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset {#}", "unfolding distinct_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. a \\<in># {#} \\<longrightarrow> count {#} a = 1", "by auto"], ["", "lemma distinct_mset_singleton: \"distinct_mset {#a#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset {#a#}", "unfolding distinct_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>aa. aa \\<in># {#a#} \\<longrightarrow> count {#a#} aa = 1", "by auto"], ["", "lemma distinct_mset_union:\n  assumes dist: \"distinct_mset (A + B)\"\n  shows \"distinct_mset A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset A", "unfolding distinct_mset_count_less_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. count A a \\<le> 1", "proof (rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. count A a \\<le> 1", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. count A a \\<le> 1", "have \\<open>count A a \\<le> count (A + B) a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. count A a \\<le> count (A + B) a", "by auto"], ["proof (state)\nthis:\n  count A a \\<le> count (A + B) a\n\ngoal (1 subgoal):\n 1. \\<And>a. count A a \\<le> 1", "moreover"], ["proof (state)\nthis:\n  count A a \\<le> count (A + B) a\n\ngoal (1 subgoal):\n 1. \\<And>a. count A a \\<le> 1", "have \\<open>count (A + B) a \\<le> 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. count (A + B) a \\<le> 1", "using dist"], ["proof (prove)\nusing this:\n  distinct_mset (A + B)\n\ngoal (1 subgoal):\n 1. count (A + B) a \\<le> 1", "unfolding distinct_mset_count_less_1"], ["proof (prove)\nusing this:\n  \\<forall>a. count (A + B) a \\<le> 1\n\ngoal (1 subgoal):\n 1. count (A + B) a \\<le> 1", "by auto"], ["proof (state)\nthis:\n  count (A + B) a \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>a. count A a \\<le> 1", "ultimately"], ["proof (chain)\npicking this:\n  count A a \\<le> count (A + B) a\n  count (A + B) a \\<le> 1", "show \\<open>count A a \\<le> 1\\<close>"], ["proof (prove)\nusing this:\n  count A a \\<le> count (A + B) a\n  count (A + B) a \\<le> 1\n\ngoal (1 subgoal):\n 1. count A a \\<le> 1", "by simp"], ["proof (state)\nthis:\n  count A a \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_mset_minus[simp]: \"distinct_mset A \\<Longrightarrow> distinct_mset (A - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset A \\<Longrightarrow> distinct_mset (A - B)", "by (metis diff_subset_eq_self mset_subset_eq_exists_conv distinct_mset_union)"], ["", "lemma count_remdups_mset_If: \\<open>count (remdups_mset A) a = (if a \\<in># A then 1 else 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. count (remdups_mset A) a = (if a \\<in># A then 1 else 0)", "unfolding remdups_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. count (mset_set (set_mset A)) a = (if a \\<in># A then 1 else 0)", "by auto"], ["", "lemma distinct_mset_rempdups_union_mset:\n  assumes \"distinct_mset A\" and \"distinct_mset B\"\n  shows \"A \\<union># B = remdups_mset (A + B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union># B = remdups_mset (A + B)", "using assms nat_le_linear"], ["proof (prove)\nusing this:\n  distinct_mset A\n  distinct_mset B\n  ?m \\<le> ?n \\<or> ?n \\<le> ?m\n\ngoal (1 subgoal):\n 1. A \\<union># B = remdups_mset (A + B)", "unfolding remdups_mset_def"], ["proof (prove)\nusing this:\n  distinct_mset A\n  distinct_mset B\n  ?m \\<le> ?n \\<or> ?n \\<le> ?m\n\ngoal (1 subgoal):\n 1. A \\<union># B = mset_set (set_mset (A + B))", "by (force simp add: multiset_eq_iff max_def count_mset_set_if distinct_mset_def not_in_iff)"], ["", "lemma distinct_mset_add_mset[simp]: \"distinct_mset (add_mset a L) \\<longleftrightarrow> a \\<notin># L \\<and> distinct_mset L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset (add_mset a L) = (a \\<notin># L \\<and> distinct_mset L)", "unfolding distinct_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>aa.\n        aa \\<in># add_mset a L \\<longrightarrow>\n        count (add_mset a L) aa = 1) =\n    (a \\<notin># L \\<and>\n     (\\<forall>a. a \\<in># L \\<longrightarrow> count L a = 1))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>aa.\n       aa \\<in># add_mset a L \\<longrightarrow>\n       count (add_mset a L) aa = 1 \\<Longrightarrow>\n    a \\<notin># L \\<and>\n    (\\<forall>a. a \\<in># L \\<longrightarrow> count L a = 1)\n 2. a \\<notin># L \\<and>\n    (\\<forall>a.\n        a \\<in># L \\<longrightarrow> count L a = 1) \\<Longrightarrow>\n    \\<forall>aa.\n       aa \\<in># add_mset a L \\<longrightarrow> count (add_mset a L) aa = 1", "apply (auto split: if_split_asm; fail)[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin># L \\<and>\n    (\\<forall>a.\n        a \\<in># L \\<longrightarrow> count L a = 1) \\<Longrightarrow>\n    \\<forall>aa.\n       aa \\<in># add_mset a L \\<longrightarrow> count (add_mset a L) aa = 1", "by (auto simp: not_in_iff; fail)"], ["", "lemma distinct_mset_size_eq_card: \"distinct_mset C \\<Longrightarrow> size C = card (set_mset C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset C \\<Longrightarrow> size C = card (set_mset C)", "by (induction C) auto"], ["", "lemma distinct_mset_add:\n  \"distinct_mset (L + L') \\<longleftrightarrow> distinct_mset L \\<and> distinct_mset L' \\<and> L \\<inter># L' = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset (L + L') =\n    (distinct_mset L \\<and> distinct_mset L' \\<and> L \\<inter># L' = {#})", "by (induction L arbitrary: L') auto"], ["", "lemma distinct_mset_set_mset_ident[simp]: \"distinct_mset M \\<Longrightarrow> mset_set (set_mset M) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset M \\<Longrightarrow> mset_set (set_mset M) = M", "by (induction M) auto"], ["", "lemma distinct_finite_set_mset_subseteq_iff[iff]:\n  assumes \"distinct_mset M\" \"finite N\"\n  shows \"set_mset M \\<subseteq> N \\<longleftrightarrow> M \\<subseteq># mset_set N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set_mset M \\<subseteq> N) = (M \\<subseteq># mset_set N)", "by (metis assms distinct_mset_set_mset_ident finite_set_mset msubset_mset_set_iff)"], ["", "lemma distinct_mem_diff_mset:\n  assumes dist: \"distinct_mset M\" and mem: \"x \\<in> set_mset (M - N)\"\n  shows \"x \\<notin> set_mset N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin># N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin># N", "have \"count M x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count M x = 1", "using dist mem"], ["proof (prove)\nusing this:\n  distinct_mset M\n  x \\<in># M - N\n\ngoal (1 subgoal):\n 1. count M x = 1", "by (meson distinct_mset_def in_diffD)"], ["proof (state)\nthis:\n  count M x = 1\n\ngoal (1 subgoal):\n 1. x \\<notin># N", "then"], ["proof (chain)\npicking this:\n  count M x = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  count M x = 1\n\ngoal (1 subgoal):\n 1. x \\<notin># N", "using mem"], ["proof (prove)\nusing this:\n  count M x = 1\n  x \\<in># M - N\n\ngoal (1 subgoal):\n 1. x \\<notin># N", "by (metis count_greater_eq_one_iff in_diff_count not_less)"], ["proof (state)\nthis:\n  x \\<notin># N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_set_mset_eq:\n  assumes \"distinct_mset M\" \"distinct_mset N\" \"set_mset M = set_mset N\"\n  shows \"M = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = N", "using assms distinct_mset_set_mset_ident"], ["proof (prove)\nusing this:\n  distinct_mset M\n  distinct_mset N\n  set_mset M = set_mset N\n  distinct_mset ?M \\<Longrightarrow> mset_set (set_mset ?M) = ?M\n\ngoal (1 subgoal):\n 1. M = N", "by fastforce"], ["", "lemma distinct_mset_union_mset[simp]:\n  \\<open>distinct_mset (D \\<union># C) \\<longleftrightarrow> distinct_mset D \\<and> distinct_mset C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset (D \\<union># C) = (distinct_mset D \\<and> distinct_mset C)", "unfolding distinct_mset_count_less_1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a. count (D \\<union># C) a \\<le> 1) =\n    ((\\<forall>a. count D a \\<le> 1) \\<and> (\\<forall>a. count C a \\<le> 1))", "by force"], ["", "lemma distinct_mset_inter_mset:\n  \"distinct_mset C \\<Longrightarrow> distinct_mset (C \\<inter># D)\"\n  \"distinct_mset D \\<Longrightarrow> distinct_mset (C \\<inter># D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (distinct_mset C \\<Longrightarrow> distinct_mset (C \\<inter># D)) &&&\n    (distinct_mset D \\<Longrightarrow> distinct_mset (C \\<inter># D))", "by (simp_all add: multiset_inter_def,\n    metis distinct_mset_minus multiset_inter_commute multiset_inter_def)"], ["", "lemma distinct_mset_remove1_All: \"distinct_mset C \\<Longrightarrow> remove1_mset L C = removeAll_mset L C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset C \\<Longrightarrow> remove1_mset L C = removeAll_mset L C", "by (auto simp: multiset_eq_iff distinct_mset_count_less_1)"], ["", "lemma distinct_mset_size_2: \"distinct_mset {#a, b#} \\<longleftrightarrow> a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset {#a, b#} = (a \\<noteq> b)", "by auto"], ["", "lemma distinct_mset_filter: \"distinct_mset M \\<Longrightarrow> distinct_mset {# L \\<in># M. P L#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset M \\<Longrightarrow> distinct_mset (filter_mset P M)", "by (simp add: distinct_mset_def)"], ["", "lemma distinct_mset_mset_distinct[simp]: \\<open>distinct_mset (mset xs) = distinct xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_mset (mset xs) = distinct xs", "by (induction xs) auto"], ["", "lemma distinct_image_mset_inj:\n  \\<open>inj_on f (set_mset M) \\<Longrightarrow> distinct_mset (image_mset f M) \\<longleftrightarrow> distinct_mset M\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (set_mset M) \\<Longrightarrow>\n    distinct_mset (image_mset f M) = distinct_mset M", "by (induction M) (auto simp: inj_on_def)"], ["", "subsection \\<open>Repeat Operation\\<close>"], ["", "lemma repeat_mset_compower: \"repeat_mset n A = (((+) A) ^^ n) {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat_mset n A = ((+) A ^^ n) {#}", "by (induction n) auto"], ["", "lemma repeat_mset_prod: \"repeat_mset (m * n) A = (((+) (repeat_mset n A)) ^^ m) {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat_mset (m * n) A = ((+) (repeat_mset n A) ^^ m) {#}", "by (induction m) (auto simp: repeat_mset_distrib)"], ["", "subsection \\<open>Cartesian Product\\<close>"], ["", "text \\<open>Definition of the cartesian products over multisets. The construction mimics of the cartesian\n  product on sets and use the same theorem names (adding only the suffix \\<open>_mset\\<close> to Sigma\n  and Times). See file @{file \\<open>~~/src/HOL/Product_Type.thy\\<close>}\\<close>"], ["", "definition Sigma_mset :: \"'a multiset \\<Rightarrow> ('a \\<Rightarrow> 'b multiset) \\<Rightarrow> ('a \\<times> 'b) multiset\" where\n  \"Sigma_mset A B \\<equiv> \\<Sum>\\<^sub># {#{#(a, b). b \\<in># B a#}. a \\<in># A #}\""], ["", "abbreviation Times_mset :: \"'a multiset \\<Rightarrow> 'b multiset \\<Rightarrow> ('a \\<times> 'b) multiset\" (infixr \"\\<times>#\" 80) where\n  \"Times_mset A B \\<equiv> Sigma_mset A (\\<lambda>_. B)\""], ["", "hide_const (open) Times_mset"], ["", "text \\<open>Contrary to the set version @{term \\<open>SIGMA x:A. B\\<close>}, we use the non-ASCII symbol \\<open>\\<in>#\\<close>.\\<close>"], ["", "syntax\n  \"_Sigma_mset\" :: \"[pttrn, 'a multiset, 'b multiset] => ('a * 'b) multiset\"\n  (\"(3SIGMAMSET _\\<in>#_./ _)\" [0, 0, 10] 10)"], ["", "translations\n  \"SIGMAMSET x\\<in>#A. B\" == \"CONST Sigma_mset A (\\<lambda>x. B)\""], ["", "text \\<open>Link between the multiset and the set cartesian product:\\<close>"], ["", "lemma Times_mset_Times: \"set_mset (A \\<times># B) = set_mset A \\<times> set_mset B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (A \\<times># B) = set_mset A \\<times> set_mset B", "unfolding Sigma_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (\\<Sum>a\\<in>#A. image_mset (Pair a) B) =\n    set_mset A \\<times> set_mset B", "by auto"], ["", "lemma Sigma_msetI [intro!]: \"\\<lbrakk>a \\<in># A; b \\<in># B a\\<rbrakk> \\<Longrightarrow> (a, b) \\<in># Sigma_mset A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in># A; b \\<in># B a\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in># Sigma_mset A B", "by (unfold Sigma_mset_def) auto"], ["", "lemma Sigma_msetE[elim!]: \"\\<lbrakk>c \\<in># Sigma_mset A B; \\<And>x y. \\<lbrakk>x \\<in># A; y \\<in># B x; c = (x, y)\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<in># Sigma_mset A B;\n     \\<And>x y.\n        \\<lbrakk>x \\<in># A; y \\<in># B x; c = (x, y)\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (unfold Sigma_mset_def) auto"], ["", "text \\<open>Elimination of @{term \"(a, b) \\<in># A \\<times># B\"} -- introduces no eigenvariables.\\<close>"], ["", "lemma Sigma_msetD1: \"(a, b) \\<in># Sigma_mset A B \\<Longrightarrow> a \\<in># A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in># Sigma_mset A B \\<Longrightarrow> a \\<in># A", "by blast"], ["", "lemma Sigma_msetD2: \"(a, b) \\<in># Sigma_mset A B \\<Longrightarrow> b \\<in># B a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in># Sigma_mset A B \\<Longrightarrow> b \\<in># B a", "by blast"], ["", "lemma Sigma_msetE2: \"\\<lbrakk>(a, b) \\<in># Sigma_mset A B; \\<lbrakk>a \\<in># A; b \\<in># B a\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in># Sigma_mset A B;\n     \\<lbrakk>a \\<in># A; b \\<in># B a\\<rbrakk> \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by blast"], ["", "lemma Sigma_mset_cong:\n  \"\\<lbrakk>A = B; \\<And>x. x \\<in># B \\<Longrightarrow> C x = D x\\<rbrakk> \\<Longrightarrow> (SIGMAMSET x \\<in># A. C x) = (SIGMAMSET x \\<in># B. D x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A = B; \\<And>x. x \\<in># B \\<Longrightarrow> C x = D x\\<rbrakk>\n    \\<Longrightarrow> Sigma_mset A C = Sigma_mset B D", "by (metis (mono_tags, lifting) Sigma_mset_def image_mset_cong)"], ["", "lemma count_sum_mset: \"count (\\<Sum>\\<^sub># M) b = (\\<Sum>P \\<in># M. count P b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (\\<Sum>\\<^sub># M) b = (\\<Sum>P\\<in>#M. count P b)", "by (induction M) auto"], ["", "lemma Sigma_mset_plus_distrib1[simp]: \"Sigma_mset (A + B) C = Sigma_mset A C + Sigma_mset B C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_mset (A + B) C = Sigma_mset A C + Sigma_mset B C", "unfolding Sigma_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>#A + B. image_mset (Pair a) (C a)) =\n    (\\<Sum>a\\<in>#A. image_mset (Pair a) (C a)) +\n    (\\<Sum>a\\<in>#B. image_mset (Pair a) (C a))", "by auto"], ["", "lemma Sigma_mset_plus_distrib2[simp]:\n  \"Sigma_mset A (\\<lambda>i. B i + C i) = Sigma_mset A B + Sigma_mset A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SIGMAMSET i\\<in>#A. B i + C i) = Sigma_mset A B + Sigma_mset A C", "unfolding Sigma_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>#A. image_mset (Pair a) (B a + C a)) =\n    (\\<Sum>a\\<in>#A. image_mset (Pair a) (B a)) +\n    (\\<Sum>a\\<in>#A. image_mset (Pair a) (C a))", "by (induction A) (auto simp: multiset_eq_iff)"], ["", "lemma Times_mset_single_left: \"{#a#} \\<times># B = image_mset (Pair a) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#a#} \\<times># B = image_mset (Pair a) B", "unfolding Sigma_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>#{#a#}. image_mset (Pair a) B) = image_mset (Pair a) B", "by auto"], ["", "lemma Times_mset_single_right: \"A \\<times># {#b#} = image_mset (\\<lambda>a. Pair a b) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<times># {#b#} = {#(a, b). a \\<in># A#}", "unfolding Sigma_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>#A. image_mset (Pair a) {#b#}) = {#(a, b). a \\<in># A#}", "by (induction A) auto"], ["", "lemma Times_mset_single_single[simp]: \"{#a#} \\<times># {#b#} = {#(a, b)#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#a#} \\<times># {#b#} = {#(a, b)#}", "unfolding Sigma_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>#{#a#}. image_mset (Pair a) {#b#}) = {#(a, b)#}", "by simp"], ["", "lemma count_image_mset_Pair:\n  \"count (image_mset (Pair a) B) (x, b) = (if x = a then count B b else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (image_mset (Pair a) B) (x, b) = (if x = a then count B b else 0)", "by (induction B) auto"], ["", "lemma count_Sigma_mset: \"count (Sigma_mset A B) (a, b) = count A a * count (B a) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (Sigma_mset A B) (a, b) = count A a * count (B a) b", "by (induction A) (auto simp: Sigma_mset_def count_image_mset_Pair)"], ["", "lemma Sigma_mset_empty1[simp]: \"Sigma_mset {#} B = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_mset {#} B = {#}", "unfolding Sigma_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<in>#{#}. image_mset (Pair a) (B a)) = {#}", "by auto"], ["", "lemma Sigma_mset_empty2[simp]: \"A \\<times># {#} = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<times># {#} = {#}", "by (auto simp: multiset_eq_iff count_Sigma_mset)"], ["", "lemma Sigma_mset_mono:\n  assumes \"A \\<subseteq># C\" and \"\\<And>x. x \\<in># A \\<Longrightarrow> B x \\<subseteq># D x\"\n  shows \"Sigma_mset A B \\<subseteq># Sigma_mset C D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_mset A B \\<subseteq># Sigma_mset C D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sigma_mset A B \\<subseteq># Sigma_mset C D", "have \"count A a * count (B a) b \\<le> count C a * count (D a) b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. count A a * count (B a) b \\<le> count C a * count (D a) b", "using assms"], ["proof (prove)\nusing this:\n  A \\<subseteq># C\n  ?x \\<in># A \\<Longrightarrow> B ?x \\<subseteq># D ?x\n\ngoal (1 subgoal):\n 1. count A a * count (B a) b \\<le> count C a * count (D a) b", "unfolding subseteq_mset_def"], ["proof (prove)\nusing this:\n  \\<forall>a. count A a \\<le> count C a\n  ?x \\<in># A \\<Longrightarrow>\n  \\<forall>a. count (B ?x) a \\<le> count (D ?x) a\n\ngoal (1 subgoal):\n 1. count A a * count (B a) b \\<le> count C a * count (D a) b", "by (metis count_inI eq_iff mult_eq_0_iff mult_le_mono)"], ["proof (state)\nthis:\n  count A ?a * count (B ?a) ?b \\<le> count C ?a * count (D ?a) ?b\n\ngoal (1 subgoal):\n 1. Sigma_mset A B \\<subseteq># Sigma_mset C D", "then"], ["proof (chain)\npicking this:\n  count A ?a * count (B ?a) ?b \\<le> count C ?a * count (D ?a) ?b", "show ?thesis"], ["proof (prove)\nusing this:\n  count A ?a * count (B ?a) ?b \\<le> count C ?a * count (D ?a) ?b\n\ngoal (1 subgoal):\n 1. Sigma_mset A B \\<subseteq># Sigma_mset C D", "by (auto simp: subseteq_mset_def count_Sigma_mset)"], ["proof (state)\nthis:\n  Sigma_mset A B \\<subseteq># Sigma_mset C D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mem_Sigma_mset_iff[iff]: \"((a,b) \\<in># Sigma_mset A B) = (a \\<in># A \\<and> b \\<in># B a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a, b) \\<in># Sigma_mset A B) = (a \\<in># A \\<and> b \\<in># B a)", "by blast"], ["", "lemma mem_Times_mset_iff: \"x \\<in># A \\<times># B \\<longleftrightarrow> fst x \\<in># A \\<and> snd x \\<in># B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in># A \\<times># B) = (fst x \\<in># A \\<and> snd x \\<in># B)", "by (induct x) simp"], ["", "lemma Sigma_mset_empty_iff: \"(SIGMAMSET i\\<in>#I. X i) = {#} \\<longleftrightarrow> (\\<forall>i\\<in>#I. X i = {#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Sigma_mset I X = {#}) = (\\<forall>i\\<in>#I. X i = {#})", "by (auto simp: Sigma_mset_def)"], ["", "lemma Times_mset_subset_mset_cancel1: \"x \\<in># A \\<Longrightarrow> (A \\<times># B \\<subseteq># A \\<times># C) = (B \\<subseteq># C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in># A \\<Longrightarrow>\n    (A \\<times># B \\<subseteq># A \\<times># C) = (B \\<subseteq># C)", "by (auto simp: subseteq_mset_def count_Sigma_mset)"], ["", "lemma Times_mset_subset_mset_cancel2: \"x \\<in># C \\<Longrightarrow> (A \\<times># C \\<subseteq># B \\<times># C) = (A \\<subseteq># B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in># C \\<Longrightarrow>\n    (A \\<times># C \\<subseteq># B \\<times># C) = (A \\<subseteq># B)", "by (auto simp: subseteq_mset_def count_Sigma_mset)"], ["", "lemma Times_mset_eq_cancel2: \"x \\<in># C \\<Longrightarrow> (A \\<times># C = B \\<times># C) = (A = B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in># C \\<Longrightarrow> (A \\<times># C = B \\<times># C) = (A = B)", "by (auto simp: multiset_eq_iff count_Sigma_mset dest!: in_countE)"], ["", "lemma split_paired_Ball_mset_Sigma_mset[simp]:\n  \"(\\<forall>z\\<in>#Sigma_mset A B. P z) \\<longleftrightarrow> (\\<forall>x\\<in>#A. \\<forall>y\\<in>#B x. P (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>z\\<in>#Sigma_mset A B. P z) =\n    (\\<forall>x\\<in>#A. \\<forall>y\\<in>#B x. P (x, y))", "by blast"], ["", "lemma split_paired_Bex_mset_Sigma_mset[simp]:\n  \"(\\<exists>z\\<in>#Sigma_mset A B. P z) \\<longleftrightarrow> (\\<exists>x\\<in>#A. \\<exists>y\\<in>#B x. P (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>z\\<in>#Sigma_mset A B. P z) =\n    (\\<exists>x\\<in>#A. \\<exists>y\\<in>#B x. P (x, y))", "by blast"], ["", "lemma sum_mset_if_eq_constant:\n  \"(\\<Sum>x\\<in>#M. if a = x then (f x) else 0) = (((+) (f a)) ^^ (count M a)) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>#M. if a = x then f x else (0::'a)) =\n    ((+) (f a) ^^ count M a) (0::'a)", "by (induction M) (auto simp: ac_simps)"], ["", "lemma iterate_op_plus: \"(((+) k) ^^ m) 0 = k * m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((+) k ^^ m) 0 = k * m", "by (induction m) auto"], ["", "lemma untion_image_mset_Pair_distribute:\n  \"\\<Sum>\\<^sub>#{#image_mset (Pair x) (C x). x \\<in># J - I#} =\n   \\<Sum>\\<^sub># {#image_mset (Pair x) (C x). x \\<in># J#} - \\<Sum>\\<^sub>#{#image_mset (Pair x) (C x). x \\<in># I#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>#J - I. image_mset (Pair x) (C x)) =\n    (\\<Sum>x\\<in>#J. image_mset (Pair x) (C x)) -\n    (\\<Sum>x\\<in>#I. image_mset (Pair x) (C x))", "by (auto simp: multiset_eq_iff count_sum_mset count_image_mset_Pair sum_mset_if_eq_constant\n    iterate_op_plus diff_mult_distrib2)"], ["", "lemma Sigma_mset_Un_distrib1: \"Sigma_mset (I \\<union># J) C = Sigma_mset I C \\<union># Sigma_mset J C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_mset (I \\<union># J) C = Sigma_mset I C \\<union># Sigma_mset J C", "by (auto simp: Sigma_mset_def sup_subset_mset_def untion_image_mset_Pair_distribute)"], ["", "lemma Sigma_mset_Un_distrib2: \"(SIGMAMSET i\\<in>#I. A i \\<union># B i) = Sigma_mset I A \\<union># Sigma_mset I B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SIGMAMSET i\\<in>#I. A i \\<union># B i) =\n    Sigma_mset I A \\<union># Sigma_mset I B", "by (auto simp: multiset_eq_iff count_sum_mset count_image_mset_Pair sum_mset_if_eq_constant\n    Sigma_mset_def diff_mult_distrib2 iterate_op_plus max_def not_in_iff)"], ["", "lemma Sigma_mset_Int_distrib1: \"Sigma_mset (I \\<inter># J) C = Sigma_mset I C \\<inter># Sigma_mset J C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_mset (I \\<inter># J) C = Sigma_mset I C \\<inter># Sigma_mset J C", "by (auto simp: multiset_eq_iff count_sum_mset count_image_mset_Pair sum_mset_if_eq_constant\n    Sigma_mset_def iterate_op_plus min_def not_in_iff)"], ["", "lemma Sigma_mset_Int_distrib2: \"(SIGMAMSET i\\<in>#I. A i \\<inter># B i) = Sigma_mset I A \\<inter># Sigma_mset I B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SIGMAMSET i\\<in>#I. A i \\<inter># B i) =\n    Sigma_mset I A \\<inter># Sigma_mset I B", "by (auto simp: multiset_eq_iff count_sum_mset count_image_mset_Pair sum_mset_if_eq_constant\n    Sigma_mset_def iterate_op_plus min_def not_in_iff)"], ["", "lemma Sigma_mset_Diff_distrib1: \"Sigma_mset (I - J) C = Sigma_mset I C - Sigma_mset J C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_mset (I - J) C = Sigma_mset I C - Sigma_mset J C", "by (auto simp: multiset_eq_iff count_sum_mset count_image_mset_Pair sum_mset_if_eq_constant\n    Sigma_mset_def iterate_op_plus min_def not_in_iff diff_mult_distrib2)"], ["", "lemma Sigma_mset_Diff_distrib2: \"(SIGMAMSET i\\<in>#I. A i - B i) = Sigma_mset I A - Sigma_mset I B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SIGMAMSET i\\<in>#I. A i - B i) = Sigma_mset I A - Sigma_mset I B", "by (auto simp: multiset_eq_iff count_sum_mset count_image_mset_Pair sum_mset_if_eq_constant\n    Sigma_mset_def iterate_op_plus min_def not_in_iff diff_mult_distrib)"], ["", "lemma Sigma_mset_Union: \"Sigma_mset (\\<Sum>\\<^sub>#X) B = (\\<Sum>\\<^sub># (image_mset (\\<lambda>A. Sigma_mset A B) X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_mset (\\<Sum>\\<^sub># X) B = (\\<Sum>A\\<in>#X. Sigma_mset A B)", "by (auto simp: multiset_eq_iff count_sum_mset count_image_mset_Pair sum_mset_if_eq_constant\n    Sigma_mset_def iterate_op_plus min_def not_in_iff sum_mset_distrib_left)"], ["", "lemma Times_mset_Un_distrib1: \"(A \\<union># B) \\<times># C = A \\<times># C \\<union># B \\<times># C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<union># B) \\<times># C = A \\<times># C \\<union># B \\<times># C", "by (fact Sigma_mset_Un_distrib1)"], ["", "lemma Times_mset_Int_distrib1: \"(A \\<inter># B) \\<times># C = A \\<times># C \\<inter># B \\<times># C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<inter># B) \\<times># C = A \\<times># C \\<inter># B \\<times># C", "by (fact Sigma_mset_Int_distrib1)"], ["", "lemma Times_mset_Diff_distrib1: \"(A - B) \\<times># C = A \\<times># C - B \\<times># C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - B) \\<times># C = A \\<times># C - B \\<times># C", "by (fact Sigma_mset_Diff_distrib1)"], ["", "lemma Times_mset_empty[simp]: \"A \\<times># B = {#} \\<longleftrightarrow> A = {#} \\<or> B = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<times># B = {#}) = (A = {#} \\<or> B = {#})", "by (auto simp: Sigma_mset_empty_iff)"], ["", "lemma Times_insert_left: \"A \\<times># add_mset x B = A \\<times># B + image_mset (\\<lambda>a. Pair a x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<times># add_mset x B = A \\<times># B + {#(a, x). a \\<in># A#}", "unfolding add_mset_add_single[of x B] Sigma_mset_plus_distrib2"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<times># B + A \\<times># {#x#} =\n    A \\<times># B + {#(a, x). a \\<in># A#}", "by (simp add: Times_mset_single_right)"], ["", "lemma Times_insert_right: \"add_mset a A \\<times># B = A \\<times># B + image_mset (Pair a) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. add_mset a A \\<times># B = A \\<times># B + image_mset (Pair a) B", "unfolding add_mset_add_single[of a A] Sigma_mset_plus_distrib1"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<times># B + {#a#} \\<times># B =\n    A \\<times># B + image_mset (Pair a) B", "by (simp add: Times_mset_single_left)"], ["", "lemma fst_image_mset_times_mset [simp]:\n  \"image_mset fst (A \\<times># B) = (if B = {#} then {#} else repeat_mset (size B) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset fst (A \\<times># B) =\n    (if B = {#} then {#} else repeat_mset (size B) A)", "by (induct B) (auto simp: Times_mset_single_right ac_simps Times_insert_left)"], ["", "lemma snd_image_mset_times_mset [simp]:\n  \"image_mset snd (A \\<times># B) = (if A = {#} then {#} else repeat_mset (size A) B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset snd (A \\<times># B) =\n    (if A = {#} then {#} else repeat_mset (size A) B)", "by (induct B) (auto simp add: Times_mset_single_right Times_insert_left image_mset_const_eq)"], ["", "lemma product_swap_mset: \"image_mset prod.swap (A \\<times># B) = B \\<times># A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset prod.swap (A \\<times># B) = B \\<times># A", "by (induction A) (auto simp add: Times_mset_single_left Times_mset_single_right\n      Times_insert_right Times_insert_left)"], ["", "context\nbegin"], ["", "qualified"], ["", "definition product_mset :: \"'a multiset \\<Rightarrow> 'b multiset \\<Rightarrow> ('a \\<times> 'b) multiset\" where\n  [code_abbrev]: \"product_mset A B = A \\<times># B\""], ["", "lemma member_product_mset: \"x \\<in># product_mset A B \\<longleftrightarrow> x \\<in># A \\<times># B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in># product_mset A B) = (x \\<in># A \\<times># B)", "by (simp add: Multiset_More.product_mset_def)"], ["", "end"], ["", "lemma count_Sigma_mset_abs_def: \"count (Sigma_mset A B) = (\\<lambda>(a, b) \\<Rightarrow> count A a * count (B a) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (Sigma_mset A B) =\n    (\\<lambda>x. case x of (a, b) \\<Rightarrow> count A a * count (B a) b)", "by (auto simp: fun_eq_iff count_Sigma_mset)"], ["", "lemma Times_mset_image_mset1: \"image_mset f A \\<times># B = image_mset (\\<lambda>(a, b). (f a, b)) (A \\<times># B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset f A \\<times># B = {#(f a, b). (a, b) \\<in># A \\<times># B#}", "by (induct B) (auto simp: Times_insert_left)"], ["", "lemma Times_mset_image_mset2: \"A \\<times># image_mset f B = image_mset (\\<lambda>(a, b). (a, f b)) (A \\<times># B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<times># image_mset f B = {#(a, f b). (a, b) \\<in># A \\<times># B#}", "by (induct A) (auto simp: Times_insert_right)"], ["", "lemma sum_le_singleton: \"A \\<subseteq> {x} \\<Longrightarrow> sum f A = (if x \\<in> A then f x else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> {x} \\<Longrightarrow>\n    sum f A = (if x \\<in> A then f x else (0::'b))", "by (auto simp: subset_singleton_iff elim: finite_subset)"], ["", "lemma Times_mset_assoc: \"(A \\<times># B) \\<times># C = image_mset (\\<lambda>(a, b, c). ((a, b), c)) (A \\<times># B \\<times># C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<times># B) \\<times># C =\n    {#((a, b), c). (a, b, c) \\<in># A \\<times># B \\<times># C#}", "by (auto simp: multiset_eq_iff count_Sigma_mset count_image_mset vimage_def Times_mset_Times\n      Int_commute count_eq_zero_iff intro!: trans[OF _ sym[OF sum_le_singleton[of _ \"(_, _, _)\"]]]\n      cong: sum.cong if_cong)"], ["", "subsection \\<open>Transfer Rules\\<close>"], ["", "lemma plus_multiset_transfer[transfer_rule]:\n  \"(rel_fun (rel_mset R) (rel_fun (rel_mset R) (rel_mset R))) (+) (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_mset R) (rel_fun (rel_mset R) (rel_mset R)) (+) (+)", "by (unfold rel_fun_def rel_mset_def)\n    (force dest: list_all2_appendI intro: exI[of _ \"_ @ _\"] conjI[rotated])"], ["", "lemma minus_multiset_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique R\"\n  shows \"(rel_fun (rel_mset R) (rel_fun (rel_mset R) (rel_mset R))) (-) (-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_mset R) (rel_fun (rel_mset R) (rel_mset R)) (-) (-)", "proof (unfold rel_fun_def rel_mset_def, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xs ys xa ya xsa ysa.\n       \\<lbrakk>list_all2 R xs ys; list_all2 R xsa ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsb ysb.\n                            mset xsb = mset xs - mset xsa \\<and>\n                            mset ysb = mset ys - mset ysa \\<and>\n                            list_all2 R xsb ysb", "fix xs ys xs' ys'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xs ys xa ya xsa ysa.\n       \\<lbrakk>list_all2 R xs ys; list_all2 R xsa ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsb ysb.\n                            mset xsb = mset xs - mset xsa \\<and>\n                            mset ysb = mset ys - mset ysa \\<and>\n                            list_all2 R xsb ysb", "assume [transfer_rule]: \"list_all2 R xs ys\" \"list_all2 R xs' ys'\""], ["proof (state)\nthis:\n  list_all2 R xs ys\n  list_all2 R xs' ys'\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys xa ya xsa ysa.\n       \\<lbrakk>list_all2 R xs ys; list_all2 R xsa ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsb ysb.\n                            mset xsb = mset xs - mset xsa \\<and>\n                            mset ysb = mset ys - mset ysa \\<and>\n                            list_all2 R xsb ysb", "have \"list_all2 R (fold remove1 xs' xs) (fold remove1 ys' ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 R (fold remove1 xs' xs) (fold remove1 ys' ys)", "by transfer_prover"], ["proof (state)\nthis:\n  list_all2 R (fold remove1 xs' xs) (fold remove1 ys' ys)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys xa ya xsa ysa.\n       \\<lbrakk>list_all2 R xs ys; list_all2 R xsa ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsb ysb.\n                            mset xsb = mset xs - mset xsa \\<and>\n                            mset ysb = mset ys - mset ysa \\<and>\n                            list_all2 R xsb ysb", "moreover"], ["proof (state)\nthis:\n  list_all2 R (fold remove1 xs' xs) (fold remove1 ys' ys)\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys xa ya xsa ysa.\n       \\<lbrakk>list_all2 R xs ys; list_all2 R xsa ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsb ysb.\n                            mset xsb = mset xs - mset xsa \\<and>\n                            mset ysb = mset ys - mset ysa \\<and>\n                            list_all2 R xsb ysb", "have \"mset (fold remove1 xs' xs) = mset xs - mset xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (fold remove1 xs' xs) = mset xs - mset xs'", "by (induct xs' arbitrary: xs) auto"], ["proof (state)\nthis:\n  mset (fold remove1 xs' xs) = mset xs - mset xs'\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys xa ya xsa ysa.\n       \\<lbrakk>list_all2 R xs ys; list_all2 R xsa ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsb ysb.\n                            mset xsb = mset xs - mset xsa \\<and>\n                            mset ysb = mset ys - mset ysa \\<and>\n                            list_all2 R xsb ysb", "moreover"], ["proof (state)\nthis:\n  mset (fold remove1 xs' xs) = mset xs - mset xs'\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys xa ya xsa ysa.\n       \\<lbrakk>list_all2 R xs ys; list_all2 R xsa ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsb ysb.\n                            mset xsb = mset xs - mset xsa \\<and>\n                            mset ysb = mset ys - mset ysa \\<and>\n                            list_all2 R xsb ysb", "have \"mset (fold remove1 ys' ys) = mset ys - mset ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (fold remove1 ys' ys) = mset ys - mset ys'", "by (induct ys' arbitrary: ys) auto"], ["proof (state)\nthis:\n  mset (fold remove1 ys' ys) = mset ys - mset ys'\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys xa ya xsa ysa.\n       \\<lbrakk>list_all2 R xs ys; list_all2 R xsa ysa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xsb ysb.\n                            mset xsb = mset xs - mset xsa \\<and>\n                            mset ysb = mset ys - mset ysa \\<and>\n                            list_all2 R xsb ysb", "ultimately"], ["proof (chain)\npicking this:\n  list_all2 R (fold remove1 xs' xs) (fold remove1 ys' ys)\n  mset (fold remove1 xs' xs) = mset xs - mset xs'\n  mset (fold remove1 ys' ys) = mset ys - mset ys'", "show \"\\<exists>xs'' ys''.\n    mset xs'' = mset xs - mset xs' \\<and> mset ys'' = mset ys - mset ys' \\<and> list_all2 R xs'' ys''\""], ["proof (prove)\nusing this:\n  list_all2 R (fold remove1 xs' xs) (fold remove1 ys' ys)\n  mset (fold remove1 xs' xs) = mset xs - mset xs'\n  mset (fold remove1 ys' ys) = mset ys - mset ys'\n\ngoal (1 subgoal):\n 1. \\<exists>xs'' ys''.\n       mset xs'' = mset xs - mset xs' \\<and>\n       mset ys'' = mset ys - mset ys' \\<and> list_all2 R xs'' ys''", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs'' ys''.\n     mset xs'' = mset xs - mset xs' \\<and>\n     mset ys'' = mset ys - mset ys' \\<and> list_all2 R xs'' ys''\n\ngoal:\nNo subgoals!", "qed"], ["", "declare rel_mset_Zero[transfer_rule]"], ["", "lemma count_transfer[transfer_rule]:\n  assumes \"bi_unique R\"\n  shows \"(rel_fun (rel_mset R) (rel_fun R (=))) count count\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_mset R) (rel_fun R (=)) count count", "unfolding rel_fun_def rel_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<exists>xs ys.\n           mset xs = x \\<and>\n           mset ys = y \\<and> list_all2 R xs ys) \\<longrightarrow>\n       (\\<forall>xa ya. R xa ya \\<longrightarrow> count x xa = count y ya)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xs ys xa ya.\n       \\<lbrakk>list_all2 R xs ys; R xa ya\\<rbrakk>\n       \\<Longrightarrow> count (mset xs) xa = count (mset ys) ya", "fix x y xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xs ys xa ya.\n       \\<lbrakk>list_all2 R xs ys; R xa ya\\<rbrakk>\n       \\<Longrightarrow> count (mset xs) xa = count (mset ys) ya", "assume \"list_all2 R xs ys\" \"R x y\""], ["proof (state)\nthis:\n  list_all2 R xs ys\n  R x y\n\ngoal (1 subgoal):\n 1. \\<And>x y xs ys xa ya.\n       \\<lbrakk>list_all2 R xs ys; R xa ya\\<rbrakk>\n       \\<Longrightarrow> count (mset xs) xa = count (mset ys) ya", "then"], ["proof (chain)\npicking this:\n  list_all2 R xs ys\n  R x y", "show \"count (mset xs) x = count (mset ys) y\""], ["proof (prove)\nusing this:\n  list_all2 R xs ys\n  R x y\n\ngoal (1 subgoal):\n 1. count (mset xs) x = count (mset ys) y", "proof (induct xs ys rule: list.rel_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. R x y \\<Longrightarrow> count (mset []) x = count (mset []) y\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>R a21 b21;\n        R x y \\<Longrightarrow> count (mset a22) x = count (mset b22) y;\n        R x y\\<rbrakk>\n       \\<Longrightarrow> count (mset (a21 # a22)) x =\n                         count (mset (b21 # b22)) y", "case (Cons x' xs y' ys)"], ["proof (state)\nthis:\n  R x' y'\n  R x y \\<Longrightarrow> count (mset xs) x = count (mset ys) y\n  R x y\n\ngoal (2 subgoals):\n 1. R x y \\<Longrightarrow> count (mset []) x = count (mset []) y\n 2. \\<And>a21 a22 b21 b22.\n       \\<lbrakk>R a21 b21;\n        R x y \\<Longrightarrow> count (mset a22) x = count (mset b22) y;\n        R x y\\<rbrakk>\n       \\<Longrightarrow> count (mset (a21 # a22)) x =\n                         count (mset (b21 # b22)) y", "then"], ["proof (chain)\npicking this:\n  R x' y'\n  R x y \\<Longrightarrow> count (mset xs) x = count (mset ys) y\n  R x y", "show ?case"], ["proof (prove)\nusing this:\n  R x' y'\n  R x y \\<Longrightarrow> count (mset xs) x = count (mset ys) y\n  R x y\n\ngoal (1 subgoal):\n 1. count (mset (x' # xs)) x = count (mset (y' # ys)) y", "using assms"], ["proof (prove)\nusing this:\n  R x' y'\n  R x y \\<Longrightarrow> count (mset xs) x = count (mset ys) y\n  R x y\n  bi_unique R\n\ngoal (1 subgoal):\n 1. count (mset (x' # xs)) x = count (mset (y' # ys)) y", "unfolding bi_unique_alt_def2"], ["proof (prove)\nusing this:\n  R x' y'\n  R x y \\<Longrightarrow> count (mset xs) x = count (mset ys) y\n  R x y\n  rel_fun R (rel_fun R (=)) (=) (=)\n\ngoal (1 subgoal):\n 1. count (mset (x' # xs)) x = count (mset (y' # ys)) y", "by (auto simp: rel_fun_def)"], ["proof (state)\nthis:\n  count (mset (x' # xs)) x = count (mset (y' # ys)) y\n\ngoal (1 subgoal):\n 1. R x y \\<Longrightarrow> count (mset []) x = count (mset []) y", "qed simp"], ["proof (state)\nthis:\n  count (mset xs) x = count (mset ys) y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subseteq_multiset_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique R\" \"right_total R\"\n  shows \"(rel_fun (rel_mset R) (rel_fun (rel_mset R) (=)))\n    (\\<lambda>M N. filter_mset (Domainp R) M \\<subseteq># filter_mset (Domainp R) N) (\\<subseteq>#)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_mset R) (rel_fun (rel_mset R) (=))\n     (\\<lambda>M N.\n         filter_mset (Domainp R) M \\<subseteq># filter_mset (Domainp R) N)\n     (\\<subseteq>#)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_fun (rel_mset R) (rel_fun (rel_mset R) (=))\n     (\\<lambda>M N.\n         filter_mset (Domainp R) M \\<subseteq># filter_mset (Domainp R) N)\n     (\\<subseteq>#)", "have count_filter_mset_less:\n    \"(\\<forall>a. count (filter_mset (Domainp R) M) a \\<le> count (filter_mset (Domainp R) N) a) \\<longleftrightarrow>\n     (\\<forall>a \\<in> {x. Domainp R x}. count M a \\<le> count N a)\" for M and N"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a.\n        count (filter_mset (Domainp R) M) a\n        \\<le> count (filter_mset (Domainp R) N) a) =\n    (\\<forall>a\\<in>{x. Domainp R x}. count M a \\<le> count N a)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>a.\n      count (filter_mset (Domainp R) ?M) a\n      \\<le> count (filter_mset (Domainp R) ?N) a) =\n  (\\<forall>a\\<in>{x. Domainp R x}. count ?M a \\<le> count ?N a)\n\ngoal (1 subgoal):\n 1. rel_fun (rel_mset R) (rel_fun (rel_mset R) (=))\n     (\\<lambda>M N.\n         filter_mset (Domainp R) M \\<subseteq># filter_mset (Domainp R) N)\n     (\\<subseteq>#)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_mset R) (rel_fun (rel_mset R) (=))\n     (\\<lambda>M N.\n         filter_mset (Domainp R) M \\<subseteq># filter_mset (Domainp R) N)\n     (\\<subseteq>#)", "unfolding subseteq_mset_def count_filter_mset_less"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_mset R) (rel_fun (rel_mset R) (=))\n     (\\<lambda>M N.\n         \\<forall>a\\<in>Collect (Domainp R). count M a \\<le> count N a)\n     (\\<lambda>A B. \\<forall>a. count A a \\<le> count B a)", "by transfer_prover"], ["proof (state)\nthis:\n  rel_fun (rel_mset R) (rel_fun (rel_mset R) (=))\n   (\\<lambda>M N.\n       filter_mset (Domainp R) M \\<subseteq># filter_mset (Domainp R) N)\n   (\\<subseteq>#)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_mset_transfer[transfer_rule]:\n  \"R 0 0 \\<Longrightarrow> rel_fun R (rel_fun R R) (+) (+) \\<Longrightarrow> (rel_fun (rel_mset R) R) sum_mset sum_mset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R (0::'a) (0::'b); rel_fun R (rel_fun R R) (+) (+)\\<rbrakk>\n    \\<Longrightarrow> rel_fun (rel_mset R) R \\<Sum>\\<^sub># \\<Sum>\\<^sub>#", "using sum_list_transfer[of R]"], ["proof (prove)\nusing this:\n  \\<lbrakk>R (0::'a) (0::'b); rel_fun R (rel_fun R R) (+) (+)\\<rbrakk>\n  \\<Longrightarrow> rel_fun (list_all2 R) R sum_list sum_list\n\ngoal (1 subgoal):\n 1. \\<lbrakk>R (0::'a) (0::'b); rel_fun R (rel_fun R R) (+) (+)\\<rbrakk>\n    \\<Longrightarrow> rel_fun (rel_mset R) R \\<Sum>\\<^sub># \\<Sum>\\<^sub>#", "unfolding rel_fun_def rel_mset_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>R (0::'a) (0::'b);\n   \\<forall>x y.\n      R x y \\<longrightarrow>\n      (\\<forall>xa ya.\n          R xa ya \\<longrightarrow> R (x + xa) (y + ya))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x y.\n                       list_all2 R x y \\<longrightarrow>\n                       R (sum_list x) (sum_list y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>R (0::'a) (0::'b);\n     \\<forall>x y.\n        R x y \\<longrightarrow>\n        (\\<forall>xa ya.\n            R xa ya \\<longrightarrow> R (x + xa) (y + ya))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x y.\n                         (\\<exists>xs ys.\n                             mset xs = x \\<and>\n                             mset ys = y \\<and>\n                             list_all2 R xs ys) \\<longrightarrow>\n                         R (\\<Sum>\\<^sub># x) (\\<Sum>\\<^sub># y)", "by auto"], ["", "lemma Sigma_mset_transfer[transfer_rule]:\n  \"(rel_fun (rel_mset R) (rel_fun (rel_fun R (rel_mset S)) (rel_mset (rel_prod R S))))\n     Sigma_mset Sigma_mset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_mset R)\n     (rel_fun (rel_fun R (rel_mset S)) (rel_mset (rel_prod R S))) Sigma_mset\n     Sigma_mset", "by (unfold Sigma_mset_def) transfer_prover"], ["", "subsection \\<open>Even More about Multisets\\<close>"], ["", "subsubsection \\<open>Multisets and Functions\\<close>"], ["", "lemma range_image_mset:\n  assumes \"set_mset Ds \\<subseteq> range f\"\n  shows \"Ds \\<in> range (image_mset f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ds \\<in> range (image_mset f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Ds \\<in> range (image_mset f)", "have \"\\<forall>D. D \\<in># Ds \\<longrightarrow> (\\<exists>C. f C = D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>D. D \\<in># Ds \\<longrightarrow> (\\<exists>C. f C = D)", "using assms"], ["proof (prove)\nusing this:\n  set_mset Ds \\<subseteq> range f\n\ngoal (1 subgoal):\n 1. \\<forall>D. D \\<in># Ds \\<longrightarrow> (\\<exists>C. f C = D)", "by blast"], ["proof (state)\nthis:\n  \\<forall>D. D \\<in># Ds \\<longrightarrow> (\\<exists>C. f C = D)\n\ngoal (1 subgoal):\n 1. Ds \\<in> range (image_mset f)", "then"], ["proof (chain)\npicking this:\n  \\<forall>D. D \\<in># Ds \\<longrightarrow> (\\<exists>C. f C = D)", "obtain f_i where\n    f_p: \"\\<forall>D. D \\<in># Ds \\<longrightarrow> (f (f_i D) = D)\""], ["proof (prove)\nusing this:\n  \\<forall>D. D \\<in># Ds \\<longrightarrow> (\\<exists>C. f C = D)\n\ngoal (1 subgoal):\n 1. (\\<And>f_i.\n        \\<forall>D.\n           D \\<in># Ds \\<longrightarrow> f (f_i D) = D \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>D. D \\<in># Ds \\<longrightarrow> f (f_i D) = D\n\ngoal (1 subgoal):\n 1. Ds \\<in> range (image_mset f)", "define Cs where\n    \"Cs \\<equiv> image_mset f_i Ds\""], ["proof (state)\nthis:\n  Cs \\<equiv> image_mset f_i Ds\n\ngoal (1 subgoal):\n 1. Ds \\<in> range (image_mset f)", "from f_p Cs_def"], ["proof (chain)\npicking this:\n  \\<forall>D. D \\<in># Ds \\<longrightarrow> f (f_i D) = D\n  Cs \\<equiv> image_mset f_i Ds", "have \"image_mset f Cs = Ds\""], ["proof (prove)\nusing this:\n  \\<forall>D. D \\<in># Ds \\<longrightarrow> f (f_i D) = D\n  Cs \\<equiv> image_mset f_i Ds\n\ngoal (1 subgoal):\n 1. image_mset f Cs = Ds", "by auto"], ["proof (state)\nthis:\n  image_mset f Cs = Ds\n\ngoal (1 subgoal):\n 1. Ds \\<in> range (image_mset f)", "then"], ["proof (chain)\npicking this:\n  image_mset f Cs = Ds", "show ?thesis"], ["proof (prove)\nusing this:\n  image_mset f Cs = Ds\n\ngoal (1 subgoal):\n 1. Ds \\<in> range (image_mset f)", "by blast"], ["proof (state)\nthis:\n  Ds \\<in> range (image_mset f)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Multisets and Lists\\<close>"], ["", "lemma length_sorted_list_of_multiset[simp]: \"length (sorted_list_of_multiset A) = size A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (sorted_list_of_multiset A) = size A", "by (metis mset_sorted_list_of_multiset size_mset)"], ["", "definition list_of_mset :: \"'a multiset \\<Rightarrow> 'a list\" where\n  \"list_of_mset m = (SOME l. m = mset l)\""], ["", "lemma list_of_mset_exi: \"\\<exists>l. m = mset l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. m = mset l", "using ex_mset"], ["proof (prove)\nusing this:\n  \\<exists>xs. mset xs = ?X\n\ngoal (1 subgoal):\n 1. \\<exists>l. m = mset l", "by metis"], ["", "lemma mset_list_of_mset[simp]: \"mset (list_of_mset m) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (list_of_mset m) = m", "by (metis (mono_tags, lifting) ex_mset list_of_mset_def someI_ex)"], ["", "lemma length_list_of_mset[simp]: \"length (list_of_mset A) = size A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (list_of_mset A) = size A", "unfolding list_of_mset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (SOME l. A = mset l) = size A", "by (metis (mono_tags) ex_mset size_mset someI_ex)"], ["", "lemma range_mset_map:\n  assumes \"set_mset Ds \\<subseteq> range f\"\n  shows \"Ds \\<in> range (\\<lambda>Cl. mset (map f Cl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ds \\<in> range (\\<lambda>Cl. mset (map f Cl))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Ds \\<in> range (\\<lambda>Cl. mset (map f Cl))", "have \"Ds \\<in> range (image_mset f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ds \\<in> range (image_mset f)", "by (simp add: assms range_image_mset)"], ["proof (state)\nthis:\n  Ds \\<in> range (image_mset f)\n\ngoal (1 subgoal):\n 1. Ds \\<in> range (\\<lambda>Cl. mset (map f Cl))", "then"], ["proof (chain)\npicking this:\n  Ds \\<in> range (image_mset f)", "obtain Cs where Cs_p: \"image_mset f Cs = Ds\""], ["proof (prove)\nusing this:\n  Ds \\<in> range (image_mset f)\n\ngoal (1 subgoal):\n 1. (\\<And>Cs.\n        image_mset f Cs = Ds \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  image_mset f Cs = Ds\n\ngoal (1 subgoal):\n 1. Ds \\<in> range (\\<lambda>Cl. mset (map f Cl))", "define Cl where \"Cl = list_of_mset Cs\""], ["proof (state)\nthis:\n  Cl = list_of_mset Cs\n\ngoal (1 subgoal):\n 1. Ds \\<in> range (\\<lambda>Cl. mset (map f Cl))", "then"], ["proof (chain)\npicking this:\n  Cl = list_of_mset Cs", "have \"mset Cl = Cs\""], ["proof (prove)\nusing this:\n  Cl = list_of_mset Cs\n\ngoal (1 subgoal):\n 1. mset Cl = Cs", "by auto"], ["proof (state)\nthis:\n  mset Cl = Cs\n\ngoal (1 subgoal):\n 1. Ds \\<in> range (\\<lambda>Cl. mset (map f Cl))", "then"], ["proof (chain)\npicking this:\n  mset Cl = Cs", "have \"image_mset f (mset Cl) = Ds\""], ["proof (prove)\nusing this:\n  mset Cl = Cs\n\ngoal (1 subgoal):\n 1. image_mset f (mset Cl) = Ds", "using Cs_p"], ["proof (prove)\nusing this:\n  mset Cl = Cs\n  image_mset f Cs = Ds\n\ngoal (1 subgoal):\n 1. image_mset f (mset Cl) = Ds", "by auto"], ["proof (state)\nthis:\n  image_mset f (mset Cl) = Ds\n\ngoal (1 subgoal):\n 1. Ds \\<in> range (\\<lambda>Cl. mset (map f Cl))", "then"], ["proof (chain)\npicking this:\n  image_mset f (mset Cl) = Ds", "have \"mset (map f Cl) = Ds\""], ["proof (prove)\nusing this:\n  image_mset f (mset Cl) = Ds\n\ngoal (1 subgoal):\n 1. mset (map f Cl) = Ds", "by auto"], ["proof (state)\nthis:\n  mset (map f Cl) = Ds\n\ngoal (1 subgoal):\n 1. Ds \\<in> range (\\<lambda>Cl. mset (map f Cl))", "then"], ["proof (chain)\npicking this:\n  mset (map f Cl) = Ds", "show ?thesis"], ["proof (prove)\nusing this:\n  mset (map f Cl) = Ds\n\ngoal (1 subgoal):\n 1. Ds \\<in> range (\\<lambda>Cl. mset (map f Cl))", "by auto"], ["proof (state)\nthis:\n  Ds \\<in> range (\\<lambda>Cl. mset (map f Cl))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_of_mset_empty[iff]: \"list_of_mset m = [] \\<longleftrightarrow> m = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_of_mset m = []) = (m = {#})", "by (metis (mono_tags, lifting) ex_mset list_of_mset_def mset_zero_iff_right someI_ex)"], ["", "lemma in_mset_conv_nth: \"(x \\<in># mset xs) = (\\<exists>i<length xs. xs ! i = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in># mset xs) = (\\<exists>i<length xs. xs ! i = x)", "by (auto simp: in_set_conv_nth)"], ["", "lemma in_mset_sum_list:\n  assumes \"L \\<in># LL\"\n  assumes \"LL \\<in> set Ci\"\n  shows \"L \\<in># sum_list Ci\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<in># sum_list Ci", "using assms"], ["proof (prove)\nusing this:\n  L \\<in># LL\n  LL \\<in> set Ci\n\ngoal (1 subgoal):\n 1. L \\<in># sum_list Ci", "by (induction Ci) auto"], ["", "lemma in_mset_sum_list2:\n  assumes \"L \\<in># sum_list Ci\"\n  obtains LL where\n    \"LL \\<in> set Ci\"\n    \"L \\<in># LL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>LL.\n        \\<lbrakk>LL \\<in> set Ci; L \\<in># LL\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  L \\<in># sum_list Ci\n\ngoal (1 subgoal):\n 1. (\\<And>LL.\n        \\<lbrakk>LL \\<in> set Ci; L \\<in># LL\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (induction Ci) auto"], ["", "(* TODO: Make [simp]. *)"], ["", "lemma in_mset_sum_list_iff: \"a \\<in># sum_list \\<A> \\<longleftrightarrow> (\\<exists>A \\<in> set \\<A>. a \\<in># A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in># sum_list \\<A>) = (\\<exists>A\\<in>set \\<A>. a \\<in># A)", "by (metis in_mset_sum_list in_mset_sum_list2)"], ["", "lemma subseteq_list_Union_mset:\n  assumes \"length Ci = n\"\n  assumes \"length CAi = n\"\n  assumes \"\\<forall>i<n.  Ci ! i \\<subseteq># CAi ! i \"\n  shows \"\\<Sum>\\<^sub># (mset Ci) \\<subseteq># \\<Sum>\\<^sub># (mset CAi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (mset Ci) \\<subseteq># \\<Sum>\\<^sub># (mset CAi)", "using assms"], ["proof (prove)\nusing this:\n  length Ci = n\n  length CAi = n\n  \\<forall>i<n. Ci ! i \\<subseteq># CAi ! i\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (mset Ci) \\<subseteq># \\<Sum>\\<^sub># (mset CAi)", "proof (induction n arbitrary: Ci CAi)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Ci CAi.\n       \\<lbrakk>length Ci = 0; length CAi = 0;\n        \\<forall>i<0. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                         \\<Sum>\\<^sub># (mset CAi)\n 2. \\<And>n Ci CAi.\n       \\<lbrakk>\\<And>Ci CAi.\n                   \\<lbrakk>length Ci = n; length CAi = n;\n                    \\<forall>i<n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                                     \\<Sum>\\<^sub># (mset CAi);\n        length Ci = Suc n; length CAi = Suc n;\n        \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                         \\<Sum>\\<^sub># (mset CAi)", "case 0"], ["proof (state)\nthis:\n  length Ci = 0\n  length CAi = 0\n  \\<forall>i<0. Ci ! i \\<subseteq># CAi ! i\n\ngoal (2 subgoals):\n 1. \\<And>Ci CAi.\n       \\<lbrakk>length Ci = 0; length CAi = 0;\n        \\<forall>i<0. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                         \\<Sum>\\<^sub># (mset CAi)\n 2. \\<And>n Ci CAi.\n       \\<lbrakk>\\<And>Ci CAi.\n                   \\<lbrakk>length Ci = n; length CAi = n;\n                    \\<forall>i<n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                                     \\<Sum>\\<^sub># (mset CAi);\n        length Ci = Suc n; length CAi = Suc n;\n        \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                         \\<Sum>\\<^sub># (mset CAi)", "then"], ["proof (chain)\npicking this:\n  length Ci = 0\n  length CAi = 0\n  \\<forall>i<0. Ci ! i \\<subseteq># CAi ! i", "show ?case"], ["proof (prove)\nusing this:\n  length Ci = 0\n  length CAi = 0\n  \\<forall>i<0. Ci ! i \\<subseteq># CAi ! i\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (mset Ci) \\<subseteq># \\<Sum>\\<^sub># (mset CAi)", "by auto"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (mset Ci) \\<subseteq># \\<Sum>\\<^sub># (mset CAi)\n\ngoal (1 subgoal):\n 1. \\<And>n Ci CAi.\n       \\<lbrakk>\\<And>Ci CAi.\n                   \\<lbrakk>length Ci = n; length CAi = n;\n                    \\<forall>i<n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                                     \\<Sum>\\<^sub># (mset CAi);\n        length Ci = Suc n; length CAi = Suc n;\n        \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                         \\<Sum>\\<^sub># (mset CAi)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n Ci CAi.\n       \\<lbrakk>\\<And>Ci CAi.\n                   \\<lbrakk>length Ci = n; length CAi = n;\n                    \\<forall>i<n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                                     \\<Sum>\\<^sub># (mset CAi);\n        length Ci = Suc n; length CAi = Suc n;\n        \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                         \\<Sum>\\<^sub># (mset CAi)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?Ci = n; length ?CAi = n;\n   \\<forall>i<n. ?Ci ! i \\<subseteq># ?CAi ! i\\<rbrakk>\n  \\<Longrightarrow> \\<Sum>\\<^sub># (mset ?Ci) \\<subseteq>#\n                    \\<Sum>\\<^sub># (mset ?CAi)\n  length Ci = Suc n\n  length CAi = Suc n\n  \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\n\ngoal (1 subgoal):\n 1. \\<And>n Ci CAi.\n       \\<lbrakk>\\<And>Ci CAi.\n                   \\<lbrakk>length Ci = n; length CAi = n;\n                    \\<forall>i<n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                                     \\<Sum>\\<^sub># (mset CAi);\n        length Ci = Suc n; length CAi = Suc n;\n        \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                         \\<Sum>\\<^sub># (mset CAi)", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?Ci = n; length ?CAi = n;\n   \\<forall>i<n. ?Ci ! i \\<subseteq># ?CAi ! i\\<rbrakk>\n  \\<Longrightarrow> \\<Sum>\\<^sub># (mset ?Ci) \\<subseteq>#\n                    \\<Sum>\\<^sub># (mset ?CAi)\n  length Ci = Suc n\n  length CAi = Suc n\n  \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i", "have \"\\<forall>i<n. tl Ci ! i \\<subseteq># tl CAi ! i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?Ci = n; length ?CAi = n;\n   \\<forall>i<n. ?Ci ! i \\<subseteq># ?CAi ! i\\<rbrakk>\n  \\<Longrightarrow> \\<Sum>\\<^sub># (mset ?Ci) \\<subseteq>#\n                    \\<Sum>\\<^sub># (mset ?CAi)\n  length Ci = Suc n\n  length CAi = Suc n\n  \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. tl Ci ! i \\<subseteq># tl CAi ! i", "by (simp add: nth_tl)"], ["proof (state)\nthis:\n  \\<forall>i<n. tl Ci ! i \\<subseteq># tl CAi ! i\n\ngoal (1 subgoal):\n 1. \\<And>n Ci CAi.\n       \\<lbrakk>\\<And>Ci CAi.\n                   \\<lbrakk>length Ci = n; length CAi = n;\n                    \\<forall>i<n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                                     \\<Sum>\\<^sub># (mset CAi);\n        length Ci = Suc n; length CAi = Suc n;\n        \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                         \\<Sum>\\<^sub># (mset CAi)", "hence \"\\<Sum>\\<^sub>#(mset (tl Ci)) \\<subseteq># \\<Sum>\\<^sub>#(mset (tl CAi))\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. tl Ci ! i \\<subseteq># tl CAi ! i\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (mset (tl Ci)) \\<subseteq>#\n    \\<Sum>\\<^sub># (mset (tl CAi))", "using Suc"], ["proof (prove)\nusing this:\n  \\<forall>i<n. tl Ci ! i \\<subseteq># tl CAi ! i\n  \\<lbrakk>length ?Ci = n; length ?CAi = n;\n   \\<forall>i<n. ?Ci ! i \\<subseteq># ?CAi ! i\\<rbrakk>\n  \\<Longrightarrow> \\<Sum>\\<^sub># (mset ?Ci) \\<subseteq>#\n                    \\<Sum>\\<^sub># (mset ?CAi)\n  length Ci = Suc n\n  length CAi = Suc n\n  \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (mset (tl Ci)) \\<subseteq>#\n    \\<Sum>\\<^sub># (mset (tl CAi))", "by auto"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (mset (tl Ci)) \\<subseteq># \\<Sum>\\<^sub># (mset (tl CAi))\n\ngoal (1 subgoal):\n 1. \\<And>n Ci CAi.\n       \\<lbrakk>\\<And>Ci CAi.\n                   \\<lbrakk>length Ci = n; length CAi = n;\n                    \\<forall>i<n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                                     \\<Sum>\\<^sub># (mset CAi);\n        length Ci = Suc n; length CAi = Suc n;\n        \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                         \\<Sum>\\<^sub># (mset CAi)", "moreover"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (mset (tl Ci)) \\<subseteq># \\<Sum>\\<^sub># (mset (tl CAi))\n\ngoal (1 subgoal):\n 1. \\<And>n Ci CAi.\n       \\<lbrakk>\\<And>Ci CAi.\n                   \\<lbrakk>length Ci = n; length CAi = n;\n                    \\<forall>i<n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                                     \\<Sum>\\<^sub># (mset CAi);\n        length Ci = Suc n; length CAi = Suc n;\n        \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                         \\<Sum>\\<^sub># (mset CAi)", "have \"hd Ci \\<subseteq># hd CAi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd Ci \\<subseteq># hd CAi", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?Ci = n; length ?CAi = n;\n   \\<forall>i<n. ?Ci ! i \\<subseteq># ?CAi ! i\\<rbrakk>\n  \\<Longrightarrow> \\<Sum>\\<^sub># (mset ?Ci) \\<subseteq>#\n                    \\<Sum>\\<^sub># (mset ?CAi)\n  length Ci = Suc n\n  length CAi = Suc n\n  \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\n\ngoal (1 subgoal):\n 1. hd Ci \\<subseteq># hd CAi", "by (metis hd_conv_nth length_greater_0_conv zero_less_Suc)"], ["proof (state)\nthis:\n  hd Ci \\<subseteq># hd CAi\n\ngoal (1 subgoal):\n 1. \\<And>n Ci CAi.\n       \\<lbrakk>\\<And>Ci CAi.\n                   \\<lbrakk>length Ci = n; length CAi = n;\n                    \\<forall>i<n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                                     \\<Sum>\\<^sub># (mset CAi);\n        length Ci = Suc n; length CAi = Suc n;\n        \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (mset Ci) \\<subseteq>#\n                         \\<Sum>\\<^sub># (mset CAi)", "ultimately"], ["proof (chain)\npicking this:\n  \\<Sum>\\<^sub># (mset (tl Ci)) \\<subseteq># \\<Sum>\\<^sub># (mset (tl CAi))\n  hd Ci \\<subseteq># hd CAi", "show \"\\<Sum>\\<^sub>#(mset Ci) \\<subseteq># \\<Sum>\\<^sub>#(mset CAi)\""], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (mset (tl Ci)) \\<subseteq># \\<Sum>\\<^sub># (mset (tl CAi))\n  hd Ci \\<subseteq># hd CAi\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (mset Ci) \\<subseteq># \\<Sum>\\<^sub># (mset CAi)", "using Suc"], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (mset (tl Ci)) \\<subseteq># \\<Sum>\\<^sub># (mset (tl CAi))\n  hd Ci \\<subseteq># hd CAi\n  \\<lbrakk>length ?Ci = n; length ?CAi = n;\n   \\<forall>i<n. ?Ci ! i \\<subseteq># ?CAi ! i\\<rbrakk>\n  \\<Longrightarrow> \\<Sum>\\<^sub># (mset ?Ci) \\<subseteq>#\n                    \\<Sum>\\<^sub># (mset ?CAi)\n  length Ci = Suc n\n  length CAi = Suc n\n  \\<forall>i<Suc n. Ci ! i \\<subseteq># CAi ! i\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (mset Ci) \\<subseteq># \\<Sum>\\<^sub># (mset CAi)", "by (cases Ci; cases CAi) (auto intro: subset_mset.add_mono)"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (mset Ci) \\<subseteq># \\<Sum>\\<^sub># (mset CAi)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>More on Multisets and Functions\\<close>"], ["", "lemma subseteq_mset_size_eql: \"X \\<subseteq># Y \\<Longrightarrow> size Y = size X \\<Longrightarrow> X = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<subseteq># Y; size Y = size X\\<rbrakk>\n    \\<Longrightarrow> X = Y", "using mset_subset_size subset_mset_def"], ["proof (prove)\nusing this:\n  ?A \\<subset># ?B \\<Longrightarrow> size ?A < size ?B\n  (?A \\<subset># ?B) = (?A \\<subseteq># ?B \\<and> ?A \\<noteq> ?B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<subseteq># Y; size Y = size X\\<rbrakk>\n    \\<Longrightarrow> X = Y", "by fastforce"], ["", "lemma image_mset_of_subset_list:\n  assumes \"image_mset \\<eta> C' = mset lC\"\n  shows \"\\<exists>qC'. map \\<eta> qC' = lC \\<and> mset qC' = C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>qC'. map \\<eta> qC' = lC \\<and> mset qC' = C'", "using assms"], ["proof (prove)\nusing this:\n  image_mset \\<eta> C' = mset lC\n\ngoal (1 subgoal):\n 1. \\<exists>qC'. map \\<eta> qC' = lC \\<and> mset qC' = C'", "apply (induction lC arbitrary: C')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>C'.\n       image_mset \\<eta> C' = mset [] \\<Longrightarrow>\n       \\<exists>qC'. map \\<eta> qC' = [] \\<and> mset qC' = C'\n 2. \\<And>a lC C'.\n       \\<lbrakk>\\<And>C'.\n                   image_mset \\<eta> C' = mset lC \\<Longrightarrow>\n                   \\<exists>qC'. map \\<eta> qC' = lC \\<and> mset qC' = C';\n        image_mset \\<eta> C' = mset (a # lC)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>qC'.\n                            map \\<eta> qC' = a # lC \\<and> mset qC' = C'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset \\<eta> C'_ = mset [] \\<Longrightarrow>\n    \\<exists>qC'. map \\<eta> qC' = [] \\<and> mset qC' = C'_", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a lC C'.\n       \\<lbrakk>\\<And>C'.\n                   image_mset \\<eta> C' = mset lC \\<Longrightarrow>\n                   \\<exists>qC'. map \\<eta> qC' = lC \\<and> mset qC' = C';\n        image_mset \\<eta> C' = mset (a # lC)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>qC'.\n                            map \\<eta> qC' = a # lC \\<and> mset qC' = C'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>C'.\n                image_mset \\<eta> C' = mset lC_ \\<Longrightarrow>\n                \\<exists>qC'. map \\<eta> qC' = lC_ \\<and> mset qC' = C';\n     image_mset \\<eta> C'_ = mset (a_ # lC_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>qC'.\n                         map \\<eta> qC' = a_ # lC_ \\<and> mset qC' = C'_", "by (fastforce dest!: msed_map_invR intro: exI[of _ \\<open>_ # _\\<close>])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma image_mset_of_subset:\n  assumes \"A \\<subseteq># image_mset \\<eta> C'\"\n  shows \"\\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "define C where \"C = image_mset \\<eta> C'\""], ["proof (state)\nthis:\n  C = image_mset \\<eta> C'\n\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "define lA where \"lA = list_of_mset A\""], ["proof (state)\nthis:\n  lA = list_of_mset A\n\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "define lD where \"lD = list_of_mset (C-A)\""], ["proof (state)\nthis:\n  lD = list_of_mset (C - A)\n\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "define lC where \"lC = lA @ lD\""], ["proof (state)\nthis:\n  lC = lA @ lD\n\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "have \"mset lC = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset lC = C", "using C_def assms"], ["proof (prove)\nusing this:\n  C = image_mset \\<eta> C'\n  A \\<subseteq># image_mset \\<eta> C'\n\ngoal (1 subgoal):\n 1. mset lC = C", "unfolding lD_def lC_def lA_def"], ["proof (prove)\nusing this:\n  C = image_mset \\<eta> C'\n  A \\<subseteq># image_mset \\<eta> C'\n\ngoal (1 subgoal):\n 1. mset (list_of_mset A @ list_of_mset (C - A)) = C", "by auto"], ["proof (state)\nthis:\n  mset lC = C\n\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "then"], ["proof (chain)\npicking this:\n  mset lC = C", "have \"\\<exists>qC'. map \\<eta> qC' = lC \\<and> mset qC' = C'\""], ["proof (prove)\nusing this:\n  mset lC = C\n\ngoal (1 subgoal):\n 1. \\<exists>qC'. map \\<eta> qC' = lC \\<and> mset qC' = C'", "using assms image_mset_of_subset_list"], ["proof (prove)\nusing this:\n  mset lC = C\n  A \\<subseteq># image_mset \\<eta> C'\n  image_mset ?\\<eta> ?C' = mset ?lC \\<Longrightarrow>\n  \\<exists>qC'. map ?\\<eta> qC' = ?lC \\<and> mset qC' = ?C'\n\ngoal (1 subgoal):\n 1. \\<exists>qC'. map \\<eta> qC' = lC \\<and> mset qC' = C'", "unfolding C_def"], ["proof (prove)\nusing this:\n  mset lC = image_mset \\<eta> C'\n  A \\<subseteq># image_mset \\<eta> C'\n  image_mset ?\\<eta> ?C' = mset ?lC \\<Longrightarrow>\n  \\<exists>qC'. map ?\\<eta> qC' = ?lC \\<and> mset qC' = ?C'\n\ngoal (1 subgoal):\n 1. \\<exists>qC'. map \\<eta> qC' = lC \\<and> mset qC' = C'", "by metis"], ["proof (state)\nthis:\n  \\<exists>qC'. map \\<eta> qC' = lC \\<and> mset qC' = C'\n\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "then"], ["proof (chain)\npicking this:\n  \\<exists>qC'. map \\<eta> qC' = lC \\<and> mset qC' = C'", "obtain qC' where qC'_p: \"map \\<eta> qC' = lC \\<and> mset qC' = C'\""], ["proof (prove)\nusing this:\n  \\<exists>qC'. map \\<eta> qC' = lC \\<and> mset qC' = C'\n\ngoal (1 subgoal):\n 1. (\\<And>qC'.\n        map \\<eta> qC' = lC \\<and> mset qC' = C' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  map \\<eta> qC' = lC \\<and> mset qC' = C'\n\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "let ?lA' = \"take (length lA) qC'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "have m: \"map \\<eta> ?lA' = lA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map \\<eta> (take (length lA) qC') = lA", "using qC'_p lC_def"], ["proof (prove)\nusing this:\n  map \\<eta> qC' = lC \\<and> mset qC' = C'\n  lC = lA @ lD\n\ngoal (1 subgoal):\n 1. map \\<eta> (take (length lA) qC') = lA", "by (metis append_eq_conv_conj take_map)"], ["proof (state)\nthis:\n  map \\<eta> (take (length lA) qC') = lA\n\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "let ?A' = \"mset ?lA'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "have \"image_mset \\<eta> ?A' = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset \\<eta> (mset (take (length lA) qC')) = A", "using m"], ["proof (prove)\nusing this:\n  map \\<eta> (take (length lA) qC') = lA\n\ngoal (1 subgoal):\n 1. image_mset \\<eta> (mset (take (length lA) qC')) = A", "using lA_def"], ["proof (prove)\nusing this:\n  map \\<eta> (take (length lA) qC') = lA\n  lA = list_of_mset A\n\ngoal (1 subgoal):\n 1. image_mset \\<eta> (mset (take (length lA) qC')) = A", "by (metis (full_types) ex_mset list_of_mset_def mset_map someI_ex)"], ["proof (state)\nthis:\n  image_mset \\<eta> (mset (take (length lA) qC')) = A\n\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "moreover"], ["proof (state)\nthis:\n  image_mset \\<eta> (mset (take (length lA) qC')) = A\n\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "have \"?A' \\<subseteq># C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (take (length lA) qC') \\<subseteq># C'", "using qC'_p"], ["proof (prove)\nusing this:\n  map \\<eta> qC' = lC \\<and> mset qC' = C'\n\ngoal (1 subgoal):\n 1. mset (take (length lA) qC') \\<subseteq># C'", "unfolding lA_def"], ["proof (prove)\nusing this:\n  map \\<eta> qC' = lC \\<and> mset qC' = C'\n\ngoal (1 subgoal):\n 1. mset (take (length (list_of_mset A)) qC') \\<subseteq># C'", "using mset_take_subseteq"], ["proof (prove)\nusing this:\n  map \\<eta> qC' = lC \\<and> mset qC' = C'\n  mset (take ?n ?xs) \\<subseteq># mset ?xs\n\ngoal (1 subgoal):\n 1. mset (take (length (list_of_mset A)) qC') \\<subseteq># C'", "by blast"], ["proof (state)\nthis:\n  mset (take (length lA) qC') \\<subseteq># C'\n\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "ultimately"], ["proof (chain)\npicking this:\n  image_mset \\<eta> (mset (take (length lA) qC')) = A\n  mset (take (length lA) qC') \\<subseteq># C'", "show ?thesis"], ["proof (prove)\nusing this:\n  image_mset \\<eta> (mset (take (length lA) qC')) = A\n  mset (take (length lA) qC') \\<subseteq># C'\n\ngoal (1 subgoal):\n 1. \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'", "by blast"], ["proof (state)\nthis:\n  \\<exists>A'. image_mset \\<eta> A' = A \\<and> A' \\<subseteq># C'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_the_same: \"\\<forall>x \\<in># X. x = y \\<Longrightarrow> card (set_mset X) \\<le> Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>#X. x = y \\<Longrightarrow> card (set_mset X) \\<le> Suc 0", "by (metis card.empty card.insert card_mono finite.intros(1) finite_insert le_SucI singletonI subsetI)"], ["", "lemma Melem_subseteq_Union_mset[simp]:\n  assumes \"x \\<in># T\"\n  shows \"x \\<subseteq># \\<Sum>\\<^sub>#T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<subseteq># \\<Sum>\\<^sub># T", "using assms sum_mset.remove"], ["proof (prove)\nusing this:\n  x \\<in># T\n  ?x \\<in># ?A \\<Longrightarrow>\n  \\<Sum>\\<^sub># ?A = ?x + \\<Sum>\\<^sub># (remove1_mset ?x ?A)\n\ngoal (1 subgoal):\n 1. x \\<subseteq># \\<Sum>\\<^sub># T", "by force"], ["", "lemma Melem_subset_eq_sum_list[simp]:\n  assumes \"x \\<in># mset T\"\n  shows \"x \\<subseteq># sum_list T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<subseteq># sum_list T", "using assms"], ["proof (prove)\nusing this:\n  x \\<in># mset T\n\ngoal (1 subgoal):\n 1. x \\<subseteq># sum_list T", "by (metis mset_subset_eq_add_left sum_mset.remove sum_mset_sum_list)"], ["", "lemma less_subset_eq_Union_mset[simp]:\n  assumes \"i < length CAi\"\n  shows \"CAi ! i \\<subseteq># \\<Sum>\\<^sub>#(mset CAi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CAi ! i \\<subseteq># \\<Sum>\\<^sub># (mset CAi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CAi ! i \\<subseteq># \\<Sum>\\<^sub># (mset CAi)", "from assms"], ["proof (chain)\npicking this:\n  i < length CAi", "have \"CAi ! i \\<in># mset CAi\""], ["proof (prove)\nusing this:\n  i < length CAi\n\ngoal (1 subgoal):\n 1. CAi ! i \\<in># mset CAi", "by auto"], ["proof (state)\nthis:\n  CAi ! i \\<in># mset CAi\n\ngoal (1 subgoal):\n 1. CAi ! i \\<subseteq># \\<Sum>\\<^sub># (mset CAi)", "then"], ["proof (chain)\npicking this:\n  CAi ! i \\<in># mset CAi", "show ?thesis"], ["proof (prove)\nusing this:\n  CAi ! i \\<in># mset CAi\n\ngoal (1 subgoal):\n 1. CAi ! i \\<subseteq># \\<Sum>\\<^sub># (mset CAi)", "by auto"], ["proof (state)\nthis:\n  CAi ! i \\<subseteq># \\<Sum>\\<^sub># (mset CAi)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_subset_eq_sum_list[simp]:\n  assumes \"i < length CAi\"\n  shows \"CAi ! i \\<subseteq># sum_list CAi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CAi ! i \\<subseteq># sum_list CAi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CAi ! i \\<subseteq># sum_list CAi", "from assms"], ["proof (chain)\npicking this:\n  i < length CAi", "have \"CAi ! i \\<in># mset CAi\""], ["proof (prove)\nusing this:\n  i < length CAi\n\ngoal (1 subgoal):\n 1. CAi ! i \\<in># mset CAi", "by auto"], ["proof (state)\nthis:\n  CAi ! i \\<in># mset CAi\n\ngoal (1 subgoal):\n 1. CAi ! i \\<subseteq># sum_list CAi", "then"], ["proof (chain)\npicking this:\n  CAi ! i \\<in># mset CAi", "show ?thesis"], ["proof (prove)\nusing this:\n  CAi ! i \\<in># mset CAi\n\ngoal (1 subgoal):\n 1. CAi ! i \\<subseteq># sum_list CAi", "by auto"], ["proof (state)\nthis:\n  CAi ! i \\<subseteq># sum_list CAi\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>More on Multiset Order\\<close>"], ["", "lemma less_multiset_doubletons:\n  assumes\n    \"y < t \\<or> y < s\"  \n    \"x < t \\<or> x < s\" \n  shows \n    \"{#y, x#} < {#t, s#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#y, x#} < {#t, s#}", "unfolding less_multiset\\<^sub>D\\<^sub>M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X Y.\n       X \\<noteq> {#} \\<and>\n       X \\<subseteq># {#t, s#} \\<and>\n       {#y, x#} = {#t, s#} - X + Y \\<and>\n       (\\<forall>k.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a. a \\<in># X \\<and> k < a))", "proof (intro exI)"], ["proof (state)\ngoal (1 subgoal):\n 1. ?X \\<noteq> {#} \\<and>\n    ?X \\<subseteq># {#t, s#} \\<and>\n    {#y, x#} = {#t, s#} - ?X + ?Y1 \\<and>\n    (\\<forall>k.\n        k \\<in># ?Y1 \\<longrightarrow>\n        (\\<exists>a. a \\<in># ?X \\<and> k < a))", "let ?X = \"{#t, s#}\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?X \\<noteq> {#} \\<and>\n    ?X \\<subseteq># {#t, s#} \\<and>\n    {#y, x#} = {#t, s#} - ?X + ?Y1 \\<and>\n    (\\<forall>k.\n        k \\<in># ?Y1 \\<longrightarrow>\n        (\\<exists>a. a \\<in># ?X \\<and> k < a))", "let ?Y = \"{#y, x#}\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?X \\<noteq> {#} \\<and>\n    ?X \\<subseteq># {#t, s#} \\<and>\n    {#y, x#} = {#t, s#} - ?X + ?Y1 \\<and>\n    (\\<forall>k.\n        k \\<in># ?Y1 \\<longrightarrow>\n        (\\<exists>a. a \\<in># ?X \\<and> k < a))", "show \"?X \\<noteq> {#} \\<and> ?X \\<subseteq># {#t, s#} \\<and> {#y, x#} = {#t, s#} - ?X + ?Y\n    \\<and> (\\<forall>k. k \\<in># ?Y \\<longrightarrow> (\\<exists>a. a \\<in># ?X \\<and> k < a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#t, s#} \\<noteq> {#} \\<and>\n    {#t, s#} \\<subseteq># {#t, s#} \\<and>\n    {#y, x#} = {#t, s#} - {#t, s#} + {#y, x#} \\<and>\n    (\\<forall>k.\n        k \\<in># {#y, x#} \\<longrightarrow>\n        (\\<exists>a. a \\<in># {#t, s#} \\<and> k < a))", "using add_eq_conv_diff assms"], ["proof (prove)\nusing this:\n  (add_mset ?a ?M = add_mset ?b ?N) =\n  (?M = ?N \\<and> ?a = ?b \\<or>\n   ?M = add_mset ?b (remove1_mset ?a ?N) \\<and>\n   ?N = add_mset ?a (remove1_mset ?b ?M))\n  y < t \\<or> y < s\n  x < t \\<or> x < s\n\ngoal (1 subgoal):\n 1. {#t, s#} \\<noteq> {#} \\<and>\n    {#t, s#} \\<subseteq># {#t, s#} \\<and>\n    {#y, x#} = {#t, s#} - {#t, s#} + {#y, x#} \\<and>\n    (\\<forall>k.\n        k \\<in># {#y, x#} \\<longrightarrow>\n        (\\<exists>a. a \\<in># {#t, s#} \\<and> k < a))", "by auto"], ["proof (state)\nthis:\n  {#t, s#} \\<noteq> {#} \\<and>\n  {#t, s#} \\<subseteq># {#t, s#} \\<and>\n  {#y, x#} = {#t, s#} - {#t, s#} + {#y, x#} \\<and>\n  (\\<forall>k.\n      k \\<in># {#y, x#} \\<longrightarrow>\n      (\\<exists>a. a \\<in># {#t, s#} \\<and> k < a))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}