{"file_name": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals/Goodstein_Sequence.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals", "problem_names": ["lemma div_mult_le: \"m div n * n \\<le> m\" for m n :: nat", "lemma power_div_same_base:\n  \"b ^ y \\<noteq> 0 \\<Longrightarrow> x \\<ge> y \\<Longrightarrow> b ^ x div b ^ y = b ^ (x - y)\" for b :: \"'a::semidom_divide\"", "lemma well_base_filter: \"well_base M \\<Longrightarrow> well_base {#m \\<in># M. p m#}\"", "lemma well_base_image_inj: \"well_base M \\<Longrightarrow> inj_on f (set_mset M) \\<Longrightarrow> well_base (image_mset f M)\"", "lemma well_base_bound:\n  assumes\n    \"well_base M\" and\n    \"\\<forall>m \\<in># M. m < n\"\n  shows \"(\\<Sum>m \\<in># M. base ^ m) < base ^ n\"", "lemma well_base\\<^sub>h_mono_hmset: \"well_base\\<^sub>h M \\<Longrightarrow> hmsetmset N \\<subseteq># hmsetmset M \\<Longrightarrow> well_base\\<^sub>h N\"", "lemma well_base\\<^sub>h_imp_well_base: \"well_base\\<^sub>h M \\<Longrightarrow> well_base (hmsetmset M)\"", "lemma encode_0[simp]: \"encode e 0 = 0\"", "lemma encode_Suc:\n  \"encode e (Suc n) = of_nat (Suc n mod base) * \\<omega>^(encode 0 e) + encode (e + 1) (Suc n div base)\"", "lemma encode_0_iff: \"encode e n = 0 \\<longleftrightarrow> n = 0\"", "lemma encode_Suc_exp: \"encode (Suc e) n = encode e (base * n)\"", "lemma encode_exp_0: \"encode e n = encode 0 (base ^ e * n)\"", "lemma mem_hmsetmset_encodeD: \"M \\<in># hmsetmset (encode e n) \\<Longrightarrow> \\<exists>e' \\<ge> e. M = encode 0 e'\"", "lemma less_imp_encode_less: \"n < p \\<Longrightarrow> encode e n < encode e p\"", "lemma aligned\\<^sub>e_encode: \"aligned\\<^sub>e e (encode e M)\"", "lemma well_base\\<^sub>h_encode: \"well_base\\<^sub>h (encode e n)\"", "lemma decode_unfold: \"decode e M = (\\<Sum>m \\<in># hmsetmset M. base ^ decode 0 m) div base ^ e\"", "lemma decode_0[simp]: \"decode e 0 = 0\"", "lemma aligned\\<^sub>d_0[simp]: \"aligned\\<^sub>d 0 M\"", "lemma aligned\\<^sub>d_mono_exp_Suc: \"aligned\\<^sub>d (Suc e) M \\<Longrightarrow> aligned\\<^sub>d e M\"", "lemma aligned\\<^sub>d_mono_hmset:\n  assumes \"aligned\\<^sub>d e M\" and \"hmsetmset M' \\<subseteq># hmsetmset M\"\n  shows \"aligned\\<^sub>d e M'\"", "lemma decode_exp_shift_Suc:\n  assumes align\\<^sub>d: \"aligned\\<^sub>d (Suc e) M\"\n  shows \"decode e M = base * decode (Suc e) M\"", "lemma decode_exp_shift:\n  assumes \"aligned\\<^sub>d e M\"\n  shows \"decode 0 M = base ^ e * decode e M\"", "lemma decode_plus:\n  assumes align\\<^sub>d_M: \"aligned\\<^sub>d e M\"\n  shows \"decode e (M + N) = decode e M + decode e N\"", "lemma less_imp_decode_less:\n  assumes\n    \"well_base\\<^sub>h M\" and\n    \"aligned\\<^sub>d e M\" and\n    \"aligned\\<^sub>d e N\" and\n    \"M < N\"\n  shows \"decode e M < decode e N\"", "lemma inj_decode: \"inj_on (decode e) {M. well_base\\<^sub>h M \\<and> aligned\\<^sub>d e M}\"", "lemma decode_0_iff: \"well_base\\<^sub>h M \\<Longrightarrow> aligned\\<^sub>d e M \\<Longrightarrow> decode e M = 0 \\<longleftrightarrow> M = 0\"", "lemma decode_encode: \"decode e (encode e n) = n\"", "lemma encode_decode_exp_0: \"well_base\\<^sub>h M \\<Longrightarrow> encode 0 (decode 0 M) = M\"", "lemma well_base\\<^sub>h_mono_base:\n  assumes\n    well\\<^sub>h: \"well_base\\<^sub>h base M\" and\n    two: \"2 \\<le> base\" and\n    bases: \"base \\<le> base'\"\n  shows \"well_base\\<^sub>h base' M\"", "lemma goodstein_step:\n  assumes gi_gt_0: \"goodstein i > 0\"\n  shows \"encode (i + 2) 0 (goodstein i) > encode (i + 3) 0 (goodstein (i + 1))\"", "theorem goodsteins_theorem: \"\\<exists>i. goodstein i = 0\""], "translations": [["", "lemma div_mult_le: \"m div n * n \\<le> m\" for m n :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. m div n * n \\<le> m", "by (fact div_times_less_eq_dividend)"], ["", "lemma power_div_same_base:\n  \"b ^ y \\<noteq> 0 \\<Longrightarrow> x \\<ge> y \\<Longrightarrow> b ^ x div b ^ y = b ^ (x - y)\" for b :: \"'a::semidom_divide\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b ^ y \\<noteq> (0::'a); y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> b ^ x div b ^ y = b ^ (x - y)", "by (metis add_diff_inverse leD nonzero_mult_div_cancel_left power_add)"], ["", "subsection \\<open>Hereditary and Nonhereditary Base-\\<open>n\\<close> Systems\\<close>"], ["", "context\n  fixes base :: nat\n  assumes base_ge_2: \"base \\<ge> 2\"\nbegin"], ["", "inductive well_base :: \"'a multiset \\<Rightarrow> bool\" where\n  \"(\\<forall>n. count M n < base) \\<Longrightarrow> well_base M\""], ["", "lemma well_base_filter: \"well_base M \\<Longrightarrow> well_base {#m \\<in># M. p m#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.well_base M \\<Longrightarrow> local.well_base (filter_mset p M)", "by (auto simp: well_base.simps)"], ["", "lemma well_base_image_inj: \"well_base M \\<Longrightarrow> inj_on f (set_mset M) \\<Longrightarrow> well_base (image_mset f M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.well_base M; inj_on f (set_mset M)\\<rbrakk>\n    \\<Longrightarrow> local.well_base (image_mset f M)", "unfolding well_base.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>Ma. M = Ma \\<and> (\\<forall>n. count Ma n < base);\n     inj_on f (set_mset M)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Ma.\n                         image_mset f M = Ma \\<and>\n                         (\\<forall>n. count Ma n < base)", "by (metis count_image_mset_le_count_inj_on le_less_trans)"], ["", "lemma well_base_bound:\n  assumes\n    \"well_base M\" and\n    \"\\<forall>m \\<in># M. m < n\"\n  shows \"(\\<Sum>m \\<in># M. base ^ m) < base ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ n", "using assms"], ["proof (prove)\nusing this:\n  local.well_base M\n  \\<forall>m\\<in>#M. m < n\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ n", "proof (induct n arbitrary: M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>local.well_base M; \\<forall>m\\<in>#M. m < 0\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ 0\n 2. \\<And>n M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>local.well_base M;\n                    \\<forall>m\\<in>#M. m < n\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub>#\n(image_mset ((^) base) M)\n                                     < base ^ n;\n        local.well_base M; \\<forall>m\\<in>#M. m < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M)\n                         < base ^ Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>local.well_base ?M1; \\<forall>m\\<in>#?M1. m < n\\<rbrakk>\n  \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) ?M1) < base ^ n\n  local.well_base M\n  \\<forall>m\\<in>#M. m < Suc n\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>local.well_base M; \\<forall>m\\<in>#M. m < 0\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ 0\n 2. \\<And>n M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>local.well_base M;\n                    \\<forall>m\\<in>#M. m < n\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub>#\n(image_mset ((^) base) M)\n                                     < base ^ n;\n        local.well_base M; \\<forall>m\\<in>#M. m < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M)\n                         < base ^ Suc n", "note ih = this(1) and well_M = this(2) and in_M_lt_Sn = this(3)"], ["proof (state)\nthis:\n  \\<lbrakk>local.well_base ?M1; \\<forall>m\\<in>#?M1. m < n\\<rbrakk>\n  \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) ?M1) < base ^ n\n  local.well_base M\n  \\<forall>m\\<in>#M. m < Suc n\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>local.well_base M; \\<forall>m\\<in>#M. m < 0\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ 0\n 2. \\<And>n M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>local.well_base M;\n                    \\<forall>m\\<in>#M. m < n\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub>#\n(image_mset ((^) base) M)\n                                     < base ^ n;\n        local.well_base M; \\<forall>m\\<in>#M. m < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M)\n                         < base ^ Suc n", "let ?Meq = \"{#m \\<in># M. m = n#}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>local.well_base M; \\<forall>m\\<in>#M. m < 0\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ 0\n 2. \\<And>n M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>local.well_base M;\n                    \\<forall>m\\<in>#M. m < n\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub>#\n(image_mset ((^) base) M)\n                                     < base ^ n;\n        local.well_base M; \\<forall>m\\<in>#M. m < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M)\n                         < base ^ Suc n", "let ?Mne = \"{#m \\<in># M. m \\<noteq> n#}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>local.well_base M; \\<forall>m\\<in>#M. m < 0\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ 0\n 2. \\<And>n M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>local.well_base M;\n                    \\<forall>m\\<in>#M. m < n\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub>#\n(image_mset ((^) base) M)\n                                     < base ^ n;\n        local.well_base M; \\<forall>m\\<in>#M. m < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M)\n                         < base ^ Suc n", "let ?K = \"{#base ^ m. m \\<in># M#}\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>local.well_base M; \\<forall>m\\<in>#M. m < 0\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ 0\n 2. \\<And>n M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>local.well_base M;\n                    \\<forall>m\\<in>#M. m < n\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub>#\n(image_mset ((^) base) M)\n                                     < base ^ n;\n        local.well_base M; \\<forall>m\\<in>#M. m < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M)\n                         < base ^ Suc n", "have M: \"M = ?Meq + ?Mne\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = {#m \\<in># M. m = n#} + {#m \\<in># M. m \\<noteq> n#}", "by (simp)"], ["proof (state)\nthis:\n  M = {#m \\<in># M. m = n#} + {#m \\<in># M. m \\<noteq> n#}\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>local.well_base M; \\<forall>m\\<in>#M. m < 0\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ 0\n 2. \\<And>n M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>local.well_base M;\n                    \\<forall>m\\<in>#M. m < n\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub>#\n(image_mset ((^) base) M)\n                                     < base ^ n;\n        local.well_base M; \\<forall>m\\<in>#M. m < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M)\n                         < base ^ Suc n", "have well_Mne: \"well_base ?Mne\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.well_base {#m \\<in># M. m \\<noteq> n#}", "by (rule well_base_filter[OF well_M])"], ["proof (state)\nthis:\n  local.well_base {#m \\<in># M. m \\<noteq> n#}\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>local.well_base M; \\<forall>m\\<in>#M. m < 0\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ 0\n 2. \\<And>n M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>local.well_base M;\n                    \\<forall>m\\<in>#M. m < n\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub>#\n(image_mset ((^) base) M)\n                                     < base ^ n;\n        local.well_base M; \\<forall>m\\<in>#M. m < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M)\n                         < base ^ Suc n", "have in_Mne_lt_n: \"\\<forall>m \\<in># ?Mne. m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>#{#m \\<in># M. m \\<noteq> n#}. m < n", "using in_M_lt_Sn"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>#M. m < Suc n\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>#{#m \\<in># M. m \\<noteq> n#}. m < n", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<in>#{#m \\<in># M. m \\<noteq> n#}. m < n\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>local.well_base M; \\<forall>m\\<in>#M. m < 0\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ 0\n 2. \\<And>n M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>local.well_base M;\n                    \\<forall>m\\<in>#M. m < n\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub>#\n(image_mset ((^) base) M)\n                                     < base ^ n;\n        local.well_base M; \\<forall>m\\<in>#M. m < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M)\n                         < base ^ Suc n", "have \"sum_mset (image_mset ((^) base) ?Meq) \\<le> (base - 1) * base ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((^) base) {#m \\<in># M. m = n#})\n    \\<le> (base - 1) * base ^ n", "unfolding filter_eq_replicate_mset"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((^) base) (replicate_mset (count M n) n))\n    \\<le> (base - 1) * base ^ n", "using base_ge_2"], ["proof (prove)\nusing this:\n  2 \\<le> base\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((^) base) (replicate_mset (count M n) n))\n    \\<le> (base - 1) * base ^ n", "by simp (metis Suc_pred diff_self_eq_0 le_SucE less_imp_le less_le_trans less_numeral_extra(3)\n      pos2 well_M well_base.cases zero_less_diff)"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset ((^) base) {#m \\<in># M. m = n#})\n  \\<le> (base - 1) * base ^ n\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>local.well_base M; \\<forall>m\\<in>#M. m < 0\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ 0\n 2. \\<And>n M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>local.well_base M;\n                    \\<forall>m\\<in>#M. m < n\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub>#\n(image_mset ((^) base) M)\n                                     < base ^ n;\n        local.well_base M; \\<forall>m\\<in>#M. m < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M)\n                         < base ^ Suc n", "moreover"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset ((^) base) {#m \\<in># M. m = n#})\n  \\<le> (base - 1) * base ^ n\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>local.well_base M; \\<forall>m\\<in>#M. m < 0\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ 0\n 2. \\<And>n M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>local.well_base M;\n                    \\<forall>m\\<in>#M. m < n\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub>#\n(image_mset ((^) base) M)\n                                     < base ^ n;\n        local.well_base M; \\<forall>m\\<in>#M. m < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M)\n                         < base ^ Suc n", "have \"base * base ^ n = base ^ n + (base - Suc 0) * base ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base * base ^ n = base ^ n + (base - Suc 0) * base ^ n", "using base_ge_2 mult_eq_if"], ["proof (prove)\nusing this:\n  2 \\<le> base\n  ?m * ?n = (if ?m = 0 then 0 else ?n + (?m - 1) * ?n)\n\ngoal (1 subgoal):\n 1. base * base ^ n = base ^ n + (base - Suc 0) * base ^ n", "by auto"], ["proof (state)\nthis:\n  base * base ^ n = base ^ n + (base - Suc 0) * base ^ n\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>local.well_base M; \\<forall>m\\<in>#M. m < 0\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ 0\n 2. \\<And>n M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>local.well_base M;\n                    \\<forall>m\\<in>#M. m < n\\<rbrakk>\n                   \\<Longrightarrow> \\<Sum>\\<^sub>#\n(image_mset ((^) base) M)\n                                     < base ^ n;\n        local.well_base M; \\<forall>m\\<in>#M. m < Suc n\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M)\n                         < base ^ Suc n", "ultimately"], ["proof (chain)\npicking this:\n  \\<Sum>\\<^sub># (image_mset ((^) base) {#m \\<in># M. m = n#})\n  \\<le> (base - 1) * base ^ n\n  base * base ^ n = base ^ n + (base - Suc 0) * base ^ n", "show ?case"], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (image_mset ((^) base) {#m \\<in># M. m = n#})\n  \\<le> (base - 1) * base ^ n\n  base * base ^ n = base ^ n + (base - Suc 0) * base ^ n\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ Suc n", "using ih[OF well_Mne in_Mne_lt_n]"], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (image_mset ((^) base) {#m \\<in># M. m = n#})\n  \\<le> (base - 1) * base ^ n\n  base * base ^ n = base ^ n + (base - Suc 0) * base ^ n\n  \\<Sum>\\<^sub># (image_mset ((^) base) {#m \\<in># M. m \\<noteq> n#})\n  < base ^ n\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ Suc n", "by (subst M) (simp del: union_filter_mset_complement)"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ Suc n\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<lbrakk>local.well_base M; \\<forall>m\\<in>#M. m < 0\\<rbrakk>\n       \\<Longrightarrow> \\<Sum>\\<^sub># (image_mset ((^) base) M) < base ^ 0", "qed simp"], ["", "inductive well_base\\<^sub>h :: \"hmultiset \\<Rightarrow> bool\" where\n  \"(\\<forall>N \\<in># hmsetmset M. well_base\\<^sub>h N) \\<Longrightarrow> well_base (hmsetmset M) \\<Longrightarrow> well_base\\<^sub>h M\""], ["", "lemma well_base\\<^sub>h_mono_hmset: \"well_base\\<^sub>h M \\<Longrightarrow> hmsetmset N \\<subseteq># hmsetmset M \\<Longrightarrow> well_base\\<^sub>h N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.well_base\\<^sub>h M;\n     hmsetmset N \\<subseteq># hmsetmset M\\<rbrakk>\n    \\<Longrightarrow> local.well_base\\<^sub>h N", "by (induct rule: well_base\\<^sub>h.induct, rule well_base\\<^sub>h.intros, blast)\n    (meson leD leI order_trans subseteq_mset_def well_base.simps)"], ["", "lemma well_base\\<^sub>h_imp_well_base: \"well_base\\<^sub>h M \\<Longrightarrow> well_base (hmsetmset M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.well_base\\<^sub>h M \\<Longrightarrow>\n    local.well_base (hmsetmset M)", "by (erule well_base\\<^sub>h.cases) simp"], ["", "subsection \\<open>Encoding of Natural Numbers into Ordinals\\<close>"], ["", "function encode :: \"nat \\<Rightarrow> nat \\<Rightarrow> hmultiset\" where\n  \"encode e n =\n   (if n = 0 then 0 else of_nat (n mod base) * \\<omega>^(encode 0 e) + encode (e + 1) (n div base))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>e n. x = (e, n) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>e n ea na.\n       (e, n) = (ea, na) \\<Longrightarrow>\n       (if n = 0 then 0\n        else of_nat (n mod base) * \\<omega>^ (encode_sumC (0, e)) +\n             encode_sumC (e + 1, n div base)) =\n       (if na = 0 then 0\n        else of_nat (na mod base) * \\<omega>^ (encode_sumC (0, ea)) +\n             encode_sumC (ea + 1, na div base))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All local.encode_dom", "using base_ge_2"], ["proof (prove)\nusing this:\n  2 \\<le> base\n\ngoal (1 subgoal):\n 1. All local.encode_dom", "proof (relation \"measure (\\<lambda>(e, n). n * (base ^ e + 1))\"; simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> e + e < n + n * base ^ e\n 2. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "fix e n :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> e + e < n + n * base ^ e\n 2. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "assume n_ge_0: \"n > 0\""], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> e + e < n + n * base ^ e\n 2. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "have \"e + e \\<le> 2 ^ e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e + e \\<le> 2 ^ e", "by (induct e; simp) (metis add_diff_cancel_left' add_leD1 diff_is_0_eq' double_not_eq_Suc_double\n      le_antisym mult_2 not_less_eq_eq power_eq_0_iff zero_neq_numeral)"], ["proof (state)\nthis:\n  e + e \\<le> 2 ^ e\n\ngoal (2 subgoals):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> e + e < n + n * base ^ e\n 2. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "also"], ["proof (state)\nthis:\n  e + e \\<le> 2 ^ e\n\ngoal (2 subgoals):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> e + e < n + n * base ^ e\n 2. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "have \"\\<dots> \\<le> base ^ e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ e \\<le> base ^ e", "using base_ge_2"], ["proof (prove)\nusing this:\n  2 \\<le> base\n\ngoal (1 subgoal):\n 1. 2 ^ e \\<le> base ^ e", "by (simp add: power_mono)"], ["proof (state)\nthis:\n  2 ^ e \\<le> base ^ e\n\ngoal (2 subgoals):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> e + e < n + n * base ^ e\n 2. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "also"], ["proof (state)\nthis:\n  2 ^ e \\<le> base ^ e\n\ngoal (2 subgoals):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> e + e < n + n * base ^ e\n 2. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "have \"\\<dots> \\<le> n * base ^ e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ^ e \\<le> n * base ^ e", "using n_ge_0"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. base ^ e \\<le> n * base ^ e", "by (simp add: Suc_leI)"], ["proof (state)\nthis:\n  base ^ e \\<le> n * base ^ e\n\ngoal (2 subgoals):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> e + e < n + n * base ^ e\n 2. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "also"], ["proof (state)\nthis:\n  base ^ e \\<le> n * base ^ e\n\ngoal (2 subgoals):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> e + e < n + n * base ^ e\n 2. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "have \"\\<dots> < n + n * base ^ e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n * base ^ e < n + n * base ^ e", "using n_ge_0"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. n * base ^ e < n + n * base ^ e", "by simp"], ["proof (state)\nthis:\n  n * base ^ e < n + n * base ^ e\n\ngoal (2 subgoals):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> e + e < n + n * base ^ e\n 2. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "finally"], ["proof (chain)\npicking this:\n  e + e < n + n * base ^ e", "show \"e + e < n + n * base ^ e\""], ["proof (prove)\nusing this:\n  e + e < n + n * base ^ e\n\ngoal (1 subgoal):\n 1. e + e < n + n * base ^ e", "by assumption"], ["proof (state)\nthis:\n  e + e < n + n * base ^ e\n\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "have \"n div base * (base * base ^ e) \\<le> n * base ^ e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n div base * (base * base ^ e) \\<le> n * base ^ e", "using base_ge_2"], ["proof (prove)\nusing this:\n  2 \\<le> base\n\ngoal (1 subgoal):\n 1. n div base * (base * base ^ e) \\<le> n * base ^ e", "by (auto intro: div_mult_le)"], ["proof (state)\nthis:\n  n div base * (base * base ^ e) \\<le> n * base ^ e\n\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "moreover"], ["proof (state)\nthis:\n  n div base * (base * base ^ e) \\<le> n * base ^ e\n\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "have \"n div base < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n div base < n", "using n_ge_0 base_ge_2"], ["proof (prove)\nusing this:\n  0 < n\n  2 \\<le> base\n\ngoal (1 subgoal):\n 1. n div base < n", "by simp"], ["proof (state)\nthis:\n  n div base < n\n\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>0 < n; 2 \\<le> base\\<rbrakk>\n       \\<Longrightarrow> n div base + n div base * (base * base ^ e)\n                         < n + n * base ^ e", "ultimately"], ["proof (chain)\npicking this:\n  n div base * (base * base ^ e) \\<le> n * base ^ e\n  n div base < n", "show \"n div base + n div base * (base * base ^ e) < n + n * base ^ e\""], ["proof (prove)\nusing this:\n  n div base * (base * base ^ e) \\<le> n * base ^ e\n  n div base < n\n\ngoal (1 subgoal):\n 1. n div base + n div base * (base * base ^ e) < n + n * base ^ e", "by linarith"], ["proof (state)\nthis:\n  n div base + n div base * (base * base ^ e) < n + n * base ^ e\n\ngoal:\nNo subgoals!", "qed"], ["", "declare encode.simps[simp del]"], ["", "lemma encode_0[simp]: \"encode e 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.encode e 0 = 0", "by (subst encode.simps) simp"], ["", "lemma encode_Suc:\n  \"encode e (Suc n) = of_nat (Suc n mod base) * \\<omega>^(encode 0 e) + encode (e + 1) (Suc n div base)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.encode e (Suc n) =\n    of_nat (Suc n mod base) * \\<omega>^ (local.encode 0 e) +\n    local.encode (e + 1) (Suc n div base)", "by (subst encode.simps) simp"], ["", "lemma encode_0_iff: \"encode e n = 0 \\<longleftrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.encode e n = 0) = (n = 0)", "proof (induct n arbitrary: e rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x e.\n       (\\<And>y e.\n           y < x \\<Longrightarrow>\n           (local.encode e y = 0) = (y = 0)) \\<Longrightarrow>\n       (local.encode e x = 0) = (x = 0)", "case (less n)"], ["proof (state)\nthis:\n  ?y1 < n \\<Longrightarrow> (local.encode ?e1 ?y1 = 0) = (?y1 = 0)\n\ngoal (1 subgoal):\n 1. \\<And>x e.\n       (\\<And>y e.\n           y < x \\<Longrightarrow>\n           (local.encode e y = 0) = (y = 0)) \\<Longrightarrow>\n       (local.encode e x = 0) = (x = 0)", "note ih = this"], ["proof (state)\nthis:\n  ?y1 < n \\<Longrightarrow> (local.encode ?e1 ?y1 = 0) = (?y1 = 0)\n\ngoal (1 subgoal):\n 1. \\<And>x e.\n       (\\<And>y e.\n           y < x \\<Longrightarrow>\n           (local.encode e y = 0) = (y = 0)) \\<Longrightarrow>\n       (local.encode e x = 0) = (x = 0)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.encode e n = 0) = (n = 0)", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> (local.encode e n = 0) = (n = 0)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> (local.encode e n = 0) = (n = 0)", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> (local.encode e n = 0) = (n = 0)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> (local.encode e n = 0) = (n = 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. (local.encode e n = 0) = (n = 0)", "by simp"], ["proof (state)\nthis:\n  (local.encode e n = 0) = (n = 0)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> (local.encode e n = 0) = (n = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> (local.encode e n = 0) = (n = 0)", "case n: (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> (local.encode e n = 0) = (n = 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.encode e n = 0) = (n = 0)", "proof (cases \"n mod base = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n mod base = 0 \\<Longrightarrow> (local.encode e n = 0) = (n = 0)\n 2. n mod base \\<noteq> 0 \\<Longrightarrow> (local.encode e n = 0) = (n = 0)", "case True"], ["proof (state)\nthis:\n  n mod base = 0\n\ngoal (2 subgoals):\n 1. n mod base = 0 \\<Longrightarrow> (local.encode e n = 0) = (n = 0)\n 2. n mod base \\<noteq> 0 \\<Longrightarrow> (local.encode e n = 0) = (n = 0)", "hence \"n div base \\<noteq> 0\""], ["proof (prove)\nusing this:\n  n mod base = 0\n\ngoal (1 subgoal):\n 1. n div base \\<noteq> 0", "using div_eq_0_iff n"], ["proof (prove)\nusing this:\n  n mod base = 0\n  (?m div ?n = 0) = (?m < ?n \\<or> ?n = 0)\n  n = Suc m\n\ngoal (1 subgoal):\n 1. n div base \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  n div base \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n mod base = 0 \\<Longrightarrow> (local.encode e n = 0) = (n = 0)\n 2. n mod base \\<noteq> 0 \\<Longrightarrow> (local.encode e n = 0) = (n = 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n div base \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (local.encode e n = 0) = (n = 0)", "using ih[of \"Suc m div base\"] n"], ["proof (prove)\nusing this:\n  n div base \\<noteq> 0\n  Suc m div base < n \\<Longrightarrow>\n  (local.encode ?e1 (Suc m div base) = 0) = (Suc m div base = 0)\n  n = Suc m\n\ngoal (1 subgoal):\n 1. (local.encode e n = 0) = (n = 0)", "by (simp add: encode_Suc) (metis One_nat_def base_ge_2 div_eq_dividend_iff div_le_dividend\n          leD lessI nat_neq_iff numeral_2_eq_2)"], ["proof (state)\nthis:\n  (local.encode e n = 0) = (n = 0)\n\ngoal (1 subgoal):\n 1. n mod base \\<noteq> 0 \\<Longrightarrow> (local.encode e n = 0) = (n = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n mod base \\<noteq> 0 \\<Longrightarrow> (local.encode e n = 0) = (n = 0)", "case False"], ["proof (state)\nthis:\n  n mod base \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n mod base \\<noteq> 0 \\<Longrightarrow> (local.encode e n = 0) = (n = 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  n mod base \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (local.encode e n = 0) = (n = 0)", "using n plus_hmultiset_def"], ["proof (prove)\nusing this:\n  n mod base \\<noteq> 0\n  n = Suc m\n  ?A + ?B = HMSet (hmsetmset ?A + hmsetmset ?B)\n\ngoal (1 subgoal):\n 1. (local.encode e n = 0) = (n = 0)", "by (simp add: encode_Suc[unfolded of_nat_times_\\<omega>_exp])"], ["proof (state)\nthis:\n  (local.encode e n = 0) = (n = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (local.encode e n = 0) = (n = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (local.encode e n = 0) = (n = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma encode_Suc_exp: \"encode (Suc e) n = encode e (base * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.encode (Suc e) n = local.encode e (base * n)", "using base_ge_2"], ["proof (prove)\nusing this:\n  2 \\<le> base\n\ngoal (1 subgoal):\n 1. local.encode (Suc e) n = local.encode e (base * n)", "by (subst (1 2) encode.simps, subst (4) encode.simps, simp add: zero_hmultiset_def[symmetric])"], ["", "lemma encode_exp_0: \"encode e n = encode 0 (base ^ e * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.encode e n = local.encode 0 (base ^ e * n)", "by (induct e arbitrary: n) (simp_all add: encode_Suc_exp mult.assoc mult.commute)"], ["", "lemma mem_hmsetmset_encodeD: \"M \\<in># hmsetmset (encode e n) \\<Longrightarrow> \\<exists>e' \\<ge> e. M = encode 0 e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in># hmsetmset (local.encode e n) \\<Longrightarrow>\n    \\<exists>e'\\<ge>e. M = local.encode 0 e'", "proof (induct e n rule: encode.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>\\<lbrakk>n \\<noteq> 0;\n                 M \\<in># hmsetmset (local.encode 0 e)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e'\\<ge>0. M = local.encode 0 e';\n        \\<lbrakk>n \\<noteq> 0;\n         M \\<in># hmsetmset (local.encode (e + 1) (n div base))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'\\<ge>e + 1. M = local.encode 0 e';\n        M \\<in># hmsetmset (local.encode e n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<ge>e. M = local.encode 0 e'", "case (1 e n)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<noteq> 0; M \\<in># hmsetmset (local.encode 0 e)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'\\<ge>0. M = local.encode 0 e'\n  \\<lbrakk>n \\<noteq> 0;\n   M \\<in># hmsetmset (local.encode (e + 1) (n div base))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'\\<ge>e + 1. M = local.encode 0 e'\n  M \\<in># hmsetmset (local.encode e n)\n\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>\\<lbrakk>n \\<noteq> 0;\n                 M \\<in># hmsetmset (local.encode 0 e)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e'\\<ge>0. M = local.encode 0 e';\n        \\<lbrakk>n \\<noteq> 0;\n         M \\<in># hmsetmset (local.encode (e + 1) (n div base))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'\\<ge>e + 1. M = local.encode 0 e';\n        M \\<in># hmsetmset (local.encode e n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<ge>e. M = local.encode 0 e'", "note ih = this(1-2) and M_in = this(3)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<noteq> 0; M \\<in># hmsetmset (local.encode 0 e)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'\\<ge>0. M = local.encode 0 e'\n  \\<lbrakk>n \\<noteq> 0;\n   M \\<in># hmsetmset (local.encode (e + 1) (n div base))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'\\<ge>e + 1. M = local.encode 0 e'\n  M \\<in># hmsetmset (local.encode e n)\n\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>\\<lbrakk>n \\<noteq> 0;\n                 M \\<in># hmsetmset (local.encode 0 e)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e'\\<ge>0. M = local.encode 0 e';\n        \\<lbrakk>n \\<noteq> 0;\n         M \\<in># hmsetmset (local.encode (e + 1) (n div base))\\<rbrakk>\n        \\<Longrightarrow> \\<exists>e'\\<ge>e + 1. M = local.encode 0 e';\n        M \\<in># hmsetmset (local.encode e n)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e'\\<ge>e. M = local.encode 0 e'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e'\\<ge>e. M = local.encode 0 e'", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> \\<exists>e'\\<ge>e. M = local.encode 0 e'\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> \\<exists>e'\\<ge>e. M = local.encode 0 e'\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. \\<exists>e'\\<ge>e. M = local.encode 0 e'", "using M_in"], ["proof (prove)\nusing this:\n  n = 0\n  M \\<in># hmsetmset (local.encode e n)\n\ngoal (1 subgoal):\n 1. \\<exists>e'\\<ge>e. M = local.encode 0 e'", "by simp"], ["proof (state)\nthis:\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "case n: (Suc m)"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "{"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "assume \"M \\<in># replicate_mset (n mod base) (encode 0 e)\""], ["proof (state)\nthis:\n  M \\<in># replicate_mset (n mod base) (local.encode 0 e)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "hence ?thesis"], ["proof (prove)\nusing this:\n  M \\<in># replicate_mset (n mod base) (local.encode 0 e)\n\ngoal (1 subgoal):\n 1. \\<exists>e'\\<ge>e. M = local.encode 0 e'", "by (meson in_replicate_mset order_refl)"], ["proof (state)\nthis:\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "}"], ["proof (state)\nthis:\n  M \\<in># replicate_mset (n mod base) (local.encode 0 e) \\<Longrightarrow>\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "moreover"], ["proof (state)\nthis:\n  M \\<in># replicate_mset (n mod base) (local.encode 0 e) \\<Longrightarrow>\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "{"], ["proof (state)\nthis:\n  M \\<in># replicate_mset (n mod base) (local.encode 0 e) \\<Longrightarrow>\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "assume \"M \\<in># hmsetmset (encode (e + 1) (n div base))\""], ["proof (state)\nthis:\n  M \\<in># hmsetmset (local.encode (e + 1) (n div base))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "hence ?thesis"], ["proof (prove)\nusing this:\n  M \\<in># hmsetmset (local.encode (e + 1) (n div base))\n\ngoal (1 subgoal):\n 1. \\<exists>e'\\<ge>e. M = local.encode 0 e'", "using ih(2) le_add1 n order_trans"], ["proof (prove)\nusing this:\n  M \\<in># hmsetmset (local.encode (e + 1) (n div base))\n  \\<lbrakk>n \\<noteq> 0;\n   M \\<in># hmsetmset (local.encode (e + 1) (n div base))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e'\\<ge>e + 1. M = local.encode 0 e'\n  ?n \\<le> ?n + ?m\n  n = Suc m\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<exists>e'\\<ge>e. M = local.encode 0 e'", "by blast"], ["proof (state)\nthis:\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "}"], ["proof (state)\nthis:\n  M \\<in># hmsetmset (local.encode (e + 1) (n div base)) \\<Longrightarrow>\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>e'\\<ge>e. M = local.encode 0 e'", "ultimately"], ["proof (chain)\npicking this:\n  M \\<in># replicate_mset (n mod base) (local.encode 0 e) \\<Longrightarrow>\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n  M \\<in># hmsetmset (local.encode (e + 1) (n div base)) \\<Longrightarrow>\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'", "show ?thesis"], ["proof (prove)\nusing this:\n  M \\<in># replicate_mset (n mod base) (local.encode 0 e) \\<Longrightarrow>\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n  M \\<in># hmsetmset (local.encode (e + 1) (n div base)) \\<Longrightarrow>\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n\ngoal (1 subgoal):\n 1. \\<exists>e'\\<ge>e. M = local.encode 0 e'", "using M_in[unfolded n encode_Suc[unfolded of_nat_times_\\<omega>_exp], folded n]"], ["proof (prove)\nusing this:\n  M \\<in># replicate_mset (n mod base) (local.encode 0 e) \\<Longrightarrow>\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n  M \\<in># hmsetmset (local.encode (e + 1) (n div base)) \\<Longrightarrow>\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n  M \\<in># hmsetmset\n            (HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n             local.encode (e + 1) (n div base))\n\ngoal (1 subgoal):\n 1. \\<exists>e'\\<ge>e. M = local.encode 0 e'", "unfolding hmsetmset_plus"], ["proof (prove)\nusing this:\n  M \\<in># replicate_mset (n mod base) (local.encode 0 e) \\<Longrightarrow>\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n  M \\<in># hmsetmset (local.encode (e + 1) (n div base)) \\<Longrightarrow>\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n  M \\<in># hmsetmset\n            (HMSet (replicate_mset (n mod base) (local.encode 0 e))) +\n           hmsetmset (local.encode (e + 1) (n div base))\n\ngoal (1 subgoal):\n 1. \\<exists>e'\\<ge>e. M = local.encode 0 e'", "by auto"], ["proof (state)\nthis:\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e'\\<ge>e. M = local.encode 0 e'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_imp_encode_less: \"n < p \\<Longrightarrow> encode e n < encode e p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < p \\<Longrightarrow> local.encode e n < local.encode e p", "proof (induct e n arbitrary: p rule: encode.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>n \\<noteq> 0; e < p\\<rbrakk>\n                   \\<Longrightarrow> local.encode 0 e < local.encode 0 p;\n        \\<And>p.\n           \\<lbrakk>n \\<noteq> 0; n div base < p\\<rbrakk>\n           \\<Longrightarrow> local.encode (e + 1) (n div base)\n                             < local.encode (e + 1) p;\n        n < p\\<rbrakk>\n       \\<Longrightarrow> local.encode e n < local.encode e p", "case (1 e n)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<noteq> 0; e < ?p1\\<rbrakk>\n  \\<Longrightarrow> local.encode 0 e < local.encode 0 ?p1\n  \\<lbrakk>n \\<noteq> 0; n div base < ?p1\\<rbrakk>\n  \\<Longrightarrow> local.encode (e + 1) (n div base)\n                    < local.encode (e + 1) ?p1\n  n < p\n\ngoal (1 subgoal):\n 1. \\<And>e n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>n \\<noteq> 0; e < p\\<rbrakk>\n                   \\<Longrightarrow> local.encode 0 e < local.encode 0 p;\n        \\<And>p.\n           \\<lbrakk>n \\<noteq> 0; n div base < p\\<rbrakk>\n           \\<Longrightarrow> local.encode (e + 1) (n div base)\n                             < local.encode (e + 1) p;\n        n < p\\<rbrakk>\n       \\<Longrightarrow> local.encode e n < local.encode e p", "note ih = this(1-2) and n_lt_p = this(3)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<noteq> 0; e < ?p1\\<rbrakk>\n  \\<Longrightarrow> local.encode 0 e < local.encode 0 ?p1\n  \\<lbrakk>n \\<noteq> 0; n div base < ?p1\\<rbrakk>\n  \\<Longrightarrow> local.encode (e + 1) (n div base)\n                    < local.encode (e + 1) ?p1\n  n < p\n\ngoal (1 subgoal):\n 1. \\<And>e n p.\n       \\<lbrakk>\\<And>p.\n                   \\<lbrakk>n \\<noteq> 0; e < p\\<rbrakk>\n                   \\<Longrightarrow> local.encode 0 e < local.encode 0 p;\n        \\<And>p.\n           \\<lbrakk>n \\<noteq> 0; n div base < p\\<rbrakk>\n           \\<Longrightarrow> local.encode (e + 1) (n div base)\n                             < local.encode (e + 1) p;\n        n < p\\<rbrakk>\n       \\<Longrightarrow> local.encode e n < local.encode e p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.encode e n < local.encode e p", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> local.encode e n < local.encode e p\n 2. n \\<noteq> 0 \\<Longrightarrow> local.encode e n < local.encode e p", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> local.encode e n < local.encode e p\n 2. n \\<noteq> 0 \\<Longrightarrow> local.encode e n < local.encode e p", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. local.encode e n < local.encode e p", "using n_lt_p base_ge_2 encode_0_iff[of e p] le_less"], ["proof (prove)\nusing this:\n  n = 0\n  n < p\n  2 \\<le> base\n  (local.encode e p = 0) = (p = 0)\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. local.encode e n < local.encode e p", "by fastforce"], ["proof (state)\nthis:\n  local.encode e n < local.encode e p\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> local.encode e n < local.encode e p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> local.encode e n < local.encode e p", "case n_nz: False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> local.encode e n < local.encode e p", "let ?Ma = \"replicate_mset (n mod base) (encode 0 e)\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> local.encode e n < local.encode e p", "let ?Na = \"replicate_mset (p mod base) (encode 0 e)\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> local.encode e n < local.encode e p", "let ?Pa = \"replicate_mset (n mod base - p mod base) (encode 0 e)\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> local.encode e n < local.encode e p", "have \"HMSet ?Ma + encode (Suc e) (n div base) < HMSet ?Na + encode (Suc e) (p div base)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "proof (cases \"n mod base < p mod base\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)\n 2. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "case mod_lt: True"], ["proof (state)\nthis:\n  n mod base < p mod base\n\ngoal (2 subgoals):\n 1. n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)\n 2. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "by (rule add_less_le_mono, simp add: mod_lt,\n          metis ih(2)[of \"p div base\", OF n_nz] Suc_eq_plus1 div_le_mono le_less n_lt_p)"], ["proof (state)\nthis:\n  HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n  local.encode (Suc e) (n div base)\n  < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (p div base)\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "case mod_ge: False"], ["proof (state)\nthis:\n  \\<not> n mod base < p mod base\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "hence div_lt: \"n div base < p div base\""], ["proof (prove)\nusing this:\n  \\<not> n mod base < p mod base\n\ngoal (1 subgoal):\n 1. n div base < p div base", "by (metis add_le_cancel_left div_le_mono div_mult_mod_eq le_neq_implies_less less_imp_le\n          n_lt_p nat_neq_iff)"], ["proof (state)\nthis:\n  n div base < p div base\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "let ?M = \"hmsetmset (encode (Suc e) (n div base))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "let ?N = \"hmsetmset (encode (Suc e) (p div base))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "have \"?M < ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset (local.encode (Suc e) (n div base))\n    < hmsetmset (local.encode (Suc e) (p div base))", "by (auto intro!: ih(2)[folded Suc_eq_plus1] n_nz div_lt)"], ["proof (state)\nthis:\n  hmsetmset (local.encode (Suc e) (n div base))\n  < hmsetmset (local.encode (Suc e) (p div base))\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "then"], ["proof (chain)\npicking this:\n  hmsetmset (local.encode (Suc e) (n div base))\n  < hmsetmset (local.encode (Suc e) (p div base))", "obtain X Y where\n        X_nemp: \"X \\<noteq> {#}\" and\n        X_sub: \"X \\<subseteq># ?N\" and\n        M: \"?M = ?N - X + Y\" and\n        ex_gt: \"\\<forall>y. y \\<in># Y \\<longrightarrow> (\\<exists>x. x \\<in># X \\<and> x > y)\""], ["proof (prove)\nusing this:\n  hmsetmset (local.encode (Suc e) (n div base))\n  < hmsetmset (local.encode (Suc e) (p div base))\n\ngoal (1 subgoal):\n 1. (\\<And>X Y.\n        \\<lbrakk>X \\<noteq> {#};\n         X \\<subseteq># hmsetmset (local.encode (Suc e) (p div base));\n         hmsetmset (local.encode (Suc e) (n div base)) =\n         hmsetmset (local.encode (Suc e) (p div base)) - X + Y;\n         \\<forall>y.\n            y \\<in># Y \\<longrightarrow>\n            (\\<exists>x. x \\<in># X \\<and> y < x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using less_multiset\\<^sub>D\\<^sub>M"], ["proof (prove)\nusing this:\n  hmsetmset (local.encode (Suc e) (n div base))\n  < hmsetmset (local.encode (Suc e) (p div base))\n  (?M < ?N) =\n  (\\<exists>X Y.\n      X \\<noteq> {#} \\<and>\n      X \\<subseteq># ?N \\<and>\n      ?M = ?N - X + Y \\<and>\n      (\\<forall>k.\n          k \\<in># Y \\<longrightarrow>\n          (\\<exists>a. a \\<in># X \\<and> k < a)))\n\ngoal (1 subgoal):\n 1. (\\<And>X Y.\n        \\<lbrakk>X \\<noteq> {#};\n         X \\<subseteq># hmsetmset (local.encode (Suc e) (p div base));\n         hmsetmset (local.encode (Suc e) (n div base)) =\n         hmsetmset (local.encode (Suc e) (p div base)) - X + Y;\n         \\<forall>y.\n            y \\<in># Y \\<longrightarrow>\n            (\\<exists>x. x \\<in># X \\<and> y < x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  X \\<noteq> {#}\n  X \\<subseteq># hmsetmset (local.encode (Suc e) (p div base))\n  hmsetmset (local.encode (Suc e) (n div base)) =\n  hmsetmset (local.encode (Suc e) (p div base)) - X + Y\n  \\<forall>y.\n     y \\<in># Y \\<longrightarrow> (\\<exists>x. x \\<in># X \\<and> y < x)\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "{"], ["proof (state)\nthis:\n  X \\<noteq> {#}\n  X \\<subseteq># hmsetmset (local.encode (Suc e) (p div base))\n  hmsetmset (local.encode (Suc e) (n div base)) =\n  hmsetmset (local.encode (Suc e) (p div base)) - X + Y\n  \\<forall>y.\n     y \\<in># Y \\<longrightarrow> (\\<exists>x. x \\<in># X \\<and> y < x)\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "assume x_in_X: \"x \\<in># X\""], ["proof (state)\nthis:\n  x \\<in># X\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "hence x_in_N: \"x \\<in># ?N\""], ["proof (prove)\nusing this:\n  x \\<in># X\n\ngoal (1 subgoal):\n 1. x \\<in># hmsetmset (local.encode (Suc e) (p div base))", "using X_sub"], ["proof (prove)\nusing this:\n  x \\<in># X\n  X \\<subseteq># hmsetmset (local.encode (Suc e) (p div base))\n\ngoal (1 subgoal):\n 1. x \\<in># hmsetmset (local.encode (Suc e) (p div base))", "by blast"], ["proof (state)\nthis:\n  x \\<in># hmsetmset (local.encode (Suc e) (p div base))\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "then"], ["proof (chain)\npicking this:\n  x \\<in># hmsetmset (local.encode (Suc e) (p div base))", "obtain e' where\n          e'_gt: \"e' > e\" and\n          x: \"x = encode 0 e'\""], ["proof (prove)\nusing this:\n  x \\<in># hmsetmset (local.encode (Suc e) (p div base))\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e < e'; x = local.encode 0 e'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Suc_le_eq dest: mem_hmsetmset_encodeD)"], ["proof (state)\nthis:\n  e < e'\n  x = local.encode 0 e'\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "have \"x > encode 0 e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.encode 0 e < x", "unfolding x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.encode 0 e < local.encode 0 e'", "using ih(1)[OF n_nz] e'_gt"], ["proof (prove)\nusing this:\n  e < ?p1 \\<Longrightarrow> local.encode 0 e < local.encode 0 ?p1\n  e < e'\n\ngoal (1 subgoal):\n 1. local.encode 0 e < local.encode 0 e'", "by (blast dest: Suc_lessD)"], ["proof (state)\nthis:\n  local.encode 0 e < x\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "}"], ["proof (state)\nthis:\n  ?x3 \\<in># X \\<Longrightarrow> local.encode 0 e < ?x3\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "hence ex_gt_e: \"\\<exists>x \\<in># X. x > encode 0 e\""], ["proof (prove)\nusing this:\n  ?x3 \\<in># X \\<Longrightarrow> local.encode 0 e < ?x3\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>#X. local.encode 0 e < x", "using X_nemp"], ["proof (prove)\nusing this:\n  ?x3 \\<in># X \\<Longrightarrow> local.encode 0 e < ?x3\n  X \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>#X. local.encode 0 e < x", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>#X. local.encode 0 e < x\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "have X_sub': \"X \\<subseteq># ?Na + ?N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq>#\n    replicate_mset (p mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (p div base))", "using X_sub"], ["proof (prove)\nusing this:\n  X \\<subseteq># hmsetmset (local.encode (Suc e) (p div base))\n\ngoal (1 subgoal):\n 1. X \\<subseteq>#\n    replicate_mset (p mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (p div base))", "by (simp add: subset_mset.add_increasing)"], ["proof (state)\nthis:\n  X \\<subseteq>#\n  replicate_mset (p mod base) (local.encode 0 e) +\n  hmsetmset (local.encode (Suc e) (p div base))\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "have mam_eq: \"?Ma + ?M = ?Na + ?N - X + (Y + ?Pa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate_mset (n mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (n div base)) =\n    replicate_mset (p mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (p div base)) -\n    X +\n    (Y + replicate_mset (n mod base - p mod base) (local.encode 0 e))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. replicate_mset (n mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (n div base)) =\n    replicate_mset (p mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (p div base)) -\n    X +\n    (Y + replicate_mset (n mod base - p mod base) (local.encode 0 e))", "from mod_ge"], ["proof (chain)\npicking this:\n  \\<not> n mod base < p mod base", "have \"?Ma = ?Na + ?Pa\""], ["proof (prove)\nusing this:\n  \\<not> n mod base < p mod base\n\ngoal (1 subgoal):\n 1. replicate_mset (n mod base) (local.encode 0 e) =\n    replicate_mset (p mod base) (local.encode 0 e) +\n    replicate_mset (n mod base - p mod base) (local.encode 0 e)", "by (simp add: replicate_mset_plus [symmetric])"], ["proof (state)\nthis:\n  replicate_mset (n mod base) (local.encode 0 e) =\n  replicate_mset (p mod base) (local.encode 0 e) +\n  replicate_mset (n mod base - p mod base) (local.encode 0 e)\n\ngoal (1 subgoal):\n 1. replicate_mset (n mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (n div base)) =\n    replicate_mset (p mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (p div base)) -\n    X +\n    (Y + replicate_mset (n mod base - p mod base) (local.encode 0 e))", "moreover"], ["proof (state)\nthis:\n  replicate_mset (n mod base) (local.encode 0 e) =\n  replicate_mset (p mod base) (local.encode 0 e) +\n  replicate_mset (n mod base - p mod base) (local.encode 0 e)\n\ngoal (1 subgoal):\n 1. replicate_mset (n mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (n div base)) =\n    replicate_mset (p mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (p div base)) -\n    X +\n    (Y + replicate_mset (n mod base - p mod base) (local.encode 0 e))", "have \"?Na + ?N - X = ?Na + (?N - X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate_mset (p mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (p div base)) -\n    X =\n    replicate_mset (p mod base) (local.encode 0 e) +\n    (hmsetmset (local.encode (Suc e) (p div base)) - X)", "by (meson X_sub multiset_diff_union_assoc)"], ["proof (state)\nthis:\n  replicate_mset (p mod base) (local.encode 0 e) +\n  hmsetmset (local.encode (Suc e) (p div base)) -\n  X =\n  replicate_mset (p mod base) (local.encode 0 e) +\n  (hmsetmset (local.encode (Suc e) (p div base)) - X)\n\ngoal (1 subgoal):\n 1. replicate_mset (n mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (n div base)) =\n    replicate_mset (p mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (p div base)) -\n    X +\n    (Y + replicate_mset (n mod base - p mod base) (local.encode 0 e))", "ultimately"], ["proof (chain)\npicking this:\n  replicate_mset (n mod base) (local.encode 0 e) =\n  replicate_mset (p mod base) (local.encode 0 e) +\n  replicate_mset (n mod base - p mod base) (local.encode 0 e)\n  replicate_mset (p mod base) (local.encode 0 e) +\n  hmsetmset (local.encode (Suc e) (p div base)) -\n  X =\n  replicate_mset (p mod base) (local.encode 0 e) +\n  (hmsetmset (local.encode (Suc e) (p div base)) - X)", "show ?thesis"], ["proof (prove)\nusing this:\n  replicate_mset (n mod base) (local.encode 0 e) =\n  replicate_mset (p mod base) (local.encode 0 e) +\n  replicate_mset (n mod base - p mod base) (local.encode 0 e)\n  replicate_mset (p mod base) (local.encode 0 e) +\n  hmsetmset (local.encode (Suc e) (p div base)) -\n  X =\n  replicate_mset (p mod base) (local.encode 0 e) +\n  (hmsetmset (local.encode (Suc e) (p div base)) - X)\n\ngoal (1 subgoal):\n 1. replicate_mset (n mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (n div base)) =\n    replicate_mset (p mod base) (local.encode 0 e) +\n    hmsetmset (local.encode (Suc e) (p div base)) -\n    X +\n    (Y + replicate_mset (n mod base - p mod base) (local.encode 0 e))", "by (simp add: M)"], ["proof (state)\nthis:\n  replicate_mset (n mod base) (local.encode 0 e) +\n  hmsetmset (local.encode (Suc e) (n div base)) =\n  replicate_mset (p mod base) (local.encode 0 e) +\n  hmsetmset (local.encode (Suc e) (p div base)) -\n  X +\n  (Y + replicate_mset (n mod base - p mod base) (local.encode 0 e))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  replicate_mset (n mod base) (local.encode 0 e) +\n  hmsetmset (local.encode (Suc e) (n div base)) =\n  replicate_mset (p mod base) (local.encode 0 e) +\n  hmsetmset (local.encode (Suc e) (p div base)) -\n  X +\n  (Y + replicate_mset (n mod base - p mod base) (local.encode 0 e))\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "have max_X: \"\\<And>k. k \\<in># Y + ?Pa \\<Longrightarrow> \\<exists>a. a \\<in># X \\<and> k < a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># Y +\n                replicate_mset (n mod base - p mod base)\n                 (local.encode 0 e) \\<Longrightarrow>\n       \\<exists>a. a \\<in># X \\<and> k < a", "using ex_gt mod_ge ex_gt_e"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     y \\<in># Y \\<longrightarrow> (\\<exists>x. x \\<in># X \\<and> y < x)\n  \\<not> n mod base < p mod base\n  \\<exists>x\\<in>#X. local.encode 0 e < x\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># Y +\n                replicate_mset (n mod base - p mod base)\n                 (local.encode 0 e) \\<Longrightarrow>\n       \\<exists>a. a \\<in># X \\<and> k < a", "by (metis in_replicate_mset union_iff)"], ["proof (state)\nthis:\n  ?k1\n  \\<in># Y +\n         replicate_mset (n mod base - p mod base)\n          (local.encode 0 e) \\<Longrightarrow>\n  \\<exists>a. a \\<in># X \\<and> ?k1 < a\n\ngoal (1 subgoal):\n 1. \\<not> n mod base < p mod base \\<Longrightarrow>\n    HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (n div base)\n    < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n      local.encode (Suc e) (p div base)", "by (subst (4 8) hmultiset.collapse[symmetric],\n          unfold HMSet_plus[symmetric] HMSet_less less_multiset\\<^sub>D\\<^sub>M,\n          rule exI[of _ X], rule exI[of _ \"Y + ?Pa\"],\n          intro conjI impI allI X_nemp X_sub' mam_eq, elim max_X)"], ["proof (state)\nthis:\n  HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n  local.encode (Suc e) (n div base)\n  < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (p div base)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n  local.encode (Suc e) (n div base)\n  < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (p div base)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> local.encode e n < local.encode e p", "thus ?thesis"], ["proof (prove)\nusing this:\n  HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n  local.encode (Suc e) (n div base)\n  < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (p div base)\n\ngoal (1 subgoal):\n 1. local.encode e n < local.encode e p", "using n_nz n_lt_p"], ["proof (prove)\nusing this:\n  HMSet (replicate_mset (n mod base) (local.encode 0 e)) +\n  local.encode (Suc e) (n div base)\n  < HMSet (replicate_mset (p mod base) (local.encode 0 e)) +\n    local.encode (Suc e) (p div base)\n  n \\<noteq> 0\n  n < p\n\ngoal (1 subgoal):\n 1. local.encode e n < local.encode e p", "by (subst (1 2) encode.simps[unfolded of_nat_times_\\<omega>_exp]) auto"], ["proof (state)\nthis:\n  local.encode e n < local.encode e p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.encode e n < local.encode e p\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive aligned\\<^sub>e :: \"nat \\<Rightarrow> hmultiset \\<Rightarrow> bool\" where\n  \"(\\<forall>m \\<in># hmsetmset M. m \\<ge> encode 0 e) \\<Longrightarrow> aligned\\<^sub>e e M\""], ["", "lemma aligned\\<^sub>e_encode: \"aligned\\<^sub>e e (encode e M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>e e (local.encode e M)", "by (subst encode_exp_0, rule aligned\\<^sub>e.intros,\n    metis encode_exp_0 leD leI lessI less_imp_encode_less lift_Suc_mono_less_iff\n      mem_hmsetmset_encodeD)"], ["", "lemma well_base\\<^sub>h_encode: \"well_base\\<^sub>h (encode e n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.well_base\\<^sub>h (local.encode e n)", "proof (induct e n rule: encode.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>n \\<noteq> 0 \\<Longrightarrow>\n                local.well_base\\<^sub>h (local.encode 0 e);\n        n \\<noteq> 0 \\<Longrightarrow>\n        local.well_base\\<^sub>h (local.encode (e + 1) (n div base))\\<rbrakk>\n       \\<Longrightarrow> local.well_base\\<^sub>h (local.encode e n)", "case (1 e n)"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow> local.well_base\\<^sub>h (local.encode 0 e)\n  n \\<noteq> 0 \\<Longrightarrow>\n  local.well_base\\<^sub>h (local.encode (e + 1) (n div base))\n\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>n \\<noteq> 0 \\<Longrightarrow>\n                local.well_base\\<^sub>h (local.encode 0 e);\n        n \\<noteq> 0 \\<Longrightarrow>\n        local.well_base\\<^sub>h (local.encode (e + 1) (n div base))\\<rbrakk>\n       \\<Longrightarrow> local.well_base\\<^sub>h (local.encode e n)", "note ih = this"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow> local.well_base\\<^sub>h (local.encode 0 e)\n  n \\<noteq> 0 \\<Longrightarrow>\n  local.well_base\\<^sub>h (local.encode (e + 1) (n div base))\n\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>n \\<noteq> 0 \\<Longrightarrow>\n                local.well_base\\<^sub>h (local.encode 0 e);\n        n \\<noteq> 0 \\<Longrightarrow>\n        local.well_base\\<^sub>h (local.encode (e + 1) (n div base))\\<rbrakk>\n       \\<Longrightarrow> local.well_base\\<^sub>h (local.encode e n)", "have well2: \"\\<forall>M \\<in># hmsetmset (encode (Suc e) (n div base)). well_base\\<^sub>h M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Multiset.Ball (hmsetmset (local.encode (Suc e) (n div base)))\n     local.well_base\\<^sub>h", "using ih(2) well_base\\<^sub>h.cases"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  local.well_base\\<^sub>h (local.encode (e + 1) (n div base))\n  \\<lbrakk>local.well_base\\<^sub>h ?a;\n   \\<And>M.\n      \\<lbrakk>?a = M; Multiset.Ball (hmsetmset M) local.well_base\\<^sub>h;\n       local.well_base (hmsetmset M)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. Multiset.Ball (hmsetmset (local.encode (Suc e) (n div base)))\n     local.well_base\\<^sub>h", "by (metis Suc_eq_plus1 Zero_not_Suc count_empty div_0\n      encode_0_iff hmsetmset_empty_iff in_countE)"], ["proof (state)\nthis:\n  Multiset.Ball (hmsetmset (local.encode (Suc e) (n div base)))\n   local.well_base\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>n \\<noteq> 0 \\<Longrightarrow>\n                local.well_base\\<^sub>h (local.encode 0 e);\n        n \\<noteq> 0 \\<Longrightarrow>\n        local.well_base\\<^sub>h (local.encode (e + 1) (n div base))\\<rbrakk>\n       \\<Longrightarrow> local.well_base\\<^sub>h (local.encode e n)", "have cnt1: \"count (hmsetmset (encode (Suc e) (n div base))) (encode 0 e) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count (hmsetmset (local.encode (Suc e) (n div base)))\n     (local.encode 0 e) =\n    0", "using aligned\\<^sub>e_encode[unfolded aligned\\<^sub>e.simps]\n      less_imp_encode_less[of n \"Suc n\" for n, simplified]"], ["proof (prove)\nusing this:\n  \\<exists>M e.\n     ?e = e \\<and>\n     local.encode ?e ?M = M \\<and>\n     Multiset.Ball (hmsetmset M) ((\\<le>) (local.encode 0 e))\n  local.encode ?e ?nb3 < local.encode ?e (Suc ?nb3)\n\ngoal (1 subgoal):\n 1. count (hmsetmset (local.encode (Suc e) (n div base)))\n     (local.encode 0 e) =\n    0", "by (meson count_inI leD)"], ["proof (state)\nthis:\n  count (hmsetmset (local.encode (Suc e) (n div base))) (local.encode 0 e) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>n \\<noteq> 0 \\<Longrightarrow>\n                local.well_base\\<^sub>h (local.encode 0 e);\n        n \\<noteq> 0 \\<Longrightarrow>\n        local.well_base\\<^sub>h (local.encode (e + 1) (n div base))\\<rbrakk>\n       \\<Longrightarrow> local.well_base\\<^sub>h (local.encode e n)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.well_base\\<^sub>h (local.encode e n)", "proof (rule well_base\\<^sub>h.intros)"], ["proof (state)\ngoal (2 subgoals):\n 1. Multiset.Ball (hmsetmset (local.encode e n)) local.well_base\\<^sub>h\n 2. local.well_base (hmsetmset (local.encode e n))", "show \"\\<forall>M \\<in># hmsetmset (encode e n). well_base\\<^sub>h M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Multiset.Ball (hmsetmset (local.encode e n)) local.well_base\\<^sub>h", "by (subst encode.simps[unfolded of_nat_times_\\<omega>_exp],\n        simp add: zero_hmultiset_def hmsetmset_plus, use ih(1) well2 in blast)"], ["proof (state)\nthis:\n  Multiset.Ball (hmsetmset (local.encode e n)) local.well_base\\<^sub>h\n\ngoal (1 subgoal):\n 1. local.well_base (hmsetmset (local.encode e n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. local.well_base (hmsetmset (local.encode e n))", "show \"well_base (hmsetmset (encode e n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.well_base (hmsetmset (local.encode e n))", "using cnt1 base_ge_2"], ["proof (prove)\nusing this:\n  count (hmsetmset (local.encode (Suc e) (n div base))) (local.encode 0 e) =\n  0\n  2 \\<le> base\n\ngoal (1 subgoal):\n 1. local.well_base (hmsetmset (local.encode e n))", "by (subst encode.simps[unfolded of_nat_times_\\<omega>_exp],\n        simp add: well_base.simps zero_hmultiset_def hmsetmset_plus,\n        metis ih(2) well_base\\<^sub>h.simps Suc_eq_plus1 less_numeral_extra(3) well_base.simps)"], ["proof (state)\nthis:\n  local.well_base (hmsetmset (local.encode e n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.well_base\\<^sub>h (local.encode e n)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Decoding of Natural Numbers from Ordinals\\<close>"], ["", "primrec decode :: \"nat \\<Rightarrow> hmultiset \\<Rightarrow> nat\" where\n  \"decode e (HMSet M) = (\\<Sum>m \\<in># M. base ^ decode 0 m) div base ^ e\""], ["", "lemma decode_unfold: \"decode e M = (\\<Sum>m \\<in># hmsetmset M. base ^ decode 0 m) div base ^ e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.decode e M =\n    (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m) div base ^ e", "by (cases M) simp"], ["", "lemma decode_0[simp]: \"decode e 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.decode e 0 = 0", "unfolding zero_hmultiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.decode e (HMSet {#}) = 0", "by simp"], ["", "inductive aligned\\<^sub>d :: \"nat \\<Rightarrow> hmultiset \\<Rightarrow> bool\" where\n  \"(\\<forall>m \\<in># hmsetmset M. decode 0 m \\<ge> e) \\<Longrightarrow> aligned\\<^sub>d e M\""], ["", "lemma aligned\\<^sub>d_0[simp]: \"aligned\\<^sub>d 0 M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d 0 M", "by (rule aligned\\<^sub>d.intros) simp"], ["", "lemma aligned\\<^sub>d_mono_exp_Suc: \"aligned\\<^sub>d (Suc e) M \\<Longrightarrow> aligned\\<^sub>d e M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d (Suc e) M \\<Longrightarrow>\n    local.aligned\\<^sub>d e M", "by (auto simp: aligned\\<^sub>d.simps)"], ["", "lemma aligned\\<^sub>d_mono_hmset:\n  assumes \"aligned\\<^sub>d e M\" and \"hmsetmset M' \\<subseteq># hmsetmset M\"\n  shows \"aligned\\<^sub>d e M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d e M'", "using assms"], ["proof (prove)\nusing this:\n  local.aligned\\<^sub>d e M\n  hmsetmset M' \\<subseteq># hmsetmset M\n\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d e M'", "by (auto simp: aligned\\<^sub>d.simps)"], ["", "lemma decode_exp_shift_Suc:\n  assumes align\\<^sub>d: \"aligned\\<^sub>d (Suc e) M\"\n  shows \"decode e M = base * decode (Suc e) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.decode e M = base * local.decode (Suc e) M", "proof (subst (1 2) decode_unfold, subst (1 2) sum_mset_distrib_div_if_dvd)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>m\\<in>#hmsetmset M. base ^ Suc e dvd base ^ local.decode 0 m\n 2. \\<forall>m\\<in>#hmsetmset M. base ^ e dvd base ^ local.decode 0 m\n 3. (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ e) =\n    base *\n    (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ Suc e)", "note align' = align\\<^sub>d[unfolded aligned\\<^sub>d.simps, simplified, unfolded Suc_le_eq]"], ["proof (state)\nthis:\n  \\<forall>m\\<in>#hmsetmset M. e < local.decode 0 m\n\ngoal (3 subgoals):\n 1. \\<forall>m\\<in>#hmsetmset M. base ^ Suc e dvd base ^ local.decode 0 m\n 2. \\<forall>m\\<in>#hmsetmset M. base ^ e dvd base ^ local.decode 0 m\n 3. (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ e) =\n    base *\n    (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ Suc e)", "show \"\\<forall>m \\<in># hmsetmset M. base ^ Suc e dvd base ^ decode 0 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>#hmsetmset M. base ^ Suc e dvd base ^ local.decode 0 m", "using align' Suc_leI le_imp_power_dvd"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>#hmsetmset M. e < local.decode 0 m\n  ?m < ?n \\<Longrightarrow> Suc ?m \\<le> ?n\n  ?m \\<le> ?n \\<Longrightarrow> ?a ^ ?m dvd ?a ^ ?n\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>#hmsetmset M. base ^ Suc e dvd base ^ local.decode 0 m", "by blast"], ["proof (state)\nthis:\n  \\<forall>m\\<in>#hmsetmset M. base ^ Suc e dvd base ^ local.decode 0 m\n\ngoal (2 subgoals):\n 1. \\<forall>m\\<in>#hmsetmset M. base ^ e dvd base ^ local.decode 0 m\n 2. (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ e) =\n    base *\n    (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ Suc e)", "show \"\\<forall>m \\<in># hmsetmset M. base ^ e dvd base ^ decode 0 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>#hmsetmset M. base ^ e dvd base ^ local.decode 0 m", "using align'"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>#hmsetmset M. e < local.decode 0 m\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>#hmsetmset M. base ^ e dvd base ^ local.decode 0 m", "by (simp add: le_imp_power_dvd le_less)"], ["proof (state)\nthis:\n  \\<forall>m\\<in>#hmsetmset M. base ^ e dvd base ^ local.decode 0 m\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ e) =\n    base *\n    (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ Suc e)", "have base_e_nz: \"base ^ e \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ^ e \\<noteq> 0", "using base_ge_2"], ["proof (prove)\nusing this:\n  2 \\<le> base\n\ngoal (1 subgoal):\n 1. base ^ e \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  base ^ e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ e) =\n    base *\n    (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ Suc e)", "have mult_base:\n    \"base ^ decode 0 m div base ^ e = base * (base ^ decode 0 m div (base * base ^ e))\"\n    if m_in: \"m \\<in># hmsetmset M\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. base ^ local.decode 0 m div base ^ e =\n    base * (base ^ local.decode 0 m div (base * base ^ e))", "using m_in align'"], ["proof (prove)\nusing this:\n  m \\<in># hmsetmset M\n  \\<forall>m\\<in>#hmsetmset M. e < local.decode 0 m\n\ngoal (1 subgoal):\n 1. base ^ local.decode 0 m div base ^ e =\n    base * (base ^ local.decode 0 m div (base * base ^ e))", "by (subst power_div_same_base[OF base_e_nz], force,\n      metis Suc_diff_Suc Suc_leI mult_is_0 power_Suc power_div_same_base power_not_zero)"], ["proof (state)\nthis:\n  ?m1 \\<in># hmsetmset M \\<Longrightarrow>\n  base ^ local.decode 0 ?m1 div base ^ e =\n  base * (base ^ local.decode 0 ?m1 div (base * base ^ e))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ e) =\n    base *\n    (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ Suc e)", "show \"(\\<Sum>m\\<in>#hmsetmset M. base ^ decode 0 m div base ^ e) =\n    base * (\\<Sum>m\\<in>#hmsetmset M. base ^ decode 0 m div base ^ Suc e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ e) =\n    base *\n    (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ Suc e)", "by (auto simp: sum_mset_distrib_left intro!: arg_cong[of _ _ sum_mset] image_mset_cong\n      elim!: mult_base)"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ e) =\n  base *\n  (\\<Sum>m\\<in>#hmsetmset M. base ^ local.decode 0 m div base ^ Suc e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decode_exp_shift:\n  assumes \"aligned\\<^sub>d e M\"\n  shows \"decode 0 M = base ^ e * decode e M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.decode 0 M = base ^ e * local.decode e M", "using assms"], ["proof (prove)\nusing this:\n  local.aligned\\<^sub>d e M\n\ngoal (1 subgoal):\n 1. local.decode 0 M = base ^ e * local.decode e M", "by (induct e) (auto simp: decode_exp_shift_Suc dest: aligned\\<^sub>d_mono_exp_Suc)"], ["", "lemma decode_plus:\n  assumes align\\<^sub>d_M: \"aligned\\<^sub>d e M\"\n  shows \"decode e (M + N) = decode e M + decode e N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.decode e (M + N) = local.decode e M + local.decode e N", "using align\\<^sub>d_M[unfolded aligned\\<^sub>d.simps, simplified]"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>#hmsetmset M. e \\<le> local.decode 0 m\n\ngoal (1 subgoal):\n 1. local.decode e (M + N) = local.decode e M + local.decode e N", "by (subst (1 2 3) decode_unfold) (auto simp: hmsetmset_plus\n    intro!: le_imp_power_dvd div_plus_div_distrib_dvd_left[OF sum_mset_dvd])"], ["", "lemma less_imp_decode_less:\n  assumes\n    \"well_base\\<^sub>h M\" and\n    \"aligned\\<^sub>d e M\" and\n    \"aligned\\<^sub>d e N\" and\n    \"M < N\"\n  shows \"decode e M < decode e N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.decode e M < local.decode e N", "using assms"], ["proof (prove)\nusing this:\n  local.well_base\\<^sub>h M\n  local.aligned\\<^sub>d e M\n  local.aligned\\<^sub>d e N\n  M < N\n\ngoal (1 subgoal):\n 1. local.decode e M < local.decode e N", "proof (induct M arbitrary: N e rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "case (less M)"], ["proof (state)\nthis:\n  \\<lbrakk>?y1 < M; local.well_base\\<^sub>h ?y1;\n   local.aligned\\<^sub>d ?e1 ?y1; local.aligned\\<^sub>d ?e1 ?N1;\n   ?y1 < ?N1\\<rbrakk>\n  \\<Longrightarrow> local.decode ?e1 ?y1 < local.decode ?e1 ?N1\n  local.well_base\\<^sub>h M\n  local.aligned\\<^sub>d e M\n  local.aligned\\<^sub>d e N\n  M < N\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "note ih = this(1) and well\\<^sub>h_M = this(2) and align\\<^sub>d_M = this(3) and align\\<^sub>d_N = this(4) and\n    M_lt_N = this(5)"], ["proof (state)\nthis:\n  \\<lbrakk>?y1 < M; local.well_base\\<^sub>h ?y1;\n   local.aligned\\<^sub>d ?e1 ?y1; local.aligned\\<^sub>d ?e1 ?N1;\n   ?y1 < ?N1\\<rbrakk>\n  \\<Longrightarrow> local.decode ?e1 ?y1 < local.decode ?e1 ?N1\n  local.well_base\\<^sub>h M\n  local.aligned\\<^sub>d e M\n  local.aligned\\<^sub>d e N\n  M < N\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "obtain K Ma Na where\n    M: \"M = K + Ma\" and\n    N: \"N = K + Na\" and\n    hds: \"head_\\<omega> Ma < head_\\<omega> Na\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>K Maa Naa.\n        \\<lbrakk>M = K + Maa; N = K + Naa;\n         head_\\<omega> Maa < head_\\<omega> Naa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hmset_pair_decompose_less[OF M_lt_N]"], ["proof (prove)\nusing this:\n  \\<exists>k n1 n2.\n     M = k + n1 \\<and> N = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2\n\ngoal (1 subgoal):\n 1. (\\<And>K Maa Naa.\n        \\<lbrakk>M = K + Maa; N = K + Naa;\n         head_\\<omega> Maa < head_\\<omega> Naa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  M = K + Ma\n  N = K + Na\n  head_\\<omega> Ma < head_\\<omega> Na\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "obtain H where\n    H: \"head_\\<omega> Na = \\<omega>^H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>H.\n        head_\\<omega> Na = \\<omega>^ H \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using hds head_\\<omega>_def"], ["proof (prove)\nusing this:\n  head_\\<omega> Ma < head_\\<omega> Na\n  head_\\<omega> ?M =\n  (if ?M = 0 then 0 else \\<omega>^ (Max_mset (hmsetmset ?M)))\n\ngoal (1 subgoal):\n 1. (\\<And>H.\n        head_\\<omega> Na = \\<omega>^ H \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  head_\\<omega> Na = \\<omega>^ H\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "have H_in: \"H \\<in># hmsetmset Na\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<in># hmsetmset Na", "by (metis (no_types) H Max_in add_mset_eq_single add_mset_not_empty finite_set_mset head_\\<omega>_def\n      hmsetmset_empty_iff hmultiset.simps(1) set_mset_eq_empty_iff zero_hmultiset_def)"], ["proof (state)\nthis:\n  H \\<in># hmsetmset Na\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "have well\\<^sub>h_Ma: \"well_base\\<^sub>h Ma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.well_base\\<^sub>h Ma", "by (rule well_base\\<^sub>h_mono_hmset[OF well\\<^sub>h_M]) (simp add: M hmsetmset_plus)"], ["proof (state)\nthis:\n  local.well_base\\<^sub>h Ma\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "have align\\<^sub>d_K: \"aligned\\<^sub>d e K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d e K", "using M align\\<^sub>d_M aligned\\<^sub>d_mono_hmset hmsetmset_plus"], ["proof (prove)\nusing this:\n  M = K + Ma\n  local.aligned\\<^sub>d e M\n  \\<lbrakk>local.aligned\\<^sub>d ?e ?M;\n   hmsetmset ?M' \\<subseteq># hmsetmset ?M\\<rbrakk>\n  \\<Longrightarrow> local.aligned\\<^sub>d ?e ?M'\n  hmsetmset (?M + ?N) = hmsetmset ?M + hmsetmset ?N\n\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d e K", "by auto"], ["proof (state)\nthis:\n  local.aligned\\<^sub>d e K\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "have align\\<^sub>d_Ma: \"aligned\\<^sub>d e Ma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d e Ma", "using M align\\<^sub>d_M aligned\\<^sub>d_mono_hmset hmsetmset_plus"], ["proof (prove)\nusing this:\n  M = K + Ma\n  local.aligned\\<^sub>d e M\n  \\<lbrakk>local.aligned\\<^sub>d ?e ?M;\n   hmsetmset ?M' \\<subseteq># hmsetmset ?M\\<rbrakk>\n  \\<Longrightarrow> local.aligned\\<^sub>d ?e ?M'\n  hmsetmset (?M + ?N) = hmsetmset ?M + hmsetmset ?N\n\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d e Ma", "by auto"], ["proof (state)\nthis:\n  local.aligned\\<^sub>d e Ma\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "have align\\<^sub>d_Na: \"aligned\\<^sub>d e Na\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d e Na", "using N align\\<^sub>d_N aligned\\<^sub>d_mono_hmset hmsetmset_plus"], ["proof (prove)\nusing this:\n  N = K + Na\n  local.aligned\\<^sub>d e N\n  \\<lbrakk>local.aligned\\<^sub>d ?e ?M;\n   hmsetmset ?M' \\<subseteq># hmsetmset ?M\\<rbrakk>\n  \\<Longrightarrow> local.aligned\\<^sub>d ?e ?M'\n  hmsetmset (?M + ?N) = hmsetmset ?M + hmsetmset ?N\n\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d e Na", "by auto"], ["proof (state)\nthis:\n  local.aligned\\<^sub>d e Na\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "have \"inj_on (decode 0) (set_mset (hmsetmset Ma))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (local.decode 0) (set_mset (hmsetmset Ma))", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>#hmsetmset Ma.\n       \\<forall>y\\<in>#hmsetmset Ma.\n          local.decode 0 x = local.decode 0 y \\<longrightarrow> x = y", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in># hmsetmset Ma; y \\<in># hmsetmset Ma;\n        local.decode 0 x = local.decode 0 y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in># hmsetmset Ma; y \\<in># hmsetmset Ma;\n        local.decode 0 x = local.decode 0 y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume\n      x_in: \"x \\<in># hmsetmset Ma\" and\n      y_in: \"y \\<in># hmsetmset Ma\" and\n      dec_eq: \"decode 0 x = decode 0 y\""], ["proof (state)\nthis:\n  x \\<in># hmsetmset Ma\n  y \\<in># hmsetmset Ma\n  local.decode 0 x = local.decode 0 y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in># hmsetmset Ma; y \\<in># hmsetmset Ma;\n        local.decode 0 x = local.decode 0 y\\<rbrakk>\n       \\<Longrightarrow> x = y", "{"], ["proof (state)\nthis:\n  x \\<in># hmsetmset Ma\n  y \\<in># hmsetmset Ma\n  local.decode 0 x = local.decode 0 y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in># hmsetmset Ma; y \\<in># hmsetmset Ma;\n        local.decode 0 x = local.decode 0 y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in># hmsetmset Ma; y \\<in># hmsetmset Ma;\n        local.decode 0 x = local.decode 0 y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume\n        x_in: \"x \\<in># hmsetmset Ma\" and\n        y_in: \"y \\<in># hmsetmset Ma\" and\n        x_lt_y: \"x < y\""], ["proof (state)\nthis:\n  x \\<in># hmsetmset Ma\n  y \\<in># hmsetmset Ma\n  x < y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in># hmsetmset Ma; y \\<in># hmsetmset Ma;\n        local.decode 0 x = local.decode 0 y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have x_lt_M: \"x < M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < M", "unfolding M"], ["proof (prove)\ngoal (1 subgoal):\n 1. x < K + Ma", "using mem_hmsetmset_imp_less[OF x_in]"], ["proof (prove)\nusing this:\n  x < Ma\n\ngoal (1 subgoal):\n 1. x < K + Ma", "by (simp add: trans_less_add2_hmset)"], ["proof (state)\nthis:\n  x < M\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in># hmsetmset Ma; y \\<in># hmsetmset Ma;\n        local.decode 0 x = local.decode 0 y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have well\\<^sub>h_x: \"well_base\\<^sub>h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.well_base\\<^sub>h x", "using well\\<^sub>h_Ma well_base\\<^sub>h.simps x_in"], ["proof (prove)\nusing this:\n  local.well_base\\<^sub>h Ma\n  local.well_base\\<^sub>h ?a =\n  (\\<exists>M.\n      ?a = M \\<and>\n      Multiset.Ball (hmsetmset M) local.well_base\\<^sub>h \\<and>\n      local.well_base (hmsetmset M))\n  x \\<in># hmsetmset Ma\n\ngoal (1 subgoal):\n 1. local.well_base\\<^sub>h x", "by blast"], ["proof (state)\nthis:\n  local.well_base\\<^sub>h x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in># hmsetmset Ma; y \\<in># hmsetmset Ma;\n        local.decode 0 x = local.decode 0 y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"decode 0 x < decode 0 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.decode 0 x < local.decode 0 y", "by (rule ih[OF x_lt_M well\\<^sub>h_x aligned\\<^sub>d_0 aligned\\<^sub>d_0 x_lt_y])"], ["proof (state)\nthis:\n  local.decode 0 x < local.decode 0 y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in># hmsetmset Ma; y \\<in># hmsetmset Ma;\n        local.decode 0 x = local.decode 0 y\\<rbrakk>\n       \\<Longrightarrow> x = y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?xa3 \\<in># hmsetmset Ma; ?ya3 \\<in># hmsetmset Ma;\n   ?xa3 < ?ya3\\<rbrakk>\n  \\<Longrightarrow> local.decode 0 ?xa3 < local.decode 0 ?ya3\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in># hmsetmset Ma; y \\<in># hmsetmset Ma;\n        local.decode 0 x = local.decode 0 y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa3 \\<in># hmsetmset Ma; ?ya3 \\<in># hmsetmset Ma;\n   ?xa3 < ?ya3\\<rbrakk>\n  \\<Longrightarrow> local.decode 0 ?xa3 < local.decode 0 ?ya3\n\ngoal (1 subgoal):\n 1. x = y", "using x_in y_in dec_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa3 \\<in># hmsetmset Ma; ?ya3 \\<in># hmsetmset Ma;\n   ?xa3 < ?ya3\\<rbrakk>\n  \\<Longrightarrow> local.decode 0 ?xa3 < local.decode 0 ?ya3\n  x \\<in># hmsetmset Ma\n  y \\<in># hmsetmset Ma\n  local.decode 0 x = local.decode 0 y\n\ngoal (1 subgoal):\n 1. x = y", "by (metis leI less_irrefl_nat order.not_eq_order_implies_strict)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (local.decode 0) (set_mset (hmsetmset Ma))\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "hence well_dec_Ma: \"well_base (image_mset (decode 0) (hmsetmset Ma))\""], ["proof (prove)\nusing this:\n  inj_on (local.decode 0) (set_mset (hmsetmset Ma))\n\ngoal (1 subgoal):\n 1. local.well_base (image_mset (local.decode 0) (hmsetmset Ma))", "by (rule well_base_image_inj[OF well_base\\<^sub>h_imp_well_base[OF well\\<^sub>h_Ma]])"], ["proof (state)\nthis:\n  local.well_base (image_mset (local.decode 0) (hmsetmset Ma))\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "have H_bound: \"\\<forall>m \\<in># hmsetmset Ma. decode 0 m < decode 0 H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>#hmsetmset Ma. local.decode 0 m < local.decode 0 H", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in># hmsetmset Ma \\<Longrightarrow>\n       local.decode 0 m < local.decode 0 H", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in># hmsetmset Ma \\<Longrightarrow>\n       local.decode 0 m < local.decode 0 H", "assume m_in: \"m \\<in># hmsetmset Ma\""], ["proof (state)\nthis:\n  m \\<in># hmsetmset Ma\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in># hmsetmset Ma \\<Longrightarrow>\n       local.decode 0 m < local.decode 0 H", "have \"\\<forall>m \\<in># hmsetmset (head_\\<omega> Ma). m < H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>#hmsetmset (head_\\<omega> Ma). m < H", "using hds[unfolded H]"], ["proof (prove)\nusing this:\n  head_\\<omega> Ma < \\<omega>^ H\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>#hmsetmset (head_\\<omega> Ma). m < H", "using head_\\<omega>_def"], ["proof (prove)\nusing this:\n  head_\\<omega> Ma < \\<omega>^ H\n  head_\\<omega> ?M =\n  (if ?M = 0 then 0 else \\<omega>^ (Max_mset (hmsetmset ?M)))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>#hmsetmset (head_\\<omega> Ma). m < H", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<in>#hmsetmset (head_\\<omega> Ma). m < H\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in># hmsetmset Ma \\<Longrightarrow>\n       local.decode 0 m < local.decode 0 H", "hence m_lt_H: \"m < H\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>#hmsetmset (head_\\<omega> Ma). m < H\n\ngoal (1 subgoal):\n 1. m < H", "using m_in"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>#hmsetmset (head_\\<omega> Ma). m < H\n  m \\<in># hmsetmset Ma\n\ngoal (1 subgoal):\n 1. m < H", "by (metis Max_less_iff empty_iff finite_set_mset head_\\<omega>_def hmultiset.sel insert_iff\n        set_mset_add_mset_insert)"], ["proof (state)\nthis:\n  m < H\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in># hmsetmset Ma \\<Longrightarrow>\n       local.decode 0 m < local.decode 0 H", "have m_lt_M: \"m < M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < M", "using mem_hmsetmset_imp_less[OF m_in]"], ["proof (prove)\nusing this:\n  m < Ma\n\ngoal (1 subgoal):\n 1. m < M", "by (simp add: M trans_less_add2_hmset)"], ["proof (state)\nthis:\n  m < M\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in># hmsetmset Ma \\<Longrightarrow>\n       local.decode 0 m < local.decode 0 H", "have well\\<^sub>h_m: \"well_base\\<^sub>h m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.well_base\\<^sub>h m", "using m_in well\\<^sub>h_Ma well_base\\<^sub>h.cases"], ["proof (prove)\nusing this:\n  m \\<in># hmsetmset Ma\n  local.well_base\\<^sub>h Ma\n  \\<lbrakk>local.well_base\\<^sub>h ?a;\n   \\<And>M.\n      \\<lbrakk>?a = M; Multiset.Ball (hmsetmset M) local.well_base\\<^sub>h;\n       local.well_base (hmsetmset M)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. local.well_base\\<^sub>h m", "by blast"], ["proof (state)\nthis:\n  local.well_base\\<^sub>h m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in># hmsetmset Ma \\<Longrightarrow>\n       local.decode 0 m < local.decode 0 H", "show \"decode 0 m < decode 0 H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.decode 0 m < local.decode 0 H", "by (rule ih[OF m_lt_M well\\<^sub>h_m aligned\\<^sub>d_0 aligned\\<^sub>d_0 m_lt_H])"], ["proof (state)\nthis:\n  local.decode 0 m < local.decode 0 H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>m\\<in>#hmsetmset Ma. local.decode 0 m < local.decode 0 H\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "have \"decode 0 Ma < base ^ decode 0 H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.decode 0 Ma < base ^ local.decode 0 H", "using well_base_bound[OF well_dec_Ma, simplified, OF H_bound]"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>#hmsetmset Ma. base ^ local.decode 0 x)\n  < base ^ local.decode 0 H\n\ngoal (1 subgoal):\n 1. local.decode 0 Ma < base ^ local.decode 0 H", "by (subst decode_unfold) simp"], ["proof (state)\nthis:\n  local.decode 0 Ma < base ^ local.decode 0 H\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "also"], ["proof (state)\nthis:\n  local.decode 0 Ma < base ^ local.decode 0 H\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "have \"\\<dots> \\<le> decode 0 Na\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base ^ local.decode 0 H \\<le> local.decode 0 Na", "by (subst (2) decode_unfold, simp, rule sum_image_mset_mono_mem[OF H_in])"], ["proof (state)\nthis:\n  base ^ local.decode 0 H \\<le> local.decode 0 Na\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "finally"], ["proof (chain)\npicking this:\n  local.decode 0 Ma < local.decode 0 Na", "have \"decode e Ma < decode e Na\""], ["proof (prove)\nusing this:\n  local.decode 0 Ma < local.decode 0 Na\n\ngoal (1 subgoal):\n 1. local.decode e Ma < local.decode e Na", "using decode_exp_shift[OF align\\<^sub>d_Ma] decode_exp_shift[OF align\\<^sub>d_Na]"], ["proof (prove)\nusing this:\n  local.decode 0 Ma < local.decode 0 Na\n  local.decode 0 Ma = base ^ e * local.decode e Ma\n  local.decode 0 Na = base ^ e * local.decode e Na\n\ngoal (1 subgoal):\n 1. local.decode e Ma < local.decode e Na", "by simp"], ["proof (state)\nthis:\n  local.decode e Ma < local.decode e Na\n\ngoal (1 subgoal):\n 1. \\<And>x N e.\n       \\<lbrakk>\\<And>y N e.\n                   \\<lbrakk>y < x; local.well_base\\<^sub>h y;\n                    local.aligned\\<^sub>d e y; local.aligned\\<^sub>d e N;\n                    y < N\\<rbrakk>\n                   \\<Longrightarrow> local.decode e y < local.decode e N;\n        local.well_base\\<^sub>h x; local.aligned\\<^sub>d e x;\n        local.aligned\\<^sub>d e N; x < N\\<rbrakk>\n       \\<Longrightarrow> local.decode e x < local.decode e N", "thus \"decode e M < decode e N\""], ["proof (prove)\nusing this:\n  local.decode e Ma < local.decode e Na\n\ngoal (1 subgoal):\n 1. local.decode e M < local.decode e N", "unfolding M N"], ["proof (prove)\nusing this:\n  local.decode e Ma < local.decode e Na\n\ngoal (1 subgoal):\n 1. local.decode e (K + Ma) < local.decode e (K + Na)", "by (simp add: decode_plus[OF align\\<^sub>d_K])"], ["proof (state)\nthis:\n  local.decode e M < local.decode e N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_decode: \"inj_on (decode e) {M. well_base\\<^sub>h M \\<and> aligned\\<^sub>d e M}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (local.decode e)\n     {M. local.well_base\\<^sub>h M \\<and> local.aligned\\<^sub>d e M}", "unfolding inj_on_def Ball_def mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       local.well_base\\<^sub>h x \\<and>\n       local.aligned\\<^sub>d e x \\<longrightarrow>\n       (\\<forall>xa.\n           local.well_base\\<^sub>h xa \\<and>\n           local.aligned\\<^sub>d e xa \\<longrightarrow>\n           local.decode e x = local.decode e xa \\<longrightarrow> x = xa)", "by (metis less_imp_decode_less less_irrefl_nat neqE)"], ["", "lemma decode_0_iff: \"well_base\\<^sub>h M \\<Longrightarrow> aligned\\<^sub>d e M \\<Longrightarrow> decode e M = 0 \\<longleftrightarrow> M = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.well_base\\<^sub>h M; local.aligned\\<^sub>d e M\\<rbrakk>\n    \\<Longrightarrow> (local.decode e M = 0) = (M = 0)", "by (metis aligned\\<^sub>d_0 decode_0 decode_exp_shift encode_0 less_imp_decode_less mult_0_right neqE\n    not_less_zero well_base\\<^sub>h_encode)"], ["", "lemma decode_encode: \"decode e (encode e n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.decode e (local.encode e n) = n", "proof (induct e n rule: encode.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>n \\<noteq> 0 \\<Longrightarrow>\n                local.decode 0 (local.encode 0 e) = e;\n        n \\<noteq> 0 \\<Longrightarrow>\n        local.decode (e + 1) (local.encode (e + 1) (n div base)) =\n        n div base\\<rbrakk>\n       \\<Longrightarrow> local.decode e (local.encode e n) = n", "case (1 e n)"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow> local.decode 0 (local.encode 0 e) = e\n  n \\<noteq> 0 \\<Longrightarrow>\n  local.decode (e + 1) (local.encode (e + 1) (n div base)) = n div base\n\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>n \\<noteq> 0 \\<Longrightarrow>\n                local.decode 0 (local.encode 0 e) = e;\n        n \\<noteq> 0 \\<Longrightarrow>\n        local.decode (e + 1) (local.encode (e + 1) (n div base)) =\n        n div base\\<rbrakk>\n       \\<Longrightarrow> local.decode e (local.encode e n) = n", "note ih = this"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow> local.decode 0 (local.encode 0 e) = e\n  n \\<noteq> 0 \\<Longrightarrow>\n  local.decode (e + 1) (local.encode (e + 1) (n div base)) = n div base\n\ngoal (1 subgoal):\n 1. \\<And>e n.\n       \\<lbrakk>n \\<noteq> 0 \\<Longrightarrow>\n                local.decode 0 (local.encode 0 e) = e;\n        n \\<noteq> 0 \\<Longrightarrow>\n        local.decode (e + 1) (local.encode (e + 1) (n div base)) =\n        n div base\\<rbrakk>\n       \\<Longrightarrow> local.decode e (local.encode e n) = n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.decode e (local.encode e n) = n", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> local.decode e (local.encode e n) = n\n 2. n \\<noteq> 0 \\<Longrightarrow> local.decode e (local.encode e n) = n", "case n_nz: False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> local.decode e (local.encode e n) = n\n 2. n \\<noteq> 0 \\<Longrightarrow> local.decode e (local.encode e n) = n", "have align\\<^sub>d1: \"aligned\\<^sub>d e (of_nat (n mod base) * \\<omega>^(encode 0 e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d e\n     (of_nat (n mod base) * \\<omega>^ (local.encode 0 e))", "unfolding of_nat_times_\\<omega>_exp"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d e\n     (HMSet (replicate_mset (n mod base) (local.encode 0 e)))", "using n_nz"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d e\n     (HMSet (replicate_mset (n mod base) (local.encode 0 e)))", "by (auto simp: ih(1) aligned\\<^sub>d.simps)"], ["proof (state)\nthis:\n  local.aligned\\<^sub>d e\n   (of_nat (n mod base) * \\<omega>^ (local.encode 0 e))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> local.decode e (local.encode e n) = n\n 2. n \\<noteq> 0 \\<Longrightarrow> local.decode e (local.encode e n) = n", "have align\\<^sub>d2: \"aligned\\<^sub>d (Suc e) (encode (Suc e) (n div base))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.aligned\\<^sub>d (Suc e) (local.encode (Suc e) (n div base))", "by (safe intro!: aligned\\<^sub>d.intros, subst ih(1)[OF n_nz, symmetric],\n        auto dest: mem_hmsetmset_encodeD intro!: Suc_le_eq[THEN iffD2]\n          less_imp_decode_less[OF well_base\\<^sub>h_encode aligned\\<^sub>d_0 aligned\\<^sub>d_0] less_imp_encode_less)"], ["proof (state)\nthis:\n  local.aligned\\<^sub>d (Suc e) (local.encode (Suc e) (n div base))\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> local.decode e (local.encode e n) = n\n 2. n \\<noteq> 0 \\<Longrightarrow> local.decode e (local.encode e n) = n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.decode e (local.encode e n) = n", "using ih base_ge_2"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow> local.decode 0 (local.encode 0 e) = e\n  n \\<noteq> 0 \\<Longrightarrow>\n  local.decode (e + 1) (local.encode (e + 1) (n div base)) = n div base\n  2 \\<le> base\n\ngoal (1 subgoal):\n 1. local.decode e (local.encode e n) = n", "by (subst encode.simps[unfolded of_nat_times_\\<omega>_exp])\n        (simp add: decode_plus[OF align\\<^sub>d1[unfolded of_nat_times_\\<omega>_exp]]\n           decode_exp_shift_Suc[OF align\\<^sub>d2])"], ["proof (state)\nthis:\n  local.decode e (local.encode e n) = n\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow> local.decode e (local.encode e n) = n", "qed simp"], ["proof (state)\nthis:\n  local.decode e (local.encode e n) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma encode_decode_exp_0: \"well_base\\<^sub>h M \\<Longrightarrow> encode 0 (decode 0 M) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.well_base\\<^sub>h M \\<Longrightarrow>\n    local.encode 0 (local.decode 0 M) = M", "by (auto intro: inj_onD[OF inj_decode] decode_encode well_base\\<^sub>h_encode)"], ["", "end"], ["", "lemma well_base\\<^sub>h_mono_base:\n  assumes\n    well\\<^sub>h: \"well_base\\<^sub>h base M\" and\n    two: \"2 \\<le> base\" and\n    bases: \"base \\<le> base'\"\n  shows \"well_base\\<^sub>h base' M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_base\\<^sub>h base' M", "using two well\\<^sub>h"], ["proof (prove)\nusing this:\n  2 \\<le> base\n  well_base\\<^sub>h base M\n\ngoal (1 subgoal):\n 1. well_base\\<^sub>h base' M", "by (induct rule: well_base\\<^sub>h.induct)\n    (meson two bases less_le_trans order_trans well_base\\<^sub>h.intros well_base.simps)"], ["", "subsection \\<open>The Goodstein Sequence and Goodstein's Theorem\\<close>"], ["", "context\n  fixes start :: nat\nbegin"], ["", "primrec goodstein :: \"nat \\<Rightarrow> nat\" where\n  \"goodstein 0 = start\"\n| \"goodstein (Suc i) = decode (i + 3) 0 (encode (i + 2) 0 (goodstein i)) - 1\""], ["", "lemma goodstein_step:\n  assumes gi_gt_0: \"goodstein i > 0\"\n  shows \"encode (i + 2) 0 (goodstein i) > encode (i + 3) 0 (goodstein (i + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode (i + 3) 0 (local.goodstein (i + 1))\n    < encode (i + 2) 0 (local.goodstein i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. encode (i + 3) 0 (local.goodstein (i + 1))\n    < encode (i + 2) 0 (local.goodstein i)", "let ?Ei = \"encode (i + 2) 0 (goodstein i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. encode (i + 3) 0 (local.goodstein (i + 1))\n    < encode (i + 2) 0 (local.goodstein i)", "let ?reencode = \"encode (i + 3) 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. encode (i + 3) 0 (local.goodstein (i + 1))\n    < encode (i + 2) 0 (local.goodstein i)", "let ?decoded_Ei = \"decode (i + 3) 0 ?Ei\""], ["proof (state)\ngoal (1 subgoal):\n 1. encode (i + 3) 0 (local.goodstein (i + 1))\n    < encode (i + 2) 0 (local.goodstein i)", "have two_le: \"2 \\<le> i + 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> i + 3", "by simp"], ["proof (state)\nthis:\n  2 \\<le> i + 3\n\ngoal (1 subgoal):\n 1. encode (i + 3) 0 (local.goodstein (i + 1))\n    < encode (i + 2) 0 (local.goodstein i)", "have \"well_base\\<^sub>h (i + 2) ?Ei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_base\\<^sub>h (i + 2) (encode (i + 2) 0 (local.goodstein i))", "by (rule well_base\\<^sub>h_encode) simp"], ["proof (state)\nthis:\n  well_base\\<^sub>h (i + 2) (encode (i + 2) 0 (local.goodstein i))\n\ngoal (1 subgoal):\n 1. encode (i + 3) 0 (local.goodstein (i + 1))\n    < encode (i + 2) 0 (local.goodstein i)", "hence well\\<^sub>h: \"well_base\\<^sub>h (i + 3) ?Ei\""], ["proof (prove)\nusing this:\n  well_base\\<^sub>h (i + 2) (encode (i + 2) 0 (local.goodstein i))\n\ngoal (1 subgoal):\n 1. well_base\\<^sub>h (i + 3) (encode (i + 2) 0 (local.goodstein i))", "by (rule well_base\\<^sub>h_mono_base) simp_all"], ["proof (state)\nthis:\n  well_base\\<^sub>h (i + 3) (encode (i + 2) 0 (local.goodstein i))\n\ngoal (1 subgoal):\n 1. encode (i + 3) 0 (local.goodstein (i + 1))\n    < encode (i + 2) 0 (local.goodstein i)", "have decoded_Ei_gt_0: \"?decoded_Ei > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < decode (i + 3) 0 (encode (i + 2) 0 (local.goodstein i))", "by (metis gi_gt_0 gr0I encode_0_iff le_add2 decode_0_iff[OF _ well\\<^sub>h aligned\\<^sub>d_0] two_le)"], ["proof (state)\nthis:\n  0 < decode (i + 3) 0 (encode (i + 2) 0 (local.goodstein i))\n\ngoal (1 subgoal):\n 1. encode (i + 3) 0 (local.goodstein (i + 1))\n    < encode (i + 2) 0 (local.goodstein i)", "have \"?reencode (?decoded_Ei - 1) < ?reencode ?decoded_Ei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode (i + 3) 0\n     (decode (i + 3) 0 (encode (i + 2) 0 (local.goodstein i)) - 1)\n    < encode (i + 3) 0\n       (decode (i + 3) 0 (encode (i + 2) 0 (local.goodstein i)))", "by (rule less_imp_encode_less[OF two_le]) (use decoded_Ei_gt_0 in linarith)"], ["proof (state)\nthis:\n  encode (i + 3) 0\n   (decode (i + 3) 0 (encode (i + 2) 0 (local.goodstein i)) - 1)\n  < encode (i + 3) 0\n     (decode (i + 3) 0 (encode (i + 2) 0 (local.goodstein i)))\n\ngoal (1 subgoal):\n 1. encode (i + 3) 0 (local.goodstein (i + 1))\n    < encode (i + 2) 0 (local.goodstein i)", "also"], ["proof (state)\nthis:\n  encode (i + 3) 0\n   (decode (i + 3) 0 (encode (i + 2) 0 (local.goodstein i)) - 1)\n  < encode (i + 3) 0\n     (decode (i + 3) 0 (encode (i + 2) 0 (local.goodstein i)))\n\ngoal (1 subgoal):\n 1. encode (i + 3) 0 (local.goodstein (i + 1))\n    < encode (i + 2) 0 (local.goodstein i)", "have \"\\<dots> = ?Ei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode (i + 3) 0\n     (decode (i + 3) 0 (encode (i + 2) 0 (local.goodstein i))) =\n    encode (i + 2) 0 (local.goodstein i)", "by (simp only: encode_decode_exp_0[OF two_le well\\<^sub>h])"], ["proof (state)\nthis:\n  encode (i + 3) 0\n   (decode (i + 3) 0 (encode (i + 2) 0 (local.goodstein i))) =\n  encode (i + 2) 0 (local.goodstein i)\n\ngoal (1 subgoal):\n 1. encode (i + 3) 0 (local.goodstein (i + 1))\n    < encode (i + 2) 0 (local.goodstein i)", "finally"], ["proof (chain)\npicking this:\n  encode (i + 3) 0\n   (decode (i + 3) 0 (encode (i + 2) 0 (local.goodstein i)) - 1)\n  < encode (i + 2) 0 (local.goodstein i)", "show ?thesis"], ["proof (prove)\nusing this:\n  encode (i + 3) 0\n   (decode (i + 3) 0 (encode (i + 2) 0 (local.goodstein i)) - 1)\n  < encode (i + 2) 0 (local.goodstein i)\n\ngoal (1 subgoal):\n 1. encode (i + 3) 0 (local.goodstein (i + 1))\n    < encode (i + 2) 0 (local.goodstein i)", "by simp"], ["proof (state)\nthis:\n  encode (i + 3) 0 (local.goodstein (i + 1))\n  < encode (i + 2) 0 (local.goodstein i)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem goodsteins_theorem: \"\\<exists>i. goodstein i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. local.goodstein i = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i. local.goodstein i = 0", "let ?G = \"\\<lambda>i. encode (i + 2) 0 (goodstein i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i. local.goodstein i = 0", "obtain i where\n    \"\\<not> ?G i > ?G (i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<not> encode (i + 1 + 2) 0 (local.goodstein (i + 1))\n               < encode (i + 2) 0 (local.goodstein i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using wf_iff_no_infinite_down_chain[THEN iffD1, OF wf,\n      unfolded not_ex not_all mem_Collect_eq prod.case, rule_format, of ?G]"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     \\<not> encode (Suc x + 2) 0 (local.goodstein (Suc x))\n            < encode (x + 2) 0 (local.goodstein x)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<not> encode (i + 1 + 2) 0 (local.goodstein (i + 1))\n               < encode (i + 2) 0 (local.goodstein i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<not> encode (i + 1 + 2) 0 (local.goodstein (i + 1))\n         < encode (i + 2) 0 (local.goodstein i)\n\ngoal (1 subgoal):\n 1. \\<exists>i. local.goodstein i = 0", "hence \"goodstein i = 0\""], ["proof (prove)\nusing this:\n  \\<not> encode (i + 1 + 2) 0 (local.goodstein (i + 1))\n         < encode (i + 2) 0 (local.goodstein i)\n\ngoal (1 subgoal):\n 1. local.goodstein i = 0", "using goodstein_step"], ["proof (prove)\nusing this:\n  \\<not> encode (i + 1 + 2) 0 (local.goodstein (i + 1))\n         < encode (i + 2) 0 (local.goodstein i)\n  0 < local.goodstein ?i \\<Longrightarrow>\n  encode (?i + 3) 0 (local.goodstein (?i + 1))\n  < encode (?i + 2) 0 (local.goodstein ?i)\n\ngoal (1 subgoal):\n 1. local.goodstein i = 0", "by (metis add.assoc gr0I one_plus_numeral semiring_norm(3))"], ["proof (state)\nthis:\n  local.goodstein i = 0\n\ngoal (1 subgoal):\n 1. \\<exists>i. local.goodstein i = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  local.goodstein i = 0\n\ngoal (1 subgoal):\n 1. \\<exists>i. local.goodstein i = 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>i. local.goodstein i = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}