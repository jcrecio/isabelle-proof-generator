{"file_name": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals/Unary_PCF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals", "problem_names": ["lemma prod_UNIV: \"UNIV = UNIV \\<times> UNIV\"", "lemma infinite_cartesian_productI1: \"infinite A \\<Longrightarrow> B \\<noteq> {} \\<Longrightarrow> infinite (A \\<times> B)\"", "lemma mk_fun_dest_fun[simp]: \"dest_fun T \\<rightarrow>\\<rightarrow> \\<B> = T\"", "lemma dest_fun_mk_fun[simp]: \"dest_fun (Ts \\<rightarrow>\\<rightarrow> T) = Ts @ dest_fun T\"", "lemma \\<delta>_mk_fun: \"\\<delta> (Ts \\<rightarrow>\\<rightarrow> T) = HMSet (hmsetmset (\\<delta> T) + mset (map \\<delta> Ts))\"", "lemma type_induct [case_names Fun]:\n  assumes\n   \"(\\<And>T. (\\<And>T1 T2. T = T1 \\<rightarrow> T2 \\<Longrightarrow> P T1) \\<Longrightarrow>\n    (\\<And>T1 T2. T = T1 \\<rightarrow> T2 \\<Longrightarrow> P T2) \\<Longrightarrow> P T)\"\n  shows \"P T\"", "lemma ex_fresh: \"\\<exists>x. (x :: char list, T) |\\<notin>| A\"", "lemma lc_Abs_iff_body: \"lc (\\<Lambda>\\<langle>T\\<rangle> t) \\<longleftrightarrow> body T t\"", "lemma fv_open_Var: \"fresh xT t \\<Longrightarrow> fv (open_Var i xT t) |\\<subseteq>| finsert xT (fv t)\"", "lemma fv_close_Var[simp]: \"fv (close_Var i xT t) = fv t |-| {|xT|}\"", "lemma close_Var_open_Var[simp]: \"fresh xT t \\<Longrightarrow> close_Var i xT (open_Var i xT t) = t\"", "lemma open_Var_inj: \"fresh xT t \\<Longrightarrow> fresh xT u \\<Longrightarrow> open_Var i xT t = open_Var i xT u \\<Longrightarrow> t = u\"", "lemma open_Var_open_Var_close_Var: \"i \\<noteq> j \\<Longrightarrow> xT \\<noteq> yU \\<Longrightarrow> fresh yU t \\<Longrightarrow>\n  open_Var i yU (open_Var j zV (close_Var j xT t)) = open_Var j zV (close_Var j xT (open_Var i yU t))\"", "lemma open_Var_close_Var[simp]: \"lc t \\<Longrightarrow> open_Var i xT (close_Var i xT t) = t\"", "lemma close_Var_inj: \"lc t \\<Longrightarrow> lc u \\<Longrightarrow> close_Var i xT t = close_Var i xT u \\<Longrightarrow> t = u\"", "lemma Apps_snoc: \"f \\<bullet> (xs @ [x]) = f \\<bullet> xs \\<cdot> x\"", "lemma Apps_append: \"f \\<bullet> (xs @ ys) = f \\<bullet>  xs \\<bullet>  ys\"", "lemma Apps_inj[simp]: \"f \\<bullet> ts = g \\<bullet> ts \\<longleftrightarrow> f = g\"", "lemma eq_Apps_conv[simp]:\n  fixes i :: idx and b :: bool and f :: expr and ts :: \"expr list\"\n  shows\n    \"(\\<langle>m\\<rangle> = f \\<bullet> ts) = (\\<langle>m\\<rangle> = f \\<and> ts = [])\"\n    \"(f  \\<bullet> ts = \\<langle>m\\<rangle>) = (\\<langle>m\\<rangle> = f \\<and> ts = [])\"\n    \"(i = f \\<bullet> ts) = (i = f \\<and> ts = [])\"\n    \"(f \\<bullet> ts = i) = (i = f \\<and> ts = [])\"\n    \"(b = f \\<bullet> ts) = (b = f \\<and> ts = [])\"\n    \"(f \\<bullet> ts = b) = (b = f \\<and> ts = [])\"\n    \"(e1 ? e2 = f \\<bullet> ts) = (e1 ? e2 = f \\<and> ts = [])\"\n    \"(f \\<bullet> ts = e1 ? e2) = (e1 ? e2 = f \\<and> ts = [])\"\n    \"(\\<Lambda>\\<langle>T\\<rangle> t = f \\<bullet> ts) = (\\<Lambda>\\<langle>T\\<rangle> t = f \\<and> ts = [])\"\n    \"(f \\<bullet> ts = \\<Lambda>\\<langle>T\\<rangle> t) = (\\<Lambda>\\<langle>T\\<rangle> t = f \\<and> ts = [])\"", "lemma Apps_Var_eq[simp]: \"\\<langle>xT\\<rangle> \\<bullet> ss = \\<langle>yU\\<rangle> \\<bullet> ts \\<longleftrightarrow> xT = yU \\<and> ss = ts\"", "lemma Apps_Abs_neq_Apps[simp, symmetric, simp]:\n  \"\\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t \\<noteq> \\<langle>xT\\<rangle> \\<bullet> ss\"\n  \"\\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t \\<noteq> (i :: idx) \\<bullet> ss\"\n  \"\\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t \\<noteq> (b :: bool) \\<bullet> ss\"\n  \"\\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t \\<noteq> (e1 ? e2) \\<bullet> ss\"", "lemma App_Abs_eq_Apps_Abs[simp]: \"\\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t = \\<Lambda>\\<langle>T'\\<rangle> r' \\<bullet> ss \\<longleftrightarrow> T = T' \\<and> r = r' \\<and> ss = [t]\"", "lemma Apps_Var_neq_Apps_Abs[simp, symmetric, simp]: \"\\<langle>xT\\<rangle> \\<bullet> ss \\<noteq> \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts\"", "lemma Apps_Var_neq_Apps_beta[simp, THEN not_sym, simp]:\n  \"\\<langle>xT\\<rangle> \\<bullet> ss \\<noteq> \\<Lambda>\\<langle>T\\<rangle> r \\<cdot> s \\<bullet> ts\"", "lemma [simp]:\n  \"(\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts = \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') = (T = T' \\<and> r = r' \\<and> ts = s' # ts')\"", "lemma fold_eq_Bool_iff[simp]:\n  \"fold (\\<rightarrow>) (rev Ts) T = \\<B> \\<longleftrightarrow> Ts = [] \\<and> T = \\<B>\"\n  \"\\<B> = fold (\\<rightarrow>) (rev Ts) T \\<longleftrightarrow> Ts = [] \\<and> T = \\<B>\"", "lemma fold_eq_Fun_iff[simp]:\n  \"fold (\\<rightarrow>) (rev Ts) T = U \\<rightarrow> V \\<longleftrightarrow>\n   (Ts = [] \\<and> T = U \\<rightarrow> V \\<or> (\\<exists>Us. Ts = U # Us \\<and> fold (\\<rightarrow>) (rev Us) T = V))\"", "lemma fv_subst:\n  \"fv (subst xT t u) = fv u |-| {|xT|} |\\<union>| (if xT |\\<in>| fv u then fv t else {||})\"", "lemma subst_fresh: \"fresh xT u \\<Longrightarrow> subst xT t u = u\"", "lemma open_open_id: \"i \\<noteq> j \\<Longrightarrow> open i t (open j t' u) = open j t' u \\<Longrightarrow> open i t u = u\"", "lemma lc_open_id: \"lc u \\<Longrightarrow> open k t u = u\"", "lemma subst_open: \"lc u \\<Longrightarrow> subst xT u (open i t v) = open i (subst xT u t) (subst xT u v)\"", "lemma subst_open_Var:\n  \"xT \\<noteq> yU \\<Longrightarrow> lc u \\<Longrightarrow> subst xT u (open_Var i yU v) = open_Var i yU (subst xT u v)\"", "lemma subst_Apps[simp]:\n  \"subst xT u (f \\<bullet> xs) = subst xT u f \\<bullet> map (subst xT u) xs\"", "lemma fresh_close_Var_id: \"fresh xT t \\<Longrightarrow> close_Var k xT t = t\"", "lemma subst_close_Var:\n  \"xT \\<noteq> yU \\<Longrightarrow> fresh yU u \\<Longrightarrow> subst xT u (close_Var i yU t) = close_Var i yU (subst xT u t)\"", "lemma subst_intro: \"fresh xT t \\<Longrightarrow> lc u \\<Longrightarrow> open0 u t = subst xT u (open0_Var xT t)\"", "lemma lc_subst[simp]: \"lc u \\<Longrightarrow> lc t \\<Longrightarrow> lc (subst xT t u)\"", "lemma body_subst[simp]: \"body U u \\<Longrightarrow> lc t \\<Longrightarrow> body U (subst xT t u)\"", "lemma lc_open_Var: \"lc u \\<Longrightarrow> lc (open_Var i xT u)\"", "lemma lc_open[simp]: \"body U u \\<Longrightarrow> lc t \\<Longrightarrow> lc (open0 t u)\"", "lemma welltyped_unique: \"t ::: T \\<Longrightarrow> t ::: U \\<Longrightarrow> T = U\"", "lemma welltyped_lc[simp]: \"t ::: T \\<Longrightarrow> lc t\"", "lemma welltyped_subst[intro]:\n  \"u ::: U \\<Longrightarrow> t ::: snd xT \\<Longrightarrow> subst xT t u ::: U\"", "lemma rename_welltyped: \"u ::: U \\<Longrightarrow> subst (x, T) \\<langle>(y, T)\\<rangle> u ::: U\"", "lemma welltyped_Abs_fresh:\n  assumes \"fresh (x, T) u\" \"open0_Var (x, T) u ::: U\"\n  shows \"\\<Lambda>\\<langle>T\\<rangle> u ::: T \\<rightarrow> U\"", "lemma Apps_alt: \"f \\<bullet> ts ::: T \\<longleftrightarrow>\n  (\\<exists>Ts. f ::: fold (\\<rightarrow>) (rev Ts) T \\<and> list_all2 (:::) ts Ts)\"", "lemma fv_constant0[simp]: \"fv (constant0 T) = {|(''bool'', \\<B>)|}\"", "lemma closed_constant[simp]: \"closed (constant T)\"", "lemma welltyped_constant0[simp]: \"constant0 T ::: T\"", "lemma lc_constant0[simp]: \"lc (constant0 T)\"", "lemma welltyped_constant[simp]: \"constant T ::: \\<B> \\<rightarrow> T\"", "lemma size_nth_arg[simp]: \"i < ar T \\<Longrightarrow> size (T !- i) < size T\"", "theorem \\<pi>_induct[rotated -2, consumes 2, case_names 0 Suc]:\n  assumes \"\\<And>T i. i < ar T \\<Longrightarrow> P T i 0\"\n    and \"\\<And>T i j. i < ar T \\<Longrightarrow> j < ar (T !- i) \\<Longrightarrow> P (T !- i) j 0 \\<Longrightarrow>\n       (\\<forall>x < ar (T !- i !- j). P (T !- i) j (x + 1)) \\<Longrightarrow> P T i (j + 1)\"\n  shows \"i < ar T \\<Longrightarrow> j \\<le> ar (T !- i) \\<Longrightarrow> P T i j\"", "lemma variant_inj: \"variant i base = variant j base \\<Longrightarrow> i = j\"", "lemma variant_inj2:\n  \"CHR ''*'' \\<notin> set b1 \\<Longrightarrow> CHR ''*'' \\<notin> set b2 \\<Longrightarrow> variant i b1 = variant j b2 \\<Longrightarrow> b1 = b2\"", "lemma Abss_Nil[simp]: \"\\<Lambda>[[]] b = b\"", "lemma Abss_Cons[simp]: \"\\<Lambda>[(x#xs)] b = \\<Lambda>\\<langle>snd x\\<rangle> (close0_Var x (\\<Lambda>[xs] b))\"", "lemma welltyped_Abss: \"b ::: U \\<Longrightarrow> T = map snd xTs \\<rightarrow>\\<rightarrow> U \\<Longrightarrow> \\<Lambda>[xTs] b ::: T\"", "lemma welltyped_Apps: \"list_all2 (:::) ts Ts \\<Longrightarrow> f ::: Ts \\<rightarrow>\\<rightarrow> U \\<Longrightarrow> f \\<bullet> ts ::: U\"", "lemma welltyped_open_Var_close_Var[intro!]:\n  \"t ::: T \\<Longrightarrow> open0_Var xT (close0_Var xT t) ::: T\"", "lemma welltyped_Var_iff[simp]:\n  \"\\<langle>(x, T)\\<rangle> ::: U \\<longleftrightarrow> T = U\"", "lemma welltyped_bool_iff[simp]: \"(b :: bool) ::: T \\<longleftrightarrow> T = \\<B>\"", "lemma welltyped_constant0_iff[simp]: \"constant0 T ::: U \\<longleftrightarrow> (U = T)\"", "lemma welltyped_constant_iff[simp]: \"constant T ::: U \\<longleftrightarrow> (U = \\<B> \\<rightarrow> T)\"", "lemma welltyped_Seq_iff[simp]: \"e1 ? e2 ::: T \\<longleftrightarrow> (T = \\<B> \\<and> e1 ::: \\<B> \\<and> e2 ::: \\<B>)\"", "lemma welltyped_Seqs_iff[simp]: \"es ?? e ::: T \\<longleftrightarrow>\n  ((es \\<noteq> [] \\<longrightarrow> T = \\<B>) \\<and> (\\<forall>e \\<in> set es. e ::: \\<B>) \\<and> e ::: T)\"", "lemma welltyped_App_iff[simp]: \"f \\<cdot> t ::: U \\<longleftrightarrow> (\\<exists>T. f ::: T \\<rightarrow> U \\<and> t ::: T)\"", "lemma welltyped_Apps_iff[simp]: \"f \\<bullet> ts ::: U \\<longleftrightarrow> (\\<exists>Ts. f ::: Ts \\<rightarrow>\\<rightarrow> U \\<and> list_all2 (:::) ts Ts)\"", "lemma eq_mk_fun_iff[simp]: \"T = Ts \\<rightarrow>\\<rightarrow> \\<B> \\<longleftrightarrow> Ts = dest_fun T\"", "lemma map_nth_eq_drop_take[simp]: \"j \\<le> length xs \\<Longrightarrow> map (nth xs) [i ..< j] = drop i (take j xs)\"", "lemma dest_fun_\\<pi>_0: \"i < ar T \\<Longrightarrow> dest_fun (\\<pi> T i 0) = nth_drop i (dest_fun T)\"", "lemma welltyped_E: \"E T i ::: \\<epsilon> T i\" and welltyped_P: \"P T i j ::: T \\<rightarrow> \\<pi> T i j\"", "lemma \\<delta>_gt_0[simp]: \"T \\<noteq> \\<B> \\<Longrightarrow> HMSet {#} < \\<delta> T\"", "lemma mset_nth_drop_less: \"i < length xs \\<Longrightarrow> mset (nth_drop i xs) < mset xs\"", "lemma map_nth_drop: \"i < length xs \\<Longrightarrow> map f (nth_drop i xs) = nth_drop i (map f xs)\"", "lemma empty_less_mset: \"{#} < mset xs \\<longleftrightarrow> xs \\<noteq> []\"", "lemma dest_fun_alt: \"dest_fun T = map (\\<lambda>i. T !- i) [0..<ar T]\"", "lemma \\<delta>_\\<pi>:\n  assumes \"i < ar T\" \"j \\<le> ar (T !- i)\"\n  shows \"\\<delta> (\\<pi> T i j) < \\<delta> T\""], "translations": [["", "lemma prod_UNIV: \"UNIV = UNIV \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = UNIV \\<times> UNIV", "by auto"], ["", "lemma infinite_cartesian_productI1: \"infinite A \\<Longrightarrow> B \\<noteq> {} \\<Longrightarrow> infinite (A \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite A; B \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> infinite (A \\<times> B)", "by (auto dest!: finite_cartesian_productD1)"], ["", "subsection \\<open>Types\\<close>"], ["", "datatype type = \\<B> (\"\\<B>\") | Fun type type (infixr \"\\<rightarrow>\" 65)"], ["", "definition mk_fun  (infixr \"\\<rightarrow>\\<rightarrow>\" 65) where\n  \"Ts \\<rightarrow>\\<rightarrow> T = fold (\\<rightarrow>) (rev Ts) T\""], ["", "primrec dest_fun where\n  \"dest_fun \\<B> = []\"\n| \"dest_fun (T \\<rightarrow> U) = T # dest_fun U\""], ["", "definition arity where\n  \"arity T = length (dest_fun T)\""], ["", "lemma mk_fun_dest_fun[simp]: \"dest_fun T \\<rightarrow>\\<rightarrow> \\<B> = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dest_fun T \\<rightarrow>\\<rightarrow> \\<B> = T", "by (induct T) (auto simp: mk_fun_def)"], ["", "lemma dest_fun_mk_fun[simp]: \"dest_fun (Ts \\<rightarrow>\\<rightarrow> T) = Ts @ dest_fun T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dest_fun (Ts \\<rightarrow>\\<rightarrow> T) = Ts @ dest_fun T", "by (induct Ts) (auto simp: mk_fun_def)"], ["", "primrec \\<delta> where\n  \"\\<delta> \\<B> = HMSet {#}\"\n| \"\\<delta> (T \\<rightarrow> U) = HMSet (add_mset (\\<delta> T) (hmsetmset (\\<delta> U)))\""], ["", "lemma \\<delta>_mk_fun: \"\\<delta> (Ts \\<rightarrow>\\<rightarrow> T) = HMSet (hmsetmset (\\<delta> T) + mset (map \\<delta> Ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> (Ts \\<rightarrow>\\<rightarrow> T) =\n    HMSet (hmsetmset (\\<delta> T) + mset (map \\<delta> Ts))", "by (induct Ts) (auto simp: mk_fun_def)"], ["", "lemma type_induct [case_names Fun]:\n  assumes\n   \"(\\<And>T. (\\<And>T1 T2. T = T1 \\<rightarrow> T2 \\<Longrightarrow> P T1) \\<Longrightarrow>\n    (\\<And>T1 T2. T = T1 \\<rightarrow> T2 \\<Longrightarrow> P T2) \\<Longrightarrow> P T)\"\n  shows \"P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P T", "proof (induct T)"], ["proof (state)\ngoal (2 subgoals):\n 1. P \\<B>\n 2. \\<And>T1 T2.\n       \\<lbrakk>P T1; P T2\\<rbrakk>\n       \\<Longrightarrow> P (T1 \\<rightarrow> T2)", "case \\<B>"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. P \\<B>\n 2. \\<And>T1 T2.\n       \\<lbrakk>P T1; P T2\\<rbrakk>\n       \\<Longrightarrow> P (T1 \\<rightarrow> T2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<B>", "by (rule assms) simp_all"], ["proof (state)\nthis:\n  P \\<B>\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2.\n       \\<lbrakk>P T1; P T2\\<rbrakk>\n       \\<Longrightarrow> P (T1 \\<rightarrow> T2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2.\n       \\<lbrakk>P T1; P T2\\<rbrakk>\n       \\<Longrightarrow> P (T1 \\<rightarrow> T2)", "case Fun"], ["proof (state)\nthis:\n  P T1_\n  P T2_\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2.\n       \\<lbrakk>P T1; P T2\\<rbrakk>\n       \\<Longrightarrow> P (T1 \\<rightarrow> T2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (T1_ \\<rightarrow> T2_)", "by (rule assms) (insert Fun, simp_all)"], ["proof (state)\nthis:\n  P (T1_ \\<rightarrow> T2_)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Terms\\<close>"], ["", "type_synonym name = string"], ["", "type_synonym idx = nat"], ["", "datatype expr =\n    Var \"name * type\" (\"\\<langle>_\\<rangle>\") | Bound idx | B bool\n  | Seq expr expr  (infixr \"?\" 75) | App expr expr (infixl \"\\<cdot>\" 75)\n  | Abs type expr (\"\\<Lambda>\\<langle>_\\<rangle> _\" [100, 100] 800)"], ["", "declare [[coercion_enabled]]"], ["", "declare [[coercion B]]"], ["", "declare [[coercion Bound]]"], ["", "notation (output) B (\"_\")"], ["", "notation (output) Bound (\"_\")"], ["", "primrec \"open\" :: \"idx \\<Rightarrow> expr \\<Rightarrow> expr \\<Rightarrow> expr\" where\n  \"open i t (j :: idx) = (if i = j then t else j)\"\n| \"open i t \\<langle>yU\\<rangle> = \\<langle>yU\\<rangle>\"\n| \"open i t (b :: bool) = b\"\n| \"open i t (e1 ? e2) = open i t e1 ? open i t e2\"\n| \"open i t (e1 \\<cdot> e2) = open i t e1 \\<cdot> open i t e2\"\n| \"open i t (\\<Lambda>\\<langle>U\\<rangle> e) = \\<Lambda>\\<langle>U\\<rangle> (open (i + 1) t e)\""], ["", "abbreviation \"open0 \\<equiv> open 0\""], ["", "abbreviation \"open_Var i xT \\<equiv> open i \\<langle>xT\\<rangle>\""], ["", "abbreviation \"open0_Var xT \\<equiv> open 0 \\<langle>xT\\<rangle>\""], ["", "primrec \"close_Var\" :: \"idx \\<Rightarrow> name \\<times> type \\<Rightarrow> expr \\<Rightarrow> expr\" where\n  \"close_Var i xT (j :: idx) = j\"\n| \"close_Var i xT \\<langle>yU\\<rangle> = (if xT = yU then i else \\<langle>yU\\<rangle>)\"\n| \"close_Var i xT (b :: bool) = b\"\n| \"close_Var i xT (e1 ? e2) = close_Var i xT e1 ? close_Var i xT e2\"\n| \"close_Var i xT (e1 \\<cdot> e2) = close_Var i xT e1 \\<cdot> close_Var i xT e2\"\n| \"close_Var i xT (\\<Lambda>\\<langle>U\\<rangle> e) = \\<Lambda>\\<langle>U\\<rangle> (close_Var (i + 1) xT e)\""], ["", "abbreviation \"close0_Var \\<equiv> close_Var 0\""], ["", "primrec \"fv\" :: \"expr \\<Rightarrow> (name \\<times> type) fset\" where\n  \"fv (j :: idx) = {||}\"\n| \"fv \\<langle>yU\\<rangle> = {|yU|}\"\n| \"fv (b :: bool) = {||}\"\n| \"fv (e1 ? e2) = fv e1 |\\<union>| fv e2\"\n| \"fv (e1 \\<cdot> e2) = fv e1 |\\<union>| fv e2\"\n| \"fv (\\<Lambda>\\<langle>U\\<rangle> e) = fv e\""], ["", "abbreviation \"fresh x e \\<equiv> x |\\<notin>| fv e\""], ["", "lemma ex_fresh: \"\\<exists>x. (x :: char list, T) |\\<notin>| A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. (x, T) |\\<notin>| A", "proof (rule ccontr, unfold not_ex not_not)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x. (x, T) |\\<in>| A \\<Longrightarrow> False", "assume \"\\<forall>x. (x, T) |\\<in>| A\""], ["proof (state)\nthis:\n  \\<forall>x. (x, T) |\\<in>| A\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, T) |\\<in>| A \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. (x, T) |\\<in>| A", "have \"infinite {x. (x, T) |\\<in>| A}\" (is \"infinite ?P\")"], ["proof (prove)\nusing this:\n  \\<forall>x. (x, T) |\\<in>| A\n\ngoal (1 subgoal):\n 1. infinite {x. (x, T) |\\<in>| A}", "by (auto simp add: infinite_UNIV_listI)"], ["proof (state)\nthis:\n  infinite {x. (x, T) |\\<in>| A}\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, T) |\\<in>| A \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  infinite {x. (x, T) |\\<in>| A}\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, T) |\\<in>| A \\<Longrightarrow> False", "have \"?P \\<subseteq> fst ` fset A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. (x, T) |\\<in>| A} \\<subseteq> fst ` fset A", "by (force simp: fmember.rep_eq)"], ["proof (state)\nthis:\n  {x. (x, T) |\\<in>| A} \\<subseteq> fst ` fset A\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, T) |\\<in>| A \\<Longrightarrow> False", "from finite_surj[OF _ this]"], ["proof (chain)\npicking this:\n  finite (fset A) \\<Longrightarrow> finite {x. (x, T) |\\<in>| A}", "have \"finite ?P\""], ["proof (prove)\nusing this:\n  finite (fset A) \\<Longrightarrow> finite {x. (x, T) |\\<in>| A}\n\ngoal (1 subgoal):\n 1. finite {x. (x, T) |\\<in>| A}", "by simp"], ["proof (state)\nthis:\n  finite {x. (x, T) |\\<in>| A}\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, T) |\\<in>| A \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  infinite {x. (x, T) |\\<in>| A}\n  finite {x. (x, T) |\\<in>| A}", "show False"], ["proof (prove)\nusing this:\n  infinite {x. (x, T) |\\<in>| A}\n  finite {x. (x, T) |\\<in>| A}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive lc where\n  lc_Var[simp]: \"lc \\<langle>xT\\<rangle>\"\n| lc_B[simp]: \"lc (b :: bool)\"\n| lc_Seq: \"lc e1 \\<Longrightarrow> lc e2 \\<Longrightarrow> lc (e1 ? e2)\"\n| lc_App: \"lc e1 \\<Longrightarrow> lc e2 \\<Longrightarrow> lc (e1 \\<cdot> e2)\"\n| lc_Abs: \"(\\<forall>x. (x, T) |\\<notin>| X \\<longrightarrow> lc (open0_Var (x, T) e)) \\<Longrightarrow> lc (\\<Lambda>\\<langle>T\\<rangle> e)\""], ["", "declare lc.intros[intro]"], ["", "definition \"body T t \\<equiv> (\\<exists>X. \\<forall>x. (x, T) |\\<notin>| X \\<longrightarrow> lc (open0_Var (x, T) t))\""], ["", "lemma lc_Abs_iff_body: \"lc (\\<Lambda>\\<langle>T\\<rangle> t) \\<longleftrightarrow> body T t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc (\\<Lambda>\\<langle>T\\<rangle> t) = body T t", "unfolding body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lc (\\<Lambda>\\<langle>T\\<rangle> t) =\n    (\\<exists>X.\n        \\<forall>x.\n           (x, T) |\\<notin>| X \\<longrightarrow> lc (open0_Var (x, T) t))", "by (subst lc.simps) simp"], ["", "lemma fv_open_Var: \"fresh xT t \\<Longrightarrow> fv (open_Var i xT t) |\\<subseteq>| finsert xT (fv t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh xT t \\<Longrightarrow>\n    fv (open_Var i xT t) |\\<subseteq>| finsert xT (fv t)", "by (induct t arbitrary: i) auto"], ["", "lemma fv_close_Var[simp]: \"fv (close_Var i xT t) = fv t |-| {|xT|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (close_Var i xT t) = fv t |-| {|xT|}", "by (induct t arbitrary: i) auto"], ["", "lemma close_Var_open_Var[simp]: \"fresh xT t \\<Longrightarrow> close_Var i xT (open_Var i xT t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh xT t \\<Longrightarrow> close_Var i xT (open_Var i xT t) = t", "by (induct t arbitrary: i) auto"], ["", "lemma open_Var_inj: \"fresh xT t \\<Longrightarrow> fresh xT u \\<Longrightarrow> open_Var i xT t = open_Var i xT u \\<Longrightarrow> t = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fresh xT t; fresh xT u;\n     open_Var i xT t = open_Var i xT u\\<rbrakk>\n    \\<Longrightarrow> t = u", "by (metis close_Var_open_Var)"], ["", "context begin"], ["", "private"], ["", "lemma open_Var_open_Var_close_Var: \"i \\<noteq> j \\<Longrightarrow> xT \\<noteq> yU \\<Longrightarrow> fresh yU t \\<Longrightarrow>\n  open_Var i yU (open_Var j zV (close_Var j xT t)) = open_Var j zV (close_Var j xT (open_Var i yU t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> j; xT \\<noteq> yU; fresh yU t\\<rbrakk>\n    \\<Longrightarrow> open_Var i yU (open_Var j zV (close_Var j xT t)) =\n                      open_Var j zV (close_Var j xT (open_Var i yU t))", "by (induct t arbitrary: i j) auto"], ["", "lemma open_Var_close_Var[simp]: \"lc t \\<Longrightarrow> open_Var i xT (close_Var i xT t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc t \\<Longrightarrow> open_Var i xT (close_Var i xT t) = t", "proof (induction t arbitrary: i rule: lc.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xTa i.\n       open_Var i xT (close_Var i xT \\<langle>xTa\\<rangle>) =\n       \\<langle>xTa\\<rangle>\n 2. \\<And>b i. open_Var i xT (close_Var i xT b) = b\n 3. \\<And>e1 e2 i.\n       \\<lbrakk>lc e1; \\<And>i. open_Var i xT (close_Var i xT e1) = e1;\n        lc e2; \\<And>i. open_Var i xT (close_Var i xT e2) = e2\\<rbrakk>\n       \\<Longrightarrow> open_Var i xT (close_Var i xT (e1 ? e2)) = e1 ? e2\n 4. \\<And>e1 e2 i.\n       \\<lbrakk>lc e1; \\<And>i. open_Var i xT (close_Var i xT e1) = e1;\n        lc e2; \\<And>i. open_Var i xT (close_Var i xT e2) = e2\\<rbrakk>\n       \\<Longrightarrow> open_Var i xT (close_Var i xT (e1 \\<cdot> e2)) =\n                         e1 \\<cdot> e2\n 5. \\<And>T X e i.\n       \\<forall>x.\n          (x, T) |\\<notin>| X \\<longrightarrow>\n          lc (open0_Var (x, T) e) \\<and>\n          (\\<forall>xa.\n              open_Var xa xT (close_Var xa xT (open0_Var (x, T) e)) =\n              open0_Var (x, T) e) \\<Longrightarrow>\n       open_Var i xT (close_Var i xT (\\<Lambda>\\<langle>T\\<rangle> e)) =\n       \\<Lambda>\\<langle>T\\<rangle> e", "case (lc_Abs T X e i)"], ["proof (state)\nthis:\n  \\<forall>x.\n     (x, T) |\\<notin>| X \\<longrightarrow>\n     lc (open0_Var (x, T) e) \\<and>\n     (\\<forall>xa.\n         open_Var xa xT (close_Var xa xT (open0_Var (x, T) e)) =\n         open0_Var (x, T) e)\n\ngoal (5 subgoals):\n 1. \\<And>xTa i.\n       open_Var i xT (close_Var i xT \\<langle>xTa\\<rangle>) =\n       \\<langle>xTa\\<rangle>\n 2. \\<And>b i. open_Var i xT (close_Var i xT b) = b\n 3. \\<And>e1 e2 i.\n       \\<lbrakk>lc e1; \\<And>i. open_Var i xT (close_Var i xT e1) = e1;\n        lc e2; \\<And>i. open_Var i xT (close_Var i xT e2) = e2\\<rbrakk>\n       \\<Longrightarrow> open_Var i xT (close_Var i xT (e1 ? e2)) = e1 ? e2\n 4. \\<And>e1 e2 i.\n       \\<lbrakk>lc e1; \\<And>i. open_Var i xT (close_Var i xT e1) = e1;\n        lc e2; \\<And>i. open_Var i xT (close_Var i xT e2) = e2\\<rbrakk>\n       \\<Longrightarrow> open_Var i xT (close_Var i xT (e1 \\<cdot> e2)) =\n                         e1 \\<cdot> e2\n 5. \\<And>T X e i.\n       \\<forall>x.\n          (x, T) |\\<notin>| X \\<longrightarrow>\n          lc (open0_Var (x, T) e) \\<and>\n          (\\<forall>xa.\n              open_Var xa xT (close_Var xa xT (open0_Var (x, T) e)) =\n              open0_Var (x, T) e) \\<Longrightarrow>\n       open_Var i xT (close_Var i xT (\\<Lambda>\\<langle>T\\<rangle> e)) =\n       \\<Lambda>\\<langle>T\\<rangle> e", "obtain x where x: \"fresh (x, T) e\" \"(x, T) \\<noteq> xT\" \"(x, T) |\\<notin>| X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>fresh (x, T) e; (x, T) \\<noteq> xT;\n         (x, T) |\\<notin>| X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_fresh[of _ \"fv e |\\<union>| finsert xT X\"]"], ["proof (prove)\nusing this:\n  \\<exists>x. (x, ?T) |\\<notin>| fv e |\\<union>| finsert xT X\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>fresh (x, T) e; (x, T) \\<noteq> xT;\n         (x, T) |\\<notin>| X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  fresh (x, T) e\n  (x, T) \\<noteq> xT\n  (x, T) |\\<notin>| X\n\ngoal (5 subgoals):\n 1. \\<And>xTa i.\n       open_Var i xT (close_Var i xT \\<langle>xTa\\<rangle>) =\n       \\<langle>xTa\\<rangle>\n 2. \\<And>b i. open_Var i xT (close_Var i xT b) = b\n 3. \\<And>e1 e2 i.\n       \\<lbrakk>lc e1; \\<And>i. open_Var i xT (close_Var i xT e1) = e1;\n        lc e2; \\<And>i. open_Var i xT (close_Var i xT e2) = e2\\<rbrakk>\n       \\<Longrightarrow> open_Var i xT (close_Var i xT (e1 ? e2)) = e1 ? e2\n 4. \\<And>e1 e2 i.\n       \\<lbrakk>lc e1; \\<And>i. open_Var i xT (close_Var i xT e1) = e1;\n        lc e2; \\<And>i. open_Var i xT (close_Var i xT e2) = e2\\<rbrakk>\n       \\<Longrightarrow> open_Var i xT (close_Var i xT (e1 \\<cdot> e2)) =\n                         e1 \\<cdot> e2\n 5. \\<And>T X e i.\n       \\<forall>x.\n          (x, T) |\\<notin>| X \\<longrightarrow>\n          lc (open0_Var (x, T) e) \\<and>\n          (\\<forall>xa.\n              open_Var xa xT (close_Var xa xT (open0_Var (x, T) e)) =\n              open0_Var (x, T) e) \\<Longrightarrow>\n       open_Var i xT (close_Var i xT (\\<Lambda>\\<langle>T\\<rangle> e)) =\n       \\<Lambda>\\<langle>T\\<rangle> e", "with lc_Abs.IH"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     (x, T) |\\<notin>| X \\<longrightarrow>\n     lc (open0_Var (x, T) e) \\<and>\n     (\\<forall>xa.\n         open_Var xa xT (close_Var xa xT (open0_Var (x, T) e)) =\n         open0_Var (x, T) e)\n  fresh (x, T) e\n  (x, T) \\<noteq> xT\n  (x, T) |\\<notin>| X", "have \"lc (open0_Var (x, T) e)\"\n    \"open_Var (i + 1) xT (close_Var (i + 1) xT (open0_Var (x, T) e)) = open0_Var (x, T) e\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (x, T) |\\<notin>| X \\<longrightarrow>\n     lc (open0_Var (x, T) e) \\<and>\n     (\\<forall>xa.\n         open_Var xa xT (close_Var xa xT (open0_Var (x, T) e)) =\n         open0_Var (x, T) e)\n  fresh (x, T) e\n  (x, T) \\<noteq> xT\n  (x, T) |\\<notin>| X\n\ngoal (1 subgoal):\n 1. lc (open0_Var (x, T) e) &&&\n    open_Var (i + 1) xT (close_Var (i + 1) xT (open0_Var (x, T) e)) =\n    open0_Var (x, T) e", "by auto"], ["proof (state)\nthis:\n  lc (open0_Var (x, T) e)\n  open_Var (i + 1) xT (close_Var (i + 1) xT (open0_Var (x, T) e)) =\n  open0_Var (x, T) e\n\ngoal (5 subgoals):\n 1. \\<And>xTa i.\n       open_Var i xT (close_Var i xT \\<langle>xTa\\<rangle>) =\n       \\<langle>xTa\\<rangle>\n 2. \\<And>b i. open_Var i xT (close_Var i xT b) = b\n 3. \\<And>e1 e2 i.\n       \\<lbrakk>lc e1; \\<And>i. open_Var i xT (close_Var i xT e1) = e1;\n        lc e2; \\<And>i. open_Var i xT (close_Var i xT e2) = e2\\<rbrakk>\n       \\<Longrightarrow> open_Var i xT (close_Var i xT (e1 ? e2)) = e1 ? e2\n 4. \\<And>e1 e2 i.\n       \\<lbrakk>lc e1; \\<And>i. open_Var i xT (close_Var i xT e1) = e1;\n        lc e2; \\<And>i. open_Var i xT (close_Var i xT e2) = e2\\<rbrakk>\n       \\<Longrightarrow> open_Var i xT (close_Var i xT (e1 \\<cdot> e2)) =\n                         e1 \\<cdot> e2\n 5. \\<And>T X e i.\n       \\<forall>x.\n          (x, T) |\\<notin>| X \\<longrightarrow>\n          lc (open0_Var (x, T) e) \\<and>\n          (\\<forall>xa.\n              open_Var xa xT (close_Var xa xT (open0_Var (x, T) e)) =\n              open0_Var (x, T) e) \\<Longrightarrow>\n       open_Var i xT (close_Var i xT (\\<Lambda>\\<langle>T\\<rangle> e)) =\n       \\<Lambda>\\<langle>T\\<rangle> e", "with x"], ["proof (chain)\npicking this:\n  fresh (x, T) e\n  (x, T) \\<noteq> xT\n  (x, T) |\\<notin>| X\n  lc (open0_Var (x, T) e)\n  open_Var (i + 1) xT (close_Var (i + 1) xT (open0_Var (x, T) e)) =\n  open0_Var (x, T) e", "show ?case"], ["proof (prove)\nusing this:\n  fresh (x, T) e\n  (x, T) \\<noteq> xT\n  (x, T) |\\<notin>| X\n  lc (open0_Var (x, T) e)\n  open_Var (i + 1) xT (close_Var (i + 1) xT (open0_Var (x, T) e)) =\n  open0_Var (x, T) e\n\ngoal (1 subgoal):\n 1. open_Var i xT (close_Var i xT (\\<Lambda>\\<langle>T\\<rangle> e)) =\n    \\<Lambda>\\<langle>T\\<rangle> e", "by (auto simp: open_Var_open_Var_close_Var\n      dest: fset_mp[OF fv_open_Var, rotated]\n      intro!: open_Var_inj[of \"(x, T)\" _ e 0])"], ["proof (state)\nthis:\n  open_Var i xT (close_Var i xT (\\<Lambda>\\<langle>T\\<rangle> e)) =\n  \\<Lambda>\\<langle>T\\<rangle> e\n\ngoal (4 subgoals):\n 1. \\<And>xTa i.\n       open_Var i xT (close_Var i xT \\<langle>xTa\\<rangle>) =\n       \\<langle>xTa\\<rangle>\n 2. \\<And>b i. open_Var i xT (close_Var i xT b) = b\n 3. \\<And>e1 e2 i.\n       \\<lbrakk>lc e1; \\<And>i. open_Var i xT (close_Var i xT e1) = e1;\n        lc e2; \\<And>i. open_Var i xT (close_Var i xT e2) = e2\\<rbrakk>\n       \\<Longrightarrow> open_Var i xT (close_Var i xT (e1 ? e2)) = e1 ? e2\n 4. \\<And>e1 e2 i.\n       \\<lbrakk>lc e1; \\<And>i. open_Var i xT (close_Var i xT e1) = e1;\n        lc e2; \\<And>i. open_Var i xT (close_Var i xT e2) = e2\\<rbrakk>\n       \\<Longrightarrow> open_Var i xT (close_Var i xT (e1 \\<cdot> e2)) =\n                         e1 \\<cdot> e2", "qed auto"], ["", "end"], ["", "lemma close_Var_inj: \"lc t \\<Longrightarrow> lc u \\<Longrightarrow> close_Var i xT t = close_Var i xT u \\<Longrightarrow> t = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lc t; lc u; close_Var i xT t = close_Var i xT u\\<rbrakk>\n    \\<Longrightarrow> t = u", "by (metis open_Var_close_Var)"], ["", "primrec Apps (infixl \"\\<bullet>\" 75) where\n  \"f \\<bullet> [] = f\"\n| \"f \\<bullet> (x # xs) = f \\<cdot> x \\<bullet> xs\""], ["", "lemma Apps_snoc: \"f \\<bullet> (xs @ [x]) = f \\<bullet> xs \\<cdot> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<bullet> (xs @ [x]) = f \\<bullet> xs \\<cdot> x", "by (induct xs arbitrary: f) auto"], ["", "lemma Apps_append: \"f \\<bullet> (xs @ ys) = f \\<bullet>  xs \\<bullet>  ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<bullet> (xs @ ys) = f \\<bullet> xs \\<bullet> ys", "by (induct xs arbitrary: f) auto"], ["", "lemma Apps_inj[simp]: \"f \\<bullet> ts = g \\<bullet> ts \\<longleftrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<bullet> ts = g \\<bullet> ts) = (f = g)", "by (induct ts arbitrary: f g) auto"], ["", "lemma eq_Apps_conv[simp]:\n  fixes i :: idx and b :: bool and f :: expr and ts :: \"expr list\"\n  shows\n    \"(\\<langle>m\\<rangle> = f \\<bullet> ts) = (\\<langle>m\\<rangle> = f \\<and> ts = [])\"\n    \"(f  \\<bullet> ts = \\<langle>m\\<rangle>) = (\\<langle>m\\<rangle> = f \\<and> ts = [])\"\n    \"(i = f \\<bullet> ts) = (i = f \\<and> ts = [])\"\n    \"(f \\<bullet> ts = i) = (i = f \\<and> ts = [])\"\n    \"(b = f \\<bullet> ts) = (b = f \\<and> ts = [])\"\n    \"(f \\<bullet> ts = b) = (b = f \\<and> ts = [])\"\n    \"(e1 ? e2 = f \\<bullet> ts) = (e1 ? e2 = f \\<and> ts = [])\"\n    \"(f \\<bullet> ts = e1 ? e2) = (e1 ? e2 = f \\<and> ts = [])\"\n    \"(\\<Lambda>\\<langle>T\\<rangle> t = f \\<bullet> ts) = (\\<Lambda>\\<langle>T\\<rangle> t = f \\<and> ts = [])\"\n    \"(f \\<bullet> ts = \\<Lambda>\\<langle>T\\<rangle> t) = (\\<Lambda>\\<langle>T\\<rangle> t = f \\<and> ts = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<langle>m\\<rangle> = f \\<bullet> ts) =\n      (\\<langle>m\\<rangle> = f \\<and> ts = []) &&&\n      (f \\<bullet> ts = \\<langle>m\\<rangle>) =\n      (\\<langle>m\\<rangle> = f \\<and> ts = [])) &&&\n     (i = f \\<bullet> ts) = (i = f \\<and> ts = []) &&&\n     (f \\<bullet> ts = i) = (i = f \\<and> ts = []) &&&\n     (b = f \\<bullet> ts) = (b = f \\<and> ts = [])) &&&\n    ((f \\<bullet> ts = b) = (b = f \\<and> ts = []) &&&\n     (e1 ? e2 = f \\<bullet> ts) = (e1 ? e2 = f \\<and> ts = [])) &&&\n    (f \\<bullet> ts = e1 ? e2) = (e1 ? e2 = f \\<and> ts = []) &&&\n    (\\<Lambda>\\<langle>T\\<rangle> t = f \\<bullet> ts) =\n    (\\<Lambda>\\<langle>T\\<rangle> t = f \\<and> ts = []) &&&\n    (f \\<bullet> ts = \\<Lambda>\\<langle>T\\<rangle> t) =\n    (\\<Lambda>\\<langle>T\\<rangle> t = f \\<and> ts = [])", "by (induct ts arbitrary: f) auto"], ["", "lemma Apps_Var_eq[simp]: \"\\<langle>xT\\<rangle> \\<bullet> ss = \\<langle>yU\\<rangle> \\<bullet> ts \\<longleftrightarrow> xT = yU \\<and> ss = ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>xT\\<rangle> \\<bullet> ss =\n     \\<langle>yU\\<rangle> \\<bullet> ts) =\n    (xT = yU \\<and> ss = ts)", "proof (induct ss arbitrary: ts rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts.\n       (\\<langle>xT\\<rangle> \\<bullet> [] =\n        \\<langle>yU\\<rangle> \\<bullet> ts) =\n       (xT = yU \\<and> [] = ts)\n 2. \\<And>x xs ts.\n       (\\<And>ts.\n           (\\<langle>xT\\<rangle> \\<bullet> xs =\n            \\<langle>yU\\<rangle> \\<bullet> ts) =\n           (xT = yU \\<and> xs = ts)) \\<Longrightarrow>\n       (\\<langle>xT\\<rangle> \\<bullet> (xs @ [x]) =\n        \\<langle>yU\\<rangle> \\<bullet> ts) =\n       (xT = yU \\<and> xs @ [x] = ts)", "case snoc"], ["proof (state)\nthis:\n  (\\<langle>xT\\<rangle> \\<bullet> xs_ =\n   \\<langle>yU\\<rangle> \\<bullet> ?ts) =\n  (xT = yU \\<and> xs_ = ?ts)\n\ngoal (2 subgoals):\n 1. \\<And>ts.\n       (\\<langle>xT\\<rangle> \\<bullet> [] =\n        \\<langle>yU\\<rangle> \\<bullet> ts) =\n       (xT = yU \\<and> [] = ts)\n 2. \\<And>x xs ts.\n       (\\<And>ts.\n           (\\<langle>xT\\<rangle> \\<bullet> xs =\n            \\<langle>yU\\<rangle> \\<bullet> ts) =\n           (xT = yU \\<and> xs = ts)) \\<Longrightarrow>\n       (\\<langle>xT\\<rangle> \\<bullet> (xs @ [x]) =\n        \\<langle>yU\\<rangle> \\<bullet> ts) =\n       (xT = yU \\<and> xs @ [x] = ts)", "then"], ["proof (chain)\npicking this:\n  (\\<langle>xT\\<rangle> \\<bullet> xs_ =\n   \\<langle>yU\\<rangle> \\<bullet> ?ts) =\n  (xT = yU \\<and> xs_ = ?ts)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<langle>xT\\<rangle> \\<bullet> xs_ =\n   \\<langle>yU\\<rangle> \\<bullet> ?ts) =\n  (xT = yU \\<and> xs_ = ?ts)\n\ngoal (1 subgoal):\n 1. (\\<langle>xT\\<rangle> \\<bullet> (xs_ @ [x_]) =\n     \\<langle>yU\\<rangle> \\<bullet> ts) =\n    (xT = yU \\<and> xs_ @ [x_] = ts)", "by (induct ts rule: rev_induct) (auto simp: Apps_snoc)"], ["proof (state)\nthis:\n  (\\<langle>xT\\<rangle> \\<bullet> (xs_ @ [x_]) =\n   \\<langle>yU\\<rangle> \\<bullet> ts) =\n  (xT = yU \\<and> xs_ @ [x_] = ts)\n\ngoal (1 subgoal):\n 1. \\<And>ts.\n       (\\<langle>xT\\<rangle> \\<bullet> [] =\n        \\<langle>yU\\<rangle> \\<bullet> ts) =\n       (xT = yU \\<and> [] = ts)", "qed auto"], ["", "lemma Apps_Abs_neq_Apps[simp, symmetric, simp]:\n  \"\\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t \\<noteq> \\<langle>xT\\<rangle> \\<bullet> ss\"\n  \"\\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t \\<noteq> (i :: idx) \\<bullet> ss\"\n  \"\\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t \\<noteq> (b :: bool) \\<bullet> ss\"\n  \"\\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t \\<noteq> (e1 ? e2) \\<bullet> ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t \\<noteq>\n     \\<langle>xT\\<rangle> \\<bullet> ss &&&\n     \\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t \\<noteq> i \\<bullet> ss) &&&\n    \\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t \\<noteq> b \\<bullet> ss &&&\n    \\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t \\<noteq> e1 ? e2 \\<bullet> ss", "by (induct ss rule: rev_induct) (auto simp: Apps_snoc)"], ["", "lemma App_Abs_eq_Apps_Abs[simp]: \"\\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t = \\<Lambda>\\<langle>T'\\<rangle> r' \\<bullet> ss \\<longleftrightarrow> T = T' \\<and> r = r' \\<and> ss = [t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda>\\<langle>T\\<rangle> r \\<cdot> t =\n     \\<Lambda>\\<langle>T'\\<rangle> r' \\<bullet> ss) =\n    (T = T' \\<and> r = r' \\<and> ss = [t])", "by (induct ss rule: rev_induct) (auto simp: Apps_snoc)"], ["", "lemma Apps_Var_neq_Apps_Abs[simp, symmetric, simp]: \"\\<langle>xT\\<rangle> \\<bullet> ss \\<noteq> \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>xT\\<rangle> \\<bullet> ss \\<noteq>\n    \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts", "proof (induct ss arbitrary: ts rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts.\n       \\<langle>xT\\<rangle> \\<bullet> [] \\<noteq>\n       \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts\n 2. \\<And>x xs ts.\n       (\\<And>ts.\n           \\<langle>xT\\<rangle> \\<bullet> xs \\<noteq>\n           \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts) \\<Longrightarrow>\n       \\<langle>xT\\<rangle> \\<bullet> (xs @ [x]) \\<noteq>\n       \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts", "case (snoc a ss)"], ["proof (state)\nthis:\n  \\<langle>xT\\<rangle> \\<bullet> ss \\<noteq>\n  \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ?ts\n\ngoal (2 subgoals):\n 1. \\<And>ts.\n       \\<langle>xT\\<rangle> \\<bullet> [] \\<noteq>\n       \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts\n 2. \\<And>x xs ts.\n       (\\<And>ts.\n           \\<langle>xT\\<rangle> \\<bullet> xs \\<noteq>\n           \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts) \\<Longrightarrow>\n       \\<langle>xT\\<rangle> \\<bullet> (xs @ [x]) \\<noteq>\n       \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts", "then"], ["proof (chain)\npicking this:\n  \\<langle>xT\\<rangle> \\<bullet> ss \\<noteq>\n  \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ?ts", "show ?case"], ["proof (prove)\nusing this:\n  \\<langle>xT\\<rangle> \\<bullet> ss \\<noteq>\n  \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ?ts\n\ngoal (1 subgoal):\n 1. \\<langle>xT\\<rangle> \\<bullet> (ss @ [a]) \\<noteq>\n    \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts", "by (induct ts rule: rev_induct) (auto simp: Apps_snoc)"], ["proof (state)\nthis:\n  \\<langle>xT\\<rangle> \\<bullet> (ss @ [a]) \\<noteq>\n  \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts\n\ngoal (1 subgoal):\n 1. \\<And>ts.\n       \\<langle>xT\\<rangle> \\<bullet> [] \\<noteq>\n       \\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts", "qed simp"], ["", "lemma Apps_Var_neq_Apps_beta[simp, THEN not_sym, simp]:\n  \"\\<langle>xT\\<rangle> \\<bullet> ss \\<noteq> \\<Lambda>\\<langle>T\\<rangle> r \\<cdot> s \\<bullet> ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>xT\\<rangle> \\<bullet> ss \\<noteq>\n    \\<Lambda>\\<langle>T\\<rangle> r \\<cdot> s \\<bullet> ts", "by (metis Apps_Var_neq_Apps_Abs Apps_append Apps_snoc eq_Apps_conv(9))"], ["", "lemma [simp]:\n  \"(\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts = \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') = (T = T' \\<and> r = r' \\<and> ts = s' # ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> ts =\n     \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n    (T = T' \\<and> r = r' \\<and> ts = s' # ts')", "proof (induct ts arbitrary: ts' rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts'.\n       (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> [] =\n        \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n       (T = T' \\<and> r = r' \\<and> [] = s' # ts')\n 2. \\<And>x xs ts'.\n       (\\<And>ts'.\n           (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> xs =\n            \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n           (T = T' \\<and> r = r' \\<and> xs = s' # ts')) \\<Longrightarrow>\n       (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> (xs @ [x]) =\n        \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n       (T = T' \\<and> r = r' \\<and> xs @ [x] = s' # ts')", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ts'.\n       (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> [] =\n        \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n       (T = T' \\<and> r = r' \\<and> [] = s' # ts')\n 2. \\<And>x xs ts'.\n       (\\<And>ts'.\n           (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> xs =\n            \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n           (T = T' \\<and> r = r' \\<and> xs = s' # ts')) \\<Longrightarrow>\n       (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> (xs @ [x]) =\n        \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n       (T = T' \\<and> r = r' \\<and> xs @ [x] = s' # ts')", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> [] =\n     \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n    (T = T' \\<and> r = r' \\<and> [] = s' # ts')", "by (induct ts' rule: rev_induct) (auto simp: Apps_snoc)"], ["proof (state)\nthis:\n  (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> [] =\n   \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n  (T = T' \\<and> r = r' \\<and> [] = s' # ts')\n\ngoal (1 subgoal):\n 1. \\<And>x xs ts'.\n       (\\<And>ts'.\n           (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> xs =\n            \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n           (T = T' \\<and> r = r' \\<and> xs = s' # ts')) \\<Longrightarrow>\n       (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> (xs @ [x]) =\n        \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n       (T = T' \\<and> r = r' \\<and> xs @ [x] = s' # ts')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ts'.\n       (\\<And>ts'.\n           (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> xs =\n            \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n           (T = T' \\<and> r = r' \\<and> xs = s' # ts')) \\<Longrightarrow>\n       (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> (xs @ [x]) =\n        \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n       (T = T' \\<and> r = r' \\<and> xs @ [x] = s' # ts')", "case snoc"], ["proof (state)\nthis:\n  (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> xs_ =\n   \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ?ts') =\n  (T = T' \\<and> r = r' \\<and> xs_ = s' # ?ts')\n\ngoal (1 subgoal):\n 1. \\<And>x xs ts'.\n       (\\<And>ts'.\n           (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> xs =\n            \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n           (T = T' \\<and> r = r' \\<and> xs = s' # ts')) \\<Longrightarrow>\n       (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> (xs @ [x]) =\n        \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n       (T = T' \\<and> r = r' \\<and> xs @ [x] = s' # ts')", "then"], ["proof (chain)\npicking this:\n  (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> xs_ =\n   \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ?ts') =\n  (T = T' \\<and> r = r' \\<and> xs_ = s' # ?ts')", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> xs_ =\n   \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ?ts') =\n  (T = T' \\<and> r = r' \\<and> xs_ = s' # ?ts')\n\ngoal (1 subgoal):\n 1. (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> (xs_ @ [x_]) =\n     \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n    (T = T' \\<and> r = r' \\<and> xs_ @ [x_] = s' # ts')", "by (induct ts' rule: rev_induct) (auto simp: Apps_snoc)"], ["proof (state)\nthis:\n  (\\<Lambda>\\<langle>T\\<rangle> r \\<bullet> (xs_ @ [x_]) =\n   \\<Lambda>\\<langle>T'\\<rangle> r' \\<cdot> s' \\<bullet> ts') =\n  (T = T' \\<and> r = r' \\<and> xs_ @ [x_] = s' # ts')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_eq_Bool_iff[simp]:\n  \"fold (\\<rightarrow>) (rev Ts) T = \\<B> \\<longleftrightarrow> Ts = [] \\<and> T = \\<B>\"\n  \"\\<B> = fold (\\<rightarrow>) (rev Ts) T \\<longleftrightarrow> Ts = [] \\<and> T = \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fold (\\<rightarrow>) (rev Ts) T = \\<B>) = (Ts = [] \\<and> T = \\<B>) &&&\n    (\\<B> = fold (\\<rightarrow>) (rev Ts) T) = (Ts = [] \\<and> T = \\<B>)", "by (induct Ts) auto"], ["", "lemma fold_eq_Fun_iff[simp]:\n  \"fold (\\<rightarrow>) (rev Ts) T = U \\<rightarrow> V \\<longleftrightarrow>\n   (Ts = [] \\<and> T = U \\<rightarrow> V \\<or> (\\<exists>Us. Ts = U # Us \\<and> fold (\\<rightarrow>) (rev Us) T = V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fold (\\<rightarrow>) (rev Ts) T = U \\<rightarrow> V) =\n    (Ts = [] \\<and> T = U \\<rightarrow> V \\<or>\n     (\\<exists>Us. Ts = U # Us \\<and> fold (\\<rightarrow>) (rev Us) T = V))", "by (induct Ts) auto"], ["", "subsection \\<open>Substitution\\<close>"], ["", "primrec subst where\n  \"subst xT t \\<langle>yU\\<rangle> = (if xT = yU then t else \\<langle>yU\\<rangle>)\"\n| \"subst xT t (i :: idx) = i\"\n| \"subst xT t (b :: bool) = b\"\n| \"subst xT t (e1 ? e2) = subst xT t e1 ? subst xT t e2\"\n| \"subst xT t (e1 \\<cdot> e2) = subst xT t e1 \\<cdot> subst xT t e2\"\n| \"subst xT t (\\<Lambda>\\<langle>T\\<rangle> e) = \\<Lambda>\\<langle>T\\<rangle> (subst xT t e)\""], ["", "lemma fv_subst:\n  \"fv (subst xT t u) = fv u |-| {|xT|} |\\<union>| (if xT |\\<in>| fv u then fv t else {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (subst xT t u) =\n    fv u |-| {|xT|} |\\<union>| (if xT |\\<in>| fv u then fv t else {||})", "by (induct u) auto"], ["", "lemma subst_fresh: \"fresh xT u \\<Longrightarrow> subst xT t u = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh xT u \\<Longrightarrow> subst xT t u = u", "by (induct u) auto"], ["", "context begin"], ["", "private"], ["", "lemma open_open_id: \"i \\<noteq> j \\<Longrightarrow> open i t (open j t' u) = open j t' u \\<Longrightarrow> open i t u = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> j; open i t (open j t' u) = open j t' u\\<rbrakk>\n    \\<Longrightarrow> open i t u = u", "by (induct u arbitrary: i j) (auto 6 0)"], ["", "lemma lc_open_id: \"lc u \\<Longrightarrow> open k t u = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc u \\<Longrightarrow> open k t u = u", "proof (induct u arbitrary: k rule: lc.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xT k. open k t \\<langle>xT\\<rangle> = \\<langle>xT\\<rangle>\n 2. \\<And>b k. open k t b = b\n 3. \\<And>e1 e2 k.\n       \\<lbrakk>lc e1; \\<And>k. open k t e1 = e1; lc e2;\n        \\<And>k. open k t e2 = e2\\<rbrakk>\n       \\<Longrightarrow> open k t (e1 ? e2) = e1 ? e2\n 4. \\<And>e1 e2 k.\n       \\<lbrakk>lc e1; \\<And>k. open k t e1 = e1; lc e2;\n        \\<And>k. open k t e2 = e2\\<rbrakk>\n       \\<Longrightarrow> open k t (e1 \\<cdot> e2) = e1 \\<cdot> e2\n 5. \\<And>T X e k.\n       \\<forall>x.\n          (x, T) |\\<notin>| X \\<longrightarrow>\n          lc (open0_Var (x, T) e) \\<and>\n          (\\<forall>xa.\n              open xa t (open0_Var (x, T) e) =\n              open0_Var (x, T) e) \\<Longrightarrow>\n       open k t (\\<Lambda>\\<langle>T\\<rangle> e) =\n       \\<Lambda>\\<langle>T\\<rangle> e", "case (lc_Abs T X e)"], ["proof (state)\nthis:\n  \\<forall>x.\n     (x, T) |\\<notin>| X \\<longrightarrow>\n     lc (open0_Var (x, T) e) \\<and>\n     (\\<forall>xa. open xa t (open0_Var (x, T) e) = open0_Var (x, T) e)\n\ngoal (5 subgoals):\n 1. \\<And>xT k. open k t \\<langle>xT\\<rangle> = \\<langle>xT\\<rangle>\n 2. \\<And>b k. open k t b = b\n 3. \\<And>e1 e2 k.\n       \\<lbrakk>lc e1; \\<And>k. open k t e1 = e1; lc e2;\n        \\<And>k. open k t e2 = e2\\<rbrakk>\n       \\<Longrightarrow> open k t (e1 ? e2) = e1 ? e2\n 4. \\<And>e1 e2 k.\n       \\<lbrakk>lc e1; \\<And>k. open k t e1 = e1; lc e2;\n        \\<And>k. open k t e2 = e2\\<rbrakk>\n       \\<Longrightarrow> open k t (e1 \\<cdot> e2) = e1 \\<cdot> e2\n 5. \\<And>T X e k.\n       \\<forall>x.\n          (x, T) |\\<notin>| X \\<longrightarrow>\n          lc (open0_Var (x, T) e) \\<and>\n          (\\<forall>xa.\n              open xa t (open0_Var (x, T) e) =\n              open0_Var (x, T) e) \\<Longrightarrow>\n       open k t (\\<Lambda>\\<langle>T\\<rangle> e) =\n       \\<Lambda>\\<langle>T\\<rangle> e", "obtain x where x: \"fresh (x, T) e\" \"(x, T) |\\<notin>| X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>fresh (x, T) e; (x, T) |\\<notin>| X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_fresh[of _ \"fv e |\\<union>| X\"]"], ["proof (prove)\nusing this:\n  \\<exists>x. (x, ?T) |\\<notin>| fv e |\\<union>| X\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>fresh (x, T) e; (x, T) |\\<notin>| X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  fresh (x, T) e\n  (x, T) |\\<notin>| X\n\ngoal (5 subgoals):\n 1. \\<And>xT k. open k t \\<langle>xT\\<rangle> = \\<langle>xT\\<rangle>\n 2. \\<And>b k. open k t b = b\n 3. \\<And>e1 e2 k.\n       \\<lbrakk>lc e1; \\<And>k. open k t e1 = e1; lc e2;\n        \\<And>k. open k t e2 = e2\\<rbrakk>\n       \\<Longrightarrow> open k t (e1 ? e2) = e1 ? e2\n 4. \\<And>e1 e2 k.\n       \\<lbrakk>lc e1; \\<And>k. open k t e1 = e1; lc e2;\n        \\<And>k. open k t e2 = e2\\<rbrakk>\n       \\<Longrightarrow> open k t (e1 \\<cdot> e2) = e1 \\<cdot> e2\n 5. \\<And>T X e k.\n       \\<forall>x.\n          (x, T) |\\<notin>| X \\<longrightarrow>\n          lc (open0_Var (x, T) e) \\<and>\n          (\\<forall>xa.\n              open xa t (open0_Var (x, T) e) =\n              open0_Var (x, T) e) \\<Longrightarrow>\n       open k t (\\<Lambda>\\<langle>T\\<rangle> e) =\n       \\<Lambda>\\<langle>T\\<rangle> e", "with lc_Abs"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     (x, T) |\\<notin>| X \\<longrightarrow>\n     lc (open0_Var (x, T) e) \\<and>\n     (\\<forall>xa. open xa t (open0_Var (x, T) e) = open0_Var (x, T) e)\n  fresh (x, T) e\n  (x, T) |\\<notin>| X", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (x, T) |\\<notin>| X \\<longrightarrow>\n     lc (open0_Var (x, T) e) \\<and>\n     (\\<forall>xa. open xa t (open0_Var (x, T) e) = open0_Var (x, T) e)\n  fresh (x, T) e\n  (x, T) |\\<notin>| X\n\ngoal (1 subgoal):\n 1. open k t (\\<Lambda>\\<langle>T\\<rangle> e) =\n    \\<Lambda>\\<langle>T\\<rangle> e", "by (auto intro: open_open_id dest: spec[of _ x] spec[of _ \"Suc k\"])"], ["proof (state)\nthis:\n  open k t (\\<Lambda>\\<langle>T\\<rangle> e) = \\<Lambda>\\<langle>T\\<rangle> e\n\ngoal (4 subgoals):\n 1. \\<And>xT k. open k t \\<langle>xT\\<rangle> = \\<langle>xT\\<rangle>\n 2. \\<And>b k. open k t b = b\n 3. \\<And>e1 e2 k.\n       \\<lbrakk>lc e1; \\<And>k. open k t e1 = e1; lc e2;\n        \\<And>k. open k t e2 = e2\\<rbrakk>\n       \\<Longrightarrow> open k t (e1 ? e2) = e1 ? e2\n 4. \\<And>e1 e2 k.\n       \\<lbrakk>lc e1; \\<And>k. open k t e1 = e1; lc e2;\n        \\<And>k. open k t e2 = e2\\<rbrakk>\n       \\<Longrightarrow> open k t (e1 \\<cdot> e2) = e1 \\<cdot> e2", "qed auto"], ["", "lemma subst_open: \"lc u \\<Longrightarrow> subst xT u (open i t v) = open i (subst xT u t) (subst xT u v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc u \\<Longrightarrow>\n    subst xT u (open i t v) = open i (subst xT u t) (subst xT u v)", "by (induction v arbitrary: i) (auto intro: lc_open_id[symmetric])"], ["", "lemma subst_open_Var:\n  \"xT \\<noteq> yU \\<Longrightarrow> lc u \\<Longrightarrow> subst xT u (open_Var i yU v) = open_Var i yU (subst xT u v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xT \\<noteq> yU; lc u\\<rbrakk>\n    \\<Longrightarrow> subst xT u (open_Var i yU v) =\n                      open_Var i yU (subst xT u v)", "by (auto simp: subst_open)"], ["", "lemma subst_Apps[simp]:\n  \"subst xT u (f \\<bullet> xs) = subst xT u f \\<bullet> map (subst xT u) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst xT u (f \\<bullet> xs) = subst xT u f \\<bullet> map (subst xT u) xs", "by (induct xs arbitrary: f) auto"], ["", "end"], ["", "context begin"], ["", "private"], ["", "lemma fresh_close_Var_id: \"fresh xT t \\<Longrightarrow> close_Var k xT t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh xT t \\<Longrightarrow> close_Var k xT t = t", "by (induct t arbitrary: k) auto"], ["", "lemma subst_close_Var:\n  \"xT \\<noteq> yU \\<Longrightarrow> fresh yU u \\<Longrightarrow> subst xT u (close_Var i yU t) = close_Var i yU (subst xT u t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xT \\<noteq> yU; fresh yU u\\<rbrakk>\n    \\<Longrightarrow> subst xT u (close_Var i yU t) =\n                      close_Var i yU (subst xT u t)", "by (induct t arbitrary: i) (auto simp: fresh_close_Var_id)"], ["", "end"], ["", "lemma subst_intro: \"fresh xT t \\<Longrightarrow> lc u \\<Longrightarrow> open0 u t = subst xT u (open0_Var xT t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fresh xT t; lc u\\<rbrakk>\n    \\<Longrightarrow> open0 u t = subst xT u (open0_Var xT t)", "by (auto simp: subst_fresh subst_open)"], ["", "lemma lc_subst[simp]: \"lc u \\<Longrightarrow> lc t \\<Longrightarrow> lc (subst xT t u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lc u; lc t\\<rbrakk> \\<Longrightarrow> lc (subst xT t u)", "proof (induct u rule: lc.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xTa. lc t \\<Longrightarrow> lc (subst xT t \\<langle>xTa\\<rangle>)\n 2. \\<And>b. lc t \\<Longrightarrow> lc (subst xT t b)\n 3. \\<And>e1 e2.\n       \\<lbrakk>lc e1; lc t \\<Longrightarrow> lc (subst xT t e1); lc e2;\n        lc t \\<Longrightarrow> lc (subst xT t e2); lc t\\<rbrakk>\n       \\<Longrightarrow> lc (subst xT t (e1 ? e2))\n 4. \\<And>e1 e2.\n       \\<lbrakk>lc e1; lc t \\<Longrightarrow> lc (subst xT t e1); lc e2;\n        lc t \\<Longrightarrow> lc (subst xT t e2); lc t\\<rbrakk>\n       \\<Longrightarrow> lc (subst xT t (e1 \\<cdot> e2))\n 5. \\<And>T X e.\n       \\<lbrakk>\\<forall>x.\n                   (x, T) |\\<notin>| X \\<longrightarrow>\n                   lc (open0_Var (x, T) e) \\<and>\n                   (lc t \\<longrightarrow>\n                    lc (subst xT t (open0_Var (x, T) e)));\n        lc t\\<rbrakk>\n       \\<Longrightarrow> lc (subst xT t (\\<Lambda>\\<langle>T\\<rangle> e))", "case (lc_Abs T X e)"], ["proof (state)\nthis:\n  \\<forall>x.\n     (x, T) |\\<notin>| X \\<longrightarrow>\n     lc (open0_Var (x, T) e) \\<and>\n     (lc t \\<longrightarrow> lc (subst xT t (open0_Var (x, T) e)))\n  lc t\n\ngoal (5 subgoals):\n 1. \\<And>xTa. lc t \\<Longrightarrow> lc (subst xT t \\<langle>xTa\\<rangle>)\n 2. \\<And>b. lc t \\<Longrightarrow> lc (subst xT t b)\n 3. \\<And>e1 e2.\n       \\<lbrakk>lc e1; lc t \\<Longrightarrow> lc (subst xT t e1); lc e2;\n        lc t \\<Longrightarrow> lc (subst xT t e2); lc t\\<rbrakk>\n       \\<Longrightarrow> lc (subst xT t (e1 ? e2))\n 4. \\<And>e1 e2.\n       \\<lbrakk>lc e1; lc t \\<Longrightarrow> lc (subst xT t e1); lc e2;\n        lc t \\<Longrightarrow> lc (subst xT t e2); lc t\\<rbrakk>\n       \\<Longrightarrow> lc (subst xT t (e1 \\<cdot> e2))\n 5. \\<And>T X e.\n       \\<lbrakk>\\<forall>x.\n                   (x, T) |\\<notin>| X \\<longrightarrow>\n                   lc (open0_Var (x, T) e) \\<and>\n                   (lc t \\<longrightarrow>\n                    lc (subst xT t (open0_Var (x, T) e)));\n        lc t\\<rbrakk>\n       \\<Longrightarrow> lc (subst xT t (\\<Lambda>\\<langle>T\\<rangle> e))", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     (x, T) |\\<notin>| X \\<longrightarrow>\n     lc (open0_Var (x, T) e) \\<and>\n     (lc t \\<longrightarrow> lc (subst xT t (open0_Var (x, T) e)))\n  lc t", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (x, T) |\\<notin>| X \\<longrightarrow>\n     lc (open0_Var (x, T) e) \\<and>\n     (lc t \\<longrightarrow> lc (subst xT t (open0_Var (x, T) e)))\n  lc t\n\ngoal (1 subgoal):\n 1. lc (subst xT t (\\<Lambda>\\<langle>T\\<rangle> e))", "by (auto simp: subst_open_Var intro!: lc.lc_Abs[of _ \"fv e |\\<union>| X |\\<union>| {|xT|}\"])"], ["proof (state)\nthis:\n  lc (subst xT t (\\<Lambda>\\<langle>T\\<rangle> e))\n\ngoal (4 subgoals):\n 1. \\<And>xTa. lc t \\<Longrightarrow> lc (subst xT t \\<langle>xTa\\<rangle>)\n 2. \\<And>b. lc t \\<Longrightarrow> lc (subst xT t b)\n 3. \\<And>e1 e2.\n       \\<lbrakk>lc e1; lc t \\<Longrightarrow> lc (subst xT t e1); lc e2;\n        lc t \\<Longrightarrow> lc (subst xT t e2); lc t\\<rbrakk>\n       \\<Longrightarrow> lc (subst xT t (e1 ? e2))\n 4. \\<And>e1 e2.\n       \\<lbrakk>lc e1; lc t \\<Longrightarrow> lc (subst xT t e1); lc e2;\n        lc t \\<Longrightarrow> lc (subst xT t e2); lc t\\<rbrakk>\n       \\<Longrightarrow> lc (subst xT t (e1 \\<cdot> e2))", "qed auto"], ["", "lemma body_subst[simp]: \"body U u \\<Longrightarrow> lc t \\<Longrightarrow> body U (subst xT t u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>body U u; lc t\\<rbrakk> \\<Longrightarrow> body U (subst xT t u)", "proof (subst (asm) body_def, elim conjE exE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>lc t;\n        \\<forall>x.\n           (x, U) |\\<notin>| X \\<longrightarrow>\n           lc (open0_Var (x, U) u)\\<rbrakk>\n       \\<Longrightarrow> body U (subst xT t u)", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>lc t;\n        \\<forall>x.\n           (x, U) |\\<notin>| X \\<longrightarrow>\n           lc (open0_Var (x, U) u)\\<rbrakk>\n       \\<Longrightarrow> body U (subst xT t u)", "assume [simp]: \"lc t\" \"\\<forall>x. (x, U) |\\<notin>| X \\<longrightarrow> lc (open0_Var (x, U) u)\""], ["proof (state)\nthis:\n  lc t\n  \\<forall>x. (x, U) |\\<notin>| X \\<longrightarrow> lc (open0_Var (x, U) u)\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>lc t;\n        \\<forall>x.\n           (x, U) |\\<notin>| X \\<longrightarrow>\n           lc (open0_Var (x, U) u)\\<rbrakk>\n       \\<Longrightarrow> body U (subst xT t u)", "show \"body U (subst xT t u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. body U (subst xT t u)", "proof (unfold body_def, intro exI[of _ \"finsert xT X\"] conjI allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, U) |\\<notin>| finsert xT X \\<Longrightarrow>\n       lc (open0_Var (x, U) (subst xT t u))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, U) |\\<notin>| finsert xT X \\<Longrightarrow>\n       lc (open0_Var (x, U) (subst xT t u))", "assume \"(x, U) |\\<notin>| finsert xT X\""], ["proof (state)\nthis:\n  (x, U) |\\<notin>| finsert xT X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x, U) |\\<notin>| finsert xT X \\<Longrightarrow>\n       lc (open0_Var (x, U) (subst xT t u))", "then"], ["proof (chain)\npicking this:\n  (x, U) |\\<notin>| finsert xT X", "show \"lc (open0_Var (x, U) (subst xT t u))\""], ["proof (prove)\nusing this:\n  (x, U) |\\<notin>| finsert xT X\n\ngoal (1 subgoal):\n 1. lc (open0_Var (x, U) (subst xT t u))", "by (auto simp: subst_open_Var[symmetric])"], ["proof (state)\nthis:\n  lc (open0_Var (x, U) (subst xT t u))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  body U (subst xT t u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lc_open_Var: \"lc u \\<Longrightarrow> lc (open_Var i xT u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc u \\<Longrightarrow> lc (open_Var i xT u)", "by (simp add: lc_open_id)"], ["", "lemma lc_open[simp]: \"body U u \\<Longrightarrow> lc t \\<Longrightarrow> lc (open0 t u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>body U u; lc t\\<rbrakk> \\<Longrightarrow> lc (open0 t u)", "proof (unfold body_def, elim conjE exE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>lc t;\n        \\<forall>x.\n           (x, U) |\\<notin>| X \\<longrightarrow>\n           lc (open0_Var (x, U) u)\\<rbrakk>\n       \\<Longrightarrow> lc (open0 t u)", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>lc t;\n        \\<forall>x.\n           (x, U) |\\<notin>| X \\<longrightarrow>\n           lc (open0_Var (x, U) u)\\<rbrakk>\n       \\<Longrightarrow> lc (open0 t u)", "assume [simp]: \"lc t\" \"\\<forall>x. (x, U) |\\<notin>| X \\<longrightarrow> lc (open0_Var (x, U) u)\""], ["proof (state)\nthis:\n  lc t\n  \\<forall>x. (x, U) |\\<notin>| X \\<longrightarrow> lc (open0_Var (x, U) u)\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>lc t;\n        \\<forall>x.\n           (x, U) |\\<notin>| X \\<longrightarrow>\n           lc (open0_Var (x, U) u)\\<rbrakk>\n       \\<Longrightarrow> lc (open0 t u)", "with ex_fresh[of _ \"fv u |\\<union>| X\"]"], ["proof (chain)\npicking this:\n  \\<exists>x. (x, ?T) |\\<notin>| fv u |\\<union>| X\n  lc t\n  \\<forall>x. (x, U) |\\<notin>| X \\<longrightarrow> lc (open0_Var (x, U) u)", "obtain x where [simp]: \"fresh (x, U) u\" \"(x, U) |\\<notin>| X\""], ["proof (prove)\nusing this:\n  \\<exists>x. (x, ?T) |\\<notin>| fv u |\\<union>| X\n  lc t\n  \\<forall>x. (x, U) |\\<notin>| X \\<longrightarrow> lc (open0_Var (x, U) u)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>fresh (x, U) u; (x, U) |\\<notin>| X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  fresh (x, U) u\n  (x, U) |\\<notin>| X\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>lc t;\n        \\<forall>x.\n           (x, U) |\\<notin>| X \\<longrightarrow>\n           lc (open0_Var (x, U) u)\\<rbrakk>\n       \\<Longrightarrow> lc (open0 t u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lc (open0 t u)", "by (subst subst_intro[of \"(x, U)\"]) auto"], ["proof (state)\nthis:\n  lc (open0 t u)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Typing\\<close>"], ["", "inductive welltyped :: \"expr \\<Rightarrow> type \\<Rightarrow> bool\" (infix \":::\" 60) where\n  welltyped_Var[intro!]: \"\\<langle>(x, T)\\<rangle> ::: T\"\n| welltyped_B[intro!]: \"(b :: bool) ::: \\<B>\"\n| welltyped_Seq[intro!]: \"e1 ::: \\<B> \\<Longrightarrow> e2 ::: \\<B> \\<Longrightarrow> e1 ? e2 ::: \\<B>\"\n| welltyped_App[intro]: \"e1 ::: T \\<rightarrow> U \\<Longrightarrow> e2 ::: T \\<Longrightarrow> e1 \\<cdot> e2 ::: U\"\n| welltyped_Abs[intro]: \"(\\<forall>x. (x, T) |\\<notin>| X \\<longrightarrow> open0_Var (x, T) e ::: U) \\<Longrightarrow> \\<Lambda>\\<langle>T\\<rangle> e ::: T \\<rightarrow> U\""], ["", "inductive_cases welltypedE[elim!]:\n   \"\\<langle>x\\<rangle> ::: T\"\n   \"(i :: idx) ::: T\"\n   \"(b :: bool) ::: T\"\n   \"e1 ? e2 ::: T\"\n   \"e1 \\<cdot> e2 ::: T\"\n   \"\\<Lambda>\\<langle>T\\<rangle> e ::: U\""], ["", "lemma welltyped_unique: \"t ::: T \\<Longrightarrow> t ::: U \\<Longrightarrow> T = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t ::: T; t ::: U\\<rbrakk> \\<Longrightarrow> T = U", "proof (induction t T arbitrary: U rule: welltyped.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x T U. \\<langle>(x, T)\\<rangle> ::: U \\<Longrightarrow> T = U\n 2. \\<And>b U. b ::: U \\<Longrightarrow> \\<B> = U\n 3. \\<And>e1 e2 U.\n       \\<lbrakk>e1 ::: \\<B>; \\<And>U. e1 ::: U \\<Longrightarrow> \\<B> = U;\n        e2 ::: \\<B>; \\<And>U. e2 ::: U \\<Longrightarrow> \\<B> = U;\n        e1 ? e2 ::: U\\<rbrakk>\n       \\<Longrightarrow> \\<B> = U\n 4. \\<And>e1 T U e2 Ua.\n       \\<lbrakk>e1 ::: T \\<rightarrow> U;\n        \\<And>Ua. e1 ::: Ua \\<Longrightarrow> T \\<rightarrow> U = Ua;\n        e2 ::: T; \\<And>U. e2 ::: U \\<Longrightarrow> T = U;\n        e1 \\<cdot> e2 ::: Ua\\<rbrakk>\n       \\<Longrightarrow> U = Ua\n 5. \\<And>T X e U Ua.\n       \\<lbrakk>\\<forall>x.\n                   (x, T) |\\<notin>| X \\<longrightarrow>\n                   open0_Var (x, T) e ::: U \\<and>\n                   (\\<forall>xa.\n                       open0_Var (x, T) e ::: xa \\<longrightarrow> U = xa);\n        \\<Lambda>\\<langle>T\\<rangle> e ::: Ua\\<rbrakk>\n       \\<Longrightarrow> T \\<rightarrow> U = Ua", "case (welltyped_Abs T X t U T')"], ["proof (state)\nthis:\n  \\<forall>x.\n     (x, T) |\\<notin>| X \\<longrightarrow>\n     open0_Var (x, T) t ::: U \\<and>\n     (\\<forall>xa. open0_Var (x, T) t ::: xa \\<longrightarrow> U = xa)\n  \\<Lambda>\\<langle>T\\<rangle> t ::: T'\n\ngoal (5 subgoals):\n 1. \\<And>x T U. \\<langle>(x, T)\\<rangle> ::: U \\<Longrightarrow> T = U\n 2. \\<And>b U. b ::: U \\<Longrightarrow> \\<B> = U\n 3. \\<And>e1 e2 U.\n       \\<lbrakk>e1 ::: \\<B>; \\<And>U. e1 ::: U \\<Longrightarrow> \\<B> = U;\n        e2 ::: \\<B>; \\<And>U. e2 ::: U \\<Longrightarrow> \\<B> = U;\n        e1 ? e2 ::: U\\<rbrakk>\n       \\<Longrightarrow> \\<B> = U\n 4. \\<And>e1 T U e2 Ua.\n       \\<lbrakk>e1 ::: T \\<rightarrow> U;\n        \\<And>Ua. e1 ::: Ua \\<Longrightarrow> T \\<rightarrow> U = Ua;\n        e2 ::: T; \\<And>U. e2 ::: U \\<Longrightarrow> T = U;\n        e1 \\<cdot> e2 ::: Ua\\<rbrakk>\n       \\<Longrightarrow> U = Ua\n 5. \\<And>T X e U Ua.\n       \\<lbrakk>\\<forall>x.\n                   (x, T) |\\<notin>| X \\<longrightarrow>\n                   open0_Var (x, T) e ::: U \\<and>\n                   (\\<forall>xa.\n                       open0_Var (x, T) e ::: xa \\<longrightarrow> U = xa);\n        \\<Lambda>\\<langle>T\\<rangle> e ::: Ua\\<rbrakk>\n       \\<Longrightarrow> T \\<rightarrow> U = Ua", "from welltyped_Abs.prems"], ["proof (chain)\npicking this:\n  \\<Lambda>\\<langle>T\\<rangle> t ::: T'", "show ?case"], ["proof (prove)\nusing this:\n  \\<Lambda>\\<langle>T\\<rangle> t ::: T'\n\ngoal (1 subgoal):\n 1. T \\<rightarrow> U = T'", "proof (elim welltypedE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X U.\n       \\<lbrakk>T' = T \\<rightarrow> U;\n        \\<forall>x.\n           (x, T) |\\<notin>| X \\<longrightarrow>\n           open0_Var (x, T) t ::: U\\<rbrakk>\n       \\<Longrightarrow> T \\<rightarrow> U = T'", "fix Y U'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X U.\n       \\<lbrakk>T' = T \\<rightarrow> U;\n        \\<forall>x.\n           (x, T) |\\<notin>| X \\<longrightarrow>\n           open0_Var (x, T) t ::: U\\<rbrakk>\n       \\<Longrightarrow> T \\<rightarrow> U = T'", "obtain x where [simp]: \"(x, T) |\\<notin>| X\" \"(x, T) |\\<notin>| Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>(x, T) |\\<notin>| X; (x, T) |\\<notin>| Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_fresh[of _ \"X |\\<union>| Y\"]"], ["proof (prove)\nusing this:\n  \\<exists>x. (x, ?T) |\\<notin>| X |\\<union>| Y\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>(x, T) |\\<notin>| X; (x, T) |\\<notin>| Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x, T) |\\<notin>| X\n  (x, T) |\\<notin>| Y\n\ngoal (1 subgoal):\n 1. \\<And>X U.\n       \\<lbrakk>T' = T \\<rightarrow> U;\n        \\<forall>x.\n           (x, T) |\\<notin>| X \\<longrightarrow>\n           open0_Var (x, T) t ::: U\\<rbrakk>\n       \\<Longrightarrow> T \\<rightarrow> U = T'", "assume [simp]: \"T' = T \\<rightarrow> U'\" \"\\<forall>x. (x, T) |\\<notin>| Y \\<longrightarrow> open0_Var (x, T) t ::: U'\""], ["proof (state)\nthis:\n  T' = T \\<rightarrow> U'\n  \\<forall>x.\n     (x, T) |\\<notin>| Y \\<longrightarrow> open0_Var (x, T) t ::: U'\n\ngoal (1 subgoal):\n 1. \\<And>X U.\n       \\<lbrakk>T' = T \\<rightarrow> U;\n        \\<forall>x.\n           (x, T) |\\<notin>| X \\<longrightarrow>\n           open0_Var (x, T) t ::: U\\<rbrakk>\n       \\<Longrightarrow> T \\<rightarrow> U = T'", "show \"T \\<rightarrow> U = T'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<rightarrow> U = T'", "by (auto intro: conjunct2[OF welltyped_Abs.IH[rule_format], rule_format, of x])"], ["proof (state)\nthis:\n  T \\<rightarrow> U = T'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T \\<rightarrow> U = T'\n\ngoal (4 subgoals):\n 1. \\<And>x T U. \\<langle>(x, T)\\<rangle> ::: U \\<Longrightarrow> T = U\n 2. \\<And>b U. b ::: U \\<Longrightarrow> \\<B> = U\n 3. \\<And>e1 e2 U.\n       \\<lbrakk>e1 ::: \\<B>; \\<And>U. e1 ::: U \\<Longrightarrow> \\<B> = U;\n        e2 ::: \\<B>; \\<And>U. e2 ::: U \\<Longrightarrow> \\<B> = U;\n        e1 ? e2 ::: U\\<rbrakk>\n       \\<Longrightarrow> \\<B> = U\n 4. \\<And>e1 T U e2 Ua.\n       \\<lbrakk>e1 ::: T \\<rightarrow> U;\n        \\<And>Ua. e1 ::: Ua \\<Longrightarrow> T \\<rightarrow> U = Ua;\n        e2 ::: T; \\<And>U. e2 ::: U \\<Longrightarrow> T = U;\n        e1 \\<cdot> e2 ::: Ua\\<rbrakk>\n       \\<Longrightarrow> U = Ua", "qed blast+"], ["", "lemma welltyped_lc[simp]: \"t ::: T \\<Longrightarrow> lc t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t ::: T \\<Longrightarrow> lc t", "by (induction t T rule: welltyped.induct) auto"], ["", "lemma welltyped_subst[intro]:\n  \"u ::: U \\<Longrightarrow> t ::: snd xT \\<Longrightarrow> subst xT t u ::: U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u ::: U; t ::: snd xT\\<rbrakk>\n    \\<Longrightarrow> subst xT t u ::: U", "proof (induction u U rule: welltyped.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x T.\n       t ::: snd xT \\<Longrightarrow>\n       subst xT t \\<langle>(x, T)\\<rangle> ::: T\n 2. \\<And>b. t ::: snd xT \\<Longrightarrow> subst xT t b ::: \\<B>\n 3. \\<And>e1 e2.\n       \\<lbrakk>e1 ::: \\<B>;\n        t ::: snd xT \\<Longrightarrow> subst xT t e1 ::: \\<B>; e2 ::: \\<B>;\n        t ::: snd xT \\<Longrightarrow> subst xT t e2 ::: \\<B>;\n        t ::: snd xT\\<rbrakk>\n       \\<Longrightarrow> subst xT t (e1 ? e2) ::: \\<B>\n 4. \\<And>e1 T U e2.\n       \\<lbrakk>e1 ::: T \\<rightarrow> U;\n        t ::: snd xT \\<Longrightarrow> subst xT t e1 ::: T \\<rightarrow> U;\n        e2 ::: T; t ::: snd xT \\<Longrightarrow> subst xT t e2 ::: T;\n        t ::: snd xT\\<rbrakk>\n       \\<Longrightarrow> subst xT t (e1 \\<cdot> e2) ::: U\n 5. \\<And>T X e U.\n       \\<lbrakk>\\<forall>x.\n                   (x, T) |\\<notin>| X \\<longrightarrow>\n                   open0_Var (x, T) e ::: U \\<and>\n                   (t ::: snd xT \\<longrightarrow>\n                    subst xT t (open0_Var (x, T) e) ::: U);\n        t ::: snd xT\\<rbrakk>\n       \\<Longrightarrow> subst xT t (\\<Lambda>\\<langle>T\\<rangle> e) :::\n                         T \\<rightarrow> U", "case (welltyped_Abs T' X u U)"], ["proof (state)\nthis:\n  \\<forall>x.\n     (x, T') |\\<notin>| X \\<longrightarrow>\n     open0_Var (x, T') u ::: U \\<and>\n     (t ::: snd xT \\<longrightarrow> subst xT t (open0_Var (x, T') u) ::: U)\n  t ::: snd xT\n\ngoal (5 subgoals):\n 1. \\<And>x T.\n       t ::: snd xT \\<Longrightarrow>\n       subst xT t \\<langle>(x, T)\\<rangle> ::: T\n 2. \\<And>b. t ::: snd xT \\<Longrightarrow> subst xT t b ::: \\<B>\n 3. \\<And>e1 e2.\n       \\<lbrakk>e1 ::: \\<B>;\n        t ::: snd xT \\<Longrightarrow> subst xT t e1 ::: \\<B>; e2 ::: \\<B>;\n        t ::: snd xT \\<Longrightarrow> subst xT t e2 ::: \\<B>;\n        t ::: snd xT\\<rbrakk>\n       \\<Longrightarrow> subst xT t (e1 ? e2) ::: \\<B>\n 4. \\<And>e1 T U e2.\n       \\<lbrakk>e1 ::: T \\<rightarrow> U;\n        t ::: snd xT \\<Longrightarrow> subst xT t e1 ::: T \\<rightarrow> U;\n        e2 ::: T; t ::: snd xT \\<Longrightarrow> subst xT t e2 ::: T;\n        t ::: snd xT\\<rbrakk>\n       \\<Longrightarrow> subst xT t (e1 \\<cdot> e2) ::: U\n 5. \\<And>T X e U.\n       \\<lbrakk>\\<forall>x.\n                   (x, T) |\\<notin>| X \\<longrightarrow>\n                   open0_Var (x, T) e ::: U \\<and>\n                   (t ::: snd xT \\<longrightarrow>\n                    subst xT t (open0_Var (x, T) e) ::: U);\n        t ::: snd xT\\<rbrakk>\n       \\<Longrightarrow> subst xT t (\\<Lambda>\\<langle>T\\<rangle> e) :::\n                         T \\<rightarrow> U", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     (x, T') |\\<notin>| X \\<longrightarrow>\n     open0_Var (x, T') u ::: U \\<and>\n     (t ::: snd xT \\<longrightarrow> subst xT t (open0_Var (x, T') u) ::: U)\n  t ::: snd xT", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (x, T') |\\<notin>| X \\<longrightarrow>\n     open0_Var (x, T') u ::: U \\<and>\n     (t ::: snd xT \\<longrightarrow> subst xT t (open0_Var (x, T') u) ::: U)\n  t ::: snd xT\n\ngoal (1 subgoal):\n 1. subst xT t (\\<Lambda>\\<langle>T'\\<rangle> u) ::: T' \\<rightarrow> U", "unfolding subst.simps"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (x, T') |\\<notin>| X \\<longrightarrow>\n     open0_Var (x, T') u ::: U \\<and>\n     (t ::: snd xT \\<longrightarrow> subst xT t (open0_Var (x, T') u) ::: U)\n  t ::: snd xT\n\ngoal (1 subgoal):\n 1. \\<Lambda>\\<langle>T'\\<rangle> subst xT t u ::: T' \\<rightarrow> U", "by (intro welltyped.welltyped_Abs[of _ \"finsert xT X\"]) (auto simp: subst_open_Var[symmetric])"], ["proof (state)\nthis:\n  subst xT t (\\<Lambda>\\<langle>T'\\<rangle> u) ::: T' \\<rightarrow> U\n\ngoal (4 subgoals):\n 1. \\<And>x T.\n       t ::: snd xT \\<Longrightarrow>\n       subst xT t \\<langle>(x, T)\\<rangle> ::: T\n 2. \\<And>b. t ::: snd xT \\<Longrightarrow> subst xT t b ::: \\<B>\n 3. \\<And>e1 e2.\n       \\<lbrakk>e1 ::: \\<B>;\n        t ::: snd xT \\<Longrightarrow> subst xT t e1 ::: \\<B>; e2 ::: \\<B>;\n        t ::: snd xT \\<Longrightarrow> subst xT t e2 ::: \\<B>;\n        t ::: snd xT\\<rbrakk>\n       \\<Longrightarrow> subst xT t (e1 ? e2) ::: \\<B>\n 4. \\<And>e1 T U e2.\n       \\<lbrakk>e1 ::: T \\<rightarrow> U;\n        t ::: snd xT \\<Longrightarrow> subst xT t e1 ::: T \\<rightarrow> U;\n        e2 ::: T; t ::: snd xT \\<Longrightarrow> subst xT t e2 ::: T;\n        t ::: snd xT\\<rbrakk>\n       \\<Longrightarrow> subst xT t (e1 \\<cdot> e2) ::: U", "qed auto"], ["", "lemma rename_welltyped: \"u ::: U \\<Longrightarrow> subst (x, T) \\<langle>(y, T)\\<rangle> u ::: U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u ::: U \\<Longrightarrow> subst (x, T) \\<langle>(y, T)\\<rangle> u ::: U", "by (rule welltyped_subst) auto"], ["", "lemma welltyped_Abs_fresh:\n  assumes \"fresh (x, T) u\" \"open0_Var (x, T) u ::: U\"\n  shows \"\\<Lambda>\\<langle>T\\<rangle> u ::: T \\<rightarrow> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>\\<langle>T\\<rangle> u ::: T \\<rightarrow> U", "proof (intro welltyped_Abs[of _ \"fv u\"] allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fresh (x, T) u \\<Longrightarrow> open0_Var (x, T) u ::: U", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fresh (x, T) u \\<Longrightarrow> open0_Var (x, T) u ::: U", "assume \"fresh (y, T) u\""], ["proof (state)\nthis:\n  fresh (y, T) u\n\ngoal (1 subgoal):\n 1. \\<And>x. fresh (x, T) u \\<Longrightarrow> open0_Var (x, T) u ::: U", "with assms(2)"], ["proof (chain)\npicking this:\n  open0_Var (x, T) u ::: U\n  fresh (y, T) u", "have \"subst (x, T) \\<langle>(y, T)\\<rangle> (open0_Var (x, T) u) ::: U\" (is \"?t ::: _\")"], ["proof (prove)\nusing this:\n  open0_Var (x, T) u ::: U\n  fresh (y, T) u\n\ngoal (1 subgoal):\n 1. subst (x, T) \\<langle>(y, T)\\<rangle> (open0_Var (x, T) u) ::: U", "by (auto intro: rename_welltyped)"], ["proof (state)\nthis:\n  subst (x, T) \\<langle>(y, T)\\<rangle> (open0_Var (x, T) u) ::: U\n\ngoal (1 subgoal):\n 1. \\<And>x. fresh (x, T) u \\<Longrightarrow> open0_Var (x, T) u ::: U", "also"], ["proof (state)\nthis:\n  subst (x, T) \\<langle>(y, T)\\<rangle> (open0_Var (x, T) u) ::: U\n\ngoal (1 subgoal):\n 1. \\<And>x. fresh (x, T) u \\<Longrightarrow> open0_Var (x, T) u ::: U", "have \"?t = open0_Var (y, T) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (x, T) \\<langle>(y, T)\\<rangle> (open0_Var (x, T) u) =\n    open0_Var (y, T) u", "by (subst subst_intro[symmetric]) (auto simp: assms(1))"], ["proof (state)\nthis:\n  subst (x, T) \\<langle>(y, T)\\<rangle> (open0_Var (x, T) u) =\n  open0_Var (y, T) u\n\ngoal (1 subgoal):\n 1. \\<And>x. fresh (x, T) u \\<Longrightarrow> open0_Var (x, T) u ::: U", "finally"], ["proof (chain)\npicking this:\n  open0_Var (y, T) u ::: U", "show \"open0_Var (y, T) u ::: U\""], ["proof (prove)\nusing this:\n  open0_Var (y, T) u ::: U\n\ngoal (1 subgoal):\n 1. open0_Var (y, T) u ::: U", "."], ["proof (state)\nthis:\n  open0_Var (y, T) u ::: U\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Apps_alt: \"f \\<bullet> ts ::: T \\<longleftrightarrow>\n  (\\<exists>Ts. f ::: fold (\\<rightarrow>) (rev Ts) T \\<and> list_all2 (:::) ts Ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<bullet> ts ::: T =\n    (\\<exists>Ts.\n        f ::: fold (\\<rightarrow>) (rev Ts) T \\<and> list_all2 (:::) ts Ts)", "proof (induct ts arbitrary: f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       f \\<bullet> [] ::: T =\n       (\\<exists>Ts.\n           f ::: fold (\\<rightarrow>) (rev Ts) T \\<and>\n           list_all2 (:::) [] Ts)\n 2. \\<And>a ts f.\n       (\\<And>f.\n           f \\<bullet> ts ::: T =\n           (\\<exists>Ts.\n               f ::: fold (\\<rightarrow>) (rev Ts) T \\<and>\n               list_all2 (:::) ts Ts)) \\<Longrightarrow>\n       f \\<bullet> (a # ts) ::: T =\n       (\\<exists>Ts.\n           f ::: fold (\\<rightarrow>) (rev Ts) T \\<and>\n           list_all2 (:::) (a # ts) Ts)", "case (Cons t ts)"], ["proof (state)\nthis:\n  ?f \\<bullet> ts ::: T =\n  (\\<exists>Ts.\n      ?f ::: fold (\\<rightarrow>) (rev Ts) T \\<and> list_all2 (:::) ts Ts)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       f \\<bullet> [] ::: T =\n       (\\<exists>Ts.\n           f ::: fold (\\<rightarrow>) (rev Ts) T \\<and>\n           list_all2 (:::) [] Ts)\n 2. \\<And>a ts f.\n       (\\<And>f.\n           f \\<bullet> ts ::: T =\n           (\\<exists>Ts.\n               f ::: fold (\\<rightarrow>) (rev Ts) T \\<and>\n               list_all2 (:::) ts Ts)) \\<Longrightarrow>\n       f \\<bullet> (a # ts) ::: T =\n       (\\<exists>Ts.\n           f ::: fold (\\<rightarrow>) (rev Ts) T \\<and>\n           list_all2 (:::) (a # ts) Ts)", "from Cons(1)[of \"f \\<cdot> t\"]"], ["proof (chain)\npicking this:\n  f \\<cdot> t \\<bullet> ts ::: T =\n  (\\<exists>Ts.\n      f \\<cdot> t ::: fold (\\<rightarrow>) (rev Ts) T \\<and>\n      list_all2 (:::) ts Ts)", "show ?case"], ["proof (prove)\nusing this:\n  f \\<cdot> t \\<bullet> ts ::: T =\n  (\\<exists>Ts.\n      f \\<cdot> t ::: fold (\\<rightarrow>) (rev Ts) T \\<and>\n      list_all2 (:::) ts Ts)\n\ngoal (1 subgoal):\n 1. f \\<bullet> (t # ts) ::: T =\n    (\\<exists>Ts.\n        f ::: fold (\\<rightarrow>) (rev Ts) T \\<and>\n        list_all2 (:::) (t # ts) Ts)", "by (force simp: list_all2_Cons1)"], ["proof (state)\nthis:\n  f \\<bullet> (t # ts) ::: T =\n  (\\<exists>Ts.\n      f ::: fold (\\<rightarrow>) (rev Ts) T \\<and>\n      list_all2 (:::) (t # ts) Ts)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<bullet> [] ::: T =\n       (\\<exists>Ts.\n           f ::: fold (\\<rightarrow>) (rev Ts) T \\<and>\n           list_all2 (:::) [] Ts)", "qed simp"], ["", "subsection \\<open>Definition 10 and Lemma 11 from Schmidt-Schau{\\ss}'s paper\\<close>"], ["", "abbreviation \"closed t \\<equiv> fv t = {||}\""], ["", "primrec constant0 where\n  \"constant0 \\<B> = Var (''bool'', \\<B>)\"\n| \"constant0 (T \\<rightarrow> U) = \\<Lambda>\\<langle>T\\<rangle> (constant0 U)\""], ["", "definition \"constant T = \\<Lambda>\\<langle>\\<B>\\<rangle> (close0_Var (''bool'', \\<B>) (constant0 T))\""], ["", "lemma fv_constant0[simp]: \"fv (constant0 T) = {|(''bool'', \\<B>)|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (constant0 T) = {|(''bool'', \\<B>)|}", "by (induct T) auto"], ["", "lemma closed_constant[simp]: \"closed (constant T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (constant T)", "unfolding constant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\n     (\\<Lambda>\\<langle>\\<B>\\<rangle> close0_Var (''bool'', \\<B>)\n (constant0 T))", "by auto"], ["", "lemma welltyped_constant0[simp]: \"constant0 T ::: T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant0 T ::: T", "by (induct T) (auto simp: lc_open_id)"], ["", "lemma lc_constant0[simp]: \"lc (constant0 T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc (constant0 T)", "using welltyped_constant0 welltyped_lc"], ["proof (prove)\nusing this:\n  constant0 ?T ::: ?T\n  ?t ::: ?T \\<Longrightarrow> lc ?t\n\ngoal (1 subgoal):\n 1. lc (constant0 T)", "by blast"], ["", "lemma welltyped_constant[simp]: \"constant T ::: \\<B> \\<rightarrow> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant T ::: \\<B> \\<rightarrow> T", "unfolding constant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>\\<langle>\\<B>\\<rangle> close0_Var (''bool'', \\<B>)\n                                     (constant0 T) :::\n    \\<B> \\<rightarrow> T", "by (auto intro: welltyped_Abs_fresh[of \"''bool''\"])"], ["", "definition nth_drop where\n  \"nth_drop i xs \\<equiv> take i xs @ drop (Suc i) xs\""], ["", "definition nth_arg (infixl \"!-\" 100) where\n  \"nth_arg T i \\<equiv> nth (dest_fun T) i\""], ["", "abbreviation ar where\n  \"ar T \\<equiv> length (dest_fun T)\""], ["", "lemma size_nth_arg[simp]: \"i < ar T \\<Longrightarrow> size (T !- i) < size T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < ar T \\<Longrightarrow> size (T !- i) < size T", "by (induct T arbitrary: i) (force simp: nth_Cons' nth_arg_def gr0_conv_Suc)+"], ["", "fun \\<pi> :: \"type \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> type\" where\n  \"\\<pi> T i 0 = (if i < ar T then nth_drop i (dest_fun T) \\<rightarrow>\\<rightarrow> \\<B> else \\<B>)\"\n| \"\\<pi> T i (Suc j) = (if i < ar T \\<and> j < ar (T!-i)\n    then \\<pi> (T!-i) j 0 \\<rightarrow>\n      map (\\<pi> (T!-i) j o Suc) [0 ..< ar (T!-i!-j)] \\<rightarrow>\\<rightarrow> \\<pi> T i 0 else \\<B>)\""], ["", "theorem \\<pi>_induct[rotated -2, consumes 2, case_names 0 Suc]:\n  assumes \"\\<And>T i. i < ar T \\<Longrightarrow> P T i 0\"\n    and \"\\<And>T i j. i < ar T \\<Longrightarrow> j < ar (T !- i) \\<Longrightarrow> P (T !- i) j 0 \\<Longrightarrow>\n       (\\<forall>x < ar (T !- i !- j). P (T !- i) j (x + 1)) \\<Longrightarrow> P T i (j + 1)\"\n  shows \"i < ar T \\<Longrightarrow> j \\<le> ar (T !- i) \\<Longrightarrow> P T i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < ar T; j \\<le> ar (T !- i)\\<rbrakk>\n    \\<Longrightarrow> P T i j", "by (induct T i j rule: \\<pi>.induct) (auto intro: assms[simplified])"], ["", "definition \\<epsilon> :: \"type \\<Rightarrow> nat \\<Rightarrow> type\" where\n  \"\\<epsilon> T i = \\<pi> T i 0 \\<rightarrow> map (\\<pi> T i o Suc) [0 ..< ar (T!-i)] \\<rightarrow>\\<rightarrow> T\""], ["", "definition Abss (\"\\<Lambda>[_] _\" [100, 100] 800) where\n  \"\\<Lambda>[xTs] b = fold (\\<lambda>xT t. \\<Lambda>\\<langle>snd xT\\<rangle> close0_Var xT t) (rev xTs) b\""], ["", "definition Seqs (infixr \"??\" 75) where\n  \"ts ?? t = fold (\\<lambda>u t. u ? t) (rev ts) t\""], ["", "definition \"variant k base = base @ replicate k CHR ''*''\""], ["", "lemma variant_inj: \"variant i base = variant j base \\<Longrightarrow> i = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. variant i base = variant j base \\<Longrightarrow> i = j", "unfolding variant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. base @ replicate i CHR ''*'' =\n    base @ replicate j CHR ''*'' \\<Longrightarrow>\n    i = j", "by auto"], ["", "lemma variant_inj2:\n  \"CHR ''*'' \\<notin> set b1 \\<Longrightarrow> CHR ''*'' \\<notin> set b2 \\<Longrightarrow> variant i b1 = variant j b2 \\<Longrightarrow> b1 = b2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CHR ''*'' \\<notin> set b1; CHR ''*'' \\<notin> set b2;\n     variant i b1 = variant j b2\\<rbrakk>\n    \\<Longrightarrow> b1 = b2", "unfolding variant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CHR ''*'' \\<notin> set b1; CHR ''*'' \\<notin> set b2;\n     b1 @ replicate i CHR ''*'' = b2 @ replicate j CHR ''*''\\<rbrakk>\n    \\<Longrightarrow> b1 = b2", "by (auto simp: append_eq_append_conv2)\n    (metis Nil_is_append_conv hd_append2 hd_in_set hd_rev last_ConsR\n     last_snoc replicate_append_same rev_replicate)+"], ["", "fun E :: \"type \\<Rightarrow> nat \\<Rightarrow> expr\" and P :: \"type \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> expr\" where\n  \"E T i = (if i < ar T then (let\n       Ti = T!-i;\n       x = \\<lambda>k. (variant k ''x'', T!-k);\n       xs = map x [0 ..< ar T];\n       xx_var = \\<langle>nth xs i\\<rangle>;\n       x_vars = map (\\<lambda>x. \\<langle>x\\<rangle>) (nth_drop i xs);\n       yy = (''z'', \\<pi> T i 0);\n       yy_var = \\<langle>yy\\<rangle>;\n       y = \\<lambda>j. (variant j ''y'', \\<pi> T i (j + 1));\n       ys = map y [0 ..< ar Ti];\n       e = \\<lambda>j. \\<langle>y j\\<rangle> \\<bullet> (P Ti j 0 \\<cdot> xx_var # map (\\<lambda>k. P Ti j (k + 1) \\<cdot> xx_var) [0 ..< ar (Ti!-j)]);\n       guards = map (\\<lambda>i. xx_var \\<bullet>\n           map (\\<lambda>j. constant (Ti!-j) \\<cdot> (if i = j then e i \\<bullet> x_vars else True)) [0 ..< ar Ti])\n         [0 ..< ar Ti]\n     in \\<Lambda>[(yy # ys @ xs)] (guards ?? (yy_var \\<bullet> x_vars))) else constant (\\<epsilon> T i) \\<cdot> False)\"\n| \"P T i 0 =\n     (if i < ar T then (let\n       f = (''f'', T);\n       f_var = \\<langle>f\\<rangle>;\n       x = \\<lambda>k. (variant k ''x'', T!-k);\n       xs = nth_drop i (map x [0 ..< ar T]);\n       x_vars = insert_nth i (constant (T!-i) \\<cdot> True) (map (\\<lambda>x. \\<langle>x\\<rangle>) xs)\n     in \\<Lambda>[(f # xs)] (f_var \\<bullet> x_vars)) else constant (T \\<rightarrow> \\<pi> T i 0) \\<cdot> False)\"\n| \"P T i (Suc j) = (if i < ar T \\<and> j < ar (T!-i) then (let\n       Ti = T!-i;\n       Tij = Ti!-j;\n       f = (''f'', T);\n       f_var = \\<langle>f\\<rangle>;\n       x = \\<lambda>k. (variant k ''x'', T!-k);\n       xs = nth_drop i (map x [0 ..< ar T]);\n       yy = (''z'', \\<pi> Ti j 0);\n       yy_var = \\<langle>yy\\<rangle>;\n       y = \\<lambda>k. (variant k ''y'', \\<pi> Ti j (k + 1));\n       ys = map y [0 ..< ar Tij];\n       y_vars = yy_var # map (\\<lambda>x. \\<langle>x\\<rangle>) ys;\n       x_vars = insert_nth i (E Ti j \\<bullet> y_vars) (map (\\<lambda>x. \\<langle>x\\<rangle>) xs)\n     in \\<Lambda>[(f # yy # ys @ xs)] (f_var \\<bullet> x_vars)) else constant (T \\<rightarrow> \\<pi> T i (j + 1)) \\<cdot> False)\""], ["", "lemma Abss_Nil[simp]: \"\\<Lambda>[[]] b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>[[]] b = b", "unfolding Abss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>xT t. \\<Lambda>\\<langle>snd xT\\<rangle> close0_Var xT t)\n     (rev []) b =\n    b", "by simp"], ["", "lemma Abss_Cons[simp]: \"\\<Lambda>[(x#xs)] b = \\<Lambda>\\<langle>snd x\\<rangle> (close0_Var x (\\<Lambda>[xs] b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>[(x # xs)] b =\n    \\<Lambda>\\<langle>snd x\\<rangle> close0_Var x (\\<Lambda>[xs] b)", "unfolding Abss_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>xT t. \\<Lambda>\\<langle>snd xT\\<rangle> close0_Var xT t)\n     (rev (x # xs)) b =\n    \\<Lambda>\\<langle>snd x\\<rangle> close0_Var x\n(fold (\\<lambda>xT t. \\<Lambda>\\<langle>snd xT\\<rangle> close0_Var xT t)\n  (rev xs) b)", "by simp"], ["", "lemma welltyped_Abss: \"b ::: U \\<Longrightarrow> T = map snd xTs \\<rightarrow>\\<rightarrow> U \\<Longrightarrow> \\<Lambda>[xTs] b ::: T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b ::: U; T = map snd xTs \\<rightarrow>\\<rightarrow> U\\<rbrakk>\n    \\<Longrightarrow> \\<Lambda>[xTs] b ::: T", "by (hypsubst_thin, induct xTs) (auto simp: mk_fun_def intro!: welltyped_Abs_fresh)"], ["", "lemma welltyped_Apps: \"list_all2 (:::) ts Ts \\<Longrightarrow> f ::: Ts \\<rightarrow>\\<rightarrow> U \\<Longrightarrow> f \\<bullet> ts ::: U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 (:::) ts Ts;\n     f ::: Ts \\<rightarrow>\\<rightarrow> U\\<rbrakk>\n    \\<Longrightarrow> f \\<bullet> ts ::: U", "by (induct ts Ts arbitrary: f rule: list.rel_induct) (auto simp: mk_fun_def)"], ["", "lemma welltyped_open_Var_close_Var[intro!]:\n  \"t ::: T \\<Longrightarrow> open0_Var xT (close0_Var xT t) ::: T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t ::: T \\<Longrightarrow> open0_Var xT (close0_Var xT t) ::: T", "by auto"], ["", "lemma welltyped_Var_iff[simp]:\n  \"\\<langle>(x, T)\\<rangle> ::: U \\<longleftrightarrow> T = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>(x, T)\\<rangle> ::: U = (T = U)", "by auto"], ["", "lemma welltyped_bool_iff[simp]: \"(b :: bool) ::: T \\<longleftrightarrow> T = \\<B>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b ::: T = (T = \\<B>)", "by auto"], ["", "lemma welltyped_constant0_iff[simp]: \"constant0 T ::: U \\<longleftrightarrow> (U = T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant0 T ::: U = (U = T)", "by (induct T arbitrary: U) (auto simp: ex_fresh lc_open_id)"], ["", "lemma welltyped_constant_iff[simp]: \"constant T ::: U \\<longleftrightarrow> (U = \\<B> \\<rightarrow> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constant T ::: U = (U = \\<B> \\<rightarrow> T)", "unfolding constant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>\\<langle>\\<B>\\<rangle> close0_Var (''bool'', \\<B>)\n                                     (constant0 T) :::\n    U =\n    (U = \\<B> \\<rightarrow> T)", "proof (intro iffI, elim welltypedE, hypsubst_thin, unfold type.inject simp_thms)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X U.\n       \\<forall>x.\n          (x, \\<B>) |\\<notin>| X \\<longrightarrow>\n          open0_Var (x, \\<B>)\n           (close0_Var (''bool'', \\<B>) (constant0 T)) :::\n          U \\<Longrightarrow>\n       U = T\n 2. U = \\<B> \\<rightarrow> T \\<Longrightarrow>\n    \\<Lambda>\\<langle>\\<B>\\<rangle> close0_Var (''bool'', \\<B>)\n                                     (constant0 T) :::\n    U", "fix X U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X U.\n       \\<forall>x.\n          (x, \\<B>) |\\<notin>| X \\<longrightarrow>\n          open0_Var (x, \\<B>)\n           (close0_Var (''bool'', \\<B>) (constant0 T)) :::\n          U \\<Longrightarrow>\n       U = T\n 2. U = \\<B> \\<rightarrow> T \\<Longrightarrow>\n    \\<Lambda>\\<langle>\\<B>\\<rangle> close0_Var (''bool'', \\<B>)\n                                     (constant0 T) :::\n    U", "assume \"\\<forall>x. (x, \\<B>) |\\<notin>| X \\<longrightarrow> open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) ::: U\""], ["proof (state)\nthis:\n  \\<forall>x.\n     (x, \\<B>) |\\<notin>| X \\<longrightarrow>\n     open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) ::: U\n\ngoal (2 subgoals):\n 1. \\<And>X U.\n       \\<forall>x.\n          (x, \\<B>) |\\<notin>| X \\<longrightarrow>\n          open0_Var (x, \\<B>)\n           (close0_Var (''bool'', \\<B>) (constant0 T)) :::\n          U \\<Longrightarrow>\n       U = T\n 2. U = \\<B> \\<rightarrow> T \\<Longrightarrow>\n    \\<Lambda>\\<langle>\\<B>\\<rangle> close0_Var (''bool'', \\<B>)\n                                     (constant0 T) :::\n    U", "moreover"], ["proof (state)\nthis:\n  \\<forall>x.\n     (x, \\<B>) |\\<notin>| X \\<longrightarrow>\n     open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) ::: U\n\ngoal (2 subgoals):\n 1. \\<And>X U.\n       \\<forall>x.\n          (x, \\<B>) |\\<notin>| X \\<longrightarrow>\n          open0_Var (x, \\<B>)\n           (close0_Var (''bool'', \\<B>) (constant0 T)) :::\n          U \\<Longrightarrow>\n       U = T\n 2. U = \\<B> \\<rightarrow> T \\<Longrightarrow>\n    \\<Lambda>\\<langle>\\<B>\\<rangle> close0_Var (''bool'', \\<B>)\n                                     (constant0 T) :::\n    U", "obtain x where \"(x, \\<B>) |\\<notin>| X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, \\<B>) |\\<notin>| X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_fresh[of \\<B> X]"], ["proof (prove)\nusing this:\n  \\<exists>x. (x, \\<B>) |\\<notin>| X\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, \\<B>) |\\<notin>| X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (x, \\<B>) |\\<notin>| X\n\ngoal (2 subgoals):\n 1. \\<And>X U.\n       \\<forall>x.\n          (x, \\<B>) |\\<notin>| X \\<longrightarrow>\n          open0_Var (x, \\<B>)\n           (close0_Var (''bool'', \\<B>) (constant0 T)) :::\n          U \\<Longrightarrow>\n       U = T\n 2. U = \\<B> \\<rightarrow> T \\<Longrightarrow>\n    \\<Lambda>\\<langle>\\<B>\\<rangle> close0_Var (''bool'', \\<B>)\n                                     (constant0 T) :::\n    U", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     (x, \\<B>) |\\<notin>| X \\<longrightarrow>\n     open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) ::: U\n  (x, \\<B>) |\\<notin>| X", "have \"open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) ::: U\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (x, \\<B>) |\\<notin>| X \\<longrightarrow>\n     open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) ::: U\n  (x, \\<B>) |\\<notin>| X\n\ngoal (1 subgoal):\n 1. open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) ::: U", "by simp"], ["proof (state)\nthis:\n  open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) ::: U\n\ngoal (2 subgoals):\n 1. \\<And>X U.\n       \\<forall>x.\n          (x, \\<B>) |\\<notin>| X \\<longrightarrow>\n          open0_Var (x, \\<B>)\n           (close0_Var (''bool'', \\<B>) (constant0 T)) :::\n          U \\<Longrightarrow>\n       U = T\n 2. U = \\<B> \\<rightarrow> T \\<Longrightarrow>\n    \\<Lambda>\\<langle>\\<B>\\<rangle> close0_Var (''bool'', \\<B>)\n                                     (constant0 T) :::\n    U", "then"], ["proof (chain)\npicking this:\n  open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) ::: U", "have \"open0_Var (''bool'', \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) ::: U\""], ["proof (prove)\nusing this:\n  open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) ::: U\n\ngoal (1 subgoal):\n 1. open0_Var (''bool'', \\<B>)\n     (close0_Var (''bool'', \\<B>) (constant0 T)) :::\n    U", "using rename_welltyped[of \\<open>open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T))\\<close>\n       U x \\<B> \"''bool''\"]"], ["proof (prove)\nusing this:\n  open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) ::: U\n  open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) :::\n  U \\<Longrightarrow>\n  subst (x, \\<B>) \\<langle>(''bool'', \\<B>)\\<rangle>\n   (open0_Var (x, \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T))) :::\n  U\n\ngoal (1 subgoal):\n 1. open0_Var (''bool'', \\<B>)\n     (close0_Var (''bool'', \\<B>) (constant0 T)) :::\n    U", "by (auto simp: subst_open subst_fresh)"], ["proof (state)\nthis:\n  open0_Var (''bool'', \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) :::\n  U\n\ngoal (2 subgoals):\n 1. \\<And>X U.\n       \\<forall>x.\n          (x, \\<B>) |\\<notin>| X \\<longrightarrow>\n          open0_Var (x, \\<B>)\n           (close0_Var (''bool'', \\<B>) (constant0 T)) :::\n          U \\<Longrightarrow>\n       U = T\n 2. U = \\<B> \\<rightarrow> T \\<Longrightarrow>\n    \\<Lambda>\\<langle>\\<B>\\<rangle> close0_Var (''bool'', \\<B>)\n                                     (constant0 T) :::\n    U", "then"], ["proof (chain)\npicking this:\n  open0_Var (''bool'', \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) :::\n  U", "show \"U = T\""], ["proof (prove)\nusing this:\n  open0_Var (''bool'', \\<B>) (close0_Var (''bool'', \\<B>) (constant0 T)) :::\n  U\n\ngoal (1 subgoal):\n 1. U = T", "by auto"], ["proof (state)\nthis:\n  U = T\n\ngoal (1 subgoal):\n 1. U = \\<B> \\<rightarrow> T \\<Longrightarrow>\n    \\<Lambda>\\<langle>\\<B>\\<rangle> close0_Var (''bool'', \\<B>)\n                                     (constant0 T) :::\n    U", "qed (auto intro!: welltyped_Abs_fresh)"], ["", "lemma welltyped_Seq_iff[simp]: \"e1 ? e2 ::: T \\<longleftrightarrow> (T = \\<B> \\<and> e1 ::: \\<B> \\<and> e2 ::: \\<B>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e1 ? e2 ::: T = (T = \\<B> \\<and> e1 ::: \\<B> \\<and> e2 ::: \\<B>)", "by auto"], ["", "lemma welltyped_Seqs_iff[simp]: \"es ?? e ::: T \\<longleftrightarrow>\n  ((es \\<noteq> [] \\<longrightarrow> T = \\<B>) \\<and> (\\<forall>e \\<in> set es. e ::: \\<B>) \\<and> e ::: T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. es ?? e ::: T =\n    ((es \\<noteq> [] \\<longrightarrow> T = \\<B>) \\<and>\n     (\\<forall>e\\<in>set es. e ::: \\<B>) \\<and> e ::: T)", "by (induct es arbitrary: e) (auto simp: Seqs_def)"], ["", "lemma welltyped_App_iff[simp]: \"f \\<cdot> t ::: U \\<longleftrightarrow> (\\<exists>T. f ::: T \\<rightarrow> U \\<and> t ::: T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot> t ::: U = (\\<exists>T. f ::: T \\<rightarrow> U \\<and> t ::: T)", "by auto"], ["", "lemma welltyped_Apps_iff[simp]: \"f \\<bullet> ts ::: U \\<longleftrightarrow> (\\<exists>Ts. f ::: Ts \\<rightarrow>\\<rightarrow> U \\<and> list_all2 (:::) ts Ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<bullet> ts ::: U =\n    (\\<exists>Ts.\n        f ::: Ts \\<rightarrow>\\<rightarrow> U \\<and> list_all2 (:::) ts Ts)", "by (induct ts arbitrary: f) (auto 0 3 simp: mk_fun_def list_all2_Cons1 intro: exI[of _ \"_ # _\"])"], ["", "lemma eq_mk_fun_iff[simp]: \"T = Ts \\<rightarrow>\\<rightarrow> \\<B> \\<longleftrightarrow> Ts = dest_fun T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (T = Ts \\<rightarrow>\\<rightarrow> \\<B>) = (Ts = dest_fun T)", "by auto"], ["", "lemma map_nth_eq_drop_take[simp]: \"j \\<le> length xs \\<Longrightarrow> map (nth xs) [i ..< j] = drop i (take j xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> length xs \\<Longrightarrow>\n    map ((!) xs) [i..<j] = drop i (take j xs)", "by (induct j) (auto simp: take_Suc_conv_app_nth)"], ["", "lemma dest_fun_\\<pi>_0: \"i < ar T \\<Longrightarrow> dest_fun (\\<pi> T i 0) = nth_drop i (dest_fun T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < ar T \\<Longrightarrow>\n    dest_fun (\\<pi> T i 0) = nth_drop i (dest_fun T)", "by auto"], ["", "lemma welltyped_E: \"E T i ::: \\<epsilon> T i\" and welltyped_P: \"P T i j ::: T \\<rightarrow> \\<pi> T i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E T i ::: \\<epsilon> T i &&& P T i j ::: T \\<rightarrow> \\<pi> T i j", "proof (induct T i and T i j rule: E_P.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>T i.\n       \\<lbrakk>\\<And>x xa xb xaa xab xac xad xae xaf xag.\n                   \\<lbrakk>i < ar T; x = T !- i;\n                    xa = (\\<lambda>k. (variant k ''x'', T !- k));\n                    xb = map xa [0..<ar T]; xaa = \\<langle>xb ! i\\<rangle>;\n                    xab = map Var (nth_drop i xb);\n                    xac = (''z'', \\<pi> T i 0); xad = \\<langle>xac\\<rangle>;\n                    xae =\n                    (\\<lambda>j. (variant j ''y'', \\<pi> T i (j + 1)));\n                    xaf = map xae [0..<ar x]\\<rbrakk>\n                   \\<Longrightarrow> P x xag 0 :::\n                                     x \\<rightarrow> \\<pi> x xag 0;\n        \\<And>x xa xb xaa xab xac xad xae xaf xag xah.\n           \\<lbrakk>i < ar T; x = T !- i;\n            xa = (\\<lambda>k. (variant k ''x'', T !- k));\n            xb = map xa [0..<ar T]; xaa = \\<langle>xb ! i\\<rangle>;\n            xab = map Var (nth_drop i xb); xac = (''z'', \\<pi> T i 0);\n            xad = \\<langle>xac\\<rangle>;\n            xae = (\\<lambda>j. (variant j ''y'', \\<pi> T i (j + 1)));\n            xaf = map xae [0..<ar x];\n            xah \\<in> set [0..<ar (x !- xag)]\\<rbrakk>\n           \\<Longrightarrow> P x xag (xah + 1) :::\n                             x \\<rightarrow> \\<pi> x xag (xah + 1)\\<rbrakk>\n       \\<Longrightarrow> E T i ::: \\<epsilon> T i\n 2. \\<And>T i. P T i 0 ::: T \\<rightarrow> \\<pi> T i 0\n 3. \\<And>T i j.\n       (\\<And>x xa xb xc xd xe xda xdb xdc xdd xaa.\n           \\<lbrakk>i < ar T \\<and> j < ar (T !- i); x = T !- i;\n            xa = x !- j; xb = (''f'', T); xc = \\<langle>xb\\<rangle>;\n            xd = (\\<lambda>k. (variant k ''x'', T !- k));\n            xe = nth_drop i (map xd [0..<ar T]); xda = (''z'', \\<pi> x j 0);\n            xdb = \\<langle>xda\\<rangle>;\n            xdc = (\\<lambda>k. (variant k ''y'', \\<pi> x j (k + 1)));\n            xdd = map xdc [0..<ar xa]; xaa = xdb # map Var xdd\\<rbrakk>\n           \\<Longrightarrow> E x j ::: \\<epsilon> x j) \\<Longrightarrow>\n       P T i (Suc j) ::: T \\<rightarrow> \\<pi> T i (Suc j)", "case (1 T i)"], ["proof (state)\nthis:\n  \\<lbrakk>i < ar T; ?x = T !- i;\n   ?xa = (\\<lambda>k. (variant k ''x'', T !- k)); ?xb = map ?xa [0..<ar T];\n   ?xaa = \\<langle>?xb ! i\\<rangle>; ?xab = map Var (nth_drop i ?xb);\n   ?xac = (''z'', \\<pi> T i 0); ?xad = \\<langle>?xac\\<rangle>;\n   ?xae = (\\<lambda>j. (variant j ''y'', \\<pi> T i (j + 1)));\n   ?xaf = map ?xae [0..<ar ?x]\\<rbrakk>\n  \\<Longrightarrow> P ?x ?xag 0 ::: ?x \\<rightarrow> \\<pi> ?x ?xag 0\n  \\<lbrakk>i < ar T; ?x = T !- i;\n   ?xa = (\\<lambda>k. (variant k ''x'', T !- k)); ?xb = map ?xa [0..<ar T];\n   ?xaa = \\<langle>?xb ! i\\<rangle>; ?xab = map Var (nth_drop i ?xb);\n   ?xac = (''z'', \\<pi> T i 0); ?xad = \\<langle>?xac\\<rangle>;\n   ?xae = (\\<lambda>j. (variant j ''y'', \\<pi> T i (j + 1)));\n   ?xaf = map ?xae [0..<ar ?x];\n   ?xah \\<in> set [0..<ar (?x !- ?xag)]\\<rbrakk>\n  \\<Longrightarrow> P ?x ?xag (?xah + 1) :::\n                    ?x \\<rightarrow> \\<pi> ?x ?xag (?xah + 1)\n\ngoal (3 subgoals):\n 1. \\<And>T i.\n       \\<lbrakk>\\<And>x xa xb xaa xab xac xad xae xaf xag.\n                   \\<lbrakk>i < ar T; x = T !- i;\n                    xa = (\\<lambda>k. (variant k ''x'', T !- k));\n                    xb = map xa [0..<ar T]; xaa = \\<langle>xb ! i\\<rangle>;\n                    xab = map Var (nth_drop i xb);\n                    xac = (''z'', \\<pi> T i 0); xad = \\<langle>xac\\<rangle>;\n                    xae =\n                    (\\<lambda>j. (variant j ''y'', \\<pi> T i (j + 1)));\n                    xaf = map xae [0..<ar x]\\<rbrakk>\n                   \\<Longrightarrow> P x xag 0 :::\n                                     x \\<rightarrow> \\<pi> x xag 0;\n        \\<And>x xa xb xaa xab xac xad xae xaf xag xah.\n           \\<lbrakk>i < ar T; x = T !- i;\n            xa = (\\<lambda>k. (variant k ''x'', T !- k));\n            xb = map xa [0..<ar T]; xaa = \\<langle>xb ! i\\<rangle>;\n            xab = map Var (nth_drop i xb); xac = (''z'', \\<pi> T i 0);\n            xad = \\<langle>xac\\<rangle>;\n            xae = (\\<lambda>j. (variant j ''y'', \\<pi> T i (j + 1)));\n            xaf = map xae [0..<ar x];\n            xah \\<in> set [0..<ar (x !- xag)]\\<rbrakk>\n           \\<Longrightarrow> P x xag (xah + 1) :::\n                             x \\<rightarrow> \\<pi> x xag (xah + 1)\\<rbrakk>\n       \\<Longrightarrow> E T i ::: \\<epsilon> T i\n 2. \\<And>T i. P T i 0 ::: T \\<rightarrow> \\<pi> T i 0\n 3. \\<And>T i j.\n       (\\<And>x xa xb xc xd xe xda xdb xdc xdd xaa.\n           \\<lbrakk>i < ar T \\<and> j < ar (T !- i); x = T !- i;\n            xa = x !- j; xb = (''f'', T); xc = \\<langle>xb\\<rangle>;\n            xd = (\\<lambda>k. (variant k ''x'', T !- k));\n            xe = nth_drop i (map xd [0..<ar T]); xda = (''z'', \\<pi> x j 0);\n            xdb = \\<langle>xda\\<rangle>;\n            xdc = (\\<lambda>k. (variant k ''y'', \\<pi> x j (k + 1)));\n            xdd = map xdc [0..<ar xa]; xaa = xdb # map Var xdd\\<rbrakk>\n           \\<Longrightarrow> E x j ::: \\<epsilon> x j) \\<Longrightarrow>\n       P T i (Suc j) ::: T \\<rightarrow> \\<pi> T i (Suc j)", "note P.simps[simp del] \\<pi>.simps[simp del] \\<epsilon>_def[simp] nth_drop_def[simp] nth_arg_def[simp]"], ["proof (state)\nthis:\n  P ?T ?i 0 =\n  (if ?i < ar ?T\n   then let f = (''f'', ?T); f_var = \\<langle>f\\<rangle>;\n            x = \\<lambda>k. (variant k ''x'', ?T !- k);\n            xs = nth_drop ?i (map x [0..<ar ?T]);\n            x_vars =\n              insert_nth ?i (constant (?T !- ?i) \\<cdot> True) (map Var xs)\n        in \\<Lambda>[(f # xs)] (f_var \\<bullet> x_vars)\n   else constant (?T \\<rightarrow> \\<pi> ?T ?i 0) \\<cdot> False)\n  P ?T ?i (Suc ?j) =\n  (if ?i < ar ?T \\<and> ?j < ar (?T !- ?i)\n   then let Ti = ?T !- ?i; Tij = Ti !- ?j; f = (''f'', ?T);\n            f_var = \\<langle>f\\<rangle>;\n            x = \\<lambda>k. (variant k ''x'', ?T !- k);\n            xs = nth_drop ?i (map x [0..<ar ?T]);\n            yy = (''z'', \\<pi> Ti ?j 0); yy_var = \\<langle>yy\\<rangle>;\n            y = \\<lambda>k. (variant k ''y'', \\<pi> Ti ?j (k + 1));\n            ys = map y [0..<ar Tij]; y_vars = yy_var # map Var ys;\n            x_vars = insert_nth ?i (E Ti ?j \\<bullet> y_vars) (map Var xs)\n        in \\<Lambda>[(f # yy # ys @ xs)] (f_var \\<bullet> x_vars)\n   else constant (?T \\<rightarrow> \\<pi> ?T ?i (?j + 1)) \\<cdot> False)\n  \\<pi> ?T ?i 0 =\n  (if ?i < ar ?T\n   then nth_drop ?i (dest_fun ?T) \\<rightarrow>\\<rightarrow> \\<B> else \\<B>)\n  \\<pi> ?T ?i (Suc ?j) =\n  (if ?i < ar ?T \\<and> ?j < ar (?T !- ?i)\n   then \\<pi> (?T !- ?i) ?j 0 \\<rightarrow>\n        map (\\<pi> (?T !- ?i) ?j \\<circ> Suc)\n         [0..<ar (?T !- ?i !- ?j)] \\<rightarrow>\\<rightarrow>\n        \\<pi> ?T ?i 0\n   else \\<B>)\n  \\<epsilon> ?T ?i =\n  \\<pi> ?T ?i 0 \\<rightarrow>\n  map (\\<pi> ?T ?i \\<circ> Suc)\n   [0..<ar (?T !- ?i)] \\<rightarrow>\\<rightarrow>\n  ?T\n  nth_drop ?i ?xs \\<equiv> take ?i ?xs @ drop (Suc ?i) ?xs\n  ?T !- ?i \\<equiv> dest_fun ?T ! ?i\n\ngoal (3 subgoals):\n 1. \\<And>T i.\n       \\<lbrakk>\\<And>x xa xb xaa xab xac xad xae xaf xag.\n                   \\<lbrakk>i < ar T; x = T !- i;\n                    xa = (\\<lambda>k. (variant k ''x'', T !- k));\n                    xb = map xa [0..<ar T]; xaa = \\<langle>xb ! i\\<rangle>;\n                    xab = map Var (nth_drop i xb);\n                    xac = (''z'', \\<pi> T i 0); xad = \\<langle>xac\\<rangle>;\n                    xae =\n                    (\\<lambda>j. (variant j ''y'', \\<pi> T i (j + 1)));\n                    xaf = map xae [0..<ar x]\\<rbrakk>\n                   \\<Longrightarrow> P x xag 0 :::\n                                     x \\<rightarrow> \\<pi> x xag 0;\n        \\<And>x xa xb xaa xab xac xad xae xaf xag xah.\n           \\<lbrakk>i < ar T; x = T !- i;\n            xa = (\\<lambda>k. (variant k ''x'', T !- k));\n            xb = map xa [0..<ar T]; xaa = \\<langle>xb ! i\\<rangle>;\n            xab = map Var (nth_drop i xb); xac = (''z'', \\<pi> T i 0);\n            xad = \\<langle>xac\\<rangle>;\n            xae = (\\<lambda>j. (variant j ''y'', \\<pi> T i (j + 1)));\n            xaf = map xae [0..<ar x];\n            xah \\<in> set [0..<ar (x !- xag)]\\<rbrakk>\n           \\<Longrightarrow> P x xag (xah + 1) :::\n                             x \\<rightarrow> \\<pi> x xag (xah + 1)\\<rbrakk>\n       \\<Longrightarrow> E T i ::: \\<epsilon> T i\n 2. \\<And>T i. P T i 0 ::: T \\<rightarrow> \\<pi> T i 0\n 3. \\<And>T i j.\n       (\\<And>x xa xb xc xd xe xda xdb xdc xdd xaa.\n           \\<lbrakk>i < ar T \\<and> j < ar (T !- i); x = T !- i;\n            xa = x !- j; xb = (''f'', T); xc = \\<langle>xb\\<rangle>;\n            xd = (\\<lambda>k. (variant k ''x'', T !- k));\n            xe = nth_drop i (map xd [0..<ar T]); xda = (''z'', \\<pi> x j 0);\n            xdb = \\<langle>xda\\<rangle>;\n            xdc = (\\<lambda>k. (variant k ''y'', \\<pi> x j (k + 1)));\n            xdd = map xdc [0..<ar xa]; xaa = xdb # map Var xdd\\<rbrakk>\n           \\<Longrightarrow> E x j ::: \\<epsilon> x j) \\<Longrightarrow>\n       P T i (Suc j) ::: T \\<rightarrow> \\<pi> T i (Suc j)", "from 1(1)[OF _ refl refl refl refl refl refl refl refl refl]\n       1(2)[OF _ refl refl refl refl refl refl refl refl refl]"], ["proof (chain)\npicking this:\n  i < ar T \\<Longrightarrow>\n  P (T !- i) ?xag 0 ::: T !- i \\<rightarrow> \\<pi> (T !- i) ?xag 0\n  \\<lbrakk>i < ar T; ?xah \\<in> set [0..<ar (T !- i !- ?xag)]\\<rbrakk>\n  \\<Longrightarrow> P (T !- i) ?xag (?xah + 1) :::\n                    T !- i \\<rightarrow> \\<pi> (T !- i) ?xag (?xah + 1)", "show ?case"], ["proof (prove)\nusing this:\n  i < ar T \\<Longrightarrow>\n  P (T !- i) ?xag 0 ::: T !- i \\<rightarrow> \\<pi> (T !- i) ?xag 0\n  \\<lbrakk>i < ar T; ?xah \\<in> set [0..<ar (T !- i !- ?xag)]\\<rbrakk>\n  \\<Longrightarrow> P (T !- i) ?xag (?xah + 1) :::\n                    T !- i \\<rightarrow> \\<pi> (T !- i) ?xag (?xah + 1)\n\ngoal (1 subgoal):\n 1. E T i ::: \\<epsilon> T i", "by (auto 0 4 simp: Let_def o_def take_map[symmetric] drop_map[symmetric]\n      list_all2_conv_all_nth nth_append min_def dest_fun_\\<pi>_0 \\<pi>.simps[of T i]\n      intro!: welltyped_Abs_fresh welltyped_Abss[of _ \\<B>])"], ["proof (state)\nthis:\n  E T i ::: \\<epsilon> T i\n\ngoal (2 subgoals):\n 1. \\<And>T i. P T i 0 ::: T \\<rightarrow> \\<pi> T i 0\n 2. \\<And>T i j.\n       (\\<And>x xa xb xc xd xe xda xdb xdc xdd xaa.\n           \\<lbrakk>i < ar T \\<and> j < ar (T !- i); x = T !- i;\n            xa = x !- j; xb = (''f'', T); xc = \\<langle>xb\\<rangle>;\n            xd = (\\<lambda>k. (variant k ''x'', T !- k));\n            xe = nth_drop i (map xd [0..<ar T]); xda = (''z'', \\<pi> x j 0);\n            xdb = \\<langle>xda\\<rangle>;\n            xdc = (\\<lambda>k. (variant k ''y'', \\<pi> x j (k + 1)));\n            xdd = map xdc [0..<ar xa]; xaa = xdb # map Var xdd\\<rbrakk>\n           \\<Longrightarrow> E x j ::: \\<epsilon> x j) \\<Longrightarrow>\n       P T i (Suc j) ::: T \\<rightarrow> \\<pi> T i (Suc j)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T i. P T i 0 ::: T \\<rightarrow> \\<pi> T i 0\n 2. \\<And>T i j.\n       (\\<And>x xa xb xc xd xe xda xdb xdc xdd xaa.\n           \\<lbrakk>i < ar T \\<and> j < ar (T !- i); x = T !- i;\n            xa = x !- j; xb = (''f'', T); xc = \\<langle>xb\\<rangle>;\n            xd = (\\<lambda>k. (variant k ''x'', T !- k));\n            xe = nth_drop i (map xd [0..<ar T]); xda = (''z'', \\<pi> x j 0);\n            xdb = \\<langle>xda\\<rangle>;\n            xdc = (\\<lambda>k. (variant k ''y'', \\<pi> x j (k + 1)));\n            xdd = map xdc [0..<ar xa]; xaa = xdb # map Var xdd\\<rbrakk>\n           \\<Longrightarrow> E x j ::: \\<epsilon> x j) \\<Longrightarrow>\n       P T i (Suc j) ::: T \\<rightarrow> \\<pi> T i (Suc j)", "case (2 T i)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>T i. P T i 0 ::: T \\<rightarrow> \\<pi> T i 0\n 2. \\<And>T i j.\n       (\\<And>x xa xb xc xd xe xda xdb xdc xdd xaa.\n           \\<lbrakk>i < ar T \\<and> j < ar (T !- i); x = T !- i;\n            xa = x !- j; xb = (''f'', T); xc = \\<langle>xb\\<rangle>;\n            xd = (\\<lambda>k. (variant k ''x'', T !- k));\n            xe = nth_drop i (map xd [0..<ar T]); xda = (''z'', \\<pi> x j 0);\n            xdb = \\<langle>xda\\<rangle>;\n            xdc = (\\<lambda>k. (variant k ''y'', \\<pi> x j (k + 1)));\n            xdd = map xdc [0..<ar xa]; xaa = xdb # map Var xdd\\<rbrakk>\n           \\<Longrightarrow> E x j ::: \\<epsilon> x j) \\<Longrightarrow>\n       P T i (Suc j) ::: T \\<rightarrow> \\<pi> T i (Suc j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P T i 0 ::: T \\<rightarrow> \\<pi> T i 0", "by (auto simp: Let_def take_map drop_map o_def list_all2_conv_all_nth nth_append nth_Cons'\n       nth_drop_def nth_arg_def\n      intro!: welltyped_constant welltyped_Abs_fresh welltyped_Abss[of _ \\<B>])"], ["proof (state)\nthis:\n  P T i 0 ::: T \\<rightarrow> \\<pi> T i 0\n\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       (\\<And>x xa xb xc xd xe xda xdb xdc xdd xaa.\n           \\<lbrakk>i < ar T \\<and> j < ar (T !- i); x = T !- i;\n            xa = x !- j; xb = (''f'', T); xc = \\<langle>xb\\<rangle>;\n            xd = (\\<lambda>k. (variant k ''x'', T !- k));\n            xe = nth_drop i (map xd [0..<ar T]); xda = (''z'', \\<pi> x j 0);\n            xdb = \\<langle>xda\\<rangle>;\n            xdc = (\\<lambda>k. (variant k ''y'', \\<pi> x j (k + 1)));\n            xdd = map xdc [0..<ar xa]; xaa = xdb # map Var xdd\\<rbrakk>\n           \\<Longrightarrow> E x j ::: \\<epsilon> x j) \\<Longrightarrow>\n       P T i (Suc j) ::: T \\<rightarrow> \\<pi> T i (Suc j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       (\\<And>x xa xb xc xd xe xda xdb xdc xdd xaa.\n           \\<lbrakk>i < ar T \\<and> j < ar (T !- i); x = T !- i;\n            xa = x !- j; xb = (''f'', T); xc = \\<langle>xb\\<rangle>;\n            xd = (\\<lambda>k. (variant k ''x'', T !- k));\n            xe = nth_drop i (map xd [0..<ar T]); xda = (''z'', \\<pi> x j 0);\n            xdb = \\<langle>xda\\<rangle>;\n            xdc = (\\<lambda>k. (variant k ''y'', \\<pi> x j (k + 1)));\n            xdd = map xdc [0..<ar xa]; xaa = xdb # map Var xdd\\<rbrakk>\n           \\<Longrightarrow> E x j ::: \\<epsilon> x j) \\<Longrightarrow>\n       P T i (Suc j) ::: T \\<rightarrow> \\<pi> T i (Suc j)", "case (3 T i j)"], ["proof (state)\nthis:\n  \\<lbrakk>i < ar T \\<and> j < ar (T !- i); ?x = T !- i; ?xa = ?x !- j;\n   ?xb = (''f'', T); ?xc = \\<langle>?xb\\<rangle>;\n   ?xd = (\\<lambda>k. (variant k ''x'', T !- k));\n   ?xe = nth_drop i (map ?xd [0..<ar T]); ?xda = (''z'', \\<pi> ?x j 0);\n   ?xdb = \\<langle>?xda\\<rangle>;\n   ?xdc = (\\<lambda>k. (variant k ''y'', \\<pi> ?x j (k + 1)));\n   ?xdd = map ?xdc [0..<ar ?xa]; ?xaa = ?xdb # map Var ?xdd\\<rbrakk>\n  \\<Longrightarrow> E ?x j ::: \\<epsilon> ?x j\n\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       (\\<And>x xa xb xc xd xe xda xdb xdc xdd xaa.\n           \\<lbrakk>i < ar T \\<and> j < ar (T !- i); x = T !- i;\n            xa = x !- j; xb = (''f'', T); xc = \\<langle>xb\\<rangle>;\n            xd = (\\<lambda>k. (variant k ''x'', T !- k));\n            xe = nth_drop i (map xd [0..<ar T]); xda = (''z'', \\<pi> x j 0);\n            xdb = \\<langle>xda\\<rangle>;\n            xdc = (\\<lambda>k. (variant k ''y'', \\<pi> x j (k + 1)));\n            xdd = map xdc [0..<ar xa]; xaa = xdb # map Var xdd\\<rbrakk>\n           \\<Longrightarrow> E x j ::: \\<epsilon> x j) \\<Longrightarrow>\n       P T i (Suc j) ::: T \\<rightarrow> \\<pi> T i (Suc j)", "note E.simps[simp del] \\<pi>.simps[simp del] Abss_Cons[simp del] \\<epsilon>_def[simp]\n    nth_drop_def[simp] nth_arg_def[simp]"], ["proof (state)\nthis:\n  E ?T ?i =\n  (if ?i < ar ?T\n   then let Ti = ?T !- ?i; x = \\<lambda>k. (variant k ''x'', ?T !- k);\n            xs = map x [0..<ar ?T]; xx_var = \\<langle>xs ! ?i\\<rangle>;\n            x_vars = map Var (nth_drop ?i xs); yy = (''z'', \\<pi> ?T ?i 0);\n            yy_var = \\<langle>yy\\<rangle>;\n            y = \\<lambda>j. (variant j ''y'', \\<pi> ?T ?i (j + 1));\n            ys = map y [0..<ar Ti];\n            e = \\<lambda>j.\n                   \\<langle>y j\\<rangle> \\<bullet>\n                   (P Ti j 0 \\<cdot> xx_var #\n                    map (\\<lambda>k. P Ti j (k + 1) \\<cdot> xx_var)\n                     [0..<ar (Ti !- j)]);\n            guards =\n              map (\\<lambda>i.\n                      xx_var \\<bullet>\n                      map (\\<lambda>j.\n                              constant (Ti !- j) \\<cdot>\n                              (if i = j then e i \\<bullet> x_vars\n                               else True))\n                       [0..<ar Ti])\n               [0..<ar Ti]\n        in \\<Lambda>[(yy # ys @ xs)] (guards ?? yy_var \\<bullet> x_vars)\n   else constant (\\<epsilon> ?T ?i) \\<cdot> False)\n  \\<pi> ?T ?i 0 =\n  (if ?i < ar ?T\n   then nth_drop ?i (dest_fun ?T) \\<rightarrow>\\<rightarrow> \\<B> else \\<B>)\n  \\<pi> ?T ?i (Suc ?j) =\n  (if ?i < ar ?T \\<and> ?j < ar (?T !- ?i)\n   then \\<pi> (?T !- ?i) ?j 0 \\<rightarrow>\n        map (\\<pi> (?T !- ?i) ?j \\<circ> Suc)\n         [0..<ar (?T !- ?i !- ?j)] \\<rightarrow>\\<rightarrow>\n        \\<pi> ?T ?i 0\n   else \\<B>)\n  \\<Lambda>[(?x # ?xs)] ?b =\n  \\<Lambda>\\<langle>snd ?x\\<rangle> close0_Var ?x (\\<Lambda>[?xs] ?b)\n  \\<epsilon> ?T ?i =\n  \\<pi> ?T ?i 0 \\<rightarrow>\n  map (\\<pi> ?T ?i \\<circ> Suc)\n   [0..<ar (?T !- ?i)] \\<rightarrow>\\<rightarrow>\n  ?T\n  nth_drop ?i ?xs \\<equiv> take ?i ?xs @ drop (Suc ?i) ?xs\n  ?T !- ?i \\<equiv> dest_fun ?T ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       (\\<And>x xa xb xc xd xe xda xdb xdc xdd xaa.\n           \\<lbrakk>i < ar T \\<and> j < ar (T !- i); x = T !- i;\n            xa = x !- j; xb = (''f'', T); xc = \\<langle>xb\\<rangle>;\n            xd = (\\<lambda>k. (variant k ''x'', T !- k));\n            xe = nth_drop i (map xd [0..<ar T]); xda = (''z'', \\<pi> x j 0);\n            xdb = \\<langle>xda\\<rangle>;\n            xdc = (\\<lambda>k. (variant k ''y'', \\<pi> x j (k + 1)));\n            xdd = map xdc [0..<ar xa]; xaa = xdb # map Var xdd\\<rbrakk>\n           \\<Longrightarrow> E x j ::: \\<epsilon> x j) \\<Longrightarrow>\n       P T i (Suc j) ::: T \\<rightarrow> \\<pi> T i (Suc j)", "from 3(1)[OF _ refl refl refl refl refl refl refl refl refl refl refl]"], ["proof (chain)\npicking this:\n  i < ar T \\<and> j < ar (T !- i) \\<Longrightarrow>\n  E (T !- i) j ::: \\<epsilon> (T !- i) j", "show ?case"], ["proof (prove)\nusing this:\n  i < ar T \\<and> j < ar (T !- i) \\<Longrightarrow>\n  E (T !- i) j ::: \\<epsilon> (T !- i) j\n\ngoal (1 subgoal):\n 1. P T i (Suc j) ::: T \\<rightarrow> \\<pi> T i (Suc j)", "by (auto 0 3 simp: Let_def o_def take_map[symmetric] drop_map[symmetric]\n      list_all2_conv_all_nth nth_append nth_Cons' min_def \\<pi>.simps[of T i]\n      intro!: welltyped_Abs_fresh welltyped_Abss[of _ \\<B>])"], ["proof (state)\nthis:\n  P T i (Suc j) ::: T \\<rightarrow> \\<pi> T i (Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<delta>_gt_0[simp]: \"T \\<noteq> \\<B> \\<Longrightarrow> HMSet {#} < \\<delta> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<noteq> \\<B> \\<Longrightarrow> HMSet {#} < \\<delta> T", "by (cases T) auto"], ["", "lemma mset_nth_drop_less: \"i < length xs \\<Longrightarrow> mset (nth_drop i xs) < mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow> mset (nth_drop i xs) < mset xs", "by (induct xs arbitrary: i) (auto simp: take_Cons' nth_drop_def gr0_conv_Suc)"], ["", "lemma map_nth_drop: \"i < length xs \\<Longrightarrow> map f (nth_drop i xs) = nth_drop i (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length xs \\<Longrightarrow>\n    map f (nth_drop i xs) = nth_drop i (map f xs)", "by (induct xs arbitrary: i) (auto simp: take_Cons' nth_drop_def gr0_conv_Suc)"], ["", "lemma empty_less_mset: \"{#} < mset xs \\<longleftrightarrow> xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#} < mset xs) = (xs \\<noteq> [])", "by auto"], ["", "lemma dest_fun_alt: \"dest_fun T = map (\\<lambda>i. T !- i) [0..<ar T]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dest_fun T = map ((!-) T) [0..<ar T]", "unfolding list_eq_iff_nth_eq nth_arg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ar T = length (map ((!) (dest_fun T)) [0..<ar T]) \\<and>\n    (\\<forall>i<ar T.\n        dest_fun T ! i = map ((!) (dest_fun T)) [0..<ar T] ! i)", "by auto"], ["", "context notes \\<pi>.simps[simp del] notes One_nat_def[simp del] begin"], ["", "lemma \\<delta>_\\<pi>:\n  assumes \"i < ar T\" \"j \\<le> ar (T !- i)\"\n  shows \"\\<delta> (\\<pi> T i j) < \\<delta> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> (\\<pi> T i j) < \\<delta> T", "using assms"], ["proof (prove)\nusing this:\n  i < ar T\n  j \\<le> ar (T !- i)\n\ngoal (1 subgoal):\n 1. \\<delta> (\\<pi> T i j) < \\<delta> T", "proof (induct T i j rule: \\<pi>_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T i.\n       i < ar T \\<Longrightarrow> \\<delta> (\\<pi> T i 0) < \\<delta> T\n 2. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "fix T i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T i.\n       i < ar T \\<Longrightarrow> \\<delta> (\\<pi> T i 0) < \\<delta> T\n 2. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "assume \"i < ar T\""], ["proof (state)\nthis:\n  i < ar T\n\ngoal (2 subgoals):\n 1. \\<And>T i.\n       i < ar T \\<Longrightarrow> \\<delta> (\\<pi> T i 0) < \\<delta> T\n 2. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "then"], ["proof (chain)\npicking this:\n  i < ar T", "show \"\\<delta> (\\<pi> T i 0) < \\<delta> T\""], ["proof (prove)\nusing this:\n  i < ar T\n\ngoal (1 subgoal):\n 1. \\<delta> (\\<pi> T i 0) < \\<delta> T", "by (subst (2) mk_fun_dest_fun[symmetric, of T], unfold \\<delta>_mk_fun)\n      (auto simp: \\<delta>_mk_fun mset_map[symmetric] take_map[symmetric] drop_map[symmetric] \\<pi>.simps\n        mset_nth_drop_less map_nth_drop simp del: mset_map)"], ["proof (state)\nthis:\n  \\<delta> (\\<pi> T i 0) < \\<delta> T\n\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "fix T i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "let ?Ti = \"T !- i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "assume [rule_format, simp]: \"i < ar T\" \"j < ar ?Ti\" \"\\<delta> (\\<pi> ?Ti j 0) < \\<delta> ?Ti\"\n    \"\\<forall>k < ar (?Ti !- j). \\<delta> (\\<pi> ?Ti j (k + 1)) < \\<delta> ?Ti\""], ["proof (state)\nthis:\n  i < ar T\n  j < ar (T !- i)\n  \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i)\n  ?k < ar (T !- i !- j) \\<Longrightarrow>\n  \\<delta> (\\<pi> (T !- i) j (?k + 1)) < \\<delta> (T !- i)\n\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "define X and Y and M where\n    [simp]: \"X = {#\\<delta> ?Ti#}\" and\n    [simp]: \"Y = {#\\<delta> (\\<pi> ?Ti j 0)#} + {#\\<delta> (\\<pi> ?Ti j (k + 1)). k \\<in># mset [0 ..< ar (?Ti !- j)]#}\" and\n    [simp]: \"M \\<equiv> {# \\<delta> z. z \\<in># mset (nth_drop i (dest_fun T))#}\""], ["proof (state)\nthis:\n  X = {#\\<delta> (T !- i)#}\n  Y =\n  {#\\<delta> (\\<pi> (T !- i) j 0)#} +\n  {#\\<delta> (\\<pi> (T !- i) j (k + 1))\n  . k \\<in># mset [0..<ar (T !- i !- j)]#}\n  M \\<equiv> image_mset \\<delta> (mset (nth_drop i (dest_fun T)))\n\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "have \"\\<delta> (\\<pi> T i (j + 1)) = HMSet (Y + M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> (\\<pi> T i (j + 1)) = HMSet (Y + M)", "by (auto simp: One_nat_def \\<pi>.simps \\<delta>_mk_fun)"], ["proof (state)\nthis:\n  \\<delta> (\\<pi> T i (j + 1)) = HMSet (Y + M)\n\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "also"], ["proof (state)\nthis:\n  \\<delta> (\\<pi> T i (j + 1)) = HMSet (Y + M)\n\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "have \"Y + M < X + M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y + M < X + M", "unfolding less_multiset\\<^sub>D\\<^sub>M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Xa Ya.\n       Xa \\<noteq> {#} \\<and>\n       Xa \\<subseteq># X + M \\<and>\n       Y + M = X + M - Xa + Ya \\<and>\n       (\\<forall>k.\n           k \\<in># Ya \\<longrightarrow>\n           (\\<exists>a. a \\<in># Xa \\<and> k < a))", "by (rule exI[of _ \"X\"], rule exI[of _ \"Y\"]) auto"], ["proof (state)\nthis:\n  Y + M < X + M\n\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "also"], ["proof (state)\nthis:\n  Y + M < X + M\n\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "have \"HMSet (X + M) = \\<delta> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMSet (X + M) = \\<delta> T", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. HMSet (X + image_mset \\<delta> (mset (nth_drop i (dest_fun T)))) =\n    \\<delta> T", "by (subst (2) mk_fun_dest_fun[symmetric, of T], subst (2) id_take_nth_drop[of i \"dest_fun T\"])\n      (auto simp: \\<delta>_mk_fun nth_arg_def nth_drop_def)"], ["proof (state)\nthis:\n  HMSet (X + M) = \\<delta> T\n\ngoal (1 subgoal):\n 1. \\<And>T i j.\n       \\<lbrakk>i < ar T; j < ar (T !- i);\n        \\<delta> (\\<pi> (T !- i) j 0) < \\<delta> (T !- i);\n        \\<forall>x<ar (T !- i !- j).\n           \\<delta> (\\<pi> (T !- i) j (x + 1)) < \\<delta> (T !- i)\\<rbrakk>\n       \\<Longrightarrow> \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y. x < y \\<Longrightarrow> HMSet x < HMSet y) \\<Longrightarrow>\n  \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "show \"\\<delta> (\\<pi> T i (j + 1)) < \\<delta> T\""], ["proof (prove)\nusing this:\n  (\\<And>x y. x < y \\<Longrightarrow> HMSet x < HMSet y) \\<Longrightarrow>\n  \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T\n\ngoal (1 subgoal):\n 1. \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T", "by simp"], ["proof (state)\nthis:\n  \\<delta> (\\<pi> T i (j + 1)) < \\<delta> T\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}