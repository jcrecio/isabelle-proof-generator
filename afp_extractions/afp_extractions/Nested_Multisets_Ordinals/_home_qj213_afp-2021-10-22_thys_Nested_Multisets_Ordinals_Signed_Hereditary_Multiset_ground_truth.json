{"file_name": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals/Signed_Hereditary_Multiset.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals", "problem_names": ["lemmas ZHMSet_inverse[simp] = ZHMSet_inverse[OF UNIV_I]", "lemmas ZHMSet_inject[simp] = ZHMSet_inject[OF UNIV_I UNIV_I]", "lemmas ZHMSet_less[simp] = less_zhmultiset.abs_eq", "lemmas ZHMSet_le[simp] = less_eq_zhmultiset.abs_eq", "lemmas zhmsetmset_less[simp] = less_zhmultiset.rep_eq[symmetric]", "lemmas zhmsetmset_le[simp] = less_eq_zhmultiset.rep_eq[symmetric]", "lemma zhmset_of_inject[simp]: \"zhmset_of M = zhmset_of N \\<longleftrightarrow> M = N\"", "lemma zhmset_of_less: \"zhmset_of M < zhmset_of N \\<longleftrightarrow> M < N\"", "lemma zhmset_of_le: \"zhmset_of M \\<le> zhmset_of N \\<longleftrightarrow> M \\<le> N\"", "lemmas ZHMSet_plus = plus_zhmultiset.abs_eq[symmetric]", "lemmas ZHMSet_diff = minus_zhmultiset.abs_eq[symmetric]", "lemmas zhmsetmset_plus = plus_zhmultiset.rep_eq", "lemmas zhmsetmset_diff = minus_zhmultiset.rep_eq", "lemma zhmset_of_plus: \"zhmset_of (A + B) = zhmset_of A + zhmset_of B\"", "lemma hmsetmset_0[simp]: \"hmsetmset 0 = {#}\"", "lemma zhmset_of_0: \"zhmset_of 0 = 0\"", "lemma hmset_pos_plus:\n  \"hmset_pos (A + B) = (hmset_pos A - hmset_neg B) + (hmset_pos B - hmset_neg A)\"", "lemma hmset_neg_plus:\n  \"hmset_neg (A + B) = (hmset_neg A - hmset_pos B) + (hmset_neg B - hmset_pos A)\"", "lemma zhmset_pos_neg_partition: \"M = zhmset_of (hmset_pos M) - zhmset_of (hmset_neg M)\"", "lemma zhmset_pos_as_neg: \"zhmset_of (hmset_pos M) = zhmset_of (hmset_neg M) + M\"", "lemma zhmset_neg_as_pos: \"zhmset_of (hmset_neg M) = zhmset_of (hmset_pos M) - M\"", "lemma hmset_pos_neg_dual:\n  \"hmset_pos a + hmset_pos b + (hmset_neg a - hmset_pos b) + (hmset_neg b - hmset_pos a) =\n   hmset_neg a + hmset_neg b + (hmset_pos a - hmset_neg b) + (hmset_pos b - hmset_neg a)\"", "lemma zhmset_of_sum_list: \"zhmset_of (sum_list Ms) = sum_list (map zhmset_of Ms)\"", "lemma less_hmset_zhmsetE:\n  assumes m_lt_n: \"M < N\"\n  obtains A B C where \"M = zhmset_of A + C\" and \"N = zhmset_of B + C\" and \"A < B\"", "lemma less_eq_hmset_zhmsetE:\n  assumes m_le_n: \"M \\<le> N\"\n  obtains A B C where \"M = zhmset_of A + C\" and \"N = zhmset_of B + C\" and \"A \\<le> B\"", "lemmas ZHMSet_uminus = uminus_zhmultiset.abs_eq[symmetric]", "lemmas zhmsetmset_uminus = uminus_zhmultiset.rep_eq"], "translations": [["", "lemmas ZHMSet_inverse[simp] = ZHMSet_inverse[OF UNIV_I]"], ["", "lemmas ZHMSet_inject[simp] = ZHMSet_inject[OF UNIV_I UNIV_I]"], ["", "declare\n  zhmsetmset_inverse [simp]\n  zhmsetmset_inject [simp]"], ["", "setup_lifting type_definition_zhmultiset"], ["", "subsection \\<open>Multiset Order\\<close>"], ["", "instantiation zhmultiset :: linorder\nbegin"], ["", "lift_definition less_zhmultiset :: \"zhmultiset \\<Rightarrow> zhmultiset \\<Rightarrow> bool\" is \"(<)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_eq_zhmultiset :: \"zhmultiset \\<Rightarrow> zhmultiset \\<Rightarrow> bool\" is \"(\\<le>)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(zhmultiset, linorder_class)", "by (intro_classes; transfer) auto"], ["", "end"], ["", "lemmas ZHMSet_less[simp] = less_zhmultiset.abs_eq"], ["", "lemmas ZHMSet_le[simp] = less_eq_zhmultiset.abs_eq"], ["", "lemmas zhmsetmset_less[simp] = less_zhmultiset.rep_eq[symmetric]"], ["", "lemmas zhmsetmset_le[simp] = less_eq_zhmultiset.rep_eq[symmetric]"], ["", "subsection \\<open>Embedding and Projections of Syntactic Ordinals\\<close>"], ["", "abbreviation zhmset_of :: \"hmultiset \\<Rightarrow> zhmultiset\" where\n  \"zhmset_of M \\<equiv> ZHMSet (zmset_of (hmsetmset M))\""], ["", "lemma zhmset_of_inject[simp]: \"zhmset_of M = zhmset_of N \\<longleftrightarrow> M = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zhmset_of M = zhmset_of N) = (M = N)", "by simp"], ["", "lemma zhmset_of_less: \"zhmset_of M < zhmset_of N \\<longleftrightarrow> M < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zhmset_of M < zhmset_of N) = (M < N)", "by (simp add: zmset_of_less)"], ["", "lemma zhmset_of_le: \"zhmset_of M \\<le> zhmset_of N \\<longleftrightarrow> M \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zhmset_of M \\<le> zhmset_of N) = (M \\<le> N)", "by (simp add: zmset_of_le)"], ["", "abbreviation hmset_pos :: \"zhmultiset \\<Rightarrow> hmultiset\" where\n  \"hmset_pos M \\<equiv> HMSet (mset_pos (zhmsetmset M))\""], ["", "abbreviation hmset_neg :: \"zhmultiset \\<Rightarrow> hmultiset\" where\n  \"hmset_neg M \\<equiv> HMSet (mset_neg (zhmsetmset M))\""], ["", "subsection \\<open>Disjoint Union and Difference\\<close>"], ["", "instantiation zhmultiset :: cancel_comm_monoid_add\nbegin"], ["", "lift_definition zero_zhmultiset :: zhmultiset is \"{#}\\<^sub>z\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition plus_zhmultiset :: \"zhmultiset \\<Rightarrow> zhmultiset \\<Rightarrow> zhmultiset\" is\n  \"\\<lambda>A B. A + B\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition minus_zhmultiset :: \"zhmultiset \\<Rightarrow> zhmultiset \\<Rightarrow> zhmultiset\" is\n  \"\\<lambda>A B. A - B\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas ZHMSet_plus = plus_zhmultiset.abs_eq[symmetric]"], ["", "lemmas ZHMSet_diff = minus_zhmultiset.abs_eq[symmetric]"], ["", "lemmas zhmsetmset_plus = plus_zhmultiset.rep_eq"], ["", "lemmas zhmsetmset_diff = minus_zhmultiset.rep_eq"], ["", "lemma zhmset_of_plus: \"zhmset_of (A + B) = zhmset_of A + zhmset_of B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of (A + B) = zhmset_of A + zhmset_of B", "by (simp add: hmsetmset_plus ZHMSet_plus zmset_of_plus)"], ["", "lemma hmsetmset_0[simp]: \"hmsetmset 0 = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset 0 = {#}", "by (rule hmultiset.inject[THEN iffD1]) (simp add: zero_hmultiset_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(zhmultiset, cancel_comm_monoid_add_class)", "by (intro_classes; transfer) (auto intro: mult.assoc add.commute)"], ["", "end"], ["", "lemma zhmset_of_0: \"zhmset_of 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of 0 = 0", "by (simp add: zero_zhmultiset_def)"], ["", "lemma hmset_pos_plus:\n  \"hmset_pos (A + B) = (hmset_pos A - hmset_neg B) + (hmset_pos B - hmset_neg A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmset_pos (A + B) =\n    hmset_pos A - hmset_neg B + (hmset_pos B - hmset_neg A)", "by (simp add: HMSet_diff HMSet_plus zhmsetmset_plus)"], ["", "lemma hmset_neg_plus:\n  \"hmset_neg (A + B) = (hmset_neg A - hmset_pos B) + (hmset_neg B - hmset_pos A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmset_neg (A + B) =\n    hmset_neg A - hmset_pos B + (hmset_neg B - hmset_pos A)", "by (simp add: HMSet_diff HMSet_plus zhmsetmset_plus)"], ["", "lemma zhmset_pos_neg_partition: \"M = zhmset_of (hmset_pos M) - zhmset_of (hmset_neg M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = zhmset_of (hmset_pos M) - zhmset_of (hmset_neg M)", "by (cases M, simp add: ZHMSet_diff[symmetric], rule mset_pos_neg_partition)"], ["", "lemma zhmset_pos_as_neg: \"zhmset_of (hmset_pos M) = zhmset_of (hmset_neg M) + M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of (hmset_pos M) = zhmset_of (hmset_neg M) + M", "using mset_pos_as_neg zhmsetmset_plus zhmsetmset_inject"], ["proof (prove)\nusing this:\n  zmset_of (mset_pos ?M) = zmset_of (mset_neg ?M) + ?M\n  zhmsetmset (?x + ?xa) = zhmsetmset ?x + zhmsetmset ?xa\n  (zhmsetmset ?x = zhmsetmset ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. zhmset_of (hmset_pos M) = zhmset_of (hmset_neg M) + M", "by fastforce"], ["", "lemma zhmset_neg_as_pos: \"zhmset_of (hmset_neg M) = zhmset_of (hmset_pos M) - M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of (hmset_neg M) = zhmset_of (hmset_pos M) - M", "using zhmsetmset_diff mset_neg_as_pos zhmsetmset_inject"], ["proof (prove)\nusing this:\n  zhmsetmset (?x - ?xa) = zhmsetmset ?x - zhmsetmset ?xa\n  zmset_of (mset_neg ?M) = zmset_of (mset_pos ?M) - ?M\n  (zhmsetmset ?x = zhmsetmset ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. zhmset_of (hmset_neg M) = zhmset_of (hmset_pos M) - M", "by fastforce"], ["", "lemma hmset_pos_neg_dual:\n  \"hmset_pos a + hmset_pos b + (hmset_neg a - hmset_pos b) + (hmset_neg b - hmset_pos a) =\n   hmset_neg a + hmset_neg b + (hmset_pos a - hmset_neg b) + (hmset_pos b - hmset_neg a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmset_pos a + hmset_pos b + (hmset_neg a - hmset_pos b) +\n    (hmset_neg b - hmset_pos a) =\n    hmset_neg a + hmset_neg b + (hmset_pos a - hmset_neg b) +\n    (hmset_pos b - hmset_neg a)", "by (simp add: HMSet_plus[symmetric] HMSet_diff[symmetric]) (rule mset_pos_neg_dual)"], ["", "lemma zhmset_of_sum_list: \"zhmset_of (sum_list Ms) = sum_list (map zhmset_of Ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of (sum_list Ms) = sum_list (map zhmset_of Ms)", "by (induct Ms) (auto simp: zero_zhmultiset_def zhmset_of_plus)"], ["", "lemma less_hmset_zhmsetE:\n  assumes m_lt_n: \"M < N\"\n  obtains A B C where \"M = zhmset_of A + C\" and \"N = zhmset_of B + C\" and \"A < B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A C B.\n        \\<lbrakk>M = zhmset_of A + C; N = zhmset_of B + C; A < B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule less_mset_zmsetE[OF m_lt_n[folded zhmsetmset_less]])\n    (metis hmsetmset_less hmultiset.sel ZHMSet_plus zhmsetmset_inverse)"], ["", "lemma less_eq_hmset_zhmsetE:\n  assumes m_le_n: \"M \\<le> N\"\n  obtains A B C where \"M = zhmset_of A + C\" and \"N = zhmset_of B + C\" and \"A \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A C B.\n        \\<lbrakk>M = zhmset_of A + C; N = zhmset_of B + C;\n         A \\<le> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule less_eq_mset_zmsetE[OF m_le_n[folded zhmsetmset_le]])\n    (metis hmsetmset_le hmultiset.sel ZHMSet_plus zhmsetmset_inverse)"], ["", "instantiation zhmultiset :: ab_group_add\nbegin"], ["", "lift_definition uminus_zhmultiset :: \"zhmultiset \\<Rightarrow> zhmultiset\" is \"\\<lambda>A. - A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas ZHMSet_uminus = uminus_zhmultiset.abs_eq[symmetric]"], ["", "lemmas zhmsetmset_uminus = uminus_zhmultiset.rep_eq"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(zhmultiset, ab_group_add_class)", "by (intro_classes; transfer; simp)"], ["", "end"], ["", "subsection \\<open>Infimum and Supremum\\<close>"], ["", "instance zhmultiset :: ordered_cancel_comm_monoid_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(zhmultiset, ordered_cancel_comm_monoid_add_class)", "by (intro_classes; transfer) (auto simp: add_left_mono)"], ["", "instance zhmultiset :: ordered_ab_group_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(zhmultiset, ordered_ab_group_add_class)", "by (intro_classes; transfer; simp)"], ["", "instantiation zhmultiset :: distrib_lattice\nbegin"], ["", "definition inf_zhmultiset :: \"zhmultiset \\<Rightarrow> zhmultiset \\<Rightarrow> zhmultiset\" where\n  \"inf_zhmultiset A B = (if A < B then A else B)\""], ["", "definition sup_zhmultiset :: \"zhmultiset \\<Rightarrow> zhmultiset \\<Rightarrow> zhmultiset\" where\n  \"sup_zhmultiset A B = (if B > A then B else A)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(zhmultiset, distrib_lattice_class)", "by intro_classes (auto simp: inf_zhmultiset_def sup_zhmultiset_def)"], ["", "end"], ["", "end"]]}