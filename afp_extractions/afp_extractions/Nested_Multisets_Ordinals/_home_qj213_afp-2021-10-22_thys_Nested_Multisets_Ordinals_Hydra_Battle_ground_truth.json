{"file_name": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals/Hydra_Battle.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals", "problem_names": ["lemma encode_f: \"encode (f n y x) = of_nat n * \\<omega>^(encode y) + encode x\""], "translations": [["", "lemma encode_f: \"encode (f n y x) = of_nat n * \\<omega>^(encode y) + encode x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode (f n y x) = of_nat n * \\<omega>^ (encode y) + encode x", "unfolding of_nat_times_\\<omega>_exp"], ["proof (prove)\ngoal (1 subgoal):\n 1. encode (f n y x) = HMSet (replicate_mset n (encode y)) + encode x", "by (induct n) (auto simp: HMSet_plus[symmetric])"], ["", "function d :: \"nat \\<Rightarrow> lisp \\<Rightarrow> lisp\" where\n  \"d n x =\n   (if car x = Nil then cdr x\n    else if car (car x) = Nil then f n (cdr (car x)) (cdr x)\n    else Cons (d n (car x)) (cdr x))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>n xa. x = (n, xa) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>n x na xa.\n       (n, x) = (na, xa) \\<Longrightarrow>\n       (if car x = Nil then cdr x\n        else if car (car x) = Nil then f n (cdr (car x)) (cdr x)\n             else Cons (d_sumC (n, car x)) (cdr x)) =\n       (if car xa = Nil then cdr xa\n        else if car (car xa) = Nil then f na (cdr (car xa)) (cdr xa)\n             else Cons (d_sumC (na, car xa)) (cdr xa))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All d_dom", "by (relation \"measure (\\<lambda>(_, x). size x)\", rule wf_measure, rename_tac n x, case_tac x, auto)"], ["", "declare d.simps[simp del]"], ["", "function h :: \"nat \\<Rightarrow> lisp \\<Rightarrow> lisp\" where\n  \"h n x = (if x = Nil then Nil else h (n + 1) (d n x))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>n xa. x = (n, xa) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>n x na xa.\n       (n, x) = (na, xa) \\<Longrightarrow>\n       (if x = Nil then Nil else h_sumC (n + 1, d n x)) =\n       (if xa = Nil then Nil else h_sumC (na + 1, d na xa))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All h_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All h_dom", "let ?R = \"inv_image {(m, n). m < n} (\\<lambda>(n, x). encode x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. All h_dom", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. All h_dom", "proof (relation ?R)"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (inv_image {(m, n). m < n} (\\<lambda>(n, x). encode x))\n 2. \\<And>n x.\n       x \\<noteq> Nil \\<Longrightarrow>\n       ((n + 1, d n x), n, x)\n       \\<in> inv_image {(m, n). m < n} (\\<lambda>(n, x). encode x)", "show \"wf ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image {(m, n). m < n} (\\<lambda>(n, x). encode x))", "by (rule wf_inv_image) (rule wf)"], ["proof (state)\nthis:\n  wf (inv_image {(m, n). m < n} (\\<lambda>(n, x). encode x))\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       x \\<noteq> Nil \\<Longrightarrow>\n       ((n + 1, d n x), n, x)\n       \\<in> inv_image {(m, n). m < n} (\\<lambda>(n, x). encode x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       x \\<noteq> Nil \\<Longrightarrow>\n       ((n + 1, d n x), n, x)\n       \\<in> inv_image {(m, n). m < n} (\\<lambda>(n, x). encode x)", "fix n x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       x \\<noteq> Nil \\<Longrightarrow>\n       ((n + 1, d n x), n, x)\n       \\<in> inv_image {(m, n). m < n} (\\<lambda>(n, x). encode x)", "assume x_cons: \"x \\<noteq> Nil\""], ["proof (state)\nthis:\n  x \\<noteq> Nil\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       x \\<noteq> Nil \\<Longrightarrow>\n       ((n + 1, d n x), n, x)\n       \\<in> inv_image {(m, n). m < n} (\\<lambda>(n, x). encode x)", "thus \"((n + 1, d n x), n, x) \\<in> ?R\""], ["proof (prove)\nusing this:\n  x \\<noteq> Nil\n\ngoal (1 subgoal):\n 1. ((n + 1, d n x), n, x)\n    \\<in> inv_image {(m, n). m < n} (\\<lambda>(n, x). encode x)", "unfolding inv_image_def mem_Collect_eq prod.case"], ["proof (prove)\nusing this:\n  x \\<noteq> Nil\n\ngoal (1 subgoal):\n 1. encode (d n x) < encode x", "proof (induct x)"], ["proof (state)\ngoal (2 subgoals):\n 1. Nil \\<noteq> Nil \\<Longrightarrow> encode (d n Nil) < encode Nil\n 2. \\<And>x1 x2.\n       \\<lbrakk>x1 \\<noteq> Nil \\<Longrightarrow>\n                encode (d n x1) < encode x1;\n        x2 \\<noteq> Nil \\<Longrightarrow> encode (d n x2) < encode x2;\n        Cons x1 x2 \\<noteq> Nil\\<rbrakk>\n       \\<Longrightarrow> encode (d n (Cons x1 x2)) < encode (Cons x1 x2)", "case (Cons l r)"], ["proof (state)\nthis:\n  l \\<noteq> Nil \\<Longrightarrow> encode (d n l) < encode l\n  r \\<noteq> Nil \\<Longrightarrow> encode (d n r) < encode r\n  Cons l r \\<noteq> Nil\n\ngoal (2 subgoals):\n 1. Nil \\<noteq> Nil \\<Longrightarrow> encode (d n Nil) < encode Nil\n 2. \\<And>x1 x2.\n       \\<lbrakk>x1 \\<noteq> Nil \\<Longrightarrow>\n                encode (d n x1) < encode x1;\n        x2 \\<noteq> Nil \\<Longrightarrow> encode (d n x2) < encode x2;\n        Cons x1 x2 \\<noteq> Nil\\<rbrakk>\n       \\<Longrightarrow> encode (d n (Cons x1 x2)) < encode (Cons x1 x2)", "note ihl = this(1)"], ["proof (state)\nthis:\n  l \\<noteq> Nil \\<Longrightarrow> encode (d n l) < encode l\n\ngoal (2 subgoals):\n 1. Nil \\<noteq> Nil \\<Longrightarrow> encode (d n Nil) < encode Nil\n 2. \\<And>x1 x2.\n       \\<lbrakk>x1 \\<noteq> Nil \\<Longrightarrow>\n                encode (d n x1) < encode x1;\n        x2 \\<noteq> Nil \\<Longrightarrow> encode (d n x2) < encode x2;\n        Cons x1 x2 \\<noteq> Nil\\<rbrakk>\n       \\<Longrightarrow> encode (d n (Cons x1 x2)) < encode (Cons x1 x2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. encode (d n (Cons l r)) < encode (Cons l r)", "proof (subst d.simps, simp, intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>car l = Nil; l \\<noteq> Nil\\<rbrakk>\n    \\<Longrightarrow> encode (f n (cdr l) r)\n                      < \\<omega>^ (encode l) + encode r\n 2. \\<lbrakk>car l \\<noteq> Nil; l \\<noteq> Nil\\<rbrakk>\n    \\<Longrightarrow> encode (d n l) < encode l", "assume l_cons: \"l \\<noteq> Nil\""], ["proof (state)\nthis:\n  l \\<noteq> Nil\n\ngoal (2 subgoals):\n 1. \\<lbrakk>car l = Nil; l \\<noteq> Nil\\<rbrakk>\n    \\<Longrightarrow> encode (f n (cdr l) r)\n                      < \\<omega>^ (encode l) + encode r\n 2. \\<lbrakk>car l \\<noteq> Nil; l \\<noteq> Nil\\<rbrakk>\n    \\<Longrightarrow> encode (d n l) < encode l", "{"], ["proof (state)\nthis:\n  l \\<noteq> Nil\n\ngoal (2 subgoals):\n 1. \\<lbrakk>car l = Nil; l \\<noteq> Nil\\<rbrakk>\n    \\<Longrightarrow> encode (f n (cdr l) r)\n                      < \\<omega>^ (encode l) + encode r\n 2. \\<lbrakk>car l \\<noteq> Nil; l \\<noteq> Nil\\<rbrakk>\n    \\<Longrightarrow> encode (d n l) < encode l", "assume \"car l = Nil\""], ["proof (state)\nthis:\n  car l = Nil\n\ngoal (2 subgoals):\n 1. \\<lbrakk>car l = Nil; l \\<noteq> Nil\\<rbrakk>\n    \\<Longrightarrow> encode (f n (cdr l) r)\n                      < \\<omega>^ (encode l) + encode r\n 2. \\<lbrakk>car l \\<noteq> Nil; l \\<noteq> Nil\\<rbrakk>\n    \\<Longrightarrow> encode (d n l) < encode l", "show \"encode (f n (cdr l) r) < \\<omega>^(encode l) + encode r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode (f n (cdr l) r) < \\<omega>^ (encode l) + encode r", "using l_cons"], ["proof (prove)\nusing this:\n  l \\<noteq> Nil\n\ngoal (1 subgoal):\n 1. encode (f n (cdr l) r) < \\<omega>^ (encode l) + encode r", "by (cases l) (auto simp: encode_f[unfolded of_nat_times_\\<omega>_exp])"], ["proof (state)\nthis:\n  encode (f n (cdr l) r) < \\<omega>^ (encode l) + encode r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>car l \\<noteq> Nil; l \\<noteq> Nil\\<rbrakk>\n    \\<Longrightarrow> encode (d n l) < encode l", "}"], ["proof (state)\nthis:\n  car l = Nil \\<Longrightarrow>\n  encode (f n (cdr l) r) < \\<omega>^ (encode l) + encode r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>car l \\<noteq> Nil; l \\<noteq> Nil\\<rbrakk>\n    \\<Longrightarrow> encode (d n l) < encode l", "{"], ["proof (state)\nthis:\n  car l = Nil \\<Longrightarrow>\n  encode (f n (cdr l) r) < \\<omega>^ (encode l) + encode r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>car l \\<noteq> Nil; l \\<noteq> Nil\\<rbrakk>\n    \\<Longrightarrow> encode (d n l) < encode l", "show \"encode (d n l) < encode l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode (d n l) < encode l", "by (rule ihl[OF l_cons])"], ["proof (state)\nthis:\n  encode (d n l) < encode l\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  encode (d n l) < encode l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  encode (d n (Cons l r)) < encode (Cons l r)\n\ngoal (1 subgoal):\n 1. Nil \\<noteq> Nil \\<Longrightarrow> encode (d n Nil) < encode Nil", "qed simp"], ["proof (state)\nthis:\n  ((n + 1, d n x), n, x)\n  \\<in> inv_image {(m, n). m < n} (\\<lambda>(n, x). encode x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  All h_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "declare h.simps[simp del]"], ["", "end"]]}