{"file_name": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals/Syntactic_Ordinal.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Nested_Multisets_Ordinals", "problem_names": ["lemma hmsetmset_times:\n  \"hmsetmset (m * n) = image_mset (case_prod (+)) (hmsetmset m \\<times># hmsetmset n)\"", "lemma empty_times_left_hmset[simp]: \"HMSet {#} * M = 0\"", "lemma empty_times_right_hmset[simp]: \"M * HMSet {#} = 0\"", "lemma singleton_times_left_hmset[simp]: \"\\<omega>^M * N = HMSet (image_mset ((+) M) (hmsetmset N))\"", "lemma singleton_times_right_hmset[simp]: \"N * \\<omega>^M = HMSet (image_mset ((+) M) (hmsetmset N))\"", "lemma plus_nmultiset_mono:\n  assumes less: \"(X, Y) < (X', Y')\" and no_elem: \"no_elem X\" \"no_elem Y\" \"no_elem X'\" \"no_elem Y'\"\n  shows \"plus_nmultiset X Y < plus_nmultiset X' Y'\"", "lemma plus_hmultiset_transfer[transfer_rule]:\n  \"(rel_fun pcr_hmultiset (rel_fun pcr_hmultiset pcr_hmultiset)) plus_nmultiset (+)\"", "lemma Times_mset_monoL:\n  assumes less: \"M < N\" and Z_nemp: \"Z \\<noteq> {#}\"\n  shows \"M \\<times># Z < N \\<times># Z\"", "lemma times_hmultiset_monoL:\n  \"a < b \\<Longrightarrow> 0 < c \\<Longrightarrow> a * c < b * c\" for a b c :: hmultiset", "lemma mult_le_mono1_hmset: \"i \\<le> j \\<Longrightarrow> i * k \\<le> j * k\" for i j k :: hmultiset", "lemma mult_le_mono2_hmset: \"i \\<le> j \\<Longrightarrow> k * i \\<le> k * j\" for i j k :: hmultiset", "lemma mult_le_mono_hmset: \"i \\<le> j \\<Longrightarrow> k \\<le> l \\<Longrightarrow> i * k \\<le> j * l\" for i j k l :: hmultiset", "lemma less_iff_add1_le_hmset: \"m < n \\<longleftrightarrow> m + 1 \\<le> n\" for m n :: hmultiset", "lemma zero_less_iff_1_le_hmset: \"0 < n \\<longleftrightarrow> 1 \\<le> n\" for n :: hmultiset", "lemma less_add_1_iff_le_hmset: \"m < n + 1 \\<longleftrightarrow> m \\<le> n\" for m n :: hmultiset", "lemma lt_1_iff_eq_0_hmset: \"M < 1 \\<longleftrightarrow> M = 0\" for M :: hmultiset", "lemma zero_less_mult_iff_hmset[simp]: \"0 < m * n \\<longleftrightarrow> 0 < m \\<and> 0 < n\" for m n :: hmultiset", "lemma one_le_mult_iff_hmset[simp]: \"1 \\<le> m * n \\<longleftrightarrow> 1 \\<le> m \\<and> 1 \\<le> n\" for m n :: hmultiset", "lemma mult_less_cancel2_hmset[simp]: \"m * k < n * k \\<longleftrightarrow> 0 < k \\<and> m < n\" for k m n :: hmultiset", "lemma mult_less_cancel1_hmset[simp]: \"k * m < k * n \\<longleftrightarrow> 0 < k \\<and> m < n\" for k m n :: hmultiset", "lemma mult_le_cancel1_hmset[simp]: \"k * m \\<le> k * n \\<longleftrightarrow> (0 < k \\<longrightarrow> m \\<le> n)\" for k m n :: hmultiset", "lemma mult_le_cancel2_hmset[simp]: \"m * k \\<le> n * k \\<longleftrightarrow> (0 < k \\<longrightarrow> m \\<le> n)\" for k m n :: hmultiset", "lemma mult_le_cancel_left1_hmset: \"y > 0 \\<Longrightarrow> x \\<le> x * y\" for x y :: hmultiset", "lemma mult_le_cancel_left2_hmset: \"y \\<le> 1 \\<Longrightarrow> x * y \\<le> x\" for x y :: hmultiset", "lemma mult_le_cancel_right1_hmset: \"y > 0 \\<Longrightarrow> x \\<le> y * x\" for x y :: hmultiset", "lemma mult_le_cancel_right2_hmset: \"y \\<le> 1 \\<Longrightarrow> y * x \\<le> x\" for x y :: hmultiset", "lemma le_square_hmset: \"m \\<le> m * m\" for m :: hmultiset", "lemma le_cube_hmset: \"m \\<le> m * (m * m)\" for m :: hmultiset", "lemma\n  less_imp_minus_plus_hmset: \"m < n \\<Longrightarrow> k < k - m + n\" and\n  le_imp_minus_plus_hmset: \"m \\<le> n \\<Longrightarrow> k \\<le> k - m + n\" for k m n :: hmultiset", "lemma gt_0_lt_mult_gt_1_hmset:\n  fixes m n :: hmultiset\n  assumes \"m > 0\" and \"n > 1\"\n  shows \"m < m * n\"", "lemma of_nat_hmset: \"of_nat n = HMSet (replicate_mset n 0)\"", "lemma of_nat_inject_hmset[simp]: \"(of_nat m :: hmultiset) = of_nat n \\<longleftrightarrow> m = n\"", "lemma of_nat_minus_hmset: \"of_nat (m - n) = (of_nat m :: hmultiset) - of_nat n\"", "lemma plus_of_nat_plus_of_nat_hmset:\n  \"k + of_nat m + of_nat n = k + of_nat (m + n)\" for k :: hmultiset", "lemma plus_of_nat_minus_of_nat_hmset:\n  fixes k :: hmultiset\n  assumes \"n \\<le> m\"\n  shows \"k + of_nat m - of_nat n = k + of_nat (m - n)\"", "lemma of_nat_lt_\\<omega>[simp]: \"of_nat n < \\<omega>\"", "lemma of_nat_ne_\\<omega>[simp]: \"of_nat n \\<noteq> \\<omega>\"", "lemma of_nat_less_hmset[simp]: \"(of_nat M :: hmultiset) < of_nat N \\<longleftrightarrow> M < N\"", "lemma of_nat_le_hmset[simp]: \"(of_nat M :: hmultiset) \\<le> of_nat N \\<longleftrightarrow> M \\<le> N\"", "lemma of_nat_times_\\<omega>_exp: \"of_nat n * \\<omega>^m = HMSet (replicate_mset n m)\"", "lemma \\<omega>_exp_times_of_nat: \"\\<omega>^m * of_nat n = HMSet (replicate_mset n m)\"", "lemma hmset_of_enat_0[simp]: \"hmset_of_enat 0 = 0\"", "lemma hmset_of_enat_1[simp]: \"hmset_of_enat 1 = 1\"", "lemma hmset_of_enat_of_nat[simp]: \"hmset_of_enat (of_nat n) = of_nat n\"", "lemma hmset_of_enat_numeral[simp]: \"hmset_of_enat (numeral n) = numeral n\"", "lemma hmset_of_enat_le_\\<omega>[simp]: \"hmset_of_enat n \\<le> \\<omega>\"", "lemma hmset_of_enat_eq_\\<omega>_iff[simp]: \"hmset_of_enat n = \\<omega> \\<longleftrightarrow> n = \\<infinity>\"", "lemma head_\\<omega>_subseteq: \"hmsetmset (head_\\<omega> M) \\<subseteq># hmsetmset M\"", "lemma head_\\<omega>_eq_0_iff[simp]: \"head_\\<omega> m = 0 \\<longleftrightarrow> m = 0\"", "lemma head_\\<omega>_0[simp]: \"head_\\<omega> 0 = 0\"", "lemma head_\\<omega>_1[simp]: \"head_\\<omega> 1 = 1\"", "lemma head_\\<omega>_of_nat[simp]: \"head_\\<omega> (of_nat n) = (if n = 0 then 0 else 1)\"", "lemma head_\\<omega>_numeral[simp]: \"head_\\<omega> (numeral n) = 1\"", "lemma head_\\<omega>_\\<omega>[simp]: \"head_\\<omega> \\<omega> = \\<omega>\"", "lemma le_imp_head_\\<omega>_le:\n  assumes m_le_n: \"m \\<le> n\"\n  shows \"head_\\<omega> m \\<le> head_\\<omega> n\"", "lemma head_\\<omega>_lt_imp_lt: \"head_\\<omega> m < head_\\<omega> n \\<Longrightarrow> m < n\"", "lemma head_\\<omega>_plus[simp]: \"head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)\"", "lemma head_\\<omega>_times[simp]: \"head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\"", "lemma zero_lt_\\<omega>[simp]: \"0 < \\<omega>\"", "lemma one_lt_\\<omega>[simp]: \"1 < \\<omega>\"", "lemma numeral_lt_\\<omega>[simp]: \"numeral n < \\<omega>\"", "lemma one_le_\\<omega>[simp]: \"1 \\<le> \\<omega>\"", "lemma of_nat_le_\\<omega>[simp]: \"of_nat n \\<le> \\<omega>\"", "lemma numeral_le_\\<omega>[simp]: \"numeral n \\<le> \\<omega>\"", "lemma not_\\<omega>_lt_1[simp]: \"\\<not> \\<omega> < 1\"", "lemma not_\\<omega>_lt_of_nat[simp]: \"\\<not> \\<omega> < of_nat n\"", "lemma not_\\<omega>_lt_numeral[simp]: \"\\<not> \\<omega> < numeral n\"", "lemma not_\\<omega>_le_1[simp]: \"\\<not> \\<omega> \\<le> 1\"", "lemma not_\\<omega>_le_of_nat[simp]: \"\\<not> \\<omega> \\<le> of_nat n\"", "lemma not_\\<omega>_le_numeral[simp]: \"\\<not> \\<omega> \\<le> numeral n\"", "lemma zero_ne_\\<omega>[simp]: \"0 \\<noteq> \\<omega>\"", "lemma one_ne_\\<omega>[simp]: \"1 \\<noteq> \\<omega>\"", "lemma numeral_ne_\\<omega>[simp]: \"numeral n \\<noteq> \\<omega>\"", "lemma\n  \\<omega>_ne_0[simp]: \"\\<omega> \\<noteq> 0\" and\n  \\<omega>_ne_1[simp]: \"\\<omega> \\<noteq> 1\" and\n  \\<omega>_ne_of_nat[simp]: \"\\<omega> \\<noteq> of_nat m\" and\n  \\<omega>_ne_numeral[simp]: \"\\<omega> \\<noteq> numeral n\"", "lemma\n  hmset_of_enat_inject[simp]: \"hmset_of_enat m = hmset_of_enat n \\<longleftrightarrow> m = n\" and\n  hmset_of_enat_less[simp]: \"hmset_of_enat m < hmset_of_enat n \\<longleftrightarrow> m < n\" and\n  hmset_of_enat_le[simp]: \"hmset_of_enat m \\<le> hmset_of_enat n \\<longleftrightarrow> m \\<le> n\"", "lemma lt_\\<omega>_imp_ex_of_nat:\n  assumes M_lt_\\<omega>: \"M < \\<omega>\"\n  shows \"\\<exists>n. M = of_nat n\"", "lemma le_\\<omega>_imp_ex_hmset_of_enat:\n  assumes M_le_\\<omega>: \"M \\<le> \\<omega>\"\n  shows \"\\<exists>n. M = hmset_of_enat n\"", "lemma lt_\\<omega>_lt_\\<omega>_imp_times_lt_\\<omega>: \"M < \\<omega> \\<Longrightarrow> N < \\<omega> \\<Longrightarrow> M * N < \\<omega>\"", "lemma times_\\<omega>_minus_of_nat[simp]: \"m * \\<omega> - of_nat n = m * \\<omega>\"", "lemma times_\\<omega>_minus_numeral[simp]: \"m * \\<omega> - numeral n = m * \\<omega>\"", "lemma \\<omega>_minus_of_nat[simp]: \"\\<omega> - of_nat n = \\<omega>\"", "lemma \\<omega>_minus_1[simp]: \"\\<omega> - 1 = \\<omega>\"", "lemma \\<omega>_minus_numeral[simp]: \"\\<omega> - numeral n = \\<omega>\"", "lemma hmset_of_enat_minus_enat[simp]: \"hmset_of_enat (m - enat n) = hmset_of_enat m - of_nat n\"", "lemma of_nat_lt_hmset_of_enat_iff: \"of_nat m < hmset_of_enat n \\<longleftrightarrow> enat m < n\"", "lemma of_nat_le_hmset_of_enat_iff: \"of_nat m \\<le> hmset_of_enat n \\<longleftrightarrow> enat m \\<le> n\"", "lemma hmset_of_enat_lt_iff_ne_infinity: \"hmset_of_enat x < \\<omega> \\<longleftrightarrow> x \\<noteq> \\<infinity>\"", "lemma minus_diff_sym_hmset: \"m - (m - n) = n - (n - m)\" for m n :: hmultiset", "lemma diff_plus_sym_hmset: \"(c - b) + b = (b - c) + c\" for b c :: hmultiset", "lemma times_diff_plus_sym_hmset: \"a * (c - b) + a * b = a * (b - c) + a * c\" for a b c :: hmultiset", "lemma times_of_nat_minus_left:\n  \"(of_nat m - of_nat n) * l = of_nat m * l - of_nat n * l\" for l :: hmultiset", "lemma times_of_nat_minus_right:\n  \"l * (of_nat m - of_nat n) = l * of_nat m - l * of_nat n\" for l :: hmultiset", "lemma lt_\\<omega>_imp_times_minus_left: \"m < \\<omega> \\<Longrightarrow> n < \\<omega> \\<Longrightarrow> (m - n) * l = m * l - n * l\"", "lemma lt_\\<omega>_imp_times_minus_right: \"m < \\<omega> \\<Longrightarrow> n < \\<omega> \\<Longrightarrow> l * (m - n) = l * m - l * n\"", "lemma hmset_pair_decompose:\n  \"\\<exists>k n1 n2. m1 = k + n1 \\<and> m2 = k + n2 \\<and> (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or> n1 = 0 \\<and> n2 = 0)\"", "lemma hmset_pair_decompose_less:\n  assumes m1_lt_m2: \"m1 < m2\"\n  shows \"\\<exists>k n1 n2. m1 = k + n1 \\<and> m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2\"", "lemma hmset_pair_decompose_less_eq:\n  assumes \"m1 \\<le> m2\"\n  shows \"\\<exists>k n1 n2. m1 = k + n1 \\<and> m2 = k + n2 \\<and> (head_\\<omega> n1 < head_\\<omega> n2 \\<or> n1 = 0 \\<and> n2 = 0)\"", "lemma mono_cross_mult_less_hmset:\n  fixes Aa A Ba B :: hmultiset\n  assumes A_lt: \"A < Aa\" and B_lt: \"B < Ba\"\n  shows \"A * Ba + B * Aa < A * B + Aa * Ba\"", "lemma triple_cross_mult_hmset:\n  \"An * (Bn * Cn + Bp * Cp - (Bn * Cp + Cn * Bp))\n   + (Cn * (An * Bp + Bn * Ap - (An * Bn + Ap * Bp))\n      + (Ap * (Bn * Cp + Cn * Bp - (Bn * Cn + Bp * Cp))\n         + Cp * (An * Bn + Ap * Bp - (An * Bp + Bn * Ap)))) =\n   An * (Bn * Cp + Cn * Bp - (Bn * Cn + Bp * Cp))\n   + (Cn * (An * Bn + Ap * Bp - (An * Bp + Bn * Ap))\n      + (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Cn * Bp))\n         + Cp * (An * Bp + Bn * Ap - (An * Bn + Ap * Bp))))\"\n  for Ap An Bp Bn Cp Cn Dp Dn :: hmultiset", "lemma offset_hmset_of_nat[simp]: \"offset_hmset (of_nat n) = n\"", "lemma offset_hmset_numeral[simp]: \"offset_hmset (numeral n) = numeral n\"", "lemma sum_coefs_distrib_plus[simp]: \"sum_coefs (M + N) = sum_coefs M + sum_coefs N\"", "lemma sum_coefs_gt_0: \"sum_coefs M > 0 \\<longleftrightarrow> M > 0\"", "lemma ludwig_waldmann_less:\n  fixes \\<alpha>1 \\<alpha>2 \\<beta>1 \\<beta>2 \\<gamma> \\<delta> :: hmultiset\n  assumes\n    \\<alpha>\\<beta>2\\<gamma>_lt_\\<alpha>\\<beta>1\\<gamma>: \"\\<alpha>2 + \\<beta>2 * \\<gamma> < \\<alpha>1 + \\<beta>1 * \\<gamma>\" and\n    \\<beta>2_le_\\<beta>1: \"\\<beta>2 \\<le> \\<beta>1\" and\n    \\<gamma>_lt_\\<delta>: \"\\<gamma> < \\<delta>\"\n  shows \"\\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>\""], "translations": [["", "lemma hmsetmset_times:\n  \"hmsetmset (m * n) = image_mset (case_prod (+)) (hmsetmset m \\<times># hmsetmset n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset (m * n) =\n    {#x + y. (x, y) \\<in># hmsetmset m \\<times># hmsetmset n#}", "unfolding times_hmultiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset\n     (HMSet {#x + y. (x, y) \\<in># hmsetmset m \\<times># hmsetmset n#}) =\n    {#x + y. (x, y) \\<in># hmsetmset m \\<times># hmsetmset n#}", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, comm_semiring_1_class)", "proof (intro_classes, goal_cases assoc comm one distrib_plus zeroL zeroR zero_one)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a. 1 * a = a\n 4. \\<And>a b c. (a + b) * c = a * c + b * c\n 5. \\<And>a. 0 * a = 0\n 6. \\<And>a. a * 0 = 0\n 7. 0 \\<noteq> 1", "case (assoc a b c)"], ["proof (state)\nthis:\n  \n\ngoal (7 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a b. a * b = b * a\n 3. \\<And>a. 1 * a = a\n 4. \\<And>a b c. (a + b) * c = a * c + b * c\n 5. \\<And>a. 0 * a = 0\n 6. \\<And>a. a * 0 = 0\n 7. 0 \\<noteq> 1", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b * c = a * (b * c)", "by (auto simp: times_hmultiset_def Times_mset_image_mset1 Times_mset_image_mset2\n      Times_mset_assoc ac_simps intro: multiset.map_cong)"], ["proof (state)\nthis:\n  a * b * c = a * (b * c)\n\ngoal (6 subgoals):\n 1. \\<And>a b. a * b = b * a\n 2. \\<And>a. 1 * a = a\n 3. \\<And>a b c. (a + b) * c = a * c + b * c\n 4. \\<And>a. 0 * a = 0\n 5. \\<And>a. a * 0 = 0\n 6. 0 \\<noteq> 1", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a b. a * b = b * a\n 2. \\<And>a. 1 * a = a\n 3. \\<And>a b c. (a + b) * c = a * c + b * c\n 4. \\<And>a. 0 * a = 0\n 5. \\<And>a. a * 0 = 0\n 6. 0 \\<noteq> 1", "case (comm a b)"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>a b. a * b = b * a\n 2. \\<And>a. 1 * a = a\n 3. \\<And>a b c. (a + b) * c = a * c + b * c\n 4. \\<And>a. 0 * a = 0\n 5. \\<And>a. a * 0 = 0\n 6. 0 \\<noteq> 1", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b = b * a", "unfolding times_hmultiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. HMSet {#x + y. (x, y) \\<in># hmsetmset a \\<times># hmsetmset b#} =\n    HMSet {#x + y. (x, y) \\<in># hmsetmset b \\<times># hmsetmset a#}", "by (subst product_swap_mset[symmetric]) (auto simp: ac_simps intro: multiset.map_cong)"], ["proof (state)\nthis:\n  a * b = b * a\n\ngoal (5 subgoals):\n 1. \\<And>a. 1 * a = a\n 2. \\<And>a b c. (a + b) * c = a * c + b * c\n 3. \\<And>a. 0 * a = 0\n 4. \\<And>a. a * 0 = 0\n 5. 0 \\<noteq> 1", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a. 1 * a = a\n 2. \\<And>a b c. (a + b) * c = a * c + b * c\n 3. \\<And>a. 0 * a = 0\n 4. \\<And>a. a * 0 = 0\n 5. 0 \\<noteq> 1", "case (one a)"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. \\<And>a. 1 * a = a\n 2. \\<And>a b c. (a + b) * c = a * c + b * c\n 3. \\<And>a. 0 * a = 0\n 4. \\<And>a. a * 0 = 0\n 5. 0 \\<noteq> 1", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * a = a", "by (auto simp: one_hmultiset_def times_hmultiset_def Times_mset_single_left)"], ["proof (state)\nthis:\n  1 * a = a\n\ngoal (4 subgoals):\n 1. \\<And>a b c. (a + b) * c = a * c + b * c\n 2. \\<And>a. 0 * a = 0\n 3. \\<And>a. a * 0 = 0\n 4. 0 \\<noteq> 1", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a b c. (a + b) * c = a * c + b * c\n 2. \\<And>a. 0 * a = 0\n 3. \\<And>a. a * 0 = 0\n 4. 0 \\<noteq> 1", "case (distrib_plus a b c)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>a b c. (a + b) * c = a * c + b * c\n 2. \\<And>a. 0 * a = 0\n 3. \\<And>a. a * 0 = 0\n 4. 0 \\<noteq> 1", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b) * c = a * c + b * c", "by (auto simp: plus_hmultiset_def times_hmultiset_def)"], ["proof (state)\nthis:\n  (a + b) * c = a * c + b * c\n\ngoal (3 subgoals):\n 1. \\<And>a. 0 * a = 0\n 2. \\<And>a. a * 0 = 0\n 3. 0 \\<noteq> 1", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. 0 * a = 0\n 2. \\<And>a. a * 0 = 0\n 3. 0 \\<noteq> 1", "case (zeroL a)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>a. 0 * a = 0\n 2. \\<And>a. a * 0 = 0\n 3. 0 \\<noteq> 1", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 * a = 0", "by (auto simp: times_hmultiset_def)"], ["proof (state)\nthis:\n  0 * a = 0\n\ngoal (2 subgoals):\n 1. \\<And>a. a * 0 = 0\n 2. 0 \\<noteq> 1", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. a * 0 = 0\n 2. 0 \\<noteq> 1", "case (zeroR a)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a. a * 0 = 0\n 2. 0 \\<noteq> 1", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a * 0 = 0", "by (auto simp: times_hmultiset_def)"], ["proof (state)\nthis:\n  a * 0 = 0\n\ngoal (1 subgoal):\n 1. 0 \\<noteq> 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<noteq> 1", "case zero_one"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. 0 \\<noteq> 1", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> 1", "by (auto simp: one_hmultiset_def)"], ["proof (state)\nthis:\n  0 \\<noteq> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma empty_times_left_hmset[simp]: \"HMSet {#} * M = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMSet {#} * M = 0", "by (simp add: times_hmultiset_def)"], ["", "lemma empty_times_right_hmset[simp]: \"M * HMSet {#} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M * HMSet {#} = 0", "by (metis mult_zero_right zero_hmultiset_def)"], ["", "lemma singleton_times_left_hmset[simp]: \"\\<omega>^M * N = HMSet (image_mset ((+) M) (hmsetmset N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>^ M * N = HMSet (image_mset ((+) M) (hmsetmset N))", "by (simp add: times_hmultiset_def Times_mset_single_left)"], ["", "lemma singleton_times_right_hmset[simp]: \"N * \\<omega>^M = HMSet (image_mset ((+) M) (hmsetmset N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N * \\<omega>^ M = HMSet (image_mset ((+) M) (hmsetmset N))", "by (metis mult.commute singleton_times_left_hmset)"], ["", "subsection \\<open>Inequalities\\<close>"], ["", "definition plus_nmultiset :: \"unit nmultiset \\<Rightarrow> unit nmultiset \\<Rightarrow> unit nmultiset\"  where\n  \"plus_nmultiset X Y = Rep_hmultiset (Abs_hmultiset X + Abs_hmultiset Y)\""], ["", "lemma plus_nmultiset_mono:\n  assumes less: \"(X, Y) < (X', Y')\" and no_elem: \"no_elem X\" \"no_elem Y\" \"no_elem X'\" \"no_elem Y'\"\n  shows \"plus_nmultiset X Y < plus_nmultiset X' Y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plus_nmultiset X Y < plus_nmultiset X' Y'", "using less[unfolded less_le_not_le] no_elem"], ["proof (prove)\nusing this:\n  (X, Y) \\<le> (X', Y') \\<and> \\<not> (X', Y') \\<le> (X, Y)\n  no_elem X\n  no_elem Y\n  no_elem X'\n  no_elem Y'\n\ngoal (1 subgoal):\n 1. plus_nmultiset X Y < plus_nmultiset X' Y'", "by (auto simp: plus_nmultiset_def plus_hmultiset_def less_multiset_ext\\<^sub>D\\<^sub>M_less less_eq_nmultiset_def\n          union_less_mono type_definition.Abs_inverse[OF type_definition_hmultiset, simplified]\n        elim!: no_elem.cases)"], ["", "lemma plus_hmultiset_transfer[transfer_rule]:\n  \"(rel_fun pcr_hmultiset (rel_fun pcr_hmultiset pcr_hmultiset)) plus_nmultiset (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun pcr_hmultiset (rel_fun pcr_hmultiset pcr_hmultiset)\n     plus_nmultiset (+)", "unfolding rel_fun_def plus_nmultiset_def pcr_hmultiset_def nmultiset.rel_eq eq_OO cr_hmultiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = Hereditary_Multiset.Rep_hmultiset y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = Hereditary_Multiset.Rep_hmultiset ya \\<longrightarrow>\n           Hereditary_Multiset.Rep_hmultiset\n            (Hereditary_Multiset.Abs_hmultiset x +\n             Hereditary_Multiset.Abs_hmultiset xa) =\n           Hereditary_Multiset.Rep_hmultiset (y + ya))", "by (auto simp: type_definition.Rep_inverse[OF type_definition_hmultiset])"], ["", "lemma Times_mset_monoL:\n  assumes less: \"M < N\" and Z_nemp: \"Z \\<noteq> {#}\"\n  shows \"M \\<times># Z < N \\<times># Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<times># Z < N \\<times># Z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<times># Z < N \\<times># Z", "obtain Y X where\n    Y_nemp: \"Y \\<noteq> {#}\" and Y_sub_N: \"Y \\<subseteq># N\" and M_eq: \"M = N - Y + X\" and\n    ex_Y: \"\\<forall>x. x \\<in># X \\<longrightarrow> (\\<exists>y. y \\<in># Y \\<and> x < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Y X.\n        \\<lbrakk>Y \\<noteq> {#}; Y \\<subseteq># N; M = N - Y + X;\n         \\<forall>x.\n            x \\<in># X \\<longrightarrow>\n            (\\<exists>y. y \\<in># Y \\<and> x < y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using less[unfolded less_multiset\\<^sub>D\\<^sub>M]"], ["proof (prove)\nusing this:\n  \\<exists>X Y.\n     X \\<noteq> {#} \\<and>\n     X \\<subseteq># N \\<and>\n     M = N - X + Y \\<and>\n     (\\<forall>k.\n         k \\<in># Y \\<longrightarrow> (\\<exists>a. a \\<in># X \\<and> k < a))\n\ngoal (1 subgoal):\n 1. (\\<And>Y X.\n        \\<lbrakk>Y \\<noteq> {#}; Y \\<subseteq># N; M = N - Y + X;\n         \\<forall>x.\n            x \\<in># X \\<longrightarrow>\n            (\\<exists>y. y \\<in># Y \\<and> x < y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Y \\<noteq> {#}\n  Y \\<subseteq># N\n  M = N - Y + X\n  \\<forall>x.\n     x \\<in># X \\<longrightarrow> (\\<exists>y. y \\<in># Y \\<and> x < y)\n\ngoal (1 subgoal):\n 1. M \\<times># Z < N \\<times># Z", "let ?X = \"X \\<times># Z\""], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<times># Z < N \\<times># Z", "let ?Y = \"Y \\<times># Z\""], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<times># Z < N \\<times># Z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<times># Z < N \\<times># Z", "unfolding less_multiset\\<^sub>D\\<^sub>M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X Y.\n       X \\<noteq> {#} \\<and>\n       X \\<subseteq># N \\<times># Z \\<and>\n       M \\<times># Z = N \\<times># Z - X + Y \\<and>\n       (\\<forall>k.\n           k \\<in># Y \\<longrightarrow>\n           (\\<exists>a. a \\<in># X \\<and> k < a))", "proof (intro exI conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. ?X \\<noteq> {#}\n 2. ?X \\<subseteq># N \\<times># Z\n 3. M \\<times># Z = N \\<times># Z - ?X + ?Y1\n 4. \\<forall>k.\n       k \\<in># ?Y1 \\<longrightarrow> (\\<exists>a. a \\<in># ?X \\<and> k < a)", "show \"M \\<times># Z = N \\<times># Z - ?Y + ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<times># Z = N \\<times># Z - Y \\<times># Z + X \\<times># Z", "unfolding M_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (N - Y + X) \\<times># Z = N \\<times># Z - Y \\<times># Z + X \\<times># Z", "by (auto simp: Sigma_mset_Diff_distrib1)"], ["proof (state)\nthis:\n  M \\<times># Z = N \\<times># Z - Y \\<times># Z + X \\<times># Z\n\ngoal (3 subgoals):\n 1. Y \\<times># Z \\<noteq> {#}\n 2. Y \\<times># Z \\<subseteq># N \\<times># Z\n 3. \\<forall>k.\n       k \\<in># X \\<times># Z \\<longrightarrow>\n       (\\<exists>a. a \\<in># Y \\<times># Z \\<and> k < a)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Y \\<times># Z \\<noteq> {#}\n 2. Y \\<times># Z \\<subseteq># N \\<times># Z\n 3. \\<forall>k.\n       k \\<in># X \\<times># Z \\<longrightarrow>\n       (\\<exists>a. a \\<in># Y \\<times># Z \\<and> k < a)", "obtain y where y: \"\\<forall>x. x \\<in># X \\<longrightarrow> y x \\<in># Y \\<and> x < y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<forall>x.\n           x \\<in># X \\<longrightarrow>\n           y x \\<in># Y \\<and> x < y x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_Y"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in># X \\<longrightarrow> (\\<exists>y. y \\<in># Y \\<and> x < y)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<forall>x.\n           x \\<in># X \\<longrightarrow>\n           y x \\<in># Y \\<and> x < y x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x. x \\<in># X \\<longrightarrow> y x \\<in># Y \\<and> x < y x\n\ngoal (3 subgoals):\n 1. Y \\<times># Z \\<noteq> {#}\n 2. Y \\<times># Z \\<subseteq># N \\<times># Z\n 3. \\<forall>k.\n       k \\<in># X \\<times># Z \\<longrightarrow>\n       (\\<exists>a. a \\<in># Y \\<times># Z \\<and> k < a)", "show \"\\<forall>x. x \\<in># ?X \\<longrightarrow> (\\<exists>y. y \\<in># ?Y \\<and> x < y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in># X \\<times># Z \\<longrightarrow>\n       (\\<exists>y. y \\<in># Y \\<times># Z \\<and> x < y)", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># X \\<times># Z \\<Longrightarrow>\n       \\<exists>y. y \\<in># Y \\<times># Z \\<and> x < y", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># X \\<times># Z \\<Longrightarrow>\n       \\<exists>y. y \\<in># Y \\<times># Z \\<and> x < y", "assume \"x \\<in># ?X\""], ["proof (state)\nthis:\n  x \\<in># X \\<times># Z\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># X \\<times># Z \\<Longrightarrow>\n       \\<exists>y. y \\<in># Y \\<times># Z \\<and> x < y", "thus \"\\<exists>y. y \\<in># ?Y \\<and> x < y\""], ["proof (prove)\nusing this:\n  x \\<in># X \\<times># Z\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<in># Y \\<times># Z \\<and> x < y", "using y"], ["proof (prove)\nusing this:\n  x \\<in># X \\<times># Z\n  \\<forall>x. x \\<in># X \\<longrightarrow> y x \\<in># Y \\<and> x < y x\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<in># Y \\<times># Z \\<and> x < y", "by (intro exI[of _ \"(y (fst x), snd x)\"]) (auto simp: less_le_not_le)"], ["proof (state)\nthis:\n  \\<exists>y. y \\<in># Y \\<times># Z \\<and> x < y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in># X \\<times># Z \\<longrightarrow>\n     (\\<exists>y. y \\<in># Y \\<times># Z \\<and> x < y)\n\ngoal (2 subgoals):\n 1. Y \\<times># Z \\<noteq> {#}\n 2. Y \\<times># Z \\<subseteq># N \\<times># Z", "qed (auto simp: Z_nemp Y_nemp Y_sub_N Sigma_mset_mono)"], ["proof (state)\nthis:\n  M \\<times># Z < N \\<times># Z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma times_hmultiset_monoL:\n  \"a < b \\<Longrightarrow> 0 < c \\<Longrightarrow> a * c < b * c\" for a b c :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < b; 0 < c\\<rbrakk> \\<Longrightarrow> a * c < b * c", "by (cases a, cases b, cases c, hypsubst_thin,\n    unfold times_hmultiset_def zero_hmultiset_def hmultiset.sel, transfer,\n    auto simp: less_multiset_ext\\<^sub>D\\<^sub>M_less multiset.pred_set\n      intro!: image_mset_strict_mono Times_mset_monoL elim!: plus_nmultiset_mono)"], ["", "instance hmultiset :: linordered_semiring_strict"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, linordered_semiring_strict_class)", "by intro_classes (subst (1 2) mult.commute, (fact times_hmultiset_monoL)+)"], ["", "lemma mult_le_mono1_hmset: \"i \\<le> j \\<Longrightarrow> i * k \\<le> j * k\" for i j k :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> i * k \\<le> j * k", "by (simp add: mult_right_mono)"], ["", "lemma mult_le_mono2_hmset: \"i \\<le> j \\<Longrightarrow> k * i \\<le> k * j\" for i j k :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> k * i \\<le> k * j", "by (simp add: mult_left_mono)"], ["", "lemma mult_le_mono_hmset: \"i \\<le> j \\<Longrightarrow> k \\<le> l \\<Longrightarrow> i * k \\<le> j * l\" for i j k l :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; k \\<le> l\\<rbrakk>\n    \\<Longrightarrow> i * k \\<le> j * l", "by (simp add: mult_mono)"], ["", "lemma less_iff_add1_le_hmset: \"m < n \\<longleftrightarrow> m + 1 \\<le> n\" for m n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m < n) = (m + 1 \\<le> n)", "proof (cases m n rule: hmultiset.exhaust[case_product hmultiset.exhaust])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> (m < n) = (m + 1 \\<le> n)", "case (HMSet_HMSet m0 n0)"], ["proof (state)\nthis:\n  m = HMSet m0\n  n = HMSet n0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> (m < n) = (m + 1 \\<le> n)", "note m = this(1) and n = this(2)"], ["proof (state)\nthis:\n  m = HMSet m0\n  n = HMSet n0\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> (m < n) = (m + 1 \\<le> n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m < n) = (m + 1 \\<le> n)", "proof (simp add: m n one_hmultiset_def plus_hmultiset_def order.order_iff_strict\n      less_multiset_ext\\<^sub>D\\<^sub>M_less, intro iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "assume m0_lt_n0: \"m0 < n0\""], ["proof (state)\nthis:\n  m0 < n0\n\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "note\n      m0_ne_n0 = m0_lt_n0[unfolded less_multiset\\<^sub>H\\<^sub>O, THEN conjunct1] and\n      ex_n0_gt_m0 = m0_lt_n0[unfolded less_multiset\\<^sub>H\\<^sub>O, THEN conjunct2, rule_format]"], ["proof (state)\nthis:\n  m0 \\<noteq> n0\n  count n0 ?y < count m0 ?y \\<Longrightarrow>\n  \\<exists>x>?y. count m0 x < count n0 x\n\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "{"], ["proof (state)\nthis:\n  m0 \\<noteq> n0\n  count n0 ?y < count m0 ?y \\<Longrightarrow>\n  \\<exists>x>?y. count m0 x < count n0 x\n\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "assume zero_m0_gt_n0: \"add_mset 0 m0 > n0\""], ["proof (state)\nthis:\n  n0 < add_mset 0 m0\n\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "note\n        n0_ne_0m0 = zero_m0_gt_n0[unfolded less_multiset\\<^sub>H\\<^sub>O, THEN conjunct1] and\n        ex_0m0_gt_n0 = zero_m0_gt_n0[unfolded less_multiset\\<^sub>H\\<^sub>O, THEN conjunct2, rule_format]"], ["proof (state)\nthis:\n  n0 \\<noteq> add_mset 0 m0\n  count (add_mset 0 m0) ?y < count n0 ?y \\<Longrightarrow>\n  \\<exists>x>?y. count n0 x < count (add_mset 0 m0) x\n\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "{"], ["proof (state)\nthis:\n  n0 \\<noteq> add_mset 0 m0\n  count (add_mset 0 m0) ?y < count n0 ?y \\<Longrightarrow>\n  \\<exists>x>?y. count n0 x < count (add_mset 0 m0) x\n\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "assume m0y_lt_n0y: \"count m0 y < count n0 y\""], ["proof (state)\nthis:\n  count m0 y < count n0 y\n\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "have \"\\<exists>x > y. count n0 x < count m0 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x>y. count n0 x < count m0 x", "proof (cases \"count (add_mset 0 m0) y < count n0 y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x\n 2. \\<not> count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x", "case True"], ["proof (state)\nthis:\n  count (add_mset 0 m0) y < count n0 y\n\ngoal (2 subgoals):\n 1. count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x\n 2. \\<not> count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x", "then"], ["proof (chain)\npicking this:\n  count (add_mset 0 m0) y < count n0 y", "obtain aa where\n            aa_gt_y: \"aa > y\" and\n            count_n0aa_lt_count_0m0aa: \"count n0 aa < count (add_mset 0 m0) aa\""], ["proof (prove)\nusing this:\n  count (add_mset 0 m0) y < count n0 y\n\ngoal (1 subgoal):\n 1. (\\<And>aa.\n        \\<lbrakk>y < aa; count n0 aa < count (add_mset 0 m0) aa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_0m0_gt_n0"], ["proof (prove)\nusing this:\n  count (add_mset 0 m0) y < count n0 y\n  count (add_mset 0 m0) ?y < count n0 ?y \\<Longrightarrow>\n  \\<exists>x>?y. count n0 x < count (add_mset 0 m0) x\n\ngoal (1 subgoal):\n 1. (\\<And>aa.\n        \\<lbrakk>y < aa; count n0 aa < count (add_mset 0 m0) aa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y < aa\n  count n0 aa < count (add_mset 0 m0) aa\n\ngoal (2 subgoals):\n 1. count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x\n 2. \\<not> count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x", "have \"aa \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aa \\<noteq> 0", "by (rule gr_implies_not_zero_hmset[OF aa_gt_y])"], ["proof (state)\nthis:\n  aa \\<noteq> 0\n\ngoal (2 subgoals):\n 1. count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x\n 2. \\<not> count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x", "hence \"count (add_mset 0 m0) aa = count m0 aa\""], ["proof (prove)\nusing this:\n  aa \\<noteq> 0\n\ngoal (1 subgoal):\n 1. count (add_mset 0 m0) aa = count m0 aa", "by simp"], ["proof (state)\nthis:\n  count (add_mset 0 m0) aa = count m0 aa\n\ngoal (2 subgoals):\n 1. count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x\n 2. \\<not> count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x", "thus ?thesis"], ["proof (prove)\nusing this:\n  count (add_mset 0 m0) aa = count m0 aa\n\ngoal (1 subgoal):\n 1. \\<exists>x>y. count n0 x < count m0 x", "using count_n0aa_lt_count_0m0aa aa_gt_y"], ["proof (prove)\nusing this:\n  count (add_mset 0 m0) aa = count m0 aa\n  count n0 aa < count (add_mset 0 m0) aa\n  y < aa\n\ngoal (1 subgoal):\n 1. \\<exists>x>y. count n0 x < count m0 x", "by auto"], ["proof (state)\nthis:\n  \\<exists>x>y. count n0 x < count m0 x\n\ngoal (1 subgoal):\n 1. \\<not> count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x", "case not_0m0_y_lt_n0y: False"], ["proof (state)\nthis:\n  \\<not> count (add_mset 0 m0) y < count n0 y\n\ngoal (1 subgoal):\n 1. \\<not> count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x", "hence y_eq_0: \"y = 0\""], ["proof (prove)\nusing this:\n  \\<not> count (add_mset 0 m0) y < count n0 y\n\ngoal (1 subgoal):\n 1. y = 0", "by (metis count_add_mset m0y_lt_n0y)"], ["proof (state)\nthis:\n  y = 0\n\ngoal (1 subgoal):\n 1. \\<not> count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x", "have sm0y_eq_n0y: \"Suc (count m0 y) = count n0 y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (count m0 y) = count n0 y", "using m0y_lt_n0y not_0m0_y_lt_n0y count_add_mset[of 0 _ 0]"], ["proof (prove)\nusing this:\n  count m0 y < count n0 y\n  \\<not> count (add_mset 0 m0) y < count n0 y\n  count (add_mset (0::?'a1) ?A) (0::?'a1) =\n  (if (0::?'a1) = (0::?'a1) then Suc (count ?A (0::?'a1))\n   else count ?A (0::?'a1))\n\ngoal (1 subgoal):\n 1. Suc (count m0 y) = count n0 y", "unfolding y_eq_0"], ["proof (prove)\nusing this:\n  count m0 0 < count n0 0\n  \\<not> count (add_mset 0 m0) 0 < count n0 0\n  count (add_mset (0::?'a1) ?A) (0::?'a1) =\n  (if (0::?'a1) = (0::?'a1) then Suc (count ?A (0::?'a1))\n   else count ?A (0::?'a1))\n\ngoal (1 subgoal):\n 1. Suc (count m0 0) = count n0 0", "by simp"], ["proof (state)\nthis:\n  Suc (count m0 y) = count n0 y\n\ngoal (1 subgoal):\n 1. \\<not> count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x", "obtain bb where \"count n0 bb < count (add_mset 0 m0) bb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bb.\n        count n0 bb < count (add_mset 0 m0) bb \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using lt_imp_ex_count_lt[OF zero_m0_gt_n0]"], ["proof (prove)\nusing this:\n  \\<exists>y. count n0 y < count (add_mset 0 m0) y\n\ngoal (1 subgoal):\n 1. (\\<And>bb.\n        count n0 bb < count (add_mset 0 m0) bb \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  count n0 bb < count (add_mset 0 m0) bb\n\ngoal (1 subgoal):\n 1. \\<not> count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x", "hence n0bb_lt_m0bb: \"count n0 bb < count m0 bb\""], ["proof (prove)\nusing this:\n  count n0 bb < count (add_mset 0 m0) bb\n\ngoal (1 subgoal):\n 1. count n0 bb < count m0 bb", "unfolding count_add_mset"], ["proof (prove)\nusing this:\n  count n0 bb < (if 0 = bb then Suc (count m0 bb) else count m0 bb)\n\ngoal (1 subgoal):\n 1. count n0 bb < count m0 bb", "by (metis (full_types) less_irrefl_nat sm0y_eq_n0y y_eq_0)"], ["proof (state)\nthis:\n  count n0 bb < count m0 bb\n\ngoal (1 subgoal):\n 1. \\<not> count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x", "hence \"bb \\<noteq> 0\""], ["proof (prove)\nusing this:\n  count n0 bb < count m0 bb\n\ngoal (1 subgoal):\n 1. bb \\<noteq> 0", "using sm0y_eq_n0y y_eq_0"], ["proof (prove)\nusing this:\n  count n0 bb < count m0 bb\n  Suc (count m0 y) = count n0 y\n  y = 0\n\ngoal (1 subgoal):\n 1. bb \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  bb \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> count (add_mset 0 m0) y < count n0 y \\<Longrightarrow>\n    \\<exists>x>y. count n0 x < count m0 x", "thus ?thesis"], ["proof (prove)\nusing this:\n  bb \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>y. count n0 x < count m0 x", "unfolding y_eq_0"], ["proof (prove)\nusing this:\n  bb \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x>0. count n0 x < count m0 x", "using n0bb_lt_m0bb not_gr_zero_hmset"], ["proof (prove)\nusing this:\n  bb \\<noteq> 0\n  count n0 bb < count m0 bb\n  (\\<not> 0 < ?M) = (?M = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>x>0. count n0 x < count m0 x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x>y. count n0 x < count m0 x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x>y. count n0 x < count m0 x\n\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "}"], ["proof (state)\nthis:\n  count m0 ?y2 < count n0 ?y2 \\<Longrightarrow>\n  \\<exists>x>?y2. count n0 x < count m0 x\n\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "hence \"n0 < m0\""], ["proof (prove)\nusing this:\n  count m0 ?y2 < count n0 ?y2 \\<Longrightarrow>\n  \\<exists>x>?y2. count n0 x < count m0 x\n\ngoal (1 subgoal):\n 1. n0 < m0", "unfolding less_multiset\\<^sub>H\\<^sub>O"], ["proof (prove)\nusing this:\n  count m0 ?y2 < count n0 ?y2 \\<Longrightarrow>\n  \\<exists>x>?y2. count n0 x < count m0 x\n\ngoal (1 subgoal):\n 1. n0 \\<noteq> m0 \\<and>\n    (\\<forall>y.\n        count m0 y < count n0 y \\<longrightarrow>\n        (\\<exists>x>y. count n0 x < count m0 x))", "using m0_ne_n0"], ["proof (prove)\nusing this:\n  count m0 ?y2 < count n0 ?y2 \\<Longrightarrow>\n  \\<exists>x>?y2. count n0 x < count m0 x\n  m0 \\<noteq> n0\n\ngoal (1 subgoal):\n 1. n0 \\<noteq> m0 \\<and>\n    (\\<forall>y.\n        count m0 y < count n0 y \\<longrightarrow>\n        (\\<exists>x>y. count n0 x < count m0 x))", "by blast"], ["proof (state)\nthis:\n  n0 < m0\n\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "hence False"], ["proof (prove)\nusing this:\n  n0 < m0\n\ngoal (1 subgoal):\n 1. False", "using m0_lt_n0"], ["proof (prove)\nusing this:\n  n0 < m0\n  m0 < n0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "}"], ["proof (state)\nthis:\n  n0 < add_mset 0 m0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. m0 < n0 \\<Longrightarrow> add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n 2. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "thus \"add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\""], ["proof (prove)\nusing this:\n  n0 < add_mset 0 m0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0", "using antisym_conv3"], ["proof (prove)\nusing this:\n  n0 < add_mset 0 m0 \\<Longrightarrow> False\n  \\<not> ?y < ?x \\<Longrightarrow> (\\<not> ?x < ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0", "by blast"], ["proof (state)\nthis:\n  add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n\ngoal (1 subgoal):\n 1. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "assume \"add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\""], ["proof (state)\nthis:\n  add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n\ngoal (1 subgoal):\n 1. add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0 \\<Longrightarrow> m0 < n0", "thus \"m0 < n0\""], ["proof (prove)\nusing this:\n  add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n\ngoal (1 subgoal):\n 1. m0 < n0", "using dual_order.strict_trans le_multiset_right_total"], ["proof (prove)\nusing this:\n  add_mset 0 m0 < n0 \\<or> add_mset 0 m0 = n0\n  \\<lbrakk>?b < ?a; ?c < ?b\\<rbrakk> \\<Longrightarrow> ?c < ?a\n  ?M < add_mset ?x ?M\n\ngoal (1 subgoal):\n 1. m0 < n0", "by blast"], ["proof (state)\nthis:\n  m0 < n0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (m < n) = (m + 1 \\<le> n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_less_iff_1_le_hmset: \"0 < n \\<longleftrightarrow> 1 \\<le> n\" for n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < n) = (1 \\<le> n)", "by (rule less_iff_add1_le_hmset[of 0, simplified])"], ["", "lemma less_add_1_iff_le_hmset: \"m < n + 1 \\<longleftrightarrow> m \\<le> n\" for m n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m < n + 1) = (m \\<le> n)", "by (rule less_iff_add1_le_hmset[of m \"n + 1\", simplified])"], ["", "instance hmultiset :: ordered_cancel_comm_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, ordered_cancel_comm_semiring_class)", "by intro_classes (simp add: mult_le_mono2_hmset)"], ["", "instance hmultiset :: zero_less_one"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, zero_less_one_class)", "by intro_classes (simp add: zero_less_iff_neq_zero_hmset)"], ["", "instance hmultiset :: linordered_semiring_1_strict"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, linordered_semiring_1_strict_class)", "by intro_classes"], ["", "instance hmultiset :: bounded_lattice_bot"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, bounded_lattice_bot_class)", "by intro_classes"], ["", "instance hmultiset :: linordered_nonzero_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, linordered_nonzero_semiring_class)", "by intro_classes simp"], ["", "instance hmultiset :: semiring_no_zero_divisors"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, semiring_no_zero_divisors_class)", "by intro_classes (use mult_pos_pos not_gr_zero_hmset in blast)"], ["", "lemma lt_1_iff_eq_0_hmset: \"M < 1 \\<longleftrightarrow> M = 0\" for M :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M < 1) = (M = 0)", "by (simp add: less_iff_add1_le_hmset)"], ["", "lemma zero_less_mult_iff_hmset[simp]: \"0 < m * n \\<longleftrightarrow> 0 < m \\<and> 0 < n\" for m n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < m * n) = (0 < m \\<and> 0 < n)", "using mult_eq_0_iff not_gr_zero_hmset"], ["proof (prove)\nusing this:\n  (?a * ?b = (0::?'a)) = (?a = (0::?'a) \\<or> ?b = (0::?'a))\n  (\\<not> 0 < ?M) = (?M = 0)\n\ngoal (1 subgoal):\n 1. (0 < m * n) = (0 < m \\<and> 0 < n)", "by blast"], ["", "lemma one_le_mult_iff_hmset[simp]: \"1 \\<le> m * n \\<longleftrightarrow> 1 \\<le> m \\<and> 1 \\<le> n\" for m n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 \\<le> m * n) = (1 \\<le> m \\<and> 1 \\<le> n)", "by (metis lt_1_iff_eq_0_hmset mult_eq_0_iff not_le)"], ["", "lemma mult_less_cancel2_hmset[simp]: \"m * k < n * k \\<longleftrightarrow> 0 < k \\<and> m < n\" for k m n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m * k < n * k) = (0 < k \\<and> m < n)", "by (metis gr_zeroI_hmset leD leI le_cases mult_right_mono mult_zero_right times_hmultiset_monoL)"], ["", "lemma mult_less_cancel1_hmset[simp]: \"k * m < k * n \\<longleftrightarrow> 0 < k \\<and> m < n\" for k m n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k * m < k * n) = (0 < k \\<and> m < n)", "by (simp add: mult.commute[of k])"], ["", "lemma mult_le_cancel1_hmset[simp]: \"k * m \\<le> k * n \\<longleftrightarrow> (0 < k \\<longrightarrow> m \\<le> n)\" for k m n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k * m \\<le> k * n) = (0 < k \\<longrightarrow> m \\<le> n)", "by (simp add: linorder_not_less[symmetric], auto)"], ["", "lemma mult_le_cancel2_hmset[simp]: \"m * k \\<le> n * k \\<longleftrightarrow> (0 < k \\<longrightarrow> m \\<le> n)\" for k m n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m * k \\<le> n * k) = (0 < k \\<longrightarrow> m \\<le> n)", "by (simp add: linorder_not_less[symmetric], auto)"], ["", "lemma mult_le_cancel_left1_hmset: \"y > 0 \\<Longrightarrow> x \\<le> x * y\" for x y :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> x \\<le> x * y", "by (metis zero_less_iff_1_le_hmset mult.commute mult.left_neutral mult_le_cancel2_hmset)"], ["", "lemma mult_le_cancel_left2_hmset: \"y \\<le> 1 \\<Longrightarrow> x * y \\<le> x\" for x y :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> 1 \\<Longrightarrow> x * y \\<le> x", "by (metis mult.commute mult.left_neutral mult_le_cancel2_hmset)"], ["", "lemma mult_le_cancel_right1_hmset: \"y > 0 \\<Longrightarrow> x \\<le> y * x\" for x y :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<Longrightarrow> x \\<le> y * x", "by (subst mult.commute) (fact mult_le_cancel_left1_hmset)"], ["", "lemma mult_le_cancel_right2_hmset: \"y \\<le> 1 \\<Longrightarrow> y * x \\<le> x\" for x y :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> 1 \\<Longrightarrow> y * x \\<le> x", "by (subst mult.commute) (fact mult_le_cancel_left2_hmset)"], ["", "lemma le_square_hmset: \"m \\<le> m * m\" for m :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> m * m", "using mult_le_cancel_left1_hmset"], ["proof (prove)\nusing this:\n  0 < ?y \\<Longrightarrow> ?x \\<le> ?x * ?y\n\ngoal (1 subgoal):\n 1. m \\<le> m * m", "by force"], ["", "lemma le_cube_hmset: \"m \\<le> m * (m * m)\" for m :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> m * (m * m)", "using mult_le_cancel_left1_hmset"], ["proof (prove)\nusing this:\n  0 < ?y \\<Longrightarrow> ?x \\<le> ?x * ?y\n\ngoal (1 subgoal):\n 1. m \\<le> m * (m * m)", "by force"], ["", "lemma\n  less_imp_minus_plus_hmset: \"m < n \\<Longrightarrow> k < k - m + n\" and\n  le_imp_minus_plus_hmset: \"m \\<le> n \\<Longrightarrow> k \\<le> k - m + n\" for k m n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m < n \\<Longrightarrow> k < k - m + n) &&&\n    (m \\<le> n \\<Longrightarrow> k \\<le> k - m + n)", "by (meson add_less_cancel_left leD le_minus_plus_same_hmset less_le_trans not_le_imp_less)+"], ["", "lemma gt_0_lt_mult_gt_1_hmset:\n  fixes m n :: hmultiset\n  assumes \"m > 0\" and \"n > 1\"\n  shows \"m < m * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m < m * n", "using assms"], ["proof (prove)\nusing this:\n  0 < m\n  1 < n\n\ngoal (1 subgoal):\n 1. m < m * n", "by (metis mult.right_neutral mult_less_cancel1_hmset)"], ["", "instance hmultiset :: linordered_comm_semiring_strict"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hmultiset, linordered_comm_semiring_strict_class)", "by intro_classes simp"], ["", "subsection \\<open>Embedding of Natural Numbers\\<close>"], ["", "lemma of_nat_hmset: \"of_nat n = HMSet (replicate_mset n 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n = HMSet (replicate_mset n 0)", "by (induct n) (auto simp: zero_hmultiset_def one_hmultiset_def plus_hmultiset_def)"], ["", "lemma of_nat_inject_hmset[simp]: \"(of_nat m :: hmultiset) = of_nat n \\<longleftrightarrow> m = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat m = of_nat n) = (m = n)", "unfolding of_nat_hmset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMSet (replicate_mset m 0) = HMSet (replicate_mset n 0)) = (m = n)", "by simp"], ["", "lemma of_nat_minus_hmset: \"of_nat (m - n) = (of_nat m :: hmultiset) - of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (m - n) = of_nat m - of_nat n", "unfolding of_nat_hmset minus_hmultiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. HMSet (replicate_mset (m - n) 0) =\n    HMSet\n     (hmsetmset (HMSet (replicate_mset m 0)) -\n      hmsetmset (HMSet (replicate_mset n 0)))", "by simp"], ["", "lemma plus_of_nat_plus_of_nat_hmset:\n  \"k + of_nat m + of_nat n = k + of_nat (m + n)\" for k :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. k + of_nat m + of_nat n = k + of_nat (m + n)", "by simp"], ["", "lemma plus_of_nat_minus_of_nat_hmset:\n  fixes k :: hmultiset\n  assumes \"n \\<le> m\"\n  shows \"k + of_nat m - of_nat n = k + of_nat (m - n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k + of_nat m - of_nat n = k + of_nat (m - n)", "using assms"], ["proof (prove)\nusing this:\n  n \\<le> m\n\ngoal (1 subgoal):\n 1. k + of_nat m - of_nat n = k + of_nat (m - n)", "by (metis add.left_commute add_diff_cancel_left' le_add_diff_inverse of_nat_add)"], ["", "lemma of_nat_lt_\\<omega>[simp]: \"of_nat n < \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n < \\<omega>", "by (auto simp: of_nat_hmset zero_less_iff_neq_zero_hmset less_multiset_ext\\<^sub>D\\<^sub>M_less)"], ["", "lemma of_nat_ne_\\<omega>[simp]: \"of_nat n \\<noteq> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n \\<noteq> \\<omega>", "by (simp add: neq_iff)"], ["", "lemma of_nat_less_hmset[simp]: \"(of_nat M :: hmultiset) < of_nat N \\<longleftrightarrow> M < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat M < of_nat N) = (M < N)", "unfolding of_nat_hmset less_multiset_ext\\<^sub>D\\<^sub>M_less"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMSet (replicate_mset M 0) < HMSet (replicate_mset N 0)) = (M < N)", "by simp"], ["", "lemma of_nat_le_hmset[simp]: \"(of_nat M :: hmultiset) \\<le> of_nat N \\<longleftrightarrow> M \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat M \\<le> of_nat N) = (M \\<le> N)", "unfolding of_nat_hmset order_le_less less_multiset_ext\\<^sub>D\\<^sub>M_less"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMSet (replicate_mset M 0) < HMSet (replicate_mset N 0) \\<or>\n     HMSet (replicate_mset M 0) = HMSet (replicate_mset N 0)) =\n    (M < N \\<or> M = N)", "by simp"], ["", "lemma of_nat_times_\\<omega>_exp: \"of_nat n * \\<omega>^m = HMSet (replicate_mset n m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n * \\<omega>^ m = HMSet (replicate_mset n m)", "by (induct n) (simp_all add: hmsetmset_plus one_hmultiset_def)"], ["", "lemma \\<omega>_exp_times_of_nat: \"\\<omega>^m * of_nat n = HMSet (replicate_mset n m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega>^ m * of_nat n = HMSet (replicate_mset n m)", "using of_nat_times_\\<omega>_exp"], ["proof (prove)\nusing this:\n  of_nat ?n * \\<omega>^ ?m = HMSet (replicate_mset ?n ?m)\n\ngoal (1 subgoal):\n 1. \\<omega>^ m * of_nat n = HMSet (replicate_mset n m)", "by simp"], ["", "subsection \\<open>Embedding of Extended Natural Numbers\\<close>"], ["", "primrec hmset_of_enat :: \"enat \\<Rightarrow> hmultiset\" where\n  \"hmset_of_enat (enat n) = of_nat n\"\n| \"hmset_of_enat \\<infinity> = \\<omega>\""], ["", "lemma hmset_of_enat_0[simp]: \"hmset_of_enat 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmset_of_enat 0 = 0", "by (simp add: zero_enat_def)"], ["", "lemma hmset_of_enat_1[simp]: \"hmset_of_enat 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmset_of_enat 1 = 1", "by (simp add: one_enat_def del: One_nat_def)"], ["", "lemma hmset_of_enat_of_nat[simp]: \"hmset_of_enat (of_nat n) = of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmset_of_enat (of_nat n) = of_nat n", "using of_nat_eq_enat"], ["proof (prove)\nusing this:\n  of_nat ?n = enat ?n\n\ngoal (1 subgoal):\n 1. hmset_of_enat (of_nat n) = of_nat n", "by auto"], ["", "lemma hmset_of_enat_numeral[simp]: \"hmset_of_enat (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmset_of_enat (numeral n) = numeral n", "by (simp add: numeral_eq_enat)"], ["", "lemma hmset_of_enat_le_\\<omega>[simp]: \"hmset_of_enat n \\<le> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmset_of_enat n \\<le> \\<omega>", "using of_nat_lt_\\<omega>[THEN less_imp_le]"], ["proof (prove)\nusing this:\n  of_nat ?n1 \\<le> \\<omega>\n\ngoal (1 subgoal):\n 1. hmset_of_enat n \\<le> \\<omega>", "by (cases n) auto"], ["", "lemma hmset_of_enat_eq_\\<omega>_iff[simp]: \"hmset_of_enat n = \\<omega> \\<longleftrightarrow> n = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hmset_of_enat n = \\<omega>) = (n = \\<infinity>)", "by (cases n) auto"], ["", "subsection \\<open>Head Omega\\<close>"], ["", "definition head_\\<omega> :: \"hmultiset \\<Rightarrow> hmultiset\" where\n  \"head_\\<omega> M = (if M = 0 then 0 else \\<omega>^(Max (set_mset (hmsetmset M))))\""], ["", "lemma head_\\<omega>_subseteq: \"hmsetmset (head_\\<omega> M) \\<subseteq># hmsetmset M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset (head_\\<omega> M) \\<subseteq># hmsetmset M", "unfolding head_\\<omega>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset\n     (if M = 0 then 0 else \\<omega>^ (Max_mset (hmsetmset M))) \\<subseteq>#\n    hmsetmset M", "by simp"], ["", "lemma head_\\<omega>_eq_0_iff[simp]: \"head_\\<omega> m = 0 \\<longleftrightarrow> m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (head_\\<omega> m = 0) = (m = 0)", "unfolding head_\\<omega>_def zero_hmultiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if m = HMSet {#} then HMSet {#}\n      else \\<omega>^ (Max_mset (hmsetmset m))) =\n     HMSet {#}) =\n    (m = HMSet {#})", "by simp"], ["", "lemma head_\\<omega>_0[simp]: \"head_\\<omega> 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> 0 = 0", "by simp"], ["", "lemma head_\\<omega>_1[simp]: \"head_\\<omega> 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> 1 = 1", "unfolding head_\\<omega>_def one_hmultiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<omega>^ 0 = 0 then 0\n     else \\<omega>^ (Max_mset (hmsetmset (\\<omega>^ 0)))) =\n    \\<omega>^ 0", "by simp"], ["", "lemma head_\\<omega>_of_nat[simp]: \"head_\\<omega> (of_nat n) = (if n = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> (of_nat n) = (if n = 0 then 0 else 1)", "unfolding head_\\<omega>_def one_hmultiset_def of_nat_hmset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if HMSet (replicate_mset n 0) = 0 then 0\n     else \\<omega>^ (Max_mset (hmsetmset (HMSet (replicate_mset n 0))))) =\n    (if n = 0 then 0 else \\<omega>^ 0)", "by simp"], ["", "lemma head_\\<omega>_numeral[simp]: \"head_\\<omega> (numeral n) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> (numeral n) = 1", "by (metis head_\\<omega>_of_nat of_nat_numeral zero_neq_numeral)"], ["", "lemma head_\\<omega>_\\<omega>[simp]: \"head_\\<omega> \\<omega> = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> \\<omega> = \\<omega>", "unfolding head_\\<omega>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<omega> = 0 then 0\n     else \\<omega>^ (Max_mset (hmsetmset \\<omega>))) =\n    \\<omega>", "by simp"], ["", "lemma le_imp_head_\\<omega>_le:\n  assumes m_le_n: \"m \\<le> n\"\n  shows \"head_\\<omega> m \\<le> head_\\<omega> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> m \\<le> head_\\<omega> n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. head_\\<omega> m \\<le> head_\\<omega> n", "have le_in_le_max: \"\\<And>a M N. M \\<le> N \\<Longrightarrow> a \\<in># M \\<Longrightarrow> a \\<le> Max (set_mset N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a M N.\n       \\<lbrakk>M \\<le> N; a \\<in># M\\<rbrakk>\n       \\<Longrightarrow> a \\<le> Max_mset N", "by (metis (no_types) Max_ge finite_set_mset le_less less_eq_multiset\\<^sub>H\\<^sub>O linorder_not_less\n      mem_Collect_eq neq0_conv order_trans set_mset_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?M \\<le> ?N; ?a \\<in># ?M\\<rbrakk>\n  \\<Longrightarrow> ?a \\<le> Max_mset ?N\n\ngoal (1 subgoal):\n 1. head_\\<omega> m \\<le> head_\\<omega> n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> m \\<le> head_\\<omega> n", "using m_le_n"], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. head_\\<omega> m \\<le> head_\\<omega> n", "unfolding head_\\<omega>_def"], ["proof (prove)\nusing this:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. (if m = 0 then 0 else \\<omega>^ (Max_mset (hmsetmset m)))\n    \\<le> (if n = 0 then 0 else \\<omega>^ (Max_mset (hmsetmset n)))", "by (cases m, cases n,\n      auto simp del: hmsetmset_le simp: head_\\<omega>_def hmsetmset_le[symmetric] zero_hmultiset_def,\n      metis Max_in dual_order.antisym finite_set_mset le_in_le_max le_less set_mset_eq_empty_iff)"], ["proof (state)\nthis:\n  head_\\<omega> m \\<le> head_\\<omega> n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma head_\\<omega>_lt_imp_lt: \"head_\\<omega> m < head_\\<omega> n \\<Longrightarrow> m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> m < head_\\<omega> n \\<Longrightarrow> m < n", "unfolding head_\\<omega>_def hmsetmset_less[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset (if m = 0 then 0 else \\<omega>^ (Max_mset (hmsetmset m)))\n    < hmsetmset\n       (if n = 0 then 0\n        else \\<omega>^ (Max_mset (hmsetmset n))) \\<Longrightarrow>\n    hmsetmset m < hmsetmset n", "by (rule all_lt_Max_imp_lt_mset, auto simp: zero_hmultiset_def split: if_splits)"], ["", "lemma head_\\<omega>_plus[simp]: \"head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)", "proof (cases m n rule: hmultiset.exhaust[case_product hmultiset.exhaust])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> head_\\<omega> (m + n) =\n                         sup (head_\\<omega> m) (head_\\<omega> n)", "case m_n: (HMSet_HMSet M N)"], ["proof (state)\nthis:\n  m = HMSet M\n  n = HMSet N\n\ngoal (1 subgoal):\n 1. \\<And>x__ xa__.\n       \\<lbrakk>m = HMSet x__; n = HMSet xa__\\<rbrakk>\n       \\<Longrightarrow> head_\\<omega> (m + n) =\n                         sup (head_\\<omega> m) (head_\\<omega> n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)", "proof (cases \"Max_mset M < Max_mset N\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Max_mset M < Max_mset N \\<Longrightarrow>\n    head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)\n 2. \\<not> Max_mset M < Max_mset N \\<Longrightarrow>\n    head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)", "case True"], ["proof (state)\nthis:\n  Max_mset M < Max_mset N\n\ngoal (2 subgoals):\n 1. Max_mset M < Max_mset N \\<Longrightarrow>\n    head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)\n 2. \\<not> Max_mset M < Max_mset N \\<Longrightarrow>\n    head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Max_mset M < Max_mset N\n\ngoal (1 subgoal):\n 1. head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)", "unfolding m_n head_\\<omega>_def sup_hmultiset_def zero_hmultiset_def plus_hmultiset_def"], ["proof (prove)\nusing this:\n  Max_mset M < Max_mset N\n\ngoal (1 subgoal):\n 1. (if HMSet (hmsetmset (HMSet M) + hmsetmset (HMSet N)) = HMSet {#}\n     then HMSet {#}\n     else \\<omega>^\n           (Max_mset\n             (hmsetmset\n               (HMSet (hmsetmset (HMSet M) + hmsetmset (HMSet N)))))) =\n    (if (if HMSet M = HMSet {#} then HMSet {#}\n         else \\<omega>^ (Max_mset (hmsetmset (HMSet M))))\n        < (if HMSet N = HMSet {#} then HMSet {#}\n           else \\<omega>^ (Max_mset (hmsetmset (HMSet N))))\n     then if HMSet N = HMSet {#} then HMSet {#}\n          else \\<omega>^ (Max_mset (hmsetmset (HMSet N)))\n     else if HMSet M = HMSet {#} then HMSet {#}\n          else \\<omega>^ (Max_mset (hmsetmset (HMSet M))))", "by (simp add: Max.union max_def dual_order.strict_implies_order)"], ["proof (state)\nthis:\n  head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)\n\ngoal (1 subgoal):\n 1. \\<not> Max_mset M < Max_mset N \\<Longrightarrow>\n    head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Max_mset M < Max_mset N \\<Longrightarrow>\n    head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)", "case False"], ["proof (state)\nthis:\n  \\<not> Max_mset M < Max_mset N\n\ngoal (1 subgoal):\n 1. \\<not> Max_mset M < Max_mset N \\<Longrightarrow>\n    head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> Max_mset M < Max_mset N\n\ngoal (1 subgoal):\n 1. head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)", "unfolding m_n head_\\<omega>_def sup_hmultiset_def zero_hmultiset_def plus_hmultiset_def"], ["proof (prove)\nusing this:\n  \\<not> Max_mset M < Max_mset N\n\ngoal (1 subgoal):\n 1. (if HMSet (hmsetmset (HMSet M) + hmsetmset (HMSet N)) = HMSet {#}\n     then HMSet {#}\n     else \\<omega>^\n           (Max_mset\n             (hmsetmset\n               (HMSet (hmsetmset (HMSet M) + hmsetmset (HMSet N)))))) =\n    (if (if HMSet M = HMSet {#} then HMSet {#}\n         else \\<omega>^ (Max_mset (hmsetmset (HMSet M))))\n        < (if HMSet N = HMSet {#} then HMSet {#}\n           else \\<omega>^ (Max_mset (hmsetmset (HMSet N))))\n     then if HMSet N = HMSet {#} then HMSet {#}\n          else \\<omega>^ (Max_mset (hmsetmset (HMSet N)))\n     else if HMSet M = HMSet {#} then HMSet {#}\n          else \\<omega>^ (Max_mset (hmsetmset (HMSet M))))", "by simp (metis False Max.union finite_set_mset leI max_def set_mset_eq_empty_iff sup.commute)"], ["proof (state)\nthis:\n  head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  head_\\<omega> (m + n) = sup (head_\\<omega> m) (head_\\<omega> n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma head_\\<omega>_times[simp]: \"head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "proof (cases \"m = 0 \\<or> n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n 2. \\<not> (m = 0 \\<or> n = 0) \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "case False"], ["proof (state)\nthis:\n  \\<not> (m = 0 \\<or> n = 0)\n\ngoal (2 subgoals):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n 2. \\<not> (m = 0 \\<or> n = 0) \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "hence m_nz: \"m \\<noteq> 0\" and n_nz: \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (m = 0 \\<or> n = 0)\n\ngoal (1 subgoal):\n 1. m \\<noteq> 0 &&& n \\<noteq> 0", "by simp+"], ["proof (state)\nthis:\n  m \\<noteq> 0\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n 2. \\<not> (m = 0 \\<or> n = 0) \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "define \\<delta> where \"\\<delta> = hmsetmset m\""], ["proof (state)\nthis:\n  \\<delta> = hmsetmset m\n\ngoal (2 subgoals):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n 2. \\<not> (m = 0 \\<or> n = 0) \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "define \\<epsilon> where \"\\<epsilon> = hmsetmset n\""], ["proof (state)\nthis:\n  \\<epsilon> = hmsetmset n\n\ngoal (2 subgoals):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n 2. \\<not> (m = 0 \\<or> n = 0) \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "have \\<delta>_nemp: \"\\<delta> \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<noteq> {#}", "unfolding \\<delta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset m \\<noteq> {#}", "using m_nz"], ["proof (prove)\nusing this:\n  m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. hmsetmset m \\<noteq> {#}", "by simp"], ["proof (state)\nthis:\n  \\<delta> \\<noteq> {#}\n\ngoal (2 subgoals):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n 2. \\<not> (m = 0 \\<or> n = 0) \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "have \\<epsilon>_nemp: \"\\<epsilon> \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon> \\<noteq> {#}", "unfolding \\<epsilon>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset n \\<noteq> {#}", "using n_nz"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. hmsetmset n \\<noteq> {#}", "by simp"], ["proof (state)\nthis:\n  \\<epsilon> \\<noteq> {#}\n\ngoal (2 subgoals):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n 2. \\<not> (m = 0 \\<or> n = 0) \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "let ?D = \"set_mset \\<delta>\""], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n 2. \\<not> (m = 0 \\<or> n = 0) \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "let ?E = \"set_mset \\<epsilon>\""], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n 2. \\<not> (m = 0 \\<or> n = 0) \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "let ?DE = \"{z. \\<exists>x \\<in> ?D. \\<exists>y \\<in> ?E. z = x + y}\""], ["proof (state)\ngoal (2 subgoals):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n 2. \\<not> (m = 0 \\<or> n = 0) \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "have max_D_in: \"Max ?D \\<in> ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_mset \\<delta> \\<in># \\<delta>", "using \\<delta>_nemp"], ["proof (prove)\nusing this:\n  \\<delta> \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. Max_mset \\<delta> \\<in># \\<delta>", "by simp"], ["proof (state)\nthis:\n  Max_mset \\<delta> \\<in># \\<delta>\n\ngoal (2 subgoals):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n 2. \\<not> (m = 0 \\<or> n = 0) \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "have max_E_in: \"Max ?E \\<in> ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_mset \\<epsilon> \\<in># \\<epsilon>", "using \\<epsilon>_nemp"], ["proof (prove)\nusing this:\n  \\<epsilon> \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. Max_mset \\<epsilon> \\<in># \\<epsilon>", "by simp"], ["proof (state)\nthis:\n  Max_mset \\<epsilon> \\<in># \\<epsilon>\n\ngoal (2 subgoals):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n 2. \\<not> (m = 0 \\<or> n = 0) \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "have \"Max ?DE = Max ?D + Max ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {z. \\<exists>x\\<in>#\\<delta>.\n               \\<exists>y\\<in>#\\<epsilon>. z = x + y} =\n    Max_mset \\<delta> + Max_mset \\<epsilon>", "proof (rule order_antisym, goal_cases le ge)"], ["proof (state)\ngoal (2 subgoals):\n 1. Max {z. \\<exists>x\\<in>#\\<delta>. \\<exists>y\\<in>#\\<epsilon>. z = x + y}\n    \\<le> Max_mset \\<delta> + Max_mset \\<epsilon>\n 2. Max_mset \\<delta> + Max_mset \\<epsilon>\n    \\<le> Max {z. \\<exists>x\\<in>#\\<delta>.\n                     \\<exists>y\\<in>#\\<epsilon>. z = x + y}", "case le"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Max {z. \\<exists>x\\<in>#\\<delta>. \\<exists>y\\<in>#\\<epsilon>. z = x + y}\n    \\<le> Max_mset \\<delta> + Max_mset \\<epsilon>\n 2. Max_mset \\<delta> + Max_mset \\<epsilon>\n    \\<le> Max {z. \\<exists>x\\<in>#\\<delta>.\n                     \\<exists>y\\<in>#\\<epsilon>. z = x + y}", "have \"\\<And>x y. x \\<in> ?D \\<Longrightarrow> y \\<in> ?E \\<Longrightarrow> x + y \\<le> Max ?D + Max ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in># \\<delta>; y \\<in># \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> x + y \\<le> Max_mset \\<delta> + Max_mset \\<epsilon>", "by (simp add: add_mono)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in># \\<delta>; ?y \\<in># \\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<le> Max_mset \\<delta> + Max_mset \\<epsilon>\n\ngoal (2 subgoals):\n 1. Max {z. \\<exists>x\\<in>#\\<delta>. \\<exists>y\\<in>#\\<epsilon>. z = x + y}\n    \\<le> Max_mset \\<delta> + Max_mset \\<epsilon>\n 2. Max_mset \\<delta> + Max_mset \\<epsilon>\n    \\<le> Max {z. \\<exists>x\\<in>#\\<delta>.\n                     \\<exists>y\\<in>#\\<epsilon>. z = x + y}", "hence mem_imp_le: \"\\<And>z. z \\<in> ?DE \\<Longrightarrow> z \\<le> Max ?D + Max ?E\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in># \\<delta>; ?y \\<in># \\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> ?x + ?y \\<le> Max_mset \\<delta> + Max_mset \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<in> {z. \\<exists>x\\<in>#\\<delta>.\n                      \\<exists>y\\<in>#\\<epsilon>.\n                         z = x + y} \\<Longrightarrow>\n       z \\<le> Max_mset \\<delta> + Max_mset \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  ?z \\<in> {z. \\<exists>x\\<in>#\\<delta>.\n                  \\<exists>y\\<in>#\\<epsilon>. z = x + y} \\<Longrightarrow>\n  ?z \\<le> Max_mset \\<delta> + Max_mset \\<epsilon>\n\ngoal (2 subgoals):\n 1. Max {z. \\<exists>x\\<in>#\\<delta>. \\<exists>y\\<in>#\\<epsilon>. z = x + y}\n    \\<le> Max_mset \\<delta> + Max_mset \\<epsilon>\n 2. Max_mset \\<delta> + Max_mset \\<epsilon>\n    \\<le> Max {z. \\<exists>x\\<in>#\\<delta>.\n                     \\<exists>y\\<in>#\\<epsilon>. z = x + y}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {z. \\<exists>x\\<in>#\\<delta>. \\<exists>y\\<in>#\\<epsilon>. z = x + y}\n    \\<le> Max_mset \\<delta> + Max_mset \\<epsilon>", "by (intro mem_imp_le Max_in, simp, use \\<delta>_nemp \\<epsilon>_nemp in fast)"], ["proof (state)\nthis:\n  Max {z. \\<exists>x\\<in>#\\<delta>. \\<exists>y\\<in>#\\<epsilon>. z = x + y}\n  \\<le> Max_mset \\<delta> + Max_mset \\<epsilon>\n\ngoal (1 subgoal):\n 1. Max_mset \\<delta> + Max_mset \\<epsilon>\n    \\<le> Max {z. \\<exists>x\\<in>#\\<delta>.\n                     \\<exists>y\\<in>#\\<epsilon>. z = x + y}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Max_mset \\<delta> + Max_mset \\<epsilon>\n    \\<le> Max {z. \\<exists>x\\<in>#\\<delta>.\n                     \\<exists>y\\<in>#\\<epsilon>. z = x + y}", "case ge"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. Max_mset \\<delta> + Max_mset \\<epsilon>\n    \\<le> Max {z. \\<exists>x\\<in>#\\<delta>.\n                     \\<exists>y\\<in>#\\<epsilon>. z = x + y}", "have \"{z. \\<exists>x \\<in> {Max ?D}. \\<exists>y \\<in> {Max ?E}. z = x + y} \\<subseteq> {z. \\<exists>x \\<in># \\<delta>. \\<exists>y \\<in># \\<epsilon>. z = x + y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {z. \\<exists>x\\<in>{Max_mset \\<delta>}.\n           \\<exists>y\\<in>{Max_mset \\<epsilon>}. z = x + y}\n    \\<subseteq> {z. \\<exists>x\\<in>#\\<delta>.\n                       \\<exists>y\\<in>#\\<epsilon>. z = x + y}", "using max_D_in max_E_in"], ["proof (prove)\nusing this:\n  Max_mset \\<delta> \\<in># \\<delta>\n  Max_mset \\<epsilon> \\<in># \\<epsilon>\n\ngoal (1 subgoal):\n 1. {z. \\<exists>x\\<in>{Max_mset \\<delta>}.\n           \\<exists>y\\<in>{Max_mset \\<epsilon>}. z = x + y}\n    \\<subseteq> {z. \\<exists>x\\<in>#\\<delta>.\n                       \\<exists>y\\<in>#\\<epsilon>. z = x + y}", "by fast"], ["proof (state)\nthis:\n  {z. \\<exists>x\\<in>{Max_mset \\<delta>}.\n         \\<exists>y\\<in>{Max_mset \\<epsilon>}. z = x + y}\n  \\<subseteq> {z. \\<exists>x\\<in>#\\<delta>.\n                     \\<exists>y\\<in>#\\<epsilon>. z = x + y}\n\ngoal (1 subgoal):\n 1. Max_mset \\<delta> + Max_mset \\<epsilon>\n    \\<le> Max {z. \\<exists>x\\<in>#\\<delta>.\n                     \\<exists>y\\<in>#\\<epsilon>. z = x + y}", "thus ?case"], ["proof (prove)\nusing this:\n  {z. \\<exists>x\\<in>{Max_mset \\<delta>}.\n         \\<exists>y\\<in>{Max_mset \\<epsilon>}. z = x + y}\n  \\<subseteq> {z. \\<exists>x\\<in>#\\<delta>.\n                     \\<exists>y\\<in>#\\<epsilon>. z = x + y}\n\ngoal (1 subgoal):\n 1. Max_mset \\<delta> + Max_mset \\<epsilon>\n    \\<le> Max {z. \\<exists>x\\<in>#\\<delta>.\n                     \\<exists>y\\<in>#\\<epsilon>. z = x + y}", "by simp"], ["proof (state)\nthis:\n  Max_mset \\<delta> + Max_mset \\<epsilon>\n  \\<le> Max {z. \\<exists>x\\<in>#\\<delta>.\n                   \\<exists>y\\<in>#\\<epsilon>. z = x + y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Max {z. \\<exists>x\\<in>#\\<delta>. \\<exists>y\\<in>#\\<epsilon>. z = x + y} =\n  Max_mset \\<delta> + Max_mset \\<epsilon>\n\ngoal (2 subgoals):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n 2. \\<not> (m = 0 \\<or> n = 0) \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "thus ?thesis"], ["proof (prove)\nusing this:\n  Max {z. \\<exists>x\\<in>#\\<delta>. \\<exists>y\\<in>#\\<epsilon>. z = x + y} =\n  Max_mset \\<delta> + Max_mset \\<epsilon>\n\ngoal (1 subgoal):\n 1. head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "unfolding \\<delta>_def \\<epsilon>_def"], ["proof (prove)\nusing this:\n  Max {z. \\<exists>x\\<in>#hmsetmset m.\n             \\<exists>y\\<in>#hmsetmset n. z = x + y} =\n  Max_mset (hmsetmset m) + Max_mset (hmsetmset n)\n\ngoal (1 subgoal):\n 1. head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "by (auto simp: head_\\<omega>_def image_def times_hmultiset_def)"], ["proof (state)\nthis:\n  head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n\n\ngoal (1 subgoal):\n 1. m = 0 \\<or> n = 0 \\<Longrightarrow>\n    head_\\<omega> (m * n) = head_\\<omega> m * head_\\<omega> n", "qed auto"], ["", "subsection \\<open>More Inequalities and Some Equalities\\<close>"], ["", "lemma zero_lt_\\<omega>[simp]: \"0 < \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<omega>", "by (metis of_nat_lt_\\<omega> of_nat_0)"], ["", "lemma one_lt_\\<omega>[simp]: \"1 < \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < \\<omega>", "by (metis enat_defs(2) hmset_of_enat.simps(1) hmset_of_enat_1 of_nat_lt_\\<omega>)"], ["", "lemma numeral_lt_\\<omega>[simp]: \"numeral n < \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n < \\<omega>", "using hmset_of_enat_numeral[symmetric] hmset_of_enat.simps(1) of_nat_lt_\\<omega> numeral_eq_enat"], ["proof (prove)\nusing this:\n  numeral ?n = hmset_of_enat (numeral ?n)\n  hmset_of_enat (enat ?n) = of_nat ?n\n  of_nat ?n < \\<omega>\n  numeral ?k = enat (numeral ?k)\n\ngoal (1 subgoal):\n 1. numeral n < \\<omega>", "by presburger"], ["", "lemma one_le_\\<omega>[simp]: \"1 \\<le> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> \\<omega>", "by (simp add: less_imp_le)"], ["", "lemma of_nat_le_\\<omega>[simp]: \"of_nat n \\<le> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat n \\<le> \\<omega>", "by (simp add: le_less)"], ["", "lemma numeral_le_\\<omega>[simp]: \"numeral n \\<le> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n \\<le> \\<omega>", "by (simp add: less_imp_le)"], ["", "lemma not_\\<omega>_lt_1[simp]: \"\\<not> \\<omega> < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<omega> < 1", "by (simp add: not_less)"], ["", "lemma not_\\<omega>_lt_of_nat[simp]: \"\\<not> \\<omega> < of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<omega> < of_nat n", "by (simp add: not_less)"], ["", "lemma not_\\<omega>_lt_numeral[simp]: \"\\<not> \\<omega> < numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<omega> < numeral n", "by (simp add: not_less)"], ["", "lemma not_\\<omega>_le_1[simp]: \"\\<not> \\<omega> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<omega> \\<le> 1", "by (simp add: not_le)"], ["", "lemma not_\\<omega>_le_of_nat[simp]: \"\\<not> \\<omega> \\<le> of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<omega> \\<le> of_nat n", "by (simp add: not_le)"], ["", "lemma not_\\<omega>_le_numeral[simp]: \"\\<not> \\<omega> \\<le> numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<omega> \\<le> numeral n", "by (simp add: not_le)"], ["", "lemma zero_ne_\\<omega>[simp]: \"0 \\<noteq> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> \\<omega>", "by (metis not_\\<omega>_le_1 zero_le_hmset)"], ["", "lemma one_ne_\\<omega>[simp]: \"1 \\<noteq> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<noteq> \\<omega>", "using not_\\<omega>_le_1"], ["proof (prove)\nusing this:\n  \\<not> \\<omega> \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 \\<noteq> \\<omega>", "by force"], ["", "lemma numeral_ne_\\<omega>[simp]: \"numeral n \\<noteq> \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. numeral n \\<noteq> \\<omega>", "by (metis not_\\<omega>_le_numeral numeral_le_\\<omega>)"], ["", "lemma\n  \\<omega>_ne_0[simp]: \"\\<omega> \\<noteq> 0\" and\n  \\<omega>_ne_1[simp]: \"\\<omega> \\<noteq> 1\" and\n  \\<omega>_ne_of_nat[simp]: \"\\<omega> \\<noteq> of_nat m\" and\n  \\<omega>_ne_numeral[simp]: \"\\<omega> \\<noteq> numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<omega> \\<noteq> 0 &&& \\<omega> \\<noteq> 1) &&&\n    \\<omega> \\<noteq> of_nat m &&& \\<omega> \\<noteq> numeral n", "using zero_ne_\\<omega> one_ne_\\<omega> of_nat_ne_\\<omega> numeral_ne_\\<omega>"], ["proof (prove)\nusing this:\n  0 \\<noteq> \\<omega>\n  1 \\<noteq> \\<omega>\n  of_nat ?n \\<noteq> \\<omega>\n  numeral ?n \\<noteq> \\<omega>\n\ngoal (1 subgoal):\n 1. (\\<omega> \\<noteq> 0 &&& \\<omega> \\<noteq> 1) &&&\n    \\<omega> \\<noteq> of_nat m &&& \\<omega> \\<noteq> numeral n", "by metis+"], ["", "lemma\n  hmset_of_enat_inject[simp]: \"hmset_of_enat m = hmset_of_enat n \\<longleftrightarrow> m = n\" and\n  hmset_of_enat_less[simp]: \"hmset_of_enat m < hmset_of_enat n \\<longleftrightarrow> m < n\" and\n  hmset_of_enat_le[simp]: \"hmset_of_enat m \\<le> hmset_of_enat n \\<longleftrightarrow> m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hmset_of_enat m = hmset_of_enat n) = (m = n) &&&\n    (hmset_of_enat m < hmset_of_enat n) = (m < n) &&&\n    (hmset_of_enat m \\<le> hmset_of_enat n) = (m \\<le> n)", "by (cases m; cases n; simp)+"], ["", "lemma lt_\\<omega>_imp_ex_of_nat:\n  assumes M_lt_\\<omega>: \"M < \\<omega>\"\n  shows \"\\<exists>n. M = of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. M = of_nat n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. M = of_nat n", "have M_lt_single_1: \"hmsetmset M < {#1#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset M < {#1#}", "by (rule M_lt_\\<omega>[unfolded hmsetmset_less[symmetric] less_multiset_ext\\<^sub>D\\<^sub>M_less hmultiset.sel])"], ["proof (state)\nthis:\n  hmsetmset M < {#1#}\n\ngoal (1 subgoal):\n 1. \\<exists>n. M = of_nat n", "have \"N = 0\" if \"N \\<in># hmsetmset M\" for N"], ["proof (prove)\ngoal (1 subgoal):\n 1. N = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. N = 0", "have \"0 < count (hmsetmset M) N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < count (hmsetmset M) N", "using that"], ["proof (prove)\nusing this:\n  N \\<in># hmsetmset M\n\ngoal (1 subgoal):\n 1. 0 < count (hmsetmset M) N", "by auto"], ["proof (state)\nthis:\n  0 < count (hmsetmset M) N\n\ngoal (1 subgoal):\n 1. N = 0", "hence \"N < 1\""], ["proof (prove)\nusing this:\n  0 < count (hmsetmset M) N\n\ngoal (1 subgoal):\n 1. N < 1", "by (metis (no_types) M_lt_single_1 count_single gr_implies_not0 less_eq_multiset\\<^sub>H\\<^sub>O less_one\n        neq_iff not_le)"], ["proof (state)\nthis:\n  N < 1\n\ngoal (1 subgoal):\n 1. N = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  N < 1\n\ngoal (1 subgoal):\n 1. N = 0", "by (simp add: lt_1_iff_eq_0_hmset)"], ["proof (state)\nthis:\n  N = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?N \\<in># hmsetmset M \\<Longrightarrow> ?N = 0\n\ngoal (1 subgoal):\n 1. \\<exists>n. M = of_nat n", "then"], ["proof (chain)\npicking this:\n  ?N \\<in># hmsetmset M \\<Longrightarrow> ?N = 0", "obtain n where hmmM: \"M = HMSet (replicate_mset n 0)\""], ["proof (prove)\nusing this:\n  ?N \\<in># hmsetmset M \\<Longrightarrow> ?N = 0\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        M = HMSet (replicate_mset n 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_replicate_mset_if_all_elems_eq"], ["proof (prove)\nusing this:\n  ?N \\<in># hmsetmset M \\<Longrightarrow> ?N = 0\n  \\<forall>x\\<in>#?M. x = ?y \\<Longrightarrow>\n  \\<exists>n. ?M = replicate_mset n ?y\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        M = HMSet (replicate_mset n 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis hmultiset.collapse)"], ["proof (state)\nthis:\n  M = HMSet (replicate_mset n 0)\n\ngoal (1 subgoal):\n 1. \\<exists>n. M = of_nat n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. M = of_nat n", "unfolding hmmM of_nat_hmset"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>na. HMSet (replicate_mset n 0) = HMSet (replicate_mset na 0)", "by blast"], ["proof (state)\nthis:\n  \\<exists>n. M = of_nat n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_\\<omega>_imp_ex_hmset_of_enat:\n  assumes M_le_\\<omega>: \"M \\<le> \\<omega>\"\n  shows \"\\<exists>n. M = hmset_of_enat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. M = hmset_of_enat n", "proof (cases \"M = \\<omega>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. M = \\<omega> \\<Longrightarrow> \\<exists>n. M = hmset_of_enat n\n 2. M \\<noteq> \\<omega> \\<Longrightarrow> \\<exists>n. M = hmset_of_enat n", "case True"], ["proof (state)\nthis:\n  M = \\<omega>\n\ngoal (2 subgoals):\n 1. M = \\<omega> \\<Longrightarrow> \\<exists>n. M = hmset_of_enat n\n 2. M \\<noteq> \\<omega> \\<Longrightarrow> \\<exists>n. M = hmset_of_enat n", "thus ?thesis"], ["proof (prove)\nusing this:\n  M = \\<omega>\n\ngoal (1 subgoal):\n 1. \\<exists>n. M = hmset_of_enat n", "by (metis hmset_of_enat.simps(2))"], ["proof (state)\nthis:\n  \\<exists>n. M = hmset_of_enat n\n\ngoal (1 subgoal):\n 1. M \\<noteq> \\<omega> \\<Longrightarrow> \\<exists>n. M = hmset_of_enat n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<noteq> \\<omega> \\<Longrightarrow> \\<exists>n. M = hmset_of_enat n", "case False"], ["proof (state)\nthis:\n  M \\<noteq> \\<omega>\n\ngoal (1 subgoal):\n 1. M \\<noteq> \\<omega> \\<Longrightarrow> \\<exists>n. M = hmset_of_enat n", "thus ?thesis"], ["proof (prove)\nusing this:\n  M \\<noteq> \\<omega>\n\ngoal (1 subgoal):\n 1. \\<exists>n. M = hmset_of_enat n", "using M_le_\\<omega> lt_\\<omega>_imp_ex_of_nat"], ["proof (prove)\nusing this:\n  M \\<noteq> \\<omega>\n  M \\<le> \\<omega>\n  ?M < \\<omega> \\<Longrightarrow> \\<exists>n. ?M = of_nat n\n\ngoal (1 subgoal):\n 1. \\<exists>n. M = hmset_of_enat n", "by (metis hmset_of_enat.simps(1) le_less)"], ["proof (state)\nthis:\n  \\<exists>n. M = hmset_of_enat n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lt_\\<omega>_lt_\\<omega>_imp_times_lt_\\<omega>: \"M < \\<omega> \\<Longrightarrow> N < \\<omega> \\<Longrightarrow> M * N < \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M < \\<omega>; N < \\<omega>\\<rbrakk>\n    \\<Longrightarrow> M * N < \\<omega>", "by (metis lt_\\<omega>_imp_ex_of_nat of_nat_lt_\\<omega> of_nat_mult)"], ["", "lemma times_\\<omega>_minus_of_nat[simp]: \"m * \\<omega> - of_nat n = m * \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m * \\<omega> - of_nat n = m * \\<omega>", "by (auto intro!: Diff_triv_mset simp: times_hmultiset_def minus_hmultiset_def\n    Times_mset_single_right of_nat_hmset disjunct_not_in image_def)"], ["", "lemma times_\\<omega>_minus_numeral[simp]: \"m * \\<omega> - numeral n = m * \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m * \\<omega> - numeral n = m * \\<omega>", "by (metis of_nat_numeral times_\\<omega>_minus_of_nat)"], ["", "lemma \\<omega>_minus_of_nat[simp]: \"\\<omega> - of_nat n = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> - of_nat n = \\<omega>", "using times_\\<omega>_minus_of_nat[of 1]"], ["proof (prove)\nusing this:\n  1 * \\<omega> - of_nat ?n = 1 * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> - of_nat n = \\<omega>", "by (metis mult.left_neutral)"], ["", "lemma \\<omega>_minus_1[simp]: \"\\<omega> - 1 = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> - 1 = \\<omega>", "using \\<omega>_minus_of_nat[of 1]"], ["proof (prove)\nusing this:\n  \\<omega> - of_nat 1 = \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> - 1 = \\<omega>", "by simp"], ["", "lemma \\<omega>_minus_numeral[simp]: \"\\<omega> - numeral n = \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> - numeral n = \\<omega>", "using times_\\<omega>_minus_numeral[of 1]"], ["proof (prove)\nusing this:\n  1 * \\<omega> - numeral ?n = 1 * \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> - numeral n = \\<omega>", "by (metis mult.left_neutral)"], ["", "lemma hmset_of_enat_minus_enat[simp]: \"hmset_of_enat (m - enat n) = hmset_of_enat m - of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hmset_of_enat (m - enat n) = hmset_of_enat m - of_nat n", "by (cases m) (auto simp: of_nat_minus_hmset)"], ["", "lemma of_nat_lt_hmset_of_enat_iff: \"of_nat m < hmset_of_enat n \\<longleftrightarrow> enat m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat m < hmset_of_enat n) = (enat m < n)", "by (metis hmset_of_enat.simps(1) hmset_of_enat_less)"], ["", "lemma of_nat_le_hmset_of_enat_iff: \"of_nat m \\<le> hmset_of_enat n \\<longleftrightarrow> enat m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat m \\<le> hmset_of_enat n) = (enat m \\<le> n)", "by (metis hmset_of_enat.simps(1) hmset_of_enat_le)"], ["", "lemma hmset_of_enat_lt_iff_ne_infinity: \"hmset_of_enat x < \\<omega> \\<longleftrightarrow> x \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hmset_of_enat x < \\<omega>) = (x \\<noteq> \\<infinity>)", "by (cases x; simp)"], ["", "lemma minus_diff_sym_hmset: \"m - (m - n) = n - (n - m)\" for m n :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. m - (m - n) = n - (n - m)", "unfolding minus_hmultiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. HMSet (hmsetmset m - hmsetmset (HMSet (hmsetmset m - hmsetmset n))) =\n    HMSet (hmsetmset n - hmsetmset (HMSet (hmsetmset n - hmsetmset m)))", "by simp (metis multiset_inter_def subset_mset.inf_aci(1))"], ["", "lemma diff_plus_sym_hmset: \"(c - b) + b = (b - c) + c\" for b c :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. c - b + b = b - c + c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c - b + b = b - c + c", "have f1: \"\\<And>h ha :: hmultiset. h - (ha + h) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h ha. h - (ha + h) = 0", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  ?h - (?ha + ?h) = 0\n\ngoal (1 subgoal):\n 1. c - b + b = b - c + c", "have f2: \"\\<And>h ha hb :: hmultiset. h + ha - (h - hb) = hb + ha - (hb - h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h ha hb. h + ha - (h - hb) = hb + ha - (hb - h)", "by (metis (no_types) add_diff_cancel_right minus_diff_sym_hmset)"], ["proof (state)\nthis:\n  ?h + ?ha - (?h - ?hb) = ?hb + ?ha - (?hb - ?h)\n\ngoal (1 subgoal):\n 1. c - b + b = b - c + c", "have \"\\<And>h ha hb :: hmultiset. h + (ha + hb) - hb = h + ha\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h ha hb. h + (ha + hb) - hb = h + ha", "by (metis (no_types) add.assoc add_diff_cancel_right')"], ["proof (state)\nthis:\n  ?h + (?ha + ?hb) - ?hb = ?h + ?ha\n\ngoal (1 subgoal):\n 1. c - b + b = b - c + c", "then"], ["proof (chain)\npicking this:\n  ?h + (?ha + ?hb) - ?hb = ?h + ?ha", "show ?thesis"], ["proof (prove)\nusing this:\n  ?h + (?ha + ?hb) - ?hb = ?h + ?ha\n\ngoal (1 subgoal):\n 1. c - b + b = b - c + c", "using f2 f1"], ["proof (prove)\nusing this:\n  ?h + (?ha + ?hb) - ?hb = ?h + ?ha\n  ?h + ?ha - (?h - ?hb) = ?hb + ?ha - (?hb - ?h)\n  ?h - (?ha + ?h) = 0\n\ngoal (1 subgoal):\n 1. c - b + b = b - c + c", "by (metis (no_types) add.commute add.right_neutral diff_diff_add_hmset)"], ["proof (state)\nthis:\n  c - b + b = b - c + c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma times_diff_plus_sym_hmset: \"a * (c - b) + a * b = a * (b - c) + a * c\" for a b c :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (c - b) + a * b = a * (b - c) + a * c", "by (metis distrib_left diff_plus_sym_hmset)"], ["", "lemma times_of_nat_minus_left:\n  \"(of_nat m - of_nat n) * l = of_nat m * l - of_nat n * l\" for l :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat m - of_nat n) * l = of_nat m * l - of_nat n * l", "by (induct n m rule: diff_induct) (auto simp: ring_distribs)"], ["", "lemma times_of_nat_minus_right:\n  \"l * (of_nat m - of_nat n) = l * of_nat m - l * of_nat n\" for l :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. l * (of_nat m - of_nat n) = l * of_nat m - l * of_nat n", "by (metis times_of_nat_minus_left mult.commute)"], ["", "lemma lt_\\<omega>_imp_times_minus_left: \"m < \\<omega> \\<Longrightarrow> n < \\<omega> \\<Longrightarrow> (m - n) * l = m * l - n * l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < \\<omega>; n < \\<omega>\\<rbrakk>\n    \\<Longrightarrow> (m - n) * l = m * l - n * l", "by (metis lt_\\<omega>_imp_ex_of_nat times_of_nat_minus_left)"], ["", "lemma lt_\\<omega>_imp_times_minus_right: \"m < \\<omega> \\<Longrightarrow> n < \\<omega> \\<Longrightarrow> l * (m - n) = l * m - l * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m < \\<omega>; n < \\<omega>\\<rbrakk>\n    \\<Longrightarrow> l * (m - n) = l * m - l * n", "by (metis lt_\\<omega>_imp_ex_of_nat times_of_nat_minus_right)"], ["", "lemma hmset_pair_decompose:\n  \"\\<exists>k n1 n2. m1 = k + n1 \\<and> m2 = k + n2 \\<and> (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or> n1 = 0 \\<and> n2 = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n        n1 = 0 \\<and> n2 = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n        n1 = 0 \\<and> n2 = 0)", "define n1 where n1: \"n1 = m1 - m2\""], ["proof (state)\nthis:\n  n1 = m1 - m2\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n        n1 = 0 \\<and> n2 = 0)", "define n2 where n2: \"n2 = m2 - m1\""], ["proof (state)\nthis:\n  n2 = m2 - m1\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n        n1 = 0 \\<and> n2 = 0)", "define k where k1: \"k = m1 - n1\""], ["proof (state)\nthis:\n  k = m1 - n1\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n        n1 = 0 \\<and> n2 = 0)", "have k2: \"k = m2 - n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = m2 - n2", "using k1"], ["proof (prove)\nusing this:\n  k = m1 - n1\n\ngoal (1 subgoal):\n 1. k = m2 - n2", "unfolding n1 n2"], ["proof (prove)\nusing this:\n  k = m1 - (m1 - m2)\n\ngoal (1 subgoal):\n 1. k = m2 - (m2 - m1)", "by (simp add: minus_diff_sym_hmset)"], ["proof (state)\nthis:\n  k = m2 - n2\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n        n1 = 0 \\<and> n2 = 0)", "have \"m1 = k + n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 = k + n1", "unfolding k1"], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 = m1 - n1 + n1", "by (metis (no_types) n1 add_diff_cancel_left add.commute add_diff_cancel_right' diff_add_zero\n      diff_diff_add minus_diff_sym_hmset)"], ["proof (state)\nthis:\n  m1 = k + n1\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n        n1 = 0 \\<and> n2 = 0)", "moreover"], ["proof (state)\nthis:\n  m1 = k + n1\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n        n1 = 0 \\<and> n2 = 0)", "have \"m2 = k + n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m2 = k + n2", "unfolding k2"], ["proof (prove)\ngoal (1 subgoal):\n 1. m2 = m2 - n2 + n2", "by (metis n2 add.commute add_diff_cancel_left add_diff_cancel_left' add_diff_cancel_right'\n      diff_add_zero diff_diff_add diff_zero k2 minus_diff_sym_hmset)"], ["proof (state)\nthis:\n  m2 = k + n2\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n        n1 = 0 \\<and> n2 = 0)", "moreover"], ["proof (state)\nthis:\n  m2 = k + n2\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n        n1 = 0 \\<and> n2 = 0)", "have hd_n: \"head_\\<omega> n1 \\<noteq> head_\\<omega> n2\" if n1_or_n2_nz: \"n1 \\<noteq> 0 \\<or> n2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "proof (cases \"n1 = 0\" \"n2 = 0\" rule: bool.exhaust[case_product bool.exhaust])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 2. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 3. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 4. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "case False_False"], ["proof (state)\nthis:\n  (n1 = 0) = False\n  (n2 = 0) = False\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 2. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 3. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 4. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "note n1_nz = this(1)[simplified] and n2_nz = this(2)[simplified]"], ["proof (state)\nthis:\n  n1 \\<noteq> 0\n  n2 \\<noteq> 0\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 2. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 3. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 4. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "define \\<delta>1 where \"\\<delta>1 = hmsetmset n1\""], ["proof (state)\nthis:\n  \\<delta>1 = hmsetmset n1\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 2. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 3. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 4. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "define \\<delta>2 where \"\\<delta>2 = hmsetmset n2\""], ["proof (state)\nthis:\n  \\<delta>2 = hmsetmset n2\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 2. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 3. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 4. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "have \\<delta>1_inter_\\<delta>2: \"\\<delta>1 \\<inter># \\<delta>2 = {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>1 \\<inter># \\<delta>2 = {#}", "unfolding \\<delta>1_def \\<delta>2_def n1 n2 minus_hmultiset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset (HMSet (hmsetmset m1 - hmsetmset m2)) \\<inter>#\n    hmsetmset (HMSet (hmsetmset m2 - hmsetmset m1)) =\n    {#}", "by (simp add: diff_intersect_sym_diff)"], ["proof (state)\nthis:\n  \\<delta>1 \\<inter># \\<delta>2 = {#}\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 2. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 3. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 4. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "have \\<delta>1_ne: \"\\<delta>1 \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>1 \\<noteq> {#}", "unfolding \\<delta>1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset n1 \\<noteq> {#}", "using n1_nz"], ["proof (prove)\nusing this:\n  n1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. hmsetmset n1 \\<noteq> {#}", "by simp"], ["proof (state)\nthis:\n  \\<delta>1 \\<noteq> {#}\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 2. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 3. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 4. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "have \\<delta>2_ne: \"\\<delta>2 \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>2 \\<noteq> {#}", "unfolding \\<delta>2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hmsetmset n2 \\<noteq> {#}", "using n2_nz"], ["proof (prove)\nusing this:\n  n2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. hmsetmset n2 \\<noteq> {#}", "by simp"], ["proof (state)\nthis:\n  \\<delta>2 \\<noteq> {#}\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 2. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 3. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 4. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "have max_\\<delta>1: \"Max (set_mset \\<delta>1) \\<in># \\<delta>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_mset \\<delta>1 \\<in># \\<delta>1", "using \\<delta>1_ne"], ["proof (prove)\nusing this:\n  \\<delta>1 \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. Max_mset \\<delta>1 \\<in># \\<delta>1", "by simp"], ["proof (state)\nthis:\n  Max_mset \\<delta>1 \\<in># \\<delta>1\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 2. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 3. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 4. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "have max_\\<delta>2: \"Max (set_mset \\<delta>2) \\<in># \\<delta>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_mset \\<delta>2 \\<in># \\<delta>2", "using \\<delta>2_ne"], ["proof (prove)\nusing this:\n  \\<delta>2 \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. Max_mset \\<delta>2 \\<in># \\<delta>2", "by simp"], ["proof (state)\nthis:\n  Max_mset \\<delta>2 \\<in># \\<delta>2\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 2. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 3. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 4. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "have max_\\<delta>1_ne_\\<delta>2: \"Max (set_mset \\<delta>1) \\<noteq> Max (set_mset \\<delta>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_mset \\<delta>1 \\<noteq> Max_mset \\<delta>2", "using \\<delta>1_inter_\\<delta>2 disjunct_not_in max_\\<delta>1 max_\\<delta>2"], ["proof (prove)\nusing this:\n  \\<delta>1 \\<inter># \\<delta>2 = {#}\n  (?A \\<inter># ?B = {#}) =\n  (\\<forall>a. a \\<notin># ?A \\<or> a \\<notin># ?B)\n  Max_mset \\<delta>1 \\<in># \\<delta>1\n  Max_mset \\<delta>2 \\<in># \\<delta>2\n\ngoal (1 subgoal):\n 1. Max_mset \\<delta>1 \\<noteq> Max_mset \\<delta>2", "by force"], ["proof (state)\nthis:\n  Max_mset \\<delta>1 \\<noteq> Max_mset \\<delta>2\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 2. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 3. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 4. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "using n1_nz n2_nz"], ["proof (prove)\nusing this:\n  n1 \\<noteq> 0\n  n2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "by (cases n1 rule: hmultiset.exhaust_sel, cases n2 rule: hmultiset.exhaust_sel,\n        auto simp: head_\\<omega>_def zero_hmultiset_def max_\\<delta>1_ne_\\<delta>2[unfolded \\<delta>1_def \\<delta>2_def])"], ["proof (state)\nthis:\n  head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n\ngoal (3 subgoals):\n 1. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 2. \\<lbrakk>(n1 = 0) = True; (n2 = 0) = False\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n 3. \\<lbrakk>(n1 = 0) = False; (n2 = 0) = True\\<rbrakk>\n    \\<Longrightarrow> head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "qed (use n1_or_n2_nz in \\<open>auto simp: head_\\<omega>_def\\<close>)"], ["proof (state)\nthis:\n  n1 \\<noteq> 0 \\<or> n2 \\<noteq> 0 \\<Longrightarrow>\n  head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n        n1 = 0 \\<and> n2 = 0)", "ultimately"], ["proof (chain)\npicking this:\n  m1 = k + n1\n  m2 = k + n2\n  n1 \\<noteq> 0 \\<or> n2 \\<noteq> 0 \\<Longrightarrow>\n  head_\\<omega> n1 \\<noteq> head_\\<omega> n2", "show ?thesis"], ["proof (prove)\nusing this:\n  m1 = k + n1\n  m2 = k + n2\n  n1 \\<noteq> 0 \\<or> n2 \\<noteq> 0 \\<Longrightarrow>\n  head_\\<omega> n1 \\<noteq> head_\\<omega> n2\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n        n1 = 0 \\<and> n2 = 0)", "by blast"], ["proof (state)\nthis:\n  \\<exists>k n1 n2.\n     m1 = k + n1 \\<and>\n     m2 = k + n2 \\<and>\n     (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or> n1 = 0 \\<and> n2 = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hmset_pair_decompose_less:\n  assumes m1_lt_m2: \"m1 < m2\"\n  shows \"\\<exists>k n1 n2. m1 = k + n1 \\<and> m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "obtain k n1 n2 where\n    m1: \"m1 = k + n1\" and\n    m2: \"m2 = k + n2\" and\n    hds: \"head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or> n1 = 0 \\<and> n2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k n1 n2.\n        \\<lbrakk>m1 = k + n1; m2 = k + n2;\n         head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n         n1 = 0 \\<and> n2 = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hmset_pair_decompose[of m1 m2]"], ["proof (prove)\nusing this:\n  \\<exists>k n1 n2.\n     m1 = k + n1 \\<and>\n     m2 = k + n2 \\<and>\n     (head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or> n1 = 0 \\<and> n2 = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>k n1 n2.\n        \\<lbrakk>m1 = k + n1; m2 = k + n2;\n         head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or>\n         n1 = 0 \\<and> n2 = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m1 = k + n1\n  m2 = k + n2\n  head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or> n1 = 0 \\<and> n2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "{"], ["proof (state)\nthis:\n  m1 = k + n1\n  m2 = k + n2\n  head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or> n1 = 0 \\<and> n2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "assume \"n1 = 0\" and \"n2 = 0\""], ["proof (state)\nthis:\n  n1 = 0\n  n2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "hence \"m1 = m2\""], ["proof (prove)\nusing this:\n  n1 = 0\n  n2 = 0\n\ngoal (1 subgoal):\n 1. m1 = m2", "unfolding m1 m2"], ["proof (prove)\nusing this:\n  n1 = 0\n  n2 = 0\n\ngoal (1 subgoal):\n 1. k + n1 = k + n2", "by simp"], ["proof (state)\nthis:\n  m1 = m2\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "hence False"], ["proof (prove)\nusing this:\n  m1 = m2\n\ngoal (1 subgoal):\n 1. False", "using m1_lt_m2"], ["proof (prove)\nusing this:\n  m1 = m2\n  m1 < m2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "}"], ["proof (state)\nthis:\n  \\<lbrakk>n1 = 0; n2 = 0\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>n1 = 0; n2 = 0\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "{"], ["proof (state)\nthis:\n  \\<lbrakk>n1 = 0; n2 = 0\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "assume \"head_\\<omega> n1 > head_\\<omega> n2\""], ["proof (state)\nthis:\n  head_\\<omega> n2 < head_\\<omega> n1\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "hence \"n1 > n2\""], ["proof (prove)\nusing this:\n  head_\\<omega> n2 < head_\\<omega> n1\n\ngoal (1 subgoal):\n 1. n2 < n1", "by (rule head_\\<omega>_lt_imp_lt)"], ["proof (state)\nthis:\n  n2 < n1\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "hence \"m1 > m2\""], ["proof (prove)\nusing this:\n  n2 < n1\n\ngoal (1 subgoal):\n 1. m2 < m1", "unfolding m1 m2"], ["proof (prove)\nusing this:\n  n2 < n1\n\ngoal (1 subgoal):\n 1. k + n2 < k + n1", "by simp"], ["proof (state)\nthis:\n  m2 < m1\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "hence False"], ["proof (prove)\nusing this:\n  m2 < m1\n\ngoal (1 subgoal):\n 1. False", "using m1_lt_m2"], ["proof (prove)\nusing this:\n  m2 < m1\n  m1 < m2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "}"], ["proof (state)\nthis:\n  head_\\<omega> n2 < head_\\<omega> n1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>n1 = 0; n2 = 0\\<rbrakk> \\<Longrightarrow> False\n  head_\\<omega> n2 < head_\\<omega> n1 \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>n1 = 0; n2 = 0\\<rbrakk> \\<Longrightarrow> False\n  head_\\<omega> n2 < head_\\<omega> n1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "using m1 m2 hds"], ["proof (prove)\nusing this:\n  \\<lbrakk>n1 = 0; n2 = 0\\<rbrakk> \\<Longrightarrow> False\n  head_\\<omega> n2 < head_\\<omega> n1 \\<Longrightarrow> False\n  m1 = k + n1\n  m2 = k + n2\n  head_\\<omega> n1 \\<noteq> head_\\<omega> n2 \\<or> n1 = 0 \\<and> n2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2", "by (blast elim: neqE)"], ["proof (state)\nthis:\n  \\<exists>k n1 n2.\n     m1 = k + n1 \\<and>\n     m2 = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hmset_pair_decompose_less_eq:\n  assumes \"m1 \\<le> m2\"\n  shows \"\\<exists>k n1 n2. m1 = k + n1 \\<and> m2 = k + n2 \\<and> (head_\\<omega> n1 < head_\\<omega> n2 \\<or> n1 = 0 \\<and> n2 = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 < head_\\<omega> n2 \\<or> n1 = 0 \\<and> n2 = 0)", "using assms"], ["proof (prove)\nusing this:\n  m1 \\<le> m2\n\ngoal (1 subgoal):\n 1. \\<exists>k n1 n2.\n       m1 = k + n1 \\<and>\n       m2 = k + n2 \\<and>\n       (head_\\<omega> n1 < head_\\<omega> n2 \\<or> n1 = 0 \\<and> n2 = 0)", "by (metis add_cancel_right_right hmset_pair_decompose_less order.not_eq_order_implies_strict)"], ["", "lemma mono_cross_mult_less_hmset:\n  fixes Aa A Ba B :: hmultiset\n  assumes A_lt: \"A < Aa\" and B_lt: \"B < Ba\"\n  shows \"A * Ba + B * Aa < A * B + Aa * Ba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * Ba + B * Aa < A * B + Aa * Ba", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A * Ba + B * Aa < A * B + Aa * Ba", "obtain j m1 m2 where A: \"A = j + m1\" and Aa: \"Aa = j + m2\" and hd_m: \"head_\\<omega> m1 < head_\\<omega> m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j m1 m2.\n        \\<lbrakk>A = j + m1; Aa = j + m2;\n         head_\\<omega> m1 < head_\\<omega> m2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis hmset_pair_decompose_less[OF A_lt])"], ["proof (state)\nthis:\n  A = j + m1\n  Aa = j + m2\n  head_\\<omega> m1 < head_\\<omega> m2\n\ngoal (1 subgoal):\n 1. A * Ba + B * Aa < A * B + Aa * Ba", "obtain k n1 n2 where B: \"B = k + n1\" and Ba: \"Ba = k + n2\" and hd_n: \"head_\\<omega> n1 < head_\\<omega> n2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k n1 n2.\n        \\<lbrakk>B = k + n1; Ba = k + n2;\n         head_\\<omega> n1 < head_\\<omega> n2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis hmset_pair_decompose_less[OF B_lt])"], ["proof (state)\nthis:\n  B = k + n1\n  Ba = k + n2\n  head_\\<omega> n1 < head_\\<omega> n2\n\ngoal (1 subgoal):\n 1. A * Ba + B * Aa < A * B + Aa * Ba", "have hd_lt: \"head_\\<omega> (m1 * n2 + m2 * n1) < head_\\<omega> (m1 * n1 + m2 * n2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_\\<omega> (m1 * n2 + m2 * n1) < head_\\<omega> (m1 * n1 + m2 * n2)", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. sup (head_\\<omega> m1 * head_\\<omega> n2)\n     (head_\\<omega> m2 * head_\\<omega> n1)\n    < sup (head_\\<omega> m1 * head_\\<omega> n1)\n       (head_\\<omega> m2 * head_\\<omega> n2)", "have \"\\<And>h ha :: hmultiset. 0 < h \\<or> \\<not> ha < h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h ha. 0 < h \\<or> \\<not> ha < h", "by force"], ["proof (state)\nthis:\n  0 < ?h \\<or> \\<not> ?ha < ?h\n\ngoal (1 subgoal):\n 1. sup (head_\\<omega> m1 * head_\\<omega> n2)\n     (head_\\<omega> m2 * head_\\<omega> n1)\n    < sup (head_\\<omega> m1 * head_\\<omega> n1)\n       (head_\\<omega> m2 * head_\\<omega> n2)", "hence \"\\<not> head_\\<omega> m2 * head_\\<omega> n2 \\<le> sup (head_\\<omega> m1 * head_\\<omega> n2) (head_\\<omega> m2 * head_\\<omega> n1)\""], ["proof (prove)\nusing this:\n  0 < ?h \\<or> \\<not> ?ha < ?h\n\ngoal (1 subgoal):\n 1. \\<not> head_\\<omega> m2 * head_\\<omega> n2\n           \\<le> sup (head_\\<omega> m1 * head_\\<omega> n2)\n                  (head_\\<omega> m2 * head_\\<omega> n1)", "using hd_m hd_n sup_hmultiset_def"], ["proof (prove)\nusing this:\n  0 < ?h \\<or> \\<not> ?ha < ?h\n  head_\\<omega> m1 < head_\\<omega> m2\n  head_\\<omega> n1 < head_\\<omega> n2\n  sup ?A ?B = (if ?A < ?B then ?B else ?A)\n\ngoal (1 subgoal):\n 1. \\<not> head_\\<omega> m2 * head_\\<omega> n2\n           \\<le> sup (head_\\<omega> m1 * head_\\<omega> n2)\n                  (head_\\<omega> m2 * head_\\<omega> n1)", "by auto"], ["proof (state)\nthis:\n  \\<not> head_\\<omega> m2 * head_\\<omega> n2\n         \\<le> sup (head_\\<omega> m1 * head_\\<omega> n2)\n                (head_\\<omega> m2 * head_\\<omega> n1)\n\ngoal (1 subgoal):\n 1. sup (head_\\<omega> m1 * head_\\<omega> n2)\n     (head_\\<omega> m2 * head_\\<omega> n1)\n    < sup (head_\\<omega> m1 * head_\\<omega> n1)\n       (head_\\<omega> m2 * head_\\<omega> n2)", "thus \"sup (head_\\<omega> m1 * head_\\<omega> n2) (head_\\<omega> m2 * head_\\<omega> n1)\n      < sup (head_\\<omega> m1 * head_\\<omega> n1) (head_\\<omega> m2 * head_\\<omega> n2)\""], ["proof (prove)\nusing this:\n  \\<not> head_\\<omega> m2 * head_\\<omega> n2\n         \\<le> sup (head_\\<omega> m1 * head_\\<omega> n2)\n                (head_\\<omega> m2 * head_\\<omega> n1)\n\ngoal (1 subgoal):\n 1. sup (head_\\<omega> m1 * head_\\<omega> n2)\n     (head_\\<omega> m2 * head_\\<omega> n1)\n    < sup (head_\\<omega> m1 * head_\\<omega> n1)\n       (head_\\<omega> m2 * head_\\<omega> n2)", "by (meson leI sup.bounded_iff)"], ["proof (state)\nthis:\n  sup (head_\\<omega> m1 * head_\\<omega> n2)\n   (head_\\<omega> m2 * head_\\<omega> n1)\n  < sup (head_\\<omega> m1 * head_\\<omega> n1)\n     (head_\\<omega> m2 * head_\\<omega> n2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  head_\\<omega> (m1 * n2 + m2 * n1) < head_\\<omega> (m1 * n1 + m2 * n2)\n\ngoal (1 subgoal):\n 1. A * Ba + B * Aa < A * B + Aa * Ba", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. A * Ba + B * Aa < A * B + Aa * Ba", "unfolding A Aa B Ba ring_distribs"], ["proof (prove)\ngoal (1 subgoal):\n 1. j * k + m1 * k + (j * n2 + m1 * n2) +\n    (k * j + n1 * j + (k * m2 + n1 * m2))\n    < j * k + m1 * k + (j * n1 + m1 * n1) +\n      (j * k + m2 * k + (j * n2 + m2 * n2))", "by (simp add: algebra_simps head_\\<omega>_lt_imp_lt[OF hd_lt])"], ["proof (state)\nthis:\n  A * Ba + B * Aa < A * B + Aa * Ba\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma triple_cross_mult_hmset:\n  \"An * (Bn * Cn + Bp * Cp - (Bn * Cp + Cn * Bp))\n   + (Cn * (An * Bp + Bn * Ap - (An * Bn + Ap * Bp))\n      + (Ap * (Bn * Cp + Cn * Bp - (Bn * Cn + Bp * Cp))\n         + Cp * (An * Bn + Ap * Bp - (An * Bp + Bn * Ap)))) =\n   An * (Bn * Cp + Cn * Bp - (Bn * Cn + Bp * Cp))\n   + (Cn * (An * Bn + Ap * Bp - (An * Bp + Bn * Ap))\n      + (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Cn * Bp))\n         + Cp * (An * Bp + Bn * Ap - (An * Bn + Ap * Bp))))\"\n  for Ap An Bp Bn Cp Cn Dp Dn :: hmultiset"], ["proof (prove)\ngoal (1 subgoal):\n 1. An * (Bn * Cn + Bp * Cp - (Bn * Cp + Cn * Bp)) +\n    (Cn * (An * Bp + Bn * Ap - (An * Bn + Ap * Bp)) +\n     (Ap * (Bn * Cp + Cn * Bp - (Bn * Cn + Bp * Cp)) +\n      Cp * (An * Bn + Ap * Bp - (An * Bp + Bn * Ap)))) =\n    An * (Bn * Cp + Cn * Bp - (Bn * Cn + Bp * Cp)) +\n    (Cn * (An * Bn + Ap * Bp - (An * Bp + Bn * Ap)) +\n     (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Cn * Bp)) +\n      Cp * (An * Bp + Bn * Ap - (An * Bn + Ap * Bp))))", "apply (simp add: algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    (Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n     (Cn * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n      Cp * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n      Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp))))", "apply (unfold add.assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Cn * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp))", "apply (rule add_right_cancel[THEN iffD1, of _ \"Cp * (An * Bp + Ap * Bn)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Cn * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn)", "apply (unfold add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    (Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n     (Cn * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n      (Cp * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n       Cp * (An * Bp + Ap * Bn)))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n      (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n       Cp * (An * Bp + Ap * Bn))))", "apply (subst times_diff_plus_sym_hmset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    (Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n     (Cn * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n      (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n       Cp * (An * Bn + Ap * Bp)))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n      (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n       Cp * (An * Bp + Ap * Bn))))", "apply (unfold add.assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Cn * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bn + Ap * Bp) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn)", "apply (subst (12) add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp * (An * Bn + Ap * Bp) +\n    (An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n     Cn * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n     Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn)", "apply (subst (11) add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp * (An * Bn + Ap * Bp) +\n    (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n     (An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n      Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n      Cn * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn)", "apply (unfold add.assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp * (An * Bn + Ap * Bp) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Cn * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn)", "apply (rule add_right_cancel[THEN iffD1, of _ \"Cn * (An * Bn + Ap * Bp)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp * (An * Bn + Ap * Bp) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Cn * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cn * (An * Bn + Ap * Bp) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp)", "apply (unfold add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp * (An * Bn + Ap * Bp) +\n    (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n     (An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n      (Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n       (Cn * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n        Cn * (An * Bn + Ap * Bp))))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n      (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n       (Cp * (An * Bp + Ap * Bn) + Cn * (An * Bn + Ap * Bp)))))", "apply (subst times_diff_plus_sym_hmset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp * (An * Bn + Ap * Bp) +\n    (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n     (An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n      (Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n       (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n        Cn * (An * Bp + Ap * Bn))))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n      (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n       (Cp * (An * Bp + Ap * Bn) + Cn * (An * Bn + Ap * Bp)))))", "apply (unfold add.assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cp * (An * Bn + Ap * Bp) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cn * (An * Bp + Ap * Bn) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp)", "apply (subst (14) add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn * (An * Bp + Ap * Bn) +\n    (Cp * (An * Bn + Ap * Bp) +\n     Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n     An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n     Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp)", "apply (subst (13) add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn * (An * Bp + Ap * Bn) +\n    (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n     (Cp * (An * Bn + Ap * Bp) +\n      Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n      An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n      Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp)", "apply (unfold add.assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bn + Ap * Bp) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp)", "apply (rule add_right_cancel[THEN iffD1, of _ \"Ap * (Bn * Cn + Bp * Cp)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bn + Ap * Bp) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp) +\n    Ap * (Bn * Cn + Bp * Cp)", "apply (unfold add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn * (An * Bp + Ap * Bn) +\n    (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n     (Cp * (An * Bn + Ap * Bp) +\n      (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n       (An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n        (Ap * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n         Ap * (Bn * Cn + Bp * Cp)))))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n      (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n       (Cp * (An * Bp + Ap * Bn) +\n        (Cn * (An * Bn + Ap * Bp) + Ap * (Bn * Cn + Bp * Cp))))))", "apply (subst times_diff_plus_sym_hmset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn * (An * Bp + Ap * Bn) +\n    (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n     (Cp * (An * Bn + Ap * Bp) +\n      (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n       (An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n        (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n         Ap * (Bn * Cp + Bp * Cn)))))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n      (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n       (Cp * (An * Bp + Ap * Bn) +\n        (Cn * (An * Bn + Ap * Bp) + Ap * (Bn * Cn + Bp * Cp))))))", "apply (unfold add.assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bn + Ap * Bp) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Ap * (Bn * Cp + Bp * Cn) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp) +\n    Ap * (Bn * Cn + Bp * Cp)", "apply (subst (16) add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ap * (Bn * Cp + Bp * Cn) +\n    (Cn * (An * Bp + Ap * Bn) +\n     Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n     Cp * (An * Bn + Ap * Bp) +\n     Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n     An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp) +\n    Ap * (Bn * Cn + Bp * Cp)", "apply (subst (15) add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ap * (Bn * Cp + Bp * Cn) +\n    (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     (Cn * (An * Bp + Ap * Bn) +\n      Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n      Cp * (An * Bn + Ap * Bp) +\n      Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n      An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp) +\n    Ap * (Bn * Cn + Bp * Cp)", "apply (unfold add.assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ap * (Bn * Cp + Bp * Cn) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bn + Ap * Bp) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp) +\n    Ap * (Bn * Cn + Bp * Cp)", "apply (rule add_right_cancel[THEN iffD1, of _ \"An * (Bn * Cp + Bp * Cn)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ap * (Bn * Cp + Bp * Cn) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bn + Ap * Bp) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    An * (Bn * Cp + Bp * Cn) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp) +\n    Ap * (Bn * Cn + Bp * Cp) +\n    An * (Bn * Cp + Bp * Cn)", "apply (unfold add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ap * (Bn * Cp + Bp * Cn) +\n    (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     (Cn * (An * Bp + Ap * Bn) +\n      (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n       (Cp * (An * Bn + Ap * Bp) +\n        (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n         (An * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n          An * (Bn * Cp + Bp * Cn))))))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n      (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n       (Cp * (An * Bp + Ap * Bn) +\n        (Cn * (An * Bn + Ap * Bp) +\n         (Ap * (Bn * Cn + Bp * Cp) + An * (Bn * Cp + Bp * Cn)))))))", "apply (subst times_diff_plus_sym_hmset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ap * (Bn * Cp + Bp * Cn) +\n    (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     (Cn * (An * Bp + Ap * Bn) +\n      (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n       (Cp * (An * Bn + Ap * Bp) +\n        (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n         (An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n          An * (Bn * Cn + Bp * Cp))))))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    (Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     (Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n      (Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n       (Cp * (An * Bp + Ap * Bn) +\n        (Cn * (An * Bn + Ap * Bp) +\n         (Ap * (Bn * Cn + Bp * Cp) + An * (Bn * Cp + Bp * Cn)))))))", "apply (unfold add.assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ap * (Bn * Cp + Bp * Cn) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bn + Ap * Bp) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    An * (Bn * Cn + Bp * Cp) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp) +\n    Ap * (Bn * Cn + Bp * Cp) +\n    An * (Bn * Cp + Bp * Cn)", "apply (subst (18) add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. An * (Bn * Cn + Bp * Cp) +\n    (Ap * (Bn * Cp + Bp * Cn) +\n     Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n     Cn * (An * Bp + Ap * Bn) +\n     Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n     Cp * (An * Bn + Ap * Bp) +\n     Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n     An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp) +\n    Ap * (Bn * Cn + Bp * Cp) +\n    An * (Bn * Cp + Bp * Cn)", "apply (subst (17) add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. An * (Bn * Cn + Bp * Cp) +\n    (An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n     (Ap * (Bn * Cp + Bp * Cn) +\n      Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n      Cn * (An * Bp + Ap * Bn) +\n      Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n      Cp * (An * Bn + Ap * Bp) +\n      Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)))) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp) +\n    Ap * (Bn * Cn + Bp * Cp) +\n    An * (Bn * Cp + Bp * Cn)", "apply (unfold add.assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. An * (Bn * Cn + Bp * Cp) +\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cp + Bp * Cn) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bn + Ap * Bp) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) =\n    An * (Bn * Cp + Bp * Cn - (Bn * Cn + Bp * Cp)) +\n    Ap * (Bn * Cn + Bp * Cp - (Bn * Cp + Bp * Cn)) +\n    Cn * (An * Bn + Ap * Bp - (An * Bp + Ap * Bn)) +\n    Cp * (An * Bp + Ap * Bn - (An * Bn + Ap * Bp)) +\n    Cp * (An * Bp + Ap * Bn) +\n    Cn * (An * Bn + Ap * Bp) +\n    Ap * (Bn * Cn + Bp * Cp) +\n    An * (Bn * Cp + Bp * Cn)", "by (simp add: algebra_simps)"], ["", "subsection \\<open>Conversions to Natural Numbers\\<close>"], ["", "definition offset_hmset :: \"hmultiset \\<Rightarrow> nat\" where\n  \"offset_hmset M = count (hmsetmset M) 0\""], ["", "lemma offset_hmset_of_nat[simp]: \"offset_hmset (of_nat n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offset_hmset (of_nat n) = n", "unfolding offset_hmset_def of_nat_hmset"], ["proof (prove)\ngoal (1 subgoal):\n 1. count (hmsetmset (HMSet (replicate_mset n 0))) 0 = n", "by simp"], ["", "lemma offset_hmset_numeral[simp]: \"offset_hmset (numeral n) = numeral n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offset_hmset (numeral n) = numeral n", "unfolding offset_hmset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. count (hmsetmset (numeral n)) 0 = numeral n", "by (metis offset_hmset_def offset_hmset_of_nat of_nat_numeral)"], ["", "definition sum_coefs :: \"hmultiset \\<Rightarrow> nat\" where\n  \"sum_coefs M = size (hmsetmset M)\""], ["", "lemma sum_coefs_distrib_plus[simp]: \"sum_coefs (M + N) = sum_coefs M + sum_coefs N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_coefs (M + N) = sum_coefs M + sum_coefs N", "unfolding plus_hmultiset_def sum_coefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. size (hmsetmset (HMSet (hmsetmset M + hmsetmset N))) =\n    size (hmsetmset M) + size (hmsetmset N)", "by simp"], ["", "lemma sum_coefs_gt_0: \"sum_coefs M > 0 \\<longleftrightarrow> M > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < sum_coefs M) = (0 < M)", "by (auto simp: sum_coefs_def zero_hmultiset_def hmsetmset_less[symmetric] less_multiset_ext\\<^sub>D\\<^sub>M_less\n    nonempty_has_size[symmetric])"], ["", "subsection \\<open>An Example\\<close>"], ["", "text \\<open>\nThe following proof is based on an informal proof by Uwe Waldmann, inspired by\na similar argument by Michel Ludwig.\n\\<close>"], ["", "lemma ludwig_waldmann_less:\n  fixes \\<alpha>1 \\<alpha>2 \\<beta>1 \\<beta>2 \\<gamma> \\<delta> :: hmultiset\n  assumes\n    \\<alpha>\\<beta>2\\<gamma>_lt_\\<alpha>\\<beta>1\\<gamma>: \"\\<alpha>2 + \\<beta>2 * \\<gamma> < \\<alpha>1 + \\<beta>1 * \\<gamma>\" and\n    \\<beta>2_le_\\<beta>1: \"\\<beta>2 \\<le> \\<beta>1\" and\n    \\<gamma>_lt_\\<delta>: \"\\<gamma> < \\<delta>\"\n  shows \"\\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "obtain \\<beta>0 \\<beta>2a \\<beta>1a where\n    \\<beta>1: \"\\<beta>1 = \\<beta>0 + \\<beta>1a\" and\n    \\<beta>2: \"\\<beta>2 = \\<beta>0 + \\<beta>2a\" and\n    hd_\\<beta>2a_vs_\\<beta>1a: \"head_\\<omega> \\<beta>2a < head_\\<omega> \\<beta>1a \\<or> \\<beta>2a = 0 \\<and> \\<beta>1a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>0 \\<beta>1a \\<beta>2a.\n        \\<lbrakk>\\<beta>1 = \\<beta>0 + \\<beta>1a;\n         \\<beta>2 = \\<beta>0 + \\<beta>2a;\n         head_\\<omega> \\<beta>2a < head_\\<omega> \\<beta>1a \\<or>\n         \\<beta>2a = 0 \\<and> \\<beta>1a = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hmset_pair_decompose_less_eq[OF \\<beta>2_le_\\<beta>1]"], ["proof (prove)\nusing this:\n  \\<exists>k n1 n2.\n     \\<beta>2 = k + n1 \\<and>\n     \\<beta>1 = k + n2 \\<and>\n     (head_\\<omega> n1 < head_\\<omega> n2 \\<or> n1 = 0 \\<and> n2 = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>0 \\<beta>1a \\<beta>2a.\n        \\<lbrakk>\\<beta>1 = \\<beta>0 + \\<beta>1a;\n         \\<beta>2 = \\<beta>0 + \\<beta>2a;\n         head_\\<omega> \\<beta>2a < head_\\<omega> \\<beta>1a \\<or>\n         \\<beta>2a = 0 \\<and> \\<beta>1a = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<beta>1 = \\<beta>0 + \\<beta>1a\n  \\<beta>2 = \\<beta>0 + \\<beta>2a\n  head_\\<omega> \\<beta>2a < head_\\<omega> \\<beta>1a \\<or>\n  \\<beta>2a = 0 \\<and> \\<beta>1a = 0\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "obtain \\<eta> \\<gamma>a \\<delta>a where\n    \\<gamma>: \"\\<gamma> = \\<eta> + \\<gamma>a\" and\n    \\<delta>: \"\\<delta> = \\<eta> + \\<delta>a\" and\n    hd_\\<gamma>a_lt_\\<delta>a: \"head_\\<omega> \\<gamma>a < head_\\<omega> \\<delta>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<eta> \\<gamma>a \\<delta>a.\n        \\<lbrakk>\\<gamma> = \\<eta> + \\<gamma>a;\n         \\<delta> = \\<eta> + \\<delta>a;\n         head_\\<omega> \\<gamma>a < head_\\<omega> \\<delta>a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using hmset_pair_decompose_less[OF \\<gamma>_lt_\\<delta>]"], ["proof (prove)\nusing this:\n  \\<exists>k n1 n2.\n     \\<gamma> = k + n1 \\<and>\n     \\<delta> = k + n2 \\<and> head_\\<omega> n1 < head_\\<omega> n2\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta> \\<gamma>a \\<delta>a.\n        \\<lbrakk>\\<gamma> = \\<eta> + \\<gamma>a;\n         \\<delta> = \\<eta> + \\<delta>a;\n         head_\\<omega> \\<gamma>a < head_\\<omega> \\<delta>a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<gamma> = \\<eta> + \\<gamma>a\n  \\<delta> = \\<eta> + \\<delta>a\n  head_\\<omega> \\<gamma>a < head_\\<omega> \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "have \"\\<alpha>2 + \\<beta>0 * \\<gamma> + \\<beta>2a * \\<gamma> = \\<alpha>2 + \\<beta>2 * \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>0 * \\<gamma> + \\<beta>2a * \\<gamma> =\n    \\<alpha>2 + \\<beta>2 * \\<gamma>", "unfolding \\<beta>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>0 * \\<gamma> + \\<beta>2a * \\<gamma> =\n    \\<alpha>2 + (\\<beta>0 + \\<beta>2a) * \\<gamma>", "by (simp add: add.commute add.left_commute distrib_left mult.commute)"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>0 * \\<gamma> + \\<beta>2a * \\<gamma> =\n  \\<alpha>2 + \\<beta>2 * \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "also"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>0 * \\<gamma> + \\<beta>2a * \\<gamma> =\n  \\<alpha>2 + \\<beta>2 * \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "have \"\\<dots> < \\<alpha>1 + \\<beta>1 * \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<gamma> < \\<alpha>1 + \\<beta>1 * \\<gamma>", "by (rule \\<alpha>\\<beta>2\\<gamma>_lt_\\<alpha>\\<beta>1\\<gamma>)"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>2 * \\<gamma> < \\<alpha>1 + \\<beta>1 * \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "also"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>2 * \\<gamma> < \\<alpha>1 + \\<beta>1 * \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "have \"\\<dots> = \\<alpha>1 + \\<beta>0 * \\<gamma> + \\<beta>1a * \\<gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>1 + \\<beta>1 * \\<gamma> =\n    \\<alpha>1 + \\<beta>0 * \\<gamma> + \\<beta>1a * \\<gamma>", "unfolding \\<beta>1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>1 + (\\<beta>0 + \\<beta>1a) * \\<gamma> =\n    \\<alpha>1 + \\<beta>0 * \\<gamma> + \\<beta>1a * \\<gamma>", "by (simp add: add.commute add.left_commute distrib_left mult.commute)"], ["proof (state)\nthis:\n  \\<alpha>1 + \\<beta>1 * \\<gamma> =\n  \\<alpha>1 + \\<beta>0 * \\<gamma> + \\<beta>1a * \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "finally"], ["proof (chain)\npicking this:\n  \\<alpha>2 + \\<beta>0 * \\<gamma> + \\<beta>2a * \\<gamma>\n  < \\<alpha>1 + \\<beta>0 * \\<gamma> + \\<beta>1a * \\<gamma>", "have *: \"\\<alpha>2 + \\<beta>2a * \\<gamma> < \\<alpha>1 + \\<beta>1a * \\<gamma>\""], ["proof (prove)\nusing this:\n  \\<alpha>2 + \\<beta>0 * \\<gamma> + \\<beta>2a * \\<gamma>\n  < \\<alpha>1 + \\<beta>0 * \\<gamma> + \\<beta>1a * \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2a * \\<gamma> < \\<alpha>1 + \\<beta>1a * \\<gamma>", "by (metis add_less_cancel_right semiring_normalization_rules(23))"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>2a * \\<gamma> < \\<alpha>1 + \\<beta>1a * \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "have \"\\<alpha>2 + \\<beta>2 * \\<delta> = \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> =\n    \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<delta>", "unfolding \\<beta>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>2 + (\\<beta>0 + \\<beta>2a) * \\<delta> =\n    \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<delta>", "by (simp add: ab_semigroup_add_class.add_ac(1) distrib_right)"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>2 * \\<delta> =\n  \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<delta>\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "also"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>2 * \\<delta> =\n  \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<delta>\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "have \"\\<dots> = \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> + \\<beta>2a * \\<delta>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<delta> =\n    \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> +\n    \\<beta>2a * \\<delta>a", "unfolding \\<delta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>0 * (\\<eta> + \\<delta>a) +\n    \\<beta>2a * (\\<eta> + \\<delta>a) =\n    \\<alpha>2 + \\<beta>0 * (\\<eta> + \\<delta>a) + \\<beta>2a * \\<eta> +\n    \\<beta>2a * \\<delta>a", "by (simp add: distrib_left semiring_normalization_rules(25))"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<delta> =\n  \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> +\n  \\<beta>2a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "also"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<delta> =\n  \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> +\n  \\<beta>2a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "have \"\\<dots> \\<le> \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> + \\<beta>2a * \\<delta>a + \\<beta>2a * \\<gamma>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> +\n    \\<beta>2a * \\<delta>a\n    \\<le> \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> +\n          \\<beta>2a * \\<delta>a +\n          \\<beta>2a * \\<gamma>a", "by simp"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> +\n  \\<beta>2a * \\<delta>a\n  \\<le> \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> +\n        \\<beta>2a * \\<delta>a +\n        \\<beta>2a * \\<gamma>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "also"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> +\n  \\<beta>2a * \\<delta>a\n  \\<le> \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> +\n        \\<beta>2a * \\<delta>a +\n        \\<beta>2a * \\<gamma>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "have \"\\<dots> = \\<alpha>2 + \\<beta>2a * \\<gamma> + \\<beta>0 * \\<delta> + \\<beta>2a * \\<delta>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> +\n    \\<beta>2a * \\<delta>a +\n    \\<beta>2a * \\<gamma>a =\n    \\<alpha>2 + \\<beta>2a * \\<gamma> + \\<beta>0 * \\<delta> +\n    \\<beta>2a * \\<delta>a", "unfolding \\<gamma> distrib_left add.assoc[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> +\n    \\<beta>2a * \\<delta>a +\n    \\<beta>2a * \\<gamma>a =\n    \\<alpha>2 + \\<beta>2a * \\<eta> + \\<beta>2a * \\<gamma>a +\n    \\<beta>0 * \\<delta> +\n    \\<beta>2a * \\<delta>a", "by (simp add: semiring_normalization_rules(23))"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> +\n  \\<beta>2a * \\<delta>a +\n  \\<beta>2a * \\<gamma>a =\n  \\<alpha>2 + \\<beta>2a * \\<gamma> + \\<beta>0 * \\<delta> +\n  \\<beta>2a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "also"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>0 * \\<delta> + \\<beta>2a * \\<eta> +\n  \\<beta>2a * \\<delta>a +\n  \\<beta>2a * \\<gamma>a =\n  \\<alpha>2 + \\<beta>2a * \\<gamma> + \\<beta>0 * \\<delta> +\n  \\<beta>2a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "have \"\\<dots> < \\<alpha>1 + \\<beta>1a * \\<gamma> + \\<beta>0 * \\<delta> + \\<beta>2a * \\<delta>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2a * \\<gamma> + \\<beta>0 * \\<delta> +\n    \\<beta>2a * \\<delta>a\n    < \\<alpha>1 + \\<beta>1a * \\<gamma> + \\<beta>0 * \\<delta> +\n      \\<beta>2a * \\<delta>a", "using *"], ["proof (prove)\nusing this:\n  \\<alpha>2 + \\<beta>2a * \\<gamma> < \\<alpha>1 + \\<beta>1a * \\<gamma>\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2a * \\<gamma> + \\<beta>0 * \\<delta> +\n    \\<beta>2a * \\<delta>a\n    < \\<alpha>1 + \\<beta>1a * \\<gamma> + \\<beta>0 * \\<delta> +\n      \\<beta>2a * \\<delta>a", "by simp"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>2a * \\<gamma> + \\<beta>0 * \\<delta> +\n  \\<beta>2a * \\<delta>a\n  < \\<alpha>1 + \\<beta>1a * \\<gamma> + \\<beta>0 * \\<delta> +\n    \\<beta>2a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "also"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>2a * \\<gamma> + \\<beta>0 * \\<delta> +\n  \\<beta>2a * \\<delta>a\n  < \\<alpha>1 + \\<beta>1a * \\<gamma> + \\<beta>0 * \\<delta> +\n    \\<beta>2a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "have \"\\<dots> = \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>1a * \\<gamma>a + \\<beta>0 * \\<eta> + \\<beta>0 * \\<delta>a + \\<beta>2a * \\<delta>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>1 + \\<beta>1a * \\<gamma> + \\<beta>0 * \\<delta> +\n    \\<beta>2a * \\<delta>a =\n    \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>1a * \\<gamma>a +\n    \\<beta>0 * \\<eta> +\n    \\<beta>0 * \\<delta>a +\n    \\<beta>2a * \\<delta>a", "unfolding \\<gamma> \\<delta> distrib_left add.assoc[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>1a * \\<gamma>a +\n    \\<beta>0 * \\<eta> +\n    \\<beta>0 * \\<delta>a +\n    \\<beta>2a * \\<delta>a =\n    \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>1a * \\<gamma>a +\n    \\<beta>0 * \\<eta> +\n    \\<beta>0 * \\<delta>a +\n    \\<beta>2a * \\<delta>a", "by (rule refl)"], ["proof (state)\nthis:\n  \\<alpha>1 + \\<beta>1a * \\<gamma> + \\<beta>0 * \\<delta> +\n  \\<beta>2a * \\<delta>a =\n  \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>1a * \\<gamma>a +\n  \\<beta>0 * \\<eta> +\n  \\<beta>0 * \\<delta>a +\n  \\<beta>2a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "also"], ["proof (state)\nthis:\n  \\<alpha>1 + \\<beta>1a * \\<gamma> + \\<beta>0 * \\<delta> +\n  \\<beta>2a * \\<delta>a =\n  \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>1a * \\<gamma>a +\n  \\<beta>0 * \\<eta> +\n  \\<beta>0 * \\<delta>a +\n  \\<beta>2a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "have \"\\<dots> \\<le> \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>0 * \\<eta> + \\<beta>0 * \\<delta>a + \\<beta>1a * \\<delta>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>1a * \\<gamma>a +\n    \\<beta>0 * \\<eta> +\n    \\<beta>0 * \\<delta>a +\n    \\<beta>2a * \\<delta>a\n    \\<le> \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>0 * \\<eta> +\n          \\<beta>0 * \\<delta>a +\n          \\<beta>1a * \\<delta>a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>1a * \\<gamma>a +\n    \\<beta>0 * \\<eta> +\n    \\<beta>0 * \\<delta>a +\n    \\<beta>2a * \\<delta>a\n    \\<le> \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>0 * \\<eta> +\n          \\<beta>0 * \\<delta>a +\n          \\<beta>1a * \\<delta>a", "have \"\\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a \\<le> \\<beta>1a * \\<delta>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a\n    \\<le> \\<beta>1a * \\<delta>a", "proof (cases \"\\<beta>2a = 0 \\<and> \\<beta>1a = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<beta>2a = 0 \\<and> \\<beta>1a = 0 \\<Longrightarrow>\n    \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a\n    \\<le> \\<beta>1a * \\<delta>a\n 2. \\<not> (\\<beta>2a = 0 \\<and> \\<beta>1a = 0) \\<Longrightarrow>\n    \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a\n    \\<le> \\<beta>1a * \\<delta>a", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<beta>2a = 0 \\<and> \\<beta>1a = 0)\n\ngoal (2 subgoals):\n 1. \\<beta>2a = 0 \\<and> \\<beta>1a = 0 \\<Longrightarrow>\n    \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a\n    \\<le> \\<beta>1a * \\<delta>a\n 2. \\<not> (\\<beta>2a = 0 \\<and> \\<beta>1a = 0) \\<Longrightarrow>\n    \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a\n    \\<le> \\<beta>1a * \\<delta>a", "hence \"head_\\<omega> \\<beta>2a < head_\\<omega> \\<beta>1a\""], ["proof (prove)\nusing this:\n  \\<not> (\\<beta>2a = 0 \\<and> \\<beta>1a = 0)\n\ngoal (1 subgoal):\n 1. head_\\<omega> \\<beta>2a < head_\\<omega> \\<beta>1a", "using hd_\\<beta>2a_vs_\\<beta>1a"], ["proof (prove)\nusing this:\n  \\<not> (\\<beta>2a = 0 \\<and> \\<beta>1a = 0)\n  head_\\<omega> \\<beta>2a < head_\\<omega> \\<beta>1a \\<or>\n  \\<beta>2a = 0 \\<and> \\<beta>1a = 0\n\ngoal (1 subgoal):\n 1. head_\\<omega> \\<beta>2a < head_\\<omega> \\<beta>1a", "by blast"], ["proof (state)\nthis:\n  head_\\<omega> \\<beta>2a < head_\\<omega> \\<beta>1a\n\ngoal (2 subgoals):\n 1. \\<beta>2a = 0 \\<and> \\<beta>1a = 0 \\<Longrightarrow>\n    \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a\n    \\<le> \\<beta>1a * \\<delta>a\n 2. \\<not> (\\<beta>2a = 0 \\<and> \\<beta>1a = 0) \\<Longrightarrow>\n    \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a\n    \\<le> \\<beta>1a * \\<delta>a", "hence \"head_\\<omega> (\\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a) < head_\\<omega> (\\<beta>1a * \\<delta>a)\""], ["proof (prove)\nusing this:\n  head_\\<omega> \\<beta>2a < head_\\<omega> \\<beta>1a\n\ngoal (1 subgoal):\n 1. head_\\<omega> (\\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a)\n    < head_\\<omega> (\\<beta>1a * \\<delta>a)", "using hd_\\<gamma>a_lt_\\<delta>a"], ["proof (prove)\nusing this:\n  head_\\<omega> \\<beta>2a < head_\\<omega> \\<beta>1a\n  head_\\<omega> \\<gamma>a < head_\\<omega> \\<delta>a\n\ngoal (1 subgoal):\n 1. head_\\<omega> (\\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a)\n    < head_\\<omega> (\\<beta>1a * \\<delta>a)", "by (auto intro: gr_zeroI_hmset simp: sup_hmultiset_def)"], ["proof (state)\nthis:\n  head_\\<omega> (\\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a)\n  < head_\\<omega> (\\<beta>1a * \\<delta>a)\n\ngoal (2 subgoals):\n 1. \\<beta>2a = 0 \\<and> \\<beta>1a = 0 \\<Longrightarrow>\n    \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a\n    \\<le> \\<beta>1a * \\<delta>a\n 2. \\<not> (\\<beta>2a = 0 \\<and> \\<beta>1a = 0) \\<Longrightarrow>\n    \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a\n    \\<le> \\<beta>1a * \\<delta>a", "hence \"\\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a < \\<beta>1a * \\<delta>a\""], ["proof (prove)\nusing this:\n  head_\\<omega> (\\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a)\n  < head_\\<omega> (\\<beta>1a * \\<delta>a)\n\ngoal (1 subgoal):\n 1. \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a < \\<beta>1a * \\<delta>a", "by (rule head_\\<omega>_lt_imp_lt)"], ["proof (state)\nthis:\n  \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a < \\<beta>1a * \\<delta>a\n\ngoal (2 subgoals):\n 1. \\<beta>2a = 0 \\<and> \\<beta>1a = 0 \\<Longrightarrow>\n    \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a\n    \\<le> \\<beta>1a * \\<delta>a\n 2. \\<not> (\\<beta>2a = 0 \\<and> \\<beta>1a = 0) \\<Longrightarrow>\n    \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a\n    \\<le> \\<beta>1a * \\<delta>a", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a < \\<beta>1a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a\n    \\<le> \\<beta>1a * \\<delta>a", "by simp"], ["proof (state)\nthis:\n  \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a \\<le> \\<beta>1a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<beta>2a = 0 \\<and> \\<beta>1a = 0 \\<Longrightarrow>\n    \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a\n    \\<le> \\<beta>1a * \\<delta>a", "qed simp"], ["proof (state)\nthis:\n  \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a \\<le> \\<beta>1a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>1a * \\<gamma>a +\n    \\<beta>0 * \\<eta> +\n    \\<beta>0 * \\<delta>a +\n    \\<beta>2a * \\<delta>a\n    \\<le> \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>0 * \\<eta> +\n          \\<beta>0 * \\<delta>a +\n          \\<beta>1a * \\<delta>a", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<beta>1a * \\<gamma>a + \\<beta>2a * \\<delta>a \\<le> \\<beta>1a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>1a * \\<gamma>a +\n    \\<beta>0 * \\<eta> +\n    \\<beta>0 * \\<delta>a +\n    \\<beta>2a * \\<delta>a\n    \\<le> \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>0 * \\<eta> +\n          \\<beta>0 * \\<delta>a +\n          \\<beta>1a * \\<delta>a", "by simp"], ["proof (state)\nthis:\n  \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>1a * \\<gamma>a +\n  \\<beta>0 * \\<eta> +\n  \\<beta>0 * \\<delta>a +\n  \\<beta>2a * \\<delta>a\n  \\<le> \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>0 * \\<eta> +\n        \\<beta>0 * \\<delta>a +\n        \\<beta>1a * \\<delta>a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>1a * \\<gamma>a +\n  \\<beta>0 * \\<eta> +\n  \\<beta>0 * \\<delta>a +\n  \\<beta>2a * \\<delta>a\n  \\<le> \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>0 * \\<eta> +\n        \\<beta>0 * \\<delta>a +\n        \\<beta>1a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "finally"], ["proof (chain)\npicking this:\n  \\<alpha>2 + \\<beta>2 * \\<delta>\n  < \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>0 * \\<eta> +\n    \\<beta>0 * \\<delta>a +\n    \\<beta>1a * \\<delta>a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>2 + \\<beta>2 * \\<delta>\n  < \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>0 * \\<eta> +\n    \\<beta>0 * \\<delta>a +\n    \\<beta>1a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>", "unfolding \\<beta>1 \\<delta>"], ["proof (prove)\nusing this:\n  \\<alpha>2 + \\<beta>2 * (\\<eta> + \\<delta>a)\n  < \\<alpha>1 + \\<beta>1a * \\<eta> + \\<beta>0 * \\<eta> +\n    \\<beta>0 * \\<delta>a +\n    \\<beta>1a * \\<delta>a\n\ngoal (1 subgoal):\n 1. \\<alpha>2 + \\<beta>2 * (\\<eta> + \\<delta>a)\n    < \\<alpha>1 + (\\<beta>0 + \\<beta>1a) * (\\<eta> + \\<delta>a)", "by (simp add: distrib_left distrib_right add.assoc[symmetric] semiring_normalization_rules(23))"], ["proof (state)\nthis:\n  \\<alpha>2 + \\<beta>2 * \\<delta> < \\<alpha>1 + \\<beta>1 * \\<delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}