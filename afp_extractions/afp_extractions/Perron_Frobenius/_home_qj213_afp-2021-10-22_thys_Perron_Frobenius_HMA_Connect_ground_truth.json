{"file_name": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius/HMA_Connect.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Perron_Frobenius", "problem_names": ["lemmas mat_def = Finite_Cartesian_Product.mat_def", "lemmas det_def = Determinants.det_def", "lemmas row_def = Finite_Cartesian_Product.row_def", "lemma vec_elements_h_def': \"vec_elements_h v = {v $h i | i. True}\"", "lemma elements_mat_h_def': \"elements_mat_h A = {A $h i $h j | i j. True}\"", "lemma spectral_radius_ev_def: \"spectral_radius A = Max (norm ` (Collect (eigen_value A)))\"", "lemma elements_mat: \"elements_mat A = {A $$ (i,j) | i j. i < dim_row A \\<and> j < dim_col A}\"", "lemma vec_elements: \"vec_elements v = { v $ i | i. i < dim_vec v}\"", "lemma to_hma_from_hma\\<^sub>v[simp]: \"to_hma\\<^sub>v (from_hma\\<^sub>v v) = v\"", "lemma to_hma_from_hma\\<^sub>m[simp]: \"to_hma\\<^sub>m (from_hma\\<^sub>m v) = v\"", "lemma from_hma_to_hma\\<^sub>v[simp]:\n  \"v \\<in> carrier_vec (CARD('n)) \\<Longrightarrow> from_hma\\<^sub>v (to_hma\\<^sub>v v :: 'a ^ 'n) = v\"", "lemma from_hma_to_hma\\<^sub>m[simp]:\n  \"A \\<in> carrier_mat (CARD('nr)) (CARD('nc)) \\<Longrightarrow> from_hma\\<^sub>m (to_hma\\<^sub>m A :: 'a ^ 'nc  ^ 'nr) = A\"", "lemma from_hma\\<^sub>v_inj[simp]: \"from_hma\\<^sub>v x = from_hma\\<^sub>v y \\<longleftrightarrow> x = y\"", "lemma from_hma\\<^sub>m_inj[simp]: \"from_hma\\<^sub>m x = from_hma\\<^sub>m y \\<longleftrightarrow> x = y\"", "lemma Domainp_HMA_V [transfer_domain_rule]: \n  \"Domainp (HMA_V :: 'a Matrix.vec \\<Rightarrow> 'a ^ 'n \\<Rightarrow> bool) = (\\<lambda> v. v \\<in> carrier_vec (CARD('n )))\"", "lemma Domainp_HMA_M [transfer_domain_rule]: \n  \"Domainp (HMA_M :: 'a Matrix.mat \\<Rightarrow> 'a ^ 'nc  ^ 'nr  \\<Rightarrow> bool) \n  = (\\<lambda> A. A \\<in> carrier_mat CARD('nr) CARD('nc))\"", "lemma Domainp_HMA_I [transfer_domain_rule]: \n  \"Domainp (HMA_I :: nat \\<Rightarrow> 'n :: finite \\<Rightarrow> bool) = (\\<lambda> i. i < CARD('n))\" (is \"?l = ?r\")", "lemma bi_unique_HMA_V [transfer_rule]: \"bi_unique HMA_V\" \"left_unique HMA_V\" \"right_unique HMA_V\"", "lemma bi_unique_HMA_M [transfer_rule]: \"bi_unique HMA_M\" \"left_unique HMA_M\" \"right_unique HMA_M\"", "lemma bi_unique_HMA_I [transfer_rule]: \"bi_unique HMA_I\" \"left_unique HMA_I\" \"right_unique HMA_I\"", "lemma right_total_HMA_V [transfer_rule]: \"right_total HMA_V\"", "lemma right_total_HMA_M [transfer_rule]: \"right_total HMA_M\"", "lemma right_total_HMA_I [transfer_rule]: \"right_total HMA_I\"", "lemma HMA_V_index [transfer_rule]: \"(HMA_V ===> HMA_I ===> (=)) ($v) ($h)\"", "lemma HMA_M_index [transfer_rule]:\n  \"(HMA_M ===> HMA_I ===> HMA_I ===> (=)) (\\<lambda> A i j. A $$ (i,j)) index_hma\"", "lemma HMA_V_0 [transfer_rule]: \"HMA_V (0\\<^sub>v CARD('n)) (0 :: 'a :: zero ^ 'n)\"", "lemma HMA_M_0 [transfer_rule]: \n  \"HMA_M (0\\<^sub>m CARD('nr) CARD('nc)) (0 :: 'a :: zero ^ 'nc  ^ 'nr )\"", "lemma HMA_M_1[transfer_rule]:\n  \"HMA_M (1\\<^sub>m (CARD('n))) (mat 1 :: 'a::{zero,one}^'n^'n)\"", "lemma from_hma\\<^sub>v_add: \"from_hma\\<^sub>v v + from_hma\\<^sub>v w = from_hma\\<^sub>v (v + w)\"", "lemma HMA_V_add [transfer_rule]: \"(HMA_V ===> HMA_V ===> HMA_V) (+) (+) \"", "lemma from_hma\\<^sub>v_diff: \"from_hma\\<^sub>v v - from_hma\\<^sub>v w = from_hma\\<^sub>v (v - w)\"", "lemma HMA_V_diff [transfer_rule]: \"(HMA_V ===> HMA_V ===> HMA_V) (-) (-)\"", "lemma from_hma\\<^sub>m_add: \"from_hma\\<^sub>m a + from_hma\\<^sub>m b = from_hma\\<^sub>m (a + b)\"", "lemma HMA_M_add [transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) (+) (+) \"", "lemma from_hma\\<^sub>m_diff: \"from_hma\\<^sub>m a - from_hma\\<^sub>m b = from_hma\\<^sub>m (a - b)\"", "lemma HMA_M_diff [transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) (-) (-) \"", "lemma scalar_product: fixes v :: \"'a :: semiring_1 ^ 'n \"\n  shows \"scalar_prod (from_hma\\<^sub>v v) (from_hma\\<^sub>v w) = scalar_product v w\"", "lemma [simp]:\n  \"from_hma\\<^sub>m (y :: 'a ^ 'nc  ^ 'nr) \\<in> carrier_mat (CARD('nr)) (CARD('nc))\"\n  \"dim_row (from_hma\\<^sub>m (y :: 'a ^ 'nc  ^ 'nr )) = CARD('nr)\"\n  \"dim_col (from_hma\\<^sub>m (y :: 'a ^ 'nc  ^ 'nr )) = CARD('nc)\"", "lemma [simp]:\n  \"from_hma\\<^sub>v (y :: 'a ^ 'n) \\<in> carrier_vec (CARD('n))\"\n  \"dim_vec (from_hma\\<^sub>v (y :: 'a ^ 'n)) = CARD('n)\"", "lemma HMA_scalar_prod [transfer_rule]:\n  \"(HMA_V ===> HMA_V ===> (=)) scalar_prod scalar_product\"", "lemma HMA_row [transfer_rule]: \"(HMA_I ===> HMA_M ===> HMA_V) (\\<lambda> i a. Matrix.row a i) row\"", "lemma HMA_col [transfer_rule]: \"(HMA_I ===> HMA_M ===> HMA_V) (\\<lambda> i a. col a i) column\"", "lemma HMA_M_mk_mat[transfer_rule]: \"((HMA_I ===> HMA_I ===> (=)) ===> HMA_M) \n  (\\<lambda> f. Matrix.mat (CARD('nr)) (CARD('nc)) (\\<lambda> (i,j). f i j)) \n  (mk_mat :: (('nr \\<Rightarrow> 'nc \\<Rightarrow> 'a) \\<Rightarrow> 'a^'nc^'nr))\"", "lemma HMA_M_mk_vec[transfer_rule]: \"((HMA_I ===> (=)) ===> HMA_V) \n  (\\<lambda> f. Matrix.vec (CARD('n)) (\\<lambda> i. f i)) \n  (mk_vec :: (('n \\<Rightarrow> 'a) \\<Rightarrow> 'a^'n))\"", "lemma mat_mult_scalar: \"A ** B = mk_mat (\\<lambda> i j. scalar_product (row i A) (column j B))\"", "lemma mult_mat_vec_scalar: \"A *v v = mk_vec (\\<lambda> i. scalar_product (row i A) v)\"", "lemma dim_row_transfer_rule: \n  \"HMA_M A (A' :: 'a ^ 'nc ^ 'nr) \\<Longrightarrow> (=) (dim_row A) (CARD('nr))\"", "lemma dim_col_transfer_rule: \n  \"HMA_M A (A' :: 'a ^ 'nc ^ 'nr) \\<Longrightarrow> (=) (dim_col A) (CARD('nc))\"", "lemma HMA_M_mult [transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) ((*)) ((**))\"", "lemma HMA_V_smult [transfer_rule]: \"((=) ===> HMA_V ===> HMA_V) (\\<cdot>\\<^sub>v) ((*s))\"", "lemma HMA_M_mult_vec [transfer_rule]: \"(HMA_M ===> HMA_V ===> HMA_V) ((*\\<^sub>v)) ((*v))\"", "lemma HMA_det [transfer_rule]: \"(HMA_M ===> (=)) Determinant.det \n  (det :: 'a :: comm_ring_1 ^ 'n ^ 'n \\<Rightarrow> 'a)\"", "lemma HMA_mat[transfer_rule]: \"((=) ===> HMA_M) (\\<lambda> k. k \\<cdot>\\<^sub>m 1\\<^sub>m CARD('n)) \n  (Finite_Cartesian_Product.mat :: 'a::semiring_1 \\<Rightarrow> 'a^'n^'n)\"", "lemma HMA_mat_minus[transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) \n  (\\<lambda> A B. A + map_mat uminus B) ((-) :: 'a :: group_add ^'nc^'nr \\<Rightarrow> 'a^'nc^'nr \\<Rightarrow> 'a^'nc^'nr)\"", "lemma HMA_mat2matofpoly[transfer_rule]: \"(HMA_M ===> HMA_M) (\\<lambda>x. map_mat (\\<lambda>a. [:a:]) x) mat2matofpoly\"", "lemma HMA_char_poly [transfer_rule]: \n  \"((HMA_M :: ('a:: comm_ring_1 mat \\<Rightarrow> 'a^'n^'n \\<Rightarrow> bool)) ===> (=)) char_poly charpoly\"", "lemma HMA_eigen_vector [transfer_rule]: \"(HMA_M ===> HMA_V ===> (=)) eigenvector eigen_vector\"", "lemma HMA_eigen_value [transfer_rule]: \"(HMA_M ===> (=) ===> (=)) eigenvalue eigen_value\"", "lemma HMA_spectral_radius [transfer_rule]: \n  \"(HMA_M ===> (=)) Spectral_Radius.spectral_radius spectral_radius\"", "lemma HMA_elements_mat[transfer_rule]: \"((HMA_M :: ('a mat \\<Rightarrow> 'a ^ 'nc ^ 'nr \\<Rightarrow> bool))  ===> (=)) \n  elements_mat elements_mat_h\"", "lemma HMA_vec_elements[transfer_rule]: \"((HMA_V :: ('a Matrix.vec \\<Rightarrow> 'a ^ 'n \\<Rightarrow> bool))  ===> (=)) \n  vec_elements vec_elements_h\"", "lemma norm_bound_elements_mat: \"norm_bound A b = (\\<forall> x \\<in> elements_mat A. norm x \\<le> b)\"", "lemma HMA_normbound [transfer_rule]: \n  \"((HMA_M :: 'a :: real_normed_field mat \\<Rightarrow> 'a ^ 'nc ^ 'nr \\<Rightarrow> bool) ===> (=) ===> (=))\n  norm_bound normbound\"", "lemma HMA_map_matrix [transfer_rule]: \n  \"((=) ===> HMA_M ===> HMA_M) map_mat map_matrix\"", "lemma HMA_transpose_matrix [transfer_rule]: \n  \"(HMA_M ===> HMA_M) transpose_mat transpose\"", "lemma HMA_map_vector [transfer_rule]: \n  \"((=) ===> HMA_V ===> HMA_V) map_vec map_vector\"", "lemma HMA_similar_mat_wit [transfer_rule]: \n  \"((HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'n ^ 'n \\<Rightarrow> _) ===> HMA_M ===> HMA_M ===> HMA_M ===> (=)) \n  similar_mat_wit similar_matrix_wit\"", "lemma HMA_similar_mat [transfer_rule]: \n  \"((HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'n ^ 'n \\<Rightarrow> _) ===> HMA_M ===> (=)) \n  similar_mat similar_matrix\"", "lemma HMA_spectrum[transfer_rule]: \"(HMA_M ===> (=)) spectrum Spectrum\"", "lemma HMA_M_erase_mat[transfer_rule]: \"(HMA_M ===> HMA_I ===> HMA_I ===> HMA_M) mat_erase erase_mat\"", "lemma HMA_M_sum_UNIV[transfer_rule]: \n  \"((HMA_I ===> (=)) ===> HMA_T ===> (=)) sum_UNIV_set sum_UNIV_type\"", "lemma matrix_add_vect_distrib: \"(A + B) *v v = A *v v + B *v v\"", "lemma matrix_vector_right_distrib: \"M *v (v + w) = M *v v + M *v w\"", "lemma matrix_vector_right_distrib_diff: \"(M :: 'a :: ring_1 ^ 'nr ^ 'nc) *v (v - w) = M *v v - M *v w\"", "lemma eigen_value_root_charpoly: \n  \"eigen_value A k \\<longleftrightarrow> poly (charpoly (A :: 'a :: field ^ 'n ^ 'n)) k = 0\"", "lemma finite_spectrum: fixes A :: \"'a :: field ^ 'n ^ 'n\"\n  shows \"finite (Collect (eigen_value A))\"", "lemma non_empty_spectrum: fixes A :: \"complex ^ 'n ^ 'n\"\n  shows \"Collect (eigen_value A) \\<noteq> {}\"", "lemma charpoly_transpose: \"charpoly (transpose A :: 'a :: field ^ 'n ^ 'n) = charpoly A\"", "lemma eigen_value_transpose: \"eigen_value (transpose A :: 'a :: field ^ 'n ^ 'n) v = eigen_value A v\"", "lemma matrix_diff_vect_distrib: \"(A - B) *v v = A *v v - B *v (v :: 'a :: ring_1 ^ 'n)\"", "lemma similar_matrix_charpoly: \"similar_matrix A B \\<Longrightarrow> charpoly A = charpoly B\"", "lemma pderiv_char_poly_erase_mat: fixes A :: \"'a :: idom ^ 'n ^ 'n\" \n  shows \"monom 1 1 * pderiv (charpoly A) = sum (\\<lambda> i. charpoly (erase_mat A i i)) UNIV\"", "lemma degree_monic_charpoly: fixes A :: \"'a :: comm_ring_1 ^ 'n ^ 'n\" \n  shows \"degree (charpoly A) = CARD('n) \\<and> monic (charpoly A)\""], "translations": [["", "lemmas mat_def = Finite_Cartesian_Product.mat_def"], ["", "lemmas det_def = Determinants.det_def"], ["", "lemmas row_def = Finite_Cartesian_Product.row_def"], ["", "notation vec_index (infixl \"$v\" 90)"], ["", "notation vec_nth (infixl \"$h\" 90)"], ["", "text \\<open>Forget that @{typ \"'a mat\"}, @{typ \"'a Matrix.vec\"}, and @{typ \"'a poly\"} \n  have been defined via lifting\\<close>"], ["", "(* TODO: add to end of matrix theory, stores lifting + transfer setup *)"], ["", "lifting_forget vec.lifting"], ["", "lifting_forget mat.lifting"], ["", "lifting_forget poly.lifting"], ["", "text \\<open>Some notions which we did not find in the HMA-world.\\<close>"], ["", "definition eigen_vector :: \"'a::comm_ring_1 ^ 'n ^ 'n \\<Rightarrow> 'a ^ 'n \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"eigen_vector A v ev = (v \\<noteq> 0 \\<and> A *v v = ev *s v)\""], ["", "definition eigen_value :: \"'a :: comm_ring_1 ^ 'n ^ 'n \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"eigen_value A k = (\\<exists> v. eigen_vector A v k)\""], ["", "definition similar_matrix_wit \n  :: \"'a :: semiring_1 ^ 'n ^ 'n \\<Rightarrow> 'a ^ 'n ^ 'n \\<Rightarrow> 'a ^ 'n ^ 'n \\<Rightarrow> 'a ^ 'n ^ 'n \\<Rightarrow> bool\" where\n  \"similar_matrix_wit A B P Q = (P ** Q = mat 1 \\<and> Q ** P = mat 1 \\<and> A = P ** B ** Q)\""], ["", "definition similar_matrix \n  :: \"'a :: semiring_1 ^ 'n ^ 'n \\<Rightarrow> 'a ^ 'n ^ 'n \\<Rightarrow> bool\" where\n  \"similar_matrix A B = (\\<exists> P Q. similar_matrix_wit A B P Q)\""], ["", "definition spectral_radius :: \"complex ^ 'n ^ 'n \\<Rightarrow> real\" where\n  \"spectral_radius A = Max { norm ev | v ev. eigen_vector A v ev}\""], ["", "definition Spectrum :: \"'a :: field ^ 'n ^ 'n \\<Rightarrow> 'a set\" where\n  \"Spectrum A = Collect (eigen_value A)\""], ["", "definition vec_elements_h :: \"'a ^ 'n \\<Rightarrow> 'a set\" where\n  \"vec_elements_h v = range (vec_nth v)\""], ["", "lemma vec_elements_h_def': \"vec_elements_h v = {v $h i | i. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_elements_h v = {v $h i |i. True}", "unfolding vec_elements_h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range (($h) v) = {v $h i |i. True}", "by auto"], ["", "definition elements_mat_h :: \"'a ^ 'nc ^ 'nr \\<Rightarrow> 'a set\" where\n  \"elements_mat_h A = range (\\<lambda> (i,j). A $h i $h j)\""], ["", "lemma elements_mat_h_def': \"elements_mat_h A = {A $h i $h j | i j. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elements_mat_h A = {A $h i $h j |i j. True}", "unfolding elements_mat_h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<lambda>(i, y). A $h i $h y) = {A $h i $h j |i j. True}", "by auto"], ["", "definition map_vector :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a ^'n \\<Rightarrow> 'b ^'n\" where \n  \"map_vector f v \\<equiv> \\<chi> i. f (v $h i)\""], ["", "definition map_matrix :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a ^ 'n ^ 'm \\<Rightarrow> 'b ^ 'n ^ 'm\" where \n  \"map_matrix f A \\<equiv> \\<chi> i. map_vector f (A $h i)\""], ["", "definition normbound :: \"'a :: real_normed_field ^ 'nc ^ 'nr \\<Rightarrow> real \\<Rightarrow> bool\" where\n  \"normbound A b \\<equiv> \\<forall> x \\<in> elements_mat_h A. norm x \\<le> b\""], ["", "lemma spectral_radius_ev_def: \"spectral_radius A = Max (norm ` (Collect (eigen_value A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_Connect.spectral_radius A = Max (cmod ` Collect (eigen_value A))", "unfolding spectral_radius_def eigen_value_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {uu_. \\<exists>v ev. uu_ = cmod ev \\<and> eigen_vector A v ev} =\n    Max (cmod ` {k. \\<exists>v. eigen_vector A v k})", "by (rule arg_cong[where f = Max], auto)"], ["", "lemma elements_mat: \"elements_mat A = {A $$ (i,j) | i j. i < dim_row A \\<and> j < dim_col A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elements_mat A = {A $$ (i, j) |i j. i < dim_row A \\<and> j < dim_col A}", "unfolding elements_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat\n          (map (\\<lambda>i. map (\\<lambda>j. A $$ (i, j)) [0..<dim_col A])\n            [0..<dim_row A])) =\n    {A $$ (i, j) |i j. i < dim_row A \\<and> j < dim_col A}", "by force"], ["", "definition vec_elements :: \"'a Matrix.vec \\<Rightarrow> 'a set\"\n  where \"vec_elements v = set [v $ i. i <- [0 ..< dim_vec v]]\""], ["", "lemma vec_elements: \"vec_elements v = { v $ i | i. i < dim_vec v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_elements v = {v $v i |i. i < dim_vec v}", "unfolding vec_elements_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (($v) v) [0..<dim_vec v]) = {v $v i |i. i < dim_vec v}", "by auto"], ["", "(* TODO: restore a bundle, for e.g., for matrix_impl *)"], ["", "context includes vec.lifting \nbegin"], ["", "end"], ["", "definition from_hma\\<^sub>v :: \"'a ^ 'n  \\<Rightarrow> 'a Matrix.vec\" where\n  \"from_hma\\<^sub>v v = Matrix.vec CARD('n) (\\<lambda> i. v $h from_nat i)\""], ["", "definition from_hma\\<^sub>m :: \"'a ^ 'nc ^ 'nr \\<Rightarrow> 'a Matrix.mat\" where\n  \"from_hma\\<^sub>m a = Matrix.mat CARD('nr) CARD('nc) (\\<lambda> (i,j). a $h from_nat i $h from_nat j)\""], ["", "definition to_hma\\<^sub>v :: \"'a Matrix.vec \\<Rightarrow> 'a ^ 'n\" where\n  \"to_hma\\<^sub>v v = (\\<chi> i. v $v to_nat i)\""], ["", "definition to_hma\\<^sub>m :: \"'a Matrix.mat \\<Rightarrow> 'a ^ 'nc  ^ 'nr \" where\n  \"to_hma\\<^sub>m a = (\\<chi> i j. a $$ (to_nat i, to_nat j))\""], ["", "declare vec_lambda_eta[simp]"], ["", "lemma to_hma_from_hma\\<^sub>v[simp]: \"to_hma\\<^sub>v (from_hma\\<^sub>v v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_hma\\<^sub>v (from_hma\\<^sub>v v) = v", "by (auto simp: to_hma\\<^sub>v_def from_hma\\<^sub>v_def to_nat_less_card)"], ["", "lemma to_hma_from_hma\\<^sub>m[simp]: \"to_hma\\<^sub>m (from_hma\\<^sub>m v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_hma\\<^sub>m (from_hma\\<^sub>m v) = v", "by (auto simp: to_hma\\<^sub>m_def from_hma\\<^sub>m_def to_nat_less_card)"], ["", "lemma from_hma_to_hma\\<^sub>v[simp]:\n  \"v \\<in> carrier_vec (CARD('n)) \\<Longrightarrow> from_hma\\<^sub>v (to_hma\\<^sub>v v :: 'a ^ 'n) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec CARD('n) \\<Longrightarrow>\n    from_hma\\<^sub>v (to_hma\\<^sub>v v) = v", "by (auto simp: to_hma\\<^sub>v_def from_hma\\<^sub>v_def to_nat_from_nat_id)"], ["", "lemma from_hma_to_hma\\<^sub>m[simp]:\n  \"A \\<in> carrier_mat (CARD('nr)) (CARD('nc)) \\<Longrightarrow> from_hma\\<^sub>m (to_hma\\<^sub>m A :: 'a ^ 'nc  ^ 'nr) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> carrier_mat CARD('nr) CARD('nc) \\<Longrightarrow>\n    from_hma\\<^sub>m (to_hma\\<^sub>m A) = A", "by (auto simp: to_hma\\<^sub>m_def from_hma\\<^sub>m_def to_nat_from_nat_id)"], ["", "lemma from_hma\\<^sub>v_inj[simp]: \"from_hma\\<^sub>v x = from_hma\\<^sub>v y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (from_hma\\<^sub>v x = from_hma\\<^sub>v y) = (x = y)", "by (intro iffI, insert to_hma_from_hma\\<^sub>v[of x], auto)"], ["", "lemma from_hma\\<^sub>m_inj[simp]: \"from_hma\\<^sub>m x = from_hma\\<^sub>m y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (from_hma\\<^sub>m x = from_hma\\<^sub>m y) = (x = y)", "by(intro iffI, insert to_hma_from_hma\\<^sub>m[of x], auto)"], ["", "definition HMA_V :: \"'a Matrix.vec \\<Rightarrow> 'a ^ 'n  \\<Rightarrow> bool\" where \n  \"HMA_V = (\\<lambda> v w. v = from_hma\\<^sub>v w)\""], ["", "definition HMA_M :: \"'a Matrix.mat \\<Rightarrow> 'a ^ 'nc  ^ 'nr  \\<Rightarrow> bool\" where \n  \"HMA_M = (\\<lambda> a b. a = from_hma\\<^sub>m b)\""], ["", "definition HMA_I :: \"nat \\<Rightarrow> 'n :: finite \\<Rightarrow> bool\" where\n  \"HMA_I = (\\<lambda> i a. i = to_nat a)\""], ["", "context includes lifting_syntax\nbegin"], ["", "lemma Domainp_HMA_V [transfer_domain_rule]: \n  \"Domainp (HMA_V :: 'a Matrix.vec \\<Rightarrow> 'a ^ 'n \\<Rightarrow> bool) = (\\<lambda> v. v \\<in> carrier_vec (CARD('n )))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp HMA_V = (\\<lambda>v. v \\<in> carrier_vec CARD('n))", "by(intro ext iffI, insert from_hma_to_hma\\<^sub>v[symmetric], auto simp: from_hma\\<^sub>v_def HMA_V_def)"], ["", "lemma Domainp_HMA_M [transfer_domain_rule]: \n  \"Domainp (HMA_M :: 'a Matrix.mat \\<Rightarrow> 'a ^ 'nc  ^ 'nr  \\<Rightarrow> bool) \n  = (\\<lambda> A. A \\<in> carrier_mat CARD('nr) CARD('nc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp HMA_M = (\\<lambda>A. A \\<in> carrier_mat CARD('nr) CARD('nc))", "by (intro ext iffI, insert from_hma_to_hma\\<^sub>m[symmetric], auto simp: from_hma\\<^sub>m_def HMA_M_def)"], ["", "lemma Domainp_HMA_I [transfer_domain_rule]: \n  \"Domainp (HMA_I :: nat \\<Rightarrow> 'n :: finite \\<Rightarrow> bool) = (\\<lambda> i. i < CARD('n))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp HMA_I = (\\<lambda>i. i < CARD('n))", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. Domainp HMA_I i = (i < CARD('n))", "fix i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. Domainp HMA_I i = (i < CARD('n))", "show \"?l i = ?r i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp HMA_I i = (i < CARD('n))", "unfolding HMA_I_def Domainp_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a. i = Bij_Nat.to_nat a) = (i < CARD('n))", "by (auto intro: exI[of _ \"from_nat i\"] simp: to_nat_from_nat_id to_nat_less_card)"], ["proof (state)\nthis:\n  Domainp HMA_I i = (i < CARD('n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bi_unique_HMA_V [transfer_rule]: \"bi_unique HMA_V\" \"left_unique HMA_V\" \"right_unique HMA_V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique HMA_V &&& left_unique HMA_V &&& right_unique HMA_V", "unfolding HMA_V_def bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        x = from_hma\\<^sub>v y \\<longrightarrow>\n        x = from_hma\\<^sub>v z \\<longrightarrow> y = z) \\<and>\n    (\\<forall>x y z.\n        x = from_hma\\<^sub>v z \\<longrightarrow>\n        y = from_hma\\<^sub>v z \\<longrightarrow> x = y) &&&\n    \\<forall>x y z.\n       x = from_hma\\<^sub>v z \\<longrightarrow>\n       y = from_hma\\<^sub>v z \\<longrightarrow> x = y &&&\n    \\<forall>x y z.\n       x = from_hma\\<^sub>v y \\<longrightarrow>\n       x = from_hma\\<^sub>v z \\<longrightarrow> y = z", "by auto"], ["", "lemma bi_unique_HMA_M [transfer_rule]: \"bi_unique HMA_M\" \"left_unique HMA_M\" \"right_unique HMA_M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique HMA_M &&& left_unique HMA_M &&& right_unique HMA_M", "unfolding HMA_M_def bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        x = from_hma\\<^sub>m y \\<longrightarrow>\n        x = from_hma\\<^sub>m z \\<longrightarrow> y = z) \\<and>\n    (\\<forall>x y z.\n        x = from_hma\\<^sub>m z \\<longrightarrow>\n        y = from_hma\\<^sub>m z \\<longrightarrow> x = y) &&&\n    \\<forall>x y z.\n       x = from_hma\\<^sub>m z \\<longrightarrow>\n       y = from_hma\\<^sub>m z \\<longrightarrow> x = y &&&\n    \\<forall>x y z.\n       x = from_hma\\<^sub>m y \\<longrightarrow>\n       x = from_hma\\<^sub>m z \\<longrightarrow> y = z", "by auto"], ["", "lemma bi_unique_HMA_I [transfer_rule]: \"bi_unique HMA_I\" \"left_unique HMA_I\" \"right_unique HMA_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique HMA_I &&& left_unique HMA_I &&& right_unique HMA_I", "unfolding HMA_I_def bi_unique_def left_unique_def right_unique_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x y z.\n        x = Bij_Nat.to_nat y \\<longrightarrow>\n        x = Bij_Nat.to_nat z \\<longrightarrow> y = z) \\<and>\n    (\\<forall>x y z.\n        x = Bij_Nat.to_nat z \\<longrightarrow>\n        y = Bij_Nat.to_nat z \\<longrightarrow> x = y) &&&\n    \\<forall>x y z.\n       x = Bij_Nat.to_nat z \\<longrightarrow>\n       y = Bij_Nat.to_nat z \\<longrightarrow> x = y &&&\n    \\<forall>x y z.\n       x = Bij_Nat.to_nat y \\<longrightarrow>\n       x = Bij_Nat.to_nat z \\<longrightarrow> y = z", "by auto"], ["", "lemma right_total_HMA_V [transfer_rule]: \"right_total HMA_V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total HMA_V", "unfolding HMA_V_def right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. x = from_hma\\<^sub>v y", "by simp"], ["", "lemma right_total_HMA_M [transfer_rule]: \"right_total HMA_M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total HMA_M", "unfolding HMA_M_def right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. x = from_hma\\<^sub>m y", "by simp"], ["", "lemma right_total_HMA_I [transfer_rule]: \"right_total HMA_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total HMA_I", "unfolding HMA_I_def right_total_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. x = Bij_Nat.to_nat y", "by simp"], ["", "lemma HMA_V_index [transfer_rule]: \"(HMA_V ===> HMA_I ===> (=)) ($v) ($h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_V ===> HMA_I ===> (=)) ($v) ($h)", "unfolding rel_fun_def HMA_V_def HMA_I_def from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x =\n       Matrix.vec CARD('b)\n        (\\<lambda>i. y $h Bij_Nat.from_nat i) \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = Bij_Nat.to_nat ya \\<longrightarrow> x $v xa = y $h ya)", "by (auto simp: to_nat_less_card)"], ["", "text \\<open>We introduce the index function to have pointwise access to \n  HMA-matrices by a constant. Otherwise, the transfer rule \n  with @{term \"\\<lambda> A i j. A $h i $h j\"} instead of index is not applicable.\\<close>"], ["", "definition \"index_hma A i j \\<equiv> A $h i $h j\""], ["", "lemma HMA_M_index [transfer_rule]:\n  \"(HMA_M ===> HMA_I ===> HMA_I ===> (=)) (\\<lambda> A i j. A $$ (i,j)) index_hma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_I ===> HMA_I ===> (=)) (\\<lambda>A i j. A $$ (i, j))\n     index_hma", "by (intro rel_funI, simp add: index_hma_def to_nat_less_card HMA_M_def HMA_I_def from_hma\\<^sub>m_def)"], ["", "lemma HMA_V_0 [transfer_rule]: \"HMA_V (0\\<^sub>v CARD('n)) (0 :: 'a :: zero ^ 'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_V (0\\<^sub>v CARD('n)) 0", "unfolding HMA_V_def from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>v CARD('n) =\n    Matrix.vec CARD('n) (\\<lambda>i. 0 $h Bij_Nat.from_nat i)", "by auto"], ["", "lemma HMA_M_0 [transfer_rule]: \n  \"HMA_M (0\\<^sub>m CARD('nr) CARD('nc)) (0 :: 'a :: zero ^ 'nc  ^ 'nr )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M (0\\<^sub>m CARD('nr) CARD('nc)) 0", "unfolding HMA_M_def from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>m CARD('nr) CARD('nc) =\n    Matrix.mat CARD('nr) CARD('nc)\n     (\\<lambda>(i, j). 0 $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j)", "by auto"], ["", "lemma HMA_M_1[transfer_rule]:\n  \"HMA_M (1\\<^sub>m (CARD('n))) (mat 1 :: 'a::{zero,one}^'n^'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M (1\\<^sub>m CARD('n)) (mat (1::'a))", "unfolding HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>m CARD('n) = from_hma\\<^sub>m (mat (1::'a))", "by (auto simp add: mat_def from_hma\\<^sub>m_def from_nat_inj)"], ["", "lemma from_hma\\<^sub>v_add: \"from_hma\\<^sub>v v + from_hma\\<^sub>v w = from_hma\\<^sub>v (v + w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_hma\\<^sub>v v + from_hma\\<^sub>v w = from_hma\\<^sub>v (v + w)", "unfolding from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec CARD('b) (\\<lambda>i. v $h Bij_Nat.from_nat i) +\n    Matrix.vec CARD('b) (\\<lambda>i. w $h Bij_Nat.from_nat i) =\n    Matrix.vec CARD('b) (\\<lambda>i. (v + w) $h Bij_Nat.from_nat i)", "by auto"], ["", "lemma HMA_V_add [transfer_rule]: \"(HMA_V ===> HMA_V ===> HMA_V) (+) (+) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_V ===> HMA_V ===> HMA_V) (+) (+)", "unfolding rel_fun_def HMA_V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = from_hma\\<^sub>v y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = from_hma\\<^sub>v ya \\<longrightarrow>\n           x + xa = from_hma\\<^sub>v (y + ya))", "by (auto simp: from_hma\\<^sub>v_add)"], ["", "lemma from_hma\\<^sub>v_diff: \"from_hma\\<^sub>v v - from_hma\\<^sub>v w = from_hma\\<^sub>v (v - w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_hma\\<^sub>v v - from_hma\\<^sub>v w = from_hma\\<^sub>v (v - w)", "unfolding from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec CARD('b) (\\<lambda>i. v $h Bij_Nat.from_nat i) -\n    Matrix.vec CARD('b) (\\<lambda>i. w $h Bij_Nat.from_nat i) =\n    Matrix.vec CARD('b) (\\<lambda>i. (v - w) $h Bij_Nat.from_nat i)", "by auto"], ["", "lemma HMA_V_diff [transfer_rule]: \"(HMA_V ===> HMA_V ===> HMA_V) (-) (-)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_V ===> HMA_V ===> HMA_V) (-) (-)", "unfolding rel_fun_def HMA_V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = from_hma\\<^sub>v y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = from_hma\\<^sub>v ya \\<longrightarrow>\n           x - xa = from_hma\\<^sub>v (y - ya))", "by (auto simp: from_hma\\<^sub>v_diff)"], ["", "lemma from_hma\\<^sub>m_add: \"from_hma\\<^sub>m a + from_hma\\<^sub>m b = from_hma\\<^sub>m (a + b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_hma\\<^sub>m a + from_hma\\<^sub>m b = from_hma\\<^sub>m (a + b)", "unfolding from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat CARD('c) CARD('b)\n     (\\<lambda>(i, j). a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j) +\n    Matrix.mat CARD('c) CARD('b)\n     (\\<lambda>(i, j). b $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j) =\n    Matrix.mat CARD('c) CARD('b)\n     (\\<lambda>(i, j). (a + b) $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j)", "by auto"], ["", "lemma HMA_M_add [transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) (+) (+) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> HMA_M) (+) (+)", "unfolding rel_fun_def HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = from_hma\\<^sub>m y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = from_hma\\<^sub>m ya \\<longrightarrow>\n           x + xa = from_hma\\<^sub>m (y + ya))", "by (auto simp: from_hma\\<^sub>m_add)"], ["", "lemma from_hma\\<^sub>m_diff: \"from_hma\\<^sub>m a - from_hma\\<^sub>m b = from_hma\\<^sub>m (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_hma\\<^sub>m a - from_hma\\<^sub>m b = from_hma\\<^sub>m (a - b)", "unfolding from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat CARD('c) CARD('b)\n     (\\<lambda>(i, j). a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j) -\n    Matrix.mat CARD('c) CARD('b)\n     (\\<lambda>(i, j). b $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j) =\n    Matrix.mat CARD('c) CARD('b)\n     (\\<lambda>(i, j). (a - b) $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j)", "by auto"], ["", "lemma HMA_M_diff [transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) (-) (-) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> HMA_M) (-) (-)", "unfolding rel_fun_def HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = from_hma\\<^sub>m y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa = from_hma\\<^sub>m ya \\<longrightarrow>\n           x - xa = from_hma\\<^sub>m (y - ya))", "by (auto simp: from_hma\\<^sub>m_diff)"], ["", "lemma scalar_product: fixes v :: \"'a :: semiring_1 ^ 'n \"\n  shows \"scalar_prod (from_hma\\<^sub>v v) (from_hma\\<^sub>v w) = scalar_product v w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_hma\\<^sub>v v \\<bullet> from_hma\\<^sub>v w = scalar_product v w", "unfolding scalar_product_def scalar_prod_def from_hma\\<^sub>v_def dim_vec"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<CARD('n).\n        Matrix.vec CARD('n) (\\<lambda>i. v $h Bij_Nat.from_nat i) $v i *\n        Matrix.vec CARD('n) (\\<lambda>i. w $h Bij_Nat.from_nat i) $v i) =\n    (\\<Sum>i\\<in>UNIV. v $h i * w $h i)", "by (simp add: sum.reindex[OF inj_to_nat, unfolded range_to_nat])"], ["", "lemma [simp]:\n  \"from_hma\\<^sub>m (y :: 'a ^ 'nc  ^ 'nr) \\<in> carrier_mat (CARD('nr)) (CARD('nc))\"\n  \"dim_row (from_hma\\<^sub>m (y :: 'a ^ 'nc  ^ 'nr )) = CARD('nr)\"\n  \"dim_col (from_hma\\<^sub>m (y :: 'a ^ 'nc  ^ 'nr )) = CARD('nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_hma\\<^sub>m y \\<in> carrier_mat CARD('nr) CARD('nc) &&&\n    dim_row (from_hma\\<^sub>m y) = CARD('nr) &&&\n    dim_col (from_hma\\<^sub>m y) = CARD('nc)", "unfolding from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat CARD('nr) CARD('nc)\n     (\\<lambda>(i, j). y $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j)\n    \\<in> carrier_mat CARD('nr) CARD('nc) &&&\n    dim_row\n     (Matrix.mat CARD('nr) CARD('nc)\n       (\\<lambda>(i, j). y $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j)) =\n    CARD('nr) &&&\n    dim_col\n     (Matrix.mat CARD('nr) CARD('nc)\n       (\\<lambda>(i, j). y $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j)) =\n    CARD('nc)", "by simp_all"], ["", "lemma [simp]:\n  \"from_hma\\<^sub>v (y :: 'a ^ 'n) \\<in> carrier_vec (CARD('n))\"\n  \"dim_vec (from_hma\\<^sub>v (y :: 'a ^ 'n)) = CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_hma\\<^sub>v y \\<in> carrier_vec CARD('n) &&&\n    dim_vec (from_hma\\<^sub>v y) = CARD('n)", "unfolding from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.vec CARD('n) (\\<lambda>i. y $h Bij_Nat.from_nat i)\n    \\<in> carrier_vec CARD('n) &&&\n    dim_vec (Matrix.vec CARD('n) (\\<lambda>i. y $h Bij_Nat.from_nat i)) =\n    CARD('n)", "by simp_all"], ["", "declare rel_funI [intro!]"], ["", "lemma HMA_scalar_prod [transfer_rule]:\n  \"(HMA_V ===> HMA_V ===> (=)) scalar_prod scalar_product\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_V ===> HMA_V ===> (=)) (\\<bullet>) scalar_product", "by (auto simp: HMA_V_def scalar_product)"], ["", "lemma HMA_row [transfer_rule]: \"(HMA_I ===> HMA_M ===> HMA_V) (\\<lambda> i a. Matrix.row a i) row\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_I ===> HMA_M ===> HMA_V) (\\<lambda>i a. Matrix.row a i) row", "unfolding HMA_M_def HMA_I_def HMA_V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>i a. i = Bij_Nat.to_nat a) ===>\n     (\\<lambda>a b. a = from_hma\\<^sub>m b) ===>\n     (\\<lambda>v w. v = from_hma\\<^sub>v w))\n     (\\<lambda>i a. Matrix.row a i) row", "by (auto simp: from_hma\\<^sub>m_def from_hma\\<^sub>v_def to_nat_less_card row_def)"], ["", "lemma HMA_col [transfer_rule]: \"(HMA_I ===> HMA_M ===> HMA_V) (\\<lambda> i a. col a i) column\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_I ===> HMA_M ===> HMA_V) (\\<lambda>i a. col a i) column", "unfolding HMA_M_def HMA_I_def HMA_V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>i a. i = Bij_Nat.to_nat a) ===>\n     (\\<lambda>a b. a = from_hma\\<^sub>m b) ===>\n     (\\<lambda>v w. v = from_hma\\<^sub>v w))\n     (\\<lambda>i a. col a i) column", "by (auto simp: from_hma\\<^sub>m_def from_hma\\<^sub>v_def to_nat_less_card column_def)"], ["", "definition mk_mat :: \"('i \\<Rightarrow> 'j \\<Rightarrow> 'c) \\<Rightarrow> 'c^'j^'i\" where\n  \"mk_mat f = (\\<chi> i j. f i j)\""], ["", "definition mk_vec :: \"('i \\<Rightarrow> 'c) \\<Rightarrow> 'c^'i\" where\n  \"mk_vec f = (\\<chi> i. f i)\""], ["", "lemma HMA_M_mk_mat[transfer_rule]: \"((HMA_I ===> HMA_I ===> (=)) ===> HMA_M) \n  (\\<lambda> f. Matrix.mat (CARD('nr)) (CARD('nc)) (\\<lambda> (i,j). f i j)) \n  (mk_mat :: (('nr \\<Rightarrow> 'nc \\<Rightarrow> 'a) \\<Rightarrow> 'a^'nc^'nr))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((HMA_I ===> HMA_I ===> (=)) ===> HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     local.mk_mat", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((HMA_I ===> HMA_I ===> (=)) ===> HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     local.mk_mat", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ((HMA_I ===> HMA_I ===> (=)) ===> HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     local.mk_mat", "fix x y i j"], ["proof (state)\ngoal (1 subgoal):\n 1. ((HMA_I ===> HMA_I ===> (=)) ===> HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     local.mk_mat", "assume id: \"\\<forall> (ya :: 'nr) (yb :: 'nc). (x (to_nat ya) (to_nat yb) :: 'a) = y ya yb\"\n       and i: \"i < CARD('nr)\" and j: \"j < CARD('nc)\""], ["proof (state)\nthis:\n  \\<forall>ya yb. x (Bij_Nat.to_nat ya) (Bij_Nat.to_nat yb) = y ya yb\n  i < CARD('nr)\n  j < CARD('nc)\n\ngoal (1 subgoal):\n 1. ((HMA_I ===> HMA_I ===> (=)) ===> HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     local.mk_mat", "from to_nat_from_nat_id[OF i] to_nat_from_nat_id[OF j] id[rule_format, of \"from_nat i\" \"from_nat j\"]"], ["proof (chain)\npicking this:\n  Bij_Nat.to_nat (Bij_Nat.from_nat i) = i\n  Bij_Nat.to_nat (Bij_Nat.from_nat j) = j\n  x (Bij_Nat.to_nat (Bij_Nat.from_nat i))\n   (Bij_Nat.to_nat (Bij_Nat.from_nat j)) =\n  y (Bij_Nat.from_nat i) (Bij_Nat.from_nat j)", "have \"x i j = y (from_nat i) (from_nat j)\""], ["proof (prove)\nusing this:\n  Bij_Nat.to_nat (Bij_Nat.from_nat i) = i\n  Bij_Nat.to_nat (Bij_Nat.from_nat j) = j\n  x (Bij_Nat.to_nat (Bij_Nat.from_nat i))\n   (Bij_Nat.to_nat (Bij_Nat.from_nat j)) =\n  y (Bij_Nat.from_nat i) (Bij_Nat.from_nat j)\n\ngoal (1 subgoal):\n 1. x i j = y (Bij_Nat.from_nat i) (Bij_Nat.from_nat j)", "by auto"], ["proof (state)\nthis:\n  x i j = y (Bij_Nat.from_nat i) (Bij_Nat.from_nat j)\n\ngoal (1 subgoal):\n 1. ((HMA_I ===> HMA_I ===> (=)) ===> HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     local.mk_mat", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>ya yb.\n              ?x2 (Bij_Nat.to_nat ya) (Bij_Nat.to_nat yb) = ?y2 ya yb;\n   ?i2 < CARD('nr); ?j2 < CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> ?x2 ?i2 ?j2 =\n                    ?y2 (Bij_Nat.from_nat ?i2) (Bij_Nat.from_nat ?j2)\n\ngoal (1 subgoal):\n 1. ((HMA_I ===> HMA_I ===> (=)) ===> HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     local.mk_mat", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>ya yb.\n              ?x2 (Bij_Nat.to_nat ya) (Bij_Nat.to_nat yb) = ?y2 ya yb;\n   ?i2 < CARD('nr); ?j2 < CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> ?x2 ?i2 ?j2 =\n                    ?y2 (Bij_Nat.from_nat ?i2) (Bij_Nat.from_nat ?j2)\n\ngoal (1 subgoal):\n 1. ((HMA_I ===> HMA_I ===> (=)) ===> HMA_M)\n     (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n     local.mk_mat", "unfolding rel_fun_def mk_mat_def HMA_M_def HMA_I_def from_hma\\<^sub>m_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>ya yb.\n              ?x2 (Bij_Nat.to_nat ya) (Bij_Nat.to_nat yb) = ?y2 ya yb;\n   ?i2 < CARD('nr); ?j2 < CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> ?x2 ?i2 ?j2 =\n                    ?y2 (Bij_Nat.from_nat ?i2) (Bij_Nat.from_nat ?j2)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<forall>xa ya.\n           xa = Bij_Nat.to_nat ya \\<longrightarrow>\n           (\\<forall>xb yb.\n               xb = Bij_Nat.to_nat yb \\<longrightarrow>\n               x xa xb = y ya yb)) \\<longrightarrow>\n       Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(xa, y). x xa y) =\n       Matrix.mat CARD('nr) CARD('nc)\n        (\\<lambda>(i, j).\n            (\\<chi>i. vec_lambda (y i)) $h Bij_Nat.from_nat i $h\n            Bij_Nat.from_nat j)", "by auto"], ["proof (state)\nthis:\n  ((HMA_I ===> HMA_I ===> (=)) ===> HMA_M)\n   (\\<lambda>f. Matrix.mat CARD('nr) CARD('nc) (\\<lambda>(i, j). f i j))\n   local.mk_mat\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_M_mk_vec[transfer_rule]: \"((HMA_I ===> (=)) ===> HMA_V) \n  (\\<lambda> f. Matrix.vec (CARD('n)) (\\<lambda> i. f i)) \n  (mk_vec :: (('n \\<Rightarrow> 'a) \\<Rightarrow> 'a^'n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((HMA_I ===> (=)) ===> HMA_V) (Matrix.vec CARD('n)) local.mk_vec", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((HMA_I ===> (=)) ===> HMA_V) (Matrix.vec CARD('n)) local.mk_vec", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ((HMA_I ===> (=)) ===> HMA_V) (Matrix.vec CARD('n)) local.mk_vec", "fix x y i"], ["proof (state)\ngoal (1 subgoal):\n 1. ((HMA_I ===> (=)) ===> HMA_V) (Matrix.vec CARD('n)) local.mk_vec", "assume id: \"\\<forall> (ya :: 'n). (x (to_nat ya) :: 'a) = y ya\"\n       and i: \"i < CARD('n)\""], ["proof (state)\nthis:\n  \\<forall>ya. x (Bij_Nat.to_nat ya) = y ya\n  i < CARD('n)\n\ngoal (1 subgoal):\n 1. ((HMA_I ===> (=)) ===> HMA_V) (Matrix.vec CARD('n)) local.mk_vec", "from to_nat_from_nat_id[OF i] id[rule_format, of \"from_nat i\"]"], ["proof (chain)\npicking this:\n  Bij_Nat.to_nat (Bij_Nat.from_nat i) = i\n  x (Bij_Nat.to_nat (Bij_Nat.from_nat i)) = y (Bij_Nat.from_nat i)", "have \"x i = y (from_nat i)\""], ["proof (prove)\nusing this:\n  Bij_Nat.to_nat (Bij_Nat.from_nat i) = i\n  x (Bij_Nat.to_nat (Bij_Nat.from_nat i)) = y (Bij_Nat.from_nat i)\n\ngoal (1 subgoal):\n 1. x i = y (Bij_Nat.from_nat i)", "by auto"], ["proof (state)\nthis:\n  x i = y (Bij_Nat.from_nat i)\n\ngoal (1 subgoal):\n 1. ((HMA_I ===> (=)) ===> HMA_V) (Matrix.vec CARD('n)) local.mk_vec", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>ya. ?x2 (Bij_Nat.to_nat ya) = ?y2 ya;\n   ?i2 < CARD('n)\\<rbrakk>\n  \\<Longrightarrow> ?x2 ?i2 = ?y2 (Bij_Nat.from_nat ?i2)\n\ngoal (1 subgoal):\n 1. ((HMA_I ===> (=)) ===> HMA_V) (Matrix.vec CARD('n)) local.mk_vec", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>ya. ?x2 (Bij_Nat.to_nat ya) = ?y2 ya;\n   ?i2 < CARD('n)\\<rbrakk>\n  \\<Longrightarrow> ?x2 ?i2 = ?y2 (Bij_Nat.from_nat ?i2)\n\ngoal (1 subgoal):\n 1. ((HMA_I ===> (=)) ===> HMA_V) (Matrix.vec CARD('n)) local.mk_vec", "unfolding rel_fun_def mk_vec_def HMA_V_def HMA_I_def from_hma\\<^sub>v_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>ya. ?x2 (Bij_Nat.to_nat ya) = ?y2 ya;\n   ?i2 < CARD('n)\\<rbrakk>\n  \\<Longrightarrow> ?x2 ?i2 = ?y2 (Bij_Nat.from_nat ?i2)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<forall>xa ya.\n           xa = Bij_Nat.to_nat ya \\<longrightarrow>\n           x xa = y ya) \\<longrightarrow>\n       Matrix.vec CARD('n) x =\n       Matrix.vec CARD('n) (\\<lambda>i. vec_lambda y $h Bij_Nat.from_nat i)", "by auto"], ["proof (state)\nthis:\n  ((HMA_I ===> (=)) ===> HMA_V) (Matrix.vec CARD('n)) local.mk_vec\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_mult_scalar: \"A ** B = mk_mat (\\<lambda> i j. scalar_product (row i A) (column j B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ** B =\n    local.mk_mat (\\<lambda>i j. scalar_product (row i A) (column j B))", "unfolding vec_eq_iff matrix_matrix_mult_def scalar_product_def mk_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       (\\<chi>i j. \\<Sum>k\\<in>UNIV. A $h i $h k * B $h k $h j) $h i $h ia =\n       (\\<chi>i j. \\<Sum>ia\\<in>UNIV. row i A $h ia * column j B $h ia) $h\n       i $h\n       ia", "by (auto simp: row_def column_def)"], ["", "lemma mult_mat_vec_scalar: \"A *v v = mk_vec (\\<lambda> i. scalar_product (row i A) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v v = local.mk_vec (\\<lambda>i. scalar_product (row i A) v)", "unfolding vec_eq_iff matrix_vector_mult_def scalar_product_def mk_mat_def mk_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<chi>i. \\<Sum>j\\<in>UNIV. A $h i $h j * v $h j) $h i =\n       (\\<chi>i. \\<Sum>ia\\<in>UNIV. row i A $h ia * v $h ia) $h i", "by (auto simp: row_def column_def)"], ["", "lemma dim_row_transfer_rule: \n  \"HMA_M A (A' :: 'a ^ 'nc ^ 'nr) \\<Longrightarrow> (=) (dim_row A) (CARD('nr))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M A A' \\<Longrightarrow> dim_row A = CARD('nr)", "unfolding HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = from_hma\\<^sub>m A' \\<Longrightarrow> dim_row A = CARD('nr)", "by auto"], ["", "lemma dim_col_transfer_rule: \n  \"HMA_M A (A' :: 'a ^ 'nc ^ 'nr) \\<Longrightarrow> (=) (dim_col A) (CARD('nc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M A A' \\<Longrightarrow> dim_col A = CARD('nc)", "unfolding HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = from_hma\\<^sub>m A' \\<Longrightarrow> dim_col A = CARD('nc)", "by auto"], ["", "lemma HMA_M_mult [transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) ((*)) ((**))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> HMA_M) (*) (**)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> HMA_M) (*) (**)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> HMA_M) (*) (**)", "fix A B :: \"'a :: semiring_1 mat\" and A' :: \"'a ^ 'n  ^ 'nr\" and B' :: \"'a ^ 'nc ^ 'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> HMA_M) (*) (**)", "assume 1[transfer_rule]: \"HMA_M A A'\" \"HMA_M B B'\""], ["proof (state)\nthis:\n  HMA_M A A'\n  HMA_M B B'\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> HMA_M) (*) (**)", "note [transfer_rule] = dim_row_transfer_rule[OF 1(1)] dim_col_transfer_rule[OF 1(2)]"], ["proof (state)\nthis:\n  dim_row A = CARD('nr)\n  dim_col B = CARD('nc)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> HMA_M) (*) (**)", "have \"HMA_M (A * B) (A' ** B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M (A * B) (A' ** B')", "unfolding times_mat_def mat_mult_scalar"], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M\n     (Matrix.mat (dim_row A) (dim_col B)\n       (\\<lambda>(i, j). Matrix.row A i \\<bullet> col B j))\n     (local.mk_mat (\\<lambda>i j. scalar_product (row i A') (column j B')))", "by (transfer_prover_start, transfer_step+, transfer, auto)"], ["proof (state)\nthis:\n  HMA_M (A * B) (A' ** B')\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> HMA_M) (*) (**)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>HMA_M ?A2 ?A'2; HMA_M ?B2 ?B'2\\<rbrakk>\n  \\<Longrightarrow> HMA_M (?A2 * ?B2) (?A'2 ** ?B'2)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> HMA_M) (*) (**)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>HMA_M ?A2 ?A'2; HMA_M ?B2 ?B'2\\<rbrakk>\n  \\<Longrightarrow> HMA_M (?A2 * ?B2) (?A'2 ** ?B'2)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> HMA_M) (*) (**)", "by blast"], ["proof (state)\nthis:\n  (HMA_M ===> HMA_M ===> HMA_M) (*) (**)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_V_smult [transfer_rule]: \"((=) ===> HMA_V ===> HMA_V) (\\<cdot>\\<^sub>v) ((*s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> HMA_V ===> HMA_V) (\\<cdot>\\<^sub>v) (*s)", "unfolding smult_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> HMA_V ===> HMA_V)\n     (\\<lambda>a v. Matrix.vec (dim_vec v) (\\<lambda>i. a * v $v i)) (*s)", "unfolding rel_fun_def HMA_V_def from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = y \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa =\n           Matrix.vec CARD('b)\n            (\\<lambda>i. ya $h Bij_Nat.from_nat i) \\<longrightarrow>\n           Matrix.vec (dim_vec xa) (\\<lambda>i. x * xa $v i) =\n           Matrix.vec CARD('b)\n            (\\<lambda>i. (y *s ya) $h Bij_Nat.from_nat i))", "by auto"], ["", "lemma HMA_M_mult_vec [transfer_rule]: \"(HMA_M ===> HMA_V ===> HMA_V) ((*\\<^sub>v)) ((*v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> HMA_V) (*\\<^sub>v) (*v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> HMA_V) (*\\<^sub>v) (*v)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> HMA_V) (*\\<^sub>v) (*v)", "fix A :: \"'a :: semiring_1 mat\" and v :: \"'a Matrix.vec\"\n      and A' :: \"'a ^ 'nc  ^ 'nr\" and v' :: \"'a ^ 'nc\""], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> HMA_V) (*\\<^sub>v) (*v)", "assume 1[transfer_rule]: \"HMA_M A A'\" \"HMA_V v v'\""], ["proof (state)\nthis:\n  HMA_M A A'\n  HMA_V v v'\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> HMA_V) (*\\<^sub>v) (*v)", "note [transfer_rule] = dim_row_transfer_rule"], ["proof (state)\nthis:\n  HMA_M ?A ?A' \\<Longrightarrow> dim_row ?A = CARD(?'nr)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> HMA_V) (*\\<^sub>v) (*v)", "have \"HMA_V (A *\\<^sub>v v) (A' *v v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_V (A *\\<^sub>v v) (A' *v v')", "unfolding mult_mat_vec_def mult_mat_vec_scalar"], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_V (Matrix.vec (dim_row A) (\\<lambda>i. Matrix.row A i \\<bullet> v))\n     (local.mk_vec (\\<lambda>i. scalar_product (row i A') v'))", "by (transfer_prover_start, transfer_step+, transfer, auto)"], ["proof (state)\nthis:\n  HMA_V (A *\\<^sub>v v) (A' *v v')\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> HMA_V) (*\\<^sub>v) (*v)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>HMA_M ?A2 ?A'2; HMA_V ?v2 ?v'2\\<rbrakk>\n  \\<Longrightarrow> HMA_V (?A2 *\\<^sub>v ?v2) (?A'2 *v ?v'2)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> HMA_V) (*\\<^sub>v) (*v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>HMA_M ?A2 ?A'2; HMA_V ?v2 ?v'2\\<rbrakk>\n  \\<Longrightarrow> HMA_V (?A2 *\\<^sub>v ?v2) (?A'2 *v ?v'2)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> HMA_V) (*\\<^sub>v) (*v)", "by blast"], ["proof (state)\nthis:\n  (HMA_M ===> HMA_V ===> HMA_V) (*\\<^sub>v) (*v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_det [transfer_rule]: \"(HMA_M ===> (=)) Determinant.det \n  (det :: 'a :: comm_ring_1 ^ 'n ^ 'n \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "fix a :: \"'a ^ 'n ^ 'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "let ?tn = \"to_nat :: 'n :: finite \\<Rightarrow> nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "let ?fn = \"from_nat :: nat \\<Rightarrow> 'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "let ?zn = \"{0..< CARD('n)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "let ?U = \"UNIV :: 'n set\""], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "let ?p1 = \"{p. p permutes ?zn}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "let ?p2 = \"{p. p permutes ?U}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "let ?f= \"\\<lambda> p i. if i \\<in> ?U then ?fn (p (?tn i)) else i\""], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "let ?g = \"\\<lambda> p i. ?fn (p (?tn i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "have fg: \"\\<And> a b c. (if a \\<in> ?U then b else c) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. (if a \\<in> UNIV then b else c) = b", "by auto"], ["proof (state)\nthis:\n  (if ?a \\<in> UNIV then ?b else ?c) = ?b\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "have \"?p2 = ?f ` ?p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. p permutes UNIV} =\n    (\\<lambda>p i.\n        if i \\<in> UNIV then Bij_Nat.from_nat (p (Bij_Nat.to_nat i))\n        else i) `\n    {p. p permutes {0..<CARD('n)}}", "by (rule permutes_bij', auto simp: to_nat_less_card to_nat_from_nat_id)"], ["proof (state)\nthis:\n  {p. p permutes UNIV} =\n  (\\<lambda>p i.\n      if i \\<in> UNIV then Bij_Nat.from_nat (p (Bij_Nat.to_nat i)) else i) `\n  {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "hence id: \"?p2 = ?g ` ?p1\""], ["proof (prove)\nusing this:\n  {p. p permutes UNIV} =\n  (\\<lambda>p i.\n      if i \\<in> UNIV then Bij_Nat.from_nat (p (Bij_Nat.to_nat i)) else i) `\n  {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. {p. p permutes UNIV} =\n    (\\<lambda>p i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) `\n    {p. p permutes {0..<CARD('n)}}", "by simp"], ["proof (state)\nthis:\n  {p. p permutes UNIV} =\n  (\\<lambda>p i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) `\n  {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "have inj_g: \"inj_on ?g ?p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>p i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))\n     {p. p permutes {0..<CARD('n)}}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{p. p permutes {0..<CARD('n)}}.\n       \\<forall>y\\<in>{p. p permutes {0..<CARD('n)}}.\n          (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))) =\n          (\\<lambda>i.\n              Bij_Nat.from_nat (y (Bij_Nat.to_nat i))) \\<longrightarrow>\n          x = y", "proof (intro ballI impI ext, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))) =\n        (\\<lambda>i. Bij_Nat.from_nat (y (Bij_Nat.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "fix p q i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))) =\n        (\\<lambda>i. Bij_Nat.from_nat (y (Bij_Nat.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "assume p: \"p permutes ?zn\" and q: \"q permutes ?zn\"\n        and id: \"(\\<lambda> i. ?fn (p (?tn i))) = (\\<lambda> i. ?fn (q (?tn i)))\""], ["proof (state)\nthis:\n  p permutes {0..<CARD('n)}\n  q permutes {0..<CARD('n)}\n  (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) =\n  (\\<lambda>i. Bij_Nat.from_nat (q (Bij_Nat.to_nat i)))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))) =\n        (\\<lambda>i. Bij_Nat.from_nat (y (Bij_Nat.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "{"], ["proof (state)\nthis:\n  p permutes {0..<CARD('n)}\n  q permutes {0..<CARD('n)}\n  (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) =\n  (\\<lambda>i. Bij_Nat.from_nat (q (Bij_Nat.to_nat i)))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))) =\n        (\\<lambda>i. Bij_Nat.from_nat (y (Bij_Nat.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))) =\n        (\\<lambda>i. Bij_Nat.from_nat (y (Bij_Nat.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "from permutes_in_image[OF p]"], ["proof (chain)\npicking this:\n  (p ?x \\<in> {0..<CARD('n)}) = (?x \\<in> {0..<CARD('n)})", "have pi: \"p (?tn i) < CARD('n)\""], ["proof (prove)\nusing this:\n  (p ?x \\<in> {0..<CARD('n)}) = (?x \\<in> {0..<CARD('n)})\n\ngoal (1 subgoal):\n 1. p (Bij_Nat.to_nat i) < CARD('n)", "by (simp add: to_nat_less_card)"], ["proof (state)\nthis:\n  p (Bij_Nat.to_nat i) < CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))) =\n        (\\<lambda>i. Bij_Nat.from_nat (y (Bij_Nat.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "from permutes_in_image[OF q]"], ["proof (chain)\npicking this:\n  (q ?x \\<in> {0..<CARD('n)}) = (?x \\<in> {0..<CARD('n)})", "have qi: \"q (?tn i) < CARD('n)\""], ["proof (prove)\nusing this:\n  (q ?x \\<in> {0..<CARD('n)}) = (?x \\<in> {0..<CARD('n)})\n\ngoal (1 subgoal):\n 1. q (Bij_Nat.to_nat i) < CARD('n)", "by (simp add: to_nat_less_card)"], ["proof (state)\nthis:\n  q (Bij_Nat.to_nat i) < CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))) =\n        (\\<lambda>i. Bij_Nat.from_nat (y (Bij_Nat.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "from fun_cong[OF id]"], ["proof (chain)\npicking this:\n  Bij_Nat.from_nat (p (Bij_Nat.to_nat ?x)) =\n  Bij_Nat.from_nat (q (Bij_Nat.to_nat ?x))", "have \"?fn (p (?tn i))  = from_nat (q (?tn i))\""], ["proof (prove)\nusing this:\n  Bij_Nat.from_nat (p (Bij_Nat.to_nat ?x)) =\n  Bij_Nat.from_nat (q (Bij_Nat.to_nat ?x))\n\ngoal (1 subgoal):\n 1. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)) =\n    Bij_Nat.from_nat (q (Bij_Nat.to_nat i))", "."], ["proof (state)\nthis:\n  Bij_Nat.from_nat (p (Bij_Nat.to_nat i)) =\n  Bij_Nat.from_nat (q (Bij_Nat.to_nat i))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))) =\n        (\\<lambda>i. Bij_Nat.from_nat (y (Bij_Nat.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "from arg_cong[OF this, of ?tn]"], ["proof (chain)\npicking this:\n  Bij_Nat.to_nat (Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) =\n  Bij_Nat.to_nat (Bij_Nat.from_nat (q (Bij_Nat.to_nat i)))", "have \"p (?tn i) = q (?tn i)\""], ["proof (prove)\nusing this:\n  Bij_Nat.to_nat (Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) =\n  Bij_Nat.to_nat (Bij_Nat.from_nat (q (Bij_Nat.to_nat i)))\n\ngoal (1 subgoal):\n 1. p (Bij_Nat.to_nat i) = q (Bij_Nat.to_nat i)", "by (simp add: to_nat_from_nat_id pi qi)"], ["proof (state)\nthis:\n  p (Bij_Nat.to_nat i) = q (Bij_Nat.to_nat i)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))) =\n        (\\<lambda>i. Bij_Nat.from_nat (y (Bij_Nat.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "}"], ["proof (state)\nthis:\n  p (Bij_Nat.to_nat ?ia3) = q (Bij_Nat.to_nat ?ia3)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))) =\n        (\\<lambda>i. Bij_Nat.from_nat (y (Bij_Nat.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "note id = this"], ["proof (state)\nthis:\n  p (Bij_Nat.to_nat ?ia3) = q (Bij_Nat.to_nat ?ia3)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>x permutes {0..<CARD('n)}; y permutes {0..<CARD('n)};\n        (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))) =\n        (\\<lambda>i. Bij_Nat.from_nat (y (Bij_Nat.to_nat i)))\\<rbrakk>\n       \\<Longrightarrow> x xa = y xa", "show \"p i = q i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p i = q i", "proof (cases \"i < CARD('n)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < CARD('n) \\<Longrightarrow> p i = q i\n 2. \\<not> i < CARD('n) \\<Longrightarrow> p i = q i", "case True"], ["proof (state)\nthis:\n  i < CARD('n)\n\ngoal (2 subgoals):\n 1. i < CARD('n) \\<Longrightarrow> p i = q i\n 2. \\<not> i < CARD('n) \\<Longrightarrow> p i = q i", "hence \"?tn (?fn i) = i\""], ["proof (prove)\nusing this:\n  i < CARD('n)\n\ngoal (1 subgoal):\n 1. Bij_Nat.to_nat (Bij_Nat.from_nat i) = i", "by (simp add: to_nat_from_nat_id)"], ["proof (state)\nthis:\n  Bij_Nat.to_nat (Bij_Nat.from_nat i) = i\n\ngoal (2 subgoals):\n 1. i < CARD('n) \\<Longrightarrow> p i = q i\n 2. \\<not> i < CARD('n) \\<Longrightarrow> p i = q i", "from id[of \"?fn i\", unfolded this]"], ["proof (chain)\npicking this:\n  p i = q i", "show ?thesis"], ["proof (prove)\nusing this:\n  p i = q i\n\ngoal (1 subgoal):\n 1. p i = q i", "."], ["proof (state)\nthis:\n  p i = q i\n\ngoal (1 subgoal):\n 1. \\<not> i < CARD('n) \\<Longrightarrow> p i = q i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < CARD('n) \\<Longrightarrow> p i = q i", "case False"], ["proof (state)\nthis:\n  \\<not> i < CARD('n)\n\ngoal (1 subgoal):\n 1. \\<not> i < CARD('n) \\<Longrightarrow> p i = q i", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i < CARD('n)\n\ngoal (1 subgoal):\n 1. p i = q i", "using p q"], ["proof (prove)\nusing this:\n  \\<not> i < CARD('n)\n  p permutes {0..<CARD('n)}\n  q permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. p i = q i", "unfolding permutes_def"], ["proof (prove)\nusing this:\n  \\<not> i < CARD('n)\n  (\\<forall>x. x \\<notin> {0..<CARD('n)} \\<longrightarrow> p x = x) \\<and>\n  (\\<forall>y. \\<exists>!x. p x = y)\n  (\\<forall>x. x \\<notin> {0..<CARD('n)} \\<longrightarrow> q x = x) \\<and>\n  (\\<forall>y. \\<exists>!x. q x = y)\n\ngoal (1 subgoal):\n 1. p i = q i", "by simp"], ["proof (state)\nthis:\n  p i = q i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p i = q i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (\\<lambda>p i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))\n   {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "have mult_cong: \"\\<And> a b c d. a = b \\<Longrightarrow> c = d \\<Longrightarrow> a * c = b * d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>a = b; c = d\\<rbrakk> \\<Longrightarrow> a * c = b * d", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?a1 = ?b1; ?c1 = ?d1\\<rbrakk>\n  \\<Longrightarrow> ?a1 * ?c1 = ?b1 * ?d1\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "have \"sum (\\<lambda> p. \n      signof p * (\\<Prod>i\\<in>?zn. a $h ?fn i $h ?fn (p i))) ?p1\n      = sum (\\<lambda> p. of_int (sign p) * (\\<Prod>i\\<in>UNIV. a $h i $h p i)) ?p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<CARD('n)}.\n       signof p *\n       (\\<Prod>i = 0..<CARD('n).\n           a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (p i))) =\n    (\\<Sum>p | p permutes UNIV.\n       of_int (sign p) * (\\<Prod>i\\<in>UNIV. a $h i $h p i))", "unfolding id sum.reindex[OF inj_g]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p | p permutes {0..<CARD('n)}.\n       signof p *\n       (\\<Prod>i = 0..<CARD('n).\n           a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (p i))) =\n    sum ((\\<lambda>p.\n             of_int (sign p) * (\\<Prod>i\\<in>UNIV. a $h i $h p i)) \\<circ>\n         (\\<lambda>p i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     {p. p permutes {0..<CARD('n)}}", "proof (rule sum.cong[OF refl], unfold mem_Collect_eq o_def, rule mult_cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int (sign (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h Bij_Nat.from_nat (x (Bij_Nat.to_nat i)))", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int (sign (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h Bij_Nat.from_nat (x (Bij_Nat.to_nat i)))", "assume p: \"p permutes ?zn\""], ["proof (state)\nthis:\n  p permutes {0..<CARD('n)}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int (sign (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h Bij_Nat.from_nat (x (Bij_Nat.to_nat i)))", "let ?q = \"\\<lambda> i. ?fn (p (?tn i))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int (sign (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h Bij_Nat.from_nat (x (Bij_Nat.to_nat i)))", "from id p"], ["proof (chain)\npicking this:\n  {p. p permutes UNIV} =\n  (\\<lambda>p i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) `\n  {p. p permutes {0..<CARD('n)}}\n  p permutes {0..<CARD('n)}", "have q: \"?q permutes ?U\""], ["proof (prove)\nusing this:\n  {p. p permutes UNIV} =\n  (\\<lambda>p i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) `\n  {p. p permutes {0..<CARD('n)}}\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) permutes UNIV", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) permutes UNIV\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int (sign (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h Bij_Nat.from_nat (x (Bij_Nat.to_nat i)))", "from p"], ["proof (chain)\npicking this:\n  p permutes {0..<CARD('n)}", "have pp: \"permutation p\""], ["proof (prove)\nusing this:\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. permutation p", "unfolding permutation_permutes"], ["proof (prove)\nusing this:\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. \\<exists>S. finite S \\<and> p permutes S", "by auto"], ["proof (state)\nthis:\n  permutation p\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int (sign (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h Bij_Nat.from_nat (x (Bij_Nat.to_nat i)))", "let ?ft = \"\\<lambda> p i. ?fn (p (?tn i))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int (sign (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h Bij_Nat.from_nat (x (Bij_Nat.to_nat i)))", "have fin: \"finite ?zn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {0..<CARD('n)}", "by simp"], ["proof (state)\nthis:\n  finite {0..<CARD('n)}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int (sign (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h Bij_Nat.from_nat (x (Bij_Nat.to_nat i)))", "have \"sign p = sign ?q \\<and> p permutes ?zn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign p =\n    sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n    p permutes {0..<CARD('n)}", "proof (induct rule: permutes_induct[OF fin _ _ p])"], ["proof (state)\ngoal (2 subgoals):\n 1. sign id =\n    sign (\\<lambda>i. Bij_Nat.from_nat (id (Bij_Nat.to_nat i))) \\<and>\n    id permutes {0..<CARD('n)}\n 2. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sign id =\n    sign (\\<lambda>i. Bij_Nat.from_nat (id (Bij_Nat.to_nat i))) \\<and>\n    id permutes {0..<CARD('n)}\n 2. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign id =\n    sign (\\<lambda>i. Bij_Nat.from_nat (id (Bij_Nat.to_nat i))) \\<and>\n    id permutes {0..<CARD('n)}", "by (auto simp: sign_id[unfolded id_def] permutes_id[unfolded id_def])"], ["proof (state)\nthis:\n  sign id =\n  sign (\\<lambda>i. Bij_Nat.from_nat (id (Bij_Nat.to_nat i))) \\<and>\n  id permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "case (2 a b p)"], ["proof (state)\nthis:\n  a \\<in> {0..<CARD('n)}\n  b \\<in> {0..<CARD('n)}\n  sign p = sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n  p permutes {0..<CARD('n)}\n  sign p = sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n  p permutes {0..<CARD('n)}\n  permutation p\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "let ?sab = \"Fun.swap a b id\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "let ?sfab = \"Fun.swap (?fn a) (?fn b) id\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "have p_sab: \"permutation ?sab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation (Fun.swap a b id)", "by (rule permutation_swap_id)"], ["proof (state)\nthis:\n  permutation (Fun.swap a b id)\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "have p_sfab: \"permutation ?sfab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permutation (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id)", "by (rule permutation_swap_id)"], ["proof (state)\nthis:\n  permutation (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id)\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "from 2(3)"], ["proof (chain)\npicking this:\n  sign p = sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n  p permutes {0..<CARD('n)}", "have IH1: \"p permutes ?zn\" and IH2: \"sign p = sign (?ft p)\""], ["proof (prove)\nusing this:\n  sign p = sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. p permutes {0..<CARD('n)} &&&\n    sign p = sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))", "by auto"], ["proof (state)\nthis:\n  p permutes {0..<CARD('n)}\n  sign p = sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "have sab_perm: \"?sab permutes ?zn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun.swap a b id permutes {0..<CARD('n)}", "using 2(1-2)"], ["proof (prove)\nusing this:\n  a \\<in> {0..<CARD('n)}\n  b \\<in> {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. Fun.swap a b id permutes {0..<CARD('n)}", "by (rule permutes_swap_id)"], ["proof (state)\nthis:\n  Fun.swap a b id permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "from permutes_compose[OF IH1 this]"], ["proof (chain)\npicking this:\n  Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "have perm1: \"?sab o p permutes ?zn\""], ["proof (prove)\nusing this:\n  Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "."], ["proof (state)\nthis:\n  Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "from IH1"], ["proof (chain)\npicking this:\n  p permutes {0..<CARD('n)}", "have p_p1: \"p \\<in> ?p1\""], ["proof (prove)\nusing this:\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. p \\<in> {p. p permutes {0..<CARD('n)}}", "by simp"], ["proof (state)\nthis:\n  p \\<in> {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "hence \"?ft p \\<in> ?ft ` ?p1\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))\n    \\<in> (\\<lambda>p i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) `\n          {p. p permutes {0..<CARD('n)}}", "by (rule imageI)"], ["proof (state)\nthis:\n  (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))\n  \\<in> (\\<lambda>p i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) `\n        {p. p permutes {0..<CARD('n)}}\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "from this[folded id]"], ["proof (chain)\npicking this:\n  (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))\n  \\<in> {p. p permutes UNIV}", "have \"?ft p permutes ?U\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))\n  \\<in> {p. p permutes UNIV}\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) permutes UNIV", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) permutes UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "hence p_ftp: \"permutation (?ft p)\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) permutes UNIV\n\ngoal (1 subgoal):\n 1. permutation (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))", "unfolding permutation_permutes"], ["proof (prove)\nusing this:\n  (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) permutes UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>S.\n       finite S \\<and>\n       (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) permutes S", "by auto"], ["proof (state)\nthis:\n  permutation (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "{"], ["proof (state)\nthis:\n  permutation (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "assume a: \"a \\<in> ?zn\" and b: \"b \\<in> ?zn\""], ["proof (state)\nthis:\n  a \\<in> {0..<CARD('n)}\n  b \\<in> {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "hence \"(?fn a = ?fn b) = (a = b)\""], ["proof (prove)\nusing this:\n  a \\<in> {0..<CARD('n)}\n  b \\<in> {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. (Bij_Nat.from_nat a = Bij_Nat.from_nat b) = (a = b)", "using 2(1-2)"], ["proof (prove)\nusing this:\n  a \\<in> {0..<CARD('n)}\n  b \\<in> {0..<CARD('n)}\n  aa__ \\<in> {0..<CARD('n)}\n  b__ \\<in> {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. (Bij_Nat.from_nat a = Bij_Nat.from_nat b) = (a = b)", "by (auto simp: from_nat_inj)"], ["proof (state)\nthis:\n  (Bij_Nat.from_nat a = Bij_Nat.from_nat b) = (a = b)\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ab4 \\<in> {0..<CARD('n)}; ?ba4 \\<in> {0..<CARD('n)}\\<rbrakk>\n  \\<Longrightarrow> (Bij_Nat.from_nat ?ab4 = Bij_Nat.from_nat ?ba4) =\n                    (?ab4 = ?ba4)\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "note inj = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ab4 \\<in> {0..<CARD('n)}; ?ba4 \\<in> {0..<CARD('n)}\\<rbrakk>\n  \\<Longrightarrow> (Bij_Nat.from_nat ?ab4 = Bij_Nat.from_nat ?ba4) =\n                    (?ab4 = ?ba4)\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "from inj[OF 2(1-2)]"], ["proof (chain)\npicking this:\n  (Bij_Nat.from_nat a = Bij_Nat.from_nat b) = (a = b)", "have id2: \"sign ?sfab = sign ?sab\""], ["proof (prove)\nusing this:\n  (Bij_Nat.from_nat a = Bij_Nat.from_nat b) = (a = b)\n\ngoal (1 subgoal):\n 1. sign (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id) =\n    sign (Fun.swap a b id)", "unfolding sign_swap_id"], ["proof (prove)\nusing this:\n  (Bij_Nat.from_nat a = Bij_Nat.from_nat b) = (a = b)\n\ngoal (1 subgoal):\n 1. (if Bij_Nat.from_nat a = Bij_Nat.from_nat b then 1 else - 1) =\n    (if a = b then 1 else - 1)", "by simp"], ["proof (state)\nthis:\n  sign (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id) =\n  sign (Fun.swap a b id)\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "have id: \"?ft (Fun.swap a b id \\<circ> p) = Fun.swap (?fn a) (?fn b) id \\<circ> ?ft p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat i))) =\n    Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n    (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat i)) =\n       (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n        (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n        i", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat i)) =\n       (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n        (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n        i", "show \"?ft (Fun.swap a b id \\<circ> p) c = (Fun.swap (?fn a) (?fn b) id \\<circ> ?ft p) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n    (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n     (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     c", "proof (cases \"p (?tn c) = a \\<or> p (?tn c) = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p (Bij_Nat.to_nat c) = a \\<or>\n    p (Bij_Nat.to_nat c) = b \\<Longrightarrow>\n    Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n    (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n     (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     c\n 2. \\<not> (p (Bij_Nat.to_nat c) = a \\<or>\n            p (Bij_Nat.to_nat c) = b) \\<Longrightarrow>\n    Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n    (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n     (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     c", "case True"], ["proof (state)\nthis:\n  p (Bij_Nat.to_nat c) = a \\<or> p (Bij_Nat.to_nat c) = b\n\ngoal (2 subgoals):\n 1. p (Bij_Nat.to_nat c) = a \\<or>\n    p (Bij_Nat.to_nat c) = b \\<Longrightarrow>\n    Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n    (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n     (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     c\n 2. \\<not> (p (Bij_Nat.to_nat c) = a \\<or>\n            p (Bij_Nat.to_nat c) = b) \\<Longrightarrow>\n    Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n    (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n     (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     c", "thus ?thesis"], ["proof (prove)\nusing this:\n  p (Bij_Nat.to_nat c) = a \\<or> p (Bij_Nat.to_nat c) = b\n\ngoal (1 subgoal):\n 1. Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n    (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n     (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     c", "by (cases, auto simp add: o_def swap_def)"], ["proof (state)\nthis:\n  Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n  (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n   (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n   c\n\ngoal (1 subgoal):\n 1. \\<not> (p (Bij_Nat.to_nat c) = a \\<or>\n            p (Bij_Nat.to_nat c) = b) \\<Longrightarrow>\n    Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n    (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n     (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p (Bij_Nat.to_nat c) = a \\<or>\n            p (Bij_Nat.to_nat c) = b) \\<Longrightarrow>\n    Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n    (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n     (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     c", "case False"], ["proof (state)\nthis:\n  \\<not> (p (Bij_Nat.to_nat c) = a \\<or> p (Bij_Nat.to_nat c) = b)\n\ngoal (1 subgoal):\n 1. \\<not> (p (Bij_Nat.to_nat c) = a \\<or>\n            p (Bij_Nat.to_nat c) = b) \\<Longrightarrow>\n    Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n    (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n     (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     c", "hence neq: \"p (?tn c) \\<noteq> a\" \"p (?tn c) \\<noteq> b\""], ["proof (prove)\nusing this:\n  \\<not> (p (Bij_Nat.to_nat c) = a \\<or> p (Bij_Nat.to_nat c) = b)\n\ngoal (1 subgoal):\n 1. p (Bij_Nat.to_nat c) \\<noteq> a &&& p (Bij_Nat.to_nat c) \\<noteq> b", "by auto"], ["proof (state)\nthis:\n  p (Bij_Nat.to_nat c) \\<noteq> a\n  p (Bij_Nat.to_nat c) \\<noteq> b\n\ngoal (1 subgoal):\n 1. \\<not> (p (Bij_Nat.to_nat c) = a \\<or>\n            p (Bij_Nat.to_nat c) = b) \\<Longrightarrow>\n    Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n    (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n     (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     c", "have pc: \"p (?tn c) \\<in> ?zn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p (Bij_Nat.to_nat c) \\<in> {0..<CARD('n)}", "unfolding permutes_in_image[OF IH1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bij_Nat.to_nat c \\<in> {0..<CARD('n)}", "by (simp add: to_nat_less_card)"], ["proof (state)\nthis:\n  p (Bij_Nat.to_nat c) \\<in> {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. \\<not> (p (Bij_Nat.to_nat c) = a \\<or>\n            p (Bij_Nat.to_nat c) = b) \\<Longrightarrow>\n    Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n    (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n     (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     c", "from neq[folded inj[OF pc 2(1)] inj[OF pc 2(2)]]"], ["proof (chain)\npicking this:\n  Bij_Nat.from_nat (p (Bij_Nat.to_nat c)) \\<noteq> Bij_Nat.from_nat a\n  Bij_Nat.from_nat (p (Bij_Nat.to_nat c)) \\<noteq> Bij_Nat.from_nat b", "have \"?fn (p (?tn c)) \\<noteq> ?fn a\" \"?fn (p (?tn c)) \\<noteq> ?fn b\""], ["proof (prove)\nusing this:\n  Bij_Nat.from_nat (p (Bij_Nat.to_nat c)) \\<noteq> Bij_Nat.from_nat a\n  Bij_Nat.from_nat (p (Bij_Nat.to_nat c)) \\<noteq> Bij_Nat.from_nat b\n\ngoal (1 subgoal):\n 1. Bij_Nat.from_nat (p (Bij_Nat.to_nat c)) \\<noteq> Bij_Nat.from_nat a &&&\n    Bij_Nat.from_nat (p (Bij_Nat.to_nat c)) \\<noteq> Bij_Nat.from_nat b", "."], ["proof (state)\nthis:\n  Bij_Nat.from_nat (p (Bij_Nat.to_nat c)) \\<noteq> Bij_Nat.from_nat a\n  Bij_Nat.from_nat (p (Bij_Nat.to_nat c)) \\<noteq> Bij_Nat.from_nat b\n\ngoal (1 subgoal):\n 1. \\<not> (p (Bij_Nat.to_nat c) = a \\<or>\n            p (Bij_Nat.to_nat c) = b) \\<Longrightarrow>\n    Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n    (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n     (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     c", "with neq"], ["proof (chain)\npicking this:\n  p (Bij_Nat.to_nat c) \\<noteq> a\n  p (Bij_Nat.to_nat c) \\<noteq> b\n  Bij_Nat.from_nat (p (Bij_Nat.to_nat c)) \\<noteq> Bij_Nat.from_nat a\n  Bij_Nat.from_nat (p (Bij_Nat.to_nat c)) \\<noteq> Bij_Nat.from_nat b", "show ?thesis"], ["proof (prove)\nusing this:\n  p (Bij_Nat.to_nat c) \\<noteq> a\n  p (Bij_Nat.to_nat c) \\<noteq> b\n  Bij_Nat.from_nat (p (Bij_Nat.to_nat c)) \\<noteq> Bij_Nat.from_nat a\n  Bij_Nat.from_nat (p (Bij_Nat.to_nat c)) \\<noteq> Bij_Nat.from_nat b\n\ngoal (1 subgoal):\n 1. Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n    (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n     (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n     c", "by (auto simp: o_def swap_def)"], ["proof (state)\nthis:\n  Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n  (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n   (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n   c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat c)) =\n  (Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n   (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n   c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>i.\n      Bij_Nat.from_nat ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat i))) =\n  Fun.swap (Bij_Nat.from_nat a) (Bij_Nat.from_nat b) id \\<circ>\n  (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))\n\ngoal (1 subgoal):\n 1. \\<And>a b p.\n       \\<lbrakk>a \\<in> {0..<CARD('n)}; b \\<in> {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        sign p =\n        sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n        p permutes {0..<CARD('n)};\n        permutation p\\<rbrakk>\n       \\<Longrightarrow> sign (Fun.swap a b id \\<circ> p) =\n                         sign\n                          (\\<lambda>i.\n                              Bij_Nat.from_nat\n                               ((Fun.swap a b id \\<circ> p)\n                                 (Bij_Nat.to_nat i))) \\<and>\n                         Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (Fun.swap a b id \\<circ> p) =\n    sign\n     (\\<lambda>i.\n         Bij_Nat.from_nat\n          ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat i))) \\<and>\n    Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "unfolding IH2 id sign_compose[OF p_sab 2(5)] sign_compose[OF p_sfab p_ftp] id2"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (Fun.swap a b id) *\n    sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) =\n    sign (Fun.swap a b id) *\n    sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n    Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}", "by (rule conjI[OF refl perm1])"], ["proof (state)\nthis:\n  sign (Fun.swap a b id \\<circ> p) =\n  sign\n   (\\<lambda>i.\n       Bij_Nat.from_nat\n        ((Fun.swap a b id \\<circ> p) (Bij_Nat.to_nat i))) \\<and>\n  Fun.swap a b id \\<circ> p permutes {0..<CARD('n)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sign p = sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n  p permutes {0..<CARD('n)}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       signof x =\n       of_int (sign (\\<lambda>i. Bij_Nat.from_nat (x (Bij_Nat.to_nat i))))\n 2. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h Bij_Nat.from_nat (x (Bij_Nat.to_nat i)))", "thus \"signof p = of_int (sign ?q)\""], ["proof (prove)\nusing this:\n  sign p = sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) \\<and>\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. signof p =\n    of_int (sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))", "unfolding signof_def sign_def"], ["proof (prove)\nusing this:\n  (if evenperm p then 1 else - 1) =\n  (if evenperm (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))) then 1\n   else - 1) \\<and>\n  p permutes {0..<CARD('n)}\n\ngoal (1 subgoal):\n 1. (if (if evenperm p then 1 else - 1) = 1 then 1::'b else - (1::'b)) =\n    of_int\n     (if evenperm (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))\n      then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  signof p =\n  of_int (sign (\\<lambda>i. Bij_Nat.from_nat (p (Bij_Nat.to_nat i))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x permutes {0..<CARD('n)} \\<Longrightarrow>\n       (\\<Prod>i = 0..<CARD('n).\n           a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (x i)) =\n       (\\<Prod>i\\<in>UNIV.\n          a $h i $h Bij_Nat.from_nat (x (Bij_Nat.to_nat i)))", "show \"(\\<Prod>i = 0..<CARD('n). a $h ?fn i $h ?fn (p i)) =\n           (\\<Prod>i\\<in>UNIV. a $h i $h ?q i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i = 0..<CARD('n).\n        a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (p i)) =\n    (\\<Prod>i\\<in>UNIV. a $h i $h Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))", "unfolding \n           range_to_nat[symmetric] prod.reindex[OF inj_to_nat]"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod\n     ((\\<lambda>i.\n          a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (p i)) \\<circ>\n      Bij_Nat.to_nat)\n     UNIV =\n    (\\<Prod>i\\<in>UNIV. a $h i $h Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))", "by (rule prod.cong[OF refl], unfold o_def, simp)"], ["proof (state)\nthis:\n  (\\<Prod>i = 0..<CARD('n).\n      a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (p i)) =\n  (\\<Prod>i\\<in>UNIV. a $h i $h Bij_Nat.from_nat (p (Bij_Nat.to_nat i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<CARD('n)}.\n     signof p *\n     (\\<Prod>i = 0..<CARD('n).\n         a $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (p i))) =\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. a $h i $h p i))\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "}"], ["proof (state)\nthis:\n  (\\<Sum>p | p permutes {0..<CARD('n)}.\n     signof p *\n     (\\<Prod>i = 0..<CARD('n).\n         ?a2 $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (p i))) =\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. ?a2 $h i $h p i))\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>p | p permutes {0..<CARD('n)}.\n     signof p *\n     (\\<Prod>i = 0..<CARD('n).\n         ?a2 $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (p i))) =\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. ?a2 $h i $h p i))\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Determinant.det det", "unfolding HMA_M_def"], ["proof (prove)\nusing this:\n  (\\<Sum>p | p permutes {0..<CARD('n)}.\n     signof p *\n     (\\<Prod>i = 0..<CARD('n).\n         ?a2 $h Bij_Nat.from_nat i $h Bij_Nat.from_nat (p i))) =\n  (\\<Sum>p | p permutes UNIV.\n     of_int (sign p) * (\\<Prod>i\\<in>UNIV. ?a2 $h i $h p i))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>a b. a = from_hma\\<^sub>m b) ===> (=)) Determinant.det det", "by (auto simp: from_hma\\<^sub>m_def Determinant.det_def det_def)"], ["proof (state)\nthis:\n  (HMA_M ===> (=)) Determinant.det det\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_mat[transfer_rule]: \"((=) ===> HMA_M) (\\<lambda> k. k \\<cdot>\\<^sub>m 1\\<^sub>m CARD('n)) \n  (Finite_Cartesian_Product.mat :: 'a::semiring_1 \\<Rightarrow> 'a^'n^'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> HMA_M) (\\<lambda>k. k \\<cdot>\\<^sub>m 1\\<^sub>m CARD('n)) mat", "unfolding Finite_Cartesian_Product.mat_def[abs_def] rel_fun_def HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = y \\<longrightarrow>\n       x \\<cdot>\\<^sub>m 1\\<^sub>m CARD('n) =\n       from_hma\\<^sub>m (\\<chi>i j. if i = j then y else (0::'a))", "by (auto simp: from_hma\\<^sub>m_def from_nat_inj)"], ["", "lemma HMA_mat_minus[transfer_rule]: \"(HMA_M ===> HMA_M ===> HMA_M) \n  (\\<lambda> A B. A + map_mat uminus B) ((-) :: 'a :: group_add ^'nc^'nr \\<Rightarrow> 'a^'nc^'nr \\<Rightarrow> 'a^'nc^'nr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> HMA_M) (\\<lambda>A B. A + map_mat uminus B) (-)", "unfolding rel_fun_def HMA_M_def from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x =\n       Matrix.mat CARD('nr) CARD('nc)\n        (\\<lambda>(i, j).\n            y $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j) \\<longrightarrow>\n       (\\<forall>xa ya.\n           xa =\n           Matrix.mat CARD('nr) CARD('nc)\n            (\\<lambda>(i, j).\n                ya $h Bij_Nat.from_nat i $h\n                Bij_Nat.from_nat j) \\<longrightarrow>\n           x + map_mat uminus xa =\n           Matrix.mat CARD('nr) CARD('nc)\n            (\\<lambda>(i, j).\n                (y - ya) $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j))", "by auto"], ["", "definition mat2matofpoly where \"mat2matofpoly A = (\\<chi> i j. [: A $ i $ j :])\""], ["", "definition charpoly where charpoly_def: \"charpoly A = det (mat (monom 1 (Suc 0)) - mat2matofpoly A)\""], ["", "definition erase_mat :: \"'a :: zero ^ 'nc ^ 'nr \\<Rightarrow> 'nr \\<Rightarrow> 'nc \\<Rightarrow> 'a ^ 'nc ^ 'nr\" \n  where \"erase_mat A i j = (\\<chi> i'. \\<chi>  j'. if i' = i \\<or> j' = j then 0 else A $ i' $ j')\""], ["", "definition sum_UNIV_type :: \"('n :: finite \\<Rightarrow> 'a :: comm_monoid_add) \\<Rightarrow> 'n itself \\<Rightarrow> 'a\" where\n  \"sum_UNIV_type f _ = sum f UNIV\""], ["", "definition sum_UNIV_set :: \"(nat \\<Rightarrow> 'a :: comm_monoid_add) \\<Rightarrow> nat \\<Rightarrow> 'a\" where\n  \"sum_UNIV_set f n = sum f {..<n}\""], ["", "definition HMA_T :: \"nat \\<Rightarrow> 'n :: finite itself \\<Rightarrow> bool\" where\n  \"HMA_T n _ = (n = CARD('n))\""], ["", "lemma HMA_mat2matofpoly[transfer_rule]: \"(HMA_M ===> HMA_M) (\\<lambda>x. map_mat (\\<lambda>a. [:a:]) x) mat2matofpoly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M) (map_mat (\\<lambda>a. [:a:])) mat2matofpoly", "unfolding rel_fun_def HMA_M_def from_hma\\<^sub>m_def mat2matofpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x =\n       Matrix.mat CARD('c) CARD('b)\n        (\\<lambda>(i, j).\n            y $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j) \\<longrightarrow>\n       map_mat (\\<lambda>a. [:a:]) x =\n       Matrix.mat CARD('c) CARD('b)\n        (\\<lambda>(i, j).\n            (\\<chi>i j. [:y $h i $h j:]) $h Bij_Nat.from_nat i $h\n            Bij_Nat.from_nat j)", "by auto"], ["", "lemma HMA_char_poly [transfer_rule]: \n  \"((HMA_M :: ('a:: comm_ring_1 mat \\<Rightarrow> 'a^'n^'n \\<Rightarrow> bool)) ===> (=)) char_poly charpoly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) char_poly charpoly", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) char_poly charpoly", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) char_poly charpoly", "fix A :: \"'a mat\" and A' :: \"'a^'n^'n\""], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) char_poly charpoly", "assume [transfer_rule]: \"HMA_M A A'\""], ["proof (state)\nthis:\n  HMA_M A A'\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) char_poly charpoly", "hence [simp]: \"dim_row A = CARD('n)\""], ["proof (prove)\nusing this:\n  HMA_M A A'\n\ngoal (1 subgoal):\n 1. dim_row A = CARD('n)", "by (simp add: HMA_M_def)"], ["proof (state)\nthis:\n  dim_row A = CARD('n)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) char_poly charpoly", "have [simp]: \"monom 1 (Suc 0) = [:0, 1 :: 'a :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) (Suc 0) = [:0::'a, 1::'a:]", "by (simp add: monom_Suc)"], ["proof (state)\nthis:\n  monom (1::'a) (Suc 0) = [:0::'a, 1::'a:]\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) char_poly charpoly", "have [simp]: \"map_mat uminus (map_mat (\\<lambda>a. [:a:]) A) = map_mat (\\<lambda>a. [:-a:]) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mat uminus (map_mat (\\<lambda>a. [:a:]) A) =\n    map_mat (\\<lambda>a. [:- a:]) A", "by (rule eq_matI, auto)"], ["proof (state)\nthis:\n  map_mat uminus (map_mat (\\<lambda>a. [:a:]) A) =\n  map_mat (\\<lambda>a. [:- a:]) A\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) char_poly charpoly", "have \"char_poly A = charpoly A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. char_poly A = charpoly A'", "unfolding char_poly_def[abs_def] char_poly_matrix_def charpoly_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Determinant.det\n     ([:0::'a, 1::'a:] \\<cdot>\\<^sub>m 1\\<^sub>m (dim_row A) +\n      map_mat (\\<lambda>a. [:- a:]) A) =\n    det (mat (monom (1::'a) (Suc 0)) - mat2matofpoly A')", "by (transfer, simp)"], ["proof (state)\nthis:\n  char_poly A = charpoly A'\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) char_poly charpoly", "}"], ["proof (state)\nthis:\n  HMA_M ?A2 ?A'2 \\<Longrightarrow> char_poly ?A2 = charpoly ?A'2\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) char_poly charpoly", "thus ?thesis"], ["proof (prove)\nusing this:\n  HMA_M ?A2 ?A'2 \\<Longrightarrow> char_poly ?A2 = charpoly ?A'2\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) char_poly charpoly", "by blast"], ["proof (state)\nthis:\n  (HMA_M ===> (=)) char_poly charpoly\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_eigen_vector [transfer_rule]: \"(HMA_M ===> HMA_V ===> (=)) eigenvector eigen_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> (=)) eigenvector eigen_vector", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> (=)) eigenvector eigen_vector", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> (=)) eigenvector eigen_vector", "fix A :: \"'a mat\" and v :: \"'a Matrix.vec\" \n    and A' :: \"'a ^ 'n ^ 'n\" and v' :: \"'a ^ 'n\" and k :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> (=)) eigenvector eigen_vector", "assume 1[transfer_rule]: \"HMA_M A A'\" and 2[transfer_rule]: \"HMA_V v v'\""], ["proof (state)\nthis:\n  HMA_M A A'\n  HMA_V v v'\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> (=)) eigenvector eigen_vector", "hence [simp]: \"dim_row A = CARD('n)\" \"dim_vec v = CARD('n)\""], ["proof (prove)\nusing this:\n  HMA_M A A'\n  HMA_V v v'\n\ngoal (1 subgoal):\n 1. dim_row A = CARD('n) &&& dim_vec v = CARD('n)", "by (auto simp add: HMA_V_def HMA_M_def)"], ["proof (state)\nthis:\n  dim_row A = CARD('n)\n  dim_vec v = CARD('n)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> (=)) eigenvector eigen_vector", "have [simp]: \"v \\<in> carrier_vec CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec CARD('n)", "using 2"], ["proof (prove)\nusing this:\n  HMA_V v v'\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec CARD('n)", "unfolding HMA_V_def"], ["proof (prove)\nusing this:\n  v = from_hma\\<^sub>v v'\n\ngoal (1 subgoal):\n 1. v \\<in> carrier_vec CARD('n)", "by simp"], ["proof (state)\nthis:\n  v \\<in> carrier_vec CARD('n)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> (=)) eigenvector eigen_vector", "have \"eigenvector A v = eigen_vector A' v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvector A v = eigen_vector A' v'", "unfolding eigenvector_def[abs_def] eigen_vector_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        v \\<in> carrier_vec (dim_row A) \\<and>\n        v \\<noteq> 0\\<^sub>v (dim_row A) \\<and>\n        A *\\<^sub>v v = k \\<cdot>\\<^sub>v v) =\n    (\\<lambda>ev. v' \\<noteq> 0 \\<and> A' *v v' = ev *s v')", "by (transfer, simp)"], ["proof (state)\nthis:\n  eigenvector A v = eigen_vector A' v'\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> (=)) eigenvector eigen_vector", "}"], ["proof (state)\nthis:\n  \\<lbrakk>HMA_M ?A2 ?A'2; HMA_V ?v2 ?v'2\\<rbrakk>\n  \\<Longrightarrow> eigenvector ?A2 ?v2 = eigen_vector ?A'2 ?v'2\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> (=)) eigenvector eigen_vector", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>HMA_M ?A2 ?A'2; HMA_V ?v2 ?v'2\\<rbrakk>\n  \\<Longrightarrow> eigenvector ?A2 ?v2 = eigen_vector ?A'2 ?v'2\n\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_V ===> (=)) eigenvector eigen_vector", "by blast"], ["proof (state)\nthis:\n  (HMA_M ===> HMA_V ===> (=)) eigenvector eigen_vector\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_eigen_value [transfer_rule]: \"(HMA_M ===> (=) ===> (=)) eigenvalue eigen_value\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> (=)) eigenvalue eigen_value", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> (=)) eigenvalue eigen_value", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> (=)) eigenvalue eigen_value", "fix A :: \"'a mat\" and A' :: \"'a ^ 'n  ^ 'n\" and k"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> (=)) eigenvalue eigen_value", "assume 1[transfer_rule]: \"HMA_M A A'\""], ["proof (state)\nthis:\n  HMA_M A A'\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> (=)) eigenvalue eigen_value", "hence [simp]: \"dim_row A = CARD('n)\""], ["proof (prove)\nusing this:\n  HMA_M A A'\n\ngoal (1 subgoal):\n 1. dim_row A = CARD('n)", "by (simp add: HMA_M_def)"], ["proof (state)\nthis:\n  dim_row A = CARD('n)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> (=)) eigenvalue eigen_value", "note [transfer_rule] = dim_row_transfer_rule[OF 1(1)]"], ["proof (state)\nthis:\n  dim_row A = CARD('n)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> (=)) eigenvalue eigen_value", "have \"(eigenvalue A k) = (eigen_value A' k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigenvalue A k = eigen_value A' k", "unfolding eigenvalue_def[abs_def] eigen_value_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>v. eigenvector A v k) = (\\<exists>v. eigen_vector A' v k)", "by (transfer, auto simp add: eigenvector_def)"], ["proof (state)\nthis:\n  eigenvalue A k = eigen_value A' k\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> (=)) eigenvalue eigen_value", "}"], ["proof (state)\nthis:\n  HMA_M ?A2 ?A'2 \\<Longrightarrow> eigenvalue ?A2 ?k2 = eigen_value ?A'2 ?k2\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> (=)) eigenvalue eigen_value", "thus ?thesis"], ["proof (prove)\nusing this:\n  HMA_M ?A2 ?A'2 \\<Longrightarrow> eigenvalue ?A2 ?k2 = eigen_value ?A'2 ?k2\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> (=)) eigenvalue eigen_value", "by blast"], ["proof (state)\nthis:\n  (HMA_M ===> (=) ===> (=)) eigenvalue eigen_value\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_spectral_radius [transfer_rule]: \n  \"(HMA_M ===> (=)) Spectral_Radius.spectral_radius spectral_radius\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) Spectral_Radius.spectral_radius\n     HMA_Connect.spectral_radius", "unfolding Spectral_Radius.spectral_radius_def[abs_def] spectrum_def \n    spectral_radius_ev_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) (\\<lambda>A. Max (cmod ` Collect (eigenvalue A)))\n     (\\<lambda>A. Max (cmod ` Collect (eigen_value A)))", "by transfer_prover"], ["", "lemma HMA_elements_mat[transfer_rule]: \"((HMA_M :: ('a mat \\<Rightarrow> 'a ^ 'nc ^ 'nr \\<Rightarrow> bool))  ===> (=)) \n  elements_mat elements_mat_h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) elements_mat elements_mat_h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) elements_mat elements_mat_h", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) elements_mat elements_mat_h", "fix y :: \"'a ^ 'nc ^ 'nr\" and i j :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) elements_mat elements_mat_h", "assume i: \"i < CARD('nr)\" and j: \"j < CARD('nc)\""], ["proof (state)\nthis:\n  i < CARD('nr)\n  j < CARD('nc)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) elements_mat elements_mat_h", "hence \"from_hma\\<^sub>m y $$ (i, j) \\<in> range (\\<lambda>(i, ya). y $h i $h ya)\""], ["proof (prove)\nusing this:\n  i < CARD('nr)\n  j < CARD('nc)\n\ngoal (1 subgoal):\n 1. from_hma\\<^sub>m y $$ (i, j)\n    \\<in> range (\\<lambda>(i, ya). y $h i $h ya)", "using to_nat_from_nat_id[OF i] to_nat_from_nat_id[OF j]"], ["proof (prove)\nusing this:\n  i < CARD('nr)\n  j < CARD('nc)\n  Bij_Nat.to_nat (Bij_Nat.from_nat i) = i\n  Bij_Nat.to_nat (Bij_Nat.from_nat j) = j\n\ngoal (1 subgoal):\n 1. from_hma\\<^sub>m y $$ (i, j)\n    \\<in> range (\\<lambda>(i, ya). y $h i $h ya)", "by (auto simp: from_hma\\<^sub>m_def)"], ["proof (state)\nthis:\n  from_hma\\<^sub>m y $$ (i, j) \\<in> range (\\<lambda>(i, ya). y $h i $h ya)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) elements_mat elements_mat_h", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < CARD('nr); ?j2 < CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> from_hma\\<^sub>m ?y2 $$ (?i2, ?j2)\n                    \\<in> range (\\<lambda>(i, ya). ?y2 $h i $h ya)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) elements_mat elements_mat_h", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < CARD('nr); ?j2 < CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> from_hma\\<^sub>m ?y2 $$ (?i2, ?j2)\n                    \\<in> range (\\<lambda>(i, ya). ?y2 $h i $h ya)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) elements_mat elements_mat_h", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < CARD('nr); ?j2 < CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> from_hma\\<^sub>m ?y2 $$ (?i2, ?j2)\n                    \\<in> range (\\<lambda>(i, ya). ?y2 $h i $h ya)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) elements_mat elements_mat_h", "fix y :: \"'a ^ 'nc ^ 'nr\" and a b"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) elements_mat elements_mat_h", "have \"\\<exists>i j. y $h a $h b = from_hma\\<^sub>m y $$ (i, j) \\<and> i < CARD('nr) \\<and> j < CARD('nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i j.\n       y $h a $h b = from_hma\\<^sub>m y $$ (i, j) \\<and>\n       i < CARD('nr) \\<and> j < CARD('nc)", "unfolding from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i j.\n       y $h a $h b =\n       Matrix.mat CARD('nr) CARD('nc)\n        (\\<lambda>(i, j). y $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j) $$\n       (i, j) \\<and>\n       i < CARD('nr) \\<and> j < CARD('nc)", "by (rule exI[of _ \"Bij_Nat.to_nat a\"], rule exI[of _ \"Bij_Nat.to_nat b\"], auto\n        simp: to_nat_less_card)"], ["proof (state)\nthis:\n  \\<exists>i j.\n     y $h a $h b = from_hma\\<^sub>m y $$ (i, j) \\<and>\n     i < CARD('nr) \\<and> j < CARD('nc)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) elements_mat elements_mat_h", "}"], ["proof (state)\nthis:\n  \\<exists>i j.\n     ?y2 $h ?a2 $h ?b2 = from_hma\\<^sub>m ?y2 $$ (i, j) \\<and>\n     i < CARD('nr) \\<and> j < CARD('nc)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) elements_mat elements_mat_h", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i2 < CARD('nr); ?j2 < CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> from_hma\\<^sub>m ?y2 $$ (?i2, ?j2)\n                    \\<in> range (\\<lambda>(i, ya). ?y2 $h i $h ya)\n  \\<exists>i j.\n     ?y2 $h ?a2 $h ?b2 = from_hma\\<^sub>m ?y2 $$ (i, j) \\<and>\n     i < CARD('nr) \\<and> j < CARD('nc)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < CARD('nr); ?j2 < CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> from_hma\\<^sub>m ?y2 $$ (?i2, ?j2)\n                    \\<in> range (\\<lambda>(i, ya). ?y2 $h i $h ya)\n  \\<exists>i j.\n     ?y2 $h ?a2 $h ?b2 = from_hma\\<^sub>m ?y2 $$ (i, j) \\<and>\n     i < CARD('nr) \\<and> j < CARD('nc)\n\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) elements_mat elements_mat_h", "unfolding elements_mat[abs_def] elements_mat_h_def[abs_def] HMA_M_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i2 < CARD('nr); ?j2 < CARD('nc)\\<rbrakk>\n  \\<Longrightarrow> from_hma\\<^sub>m ?y2 $$ (?i2, ?j2)\n                    \\<in> range (\\<lambda>(i, ya). ?y2 $h i $h ya)\n  \\<exists>i j.\n     ?y2 $h ?a2 $h ?b2 = from_hma\\<^sub>m ?y2 $$ (i, j) \\<and>\n     i < CARD('nr) \\<and> j < CARD('nc)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>a b. a = from_hma\\<^sub>m b) ===> (=))\n     (\\<lambda>A. {A $$ (i, j) |i j. i < dim_row A \\<and> j < dim_col A})\n     (\\<lambda>A. range (\\<lambda>(i, y). A $h i $h y))", "by auto"], ["proof (state)\nthis:\n  (HMA_M ===> (=)) elements_mat elements_mat_h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_vec_elements[transfer_rule]: \"((HMA_V :: ('a Matrix.vec \\<Rightarrow> 'a ^ 'n \\<Rightarrow> bool))  ===> (=)) \n  vec_elements vec_elements_h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) vec_elements vec_elements_h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) vec_elements vec_elements_h", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) vec_elements vec_elements_h", "fix y :: \"'a ^ 'n\" and i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) vec_elements vec_elements_h", "assume i: \"i < CARD('n)\""], ["proof (state)\nthis:\n  i < CARD('n)\n\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) vec_elements vec_elements_h", "hence \"from_hma\\<^sub>v y $ i \\<in> range (vec_nth y)\""], ["proof (prove)\nusing this:\n  i < CARD('n)\n\ngoal (1 subgoal):\n 1. from_hma\\<^sub>v y $v i \\<in> range (($h) y)", "using to_nat_from_nat_id[OF i]"], ["proof (prove)\nusing this:\n  i < CARD('n)\n  Bij_Nat.to_nat (Bij_Nat.from_nat i) = i\n\ngoal (1 subgoal):\n 1. from_hma\\<^sub>v y $v i \\<in> range (($h) y)", "by (auto simp: from_hma\\<^sub>v_def)"], ["proof (state)\nthis:\n  from_hma\\<^sub>v y $v i \\<in> range (($h) y)\n\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) vec_elements vec_elements_h", "}"], ["proof (state)\nthis:\n  ?i2 < CARD('n) \\<Longrightarrow>\n  from_hma\\<^sub>v ?y2 $v ?i2 \\<in> range (($h) ?y2)\n\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) vec_elements vec_elements_h", "moreover"], ["proof (state)\nthis:\n  ?i2 < CARD('n) \\<Longrightarrow>\n  from_hma\\<^sub>v ?y2 $v ?i2 \\<in> range (($h) ?y2)\n\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) vec_elements vec_elements_h", "{"], ["proof (state)\nthis:\n  ?i2 < CARD('n) \\<Longrightarrow>\n  from_hma\\<^sub>v ?y2 $v ?i2 \\<in> range (($h) ?y2)\n\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) vec_elements vec_elements_h", "fix y :: \"'a ^ 'n\" and a"], ["proof (state)\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) vec_elements vec_elements_h", "have \"\\<exists>i. y $h a = from_hma\\<^sub>v y $ i \\<and> i < CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. y $h a = from_hma\\<^sub>v y $v i \\<and> i < CARD('n)", "unfolding from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       y $h a =\n       Matrix.vec CARD('n) (\\<lambda>i. y $h Bij_Nat.from_nat i) $v i \\<and>\n       i < CARD('n)", "by (rule exI[of _ \"Bij_Nat.to_nat a\"], auto simp: to_nat_less_card)"], ["proof (state)\nthis:\n  \\<exists>i. y $h a = from_hma\\<^sub>v y $v i \\<and> i < CARD('n)\n\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) vec_elements vec_elements_h", "}"], ["proof (state)\nthis:\n  \\<exists>i. ?y2 $h ?a2 = from_hma\\<^sub>v ?y2 $v i \\<and> i < CARD('n)\n\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) vec_elements vec_elements_h", "ultimately"], ["proof (chain)\npicking this:\n  ?i2 < CARD('n) \\<Longrightarrow>\n  from_hma\\<^sub>v ?y2 $v ?i2 \\<in> range (($h) ?y2)\n  \\<exists>i. ?y2 $h ?a2 = from_hma\\<^sub>v ?y2 $v i \\<and> i < CARD('n)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i2 < CARD('n) \\<Longrightarrow>\n  from_hma\\<^sub>v ?y2 $v ?i2 \\<in> range (($h) ?y2)\n  \\<exists>i. ?y2 $h ?a2 = from_hma\\<^sub>v ?y2 $v i \\<and> i < CARD('n)\n\ngoal (1 subgoal):\n 1. (HMA_V ===> (=)) vec_elements vec_elements_h", "unfolding vec_elements[abs_def] vec_elements_h_def[abs_def] rel_fun_def HMA_V_def"], ["proof (prove)\nusing this:\n  ?i2 < CARD('n) \\<Longrightarrow>\n  from_hma\\<^sub>v ?y2 $v ?i2 \\<in> range (($h) ?y2)\n  \\<exists>i. ?y2 $h ?a2 = from_hma\\<^sub>v ?y2 $v i \\<and> i < CARD('n)\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x = from_hma\\<^sub>v y \\<longrightarrow>\n       {x $v i |i. i < dim_vec x} = range (($h) y)", "by auto"], ["proof (state)\nthis:\n  (HMA_V ===> (=)) vec_elements vec_elements_h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm_bound_elements_mat: \"norm_bound A b = (\\<forall> x \\<in> elements_mat A. norm x \\<le> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_bound A b = (\\<forall>x\\<in>elements_mat A. norm x \\<le> b)", "unfolding norm_bound_def elements_mat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i j.\n        i < dim_row A \\<longrightarrow>\n        j < dim_col A \\<longrightarrow> norm (A $$ (i, j)) \\<le> b) =\n    (\\<forall>x\\<in>{A $$ (i, j) |i j. i < dim_row A \\<and> j < dim_col A}.\n        norm x \\<le> b)", "by auto"], ["", "lemma HMA_normbound [transfer_rule]: \n  \"((HMA_M :: 'a :: real_normed_field mat \\<Rightarrow> 'a ^ 'nc ^ 'nr \\<Rightarrow> bool) ===> (=) ===> (=))\n  norm_bound normbound\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> (=)) norm_bound normbound", "unfolding normbound_def[abs_def] norm_bound_elements_mat[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=) ===> (=))\n     (\\<lambda>A b. \\<forall>x\\<in>elements_mat A. norm x \\<le> b)\n     (\\<lambda>A b. \\<forall>x\\<in>elements_mat_h A. norm x \\<le> b)", "by (transfer_prover)"], ["", "lemma HMA_map_matrix [transfer_rule]: \n  \"((=) ===> HMA_M ===> HMA_M) map_mat map_matrix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> HMA_M ===> HMA_M) map_mat HMA_Connect.map_matrix", "unfolding map_vector_def map_matrix_def[abs_def] map_mat_def[abs_def] HMA_M_def from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     (\\<lambda>a b.\n         a =\n         Matrix.mat CARD('d) CARD('c)\n          (\\<lambda>(i, j).\n              b $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j)) ===>\n     (\\<lambda>a b.\n         a =\n         Matrix.mat CARD('d) CARD('c)\n          (\\<lambda>(i, j). b $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j)))\n     (\\<lambda>f A.\n         Matrix.mat (dim_row A) (dim_col A) (\\<lambda>ij. f (A $$ ij)))\n     (\\<lambda>f A. \\<chi>i ia. f (A $h i $h ia))", "by auto"], ["", "lemma HMA_transpose_matrix [transfer_rule]: \n  \"(HMA_M ===> HMA_M) transpose_mat transpose\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M) transpose_mat Finite_Cartesian_Product.transpose", "unfolding transpose_mat_def transpose_def HMA_M_def from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>a b.\n         a =\n         Matrix.mat CARD('c) CARD('b)\n          (\\<lambda>(i, j).\n              b $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j)) ===>\n     (\\<lambda>a b.\n         a =\n         Matrix.mat CARD('b) CARD('c)\n          (\\<lambda>(i, j). b $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j)))\n     (\\<lambda>A.\n         Matrix.mat (dim_col A) (dim_row A) (\\<lambda>(i, j). A $$ (j, i)))\n     (\\<lambda>A. \\<chi>i j. A $h j $h i)", "by auto"], ["", "lemma HMA_map_vector [transfer_rule]: \n  \"((=) ===> HMA_V ===> HMA_V) map_vec map_vector\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> HMA_V ===> HMA_V) map_vec map_vector", "unfolding map_vector_def[abs_def] map_vec_def[abs_def] HMA_V_def from_hma\\<^sub>v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     (\\<lambda>v w.\n         v = Matrix.vec CARD('c) (\\<lambda>i. w $h Bij_Nat.from_nat i)) ===>\n     (\\<lambda>v w.\n         v = Matrix.vec CARD('c) (\\<lambda>i. w $h Bij_Nat.from_nat i)))\n     (\\<lambda>f v. Matrix.vec (dim_vec v) (\\<lambda>i. f (v $v i)))\n     (\\<lambda>f v. \\<chi>i. f (v $h i))", "by auto"], ["", "lemma HMA_similar_mat_wit [transfer_rule]: \n  \"((HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'n ^ 'n \\<Rightarrow> _) ===> HMA_M ===> HMA_M ===> HMA_M ===> (=)) \n  similar_mat_wit similar_matrix_wit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> HMA_M ===> HMA_M ===> (=)) similar_mat_wit\n     similar_matrix_wit", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya; HMA_M xb yb; HMA_M xc yc\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit x xa xb xc =\n                         similar_matrix_wit y ya yb yc", "case (1 a A b B c C d D)"], ["proof (state)\nthis:\n  HMA_M a A\n  HMA_M b B\n  HMA_M c C\n  HMA_M d D\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya; HMA_M xb yb; HMA_M xc yc\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit x xa xb xc =\n                         similar_matrix_wit y ya yb yc", "note [transfer_rule] = this"], ["proof (state)\nthis:\n  HMA_M a A\n  HMA_M b B\n  HMA_M c C\n  HMA_M d D\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya; HMA_M xb yb; HMA_M xc yc\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit x xa xb xc =\n                         similar_matrix_wit y ya yb yc", "hence id: \"dim_row a = CARD('n)\""], ["proof (prove)\nusing this:\n  HMA_M a A\n  HMA_M b B\n  HMA_M c C\n  HMA_M d D\n\ngoal (1 subgoal):\n 1. dim_row a = CARD('n)", "by (auto simp: HMA_M_def)"], ["proof (state)\nthis:\n  dim_row a = CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya; HMA_M xb yb; HMA_M xc yc\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit x xa xb xc =\n                         similar_matrix_wit y ya yb yc", "have *: \"(c * d = 1\\<^sub>m (dim_row a) \\<and> d * c = 1\\<^sub>m (dim_row a) \\<and> a = c * b * d) =\n    (C ** D = mat 1 \\<and> D ** C = mat 1 \\<and> A = C ** B ** D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c * d = 1\\<^sub>m (dim_row a) \\<and>\n     d * c = 1\\<^sub>m (dim_row a) \\<and> a = c * b * d) =\n    (C ** D = mat (1::'a) \\<and>\n     D ** C = mat (1::'a) \\<and> A = C ** B ** D)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c * d = 1\\<^sub>m CARD('n) \\<and>\n     d * c = 1\\<^sub>m CARD('n) \\<and> a = c * b * d) =\n    (C ** D = mat (1::'a) \\<and>\n     D ** C = mat (1::'a) \\<and> A = C ** B ** D)", "by (transfer, simp)"], ["proof (state)\nthis:\n  (c * d = 1\\<^sub>m (dim_row a) \\<and>\n   d * c = 1\\<^sub>m (dim_row a) \\<and> a = c * b * d) =\n  (C ** D = mat (1::'a) \\<and> D ** C = mat (1::'a) \\<and> A = C ** B ** D)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya; HMA_M xb yb; HMA_M xc yc\\<rbrakk>\n       \\<Longrightarrow> similar_mat_wit x xa xb xc =\n                         similar_matrix_wit y ya yb yc", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat_wit a b c d = similar_matrix_wit A B C D", "unfolding similar_mat_wit_def Let_def similar_matrix_wit_def *"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a, b, c, d} \\<subseteq> carrier_mat (dim_row a) (dim_row a) \\<and>\n     C ** D = mat (1::'a) \\<and>\n     D ** C = mat (1::'a) \\<and> A = C ** B ** D) =\n    (C ** D = mat (1::'a) \\<and>\n     D ** C = mat (1::'a) \\<and> A = C ** B ** D)", "using 1"], ["proof (prove)\nusing this:\n  HMA_M a A\n  HMA_M b B\n  HMA_M c C\n  HMA_M d D\n\ngoal (1 subgoal):\n 1. ({a, b, c, d} \\<subseteq> carrier_mat (dim_row a) (dim_row a) \\<and>\n     C ** D = mat (1::'a) \\<and>\n     D ** C = mat (1::'a) \\<and> A = C ** B ** D) =\n    (C ** D = mat (1::'a) \\<and>\n     D ** C = mat (1::'a) \\<and> A = C ** B ** D)", "by (auto simp: HMA_M_def)"], ["proof (state)\nthis:\n  similar_mat_wit a b c d = similar_matrix_wit A B C D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_similar_mat [transfer_rule]: \n  \"((HMA_M :: _ \\<Rightarrow> 'a :: comm_ring_1 ^ 'n ^ 'n \\<Rightarrow> _) ===> HMA_M ===> (=)) \n  similar_mat similar_matrix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_M ===> (=)) similar_mat similar_matrix", "proof (intro rel_funI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> similar_mat x xa = similar_matrix y ya", "case (1 a A b B)"], ["proof (state)\nthis:\n  HMA_M a A\n  HMA_M b B\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> similar_mat x xa = similar_matrix y ya", "note [transfer_rule] = this"], ["proof (state)\nthis:\n  HMA_M a A\n  HMA_M b B\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> similar_mat x xa = similar_matrix y ya", "hence id: \"dim_row a = CARD('n)\""], ["proof (prove)\nusing this:\n  HMA_M a A\n  HMA_M b B\n\ngoal (1 subgoal):\n 1. dim_row a = CARD('n)", "by (auto simp: HMA_M_def)"], ["proof (state)\nthis:\n  dim_row a = CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> similar_mat x xa = similar_matrix y ya", "{"], ["proof (state)\nthis:\n  dim_row a = CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> similar_mat x xa = similar_matrix y ya", "fix c d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> similar_mat x xa = similar_matrix y ya", "assume \"similar_mat_wit a b c d\""], ["proof (state)\nthis:\n  similar_mat_wit a b c d\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> similar_mat x xa = similar_matrix y ya", "hence \"{c,d} \\<subseteq> carrier_mat CARD('n) CARD('n)\""], ["proof (prove)\nusing this:\n  similar_mat_wit a b c d\n\ngoal (1 subgoal):\n 1. {c, d} \\<subseteq> carrier_mat CARD('n) CARD('n)", "unfolding similar_mat_wit_def id Let_def"], ["proof (prove)\nusing this:\n  {a, b, c, d} \\<subseteq> carrier_mat CARD('n) CARD('n) \\<and>\n  c * d = 1\\<^sub>m CARD('n) \\<and>\n  d * c = 1\\<^sub>m CARD('n) \\<and> a = c * b * d\n\ngoal (1 subgoal):\n 1. {c, d} \\<subseteq> carrier_mat CARD('n) CARD('n)", "by auto"], ["proof (state)\nthis:\n  {c, d} \\<subseteq> carrier_mat CARD('n) CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> similar_mat x xa = similar_matrix y ya", "}"], ["proof (state)\nthis:\n  similar_mat_wit a b ?c2 ?d2 \\<Longrightarrow>\n  {?c2, ?d2} \\<subseteq> carrier_mat CARD('n) CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> similar_mat x xa = similar_matrix y ya", "note * = this"], ["proof (state)\nthis:\n  similar_mat_wit a b ?c2 ?d2 \\<Longrightarrow>\n  {?c2, ?d2} \\<subseteq> carrier_mat CARD('n) CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>HMA_M x y; HMA_M xa ya\\<rbrakk>\n       \\<Longrightarrow> similar_mat x xa = similar_matrix y ya", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_mat a b = similar_matrix A B", "unfolding similar_mat_def similar_matrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>P. Ex (similar_mat_wit a b P)) =\n    (\\<exists>P. Ex (similar_matrix_wit A B P))", "by (transfer, insert *, blast)"], ["proof (state)\nthis:\n  similar_mat a b = similar_matrix A B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma HMA_spectrum[transfer_rule]: \"(HMA_M ===> (=)) spectrum Spectrum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) spectrum Spectrum", "unfolding spectrum_def[abs_def] Spectrum_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> (=)) (\\<lambda>A. Collect (eigenvalue A))\n     (\\<lambda>A. Collect (eigen_value A))", "by transfer_prover"], ["", "lemma HMA_M_erase_mat[transfer_rule]: \"(HMA_M ===> HMA_I ===> HMA_I ===> HMA_M) mat_erase erase_mat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_I ===> HMA_I ===> HMA_M) mat_erase erase_mat", "unfolding mat_erase_def[abs_def] erase_mat_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HMA_M ===> HMA_I ===> HMA_I ===> HMA_M)\n     (\\<lambda>A i j.\n         Matrix.mat (dim_row A) (dim_col A)\n          (\\<lambda>(i', j').\n              if i' = i \\<or> j' = j then 0::'a else A $$ (i', j')))\n     (\\<lambda>A i j.\n         \\<chi>i' j'. if i' = i \\<or> j' = j then 0::'a else A $h i' $h j')", "by (auto simp: HMA_M_def HMA_I_def from_hma\\<^sub>m_def to_nat_from_nat_id intro!: eq_matI)"], ["", "lemma HMA_M_sum_UNIV[transfer_rule]: \n  \"((HMA_I ===> (=)) ===> HMA_T ===> (=)) sum_UNIV_set sum_UNIV_type\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((HMA_I ===> (=)) ===> HMA_T ===> (=)) sum_UNIV_set sum_UNIV_type", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (\\<forall>xa ya.\n           HMA_I xa ya \\<longrightarrow> x xa = y ya) \\<longrightarrow>\n       (\\<forall>xa ya.\n           HMA_T xa ya \\<longrightarrow>\n           sum_UNIV_set x xa = sum_UNIV_type y ya)", "proof (clarify, rename_tac f fT n nT)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "fix f and fT :: \"'b \\<Rightarrow> 'a\" and n and nT :: \"'b itself\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "assume f: \"\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y\"\n    and n: \"HMA_T n nT\""], ["proof (state)\nthis:\n  \\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y\n  HMA_T n nT\n\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "let ?f = \"from_nat :: nat \\<Rightarrow> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "let ?t = \"to_nat :: 'b \\<Rightarrow> nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "from n[unfolded HMA_T_def]"], ["proof (chain)\npicking this:\n  n = CARD('b)", "have n: \"n = CARD('b)\""], ["proof (prove)\nusing this:\n  n = CARD('b)\n\ngoal (1 subgoal):\n 1. n = CARD('b)", "."], ["proof (state)\nthis:\n  n = CARD('b)\n\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "from to_nat_from_nat_id[where 'a = 'b, folded n]"], ["proof (chain)\npicking this:\n  ?i < n \\<Longrightarrow> Bij_Nat.to_nat (Bij_Nat.from_nat ?i) = ?i", "have tf: \"i < n \\<Longrightarrow> ?t (?f i) = i\" for i"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> Bij_Nat.to_nat (Bij_Nat.from_nat ?i) = ?i\n\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> Bij_Nat.to_nat (Bij_Nat.from_nat i) = i", "by auto"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> Bij_Nat.to_nat (Bij_Nat.from_nat ?i) = ?i\n\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "have \"sum_UNIV_set f n = sum f (?t ` ?f ` {..<n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_UNIV_set f n = sum f (Bij_Nat.to_nat ` Bij_Nat.from_nat ` {..<n})", "unfolding sum_UNIV_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f {..<n} = sum f (Bij_Nat.to_nat ` Bij_Nat.from_nat ` {..<n})", "by (rule arg_cong[of _ _ \"sum f\"], insert tf, force)"], ["proof (state)\nthis:\n  sum_UNIV_set f n = sum f (Bij_Nat.to_nat ` Bij_Nat.from_nat ` {..<n})\n\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "also"], ["proof (state)\nthis:\n  sum_UNIV_set f n = sum f (Bij_Nat.to_nat ` Bij_Nat.from_nat ` {..<n})\n\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "have \"\\<dots> = sum (f \\<circ> ?t) (?f ` {..<n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (Bij_Nat.to_nat ` Bij_Nat.from_nat ` {..<n}) =\n    sum (f \\<circ> Bij_Nat.to_nat) (Bij_Nat.from_nat ` {..<n})", "by (rule sum.reindex, insert tf n, auto simp: inj_on_def)"], ["proof (state)\nthis:\n  sum f (Bij_Nat.to_nat ` Bij_Nat.from_nat ` {..<n}) =\n  sum (f \\<circ> Bij_Nat.to_nat) (Bij_Nat.from_nat ` {..<n})\n\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "also"], ["proof (state)\nthis:\n  sum f (Bij_Nat.to_nat ` Bij_Nat.from_nat ` {..<n}) =\n  sum (f \\<circ> Bij_Nat.to_nat) (Bij_Nat.from_nat ` {..<n})\n\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "have \"?f ` {..<n} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Bij_Nat.from_nat ` {..<n} = UNIV", "using range_to_nat[where 'a = 'b, folded n]"], ["proof (prove)\nusing this:\n  range Bij_Nat.to_nat = {0..<n}\n\ngoal (1 subgoal):\n 1. Bij_Nat.from_nat ` {..<n} = UNIV", "by force"], ["proof (state)\nthis:\n  Bij_Nat.from_nat ` {..<n} = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "also"], ["proof (state)\nthis:\n  Bij_Nat.from_nat ` {..<n} = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "have \"sum (f \\<circ> ?t) UNIV = sum fT UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (f \\<circ> Bij_Nat.to_nat) UNIV = sum fT UNIV", "proof (rule sum.cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow> (f \\<circ> Bij_Nat.to_nat) x = fT x", "fix i :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow> (f \\<circ> Bij_Nat.to_nat) x = fT x", "show \"(f \\<circ> ?t) i = fT i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> Bij_Nat.to_nat) i = fT i", "unfolding o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Bij_Nat.to_nat i) = fT i", "by (rule f[rule_format], auto simp: HMA_I_def)"], ["proof (state)\nthis:\n  (f \\<circ> Bij_Nat.to_nat) i = fT i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (f \\<circ> Bij_Nat.to_nat) UNIV = sum fT UNIV\n\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "also"], ["proof (state)\nthis:\n  sum (f \\<circ> Bij_Nat.to_nat) UNIV = sum fT UNIV\n\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "have \"\\<dots> = sum_UNIV_type fT nT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum fT UNIV = sum_UNIV_type fT nT", "unfolding sum_UNIV_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum fT UNIV = sum fT UNIV", ".."], ["proof (state)\nthis:\n  sum fT UNIV = sum_UNIV_type fT nT\n\ngoal (1 subgoal):\n 1. \\<And>f fT n nT.\n       \\<lbrakk>\\<forall>x y. HMA_I x y \\<longrightarrow> f x = fT y;\n        HMA_T n nT\\<rbrakk>\n       \\<Longrightarrow> sum_UNIV_set f n = sum_UNIV_type fT nT", "finally"], ["proof (chain)\npicking this:\n  sum_UNIV_set f n = sum_UNIV_type fT nT", "show \"sum_UNIV_set f n = sum_UNIV_type fT nT\""], ["proof (prove)\nusing this:\n  sum_UNIV_set f n = sum_UNIV_type fT nT\n\ngoal (1 subgoal):\n 1. sum_UNIV_set f n = sum_UNIV_type fT nT", "."], ["proof (state)\nthis:\n  sum_UNIV_set f n = sum_UNIV_type fT nT\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>Setup a method to easily convert theorems from JNF into HMA.\\<close>"], ["", "method transfer_hma uses rule = (\n  (fold index_hma_def)?, (* prepare matrix access for transfer *)\n  transfer,\n  rule rule, \n  (unfold carrier_vec_def carrier_mat_def)?, \n  auto)"], ["", "text \\<open>Now it becomes easy to transfer results which are not yet proven in HMA, such as:\\<close>"], ["", "lemma matrix_add_vect_distrib: \"(A + B) *v v = A *v v + B *v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A + B) *v v = A *v v + B *v v", "by (transfer_hma rule: add_mult_distrib_mat_vec)"], ["", "lemma matrix_vector_right_distrib: \"M *v (v + w) = M *v v + M *v w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M *v (v + w) = M *v v + M *v w", "by (transfer_hma rule: mult_add_distrib_mat_vec)"], ["", "lemma matrix_vector_right_distrib_diff: \"(M :: 'a :: ring_1 ^ 'nr ^ 'nc) *v (v - w) = M *v v - M *v w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M *v (v - w) = M *v v - M *v w", "by (transfer_hma rule: mult_minus_distrib_mat_vec)"], ["", "lemma eigen_value_root_charpoly: \n  \"eigen_value A k \\<longleftrightarrow> poly (charpoly (A :: 'a :: field ^ 'n ^ 'n)) k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_value A k = (poly (charpoly A) k = (0::'a))", "by (transfer_hma rule: eigenvalue_root_char_poly)"], ["", "lemma finite_spectrum: fixes A :: \"'a :: field ^ 'n ^ 'n\"\n  shows \"finite (Collect (eigen_value A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Collect (eigen_value A))", "by (transfer_hma rule: card_finite_spectrum(1)[unfolded spectrum_def])"], ["", "lemma non_empty_spectrum: fixes A :: \"complex ^ 'n ^ 'n\"\n  shows \"Collect (eigen_value A) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect (eigen_value A) \\<noteq> {}", "by (transfer_hma rule: spectrum_non_empty[unfolded spectrum_def])"], ["", "lemma charpoly_transpose: \"charpoly (transpose A :: 'a :: field ^ 'n ^ 'n) = charpoly A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. charpoly (Finite_Cartesian_Product.transpose A) = charpoly A", "by (transfer_hma rule: char_poly_transpose_mat)"], ["", "lemma eigen_value_transpose: \"eigen_value (transpose A :: 'a :: field ^ 'n ^ 'n) v = eigen_value A v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eigen_value (Finite_Cartesian_Product.transpose A) v = eigen_value A v", "unfolding eigen_value_root_charpoly charpoly_transpose"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly (charpoly A) v = (0::'a)) = (poly (charpoly A) v = (0::'a))", "by simp"], ["", "lemma matrix_diff_vect_distrib: \"(A - B) *v v = A *v v - B *v (v :: 'a :: ring_1 ^ 'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - B) *v v = A *v v - B *v v", "by (transfer_hma rule: minus_mult_distrib_mat_vec)"], ["", "lemma similar_matrix_charpoly: \"similar_matrix A B \\<Longrightarrow> charpoly A = charpoly B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. similar_matrix A B \\<Longrightarrow> charpoly A = charpoly B", "by (transfer_hma rule: char_poly_similar)"], ["", "lemma pderiv_char_poly_erase_mat: fixes A :: \"'a :: idom ^ 'n ^ 'n\" \n  shows \"monom 1 1 * pderiv (charpoly A) = sum (\\<lambda> i. charpoly (erase_mat A i i)) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * pderiv (charpoly A) =\n    (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * pderiv (charpoly A) =\n    (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i))", "let ?A = \"from_hma\\<^sub>m A\""], ["proof (state)\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * pderiv (charpoly A) =\n    (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i))", "let ?n = \"CARD('n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * pderiv (charpoly A) =\n    (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i))", "have tA[transfer_rule]: \"HMA_M ?A A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_M (from_hma\\<^sub>m A) A", "unfolding HMA_M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. from_hma\\<^sub>m A = from_hma\\<^sub>m A", "by simp"], ["proof (state)\nthis:\n  HMA_M (from_hma\\<^sub>m A) A\n\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * pderiv (charpoly A) =\n    (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i))", "have tN[transfer_rule]: \"HMA_T ?n TYPE('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HMA_T CARD('n) TYPE('n)", "unfolding HMA_T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CARD('n) = CARD('n)", "by simp"], ["proof (state)\nthis:\n  HMA_T CARD('n) TYPE('n)\n\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * pderiv (charpoly A) =\n    (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i))", "have A: \"?A \\<in> carrier_mat ?n ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_hma\\<^sub>m A \\<in> carrier_mat CARD('n) CARD('n)", "unfolding from_hma\\<^sub>m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix.mat CARD('n) CARD('n)\n     (\\<lambda>(i, j). A $h Bij_Nat.from_nat i $h Bij_Nat.from_nat j)\n    \\<in> carrier_mat CARD('n) CARD('n)", "by auto"], ["proof (state)\nthis:\n  from_hma\\<^sub>m A \\<in> carrier_mat CARD('n) CARD('n)\n\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * pderiv (charpoly A) =\n    (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i))", "have id: \"sum (\\<lambda> i. charpoly (erase_mat A i i)) UNIV = \n    sum_UNIV_type (\\<lambda> i. charpoly (erase_mat A i i)) TYPE('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i)) =\n    sum_UNIV_type (\\<lambda>i. charpoly (erase_mat A i i)) TYPE('n)", "unfolding sum_UNIV_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i)) =\n    (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i))", ".."], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i)) =\n  sum_UNIV_type (\\<lambda>i. charpoly (erase_mat A i i)) TYPE('n)\n\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * pderiv (charpoly A) =\n    (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * pderiv (charpoly A) =\n    (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. monom (1::'a) 1 * pderiv (charpoly A) =\n    sum_UNIV_type (\\<lambda>i. charpoly (erase_mat A i i)) TYPE('n)", "by (transfer, insert pderiv_char_poly_mat_erase[OF A], simp add: sum_UNIV_set_def)"], ["proof (state)\nthis:\n  monom (1::'a) 1 * pderiv (charpoly A) =\n  (\\<Sum>i\\<in>UNIV. charpoly (erase_mat A i i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_monic_charpoly: fixes A :: \"'a :: comm_ring_1 ^ 'n ^ 'n\" \n  shows \"degree (charpoly A) = CARD('n) \\<and> monic (charpoly A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (charpoly A) = CARD('n) \\<and> monic (charpoly A)", "proof (transfer, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> carrier_mat CARD('n) CARD('n) \\<Longrightarrow>\n       degree (char_poly A) = CARD('n) \\<and> monic (char_poly A)", "case 1"], ["proof (state)\nthis:\n  A_ \\<in> carrier_mat CARD('n) CARD('n)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> carrier_mat CARD('n) CARD('n) \\<Longrightarrow>\n       degree (char_poly A) = CARD('n) \\<and> monic (char_poly A)", "from degree_monic_char_poly[OF 1]"], ["proof (chain)\npicking this:\n  degree (char_poly A_) = CARD('n) \\<and>\n  coeff (char_poly A_) CARD('n) = (1::'a)", "show ?case"], ["proof (prove)\nusing this:\n  degree (char_poly A_) = CARD('n) \\<and>\n  coeff (char_poly A_) CARD('n) = (1::'a)\n\ngoal (1 subgoal):\n 1. degree (char_poly A_) = CARD('n) \\<and> monic (char_poly A_)", "by auto"], ["proof (state)\nthis:\n  degree (char_poly A_) = CARD('n) \\<and> monic (char_poly A_)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}